      WsbAffirmHr( GetCookieFromBaseHsm( m_pRootNode, &Cookie ) );

        }

        WsbAffirmPointer( Cookie );

        CSakDataNodePrivate* pNodePriv = (CSakDataNodePrivate*)Cookie;
        WsbAffirmHr( CSakDataNodePrivate::Verify( pNodePriv ) );

        WsbAffirmHr( pNodePriv->m_pNode.QueryInterface( ppBaseHsm ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetBaseHsmFromCookie", L"hr = <%ls>, *ppBaseHsm = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppBaseHsm ) );
    return ( hr );
}


HRESULT
CSakData::GetCookieFromBaseHsm (
    IN  ISakNode *    pNode,
    OUT MMC_COOKIE *        pCookie
    )
/*++

Routine Description:

    Retrieves the cookie for the object referenced by the 
    given IBaseHSM.

Arguments:

    pBaseHsm     - identifies the node to be worked on.

    pCookie      - returned Cookie.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::GetCookieFromBaseHsm", L"pNode = <0x%p>, pCookie = <0x%p>", pNode, pCookie );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pNode );

        //
        // Ask the node for our private data back
        //
        RS_PRIVATE_DATA data;

        WsbAffirmHr( pNode->GetPrivateData( &data ) );

        if( !data ) {

            CSakDataNodePrivate *pNodePriv = new CSakDataNodePrivate( pNode );
            WsbAffirmAlloc( pNodePriv );
            WsbAffirmHr( pNode->GetPrivateData( &data ) );

        }

        WsbAffirmHr( CSakDataNodePrivate::Verify( (CSakDataNodePrivate*)data ) );

        *pCookie = (MMC_COOKIE)data;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetCookieFromBaseHsm", L"hr = <%ls>, *pCookie = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)pCookie ) );
    return( hr );
}


HRESULT
CSakData::GetDataObjectFromCookie (
    IN  MMC_COOKIE          Cookie, 
    OUT IDataObject **ppDataObject
    )

/*++

Routine Description:

    Retrieves the IDataObject for the object referenced by the 
    given cookie.

Arguments:

    Cookie       - identifies the node to be worked on.

    ppDataObject - returned IDataObject interface.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetDataObjectFromCookie", L"Cookie = <0x%p>, ppDataObject = <0x%p>", Cookie, ppDataObject );

    HRESULT hr = S_OK;

    try {

        //
        // Check Params
        //
        WsbAffirmPointer( ppDataObject );

        //
        // Use GetBaseHsmFromCookie to resolve to node object
        //
        CComPtr<ISakNode> pNode;
        WsbAffirmHr( GetBaseHsmFromCookie( Cookie, &pNode ) );
        WsbAffirmPointer( pNode );

        WsbAffirmHr( RsQueryInterface2( pNode, IDataObject, ppDataObject ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetDataObjectFromCookie", L"hr = <%ls>, *ppDataObject = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppDataObject ) );
    return( hr );
}


HRESULT
CSakData::SetContextType(
    IDataObject*      pDataObject,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Set the MMC context type in the data object for later retrieval by any method
    which receives this dataobject (CCT_SNAPIN_MANAGER, CCT_SCOPE, CCT_RESULT, etc).

Arguments:

    pDataObject  - identifies the node to be worked on.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::SetContextType", L"pDataObject = <0x%p>, type = <%d>", pDataObject, type );

    // Prepare structures to store an HGLOBAL from the dataobject.
    // Allocate memory for the stream which will contain the SakSnap GUID.
    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)CSakNode::m_cfInternal, NULL, 
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    HRESULT hr = S_OK;

    try {

        // Allocate space in which to place the data
        stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(INTERNAL));
        WsbAffirm( stgmedium.hGlobal != NULL, E_POINTER );

        // Put the data into the global memory. This is what will eventually be 
        // copied down into the member variables of the dataobject, itself.
        memcpy(&stgmedium.hGlobal, &type, sizeof(type));

        // Copy this data into the dataobject.
        WsbAffirmHr( pDataObject->SetData(&formatetc, &stgmedium, FALSE ));

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::SetContextType", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::InitializeRootNode(
    void
    )
/*++

Routine Description:

    The initialization of the root node is separate in order to
    allow reconnect multiple times (as needed). This is the
    implementation of initialization.

Arguments:

    pDataObject  - identifies the node to be worked on.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::InitializeRootNode", L"" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;

    try {

        // Make sure the computer name is set in CSakdata if we are managing the local
        // Hsm

        if( m_ManageLocal ) {

            WCHAR computerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
            DWORD dw = MAX_COMPUTERNAME_LENGTH + 1;

            WsbAffirmStatus(GetComputerName( computerName, &dw ));

            m_HsmName = computerName;

        }
        //
        // Initialize the static root node (no recursion. Descendants are NOT created here)
        //

        WsbAffirmPointer( m_pRootNode );

        WsbAffirmHr( m_pRootNode->InitNode( (ISakSnapAsk*)this, NULL, NULL ) );

        //
        // Set the Display Name in the object
        //
        CString fullTitle;

        if( IsPrimaryImpl( ) ) {

            //
            // We're standalone, so show the targeted server
            //
            if( m_ManageLocal ) {

                fullTitle.LoadString( IDS_MANAGE_LOCAL );
        
            } else if( !m_HsmName.IsEmpty( ) ) {

                AfxFormatString1( fullTitle, IDS_HSM_NAME_PREFIX, m_HsmName );
    
            } else {

                fullTitle = HSMADMIN_NO_HSM_NAME;

            }

        } else {

            //
            // We're an extension, so just show app name
            //
            fullTitle.LoadString( AFX_IDS_APP_TITLE );

        }


        // Put the displayname
        CComPtr <ISakNodeProp> pRootNodeProp;
        WsbAffirmHr( RsQueryInterface( m_pRootNode, ISakNodeProp, pRootNodeProp ) );
        WsbAffirmHr( pRootNodeProp->put_DisplayName( (LPWSTR)(LPCWSTR) fullTitle ) );

        WsbAffirmHr( m_pRootNode->RefreshObject() );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::InitializeRootNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::AffirmServiceConnection(
    INT ConnType
    )
/*++

Routine Description:
    Validates that the connection to the requested HSM service is still valid.  If not,
    attempts to reconnect to the service.

Arguments:

    ConnType - type of service connection being checked

Return Value:

    S_OK         - Node created and bound to server.

    S_FALSE      - Service has not yet been setup or stopped.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::AffirmServiceConnection", L"" );
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    BOOL          previouslyConnected = ( GetState() == S_OK );
    BOOL          firstTime           = m_FirstTime;
    CString       szMessage;
    CWsbStringPtr computerName;


    try {


        //
        // Handle this first so reentrancy is not a problem
        //
        if( m_FirstTime ) {

            m_FirstTime = FALSE;

        }

        WsbAffirmHr( WsbGetComputerName( computerName ) );

        //
        // See if snapin is supposed to be disabled. If so, then 
        // don't do anything.
        //
        if( m_Disabled ) {

            WsbThrow( RS_E_DISABLED );

        }

        //
        // We want to avoid starting the services if they are stopped.
        // So, check the service state before continuing.
        //
        HRESULT hrCheck;
        {
            //
            // Potentially a long operation - show wait cursor if possible
            //
            CWaitCursor waitCursor;
            hrCheck = WsbCheckService( m_HsmName, APPID_RemoteStorageEngine );
        }
        if( S_FALSE == hrCheck ) {

            //
            // Engine service is not running
            //
            WsbThrow( S_FALSE );

        } else if( ( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == hrCheck ) ||
                   ( E_ACCESSDENIED == hrCheck ) ) {

            //
            // Engine is not installed (or at least we can't check
            // because local privs don't allow, but may on a different
            // server)
            //
            // If we are set to "Manage Local" then we will provide the
            // opportunity to look at a different machine
            //
            if( firstTime && m_ManageLocal ) {

                //
                // If we get back "File not found" then the engine was
                // not installed, so we need to ask for a different machine
                // to administer
                //
                hrCheck = RetargetSnapin( );
                WsbAffirmHrOk( hrCheck );


            } else {

                //
                // we want to return the true error if access is denied
                // and can't retarget to another machine without same error
                //
                if( E_ACCESSDENIED == hrCheck ) {

                    WsbThrow( hrCheck );

                } else {

                    WsbThrow( RS_E_NOT_INSTALLED );

                }

            }
        }

        //
        // Is the current connection still valid?
        // Test the connection. If it's OK, return it.  If not,
        // re-establish the connection.
        //
        HRESULT hrConnected = VerifyConnection( ConnType );
        WsbAffirmHr( hrConnected );
        
        //
        // If it looks like we're not connected, then connect
        //
        if( S_FALSE == hrConnected ) {
    
            //
            // Connect to engine first and see if we are setup.
            // Don't process any further if not setup.
            //
            WsbAffirmHr( RawConnect( HSMCONN_TYPE_HSM ) );
            HRESULT hrSetup = RsIsRemoteStorageSetupEx( m_pHsmServer );
            WsbAffirmHr( hrSetup );

            if( S_FALSE == hrSetup ) {

                //
                // Not setup - see if we are local
                //
                if( computerName.IsEqual( m_HsmName ) && firstTime ) {

                    hrSetup = RunSetupWizard( m_pHsmServer );

                }

                //
                // By this point, if hrSetup is not S_OK,
                // we are not configured.
                //
                if( S_OK != hrSetup ) {

                    WsbThrow( RS_E_NOT_CONFIGURED );

                }

            }

            //
            // At this point we should be setup and ready to connect
            //
            WsbAffirmHrOk( RawConnect( ConnType ) );

        }

        //
        // We're connected
        //
        SetState( TRUE );

    } WsbCatchAndDo( hr,

        //
        // Need to decide if we should ignore the error or not.
        // Note that even if the error is ignored here, its 
        // returned still to the caller
        //
        BOOL ignoreError = FALSE;

        //
        // if RMS error of not ready, and we received this last time RMS 
        // connection was made, ignore the error.
        //
        if( HSMCONN_TYPE_RMS == ConnType ) {
        
            HRESULT hrPrevConnect = m_HrRmsConnect;
            m_HrRmsConnect = hr;

            if( ( RsIsRmsErrorNotReady( hr ) == S_OK ) &&
                ( RsIsRmsErrorNotReady( hrPrevConnect ) == S_OK ) ) {

                ignoreError = TRUE;

            }

        }

        if( !ignoreError ) {

            //
            // Set up state conditions before anything else
            //
            ClearConnections( );
            SetState( FALSE );

            //
            // If we were previously connected or this is the first connect,
            // report the error
            //
            if( previouslyConnected || firstTime ) {

                //
                // Temporarily set to disable so we don't recurse when dialog is up
                //
                BOOL disabled = m_Disabled;
                m_Disabled = TRUE;

                CString msg;
                switch( hr ) {

                case S_OK:
                    //
                    // Connected OK - no error
                    //
                    break;
            
                case RS_E_DISABLED:
                    //
                    // Disabled - just ignore
                    //
                    break;
            
                case S_FALSE:
                    //
                    // Service not running
                    //
                    AfxFormatString1( msg, IDS_ERR_SERVICE_NOT_RUNNING, m_HsmName );
                    AfxMessageBox( msg, RS_MB_ERROR );
                    break;

                case RS_E_NOT_CONFIGURED:
                    //
                    // If remote, let user know it needs to be set up locally
                    //
                    if( ! computerName.IsEqual( m_HsmName ) ) {

                        AfxFormatString1( msg, IDS_ERR_SERVICE_NOT_SETUP_REMOTE, m_HsmName );
                        AfxMessageBox( msg, RS_MB_ERROR );

                    }
                    break;

               case RS_E_NOT_INSTALLED:
                    //
                    // Give indication of where this can be setup
                    //
                    AfxFormatString1( msg, IDS_ERR_SERVICE_NOT_INSTALLED, m_HsmName );
                    AfxMessageBox( msg, RS_MB_ERROR );
                    break;

               case RS_E_CANCELLED:
                    //
                    // User cancelled - there's no error to notify
                    //
                    break;

                default:
                    //
                    // Report the error
                    //
                    AfxFormatString1( msg, IDS_ERR_SERVICE_NOT_CONNECTING, m_HsmName );
                    AfxMessageBox( msg, RS_MB_ERROR );
                    if( HSMCONN_TYPE_RMS == ConnType ) {

                        disabled = TRUE;

                    }

                }

                //
                // Restore disabledness
                //
                m_Disabled = disabled;
            }

        }
    );

    //
    // Need to track RMS connections separately
    //
    if( HSMCONN_TYPE_RMS == ConnType ) {

        m_HrRmsConnect = hr;

    }

    //
    // If our state of "Connection" changed, cause a refresh
    //
    BOOL connected = ( GetState() == S_OK );
    if( ( connected != previouslyConnected ) && ( ! firstTime ) ) {

        RefreshNode( m_pRootNode );

    }

    WsbTraceOut( L"CSakData::AffirmServiceConnection", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::VerifyConnection(
    INT ConnType
    )
/*++

Routine Description:

    Verify whether the indicated connection is still good or not.
    Does not attempt to reconnect.

Arguments:

    ConnType - type of service connection being checked

Return Value:

    S_OK         - Connected.

    S_FALSE      - Not connected. 

    E_*          - Error occurred while checking

--*/
{
    WsbTraceIn( L"CSakData::VerifyConnection", L"" );
    HRESULT hr = S_FALSE;

    try {

        switch( ConnType ) {
    
        case HSMCONN_TYPE_HSM:
            if( m_pHsmServer ) {
    
                GUID id;
                WsbAffirmHr( m_pHsmServer->GetID( &id ) );
                hr = S_OK;
    
            }
            break;
    
        case HSMCONN_TYPE_RMS:
            if( m_pRmsServer ) {
    
                WsbAffirmHr( m_pRmsServer->IsReady( ) );
                hr = S_OK;
    
            }
            break;
    
        case HSMCONN_TYPE_FSA:
            if( m_pFsaServer ) {
    
                CWsbStringPtr pszName;
                WsbAffirmHr( m_pFsaServer->GetName( &pszName, 0 ) );
                hr = S_OK;
    
            }
            break;
        }

    } WsbCatchAndDo( hr,
        
        ClearConnections( );
        
    );
    
    WsbTraceOut( L"CSakData::VerifyConnection", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::RawConnect(
    INT ConnType
    )
/*++

Routine Description:

    Do low level connection to service specified

Arguments:

    ConnType - type of service connection

Return Value:

    S_OK         - Connected.

    E_*          - Error occurred while checking

--*/
{
    WsbTraceIn( L"CSakData::RawConnect", L"" );
    HRESULT hr = S_OK;

    try {

        
        //
        // Potentially a long operation - show wait cursor if possible
        //
        CWaitCursor waitCursor;

        switch( ConnType ) {
       
        case HSMCONN_TYPE_HSM:
            if( ! m_pHsmServer ) {

                WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, m_HsmName, IID_IHsmServer, (void**)&m_pHsmServer ) );

            }
            break;
       
        case HSMCONN_TYPE_RMS:
            if( ! m_pRmsServer ) {

                CComPtr<IHsmServer> pHsm;
                WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, m_HsmName, IID_IHsmServer, (void**)&pHsm ) );
                WsbAffirmPointer(pHsm);
                WsbAffirmHr(pHsm->GetHsmMediaMgr(&m_pRmsServer));
                WsbAffirmHrOk( VerifyConnection( HSMCONN_TYPE_RMS ) );

            }
            break;
       
        case HSMCONN_TYPE_FSA:
            if( ! m_pFsaServer ) {

                CWsbStringPtr LogicalName( m_HsmName );
       
                //
                //  FSA confuses things by having a
                // extra level for the "type"
                //
                LogicalName.Append( "\\NTFS" );
                WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_FSA, LogicalName, IID_IFsaServer, (void**)&m_pFsaServer ) );

            }
            break;
        }

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::RawConnect", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::ClearConnections(
    )
/*++

Routine Description:

    Clear cached connections

Arguments:

    none.

Return Value:

    S_OK         - Cleared.

    E_*          - Error occurred while checking

--*/
{
    WsbTraceIn( L"CSakData::ClearConnections", L"" );
    HRESULT hr = S_OK;

    try {

        m_pHsmServer = 0;
        m_pRmsServer = 0;
        m_pFsaServer = 0;

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::ClearConnections", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::RunSetupWizard(
    IHsmServer * pServer
    )
/*++

Routine Description:

    Run the setup wizard

    Handles disabling / enabling as needed

Arguments:

    pServer - interface to engine

Return Value:

    S_OK         - Setup Correctly.

    S_FALSE      - Canceled

    E_*          - Error occurred while setting up

--*/
{
    WsbTraceIn( L"CSakData::RunSetupWizard", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // use wizard to create manage volume
        //
        CComObject<CQuickStartWizard>* pWizard = new CComObject<CQuickStartWizard>;
        WsbAffirmAlloc( pWizard );

        CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
        WsbAffirmHr( CreateWizard( pSakWizard ) );

        //
        // RS_E_CANCELED indicates canceled, and FAILEd indicates error.
        // If so, then throw "Not set up"
        //
        if( S_OK != pWizard->m_HrFinish ) {

            WsbThrow( S_FALSE );

        }

        WsbAffirmHrOk( RsIsRemoteStorageSetupEx( pServer ) );

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::RunSetupWizard", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::RetargetSnapin(
    )
/*++

Routine Description:

    Run the small choose server dialog

Arguments:

    none.

Return Value:

    S_OK         - Setup Correctly.

    S_FALSE      - Canceled

    E_*          - Error occurred while changing

--*/
{
    WsbTraceIn( L"CSakData::RetargetSnapin", L"" );
    HRESULT hr = S_OK;

    try {

        if( IsPrimaryImpl( ) ) {

            //
            // Bring up dialog
            //
            CChooseHsmQuickDlg dlg;
            dlg.m_pHsmName = &m_HsmName;
            if( IDOK == dlg.DoModal( ) ) {

                m_PersistManageLocal = FALSE;
                m_ManageLocal        = FALSE;

                //
                // We want the name shown to be accurate, regardless
                // of whether they targetted to a valid machine.
                // So, re-initialize the root node before going 
                // any further.
                //
                WsbAffirmHr( InitializeRootNode( ) );

                //
                // Make sure we hook up OK. If not, just disable
                // Note that since we set "First" flag at beginning
                // of the block, this will not endlessly recurse
                //
                hr = AffirmServiceConnection( HSMCONN_TYPE_HSM );
                if( FAILED( hr ) ) {

                    Disable( );
                    WsbThrow( hr );

                }
            
            } else {

                //
                // They canceled out, so just disable
                //
                Disable( );
                WsbThrow( RS_E_CANCELLED );

            }

        } else {

            //
            // As extension we don't allow retargeting, so we just disable
            //
            Disable( );
            WsbThrow( S_FALSE );

        }


    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::RetargetSnapin", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::CreateChildNodes(
    ISakNode* pParentNode
    ) 
/*++

Routine Description:

    Create and initialize the children of an existing COM parent. Currently, this 
    initialization is being done from HSM object.

Arguments:

    pNode        - The node to create the children of.

Return Value:

    S_OK         - Children created.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::CreateChildNodes", L"pParentNode = <0x%p>", pParentNode );
    HRESULT hr = S_OK;

    try {

        //
        // Initialize the child nodes - first delete existing children from UI,
        // then initialize new children into UI. No recursion. Decendents are 
        // NOT created here.
        //

        CComPtr<ISakNode> pNode;
        WsbAffirmHr( RsQueryInterface( pParentNode, ISakNode, pNode ) );
        WsbAffirmHr( pNode->DeleteAllChildren( ) );
        WsbAffirmHr( pNode->CreateChildren( ) );

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::CreateChildNodes", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::FreeEnumChildren(
    ISakNode* pParentNode
    )
/*++

Routine Description:

    Recursively (bottom-up) free the SCOPEDATAITEM children of the pParent 
    enumerated node  

Arguments:

    pParentNode  - identifies the node to be worked on.

Return Value:

    S_OK         - Children freed successfully.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::FreeEnumChildren", L"pParentNode = <0x%p>", pParentNode );
    HRESULT hr = S_OK;
    
    try {

        HSCOPEITEM scopeIDParent;
        pParentNode->GetScopeID( &scopeIDParent );

        WsbAffirm( scopeIDParent > 0, E_FAIL )
    
        WsbAffirmHr( m_pNameSpace->DeleteItem( scopeIDParent, FALSE ) );
        pParentNode->SetEnumState( FALSE );

    } WsbCatch (hr);

    WsbTraceOut( L"CSakData::FreeEnumChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// IPersistStream implementation
//

STDMETHODIMP
CSakData::Save( 
    IStream *pStm, 
    BOOL fClearDirty 
    ) 

/*++

Routine Description:

    Save the information we need to reconstruct the root node in the
    supplied stream.

Arguments:

    pStm        I: Console-supplied stream
    fClearDirty I: The console tells us to clear our dirty flag
    
Return Value:

    S_OK         - Saved successfully.
    E_*          - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::Save", L"pStm = <0x%p>, fClearDirty", pStm, WsbBoolAsString( fClearDirty ) );

    HRESULT hr = S_OK;

    try {

        ULONG version = HSMADMIN_CURRENT_VERSION;
        WsbAffirmHr( WsbSaveToStream( pStm, version ) );

        if( m_PersistManageLocal ) {

            WsbAffirmHr( WsbSaveToStream( pStm, m_ManageLocal ) );
            CWsbStringPtr pHsmName( m_HsmName );
            WsbAffirmHr( WsbSaveToStream( pStm, pHsmName ) );

        } else {

            WsbAffirmHr( WsbSaveToStream( pStm, (BOOL)TRUE ) );
            CWsbStringPtr pHsmName( "" );
            WsbAffirmHr( WsbSaveToStream( pStm, pHsmName ) );

        }

        // Set the dirty flag
        if( fClearDirty ) ClearDirty( );

    } WsbCatch( hr );


    WsbTraceOut( L"CSakData::Save", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakData::Load( 
    IStream *pStm
    )
/*++

Routine Description:

    Load the information we need to reconstruct the root node from the
    supplied stream.

Arguments:

    pStm        IConsole-supplied stream
    
Return Value:

    S_OK         - Saved successfully.
    E_*          - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::Load", L"pStm = <0x%p>", pStm );

    HRESULT hr = S_OK;
    try {

        ULONG version = 0;
        WsbAffirmHr( WsbLoadFromStream( pStm, &version ) );
        WsbAssert( ( version == 1 ), E_FAIL );

        // Get the flag for local or named HSM
        WsbLoadFromStream( pStm, &m_ManageLocal );
        CWsbStringPtr pHsmName;

        // Get the HSM name ("" for local HSM)
        WsbLoadFromStream( pStm, &pHsmName, 0 );
        m_HsmName = pHsmName;

        // Grab any options from the command line after loading
        InitFromCommandLine( );

        // Set the Hsm name in SakData and HsmCom objects
        WsbAffirmHr( InitializeRootNode() );

        ClearDirty();

    } WsbCatch (hr);

    WsbTraceOut( L"CSakData::Load", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}   

STDMETHODIMP
CSakData::IsDirty(
    void
    )

/*++

Routine Description:

    The console asks us if we are dirty.

Arguments:

    None
    
Return Value:

    S_OK         - Dirty.
    S_FALSE      - Not Dirty. 

--*/
{
    WsbTraceIn( L"CSakData::IsDirty", L"" );

    HRESULT hr = ThisIsDirty() ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakData::IsDirty", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::GetSizeMax( 
    ULARGE_INTEGER * /*pcbSize*/
    )

/*++

Routine Description:

    Not currently used by the console

Arguments:

    pcbSize
    
Return Value:

    E_NOTIMPL
--*/

{
    WsbTraceIn( L"CSakData::GetSizeMax", L"" );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CSakData::GetSizeMax", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakData::GetClassID( 
    CLSID *pClassID 
    )
/*++

Routine Description:

    Not currently used by the console

Arguments:

    pClassID  - The class ID for the snapin
    
Return Value:

    S_OK
--*/
{
    WsbTraceIn( L"CSakData::GetClassID", L"pClassID = <0x%p>", pClassID );

    HRESULT hr = S_OK;
    *pClassID = CLSID_HsmAdmin;

    WsbTraceOut( L"CSakData::GetClassID", L"hr = <%ls>, *pClassID = <%ls>", WsbHrAsString( hr ), WsbPtrToGuidAsString( pClassID ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
//
// Adds images to the consoles image list from the static array
//
HRESULT CSakData::OnAddImages()
{
    HRESULT hr = S_OK;
    HICON hIcon;
    try {

        //
        // Put the images from the static array into the image list
        // for the scope pane
        //

        for( INT i = 0; i < m_nImageCount; i++ ) {
            // Load the icon using the resource Id stored in the
            // static array and get the handle.  

            hIcon = LoadIcon( _Module.m_hInst, 
                MAKEINTRESOURCE( m_nImageArray [i] ) );

            // Add to the Console's Image list
            WsbAffirmHr( m_pImageScope->ImageListSetIcon( (RS_WIN32_HANDLE*)hIcon, i ) );
        }
    } WsbCatch (hr);
    return hr;
}
    

//////////////////////////////////////////////////////////////////////////////////
//
// Description: Add the supplied resource ID to the list of resource IDs for
//      the scope pane.  Returns the index into the array.
//
INT CSakData::AddImage( UINT rId )
{
    INT nIndex = -1;
    if (CSakData::m_nImageCount < RS_SCOPE_IMAGE_ARRAY_MAX) {

        CSakData::m_nImageArray[CSakData::m_nImageCount] = rId;
        nIndex = CSakData::m_nImageCount;
        CSakData::m_nImageCount++;

    }
    return nIndex;
}

void CSakData::SetState (BOOL State)
{
    m_State = State;
}

STDMETHODIMP
CSakData::GetState ()
{
    return ((m_State) ? S_OK : S_FALSE);
}

STDMETHODIMP
CSakData::Disable(
    IN BOOL Disable
    )
{
    WsbTraceIn( L"CSakData::Disable", L"Disable = <%ls>", WsbBoolAsString( Disable ) );

    HRESULT hr = S_OK;
    m_Disabled = Disable ? TRUE : FALSE; // Force values to TRUE or FALSE

    //
    // Make sure state is correct as well
    //
    if( Disable ) {

        SetState( FALSE );

    }

    WsbTraceOut( L"CSakData::Disable", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakData::IsDisabled(
    )
{
    WsbTraceIn( L"CSakData::IsDisabled", L"" );

    HRESULT hr = m_Disabled ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakData::IsDisabled", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


// Is the dataobject either type of multi-select dataobject?
HRESULT 
CSakData::IsDataObjectMultiSelect   ( IDataObject *pDataObject ) 
{ 
    HRESULT hr = S_OK;

    WsbTraceThreadOff( );

    hr = ( ( (IsDataObjectOt( pDataObject ) ) == S_OK ) || 
        ( (IsDataObjectMs( pDataObject ) ) == S_OK ) ) ? S_OK : S_FALSE;

    WsbTraceThreadOn( );
    return( hr );
}

// Is the dataobject an Object Types dataobject?
HRESULT
CSakData::IsDataObjectOt ( IDataObject *pDataObject )
{
    HRESULT hr = S_FALSE;

    WsbTraceThreadOff( );

    // Is this a mutli-select data object?
    FORMATETC fmt = {(CLIPFORMAT)m_cfObjectTypes, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

    if ( pDataObject->GetData( &fmt, &stgm ) == S_OK ) {
        hr = S_OK;
    }

    ReleaseStgMedium( &stgm );

    WsbTraceThreadOn( );
    return( hr );
}

// Is the dataobject a Mutli-Select dataobject?
HRESULT
CSakData::IsDataObjectMs ( IDataObject *pDataObject )
{
    HRESULT hr = S_FALSE;

    WsbTraceThreadOff( );

    // Is this a mutli-select data object?
    FORMATETC fmt = {(CLIPFORMAT)m_cfMultiSelect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

    if ( pDataObject->GetData( &fmt, &stgm ) == S_OK ) {
        hr = S_OK;
    }

    ReleaseStgMedium( &stgm );

    WsbTraceThreadOn( );
    return( hr );
}

#if 0
HRESULT CSakData::SaveColumnWidths( USHORT listCtrlId, CListCtrl *pListCtrl ) 
{
    WsbTraceIn( L"CSakData::SaveColumnWidths", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;
    HRESULT hrInternal;
    UINT columnWidth;
    GUID nodeTypeGuid;
    BOOL exists = FALSE;
    UINT updateIndex;
    UINT col;

    try {
        WsbAssertPointer( pListCtrl );

        // Search to see if the listCtrlId already has an entry
        for( INT index = 0; index < m_cListViewWidths; index++ ) {

            if ( m_ListViewWidths[ index ].listCtrlId == listCtrlId ) {

                updateIndex = index;
                exists = TRUE;

            }
        }
        if ( !exists ) {

            // Create a new entry
            WsbAssert( m_cListViewWidths < BHSM_MAX_NODE_TYPES - 1, E_FAIL );
            updateIndex = m_cListViewWidths;
            m_ListViewWidths[ updateIndex ].listCtrlId = listCtrlId;
            m_cListViewWidths++;
        }

        // Now set the column widths
         col = 0;
         hrInternal = S_OK;
         while( hrInternal == S_OK ) {

            hrInternal =  pListCtrl->GetColumnWidth( col, &columnWidth );
            if (hrInternal == S_OK) {

                m_ListViewWidths[ updateIndex ].columnWidths[ col ] = columnWidth;
                col++;

            }
        }
        // if we failed totally to get column widths, don't wipe out the previous value
        if ( col > 0 ) {
         m_ListViewWidths[ updateIndex ].colCount = col;
        }
    } WsbCatch (hr);
    WsbTraceOut( L"CSakData::SaveColumnWidths", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CSakData::GetSavedColumnWidths( USHORT listCtrlId, CListCtrl *pListCtrl ) 
{
    WsbTraceIn( L"CSakData::SaveColumnWidths", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;
    GUID nodeTypeGuid;
    BOOL exists = FALSE;
    INT col;

    try {
        WsbAssertPointer( pNode );

        // Search to see if the listCtrlId already has an entry
        for ( INT index = 0; index < m_cListViewWidths; index++ ) {
            if ( m_ListViewWidths[ index ].listCtrlId == listCtrlId ) {
                for ( col = 0; col < m_ListViewWidths[ index ].colCount; col++) {
                    // Return the column widths
                    pColumnWidths[ col ] = m_ListViewWidths[ index ].columnWidths[ col ];
                }
                *pColCount = m_ListViewWidths[ index ].colCount;
                exists = TRUE;
            }
        }
        if ( !exists ) {
            return WSB_E_NOTFOUND;
        }
    } WsbCatch (hr);
    WsbTraceOut( L"CSakData::SaveColumnWidths", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}
#endif


void
CSakData::InitFromCommandLine(
    void
    )
/*++

Routine Description:

    Retreive the command line info and fill in appropriate fields.

Arguments:

  none.

Return Value:

  none.

--*/
{
    WsbTraceIn( L"CSakData::InitFromCommandLine", L"" );

    g_App.ParseCommandLine( m_Parse );

    if( m_Parse.m_SetManageLocal )          m_ManageLocal           = m_Parse.m_ManageLocal;
    if( m_Parse.m_SetHsmName )              m_HsmName               = m_Parse.m_HsmName;
    if( m_Parse.m_SetPersistManageLocal )   m_PersistManageLocal    = m_Parse.m_PersistManageLocal;

}

/////////////////////////////////////////////////////////////////////////////
// CSakDataWnd

BOOL
CSakDataWnd::Create(
    CSakData * pSakData
    )
{
    WsbTraceIn( L"CSakDataWnd::Create", L"" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    m_pSakData = pSakData;

    BOOL retval = CWnd::CreateEx( 0, AfxRegisterWndClass( 0 ), _T("RSAdmin MsgWnd"), WS_OVERLAPPED, 0, 0, 0, 0, 0, 0 );

    WsbTraceOut( L"CSakDataWnd::Create", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

void
CSakDataWnd::PostNcDestroy(
    )
{
    WsbTraceIn( L"CSakDataWnd::PostNcDestroy", L"" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    CWnd::PostNcDestroy( );

    //
    // Cleanup object
    //
    delete this;

    WsbTraceOut( L"CSakDataWnd::PostNcDestroy", L"" );
}

BEGIN_MESSAGE_MAP(CSakDataWnd, CWnd)
    //{{AFX_MSG_MAP(CSakDataWnd)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
    ON_MESSAGE( WM_SAKDATA_UPDATE_ALL_VIEWS, OnUpdateAllViews )
    ON_MESSAGE( WM_SAKDATA_REFRESH_NODE,     OnRefreshNode )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSakDataWnd message handlers
LONG
CSakDataWnd::OnUpdateAllViews(
    IN UINT,
    IN LONG lParam )
{
    WsbTraceIn( L"CSakDataWnd::OnUpdateAllViews", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // Call the internal update
        //
        WsbAffirmHr( m_pSakData->InternalUpdateAllViews( (MMC_COOKIE)lParam ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakDataWnd::OnUpdateAllViews", L"" );
    return( 0 );
}

void
CSakDataWnd::PostUpdateAllViews(
    IN MMC_COOKIE Cookie
    )
{
    WsbTraceIn( L"CSakDataWnd::PostUpdateAllViews", L"" );

    PostMessage( WM_SAKDATA_UPDATE_ALL_VIEWS, 0, Cookie );

    WsbTraceOut( L"CSakDataWnd::PostUpdateAllViews", L"" );

}

LONG
CSakDataWnd::OnRefreshNode(
    IN UINT,
    IN LONG lParam )
{
    WsbTraceIn( L"CSakDataWnd::OnRefreshNode", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // Call the internal update
        //
        WsbAffirmHr( m_pSakData->InternalRefreshNode( (MMC_COOKIE)lParam ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakDataWnd::OnRefreshNode", L"" );
    return( 0 );
}

void
CSakDataWnd::PostRefreshNode(
    IN MMC_COOKIE Cookie
    )
{
    WsbTraceIn( L"CSakDataWnd::PostRefreshNode", L"" );

    PostMessage( WM_SAKDATA_REFRESH_NODE, 0, Cookie );

    WsbTraceOut( L"CSakDataWnd::PostRefreshNode", L"" );

}

ULONG
CSakData::InternalAddRef(
    )
{
    WsbTraceIn( L"CSakData::InternalAddRef", L"" );

    ULONG retval = CComObjectRoot::InternalAddRef( );

    WsbTraceOut( L"CSakData::InternalAddRef", L"retval = <%lu>", retval );
    return( retval );
}

ULONG
CSakData::InternalRelease(
    )
{
    WsbTraceIn( L"CSakData::InternalRelease", L"" );

    ULONG retval = CComObjectRoot::InternalRelease( );

    WsbTraceOut( L"CSakData::InternalRelease", L"retval = <%lu>", retval );
    return( retval );
}

STDMETHODIMP
CSakData::GetHelpTopic(
    LPOLESTR* pTopic
    )
{
    WsbTraceIn( L"CSakData::GetHelpTopic", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pTopic );

        *pTopic = 0;
        CWsbStringPtr topic;
        WsbAffirmHr( topic.LoadFromRsc( _Module.m_hInst, IDS_HELPFILE ) );

#if 1 // Hopefully temporary hack since MMC can't find the help directory
        WsbAffirmHr( topic.Prepend( L"\\help\\" ) );
        CWsbStringPtr winDir;
        WsbAffirmHr( winDir.Alloc( RS_WINDIR_SIZE ) );
        WsbAffirmStatus( ::GetWindowsDirectory( (WCHAR*)winDir, RS_WINDIR_SIZE ) != 0 );
        WsbAffirmHr( topic.Prepend( winDir ) );
#endif

        WsbAffirmHr( topic.GiveTo( pTopic ) );

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::GetHelpTopic", L"hr = <%ls>, *pTopic = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pTopic ) );
    return( hr );
}

STDMETHODIMP
CSakData::GetLinkedTopics(
    LPOLESTR* pTopic
    )
{
    WsbTraceIn( L"CSakData::GetLinkedTopics", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pTopic );

        *pTopic = 0;
        CWsbStringPtr topic;
        WsbAffirmHr( topic.LoadFromRsc( _Module.m_hInst, IDS_HELPFILELINK ) );

#if 1 // Hopefully temporary hack since MMC can't find the help directory
        WsbAffirmHr( topic.Prepend( L"\\help\\" ) );
        CWsbStringPtr winDir;
        WsbAffirmHr( winDir.Alloc( RS_WINDIR_SIZE ) );
        WsbAffirmStatus( ::GetWindowsDirectory( (WCHAR*)winDir, RS_WINDIR_SIZE ) != 0 );
        WsbAffirmHr( topic.Prepend( winDir ) );
#endif

        WsbAffirmHr( topic.GiveTo( pTopic ) );

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::GetLinkedTopics", L"hr = <%ls>, *pTopic = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pTopic ) );
    return( hr );
}

STDMETHODIMP
CSakData::CreateWizard(
    IN ISakWizard * pWizard
    )
{
    WsbTraceIn( L"CSakData::CreateWizard", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pWizard );

        //
        // Need to get prop sheet privider and create wizard
        //
        CComPtr<IPropertySheetProvider> pProvider;
        WsbAffirmHr( m_pConsole.QueryInterface( &pProvider ) );

        //
        // Create it
        //
        CWsbStringPtr pszName;
        WsbAffirmHr( pWizard->GetTitle( &pszName ) );

        //
        // Create the property sheet
        //
        CComPtr<IDataObject> pDataObject;
        WsbAffirmHr( RsQueryInterface( pWizard, IDataObject, pDataObject ) );
        WsbAffirmHr( pProvider->CreatePropertySheet( pszName, FALSE, 0, pDataObject, MMC_PSO_NEWWIZARDTYPE ) );

        //
        // Tell the IComponentData interface to add pages
        //
        CComPtr <IUnknown> pUnkComponentData;
        pUnkComponentData = (IUnknown *) (IComponentData*) this;
        WsbAffirmHr( pProvider->AddPrimaryPages( pUnkComponentData, TRUE, 0, TRUE ) );

        //
        // And show it
        //
        HWND mainWnd;
        WsbAffirmHr( m_pConsole->GetMainWindow( &mainWnd ) );
        WsbAffirmHr( pProvider->Show( reinterpret_cast<RS_WIN32_HANDLE>(mainWnd), 0 ) );

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::CreateWizard", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakData::GetWatermarks(
    IN  LPDATAOBJECT pDataObject,
    OUT HBITMAP*     pWatermark,
    OUT HBITMAP*     pHeader,
    OUT HPALETTE*    pPalette,
    OUT BOOL*        pStretch
    )
{
    WsbTraceIn( L"CSakData::GetWatermarks", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Need to get the ISakWizard interface to do actual work
        //
        CComPtr<ISakWizard> pWizard;
        WsbAffirmHr( RsQueryInterface( pDataObject, ISakWizard, pWizard ) );

        //
        // And make the call
        //
        WsbAffirmHr( pWizard->GetWatermarks( pWatermark, pHeader, pPalette, pStretch ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetWatermarks", L"" );
    return( hr );
}

CSakDataNodePrivate::CSakDataNodePrivate( ISakNode* pNode )
{
    m_pNode = pNode;
    RS_PRIVATE_DATA data = (RS_PRIVATE_DATA)this;
    if( SUCCEEDED( pNode->SetPrivateData( data ) ) ) {

        m_Magic = RS_NODE_MAGIC_GOOD;

    } else {

        m_Magic = RS_NODE_MAGIC_DEFUNCT;

    }
}

CSakDataNodePrivate::~CSakDataNodePrivate( )
{
    m_Magic = RS_NODE_MAGIC_DEFUNCT;
    if( m_pNode ) {

        m_pNode->SetPrivateData( 0 );

    }
}

HRESULT CSakDataNodePrivate::Verify( CSakDataNodePrivate* pNodePriv )
{
    HRESULT hr = E_POINTER;

    if( !IsBadWritePtr( pNodePriv, sizeof( CSakDataNodePrivate ) ) ) {

        if( RS_NODE_MAGIC_GOOD == pNodePriv->m_Magic ) {

            hr = S_OK;

        }
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\csaksnap.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CSakSnap.h

Abstract:

    Implementation of IComponent for Snapin.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef CSAKSNAP_H
#define CSAKSNAP_H

#define RS_RESULT_IMAGE_ARRAY_MAX 100

typedef struct {
    GUID nodeTypeId;
    USHORT colCount;
    USHORT columnWidths[BHSM_MAX_CHILD_PROPS];
} COLUMN_WIDTH_SET;

class CSakData;

/////////////////////////////////////////////////////////////////////////////
// COM class representing the SakSnap snapin object
class  ATL_NO_VTABLE CSakSnap : 
    public IComponent,          // interface that console calls into
    public IExtendPropertySheet,// add pages to the property sheet of an item. 
    public IExtendContextMenu,  // add items to context menu of an item
    public IExtendControlbar,   // add items to control bar of an item
    public IResultDataCompare,  // So we can custom sort
    public IPersistStream,
    public CComObjectRoot,      // handle object reference counts for objects
    public CComCoClass<CSakSnap,&CLSID_HsmAdmin>
{

public:
    CSakSnap( ) {};

BEGIN_COM_MAP(CSakSnap)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()


DECLARE_REGISTRY_RESOURCEID(IDR_HsmAdmin)


// IComponent interface members
public:
    STDMETHOD( Initialize )      ( IConsole* pConsole);
    STDMETHOD( Notify )          ( IDataObject* pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param );
    STDMETHOD( Destroy )         ( MMC_COOKIE cookie );
    STDMETHOD( GetResultViewType )(MMC_COOKIE cookie,  BSTR* ppViewType, long * pViewOptions );
    STDMETHOD( QueryDataObject ) ( MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject** ppDataObject );
    STDMETHOD( GetDisplayInfo )  ( LPRESULTDATAITEM pScopeItem );
    STDMETHOD( CompareObjects )  ( IDataObject* pDataObjectA, IDataObject* pDataObjectB );

// IExtendPropertySheet interface
public:
    STDMETHOD( CreatePropertyPages )( LPPROPERTYSHEETCALLBACK lpProvider, RS_NOTIFY_HANDLE handle, LPDATAOBJECT lpIDataObject );
    STDMETHOD( QueryPagesFor )      ( LPDATAOBJECT lpDataObject );

// IExtendContextMenu 
public:
    STDMETHOD( AddMenuItems )    ( IDataObject* pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG* pInsertionAllowed );
    STDMETHOD( Command )         ( long nCommandID, IDataObject* pDataObject );

// IExtendControlbar
    STDMETHOD( SetControlbar )   ( LPCONTROLBAR pControlbar );
    STDMETHOD( ControlbarNotify )( MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param );

// IResultDataCompare
    STDMETHOD( Compare )         ( IN LPARAM lUserParam, IN MMC_COOKIE CookieA, IN MMC_COOKIE CookieB, IN OUT int* pnResult );

// IPersistStream methods
    STDMETHOD( Save )( IStream *pStm, BOOL fClearDirty ); 
    STDMETHOD( Load )( IStream *pStm );
    STDMETHOD( IsDirty )(void); 
    STDMETHOD( GetSizeMax )( ULARGE_INTEGER *pcbSize ); 
    STDMETHOD( GetClassID )( CLSID *pClassID ); 

public:

// Notify event handlers
protected:
    HRESULT OnFolder        (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnShow          (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnSelect        (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnMinimize      (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnChange        (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnRefresh       (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnDelete        (IDataObject * pNode, LPARAM arg, LPARAM param);

// Toolbar event handler
    void CSakSnap::OnSelectToolbars(LPARAM arg, LPARAM param);

// Pseudo Constructor / Destructor
public:
    HRESULT FinalConstruct();
    void    FinalRelease();

// Methods to work with the image lists
private:
    // Given an HICON, return "virtual index" from result pane's image list
    CComPtr<IImageList>        m_pImageResult;    // SakSnap interface pointer to result pane image list
    HRESULT OnAddImages();
    HRESULT OnToolbarButtonClick(LPARAM arg, LPARAM param);

protected:
    // Enumerate the children of a node in result pane.
    HRESULT EnumResultPane( ISakNode* pNode );

    // functions to initialize headers in result view
    HRESULT InitResultPaneHeaders( ISakNode* pNode );

    // function to clear all icons of the node's children
    HRESULT ClearResultIcons( ISakNode* pNode );

// Interface pointers
protected:
    friend class CSakData;

    CComPtr<IConsole>       m_pConsole;     // Console's IFrame interface
    CComPtr<IResultData>    m_pResultData;
    CComPtr<IHeaderCtrl>    m_pHeader;      // Result pane's header control interface
    CComPtr<IControlbar>    m_pControlbar;  // control bar to hold my tool bars
    CComPtr<IConsoleVerb>   m_pConsoleVerb;
    CComPtr<IToolbar>       m_pToolbar;     // Toolbar for view
    CSakData *              m_pSakData;     // Pointer to owning SakData

private:
    CComPtr<ISakNode>       m_pEnumeratedNode;
    MMC_COOKIE              m_ActiveNodeCookie;  // ISakNode of active node in scope pane
    HRESULT                 ClearResultPane();
    HRESULT                 EnumRootDisplayProps( IEnumString ** ppEnum );

    // Contains column widths for a given node type COLUMN_WIDTH_SET    
    COLUMN_WIDTH_SET    m_ChildPropWidths[ BHSM_MAX_NODE_TYPES ];
    USHORT              m_cChildPropWidths;

    HRESULT GetSavedColumnWidths( ISakNode *pNode, INT *pColCount, INT *pColumnWidths );
    HRESULT SaveColumnWidths( ISakNode *pNode );

    // Image Array
public:
    static UINT m_nImageArray[RS_RESULT_IMAGE_ARRAY_MAX];
    static INT  m_nImageCount;

    // Static functions
public:
    static INT AddImage( UINT rId );


};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\cpropsht.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CPropSht.cpp

Abstract:

    Implementation of Property-Sheet-Like container object
    for property sheet pages.

Author:

    Art Bragg 10/8/97

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
//
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

// To make sure callbacks are in correct order:
// PropPageCallback -> MMC Callback -> MFC Callback
// This is because MMC only stores one pointer, and they want it
// to be MFC's
// note that pfnCallback has already been set to PropPageCallback

HRESULT CSakPropertyPage::SetMMCCallBack( )
{
    HRESULT hr = S_OK;

    m_psp.pfnCallback = m_pMfcCallback;
    hr = MMCPropPageCallback( &( m_psp ) );
    m_pMfcCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = PropPageCallback;

    return( hr );
}

// To make sure callbacks are in correct order:
// PropPageCallback -> MMC Callback -> MFC Callback
// This is because MMC only stores one pointer, and they want it
// to be MFC's
// note that pfnCallback has already been set to PropPageCallback

HRESULT CSakWizardPage::SetMMCCallBack( )
{
    HRESULT hr = S_OK;

    m_psp.pfnCallback = m_pMfcCallback;
    hr = MMCPropPageCallback( &( m_psp ) );
    m_pMfcCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = PropPageCallback;

    return( hr );
}


HRESULT
CSakPropertySheet::InitSheet(
            RS_NOTIFY_HANDLE Handle,
            IUnknown*        pUnkPropSheetCallback,
            CSakNode*        pSakNode,
            ISakSnapAsk*     pSakSnapAsk,
            IEnumGUID*       pEnumObjectId,
            IEnumUnknown*    pEnumUnkNode
    )
{
    WsbTraceIn( L"CSakPropertySheet::InitSheet", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Set data members
        //
        WsbAffirmHr( RsQueryInterface( pUnkPropSheetCallback, IPropertySheetCallback, m_pPropSheetCallback ) );
        m_pSakNode              = pSakNode;
        m_Handle                = Handle;
        m_bMultiSelect          = pEnumObjectId ? TRUE : FALSE ;

        if( pSakNode ) {

            WsbAffirmHr( SetNode( pSakNode ) );

        }

        //
        // Marshall ISakSnapAsk
        //
        WsbAffirmPointer( pSakSnapAsk );
        WsbAffirmHr ( CoMarshalInterThreadInterfaceInStream(
            IID_ISakSnapAsk, pSakSnapAsk, &m_pSakSnapAskStream ) );

        //
        // Store the GUIDs
        //
        if( pEnumObjectId ) {

            GUID objectId;
            while( pEnumObjectId->Next( 1, &objectId, NULL ) == S_OK) {

                m_ObjectIdList.Add( objectId );

            }
        }

        //
        // Store the nodes
        //
        if( pEnumUnkNode ) {

            CComPtr<IUnknown> pUnkNode;
            CComPtr<ISakNode> pNode;
            pEnumUnkNode->Reset( );
            while( pEnumUnkNode->Next( 1, &pUnkNode, NULL ) == S_OK ) {

                WsbAffirmHr( pUnkNode.QueryInterface( &pNode ) );
                m_UnkNodeList.Add( pNode );
                pUnkNode.Release( );
                pNode.Release( );

            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakPropertySheet::InitSheet", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakPropertySheet::SetNode(
    CSakNode*        pSakNode
    )
{
    WsbTraceIn( L"CSakPropertySheet::SetNode", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Marshall pHsmObj as an unknown
        //
        CComPtr <IUnknown> pHsmObj;
        pSakNode->GetHsmObj( &pHsmObj );
        if( pHsmObj ) {

            WsbAffirmHr ( CoMarshalInterThreadInterfaceInStream(
                IID_IUnknown, pHsmObj, &m_pHsmObjStream ) );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakPropertySheet::SetNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

CSakPropertySheet::~CSakPropertySheet()
{
    WsbTraceIn( L"CSakPropertySheet::~CSakPropertySheet", L"" );

    MMCFreeNotifyHandle( m_Handle );

    WsbTraceOut( L"CSakPropertySheet::~CSakPropertySheet", L"" );
}

HRESULT CSakPropertySheet::GetNextObjectId( INT *pBookMark, GUID *pObjectId )
{
    HRESULT hr = S_OK;
    try {
        WsbAffirm( *pBookMark >= 0, E_FAIL );
        if( *pBookMark <= m_ObjectIdList.GetUpperBound( ) ) {

            *pObjectId = m_ObjectIdList[ *pBookMark ];
            (*pBookMark)++;

        } else {

            //
            // We're done
            //
            WsbThrow ( S_FALSE );

        }
    } WsbCatch( hr );

    return( hr );
}

HRESULT CSakPropertySheet::GetNextNode( INT *pBookMark, ISakNode **ppNode )
{
    HRESULT hr = S_OK;
    try {

        WsbAffirm( *pBookMark >= 0, E_FAIL );
        if( *pBookMark < m_UnkNodeList.length( ) ) {

            WsbAffirmHr( m_UnkNodeList.CopyTo( *pBookMark, ppNode ) );
            (*pBookMark)++;

        } else {

            //
            // We're done
            //
            hr = S_FALSE;

        }

    } WsbCatch( hr );

    return( hr );
}

void CSakPropertySheet::AddPageRef()
{
    m_nPageCount++;
}


void CSakPropertySheet::ReleasePageRef()
{
    m_nPageCount--;

    //
    // Check to see if this is last reference
    //
    if( m_nPageCount <= 0 ) {

        delete( this );

    }
}


HRESULT CSakPropertySheet::GetHsmObj( IUnknown **ppHsmObj )
{
    HRESULT hr = S_OK;
    try {

        if( !m_pHsmObj ) {

            //
            // Unmarhsall the pointer
            //
            WsbAffirmHr( CoGetInterfaceAndReleaseStream( m_pHsmObjStream, IID_IUnknown, 
                    (void **) &m_pHsmObj ) );
        } 
        m_pHsmObj.CopyTo( ppHsmObj );

    } WsbCatch( hr );
    return( hr );
}

HRESULT CSakPropertySheet::GetSakSnapAsk( ISakSnapAsk **ppAsk )
{
    HRESULT hr = S_OK;
    try {

        if ( !m_pSakSnapAsk ) {

            //
            // Unmarhsall the pointer
            //
            WsbAffirmHr( CoGetInterfaceAndReleaseStream( m_pSakSnapAskStream, IID_ISakSnapAsk, 
                    (void **) &m_pSakSnapAsk ) );
        }
        m_pSakSnapAsk.CopyTo( ppAsk );

    } WsbCatch( hr );

    return( hr );
}

HRESULT CSakPropertySheet::GetHsmServer (IHsmServer **ppHsmServer)
{
    HRESULT hr = S_OK;
    try {

        CComPtr<ISakSnapAsk> pAsk;
        WsbAffirmHr( GetSakSnapAsk( &pAsk ) );
        WsbAffirmHrOk( pAsk->GetHsmServer( ppHsmServer ) );

    } WsbCatch( hr );
    return( hr );
}

HRESULT CSakPropertySheet::GetFsaServer (IFsaServer **ppFsaServer)
{
    HRESULT hr = S_OK;
    try {

        CComPtr<ISakSnapAsk> pAsk;
        WsbAffirmHr( GetSakSnapAsk( &pAsk ) );
        WsbAffirmHrOk( pAsk->GetFsaServer( ppFsaServer ) );

    } WsbCatch( hr );
    return( hr );
}

HRESULT CSakPropertySheet::GetRmsServer (IRmsServer **ppRmsServer)
{
    HRESULT hr = S_OK;
    try {

        CComPtr<ISakSnapAsk> pAsk;
        WsbAffirmHr( GetSakSnapAsk( &pAsk ) );
        WsbAffirmHrOk( pAsk->GetRmsServer( ppRmsServer ) );

    } WsbCatch( hr );
    return( hr );
}


HRESULT CSakPropertySheet::IsMultiSelect ( )
{
    return m_bMultiSelect ? S_OK : S_FALSE;
}
        
HRESULT CSakPropertySheet::OnPropertyChange( RS_NOTIFY_HANDLE hConsoleHandle, ISakNode* pNode )
{
    //
    // Called by a property sheet to notify MMC
    //
    HRESULT hr = S_OK;
    RS_PRIVATE_DATA privData;

    //
    // Notify the console that properties have changed for the node(s)
    //
    try {

        if( !m_bMultiSelect ) {

            //
            // Single Select
            //
            if( ! pNode ) {

                pNode = m_pSakNode;
            }

            WsbAffirmHr( pNode->GetPrivateData( &privData ) );
            WsbAffirmHr( MMCPropertyChangeNotify( hConsoleHandle, (LPARAM)privData ) );

        } else {

            //
            // Multi Select
            //
            INT bookMark = 0;
            CComPtr<ISakNode> pNode;
            while( GetNextNode( &bookMark, &pNode ) == S_OK) {

                WsbAffirmHr( pNode->GetPrivateData( &privData ) );
                WsbAffirmHr( MMCPropertyChangeNotify( hConsoleHandle, (LPARAM)privData ) );

                pNode.Release( );

            }
        }

    } WsbCatch( hr );

    return( hr );
}

// This function is to be called from the page thread
HRESULT CSakPropertySheet::GetFsaFilter( IFsaFilter **ppFsaFilter )
{
    WsbTraceIn( L"CSakPropertySheet::GetFsaFilter", L"" ); 
    HRESULT hr = S_OK;

    try {

        CComPtr<IFsaServer> pFsa;
        WsbAffirmHr( GetFsaServer( &pFsa ) );

        //
        // Get the FsaFilter object
        //
        WsbAffirmHr( pFsa->GetFilter( ppFsaFilter ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakPropertySheet::GetFsaFilter", L"hr = <%ls>, *ppFsaFilter = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppFsaFilter ) );
    return( hr );
}

HRESULT
CSakPropertySheet::AddPage(
    IN CSakPropertyPage* pPage
    )
{
    WsbTraceIn( L"CSakPropertySheet::AddPage", L"" ); 
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    HRESULT hr = S_OK;

    try {

        //
        // Get the property sheet callback interface from the input param.
        //
        pPage->m_hConsoleHandle = m_Handle;
        pPage->m_pParent        = this;

        WsbAffirmHr( pPage->SetMMCCallBack( ) );

        HPROPSHEETPAGE hPage;
        hPage = CreatePropertySheetPage( &( pPage->m_psp ) );
        WsbAffirmPointer( hPage );
        AddPageRef( );

        WsbAffirmHr( m_pPropSheetCallback->AddPage( hPage ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakPropertySheet::AddPage", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

CSakPropertyPage::CSakPropertyPage( UINT nIDTemplate, UINT nIDCaption ) :
    CRsPropertyPage( nIDTemplate, nIDCaption ),
    m_pParent( 0 )
{
}

void
CSakPropertyPage::OnPageRelease( )
{
    if( m_pParent ) {

        m_pParent->ReleasePageRef( );

    }
    delete this;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// class CSakVolPropSheet
//
// Supports property sheets for Managed volume and Managed Volume List
//
//
HRESULT CSakVolPropSheet::GetFsaResource (IFsaResource **ppFsaResource)
{
    WsbTraceIn( L"CSakVolPropSheet::GetFsaResource", L"" ); 
    HRESULT hr = S_OK;

    try {

        //
        // Get the hsm object which is a CHsmManagedResource
        //
        CComPtr<IUnknown> pUnk;
        WsbAffirmHr( GetHsmObj( &pUnk ) );
        CComPtr<IHsmManagedResource> pManRes;
        WsbAffirmHr( pUnk.QueryInterface( &pManRes ) );

        //
        // Then Get Coresponding FSA resource
        //
        CComPtr<IUnknown> pUnkFsaRes;
        WsbAffirmHr( pManRes->GetFsaResource( &pUnkFsaRes ) );
        WsbAffirmHr( pUnkFsaRes.QueryInterface( ppFsaResource ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakVolPropSheet::GetFsaResource", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakVolPropSheet::AddPage(
    IN CSakVolPropPage* pPage
    )
{
    WsbTraceIn( L"CSakVolPropSheet::AddPage", L"" ); 

    HRESULT hr = CSakPropertySheet::AddPage( pPage );
    if( SUCCEEDED( hr ) ) {

        pPage->m_pVolParent = this;

    }

    WsbTraceOut( L"CSakVolPropSheet::AddPage", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

CSakVolPropPage::CSakVolPropPage( UINT nIDTemplate, UINT nIDCaption ) :
    CSakPropertyPage( nIDTemplate, nIDCaption ),
    m_pVolParent( 0 )
{
}

////////////////////////////////////////////////////////////////////////////////////////
//
// class CSakWizardSheet
//
// Supports wizards created through MMC
//
//

CSakWizardSheet::CSakWizardSheet( ) :
    m_HrFinish( RS_E_CANCELLED ),
    m_pFirstPage( 0 )
{

}

STDMETHODIMP
CSakWizardSheet::GetWatermarks(
    OUT HBITMAP*  pWatermark,
    OUT HBITMAP*  pHeader,
    OUT HPALETTE* pPalette,
    OUT BOOL*     pStretch
    )
{
    WsbTraceIn( L"CSakWizardSheet::GetWatermarks", L"" ); 
    AFX_MANAGE_STATE(AfxGetStaticModuleState()); 
    HRESULT hr = S_OK;

    try {

        //
        // Have we loaded them yet?
        //
        if( ! m_Header.GetSafeHandle( ) ) {

            m_Header.LoadBitmap( m_HeaderId );
            m_Watermark.LoadBitmap( m_WatermarkId );

        }

        *pHeader    = (HBITMAP)m_Header.GetSafeHandle( );
        *pWatermark = (HBITMAP)m_Watermark.GetSafeHandle( );
        *pStretch   = TRUE;
        *pPalette   = 0;
     
    } WsbCatch( hr );

    WsbTraceOut( L"CSakWizardSheet::GetWatermarks", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakWizardSheet::GetTitle(
    OUT OLECHAR** pTitle
    )
{
    WsbTraceIn( L"CSakWizardSheet::GetTitle", L"" ); 
    HRESULT hr = S_OK;

    try {

        //
        // Have we loaded yet?
        //
        if( m_Title.IsEmpty( ) ) {

            m_Title.LoadString( m_TitleId );

        }

        //
        // Easiest way to CoTaskMemAlloc string
        //
        CWsbStringPtr title = m_Title;
        WsbAffirmHr( title.GiveTo( pTitle ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakWizardSheet::GetTitle", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

void CSakWizardSheet::AddPageRef()
{
    ((ISakWizard*)this)->AddRef( );
}


void CSakWizardSheet::ReleasePageRef()
{
    ((ISakWizard*)this)->Release( );
}

HRESULT
CSakWizardSheet::AddPage(
    IN CSakWizardPage* pPage
    )
{
    WsbTraceIn( L"CSakWizardSheet::AddPage", L"" ); 
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    HRESULT hr = S_OK;

    try {

        //
        // Need to track first page so that we can find true HWND of sheet
        // in later calls
        //
        if( ! m_pFirstPage ) {

            m_pFirstPage = pPage;

        }

        //
        // Take the caption from our sheet class and put it in the page
        //
        pPage->SetCaption( CString( m_Title ) );


        //
        // Get the property sheet callback interface from the input param.
        //
        pPage->m_pSheet = this;
        WsbAffirmHr( pPage->SetMMCCallBack( ) );

        HPROPSHEETPAGE hPage;
        hPage = pPage->CreatePropertyPage( );
        WsbAffirmPointer( hPage );
        AddPageRef( );

        WsbAffirmHr( m_pPropSheetCallback->AddPage( hPage ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakWizardSheet::AddPage", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


void CSakWizardSheet::SetWizardButtons(
    DWORD Flags
    )
{
    WsbTraceIn( L"CSakWizardSheet::SetWizardButtons", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFirstPage );
        WsbAffirmHandle( m_pFirstPage->GetSafeHwnd( ) );

        CPropertySheet* pSheet;
        pSheet = (CPropertySheet*)m_pFirstPage->GetParent( );

        WsbAffirmPointer( pSheet );
        pSheet->SetWizardButtons( Flags );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakWizardSheet::SetWizardButtons", L"hr = <%ls>", WsbHrAsString( hr ) );
}


BOOL CSakWizardSheet::PressButton(
    int Button
    )
{
    WsbTraceIn( L"CSakWizardSheet::PressButton", L"" );
    HRESULT hr     = S_OK;
    BOOL    retVal = FALSE;

    try {

        WsbAffirmPointer( m_pFirstPage );
        WsbAffirmHandle( m_pFirstPage->GetSafeHwnd( ) );

        CPropertySheet* pSheet;
        pSheet = (CPropertySheet*)m_pFirstPage->GetParent( );

        WsbAffirmPointer( pSheet );
        retVal = pSheet->PressButton( Button );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakWizardSheet::PressButton", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( retVal );
}


CSakWizardPage::CSakWizardPage( UINT nIDTemplate, BOOL bExterior, UINT nIdTitle, UINT nIdSubtitle ) :
    CRsWizardPage( nIDTemplate, bExterior, nIdTitle, nIdSubtitle ),
    m_pSheet( 0 )
{
}

BOOL CSakWizardPage::OnWizardFinish( )
{
    WsbTraceIn( L"CSakWizardPage::OnWizardFinish", L"" );

    //
    // Delegate the finish work to the sheet
    //
    m_pSheet->OnFinish( );
    
    BOOL retval = CRsWizardPage::OnWizardFinish( );

    WsbTraceOut( L"CSakWizardPage::OnWizardFinish", L"" );
    return( retval );
}

void CSakWizardPage::OnCancel( ) 
{
    WsbTraceIn( L"CSakWizardPage::OnCancel", L"" );

    //
    // Since the Sheet does not receive an "OnCancel", we call it from the
    // page that will always exist - the intro
    //

    m_pSheet->OnCancel( );
    
    CRsWizardPage::OnCancel( );

    WsbTraceOut( L"CSakWizardPage::OnCancel", L"" );
}

void
CSakWizardPage::OnPageRelease( )
{
    if( m_pSheet ) {

        m_pSheet->ReleasePageRef( );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\dataobj.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    DataObj.cpp

Abstract:

    Implementation of IDataObject interface, which is supported
    by the CBaseHsm COM object.

Author:

    Rohde Wakefield [rohde]   19-Aug-1997

Revision History:

--*/

#include "stdafx.h"

// Declare Snap-in NodeType formats:
// - GUID format
// - string GUID format
// - display name format.
// - internal format.
UINT CSakNode::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
UINT CSakNode::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);  
UINT CSakNode::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME); 
UINT CSakNode::m_cfInternal       = RegisterClipboardFormat(SAKSNAP_INTERNAL); 
UINT CSakNode::m_cfClassId        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);  
UINT CSakNode::m_cfComputerName   = RegisterClipboardFormat(MMC_SNAPIN_MACHINE_NAME); 
UINT CSakNode::m_cfEventLogViews  = RegisterClipboardFormat(CF_EV_VIEWS); 


HRESULT
CSakNode::GetDataGeneric(
    IN     LPFORMATETC lpFormatetcIn,
    IN OUT LPSTGMEDIUM lpMedium,
    IN     BOOL DoAlloc
    )
/*++

Routine Description:

    Retrieve information FROM the dataobject and put INTO lpMedium.

Arguments:

    lpFormatetc     - Format to retreive.

    lpMedium        - Storage to put information into.

Return Value:

    S_OK            - Storage filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakNode::GetDataGeneric", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetcIn->cfFormat ), WsbBoolAsString( DoAlloc ) );
    HRESULT hr = DV_E_CLIPFORMAT;

    try {

        WsbAffirmPointer( lpMedium );

        if( DoAlloc ) {

            lpMedium->hGlobal = 0;
            lpMedium->tymed   = TYMED_HGLOBAL;

        } else {

            WsbAffirm( TYMED_HGLOBAL == lpMedium->tymed, DV_E_TYMED );
            WsbAffirmPointer( lpMedium->hGlobal );

        }

        // Based on the CLIPFORMAT write data to "lpMediam" in the correct format.
        const CLIPFORMAT cf = lpFormatetcIn->cfFormat;

        // clip format is the GUID node type
        if(cf == m_cfNodeType) {
            hr = RetrieveNodeTypeData(lpMedium);

        // clip format is the string "spelling" of the GUID node type
        } else if(cf == m_cfNodeTypeString) {
            hr = RetrieveNodeTypeStringData(lpMedium);

        // clip format is the computer represented
        } else if (cf == m_cfComputerName) {
            hr = RetrieveComputerName(lpMedium);

        // clip format is the event viewer setup
        } else if (cf == m_cfEventLogViews) {
            hr = RetrieveEventLogViews(lpMedium);

        // clip format is the display name of the node
        } else if (cf == m_cfDisplayName) {
            hr = RetrieveDisplayName(lpMedium);

        // clip format is the ClassId
        } else if( cf == m_cfClassId ) {
            hr = RetrieveClsid( lpMedium );

        // clip format is an INTERNAL format
        } else if (cf == m_cfInternal) {
            hr = RetrieveInternal(lpMedium);

        } else {
            hr = DV_E_CLIPFORMAT;
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::GetDataGeneric", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakNode::GetData(
    IN  LPFORMATETC lpFormatetcIn,
    OUT LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve information FROM the dataobject and put INTO lpMedium.
    Storage allocated and returned.

Arguments:

    lpFormatetc     - Format to retreive.

    lpMedium        - Storage to put information into.

Return Value:

    S_OK            - Storage filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakNode::GetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetcIn->cfFormat ) );

    HRESULT hr = S_OK;

    hr = GetDataGeneric( lpFormatetcIn, lpMedium, TRUE );

    WsbTraceOut( L"CSakNode::GetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakNode::GetDataHere(
    IN     LPFORMATETC lpFormatetc,
    IN OUT LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve information FROM the dataobject and put INTO lpMedium.

Arguments:

    lpFormatetc     - Format to retreive.

    lpMedium        - Storage to put information into.

Return Value:

    S_OK            - Storage filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakNode::GetDataHere", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );
    HRESULT hr = S_OK;

    hr = GetDataGeneric( lpFormatetc, lpMedium, FALSE );

    WsbTraceOut( L"CSakNode::GetDataHere", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakNode::SetData(
    LPFORMATETC lpFormatetc,
    LPSTGMEDIUM lpMedium,
    BOOL        /*fRelease*/
    )
/*++

Routine Description:

    Put data INTO a dataobject FROM the information in the lpMedium.
    We do not allow any data to be set.

Arguments:

    lpFormatetc     - Format to set.

    lpMedium        - Storage to get information from.

    fRelease        - Indicates who owns storage after call.

Return Value:

    S_OK            - Storage retreived.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakNode::SetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to "lpMediam" in the correct format.
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    //clip format is an INTERNAL format
    if( cf == m_cfInternal ) {

        hr = StoreInternal( lpMedium );

    }

    WsbTraceOut( L"CSakNode::SetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

///////////////////////////////////////////////////////////////////////
// Note - CSakNode does not implement these
///////////////////////////////////////////////////////////////////////

STDMETHODIMP CSakNode::EnumFormatEtc(DWORD /*dwDirection*/, LPENUMFORMATETC* /*ppEnumFormatEtc*/)
{
    WsbTraceIn( L"CSakNode::EnumFormatEtc", L"" );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CSakNode::EnumFormatEtc", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

// Retrieve from a dataobject with the NodeType (GUID) data in it.
HRESULT CSakNode::RetrieveNodeTypeData(LPSTGMEDIUM lpMedium)
{
    return Retrieve((const void*)(m_rTypeGuid), sizeof(GUID), lpMedium);
}

// Retrieve from a dataobject with the node type object in GUID string format
HRESULT CSakNode::RetrieveNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    CWsbStringPtr guidString = *m_rTypeGuid;
    return Retrieve(guidString, ((wcslen(guidString)+1) * sizeof(wchar_t)), lpMedium);
}

// Retrieve from a dataobject with the display named used in the scope pane
HRESULT CSakNode::RetrieveDisplayName(LPSTGMEDIUM lpMedium)
{
    // Load the name the data object
    return Retrieve(m_szName, ((wcslen(m_szName)+1) * sizeof(wchar_t)), lpMedium);
}

//  Retrieve from a dataobject with the CLSID data in it.
HRESULT CSakNode::RetrieveClsid(LPSTGMEDIUM lpMedium)
{
    // zzzz
    return Retrieve( (const void*)(&CLSID_HsmAdminDataSnapin), sizeof(CLSID), lpMedium );
}

// Retrieve INTERNAL data from the dataobject's m_internal member INTO the lpMedium
HRESULT CSakNode::RetrieveInternal(LPSTGMEDIUM lpMedium)
{
    return Retrieve(&m_internal, sizeof(INTERNAL), lpMedium);
}

// Retrieve data from the dataobject's hsm name
HRESULT CSakNode::RetrieveComputerName(LPSTGMEDIUM lpMedium)
{
    HRESULT hr = S_OK;

    try {

        CWsbStringPtr computerName;
        HRESULT hrTemp = m_pSakSnapAsk->GetHsmName( &computerName );
        WsbAffirmHr( hrTemp );

        if( S_FALSE == hrTemp ) {

            computerName = L"";

        }

        WsbAffirmHr( 
            Retrieve(
                (WCHAR*)computerName,
                ( wcslen( computerName ) + 1 ) * sizeof(WCHAR),
                lpMedium ) );

    } WsbCatch( hr );

    return( hr );
}

// Retrieve event setup info
HRESULT CSakNode::RetrieveEventLogViews(LPSTGMEDIUM lpMedium)
{
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        WsbAffirmPointer( lpMedium );
        ULONG strLength = 0;

        CWsbStringPtr hsmName;
        CString appName, sysName;
        CString nullString;
        CString appPath, sysPath;

        appName.LoadString( IDS_EVENT_LOG_APP_TITLE );
        sysName.LoadString( IDS_EVENT_LOG_SYS_TITLE );
        nullString = L"";

        HRESULT hrTemp = m_pSakSnapAsk->GetHsmName( &hsmName );
        WsbAffirmHr( hrTemp );
        if( S_FALSE == hrTemp ) {

            hsmName = L"";
            appPath = L"";
            sysPath = L"";

        } else {

            CString configPath = L"\\\\";
            configPath += hsmName;
            configPath += L"\\Admin$\\System32\\config\\";
            appPath = configPath;
            sysPath = configPath;
            appPath += L"AppEvent.Evt";
            sysPath += L"SysEvent.Evt";

        }
        
#define ADD_TYPE(data, type) \
  {type x = data; \
   WsbAffirmHr( spStm->Write(&x, sizeof(type), NULL) ) };

#define ADD_USHORT(us) ADD_TYPE(us, USHORT)
#define ADD_BOOL(b)    ADD_TYPE(b,  BOOL)
#define ADD_ULONG(ul)  ADD_TYPE(ul, ULONG)
#define ADD_STRING(str) \
  {strLength = (ULONG)wcslen((LPCWSTR)(str)) + 1;           \
   ADD_USHORT((USHORT)strLength);                           \
   WsbAffirmHr( spStm->Write(str, strLength * sizeof(WCHAR), NULL) ) };

        CComPtr<IStream> spStm;

        WsbAffirmHr( CreateStreamOnHGlobal(NULL, FALSE, &spStm) );

        //
        // Add header info
        //
        ADD_BOOL( TRUE ); // fOnlyTheseViews
        ADD_USHORT( 2 );  // cViews

        //
        // Add application log filtered for our services
        //
        ADD_ULONG( ELT_APPLICATION );      // Type;
        ADD_USHORT( VIEWINFO_FILTERED | 
                    LOGINFO_DONT_PERSIST); // flViewFlags
        ADD_STRING( hsmName );             // ServerName
        PCWSTR pwz = L"Application";
        ADD_STRING( pwz );                 // SourceName
        ADD_STRING( appPath );             // FileName
        ADD_STRING( appName );             // DisplayName

        ADD_ULONG( EVENTLOG_ALL_EVENTS );  // flRecType (could filter warning, error, etc.)
        ADD_USHORT( 0 );                   // usCategory
        ADD_BOOL( FALSE );                 // fEventID
        ADD_ULONG( 0 );                    // ulEventID
        ADD_STRING( WSB_LOG_SOURCE_NAME ); // szSourceName
        ADD_STRING( nullString );          // szUser
        ADD_STRING( hsmName );             // szComputer
        ADD_ULONG( 0 );                    // ulFrom
        ADD_ULONG( 0 );                    // ulTo

        //
        // Add system log filtered for our device
        //
        ADD_ULONG( ELT_SYSTEM );           // Type;
        ADD_USHORT( VIEWINFO_FILTERED | 
                    LOGINFO_DONT_PERSIST); // flViewFlags
        ADD_STRING( hsmName );             // ServerName
        pwz = L"System";
        ADD_STRING( pwz );                 // SourceName
        ADD_STRING( sysPath );             // FileName
        ADD_STRING( sysName );             // DisplayName

        ADD_ULONG( EVENTLOG_ALL_EVENTS );  // flRecType (could filter warning, error, etc.)
        ADD_USHORT( 0 );                   // usCategory
        ADD_BOOL( FALSE );                 // fEventID
        ADD_ULONG( 0 );                    // ulEventID
        ADD_STRING( WSB_LOG_FILTER_NAME ); // szSourceName
        ADD_STRING( nullString );          // szUser
        ADD_STRING( hsmName );             // szComputer
        ADD_ULONG( 0 );                    // ulFrom
        ADD_ULONG( 0 );                    // ulTo

        HGLOBAL hMem = NULL;

        WsbAffirmHr( GetHGlobalFromStream(spStm, &hMem) );

        lpMedium->hGlobal        = hMem;       // StgMedium variables 
        lpMedium->tymed          = TYMED_HGLOBAL;
        lpMedium->pUnkForRelease = NULL;

  } WsbCatch( hr );

    return( hr );
}

// Store the INTERNAL data FROM the lpMedium->hGlobal INTO the dataobject's m_internal member
HRESULT CSakNode::StoreInternal(LPSTGMEDIUM lpMedium)
{
    return Store(&m_internal, sizeof(INTERNAL), lpMedium);
}

// Retrieve FROM a dataobject INTO a lpMedium. The data object can be one of
// several types of data in it (nodetype, nodetype string, display name, or 
// INTERNAL data). 
// This function moves data from pBuffer to the lpMedium->hGlobal
//
HRESULT CSakNode::Retrieve(const void* pBuffer, DWORD len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pBuffer );
        WsbAffirmPointer( lpMedium );
        WsbAffirm( TYMED_HGLOBAL == lpMedium->tymed, DV_E_TYMED );

        //
        // Check to see if we need to allocate the global memory here
        //
        if( 0 == lpMedium->hGlobal ) {

            lpMedium->hGlobal = ::GlobalAlloc( GPTR, len );

        } else {

            WsbAffirm( GlobalSize( lpMedium->hGlobal ) >= (DWORD)len, STG_E_MEDIUMFULL );

        }

        WsbAffirmPointer( lpMedium->hGlobal );

        // Create the stream on the hGlobal passed in. When we write to the stream,
        // it simultaneously writes to the hGlobal the same information.
        LPSTREAM lpStream;
        WsbAffirmHr( CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream ));

        // Write 'len' number of bytes from pBuffer into the stream. When we write
        // to the stream, it simultaneously writes to the global memory we
        // associated it with above.
        ULONG numBytesWritten;
        WsbAffirmHr( lpStream->Write(pBuffer, len, &numBytesWritten ));

        // Because we told CreateStreamOnHGlobal with 'FALSE', only the stream is released here.
        // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
        // at the correct time.  This is according to the IDataObject specification.
        lpStream->Release();

    } WsbCatch( hr );

    return hr;
}

// Store INTO a dataobject FROM an lpMedium. The data object can be one of
// several types of data in it (nodetype, nodetype string, display name, or 
// INTERNAL data). 
// This function moves data INTO pBuffer FROM the lpMedium->hGlobal
//
HRESULT CSakNode::Store( void* pBuffer, DWORD len, LPSTGMEDIUM lpMedium )
{
    HRESULT hr = S_OK;

    try {
        WsbAffirmPointer( pBuffer );
        WsbAffirmPointer( lpMedium );
        WsbAffirm( lpMedium->tymed == TYMED_HGLOBAL, E_INVALIDARG );

        // Use memcpy, because the lpStream->Read is failing to read any bytes. 
        memcpy(pBuffer, &(lpMedium->hGlobal), len);

    } WsbCatch( hr );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\csakdata.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CSakData.h

Abstract:

    IComponentData implementation for Snapin.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _CSAKDATA_H
#define _CSAKDATA_H

#define RS_SCOPE_IMAGE_ARRAY_MAX  100

//typedef struct {
//  USHORT listViewId;
//  USHORT colCount;
//  USHORT columnWidths[BHSM_MAX_CHILD_PROPS];
//} COLUMN_WIDTH_SET_PROP_PAGE;

// Maximum number of listview controls that have their properties saved
// #define MAX_LISTVIEWS 20

/////////////////////////////////////////////////////////////////////////////
// CSakDataWnd window
class CSakData;

class CSakDataWnd : public CWnd
{
// Construction
public:
    CSakDataWnd( ) {};

    BOOL Create( CSakData * pSakData );
    virtual void PostNcDestroy( );

// Attributes
public:
    CSakData * m_pSakData;

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSakDataWnd)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CSakDataWnd() {};

    // Generated message map functions
#define WM_SAKDATA_UPDATE_ALL_VIEWS ( WM_USER + 1 )
#define WM_SAKDATA_REFRESH_NODE     ( WM_USER + 2 )
    void PostUpdateAllViews( MMC_COOKIE Cookie );
    void PostRefreshNode( MMC_COOKIE Cookie );

protected:
    //{{AFX_MSG(CSakDataWnd)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    virtual LONG OnUpdateAllViews( UINT, IN LONG lParam );
    virtual LONG OnRefreshNode( UINT, IN LONG lParam );
    DECLARE_MESSAGE_MAP()
};


class CSakDataNodePrivate
{
public:
    CSakDataNodePrivate( ISakNode* pNode );
    ~CSakDataNodePrivate( );

    static HRESULT Verify( CSakDataNodePrivate* pNodePriv );


    DWORD             m_Magic;
    CComPtr<ISakNode> m_pNode;
};
#define RS_NODE_MAGIC_GOOD     ((DWORD)0xF0E1D2C3)
#define RS_NODE_MAGIC_DEFUNCT  ((DWORD)0x4BADF00D)

/////////////////////////////////////////////////////////////////////////////
// COM class representing the SakSnap snapin object
class ATL_NO_VTABLE CSakData : 
    public IComponentData,      // Access to cached info
    public IExtendPropertySheet2,// add pages to the property sheet of an item.
    public IExtendContextMenu,  // add items to context menu of an item
    public ISnapinHelp2,        // Add support for HTMLHelp
    public IDataObject,         // To support data object queries.
    public ISakSnapAsk,         // provided so that nodes can query snapin info
    public IPersistStream,
    public CComObjectRoot      // handle object reference counts for objects
//  public CComCoClass<CSakData,&CLSID_HsmAdminData>
{
public:
    CSakData() {};

BEGIN_COM_MAP(CSakData)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendPropertySheet2)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(ISakSnapAsk)
    COM_INTERFACE_ENTRY(ISnapinHelp)
    COM_INTERFACE_ENTRY(ISnapinHelp2)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

static UINT    m_cfMultiSelect;
static UINT    m_cfObjectTypes;

public:
    virtual const CLSID& GetCoClassID() = 0;
    virtual const BOOL IsPrimaryImpl() = 0;

public:
    static UINT m_nImageArray[RS_SCOPE_IMAGE_ARRAY_MAX];
    static INT  m_nImageCount;

// IComponentData
public:
    STDMETHOD( Initialize )      ( IUnknown* pUnk );
    STDMETHOD( CreateComponent ) ( IComponent** ppComponent );
    STDMETHOD( Notify )          ( IDataObject* pDataObject, MMC_NOTIFY_TYPE, LPARAM arg, LPARAM param );
    STDMETHOD( Destroy )         ( void );
    STDMETHOD( QueryDataObject ) ( MMC_COOKIE cookie, DATA_OBJECT_TYPES, IDataObject** ppDataObject);
    STDMETHOD( GetDisplayInfo )  ( SCOPEDATAITEM* pScopeItem);
    STDMETHOD( CompareObjects )  ( IDataObject* pDataObjectA, IDataObject* pDataObjectB);

// IExtendPropertySheet interface
public:
    STDMETHOD( CreatePropertyPages )( LPPROPERTYSHEETCALLBACK lpProvider, RS_NOTIFY_HANDLE handle, LPDATAOBJECT lpIDataObject );
    STDMETHOD( QueryPagesFor )      ( LPDATAOBJECT lpDataObject );

// IExtendPropertySheet2 interface
public:
    STDMETHOD( GetWatermarks )   ( IN LPDATAOBJECT pDataObject, OUT HBITMAP* pWatermark, OUT HBITMAP* pHeader, OUT HPALETTE* pPalette, OUT BOOL* pStretch );

// IExtendContextMenu 
public:
    STDMETHOD( AddMenuItems )    ( IDataObject* pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG* pInsertionAllowed );
    STDMETHOD( Command )         ( long nCommandID, IDataObject* pDataObject );

// ISnapinHelp2 
public:
    STDMETHOD( GetHelpTopic )    ( LPOLESTR * pHelpTopic );
    STDMETHOD( GetLinkedTopics ) ( LPOLESTR * pHelpTopic );

// IDataObject methods
public:
    // Implemented
    STDMETHOD( SetData )         ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease );
    STDMETHOD( GetData )         ( LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium );
    STDMETHOD( GetDataHere )     ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium );
    STDMETHOD( EnumFormatEtc )   ( DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc );

// IPersistStream methods
    STDMETHOD( Save )( IStream *pStm, BOOL fClearDirty ); 
    STDMETHOD( Load )( IStream *pStm );
    STDMETHOD( IsDirty )(void); 
    STDMETHOD( GetSizeMax )( ULARGE_INTEGER *pcbSize ); 
    STDMETHOD( GetClassID )( CLSID *pClassID ); 

    // Not Implemented
private:
    STDMETHOD( QueryGetData )    ( LPFORMATETC /*lpFormatetc*/ ) { return E_NOTIMPL; };
    STDMETHOD( GetCanonicalFormatEtc ) ( LPFORMATETC /*lpFormatetcIn*/, LPFORMATETC /*lpFormatetcOut*/ ) { return E_NOTIMPL; };
    STDMETHOD( DAdvise )         ( LPFORMATETC /*lpFormatetc*/, DWORD /*advf*/, LPADVISESINK /*pAdvSink*/, LPDWORD /*pdwConnection*/ ) { return E_NOTIMPL; };
    STDMETHOD( DUnadvise )       ( DWORD /*dwConnection*/ ) { return E_NOTIMPL; };
    STDMETHOD( EnumDAdvise )     ( LPENUMSTATDATA* /*ppEnumAdvise*/ ) { return E_NOTIMPL; };


// ISakSnapAsk interface members
public:
    STDMETHOD( GetNodeOfType )    ( REFGUID nodetype, ISakNode** ppUiNode );
    STDMETHOD( GetHsmServer )     ( IHsmServer** ppHsmServer );
    STDMETHOD( GetRmsServer )     ( IRmsServer** ppRmsServer );
    STDMETHOD( GetFsaServer )     ( IFsaServer** ppFsaServer );
    STDMETHOD( RefreshNode )      ( ISakNode* pNode );
    STDMETHOD( UpdateAllViews )   ( ISakNode* pUnkNode );
    STDMETHOD( ShowPropertySheet )( ISakNode* pUnkNode, IDataObject *pDataObject, INT initialPage );
    STDMETHOD( GetHsmName )       ( OUT OLECHAR ** pszName OPTIONAL );
    STDMETHOD( GetState )         ();
    STDMETHOD( Disable )          ( IN BOOL Disable = TRUE );
    STDMETHOD( IsDisabled )       ( );
    STDMETHOD( CreateWizard )     ( IN ISakWizard * pWizard );
    STDMETHOD( DetachFromNode )   ( IN ISakNode* pNode );

// Pseudo Constructor / Destructor
public:
    HRESULT FinalConstruct();
    void    FinalRelease();
    ULONG InternalAddRef( );
    ULONG InternalRelease( );


// helper method utilized by Data Object Functions 
private:
    HRESULT Retrieve            ( const void* pBuffer, DWORD len, LPSTGMEDIUM lpMedium );
    HRESULT RetrieveDisplayName ( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveNodeTypeData( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveNodeTypeStringData( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveClsid       ( LPSTGMEDIUM lpMedium );

    static UINT    m_cfDisplayName;
    static UINT    m_cfNodeType;
    static UINT    m_cfNodeTypeString;  
    static UINT    m_cfClassId;

// Methods to work with the image lists
private:
    HRESULT OnAddImages();

// Methods to work between cookie, DataObject, and ISakNode*
public:
    HRESULT GetBaseHsmFromDataObject    ( IDataObject * pDataObject, ISakNode ** ppBaseHsm, IEnumGUID **ppObjectId = NULL, IEnumUnknown **ppUnkNode = NULL );
    HRESULT GetBaseHsmFromCookie        ( MMC_COOKIE Cookie, ISakNode ** ppBaseHsm );
    HRESULT GetDataObjectFromBaseHsm    ( ISakNode * pBaseHsm, IDataObject**ppDataObject );
    HRESULT GetDataObjectFromCookie     ( MMC_COOKIE Cookie, IDataObject**ppDataObject );
    HRESULT GetCookieFromBaseHsm        ( ISakNode * pBaseHsm, MMC_COOKIE * pCookie );
    HRESULT IsDataObjectMs              ( IDataObject *pDataObject );
    HRESULT IsDataObjectOt              ( IDataObject *pDataObject );
    HRESULT IsDataObjectMultiSelect     ( IDataObject *pDataObject );

// Helpers for un-ravelling multi-select data objects
private:
    HRESULT GetBaseHsmFromMsDataObject  ( IDataObject * pDataObject, ISakNode ** ppBaseHsm, IEnumGUID ** ppObjectId, IEnumUnknown **ppEnumUnk );
    HRESULT GetBaseHsmFromOtDataObject  ( IDataObject * pDataObject, ISakNode ** ppBaseHsm, IEnumGUID ** ppObjectId, IEnumUnknown **ppEnumUnk );

// Methods to work with nodes as data objects
private:
    HRESULT SetContextType           ( IDataObject* pDataObject, DATA_OBJECT_TYPES type );

// Notify event handlers
protected:
    HRESULT OnFolder        ( IDataObject *pDataObject, LPARAM arg, LPARAM param );
    HRESULT OnShow          ( IDataObject *pDataObject, LPARAM arg, LPARAM param );
    HRESULT OnSelect        ( IDataObject *pDataObject, LPARAM arg, LPARAM param );
    HRESULT OnMinimize      ( IDataObject *pDataObject, LPARAM arg, LPARAM param );
    HRESULT OnContextHelp   ( IDataObject *pDataObject, LPARAM arg, LPARAM param );
    HRESULT OnRemoveChildren( IDataObject *pDataObject );

    HRESULT RemoveChildren( ISakNode *pNode );

// Handle posted (delayed) messages from nodes.
public:
    HRESULT InternalUpdateAllViews( MMC_COOKIE Cookie );
    HRESULT InternalRefreshNode( MMC_COOKIE Cookie );
    HRESULT RefreshNodeEx( ISakNode * pNode );

private:    
    // Initialize the root node 
    HRESULT InitializeRootNode( void );

    // Guarantee that the children of a particular node are created in our hierarchical list.
    friend class CSakSnap;
    HRESULT EnsureChildrenAreCreated( ISakNode* pNode );
    HRESULT CreateChildNodes( ISakNode* pNode );

    // Enumerate the children of a node in scope pane.
    HRESULT EnumScopePane( ISakNode* pNode, HSCOPEITEM pParent );
    HRESULT FreeEnumChildren( ISakNode* pBaseHsmParent );

// Connection helper functions
    HRESULT AffirmServiceConnection(INT ConnType);
    HRESULT VerifyConnection(INT ConnType);
    HRESULT ClearConnections( );
    HRESULT RawConnect(INT ConnType);
    HRESULT RunSetupWizard(IHsmServer * pServer );
    HRESULT RetargetSnapin( );

// About Helper functions
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);

// Internal Data
private:
    static UINT m_CFMachineName;
    HRESULT GetServerFocusFromDataObject(IDataObject *pDataObject, CString& HsmName);

    // Interface pointers
    CComPtr<IConsole>          m_pConsole;        // Console's IFrame interface
    CComPtr<IConsoleNameSpace> m_pNameSpace;      // SakSnap interface pointer to scope pane
    CComPtr<IImageList>        m_pImageScope;     // SakSnap interface pointer to scope pane image list
    CComPtr<ISakNode>          m_pRootNode;       // Node tree root

    CComPtr<IHsmServer>        m_pHsmServer;      // Hsm Engine pointer
    CComPtr<IRmsServer>        m_pRmsServer;      // Rms pointer
    CComPtr<IFsaServer>        m_pFsaServer;      // Fsa pointer

    CString                    m_HsmName;         // name of Hsm to connect to.
    BOOL                       m_ManageLocal;     // To know if we should manage the local server.
    BOOL                       m_PersistManageLocal;  // To know if snapin configuration is transient.
    BOOL                       m_RootNodeInitialized; // To know if we need to init node on expand

    // Persistence data and functions
    BOOL                    m_IsDirty;

    // Store user profile data for the listviews in the property sheets
    // Note: result view data is stored in CSakSnap
//  COLUMN_WIDTH_SET_PROP_PAGE m_ListViewWidths[MAX_LISTVIEWS];
//  USHORT m_cListViewWidths;


    void SetDirty( BOOL b = TRUE ) { m_IsDirty = b; }
    void ClearDirty() { m_IsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_IsDirty; }

    BOOL m_State;
    void SetState( BOOL State );
    BOOL m_FirstTime;
    BOOL m_Disabled;

    // Variables to track RMS's state separately, since it can be delayed
    // in coming up when other services are OK
    HRESULT m_HrRmsConnect;

// Static functions
public:
    static INT AddImage( UINT rId );

//
// Command Line parsing functions
//  
private:
    class CParamParse : public CCommandLineInfo {

    public:
        CParamParse( ) : m_ManageLocal( 0 ), m_SetHsmName( 0 ), m_SetManageLocal( 0 ), m_SetPersistManageLocal( 0 ) { }

        virtual void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );

        CString m_HsmName;
        BOOL    m_ManageLocal;
        BOOL    m_PersistManageLocal;

        BOOL    m_SetHsmName;
        BOOL    m_SetManageLocal;
        BOOL    m_SetPersistManageLocal;

        static const CString m_DsFlag;

    };

    CParamParse m_Parse;

    void InitFromCommandLine( );
    
    CSakDataWnd *m_pWnd;
};


class CSakDataPrimaryImpl : public CSakData,
    public CComCoClass<CSakDataPrimaryImpl, &CLSID_HsmAdminDataSnapin>
{
public:
    DECLARE_REGISTRY_RESOURCEID(IDR_HsmAdminDataSnapin)
    virtual const CLSID & GetCoClassID() { return CLSID_HsmAdminDataSnapin; }
    virtual const BOOL IsPrimaryImpl() { return TRUE; }
};

class CSakDataExtensionImpl : public CSakData,
    public CComCoClass<CSakDataExtensionImpl, &CLSID_HsmAdminDataExtension>
{
public:
    DECLARE_REGISTRY_RESOURCEID(IDR_HsmAdminDataExtension)
    virtual const CLSID & GetCoClassID(){ return CLSID_HsmAdminDataExtension; }
    virtual const BOOL IsPrimaryImpl() { return FALSE; }
};

/////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\csaksnap.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CSakSnap.cpp

Abstract:

    This component implements the IComponent interface for
    the snapin. Primarily it is responsible for handling the
    result view panes.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/

#include "stdafx.h"
#include "CSakSnap.h"
#include "CSakData.h"
#include "MsDatObj.h"


UINT CSakSnap::m_nImageArray[RS_RESULT_IMAGE_ARRAY_MAX];
INT  CSakSnap::m_nImageCount = 0;

STDMETHODIMP
CSakSnap::GetResultViewType(
    IN  MMC_COOKIE Cookie,
    OUT BSTR* ppViewType,
    OUT long* pViewOptions
    )
/*++

Routine Description:

    Determine what the type of the result view will be:

Arguments:

    pUnk            - Base IUnknown of console

Return Value:

    S_OK    : either an OCX CLSID string or a URL path.
    S_FALSE : default list view will be used.

--*/
{
    WsbTraceIn( L"CSakSnap::GetResultViewType", L"Cookie = <0x%p>, ppViewType = <0x%p>, pViewOptions = <0x%p>", Cookie, ppViewType, pViewOptions );

    HRESULT hr = S_FALSE;

    try {

        CComPtr<ISakNode> pSakNode;
        WsbAffirmHr( m_pSakData->GetBaseHsmFromCookie( Cookie, &pSakNode ) );


        //
        // Use default view
        //

        *ppViewType = 0;
        *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
        hr = S_FALSE;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::GetResultViewType", L"hr = <%ls>, *ppViewType = <%ls>, *pViewOptions = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( ppViewType ), WsbPtrToPtrAsString( (void**)pViewOptions ) );
    return( hr );
}


STDMETHODIMP
CSakSnap::Initialize(
    IN  IConsole * lpConsole
    )
/*++

Routine Description:

    Called when the user first clicks on node to show result pane.

Arguments:

    pUnk            - Base IUnknown of console

Return Value:

    S_OK            - Correctly initialized.

    E_xxxxxxxxxxx   - Unable to initialize.

--*/
{
    WsbTraceIn( L"CSakSnap::Initialize", L"lpConsole = <0x%p>", lpConsole );

    HRESULT hr = S_OK;
    try {

        //
        // validity check on parameters
        //

        WsbAffirmPointer( lpConsole );

        //
        // Save the IConsole pointer 
        //

        m_pConsole = lpConsole;

        //
        // Save the result image list
        // MS seems to QI for this instead of call
        // 'QueryResultImageList'
        //

        WsbAffirmHr( m_pConsole->QueryInterface( IID_IImageList, (void**)&m_pImageResult ) );
        // WsbAffirmHr( m_pConsole->QueryResultImageList( &m_pImageResult ) );

        //
        // Save the result data pointer
        //
        WsbAffirmHr( m_pConsole->QueryInterface( IID_IResultData, (void**)&m_pResultData ) );
        // Save the ConsolveVerb pointer
//      WsbAffirmHr( m_pConsole->QueryInterface( IID_IConsoleVerb, (void **)&m_pConsoleVerb ) );
        WsbAffirmHr (m_pConsole->QueryConsoleVerb(&m_pConsoleVerb));

 
        //
        // Get the header interface
        //

        WsbAffirmHr( m_pConsole->QueryInterface( IID_IHeaderCtrl, (void**)&m_pHeader ) );

        //
        // Give the console the header control interface pointer
        //

        WsbAffirmHr( m_pConsole->SetHeader( m_pHeader ) );

    } WsbCatch( hr);

    WsbTraceOut( L"CSakSnap::Initialize", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}





STDMETHODIMP
CSakSnap::Notify(
    IN  IDataObject*    pDataObject,
    IN  MMC_NOTIFY_TYPE event,
    IN  LPARAM            arg,
    IN  LPARAM            param
    )
/*++

Routine Description:

    Handle user clicks on nodes in the result view, along with other
    MMC notices.

Arguments:

    pDataObject     - Data Object for which event occured

    event           - The event type

    arg, param      - Info for event (depend on type)

Return Value:

    S_OK            - Notification handled without error.

    E_xxxxxxxxxxx   - Unable to register server.

--*/
{
    WsbTraceIn( L"CSakSnap::Notify", L"pDataObject = <0x%p>, event = <%ls>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, RsNotifyEventAsString( event ), arg, arg, param, param );
    CComPtr <IDataObject> pTempDataObject;
    HRESULT hr = S_OK;

    try {

        CComPtr<ISakNode> pBaseHsm;
        CComPtr <ISakSnapAsk> pSakSnapAsk;

        
        switch( event ) {

        case MMCN_PROPERTY_CHANGE:
            WsbAffirmHr( m_pSakData->GetDataObjectFromCookie( param, &pTempDataObject ) );
            WsbAffirmHr( OnChange( pTempDataObject, arg, 0L ) );
            break;

        // This node was expanded or contracted in the scope pane (the user 
        // clicked on the actual node
        case MMCN_SHOW:
            WsbAffirmHr( OnShow(pDataObject, arg, param) );
            break;
        
        // Not implemented
        case MMCN_SELECT:
            WsbAffirmHr( OnSelect(pDataObject, arg, param) );
            break;
        
        // Not implemented
        case MMCN_MINIMIZED:
            WsbAffirmHr( OnMinimize(pDataObject, arg, param) );
            break;
                
        case MMCN_ADD_IMAGES:
            WsbAffirmHr( OnAddImages() );
            break;

        case MMCN_VIEW_CHANGE:
            WsbAffirmHr ( OnChange(pDataObject, arg, param) );
            break;

        case MMCN_CLICK:
            break;

        case MMCN_DBLCLICK:
            //
            // return S_FALSE so that auto-expansion takes place
            //
            hr = S_FALSE;
            break;

        case MMCN_DELETE:
            WsbAffirmHr( OnDelete(pDataObject, arg, param) );
            break;

        case MMCN_REFRESH:
            WsbAffirmHr( OnRefresh(pDataObject, arg, param) );
            break;

        case MMCN_CONTEXTHELP:
            WsbAffirmHr( m_pSakData->OnContextHelp( pDataObject, arg, param ) );
            break;

        // Note - Future expansion of notify types possible
        default:
//          WsbThrow( S_FALSE );  // Handle new messages
            break;
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::Notify", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakSnap::Destroy(
    MMC_COOKIE Cookie
    )
/*++

Routine Description:

    Called to force the release of any owned objects and
    to clear all views.

Arguments:

    cookie          - Not used.

Return Value:

    S_OK            - Correctly tore down.

    E_xxxxxxxxxxx   - Failure occurred (not meaningful).

--*/
{
    WsbTraceIn( L"CSakSnap::Destroy", L"Cookie = <0x%p>", Cookie );

    HRESULT hr = S_OK;

    try {

        // This is a straight C++ pointer, so null it out
        m_pSakData = 0;


        // Release the interfaces that we QI'ed
        if( m_pToolbar && m_pControlbar ) {
            m_pControlbar->Detach( m_pToolbar );
        }
        if( m_pConsole ) {
            m_pConsole->SetHeader( 0 );
        }

        m_pToolbar.Release();
        m_pControlbar.Release();
        m_pHeader.Release();
        m_pResultData.Release();
        m_pImageResult.Release();
        m_pConsoleVerb.Release();
        m_pConsole.Release( );


    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::Destroy", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakSnap::QueryDataObject(
    IN  MMC_COOKIE              cookie,
    IN  DATA_OBJECT_TYPES type, 
    OUT IDataObject**     ppDataObject
    )
/*++

Routine Description:

    Called by the console when it needs data for a particular node.
    Since each node is a data object, its IDataObject interface is
    simply returned. The console will later pass in this dataobject to 
    SakSnap help it establish the context under which it is being called.

Arguments:

    cookie          - Node which is being queried.

    type            - The context under which a dataobject is being requested.

    ppDataObject    - returned data object.

Return Value:

    S_OK            - Data Object found and returned.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{

    WsbTraceIn( L"CSakSnap::QueryDataObject", L"cookie = <0x%p>, type = <%d>, ppDataObject = <0x%p>", cookie, type, ppDataObject );

    HRESULT hr = S_OK;

    try {
        //
        // If multi select, we create and return a special data object
        //
        if( ( MMC_MULTI_SELECT_COOKIE == cookie ) ) {
            HRESULT hrInternal = S_OK;

            RESULTDATAITEM item;
            item.mask = RDI_STATE;
            item.nState = LVIS_SELECTED;
            item.nIndex = -1;

            // Create a Com object
            CComObject <CMsDataObject> * pMsDataObject = new CComObject <CMsDataObject>;
            pMsDataObject->FinalConstruct();
            pMsDataObject->AddRef(); // zzzzz

            // Get the IDataObject pointer to pass back to the caller
            WsbAffirmHr (pMsDataObject->QueryInterface (IID_IDataObject, (void **) ppDataObject));

            // Go through the selected nodes in the result pane and add their node pointers
            // and GUIDs to the Data object.
            while (hrInternal == S_OK) {
                hrInternal = m_pResultData->GetNextItem (&item);
                if (hrInternal == S_OK) {
                    CComPtr<ISakNode> pSakNode;
                    WsbAffirmHr( m_pSakData->GetBaseHsmFromCookie( item.lParam, &pSakNode ) );
                    WsbAffirmPointer( pSakNode );
                    WsbAffirmHr( pMsDataObject->AddNode( pSakNode ) );
                }
            } // while

        } else {

            //
            // Delegate to SakData
            //

            WsbAffirmHr (m_pSakData->QueryDataObject( cookie, type, ppDataObject ));
        }
    } WsbCatch (hr);

    WsbTraceOut( L"CSakSnap::QueryDataObject", L"hr = <%ls>, *ppDataObject = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppDataObject ) );
    return( hr );
}

void
CSakSnap::FinalRelease(
    void
    )
/*++

Routine Description:

    Called on final release in order to clean up all members.

Arguments:

    none.

Return Value:

    none.

--*/
{
    WsbTraceIn( L"CSakSnap::FinalRelease", L"" );
    WsbTraceOut( L"CSakSnap::FinalRelease", L"" );
}


HRESULT
CSakSnap::FinalConstruct(
    void
    )
/*++

Routine Description:

    Called during initial CSakSnap construction to initialize members.

Arguments:

    none.

Return Value:

    S_OK            - Initialized correctly.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::FinalConstruct", L"" );

    HRESULT hr = CComObjectRoot::FinalConstruct( );

    m_ActiveNodeCookie = 0;
    m_pEnumeratedNode = NULL;

    //
    // Initialize column widths to 0
    //
    for( INT i = 0; i < BHSM_MAX_NODE_TYPES; i++ ) {

        m_ChildPropWidths[ i ].nodeTypeId = GUID_NULL;
        m_ChildPropWidths[ i ].colCount = 0;

        for ( INT j = 0; j < BHSM_MAX_CHILD_PROPS; j++ ) {

            m_ChildPropWidths[ i ].columnWidths[ j ] = 0;

        }
    }
    m_cChildPropWidths = 0;

    WsbTraceOut( L"CSakSnap::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakSnap::InitResultPaneHeaders(
    ISakNode* pNode
    )
/*++

Routine Description:

    This functions sets up the result view header titles and widths. 
    It should be called immediately prior to populating the result view.

Arguments:

    pNode - Node whose contents will be shown.

Return Value:

    S_OK            - Initialized correctly.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::InitResultPaneHeaders", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;
    BOOL bGotSavedWidths = FALSE;
    CComPtr<IEnumString> pEnumStr;

    try {

        WsbAffirmPointer( m_pHeader );
        WsbAffirmPointer( pNode );

        // Clean out any old columns in the result pane
        hrInternal = S_OK;
        while ( hrInternal == S_OK ) {
            hrInternal = m_pHeader->DeleteColumn( 0 );
        }

        // Get saved column widths (from CSakSnap) (they may not exist). 

        INT columnWidths [ BHSM_MAX_CHILD_PROPS ];
        INT colCount;
        hrInternal = GetSavedColumnWidths( pNode, &colCount, columnWidths );
        if( hrInternal == S_OK ) {

            bGotSavedWidths = TRUE;

        }

        // Enumerate child display property column widths and create the columns with the correct
        // widths (but wrong titles). 
        WsbAffirmHr( pNode->EnumChildDisplayPropWidths( &pEnumStr ) );
        if( pEnumStr )  {

            OLECHAR* str;
        
            // loop over the columns of display properties to get their widths.
            INT nCol = 0;
            while( pEnumStr->Next( 1, &str, NULL ) == S_OK ) {
            
                // Set the the next column width.  Sometimes we may display more columns
                // than were saved - if so use the resource string for those columns.  We
                // don't throw errors because this function can get called when (I think)
                // when the scope pane is displaying the nodes in the result pane and the 
                // header functions will fail.

                if( bGotSavedWidths && ( nCol < colCount ) ) {

                    hrInternal = m_pHeader->InsertColumn( nCol, str, LVCFMT_LEFT, columnWidths[ nCol ]  );

                } else {

                    hrInternal = m_pHeader->InsertColumn( nCol, str, LVCFMT_LEFT, MMCLV_AUTO );

                }
                nCol++;
                CoTaskMemFree( str );
                str = 0;
            }
        
        } else {
        
            hr = S_FALSE;
        
        }
        
        // Enumerate child display titles and use as correct column titles.
        pEnumStr = NULL;
        pNode->EnumChildDisplayTitles( &pEnumStr );
        if( pEnumStr )  {
        
            OLECHAR* str;
        
            // loop over the columns of display properties to get their titles.
            INT nCol = 0;
            while( pEnumStr->Next( 1, &str, NULL ) == S_OK ) {
        
                // Reset the strings in the titles of the headers. For some reason, it is NOW
                // acting as if 0 based.
                WsbAffirmHr( m_pHeader->SetColumnText( nCol, str ) );
                nCol++;

                CoTaskMemFree( str );
                str = 0;
            }
        
        } else {
        
            hr = S_FALSE;
        
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::InitResultPaneHeaders", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}


STDMETHODIMP
CSakSnap::GetDisplayInfo(
    IN OUT RESULTDATAITEM * pResult
    )
/*++

Routine Description:

    When MMC is told to call back concerning resultview items,
    we receive a call here to fill in missing information (once per "cell" 
    in the columns and rows of a "listview" style of result view).  
    
    Note that the snapin manager automatically calls this method for the items 
    appearing in the scope pane to render them in the result pane, and then it is 
    called again for the items that appear only in the result pane as a result of 
    our establishing the callback in EnumResultView.

Arguments:

    pResult         - RESULTDATAITEM structure representing state of the node
                      in the result listview.

Return Value:

    S_OK            - Struct filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    static CWsbStringPtr tmpString;

    WsbTraceIn( L"CSakSnap::GetDisplayInfo", L"cookie = <0x%p>, pScopeItem->mask = <0x%p>, pResult->nCol = <%d>", pResult->lParam, pResult->mask, pResult->nCol );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pResult );
        
        CComPtr<ISakNode> pNode;    // basehsm interface for the node whose properties are being displayed.
        WsbAffirmHr( m_pSakData->GetBaseHsmFromCookie( pResult->lParam, &pNode ) );
        
        if( pResult->mask & RDI_IMAGE ) {

            WsbAffirmHr( pNode->GetResultIcon( m_pSakData->m_State, &pResult->nImage ) );

        }
        //
        // If the RESULTDATAITEM indicates that it needs a string...
        //
        if( pResult->mask & RDI_STR ) {
        
            //
            // Use the basehsm pointer to get the correct data to populate the listview.
            //

            DISPID             dispid;
            CComPtr<IDispatch> pDisp;       // dispatch interface
            CComPtr<ISakNode>  pParentNode; // basehsm interface for the node's parent
        
            CWsbVariant        varRet;
            CWsbStringPtr      pPropString;
        
            //
            // Prepare an enumerator to look at each child property 
            // (i.e. - column of info). Need to get the list of child properties from
            // the parent of this child.
            //

            CComPtr<IEnumString> pEnum;
            WsbAffirmHr( pNode->GetParent( &pParentNode ));

            //
            // If parentNode == 0, we are displaying our root node in the result pane
            // ( we are extending someone else ).  Since the parent has determined the
            // columns to be name, type and description, we show that.
            //

            if( ! pParentNode ) {

                WsbAffirmHr( EnumRootDisplayProps( &pEnum ) );

            } else {

                WsbAffirmHr( pParentNode->EnumChildDisplayProps( &pEnum ) );

            }
            if( pEnum ) {
        
                //
                // Skip the correct number of columns to access 
                // the exact column that we need.
                //

                if( pResult->nCol > 0 ) {

                    WsbAffirmHr( pEnum->Skip( pResult->nCol ) );

                }
                WsbAffirmHr( pEnum->Next( 1, &pPropString, NULL ) );
        
                //
                // get the dispatch interface for this node
                //
                WsbAffirmHr( pNode->QueryInterface( IID_IDispatch, (void**)&pDisp ) );
        
                DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

                //      
                // convert the property name to a dispatch id that can be invoked.
                // Invoke the interfaces to get the value of the cell.
                //

                WsbAffirmHr( pDisp->GetIDsOfNames( IID_NULL, &(pPropString), 1, LOCALE_USER_DEFAULT, &dispid ));
                WsbAffirmHr( pDisp->Invoke( dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, 
                    &dispparamsNoArgs, &varRet, NULL, NULL) );
                tmpString = (OLECHAR*)varRet;
            }

            pResult->str = tmpString;
        }
    
    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::GetDisplayInfo", L"hr = <%ls>, pResult->str = <%ls>, pResult->nImage = <%ls>", WsbHrAsString( hr ), (RDI_STR & pResult->mask) ? pResult->str : L"N/A", (RDI_IMAGE & pResult->mask) ? WsbLongAsString( pResult->nImage ) : L"N/A" );
    return( hr );
}

HRESULT CSakSnap::EnumRootDisplayProps( IEnumString ** ppEnum )
{
    WsbTraceIn( L"CSakSnap::EnumRootDisplayProps", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    
    CEnumString * pEnum = 0;
    BSTR rgszRootPropIds[] = {L"DisplayName", L"Type", L"Description"};
    INT cRootPropsShow = 3;
    try {

        WsbAffirmPointer( ppEnum );
        WsbAffirm( cRootPropsShow > 0, S_FALSE );

        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumString;
        WsbAffirm( pEnum, E_OUTOFMEMORY );

        WsbAffirmHr( pEnum->FinalConstruct( ) );
        WsbAffirmHr( pEnum->Init( &rgszRootPropIds[0], &rgszRootPropIds[cRootPropsShow], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumString, (void**)ppEnum ) );
        
    } WsbCatchAndDo( hr,
        
        if( pEnum ) delete pEnum;
        
    );

    WsbTraceOut( L"CSakSnap::EnumRootDisplayProps", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// IExtendPropertySheet Implementation. 
//

STDMETHODIMP
CSakSnap::CreatePropertyPages(
    IPropertySheetCallback* pPropSheetCallback, 
    RS_NOTIFY_HANDLE        handle,
    IDataObject*            pDataObject
    )
/*++

Routine Description:

    Console calls this when it is building a property sheet to
    show for a node. It is also called for the data object given
    to represent the snapin to the snapin manager, and should 
    show the initial selection page at that point.

Arguments:

    pPropSheetCallback - MMC interface to use to add page.

    handle          - Handle to MMC to use to add the page.

    pDataObject     - Data object refering to node.

Return Value:

    S_OK            - Pages added.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::CreatePropertyPages", L"pPropSheetCallback = <0x%p>, handle = <0x%p>, pDataObject = <0x%p>", pPropSheetCallback, handle, pDataObject );

    //
    // Delegate to CSakData
    //

    HRESULT hr = m_pSakData->CreatePropertyPages( pPropSheetCallback, handle, pDataObject );

    WsbTraceOut( L"CSakSnap::CreatePropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakSnap::QueryPagesFor(
    IDataObject* pDataObject
    )
/*++

Routine Description:

    This method is called by MMC when it wants to find out if this node
    supports property pages. The answer is yes if:

    1) The MMC context is either for the scope pane or result pane, AND

    2) The node actually DOES have property pages.

    OR

    1) The Data Object is acquired by the snapin manager.

    Return S_OK if it DOES have pages, and S_FALSE if it does NOT have pages.

Arguments:

    pDataObject     - Data object refering to node.

Return Value:

    S_OK            - Pages exist.

    S_FALSE         - No property pages.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::QueryPagesFor", L"pDataObject = <0x%p>", pDataObject );

    HRESULT hr = m_pSakData->QueryPagesFor( pDataObject );

    WsbTraceOut( L"CSakSnap::QueryPagesFor", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}

STDMETHODIMP
CSakSnap::CompareObjects(
    IN  IDataObject* pDataObjectA,
    IN  IDataObject* pDataObjectB
    )
/*++

Routine Description:

    Compare data objects for MMC

Arguments:

    pDataObjectA,     - Data object refering to node.
    pDataObjectB

Return Value:

    S_OK            - Objects represent the same node.

    S_FALSE         - Objects do not represent the same node.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( L"CSakSnap::CompareObjects", L"pDataObjectA = <0x%p>, pDataObjectB = <0x%p>", pDataObjectA, pDataObjectB );

    hr = m_pSakData->CompareObjects( pDataObjectA, pDataObjectB );

    WsbTraceOut( L"CSakSnap::CompareObjects", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}


/////////////////////////////////////////////////////////////////////////////////////////
//
// IPersistStream implementation
//

HRESULT
CSakSnap::Save( 
    IStream *pStm, 
    BOOL fClearDirty 
    )
/*++

Routine Description:

    Save the information we need to reconstruct the root node in the
    supplied stream.

Arguments:

    pStm        I: Console-supplied stream
    fClearDirty I: The console tells us to clear our dirty flag
    
Return Value:

    S_OK         - Saved successfully.
    E_*          - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakSnap::Save", L"pStm = <0x%p>, fClearDirty", pStm, WsbBoolAsString( fClearDirty ) );

    HRESULT hr = S_OK;
    INT index;
    INT jindex;

    try {
        ULONG version = HSMADMIN_CURRENT_VERSION;
        WsbAffirmHr( WsbSaveToStream( pStm, version ) );

        // Get the settings from the currently opened view
        if ( m_pEnumeratedNode ) {
            SaveColumnWidths( m_pEnumeratedNode );
        }

        // Save the number of different nodes
        WsbAffirmHr( WsbSaveToStream ( pStm, m_cChildPropWidths ) );

        // For each different node...
        for ( index = 0; index < m_cChildPropWidths; index++ ) {

            // Save the nodetype and column count
            WsbAffirmHr( WsbSaveToStream ( pStm, m_ChildPropWidths[ index ].nodeTypeId ) );
            WsbAffirmHr( WsbSaveToStream ( pStm, m_ChildPropWidths[ index ].colCount ) );

            // Save the column widths
            for ( jindex = 0; jindex < m_ChildPropWidths[ index ].colCount; jindex++ ) {
                WsbAffirmHr( WsbSaveToStream ( pStm, m_ChildPropWidths[ index ].columnWidths[ jindex ] ) );
            }
        }
    } WsbCatch ( hr );

    WsbTraceOut( L"CSakSnap::Save", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::Load( 
    IStream *pStm
    )
/*++

Routine Description:

    Load the information we need to reconstruct the root node from the
    supplied stream.

Arguments:

    pStm        IConsole-supplied stream
    
Return Value:

    S_OK         - Saved successfully.
    E_*          - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakSnap::Load", L"pStm = <0x%p>", pStm );

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;
    USHORT  nodeCount;
    INT index;
    INT jindex;

    try {
        ULONG version = 0;
        WsbAffirmHr( WsbLoadFromStream( pStm, &version ) );
        WsbAssert( ( version == 1 ), E_FAIL );

        // Set to zero in case we fail part way through
        m_cChildPropWidths = 0;

        // If this fails, it probably means that nothing has been saved yet
        hrInternal = WsbLoadFromStream (pStm, &nodeCount);
        if ( hrInternal == S_OK ) {

            for ( index = 0; index < nodeCount; index++ ) {

                // Retrieve the nodetype and column count
                WsbAffirmHr( WsbLoadFromStream ( pStm, &( m_ChildPropWidths[ index ].nodeTypeId ) ) );
                WsbAffirmHr( WsbLoadFromStream ( pStm, &( m_ChildPropWidths[ index ].colCount ) ) );

                // Retrieve the column widths
                for ( jindex = 0; jindex < m_ChildPropWidths[ index ].colCount; jindex++ ) {
                    WsbAffirmHr( WsbLoadFromStream ( pStm, &( m_ChildPropWidths[ index ].columnWidths[ jindex ] ) ) );
                }
            }
            m_cChildPropWidths = nodeCount;
        }
        WsbTraceOut( L"CSakSnap::Load", L"hr = <%ls>", WsbHrAsString( hr ) );
    } WsbCatch (hr);
    return( hr );
}   

HRESULT
CSakSnap::IsDirty(
    void
    )
/*++

Routine Description:

    The console asks us if we are dirty.

Arguments:

    None
    
Return Value:

    S_OK         - Dirty.
    S_FALSE      - Not Dirty. 

--*/
{
    WsbTraceIn( L"CSakSnap::IsDirty", L"" );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakSnap::IsDirty", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::GetSizeMax( 
    ULARGE_INTEGER *pcbSize
    )
/*++

Routine Description:

    Not currently used by the console

Arguments:

    pcbSize
    
Return Value:

    S_OK

--*/
{
    WsbTraceIn( L"CSakSnap::GetSizeMax", L"" );

    pcbSize->QuadPart = 256;
    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakSnap::GetSizeMax", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::GetClassID( 
    CLSID *pClassID 
    )
/*++

Routine Description:

    Not currently used by the console

Arguments:

    pClassID  - The class ID for the snapin
    
Return Value:

    S_OK
--*/
{
    WsbTraceIn( L"CSakSnap::GetClassID", L"pClassID = <0x%p>", pClassID );

    HRESULT hr = S_OK;
    *pClassID = CLSID_HsmAdmin;

    WsbTraceOut( L"CSakSnap::GetClassID", L"hr = <%ls>, *pClassID = <%ls>", WsbHrAsString( hr ), WsbPtrToGuidAsString( pClassID ) );
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////////
//
// Description: Add the supplied resource ID to the list of resource IDs for
//      the scope pane.  Returns the index into the array.
//
INT CSakSnap::AddImage( UINT rId )
{
    INT nIndex = 1;
    if (CSakSnap::m_nImageCount < RS_RESULT_IMAGE_ARRAY_MAX) {

        CSakSnap::m_nImageArray[CSakSnap::m_nImageCount] = rId;
        nIndex = CSakSnap::m_nImageCount;
        CSakSnap::m_nImageCount++;

    }
    return nIndex;
}

/////////////////////////////////////////////////////////////////////////////
//
// Adds images to the consoles image list from the static array
//
HRESULT CSakSnap::OnAddImages()
{
    HRESULT hr = S_OK;
    HICON hIcon;
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    try {

        //
        // References to the image list are now invalid
        //

        // Put the images from the static array into the image list
        // for the result pane

        for( INT i = 0; i < m_nImageCount; i++) {
            // Load the icon using the resource Id stored in the
            // static array and get the handle.  

            hIcon = LoadIcon( _Module.m_hInst, 
                MAKEINTRESOURCE( m_nImageArray [i] ) );

            // Add to the Console's Image list
            WsbAffirmHr( m_pImageResult->ImageListSetIcon( (RS_WIN32_HANDLE*)hIcon, i) );
        }
    } WsbCatch (hr);
    return hr;
}


HRESULT CSakSnap::SaveColumnWidths( ISakNode *pNode ) 
{
    WsbTraceIn( L"CSakSnap::SaveColumnWidths", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;
    HRESULT hrInternal;
    INT columnWidth;
    GUID nodeTypeGuid;
    BOOL exists = FALSE;
    INT updateIndex = -1;
    INT col;

    try {
        WsbAssertPointer( pNode );

        // Get the type of the supplied node
        WsbAffirmHr( pNode->GetNodeType ( &nodeTypeGuid ) );

        // Search to see if the GUID already has an entry
        for ( INT index = 0; index < m_cChildPropWidths; index++ ) {

            if ( m_ChildPropWidths[ index ].nodeTypeId == nodeTypeGuid ) {

                updateIndex = index;
                exists = TRUE;

            }
        }
        if ( !exists ) {

            // Create a new entry
            WsbAssert( m_cChildPropWidths < BHSM_MAX_NODE_TYPES - 1, E_FAIL );
            updateIndex = m_cChildPropWidths;
            m_ChildPropWidths[ updateIndex ].nodeTypeId = nodeTypeGuid;
            m_cChildPropWidths++;
        }

        // Now set the column widths
         col = 0;
         hrInternal = S_OK;
         while ( hrInternal == S_OK ) {
            hrInternal =  m_pHeader->GetColumnWidth( col, &columnWidth );
            if (hrInternal == S_OK) {
                m_ChildPropWidths[ updateIndex ].columnWidths[ col ] = (USHORT)columnWidth;
                col++;
            }
        }
        // if we failed totally to get column widths, don't wipe out the previous value
        if ( col > 0 ) {
         m_ChildPropWidths[ updateIndex ].colCount = (USHORT)col;
        }
    } WsbCatch (hr);
    WsbTraceOut( L"CSakSnap::SaveColumnWidths", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CSakSnap::GetSavedColumnWidths( ISakNode *pNode, INT *pColCount, INT *pColumnWidths ) 
{
    WsbTraceIn( L"CSakSnap::SaveColumnWidths", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;
    GUID nodeTypeGuid;
    BOOL exists = FALSE;
    INT col;

    try {

        WsbAssertPointer( pNode );

        // Get the type of the supplied node
        WsbAffirmHr( pNode->GetNodeType ( &nodeTypeGuid ) );

        // Search to see if the GUID already has an entry
        for( INT index = 0; index < m_cChildPropWidths; index++ ) {

            if ( m_ChildPropWidths[ index ].nodeTypeId == nodeTypeGuid ) {

                for ( col = 0; col < m_ChildPropWidths[ index ].colCount; col++) {

                    // Return the column widths
                    pColumnWidths[ col ] = m_ChildPropWidths[ index ].columnWidths[ col ];

                }
                *pColCount = m_ChildPropWidths[ index ].colCount;
                exists = TRUE;
            }
        }
        if ( !exists ) {
            return WSB_E_NOTFOUND;
        }
    } WsbCatch (hr);
    WsbTraceOut( L"CSakSnap::SaveColumnWidths", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//


STDMETHODIMP CSakSnap::SetControlbar(LPCONTROLBAR pControlbar)
{
    WsbTraceIn( L"CSakSnap::SetControlbar", L"pControlbar = <0x%p>", pControlbar );

    HRESULT hr = S_OK;

    try {

        //
        // Clear out old controlbar
        //
        if( m_pControlbar && m_pToolbar ) {

            m_pControlbar->Detach( m_pToolbar );

        }
        m_pToolbar.Release( );
        m_pControlbar.Release( );

        //
        // Hold on to the controlbar interface.
        //
        m_pControlbar = pControlbar;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::SetControlbar", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakSnap::ControlbarNotify( MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param )
{
    WsbTraceIn( L"CSakSnap::ControlbarNotify", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_FALSE;

    switch( event ) {

    case MMCN_BTN_CLICK:
        hr = OnToolbarButtonClick( arg, param );
        break;

    case MMCN_DESELECT_ALL:
        break;

    case MMCN_SELECT:
        OnSelectToolbars( arg, param );
        break;

    case MMCN_MENU_BTNCLICK:
//      HandleExtMenus(arg, param);
        break;

    default:
        break;
    }

    WsbTraceOut( L"CSakSnap::ControlbarNotify", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CSakSnap::OnToolbarButtonClick( LPARAM arg, LPARAM cmdId )
{
    WsbTraceIn( L"CSakSnap::OnToolbarButtonClick", L"arg = <0x%p>, cmdId = <%ld>" );
    HRESULT hr = S_OK;


    try {

        IDataObject* pDataObject = (IDataObject*)arg;
        WsbAffirmPointer( pDataObject );

        CComPtr<ISakNode> pNode;
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode ) );

        // Delegate to the node
        WsbAffirmHr( pNode->OnToolbarButtonClick( pDataObject, (LONG)cmdId ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnToolbarButtonClick", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


void CSakSnap::OnSelectToolbars(LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    try {

        BOOL bScope  = (BOOL) LOWORD( arg );
        BOOL bSelect = (BOOL) HIWORD( arg );

        IDataObject* pDataObject = (IDataObject*)param;
        WsbAffirmPointer( pDataObject );

        CComPtr<ISakNode> pNode;
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode ) );

        if( bSelect ) {

            //
            // ATL detaches any existing toolbar before attaching new ones.
            // This appears to fix issues of us adding toolbar upon toolbar
            //
            if( m_pToolbar ) {

                m_pControlbar->Detach( m_pToolbar );
                m_pToolbar.Release( );

            }

            //
            // Does the node have a toolbar?
            //
            if( pNode->HasToolbar() == S_OK ) {

                //
                // Create the toolbar for the indicated node
                //
                WsbAffirmHr( m_pControlbar->Create( TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pToolbar) ) );

                //
                // Returns S_FALSE if there is no toolbar for the node
                //
                if( pNode->SetupToolbar( m_pToolbar ) == S_OK ) {

                    //
                    // Attach the toolbar
                    //
                    WsbAffirmHr( m_pControlbar->Attach( TOOLBAR, (IUnknown*) m_pToolbar ) );

                }

            }

        } else {

            //
            // Destroy the toolbar
            // NOTE: Not done in ATL snapin classes
            //
            if( m_pToolbar ) {

                m_pControlbar->Detach( m_pToolbar );

            }
            m_pToolbar.Release();

       }


    } WsbCatch( hr );
}




STDMETHODIMP
CSakSnap::Compare(
    IN     LPARAM   /*lUserParam*/,
    IN     MMC_COOKIE CookieA,
    IN     MMC_COOKIE CookieB,
    IN OUT int*       pnResult
    )
{
    HRESULT hr = S_OK;

    try {

        //
        // Store column and set result to 'equal' ASAP
        //
        WsbAffirmPointer( pnResult );
        int col = *pnResult;
        *pnResult = 0;

        //
        // And make sure we have a node we know we're showing
        //
        WsbAffirmPointer( m_pEnumeratedNode );


        CComPtr<ISakNode>  pNodeA, pNodeB;
        CComPtr<IDispatch> pDispA, pDispB;
        WsbAffirmHr( m_pSakData->GetBaseHsmFromCookie( CookieA, &pNodeA ) );
        WsbAffirmHr( m_pSakData->GetBaseHsmFromCookie( CookieB, &pNodeB ) );
        WsbAffirmHr( pNodeA.QueryInterface( &pDispA ) );
        WsbAffirmHr( pNodeB.QueryInterface( &pDispB ) );

        CComPtr<IEnumString> pEnum;
        WsbAffirmHrOk( m_pEnumeratedNode->EnumChildDisplayProps( &pEnum ) );

        //
        // Skip the correct number of columns to access 
        // the exact column that we need.
        //
        if( col > 0 ) {

            WsbAffirmHr( pEnum->Skip( col ) );

        }

        CWsbVariant    varRetA, varRetB;
        CWsbStringPtr  pPropString;
        WsbAffirmHrOk( pEnum->Next( 1, &pPropString, NULL ) );
        WsbAffirmHr( pPropString.Append( L"_SortKey" ) );


        //      
        // convert the property name to a dispatch id that can be invoked.
        // Invoke the interfaces to get the value of the cell.
        //
        DISPID     dispid;
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

        WsbAffirmHr( pDispA->GetIDsOfNames( IID_NULL, &(pPropString), 1, LOCALE_USER_DEFAULT, &dispid ));
        WsbAffirmHr(
            pDispA->Invoke(
                dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
                &dispparamsNoArgs, &varRetA, NULL, NULL ) );
        WsbAffirmHr(
            pDispB->Invoke(
                dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
                &dispparamsNoArgs, &varRetB, NULL, NULL ) );

        WsbAffirmPointer( (WCHAR*)varRetA );
        WsbAffirmPointer( (WCHAR*)varRetB );
        *pnResult = _wcsicmp( (WCHAR*)varRetA, (WCHAR*)varRetB );

        //
        // If results are that they are the same (and not first column)
        // than compare the first column (the Name)
        //
        if( ( 0 == *pnResult ) && ( col > 0 ) ) {

            *pnResult = 0; // Compare first Column if same
            WsbAffirmHr( Compare( 0, CookieA, CookieB, pnResult ) );

        }
        WsbTrace( L"CSakSnap::Compare: *pnResult = <%ls>, SortKeyA = <%ls>, SortKeyB = <%ls>\n", WsbPtrToLongAsString( (LONG*)pnResult ), (WCHAR*)varRetA, (WCHAR*)varRetB );

    } WsbCatch( hr );

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\evntdata.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    evntdata.cpp

Abstract:

    This module is responsible for handling the notification
    calls from MMC CSakData.

Author:

    Rohde Wakefield [rohde]   06-Mar-1997

Revision History:

--*/


#include "stdafx.h"
#include "CSakSnap.h"
#include "CSakData.h"

UINT CSakData::m_CFMachineName =
    RegisterClipboardFormat( L"MMC_SNAPIN_MACHINE_NAME" );


HRESULT
CSakData::OnFolder( 
    IN  IDataObject* pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

    Param is the unique identifier ( an HSCOPEITEM of the
    expanding or contracting item )

Arguments:

    pNode           - The node which is expanding.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnFolder", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        // if the arg is TRUE, the node is being expanded.
        if( arg )
        {
            CComPtr<ISakNode> pNode;

            // Get the basehsm out of the data record.  
            GetBaseHsmFromDataObject ( pDataObject, &pNode );

            if( !pNode ) {
                // The dataobject is not one of ours - we must be extending another
                // snapin.

                // Get the root node from UnkRootNode ( it has already been created
                // by Initialize )
                WsbAffirmPointer( m_pRootNode );

                // We're an extension snapin. 
                // Get the server focus from the data object.
                //

                CString hsmName;
                WsbAffirmHr( GetServerFocusFromDataObject( pDataObject, hsmName ) );
                if( hsmName == "" ) {

                    m_ManageLocal = TRUE;
                    m_HsmName = "";

                } else {

                    m_ManageLocal = FALSE;
                    // eliminate starting \\ if there is one.  Computer management
                    // precedes the server name with \\.
                    if( hsmName.Left( 2 ) == L"\\\\" ) {

                        int len = hsmName.GetLength( );
                        m_HsmName = hsmName.Right( len - 2 );

                    } else {

                        m_HsmName = hsmName;

                    }
                }


                // Set the Hsm name in SakData and HsmCom objects
                WsbAffirmHr( InitializeRootNode( ) );

                // Create a scope pane item and insert it
                SCOPEDATAITEM sdi;
 
                ZeroMemory( &sdi, sizeof sdi );
                sdi.mask        = SDI_STR           | 
                                      SDI_PARAM     | 
                                      SDI_IMAGE     | 
                                      SDI_OPENIMAGE |
                                      SDI_PARENT;
                sdi.relativeID  = ( HSCOPEITEM )( param );
                sdi.displayname = MMC_CALLBACK;
                WsbAffirmHr( m_pRootNode->GetScopeCloseIcon( m_State, &sdi.nImage ) );
                WsbAffirmHr( m_pRootNode->GetScopeOpenIcon( m_State, &sdi.nOpenImage ) );

                // This is a special token for the extension root node
                sdi.lParam      = EXTENSION_RS_FOLDER_PARAM;
 
                // Insert the node into the scope pane and save the scope ID
                WsbAffirmHr( m_pNameSpace->InsertItem( &sdi ) );
                WsbAffirmHr( m_pRootNode->SetScopeID( ( HSCOPEITEM )( sdi.ID ) ) );
                m_RootNodeInitialized = TRUE;

 
            } else {

                GUID nodeGuid;
                WsbAffirmHr( pNode->GetNodeType( &nodeGuid ) );
                if( IsEqualGUID( nodeGuid, cGuidHsmCom ) ) {

                    if( !m_RootNodeInitialized ) {

                        m_RootNodeInitialized = TRUE;

                        //
                        // Set the scopeitem in the node
                        //
                        WsbAffirmHr( pNode->SetScopeID( ( HSCOPEITEM )( param ) ) );

                        //
                        // Update the text and icon ( text is wrong if loaded
                        // from file and command line switch given for 
                        // different machine
                        //
                        SCOPEDATAITEM sdi;
 
                        ZeroMemory( &sdi, sizeof sdi );
                        sdi.mask        = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;

                        sdi.ID          = ( HSCOPEITEM )( param );

                        sdi.displayname = MMC_CALLBACK;

                        WsbAffirmHr( pNode->GetScopeCloseIcon( m_State, &sdi.nImage ) );
                        WsbAffirmHr( pNode->GetScopeOpenIcon( m_State, &sdi.nOpenImage ) );

                        WsbAffirmHr( m_pNameSpace->SetItem( &sdi ) );

                    }

                }

                //
                // Initialize child node list prior to graphically enumerating them 
                //

                WsbAffirmHr( EnsureChildrenAreCreated( pNode ) );

                //
                // Param contains the HSCOPEITEM of the node being opened.
                //

                WsbAffirmHr( EnumScopePane( pNode, ( HSCOPEITEM )( param ) ) );
            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::OnFolder", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

////////////////////////////////////////////////////////////////////////////////////
//
// Description: Get the server name from the supplied data object.  The dataobject
//      is implemented by the snapin we are extending
//
HRESULT CSakData::GetServerFocusFromDataObject( IDataObject *pDataObject, CString& HsmName )
{
    HRESULT hr = S_OK;
    try {


        STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
        FORMATETC formatetc = { (CLIPFORMAT)m_CFMachineName, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

         // Allocate memory for the stream

        // Note: we add 2 bytes because Computer Management puts \\ at the 
        // beginning of the computer name. - AHB 12/22/97
        //
        stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof( WCHAR ) * ( MAX_PATH + 1 + 2 ) );

        WsbAffirmPointer( stgmedium.hGlobal )

        // Attempt to get data from the object

        WsbAffirmHr( pDataObject->GetDataHere( &formatetc, &stgmedium ) );

        HsmName = ( OLECHAR * ) stgmedium.hGlobal;

        GlobalFree( stgmedium.hGlobal );

    } WsbCatch ( hr ) ;
    return hr;
}


HRESULT
CSakData::OnShow( 
    IN  IDataObject* pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

    The result view is just about to be shown. 
    Set the headers for the result view.
    Param is the unique identifier ( an HSCOPEITEM ) of the 
    selected or deselected item.

Arguments:

    pNode           - The node which is showing.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnShow", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;
    try {
        CComPtr<ISakNode> pNode;

        // Get the basehsm out of the data record.  
        GetBaseHsmFromDataObject ( pDataObject, &pNode );
        //
        // Arg is TRUE when it is time to enumerate
        //

        if( arg ) {

            //
            // Initialize child node list prior to graphically enumerating them
            //

            WsbAffirmHr( EnsureChildrenAreCreated( pNode ) );

            //
            // Enumerate both the scope and result views. "Param" contains the 
            // HSCOPEITEM of the node being shown.
            //

            WsbAffirmHr( EnumScopePane( pNode, ( HSCOPEITEM )( param ) ) );

        } else {
            //
            // Free data associated with the result pane items, because
            // your node is no longer being displayed.
            // Note: The console will remove the items from the result pane
            //
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::OnShow", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::OnSelect( 
    IN  IDataObject* pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

    Called when a "folder" ( node ) is going to be opened ( not expanded ).
    Param is the unique identifier ( an HSCOPEITEM of the
    expanding or contracting item )

Arguments:

    pNode           - The node which is expanding.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnSelect", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakData::OnSelect", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::OnMinimize( 
    IN  IDataObject* pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:


Arguments:

    pNode           - The node which is expanding.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnMinimize", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakData::OnMinimize", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::OnContextHelp( 
    IN  IDataObject* pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

    Called when help is selected on a node. Shows the top level help.

Arguments:

    pNode           - The node which is requesting help.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnContextHelp", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    try {

        //
        // Get the help interface
        //
        CComPtr<IDisplayHelp> pDisplayHelp;
        WsbAffirmHr( m_pConsole.QueryInterface( &pDisplayHelp ) );

        //
        // Form up the correct name
        //
        CWsbStringPtr helpFile;
        WsbAffirmHr( helpFile.LoadFromRsc( _Module.m_hInst, IDS_HELPFILELINK ) );
        WsbAffirmHr( helpFile.Append( L"::/rss_node_howto.htm" ) );

        //
        // And show it
        //
        WsbAffirmHr( pDisplayHelp->ShowTopic( helpFile ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::OnContextHelp", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::EnumScopePane( 
    IN  ISakNode* pNode,
    IN  HSCOPEITEM pParent
    )
/*++

Routine Description:

    Insert the items into the scopepane under the item which is represented by
    cookie and pParent. 

Arguments:

    pNode           - The node which is expanding.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::EnumScopePane", L"pNode = <0x%p>, pParent = <0x%p>", pNode, pParent );

    HRESULT hr = S_OK;

    try {
        //
        // Verify params
        //

        WsbAffirmPointer( pNode );
        WsbAffirmPointer( pParent );

        //
        // make sure we QI'ed for the interface
        //

        WsbAffirmPointer( m_pNameSpace ); 

        //
        // Avoid enumerating the same node twice. Once enumerated, a node remembers it.
        //

        BOOL isEnumerated;
        WsbAffirmHr( pNode->GetEnumState( &isEnumerated ) );

        if( !isEnumerated ) {

            //
            // This node has NOT been enumerated in the tree.
            //

            if( S_OK == pNode->IsContainer( ) ) {

                CComPtr<IEnumUnknown> pEnum;        // child enumerator object
                CComQIPtr<ISakNode, &IID_ISakNode>     pBaseHsmChild;   // child pointer to BaseHsm interface
            
                // Create an Enumeration object for the children and enumerate them
                WsbAffirmHr( pNode->EnumChildren( &pEnum ) );
            
                CComPtr<IUnknown> pUnkChild;        // pointer to next child in list
            
                while( pEnum->Next( 1, &pUnkChild, NULL ) == S_OK ) {

                    pBaseHsmChild = pUnkChild;

                    WsbAffirmPointer( pBaseHsmChild );


                    //
                    // If this is a leaf node, don't enumerate in scope pane.
                    //

                    if( pBaseHsmChild->IsContainer( ) != S_OK ) {
                    
                        pBaseHsmChild.Release( );
                        pUnkChild.Release( );
                        continue;
                    
                    }
            
                    //
                    // Set up a SCOPEDATAITEM for this child node and insert the child into the scope treeview
                    //

                    SCOPEDATAITEM childScopeItem;
                    memset( &childScopeItem, 0, sizeof( SCOPEDATAITEM ) );
            
                    //
                    // Set String to be callback
                    //

                    childScopeItem.displayname = MMC_CALLBACK;
                    childScopeItem.mask |= SDI_STR;
            
                    //
                    // Add "expandable" indicator to tree node if 
                    // this node has children. Fake out number
                    // of children.
                    //

                    if( pBaseHsmChild->IsContainer( ) == S_OK ) {

                        childScopeItem.cChildren = 1;
                        childScopeItem.mask |= SDI_CHILDREN;

                    }
            
                    //
                    // Set child node's scope item parent.
                    //

                    childScopeItem.relativeID = pParent;
                    childScopeItem.mask |= SDI_PARENT;          

                    //
                    // Set the param in the ScopeItem to the unknown pointer
                    // to this node, so that when this scopeitem is sent back
                    // to us, we can get it out and use it to look up
                    // node-specific info.
                    //

                    WsbAffirmHr( GetCookieFromBaseHsm( pBaseHsmChild, (MMC_COOKIE*)(&childScopeItem.lParam) ) );
                    childScopeItem.mask |= SDI_PARAM;
            
                    childScopeItem.mask |= SDI_STATE;
                    childScopeItem.nState = 0;

                    //
                    // Note - After insertion into the tree, the SCOPEITEM ID member contains the handle to 
                    // the newly inserted item
                    //
                    WsbAffirmHr ( pBaseHsmChild->GetScopeCloseIcon( m_State, &childScopeItem.nImage ) );
                    childScopeItem.mask |= SDI_IMAGE;
                    WsbAffirmHr ( pBaseHsmChild->GetScopeOpenIcon( m_State, &childScopeItem.nOpenImage ) );
                    childScopeItem.mask |= SDI_OPENIMAGE;

                    WsbAffirmHr( m_pNameSpace->InsertItem( &childScopeItem ) );
                    WsbAffirm( childScopeItem.ID != NULL, E_UNEXPECTED );

                    //
                    // Set the scopeitem id in the node object
                    //
                    WsbAffirmHr( pBaseHsmChild->SetScopeID( childScopeItem.ID ) );
            
                    //
                    // release the test interface pointer and string for next node
                    //

                    pBaseHsmChild.Release( );
                    pUnkChild.Release( );
                }

                //
                // Indicate that this node has been enumerated
                //

                WsbAffirmHr( pNode->SetEnumState( TRUE ) );
            }

        }
        
    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::EnumScopePane", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



HRESULT
CSakData::EnsureChildrenAreCreated( 
    IN  ISakNode * pNode
    )
/*++

Routine Description:

    Guarantee that the immediate children of a particular node are created 
    in our hierarchical list of nodes.

Arguments:

    pNode           - The node to check.

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::EnsureChildrenAreCreated", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;

    try {
    
        //
        // Create the node's children if the node's list of children is
        // currently invalid ( i.e. - never created, or out-of-date )
        //

        if( pNode->ChildrenAreValid( ) == S_FALSE ) {

            WsbAffirmHr( CreateChildNodes( pNode ) );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::EnsureChildrenAreCreated", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::OnRemoveChildren(
    IN  IDataObject*    pDataObject
    )
/*++

Routine Description:

Arguments:

    pDataObject           - The node

Return Value:

    S_OK            - Removed successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnRemoveChildren", L"pDataObject = <0x%p>", pDataObject );
    HRESULT hr = S_OK;

    try {

        CComPtr<ISakNode> pNode;
        WsbAffirmHr( GetBaseHsmFromDataObject( pDataObject, &pNode ) );
        WsbAffirmHr( RemoveChildren( pNode ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::OnRemoveChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::RemoveChildren(
    IN  ISakNode*    pNode
    )
/*++

Routine Description:
    Recursively clean up the cookies for this node's children,
    but not this node itself.

Arguments:

    pNode           - The node

Return Value:

    S_OK            - Removed successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::RemoveChildren", L"pNode = <0x%p>", pNode );
    HRESULT hr = S_OK;

    try {

        CComPtr<IEnumUnknown> pEnum;        // child enumerator object
        CComPtr<ISakNode>     pChild;       // child pointer to BaseHsm interface
    
        // Create an Enumeration object for the children and enumerate them
        WsbAffirmHr( pNode->EnumChildren( &pEnum ) );
    
        CComPtr<IUnknown> pUnkChild;        // pointer to next child in list
    
        while( pEnum->Next( 1, &pUnkChild, NULL ) == S_OK ) {

            WsbAffirmHr( pUnkChild.QueryInterface( &pChild ) );

            RemoveChildren( pChild ); // OK to fail and keep going

            DetachFromNode( pChild );

            pUnkChild.Release( );
            pChild.Release( );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::RemoveChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



STDMETHODIMP
CSakData::DetachFromNode(
    IN ISakNode* pNode )
/*++

Routine Description:
    Called when a node is terminating in order for sakdata to remove
    any cookies holding onto node.

Arguments:

    pNode           - The node

Return Value:

    S_OK            - Removed successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::DetachFromNode", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pNode );

        RS_PRIVATE_DATA data;
        WsbAffirmHr( pNode->GetPrivateData( &data ) );

        CSakDataNodePrivate* pNodePriv = (CSakDataNodePrivate*)data;
        if( pNodePriv && SUCCEEDED( CSakDataNodePrivate::Verify( pNodePriv ) ) ) {

            delete pNodePriv;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::DetachFromNode", L"" );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\dlldatax.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    DllDataX.h

Abstract:

    Help wrap dlldata.c

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\evntsnap.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    evntsnap.cpp

Abstract:

    This module is responsible for handling the notification
    calls from MMC for CSakSnap.

Author:

    Rohde Wakefield [rohde]   06-Mar-1997

Revision History:

--*/


#include "stdafx.h"
#include "CSakSnap.h"
#include "CSakData.h"





HRESULT
CSakSnap::OnShow(
    IN  IDataObject*    pDataObject,
    IN  LPARAM            arg,
    IN  LPARAM            param
    )
/*++

Routine Description:

    The result view is just about to be shown. 
    Set the headers for the result view.
    Param is the unique identifier (an HSCOPEITEM) of the 
    selected or deselected item.

Arguments:

    pDataObject           - The node which is showing.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnShow", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );
    HRESULT hr = S_OK;

    try {

        CComPtr<ISakNode> pNode;
        //
        // We've got a regular data object (single select)
        //
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode, NULL ) );

        //
        // Arg is TRUE when it is time to enumerate
        //

        if( arg ) {

            //
            // Initialize child node list prior to graphically enumerating them
            //
            WsbAffirmHr( m_pSakData->EnsureChildrenAreCreated( pNode ) );

            //
            // Show the the node's children column headers in the result view.
            //
            WsbAffirmHr( InitResultPaneHeaders( pNode ) );

            //
            // Enumerate both the scope and result views. "Param" contains the 
            // HSCOPEITEM of the node being shown.
            //
            WsbAffirmHr( EnumResultPane( pNode ) );

        } else {

            //
            // The node is being contracted - save the result pane configuration
            //

            //
            // Save them in CSakSnap for this node
            //
            WsbAffirmHr( SaveColumnWidths( pNode ) );

            //
            // Free data associated with the result pane items, because
            // your node is no longer being displayed.
            // Note: The console will remove the items from the result pane
            //
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnShow", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::OnChange(
    IN  IDataObject*    pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

    Update the scope and result panes from the already existing objects.

Arguments:

    pNode           - The node which is showing.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnChange", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    try {

        CComPtr<ISakNode> pNode;
        MMC_COOKIE cookie;

        //
        // We've got a regular data object (single select)
        //
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode, NULL ) );
        WsbAffirmHr( m_pSakData->GetCookieFromBaseHsm( pNode, &cookie ) );

        //
        // Find out if object is still valid
        //
        if( S_OK == pNode->IsValid( ) ) {

            //
            // Refresh the object itself
            //
            pNode->RefreshObject( );

            //
            // If this node's children are currently enumerated in the result pane, 
            // delete and recreate all children
            //
            if( pNode == m_pEnumeratedNode ) {

                //
                // Re-show the the node's children column headers in the result view.
                // We do this because some views may change the number of columns they show
                //

                //
                // Save the current configuration
                //
                WsbAffirmHr( SaveColumnWidths( pNode ) );

                //
                // Clear out the MMC Result Pane
                //
                WsbAffirmHr( ClearResultPane() );

                //
                // Recreate the headers
                //
                WsbAffirmHr( InitResultPaneHeaders( pNode ) );

                //
                // Refresh the children
                //
                MMC_COOKIE cookie;
                WsbAffirmHr( m_pSakData->GetCookieFromBaseHsm( pNode, &cookie ) );
                WsbAffirmHr( m_pSakData->InternalRefreshNode( cookie ) );

                //
                // Redisplay children in the result pane
                //
                WsbAffirmHr( EnumResultPane( pNode ) );

            } else {

                //
                // If this is the active node (but not displayed in the result pane, 
                //  destroy and recreate it's child nodes
                //
                if( cookie == m_ActiveNodeCookie) {

                    //   
                    // This node's children are not currently in the result pane.
                    // Refresh the children
                    //
                    WsbAffirmHr( m_pSakData->RefreshNode( pNode ) );

                }
            }

            //
            // Is this a leaf node?
            //
            if( pNode->IsContainer() != S_OK ) {

                //
                // Redisplay in the result pane
                // Tell MMC to update the item
                //
                // Get the cookie for the node
                //
                if( cookie > 0 ) {

                    HRESULTITEM itemID;
                    WsbAffirmHr( m_pResultData->FindItemByLParam( cookie, &itemID ) );

                    //
                    // Force the result pane to udpate this item
                    // Note that we have to force an icon update ourselves
                    //
                    RESULTDATAITEM resultItem;
                    memset( &resultItem, 0, sizeof(RESULTDATAITEM) );

                    resultItem.itemID = itemID;
                    WsbAffirmHr( pNode->GetResultIcon( m_pSakData->m_State, &resultItem.nImage ) );
                    resultItem.mask |= RDI_IMAGE;

                    WsbAffirmHr( m_pResultData->SetItem( &resultItem ) );
                    WsbAffirmHr( m_pResultData->UpdateItem( itemID ) );

                }
            }

        } else {

            //
            // Not valid - have parent update
            //
            CComPtr<ISakNode> pParentNode;
            WsbAffirmHr( pNode->GetParent( &pParentNode ) );
            WsbAffirmHr( m_pSakData->UpdateAllViews( pParentNode ) );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnChange", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::OnRefresh(
    IN  IDataObject*    pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

Arguments:

    pNode           - The node

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnRefresh", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    try {

        CComPtr<ISakNode> pNode;
        
        //
        // We've got a regular data object (single select)
        //
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode, NULL ) );
        WsbAffirmHr( m_pSakData->UpdateAllViews( pNode ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnRefresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::OnDelete(
    IN  IDataObject*    pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

Arguments:

    pDataObject           - The node

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnDelete", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;
    CComPtr<ISakNode> pNode;

    try {

        //
        // We've got a regular data object (single select)
        //
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode, NULL ) );
        WsbAffirmHr ( pNode->DeleteObject() );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnDelete", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}




HRESULT
CSakSnap::OnSelect(
    IN  IDataObject*    pDataObject,
    IN  LPARAM            arg,
    IN  LPARAM            param
    )
/*++

Routine Description:

    Called when a node is selected.  If the node is in the scope pane,
    save it as the currently active node.

Arguments:

    pNode           - The 

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnSelect", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );
    BOOL bState;
    BOOL bMultiSelect;
    MMC_CONSOLE_VERB defaultVerb = MMC_VERB_NONE;
    HRESULT hr = S_OK;

    try {

        CComPtr<IEnumGUID> pEnumObjectId;
        CComPtr<ISakNode>  pNode;
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode, &pEnumObjectId ) );
        // If we got back an enumeration, we're doing multi-select
        bMultiSelect = pEnumObjectId ? TRUE : FALSE;

        bState = ( m_pSakData->GetState() == S_OK );

        //
        // Set the verb state for the node
        //
        if( pNode->SupportsProperties( bMultiSelect ) == S_OK ) {

            if( bState || ( pNode->SupportsPropertiesNoEngine() == S_OK) ) {

                //
                // Engine OK - enable
                //
                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, HIDDEN, FALSE ) );
                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE ) );
                defaultVerb = MMC_VERB_PROPERTIES;

            } else { 

                //
                // Engine down - set to disabled
                //
                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, HIDDEN, FALSE ) );
                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, FALSE ) );

            }

        } else {

            WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, HIDDEN, TRUE) );

        }
        

        if( pNode->SupportsRefresh( bMultiSelect ) == S_OK ) {

            if( bState || ( pNode->SupportsRefreshNoEngine() == S_OK ) ) {

                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, HIDDEN, FALSE ) );
                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) );

            } else {

                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, HIDDEN, TRUE ) );

            }

        } else {

            WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, HIDDEN, TRUE ) );

        }
        
        if( pNode->SupportsDelete( bMultiSelect ) == S_OK ) {

            WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_DELETE, HIDDEN, FALSE ) );
            WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, bState ) );

        } else {

            WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_DELETE, HIDDEN, TRUE ) );

        }
            
        //
        // If container, default action should be to open, regardless
        // of any previous work
        //
        if( S_OK == pNode->IsContainer( ) ) {

            defaultVerb = MMC_VERB_OPEN;

        }

        WsbAffirmHr( m_pConsoleVerb->SetDefaultVerb( defaultVerb ) );

        // Standard functionality NOT support by all items
        WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_RENAME, HIDDEN, TRUE ) );
        WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_COPY,   HIDDEN, TRUE ) );
        WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PASTE,  HIDDEN, TRUE ) );
        WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PRINT,  HIDDEN, TRUE ) );
        
        // Extract data from the arg
        BOOL bScope = (BOOL) LOWORD(arg);
        BOOL bSelect = (BOOL) HIWORD(arg);
        
        if( bScope && bSelect ) {

            WsbAffirmHr( m_pSakData->GetCookieFromBaseHsm( pNode, &m_ActiveNodeCookie ) );
        
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnSelect", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakSnap::OnMinimize(
    IN  IDataObject*    pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

Arguments:

    pNode           - The node

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnMinimize", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakSnap::OnMinimize", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



HRESULT
CSakSnap::EnumResultPane(
    IN  ISakNode* pNode
    )
/*++

Routine Description:

    Insert the child items into the result pane. 

Arguments:

    pNode           - The node which is expanding.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::EnumResultPane", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pNode );

        CComPtr<IResultData> pResult;
        WsbAffirmHr( m_pConsole->QueryInterface( IID_IResultData, (void**)&pResult ) );

        //
        // Clear the result pane
        //
        WsbAffirmHr( ClearResultPane() );

        //
        // allocate and initialize a result item.
        //
        RESULTDATAITEM resultItem;
        memset( &resultItem, 0, sizeof(RESULTDATAITEM) );
        
        //
        // Loop through this node's children (just one level deep).
        //
        if( pNode->IsContainer( ) == S_OK ) {

            CComPtr<IEnumUnknown> pEnum;        // child enumerator
            CComPtr<ISakNode>     pNodeChild;   // ISakNode pointer for the child
        
            //
            // Force a fresh list to be used - this way list is updated
            // WRT added or deleted nodes
            //
            if( S_OK == pNode->HasDynamicChildren( ) ) {

                WsbAffirmHr( m_pSakData->FreeEnumChildren( pNode ) );
                WsbAffirmHr( pNode->InvalidateChildren() )
                WsbAffirmHr( pNode->RefreshObject( ) );

            }

            //
            // Enumerate and add in order
            //
            WsbAffirmHr( pNode->EnumChildren( &pEnum ) );
            CComPtr<IUnknown> pUnk;
            int virtIndex = 0;

            HRESULT hrEnum = S_OK;

            while( S_OK == hrEnum ) {

                //
                // Clear these from previous iterations
                //
                pUnk.Release( );
                pNodeChild.Release( );

                //
                // Get the next
                //
                hrEnum = pEnum->Next( 1, &pUnk, NULL );
                WsbAffirmHr( hrEnum );
                    
                //
                // Did we just hit the end of the list?
                //
                if( S_FALSE == hrEnum ) { 

                    continue;

                }

                WsbAffirmHr( RsQueryInterface( pUnk, ISakNode, pNodeChild ) );
                
                //
                // MMC will automatically put in items from the scope
                // pane so do not put these up.
                //
                if( pNodeChild->IsContainer( ) == S_OK ) {

                    continue;

                }

                //
                // Put the first column of info into the result view.
                //
                memset( &resultItem, 0, sizeof(RESULTDATAITEM) );

                resultItem.str = MMC_CALLBACK;
                resultItem.mask |= RDI_STR;
        
                //
                // stuff the child BaseHsm interface in the RESULTDATAITEM lParam.
                //
                WsbAffirmHr( m_pSakData->GetCookieFromBaseHsm( pNodeChild, (MMC_COOKIE*)( &resultItem.lParam ) ) );
                resultItem.mask |= RDI_PARAM;

                WsbAffirmHr( pNodeChild->GetResultIcon( m_pSakData->m_State, &resultItem.nImage ) );
                resultItem.mask |= RDI_IMAGE;

                pResult->InsertItem( &resultItem );

            }
        }

        // Record the fact that this node is showing in the result pane
        m_pEnumeratedNode = pNode;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::EnumResultPane", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


/*++

Routine Description:

    Calls MMC to clear out the result pane.

Arguments:


Return Value:

    S_OK            - OK

    E_xxxxxxxxxxx   - Failure occurred.

--*/
HRESULT CSakSnap::ClearResultPane()
{
    WsbTraceIn( L"CSakSnap::ClearResultPane", L"");
    HRESULT hr = S_OK;

    try {

        CComPtr<IResultData> pResult;
        WsbAffirmHr( m_pConsole->QueryInterface( IID_IResultData, (void**)&pResult ) );
        WsbAffirmHr( pResult->DeleteAllRsltItems( ) );
        m_pEnumeratedNode = NULL;

    } WsbCatch (hr);

    WsbTraceOut( L"CSakSnap::ClearResultPane", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\msdatobj.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MsDatObj.cpp

Abstract:

    Implementation of IDataObject interface for Multi-Select
    Allows MMC to get a list of Node Types

Author:

    Art Bragg 28-Aug-1997

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
//
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "msdatobj.h"

#define BUMP_SIZE 20

// Declare Snap-in NodeType formats:
UINT CMsDataObject::m_cfObjectTypes    = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);

HRESULT
CMsDataObject::FinalConstruct(
    void
    )
/*++

Routine Description:

    Called during initial CMsDataObject construction to initialize members.

Arguments:

    none.

Return Value:

    S_OK            - Initialized correctly.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( L"CMsDataObject::FinalConstruct", L"" );

    try {
        m_Count = 0;

        // Allocate initial array of GUIDs
        m_pGUIDArray = (GUID *) malloc (BUMP_SIZE * sizeof(GUID));
        WsbAffirm ((m_pGUIDArray != NULL), E_OUTOFMEMORY);
        ZeroMemory (m_pGUIDArray, (BUMP_SIZE * sizeof(GUID)));

        m_pUnkNodeArray = (IUnknown **) malloc( BUMP_SIZE * sizeof(IUnknown*) );
        WsbAffirm ((m_pGUIDArray != NULL), E_OUTOFMEMORY);
        ZeroMemory (m_pGUIDArray, (BUMP_SIZE * sizeof(IUnknown*)));

        m_pObjectIdArray = (GUID *) malloc (BUMP_SIZE * sizeof(GUID));
        WsbAffirm ((m_pObjectIdArray != NULL), E_OUTOFMEMORY);
        ZeroMemory (m_pObjectIdArray, (BUMP_SIZE * sizeof(GUID)));

        m_ArraySize = BUMP_SIZE;

        WsbAffirmHr (CComObjectRoot::FinalConstruct( ));
    } WsbCatch (hr);

    WsbTraceOut( L"CMsDataObject::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

void
CMsDataObject::FinalRelease(
    void
    )
/*++

Routine Description:

    Called on final release in order to clean up all members.

Arguments:

    none.

Return Value:

    none.

--*/
{
    WsbTraceIn( L"CMsDataObject::FinalRelease", L"" );

    // Clean up array of GUIDs
    free( m_pGUIDArray );

    for( DWORD  i = 0; i < m_Count; i++ ) {

        m_pUnkNodeArray[i]->Release();

    }

    free( m_pUnkNodeArray );


    WsbTraceOut( L"CMsDataObject::FinalRelease", L"" );
}

// IDataObject

STDMETHODIMP
CMsDataObject::GetDataHere(
    LPFORMATETC lpFormatetc,
    LPSTGMEDIUM /*lpMedium*/
    )
/*++

Routine Description:

    Retrieve information FROM the dataobject and put INTO lpMedium.

Arguments:

    lpFormatetc     - Format to retreive.

    lpMedium        - Storage to put information into.

Return Value:

    S_OK            - Storage filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CMsDataObject::GetDataHere", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CMsDataObject::GetDataHere", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );

}

STDMETHODIMP
CMsDataObject::SetData(
    LPFORMATETC lpFormatetc,
    LPSTGMEDIUM /*lpMedium*/,
    BOOL /*fRelease*/
    )
{
    WsbTraceIn( L"CMsDataObject::SetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CMsDataObject::SetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

///////////////////////////////////////////////////////////////////////
// Note - CMsDataObject does not implement these
///////////////////////////////////////////////////////////////////////

STDMETHODIMP
CMsDataObject::GetData(
    LPFORMATETC lpFormatetcIn,
    LPSTGMEDIUM lpMedium
    )
{
    WsbTraceIn( L"CMsDataObject::GetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetcIn->cfFormat ) );

    HRESULT hr = S_OK;

    lpMedium->tymed          = TYMED_NULL;
    lpMedium->hGlobal        = NULL;
    lpMedium->pUnkForRelease = NULL;

    try {

        //
        // Don't need to throw error if not a format we don't understand - 
        // which is currently only CCF_OBJECT_TYPES_IN_MULTI_SELECT
        //
        if( lpFormatetcIn->cfFormat == m_cfObjectTypes ) {

            //
            // Check to make sure there is data to transfer
            //
            WsbAffirm( ( lpFormatetcIn->tymed & TYMED_HGLOBAL ), DV_E_TYMED );

            //
            // m_ppDataObjects  m_count
            //
            UINT datasize = sizeof(DWORD) + ( sizeof(GUID) * m_Count );
            lpMedium->hGlobal = ::GlobalAlloc( GPTR, datasize );
            WsbAffirmAlloc( lpMedium->hGlobal );

            //
            // Put the count in the allocated memory
            //
            BYTE* pb = reinterpret_cast<BYTE*>(lpMedium->hGlobal);
            *((DWORD*)lpMedium->hGlobal) = m_Count;

            //
            // Copy the GUIDs to the allocated memory
            //
            if( m_Count > 0 ) {

                pb += sizeof(DWORD);
                CopyMemory(pb, m_pGUIDArray, m_Count * sizeof(GUID));

            }

            lpMedium->tymed = TYMED_HGLOBAL;

        } else {

            hr = DATA_E_FORMATETC;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CMsDataObject::GetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CMsDataObject::EnumFormatEtc(DWORD /*dwDirection*/, LPENUMFORMATETC* /*ppEnumFormatEtc*/)
{
    WsbTraceIn( L"CMsDataObject::EnumFormatEtc", L"" );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CMsDataObject::EnumFormatEtc", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT CMsDataObject::RetrieveMultiSelectData (LPSTGMEDIUM lpMedium)
{
    WsbTraceIn( L"CMsDataObject::RetrieveMultiSelectData", L"" );
    HRESULT hr = S_OK;

    try {
        WsbAffirm( lpMedium != NULL, E_POINTER);
        WsbAffirm( lpMedium->tymed == TYMED_HGLOBAL, E_FAIL );

        // Create the stream on the hGlobal passed in. When we write to the stream,
        // it simultaneously writes to the hGlobal the same information.
        LPSTREAM lpStream;
        WsbAffirmHr( CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream ));

        // Write 'len' number of bytes from pBuffer into the stream. When we write
        // to the stream, it simultaneously writes to the global memory we
        // associated it with above.
        ULONG numBytesWritten;

        // Write the count first
        WsbAffirmHr( lpStream->Write(&m_Count, sizeof (m_Count), &numBytesWritten ));

        // Write the GUID array
        WsbAffirmHr( lpStream->Write(m_pGUIDArray, m_Count * sizeof (GUID), &numBytesWritten ));

        // Because we told CreateStreamOnHGlobal with 'FALSE', only the stream is released here.
        // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
        // at the correct time.  This is according to the IDataObject specification.
        lpStream->Release();

    } WsbCatch( hr );

    WsbTraceOut( L"CMsDataObject::RetrieveMultiSelectData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}


// Data setting method
// Note that we keep the node array seperate from the GUID array because
// the GetData interface memory copies the GUID array to the stream.

STDMETHODIMP
CMsDataObject::AddNode (ISakNode *pNode )
{
    WsbTraceIn( L"CMsDataObject::AddNode", L"pNode = <0x%p>", pNode );
    HRESULT hr = S_OK;
    GUID thisGUID;
    GUID objectId;

    GUID * pGUIDArray         = 0,
         * pObjectIdArray     = 0;
    IUnknown ** pUnkNodeArray = 0;


    try {

        //
        // Get the object type GUID
        //
        WsbAffirmHr( pNode->GetNodeType( &thisGUID ) );

        //
        // Get the unique ID for the engine object (i.e. FsaResource)
        //
        WsbAffirmHr( pNode->GetObjectId( &objectId ) );

        //
        // Reallocate if we need to
        //
        if( m_Count >= m_ArraySize ) {


            //
            // Allocate new buffer
            //
            m_ArraySize += BUMP_SIZE;
            pGUIDArray     = (GUID *)      malloc( m_ArraySize * sizeof( GUID ) );
            WsbAffirmAlloc( pGUIDArray ); 
            pUnkNodeArray  = (IUnknown **) malloc( m_ArraySize * sizeof( IUnknown* ) );
            WsbAffirmAlloc( pUnkNodeArray );
            pObjectIdArray = (GUID *)      malloc( m_ArraySize * sizeof( GUID ) );
            WsbAffirmAlloc( pObjectIdArray );

            //
            // copy over old buffer and free
            //
            memcpy( pGUIDArray,     m_pGUIDArray,     m_Count * sizeof( GUID ) );
            memcpy( pUnkNodeArray,  m_pUnkNodeArray,  m_Count * sizeof( IUnknown* ) );
            memcpy( pObjectIdArray, m_pObjectIdArray, m_Count * sizeof( GUID ) );
            free( m_pGUIDArray );
            free( m_pUnkNodeArray );
            free( m_pObjectIdArray );
            m_pGUIDArray     = pGUIDArray;
            m_pUnkNodeArray  = pUnkNodeArray;
            m_pObjectIdArray = pObjectIdArray;
            pGUIDArray     = 0;
            pUnkNodeArray  = 0;
            pObjectIdArray = 0;

        }

        //
        // Put the GUID in the array
        //
        m_pGUIDArray[ m_Count ] = thisGUID;

        //
        // Put the objectId in the array
        //
        m_pObjectIdArray[ m_Count ] = objectId;

        //
        // Put the unknown pointer (the Cookie) in the array
        //
        CComPtr<IUnknown> pUnkNode;
        WsbAffirmHr( RsQueryInterface( pNode, IUnknown, pUnkNode ) );
        pUnkNode.CopyTo( &m_pUnkNodeArray[ m_Count ] );
        m_Count++;

    } WsbCatch( hr );

    if( pGUIDArray )      free( pGUIDArray );
    if( pObjectIdArray )  free( pObjectIdArray );
    if( pUnkNodeArray )   free( pUnkNodeArray );

    WsbTraceOut( L"CMsDataObject::AddNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP 
CMsDataObject::GetNodeEnumerator( IEnumUnknown **ppEnum )
{
    WsbTraceIn( L"CMsDataObject::GetNodeEnumerator", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    CEnumUnknown * pEnum = 0;

    try {

        WsbAffirmPointer( ppEnum );
        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumUnknown;
        WsbAffirm( 0 != pEnum, E_OUTOFMEMORY );
        
        //
        // Initialize it to copy the current node interface pointers
        //
        WsbAffirmHr( pEnum->FinalConstruct() );
        WsbAffirmHr( pEnum->Init( &m_pUnkNodeArray[0], &m_pUnkNodeArray[m_Count], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumUnknown, (void**)ppEnum ) );

    } WsbCatchAndDo( hr,

        if( pEnum ) delete pEnum;

    );

    WsbTraceOut( L"CMsDataObject::GetNodeEnumerator", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}

STDMETHODIMP 
CMsDataObject::GetObjectIdEnumerator( IEnumGUID ** ppEnum )
{
    WsbTraceIn( L"CMsDataObject::GetObjectIdEnumerator", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    CEnumGUID * pEnum = 0;

    try {

        WsbAffirmPointer( ppEnum );
        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumGUID;
        WsbAffirm( 0 != pEnum, E_OUTOFMEMORY );
        
        //
        // Initialize it to copy the current node interface pointers
        //
        WsbAffirmHr( pEnum->FinalConstruct() );
        WsbAffirmHr( pEnum->Init( &m_pObjectIdArray[0], &m_pObjectIdArray[m_Count], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumGUID, (void**)ppEnum ) );

    } WsbCatchAndDo( hr,

        if( pEnum ) delete pEnum;

    );

    WsbTraceOut( L"CMsDataObject::GetObjectIdEnumerator", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\msdatobj.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MsDatObj.h

Abstract:

    Implementation of IDataObject for Multi-Select

Author:

    Art Bragg   28-Aug-1997

Revision History:

--*/

#ifndef MSDATOBJ_H
#define MSDATOBJ_H

class CMsDataObject;

/////////////////////////////////////////////////////////////////////////////
// COM class representing the object
class  ATL_NO_VTABLE CMsDataObject : 
    public IDataObject,
    public IMsDataObject, // Our internal interface to the data object
    public CComObjectRoot      // handle object reference counts for objects
//  public CComCoClass<CMsDataObject, &CLSID_MsDataObject>
{
public:
    CMsDataObject() {
    };

BEGIN_COM_MAP(CMsDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IMsDataObject)
END_COM_MAP()


// DECLARE_REGISTRY_RESOURCEID(IDR_MsDataObject)


// IDataObject methods
public:
    // Implemented
    STDMETHOD( SetData )         ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease );
    STDMETHOD( GetData )         ( LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium );
    STDMETHOD( GetDataHere )     ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium );
    STDMETHOD( EnumFormatEtc )   ( DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc );

    // Not implemented
    STDMETHOD( QueryGetData )              ( LPFORMATETC /*lpFormatetc*/ ) 
    { return E_NOTIMPL; };

    STDMETHOD( GetCanonicalFormatEtc )     ( LPFORMATETC /*lpFormatetcIn*/, LPFORMATETC /*lpFormatetcOut*/ )
    { return E_NOTIMPL; };

    STDMETHOD( DAdvise )                   ( LPFORMATETC /*lpFormatetc*/, DWORD /*advf*/, LPADVISESINK /*pAdvSink*/, LPDWORD /*pdwConnection*/ )
    { return E_NOTIMPL; };
    
    STDMETHOD( DUnadvise )                 ( DWORD /*dwConnection*/ )
    { return E_NOTIMPL; };

    STDMETHOD( EnumDAdvise )               ( LPENUMSTATDATA* /*ppEnumAdvise*/ )
    { return E_NOTIMPL; };

// IMsDataObject methods
    STDMETHOD( AddNode )                    ( ISakNode *pNode );
    STDMETHOD( GetNodeEnumerator )          ( IEnumUnknown ** ppEnum );
    STDMETHOD( GetObjectIdEnumerator )      ( IEnumGUID ** ppEnum );

// Pseudo Constructor / Destructor
public:
    HRESULT FinalConstruct();
    void    FinalRelease();


// Data
private:
    DWORD       m_Count;                // Number of GUIDs in array
    DWORD       m_ArraySize;            // Current allocated size of array
    GUID        *m_pGUIDArray;          // Array of GUIDs - type of object
    GUID        *m_pObjectIdArray;      // Array of ObjectIds - unique GUIDs for specific objects
    IUnknown    **m_pUnkNodeArray;      // Array of unknown ISakNode pointers

static UINT m_cfObjectTypes;

// Private Helper Function
private:
    HRESULT RetrieveMultiSelectData(LPSTGMEDIUM lpMedium);


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\hsmcreat.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmCreate.cpp

Abstract:

    Implementation of ISakNode interfaces init and creation.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"


/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         InitNode
//
//  Initialize single COM object without using the registry. Derived
//  objects frequently augment this method by implementing it themselves.
//

STDMETHODIMP
CSakNode::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CSakNode::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );

    HRESULT hr = S_OK;

    try {

        CWsbStringPtr sz;
        
        // Grab Display Name, Displayed Type, Description
        WsbAffirmHr( put_DisplayName( L"Error Node Name" ) );
        WsbAffirmHr( put_Type( L"Error Node Type" ) );
        WsbAffirmHr( put_Description( L"Error Node Description" ) );
        
        // save a pointer to the ask interface in the main snapin.
        m_pSakSnapAsk = pSakSnapAsk;
        
        // Save the pointer to the COM object
        m_pHsmObj = pHsmObj;
        
        // save the cookie of the parent node.
        m_pParent = pParent;
        
        // Set result pane columns to the defaults
        WsbAffirmHr( SetChildProps(
            RS_STR_RESULT_PROPS_DEFAULT_IDS,
            IDS_RESULT_PROPS_DEFAULT_TITLES,
            IDS_RESULT_PROPS_DEFAULT_WIDTHS ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( S_OK );
}

STDMETHODIMP
CSakNode::TerminateNode(
    )
{
    WsbTraceIn( L"CSakNode::TerminateNode", L"" );

    HRESULT hr = S_OK;

    try {


        //
        // Remove any info in console
        //
        m_pSakSnapAsk->DetachFromNode( this );

        //
        // Release the connection point, if it was established
        //

        if( m_Advise && m_pUnkConnection ) {

            AtlUnadvise( m_pUnkConnection, IID_IHsmEvent, m_Advise );

        }

        //
        // And cleanup internal interface pointers
        //
        m_pUnkConnection.Release( );
        m_pSakSnapAsk.Release( );
        m_pHsmObj.Release( );
        m_pParent.Release( );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::TerminateNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         CreateChildren
//
//  Create and initialize all the children of a given node. This method should 
//  be overridden in all derived classes that actually have children.
//

STDMETHODIMP CSakNode::CreateChildren( )
{
    WsbTraceIn( L"CSakNode::CreateChildren", L"" );

    HRESULT hr = E_FAIL;

    WsbTraceOut( L"CSakNode::CreateChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakNode::InternalDelete(
    BOOL Recurse
    )
{
    WsbTraceIn( L"CSakNode::InternalDelete", L"Recurse = <%ls>", WsbBoolAsString( Recurse ) );

    HRESULT hr = S_OK;

    //
    // Loop through children, deleting them recursively.
    //
    try {

        ISakNode**        ppNode;
        for( ppNode = m_Children.begin( ); ppNode < m_Children.end( ); ppNode++ ) {

            if( *ppNode ) {

                (*ppNode)->TerminateNode( );

                if( Recurse ) {

                    (*ppNode)->DeleteAllChildren( );

                }
            }
        }

        m_Children.Clear( );
        m_bChildrenAreValid = FALSE;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::InternalDelete", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         DeleteChildren
//
//  Delete immediate children from this UI node. There is no need for
//  derived classes to override this function. This is NOT a recursive function.
//

STDMETHODIMP CSakNode::DeleteChildren( )
{
    WsbTraceIn( L"CSakNode::DeleteChildren", L"" );

    HRESULT hr = S_OK;

    hr = InternalDelete( FALSE );

    WsbTraceOut( L"CSakNode::DeleteChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         DeleteAllChildren
//
//  Delete all children (recursively) from this UI node. There is no need for
//  derived classes to override this function. This IS a recursive function.
//  It is to be used to totally free up all UI nodes in the snapin from this node
//  on down.
//

STDMETHODIMP CSakNode::DeleteAllChildren( void )
{
    WsbTraceIn( L"CSakNode::DeleteAllChildren", L"" );

    HRESULT hr = S_OK;

    hr = InternalDelete( TRUE );

    WsbTraceOut( L"CSakNode::DeleteAllChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
//
//         Helper Functions for derived classes
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         NewChild
//
//  Given a string describing the node type, create an instance of the 
//  corresponding COM object. Return an IUnknown pointer to the new child.
//

HRESULT CSakNode::NewChild( REFGUID nodetype, IUnknown** ppUnkChild )
{
    WsbTraceIn( L"CSakNode::NewChild", L"nodetype = <%ls>, ppUnkChild = <0x%p>", WsbGuidAsString( nodetype ), ppUnkChild );
    HRESULT hr = S_OK;

    try {
    
        // Get the class ID of the new node, based on its spelled-out class.
        // Create a COM instance of the child and retrieve its IUnknown interface pointer.
        const CLSID * pclsid;

        WsbAffirmHr( GetCLSIDFromNodeType( nodetype, &pclsid ) );
        WsbAffirmHr( CoCreateInstance( *pclsid, 0, CLSCTX_INPROC, IID_IUnknown, (void**)ppUnkChild ));

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::NewChild", L"hr = <%ls>, *ppUnkChild = <0x%p>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppUnkChild ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         GetCLSIDFromNodeType
//
//  Given a class node type GUID report back its corresponding CLSID.
//

HRESULT CSakNode::GetCLSIDFromNodeType( REFGUID nodetype, const CLSID ** ppclsid )
{
    HRESULT hr = S_FALSE;
    *ppclsid = NULL;

    // As more classes are introduced into this system, add entries for them here.
    if( IsEqualGUID( nodetype, cGuidCar ))
        *ppclsid = &CLSID_CUiCar;

    else if( IsEqualGUID( nodetype, cGuidHsmCom ))
        *ppclsid = &CLSID_CUiHsmCom;

    else if( IsEqualGUID( nodetype, cGuidManVol ))
        *ppclsid = &CLSID_CUiManVol;

    else if( IsEqualGUID( nodetype, cGuidManVolLst ))
        *ppclsid = &CLSID_CUiManVolLst;

    else if( IsEqualGUID( nodetype, cGuidMedSet ))
        *ppclsid = &CLSID_CUiMedSet;

    if( *ppclsid  )
        hr = S_OK;

    return( hr );
}

const OLECHAR * CSakNode::GetClassNameFromNodeType( REFGUID NodeType )
{
    const OLECHAR * retval = L"Unkown";

    if( IsEqualGUID( NodeType, cGuidCar ) )
        retval = L"CUiCar";

    else if( IsEqualGUID( NodeType, cGuidHsmCom ) )
        retval = L"CUiHsmCom";

    else if( IsEqualGUID( NodeType, cGuidManVol ) )
        retval = L"CUiManVol";

    else if( IsEqualGUID( NodeType, cGuidManVolLst ) )
        retval = L"CUiManVolLst";

    else if( IsEqualGUID( NodeType, cGuidMedSet ) )
        retval = L"CUiMedSet";

    else if( IsEqualGUID( NodeType, GUID_NULL ) )
        retval = L"GUID_NULL";

    return( retval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HsmAdmin.rc
//
#define IDR_HsmAdmin                    1
#define IDS_NAME                        3
#define IDS_SIZE                        4
#define IDS_TYPE                        5
#define IDS_EVENT_LOG_APP_TITLE         6
#define IDS_EVENT_LOG_SYS_TITLE         7
#define IDR_CUiMedSet                   8
#define IDS_ERR_SERVICE_NOT_CONNECTING  8
#define IDR_CUiManVolLst                9
#define IDS_COPYSET_COPYSET             9
#define IDS_COPYSET_OUT_OF_DATE         10
#define IDS_COPYSET_DO_NOT_EXIST        11
#define IDS_WIZ_CAR_COPY_NUM_COPIES_TITLE 12
#define IDS_WIZ_CAR_COPY_NUM_COPIES_SUBTITLE 13
#define IDS_WIZ_CAR_COPY_SELECT_TITLE   14
#define IDS_WIZ_CAR_COPY_SELECT_SUBTITLE 15
#define IDR_CUiHsmCom                   16
#define IDS_WIZ_MANVOLLST_LEVELS_TITLE  16
#define IDR_CUiManVol                   17
#define IDS_WIZ_MANVOLLST_LEVELS_SUBTITLE 17
#define IDR_HsmAdminDataSnapin          18
#define IDS_WIZ_MANVOLLST_SELECT_TITLE  18
#define IDR_HsmAdminDataExtension       19
#define IDS_WIZ_MANVOLLST_SELECT_SUBTITLE 19
#define IDS_WIZ_MANVOLLST_SELECTX_TITLE 20
#define IDS_WIZ_MANVOLLST_SELECTX_SUBTITLE 21
#define IDS_WIZ_QSTART_CHECK_TITLE      22
#define IDS_WIZ_QSTART_CHECK_SUBTITLE   23
#define IDR_CUiCar                      24
#define IDS_WIZ_QSTART_INITIAL_VAL_TITLE 24
#define IDS_WIZ_QSTART_INITIAL_VAL_SUBTITLE 25
#define IDS_WIZ_QSTART_MANRES_SEL_TITLE 26
#define IDS_WIZ_QSTART_MANRES_SEL_SUBTITLE 27
#define IDS_WIZ_QSTART_MANRES_SELX_TITLE 28
#define IDS_WIZ_QSTART_MANRES_SELX_SUBTITLE 29
#define IDS_WIZ_QSTART_MEDIA_SEL_TITLE  30
#define IDS_WIZ_QSTART_MEDIA_SEL_SUBTITLE 31
#define IDS_WIZ_QSTART_SCHEDULE_TITLE   32
#define IDS_WIZ_QSTART_SCHEDULE_SUBTITLE 33
#define IDS_WIZ_UNMANAGE_SELECT_TITLE   34
#define IDS_WIZ_UNMANAGE_SELECT_SUBTITLE 35
#define IDS_WIZ_LAST_ACCESS_DATE_DISABLED 36
#define IDS_WIZ_LAST_ACCESS_DATE_ENABLED 37
#define IDD_DLG_RECREATE_CHOOSE_COPY    101
#define IDD_WIZ_QSTART_INTRO            105
#define IDR_About                       108
#define IDC_MANAGE_BROWSE               110
#define IDR_MANVOLLST                   145
#define IDR_MANVOL                      186
#define IDR_MEDSET                      213
#define IDR_HSMCOM                      215
#define IDR_CAR                         218
#define IDR_VALIDATE_ANIM               219
#define IDD_PROP_HSMCOM_STAT            282
#define IDC_MANAGE_LOCAL                1004
#define IDC_MINSIZE_BUDDY               1022
#define IDC_MINSIZE_SPIN                1023
#define IDC_ACCESS_BUDDY                1024
#define IDC_ACCESS_SPIN                 1025
#define IDC_MANVOLLST_FSARESLBOX        1052
#define IDC_MANRES_SELECT               1085
#define IDC_FREESPACE_BUDDY             1087
#define IDC_FREESPACE_SPIN              1088
#define IDC_MEDIA_SEL                   1089
#define IDC_MANAGE_REMOTE               1101
#define IDC_MANAGE_NAME                 1102
#define IDC_EDIT_RECALL_LIMIT           1106
#define IDC_EDIT_COPYFILES_LIMIT        1107
#define IDC_INTRO_TEXT                  1108
#define IDC_SPIN_RECALL_LIMIT           1115
#define IDC_SPIN_COPYFILES_LIMIT        1116
#define IDC_EDIT_LEVEL                  1117
#define IDC_EDIT_SIZE                   1118
#define IDC_EDIT_TIME                   1119
#define IDC_SPIN_LEVEL                  1120
#define IDC_SPIN_SIZE                   1121
#define IDC_SPIN_TIME                   1122
#define IDC_BTN_ADD                     1127
#define IDC_BTN_REMOVE                  1128
#define IDC_BTN_UP                      1129
#define IDC_BTN_DOWN                    1130
#define IDC_BTN_EDIT                    1132
#define IDC_EDIT_PATH                   1136
#define IDC_EDIT_FILESPEC               1137
#define IDC_RADIO_INCLUDE               1138
#define IDC_RADIO_EXCLUDE               1139
#define IDC_CHECK_SUBDIRS               1140
#define IDC_EDIT_RESOURCE_NAME          1143
#define IDC_WIZ_MANVOLLST_INTRO_TEXT    1145
#define IDC_WIZ_MANVOLLST_EDIT_LEVEL    1151
#define IDC_WIZ_MANVOLLST_SPIN_LEVEL    1152
#define IDC_WIZ_MANVOLLST_EDIT_SIZE     1153
#define IDC_WIZ_MANVOLLST_SPIN_SIZE     1154
#define IDC_WIZ_MANVOLLST_EDIT_DAYS     1155
#define IDC_WIZ_MANVOLLST_SPIN_DAYS     1156
#define IDC_UNMANAGE_TRUNCATE           1164
#define IDC_STATIC_MANAGED_SPACE_4DIGIT 1165
#define IDC_STATIC_FREE_SPACE_4DIGIT    1166
#define IDC_STATIC_PREMIGRATED_SPACE_4DIGIT 1167
#define IDC_STATIC_USED_SPACE_4DIGIT    1169
#define IDC_STATIC_DESCRIPTION2         1170
#define IDC_STATIC_REMOTE_STORAGE_4DIGIT 1171
#define IDC_STATIC_FREE_PCT             1173
#define IDC_STATIC_USED_PCT             1174
#define IDC_STATIC_PREMIGRATED_PCT      1175
#define IDC_STATIC_FREE_DESIRED_4DIGIT  1176
#define IDC_STATIC_ACTUAL_FREE_PCT      1177
#define IDC_STATIC_FREE_ACTUAL_4DIGIT   1178
#define IDC_TEXT_DISABLED               1179
#define IDC_LIST_IE                     1180
#define IDI_BLUESAKKARA                 5100
#define IDI_DEVLST                      5203
#define IDI_NODEMANVOL                  5307
#define IDI_NODELIB                     5311
#define IDI_NODETAPE                    5405
#define IDD_WIZ_MANVOLLST_SELECT        5442
#define IDD_WIZ_QSTART_FINISH           5447
#define IDB_QSTART_WATERMARK            5448
#define IDD_WIZ_QSTART_MANRES_SEL       5449
#define IDD_WIZ_QSTART_INITIAL_VAL      5450
#define IDD_WIZ_QSTART_MEDIA_SEL        5451
#define IDB_QSTART_HEADER               5452
#define IDD_PROP_MANRES_STATUS          5457
#define IDD_PROP_MANRES_LEVELS          5458
#define IDD_PROP_MANRES_INCEXC          5459
#define IDD_PROP_SCHEDULE               5462
#define IDD_DLG_RULE_EDIT               5467
#define IDD_CHOOSE_HSM_2                5468
#define IDD_WIZ_MANVOLLST_INTRO         5477
#define IDD_WIZ_MANVOLLST_FINISH        5478
#define IDD_WIZ_MANVOLLST_LEVELS        5479
#define IDS_RECREATE_COL_COPY_TITLE     6000
#define IDS_RECREATE_COL_NAME_TITLE     6001
#define IDS_RECREATE_COL_DATE_TITLE     6002
#define IDS_RECREATE_COL_STATUS_TITLE   6003
#define IDS_RECREATE_COL_COPY_WIDTH     6004
#define IDS_RECREATE_COL_NAME_WIDTH     6005
#define IDS_RECREATE_COL_STATUS_WIDTH   6006
#define IDS_RECREATE_LOCATION_ONLINE    6007
#define IDS_RECREATE_LOCATION_OFFLINE   6008
#define IDS_RECREATE_LOCATION_UNKNOWN   6009
#define IDS_RECREATE_STATUS_FORMAT      6010
#define IDS_RECREATE_COPY_FORMAT        6011
#define IDS_MEDIA_NONAME                6012
#define IDS_RECREATE_LOCATION_DISABLED  6013
#define IDS_HSM_NAME_PREFIX             6039
#define IDS_HELPFILEPOPUP               6040
#define IDS_ERR_COPYSET_RANGE           6041
#define IDS_WIZ_QSTART_TITLE            6042
#define IDS_CONFIRM_MEDIA_COPY_DELETE   6043
#define IDS_ERR_VOLUME_DELETE_PENDING   6044
#define IDS_HELPFILE                    6045
#define IDS_HELPFILELINK                6046
#define IDS_ERR_MINSIZE_RANGE           6047
#define IDS_QSTART_MANRES_TEXT          6048
#define IDS_QSTART_FREESPACE_TEXT       6049
#define IDS_QSTART_CRITERIA_TEXT        6050
#define IDS_QSTART_MEDIA_TEXT           6051
#define IDS_QSTART_SCHED_TEXT           6052
#define IDS_QSTART_MANAGE_NO_VOLUMES    6053
#define IDS_QSTART_FINISH_INDENT        6054
#define IDS_SCHED_TASK_TEMP_TITLE       6058
#define IDS_ERR_NO_ITEM_SELECTED        6060
#define IDS_TB_TEXT_VOLUME_LIST_SCHED   6061
#define IDS_TB_TIP_VOLUME_LIST_SCHED    6062
#define IDS_TB_TEXT_MESE_COPY           6063
#define IDS_TB_TEXT_VOLUME_SETTINGS     6064
#define IDS_QSTART_RESTART_NT           6065
#define IDS_TB_TIP_VOLUME_SETTINGS      6067
#define IDS_CONFIRM_DELETE_RULE         6068
#define IDS_INCLUDE                     6069
#define IDS_EXCLUDE                     6070
#define IDS_RULE_TYPE_SYSTEM            6071
#define IDS_RULE_TYPE_USER              6072
#define IDS_YES                         6073
#define IDS_NO                          6074
#define IDS_ERR_RULE_NO_FILESPEC        6075
#define IDS_ERR_RULE_NO_PATH            6076
#define IDS_ERR_RULE_DUPLICATE          6077
#define IDS_ERR_RULE_ILLEGAL_PATH       6078
#define IDS_ERR_MANAGE_TASK             6079
#define IDS_TB_TEXT_VOLUME_TOOLS        6081
#define ID_MANVOLLST_NEW_MANVOL         6082
#define IDS_TB_TIP_VOLUME_TOOLS         6083
#define IDS_TB_TEXT_VOLUME_RULES        6084
#define IDS_TB_TIP_VOLUME_RULES         6085
#define IDS_TB_TIP_MESE_COPY            6086
#define IDS_TB_TEXT_CAR_COPIES          6087
#define IDS_TB_TIP_CAR_COPIES           6088
#define IDS_TB_TEXT_VOLUME_LIST_NEW     6089
#define IDS_TB_TIP_VOLUME_LIST_NEW      6091
#define ID_MANVOL_ROOT_LEVELS           6092
#define ID_MANVOL_TASK_LEVELS           6093
#define ID_MANVOL_ROOT_RULES            6094
#define ID_MANVOL_TASK_RULES            6095
#define IDS_ERR_QSTART_NO_FILTER        6096
#define IDS_ERR_QSTART_FILTER_ERROR     6097
#define IDS_ERR_OPEN_SERVICE            6098
#define IDS_ERROR_QSTART_ONFINISH       6099
#define ID_HSMCOM_ROOT_SCHEDULE         6100
#define IDS_ERR_MANVOLWIZ_FINISH        6101
#define IDS_WIZ_MANVOLLST_TITLE         6105
#define IDS_MANAGE_LOCAL                6106
#define IDS_UNLABELED_VOLUME            6108
#define IDS_UNLABELED_VOLUME2           6109
#define IDS_RUN_JOB                     6110
#define IDS_JOB_MANAGE                  6111
#define IDS_JOB_RECALL                  6112
#define IDS_JOB_TRUNCATE                6113
#define IDS_JOB_UNMANAGE                6114
#define IDS_JOB_VALIDATE                6115
#define IDS_JOB_NAME_PREFIX             6116
#define IDS_CAR_COPYSET_NONE_SINGULAR   6119
#define IDS_COMPANY                     6125
#define IDS_DESCRIPTION                 6126
#define IDS_CAR_STATUS_RECREATE_SINGULAR 6127
#define IDS_JOB_MEDIA_COPY_TITLE        6128
#define IDS_RESULT_PROPS_MANRESLST_TITLES 6130
#define IDS_RESULT_PROPS_MANRESLST_WIDTHS 6131
#define IDS_RESULT_PROPS_DEFAULT_TITLES 6133
#define IDS_RESULT_PROPS_DEFAULT_WIDTHS 6134
#define IDS_RESULT_PROPS_COM_TITLES     6136
#define IDS_RESULT_PROPS_COM_WIDTHS     6137
#define IDS_DAYS                        6138
#define IDS_MANVOLLST_DISPLAY_NAME      6139
#define IDS_MANVOLLST_DESCRIPTION       6140
#define IDS_ERR_SERVICE_NOT_RUNNING     6141
#define IDS_CAR_COPYSET_NONE            6142
#define IDS_ERR_SERVICE_NOT_SETUP       6143
#define IDS_ERR_REFRESH_FAILED          6144
#define IDS_SERVICE_STATUS_STOPPED      6147
#define IDS_SERVICE_STATUS_START_PENDING 6148
#define IDS_SERVICE_STATUS_STOP_PENDING 6149
#define IDS_SERVICE_STATUS_RUNNING      6150
#define IDS_SERVICE_STATUS_CONTINUE_PENDING 6151
#define IDS_SERVICE_STATUS_PAUSE_PENDING 6152
#define IDS_SERVICE_STATUS_PAUSED       6153
#define IDS_HSMCOM_TYPE                 6154
#define IDS_HSMCOM_DESCRIPTION          6155
#define IDS_SERVICE_STATUS_NOT_SETUP    6156
#define IDS_ERR_SERVICE_NOT_SETUP_REMOTE 6157
#define IDS_ERR_SERVICE_NOT_INSTALLED   6158
#define IDS_JOB_MEDIA_RECREATE_TITLE    6159
#define IDS_GENERIC_JOB_COMMENT         6163
#define IDS_MEDIA_COPIES_DESCRIPTION    6165
#define IDS_RESULT_PROPS_MEDSET_TITLES  6167
#define IDS_RESULT_PROPS_MEDSET_WIDTHS  6168
#define IDS_MEDSET_DISPLAYNAME          6169
#define IDS_MEDSET_TYPE                 6170
#define IDS_MEDSET_DESCRIPTION          6171
#define IDS_MEDTYPE_UNKNOWN             6172
#define IDS_MEDTYPE_FIXED               6173
#define IDS_MEDTYPE_REMOVABLE           6174
#define IDS_MEDTYPE_OPTICAL             6175
#define IDS_MEDTYPE_TAPE                6176
#define IDS_CAR_COPYSET_INSYNC          6177
#define IDS_CAR_COPYSET_OUTSYNC         6178
#define IDS_CAR_COPYSET_ERROR_SP        6179
#define IDS_MEDIA                       6180
#define IDS_VOLUMES                     6181
#define IDS_VOLUME                      6182
#define IDS_CAR_STATUS_ERROR_INCOMPLETE_SINGULAR 6183
#define IDS_CAR_STATUS_ERROR_INCOMPLETE_PLURAL 6184
#define IDS_CAR_TYPE                    6188
#define IDS_CAR_DESCRIPTION             6189
#define IDS_CAR_STATUS_ERROR_RW_SP      6190
#define IDS_CAR_STATUS_READONLY_PLURAL  6191
#define IDS_CAR_STATUS_NORMAL_PLURAL    6192
#define IDS_CAR_STATUS_ERROR_RO_SP      6193
#define IDS_CAR_COPYSET_INSYNC_PLURAL   6194
#define IDS_CAR_COPYSET_OUTSYNC_PLURAL  6195
#define IDS_CAR_COPYSET_ERROR           6196
#define IDS_CAR_STATUS_ERROR_MISSING    6197
#define IDS_CAR_STATUS_ERROR_MISSING_SINGULAR 6198
#define IDS_CAR_STATUS_ERROR_MISSING_PLURAL 6199
#define IDS_CAR_COPYSET_MISSING         6200
#define IDS_CAR_COPYSET_MISSING_SINGULAR 6201
#define IDS_MEDIA_RECREATE_JOB_COMMENT  6202
#define IDS_MEDIA_COPY_JOB_COMMENT      6203
#define IDS_CAR_COPYSET_MISSING_PLURAL  6204
#define IDS_SCHED_MANAGE_TITLE          6205
#define IDS_ERR_CREATE_TASK             6207
#define IDS_ERR_NO_ADMIN_PRIV           6212
#define IDS_ERR_NO_SUPP_MEDIA           6214
#define IDS_CONFIRM_MEDIA_RECREATE      6215
#define IDS_WIZ_CAR_COPY_TITLE          6217
#define IDS_WIZ_CAR_COPY_SELECT         6218
#define IDS_WIZ_CAR_COPY_SEL_TEXT       6219
#define IDS_WIZ_CAR_COPY_NEW_NUM        6220
#define IDS_WIZ_UNMANAGE_TITLE          6221
#define IDS_WIZ_FINISH_RUN_JOB          6224
#define IDS_WIZ_UNMANAGE_CONFIRM_NOMANAGE 6226
#define IDS_WIZ_UNMANAGE_CONFIRM_FULL   6227
#define IDS_WIZ_UNMANAGE_SELECT         6230
#define IDS_WIZ_UNMANAGE_SEL_NOMANAGE   6231
#define IDS_WIZ_UNMANAGE_SEL_FULL       6232
#define IDS_WIZ_UNMANAGE_NOMANAGE_TASK_TEXT 6235
#define IDS_JOB_QUICK_UNMANAGE          6236
#define IDS_JOB_FULL_UNMANAGE           6237
#define IDS_VOLUME_STATUS_LABEL_MULTI   6238
#define IDS_VOLUME_STATUS_RS_LABEL_MULTI 6239
#define IDS_VOLUME_STATUS_LABEL_SINGLE  6240
#define IDS_VOLUME_STATUS_RS_LABEL_SINGLE 6241
#define IDS_CAR_NAME_UNKNOWN            6242
#define IDS_CONFIRM_MEDIA_COPY_DELETE_MULTI 6243
#define IDS_CAR_COPYSET_NONE_PLURAL     6244
#define IDS_CAR_COPYSET_INSYNC_SINGULAR 6245
#define IDS_CAR_COPYSET_OUTSYNC_SINGULAR 6246
#define IDS_CAR_STATUS_READONLY_SINGULAR 6247
#define IDS_CAR_STATUS_RECREATE_PLURAL  6248
#define IDS_CAR_STATUS_NORMAL_SINGULAR  6249
#define IDS_RUN_JOB_MULTI1              6250
#define IDS_RUN_JOB_MULTI2              6251
#define IDS_NO_VOLUMES                  6253
#define IDS_LISTVIEW_WIDTHS_IE          6254
#define IDS_LISTVIEW_TITLES_IE          6255
#define IDS_RULE_SUBDIRS_USE            6256
#define IDS_RULE_SUBDIRS_IGNORE         6257
#define IDS_VOLUMES_MANAGED_PLURAL      6258
#define IDS_VOLUMES_MANAGED_SINGULAR    6259
#define IDS_CARTRIDGES_USED_PLURAL      6260
#define IDS_CARTRIDGES_USED_SINGULAR    6261
#define IDS_CAR_STATUS_NORMAL           6262
#define IDS_CAR_STATUS_READONLY         6263
#define IDS_CAR_STATUS_RECREATE         6264
#define IDS_CAR_STATUS_ERROR_RO         6265
#define IDS_CAR_STATUS_ERROR_RW         6266
#define IDS_CAR_STATUS_ERROR_INCOMPLETE 6267
#define IDS_ERROR_SYSTEM_CHECK          6273
#define IDS_CAPACITY                    6274
#define IDS_FREESPACE                   6275
#define IDS_RUN_COPY_JOB                6276
#define IDS_RUN_VALIDATE_JOB            6277
#define IDS_RUN_CFS_JOB                 6278
#define IDS_MONITOR_TASK                6279
#define IDS_RUN_MULTI_COPY_JOBS         6280
#define IDS_RUN_MULTI_VALIDATE_JOBS     6281
#define IDS_RUN_MULTI_CFS_JOBS          6282
#define IDS_VOL_NOT_AVAILABLE           6283
#define IDD_PROP_MEDIA_COPIES           7000
#define IDD_WIZ_QSTART_SCHEDULE         7001
#define IDB_SMALL_SAKKARA               7003
#define IDB_LARGE_SAKKARA               7004
#define IDD_WIZ_QSTART_CHECK            7004
#define IDD_PROP_CAR_STATUS             7005
#define IDD_PROP_CAR_COPIES             7006
#define IDI_DEVLSTX                     7007
#define IDD_WIZ_CAR_COPY_INTRO          7007
#define IDI_NODELIBX                    7008
#define IDD_WIZ_CAR_COPY_FINISH         7008
#define IDD_WIZ_CAR_COPY_SELECT         7009
#define IDD_WIZ_UNMANAGE_FINISH         7010
#define IDD_WIZ_UNMANAGE_INTRO          7011
#define IDD_WIZ_UNMANAGE_SELECT         7012
#define IDD_PROP_CAR_RECOVER            7013
#define IDD_PROP_CAR_STATUS_MULTI       7014
#define IDD_PROP_CAR_COPIES_MULTI       7015
#define IDD_PROP_MANRES_TOOLS           7016
#define IDD_WIZ_CAR_COPY_NUM_COPIES     7017
#define IDB_UNMANAGE_HEADER             7018
#define IDB_MANAGE_HEADER               7019
#define IDB_MEDIA_SYNC_WATERMARK        7020
#define IDB_MEDIA_SYNC_HEADER           7021
#define IDB_UNMANAGE_WATERMARK          7022
#define IDB_MANAGE_WATERMARK            7023
#define IDB_TOOLBAR_VOLUME              7028
#define IDB_TOOLBAR_VOLUME_LIST         7029
#define IDB_TOOLBAR_MESE                7030
#define IDB_TOOLBAR_CAR                 7031
#define IDI_NODEMANVOLX                 7036
#define IDD_CHOOSE_HSM                  7037
#define IDI_MOVEUP                      7038
#define IDD_WIZ_QSTART_MANRES_SELX      7038
#define IDI_MOVEDOWN                    7039
#define IDD_WIZ_MANVOLLST_SELECTX       7039
#define IDD_PROP_RECALL_LIMIT           7040
#define IDI_MOVEDOWN2                   7041
#define IDI_MOVEUP2                     7042
#define IDI_NODEOPENFOLDER              7044
#define IDI_NODETAPEX                   7046
#define IDI_NODEMANVOLD                 7047
#define IDI_NODETAPED                   7048
#define IDD_VALIDATE_WAIT               7049
#define ID_MANVOLLST_ROOT_MANVOL        8007
#define ID_HSMCOM_ROOT_SETUPWIZARD      8008
#define ID_HSMCOM_TASK_SETUPWIZARD      8009
#define ID_MEDSET_ROOT_COPY             8014
#define ID_CAR_COPIES                   8015
#define ID_MANVOL_ROOT_TASKS            8016
#define ID_TASK                         8019
#define ID_MANVOL_ROOT_TOOLS_COPY       8020
#define ID_MANVOL_ROOT_TOOLS_VALIDATE   8021
#define ID_MANVOL_ROOT_TOOLS_CREATE_FREESPACE 8022
#define ID_MANVOL_ROOT_REMOVE           8023
#define IDC_EDIT_MEDIA_COPIES           9000
#define IDC_SPIN_MEDIA_COPIES           9001
#define IDC_SCHED_TEXT                  9002
#define IDC_CHANGE_SCHED                9003
#define IDC_CHECK_LOGON_TEXT            9004
#define IDC_CHECK_LOGON_BOX             9005
#define IDC_CHECK_SUPP_MEDIA_BOX        9007
#define IDC_CHECK_SUPP_MEDIA_TEXT       9008
#define IDC_DESCRIPTION                 9014
#define IDC_NAME                        9015
#define IDC_MODIFIED_1_LABEL            9016
#define IDC_STATUS                      9017
#define IDC_CAPACITY                    9018
#define IDC_FREESPACE                   9019
#define IDC_MODIFIED_2_LABEL            9020
#define IDC_MODIFIED_3_LABEL            9021
#define IDC_RECREATE_MASTER             9023
#define IDC_NAME_1                      9024
#define IDC_STATUS_1                    9025
#define IDC_MODIFIED_1                  9026
#define IDC_STATUS_1_LABEL              9027
#define IDC_NAME_1_LABEL                9028
#define IDC_DELETE_1                    9029
#define IDC_NAME_2_LABEL                9030
#define IDC_NAME_2                      9031
#define IDC_STATUS_2_LABEL              9032
#define IDC_STATUS_2                    9033
#define IDC_MODIFIED_2                  9034
#define IDC_DELETE_2                    9035
#define IDC_NAME_3_LABEL                9036
#define IDC_NAME_3                      9037
#define IDC_STATUS_3_LABEL              9038
#define IDC_STATUS_3                    9039
#define IDC_MODIFIED_3                  9040
#define IDC_DELETE_3                    9041
#define IDC_COPY_1                      9042
#define IDC_COPY_2                      9043
#define IDC_COPY_3                      9044
#define IDC_MODIFIED                    9045
#define IDC_RECREATE_WARNING            9046
#define IDC_STATIC_STATUS               9047
#define IDC_TASK_TEXT                   9048
#define IDC_COPY_LIST                   9049
#define IDC_SELECT_TEXT                 9050
#define IDC_NOMANAGE                    9051
#define IDC_FULL                        9052
#define IDC_STATIC_RS_DATA_LABEL        9056
#define IDC_BTN_COPY_NOW                9057
#define IDC_BTN_VALIDATE                9059
#define IDC_BTN_FREE                    9060
#define IDC_STATIC_NO_VOLUMES_TEXT      9062
#define IDC_RADIO_MANAGE_ALL            9063
#define IDC_RADIO_SELECT                9064
#define IDC_STATIC_MANAGED_VOLUMES      9069
#define IDC_STATIC_DATA_IN_RS_LABEL     9070
#define IDC_STATIC_CARTS_USED           9071
#define IDC_STATIC_MANAGED_VOLUMES_LABEL 9072
#define IDC_STATIC_DATA_IN_RS           9073
#define IDC_STATIC_CARTS_USED_LABEL     9074
#define IDC_STATIC_ENGINE_BUILD_HSM     9075
#define IDC_STATIC_ENGINE_BUILD_FSA     9076
#define IDC_STATIC_BUILD_LABEL_HSM      9077
#define IDC_STATIC_BUILD_LABEL_FSA      9078
#define IDC_REQUESTS_IN_NTMS            9084
#define IDC_WHICH_VOLUME                9085
#define IDC_DESCRIPTION_MULTI           9086
#define IDC_STATIC_VOLUME_NAME          9087
#define IDC_STATIC_GROUP                9088
#define IDC_EXEMPT_ADMINS               9090
#define IDC_MANAGE_ALLOW_CHANGE         9091
#define IDC_TEXT_MEDIA_COPIES           9092
#define IDC_SNAPIN_TITLE                9093
#define IDC_MOREINFO                    9094
#define IDC_STATIC_STATUS_LABEL         9097
#define IDC_NAME_LABEL                  9098
#define IDC_STATUS_LABEL                9099
#define IDC_CAPACITY_LABEL              9100
#define IDC_FREESPACE_LABEL             9101
#define IDC_MODIFIED_LABEL              9102
#define IDC_LIST_IE_LABEL               9104
#define IDC_STATIC_ACTUAL_FREE_PCT_LABEL 9105
#define IDC_STATIC_ACTUAL_FREE_PCT_UNIT 9106
#define IDC_EDIT_LEVEL_LABEL            9107
#define IDC_EDIT_LEVEL_UNIT             9108
#define IDC_EDIT_SIZE_LABEL             9109
#define IDC_EDIT_SIZE_UNIT              9110
#define IDC_EDIT_TIME_LABEL             9111
#define IDC_EDIT_TIME_UNIT              9112
#define IDC_STATIC_PREMIGRATED_SPACE_4DIGIT_LABEL 9113
#define IDC_STATIC_PREMIGRATED_PCT_UNIT 9114
#define IDC_STATIC_USED_SPACE_4DIGIT_LABEL 9116
#define IDC_STATIC_USED_SPACE_4DIGIT_HELP 9117
#define IDC_STATIC_USED_PCT_UNIT        9118
#define IDC_STATIC_FREE_SPACE_4DIGIT_LABEL 9119
#define IDC_STATIC_FREE_PCT_UNIT        9120
#define IDC_STATIC_MANAGED_SPACE_4DIGIT_LABEL 9121
#define IDC_BTN_COPY_NOW_LABEL          9122
#define IDC_BTN_COPY_NOW_GROUP          9123
#define IDC_BTN_VALIDATE_LABEL          9124
#define IDC_BTN_VALIDATE_GROUP          9125
#define IDC_BTN_FREE_LABEL              9126
#define IDC_BTN_FREE_GROUP              9127
#define IDC_SCHED_LABEL                 9128
#define IDC_CHANGE_SCHED_LABEL          9129
#define IDC_EDIT_RECALL_LIMIT_LABEL     9130
#define IDC_SPIN_COPYFILES_LIMIT_LABEL  9131
#define IDC_UNMANAGE_FREE_SPACE_LABEL   9132
#define IDC_UNMANAGE_TRUNCATE_LABEL     9133
#define IDC_UNMANAGE_FREE_SPACE         9134
#define IDC_RECREATE_COPY_LIST          9135
#define IDC_BUTTON_REFRESH              9140
#define IDC_REFRESH_DESCRIPTION         9141
#define IDC_UNMANAGE_FULL_DESCRIPTION   9142
#define IDC_ANIMATE_VALIDATE            9143
#define IDS_ERROR_HEADER                33007
#define IDS_ERROR_CONNECT_HSM           33008

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        7050
#define _APS_NEXT_COMMAND_VALUE         8024
#define _APS_NEXT_CONTROL_VALUE         9145
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\hsmadmin.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmAdmin.cpp

Abstract:

    Main module file - defines the overall COM server.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/


#include "stdafx.h"

// Include typedefs for all classes declared in DLL
#include "CSakSnap.h"
#include "CSakData.h"

#include "About.h"
#include "Ca.h"
#include "HsmCom.h"
#include "ManVol.h"
#include "ManVolLs.h"
#include "MeSe.h"

#ifdef _MERGE_PROXYSTUB
#include "dlldatax.h"
extern "C" HINSTANCE hProxyDll;
#endif

CComModule         _Module;
CHsmAdminApp       g_App;
CComPtr<IWsbTrace> g_pTrace;

//
// Marks the beginning of the map of ATL objects in this DLL for which
// class factories will be supplied. When CComModule::RegisterServer is 
// called, it updates the system registry for each object in the object map. 
//

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CAbout,                  CAbout)
    OBJECT_ENTRY(CLSID_CUiCar,                  CUiCar)
    OBJECT_ENTRY(CLSID_CUiHsmCom,               CUiHsmCom)
    OBJECT_ENTRY(CLSID_CUiManVol,               CUiManVol)
    OBJECT_ENTRY(CLSID_CUiManVolLst,            CUiManVolLst)
    OBJECT_ENTRY(CLSID_CUiMedSet,               CUiMedSet)
    OBJECT_ENTRY(CLSID_HsmAdminDataSnapin,      CSakDataPrimaryImpl)
    OBJECT_ENTRY(CLSID_HsmAdminDataExtension,   CSakDataExtensionImpl)
    OBJECT_ENTRY(CLSID_HsmAdmin,                CSakSnap)
END_OBJECT_MAP()

BOOL CHsmAdminApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);
    AfxEnableControlContainer( );

    try {

#ifdef _MERGE_PROXYSTUB
        hProxyDll = m_hInstance;
#endif

        CString keyName;
        keyName.Format( L"ClsID\\%ls", WsbGuidAsString( CLSID_CWsbTrace ) );

        CRegKey key;
        if( key.Open( HKEY_CLASSES_ROOT, keyName, KEY_READ ) != ERROR_SUCCESS ) {

            throw( GetLastError( ) );

        }

        if( SUCCEEDED( g_pTrace.CoCreateInstance( CLSID_CWsbTrace ) ) ) {
        
            CString tracePath, regPath;
            CWsbStringPtr outString;
        
            outString.Alloc( 256 );
            regPath = L"SOFTWARE\\Microsoft\\RemoteStorage\\RsAdmin";
        
            //
            // We want to put the path where the trace file should go.
            //
            if( WsbGetRegistryValueString( 0, regPath, L"WsbTraceFileName", outString, 256, 0 ) != S_OK ) {
        
                WCHAR * systemPath;
                systemPath = _wgetenv( L"SystemRoot" );
                tracePath.Format( L"%ls\\System32\\RemoteStorage\\Trace\\RsAdmin.Trc", systemPath );

                WsbSetRegistryValueString( 0, regPath, L"WsbTraceFileName", tracePath );

                //
                // Try a little to make sure the trace directory exists.
                //
                tracePath.Format( L"%ls\\System32\\RemoteStorage", systemPath );
                CreateDirectory( tracePath, 0 );
                tracePath += L"\\Trace";
                CreateDirectory( tracePath, 0 );

            }
        
            g_pTrace->SetRegistryEntry( (LPWSTR)(LPCWSTR)regPath );
            g_pTrace->LoadFromRegistry();
        
        }
    } catch( ... ) { }

    WsbTraceIn( L"CHsmAdminApp::InitInstance", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Need to give complete path to POPUP help file
        //
        CWsbStringPtr helpFile;
        WsbAffirmHr( helpFile.LoadFromRsc( _Module.m_hInst, IDS_HELPFILEPOPUP ) );

        CWsbStringPtr winDir;
        WsbAffirmHr( winDir.Alloc( RS_WINDIR_SIZE ) );
        WsbAffirmStatus( ::GetWindowsDirectory( (WCHAR*)winDir, RS_WINDIR_SIZE ) != 0 );

        CString helpFilePath = CString( winDir ) + L"\\help\\" + CString( helpFile );
        m_pszHelpFilePath = _tcsdup( helpFilePath );

    } WsbCatch( hr );

    BOOL retval = CWinApp::InitInstance( );
    WsbTraceOut( L"CHsmAdminApp::InitInstance", L"BOOL = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

int CHsmAdminApp::ExitInstance()
{
    WsbTraceIn( L"CHsmAdminApp::ExitInstance", L"" );

    _Module.Term();
    int retval = CWinApp::ExitInstance();

    WsbTraceOut( L"CHsmAdminApp::ExitInstance", L"int = <%ls>", WsbLongAsString( retval ) );
    return( retval );
}


void CHsmAdminApp::ParseCommandLine(CCommandLineInfo& rCmdInfo)
{
    int argc = 0;
    WCHAR **argv;

    WsbTraceIn( L"CHsmAdminApp::ParseCommandLine", L"" );

    argv = CommandLineToArgvW( GetCommandLineW(), &argc );
    if (argc > 0) {
    	WsbAffirmPointer(argv);
    }
    for (int i = 1; i < argc; i++)
    {
        CString pszParam = argv[i];
        BOOL bFlag = FALSE;
        BOOL bLast = ((i + 1) == argc);
        WsbTrace( L"CHsmAdminApp::ParseCommandLine: arg[%d] = \"%s\"\n",
                i, (LPCTSTR)pszParam);
        if( pszParam[0] == '-' || pszParam[0] == '/' )
        {
            // remove flag specifier
            bFlag = TRUE;
            pszParam = pszParam.Mid( 1 );
        }
        rCmdInfo.ParseParam( pszParam, bFlag, bLast );
    }
    WsbTraceOut( L"CHsmAdminApp::ParseCommandLine", L"" );
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    WsbTraceIn( L"DllCanUnloadNow", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
#ifdef _MERGE_PROXYSTUB
    hr = ( S_OK == PrxDllCanUnloadNow() ) ? S_OK : S_FALSE;
#endif

    if( S_OK == hr ) {
        
        hr = (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;

    }
    WsbTraceOut( L"DllCanUnloadNow", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    WsbTraceIn( L"DllGetClassObject", L"" );

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

#ifdef _MERGE_PROXYSTUB
    hr = PrxDllGetClassObject( rclsid, riid, ppv );
#endif

    if( CLASS_E_CLASSNOTAVAILABLE == hr ) {

        hr = _Module.GetClassObject(rclsid, riid, ppv);

    }

    WsbTraceOut( L"DllGetClassObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    WsbTraceIn( L"DllRegisterServer", L"" );

    // registers object, typelib and all interfaces in typelib
    HRESULT hr = S_OK;

#ifdef _MERGE_PROXYSTUB
    hr = PrxDllRegisterServer();
#endif

    if( SUCCEEDED( hr ) ) {

        hr = CoInitialize( 0 );

        if (SUCCEEDED(hr)) {
            hr = _Module.RegisterServer( TRUE );
            CoUninitialize( );
        }

        //
        // Need to over-ride the rgs name description for multi language support
        //
        CWsbStringPtr name, nameIndirect, regPath;
        HRESULT hrMUI = S_OK;
        UINT uLen = 0;
        if( SUCCEEDED( name.LoadFromRsc( _Module.m_hInst, IDS_HSMCOM_DESCRIPTION ) ) ) {

            const OLECHAR* mmcPath = L"SOFTWARE\\Microsoft\\MMC\\SnapIns\\";

            // Create indirect string
            hrMUI = nameIndirect.Alloc(MAX_PATH);
            if (S_OK == hrMUI) {
                uLen = GetSystemDirectory(nameIndirect, MAX_PATH);
                if (uLen > MAX_PATH) {
                    // Try again with larger buffer
                    hrMUI = nameIndirect.Realloc(uLen);
                    if (S_OK == hrMUI) {
                        uLen = GetSystemDirectory(nameIndirect, uLen);
                        if (0 == uLen) {
                            hrMUI = S_FALSE;
                        }
                    }
                }
            }

            if (S_OK == hrMUI) {
                hrMUI = nameIndirect.Prepend(OLESTR("@"));
            }
            if (S_OK == hrMUI) {
                WCHAR resId[64];
                wsprintf(resId, OLESTR("\\rsadmin.dll,-%d"), IDS_HSMCOM_DESCRIPTION);
                hrMUI = nameIndirect.Append(resId);
            } 

            // Sanpin
            regPath = mmcPath;
            regPath.Append( WsbGuidAsString( CLSID_HsmAdminDataSnapin ) );

            // Set the MUI support value
            if (S_OK == hrMUI) {
                WsbSetRegistryValueString( 0, regPath, L"NameStringIndirect", nameIndirect );
            }

            // Set the fallback value
            WsbSetRegistryValueString( 0, regPath, L"NameString", name );


            // Extension
            regPath = mmcPath;
            regPath.Append( WsbGuidAsString( CLSID_HsmAdminDataExtension ) );

            // Set the MUI support value
            if (S_OK == hrMUI) {
                WsbSetRegistryValueString( 0, regPath, L"NameStringIndirect", nameIndirect );
            }

            // Set the fallback value
            WsbSetRegistryValueString( 0, regPath, L"NameString", name );

        }

    }

    WsbTraceOut( L"DllRegisterServer", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    WsbTraceIn( L"DllUnregisterServer", L"" );

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }

    WsbTraceOut( L"DllUnregisterServer", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\rsadutil.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsAdUtil.h

Abstract:

    Utility functions for GUI - for us in HSMADMIN files only

Author:

    Art Bragg [abragg]   04-Mar-1997

Revision History:

--*/

// Defined constants for media copy states
#define RS_MEDIA_COPY_STATUS_NONE           ((USHORT)5000)
#define RS_MEDIA_COPY_STATUS_ERROR          ((USHORT)5001)
#define RS_MEDIA_COPY_STATUS_OUTSYNC        ((USHORT)5002)
#define RS_MEDIA_COPY_STATUS_INSYNC         ((USHORT)5003)
#define RS_MEDIA_COPY_STATUS_MISSING        ((USHORT)5004)

// Defined constants for master media states
#define RS_MEDIA_STATUS_RECREATE            ((USHORT)5101)
#define RS_MEDIA_STATUS_READONLY            ((USHORT)5102)
#define RS_MEDIA_STATUS_NORMAL              ((USHORT)5103)
#define RS_MEDIA_STATUS_ERROR_RO            ((USHORT)5104)
#define RS_MEDIA_STATUS_ERROR_RW            ((USHORT)5105)
#define RS_MEDIA_STATUS_ERROR_MISSING       ((USHORT)5106)
#define RS_MEDIA_STATUS_ERROR_INCOMPLETE    ((USHORT)5107)

void
RsReportError( HRESULT hrToReport, int textId, ... );

HRESULT RsGetStatusString (
    DWORD    serviceStatus,
    HRESULT  hrSetup,
    CString& sStatus
    );

WCHAR *
RsNotifyEventAsString (
    IN  MMC_NOTIFY_TYPE event
    );

WCHAR *
RsClipFormatAsString (
    IN  CLIPFORMAT cf
    );

HRESULT
RsIsRemoteStorageSetup(
    void
    );

HRESULT
RsIsRemoteStorageSetupEx(
    IHsmServer * pHsmServer
    );

HRESULT
RsIsSupportedMediaAvailable(
    void
    );

HRESULT
RsIsRmsErrorNotReady(
    HRESULT HrError
    );

USHORT
RsGetCopyStatus(
    IN  REFGUID   CopyId,
    IN  HRESULT   CopyHr,
    IN  SHORT     CopyNextDataSet,
    IN  SHORT     LastGoodNextDataSet
    );

HRESULT
RsGetCopyStatusStringVerb(
    IN  USHORT      copyStatus,
    OUT CString&    String
    );

HRESULT
RsGetCopyStatusString(
    IN  USHORT      copyStatus,
    OUT CString&    String
    );

USHORT
RsGetCartStatus(
    IN  HRESULT   LastHr,
    IN  BOOL      ReadOnly,
    IN  BOOL      Recreate,
    IN  SHORT     NextDataSet,
    IN  SHORT     LastGoodNextDataSet
    );

HRESULT
RsGetCartStatusString(
    IN  USHORT      cartStatus,
    OUT CString&    String
    );

HRESULT
RsGetCartStatusStringVerb(
    IN  USHORT      cartStatus,
    IN  BOOL        plural,
    OUT CString&    String
    );

HRESULT
RsGetCartMultiStatusString( 
    IN USHORT statusRecreate, 
    IN USHORT statusReadOnly, 
    IN USHORT statusNormal, 
    IN USHORT statusRO, 
    IN USHORT statusRW, 
    IN USHORT statusMissing,
    OUT CString &outString 
    );

HRESULT
RsGetCopyMultiStatusString( 
    IN USHORT statusNone, 
    IN USHORT statusError, 
    IN USHORT statusOutSync, 
    IN USHORT statusInSync,
    OUT CString &outString
    );

HRESULT
RsCreateAndRunFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource,
    IN  BOOL ShowMsg = TRUE
    );

HRESULT
RsCreateAndRunDirectFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource,
    IN  BOOL waitJob
    );

HRESULT
RsCancelDirectFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource
    );

HRESULT
RsCreateJobName(
    IN  HSM_JOB_DEF_TYPE jobType, 
    IN  IFsaResource *   pResource,
    OUT CString&         szJobName
    );

HRESULT
RsGetJobTypeString(
    IN  HSM_JOB_DEF_TYPE jobType,
    OUT CString&         szJobType
    );

HRESULT
RsCreateAndRunMediaCopyJob(
    IN  IHsmServer * pHsmServer,
    IN  UINT SetNum,
    IN  BOOL ShowMsg
    );

HRESULT
RsCreateAndRunMediaRecreateJob(
    IN  IHsmServer * pHsmServer,
    IN  IMediaInfo * pMediaInfo,
    IN  REFGUID      MediaId,
    IN  CString &    MediaDescription,
    IN  SHORT        CopyToUse
    );

HRESULT
RsGetStoragePoolId(
    IN  IHsmServer *pHsmServer,
    OUT GUID *      pStoragePoolId
    );

HRESULT
RsGetStoragePool(
    IN  IHsmServer *       pHsmServer,
    OUT IHsmStoragePool ** ppStoragePool
    );

HRESULT
RsGetInitialLVColumnProps(
    int IdWidths, 
    int IdTitles, 
    CString **pColumnWidths, 
    CString **pColumnTitles,
    int *pColumnCount
    );

HRESULT
RsServerSaveAll(
    IUnknown * pUnkServer
    );

HRESULT
RsGetVolumeDisplayName(
    IFsaResource * pResource,
    CString &      DisplayName
    );

HRESULT
RsGetVolumeDisplayName2(
    IFsaResource * pResource,
    CString &      DisplayName
    );

HRESULT
RsGetVolumeSortKey(
    IFsaResource * pResource,
    CString &      DisplayName
    );

HRESULT
RsIsVolumeAvailable(
    IFsaResource * pResource
    );

HRESULT
RsIsWhiteOnBlack(
    );

class CCopySetInfo {

public:
    SHORT    m_NextDataSet;
    FILETIME m_ModifyTime;
    HRESULT  m_Hr;
    GUID     m_RmsId;
    BOOL     m_Disabled;
};

class CResourceInfo {
public:
    CResourceInfo( IFsaResource* pResource ) {
        m_pResource = pResource;
        m_HrConstruct = RsGetVolumeDisplayName( m_pResource, m_DisplayName );
        if( SUCCEEDED( m_HrConstruct ) ) {
            m_HrConstruct = RsGetVolumeSortKey( m_pResource, m_SortKey );
        }
    };
    static INT CALLBACK Compare( LPARAM lParam1, LPARAM lParam2, LPARAM /* lParamSort */ ) {
        CResourceInfo* pResInfo1 = (CResourceInfo*)lParam1;
        CResourceInfo* pResInfo2 = (CResourceInfo*)lParam2;
        if( ! pResInfo1 ) return( -1 );
        if( ! pResInfo2 ) return(  1 );
        return( pResInfo1->m_SortKey.CompareNoCase( pResInfo2->m_SortKey ) );
    }

    CString                 m_DisplayName;
    CString                 m_SortKey;
    CComPtr<IFsaResource>   m_pResource;
    HRESULT                 m_HrConstruct;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\sakmenu.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SakMenu.cpp

Abstract:

    Implements all the context menu interface to the individual nodes,
    including getting menu resources and turning into MMC menus, and
    forwarding on command messages.

Author:

    Rohde Wakefield   [rohde]   09-Dec-1996

Revision History:

--*/


#include "stdafx.h"
#include "CSakData.h"
#include "CSakSnap.h"


//
// Mask for a long value out of a short value's range
//

#define SHORT_VALUE_RANGE (MAXULONG ^ ((unsigned short)MAXSHORT))




static HRESULT
AddMmcMenuItems (
    IN CMenu *                pMenu,
    IN LONG                   lInsertionPointID,
    IN ISakNode *             pNode,
    IN IContextMenuCallback * pContextMenuCallback
    )

/*++

Routine Description:

    Called for any node clicked on with right mouse. Goes to the
    node object to construct the MMC menu.

Arguments:

    pDataObject - identifies the node to be worked on.

    pContextMenuCallback - The MMC menu interface to use.

Return Value:

    S_OK - All added fine - continue.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"AddMmcMenuItems", L"lInsertionPointID = <0x%p>, pNode = <0x%p>", lInsertionPointID, pNode );

    HRESULT hr = S_OK;

    try {

        //
        // It is ok to pass a NULL pMenu - means do not add
        // any entries
        //

        if ( 0 != pMenu ) {

            CString menuText;
            CString statusText;
            
            BSTR    bstr;
            
            CONTEXTMENUITEM menuItem;
            memset ( (void*)&menuItem, 0, sizeof ( menuItem ) );
            menuItem.lInsertionPointID = lInsertionPointID;

            UINT menuCount = pMenu->GetMenuItemCount ( );

            for ( UINT index = 0; index < menuCount; index++ ) {

                //
                // For each menu item, fill out MMC's CONTEXTMENUITEM struct
                // appropriately and call AddItem
                //

                menuItem.lCommandID = pMenu->GetMenuItemID ( index );

                pMenu->GetMenuString ( index, menuText, MF_BYPOSITION );
                menuItem.strName = (LPTSTR)(LPCTSTR)menuText;

                WsbAffirmHr ( pNode->GetMenuHelp ( menuItem.lCommandID, &bstr ) );
                if ( 0 != bstr ) {

                    statusText = bstr;
                    SysFreeString ( bstr );
                    menuItem.strStatusBarText = (LPTSTR)(LPCTSTR)statusText;

                } else {

                    menuItem.strStatusBarText = 0;

                }

                menuItem.fFlags        = pMenu->GetMenuState ( index, MF_BYPOSITION );
                menuItem.fSpecialFlags = 0;

                //
                // Since AppStudio does not make available the MFS_DEFUALT flag,
                // we will use the MF_HELP flag for default entry.
                //

                if ( 0 != ( menuItem.fFlags & MF_HELP ) ) {

                    menuItem.fFlags        &= ~MF_HELP;
                    menuItem.fSpecialFlags |= CCM_SPECIAL_DEFAULT_ITEM;

                }

                pContextMenuCallback->AddItem ( &menuItem );

            }

        }
        
    } WsbCatch ( hr );

    WsbTraceOut( L"AddMmcMenuItems", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}


STDMETHODIMP
CSakData::AddMenuItems (
    IN  LPDATAOBJECT          pDataObject, 
    IN  LPCONTEXTMENUCALLBACK pContextMenuCallback,
    OUT LONG*                 pInsertionAllowed
    )

/*++

Routine Description:

    Called for any node clicked on with right mouse. Goes to the
    node object to construct the MMC menu.

Arguments:

    pDataObject - identifies the node to be worked on.

    pContextMenuCallback - The MMC menu interface to use.

Return Value:

    S_OK - All added fine - continue.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::AddMenuItems", L"pDataObject = <0x%p>", pDataObject );

    HRESULT hr = S_OK;
    BOOL bMultiSelect;

    try {

        //
        // Note - snap-ins need to look at the data object and determine
        // in what context, menu items need to be added.

        // We should be expecting either single data object or Multi-Select
        // data object.  Not Object Types data object.
        //

        CComPtr<ISakNode>  pNode;
        CComPtr<IEnumGUID> pEnumObjectId;
        WsbAffirmHr( GetBaseHsmFromDataObject( pDataObject, &pNode, &pEnumObjectId ) );
        bMultiSelect = pEnumObjectId ? TRUE : FALSE;

        CMenu menu;
        HMENU hMenu;
        WsbAffirmHr( pNode->GetContextMenu ( bMultiSelect, &hMenu ) );

        menu.Attach( hMenu );

        //
        // Any menu returned by GetContextMenu should have three
        // top-level popups for the following portions of the 
        // MMC context menu:
        //
        // 1. Root (Above all other items)
        // 2. Create New
        // 3. Task
        //
        // If any of these should not have any items added for them,
        // the top-level item should not be a pop (sans MF_POPUP)
        //

        if( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP ) {

            WsbAffirmHr ( AddMmcMenuItems ( menu.GetSubMenu ( MENU_INDEX_ROOT ), 
                CCM_INSERTIONPOINTID_PRIMARY_TOP, pNode, pContextMenuCallback ) );

        }

        if( *pInsertionAllowed & CCM_INSERTIONALLOWED_NEW ) {

            WsbAffirmHr ( AddMmcMenuItems ( menu.GetSubMenu ( MENU_INDEX_NEW ), 
                CCM_INSERTIONPOINTID_PRIMARY_NEW, pNode, pContextMenuCallback ) );

        }

        if( *pInsertionAllowed & CCM_INSERTIONALLOWED_TASK ) {

            WsbAffirmHr ( AddMmcMenuItems ( menu.GetSubMenu ( MENU_INDEX_TASK ), 
                CCM_INSERTIONPOINTID_PRIMARY_TASK, pNode, pContextMenuCallback ) );

        }
        
    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::AddMenuItems", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}



STDMETHODIMP
CSakData::Command (
    IN  long         nCommandID,
    IN  LPDATAOBJECT pDataObject
    )

/*++

Routine Description:

    Called for any node receiving a menu command. Goes to the
    node object to handle the command, and allows general
    (not node-specific) commands to be handled centrally.

Arguments:

    nCommandID - ID of command.

    pDataObject - Data object representing the node.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::Command", L"nCommandID = <%ld>, pDataObject = <0x%p>", nCommandID, pDataObject );

    HRESULT hr = S_OK;

    try {

        HRESULT resultCommand = S_FALSE;

        //
        // All node commands are SHORT values. Check range first.
        //

        if ( 0 == ( nCommandID & SHORT_VALUE_RANGE ) ) {

            //
            // We start by getting the corresponding ISakNode interface 
            // to the node
            //
            
            CComPtr<ISakNode>  pNode;
            CComPtr<IEnumGUID> pEnumObjectId;
            WsbAffirmHr( GetBaseHsmFromDataObject ( pDataObject, &pNode, &pEnumObjectId ) );
            
            //
            // Then see if it wants to handle the command
            //
            
            WsbAffirmHr( ( resultCommand = pNode->InvokeCommand ( (SHORT)nCommandID, pDataObject ) ) );

        }

    } WsbCatch ( hr )

    WsbTraceOut( L"CSakData::Command", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}


STDMETHODIMP
CSakSnap::AddMenuItems (
    IN  LPDATAOBJECT          pDataObject, 
    IN  LPCONTEXTMENUCALLBACK pContextMenuCallback,
    OUT LONG*                 pInsertionAllowed
    )
/*++

Routine Description:

    Called for any node clicked on with right mouse in result pane.
    Delegates to CSakData.

Arguments:

    pDataObject - identifies the node to be worked on.

    pContextMenuCallback - The MMC menu interface to use.

Return Value:

    S_OK - All added fine - continue.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakSnap::AddMenuItems", L"pDataObject = <0x%p>", pDataObject );
    HRESULT hr = S_OK;
    try {

        WsbAffirmHr( m_pSakData->AddMenuItems( pDataObject, pContextMenuCallback, pInsertionAllowed ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::AddMenuItems", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakSnap::Command (
    IN  long         nCommandID,
    IN  LPDATAOBJECT pDataObject
    )

/*++

Routine Description:

    Called for any node receiving a menu command.
    Delegated to CSakData.

Arguments:

    nCommandID - ID of command.

    pDataObject - Data object representing the node.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakSnap::Command", L"nCommandID = <%ld>, pDataObject = <0x%p>", nCommandID, pDataObject );
    HRESULT hr;
    try {

        hr = m_pSakData->Command( nCommandID, pDataObject );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::Command", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\saknodei.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SakNodeI.h

Abstract:

    Template class for holding the icons for each node type derived
    from it.

Author:

    Art Bragg 9/26/97

Revision History:

--*/
#ifndef _CSAKNODI_H
#define _CSAKNODI_H


template <class T>
class CSakNodeImpl : public CSakNode {


protected:
    static int m_nScopeOpenIcon;    
    static int m_nScopeCloseIcon;  
    static int m_nScopeOpenIconX;   
    static int m_nScopeCloseIconX;  
    static int m_nResultIcon;  
    static int m_nResultIconX;  
    
public:
//---------------------------------------------------------------------------
//
//         get/SetScopeOpenIconIndex
//
//  Get/Put the virtual index of the Open Icon.
//

STDMETHODIMP GetScopeOpenIcon(BOOL bOK, int* pIconIndex)
{
    // return FALSE if the index has never been set
    if (bOK)
    {
        *pIconIndex = m_nScopeOpenIcon;
        return ((m_nScopeOpenIcon == UNINITIALIZED) ? S_FALSE : S_OK);
    } else {
        *pIconIndex = m_nScopeOpenIconX;
        return ((m_nScopeOpenIconX == UNINITIALIZED) ? S_FALSE : S_OK);
    }
}


//---------------------------------------------------------------------------
//
//         get/SetScopeCloseIconIndex
//
//  Get/Put the virtual index of the Close Icon.
//

STDMETHODIMP GetScopeCloseIcon(BOOL bOK, int* pIconIndex)
{
    // return FALSE if the index has never been set
    if (bOK) {
        *pIconIndex = m_nScopeCloseIcon;
        return ((m_nScopeCloseIcon == UNINITIALIZED) ? S_FALSE : S_OK);
    } else {
        *pIconIndex = m_nScopeCloseIconX;
        return ((m_nScopeCloseIconX == UNINITIALIZED) ? S_FALSE : S_OK);
    }
}


//---------------------------------------------------------------------------
//
//         get/SetResultIconIndex
//
//  Get/Put the virtual index of the Close Icon.
//

STDMETHODIMP GetResultIcon(BOOL bOK, int* pIconIndex)
{
    // return FALSE if the index has never been set
    if (bOK) {
        *pIconIndex = m_nResultIcon;
        return ((m_nResultIcon == UNINITIALIZED) ? S_FALSE : S_OK);
    } else {
        *pIconIndex = m_nResultIconX;
        return ((m_nResultIconX == UNINITIALIZED) ? S_FALSE : S_OK);
    }

}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\rsadutil.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsAdUtil.cpp

Abstract:

    Utility functions for GUI - for us in HSMADMIN files only

Author:

    Art Bragg [abragg]   04-Mar-1997

Revision History:

    Chris Timmes    [ctimmes]   21-Nov-1997  
    
    - modified RsCreateAndRunFsaJob(), RsCreateAndRunMediaCopyJob(),and 
      RsCreateAndRunMediaRecreateJob() to use the new Engine method CreateTask(), which
      creates a task in the NT Task Scheduler.  Change required due to changing Sakkara 
      to run under LocalSystem account.
      
--*/

#include "stdafx.h"


HRESULT
RsGetStatusString (
    DWORD    serviceStatus,
    HRESULT  hrSetup,
    CString& sStatus
    )
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch( serviceStatus ) {
    case SERVICE_STOPPED:
        sStatus.LoadString(IDS_SERVICE_STATUS_STOPPED);
        break;
    case SERVICE_START_PENDING:
        sStatus.LoadString(IDS_SERVICE_STATUS_START_PENDING);
        break;
    case SERVICE_STOP_PENDING:
        sStatus.LoadString(IDS_SERVICE_STATUS_STOP_PENDING);
        break;
    case SERVICE_RUNNING:
        //
        // See if we are setup yet
        //
        if( S_FALSE == hrSetup ) {

            sStatus.LoadString(IDS_SERVICE_STATUS_NOT_SETUP);

        } else {

            sStatus.LoadString(IDS_SERVICE_STATUS_RUNNING);

        }
        break;
    case SERVICE_CONTINUE_PENDING:
        sStatus.LoadString(IDS_SERVICE_STATUS_CONTINUE_PENDING);
        break;
    case SERVICE_PAUSE_PENDING:
        sStatus.LoadString(IDS_SERVICE_STATUS_PAUSE_PENDING);
        break;
    case SERVICE_PAUSED:
        sStatus.LoadString(IDS_SERVICE_STATUS_PAUSED);
        break;
    }
    return S_OK;
}

WCHAR *
RsNotifyEventAsString (
    IN  MMC_NOTIFY_TYPE event
    )
/*++

Routine Description:

    For debug purposes, converts the event type into a UNICODE string.

Arguments:

    event           - The event type

Return Value:

    String representing notify code - not I18N'd.

--*/
{
#define CASE_EVENT(x) case x: return TEXT(#x); break;
    
    switch( event )
    {

    CASE_EVENT( MMCN_ACTIVATE        )
    CASE_EVENT( MMCN_ADD_IMAGES      )
    CASE_EVENT( MMCN_BTN_CLICK       )
    CASE_EVENT( MMCN_CLICK           )
    CASE_EVENT( MMCN_COLUMN_CLICK    )
    CASE_EVENT( MMCN_CONTEXTMENU     )
    CASE_EVENT( MMCN_CUTORMOVE       )
    CASE_EVENT( MMCN_DBLCLICK        )
    CASE_EVENT( MMCN_DELETE          )
    CASE_EVENT( MMCN_DESELECT_ALL    )
    CASE_EVENT( MMCN_EXPAND          )
    CASE_EVENT( MMCN_HELP            )
    CASE_EVENT( MMCN_MENU_BTNCLICK   )
    CASE_EVENT( MMCN_MINIMIZED       )
    CASE_EVENT( MMCN_PASTE           )
    CASE_EVENT( MMCN_PROPERTY_CHANGE )
    CASE_EVENT( MMCN_QUERY_PASTE     )
    CASE_EVENT( MMCN_REFRESH         )
    CASE_EVENT( MMCN_REMOVE_CHILDREN )
    CASE_EVENT( MMCN_RENAME          )
    CASE_EVENT( MMCN_SELECT          )
    CASE_EVENT( MMCN_SHOW            )
    CASE_EVENT( MMCN_VIEW_CHANGE     )
    CASE_EVENT( MMCN_SNAPINHELP      )
    CASE_EVENT( MMCN_CONTEXTHELP     )
    CASE_EVENT( MMCN_INITOCX         )
    CASE_EVENT( MMCN_FILTER_CHANGE   )
    CASE_EVENT( MMCN_FILTERBTN_CLICK )
    CASE_EVENT( MMCN_RESTORE_VIEW    )
    CASE_EVENT( MMCN_PRINT           )
    CASE_EVENT( MMCN_PRELOAD         )
    CASE_EVENT( MMCN_LISTPAD         )
    CASE_EVENT( MMCN_EXPANDSYNC      )

    default:
        static WCHAR buf[32];
        swprintf( buf, L"Unknown Event[0x%p]", event );
        return( buf );
    }
}


WCHAR *
RsClipFormatAsString (
    IN  CLIPFORMAT cf
    )
/*++

Routine Description:

    For debug purposes, converts the event type into a UNICODE string.

Arguments:

    event           - The event type

Return Value:

    String representing notify code - not I18N'd.

--*/
{
    static WCHAR buf[128];

    GetClipboardFormatName( cf, buf, 128 );
    return( buf );
}


HRESULT
RsIsRemoteStorageSetup(
    void
    )
/*++

Routine Description:

    Reports back if Remote Storage has been set up on this machine.

Arguments:

    none.

Return Value:

    S_OK if setup
    S_FALSE if not

--*/
{
    WsbTraceIn( L"RsIsRemoteStorageSetup", L"" );
    HRESULT hr = S_FALSE;

    try {
    
        //
        // First, see if service is registered
        //

        CWsbStringPtr hsmName;
        WsbTrace( L"Checking if service is registered\n" );
        WsbAffirmHr( WsbGetServiceInfo( APPID_RemoteStorageEngine, &hsmName, 0 ) );

        //
        // Second, contact the engine. this will start the service if it
        // is not already started.
        //

        CWsbStringPtr computerName;
        WsbAffirmHr( WsbGetComputerName( computerName ) );

        CComPtr<IHsmServer> pHsm;
        WsbTrace( L"Contacting Engine\n" );
        WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, computerName, IID_IHsmServer, (void**)&pHsm ) );

        //
        // Third, see if it has a storage pool ID
        //

        hr = RsIsRemoteStorageSetupEx( pHsm );

    } WsbCatch( hr );


    WsbTraceOut( L"RsIsRemoteStorageSetup", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

void 
RsReportError( HRESULT hrToReport, int textId, ... ) 
/*++

Routine Description:

    Reports an error to the user.

Arguments:

    hrToReport - the hr that was thrown
    textId      - Resource Id of context of the error
    ...         - Substitution arguments for textId

Return Value:

    none

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Make sure we don't report S_OK, S_FALSE
    //
    if( FAILED( hrToReport ) ) {

        CString errorText;
        CString formatString;

        //
        // Substitute in the text context string
        //
        va_list list;
        va_start( list, textId );

        formatString.LoadString( textId );
        LPTSTR p;
        p = errorText.GetBuffer( 1024 );
        vswprintf( p, (LPCTSTR) formatString, list );
        errorText.ReleaseBuffer();

        va_end( list );


        CWsbStringPtr hrText;
        CString msgText;
        CString headerText;

        //
        // Put together the complete text
        //
        hrText = WsbHrAsString( hrToReport );
        headerText.LoadString( IDS_ERROR_HEADER );
        msgText = headerText + L"\n\r\n\r" + errorText + L"\n\r\n\r" + hrText;

        //
        // Show the message
        //
        AfxMessageBox( msgText, RS_MB_ERROR );

    }
}





HRESULT
RsIsRemoteStorageSetupEx(
    IHsmServer * pHsmServer
    )
/*++

Routine Description:

    Reports back if Remote Storage has been set up on this machine.

Arguments:

    none.

Return Value:

    S_OK if setup
    S_FALSE if not

--*/
{
    WsbTraceIn( L"RsIsRemoteStorageSetupEx", L"" );
    HRESULT hr = S_FALSE;

    try {
    
        //
        // If it has a Media Set ID, it's set up.
        //

        GUID guid;
        CWsbBstrPtr poolName;
        CComPtr<IHsmStoragePool> pPool;
        WsbAffirmHr( RsGetStoragePool( pHsmServer, &pPool ) );
        WsbAffirmHr( pPool->GetMediaSet( &guid, &poolName ) );

        if( ! IsEqualGUID( guid, GUID_NULL ) ) {

            hr = S_OK;

        }
    
    } WsbCatch( hr );

    WsbTraceOut( L"RsIsRemoteStorageSetupEx", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
RsIsSupportedMediaAvailable(
    void
    )
/*++

Routine Description:

    Checks to see if NTMS is setup, and setup with useable media.

Arguments:

    none.

Return Value:

    TRUE if NTMS is configured with supported media
    FALSE if NTMS is not configured with supported media

--*/
{
    WsbTraceIn( L"RsIsSupportedMediaAvailable", L"" );
    HRESULT hr = S_FALSE;

    try {
        
        //
        // First, contact the RMS engine and ask it if 
        // RMS has supported media.
        //

        CWsbStringPtr computerName;
        WsbAffirmHr( WsbGetComputerName( computerName ) );
        CComPtr<IHsmServer> pHsm;
        CComPtr<IRmsServer> pRms;
        WsbTrace( L"Contacting HSM Server to get RMS\n" );
        WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, computerName, IID_IHsmServer, (void**)&pHsm ) );
        WsbAffirmPointer(pHsm);
        WsbAffirmHr(pHsm->GetHsmMediaMgr(&pRms));
        WsbTrace( L"Connected to RMS\n" );

        //
        // Second, wait for RMS to finish initializing, thus
        // to have all media sets added
        //

        {
            CComObject<CRmsSink> *pSink = new CComObject<CRmsSink>;
            CComPtr<IUnknown> pSinkUnk = pSink;
            WsbAffirmHr( pSink->Construct( pRms ) );

            WsbAffirmHr( pSink->WaitForReady( ) );

            WsbAffirmHr( pSink->DoUnadvise( ) );
        }

        //
        // Fourth
        // Ask it
        //

        CComPtr<IWsbIndexedCollection> pMediaSets;
        WsbAffirmHr( pRms->GetMediaSets( &pMediaSets ) );

        ULONG numEntries;
        WsbTrace( L"Checking for Media Sets\n" );
        WsbAffirmHr( pMediaSets->GetEntries( &numEntries ) );

        WsbTrace( L"NumMediaSets = 0x%lu\n", numEntries );

        if( numEntries > 0 ) {

            //
            // All conditions met, return TRUE
            //

            WsbTrace( L"Supported Media Found\n" );

            hr = S_OK;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"RsIsSupportedMediaAvailable", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

USHORT
RsGetCopyStatus(
    IN  REFGUID   CopyId,
    IN  HRESULT   CopyHr,
    IN  SHORT     CopyNextDataSet,
    IN  SHORT     LastGoodNextDataSet
    )
/*++

Routine Description:

    Compares the two times and returns an appropriate defined value
    based upon comparison (for Media Copies)

Arguments:

    MasterTime - the time of last update to master

    CopyTime - the time of last update to copy

    copyStatus - returned value

Return Value:

    none

--*/
{
    WsbTraceIn( L"RsGetCopyStatus", L"CopyId = <%ls>, CopyHr = <%ls>, CopyNextDataSet = <%hd>, LastGoodNextDataSet = <%hd>", WsbGuidAsString( CopyId ), WsbHrAsString( CopyHr ), CopyNextDataSet, LastGoodNextDataSet );
    USHORT copyStatus;

    //
    // Certain errors need to be masked out because they do not necessarily
    // mean the media copy has an error - just that something happened that
    // was unexpected, like timed out mounts or canceled mounts
    //
    switch( CopyHr ) {

    case RMS_E_CANCELLED:
    case RMS_E_REQUEST_REFUSED:
    case RMS_E_WRITE_PROTECT:
    case RMS_E_MEDIA_OFFLINE:
    case RMS_E_TIMEOUT:
    case RMS_E_SCRATCH_NOT_FOUND:
    case RMS_E_CARTRIDGE_UNAVAILABLE:
    case RMS_E_CARTRIDGE_DISABLED:

        CopyHr = S_OK;
        break;

    }

    if( IsEqualGUID( CopyId, GUID_NULL ) ) {

        copyStatus = RS_MEDIA_COPY_STATUS_NONE;

    } else if( RMS_E_CARTRIDGE_NOT_FOUND == CopyHr ) {

        copyStatus = RS_MEDIA_COPY_STATUS_MISSING;

    } else if( FAILED( CopyHr ) ) {

        copyStatus = RS_MEDIA_COPY_STATUS_ERROR;

    } else if( CopyNextDataSet < LastGoodNextDataSet ) {

        copyStatus = RS_MEDIA_COPY_STATUS_OUTSYNC;

    } else {

        copyStatus = RS_MEDIA_COPY_STATUS_INSYNC;

    }

    WsbTraceOut( L"RsGetCopyStatus", L"copyStatus = <%hu>", copyStatus );
    return copyStatus;
}

HRESULT
RsGetCopyStatusStringVerb(
    IN  USHORT    copyStatus,
    IN  BOOL    plural,
    OUT CString & statusString
    )
/*++

Routine Description:

    Creates and returns a status string based on the status, with
    a verb on it, for example "is synchronized"

Arguments:

    copyStatus - defined status for media copies

    plural - true if verb should be plural

    String - Resulting string

Return Value:

    non.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( L"RsGetCopyStatusStringVerb", L"CopyStatus = <%hu> ", copyStatus );
    switch ( copyStatus ) {
    case RS_MEDIA_COPY_STATUS_NONE:
        if ( plural )
            statusString.LoadString( IDS_CAR_COPYSET_NONE_PLURAL );
        else
            statusString.LoadString( IDS_CAR_COPYSET_NONE_SINGULAR );
        break;
    case RS_MEDIA_COPY_STATUS_ERROR:
        statusString.LoadString( IDS_CAR_COPYSET_ERROR_SP );
        break;
    case RS_MEDIA_COPY_STATUS_MISSING:
        if ( plural )
            statusString.LoadString( IDS_CAR_COPYSET_MISSING_PLURAL );
        else
            statusString.LoadString( IDS_CAR_COPYSET_MISSING_SINGULAR );
        break;
    case RS_MEDIA_COPY_STATUS_OUTSYNC:
        if ( plural )
            statusString.LoadString( IDS_CAR_COPYSET_OUTSYNC_PLURAL );
        else
            statusString.LoadString( IDS_CAR_COPYSET_OUTSYNC_SINGULAR );
        break;
    case RS_MEDIA_COPY_STATUS_INSYNC:
        if ( plural )
            statusString.LoadString( IDS_CAR_COPYSET_INSYNC_PLURAL );
        else
            statusString.LoadString( IDS_CAR_COPYSET_INSYNC_SINGULAR );
        break;
    default:
        statusString = L"";
        hr = E_INVALIDARG;
        break;
    }
    WsbTraceOut( L"RsGetCopyStatusStringVerb", L"String = <%ls>", statusString );
    return hr;
}

HRESULT
RsGetCopyStatusString(
    IN  USHORT    copyStatus,
    OUT CString & statusString
    )
/*++

Routine Description:

    Creates and returns a status string based on the status

Arguments:

    copyStatus - defined status for media copies

    String - Resulting string

Return Value:

    non.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( L"RsGetCopyStatusString", L"CopyStatus = <%hu> ", copyStatus );
    switch ( copyStatus ) {
    case RS_MEDIA_COPY_STATUS_NONE:
        statusString.LoadString( IDS_CAR_COPYSET_NONE );
        break;
    case RS_MEDIA_COPY_STATUS_ERROR:
        statusString.LoadString( IDS_CAR_COPYSET_ERROR );
        break;
    case RS_MEDIA_COPY_STATUS_MISSING:
        statusString.LoadString( IDS_CAR_COPYSET_MISSING );
        break;
    case RS_MEDIA_COPY_STATUS_OUTSYNC:
        statusString.LoadString( IDS_CAR_COPYSET_OUTSYNC );
        break;
    case RS_MEDIA_COPY_STATUS_INSYNC:
        statusString.LoadString( IDS_CAR_COPYSET_INSYNC );
        break;
    default:
        statusString = L"";
        hr = E_INVALIDARG;
        break;
    }
    WsbTraceOut( L"RsGetCopyStatusString", L"String = <%ls>", statusString );
    return hr;
}


USHORT
RsGetCartStatus(
    IN  HRESULT   LastHr,
    IN  BOOL      ReadOnly,
    IN  BOOL      Recreate,
    IN  SHORT     NextDataSet,
    IN  SHORT     LastGoodNextDataSet
    )
/*++

Routine Description:

    Returns a constant appropriate the status of a piece of media.

Arguments:

    MasterTime - the time of last update to master

    CopyTime - the time of last update to copy

Return Value:

    defined constant for media status

--*/
{
    USHORT cartStatus;
    if( Recreate ) {

        cartStatus = RS_MEDIA_STATUS_RECREATE;

    } else if( NextDataSet < LastGoodNextDataSet ) {

        cartStatus = RS_MEDIA_STATUS_ERROR_INCOMPLETE;
        
    } else if( SUCCEEDED( LastHr ) || ( RMS_E_CARTRIDGE_DISABLED == LastHr ) ) {

        cartStatus = ( ReadOnly ? RS_MEDIA_STATUS_READONLY : RS_MEDIA_STATUS_NORMAL );

    } else if( RMS_E_CARTRIDGE_NOT_FOUND == LastHr ) {

        cartStatus = RS_MEDIA_STATUS_ERROR_MISSING;

    } else {

        cartStatus = ( ReadOnly ? RS_MEDIA_STATUS_ERROR_RO : RS_MEDIA_STATUS_ERROR_RW );

    }
    return cartStatus;
}

HRESULT
RsGetCartStatusStringVerb(
    IN USHORT cartStatus,
    IN BOOL plural,
    OUT CString & statusString
    )
/*++

Routine Description:

    Retreives a string appropriate the status of a piece of media with
    a verb on it, for example "is read-only"

Arguments:
    
    cartStatus


    String - Resulting string

Return Value:

    non.

--*/
{
    HRESULT hr = S_OK;
    switch( cartStatus ) {

    case RS_MEDIA_STATUS_RECREATE:
        if( plural ) {

            statusString.LoadString( IDS_CAR_STATUS_RECREATE_PLURAL );

        } else  {

            statusString.LoadString( IDS_CAR_STATUS_RECREATE_SINGULAR  );

        }
        break;

    case RS_MEDIA_STATUS_READONLY:
        if( plural ) {

            statusString.LoadString( IDS_CAR_STATUS_READONLY_PLURAL );

        } else {

            statusString.LoadString( IDS_CAR_STATUS_READONLY_SINGULAR );

        }
        break;

    case RS_MEDIA_STATUS_NORMAL:
        if( plural ) {

            statusString.LoadString( IDS_CAR_STATUS_NORMAL_PLURAL );

        } else {

            statusString.LoadString( IDS_CAR_STATUS_NORMAL_SINGULAR );

        }
        break;

    case RS_MEDIA_STATUS_ERROR_RO:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_RO_SP );
        break;

    case RS_MEDIA_STATUS_ERROR_RW:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_RW_SP );
        break;

    case RS_MEDIA_STATUS_ERROR_INCOMPLETE:
        if( plural ) {

            statusString.LoadString( IDS_CAR_STATUS_ERROR_INCOMPLETE_PLURAL );

        } else {

            statusString.LoadString( IDS_CAR_STATUS_ERROR_INCOMPLETE_SINGULAR );

        }
        break;

    case RS_MEDIA_STATUS_ERROR_MISSING:
        if( plural ) {

            statusString.LoadString( IDS_CAR_STATUS_ERROR_MISSING_PLURAL );

        } else {

            statusString.LoadString( IDS_CAR_STATUS_ERROR_MISSING_SINGULAR );

        }
        break;

    default:
        statusString = L"";
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT
RsGetCartStatusString(
    IN USHORT cartStatus,
    OUT CString & statusString
    )
/*++

Routine Description:

    Retreives a string appropriate the status of a piece of media.

Arguments:
    
    cartStatus


    String - Resulting string

Return Value:

    non.

--*/
{
    HRESULT hr = S_OK;
    switch( cartStatus ) {

    case RS_MEDIA_STATUS_RECREATE:
        statusString.LoadString( IDS_CAR_STATUS_RECREATE );
        break;

    case RS_MEDIA_STATUS_READONLY:
        statusString.LoadString( IDS_CAR_STATUS_READONLY );
        break;

    case RS_MEDIA_STATUS_NORMAL:
        statusString.LoadString( IDS_CAR_STATUS_NORMAL );
        break;

    case RS_MEDIA_STATUS_ERROR_RO:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_RO );
        break;

    case RS_MEDIA_STATUS_ERROR_RW:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_RW );
        break;

    case RS_MEDIA_STATUS_ERROR_MISSING:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_MISSING );
        break;

    case RS_MEDIA_STATUS_ERROR_INCOMPLETE:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_INCOMPLETE );
        break;

    default:
        statusString = L"";
        hr = E_INVALIDARG;
    }

    return( hr );
}

HRESULT
RsGetCartMultiStatusString(
    IN USHORT statusRecreate,
    IN USHORT statusReadOnly,
    IN USHORT statusNormal,
    IN USHORT statusRO,
    IN USHORT statusRW,
    IN USHORT statusMissing,
    OUT CString &outString )
{
    HRESULT hr = S_OK;
    try {

        outString = L"";
        CString statusString;
        CString formatString;
        BOOL    skipSeparator = TRUE; // used to omit first prepended comma

#define INSERT_SEPARATOR if( ! skipSeparator ) { outString += ", "; } else { skipSeparator = FALSE; }

        if( statusNormal > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_NORMAL, ( statusNormal != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusNormal, statusString );
            outString += formatString;

        }

        if( statusReadOnly > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_READONLY, ( statusReadOnly != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusReadOnly, statusString );
            outString += formatString;

        }

        if( statusRecreate > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_RECREATE, ( statusRecreate != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusRecreate, statusString );
            outString += formatString;

        }

        if( statusRO > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_ERROR_RO, ( statusRO != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusRO, statusString );
            outString += formatString;

        }

        if( statusRW > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_ERROR_RW, ( statusRW != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusRW, statusString );
            outString += formatString;

        }

        if( statusMissing > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_ERROR_MISSING, ( statusMissing != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusMissing, statusString );
            outString += formatString;

        }

    } WsbCatch( hr );
    return( hr );
}

HRESULT
RsGetCopyMultiStatusString( 
    IN USHORT statusNone, 
    IN USHORT statusError, 
    IN USHORT statusOutSync, 
    IN USHORT statusInSync,
    OUT CString &outString
    )
{
    HRESULT hr = S_OK;
    try {
        outString = L"";
        CString statusString;
        CString formatString;


        WsbAffirmHr( RsGetCopyStatusStringVerb( RS_MEDIA_COPY_STATUS_INSYNC, ( statusInSync != 1), statusString ) );
        formatString.Format( L"%d %s, ", statusInSync, statusString );
        outString += formatString;

        WsbAffirmHr( RsGetCopyStatusStringVerb( RS_MEDIA_COPY_STATUS_OUTSYNC, ( statusOutSync != 1), statusString ) );
        formatString.Format( L"%d %s, ", statusOutSync, statusString );
        outString += formatString;

        WsbAffirmHr( RsGetCopyStatusStringVerb( RS_MEDIA_COPY_STATUS_NONE, ( statusNone != 1), statusString ) );
        formatString.Format( L"%d %s, ", statusNone, statusString );
        outString += formatString;

        WsbAffirmHr( RsGetCopyStatusStringVerb( RS_MEDIA_COPY_STATUS_ERROR, ( statusError != 1 ), statusString ) );
        formatString.Format( L"%d %s, ", statusError, statusString );
        outString += formatString;

        WsbAffirmHr( RsGetCopyStatusStringVerb( RS_MEDIA_COPY_STATUS_MISSING, ( statusError != 1 ), statusString ) );
        formatString.Format( L"%d %s", statusError, statusString );
        outString += formatString;
    } WsbCatch (hr);
    return hr;
}



HRESULT
RsCreateAndRunFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource,
    IN  BOOL ShowMsg
    )
///////////////////////////////////////////////////////////////////////
//
//      RsCreateAndRunFsaJob
//
// Creates a job in the engine of the given type, since scanning of a 
// resource is required by the job, and since the job is partitioned 
// across the Remote Storage major components.  Puts the job in the
// NT Task Scheduler and runs it now via a call to the Engine's CreateTask()
// method.  The Task Scheduler task is Disabled, so it will not be run 
// according to a schedule.
//
//
{
    WsbTraceIn( L"RsCreateAndRunFsaJob", L"jobType = <%d>", jobType );
                                    

    HRESULT hr = S_OK;
    CComPtr<IWsbCreateLocalObject>  pLocalObject;
    CComPtr<IHsmJob>                pExistJob;
    CComPtr<IHsmJob>                pNewJob;
    CWsbStringPtr                   pszExistJobName;

    try {

        WsbAssertPointer( pFsaResource );
        WsbAssertPointer( pHsmServer );

        //
        // First check to see if volume is available. If not, return
        // S_FALSE
        //
        HRESULT hrAvailable = pFsaResource->IsAvailable( );
        WsbAffirmHr( hrAvailable );
        HRESULT hrDeletePending = pFsaResource->IsDeletePending( );
        WsbAffirmHr( hrDeletePending );

        WsbAffirm( ( S_OK == hrAvailable ) && ( S_OK != hrDeletePending ), S_FALSE );

        //
        // Get the volume name
        //
        CWsbStringPtr szWsbVolumeName;
        WsbAffirmHr( pFsaResource->GetName( &szWsbVolumeName, 0 ) );

        //
        // Create a job name
        //
        CString jobName;
        RsCreateJobName( jobType, pFsaResource, jobName );

        //
        // Exit with an error if a job of this name is active already
        //
        if (S_OK == pHsmServer->FindJobByName( (LPWSTR)(LPCWSTR)jobName, &pExistJob)) {
            if (S_OK == pExistJob->IsActive()) {
                WsbThrow(JOB_E_ALREADYACTIVE);
            }
        }
        
        //
        // Inform the user, then create the job in the Engine, finally create 
        // and start the job in the NT Task Scheduler.
        //
        CString szJobType;
        WsbAffirmHr( RsGetJobTypeString( jobType, szJobType ) );
        CWsbStringPtr computerName;
        WsbAffirmHr( pHsmServer->GetName( &computerName ) );
        CString message;
        AfxFormatString2( message, IDS_RUN_JOB, jobName, computerName );

        if( !ShowMsg || ( AfxMessageBox( message, MB_ICONINFORMATION | MB_OKCANCEL | 
                                                    MB_DEFBUTTON2 ) == IDOK ) ) {
            //
            // Get the one and only (for Sakkara) storage pool Id
            //
            GUID storagePoolId;
            WsbAffirmHr( RsGetStoragePoolId( pHsmServer, &storagePoolId ) );

            //
            // Get a CreateLocalobject interface with which to create the job
            //
            WsbAffirmHr( RsQueryInterface( pHsmServer, IWsbCreateLocalObject, pLocalObject ) );

            //
            // Create the new job in the engine
            //
            WsbAffirmHr( pLocalObject->CreateInstance( CLSID_CHsmJob, IID_IHsmJob, (void**) &pNewJob ) );
            WsbAffirmHr( pNewJob->InitAs(
                (LPWSTR)(LPCWSTR)jobName, NULL, jobType, storagePoolId, 
                pHsmServer, TRUE, pFsaResource));

            //
            // Get the jobs collection from the engine
            //
            CComPtr<IWsbIndexedCollection> pJobs;
            WsbAffirmHr( pHsmServer->GetJobs( &pJobs ) );

            //
            // If any jobs exist with this name, delete them
            //
            ULONG cCount;
            WsbAffirmHr (pJobs->GetEntries( &cCount ) );
            for( UINT i = 0; i < cCount; i++ ) {

                pExistJob.Release( );
                WsbAffirmHr( pJobs->At( i, IID_IHsmJob, (void **) &pExistJob ) );
                WsbAffirmHr( pExistJob->GetName( &pszExistJobName, 0 ) );
                if( pszExistJobName.IsEqual( jobName ) ) {

                    WsbAffirmHr( pJobs->RemoveAndRelease( pExistJob ) );
                    i--; cCount--;

                }
            }

            //
            // Add the new job to the engine collection
            //
            WsbAffirmHr( pJobs->Add( pNewJob ) );

            //
            // Set up to call the Engine to create an entry in NT Task Scheduler
            //
            // Create the parameter string to the program NT Scheduler
            // will run (for Sakkara this is RsLaunch).
            //
            CString szParameters;
            szParameters.Format( L"run \"%ls\"", jobName );

            //
            // Create the comment string for the NT Scheduler entry
            //
            CString commentString;
            AfxFormatString2( commentString, IDS_GENERIC_JOB_COMMENT, szJobType, szWsbVolumeName);

            //
            // Declare and initialize the schedule components passed to 
            // the engine.  Since this task is Disabled these are simply
            // set to 0 (COM requires populating all arguments).
            //
            TASK_TRIGGER_TYPE   jobTriggerType = TASK_TIME_TRIGGER_ONCE;
            WORD                jobStartHour   = 0;
            WORD                jobStartMinute = 0;

            //
            // Indicate this is a Disabled task
            //
            BOOL                scheduledJob   = FALSE;

            //
            // Create and run the task
            //
            WsbAffirmHr( pHsmServer->CreateTask( jobName, szParameters,
                                                  commentString, jobTriggerType,
                                                  jobStartHour, jobStartMinute,
                                                  scheduledJob ) );
        }

    } WsbCatch( hr );

    WsbTraceOut( L"RsCreateAndRunFsaJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
RsCreateAndRunDirectFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource,
    IN  BOOL waitJob
    )
///////////////////////////////////////////////////////////////////////
//
//      RsCreateAndRunFsaJob
//
// Creates a job in the engine of the given type and run it.
// Wait for the job if required.
// Notes:
// 1) This job is not created and ran through the Task Scheduler
// 2) Most of the code is taken from StartJob in clivol.cpp
//    In the future we should consider using this code instead of replicating
//
{
    WsbTraceIn( L"RsCreateAndRunDirectFsaJob", L"jobType = <%d>", jobType );
                                    
    HRESULT hr = S_OK;

    try {
        CComPtr<IHsmJob>    pJob;
        CString             jobName;

        // Create job name
        WsbAffirmHr(RsCreateJobName(jobType, pFsaResource, jobName));

        // If job exists - use it, otherwize, craete and add an appropriate job object
        hr = pHsmServer->FindJobByName((LPWSTR)(LPCWSTR)jobName, &pJob);
        if (S_OK == hr) {
            // Job already exists

        } else if (WSB_E_NOTFOUND == hr) {
            // No such job yet
            CComPtr<IWsbCreateLocalObject>  pCreateObj;
            CComPtr<IWsbIndexedCollection>  pJobs;
            CComPtr<IWsbIndexedCollection>  pCollection;
            CComPtr<IHsmStoragePool>        pStoragePool;
            GUID                            poolId;
            ULONG                           count;

            hr = S_OK;
            pJob = 0;

            // Create and add the job
            WsbAffirmHr(pHsmServer->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
            WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmJob, IID_IHsmJob, (void**) &pJob));

            WsbAffirmHr(pHsmServer->GetStoragePools(&pCollection));
            WsbAffirmHr(pCollection->GetEntries(&count));
            WsbAffirm(1 == count, E_FAIL);
            WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));
            WsbAffirmHr(pStoragePool->GetId(&poolId));

            WsbAffirmHr(pJob->InitAs((LPWSTR)(LPCWSTR)jobName, NULL, jobType, 
                                poolId, pHsmServer, TRUE, pFsaResource));
            WsbAffirmHr(pHsmServer->GetJobs(&pJobs));
            WsbAffirmHr(pJobs->Add(pJob));

        } else {
            // Other error - abort
            WsbThrow(hr);
        }

        // Start the job
        WsbAffirmHr(pJob->Start());

        // Wait if required
        if (waitJob) {
            WsbAffirmHr(pJob->WaitUntilDone());
        }

    } WsbCatch(hr);

    WsbTraceOut( L"RsCreateAndRunDirectFsaJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
RsCancelDirectFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource
    )
///////////////////////////////////////////////////////////////////////
//
//      RsCancelDirectFsaJob
//
// Cancel a job that was previously ran with RsCreateAndRunDirectFsaJob
// Notes:
// 1) This job is not cancelled through the Task Scheduler
// 2) Most of the code is taken from CancelJob in clivol.cpp
//    In the future we should consider using this code instead of replicating
//
{
    WsbTraceIn( L"RsCancelDirectFsaJob", L"jobType = <%d>", jobType );
                                    
    HRESULT hr = S_OK;

    try {
        CComPtr<IHsmJob>    pJob;
        CString             jobName;

        // Create job name
        WsbAffirmHr(RsCreateJobName(jobType, pFsaResource, jobName));

        // If job exists, try to cancel it
        hr = pHsmServer->FindJobByName((LPWSTR)(LPCWSTR)jobName, &pJob);
        if (S_OK == hr) {
            // Cancel (we don't care if it's actually running or not)
            WsbAffirmHr(pJob->Cancel(HSM_JOB_PHASE_ALL));

        } else if (WSB_E_NOTFOUND == hr) {
            // No such job, for sure it is not running...
            hr = S_OK;

        } else {
            // Other error - abort
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut( L"RsCancelDirectFsaJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
RsCreateJobName(
    IN  HSM_JOB_DEF_TYPE jobType, 
    IN  IFsaResource *   pResource,
    OUT CString&         jobName
    )
/////////////////////////////////////////////////////////////////////////////////
//
//              RsCreateJobName
//
// Creates a job name for a volume type job
//
//
{
    WsbTraceIn( L"RsCreateJobName", L"jobType = <%d>", jobType );

    HRESULT hr = S_OK;
    try {

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        CString jobTypeString;
        RsGetJobTypeString( jobType, jobTypeString );

        CWsbStringPtr path;
        WsbAffirmHr( pResource->GetUserFriendlyName( &path, 0 ) );

        // For now, ignore the path if it's not a drive letter
        size_t pathLen = wcslen(path);
        if ((pathLen != 3) || (path[1] != L':')) {
            path = L"";
        }

        CString volumeString;
        if( path.IsEqual ( L"" ) ) {

            //
            // No drive letter - use the volume name and serial number instead
            //
            ULONG   serial;
            CWsbStringPtr name;

            WsbAffirmHr( pResource->GetName( &name, 0 ) );
            WsbAffirmHr( pResource->GetSerial( &serial ) );

            if( name.IsEqual( L"" ) ) {

                //
                // No name, no drive letter - just have serial number
                //
                volumeString.Format( L"%8.8lx", serial );

            } else {

                volumeString.Format( L"%ls-%8.8lx", (OLECHAR*)name, serial );

            }

        } else {

            path[1] = L'\0';
            volumeString = path;

        }
        AfxFormatString2( jobName, IDS_JOB_NAME_PREFIX, jobTypeString, volumeString );

    } WsbCatch (hr);

    WsbTraceOut( L"RsCreateJobName", L"hr = <%ls>, jobName = <%ls>", WsbHrAsString( hr ), (LPCWSTR)jobName );
    return( hr );
}



HRESULT
RsGetJobTypeString(
    IN  HSM_JOB_DEF_TYPE jobType,
    OUT CString&         szJobType
    )
{
    WsbTraceIn( L"RsGetJobTypeString", L"jobType = <%d>", jobType );

    HRESULT hr = S_OK;
    try {
        switch( jobType ) {
        case HSM_JOB_DEF_TYPE_MANAGE:
            szJobType.LoadString( IDS_JOB_MANAGE );
            break;
        case HSM_JOB_DEF_TYPE_RECALL:
            szJobType.LoadString( IDS_JOB_RECALL );
            break;
        case HSM_JOB_DEF_TYPE_TRUNCATE:
            szJobType.LoadString( IDS_JOB_TRUNCATE );
            break;
        case HSM_JOB_DEF_TYPE_UNMANAGE:
            szJobType.LoadString( IDS_JOB_UNMANAGE );
            break;
        case HSM_JOB_DEF_TYPE_FULL_UNMANAGE:
            szJobType.LoadString( IDS_JOB_FULL_UNMANAGE );
            break;
        case HSM_JOB_DEF_TYPE_QUICK_UNMANAGE:
            szJobType.LoadString( IDS_JOB_QUICK_UNMANAGE );
            break;
        case HSM_JOB_DEF_TYPE_VALIDATE:
            szJobType.LoadString( IDS_JOB_VALIDATE );
            break;
        default:
            WsbAssert( FALSE, E_INVALIDARG );
        }
    } WsbCatch ( hr );

    WsbTraceOut( L"RsGetJobTypeString", L"hr = <%ls>, szJobType = <%ls>", WsbHrAsString( hr ), (LPCWSTR)szJobType );
    return( hr );
}



HRESULT
RsCreateAndRunMediaCopyJob(
    IN  IHsmServer * pHsmServer,
    IN  UINT         SetNum,
    IN  BOOL         ShowMsg
    )
///////////////////////////////////////////////////////////////////////
//
//      RsCreateAndRunMediaCopyJob
//
// Creates and runs a task to synchronize (update) a specified copy set.
// Since the Media Copy Job is run via a single Engine method (there is no 
// partitioning of the task across major components) and no scanning of 
// files/resources/etc is required to run it, this method does not create 
// a job in the Engine.  It only creates a task in the NT Task Scheduler and 
// runs it now via a call to the Engine's CreateTask() method.  The Task 
// Scheduler task is Disabled, so it will not be run according to a schedule.
//
//
{
    WsbTraceIn( L"RsCreateAndRunMediaCopyJob", L"SetNum = <%u>", SetNum );

    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pHsmServer );
        
        // Create the task name to put in the scheduler

        CString jobName, message;
        jobName.Format( IDS_JOB_MEDIA_COPY_TITLE, SetNum ); 
        CWsbStringPtr computerName;
        WsbAffirmHr( pHsmServer->GetName( &computerName ) );
        AfxFormatString2( message, IDS_RUN_JOB, jobName, computerName );
        if( !ShowMsg || ( AfxMessageBox( message, MB_ICONINFORMATION | 
                                            MB_OKCANCEL ) == IDOK ) ) {
            // Set up to call the Engine to create an entry in NT Task Scheduler

            // Create the parameter string to the program NT Scheduler 
            // will run (for Sakkara this is RsLaunch)
            CString szParameters;
            szParameters.Format( L"sync %d", SetNum );

            // Create the comment string for the NT Scheduler entry
            CString commentString;
            commentString.Format( IDS_MEDIA_COPY_JOB_COMMENT, SetNum );

            // Declare and initialize the schedule components passed to 
            // the engine.  Since this task is Disabled these are simply
            // set to 0 (COM requires populating all arguments).
            TASK_TRIGGER_TYPE   jobTriggerType = TASK_TIME_TRIGGER_ONCE;
            WORD                jobStartHour   = 0;
            WORD                jobStartMinute = 0;

            // Indicate this is a Disabled task
            BOOL                scheduledJob   = FALSE;

            // Create and run the task
            WsbAffirmHr( pHsmServer->CreateTask( jobName, szParameters,
                                                  commentString, jobTriggerType,
                                                  jobStartHour, jobStartMinute,
                                                  scheduledJob ) );
        }
    } WsbCatch (hr);

    WsbTraceOut( L"RsCreateAndRunMediaCopyJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



HRESULT
RsCreateAndRunMediaRecreateJob(
    IN  IHsmServer * pHsmServer,
    IN  IMediaInfo * pMediaInfo,
    IN  REFGUID      MediaId,
    IN  CString &    MediaDescription,
    IN  SHORT        CopyToUse
    )
///////////////////////////////////////////////////////////////////////
//
//      RsCreateAndRunMediaRecreateJob
//
// Creates and runs a task to recreate the master of a piece of media.
// Since the Re-create Master Job is run via a single Engine method (there 
// is no partitioning of the task across major components) and no scanning 
// of files/resources/etc is required to run it, this method does not create 
// a job in the Engine.  It only creates a task in the NT Task Scheduler and 
// runs it now via a call to the Engine's CreateTask() method.  The Task 
// Scheduler task is Disabled, so it will not be run according to a schedule.
//
//
{
    WsbTraceIn( 
        L"RsCreateAndRunMediaRecreateJob", L"MediaId = <%ls>, Media Description = <%ls>, CopyToUse = <%hd>", 
                    WsbGuidAsString( MediaId ), (LPCWSTR)MediaDescription, CopyToUse );

    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pHsmServer );
        WsbAssertPointer( pMediaInfo );
        
        // Create the task name to put in the scheduler
        CString jobName, message;
        AfxFormatString1( jobName, IDS_JOB_MEDIA_RECREATE_TITLE, MediaDescription ); 
        CWsbStringPtr computerName;
        WsbAffirmHr( pHsmServer->GetName( &computerName ) );
        AfxFormatString2( message, IDS_RUN_JOB, jobName, computerName );

        if( IDOK == AfxMessageBox( message, MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON2 ) ) {

            // Set up to call the Engine to create an entry in NT Task Scheduler

            // Create the parameter string to the program NT Scheduler 
            // will run (for Sakkara this is RsLaunch).  First convert
            // the input MediaId GUID to a string since it is used in 
            // the job parameter string.
            CWsbStringPtr stringId( MediaId );
            CString szParameters;
            szParameters.Format( L"recreate -i %ls -c %hd", (WCHAR*)stringId, CopyToUse );

            // Create the comment string for the NT Scheduler entry
            CString commentString;
            commentString.LoadString( IDS_MEDIA_RECREATE_JOB_COMMENT );

            // Declare and initialize the schedule components passed to 
            // the engine.  Since this task is Disabled these are simply
            // set to 0 (COM requires populating all arguments).
            TASK_TRIGGER_TYPE   jobTriggerType = TASK_TIME_TRIGGER_ONCE;
            WORD                jobStartHour   = 0;
            WORD                jobStartMinute = 0;

            // Indicate this is a Disabled task
            BOOL                scheduledJob   = FALSE;

            // The Re-create Master job requires the Recreate state of the master 
            // media that will be re-created to have been set.  Do so here since
            // the user has already confirmed they want to run this job.  (The 
            // UI already has the Engine's Segment database open.)
            WsbAffirmHr( pMediaInfo->SetRecreate( TRUE ) );
            WsbAffirmHr( pMediaInfo->Write() );

            // Create and run the task
            WsbAffirmHr( pHsmServer->CreateTask( jobName, szParameters,
                                                  commentString, jobTriggerType,
                                                  jobStartHour, jobStartMinute,
                                                  scheduledJob ) );
        }

    } WsbCatch (hr);

    WsbTraceOut( L"RsCreateAndRunMediaRecreateJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



HRESULT
RsGetStoragePoolId(
    IN  IHsmServer *pHsmServer,
    OUT GUID *pStoragePoolId
    )
{
    WsbTraceIn( L"RsGetStoragePoolId", L"pHsmServer = <0x%p>, pStoragePoolId = <0x%p>", pHsmServer, pStoragePoolId );

    HRESULT hr = S_OK;
    try {

        CComPtr <IHsmStoragePool>       pStoragePool;

        WsbAffirmHr( RsGetStoragePool( pHsmServer, &pStoragePool ) );

        //
        // Get the GUID of the storage pool
        //
        WsbAffirmHr( pStoragePool->GetId( pStoragePoolId ) );

    } WsbCatch( hr );

    WsbTraceOut( L"RsGetStoragePoolId", L"hr = <%ls>, *pStoragePoolId = <%ls>", WsbHrAsString( hr ), WsbPtrToGuidAsString( pStoragePoolId ) );
    return( hr );
}


HRESULT
RsGetStoragePool(
    IN  IHsmServer       *pHsmServer,
    OUT IHsmStoragePool **ppStoragePool
    )
{
    WsbTraceIn( L"RsGetStoragePool", L"pHsmServer = <0x%p>, ppStoragePool = <0x%p>", pHsmServer, ppStoragePool );

    ULONG count;
    HRESULT hr = S_OK;
    try {

        CComPtr <IWsbIndexedCollection> pCollection;

        //
        // Get the storage pools collection.  There should only be one member.
        //
        WsbAffirmHr( pHsmServer->GetStoragePools( &pCollection ) );
        WsbAffirmHr( pCollection->GetEntries( &count ) );
        WsbAffirm( 1 == count, E_FAIL );

        WsbAffirmHr( pCollection->At( 0, IID_IHsmStoragePool, (void **) ppStoragePool ) );

    } WsbCatch( hr );

    WsbTraceOut( L"RsGetStoragePool", L"hr = <%ls>, *pStoragePoolId = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppStoragePool ) );
    return( hr );
}

HRESULT
RsGetInitialLVColumnProps(
    int IdWidths, 
    int IdTitles, 
    CString **pColumnWidths, 
    CString **pColumnTitles,
    int *pColumnCount
)
{
    HRESULT hr = S_OK;
    CString szResource;
    OLECHAR* szData;
    int colCount = 0;
    int colWidths = 0;
    int colTitles = 0;
    int i = 0;

    try {
        if ( !pColumnWidths ) {

            // Caller asked us to return number of columns
            colCount = 0;
            szResource.LoadString (IdTitles);
            szData = szResource.GetBuffer( 0 );
            szData = wcstok( szData, L":" );
            while( szData ) {
                colCount++;
                szData = wcstok( NULL, L":" );
            }
        } else {

            // Properites Widths
            colWidths = 0;
            szResource.LoadString (IdWidths);
            szData = szResource.GetBuffer( 0 );
            szData = wcstok( szData, L":" );
            while( szData ) {
                pColumnWidths[colWidths++] = new CString( szData );
                szData = wcstok( NULL, L":" );
            }

            // Properites Titles
            colTitles = 0;
            szResource.LoadString (IdTitles);
            szData = szResource.GetBuffer( 0 );
            szData = wcstok( szData, L":" );
            while( szData ) {
                pColumnTitles[colTitles++] = new CString( szData );
                szData = wcstok( NULL, L":" );
            }
            WsbAffirm( ( colTitles == colWidths ), E_FAIL );
            colCount = colTitles;
        }
        *pColumnCount = colCount;
    } WsbCatch (hr);
    return hr;
}


HRESULT
RsServerSaveAll(
    IN IUnknown * pUnkServer
    )
{
    WsbTraceIn( L"RsServerSaveAll", L"" );

    HRESULT hr = S_OK;

    try {

        CComPtr<IWsbServer> pServer;
        WsbAffirmHr( RsQueryInterface( pUnkServer, IWsbServer, pServer ) );
        WsbAffirmHr( pServer->SaveAll( ) );

    } WsbCatch( hr )

    WsbTraceOut( L"RsServerSaveAll", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
RsGetVolumeDisplayName(
    IFsaResource * pResource,
    CString &      DisplayName
    )
{
    WsbTraceIn( L"RsGetVolumeDisplayName", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( pResource );
        CWsbStringPtr label;
        CWsbStringPtr userName;
        WsbAffirmHr( pResource->GetName( &label, 0 ) );
        WsbAffirmHr( pResource->GetUserFriendlyName( &userName, 0 ) );

        // The user name is a drive letter.
        if( userName.IsEqual( L"" ) ) {

            if( label.IsEqual( L"" ) ) {

                if (S_OK == pResource->IsAvailable()) {

                    DisplayName.LoadString( IDS_UNLABELED_VOLUME );

                } else {

                    CString str1, str2;
                    str1.LoadString( IDS_UNLABELED_VOLUME );
                    str2.LoadString( IDS_VOL_NOT_AVAILABLE );
                    DisplayName.Format( L"%ls (%ls)", str1.GetBuffer(0), str2.GetBuffer(0) );
        
                }

            } else {

                // If it's not a drive letter we use the label.
                if (S_OK == pResource->IsAvailable()) {

                    DisplayName.Format( L"%ls", (WCHAR*)label );

                } else {

                    CString str2;
                    str2.LoadString( IDS_VOL_NOT_AVAILABLE );
                    DisplayName.Format( L"%ls (%ls)", (WCHAR*)label, str2.GetBuffer(0) );

                }

            }

        } else {

            userName[(int)(wcslen(userName)-1)] = 0;
            // The user name is a drive letter or a mount point path with a trailing backslash
            // If the label is "", it's ignored in the formatting.
            DisplayName.Format( L"%ls (%ls)", (WCHAR*)label, (WCHAR*)userName );

        }

    } WsbCatch( hr )

    WsbTraceOut( L"RsGetVolumeDisplayName", L"hr = <%ls>, DisplayName = <%ls>", WsbHrAsString( hr ), (LPCWSTR)DisplayName );
    return( hr );
}

// Temporary version that for unlabeled volumes w/ drive-letter puts in the 
// size and free space
HRESULT
RsGetVolumeDisplayName2(
    IFsaResource * pResource,
    CString &      DisplayName
    )
{
    WsbTraceIn( L"RsGetVolumeDisplayName2", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( pResource );
        CWsbStringPtr label;
        CWsbStringPtr userName;
        WsbAffirmHr( pResource->GetName( &label, 0 ) );
        WsbAffirmHr( pResource->GetUserFriendlyName( &userName, 0 ) );

        // The user name is a drive letter.
        if( userName.IsEqual ( L"" ) ) {

            if( label.IsEqual ( L"" ) ) {

                LONGLONG    totalSpace  = 0;
                LONGLONG    freeSpace   = 0;
                LONGLONG    premigrated = 0;
                LONGLONG    truncated   = 0;
                WsbAffirmHr( pResource->GetSizes( &totalSpace, &freeSpace, &premigrated, &truncated ) );
                CString totalString, freeString;
                RsGuiFormatLongLong4Char( totalSpace, totalString );
                RsGuiFormatLongLong4Char( freeSpace, freeString );
                AfxFormatString2( DisplayName, IDS_UNLABELED_VOLUME2, totalString, freeString );

            } else {

                // If it's not a drive letter we use the label.
                DisplayName.Format( L"%ls", (WCHAR*)label );

            }

        } else {
            userName[(int)(wcslen(userName)-1)] = 0;
            // The user name is a drive letter or a mount point path with a trailing backslash
            // If the label is "", it's ignored in the formatting.
            DisplayName.Format( L"%ls (%ls)", (WCHAR*)label, (WCHAR*)userName );

        }

    } WsbCatch( hr )

    WsbTraceOut( L"RsGetVolumeDisplayName2", L"hr = <%ls>, DisplayName = <%ls>", WsbHrAsString( hr ), (LPCWSTR)DisplayName );
    return( hr );
}

HRESULT
RsGetVolumeSortKey(
    IFsaResource * pResource,
    CString &      DisplayName
    )
{
    WsbTraceIn( L"RsGetVolumeSortKey", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( pResource );
        CWsbStringPtr label;
        CWsbStringPtr userName;
        WsbAffirmHr( pResource->GetName( &label, 0 ) );
        WsbAffirmHr( pResource->GetUserFriendlyName( &userName, 0 ) );

        DisplayName.Format( L"%ls %ls", (WCHAR*)userName, (WCHAR*)label );

    } WsbCatch( hr )

    WsbTraceOut( L"RsGetVolumeSortKey", L"hr = <%ls>, DisplayName = <%ls>", WsbHrAsString( hr ), (LPCWSTR)DisplayName );
    return( hr );
}

HRESULT
RsIsVolumeAvailable(
    IFsaResource * pResource
    )
{
    WsbTraceIn( L"RsIsVolumeAvailable", L"" );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pResource );

        hr = pResource->IsAvailable();

    } WsbCatch( hr )

    WsbTraceOut( L"RsIsVolumeAvailable", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
RsIsWhiteOnBlack(
    )
{
    WsbTraceIn( L"RsIsWhiteOnBlack", L"" );

    HRESULT hr = S_FALSE;

#define RS_CONTRAST_LIMIT 173
    //
    // Look to see if button background is within RS_CONTRAST_LIMIT
    // units of black.
    // Note that full white has a distance of 256 * sqrt(3) = 443
    // Use Euclidean distance but compare before taking root
    //
    DWORD face3d = ::GetSysColor( COLOR_3DFACE );
    DWORD blackDelta = GetRValue( face3d ) * GetRValue( face3d ) +
                       GetGValue( face3d ) * GetGValue( face3d ) +
                       GetBValue( face3d ) * GetBValue( face3d );

    if( blackDelta < RS_CONTRAST_LIMIT * RS_CONTRAST_LIMIT ) {

        hr = S_OK;

    }

    WsbTraceOut( L"RsIsWhiteOnBlack", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
RsIsRmsErrorNotReady(
    HRESULT HrError
    )
{
    WsbTraceIn( L"RsIsRmsErrorNotReady", L"" );

    HRESULT hr = S_FALSE;

    try {

            switch( HrError ) {

            case RMS_E_NOT_READY_SERVER_STARTING:
            case RMS_E_NOT_READY_SERVER_STARTED:
            case RMS_E_NOT_READY_SERVER_INITIALIZING:
            case RMS_E_NOT_READY_SERVER_STOPPING:
            case RMS_E_NOT_READY_SERVER_STOPPED:
            case RMS_E_NOT_READY_SERVER_DISABLED:
            case RMS_E_NOT_READY_SERVER_LOCKED:

                hr = S_OK;
    
            }

    } WsbCatch( hr );

    WsbTraceOut( L"RsIsRmsErrorNotReady", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\sakvlls.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    SAKVlLs.h

Abstract:

    Managed Volume wizard.

Author:

    Micheal Moore [mmoore]   30-Sep-1998

Revision History:

--*/

#ifndef _SAKVLLS_H
#define _SAKVLLS_H

class CSakVolList : public CListCtrl {
// Construction/Destruction
public:
    CSakVolList();
    virtual ~CSakVolList();

// Attributes
protected:
    int m_nVolumeIcon;
    CImageList m_imageList;

// Operations
public:    
    //
    // SetExtendedStyle, GetCheck, and SetCheck are temporary methods.
    // When the version of MFC we are building against is updated
    // they can be deleted.
    //
    DWORD SetExtendedStyle( DWORD dwNewStyle );
    BOOL GetCheck ( int nItem ) const;
    BOOL SetCheck( int nItem, BOOL fCheck = TRUE );

    //
    // Inserts an Item for the name at this->GetItemCount and
    // calls SetItem for the capacity and free space.  The int * pIndex
    // parameter is optional and will return the index of the newly appended
    // item to the list.  The return value suggests the Append was 
    // successful or not.
    //
    BOOL AppendItem( LPCTSTR name, LPCTSTR capacity, LPCTSTR freeSpace, int * pIndex = NULL );

// Implementation
protected:    
    BOOL CreateImageList();
    //{{AFX_MSG(CSakVolList)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSakVolList)
    virtual void PreSubclassWindow();
    //}}AFX_VIRTUAL

    DECLARE_MESSAGE_MAP()
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\sakvlls.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    SakVlLs.cpp

Abstract:

    Managed Volume node implementation.

Author:

    Michael Moore [mmoore]   30-Sep-1998

Revision History:

--*/

#include "stdafx.h"
#include "SakVlLs.h"

CSakVolList::CSakVolList() 
    : CListCtrl(),
      m_nVolumeIcon(-1)
{
}

CSakVolList::~CSakVolList()
{
}

//-----------------------------------------------------------------------------
//
//                      PreSubclassWindow
//
//  Create the image list for the list control.  Set the desired 
//  extended styles.  Finally, Initilize the list header.
//
//
void
CSakVolList::PreSubclassWindow()
{
    CreateImageList( );

    // 
    // The style we want to see it Checkboxes and full row select
    //
    SetExtendedStyle( LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT );

    //
    // Create the columns for the list box
    //
    CString temp;       
    INT index;
    LV_COLUMN col;
    INT column = 0;

    //
    // Also need to calculate some buffer space
    // Use 4 dialog units (for numeral)
    //
    CRect padRect( 0, 0, 8, 8 );
    ::MapDialogRect( GetParent()->m_hWnd, &padRect );

    //
    // Name Column
    //
    temp.LoadString(IDS_NAME);
    col.mask =  ( LVCF_FMT | LVCF_WIDTH | LVCF_TEXT );
    col.fmt = LVCFMT_LEFT;
    col.cx = GetStringWidth( temp ) + padRect.Width( ) * 10;
    col.pszText = (LPTSTR)(LPCTSTR)temp;
    index = InsertColumn( column, &col );
    column++;

    //
    // Capacity Column
    //
    temp.LoadString( IDS_CAPACITY );
    col.cx = GetStringWidth( temp ) + padRect.Width( );
    col.pszText = (LPTSTR)(LPCTSTR)temp;    
    InsertColumn( column, &col );
    column++;

    //
    // Free Space Column
    //
    temp.LoadString( IDS_FREESPACE );
    col.cx = GetStringWidth( temp ) + padRect.Width( );
    col.pszText = (LPTSTR)(LPCTSTR)temp;
    InsertColumn( column, &col );
    column++;

    CListCtrl::PreSubclassWindow();    
}

//-----------------------------------------------------------------------------
//
//                      CreateImageList
//
//  Load an image list with a single icon to represent a volume
//  and set the image list to be the newly created list.
//
//
BOOL CSakVolList::CreateImageList ( )
{
    BOOL bRet = TRUE;
    HICON hIcon;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    CWinApp* pApp = AfxGetApp( );

    bRet = m_imageList.Create( ::GetSystemMetrics( SM_CXSMICON ),
                            ::GetSystemMetrics( SM_CYSMICON ),
                            ILC_COLOR | ILC_MASK, 2,5 );

    if ( bRet ) 
    {
        hIcon = pApp->LoadIcon( IDI_NODEMANVOL );
        if ( hIcon != NULL ) 
        {
            m_nVolumeIcon = m_imageList.Add( hIcon );
            ::DeleteObject( hIcon );
            SetImageList( &m_imageList, LVSIL_SMALL );
        }
        else
        {
            bRet = FALSE;
        }
    }

    return( bRet ); 
}

//-----------------------------------------------------------------------------
//
//                      SetExtendedStyle
//
//  The alternatives that are #if'd out are to call CListCtrl::SetExtendedStyle
//  or the ComCtrl.h declared ListView_SetExtendedListViewStyle.  We will
//  eventually get rid of this function when the mfc headers and libs are
//  updated from then NT group. 
//  
//
DWORD 
CSakVolList::SetExtendedStyle( DWORD dwNewStyle )
{
#if 0 // (_WIN32_IE >= 0x0400)
    return CListCtrl::SetExtendeStyle( dwNewStyle );
#elif 0 //(_WIN32_IE >= 0x0300)
    return ListView_SetExtendedListViewStyle( m_hWnd, dwNewStyle );
#else
    ASSERT(::IsWindow(m_hWnd)); 
    return (DWORD) ::SendMessage(m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, (LPARAM) dwNewStyle); 
#endif
}

//-----------------------------------------------------------------------------
//
//                      GetCheck
//
//  The alternatives that are #if'd out are to call CListCtrl::GetCheck
//  or the ComCtrl.h declared ListView_GetCheckState.  We will
//  eventually get rid of this function when the mfc headers and libs are
//  updated from then NT group. 
//
//  Note: I could not get the ListView_Get... to compile under our current
//  environment.
//  
//
BOOL
CSakVolList::GetCheck ( int nItem ) const
{
#if 0 //(_WIN32_IE >= 0x0400)
    return CListCtrl::GetCheck( nItem );
#elif 0 //(_WIN32_IE >= 0x0300)
    return ListView_GetCheckState( m_hWnd, nItem );
#else
    ASSERT(::IsWindow(m_hWnd));
    int nState = (int)::SendMessage(m_hWnd, LVM_GETITEMSTATE, (WPARAM)nItem,
          (LPARAM)LVIS_STATEIMAGEMASK);
    // Return zero if it's not checked, or nonzero otherwise.
    return ((BOOL)(nState >> 12) -1);
#endif
}

//-----------------------------------------------------------------------------
//
//                      SetCheck
//
//  The alternatives that are #if'd out are to call CListCtrl::SetCheck
//  or the ComCtrl.h declared ListView_SetCheckState.  We will
//  eventually get rid of this function when the mfc headers and libs are
//  updated from then NT group. 
//
//  Note: I could not get the ListView_Set... to compile under our current
//  environment.
//  
//
BOOL
CSakVolList::SetCheck( int nItem, BOOL fCheck )
{
#if 0 //(_WIN32_IE >= 0x0400)
    return CListCtrl::SetCheck( nItem, fCheck );
#elif 0 //(_WIN32_IE >= 0x0300)
    return ListView_SetCheckState( m_hWnd, nItem, fCheck );
#else
    ASSERT(::IsWindow(m_hWnd));
    LVITEM lvi;
    lvi.stateMask = LVIS_STATEIMAGEMASK;

    /*
    Since state images are one-based, 1 in this macro turns the check off, and
    2 turns it on.
    */
    lvi.state = INDEXTOSTATEIMAGEMASK((fCheck ? 2 : 1));
    return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)&lvi);
#endif
}

//-----------------------------------------------------------------------------
//
//                      AppendItem
//
//  Insert an item into the list with the Volume Icon with name, capacity
//  and free space.  Return TRUE if successful and set pIndex = to the 
//  index of the inserted list item.  
//  
//
BOOL
CSakVolList::AppendItem( LPCTSTR name, LPCTSTR capacity, LPCTSTR freeSpace , int * pIndex)
{
    BOOL bRet = FALSE;
    int subItem = 1;
    int index = InsertItem( GetItemCount(), name, m_nVolumeIcon );                   
    if ( index != -1 )
    {
        LVITEM capItem;
        capItem.mask = LVIF_TEXT;
        capItem.pszText = (LPTSTR)capacity;
        capItem.iItem = index;
        capItem.iSubItem = subItem;
        subItem++;

        LVITEM freeItem;
        freeItem.mask = LVIF_TEXT;
        freeItem.pszText = (LPTSTR)freeSpace;
        freeItem.iItem = index;
        freeItem.iSubItem = subItem;
        subItem++;

        bRet = ( SetItem( &capItem ) && SetItem ( &freeItem) );
    }     

    if ( pIndex != NULL ) 
        *pIndex = index;

    return bRet;
}

BEGIN_MESSAGE_MAP(CSakVolList, CListCtrl)
    //{{AFX_MSG_MAP(CSakVolList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\schdtask.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SchdTask.h

Abstract:

    CSchdTask - Class that allows access to a scheduled task.

Author:

    Art Bragg   9/4/97

Revision History:

--*/

#ifndef _SCHDTASK_H
#define _SCHDTASK_H

#include "mstask.h"

class CSchdTask
{

// Construction/Destruction
public:

CSchdTask 
    (
    CString szComputerName, 
    const TCHAR* task,
    int          propPageTitleID,
    const TCHAR* parameters,
    const TCHAR* comment,
    CEdit*       pEdit
    );
~CSchdTask ();

// Public Functions

HRESULT CheckTaskExists (
    BOOL bCreateTask
    );

HRESULT CreateTask();

HRESULT DeleteTask();

HRESULT ShowPropertySheet();

HRESULT UpdateDescription();

HRESULT Save();

// Properties
private:
CString                     m_szParameters;
CString                     m_szComment;
CString                     m_szComputerName;       // Name of HSM computer
CComPtr <ITask>             m_pTask;                // Pointer to ITask - NULL task doesn't exist
CEdit                       *m_pEdit;               // Pointer to Edit Control
CString                     m_szJobTitle;           // Job Title
CComPtr <ISchedulingAgent>  m_pSchedAgent;          // Pointer to Scheduling Agent
CComPtr<ITaskTrigger>       m_pTrigger;             // Pointer to task trigger
int m_propPageTitleID;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\schdtask.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SchdTask.cpp

Abstract:

    CSchdTask - Class that allows access to a scheduled task. 
        Check the task
        Create the task
        Delete the task
        Save the task
        Show property page
        Show task description in text box

Author:

    Art Bragg   9/4/97

Revision History:

--*/

#include "stdafx.h"
#include "SchdTask.h"
#include "SchedSht.h"


/////////////////////////////////////////////////////////////////////////////
// CSchdTask
//
// Description: Save arguments to data members.  Create the Scheduling Agent
//              object.
//
// Arguments:
//  szComputerName  - Name of HSM computer owning task scheduler
//  taskID          - Resource ID for task name
//  propPageTitleID - Resource ID for property page title
//  pEdit           - Edit control to show description in
//
// Returns:
//  S_OK, S_XXXX
//
///////////////////////////////////////////////////////////////////////////////////
//
CSchdTask::CSchdTask 
    (
    CString szComputerName, 
    const TCHAR* task,
    int          propPageTitleID,
    const TCHAR* parameters,
    const TCHAR* comment,
    CEdit*       pEdit
    )
{
    HRESULT hr = S_OK;
    try {
        WsbTraceIn( L"CSchdTask::CSchdTask", L"ComputerName = <%ls> task = <%ls> propPageTitleID = <%d> pEdit = <%ld>",
            szComputerName, task, propPageTitleID, pEdit  );

        m_pTask = NULL;

        m_szComputerName = szComputerName;

        // Save the property page title resource ID
        m_propPageTitleID = propPageTitleID;

        // Save the pointer to the control in which to display the schedule text
        m_pEdit = pEdit;

        WsbAffirmHr( m_pSchedAgent.CoCreateInstance( CLSID_CSchedulingAgent ) );

        // Get the hsm computer and prepend "\\"
        CString szHsmName ("\\\\" + szComputerName);

        // Tell the task manager which computer to look on
        m_pSchedAgent->SetTargetComputer (szHsmName);

        m_szJobTitle = task;
        m_szParameters = parameters;
        m_szComment = comment;

    } WsbCatch (hr);

    WsbTraceOut( L"CSchdTask::CSchdTask", L"hr = <%ls>", WsbHrAsString( hr ) );
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Function: CheckTaskExists
//
// Description:  Tries to access the task owned by the object.  If the task does not
//               exist, returns S_FALSE and if caller requested puts up an error and
//               creates the task.
//
//  Arguments:   bCreateTask - true = put up an error and create task if it doesn't exist
//
//  Returns:    S_OK - Task exists
//              S_FALSE - Task did not exist (may have been created)
//              S_XXXX - Error
//
/////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::CheckTaskExists(
    BOOL bCreateTask
    )
{
    WsbTraceIn( L"CSchdTask::CheckTaskExists", L"bCreateTask = <%ld>", bCreateTask );

    HRESULT hr = S_OK;

    try {

        //
        // Get the task we're interested in
        //
        CComPtr <IUnknown> pIU;
        if( m_pSchedAgent->Activate( m_szJobTitle, IID_ITask, &pIU ) == S_OK ) {

            //
            // QI to the task interface and save it
            //
            m_pTask.Release( );
            WsbAffirmHr( pIU->QueryInterface( IID_ITask, (void **) &m_pTask ) );

        } else {

            //
            // The task doesn't exist - create it if the caller wanted
            // us to.
            //
            if( bCreateTask ) {

                CString sMessage;
                AfxFormatString2( sMessage, IDS_ERR_MANAGE_TASK, m_szJobTitle, m_szComputerName );
                AfxMessageBox( sMessage, RS_MB_ERROR );
                
                //
                // Create the task
                //
                WsbAffirmHr( CreateTask( ) );
                WsbAffirmHr( Save( ) );

            }
            
            //
            // Return false (the task does or did not exist)
            //
            hr = S_FALSE;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSchdTask::CheckTaskExists", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Function: CreateTask
//
// Description: Creates the data-member task in the task scheduler.
//
// Arguments: None
//
// Returns: S_OK, S_XXXX
//
/////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::CreateTask()
{
    WsbTraceIn( L"CSchdTask::CreateTask", L"");
    HRESULT hr = S_OK;
    try {

        //
        // Need to connect to the HSM engine and let it create it
        // so that it runs under the LocalSystem account
        //
        CComPtr<IHsmServer> pServer;
        WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, m_szComputerName, IID_IHsmServer, (void**)&pServer ) );

        WsbAffirmHr( pServer->CreateTask( m_szJobTitle, m_szParameters, m_szComment, TASK_TIME_TRIGGER_DAILY, 2, 0, TRUE ) );

        //
        // And Configure it
        //
        m_pTask.Release( );
        WsbAffirmHr( m_pSchedAgent->Activate( m_szJobTitle, IID_ITask, (IUnknown**)&m_pTask ) );

    } WsbCatch (hr);

    WsbTraceOut( L"CSchdTask::CreateTask", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// Function: DeleteTask
//
// Description: Deletes the data-member task from the task scheduler
//
// Arguments: None
//
// Returns: S_OK, S_XXX
//
////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::DeleteTask()
{
    WsbTraceIn( L"CSchdTask::CreateTask", L"");
    HRESULT hr = S_OK;
    try {
        WsbAffirmPointer (m_pSchedAgent);
        WsbAffirmHr (m_pSchedAgent->Delete( m_szJobTitle ));
    } WsbCatch (hr);
    WsbTraceOut( L"CSchdTask::DeleteTask", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Function: ShowPropertySheet
//
// Description: Shows a property sheet for the data-member task.
//
// Arguments: None
//
// Returns: S_OK, S_XXX
//
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::ShowPropertySheet()
{
    WsbTraceIn( L"CSchdTask::ShowPropertySheet", L"");

    CScheduleSheet scheduleSheet(m_propPageTitleID , m_pTask, 0, 0 );

    scheduleSheet.DoModal( );
    WsbTraceOut( L"CSchdTask::ShowPropertySheet", L"hr = <%ls>", WsbHrAsString( S_OK ) );
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Function: UpdateDescription
//
// Description: Displays the data-member task's summary in the data-member text box.
//
// Arguments: None
//
// Returns: S_OK, S_XXX
//
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::UpdateDescription
(
    void
    )
{
    WsbTraceIn( L"CSchdTask::UpdateDescription", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // And set schedule text into the text box.
        //
        
        CString buildString;
        WORD triggerCount, triggerIndex;

        WsbAffirmHr( m_pTask->GetTriggerCount( &triggerCount ) );
        
        CWsbStringPtr scheduleString;
        
        for( triggerIndex = 0; triggerIndex < triggerCount; triggerIndex++ ) {
        
            WsbAffirmHr( m_pTask->GetTriggerString( triggerIndex, &scheduleString ) );
            buildString += scheduleString;
            buildString += L"\r\n";

            scheduleString.Free( );
        
        }
        
        m_pEdit->SetWindowText( buildString );
        
        //
        // Now check to see if we should add a scroll bar
        //
        
        //
        // It seems the only way to know that an edit control needs a scrollbar
        // is to force it to scroll to the bottom and see if the first
        // visible line is the first actual line
        //
        
        m_pEdit->LineScroll( MAXSHORT );
        if( m_pEdit->GetFirstVisibleLine( ) > 0 ) {
        
            //
            // Add the scroll styles
            //
        
            m_pEdit->ModifyStyle( 0, WS_VSCROLL | ES_AUTOVSCROLL, SWP_DRAWFRAME );
        
        
        } else {
        
            //
            // Remove the scrollbar (set range to 0)
            //
        
            m_pEdit->SetScrollRange( SB_VERT, 0, 0, TRUE );
        
        }
        
        //
        // Remove selection
        //
        
        m_pEdit->PostMessage( EM_SETSEL, -1, 0 );

    } WsbCatch( hr );

    WsbTraceOut( L"CSchdTask::UpdateDescription", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Function: Save
//
// Description: Saves the data member task to the task scheduler
//
// Arguments: None
//
// Returns: S_OK, S_XXX
//
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::Save (void)
{
    WsbTraceIn( L"CSchdTask::Save", L"" );
    HRESULT hr = S_OK;

    try {

        CComPtr<IPersistFile> pPersist;
        WsbAffirmHr( m_pTask->QueryInterface( IID_IPersistFile, (void**)&pPersist ) );
        WsbAffirmHr( pPersist->Save( 0, 0 ) );

    } WsbCatch (hr);

    WsbTraceOut( L"CSchdTask::Save", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\schedsht.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SchedSht.cpp

Abstract:

    CScheduleSheet - Class that allows a schedule to be edited
                     in a property sheet of its own.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "SchedSht.h"


/////////////////////////////////////////////////////////////////////////////
// CScheduleSheet

CScheduleSheet::CScheduleSheet(UINT nIDCaption, ITask * pTask, CWnd* pParentWnd, DWORD /*dwFlags*/)
    :CPropertySheet(nIDCaption, pParentWnd, 0)
{
    HRESULT hr = S_OK;

    try {

        //
        // Save the scheduled task pointer
        //

        WsbAffirmPointer( pTask );
        m_pTask = pTask;

        //
        // Get the property page structures
        //

        CComPtr<IProvideTaskPage> pProvideTaskPage;
        WsbAffirmHr( pTask->QueryInterface( IID_IProvideTaskPage, (void**)&pProvideTaskPage ) );
        WsbAffirmHr( pProvideTaskPage->GetPage( TASKPAGE_SCHEDULE, FALSE, &m_hSchedulePage ) );
//      WsbAffirmHr( pProvideTaskPage->GetPage( TASKPAGE_SETTINGS, FALSE, &m_hSettingsPage ) );

    } WsbCatch( hr );

}

CScheduleSheet::~CScheduleSheet()
{
    //
    // Set the pointer to the PROPSHEETHEADER array to
    // null since MFC will try to free it when we are
    // destroyed.
    //

    m_psh.ppsp = 0;
}


BEGIN_MESSAGE_MAP(CScheduleSheet, CPropertySheet)
    //{{AFX_MSG_MAP(CScheduleSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


void 
CScheduleSheet::BuildPropPageArray
(
    void
    )
{
    CPropertySheet::BuildPropPageArray( );

    //
    // We put in a dummy set of pages to keep MFC happy.
    // Here we will substitute our own array of HPROPSHEETPAGE's
    // instead, since this is all Task Scheduler gives us.
    //

    m_psh.dwFlags &= ~PSH_PROPSHEETPAGE;
    m_psh.dwFlags |= PSH_NOAPPLYNOW;
    m_psh.phpage = &m_hSchedulePage;
    m_psh.nPages = 1;
}

BOOL CScheduleSheet::OnInitDialog() 
{
    BOOL bResult = CPropertySheet::OnInitDialog();
    
    LONG style = ::GetWindowLong( m_hWnd, GWL_EXSTYLE );
    style |= WS_EX_CONTEXTHELP;
    ::SetWindowLong( m_hWnd, GWL_EXSTYLE, style );
    
    return bResult;
}

#ifdef _DEBUG
void CScheduleSheet::AssertValid() const
{
    //
    // Need to override so that CPropSheet is happy
    // Note that this code duplicates what is in 
    // CPropertySheet::AssertValid except the assertion
    // the dwFlags has the PSH_PROPSHEETPAGE bit set
    // We assert that it is not set
    //
    CWnd::AssertValid();
    m_pages.AssertValid();
    ASSERT(m_psh.dwSize == sizeof(PROPSHEETHEADER));
    //ASSERT((m_psh.dwFlags & PSH_PROPSHEETPAGE) == PSH_PROPSHEETPAGE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=gui
MINORCOMP=HsmMMC

INCLUDES=$(SDK_INC_PATH);$(BASEP_HSM_DIR)\inc;$(BASEP_HSM_DIR)\inc\$(O);..;..\$(O);..\computer;..\device;..\job;..\volume;..\..\inc;$(ADMIN_INC_PATH)

C_DEFINES=$(C_DEFINES) -D_MERGE_PROXYSTUB

UMTYPE=windows

USE_NATIVE_EH=1

USE_MFCUNICODE=1
MFC_USRDLL=1
MFC_VER=42
USE_ATL=1

MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_PCH=precomp.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\computer\hsmcom.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmCom.h

Abstract:

    Root node of snapin - represents the Computer.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _HSMCOM_H
#define _HSMCOM_H

#include "prhsmcom.h"
#include "SakNodeI.h"

class ATL_NO_VTABLE CUiHsmCom : 
    public CSakNodeImpl<CUiHsmCom>,
    public CComCoClass<CUiHsmCom,&CLSID_CUiHsmCom>
{

public:
// constructor/destructor
    CUiHsmCom(void) {};
BEGIN_COM_MAP(CUiHsmCom)
    COM_INTERFACE_ENTRY2(IDispatch, ISakNodeProp)
    COM_INTERFACE_ENTRY(ISakNode)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(ISakNodeProp)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CUiHsmCom)

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

public: 

    // ISakNode methods
    STDMETHOD( InvokeCommand )        ( SHORT sCmd, IDataObject *pDataObject );
    STDMETHOD( GetContextMenu )       ( BOOL bMultiSelect, HMENU *phMenu );
    STDMETHOD( CreateChildren )       ( ); 
    STDMETHOD( InitNode )             ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( AddPropertyPages)      ( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID* pEnumObjectId, IEnumUnknown *pEnumUnkNode );

    // data members
    // static, class-wide variables
    static INT  m_nScopeOpenIconIndex;  // virtual scope index of Open Icon
    static INT  m_nScopeCloseIconIndex; // virtual scope index of Close Icon
    static INT  m_nResultIconIndex;     // virtual scope index of Close Icon

    // data member unique to this class.
    CWsbStringPtr m_szHsmName;              // name of Hsm

    // property pages
    CPropHsmComStat* m_pPageStat;
    CPropHsmComStat* m_pPageServices;
    
    // Private helper functions
    HRESULT GetEngineStatus (HSM_SYS_STS *status);
    HRESULT SetEngineStatus (HSM_SYS_STS status);
    HRESULT CheckStatusChange (HSM_SYS_STS oldStatus, HSM_SYS_STS newStatus, BOOL *fOk);

};

class CUiHsmComSheet : public CSakPropertySheet
{
public:
    CUiHsmComSheet( ) { };

    HRESULT AddPropertyPages( );
    HRESULT InitSheet(
            RS_NOTIFY_HANDLE handle, 
            IUnknown *pUnkPropSheetCallback, 
            CSakNode *pSakNode,
            ISakSnapAsk *pSakSnapAsk,
            IEnumGUID *pEnumObjectId,
            IEnumUnknown *pEnumUnkNode);
    CString m_NodeTitle;

private:
};



#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\stdafx.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Top level header file so we can take advantage of precompiled
    headers..

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _STDAFX_H
#define _STDAFX_H

//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// Undefine ASSSERT because the MFC also defines it and we don't 
// want the warning.
#undef ASSERT
}

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxcmn.h>         // MFC support for Windows Common Controls
#include <afxtempl.h>   
#include <mmc.h>

#define WSB_TRACE_IS        WSB_TRACE_BIT_UI

#define CComPtr CComPtrAtl21

#include "wsb.h"
#include "rslimits.h"

#undef  CComPtr

//
// Temp Hack until using newer ATL
//
#undef  ATLASSERT
#define ATLASSERT _ASSERTE
template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
    private:
        virtual ULONG STDMETHODCALLTYPE AddRef()=0;
        virtual ULONG STDMETHODCALLTYPE Release()=0;
};

template <class T>
class CComPtr
{
public:
    typedef T _PtrClass;
    CComPtr()
    {
        p=NULL;
    }
    CComPtr(T* lp)
    {
        if ((p = lp) != NULL)
            p->AddRef();
    }
    CComPtr(const CComPtr<T>& lp)
    {
        if ((p = lp.p) != NULL)
            p->AddRef();
    }
    ~CComPtr()
    {
        if (p)
            p->Release();
    }
    void Release()
    {
        IUnknown* pTemp = p;
        if (pTemp)
        {
            p = NULL;
            pTemp->Release();
        }
    }
    operator T*() const
    {
        return (T*)p;
    }
    T& operator*() const
    {
        ATLASSERT(p!=NULL);
        return *p;
    }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&()
    {
        ATLASSERT(p==NULL);
        return &p;
    }
    _NoAddRefReleaseOnCComPtr<T>* operator->() const
    {
        ATLASSERT(p!=NULL);
        return (_NoAddRefReleaseOnCComPtr<T>*)p;
    }
    T* operator=(T* lp)
    {
        return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
    }
    T* operator=(const CComPtr<T>& lp)
    {
        return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
    }
    bool operator!() const
    {
        return (p == NULL);
    }
    bool operator<(T* pT) const
    {
        return p < pT;
    }
    bool operator==(T* pT) const
    {
        return p == pT;
    }
    // Compare two objects for equivalence
    bool IsEqualObject(IUnknown* pOther)
    {
        if (p == NULL && pOther == NULL)
            return true; // They are both NULL objects

        if (p == NULL || pOther == NULL)
            return false; // One is NULL the other is not

        CComPtr<IUnknown> punk1;
        CComPtr<IUnknown> punk2;
        p->QueryInterface(IID_IUnknown, (void**)&punk1);
        pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
        return punk1 == punk2;
    }
    void Attach(T* p2)
    {
        if (p)
            p->Release();
        p = p2;
    }
    T* Detach()
    {
        T* pt = p;
        p = NULL;
        return pt;
    }
    HRESULT CopyTo(T** ppT)
    {
        ATLASSERT(ppT != NULL);
        if (ppT == NULL)
            return E_POINTER;
        *ppT = p;
        if (p)
            p->AddRef();
        return S_OK;
    }
    HRESULT SetSite(IUnknown* punkParent)
    {
        return AtlSetChildSite(p, punkParent);
    }
    HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
    {
        return AtlAdvise(p, pUnk, iid, pdw);
    }
    HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
    {
        ATLASSERT(p == NULL);
        return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
    }
    HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
    {
        CLSID clsid;
        HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
        ATLASSERT(p == NULL);
        if (SUCCEEDED(hr))
            hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
        return hr;
    }
    template <class Q>
    HRESULT QueryInterface(Q** pp) const
    {
        ATLASSERT(pp != NULL && *pp == NULL);
        return p->QueryInterface(__uuidof(Q), (void**)pp);
    }
    T* p;
};

//
// End Temp Hack
//

#include "Engine.h"
#include "Fsa.h"
#include "Rms.h"
#include "Job.h"

#define RsQueryInterface( pUnk, interf, pNew )  (pUnk)->QueryInterface( IID_##interf, (void**) static_cast<interf **>( &pNew ) )
#define RsQueryInterface2( pUnk, interf, pNew ) (pUnk)->QueryInterface( IID_##interf, (void**) static_cast<interf **>( pNew ) )

#include "hsmadmin.h"
#include "resource.h"
#include "BaseHsm.h"
#include "RsUtil.h"
#include "RsAdUtil.h"
#include "PropPage.h"
#include "CPropSht.h"
#include "rshelpid.h"

class CHsmAdminApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    void CHsmAdminApp::ParseCommandLine(CCommandLineInfo& rCmdInfo);
};

extern CHsmAdminApp       g_App;

#if 1

// Turn on In-Your-Trace error messages for debugging.

class CWsbThrowContext {
public:
    CWsbThrowContext( char * File, long Line, HRESULT Hr ) :
        m_File(File), m_Line(Line), m_Hr(Hr) { }
    char *  m_File;
    long    m_Line;
    HRESULT m_Hr;
};

#undef WsbThrow
#define WsbThrow(hr) throw( CWsbThrowContext( __FILE__, __LINE__, hr ) );

#undef WsbCatchAndDo
#define WsbCatchAndDo(hr, code)         \
    catch(CWsbThrowContext context) {   \
        hr = context.m_Hr;                  \
        CString msg;                    \
        msg.Format( L"Throw '%ls' on line [%ld] of %hs\n", WsbHrAsString( hr ), (long)context.m_Line, context.m_File ); \
        WsbTrace( (LPWSTR)(LPCWSTR)msg ); \
        { code }                        \
    }

#undef WsbCatch
#define WsbCatch(hr)                    \
    catch(CWsbThrowContext context) {   \
        hr = context.m_Hr;                  \
        CString msg;                    \
        msg.Format( L"Throw '%ls' on line [%ld] of %hs\n", WsbHrAsString( hr ), (long)context.m_Line, context.m_File ); \
        WsbTrace( (LPWSTR)(LPCWSTR)msg ); \
    }

#endif


// constant values used throughout
#define UNINITIALIZED (-1)
#define HSM_MAX_NAME MAX_COMPUTERNAME_LENGTH
#define ONE_MEG (1048576)

// Clipboard formats
extern const wchar_t* SAKSNAP_INTERNAL;
extern const wchar_t* MMC_SNAPIN_MACHINE_NAME;
extern const wchar_t* CF_EV_VIEWS;

#define ELT_SYSTEM            (101)
#define ELT_APPLICATION       (103)
#define VIEWINFO_FILTERED     (0x0002)
#define VIEWINFO_USER_CREATED (0x0008)
#define LOGINFO_DONT_PERSIST  (0x0800)
#define EVENTLOG_ALL_EVENTS   (EVENTLOG_ERROR_TYPE|EVENTLOG_WARNING_TYPE|EVENTLOG_INFORMATION_TYPE|EVENTLOG_AUDIT_SUCCESS|EVENTLOG_AUDIT_FAILURE)


#define HSMADMIN_CURRENT_VERSION    1 // Current version for use in IPersist

///////////////////////////////////////////////////////////////////////////
//
// Menu constants
//
//
// Menubar's submenu order for adding into MMC context menu:
//

#define MENU_INDEX_ROOT   0
#define MENU_INDEX_NEW    1
#define MENU_INDEX_TASK   2

#define MENU_HSMCOM_ROOT_PAUSE      0
#define MENU_HSMCOM_ROOT_CONTINUE   1

#define MENU_HSMCOM_TASK_PAUSE      0
#define MENU_HSMCOM_TASK_CONTINUE   1

#define EXTENSION_RS_FOLDER_PARAM -1
#define HSMADMIN_NO_HSM_NAME L"No Hsm Name"

#ifndef IDC_HAND
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif

#define RS_STR_KICKOFF_PARAMS               _T("run manage")
#define RS_STR_RESULT_PROPS_MANRESLST_IDS   _T("DisplayName:Capacity:FreeSpace:DesiredFreeSpaceP")
#define RS_STR_RESULT_PROPS_DEFAULT_IDS     _T("DisplayName:Type:Description")
#define RS_STR_RESULT_PROPS_COM_IDS         _T("DisplayName:Description")
#define RS_STR_RESULT_PROPS_MEDSET_IDS      _T("DisplayName:Description:CapacityP:FreeSpaceP:StatusP:CopySet1P:CopySet2P:CopySet3P")

///////////////////////////////////////////////////////////////////////////
//
// Common Flags
//

#define RS_MB_ERROR    (MB_OK|MB_ICONSTOP)
#define RS_WINDIR_SIZE (2*MAX_PATH)


///////////////////////////////////////////////////////////////////////////
//
// Common internal errors
//

#define RS_E_NOT_CONFIGURED HRESULT_FROM_WIN32( ERROR_BAD_CONFIGURATION )
#define RS_E_NOT_INSTALLED  HRESULT_FROM_WIN32( ERROR_PRODUCT_UNINSTALLED )
#define RS_E_DISABLED       HRESULT_FROM_WIN32( ERROR_RESOURCE_DISABLED )
#define RS_E_CANCELLED      HRESULT_FROM_WIN32( ERROR_CANCELLED )



/////////////////////////////////////////////////////////////////////////////
//
//  GUIDs for all UI nodes in the system (used as type identifiers)
//
/////////////////////////////////////////////////////////////////////////////

// HsmCom UI node - 
// This is the static node known by the snapin manager. This is the only one that is 
// actually registered (see hsmadmin.rgs). 
extern const GUID cGuidHsmCom;

// The rest of the UI nodes - 
extern const GUID cGuidManVol;
extern const GUID cGuidCar;
extern const GUID cGuidMedSet;
extern const GUID cGuidManVolLst;


#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\schedsht.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SchedSht.h

Abstract:

    CScheduleSheet - Class that allows a schedule to be edited
                     in a property sheet of its own.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/


#ifndef _SCHEDSHT_H
#define _SCHEDSHT_H

#include <mstask.h>

/////////////////////////////////////////////////////////////////////////////
// CScheduleSheet

class CScheduleSheet : public CPropertySheet
{

// Construction
public:
    CScheduleSheet(UINT nIDCaption, ITask * pTask, CWnd* pParentWnd = NULL, DWORD dwFlags = 0 );

// Attributes
public:
    CComPtr<ITask> m_pTask;
    HPROPSHEETPAGE m_hSchedulePage;
    HPROPSHEETPAGE m_hSettingsPage;

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CScheduleSheet)
    public:
    virtual BOOL OnInitDialog();
    //}}AFX_VIRTUAL

    virtual void BuildPropPageArray();

// Implementation
public:
    virtual ~CScheduleSheet();
#ifdef _DEBUG
    virtual void AssertValid() const;
#endif

    // Generated message map functions
protected:
    //{{AFX_MSG(CScheduleSheet)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\stdafx.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.cpp

Abstract:

    This module declares the global constants used within the
    snapin, as well as including standard implementations from ATL.

Author:

    John Biard [jrb]   04-Mar-1997

Revision History:

--*/

#include "stdafx.h"

#pragma warning(4:4701)
#include <atlimpl.cpp> 
#pragma warning(3:4701)

#include "RsUtil.cpp"

// Internal private clipboard format.
const wchar_t* SAKSNAP_INTERNAL        = L"SAKSNAP_INTERNAL"; 
const wchar_t* MMC_SNAPIN_MACHINE_NAME = L"MMC_SNAPIN_MACHINE_NAME"; 
const wchar_t* CF_EV_VIEWS             = L"CF_EV_VIEWS"; 

/////////////////////////////////////////////////////////////////////////////
//
//  GUIDs for all UI nodes in the system (used as type identifiers)
//
/////////////////////////////////////////////////////////////////////////////

// HsmCom UI node - 
// This is the static node known by the snapin manager. This is the only one that is 
// actually registered (see hsmadmin.rgs). 
const GUID cGuidHsmCom    = { 0x8b4bac42, 0x85ff, 0x11d0, { 0x8f, 0xca, 0x0, 0xa0, 0xc9, 0x19, 0x4, 0x47 } };

// The rest of the UI nodes -
const GUID cGuidManVol    = { 0x39982290, 0x8691, 0x11d0, { 0x8f, 0xca, 0x0, 0xa0, 0xc9, 0x19, 0x4, 0x47 } };
const GUID cGuidCar       = { 0x39982296, 0x8691, 0x11d0, { 0x8f, 0xca, 0x0, 0xa0, 0xc9, 0x19, 0x4, 0x47 } };
const GUID cGuidMedSet    = { 0x29e5be12, 0x8abd, 0x11d0, { 0x8f, 0xcd, 0x0, 0xa0, 0xc9, 0x19, 0x4, 0x47 } };
const GUID cGuidManVolLst = { 0x39982298, 0x8691, 0x11d0, { 0x8f, 0xca, 0x0, 0xa0, 0xc9, 0x19, 0x4, 0x47 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\computer\prhsmcom.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrHsmCom.cpp

Abstract:

    Implements all the property page interface to the individual nodes,
    including creating the property page, and adding it to the property sheet.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include "HsmCom.h"
#include "PrHsmCom.h"
#include "ca.h"
#include "intshcut.h"

static DWORD pHelpIds[] = 
{

    IDC_SNAPIN_TITLE,                   idh_instance,
    IDC_STATIC_STATUS,                  idh_status,
    IDC_STATIC_STATUS_LABEL,            idh_status,
    IDC_STATIC_MANAGED_VOLUMES,         idh_total_managed_volumes,
    IDC_STATIC_MANAGED_VOLUMES_LABEL,   idh_total_managed_volumes,
    IDC_STATIC_CARTS_USED,              idh_total_cartridges_used,
    IDC_STATIC_CARTS_USED_LABEL,        idh_total_cartridges_used,
    IDC_STATIC_DATA_IN_RS,              idh_total_data_remote_storage,
    IDC_STATIC_DATA_IN_RS_LABEL,        idh_total_data_remote_storage,
    IDC_STATIC_GROUP,                   idh_version,
    IDC_STATIC_BUILD_LABEL_HSM,         idh_version,
    IDC_STATIC_ENGINE_BUILD_HSM,        idh_version,

    0, 0
};


CPropHsmComStat::CPropHsmComStat() : CSakPropertyPage(CPropHsmComStat::IDD)
    
{
    //{{AFX_DATA_INIT(CPropHsmComStat)
    //}}AFX_DATA_INIT

    m_hConsoleHandle = 0;
    m_pParent        = 0;
    m_bUpdate        = FALSE;
    m_pHelpIds       = pHelpIds;
}

CPropHsmComStat::~CPropHsmComStat()
{
}

BOOL CPropHsmComStat::OnInitDialog() 
{
    WsbTraceIn( L"CPropHsmComStat::OnInitDialog", L"" );
    HRESULT hr = S_OK;
    ULONG volCount = 0; // number of managed Resources in server
    LONGLONG totalTotal = 0;
    LONGLONG totalFree = 0;         
    LONGLONG totalUsed = 0;         
    LONGLONG totalPremigrated = 0;
    LONGLONG totalTruncated = 0;
    LONGLONG remoteStorage = 0;
    LONGLONG total = 0;
    LONGLONG free = 0;
    LONGLONG premigrated = 0;
    LONGLONG truncated = 0;
    CMediaInfoObject mio;
    int             i;
    int             mediaCount = 0;
    CComPtr<IWsbIndexedCollection> pManResCollection;
    CComPtr<IHsmServer>            pHsmServer;
    CComPtr<IFsaServer>            pFsaServer;
    CComPtr<IRmsServer>            pRmsServer;
    CComPtr<IFsaResource>          pFsaRes;
    CComPtr<IUnknown>              pUnkFsaRes;  // unknown pointer to managed resource list
    CComPtr<IHsmManagedResource>   pHsmManRes;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

#if DBG
        //
        // For checked builds, make visible the version info
        //
        GetDlgItem( IDC_STATIC_GROUP            )->ShowWindow( SW_SHOWNA );
        GetDlgItem( IDC_STATIC_BUILD_LABEL_HSM  )->ShowWindow( SW_SHOWNA );
        GetDlgItem( IDC_STATIC_ENGINE_BUILD_HSM )->ShowWindow( SW_SHOWNA );
#endif

        //
        // Put the title up
        //
        SetDlgItemText( IDC_SNAPIN_TITLE, m_NodeTitle );

        //
        // Show service status
        //
        GetAndShowServiceStatus();

        //
        // Contact the engine
        //
        HRESULT hrInternal = m_pParent->GetHsmServer( &pHsmServer );
        if( hrInternal == S_OK ) {

            //
            // The engine is up
            //
            WsbAffirmHr ( ( (CUiHsmComSheet *)m_pParent )->GetRmsServer( &pRmsServer ) );
            WsbAffirmHr ( ( (CUiHsmComSheet *)m_pParent )->GetFsaServer( &pFsaServer ) );

            //
            // Get the number of managed volumes
            //
            WsbAffirmHr( pHsmServer->GetManagedResources( &pManResCollection ) );
            WsbAffirmHr( pManResCollection->GetEntries( &volCount ));

            //
            // Iterate through the collection
            //
            for( i = 0; i < (int)volCount; i++ ) {

                //
                // Protect against bad volumes with try statement.
                // Otherwise we bail initializing whole dialog
                //
                HRESULT hrLocal = S_OK;
                try {

                    //
                    // Get the FsaResource
                    //
                    pHsmManRes.Release( );
                    pUnkFsaRes.Release( );
                    pFsaRes.Release( );
                    WsbAffirmHr( pManResCollection->At( i, IID_IHsmManagedResource, ( void** ) &pHsmManRes ) );
                    WsbAffirmHr( pHsmManRes->GetFsaResource( &pUnkFsaRes ) );
                    WsbAffirmHr( RsQueryInterface( pUnkFsaRes, IFsaResource, pFsaRes ) );

                    // Total up statistics
                    WsbAffirmHr( pFsaRes->GetSizes( &total, &free, &premigrated, &truncated ) );
                    totalPremigrated    += premigrated;
                    totalTruncated      += truncated;

                    remoteStorage = totalPremigrated + totalTruncated;

                } WsbCatch( hrLocal );
            }

            HRESULT hrLocal = S_OK;
            try {

                //
                // Count the number of media used
                // Initialize media object
                //
                WsbAffirmHr( mio.Initialize( GUID_NULL, pHsmServer, pRmsServer ) );

                // Did we get a node?
                if( mio.m_MediaId != GUID_NULL ) {
                    HRESULT hrEnum = S_OK;
                    while( SUCCEEDED( hrEnum ) ) {

                        if( S_OK == mio.DoesMasterExist( ) ) {

                            mediaCount++;
                        }

                        for( INT index = 0; index < mio.m_NumMediaCopies; index++ ) {

                            if( S_OK == mio.DoesCopyExist( index ) ) {

                                mediaCount++;
                            }
                        }

                        hrEnum = mio.Next();
                    }
                }

            } WsbCatch( hrLocal );


            CString sText;
            // Set number of managed volumes
            SetDlgItemInt( IDC_STATIC_MANAGED_VOLUMES, volCount, FALSE );

            // Show data in Remote Storage - text is same for singular and plural
            CString sFormattedNumber;
            RsGuiFormatLongLong4Char (remoteStorage, sFormattedNumber );
            SetDlgItemText( IDC_STATIC_DATA_IN_RS, sFormattedNumber );

            SetDlgItemInt( IDC_STATIC_CARTS_USED, mediaCount, FALSE );

            CWsbStringPtr pNtProductVersionHsm;
            ULONG buildVersionHsm;
            ULONG ntProductBuildHsm;

            //
            // Get service versions
            // Note: Fsa version is NOT in use at the moment, it may be used as an HSM 
            //  client version in a future C/S HSM
            //
            {

                CComPtr <IWsbServer> pWsbHsmServer;
                WsbAffirmHr( RsQueryInterface( pHsmServer, IWsbServer, pWsbHsmServer ) );
                WsbAffirmHr( pWsbHsmServer->GetNtProductBuild( &ntProductBuildHsm ) );
                WsbAffirmHr( pWsbHsmServer->GetNtProductVersion( &pNtProductVersionHsm, 0 ) );
                WsbAffirmHr( pWsbHsmServer->GetBuildVersion( &buildVersionHsm ) );

            }
    
            sText.Format( L"%ls.%d [%ls]", (WCHAR*)pNtProductVersionHsm, ntProductBuildHsm, RsBuildVersionAsString( buildVersionHsm ) );
            SetDlgItemText( IDC_STATIC_ENGINE_BUILD_HSM, sText );

            //
            // The engine is up.  Show the controls
            //
            GetDlgItem( IDC_STATIC_MANAGED_VOLUMES_LABEL )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_MANAGED_VOLUMES )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_DATA_IN_RS_LABEL )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_DATA_IN_RS )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_CARTS_USED_LABEL )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_CARTS_USED )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_GROUP )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_BUILD_LABEL_HSM )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_ENGINE_BUILD_HSM )->ShowWindow( SW_SHOW );

        } else {

            // The engine is down.  Hide the controls
            GetDlgItem( IDC_STATIC_MANAGED_VOLUMES_LABEL )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_MANAGED_VOLUMES )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_DATA_IN_RS )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_DATA_IN_RS_LABEL )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_CARTS_USED_LABEL )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_CARTS_USED )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_GROUP )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_BUILD_LABEL_HSM )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_ENGINE_BUILD_HSM )->ShowWindow( SW_HIDE );

        }

    } WsbCatch( hr );

    CSakPropertyPage::OnInitDialog();
 
    WsbTraceOut( L"CPropHsmComStat::OnInitDialog", L"" );
    return TRUE;
}


BOOL CPropHsmComStat::OnCommand(WPARAM wParam, LPARAM lParam) 
{
    // Page is dirty, mark it.
    // SetModified();   
    // m_bUpdate = TRUE;
    return CSakPropertyPage::OnCommand(wParam, lParam);
}

void CPropHsmComStat::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CPropHsmComStat::DoDataExchange", L"" );
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPropHsmComStat)
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CPropHsmComStat::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CPropHsmComStat, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPropHsmComStat)
    ON_WM_DESTROY()
    ON_WM_DRAWITEM()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropHsmComStat message handlers

BOOL CPropHsmComStat::OnApply() 
{
    if (m_bUpdate == TRUE)
    {
        // Do the work of making the change here.

        m_bUpdate = FALSE;
    }
    
    return CSakPropertyPage::OnApply();
}



HRESULT CPropHsmComStat::GetAndShowServiceStatus()
{
    WsbTraceIn( L"CPropHsmComStat::GetAndShowServiceStatus", L"" );
    HRESULT hr = S_OK;
    try {

        //
        // Get and display service statuses
        //
        DWORD   serviceStatus;
        CString sStatus;
        
        // Engine
        HRESULT hrSetup = S_FALSE;
        WsbAffirmHr( WsbGetServiceStatus( m_pszName, APPID_RemoteStorageEngine, &serviceStatus ) );
        if( SERVICE_RUNNING == serviceStatus ) {

            CComPtr<IHsmServer> pHsmServer;
            hr = ( m_pParent->GetHsmServer( &pHsmServer ) );
            if ( hr == RS_E_NOT_CONFIGURED ) {

                hrSetup = S_FALSE;

            }
            else {

                hrSetup = S_OK;
                WsbAffirmHr( hr );

            }

        }

        RsGetStatusString( serviceStatus, hrSetup, sStatus );
        SetDlgItemText( IDC_STATIC_STATUS, sStatus );

    } WsbCatch( hr );

    WsbTraceOut( L"CPropHsmComStat::GetAndShowServiceStatus", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



/////////////////////////////////////////////////////////////////////////////
// CRsWebLink

CRsWebLink::CRsWebLink()
{
}

CRsWebLink::~CRsWebLink()
{
}


BEGIN_MESSAGE_MAP(CRsWebLink, CStatic)
    //{{AFX_MSG_MAP(CRsWebLink)
    ON_WM_LBUTTONDOWN()
    ON_WM_CTLCOLOR_REFLECT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRsWebLink message handlers

void CRsWebLink::PreSubclassWindow() 
{
    //
    // Need to set up font correctly
    //
    LOGFONT logfont;
    CFont*  tempFont = GetFont( );
    tempFont->GetLogFont( &logfont );

//    logfont.lfWeight    = FW_BOLD;
    logfont.lfUnderline = TRUE;

    m_Font.CreateFontIndirect( &logfont );
    
    SetFont( &m_Font );

    //
    // Resize based on font
    //
    CRect       rect;
    CWindowDC   dc( this );
    CString     title;
    GetClientRect( rect );
    GetWindowText( title );

    dc.SelectObject( m_Font );
    CSize size = dc.GetTextExtent( title );
    SetWindowPos( 0, 0, 0, size.cx, rect.bottom, SWP_NOMOVE | SWP_NOZORDER );

    //
    // And set the class cursor
    //
    HCURSOR hCur = AfxGetApp( )->LoadStandardCursor( IDC_HAND );
    SetClassLongPtr( GetSafeHwnd( ), GCLP_HCURSOR, (LONG_PTR)hCur );

    CStatic::PreSubclassWindow();
}

void CRsWebLink::OnLButtonDown(UINT nFlags, CPoint point) 
{
    WsbTraceIn( L"CRsWebLink::OnLButtonDown", L"" );

    CString caption;
    CString addr;

    GetWindowText( caption );
    addr = TEXT( "http://" );
    addr += caption;

    AfxGetApp()->BeginWaitCursor( );

    OpenURL( addr );

    AfxGetApp( )->EndWaitCursor( );

    CStatic::OnLButtonDown( nFlags, point );

    WsbTraceOut( L"CRsWebLink::OnLButtonDown", L"" );
}

HRESULT CRsWebLink::OpenURL(CString &Url)
{
    HRESULT hr = S_OK;

    try {

        CComPtr<IUniformResourceLocator> pURL;
        WsbAffirmHr( CoCreateInstance( CLSID_InternetShortcut, 0, CLSCTX_ALL, IID_IUniformResourceLocator, (void**)&pURL ) );
        WsbAffirmHr( pURL->SetURL( Url, IURL_SETURL_FL_GUESS_PROTOCOL ) );

        //
        // Open the URL by calling InvokeCommand
        //
        URLINVOKECOMMANDINFO ivci;
        ivci.dwcbSize   = sizeof( URLINVOKECOMMANDINFO );
        ivci.dwFlags    = IURL_INVOKECOMMAND_FL_ALLOW_UI;
        ivci.hwndParent = 0;
        ivci.pcszVerb   = TEXT( "open" );

        WsbAffirmHr( pURL->InvokeCommand( &ivci ) );

    } WsbCatch( hr );

    return( hr );
}

HBRUSH CRsWebLink::CtlColor(CDC* pDC, UINT /* nCtlColor */ )
{
    HBRUSH hBrush = (HBRUSH)GetStockObject( HOLLOW_BRUSH );
    pDC->SetTextColor( RGB( 0, 0, 255 ) );
    pDC->SetBkMode( TRANSPARENT ); 
    return( hBrush );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\computer\prhsmcom.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrHsmCom.cpp

Abstract:

    Implements all the property page interface to the individual nodes,
    including creating the property page, and adding it to the property sheet.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#ifndef _PROPHSMCOM_H
#define _PROPHSMCOM_H

/////////////////////////////////////////////////////////////////////////////
// CRsWebLink window

class CRsWebLink : public CStatic
{
// Construction
public:
    CRsWebLink();

// Attributes
public:
    CFont m_Font;

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRsWebLink)
    protected:
    virtual void PreSubclassWindow();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRsWebLink();

    // Generated message map functions
protected:
    //{{AFX_MSG(CRsWebLink)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
private:
    HRESULT OpenURL( CString& Url );
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPropHsmComStat dialog

class CPropHsmComStat : public CSakPropertyPage
{
// Construction
public:
    CPropHsmComStat();
    ~CPropHsmComStat();

// Dialog Data
    //{{AFX_DATA(CPropHsmComStat)
    enum { IDD = IDD_PROP_HSMCOM_STAT };
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPropHsmComStat)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPropHsmComStat)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    CString            m_NodeTitle;

private:
    BOOL    m_bUpdate;
    CWsbStringPtr m_pszName;

    // Helper functions
    HRESULT GetAndShowServiceStatus();

};


/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\computer\hsmcom.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmCom.cpp

Abstract:

    Root node of snapin - represents the Computer.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include "HsmCom.h"
#include "WzQstart.h"
#include "PrMrLsRc.h"
#include "PrMedSet.h"
#include "PrSched.h"


int CUiHsmCom::m_nScopeCloseIcon  = AddScopeImage( IDI_BLUESAKKARA );
int CUiHsmCom::m_nScopeCloseIconX = CUiHsmCom::m_nScopeCloseIcon;
int CUiHsmCom::m_nScopeOpenIcon   = CUiHsmCom::m_nScopeCloseIcon;
int CUiHsmCom::m_nScopeOpenIconX  = CUiHsmCom::m_nScopeCloseIconX;
int CUiHsmCom::m_nResultIcon      = AddResultImage( IDI_BLUESAKKARA );
int CUiHsmCom::m_nResultIconX     = CUiHsmCom::m_nResultIcon;


/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CUiHsmCom::FinalConstruct( )
{
    WsbTraceIn( L"CUiHsmCom::FinalConstruct", L"" );

    m_rTypeGuid = &cGuidHsmCom;

    HRESULT hr = CSakNode::FinalConstruct( );

    m_bSupportsPropertiesSingle     = TRUE;
    m_bSupportsPropertiesMulti      = FALSE;
    m_bSupportsPropertiesNoEngine   = TRUE;
    m_bSupportsDeleteSingle         = FALSE;
    m_bSupportsDeleteMulti          = FALSE;
    m_bSupportsRefreshSingle        = TRUE;
    m_bSupportsRefreshMulti         = FALSE;
    m_bSupportsRefreshNoEngine      = TRUE;
    m_bIsContainer                  = TRUE;

    m_pPageStat = NULL;
    m_pPageServices = NULL;

    WsbTraceOut( L"CUiHsmCom::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CUiHsmCom::FinalRelease( )
{
    WsbTraceIn( L"CUiHsmCom::FinalRelease", L"" );


    CSakNode::FinalRelease( );

    WsbTraceOut( L"CUiHsmCom::FinalRelease", L"" );
}


/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         GetContextMenu
//
//  Return an HMENU to be used for context menus on this node.
//

STDMETHODIMP 
CUiHsmCom::GetContextMenu( BOOL /*bMultiSelect*/, HMENU* phMenu )
{
    WsbTraceIn( L"CUiHsmCom::GetContextMenu", L"" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    CMenu* pRootMenu, *pNewMenu, *pTaskMenu;

    try {

        //
        // Get the context menu from the resource
        //
        WsbAffirmHr( LoadContextMenu( IDR_HSMCOM, phMenu ) );

        CMenu menu;
        menu.Attach( *phMenu );
        pRootMenu = menu.GetSubMenu( MENU_INDEX_ROOT );
        pNewMenu  = menu.GetSubMenu( MENU_INDEX_NEW );
        pTaskMenu = menu.GetSubMenu( MENU_INDEX_TASK );

        //
        // If we are not configured locally, allow the option to setup
        // Remote Storage Server. If we are setup, allow them to reconnect
        // if not connected.
        //
        BOOL deleteMenu = TRUE;

        if( S_FALSE == m_pSakSnapAsk->GetHsmName( 0 ) ) {

            CComPtr<IHsmServer> pServer;
            HRESULT hrConn = m_pSakSnapAsk->GetHsmServer( &pServer );

            if( RS_E_NOT_CONFIGURED == hrConn ) {

                deleteMenu = FALSE;

            }
        }

        if( deleteMenu ) {

            pRootMenu->DeleteMenu( ID_HSMCOM_ROOT_SETUPWIZARD, MF_BYCOMMAND );

        }
        if( !deleteMenu || ( S_OK != m_pSakSnapAsk->GetState( ) ) ) {

            pRootMenu->EnableMenuItem( ID_HSMCOM_ROOT_SCHEDULE, MF_GRAYED | MF_BYCOMMAND );

        }

        menu.Detach( );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiHsmCom::GetContextMenu", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         InvokeCommand
//
//  User has selected a command from the menu. Process it here.
//

STDMETHODIMP 
CUiHsmCom::InvokeCommand( SHORT sCmd, IDataObject* pDataObject )
{
    WsbTraceIn( L"CUiHsmCom::InvokeCommand", L"sCmd = <%d>", sCmd );

    CString theString;
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        switch( sCmd ) {

        case ID_HSMCOM_ROOT_SETUPWIZARD:
            {
                //
                // use wizard to create manage volume
                //
                CComObject<CQuickStartWizard>* pWizard = new CComObject<CQuickStartWizard>;
                WsbAffirmAlloc( pWizard );

                CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
                WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );

                    //
                // RS_E_CANCELED indicates canceled, and FAILEd indicates error.
                // If so, then throw "Not set up"
                    //
                if( S_OK == pWizard->m_HrFinish ) {

                    WsbAffirmHr( RefreshScopePane( ) );

                }
            }
            break;


        case ID_HSMCOM_ROOT_SCHEDULE:

            WsbAffirmHr( m_pSakSnapAsk->ShowPropertySheet( this, pDataObject, 1 ) );
            break;

        case MMC_VERB_REFRESH:

            WsbAffirmHr( RefreshScopePane( ) );
            break;

        default:
            break;
        } 

    } WsbCatch( hr );

    WsbTraceOut( L"CUiHsmCom::InvokeCommand", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         CreateChildren
//
//  Create and initialize all the children of the Hsm Computer node.
//

STDMETHODIMP CUiHsmCom::CreateChildren( )
{
    WsbTraceIn( L"CUiHsmCom::CreateChildren", L"" );

    //
    // Initialize the children of this node (no recursion. Decendents of children
    // are NOT created here)
    //

    HRESULT hr = S_OK;

    try {

        CComPtr<IUnknown> pUnkChild;  // IUnknown pointer to new child.
        CComPtr<ISakNode> pSakNode;   // creation interface for new child node.

        //
        // Create a Managed Resource list UI node to be the parent of all managed volumes.
        //

        WsbAffirmHr( NewChild( cGuidManVolLst, &pUnkChild ) );

        //
        // Initialize the child UI COM object, putting the Hsm Managed Resource collection object inside the UI object.
        //

        WsbAffirmHr( RsQueryInterface( pUnkChild, ISakNode, pSakNode ) );
        WsbAffirmHr( pSakNode->InitNode( m_pSakSnapAsk, NULL, this ) );
        
        //
        // Add the child COM object to the parent's list of children.
        //
        WsbAffirmHr( AddChild( pSakNode ) );

        // Free up resources
        pUnkChild.Release( );
        pSakNode.Release( );


        
        ///////////////////////////////
        // CREATE MEDIA SET NODE

        //
        // Create a Remote Storage UI node to be the parent of all remote storage sub-nodes.
        //

        WsbAffirmHr( NewChild( cGuidMedSet, &pUnkChild ) );

        //
        // Initialize the child UI COM object, putting the Rms Server object inside the UI object.
        //

        WsbAffirmHr( RsQueryInterface( pUnkChild, ISakNode, pSakNode ) );
        WsbAffirmHr( pSakNode->InitNode( m_pSakSnapAsk, NULL, this ) );
        
        //
        // Add the child COM object to the parent's list of children.
        //

        WsbAffirmHr( AddChild( pSakNode ) );
    } WsbCatch( hr );

    //
    // Indicate that this node's children are valid and up-to-date (even if there ARE
    // no children - at least now we know it).
    //

    m_bChildrenAreValid = TRUE;

    //
    // indicate that this parent node needs to be re-enumerated
    //

    m_bEnumState = FALSE;

    WsbTraceOut( L"CUiHsmCom::CreateChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
} 


//---------------------------------------------------------------------------
//
//         InitNode
//
//  Initialize single COM object without using the registry. Derived
//  objects frequently augment this method by implementing it themselves.
//

STDMETHODIMP
CUiHsmCom::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CUiHsmCom::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );

    HRESULT hr = S_OK;
    try {

        //
        // Note: The Hsm computer node no longer owns a server pointer
        //
        WsbAffirmHr( CSakNode::InitNode( pSakSnapAsk, NULL, pParent ));

        //
        // Set Display Type and Description. 
        //
        CString tempString;
        tempString.LoadString( IDS_HSMCOM_TYPE );
        WsbAffirmHr( put_Type( (OLECHAR *)(LPCWSTR)tempString ) );
        tempString.LoadString( IDS_HSMCOM_DESCRIPTION );
        WsbAffirmHr( put_Description( (OLECHAR *)(LPCWSTR)tempString ) );

        //
        // Set up the result view columns
        //
        WsbAffirmHr( SetChildProps( RS_STR_RESULT_PROPS_COM_IDS, IDS_RESULT_PROPS_COM_TITLES, IDS_RESULT_PROPS_COM_WIDTHS ) );

        RefreshObject();

    } WsbCatch( hr );

    WsbTraceOut( L"CUiHsmCom::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP 
CUiHsmCom::AddPropertyPages( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID *pEnumObjectId, IEnumUnknown *pEnumUnkNode)
{
    WsbTraceIn( L"CUiHsmCom::AddPropertyPages", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // Create an object to hold the pages
        //
        CUiHsmComSheet *pHsmComPropertySheet = new CUiHsmComSheet;
        WsbAffirmAlloc( pHsmComPropertySheet );

        WsbAffirmHr( pHsmComPropertySheet->InitSheet( 
            handle, 
            pUnkPropSheetCallback, 
            this,
            m_pSakSnapAsk,
            pEnumObjectId,
            pEnumUnkNode
            ) );

        //
        // Tell the object to add it's pages
        //
        WsbAffirmHr( pHsmComPropertySheet->AddPropertyPages( ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CUiHsmCom::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// class CUiManVolSheet
//
HRESULT
CUiHsmComSheet::InitSheet(
            RS_NOTIFY_HANDLE handle,
            IUnknown*        pUnkPropSheetCallback,
            CSakNode*        pSakNode,
            ISakSnapAsk*     pSakSnapAsk,
            IEnumGUID*       pEnumObjectId,
            IEnumUnknown*    pEnumUnkNode
            )
{

    WsbTraceIn( L"CUiHsmComSheet::InitSheet", L"handle = <%ld>, pUnkPropSheetCallback = <0x%p>, pSakNode = <0x%p>, pSakSnapAsk = <0x%p>, pEnumObjectId = <0x%p>, ", 
        handle, pUnkPropSheetCallback, pSakNode, pSakSnapAsk, pEnumObjectId );
    HRESULT hr = S_OK;

    try {


        WsbAffirmHr( CSakPropertySheet::InitSheet( handle, pUnkPropSheetCallback, pSakNode,
                    pSakSnapAsk, pEnumObjectId, pEnumUnkNode ) );

        CWsbBstrPtr nodeName;
        WsbAffirmHr( pSakNode->get_DisplayName( &nodeName ) );
        m_NodeTitle = nodeName;

    } WsbCatch( hr );

    WsbTraceOut( L"CUiHsmComSheet::InitSheet", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT CUiHsmComSheet::AddPropertyPages ( )
{
    WsbTraceIn( L"CUiHsmComSheet::AddPropertyPages", L"" ); 
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    try {

        HPROPSHEETPAGE hPage = NULL; // Windows property page handle

        // --------------------- Statistics Page ----------------------------------
        // Create the Hsm Statistics property page.
        CPropHsmComStat* pPageStats = new CPropHsmComStat();
        WsbAffirmAlloc( pPageStats );

        pPageStats->m_NodeTitle = m_NodeTitle;

        AddPage( pPageStats );

        // 
        // Add the Schedule, Recall, and Media Copies pages
        // if setup has happened and the Remote Storage Service
        // is running.
        //

        if( S_OK == m_pSakNode->m_pSakSnapAsk->GetState() ) {

            //--------------------- Schedule Page --------------------------------------
            CPrSchedule* pPageSched = new CPrSchedule();
            WsbAffirmAlloc( pPageSched );

            AddPage( pPageSched );

            //--------------------- Recall Limit Page --------------------------------------
            // Create the Hsm Recall property page.
            CPrMrLsRec* pPageRecall = new CPrMrLsRec();
            WsbAffirmAlloc( pPageRecall );

            AddPage( pPageRecall );

            // --------------------- Media Copies Page ----------------------------------
            CPrMedSet *pPageMediaCopies = new CPrMedSet();
            WsbAffirmAlloc( pPageMediaCopies )

            AddPage( pPageMediaCopies );

            // Add more pages here.
            // ....

        }

    } WsbCatch( hr );

    

    WsbTraceOut( L"CUiHsmComSheet::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\computer\wzqstart.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WzQStart.cpp

Abstract:

    Setup Wizard implementation.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include "HsmConn.h"
#include "RpFilt.h"
#include "rsstrdef.h"

#include "WzQStart.h"
#include "SchedSht.h"

#define CHECK_SYSTEM_TIMER_ID 9284
#define CHECK_SYSTEM_TIMER_MS 1000

#define QSHEET ((CQuickStartWizard*)m_pSheet)

const HRESULT E_INVALID_DOMAINNAME = HRESULT_FROM_WIN32( ERROR_INVALID_DOMAINNAME );
const HRESULT E_ACCESS_DENIED      = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );


/////////////////////////////////////////////////////////////////////////////
// CQuickStartWizard

CQuickStartWizard::CQuickStartWizard( )
{
    WsbTraceIn( L"CQuickStartWizard::CQuickStartWizard", L"" );

    m_TitleId     = IDS_WIZ_QSTART_TITLE;
    m_HeaderId    = IDB_QSTART_HEADER;
    m_WatermarkId = IDB_QSTART_WATERMARK;

    //
    // Init So that we know what checks we have done
    //
    m_CheckSysState    = CST_NOT_STARTED;
    m_hrCheckSysResult = S_OK;

    WsbTraceOut( L"CQuickStartWizard::CQuickStartWizard", L"" );
}

CQuickStartWizard::~CQuickStartWizard( )
{
    WsbTraceIn( L"CQuickStartWizard::~CQuickStartWizard", L"" );

    WsbTraceOut( L"CQuickStartWizard::~CQuickStartWizard", L"" );
}

STDMETHODIMP
CQuickStartWizard::AddWizardPages(
    IN RS_PCREATE_HANDLE Handle,
    IN IUnknown*         pCallback,
    IN ISakSnapAsk*      pSakSnapAsk
    )
{
    WsbTraceIn( L"CQuickStartWizard::AddWizardPages", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Initialize the Sheet
        //
        WsbAffirmHr( InitSheet( Handle, pCallback, 0, pSakSnapAsk, 0, 0 ) );

        //
        // Load pages 
        //
        WsbAffirmHr( AddPage( &m_IntroPage ) );
        WsbAffirmHr( AddPage( &m_CheckPage ) );
        WsbAffirmHr( AddPage( &m_ManageRes ) );
        WsbAffirmHr( AddPage( &m_ManageResX ) );
        WsbAffirmHr( AddPage( &m_InitialValues ) );
        WsbAffirmHr( AddPage( &m_MediaSel ) );
        WsbAffirmHr( AddPage( &m_SchedulePage ) );
        WsbAffirmHr( AddPage( &m_FinishPage ) );
        
    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartWizard::AddWizardPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CQuickStartWizard::InitTask( )
{
    WsbTraceIn( L"CQuickStartWizard::InitTask", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // Need to connect to the scheduling agent to get a page
        // to show. Do that up front
        //
        
        WsbAffirmHr( m_pSchedAgent.CoCreateInstance( CLSID_CSchedulingAgent ) );
        
        CString jobTitle;
        jobTitle.LoadString( IDS_SCHED_TASK_TEMP_TITLE );

        //
        // If it exists already, blow it away (assume doing fresh install)
        // Ignore error in case not exist.
        //
        m_pSchedAgent->Delete( jobTitle );

        WsbAffirmHr( m_pSchedAgent->NewWorkItem( jobTitle, CLSID_CTask, IID_ITask, (IUnknown**)&m_pTask ) );

        TASK_TRIGGER taskTrigger;
        SYSTEMTIME sysTime;
        WORD triggerNumber;
        WsbAffirmHr( m_pTask->CreateTrigger( &triggerNumber, &m_pTrigger ) );
        
        memset( &taskTrigger, 0, sizeof( taskTrigger ) );
        taskTrigger.cbTriggerSize = sizeof( taskTrigger );

        GetSystemTime( &sysTime );
        taskTrigger.wBeginYear  = sysTime.wYear;
        taskTrigger.wBeginMonth = sysTime.wMonth;
        taskTrigger.wBeginDay   = sysTime.wDay;

        taskTrigger.wStartHour  = 2;
        taskTrigger.TriggerType = TASK_TIME_TRIGGER_DAILY;
        taskTrigger.Type.Daily.DaysInterval = 1;

        WsbAffirmHr( m_pTrigger->SetTrigger( &taskTrigger ) );

    } WsbCatchAndDo( hr,
    
        CString errString;
        AfxFormatString1( errString, IDS_ERR_CREATE_TASK, WsbHrAsString( hr ) );

        AfxMessageBox( errString, RS_MB_ERROR ); 
        PressButton( PSBTN_FINISH );

    );

    WsbTraceOut( L"CQuickStartWizard::InitTask", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CQuickStartWizard::OnCancel( ) 
{
    WsbTraceIn( L"CQuickStartWizard::OnCancel", L"" );

    //
    // Need to delete the task
    //

    if( m_pSchedAgent ) {

        if( m_pTrigger )  m_pTrigger.Release( );
        if( m_pTask )     m_pTask.Release( );

        CWsbStringPtr jobTitle;
        WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_TASK_TITLE, &jobTitle));

        m_pSchedAgent->Delete( jobTitle );

        //
        // Delete the temporary tesk
        //
        CString tempTitle;
        tempTitle.LoadString( IDS_SCHED_TASK_TEMP_TITLE );

        m_pSchedAgent->Delete( tempTitle );

    }

    WsbTraceOut( L"CQuickStartWizard::OnCancel", L"" );
    return( S_OK );
}

HRESULT 
CQuickStartWizard::OnFinish(
    )
{
    WsbTraceIn( L"CQuickStartWizard::OnFinish", L"" );
    BOOL doAll = FALSE;

    //
    // The sheet really owns the process as a whole,
    // so it will do the final assembly
    //

    HRESULT hr     = S_OK;
    HRESULT hrLoop = S_OK;
    BOOL    completedAll = FALSE;

    try {

        //
        // Show the Wait cursor so that they know we are busy
        //
        CWaitCursor wait;

        //
        // Get the HSM service interface for creating local objects
        //

        CComPtr<IWsbCreateLocalObject>  pCreateLocal;
        CComPtr<IHsmServer> pServer;
        CComPtr<IFsaServer> pFsa;
        CComPtr<IRmsServer> pRms;
        CComPtr<IWsbIndexedCollection> pResCollection;
        CComPtr<IHsmManagedResource> pHsmResource;
        CComPtr <IWsbIndexedCollection> pStoPoCollection;
        CComPtr <IHsmStoragePool> pStoragePool;

        WsbAffirmHr( GetHsmServer( pServer ) );
        WsbAffirmHr( GetFsaServer( pFsa ) );
        WsbAffirmHr( GetRmsServer( pRms ) );
        WsbAffirmHr( pServer->QueryInterface( IID_IWsbCreateLocalObject, (void **) &pCreateLocal ) );
        WsbAffirmHr( pServer->GetManagedResources( &pResCollection ) );

        WsbAffirmHr( pResCollection->RemoveAllAndRelease( ) );

        //
        // Pull out the default levels for all resources to be managed
        //

        ULONG    defaultFreeSpace = CONVERT_TO_HSMNUM( m_InitialValues.m_FreeSpaceSpinner.GetPos( ) );
        LONGLONG defaultMinSize = ( (LONGLONG)m_InitialValues.m_MinSizeSpinner.GetPos( ) ) * ((LONGLONG)1024);
        FILETIME defaultAccess = WsbLLtoFT( ( (LONGLONG)m_InitialValues.m_AccessSpinner.GetPos( ) ) * (LONGLONG)WSB_FT_TICKS_PER_DAY );
    
        // Is the "all" radio button selected?
        if( !m_ManageRes.m_RadioSelect.GetCheck() ) {

            doAll = TRUE;

        }


        //
        // Go through the listbox and pull out the checked resources.
        // Create HSM managed volumes for them
        //

        CSakVolList &listBox = m_ManageRes.m_ListBox;

        INT index;
        for( index = 0; index < listBox.GetItemCount( ); index++ ) {

            if( ( doAll ) || ( listBox.GetCheck( index ) ) ) {

                CResourceInfo* pResInfo = (CResourceInfo*)listBox.GetItemData( index );
                WsbAffirmPointer( pResInfo );

                try {

                    //
                    // Create Local to server since it will eventually own it.
                    //

                    pHsmResource.Release( );
                    WsbAffirmHr( pCreateLocal->CreateInstance( 
                        CLSID_CHsmManagedResource, 
                        IID_IHsmManagedResource, 
                        (void**)&pHsmResource ) );

                    //
                    // Initialize Fsa object to its initial values.
                    //

                    WsbAffirmHr( (pResInfo->m_pResource)->SetHsmLevel( defaultFreeSpace ) );
                    WsbAffirmHr( (pResInfo->m_pResource)->SetManageableItemLogicalSize( defaultMinSize ) );
                    WsbAffirmHr( (pResInfo->m_pResource)->SetManageableItemAccessTime( TRUE, defaultAccess ) );

                    //
                    // Associate HSM Managed Resource with the FSA resource
                    // (also adds to HSM collection)
                    //

                    WsbAffirmHr( pHsmResource->InitFromFsaResource( pResInfo->m_pResource ) );
                    WsbAffirmHr( pResCollection->Add( pHsmResource ) );

                } WsbCatch( hrLoop );

            }

        }

        //
        // And now that all configuration of services is done, 
        // save it all
        //

        WsbAffirmHr( RsServerSaveAll( pServer ) );
        WsbAffirmHr( RsServerSaveAll( pFsa ) );

        //
        // Set up the schedule. We have created a temporary object that
        // will never be saved to disk. Instead, we need the service to
        // create the task so that it has the correct account. We then
        // grab it and copy over the triggers from the temp job.
        //
        CWsbStringPtr taskTitle, commentString;
        WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_TASK_TITLE, &taskTitle));
        WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_COMMENT, &commentString));

        CComPtr<ITask> pTask;
        WsbAffirmHr( pServer->CreateTask( taskTitle, L"", commentString, TASK_TIME_TRIGGER_DAILY, 0, 0, TRUE ) );
        WsbAffirmHr( m_pSchedAgent->Activate( taskTitle, IID_ITask, (IUnknown**)&pTask ) );

        // Nuke the temporary one created for us.
        WsbAffirmHr( pTask->DeleteTrigger( 0 ) );

        CComPtr<ITaskTrigger> pTrigger1, pTrigger2;
        WORD triggerCount, triggerIndex, newTriggerIndex;
        TASK_TRIGGER taskTrigger;
        WsbAffirmHr( m_pTask->GetTriggerCount( &triggerCount ) );
        for( triggerIndex = 0; triggerIndex < triggerCount; triggerIndex++ ) {

            WsbAffirmHr( m_pTask->GetTrigger( triggerIndex, &pTrigger1 ) );
            WsbAffirmHr( pTrigger1->GetTrigger( &taskTrigger ) );

            WsbAffirmHr( pTask->CreateTrigger( &newTriggerIndex, &pTrigger2 ) );
            // Just to note - WsbAffirm( newTriggerIndex == triggerIndex, E_UNEXPECTED );
            WsbAffirmHr( pTrigger2->SetTrigger( &taskTrigger ) );

            pTrigger1.Release( );
            pTrigger2.Release( );

        }

        // Set real parameters since we have a real schedule now.
        CString parameters;
        parameters = RS_STR_KICKOFF_PARAMS;
        WsbAffirmHr( pTask->SetParameters( parameters ) );

        CComPtr<IPersistFile> pPersist;
        WsbAffirmHr( pTask->QueryInterface( IID_IPersistFile, (void**)&pPersist ) );

        WsbAffirmHr( pPersist->Save( 0, 0 ) );

        //
        // Do last since it is what we key off of for being "Set up"
        //
        // Configure the selected media set
        //
        INT curSel = m_MediaSel.m_ListMediaSel.GetCurSel ();
        WsbAffirm( (curSel != LB_ERR), E_FAIL );
        IRmsMediaSet* pMediaSet = (IRmsMediaSet *)  m_MediaSel.m_ListMediaSel.GetItemDataPtr( curSel );

        //
        // Get the storage pool.
        //
        WsbAffirmHr( RsGetStoragePool( pServer, &pStoragePool ) );

        //
        // Set the media set info in the storage pool
        //
        WsbAffirmHr( pStoragePool->InitFromRmsMediaSet( pMediaSet ) );

        WsbAffirmHr( RsServerSaveAll( pServer ) );

        //
        // Delete the temporary tesk
        //
        CString tempTitle;
        tempTitle.LoadString( IDS_SCHED_TASK_TEMP_TITLE );

        m_pSchedAgent->Delete( tempTitle );

        //
        // Show any error that occurred while managing volumes
        //
        completedAll = TRUE;
        WsbAffirmHr( hrLoop );

    } WsbCatchAndDo( hr,

        CString errString;
        AfxFormatString1( errString, IDS_ERROR_QSTART_ONFINISH, WsbHrAsString( hr ) );
        AfxMessageBox( errString, RS_MB_ERROR ); 

    );

    //
    // Set result so invoking code knows what our result is.
    // The constructor set this to RS_E_CANCELED, so an S_FALSE would
    // indicate a canceled wizard.
    //
    m_HrFinish = ( completedAll ) ? S_OK : hr;

    WsbTraceOut( L"CQuickStartWizard::OnFinish", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CQuickStartWizard::GetHsmServer(
    CComPtr<IHsmServer> &pServ
    )
{
    WsbTraceIn( L"CQuickStartWizard::GetHsmServer", L"" );

    HRESULT hr = S_OK;

    try {

        if( !m_pHsmServer ) {

            CWsbStringPtr computerName;
            WsbAffirmHr( WsbGetComputerName( computerName ) );

            WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, computerName, IID_IHsmServer, (void**)&m_pHsmServer ) );

        }

        pServ = m_pHsmServer;

    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartWizard::GetHsmServer", L"hr = <%ls>, pServ = <0x%p>", WsbHrAsString( hr ), pServ.p );
    return( hr );
}

HRESULT
CQuickStartWizard::GetFsaServer(
    CComPtr<IFsaServer> &pServ
    )
{
    WsbTraceIn( L"CQuickStartWizard::GetFsaServer", L"" );

    HRESULT hr = S_OK;

    try {

        if( !m_pFsaServer ) {

            CWsbStringPtr computerName;
            WsbAffirmHr( WsbGetComputerName( computerName ) );
            WsbAffirmHr(computerName.Append("\\NTFS"));

            WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_FSA, computerName, IID_IFsaServer, (void**)&m_pFsaServer ) );

        }

        pServ = m_pFsaServer;

    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartWizard::GetFsaServer", L"hr = <%ls>, pServ = <0x%p>", WsbHrAsString( hr ), pServ.p );
    return( hr );
}

HRESULT
CQuickStartWizard::GetRmsServer(
    CComPtr<IRmsServer> &pServ
    )
{
    WsbTraceIn( L"CQuickStartWizard::GetRmsServer", L"" );

    HRESULT hr = S_OK;

    try {

        if( !m_pRmsServer ) {

            CWsbStringPtr computerName;
            WsbAffirmHr( WsbGetComputerName( computerName ) );

            CComPtr<IHsmServer>     pHsmServer;
            WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, computerName, IID_IHsmServer, (void**)&pHsmServer ) );
            WsbAffirmPointer(pHsmServer);
            WsbAffirmHr(pHsmServer->GetHsmMediaMgr(&m_pRmsServer));
        }

        pServ = m_pRmsServer;

    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartWizard::GetRmsServer", L"hr = <%ls>, pServ = <0x%p>", WsbHrAsString( hr ), pServ.p );
    return( hr );
}

HRESULT
CQuickStartWizard::ReleaseServers( 
    void
    )
{
    WsbTraceIn( L"CQuickStartWizard::ReleaseServers", L"" );

    HRESULT hr = S_OK;

    m_pHsmServer.Release( );
    m_pFsaServer.Release( );
    m_pRmsServer.Release( );

    WsbTraceOut( L"CQuickStartWizard::ReleaseServers", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( S_OK );
}

DWORD WINAPI
CQuickStartWizard::CheckSysThreadStart(
    LPVOID pv
    )
{
    WsbTraceIn( L"CQuickStartWizard::CheckSysThreadStart", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;
    HRESULT hrCom = S_OK;

    CQuickStartWizard * pWiz = (CQuickStartWizard*)pv;

    try {
        hrCom = CoInitialize( 0 );
        WsbAffirmHr( hrCom );

        WsbAffirmPointer( pv );

        pWiz->m_hrCheckSysResult = S_OK;
        do {
        
            WsbTrace( L"Checking Account Security\n" );
            pWiz->m_CheckSysState = CST_ACCOUNT;

            //
            // Do they have admin privs?
            //

            WsbAffirmHr( hrInternal = WsbCheckAccess( WSB_ACCESS_TYPE_ADMINISTRATOR ) );
            if( hrInternal == E_ACCESSDENIED ) {

                hr = S_FALSE;
                continue;


            }

            // Is media suppported?
            WsbTrace( L"Account Security OK\n" );
        
            WsbTrace( L"Checking for Supported Media\n" );
            pWiz->m_CheckSysState = CST_SUPP_MEDIA;

            WsbAffirmHr(hrInternal = RsIsSupportedMediaAvailable( ) );
            if( hrInternal == S_FALSE ) {

                hr = S_FALSE;
                continue;

            }

            WsbTrace( L"Supported Media Found\n" );
            pWiz->m_CheckSysState    = CST_DONE;

        
        } while( 0 );
    } WsbCatch( hr );
            
    //
    // And report back what our results are
    //
    
    pWiz->m_hrCheckSysResult = hr;
    
    //
    // We'll exit and end thread, so hide the main threads handle of us.
    //
    
    pWiz->m_hCheckSysThread = 0;

    if (SUCCEEDED(hrCom)) {
        CoUninitialize( );
    }

    WsbTraceOut( L"CQuickStartWizard::CheckSysThreadStart", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
// CQuickStartIntro property page

BEGIN_MESSAGE_MAP(CQuickStartIntro, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartIntro)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

CQuickStartIntro::CQuickStartIntro() :
    CSakWizardPage_InitBaseExt( WIZ_QSTART_INTRO )
{
    WsbTraceIn( L"CQuickStartIntro::CQuickStartIntro", L"" );
    //{{AFX_DATA_INIT(CQuickStartIntro)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    WsbTraceOut( L"CQuickStartIntro::CQuickStartIntro", L"" );
}

HRESULT
CQuickStartIntro::IsDriverRunning()
{
    HRESULT hr = S_FALSE;

    //
    // Ensure the filter is installed and running.
    //

    SC_HANDLE hSCM    = 0;
    SC_HANDLE hDriver = 0;
    SERVICE_STATUS serviceStatus;

    try {

        hSCM = OpenSCManager( 0, 0, GENERIC_READ );
        WsbAffirmPointer( hSCM );

        hDriver = OpenService( hSCM, TEXT( RSFILTER_SERVICENAME ), SERVICE_QUERY_STATUS );
        WsbAffirmStatus( 0 != hDriver );

        WsbAffirmStatus( QueryServiceStatus( hDriver, &serviceStatus ) );

        if( SERVICE_RUNNING == serviceStatus.dwCurrentState ) {

            //
            // Things look good, set flag so Wizard will allow conitue.
            //
            hr = S_OK;

        }


    } WsbCatch( hr );

    if( hSCM )    CloseServiceHandle( hSCM );
    if( hDriver ) CloseServiceHandle( hDriver );

    return( hr );
}

HRESULT
CQuickStartIntro::CheckLastAccessDateState(
    LAD_STATE* ladState
    )
{
    WsbTraceIn( L"CQuickStartIntro::CheckLastAccessDateState", L"" );

    const OLECHAR* localMachine = 0;
    const OLECHAR* regPath      = L"System\\CurrentControlSet\\Control\\FileSystem";
    const OLECHAR* regValue     = L"NtfsDisableLastAccessUpdate";

    HRESULT hr   = S_OK;
    DWORD   pVal = 0;

    try {

        // Install might have changed this registry value from 1 to 0. If the value
        // is not 1, we assume that the registry was 1 at one time and install
        // changed it to 0. This is a one time check, so the value is removed from
        // the registry if not 1.

        // If the following fails we assume that the value is not in the registry,
        // the normal case.

        if( S_OK == WsbGetRegistryValueDWORD( localMachine,
                                              regPath,
                                              regValue,
                                              &pVal ) ) {

            if( pVal == (DWORD)1 ) {

                *ladState = LAD_DISABLED;

            } else {

                *ladState = LAD_ENABLED;

                WsbAffirmHr( WsbRemoveRegistryValue ( localMachine,
                                                      regPath,
                                                      regValue ) );
            }

        } else {

            *ladState = LAD_UNSET;
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartIntro::CheckLastAccessDateState",
                 L"HRESULT = %ls, *ladState = %d",
                 WsbHrAsString( hr ),
                 *ladState );

    return( hr );
}

LRESULT 
CQuickStartIntro::OnWizardNext()
{
    LAD_STATE ladState = LAD_UNSET;

    HRESULT hr = IsDriverRunning( );
    
    if( S_FALSE == hr ) {

        //
        // And the final restart dialog so the filter can load
        // In order to shut down we must enable a privilege.
        //

        if( IDYES == AfxMessageBox( IDS_QSTART_RESTART_NT, MB_YESNO | MB_ICONEXCLAMATION ) ) {

            HANDLE hToken;
            if( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) ) {

                TOKEN_PRIVILEGES privs;

                LookupPrivilegeValue( 0, SE_SHUTDOWN_NAME, &privs.Privileges[0].Luid );
                privs.PrivilegeCount = 1;
                privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                AdjustTokenPrivileges( hToken, FALSE, &privs, 0, 0, 0 );

                ExitWindowsEx( EWX_REBOOT, 0 );

            }
        }
        return( -1 );

    } else if( HRESULT_FROM_WIN32( ERROR_SERVICE_DOES_NOT_EXIST ) == hr ) {

        AfxMessageBox( IDS_ERR_QSTART_NO_FILTER, RS_MB_ERROR );
        return( -1 );

    } else if( FAILED( hr ) ) {

        CString message;
        AfxFormatString1( message, IDS_ERR_QSTART_FILTER_ERROR, WsbHrAsString( hr ) );
        AfxMessageBox( message, RS_MB_ERROR );
        return( -1 );

    } else {

        WsbAffirmHr( CheckLastAccessDateState( &ladState ) );

        if( ladState == LAD_DISABLED ) {

            AfxMessageBox( IDS_WIZ_LAST_ACCESS_DATE_DISABLED, MB_OK | MB_ICONEXCLAMATION );

        } else if( ladState == LAD_ENABLED ) {

            AfxMessageBox( IDS_WIZ_LAST_ACCESS_DATE_ENABLED, MB_OK | MB_ICONEXCLAMATION );
        }
    }
    
    //
    // Last check is if we can create temp task
    //
    if( FAILED( QSHEET->InitTask( ) ) ) {

        return( -1 );        

    }

    //
    // If we got through it, must be OK to continue
    //
    return( 0 );
}

CQuickStartIntro::~CQuickStartIntro( )
{
    WsbTraceIn( L"CQuickStartIntro::~CQuickStartIntro", L"" );
    WsbTraceOut( L"CQuickStartIntro::~CQuickStartIntro", L"" );
}

void CQuickStartIntro::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartIntro::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartIntro)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartIntro::DoDataExchange", L"" );
}

BOOL CQuickStartIntro::OnInitDialog( ) 
{
    WsbTraceIn( L"CQuickStartIntro::OnInitDialog", L"" );

    CSakWizardPage::OnInitDialog( );

    WsbTraceOut( L"CQuickStartIntro::OnInitDialog", L"" );
    return TRUE;
}

BOOL CQuickStartIntro::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartIntro::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    m_pSheet->SetWizardButtons( PSWIZB_NEXT );

    WsbTraceOut( L"CQuickStartIntro::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

/////////////////////////////////////////////////////////////////////////////
// CQuickStartInitialValues property page

CQuickStartInitialValues::CQuickStartInitialValues() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_INITIAL_VAL )
{
    WsbTraceIn( L"CQuickStartInitialValues::CQuickStartInitialValues", L"" );
    //{{AFX_DATA_INIT(CQuickStartInitialValues)
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartInitialValues::CQuickStartInitialValues", L"" );
}

CQuickStartInitialValues::~CQuickStartInitialValues( )
{
    WsbTraceIn( L"CQuickStartInitialValues::~CQuickStartInitialValues", L"" );
    WsbTraceOut( L"CQuickStartInitialValues::~CQuickStartInitialValues", L"" );
}

void CQuickStartInitialValues::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartInitialValues::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartInitialValues)
    DDX_Control(pDX, IDC_MINSIZE_BUDDY, m_MinSizeEdit);
    DDX_Control(pDX, IDC_FREESPACE_BUDDY, m_FreeSpaceEdit);
    DDX_Control(pDX, IDC_ACCESS_BUDDY, m_AccessEdit);
    DDX_Control(pDX, IDC_MINSIZE_SPIN, m_MinSizeSpinner);
    DDX_Control(pDX, IDC_FREESPACE_SPIN, m_FreeSpaceSpinner);
    DDX_Control(pDX, IDC_ACCESS_SPIN, m_AccessSpinner);
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartInitialValues::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartInitialValues, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartInitialValues)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CQuickStartInitialValues message handlers

BOOL CQuickStartInitialValues::OnInitDialog( ) 
{
    WsbTraceIn( L"CQuickStartInitialValues::OnInitDialog", L"" );

    CSakWizardPage::OnInitDialog( );

    HRESULT hr = S_OK;

    try {

        //
        // Set up the spinners
        //

        m_FreeSpaceSpinner.SetRange( HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );
        m_MinSizeSpinner.SetRange( HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
        m_AccessSpinner.SetRange( HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );

        m_FreeSpaceSpinner.SetPos( HSMADMIN_DEFAULT_FREESPACE );
        m_MinSizeSpinner.SetPos( HSMADMIN_DEFAULT_MINSIZE );
        m_AccessSpinner.SetPos( HSMADMIN_DEFAULT_INACTIVITY );

        m_FreeSpaceEdit.SetLimitText( 2 );
        m_MinSizeEdit.SetLimitText( 5 );
        m_AccessEdit.SetLimitText( 3 );

    } WsbCatch( hr );
    

    WsbTraceOut( L"CQuickStartInitialValues::OnInitDialog", L"" );
    return TRUE;
}

BOOL CQuickStartInitialValues::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartInitialValues::OnSetActive", L"" );

    BOOL retval = FALSE;

    //
    // Make sure at least one item is checked before allowing active
    //

    BOOL check = FALSE;
    CSakVolList &listBox = QSHEET->m_ManageRes.m_ListBox;
    for( INT i = 0; ( i < listBox.GetItemCount( ) ) && !check; i++  ) {
    
        if( listBox.GetCheck( i ) )    check = TRUE;
    
    }

    if( check ) {

        retval = CSakWizardPage::OnSetActive( );

        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    }
    
    WsbTraceOut( L"CQuickStartInitialValues::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

BOOL CQuickStartInitialValues::OnKillActive( ) 
{
    WsbTraceIn( L"CQuickStartInitialValues::OnKillActive", L"" );

    BOOL retval = FALSE;

    //
    // Need to handle strange case where a user can enter a value within
    // the parameters of the number of digits allowed, but the value can
    // be out of range. This is detected by the spin box which will
    // return an error if its buddy control is out of range.
    //
    if( HIWORD( m_MinSizeSpinner.GetPos( ) ) > 0 ) {

        // Control reports on error...
        retval = FALSE;

        CString message;
        AfxFormatString2( message, IDS_ERR_MINSIZE_RANGE, 
            CString( WsbLongAsString( (LONG)HSMADMIN_MIN_MINSIZE ) ),
            CString( WsbLongAsString( (LONG)HSMADMIN_MAX_MINSIZE ) ) );
        AfxMessageBox( message, MB_OK | MB_ICONWARNING );

    } else {

        retval = CSakWizardPage::OnKillActive();

    }
    
    WsbTraceOut( L"CQuickStartInitialValues::OnKillActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}


/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageRes property page

CQuickStartManageRes::CQuickStartManageRes() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_MANRES_SEL )
{
    WsbTraceIn( L"CQuickStartManageRes::CQuickStartManageRes", L"" );
    //{{AFX_DATA_INIT(CQuickStartManageRes)
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartManageRes::CQuickStartManageRes", L"" );
}

CQuickStartManageRes::~CQuickStartManageRes( )
{
    WsbTraceIn( L"CQuickStartManageRes::~CQuickStartManageRes", L"" );
    WsbTraceOut( L"CQuickStartManageRes::~CQuickStartManageRes", L"" );
}

void CQuickStartManageRes::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartManageRes::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartManageRes)
    DDX_Control(pDX, IDC_MANRES_SELECT, m_ListBox);
    DDX_Control(pDX, IDC_RADIO_SELECT, m_RadioSelect);
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartManageRes::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartManageRes, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartManageRes)
    ON_WM_DESTROY( )
    ON_LBN_DBLCLK(IDC_MANRES_SELECT, OnDblclkSelect)
    ON_BN_CLICKED(IDC_RADIO_MANAGE_ALL, OnRadioQsManageAll)
    ON_BN_CLICKED(IDC_RADIO_SELECT, OnQsRadioSelect)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_MANRES_SELECT, OnItemchanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageRes message handlers

BOOL CQuickStartManageRes::OnInitDialog( ) 
{
    WsbTraceIn( L"CQuickStartManageRes::OnInitDialog", L"" );

    CSakWizardPage::OnInitDialog( );
    
    BOOL           gotOne   = FALSE;
    HRESULT        hr       = S_OK;
    CResourceInfo* pResInfo = 0;

    try {

        //
        // Connect to the FSA for this machine
        //

        CWsbStringPtr computerName;
        WsbAffirmHr( WsbGetComputerName( computerName ) );
        
        CComPtr<IFsaServer> pFsaServer;
        WsbAffirmHr( QSHEET->GetFsaServer( pFsaServer ) );

        CComPtr<IWsbEnum> pEnum;
        WsbAffirmHr( pFsaServer->EnumResources( &pEnum ) );

        HRESULT hrEnum;
        CComPtr<IFsaResource> pResource;

        hrEnum = pEnum->First( IID_IFsaResource, (void**)&pResource );
        WsbAffirm( SUCCEEDED( hrEnum ) || ( WSB_E_NOTFOUND == hrEnum ), hrEnum );

        INT index = 0;
        while( SUCCEEDED( hrEnum ) ) {

            //
            // If path is blank, do not show this volume
            //
            if( S_OK == RsIsVolumeAvailable( pResource ) ) {

                gotOne = TRUE;

                pResInfo = new CResourceInfo( pResource );
                WsbAffirmAlloc( pResInfo );
                WsbAffirmHr( pResInfo->m_HrConstruct );

                //
                // Set Name, Capacity and Free Space columns.
                //
                WsbAffirm( LB_ERR != index, E_FAIL );
                LONGLONG    totalSpace  = 0;
                LONGLONG    freeSpace   = 0;
                LONGLONG    premigrated = 0;
                LONGLONG    truncated   = 0;
                WsbAffirmHr( pResource->GetSizes( &totalSpace, &freeSpace, &premigrated, &truncated ) );
                CString totalString, freeString;
                RsGuiFormatLongLong4Char( totalSpace, totalString );
                RsGuiFormatLongLong4Char( freeSpace, freeString );                  

                WsbAffirm( m_ListBox.AppendItem( pResInfo->m_DisplayName, totalString, freeString, &index ), E_FAIL );
                WsbAffirm( -1 != index, E_FAIL );

                //
                // Store struct pointer in listbox
                //
                WsbAffirm( m_ListBox.SetItemData( index, (DWORD_PTR)pResInfo ), E_FAIL );
                pResInfo = 0;

                //
                // Initialize selected array
                //
                m_ListBoxSelected[ index ] = FALSE;
            }

            //
            // Prepare for next iteration
            //
            pResource.Release( );
            hrEnum = pEnum->Next( IID_IFsaResource, (void**)&pResource );

        }

        m_ListBox.SortItems( CResourceInfo::Compare, 0 );

        //
        // Set the button AFTER we fill the box
        //
        CheckRadioButton( IDC_RADIO_MANAGE_ALL, IDC_RADIO_SELECT, IDC_RADIO_SELECT );
        OnQsRadioSelect( );
    } WsbCatch( hr );

    if( pResInfo )  delete pResInfo;
    
    WsbTraceOut( L"CQuickStartManageRes::OnInitDialog", L"" );
    return TRUE;
}

BOOL CQuickStartManageRes::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartManageRes::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    if( m_ListBox.GetItemCount( ) <= 0 ) {

        retval = FALSE;

    }

    SetButtons( );

    WsbTraceOut( L"CQuickStartManageRes::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

void CQuickStartManageRes::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
    WsbTraceIn( L"CQuickStartManageRes::OnItemchanged", L"" );

    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    SetButtons();
    
    *pResult = 0;

    WsbTraceOut( L"CQuickStartManageRes::OnItemchanged", L"" );
}
   
void CQuickStartManageRes::OnDblclkSelect( ) 
{
    WsbTraceIn( L"CQuickStartManageRes::OnDblclkSelect", L"" );

    SetButtons( );

    WsbTraceOut( L"CQuickStartManageRes::OnDblclkSelect", L"" );
}

void CQuickStartManageRes::SetButtons( )
{
    WsbTraceIn( L"CQuickStartManageRes::SetButtons", L"" );

    BOOL fChecked = FALSE;
    INT count;

    // Is the "all" radio checked?
    if( !m_RadioSelect.GetCheck() ) {

        fChecked = TRUE;

    } else {

        // If one or more selected in the list box, set next button
        count = m_ListBox.GetItemCount();
        for( INT index = 0; index < count; index++ ) {

            if( m_ListBox.GetCheck( index ) ) {

                fChecked = TRUE;

            }
        }
    }

    m_pSheet->SetWizardButtons( PSWIZB_NEXT );

    WsbTraceOut( L"CQuickStartManageRes::SetButtons", L"" );
}

void CQuickStartManageRes::OnDestroy( ) 
{
    WsbTraceIn( L"CQuickStartManageRes::OnDestroy", L"" );

    CSakWizardPage::OnDestroy( );

    //
    // Cleanup the listbox's interface pointers
    // happens when the CResourceInfo is destructed
    //

    INT index;

    for( index = 0; index < m_ListBox.GetItemCount( ); index++ ) {

        CResourceInfo* pResInfo = (CResourceInfo*)m_ListBox.GetItemData( index );
        delete pResInfo;

    }
    
    WsbTraceOut( L"CQuickStartManageRes::OnDestroy", L"" );
}

void CQuickStartManageRes::OnRadioQsManageAll() 
{
    INT i;

    //
    // Save the current selection in the itemData array
    // Check all the boxes for display purposes only
    //
    for( i = 0; i < m_ListBox.GetItemCount(); i++ ) {

        m_ListBoxSelected[ i ] = m_ListBox.GetCheck( i );
        m_ListBox.SetCheck( i, TRUE );

    }

    m_ListBox.EnableWindow( FALSE );

    SetButtons();
}

void CQuickStartManageRes::OnQsRadioSelect() 
{
    INT i;

    // Get saved selection from itemdata array
    for( i = 0; i < m_ListBox.GetItemCount(); i++ ) {

        m_ListBox.SetCheck( i, m_ListBoxSelected[ i ] );

    }

    m_ListBox.EnableWindow( TRUE );

    SetButtons();
}

/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageResX property page

CQuickStartManageResX::CQuickStartManageResX() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_MANRES_SELX )
{
    WsbTraceIn( L"CQuickStartManageResX::CQuickStartManageResX", L"" );
    //{{AFX_DATA_INIT(CQuickStartManageResX)
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartManageResX::CQuickStartManageResX", L"" );
}

CQuickStartManageResX::~CQuickStartManageResX( )
{
    WsbTraceIn( L"CQuickStartManageResX::~CQuickStartManageResX", L"" );
    WsbTraceOut( L"CQuickStartManageResX::~CQuickStartManageResX", L"" );
}

void CQuickStartManageResX::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartManageResX::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartManageResX)
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartManageResX::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartManageResX, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartManageResX)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageResX message handlers

BOOL CQuickStartManageResX::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartManageResX::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    if( QSHEET->m_ManageRes.m_ListBox.GetItemCount( ) > 0 ) {

        retval = FALSE;

    }

    m_pSheet->SetWizardButtons( PSWIZB_NEXT );

    WsbTraceOut( L"CQuickStartManageResX::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

/////////////////////////////////////////////////////////////////////////////
// CQuickStartMediaSel property page

CQuickStartMediaSel::CQuickStartMediaSel() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_MEDIA_SEL )
{
    WsbTraceIn( L"CQuickStartMediaSel::CQuickStartMediaSel", L"" );
    //{{AFX_DATA_INIT(CQuickStartMediaSel)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartMediaSel::CQuickStartMediaSel", L"" );
}

CQuickStartMediaSel::~CQuickStartMediaSel( )
{
    WsbTraceIn( L"CQuickStartMediaSel::~CQuickStartMediaSel", L"" );
    WsbTraceOut( L"CQuickStartMediaSel::~CQuickStartMediaSel", L"" );
}

void CQuickStartMediaSel::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartMediaSel::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartMediaSel)
    DDX_Control(pDX, IDC_MEDIA_SEL, m_ListMediaSel);
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartMediaSel::DoDataExchange", L"" );
}

BEGIN_MESSAGE_MAP(CQuickStartMediaSel, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartMediaSel)
    ON_WM_DESTROY()
    ON_LBN_SELCHANGE(IDC_MEDIA_SEL, OnSelchangeMediaSel)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

BOOL CQuickStartMediaSel::OnInitDialog() 
{
    WsbTraceIn( L"CQuickStartMediaSel::OnInitDialog", L"" );

    HRESULT hr = 0;
    ULONG numEntries;

    CSakWizardPage::OnInitDialog();
    
    try {
        //
        // Get IRmsServer
        //
        CComPtr<IRmsServer> pRmsServer;
        WsbAffirmHr( QSHEET->GetRmsServer( pRmsServer ) );

        //
        // Get collection of Rms media sets
        //
        CComPtr<IRmsMediaSet> pMediaSet;
        CComPtr<IWsbIndexedCollection> pMediaSets;
        pRmsServer->GetMediaSets (&pMediaSets);

        WsbAffirmHr( pMediaSets->GetEntries( &numEntries ) );

        
        for( ULONG i = 0; i < numEntries; i++ ) {

            CWsbBstrPtr szMediaType;
            pMediaSet.Release();
            WsbAffirmHr( pMediaSets->At( i, IID_IRmsMediaSet, (void**) &pMediaSet ) );
            WsbAffirmHr( pMediaSet->GetName ( &szMediaType ) );

            //
            // Add the string to the listbox
            //
            INT index = m_ListMediaSel.AddString (szMediaType);

            //
            // Add the interface pointer to the list box
            //
            m_ListMediaSel.SetItemDataPtr( index, pMediaSet.Detach( ) );

        }

        //
        // And automatically select the first entry
        //
        m_ListMediaSel.SetCurSel( 0 );

    } WsbCatch (hr);
    

    WsbTraceOut( L"CQuickStartMediaSel::OnInitDialog", L"" );
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CQuickStartMediaSel message handlers

void CQuickStartMediaSel::OnDestroy() 
{
    WsbTraceIn( L"CQuickStartMediaSel::OnDestroy", L"" );

    CSakWizardPage::OnDestroy();
    //
    // Cleanup the listbox's interface pointers
    //

    INT index;
    for( index = 0; index < m_ListMediaSel.GetCount( ); index++ ) {

        IRmsMediaSet* pMediaSet = (IRmsMediaSet*) (m_ListMediaSel.GetItemDataPtr( index ));
        pMediaSet->Release( );

    }

    WsbTraceOut( L"CQuickStartMediaSel::OnDestroy", L"" );
}

void CQuickStartMediaSel::SetButtons( )
{
    WsbTraceIn( L"CQuickStartMediaSel::SetButtons", L"" );

    //
    // Make sure at least one item is checked before allowing "next"
    //

    if( m_ListMediaSel.GetCurSel() != LB_ERR ) {

        //
        // Something is selected
        //
        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    } else {

        //
        // Nothing selected - don't allow to pass
        //
        m_pSheet->SetWizardButtons( PSWIZB_BACK );

    }

    WsbTraceOut( L"CQuickStartMediaSel::SetButtons", L"" );
}

BOOL CQuickStartMediaSel::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartMediaSel::OnSetActive", L"" );

    SetButtons( );

    BOOL retval = CSakWizardPage::OnSetActive( );
    WsbTraceOut( L"CQuickStartMediaSel::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

void CQuickStartMediaSel::OnSelchangeMediaSel() 
{
    WsbTraceIn( L"CQuickStartMediaSel::OnSelchangeMediaSel", L"" );

    SetButtons( );

    WsbTraceOut( L"CQuickStartMediaSel::OnSelchangeMediaSel", L"" );
}

/////////////////////////////////////////////////////////////////////////////
// CQuickStartSchedule property page

CQuickStartSchedule::CQuickStartSchedule() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_SCHEDULE )
{
    WsbTraceIn( L"CQuickStartSchedule::CQuickStartSchedule", L"" );
    //{{AFX_DATA_INIT(CQuickStartSchedule)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartSchedule::CQuickStartSchedule", L"" );
}

CQuickStartSchedule::~CQuickStartSchedule()
{
    WsbTraceIn( L"CQuickStartSchedule::~CQuickStartSchedule", L"" );
    WsbTraceOut( L"CQuickStartSchedule::~CQuickStartSchedule", L"" );
}

void CQuickStartSchedule::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartSchedule::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartSchedule)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartSchedule::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartSchedule, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartSchedule)
    ON_BN_CLICKED(IDC_CHANGE_SCHED, OnChangeSchedule)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQuickStartSchedule message handlers

void CQuickStartSchedule::OnChangeSchedule() 
{
    WsbTraceIn( L"CQuickStartSchedule::OnChangeSchedule", L"" );

    CScheduleSheet scheduleSheet( IDS_SCHED_MANAGE_TITLE, QSHEET->m_pTask, 0, 0 );

    scheduleSheet.DoModal( );

    UpdateDescription( );

    WsbTraceOut( L"CQuickStartSchedule::OnChangeSchedule", L"" );
}

BOOL CQuickStartSchedule::OnSetActive() 
{
    WsbTraceIn( L"CQuickStartSchedule::OnSetActive", L"" );

    CSakWizardPage::OnSetActive();

    //
    // Enable buttons
    //

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );
    
    //
    // Update the text box which has the description
    //

    UpdateDescription( );

    WsbTraceOut( L"CQuickStartSchedule::OnSetActive", L"" );
    return TRUE;
}

HRESULT
CQuickStartSchedule::UpdateDescription
(
    void
    )
{
    WsbTraceIn( L"CQuickStartSchedule::UpdateDescription", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // And set schedule text into the text box.
        //
        
        CString buildString;
        WORD triggerCount, triggerIndex;

        WsbAffirmHr( QSHEET->m_pTask->GetTriggerCount( &triggerCount ) );
        
        CWsbStringPtr scheduleString;
        
        for( triggerIndex = 0; triggerIndex < triggerCount; triggerIndex++ ) {
        
            WsbAffirmHr( QSHEET->m_pTask->GetTriggerString( triggerIndex, &scheduleString ) );
            buildString += scheduleString;
            buildString += L"\r\n";

            scheduleString.Free( );
        
        }
        
        CEdit *pEdit = (CEdit *) GetDlgItem( IDC_SCHED_TEXT );
        pEdit->SetWindowText( buildString );
        
        //
        // Now check to see if we should add a scroll bar
        //
        
        //
        // It seems the only way to know that an edit control needs a scrollbar
        // is to force it to scroll to the bottom and see if the first
        // visible line is the first actual line
        //
        
        pEdit->LineScroll( MAXSHORT );
        if( pEdit->GetFirstVisibleLine( ) > 0 ) {
        
            //
            // Add the scroll styles
            //
        
            pEdit->ModifyStyle( 0, WS_VSCROLL | ES_AUTOVSCROLL, SWP_DRAWFRAME );
        
        
        } else {
        
            //
            // Remove the scrollbar (set range to 0)
            //
        
            pEdit->SetScrollRange( SB_VERT, 0, 0, TRUE );
        
        }
        
        //
        // Remove selection
        //
        
        pEdit->PostMessage( EM_SETSEL, -1, 0 );

    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartSchedule::UpdateDescription", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
// CQuickStartFinish property page

CQuickStartFinish::CQuickStartFinish() :
    CSakWizardPage_InitBaseExt( WIZ_QSTART_FINISH )
{
    WsbTraceIn( L"CQuickStartFinish::CQuickStartFinish", L"" );
    //{{AFX_DATA_INIT(CQuickStartFinish)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartFinish::CQuickStartFinish", L"" );
}

CQuickStartFinish::~CQuickStartFinish( )
{
    WsbTraceIn( L"CQuickStartFinish::~CQuickStartFinish", L"" );
    WsbTraceOut( L"CQuickStartFinish::~CQuickStartFinish", L"" );
}

void CQuickStartFinish::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartFinish::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartFinish)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartFinish::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartFinish, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartFinish)
    ON_EN_SETFOCUS(IDC_WIZ_FINAL_TEXT, OnSetFocusFinalText)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CQuickStartFinish message handlers

BOOL CQuickStartFinish::OnInitDialog( ) 
{
    WsbTraceIn( L"CQuickStartFinish::OnInitDialog", L"" );

    //
    // Set up the fonts that we use for this page
    //

    CSakWizardPage::OnInitDialog( );

    WsbTraceOut( L"CQuickStartFinish::OnInitDialog", L"" );
    return TRUE;
}

BOOL CQuickStartFinish::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartFinish::OnSetActive", L"" );

    CSakWizardPage::OnSetActive( );

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
    
    //
    // Fill in text of configuration
    //

    CString formatString, formattedString, buildString, tempString, indentString;
    indentString.LoadString( IDS_QSTART_FINISH_INDENT );

#define FORMAT_TEXT( cid, arg )              \
    AfxFormatString1( formattedString, cid, arg ); \
    buildString += formattedString;

    FORMAT_TEXT( IDS_QSTART_MANRES_TEXT,    0 );
    buildString += L"\r\n";

    //
    // Add Resources
    //

    CSakVolList *pListBox = &(QSHEET->m_ManageRes.m_ListBox);

    INT index, managedCount = 0;
    for( index = 0; index < pListBox->GetItemCount( ); index++ ) {

        if( pListBox->GetCheck( index ) ) {

            buildString += indentString;
            tempString = pListBox->GetItemText( index, 0 );
            buildString += tempString;
            buildString += L"\r\n";

            managedCount++;

        }

    }

    if( 0 == managedCount ) {

        FORMAT_TEXT( IDS_QSTART_MANAGE_NO_VOLUMES, 0 );
        buildString += L"\r\n\r\n";

    } else {

        buildString += L"\r\n";

        //
        // The levels
        //
        
        FORMAT_TEXT( IDS_QSTART_FREESPACE_TEXT, WsbLongAsString( QSHEET->m_InitialValues.m_FreeSpaceSpinner.GetPos( ) ) );
        buildString += L"\r\n\r\n";
        
        AfxFormatString2( formattedString, IDS_QSTART_CRITERIA_TEXT,
            CString( WsbLongAsString( QSHEET->m_InitialValues.m_MinSizeSpinner.GetPos( ) ) ),
            CString( WsbLongAsString( QSHEET->m_InitialValues.m_AccessSpinner.GetPos( ) ) ) );
        buildString += formattedString;
        buildString += L"\r\n\r\n";

    }

    //
    // Media Type
    //

    QSHEET->m_MediaSel.m_ListMediaSel.GetWindowText( tempString );
    FORMAT_TEXT( IDS_QSTART_MEDIA_TEXT, tempString );
    buildString += L"\r\n\r\n";

    //
    // And Schedule
    //

    FORMAT_TEXT( IDS_QSTART_SCHED_TEXT,     0 );
    buildString += L"\r\n";

    WORD triggerCount, triggerIndex;
    QSHEET->m_pTask->GetTriggerCount( &triggerCount );
    
    CWsbStringPtr scheduleString;
    for( triggerIndex = 0; triggerIndex < triggerCount; triggerIndex++ ) {
    
        QSHEET->m_pTask->GetTriggerString( triggerIndex, &scheduleString );
        buildString += indentString;
        buildString += scheduleString;
        if( triggerIndex < triggerCount - 1 ) {

            buildString += L"\r\n";

        }

        scheduleString.Free( );

    }

    CEdit * pEdit = (CEdit*)GetDlgItem( IDC_WIZ_FINAL_TEXT );
    pEdit->SetWindowText( buildString );

    // Set the margins
    pEdit->SetMargins( 4, 4 );

    pEdit->PostMessage( EM_SETSEL, 0, 0 );
    pEdit->PostMessage( EM_SCROLLCARET, 0, 0 );
    pEdit->PostMessage( EM_SETSEL, -1, 0 );

    WsbTraceOut( L"CQuickStartFinish::OnSetActive", L"" );
    return TRUE;
}

void CQuickStartFinish::OnSetFocusFinalText() 
{
    WsbTraceIn( L"CQuickStartFinish::OnSetFocusFinalText", L"" );

    //
    // Deselect the text
    //

    CEdit *pEdit = (CEdit *) GetDlgItem( IDC_WIZ_FINAL_TEXT );
    pEdit->SetSel( -1, 0, FALSE );

    WsbTraceOut( L"CQuickStartFinish::OnSetFocusFinalText", L"" );
}


/////////////////////////////////////////////////////////////////////////////
// CQuickStartCheck property page

CQuickStartCheck::CQuickStartCheck() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_CHECK )
{
    WsbTraceIn( L"CQuickStartCheck::CQuickStartCheck", L"" );

    m_TimerStarted = FALSE;

    //{{AFX_DATA_INIT(CQuickStartCheck)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartCheck::CQuickStartCheck", L"" );
}

CQuickStartCheck::~CQuickStartCheck()
{
    WsbTraceIn( L"CQuickStartCheck::~CQuickStartCheck", L"" );
    WsbTraceOut( L"CQuickStartCheck::~CQuickStartCheck", L"" );
}

void CQuickStartCheck::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartCheck::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartCheck)
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartCheck::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartCheck, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartCheck)
    ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQuickStartCheck message handlers

BOOL CQuickStartCheck::OnSetActive() 
{
    WsbTraceIn( L"CQuickStartCheck::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive();

    m_pSheet->SetWizardButtons( PSWIZB_BACK );

    //
    // Kick off the thread which will check the system
    //

    DWORD threadId;
    QSHEET->m_CheckSysState = CST_NOT_STARTED;
    QSHEET->m_hCheckSysThread =
            CreateThread( 0, 1024, CQuickStartWizard::CheckSysThreadStart, QSHEET, 0, &threadId );

    StartTimer( );

    WsbTraceOut( L"CQuickStartCheck::OnSetActive", L"" );
    return( retval );
}

BOOL CQuickStartCheck::OnKillActive() 
{
    WsbTraceIn( L"CQuickStartCheck::OnKillActive", L"" );

    StopTimer( );
    
    BOOL retval = CSakWizardPage::OnKillActive();

    WsbTraceOut( L"CQuickStartCheck::OnKillActive", L"" );
    return( retval );}

BOOL CQuickStartCheck::OnInitDialog() 
{
    WsbTraceIn( L"CQuickStartCheck::OnInitDialog", L"" );

    CSakWizardPage::OnInitDialog();

    GetDlgItem( IDC_CHECK_LOGON_BOX      )->SetFont( GetWingDingFont( ) );
    GetDlgItem( IDC_CHECK_SUPP_MEDIA_BOX )->SetFont( GetWingDingFont( ) );

    m_CheckString = GetWingDingCheckChar( );
    m_ExString    = GetWingDingExChar( );

    WsbTraceOut( L"CQuickStartCheck::OnInitDialog", L"" );
    return TRUE;
}

void CQuickStartCheck::StartTimer( )
{
    WsbTraceIn( L"CQuickStartCheck::StartTimer", L"" );

    if( !m_TimerStarted ) {

        m_TimerStarted = TRUE;
        SetTimer( CHECK_SYSTEM_TIMER_ID, CHECK_SYSTEM_TIMER_MS, 0 );

    }

    WsbTraceOut( L"CQuickStartCheck::StartTimer", L"" );
}

void CQuickStartCheck::StopTimer( )
{
    WsbTraceIn( L"CQuickStartCheck::StopTimer", L"" );

    if( m_TimerStarted ) {

        m_TimerStarted = FALSE;
        KillTimer( CHECK_SYSTEM_TIMER_ID );

        if( CST_DONE != QSHEET->m_CheckSysState ) {

            TerminateThread( QSHEET->m_hCheckSysThread, 0 );

        }

    }

    WsbTraceOut( L"CQuickStartCheck::StopTimer", L"" );
}


void CQuickStartCheck::OnTimer(UINT nIDEvent) 
{
    WsbTraceIn( L"CQuickStartCheck::OnTimer", L"" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if( CHECK_SYSTEM_TIMER_ID == nIDEvent ) {

        HRESULT hr = S_OK;

        try {

            //
            // First update the checkmarks
            //

            HRESULT   hrThread = QSHEET->m_hrCheckSysResult;
            CST_STATE state = QSHEET->m_CheckSysState;

            SetDlgItemText( IDC_CHECK_LOGON_BOX, state > CST_ACCOUNT ? m_CheckString : L"" );
            SetDlgItemText( IDC_CHECK_SUPP_MEDIA_BOX, state > CST_SUPP_MEDIA ? m_CheckString : L"" );

            GetDlgItem( IDC_CHECK_LOGON_TEXT )->SetFont( CST_ACCOUNT == state ? GetBoldShellFont( ) : GetShellFont( ) );
            GetDlgItem( IDC_CHECK_SUPP_MEDIA_TEXT )->SetFont( CST_SUPP_MEDIA == state ? GetBoldShellFont( ) : GetShellFont( ) );

            switch( QSHEET->m_CheckSysState ) {

            case CST_ACCOUNT:
                if( hrThread == S_FALSE ) {
                    StopTimer( );
                    AfxMessageBox( IDS_ERR_NO_ADMIN_PRIV, RS_MB_ERROR );
                    m_pSheet->PressButton( PSBTN_CANCEL );
//                    m_pSheet->SetWizardButtons( PSWIZB_BACK );
                }
                break;

            case CST_SUPP_MEDIA:
                if( hrThread == S_FALSE ) {
                    StopTimer( );
                    AfxMessageBox( IDS_ERR_NO_SUPP_MEDIA, RS_MB_ERROR );
                    m_pSheet->PressButton( PSBTN_CANCEL );
//                    m_pSheet->SetWizardButtons( PSWIZB_BACK );
                }
                break;

            case CST_DONE:
                StopTimer( );
                m_pSheet->PressButton( PSBTN_NEXT );
                break;

            }

            if( FAILED( hrThread ) ) {
                StopTimer( );

                // Report any errors
                RsReportError( hrThread, IDS_ERROR_SYSTEM_CHECK ); 

                m_pSheet->PressButton( PSBTN_CANCEL );
//                m_pSheet->SetWizardButtons( PSWIZB_BACK );

            }

        } WsbCatch( hr );

    }
    
    CSakWizardPage::OnTimer(nIDEvent);

    WsbTraceOut( L"CQuickStartCheck::OnTimer", L"" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\device\ca.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Ca.cpp

Abstract:

    Cartridge Node Implementation.

Author:

    Rohde Wakefield   [rohde]   07-Aug-97

Revision History:

--*/



#include "stdafx.h"
#include "Ca.h"
#include "PrCar.h"

int CUiCar::m_nResultIcon      = AddResultImage( IDI_NODETAPE );
int CUiCar::m_nResultIconX     = AddResultImage( IDI_NODETAPEX );
int CUiCar::m_nResultIconD     = AddResultImage( IDI_NODETAPED );
// Not used
int CUiCar::m_nScopeCloseIcon  = AddScopeImage( IDI_NODETAPE );
int CUiCar::m_nScopeCloseIconX = AddScopeImage( IDI_NODETAPE );
int CUiCar::m_nScopeOpenIcon   = CUiCar::m_nScopeCloseIcon;
int CUiCar::m_nScopeOpenIconX  = CUiCar::m_nScopeCloseIconX;

/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CUiCar::FinalConstruct( )
{
    WsbTraceIn( L"CUiCar::FinalConstruct", L"" );

    m_rTypeGuid    = &cGuidCar;
    m_bIsContainer = FALSE;

    HRESULT hr = CSakNode::FinalConstruct( );

    m_bSupportsPropertiesSingle    = TRUE;
    m_bSupportsPropertiesMulti = TRUE;
    m_bSupportsDeleteSingle = FALSE;
    m_bSupportsDeleteMulti = FALSE;
    m_bSupportsRefreshSingle = TRUE;
    m_bSupportsRefreshMulti = FALSE;

    // Toolbar values
    INT i = 0;

#if 0 // MS does not want this button to show
    m_ToolbarButtons[i].nBitmap = 0;
    m_ToolbarButtons[i].idCommand = TB_CMD_CAR_COPIES;
    m_ToolbarButtons[i].idButtonText = IDS_TB_TEXT_CAR_COPIES;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_CAR_COPIES;
    i++;
#endif

    m_ToolbarBitmap             = IDB_TOOLBAR_CAR;
    m_cToolbarButtons           = i;

    WsbTraceOut( L"CUiCar::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CUiCar::FinalRelease( )
{
    WsbTraceIn( L"CUiCar::FinalRelease", L"" );

    CSakNode::FinalRelease( );

    WsbTraceOut( L"CUiCar::FinalRelease", L"" );
}

/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         GetContextMenu
//
//  Return an HMENU to be used for context menus on this node.
//

STDMETHODIMP 
CUiCar::GetContextMenu( BOOL /*bMultiSelect*/, HMENU* phMenu )
{
    return( LoadContextMenu( IDR_CAR, phMenu ) );
}


//---------------------------------------------------------------------------
//
//         InvokeCommand
//
//  User has selected a command from the menu. Process it here.
//

STDMETHODIMP 
CUiCar::InvokeCommand( SHORT sCmd, IDataObject* pDataObject )
{
    WsbTraceIn( L"CUiCar::InvokeCommand", L"sCmd = <%d>", sCmd );

    CString theString;
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch (sCmd) {
    case ID_CAR_COPIES:
        ShowCarProperties( pDataObject, 1 );
        break;
    }

#if 0
    switch (sCmd) {
        case ID_CAR_ROOT_DELCARTRIDGE:
            theString.Format (L"Del Cartridge menu command for Car: %d", sCmd);
            AfxMessageBox(theString);
            break;
        
        default:
            theString.Format (L"Unknown menu command for Car: %d", sCmd);
            AfxMessageBox(theString);
            break;
    }
#endif

    WsbTraceOut( L"CUiCar::InvokeCommand", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiCar::OnToolbarButtonClick( IDataObject *pDataObject, long cmdId )
{
    WsbTraceIn( L"CUiCar::OnToolbarButtonClick", L"cmdId = <%d>", cmdId );
    HRESULT hr = S_OK;
    try {
        switch ( cmdId ) {
        case TB_CMD_CAR_COPIES:
            ShowCarProperties( pDataObject, 1 );
            break;
        }
    } WsbCatch( hr );
    WsbTraceOut( L"CUiCar::OnToolbarButtonClick", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiCar::ShowCarProperties (IDataObject *pDataObject, int initialPage)
{
    WsbTraceIn( L"CUiCar::ShowCarProperties", L"initialPage = <%d>", initialPage );

    HRESULT hr = S_OK;
    try {

        CComPtr<ISakNode> pSakNode;
        WsbAffirmHr( _InternalQueryInterface( IID_ISakNode, (void **) &pSakNode ) );
        WsbAffirmHr( m_pSakSnapAsk->ShowPropertySheet( pSakNode, pDataObject, initialPage ) );

    } WsbCatch (hr);

    WsbTraceOut( L"CUiCar::ShowCarProperties", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

//---------------------------------------------------------------------------
//
//         InitNode
//
//  Initialize single COM object.
//

STDMETHODIMP
CUiCar::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CUiCar::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );
    HRESULT hr = S_OK;

    try {

        // Note that this node must have it's objectId set before initnode is called.
        //
        // Init the lower layers. 
        //

        WsbAffirmHr( CSakNode::InitNode( pSakSnapAsk, 0, pParent ) );

        //
        // Set Display Type
        //
        CString tempString;
        tempString.LoadString( IDS_CAR_TYPE );
        WsbAffirmHr( put_Type( (OLECHAR *)(LPCWSTR)tempString ) );

        WsbAffirmHr( RefreshObject() );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCar::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP CUiCar::RefreshObject()
{
    WsbTraceIn( L"CUiCar::RefreshObject", L"" );
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CMediaInfoObject mio;
    try {

        CComPtr<IHsmServer> pHsmServer;
        WsbAffirmHrOk( m_pSakSnapAsk->GetHsmServer( &pHsmServer ) );

        CComPtr<IRmsServer> pRmsServer;
        WsbAffirmHrOk( m_pSakSnapAsk->GetRmsServer( &pRmsServer ) );

        //
        // Create a GUI media object and initialize it with the info
        //
        WsbAffirmHr( mio.Initialize( m_ObjectId, pHsmServer, pRmsServer ) );

        //
        // Copy information from the media info object to the node object
        //
        m_RmsIdMaster           = mio.m_RmsIdMaster;
        m_Type                  = mio.m_Type;
        m_FreeSpace             = mio.m_FreeSpace,
        m_Capacity              = mio.m_Capacity;
        m_LastHr                = mio.m_LastHr;
        m_ReadOnly              = mio.m_ReadOnly;
        m_Recreating            = mio.m_Recreating;
        m_MasterName            = mio.m_MasterName;
        m_Modify                = mio.m_Modify;
        m_NextDataSet           = mio.m_NextDataSet;
        m_LastGoodNextDataSet   = mio.m_LastGoodNextDataSet;
        m_Disabled              = mio.m_Disabled;

        WsbAffirmHr( put_Description( (LPWSTR)(LPCWSTR)mio.m_MasterDescription ) );
        WsbAffirmHr( put_DisplayName( (LPWSTR)(LPCWSTR)mio.m_Description ) );

        //
        // Update the media copy info
        //
        for( int i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {

            m_CopyInfo[i] = mio.m_CopyInfo[i];

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCar::RefreshObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}




HRESULT
CUiCar::GetCopySetP(
    IN  int CopySet,
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the state of the
    given copy set.

Arguments:

    CopySet - copy set of interest.

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CUiCar::GetCopySetP", L"CopySet = <%d>, pszValue = <0x%p>", CopySet, pszValue );

    //
    // Three states - Up-to-date, Out-of-date, Error
    //

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    
    try {
        
        USHORT status;
        CString statusString;

        status = RsGetCopyStatus( m_CopyInfo[ CopySet - 1 ].m_RmsId, m_CopyInfo[ CopySet - 1 ].m_Hr, m_CopyInfo[ CopySet - 1 ].m_NextDataSet, m_LastGoodNextDataSet );
        WsbAffirmHr( RsGetCopyStatusString( status, statusString ) );

        *pszValue = SysAllocString( statusString );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCar::GetCopySetP", L"hr = <%ls>, pszValue = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pszValue ) );
    return( hr );
}


STDMETHODIMP
CUiCar::get_CopySet1P_SortKey(
    OUT BSTR * pszValue
    )
{
    return( get_CopySet1P( pszValue ) );
}

STDMETHODIMP
CUiCar::get_CopySet2P_SortKey(
    OUT BSTR * pszValue
    )
{
    return( get_CopySet2P( pszValue ) );
}

STDMETHODIMP
CUiCar::get_CopySet3P_SortKey(
    OUT BSTR * pszValue
    )
{
    return( get_CopySet3P( pszValue ) );
}


STDMETHODIMP
CUiCar::get_CopySet1P(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the state of the
    first copy set.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    return( GetCopySetP( 1, pszValue ) );
}


STDMETHODIMP
CUiCar::get_CopySet2P(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the state of the
    second copy set.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    return( GetCopySetP( 2, pszValue ) );
}


STDMETHODIMP
CUiCar::get_CopySet3P(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the state of the
    third copy set.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    return( GetCopySetP( 3, pszValue ) );
}


STDMETHODIMP
CUiCar::get_MediaTypeP(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the type of media.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    
    try {
        
        CString retval;
        int resourceId = IDS_MEDTYPE_UNKNOWN;

        switch( m_Type ) {
        case HSM_JOB_MEDIA_TYPE_FIXED_MAG:
            resourceId = IDS_MEDTYPE_FIXED;
            break;

        case HSM_JOB_MEDIA_TYPE_REMOVABLE_MAG:
            resourceId = IDS_MEDTYPE_REMOVABLE;
            break;

        case HSM_JOB_MEDIA_TYPE_OPTICAL:
            resourceId = IDS_MEDTYPE_OPTICAL;
            break;

        case HSM_JOB_MEDIA_TYPE_TAPE:
            resourceId = IDS_MEDTYPE_TAPE;
            break;
        }

        retval.LoadString( resourceId );
        *pszValue = SysAllocString( retval );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP
CUiCar::get_CapacityP(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the capacity of 
    the cartridge.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    HRESULT hr = S_OK;
    
    try {
        
        CString retval;
        WsbAffirmHr( RsGuiFormatLongLong4Char( m_Capacity, retval ) );

        *pszValue = SysAllocString( retval );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP
CUiCar::get_CapacityP_SortKey(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the capacity of 
    the cartridge.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    HRESULT hr = S_OK;
    
    try {
        
        *pszValue = SysAlloc64BitSortKey( m_Capacity );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP
CUiCar::get_FreeSpaceP(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the free space on 
    the cartridge.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    HRESULT hr = S_OK;
    
    try {
        
        CString retval;
        WsbAffirmHr( RsGuiFormatLongLong4Char( m_FreeSpace, retval ) );

        *pszValue = SysAllocString( retval );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP
CUiCar::get_FreeSpaceP_SortKey(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the free space on 
    the cartridge.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    HRESULT hr = S_OK;
    
    try {
        
        *pszValue = SysAlloc64BitSortKey( m_FreeSpace );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP
CUiCar::get_StatusP(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the state of the media.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    
    try {
        USHORT status;
        CString statusString;
        status = RsGetCartStatus( m_LastHr, m_ReadOnly, m_Recreating, m_NextDataSet, m_LastGoodNextDataSet );
        WsbAffirmHr( RsGetCartStatusString( status, statusString ) );

        *pszValue = SysAllocString( statusString );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP
CUiCar::get_StatusP_SortKey(
    OUT BSTR * pszValue
    )
{
    return( get_StatusP( pszValue ) );
}

//----------------------------------------------------------------------------
//
//      AddPropertyPages
//

STDMETHODIMP 
CUiCar::AddPropertyPages(
    IN  RS_NOTIFY_HANDLE handle,
    IN  IUnknown*        pUnkPropSheetCallback,
    IN  IEnumGUID*       pEnumObjectId, 
    IN  IEnumUnknown*    pEnumUnkNode
    )
{
    WsbTraceIn( L"CUiCar::AddPropertyPages", L"" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    try {

        //
        // Make sure we can still contact the engine before doing this
        // If not running, we shouldn't even exist so update parent
        //
        CComPtr<IHsmServer> pHsmServer;
        HRESULT hrRunning = m_pSakSnapAsk->GetHsmServer( &pHsmServer );
        if( S_FALSE == hrRunning ) {

            m_pSakSnapAsk->UpdateAllViews( m_pParent );

        }
        WsbAffirmHrOk( hrRunning );

        // Create an object to hold the pages
        CUiCarSheet *pCarPropertySheet = new CUiCarSheet;
        WsbAffirmAlloc( pCarPropertySheet );
        WsbAffirmHr( pCarPropertySheet->InitSheet( 
            handle, 
            pUnkPropSheetCallback, 
            (CSakNode *) this,
            m_pSakSnapAsk,
            pEnumObjectId,
            pEnumUnkNode
            ) );

        // Tell the object to add it's pages
        WsbAffirmHr( pCarPropertySheet->AddPropertyPages( ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CUiCar::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}

STDMETHODIMP
CUiCar::GetResultIcon(
    IN  BOOL bOK,
    OUT int* pIconIndex
    )
{
    WsbTraceIn( L"CUiCar::GetResultIcon", L"" ); 

    HRESULT hr = S_OK;

    try {

        if( m_Disabled ) {

            *pIconIndex = m_nResultIconD;

        } else {

            //
            // Check to make sure it's not deleted (or being deleted)
            // If so, put on the X
            //
            USHORT status;
            status = RsGetCartStatus( m_LastHr, m_ReadOnly, m_Recreating, m_NextDataSet, m_LastGoodNextDataSet );
            switch( status ) {
    
            case RS_MEDIA_STATUS_ERROR_MISSING:
                bOK = FALSE;
                break;

            }
            WsbAffirmHr( CSakNodeImpl<CUiCar>::GetResultIcon( bOK, pIconIndex ) );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCar::GetResultIcon", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//
// Class CUiCarSheet
//

HRESULT
CUiCarSheet::InitSheet(
            RS_NOTIFY_HANDLE handle, 
            IUnknown*        pUnkPropSheetCallback, 
            CSakNode*        pSakNode,
            ISakSnapAsk*     pSakSnapAsk,
            IEnumGUID*       pEnumObjectId,
            IEnumUnknown*    pEnumUnkNode
            ) 
{
    WsbTraceIn( L"CUiCarSheet::InitSheet", 
        L"handle <0x%p>, pUnkPropSheetCallback <0x%p>, pSakNode <0x%p>, pSakSnapAsk <0x%p>, pEnumObjectId <0x%p>, pEnumUnkNode <0x%p>",
        handle, pUnkPropSheetCallback, pSakNode, pSakSnapAsk, pEnumObjectId, pEnumUnkNode);

    HRESULT hr = S_OK;
    try {

        WsbAffirmHr( CSakPropertySheet::InitSheet( handle, pUnkPropSheetCallback, pSakNode, pSakSnapAsk, pEnumObjectId, pEnumUnkNode ) );

        m_pPropPageStatus = NULL;
        m_pPropPageCopies = NULL;
        m_pPropPageRecover = NULL;

        //
        // Save the object id (used in single select)
        //
        WsbAffirmHr( pSakNode->GetObjectId ( & m_mediaId ) );

        //
        // Get the Hsm Server
        //
        CComPtr <IHsmServer> pHsmServer;
        WsbAffirmHrOk( pSakSnapAsk->GetHsmServer( &pHsmServer ) );

        //
        // Get Number of Media Copies from engine and save
        //
        CComPtr<IHsmStoragePool> pPool;
        WsbAffirmHr( RsGetStoragePool( pHsmServer, &pPool ) );
        WsbAffirmHr( pPool->GetNumMediaCopies( &m_pNumMediaCopies ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCarSheet::InitSheet", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
    

HRESULT CUiCarSheet::GetNumMediaCopies (USHORT *pNumMediaCopies)
{
    WsbTraceIn( L"CUiCarSheet::GetNumMediaCopies", L"pNumMediaCopies = <0x%p>", pNumMediaCopies);
    *pNumMediaCopies = m_pNumMediaCopies;
    WsbTraceOut( L"CUiCarSheet::GetNumMediaCopies", L"*pNumMediaCopies = <%hu>", *pNumMediaCopies );
    return( S_OK );
}

HRESULT CUiCarSheet::AddPropertyPages()
{
    WsbTraceIn( L"CUiCarSheet::AddPropertyPages", L"");
    HRESULT hr = S_OK;
    try {
        // set the dll context so that MMC can find the resource.
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // --------------------- Status Page ----------------------------------
        long resourceId = ( IsMultiSelect() != S_OK ) ? IDD_PROP_CAR_STATUS : IDD_PROP_CAR_STATUS_MULTI;
        m_pPropPageStatus = new CPropCartStatus( resourceId );
        WsbAffirmAlloc( m_pPropPageStatus );

        WsbAffirmHr( AddPage( m_pPropPageStatus ) );

        // --------------------- Copies Page ----------------------------------
        resourceId = ( IsMultiSelect() != S_OK ) ? IDD_PROP_CAR_COPIES : IDD_PROP_CAR_COPIES_MULTI;
        m_pPropPageCopies = new CPropCartCopies( resourceId );
        WsbAffirmAlloc( m_pPropPageCopies );

        WsbAffirmHr( AddPage( m_pPropPageCopies ) );

        // --------------------- Recovery Page ----------------------------------

        // Only show this page for single select

        if( IsMultiSelect() != S_OK ) {

            m_pPropPageRecover = new CPropCartRecover();
            WsbAffirmAlloc( m_pPropPageRecover );

            WsbAffirmHr( AddPage( m_pPropPageRecover ) );
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCarSheet::AddPropertyPages",  L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiCarSheet::GetMediaId (GUID *pMediaId)
{
    WsbTraceIn( L"CUiCarSheet::GetMediaId", L"");
    *pMediaId = m_mediaId;
    WsbTraceOut( L"CUiCarSheet::GetMediaId",  L"*pMediaId <%ls>", WsbGuidAsString( *pMediaId ));
    return S_OK;
}

HRESULT CUiCarSheet::OnPropertyChange( RS_NOTIFY_HANDLE hNotifyHandle )
{
    HRESULT hr = S_OK;
    try {

        //
        // Call the base class to notify MMC and refresh the result pane
        //
        CSakPropertySheet::OnPropertyChange( hNotifyHandle );

        // Refresh all our pages
        if( m_pPropPageStatus )  m_pPropPageStatus->Refresh();
        if( m_pPropPageCopies )  m_pPropPageCopies->Refresh();
        if( m_pPropPageRecover ) m_pPropPageRecover->Refresh();

    } WsbCatch( hr );

    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// CMediaInfoObject

CMediaInfoObject::CMediaInfoObject(  )
{
    WsbTraceIn( L"CMediaInfoObject::CMediaInfoObject", L"");
    m_MediaId        = GUID_NULL;
    m_RmsIdMaster    = GUID_NULL;
    m_NumMediaCopies = 0;
    for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

        m_CopyInfo[ index ].m_ModifyTime = WsbLLtoFT( 0 );
        m_CopyInfo[ index ].m_Hr = S_OK;
        m_CopyInfo[ index ].m_RmsId = GUID_NULL;

    }
    WsbTraceOut( L"CMediaInfoObject::CMediaInfoObject",  L"");
}

CMediaInfoObject::~CMediaInfoObject( )
{
    WsbTraceIn( L"CMediaInfoObject::~CMediaInfoObject", L"");

    // Release the entity first
    if( m_pMediaInfo ) {
        m_pMediaInfo = 0;
    }

    // Close the DB
    if( m_pDb ) {
        m_pDb->Close( m_pDbSession );
    }

    WsbTraceOut( L"CMediaInfoObject::~CMediaInfoObject",  L"");
}

HRESULT CMediaInfoObject::First( )
{
    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( m_pMediaInfo );
        WsbAffirmHr( m_pMediaInfo->First( ) );

        //
        // Get information
        //
        WsbAffirmHr( InternalGetInfo( ) );

    } WsbCatch ( hr );
    return( hr );
}

HRESULT CMediaInfoObject::Next( )
{
    HRESULT hr = S_OK;
    try {
        WsbAffirmPointer( m_pMediaInfo );
        WsbAffirmHr( m_pMediaInfo->Next() );

        // Get information
        WsbAffirmHr( InternalGetInfo() );

    } WsbCatch ( hr );
    return hr;
}
HRESULT CMediaInfoObject::DeleteCopy( int Copy )
{
    HRESULT hr = S_OK;
    try {
        GUID mediaSubsystemId;
        WsbAffirmHr( m_pMediaInfo->GetCopyMediaSubsystemId( (USHORT)Copy, &mediaSubsystemId ));

        // If the cartridge cannot be found we assume it
        // was already deallocated through the media manager UI.
        HRESULT hrRecycle = m_pRmsServer->RecycleCartridge( mediaSubsystemId, 0 );
        WsbAffirm( S_OK == hrRecycle || RMS_E_CARTRIDGE_NOT_FOUND == hrRecycle, hrRecycle );

        WsbAffirmHr( m_pMediaInfo->DeleteCopy( (USHORT)Copy ) );
        WsbAffirmHr( m_pMediaInfo->Write( ) );
    } WsbCatch (hr);
    return hr;
}

HRESULT CMediaInfoObject::RecreateMaster( )
{
    HRESULT hr = S_OK;
    try {

        SHORT copyToUse = 0;
        //
        // Before we do recreate master, let's make sure there
        // is an up-to-date copy available
        //
        BOOL goodCopyAvailable = FALSE;
        USHORT status;
        CComPtr<IRmsCartridge> pRmsCart;
        LONG type;

        for( int index = 0; index < m_NumMediaCopies && !goodCopyAvailable; index++ ) {

            status = RsGetCopyStatus( m_CopyInfo[ index ].m_RmsId, m_CopyInfo[ index ].m_Hr, m_CopyInfo[ index ].m_NextDataSet, m_LastGoodNextDataSet );

            if( RS_MEDIA_COPY_STATUS_INSYNC == status ) {

                //
                // Enabled?
                //
                if( ! m_CopyInfo[ index ].m_Disabled ) {

                    pRmsCart.Release( );
                    HRESULT hrFind = m_pRmsServer->FindCartridgeById( m_CopyInfo[ index ].m_RmsId, &pRmsCart );
                    if( SUCCEEDED( hrFind ) ) {

                        //
                        // Available without user intervention?
                        //
                        WsbAffirmHr( pRmsCart->GetLocation( &type, 0, 0, 0, 0, 0, 0, 0 ) );

                        switch( (RmsElement) type ) {

                        case RmsElementShelf:
                        case RmsElementOffSite:
                        case RmsElementUnknown:
                            break;

                        default:
                            goodCopyAvailable = TRUE;

                        }
                    }
                }
            }
        }

        if( !goodCopyAvailable ) {

            CRecreateChooseCopy dlg( this );
            if( IDOK == dlg.DoModal( ) ) {

                copyToUse = dlg.CopyToUse( );

            } else {

                //
                // Otherwise, cancel
                //
                WsbThrow( E_FAIL );

            }

        }

        WsbAffirmHr( RsCreateAndRunMediaRecreateJob( m_pHsmServer, m_pMediaInfo, m_MediaId, m_Description, copyToUse ) );

    } WsbCatch ( hr );
    return hr;
}


HRESULT CMediaInfoObject::Initialize( GUID mediaId, IHsmServer *pHsmServer, IRmsServer *pRmsServer )
{

//  Initialize can be called any number of times
//  Note: Initialize with GUID_NULL to start with the first record

    WsbTraceIn( L"CMediaInfoObject::Initialize", L"mediaId = <%ls>, pHsmServer = <0x%p>, pRmsServer = <%0x%0.8x>",
        WsbGuidAsString( mediaId ), pHsmServer, pRmsServer );
    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;

    try {

        m_pHsmServer = pHsmServer;
        m_pRmsServer = pRmsServer;

        // If already initialized, don't re-open
        if( !m_pDb ) {
            WsbAffirmHr( pHsmServer->GetSegmentDb( &m_pDb ) );
            WsbAffirmHr( m_pDb->Open( &m_pDbSession ) );
            WsbAffirmHr( m_pDb->GetEntity( m_pDbSession, HSM_MEDIA_INFO_REC_TYPE,  IID_IMediaInfo, (void**)&m_pMediaInfo ) );
        }

        // Get the number of media sets
        CComPtr<IHsmStoragePool> pPool;
        WsbAffirmHr( RsGetStoragePool( m_pHsmServer, &pPool ) );
        WsbAffirmHr( pPool->GetNumMediaCopies( &m_NumMediaCopies ) );

        // If the caller supplied a GUID, find the corresponding record.  If not, start at
        // the beginning.
        if( IsEqualGUID( mediaId, GUID_NULL ) ) {
            // Don't throw an error on First, it's OK to not have any media
            try {

                if( SUCCEEDED( m_pMediaInfo->First() ) ) {

                    WsbAffirmHr( InternalGetInfo () );
                }

            } WsbCatch( hrInternal );
            
        } else {

            WsbAffirmHr( m_pMediaInfo->SetId( mediaId ) );
            WsbAffirmHr( m_pMediaInfo->FindEQ( ) );

            WsbAffirmHr( InternalGetInfo () );
        }
    } WsbCatch( hr );

    WsbTraceOut( L"CMediaInfoObject::Initialize", L"hr = <%ls>", WsbHrAsString( hr ) );

    return( hr );
}

HRESULT CMediaInfoObject::InternalGetInfo( )
{
    HRESULT            hr = S_OK;
    CWsbStringPtr      name;
    CWsbStringPtr      description;
    LONGLONG           logicalValidBytes;
    GUID               storagePool;

    try {

        //
        // Get information about the last known good master so that we
        // have a true reference whether a copy is up-to-date or not,
        // and whether a recreated master is complete or not.
        //
        GUID        unusedGuid1;
        GUID        unusedGuid2; // NOTE: Use multiples so the trace in GetLastKnownGoodMasterInfo works
        GUID        unusedGuid3; // NOTE: Use multiples so the trace in GetLastKnownGoodMasterInfo works
        LONGLONG    unusedLL1;
        LONGLONG    unusedLL2;   // NOTE: Use multiples so the trace in GetLastKnownGoodMasterInfo works
        BOOL        unusedBool;
        HRESULT     unusedHr;
        FILETIME    unusedFt;
        HSM_JOB_MEDIA_TYPE unusedJMT;

        m_Disabled = FALSE;

        WsbAffirmHr( m_pMediaInfo->GetLastKnownGoodMasterInfo(
            &unusedGuid1, &unusedGuid2, &unusedGuid3, &unusedLL1, &unusedLL2,
            &unusedHr, &description, 0, &unusedJMT, &name, 0, &unusedBool, &unusedFt,
            &m_LastGoodNextDataSet ) );
        name.Free( );
        description.Free( );

        //
        // Get the standard media info
        //
        WsbAffirmHr( m_pMediaInfo->GetMediaInfo( 
            &m_MediaId,        &m_RmsIdMaster,      &storagePool,
            &m_FreeSpace,      &m_Capacity,         &m_LastHr,
            &m_NextDataSet,    &description, 0,     &m_Type,
            &name, 0,          &m_ReadOnly,         &m_Modify,
            &logicalValidBytes, &m_Recreating ) );

        m_Name        = name;
        m_Description = description;

        //
        // Get info about the copy sets. Note that we grab all
        // info, not just up to the number of copys set by user
        //
        USHORT index;
        USHORT status;
        for( index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

            description.Free( );
            name.Free( );

            m_CopyInfo[index].m_Disabled = FALSE;

            //
            // copy sets are 1 based.
            //
            WsbAffirmHr( m_pMediaInfo->GetCopyInfo( (USHORT)( index + 1 ),
                &(m_CopyInfo[index].m_RmsId), &description, 0, &name, 0,
                &(m_CopyInfo[index].m_ModifyTime),
                &(m_CopyInfo[index].m_Hr),
                &(m_CopyInfo[index].m_NextDataSet) ) );


            status = RsGetCopyStatus( m_CopyInfo[ index ].m_RmsId, m_CopyInfo[ index ].m_Hr, m_CopyInfo[ index ].m_NextDataSet, m_LastGoodNextDataSet );

            if ( status != RS_MEDIA_COPY_STATUS_NONE ) {

                if( m_pRmsServer ) {

                    //
                    // Make sure the cartridge is still available.
                    //
                    CComPtr<IRmsCartridge> pRmsCart;
                    HRESULT hrFind = m_pRmsServer->FindCartridgeById( m_CopyInfo[index].m_RmsId, &pRmsCart );
                    if( FAILED( hrFind ) ) {

                        //
                        // Didn't find cartridge, may have been deallocated
                        // Show that there is a problem and use what info we have
                        //
                        m_CopyInfo[index].m_Hr = hrFind;

                    } else {

                        //
                        // Is Cartridge disabled?
                        //
                        CComPtr<IRmsComObject> pCartCom;
                        WsbAffirmHr( pRmsCart.QueryInterface( &pCartCom ) );
                        if( pCartCom->IsEnabled( ) == S_FALSE ) {

                            m_CopyInfo[index].m_Disabled = TRUE;

                        }
                    }
                }
            }
        }

        if( m_pRmsServer ) {

            //
            // Get the corresponding RmsCartridge object
            //
            CComPtr<IRmsCartridge> pRmsCart;
            HRESULT hrFind = m_pRmsServer->FindCartridgeById( m_RmsIdMaster, &pRmsCart );

            if( SUCCEEDED( hrFind ) ) {


                //
                // Is Cartridge disabled?
                //
                CComPtr<IRmsComObject> pCartCom;
                WsbAffirmHr( pRmsCart.QueryInterface( &pCartCom ) );
                if( pCartCom->IsEnabled( ) == S_FALSE ) {

                    m_Disabled = TRUE;

                }

                //
                // Fill out internal info
                //
                CWsbBstrPtr bstr;
                WsbAffirmHr( pRmsCart->GetName( &bstr ) );
                if( wcscmp( bstr, L"" ) == 0 ) {

                    m_MasterName.Format( IDS_CAR_NAME_UNKNOWN );

                } else {

                    m_MasterName = bstr;

                }

                bstr.Free( );
                WsbAffirmHr( pRmsCart->GetDescription( &bstr ) );
                m_MasterDescription = bstr;

            } else {

                //
                // Didn't find cartridge, may have been deallocated
                // Show that there is a problem and use what info we have
                //
                m_LastHr = hrFind;

            }
        }

    } WsbCatch( hr );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// CRecreateChooseCopy dialog


CRecreateChooseCopy::CRecreateChooseCopy(CMediaInfoObject * pMio, CWnd* pParent /*=NULL*/)
    : CDialog(CRecreateChooseCopy::IDD, pParent), m_pMio( pMio ), m_CopyToUse( 0 )
{
    //{{AFX_DATA_INIT(CRecreateChooseCopy)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CRecreateChooseCopy::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRecreateChooseCopy)
    DDX_Control(pDX, IDC_RECREATE_COPY_LIST, m_List);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRecreateChooseCopy, CDialog)
    //{{AFX_MSG_MAP(CRecreateChooseCopy)
    ON_NOTIFY(NM_CLICK, IDC_RECREATE_COPY_LIST, OnClickList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRecreateChooseCopy message handlers
SHORT CRecreateChooseCopy::CopyToUse( void )
{
    WsbTraceIn( L"CRecreateChooseCopy::CopyToUse", L"" );

    SHORT copyToUse = m_CopyToUse;

    WsbTraceOut( L"CRecreateChooseCopy::CopyToUse", L"copyToUse = <%hd>", copyToUse );
    return( copyToUse );
}

void CRecreateChooseCopy::OnClickList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    WsbTraceIn( L"CRecreateChooseCopy::OnClickList", L"" );

    NMLISTVIEW *pNMLV = (NMLISTVIEW*)pNMHDR;    

    int index = pNMLV->iItem;
    BOOL enableOk = FALSE;

    if( ( index >= 0 ) && ( index < m_pMio->m_NumMediaCopies ) ) {

        if( ! m_pMio->m_CopyInfo[ index ].m_Disabled ) {

            USHORT status;
            status = RsGetCopyStatus( m_pMio->m_CopyInfo[ index ].m_RmsId, m_pMio->m_CopyInfo[ index ].m_Hr, m_pMio->m_CopyInfo[ index ].m_NextDataSet, m_pMio->m_LastGoodNextDataSet );

            switch( status ) {

            case RS_MEDIA_COPY_STATUS_NONE:
            case RS_MEDIA_COPY_STATUS_MISSING:

                //
                // Do not allow
                //
                break;


            case RS_MEDIA_COPY_STATUS_OUTSYNC:
            case RS_MEDIA_COPY_STATUS_INSYNC:
            case RS_MEDIA_COPY_STATUS_ERROR:

                enableOk = TRUE;
                m_CopyToUse = (USHORT)( index + 1 );
                break;

            }
        }
    }

    GetDlgItem( IDOK )->EnableWindow( enableOk );

    *pResult = 0;
    WsbTraceOut( L"CRecreateChooseCopy::OnClickList", L"" );
}

BOOL CRecreateChooseCopy::OnInitDialog() 
{
    WsbTraceIn( L"CRecreateChooseCopy::OnInitDialog", L"" );
    HRESULT hr = S_OK;

    try {

        CDialog::OnInitDialog();

        //
        // Disable the OK button until something appropriate is selected
        //
        GetDlgItem( IDOK )->EnableWindow( FALSE );

        //
        // Set the style appropriately
        //
        ListView_SetExtendedListViewStyle( m_List.GetSafeHwnd( ), LVS_EX_FULLROWSELECT );

        //
        // Also need to calculate some buffer space
        // Use 8 dialog units (for numeral)
        //
        CRect padRect( 0, 0, 8, 8 );
        MapDialogRect( padRect );

        //
        // Set up columns
        //
        CString title;
        int column = 0;
        int width, widthDateTitle, widthSum = 0;

        m_ColCopy = column++;
        title.LoadString( IDS_RECREATE_COL_COPY_WIDTH );
        width = m_List.GetStringWidth( title ) + padRect.Width( );
        widthSum += width;
        title.LoadString( IDS_RECREATE_COL_COPY_TITLE );
        m_List.InsertColumn( m_ColCopy, title, LVCFMT_LEFT, width );

        m_ColName = column++;
        title.LoadString( IDS_RECREATE_COL_NAME_WIDTH );
        width = m_List.GetStringWidth( title ) + padRect.Width( );
        widthSum += width;
        title.LoadString( IDS_RECREATE_COL_NAME_TITLE );
        m_List.InsertColumn( m_ColName, title, LVCFMT_LEFT, width );

        m_ColStatus = column++;
        title.LoadString( IDS_RECREATE_COL_STATUS_WIDTH );
        width = m_List.GetStringWidth( title ) + padRect.Width( );
        widthSum += width;
        title.LoadString( IDS_RECREATE_COL_STATUS_TITLE );
        m_List.InsertColumn( m_ColStatus, title, LVCFMT_LEFT, width );

        m_ColDate = column++;
        title.LoadString( IDS_RECREATE_COL_DATE_TITLE );
        m_List.InsertColumn( m_ColDate, title );
        widthDateTitle = m_List.GetStringWidth( title );

        //
        // Date gets what is left in width
        //
        CRect viewRect;
        m_List.GetClientRect( &viewRect );
        m_List.SetColumnWidth( m_ColDate, max( widthDateTitle, viewRect.Width( ) - widthSum ) );

        //
        // Fill in list view
        //
        CComPtr<IRmsCartridge> pRmsCart;
        CWsbBstrPtr name;
        USHORT status;
        CString statusString1, statusString2;
        LONG type;
        for( int index = 0; index < m_pMio->m_NumMediaCopies; index++ ) {

            title.Format( IDS_RECREATE_COPY_FORMAT, index + 1 );
            m_List.InsertItem( index, title );

            status = RsGetCopyStatus(
                m_pMio->m_CopyInfo[ index ].m_RmsId,
                m_pMio->m_CopyInfo[ index ].m_Hr,
                m_pMio->m_CopyInfo[ index ].m_NextDataSet,
                m_pMio->m_LastGoodNextDataSet );
            WsbAffirmHr( RsGetCopyStatusString( status, statusString1 ) );

            if( RS_MEDIA_COPY_STATUS_NONE == status ) {

                title = statusString1;

            } else {

                type = RmsElementUnknown;
                pRmsCart.Release( );
                HRESULT hrFind = m_pMio->m_pRmsServer->FindCartridgeById( m_pMio->m_CopyInfo[ index ].m_RmsId, &pRmsCart );

                if( SUCCEEDED( hrFind ) ) {

                    name.Free( );
                    WsbAffirmHr( pRmsCart->GetName( &name ) );
                    m_List.SetItemText( index, m_ColName, name );

                    WsbAffirmHr( pRmsCart->GetLocation( &type, 0, 0, 0, 0, 0, 0, 0 ) );

                }

                if( m_pMio->m_CopyInfo[ index ].m_Disabled ) {

                    statusString2.LoadString( IDS_RECREATE_LOCATION_DISABLED );

                } else {

                    switch( (RmsElement) type ) {

                    case RmsElementShelf:
                    case RmsElementOffSite:
                        statusString2.LoadString( IDS_RECREATE_LOCATION_OFFLINE );
                        break;

                    case RmsElementUnknown:
                        statusString2.LoadString( IDS_RECREATE_LOCATION_UNKNOWN );
                        break;

                    default:
                        statusString2.LoadString( IDS_RECREATE_LOCATION_ONLINE );

                    }

                }

                AfxFormatString2( title, IDS_RECREATE_STATUS_FORMAT, statusString1, statusString2 );

                CTime time( m_pMio->m_CopyInfo[ index ].m_ModifyTime );
                m_List.SetItemText( index, m_ColDate, time.Format( L"%c" ) );

            }
            m_List.SetItemText( index, m_ColStatus, title );

        }

    } WsbCatch( hr );
    
    WsbTraceOut( L"CRecreateChooseCopy::OnInitDialog", L"" );
    return TRUE;
}

void CRecreateChooseCopy::OnOK() 
{
    //
    // Before passing on the OK, check to see if the selected copy is
    // cause for one last warning before continuing i.e. out-of-date or
    // errored copy
    //
    BOOL okToContinue = FALSE;
    int index = m_CopyToUse - 1;

    if( ( index >= 0 ) && ( index < m_pMio->m_NumMediaCopies ) ) {

        if( ! m_pMio->m_CopyInfo[ index ].m_Disabled ) {

            USHORT status;
            status = RsGetCopyStatus( m_pMio->m_CopyInfo[ index ].m_RmsId, m_pMio->m_CopyInfo[ index ].m_Hr, m_pMio->m_CopyInfo[ index ].m_NextDataSet, m_pMio->m_LastGoodNextDataSet );

            switch( status ) {

            case RS_MEDIA_COPY_STATUS_NONE:
            case RS_MEDIA_COPY_STATUS_MISSING:

                //
                // Do not allow
                //
                break;


            case RS_MEDIA_COPY_STATUS_INSYNC:

                okToContinue = TRUE;
                break;


            case RS_MEDIA_COPY_STATUS_OUTSYNC:
            case RS_MEDIA_COPY_STATUS_ERROR:
                {

                    CString confirm, format;
                    format.LoadString( IDS_CONFIRM_MEDIA_RECREATE );
                    LPCWSTR description = m_pMio->m_Description;
                    AfxFormatStrings( confirm, format, &description, 1 );

                    if( IDYES == AfxMessageBox( confirm, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 ) ) {

                        okToContinue = TRUE;

                    }
                }
                break;

            }
        }
    }

    if( okToContinue ) {

        CDialog::OnOK();

    }
}

HRESULT CMediaInfoObject::DoesMasterExist( )
{
    return( 
        ( GUID_NULL != m_MediaId ) && 
        ( RMS_E_CARTRIDGE_NOT_FOUND != m_LastHr ) ? S_OK : S_FALSE );
}
HRESULT CMediaInfoObject::DoesCopyExist(INT Copy)
{
    return( 
        ( GUID_NULL != m_CopyInfo[Copy].m_RmsId ) && 
        ( RMS_E_CARTRIDGE_NOT_FOUND != m_CopyInfo[Copy].m_Hr ) ? S_OK : S_FALSE );
}

HRESULT CMediaInfoObject::IsCopyInSync(INT Copy)
{
    if( RS_MEDIA_COPY_STATUS_INSYNC ==
        RsGetCopyStatus(
            m_CopyInfo[Copy].m_RmsId,
            S_OK, // ignore errors in copy
            m_CopyInfo[Copy].m_NextDataSet,
            m_LastGoodNextDataSet ) ) {

        return S_OK;

    }

    return( S_FALSE );
}

HRESULT CMediaInfoObject::IsViewable( BOOL ConsiderInactiveCopies )
{
    HRESULT hr = S_FALSE;

    if( S_OK == DoesMasterExist( ) ) {

        hr = S_OK;

    } else {

        //
        // Look to see if any of the copies exist
        //
        INT lastCopy = ConsiderInactiveCopies ? HSMADMIN_MAX_COPY_SETS : m_NumMediaCopies;

        for( INT index = 0; index < lastCopy; index++ ) {

            if( S_OK == DoesCopyExist( index ) ) {

                hr = S_OK;
                break;

            }
        }
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\computer\wzqstart.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WzQStart.h

Abstract:

    Setup Wizard implementation.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _WZQSTART_H
#define _WZQSTART_H

#pragma once

#include <mstask.h>
#include "SakVlLs.h"

class CQuickStartWizard;

/////////////////////////////////////////////////////////////////////////////
// CQuickStartIntro dialog

class CQuickStartIntro : public CSakWizardPage
{
// Construction
public:
    CQuickStartIntro();
    ~CQuickStartIntro();
    virtual LRESULT OnWizardNext();

public:
// Dialog Data
    //{{AFX_DATA(CQuickStartIntro)
    enum { IDD = IDD_WIZ_QSTART_INTRO };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartIntro)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartIntro)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    enum LAD_STATE {

        LAD_ENABLED,
        LAD_DISABLED,
        LAD_UNSET
    };

    HRESULT IsDriverRunning();
    HRESULT CheckLastAccessDateState( LAD_STATE* );

};

/////////////////////////////////////////////////////////////////////////////
// CQuickStartCheck dialog

class CQuickStartCheck : public CSakWizardPage
{
// Construction
public:
    CQuickStartCheck();
    ~CQuickStartCheck();

// Dialog Data
    //{{AFX_DATA(CQuickStartCheck)
    enum { IDD = IDD_WIZ_QSTART_CHECK };
    //}}AFX_DATA



// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartCheck)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    CString m_ExString, m_CheckString;

    BOOL      m_TimerStarted;

    void StartTimer( );
    void StopTimer( );

protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartCheck)
    virtual BOOL OnInitDialog();
    afx_msg void OnTimer(UINT nIDEvent);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CQuickStartFinish dialog

class CQuickStartFinish : public CSakWizardPage
{
// Construction
public:
    CQuickStartFinish();
    ~CQuickStartFinish();

// Dialog Data
    //{{AFX_DATA(CQuickStartFinish)
    enum { IDD = IDD_WIZ_QSTART_FINISH };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartFinish)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartFinish)
    virtual BOOL OnInitDialog();
    afx_msg void OnSetFocusFinalText();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CQuickStartInitialValues dialog

class CQuickStartInitialValues : public CSakWizardPage
{
// Construction
public:
    CQuickStartInitialValues();
    ~CQuickStartInitialValues();

// Dialog Data
    //{{AFX_DATA(CQuickStartInitialValues)
    enum { IDD = IDD_WIZ_QSTART_INITIAL_VAL };
    CEdit   m_MinSizeEdit;
    CEdit   m_FreeSpaceEdit;
    CEdit   m_AccessEdit;
    CSpinButtonCtrl m_MinSizeSpinner;
    CSpinButtonCtrl m_FreeSpaceSpinner;
    CSpinButtonCtrl m_AccessSpinner;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartInitialValues)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartInitialValues)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageRes dialog

class CQuickStartManageRes : public CSakWizardPage
{
// Construction
public:
    CQuickStartManageRes();
    ~CQuickStartManageRes();

// Dialog Data
    //{{AFX_DATA(CQuickStartManageRes)
    enum { IDD = IDD_WIZ_QSTART_MANRES_SEL };
    CSakVolList   m_ListBox;
    CButton m_RadioSelect;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartManageRes)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    void SetButtons( );

protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartManageRes)
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();
    afx_msg void OnDblclkSelect();
    afx_msg void OnRadioQsManageAll();
    afx_msg void OnQsRadioSelect();
    afx_msg void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    BOOL m_ListBoxSelected[HSMADMIN_MAX_VOLUMES];

};

/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageRes dialog

class CQuickStartManageResX : public CSakWizardPage
{
// Construction
public:
    CQuickStartManageResX();
    ~CQuickStartManageResX();

// Dialog Data
    //{{AFX_DATA(CQuickStartManageResX)
    enum { IDD = IDD_WIZ_QSTART_MANRES_SELX };
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartManageResX)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartManageResX)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CQuickStartMediaSel dialog

class CQuickStartMediaSel : public CSakWizardPage
{
// Construction
public:
    CQuickStartMediaSel();
    ~CQuickStartMediaSel();

// Dialog Data
    //{{AFX_DATA(CQuickStartMediaSel)
    enum { IDD = IDD_WIZ_QSTART_MEDIA_SEL };
    CComboBox    m_ListMediaSel;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartMediaSel)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartMediaSel)
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();
    afx_msg void OnSelchangeMediaSel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    void SetButtons( );
};


/////////////////////////////////////////////////////////////////////////////
// CQuickStartSchedule dialog

class CQuickStartSchedule : public CSakWizardPage
{
// Construction
public:
    CQuickStartSchedule();
    ~CQuickStartSchedule();

// Dialog Data
    //{{AFX_DATA(CQuickStartSchedule)
    enum { IDD = IDD_WIZ_QSTART_SCHEDULE };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartSchedule)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    HRESULT UpdateDescription( );

protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartSchedule)
    afx_msg void OnChangeSchedule();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CQuickStartWizard

// Enumeration of states of checking system worker thread
enum CST_STATE {

    CST_NOT_STARTED,
    CST_ACCOUNT,
    CST_NTMS_INSTALL,
    CST_SUPP_MEDIA,
    CST_DONE,

};

class CQuickStartWizard : public CSakWizardSheet
{
// Construction
public:
    CQuickStartWizard( );

// Attributes
public:
    CQuickStartIntro          m_IntroPage;
    CQuickStartCheck          m_CheckPage;
    CQuickStartManageRes      m_ManageRes;
    CQuickStartManageResX     m_ManageResX;
    CQuickStartInitialValues  m_InitialValues;
    CQuickStartSchedule       m_SchedulePage;
    CQuickStartMediaSel       m_MediaSel;
    CQuickStartFinish         m_FinishPage;



// Operations
public:

// Implementation
public:
    virtual ~CQuickStartWizard();

public:
///////////////////////////////
// Used across multiple pages:
    CWsbStringPtr       m_ComputerName;

    HRESULT GetHsmServer( CComPtr<IHsmServer> &pServ );
    HRESULT GetFsaServer( CComPtr<IFsaServer> &pServ );
    HRESULT GetRmsServer( CComPtr<IRmsServer> &pServ );

    HRESULT ReleaseServers( void );

    virtual HRESULT OnCancel( void );
    virtual HRESULT OnFinish( void );

    STDMETHOD( AddWizardPages ) ( IN RS_PCREATE_HANDLE Handle, IN IUnknown* pPropSheetCallback, IN ISakSnapAsk* pSakSnapAsk );
    HRESULT InitTask( void );


    CComPtr<ISchedulingAgent> m_pSchedAgent;
    CComPtr<ITask>            m_pTask;
    CComPtr<ITaskTrigger>     m_pTrigger;

    CWsbStringPtr m_HsmServiceName;
    CWsbStringPtr m_FsaServiceName;
    CWsbStringPtr m_RmsServiceName;

    HANDLE    m_hCheckSysThread;
    CST_STATE m_CheckSysState;
    HRESULT   m_hrCheckSysResult;

    static DWORD WINAPI CheckSysThreadStart( LPVOID pv );

private:
    CComPtr<IHsmServer> m_pHsmServer;
    CComPtr<IFsaServer> m_pFsaServer;
    CComPtr<IRmsServer> m_pRmsServer;

};



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\device\mese.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MeSe.cpp

Abstract:

    Node representing our Media Set (Media Pool) within NTMS.

Author:

    Rohde Wakefield [rohde]   04-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "MeSe.h"
#include "WzMedSet.h"
#include "ca.h"



int CUiMedSet::m_nScopeCloseIcon  = AddScopeImage( IDI_NODELIB );
int CUiMedSet::m_nScopeCloseIconX = AddScopeImage( IDI_NODELIBX );
int CUiMedSet::m_nScopeOpenIcon   = AddScopeImage( IDI_NODEOPENFOLDER );
int CUiMedSet::m_nScopeOpenIconX  = CUiMedSet::m_nScopeCloseIconX;
int CUiMedSet::m_nResultIcon      = AddResultImage( IDI_NODELIB );
int CUiMedSet::m_nResultIconX     = AddResultImage( IDI_NODELIBX );


/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CUiMedSet::FinalConstruct( )
{
    WsbTraceIn( L"CUiMedSet::FinalConstruct", L"" );

    m_rTypeGuid    = &cGuidMedSet;
    m_NumCopySets  = 0;

    HRESULT hr = CSakNode::FinalConstruct( );

    m_bSupportsPropertiesSingle = FALSE;
    m_bSupportsPropertiesMulti  = FALSE;
    m_bSupportsDeleteSingle     = FALSE;
    m_bSupportsDeleteMulti      = FALSE;
    m_bSupportsRefreshSingle    = TRUE;
    m_bSupportsRefreshMulti     = FALSE;
    m_bIsContainer              = TRUE;
    m_bHasDynamicChildren       = TRUE;


    // Toolbar values
    INT i = 0;

    m_ToolbarButtons[i].nBitmap = 0;
    m_ToolbarButtons[i].idCommand =     TB_CMD_MESE_COPY;
    m_ToolbarButtons[i].idButtonText =  IDS_TB_TEXT_MESE_COPY;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_MESE_COPY;
    i++;

    m_ToolbarBitmap             = IDB_TOOLBAR_MESE;
    m_cToolbarButtons           = i;

    WsbTraceOut( L"CUiMedSet::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CUiMedSet::FinalRelease( )
{
    WsbTraceIn( L"CUiMedSet::FinalRelease", L"" );

//  if( m_pDbSession ) {
//
//      m_pDb->Close( m_pDbSession );
//
//  }

    CSakNode::FinalRelease( );

    WsbTraceOut( L"CUiMedSet::FinalRelease", L"" );
}


/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         GetContextMenu
//
//  Return an HMENU to be used for context menus on this node.
//

STDMETHODIMP 
CUiMedSet::GetContextMenu( BOOL bMultiSelect, HMENU* phMenu )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    try {

        CMenu* pRootMenu;
        LoadContextMenu( IDR_MEDSET, phMenu );
        CMenu menu;
        menu.Attach( *phMenu );
        pRootMenu = menu.GetSubMenu( MENU_INDEX_ROOT );

        pRootMenu->EnableMenuItem( ID_MEDSET_ROOT_COPY, MF_GRAYED | MF_BYCOMMAND );
        //
        // If not multi-select, and media copies are supported, 
        // and If engine up, enable copy
        //
        if( !bMultiSelect && ( m_pSakSnapAsk->GetState() == S_OK ) ) {

            if( m_MediaCopiesEnabled ) {

                pRootMenu->EnableMenuItem( ID_MEDSET_ROOT_COPY, MF_BYCOMMAND );
            }
        }

        menu.Detach();

    } WsbCatch( hr );

    return( hr );
}


//---------------------------------------------------------------------------
//
//         InvokeCommand
//
//  User has selected a command from the menu. Process it here.
//

STDMETHODIMP 
CUiMedSet::InvokeCommand( SHORT sCmd, IDataObject* /*pDataObject*/ )
{
    WsbTraceIn( L"CUiMedSet::InvokeCommand", L"sCmd = <%d>", sCmd );

    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CComPtr<IHsmServer> pHsm;

    try {

        
        switch (sCmd) {

            case ID_MEDSET_ROOT_COPY:
                {
                //
                // use wizard to sync media copies
                //
                CComObject<CMediaCopyWizard>* pWizard = new CComObject<CMediaCopyWizard>;
                WsbAffirmAlloc( pWizard );

                CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
                WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );
                }
                break;
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiMedSet::InvokeCommand", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiMedSet::SetupToolbar( IToolbar *pToolbar ) 
{
    WsbTraceIn( L"CUiMedSet::SetupToolbar", L"pToolbar = <0x%p>", pToolbar );
    HRESULT hr = S_OK;

    try {

        BOOL state = ( S_OK == m_pSakSnapAsk->GetState( ) ) ? TRUE : FALSE;

        for( INT i = 0; i < m_cToolbarButtons; i++ ) {

            m_ToolbarButtons[i].fsState = (UCHAR)( state ? TBSTATE_ENABLED : 0 );

            //
            // If media copy button, need to check if should be enabled
            //
            if( state && ( TB_CMD_MESE_COPY == m_ToolbarButtons[i].idCommand ) ) {

                if( m_MediaCopiesEnabled ) {
                    
                    m_ToolbarButtons[i].fsState = TBSTATE_ENABLED;

                } else {

                    m_ToolbarButtons[i].fsState = 0;
                }
            }
        }

        WsbAffirmHr( CSakNode::SetupToolbar( pToolbar ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiMedSet::SetupToolbar", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiMedSet::OnToolbarButtonClick( IDataObject * /* pDataObject */, long cmdId )
{
    WsbTraceIn( L"CUiMedSet::OnToolbarButtonClick", L"cmdId = <%d>", cmdId );
    HRESULT hr = S_OK;
    try {

        switch ( cmdId ) {

        case TB_CMD_MESE_COPY:
            {
                //
                // use wizard to sync media copies
                //
                CComObject<CMediaCopyWizard>* pWizard = new CComObject<CMediaCopyWizard>;
                WsbAffirmAlloc( pWizard );

                CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
                WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );
            }
            break;
        }
    } WsbCatch( hr );

    WsbTraceOut( L"CUiMedSet::OnToolbarButtonClick", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         CreateChildren
//
//  Create and initialize all the children of the media node.
//

STDMETHODIMP CUiMedSet::CreateChildren( )
{
    CMediaInfoObject mio;
    WsbTraceIn( L"CUiMedSet::CreateChildren", L"" );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pHsmServer );
        WsbAffirmPointer( m_pRmsServer );

        HRESULT hrEnum;

        // Get media info
        WsbAffirmHr( mio.Initialize( GUID_NULL, m_pHsmServer, m_pRmsServer ) );

        // Did we get a node?
        if( mio.m_MediaId != GUID_NULL ) {

            hrEnum = S_OK;
            while( SUCCEEDED( hrEnum ) ) {

                if( S_OK == mio.IsViewable( FALSE ) ) {

                    //
                    // Create the coresponding node
                    //

                    CComPtr<IUnknown> pUnkChild;
                    CComPtr<ISakNode> pNode;

                    WsbAffirmHr( NewChild( cGuidCar, &pUnkChild ) );
                    WsbAffirmHr( RsQueryInterface( pUnkChild, ISakNode, pNode ) );

                    //
                    // And initialize
                    //

                    // The media node now initializes based on the media id.  Assign it in
                    // the base class.
                    pNode->SetObjectId( mio.m_MediaId );
                    WsbAffirmHr( pNode->InitNode( m_pSakSnapAsk, 0, this ) );

                    //
                    // Add the child COM object to the parent's list of children.
                    //
                    WsbAffirmHr( AddChild( pNode ) );
                }

                hrEnum = mio.Next();
            }

            WsbAffirm( SUCCEEDED( hrEnum ) || ( WSB_E_NOTFOUND == hrEnum ), hrEnum );
        }
    } WsbCatch( hr );

    //
    // Indicate that this node's children are valid and up-to-date (even if there ARE
    // no children - at least now we know it).
    //
    m_bChildrenAreValid = TRUE;

    //
    // indicate that this parent node needs to be re-enumerated
    //
    m_bEnumState = FALSE;

    WsbTraceOut( L"CUiMedSet::CreateChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//
//         InitNode
//
//  Initialize single COM object. Derived objects frequently augment this method 
//  by implementing it themselves.
//

STDMETHODIMP
CUiMedSet::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CUiMedSet::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );
    HRESULT hr = S_OK;

    try {

        WsbAffirmHr( CSakNode::InitNode( pSakSnapAsk, pHsmObj, pParent ) );


        //
        // Set Display Type and Description
        //

        CString tempString;
        tempString.LoadString( IDS_MEDSET_DISPLAYNAME );
        WsbAffirmHr( put_DisplayName( (OLECHAR *)(LPCWSTR)tempString ) );
        tempString.LoadString( IDS_MEDSET_TYPE );
        WsbAffirmHr( put_Type( (OLECHAR *)(LPCWSTR)tempString ) );
        tempString.LoadString( IDS_MEDSET_DESCRIPTION );
        WsbAffirmHr( put_Description( (OLECHAR *)(LPCWSTR)tempString ) );

        WsbAffirmHr( RefreshObject() );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiMedSet::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CUiMedSet::TerminateNode(
    )
/*++

Routine Description:

    Free any interface connections or other resources
    that would prevent correct shutdown of node (would
    keep ref count from going to 0).

Arguments:

    CopySet - copy set of interest.

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_* - Some error occurred. 

--*/
{
    WsbTraceIn( L"CUiMedSet::TerminateNode", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Release any interface pointers kept so that circular references
        // are broken
        //
        m_pStoragePool.Release( );
        m_pHsmServer.Release( );
        m_pRmsServer.Release( );


        //
        // And call the base class for it's pieces
        //
        WsbAffirmHr( CSakNode::TerminateNode( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiMedSet::TerminateNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiMedSet::RefreshObject()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    try {

        m_NumCopySets        = 0;
        m_MediaCopiesEnabled = FALSE;

        WsbAssertPointer( m_pSakSnapAsk );

        //
        // If the engine is down, we want to create the node anyway
        // Need to release smart pointers so that interfaces are
        // correctly reference counted. IOW, if they already have
        // an interface pointer stored, it will not get released
        // before being clobbered here in the Get functions.
        //
        m_pHsmServer.Release( );
        m_pRmsServer.Release( );
        m_pStoragePool.Release( );

        if( m_pSakSnapAsk->GetHsmServer( &m_pHsmServer ) == S_OK ) {

            if( m_pSakSnapAsk->GetRmsServer( &m_pRmsServer ) == S_OK ) {

                //
                // Get the storage pool of interest
                //
                if( RsGetStoragePool( m_pHsmServer, &m_pStoragePool ) == S_OK ) {

                    //
                    // Contact data base and store necessary info
                    //
                    CMediaInfoObject mio;
                    mio.Initialize( GUID_NULL, m_pHsmServer, m_pRmsServer );
                    m_NumCopySets = mio.m_NumMediaCopies;

                    //
                    // Find out if media copies are supported
                    //
                    GUID mediaSetId;
                    CWsbBstrPtr mediaName;
                    WsbAffirmHr( m_pStoragePool->GetMediaSet( &mediaSetId, &mediaName ) );

                    CComPtr<IRmsMediaSet> pMediaSet;
                    WsbAffirmHr( m_pRmsServer->CreateObject( mediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void**)&pMediaSet ) );

                    m_MediaCopiesEnabled = ( pMediaSet->IsMediaCopySupported( ) == S_OK );
                }
            }
        }

        //
        // Set up the result view columns
        // This changes with the number of media copies, so can't
        // do once in Init()
        //
        WsbAffirmHr( SetChildProps( RS_STR_RESULT_PROPS_MEDSET_IDS,
            IDS_RESULT_PROPS_MEDSET_TITLES, IDS_RESULT_PROPS_MEDSET_WIDTHS ) );
        m_cChildPropsShow = m_cChildProps - HSMADMIN_MAX_COPY_SETS + m_NumCopySets;

    } WsbCatch( hr );

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\device\ca.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Ca.h

Abstract:

    Cartridge node implementation. Represents a piece of media.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/
#ifndef _CAR_H
#define _CAR_H

#include "saknodei.h"
#include "PrCar.h"

// Forward declaration
// class CMediaInfoObject;
class   CPropCartStatus;
class   CPropCartCopies;
class   CPropCartRecover;
class   CRecreateChooseCopy;


///////////////////////////////////////////////////////////////////////////////////
//
//
//  Property Sheet container class for media
//

// Media information object

class CMediaInfoObject 
{
// Construction
public:
    CMediaInfoObject();
    ~CMediaInfoObject();

protected:

private:
    CComPtr<IWsbDb>         m_pDb;
    CComPtr<IWsbDbSession>  m_pDbSession;
    CComPtr<IMediaInfo>     m_pMediaInfo;
    CComPtr<IHsmServer>     m_pHsmServer;
    CComPtr<IRmsServer>     m_pRmsServer;

public:
    HRESULT Initialize( GUID nMediaId, IHsmServer *pHsmServer, IRmsServer *pRmsServer );
    HRESULT First( );
    HRESULT Next( );
    HRESULT DeleteCopy( int Copy );
    HRESULT RecreateMaster( );


public:
	HRESULT IsCopyInSync( INT Copy );
    HRESULT DoesMasterExist( );
	HRESULT DoesCopyExist( INT Copy );
    HRESULT IsViewable( BOOL ConsiderInactiveCopies );
    GUID                m_MediaId;
    GUID                m_RmsIdMaster;
    CCopySetInfo        m_CopyInfo[HSMADMIN_MAX_COPY_SETS];

    CString             m_Name,
                        m_Description;
    CString             m_MasterName,
                        m_MasterDescription;

    HRESULT             m_LastHr;
    HSM_JOB_MEDIA_TYPE  m_Type;
    LONGLONG            m_FreeSpace,
                        m_Capacity;

    SHORT               m_NextDataSet;
    FILETIME            m_Modify;
    BOOL                m_ReadOnly,
                        m_Recreating,
                        m_Disabled;

    SHORT               m_LastGoodNextDataSet;

    USHORT              m_NumMediaCopies;



    // Helper functions
private:
    HRESULT InternalGetInfo();

    friend class CRecreateChooseCopy;
};


class CUiCarSheet : public CSakPropertySheet
{
public:
    CUiCarSheet( ) { };
    HRESULT AddPropertyPages( );
    HRESULT InitSheet(
            RS_NOTIFY_HANDLE handle, 
            IUnknown*        pUnkPropSheetCallback, 
            CSakNode*        pSakNode,
            ISakSnapAsk*     pSakSnapAsk,
            IEnumGUID*       pEnumObjectId,
            IEnumUnknown*    pEnumUnkNode);
    HRESULT GetNumMediaCopies( USHORT *pNumMediaCopies );
    HRESULT GetMediaId( GUID *pMediaId );


private:
    USHORT      m_pNumMediaCopies;
    GUID        m_mediaId;
    CPropCartStatus     *m_pPropPageStatus;
    CPropCartCopies     *m_pPropPageCopies;
    CPropCartRecover    *m_pPropPageRecover;

public:
    HRESULT OnPropertyChange( RS_NOTIFY_HANDLE hNotifyHandle );
};


class ATL_NO_VTABLE CUiCar : 
    public CSakNodeImpl<CUiCar>,
    public CComCoClass<CUiCar,&CLSID_CUiCar>,
    public CComDualImpl<ICartridge, &IID_ICartridge, &LIBID_HSMADMINLib>
{


public:
// constructor/destructor
    CUiCar(void) {};
BEGIN_COM_MAP(CUiCar)
    COM_INTERFACE_ENTRY2(IDispatch,    ICartridge)
    COM_INTERFACE_ENTRY2(ISakNodeProp, ICartridge)

    COM_INTERFACE_ENTRY(ISakNode)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CUiCar)

    // for multiple-inheritance, forward all base implementations to CSakNode.
    FORWARD_BASEHSM_IMPLS 

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

public: 
    STDMETHOD( InvokeCommand )          ( SHORT sCmd, IDataObject *pDataObject );
    STDMETHOD( GetContextMenu )         ( BOOL bMultiSelect, HMENU *phMenu );
    STDMETHOD( AddPropertyPages )       ( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID* pEnumObjectId, IEnumUnknown *pEnumUnkNode );

    // ISakNode methods
    STDMETHOD( InitNode )               ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( RefreshObject )          ();
    STDMETHOD( OnToolbarButtonClick )   ( IDataObject *pDataObject, long cmdId );
    STDMETHOD( GetResultIcon )          ( IN BOOL bOK, OUT int* pIconIndex );

    // ICartridge methods
    STDMETHOD( get_MediaTypeP )         ( BSTR * pszValue );
    STDMETHOD( get_CapacityP )          ( BSTR * pszValue );
    STDMETHOD( get_CapacityP_SortKey )  ( BSTR * pszValue );
    STDMETHOD( get_FreeSpaceP )         ( BSTR * pszValue );
    STDMETHOD( get_FreeSpaceP_SortKey ) ( BSTR * pszValue );
    STDMETHOD( get_StatusP )            ( BSTR * pszValue );
    STDMETHOD( get_StatusP_SortKey )    ( BSTR * pszValue );
    STDMETHOD( get_CopySet1P )          ( BSTR * pszValue );
    STDMETHOD( get_CopySet2P )          ( BSTR * pszValue );
    STDMETHOD( get_CopySet3P )          ( BSTR * pszValue );
    STDMETHOD( get_CopySet1P_SortKey )  ( BSTR * pszValue );
    STDMETHOD( get_CopySet2P_SortKey )  ( BSTR * pszValue );
    STDMETHOD( get_CopySet3P_SortKey )  ( BSTR * pszValue );


    // Interal Copy set access functions
    HRESULT GetCopySetP                 ( int CopySet, BSTR * pszValue );

    // private store of media info
private:

    GUID                m_RmsIdMaster;
    HSM_JOB_MEDIA_TYPE  m_Type;
    LONGLONG            m_FreeSpace,
                        m_Capacity;
    HRESULT             m_LastHr;
    BOOL                m_ReadOnly;
    BOOL                m_Recreating;
    CString             m_MasterName;
    FILETIME            m_Modify;
    SHORT               m_NextDataSet;
    SHORT               m_LastGoodNextDataSet;
    BOOL                m_Disabled;

    CCopySetInfo  m_CopyInfo[HSMADMIN_MAX_COPY_SETS];
    HRESULT ShowCarProperties (IDataObject *pDataObject, int initialPage);
    
    // static, class-wide variables
    static INT  m_nResultIconD;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CRecreateChooseCopy dialog

class CRecreateChooseCopy : public CDialog
{
// Construction
public:
    CRecreateChooseCopy( CMediaInfoObject * pMio, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CRecreateChooseCopy)
    enum { IDD = IDD_DLG_RECREATE_CHOOSE_COPY };
    CListCtrl   m_List;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRecreateChooseCopy)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    CMediaInfoObject * m_pMio;
    SHORT m_CopyToUse;
    int   m_ColCopy;
    int   m_ColName;
    int   m_ColDate;
    int   m_ColStatus;

public:
    SHORT CopyToUse( void );

protected:

    // Generated message map functions
    //{{AFX_MSG(CRecreateChooseCopy)
    afx_msg void OnClickList(NMHDR* pNMHDR, LRESULT* pResult);
    virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\device\prcar.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrCar.cpp

Abstract:

    Cartridge Property Pages.

Author:

    Rohde Wakefield [rohde]   15-Sep-1997

Revision History:

--*/

#include "stdafx.h"

#include "metalib.h"

#include "PrCar.h"
#include "ca.h"

static void RsAddDisabledText( CString & StatusString, BOOL Disabled )
{
    if( Disabled ) {

        CString disabledText;
        CString tempText;
        disabledText.LoadString( IDS_RECREATE_LOCATION_DISABLED );

        AfxFormatString2( tempText, IDS_RECREATE_STATUS_FORMAT, StatusString, disabledText );
        StatusString = tempText;

    }
}

static DWORD pStatusHelpIds[] = 
{

    IDC_NAME,               idh_media_master_name,
    IDC_NAME_LABEL,         idh_media_master_name,
    IDC_STATUS,             idh_media_master_status,
    IDC_STATUS_LABEL,       idh_media_master_status,
    IDC_CAPACITY,           idh_media_master_capacity,
    IDC_CAPACITY_LABEL,     idh_media_master_capacity,
    IDC_FREESPACE,          idh_media_master_free_space,
    IDC_FREESPACE_LABEL,    idh_media_master_free_space,
    IDC_MODIFIED,           idh_media_master_last_modified,
    IDC_MODIFIED_LABEL,     idh_media_master_last_modified,
    IDC_STATUS_1,           idh_media_copy1_status,
    IDC_COPY_1,             idh_media_copy1_status,
    IDC_STATUS_2,           idh_media_copy2_status,
    IDC_COPY_2,             idh_media_copy2_status,
    IDC_STATUS_3,           idh_media_copy3_status,
    IDC_COPY_3,             idh_media_copy3_status,

    0, 0
};

static DWORD pCopiesHelpIds[] = 
{

    IDC_MODIFIED,           idh_media_master_last_modified,
    IDC_MODIFIED_LABEL,     idh_media_master_last_modified,
    IDC_NAME_1_LABEL,       idh_media_copy1_name,
    IDC_NAME_1,             idh_media_copy1_name,
    IDC_NAME_2_LABEL,       idh_media_copy2_name,
    IDC_NAME_2,             idh_media_copy2_name,
    IDC_NAME_3_LABEL,       idh_media_copy3_name,
    IDC_NAME_3,             idh_media_copy3_name,
    IDC_STATUS_1,           idh_media_copy1_status,
    IDC_STATUS_1_LABEL,     idh_media_copy1_status,
    IDC_STATUS_2,           idh_media_copy2_status,
    IDC_STATUS_2_LABEL,     idh_media_copy2_status,
    IDC_STATUS_3,           idh_media_copy3_status,
    IDC_STATUS_3_LABEL,     idh_media_copy3_status,
    IDC_DELETE_1,           idh_media_copy1_delete_button,
    IDC_DELETE_2,           idh_media_copy2_delete_button,
    IDC_DELETE_3,           idh_media_copy3_delete_button,
    IDC_MODIFIED_1,         idh_media_copy1_last_modified,
    IDC_MODIFIED_1_LABEL,   idh_media_copy1_last_modified,
    IDC_MODIFIED_2,         idh_media_copy2_last_modified,
    IDC_MODIFIED_2_LABEL,   idh_media_copy2_last_modified,
    IDC_MODIFIED_3,         idh_media_copy3_last_modified,
    IDC_MODIFIED_3_LABEL,   idh_media_copy3_last_modified,

    0, 0
};

static DWORD pRecoverHelpIds[] = 
{
    IDC_RECREATE_MASTER,    idh_media_recreate_master_button,

    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPropCartStatus property page

CPropCartStatus::CPropCartStatus( long resourceId ) : CSakPropertyPage( resourceId )
{
    //{{AFX_DATA_INIT(CPropCartStatus)
    //}}AFX_DATA_INIT

    m_pHelpIds = pStatusHelpIds;
    m_DlgID    = resourceId;
}


CPropCartStatus::~CPropCartStatus()
{
}

void CPropCartStatus::DoDataExchange(CDataExchange* pDX)
{
    CSakPropertyPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CPropCartStatus)
	//}}AFX_DATA_MAP
    if( IDD_PROP_CAR_STATUS == m_DlgID ) {

        DDX_Control(pDX, IDC_DESCRIPTION, m_Description);
        DDX_Control(pDX, IDC_NAME,        m_Name);

    }
}


BEGIN_MESSAGE_MAP(CPropCartStatus, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPropCartStatus)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropCartStatus message handlers

typedef struct {
    int label, status;
} CONTROL_SET_GENERAL;

CONTROL_SET_GENERAL copyGeneral[] = {
    { IDC_COPY_1, IDC_STATUS_1 },
    { IDC_COPY_2, IDC_STATUS_2 },
    { IDC_COPY_3, IDC_STATUS_3 }
};

BOOL CPropCartStatus::OnInitDialog( )
{
    WsbTraceIn( L"CPropCartStatus::OnInitDialog", L"" );
    HRESULT hr = S_OK;
    CSakPropertyPage::OnInitDialog( );

    try {

        //
        // Get the Hsm Server
        //
        WsbAffirmHr( m_pParent->GetHsmServer( &m_pHsmServer ) );

        //
        // Get the Rms Server
        //
        WsbAffirmHr( ( (CUiCarSheet *)m_pParent )->GetRmsServer( &m_pRmsServer ) );

        //
        // Set multi-select boolean
        //
        m_bMultiSelect = ( m_pParent->IsMultiSelect() == S_OK );
        
        Refresh();

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartStatus::OnInitDialog", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( TRUE );
}

HRESULT CPropCartStatus::Refresh () 
{
    WsbTraceIn( L"CPropCartStatus::Refresh", L"" );

    GUID mediaId;
    USHORT status;
    CString statusString;
    CMediaInfoObject mio;
    CString sText;
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    try {

        //
        // If refresh is called and the node is not initialized, do nothing
        //
        if( m_pHsmServer ) {

            //
            // Get the number of media copies from the sheet object
            //
            WsbAffirmHr( ( (CUiCarSheet *)m_pParent )->GetNumMediaCopies( &m_NumMediaCopies ) );

            if( !m_bMultiSelect ) {

                //
                // SINGLE SELECT
                //

                //
                // Get media info
                //
                ( (CUiCarSheet *)m_pParent )->GetMediaId( &mediaId );

                mio.Initialize( mediaId, m_pHsmServer, m_pRmsServer );

                //
                // Get info and set controls
                //
                SetDlgItemText( IDC_DESCRIPTION, mio.m_MasterDescription );
                SetDlgItemText( IDC_NAME,        mio.m_MasterName );
                
                status = RsGetCartStatus( mio.m_LastHr, mio.m_ReadOnly, mio.m_Recreating, mio.m_NextDataSet, mio.m_LastGoodNextDataSet );
                WsbAffirmHr( RsGetCartStatusString( status, statusString ) );
                RsAddDisabledText( statusString, mio.m_Disabled );

                SetDlgItemText( IDC_STATUS, statusString );

                //
                // Show capacity statistics
                //
                WsbAffirmHr( RsGuiFormatLongLong4Char( mio.m_Capacity, sText ) );
                SetDlgItemText( IDC_CAPACITY, sText );

                WsbAffirmHr( RsGuiFormatLongLong4Char( mio.m_FreeSpace, sText ) );
                SetDlgItemText( IDC_FREESPACE, sText );

                CTime time( mio.m_Modify );
                SetDlgItemText( IDC_MODIFIED, time.Format( L"%#c" ) );

                for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                    GetDlgItem( copyGeneral[index].label )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyGeneral[index].status )->EnableWindow( index < m_NumMediaCopies );

                    status = RsGetCopyStatus( mio.m_CopyInfo[index].m_RmsId, mio.m_CopyInfo[index].m_Hr, mio.m_CopyInfo[index].m_NextDataSet, mio.m_LastGoodNextDataSet );
                    WsbAffirmHr( RsGetCopyStatusString( status, statusString ) );
                    RsAddDisabledText( statusString, mio.m_CopyInfo[index].m_Disabled );
                    SetDlgItemText( copyGeneral[index].status, statusString );

                }

            } else {

                //
                // Multi-Select
                //
                GUID mediaId;
                LONGLONG totalCapacity  = 0;
                LONGLONG totalFreeSpace = 0;
                USHORT statusCartRecreate  = 0;
                USHORT statusCartReadOnly  = 0;
                USHORT statusCartNormal    = 0;
                USHORT statusCartRO        = 0;
                USHORT statusCartRW        = 0;
                USHORT statusCartMissing   = 0;
                USHORT statusCopyNone[ HSMADMIN_MAX_COPY_SETS ];
                USHORT statusCopyError[ HSMADMIN_MAX_COPY_SETS ];
                USHORT statusCopyMissing[ HSMADMIN_MAX_COPY_SETS ];
                USHORT statusCopyOutSync[ HSMADMIN_MAX_COPY_SETS ];
                USHORT statusCopyInSync[ HSMADMIN_MAX_COPY_SETS ];

                //
                // initialize copy totals
                //
                for( int i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {

                    statusCopyNone[i]    = 0; 
                    statusCopyError[i]   = 0; 
                    statusCopyOutSync[i] = 0; 
                    statusCopyInSync[i]  = 0;

                }

                int bookMark = 0;
                int numMedia = 0;
                while( m_pParent->GetNextObjectId( &bookMark, &mediaId ) == S_OK ) {

                    numMedia++;
                    mio.Initialize( mediaId, m_pHsmServer, m_pRmsServer  );

                    //
                    // total up statuses
                    //
                    status = RsGetCartStatus( mio.m_LastHr, mio.m_ReadOnly, mio.m_Recreating, mio.m_NextDataSet, mio.m_LastGoodNextDataSet );
                    switch( status ) {

                    case RS_MEDIA_STATUS_RECREATE:
                        statusCartRecreate++;
                        break;

                    case RS_MEDIA_STATUS_READONLY:
                        statusCartReadOnly++;
                        break;

                    case RS_MEDIA_STATUS_NORMAL:
                        statusCartNormal++;
                        break;

                    case RS_MEDIA_STATUS_ERROR_RO:
                        statusCartRO++;
                        break;

                    case RS_MEDIA_STATUS_ERROR_RW:
                        statusCartRW++;
                        break;

                    case RS_MEDIA_STATUS_ERROR_MISSING:
                        statusCartMissing++;
                        break;

                    }

                    for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                        int status = RsGetCopyStatus( mio.m_CopyInfo[index].m_RmsId, mio.m_CopyInfo[index].m_Hr, mio.m_CopyInfo[index].m_NextDataSet, mio.m_LastGoodNextDataSet );

                        //
                        // Total up the statuses
                        //
                        switch( status ) {

                        case RS_MEDIA_COPY_STATUS_NONE:
                            statusCopyNone[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_ERROR:
                            statusCopyError[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_MISSING:
                            statusCopyMissing[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_OUTSYNC:
                            statusCopyOutSync[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_INSYNC:
                            statusCopyInSync[index]++;
                            break;

                        }

                    }

                    totalCapacity  += mio.m_Capacity;
                    totalFreeSpace += mio.m_FreeSpace;

                } // While

                //
                // Display number of media selected
                //
                sText.Format( IDS_MEDIA, numMedia );
                SetDlgItemText( IDC_DESCRIPTION_MULTI, sText );

                //
                // Show the accumulated statistics
                //
                CString sText;
                WsbAffirmHr( RsGuiFormatLongLong4Char( totalCapacity, sText ) );
                SetDlgItemText( IDC_CAPACITY, sText );

                WsbAffirmHr( RsGuiFormatLongLong4Char( totalFreeSpace, sText ) );
                SetDlgItemText( IDC_FREESPACE, sText );

                //
                // Show the accumulated cart statuses
                //
                RsGetCartMultiStatusString( statusCartRecreate, statusCartReadOnly, 
                    statusCartNormal, statusCartRO, statusCartRW, statusCartMissing,
                    statusString );
                SetDlgItemText( IDC_STATUS, statusString );

                for( i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {

                    WsbAffirmHr( RsGetCopyMultiStatusString( statusCopyNone[i], 
                            statusCopyError[i], statusCopyOutSync[i], statusCopyInSync[i], statusString ) );
                    SetDlgItemText( copyGeneral[i].status, statusString );

                    GetDlgItem( copyGeneral[i].label )->EnableWindow( i < m_NumMediaCopies );
                    GetDlgItem( copyGeneral[i].status )->EnableWindow( i < m_NumMediaCopies );

                } // for
            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartStatus::Refresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

BOOL CPropCartStatus::OnApply( )
{
    WsbTraceIn( L"CPropCartStatus::OnApply", L"" );

    BOOL retVal = CSakPropertyPage::OnApply( );

    WsbTraceOut( L"CPropCartStatus::OnApply", L"" );
    return( retVal );
}


/////////////////////////////////////////////////////////////////////////////
// CPropCartCopies property page

CPropCartCopies::CPropCartCopies( long resourceId ) : CSakPropertyPage( resourceId )
{
    //{{AFX_DATA_INIT(CPropCartCopies)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_pHelpIds = pCopiesHelpIds;
    m_DlgID    = resourceId;
}

CPropCartCopies::~CPropCartCopies()
{
}

void CPropCartCopies::DoDataExchange(CDataExchange* pDX)
{
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPropCartCopies)
	//}}AFX_DATA_MAP
    if( IDD_PROP_CAR_COPIES == m_DlgID ) {

        DDX_Control(pDX, IDC_NAME_3, m_Name3);
        DDX_Control(pDX, IDC_NAME_2, m_Name2);
        DDX_Control(pDX, IDC_NAME_1, m_Name1);

        DDX_Control(pDX, IDC_STATUS_3, m_Status3);
        DDX_Control(pDX, IDC_STATUS_2, m_Status2);
        DDX_Control(pDX, IDC_STATUS_1, m_Status1);
    }
}


BEGIN_MESSAGE_MAP(CPropCartCopies, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPropCartCopies)
    ON_BN_CLICKED(IDC_DELETE_1, OnDelete1)
    ON_BN_CLICKED(IDC_DELETE_2, OnDelete2)
    ON_BN_CLICKED(IDC_DELETE_3, OnDelete3)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropCartCopies message handlers

typedef struct {

    int group,
        nameLabel,
        name,
        statusLabel,
        status,
        modifyLabel,
        modify,
        deleteCopy;

} CONTROL_SET_COPIES;

CONTROL_SET_COPIES copyCopies[] = {
    { IDC_COPY_1, IDC_NAME_1_LABEL, IDC_NAME_1, IDC_STATUS_1_LABEL, IDC_STATUS_1, IDC_MODIFIED_1_LABEL, IDC_MODIFIED_1, IDC_DELETE_1 },
    { IDC_COPY_2, IDC_NAME_2_LABEL, IDC_NAME_2, IDC_STATUS_2_LABEL, IDC_STATUS_2, IDC_MODIFIED_2_LABEL, IDC_MODIFIED_2, IDC_DELETE_2 },
    { IDC_COPY_3, IDC_NAME_3_LABEL, IDC_NAME_3, IDC_STATUS_3_LABEL, IDC_STATUS_3, IDC_MODIFIED_3_LABEL, IDC_MODIFIED_3, IDC_DELETE_3 }
};

BOOL CPropCartCopies::OnInitDialog() 
{
    WsbTraceIn( L"CPropCartCopies::OnInitDialog", L"" );
    HRESULT hr = S_OK;

    CSakPropertyPage::OnInitDialog( );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    try {

        //
        // Get the Hsm Server
        //
        WsbAffirmHr( m_pParent->GetHsmServer( &m_pHsmServer ) );

        //
        // Get the Rms Server
        //
        WsbAffirmHr( ( (CUiCarSheet* ) m_pParent )->GetRmsServer( &m_pRmsServer ) );

        //
        // Set multi-select boolean
        //
        m_bMultiSelect = ( m_pParent->IsMultiSelect() == S_OK );    

        Refresh();

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartCopies::OnInitDialog", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( TRUE );
}

HRESULT CPropCartCopies::Refresh( ) 
{
    WsbTraceIn( L"CPropCartCopies::Refresh", L"" );
    HRESULT hr = S_OK;

    GUID mediaId;
    CMediaInfoObject mio;

    try {
        //
        // Only refresh if we've been intialized
        //
        if( m_pHsmServer ) {

            //
            // Get the number of media copies from the sheet object
            //
            WsbAffirmHr( ( (CUiCarSheet *)m_pParent )->GetNumMediaCopies( &m_NumMediaCopies ) );

            if( !m_bMultiSelect ) {

                //
                // SINGLE SELECT
                //

                //
                // Get the media Id and initialize the info object
                //
                ( (CUiCarSheet *)m_pParent )->GetMediaId( &mediaId );
                mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );

                //
                // Get info and set controls
                //
                CTime time( mio.m_Modify );
                SetDlgItemText( IDC_MODIFIED, time.Format( L"%#c" ) );


                //
                // Disable the controls for displaying info on non-existant
                // Copies. Fill in the info for copies that exist.
                //
                for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                    BOOL mediaMissing = IsEqualGUID( mio.m_CopyInfo[index].m_RmsId, GUID_NULL );

                    GetDlgItem( copyCopies[index].group )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].nameLabel )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].name )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].statusLabel )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].status )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].modifyLabel )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].modify )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].deleteCopy )->EnableWindow( ! mediaMissing );

                    SetDlgItemText( copyCopies[index].name, L"" );
                    SetDlgItemText( copyCopies[index].status, L"" );
                    SetDlgItemText( copyCopies[index].modify, L"" );

                    USHORT status;
                    CString statusString;
                    status = RsGetCopyStatus( mio.m_CopyInfo[index].m_RmsId, mio.m_CopyInfo[index].m_Hr, mio.m_CopyInfo[index].m_NextDataSet, mio.m_LastGoodNextDataSet );
                    WsbAffirmHr( RsGetCopyStatusString( status, statusString ) );
                    RsAddDisabledText( statusString, mio.m_CopyInfo[index].m_Disabled );
                    SetDlgItemText( copyCopies[index].status, statusString );

                    if( !mediaMissing ) {

                        time = mio.m_CopyInfo[index].m_ModifyTime;
                        SetDlgItemText( copyCopies[index].modify, time.Format( L"%#c" ) );

                        CComPtr<IRmsCartridge> pCart;
                        CWsbBstrPtr name;
                        if( SUCCEEDED( m_pRmsServer->FindCartridgeById( mio.m_CopyInfo[index].m_RmsId, &pCart ) ) ) {

                            WsbAffirmHr( pCart->GetName( &name ) );

                        }
                        SetDlgItemText( copyCopies[index].name, name );

                    }

                }

            } else {

                //
                // MULTI-SELECT
                //
                BOOL bGotOne [HSMADMIN_MAX_COPY_SETS];
                int bookMark = 0;
                USHORT statusCopyNone [HSMADMIN_MAX_COPY_SETS];
                USHORT statusCopyError [HSMADMIN_MAX_COPY_SETS];
                USHORT statusCopyMissing [HSMADMIN_MAX_COPY_SETS];
                USHORT statusCopyOutSync [HSMADMIN_MAX_COPY_SETS];
                USHORT statusCopyInSync [HSMADMIN_MAX_COPY_SETS];

                //
                // initialize copy totals
                //
                for( int i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {
                    statusCopyNone[i] = 0; 
                    statusCopyError[i] = 0; 
                    statusCopyOutSync[i] = 0; 
                    statusCopyInSync[i] = 0;
                    bGotOne[i] = FALSE;
                }

                //
                // For each selected medium...
                //
                while( m_pParent->GetNextObjectId( &bookMark, &mediaId ) == S_OK ) {
                    mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );

                    //
                    // Tally up the statuses for all valid copy sets
                    //
                    for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                        //
                        //  Is there is at least one valid copy in this copyset
                        // for any of the selected media?
                        //
                        if( ! IsEqualGUID( mio.m_CopyInfo[index].m_RmsId, GUID_NULL ) ) {

                            bGotOne[index] = TRUE;

                        }

                        USHORT status;
                        CString statusString;
                        status = RsGetCopyStatus( mio.m_CopyInfo[index].m_RmsId, mio.m_CopyInfo[index].m_Hr, mio.m_CopyInfo[index].m_NextDataSet, mio.m_LastGoodNextDataSet );
                        // Total up the statuses
                        switch( status ) {

                        case RS_MEDIA_COPY_STATUS_NONE:
                            statusCopyNone[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_ERROR:
                            statusCopyError[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_MISSING:
                            statusCopyMissing[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_OUTSYNC:
                            statusCopyOutSync[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_INSYNC:
                            statusCopyInSync[index]++;
                            break;

                        } 
                    }
                } // while

                //
                // Show accumlated statuses for each valid copy set
                //
                CString statusString;
                for( i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {

                    WsbAffirmHr( RsGetCopyMultiStatusString( statusCopyNone[i], 
                            statusCopyError[i], statusCopyOutSync[i], statusCopyInSync[i], statusString ) );
                    SetDlgItemText( copyCopies[i].status, statusString );

                }

                //
                // Set control states
                //
                for( i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {

                    GetDlgItem( copyCopies[i].group )->EnableWindow( i < m_NumMediaCopies );
                    GetDlgItem( copyCopies[i].statusLabel )->EnableWindow( i < m_NumMediaCopies );
                    GetDlgItem( copyCopies[i].status )->EnableWindow( i < m_NumMediaCopies );
                    GetDlgItem( copyCopies[i].deleteCopy )->EnableWindow( bGotOne[i] );

                }
            }
        }
    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartCopies::Refresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

void CPropCartCopies::OnDelete1() 
{
    OnDelete( 1 );
}

void CPropCartCopies::OnDelete2() 
{
    OnDelete( 2 );
}

void CPropCartCopies::OnDelete3() 
{
    OnDelete( 3 );
}

void CPropCartCopies::OnDelete( int Copy ) 
{
    WsbTraceIn( L"CPropCartCopies::OnDelete", L"Copy = <%d>", Copy );
    HRESULT hr = S_OK;

    CMediaInfoObject mio;
    GUID mediaId;

    try {

        if( !m_bMultiSelect ) {

            //
            // Single Select
            //
            CString confirm;

            //
            // Get the media Id and initialize the info object
            //
            ( (CUiCarSheet *)m_pParent )->GetMediaId( &mediaId );
            mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );
            confirm.Format( IDS_CONFIRM_MEDIA_COPY_DELETE, Copy, mio.m_Description );

            if( IDYES == AfxMessageBox( confirm, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 ) ) {

                WsbAffirmHr( mio.DeleteCopy( Copy ) );

            }

        } else {

            //
            // Multi-Select
            // tally up the names of the selected media
            //
            int bookMark = 0;
            GUID mediaId;
            CString szMediaList = L"";
            BOOL bFirst = TRUE;
            while( m_pParent->GetNextObjectId( &bookMark, &mediaId ) == S_OK ) {

                mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );
                
                //
                // Does the copy exist?
                //
                if( !IsEqualGUID( mio.m_CopyInfo[Copy - 1].m_RmsId, GUID_NULL ) ) {

                    //
                    // Put in commas after the first Id
                    //
                    if( !bFirst ) {

                        szMediaList += L", ";

                    } else {

                        bFirst = FALSE;

                    }
                    szMediaList += mio.m_Description;
                }
            }

            CString confirm;
            confirm.Format( IDS_CONFIRM_MEDIA_COPY_DELETE_MULTI, Copy, szMediaList );

            if( IDYES == AfxMessageBox( confirm, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 ) ) {

                bookMark = 0;
                while( m_pParent->GetNextObjectId( &bookMark, &mediaId ) == S_OK ) {

                    WsbAffirmHr( mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer ) );

                    //
                    // Does the copy exist?
                    //
                    if( !IsEqualGUID( mio.m_CopyInfo[Copy - 1].m_RmsId, GUID_NULL ) ) {

                        WsbAffirmHr( mio.DeleteCopy( Copy ) ); 

                    }
                }
            }
        }
        
        //
        // Now notify all the nodes
        //
        ( (CUiCarSheet *) m_pParent )-> OnPropertyChange( m_hConsoleHandle );

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartCopies::OnDelete", L"hr = <%ls>", WsbHrAsString( hr ) );
}

/////////////////////////////////////////////////////////////////////////////
// CPropCartRecover property page

CPropCartRecover::CPropCartRecover() : CSakPropertyPage(CPropCartRecover::IDD)
{
    //{{AFX_DATA_INIT(CPropCartRecover)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_pHelpIds = pRecoverHelpIds;
}

CPropCartRecover::~CPropCartRecover()
{
}

void CPropCartRecover::DoDataExchange(CDataExchange* pDX)
{
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPropCartRecover)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropCartRecover, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPropCartRecover)
        ON_BN_CLICKED(IDC_RECREATE_MASTER, OnRecreateMaster)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CPropCartRecover::OnRecreateMaster() 
{
    WsbTraceIn( L"CPropCartRecover::OnRecreateMaster", L"" );
    HRESULT hr = S_OK;

    CMediaInfoObject mio;
    GUID mediaId;

    try {

        //
        // For single select only!
        //
        WsbAssert( !m_bMultiSelect, E_FAIL );

        //
        // Get the media Id and initialize the info object
        //
        ( (CUiCarSheet *)m_pParent )->GetMediaId( &mediaId );
        mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );
        WsbAffirmHr( mio.RecreateMaster() );

        //
        // Now notify all the nodes
        //
        ( (CUiCarSheet *) m_pParent )->OnPropertyChange( m_hConsoleHandle );

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartRecover::OnRecreateMaster", L"hr = <%ls>", WsbHrAsString( hr ) );
}

/////////////////////////////////////////////////////////////////////////////
// CPropCartRecover message handlers

BOOL CPropCartRecover::OnInitDialog() 
{
    WsbTraceIn( L"CPropCartRecover::OnInitDialog", L"" );
    HRESULT hr = S_OK;

    CSakPropertyPage::OnInitDialog();

    try {

        //
        // Set multi-select boolean
        //
        m_bMultiSelect = ( m_pParent->IsMultiSelect() == S_OK );    

        //
        // Get the Hsm Server
        //
        WsbAffirmHr( m_pParent->GetHsmServer( &m_pHsmServer ) );

        //
        // Get the Rms Server
        //
        WsbAffirmHr( ( (CUiCarSheet *) m_pParent )->GetRmsServer( &m_pRmsServer ) );

        Refresh( );

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartRecover::OnInitDialog", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( TRUE );
}
HRESULT CPropCartRecover::Refresh() 
{
    WsbTraceIn( L"CPropCartRecover::Refresh", L"" );
    HRESULT hr = S_OK;

    GUID mediaId;
    CMediaInfoObject mio;

    try {

        //
        // Only refresh if we've been initialized
        //
        if( m_pHsmServer ) {

            if( ! m_bMultiSelect ) {

                //
                // Get the number of media copies from the sheet object
                //
                WsbAffirmHr( ( (CUiCarSheet *) m_pParent )->GetNumMediaCopies( &m_NumMediaCopies ) );

                //
                // Get the media Id and initialize the info object
                //
                ( (CUiCarSheet *)m_pParent )->GetMediaId( &mediaId );
                mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );

                //
                // SINGLE SELECT (this page is implemented for single-select only
                //
                BOOL enableRecreate = FALSE;
                for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                    if( index < m_NumMediaCopies ) {

                        if( !IsEqualGUID( mio.m_CopyInfo[index].m_RmsId, GUID_NULL ) ) {

                            enableRecreate = TRUE;

                        }

                    } else {

                        SetDlgItemText( copyGeneral[index].status, L"" );

                    }

                }

                GetDlgItem( IDC_RECREATE_MASTER )->EnableWindow( enableRecreate );
            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartRecover::Refresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\device\prcar.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrCar.cpp

Abstract:

    Cartridge Property Pages.

Author:

    Rohde Wakefield [rohde]   15-Sep-1997

Revision History:

--*/

#ifndef _PRCAR_H
#define _PRCAR_H

#include "Ca.h"

class CMediaInfoObject;
/////////////////////////////////////////////////////////////////////////////
// CPropCartStatus dialog

class CPropCartStatus : public CSakPropertyPage
{
// Construction
public:
    CPropCartStatus( long resourceId );
    ~CPropCartStatus();

// Dialog Data
    //{{AFX_DATA(CPropCartStatus)
	enum { IDD = IDD_PROP_CAR_STATUS };
	CRsGuiOneLiner	m_Description;
	CRsGuiOneLiner	m_Name;
	//}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPropCartStatus)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPropCartStatus)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    CComPtr <IHsmServer> m_pHsmServer;
    CComPtr <IRmsServer> m_pRmsServer;
    HRESULT Refresh();

private:
    USHORT m_NumMediaCopies;
    BOOL   m_bMultiSelect;
    UINT   m_DlgID;

};

/////////////////////////////////////////////////////////////////////////////
// CPropCartCopies dialog

class CPropCartCopies : public CSakPropertyPage
{
// Construction
public:
    CPropCartCopies( long resourceId );
    ~CPropCartCopies();

// Dialog Data
    //{{AFX_DATA(CPropCartCopies)
	enum { IDD = IDD_PROP_CAR_COPIES };
	//}}AFX_DATA
	CRsGuiOneLiner	m_Name3;
	CRsGuiOneLiner	m_Name2;
	CRsGuiOneLiner	m_Name1;
	CRsGuiOneLiner	m_Status3;
	CRsGuiOneLiner	m_Status2;
	CRsGuiOneLiner	m_Status1;


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPropCartCopies)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPropCartCopies)
    virtual BOOL OnInitDialog();
    afx_msg void OnDelete1();
    afx_msg void OnDelete2();
    afx_msg void OnDelete3();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    CComPtr <IHsmServer> m_pHsmServer;
    CComPtr <IRmsServer> m_pRmsServer;
    HRESULT Refresh();

private:
    USHORT m_NumMediaCopies;
    void   OnDelete( int Copy );
    BOOL   m_bMultiSelect;
    UINT   m_DlgID;
};
/////////////////////////////////////////////////////////////////////////////
// CPropCartRecover dialog

class CPropCartRecover : public CSakPropertyPage
{
// Construction
public:
    CPropCartRecover();
    ~CPropCartRecover();

// Dialog Data
    //{{AFX_DATA(CPropCartRecover)
    enum { IDD = IDD_PROP_CAR_RECOVER };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPropCartRecover)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPropCartRecover)
    virtual BOOL OnInitDialog();
    afx_msg void OnRecreateMaster();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    USHORT m_NumMediaCopies;
    BOOL   m_bMultiSelect;

public:
    CComPtr <IHsmServer>    m_pHsmServer;
    CComPtr <IRmsServer>    m_pRmsServer;
    HRESULT Refresh();
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX
#endif // _PRCAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\device\mese.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    ChooHsm.cpp

Abstract:

    Node representing our Media Set (Media Pool) within NTMS.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _MEDSET_H
#define _MEDSET_H

#include "SakNodeI.h"

class ATL_NO_VTABLE CUiMedSet : 
    public CSakNodeImpl<CUiMedSet>,
    public CComCoClass<CUiMedSet,&CLSID_CUiMedSet>
{

public:
// constructor/destructor
    CUiMedSet(void) {};
BEGIN_COM_MAP(CUiMedSet)
    COM_INTERFACE_ENTRY2(IDispatch, ISakNodeProp)
    COM_INTERFACE_ENTRY(ISakNode)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(ISakNodeProp)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CUiMedSet)

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

public: 
    STDMETHOD( InvokeCommand )             ( SHORT sCmd, IDataObject *pDataObject );
    STDMETHOD( GetContextMenu )            ( BOOL bMultiSelect, HMENU *phMenu );

    // ISakNode methods
    STDMETHOD( CreateChildren )            ( void ); 
    STDMETHOD( InitNode )                  ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( TerminateNode )             ( void );
    STDMETHOD( RefreshObject )             ( );
    STDMETHOD( SetupToolbar )               ( IToolbar *pToolbar );
    STDMETHOD( OnToolbarButtonClick )      ( IDataObject *pDataObject, long cmdId );

    // static, class-wide variables
    static INT  m_nScopeOpenIconIndex;  // virtual scope index of Open Icon
    static INT  m_nScopeCloseIconIndex; // virtual scope index of Close Icon
    static INT  m_nResultIconIndex; // virtual scope index of Close Icon

private:

    CComPtr <IHsmStoragePool> m_pStoragePool;
    CComPtr <IHsmServer>      m_pHsmServer;
    CComPtr <IRmsServer>      m_pRmsServer;
    USHORT                    m_NumCopySets;
    BOOL                      m_MediaCopiesEnabled;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\device\wzmedset.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WzMedSet.cpp

Abstract:

    Wizard for Media Set - Copy Set Wizard.

Author:

    Rohde Wakefield [rohde]   23-09-1997

Revision History:

--*/

#include "stdafx.h"

#include "MeSe.h"
#include "WzMedSet.h"

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizard

CMediaCopyWizard::CMediaCopyWizard()
{
    WsbTraceIn( L"CMediaCopyWizard::CMediaCopyWizard", L"" );

    m_TitleId     = IDS_WIZ_CAR_COPY_TITLE;
    m_HeaderId    = IDB_MEDIA_SYNC_HEADER;
    m_WatermarkId = IDB_MEDIA_SYNC_WATERMARK;

    WsbTraceOut( L"CMediaCopyWizard::CMediaCopyWizard", L"" );
}

CMediaCopyWizard::~CMediaCopyWizard()
{
    WsbTraceIn( L"CMediaCopyWizard::~CMediaCopyWizard", L"" );
    WsbTraceOut( L"CMediaCopyWizard::~CMediaCopyWizard", L"" );
}

STDMETHODIMP
CMediaCopyWizard::AddWizardPages(
    IN RS_PCREATE_HANDLE Handle,
    IN IUnknown*         pCallback,
    IN ISakSnapAsk*      pSakSnapAsk
    )
{
    WsbTraceIn( L"CMediaCopyWizard::AddWizardPages", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Initialize the Sheet
        //
        WsbAffirmHr( InitSheet( Handle, pCallback, 0, pSakSnapAsk, 0, 0 ) );

        //
        // Get the number of media copies. If 0, we put up the media copies
        // page.
        //
        CComPtr<IHsmServer> pHsmServer;
        CComPtr<IHsmStoragePool> pStoragePool;
        WsbAffirmHrOk( pSakSnapAsk->GetHsmServer( &pHsmServer ) );
        WsbAffirmHr( RsGetStoragePool( pHsmServer, &pStoragePool ) );

        WsbAffirmHr( pStoragePool->GetNumMediaCopies( &m_numMediaCopiesOrig ) );

        //
        // Load pages 
        //
        WsbAffirmHr( AddPage( &m_pageIntro ) );

        if ( m_numMediaCopiesOrig == 0 ) {

            WsbAffirmHr( AddPage( &m_pageNumCopies ) );

        }

        WsbAffirmHr( AddPage( &m_pageSelect ) );
        WsbAffirmHr( AddPage( &m_pageFinish ) );


    } WsbCatch( hr );

    WsbTraceOut( L"CMediaCopyWizard::AddWizardPages", L"" );
    return( hr );
}

HRESULT CMediaCopyWizard::OnFinish( )
{
    WsbTraceIn( L"CMediaCopyWizard::OnFinish", L"" );
    //
    // The sheet really owns the process as a whole,
    // so it will do the final assembly
    //

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;

    try {

        USHORT numMediaCopies;

        CComPtr<IHsmServer> pHsmServer;
        CComPtr<IHsmStoragePool> pStoragePool;
        WsbAffirmHrOk( GetHsmServer( &pHsmServer ) );
        WsbAffirmHr( RsGetStoragePool( pHsmServer, &pStoragePool ) );

        //
        // If we changed the number of media copies (i.e. it was orignally 0),
        // reset it in Engine
        //
        if( m_numMediaCopiesOrig == 0 ) {

            hrInternal = m_pageNumCopies.GetNumMediaCopies( &numMediaCopies );
            if( S_OK == hrInternal ) {


                WsbAffirmHr( pStoragePool->SetNumMediaCopies( numMediaCopies ) );
                WsbAffirmHr( pHsmServer->SavePersistData( ) );

                HRESULT hrUpdate = S_OK;
                try {

                    //
                    // Find the media node - updating the root node is useless
                    // since we need to change the media node contents.
                    //
                    CComPtr<ISakSnapAsk> pAsk;
                    CComPtr<ISakNode>    pNode;
                    WsbAffirmHr( GetSakSnapAsk( &pAsk ) );
                    WsbAffirmHr( pAsk->GetNodeOfType( cGuidMedSet, &pNode ) );

                    //
                    // Now notify the node
                    //
                    OnPropertyChange( m_Handle, pNode );

                } WsbCatch( hrUpdate );
            }
        }

        //
        // And run the job for the selected copy set
        //

        INT copyNum = m_pageSelect.m_List.GetSelectedSet( );
        WsbAffirmHr( RsCreateAndRunMediaCopyJob( pHsmServer, copyNum, FALSE ) );

    } WsbCatch( hr );

    m_HrFinish = hr;

    WsbTraceOut( L"CMediaCopyWizard::OnFinish", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardIntro property page

CMediaCopyWizardIntro::CMediaCopyWizardIntro() :
    CSakWizardPage_InitBaseExt( WIZ_CAR_COPY_INTRO )
{
    WsbTraceIn( L"CMediaCopyWizardIntro::CMediaCopyWizardIntro", L"" );
    //{{AFX_DATA_INIT(CMediaCopyWizardIntro)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CMediaCopyWizardIntro::CMediaCopyWizardIntro", L"" );
}

CMediaCopyWizardIntro::~CMediaCopyWizardIntro()
{
    WsbTraceIn( L"CMediaCopyWizardIntro::~CMediaCopyWizardIntro", L"" );
    WsbTraceOut( L"CMediaCopyWizardIntro::~CMediaCopyWizardIntro", L"" );
}

void CMediaCopyWizardIntro::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CMediaCopyWizardIntro::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CMediaCopyWizardIntro)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CMediaCopyWizardIntro::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CMediaCopyWizardIntro, CSakWizardPage)
    //{{AFX_MSG_MAP(CMediaCopyWizardIntro)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardIntro message handlers

BOOL CMediaCopyWizardIntro::OnInitDialog( )
{
    WsbTraceIn( L"CMediaCopyWizardIntro::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );
    
    WsbTraceOut( L"CMediaCopyWizardIntro::OnInitDialog", L"" );
    return TRUE;
}

BOOL CMediaCopyWizardIntro::OnSetActive( )
{
    WsbTraceIn( L"CMediaCopyWizardIntro::OnSetActive", L"" );
    m_pSheet->SetWizardButtons( PSWIZB_NEXT );
    
    BOOL retval = CSakWizardPage::OnSetActive( );

    WsbTraceOut( L"CMediaCopyWizardIntro::OnSetActive", L"" );
    return( retval );
}

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardSelect property page

CMediaCopyWizardSelect::CMediaCopyWizardSelect():
    CSakWizardPage_InitBaseInt( WIZ_CAR_COPY_SELECT ),
    m_List( this )

{
    WsbTraceIn( L"CMediaCopyWizardSelect::CMediaCopyWizardSelect", L"" );
    //{{AFX_DATA_INIT(CMediaCopyWizardSelect)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    WsbTraceOut( L"CMediaCopyWizardSelect::CMediaCopyWizardSelect", L"" );
}

CMediaCopyWizardSelect::~CMediaCopyWizardSelect()
{
    WsbTraceIn( L"CMediaCopyWizardSelect::~CMediaCopyWizardSelect", L"" );
    WsbTraceOut( L"CMediaCopyWizardSelect::~CMediaCopyWizardSelect", L"" );
}

void CMediaCopyWizardSelect::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CMediaCopyWizardSelect::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CMediaCopyWizardSelect)
    DDX_Control(pDX, IDC_COPY_LIST, m_List);
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CMediaCopyWizardSelect::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CMediaCopyWizardSelect, CSakWizardPage)
    //{{AFX_MSG_MAP(CMediaCopyWizardSelect)
    ON_CBN_SELCHANGE(IDC_COPY_LIST, OnSelchangeCopyList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardSelect message handlers


BOOL CMediaCopyWizardSelect::OnInitDialog( )
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );

    WsbTraceOut( L"CMediaCopyWizardSelect::OnInitDialog", L"" );
    return TRUE;
}

BOOL CMediaCopyWizardSelect::OnSetActive( )
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnSetActive", L"" );

    m_List.UpdateView( );
    SetButtons( );

    BOOL retval = CSakWizardPage::OnSetActive( );

    WsbTraceOut( L"CMediaCopyWizardSelect::OnSetActive", L"" );
    return( retval );
}

void
CMediaCopyWizardSelect::SetButtons()
{
    WsbTraceIn( L"CMediaCopyWizardSelect::SetButtons", L"" );

    INT curSel = m_List.GetSelectedSet( );
    if( curSel > 0 ) {

        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    } else {

        m_pSheet->SetWizardButtons( PSWIZB_BACK );

    }
    WsbTraceOut( L"CMediaCopyWizardSelect::SetButtons", L"" );
}

void CMediaCopyWizardSelect::OnSelchangeCopyList() 
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnSelchangeCopyList", L"" );

    SetButtons();
    
    WsbTraceOut( L"CMediaCopyWizardSelect::OnSelchangeCopyList", L"" );
}

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardFinish property page

CMediaCopyWizardFinish::CMediaCopyWizardFinish() :
    CSakWizardPage_InitBaseExt( WIZ_CAR_COPY_FINISH )
{
    WsbTraceIn( L"CMediaCopyWizardFinish::CMediaCopyWizardFinish", L"" );
    //{{AFX_DATA_INIT(CMediaCopyWizardFinish)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CMediaCopyWizardFinish::CMediaCopyWizardFinish", L"" );
}

CMediaCopyWizardFinish::~CMediaCopyWizardFinish()
{
    WsbTraceIn( L"CMediaCopyWizardFinish::~CMediaCopyWizardFinish", L"" );
    WsbTraceOut( L"CMediaCopyWizardFinish::~CMediaCopyWizardFinish", L"" );
}

void CMediaCopyWizardFinish::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CMediaCopyWizardFinish::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CMediaCopyWizardFinish)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CMediaCopyWizardFinish::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CMediaCopyWizardFinish, CSakWizardPage)
    //{{AFX_MSG_MAP(CMediaCopyWizardFinish)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardFinish message handlers




BOOL CMediaCopyWizardFinish::OnInitDialog( )
{
    WsbTraceIn( L"CMediaCopyWizardFinish::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );

//    GetDlgItem( IDC_REQUESTS_IN_NTMS )->SetFont( GetBoldShellFont( ) );

    WsbTraceOut( L"CMediaCopyWizardFinish::OnInitDialog", L"" );
    return TRUE;
}

BOOL CMediaCopyWizardFinish::OnSetActive( )
{
    HRESULT hrInternal = S_OK;
    WsbTraceIn( L"CMediaCopyWizardFinish::OnSetActive", L"" );
    BOOL fRet = CSakWizardPage::OnSetActive( );

    //
    // Update the text on the page according to what is selected.
    //

    CString tmpString, tmpString2, newText;
    USHORT numMediaCopies = 0, oldMediaCopies = 0;

    CMediaCopyWizard* pSheet = (CMediaCopyWizard*)m_pSheet;
    oldMediaCopies = pSheet->m_numMediaCopiesOrig;

    // If we were originally set to 0, then we must have a new setting
    // in the media copies page
    if( oldMediaCopies == 0 ) {

        hrInternal = pSheet->m_pageNumCopies.GetNumMediaCopies( &numMediaCopies );

    } else {

        numMediaCopies = oldMediaCopies;

    }

    //
    // If we are changing the number of media copies, show it here
    //

    if( ( S_OK == hrInternal ) && ( numMediaCopies != oldMediaCopies ) ) {

        tmpString.LoadString( IDS_WIZ_CAR_COPY_NEW_NUM );
        tmpString2.Format( tmpString, (INT)numMediaCopies, (INT)oldMediaCopies );

    }

    //
    // Grab the copy set description - make so that it fits within a sentence.
    //
    INT setNum = pSheet->m_pageSelect.m_List.GetSelectedSet( );
    tmpString.Format( L"%d", setNum );
    AfxFormatString2( newText, IDS_WIZ_CAR_COPY_SELECT, tmpString, tmpString2 );
    SetDlgItemText( IDC_SELECT_TEXT, newText );

    //
    // And fill in the task notification from the resource strings used
    // to present the dialog normally.
    //

    newText.LoadString( IDS_JOB_MEDIA_COPY_TITLE );
    tmpString.Format( newText, pSheet->m_pageSelect.m_List.GetSelectedSet( ) );

    CWsbStringPtr computerName;

    HRESULT hr = S_OK;
    try {

        CComPtr<IHsmServer> pHsmServer;
        WsbAffirmHrOk( m_pSheet->GetHsmServer( &pHsmServer ) );
        WsbAffirmHr( pHsmServer->GetName( &computerName ) );

    } WsbCatch( hr );

    AfxFormatString2( newText, IDS_WIZ_FINISH_RUN_JOB, tmpString, computerName );
    SetDlgItemText( IDC_TASK_TEXT, newText );

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
    
    WsbTraceOut( L"CMediaCopyWizardFinish::OnSetActive", L"" );
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardNumCopies property page

CMediaCopyWizardNumCopies::CMediaCopyWizardNumCopies() :
    CSakWizardPage_InitBaseInt( WIZ_CAR_COPY_NUM_COPIES )
{
    //{{AFX_DATA_INIT(CMediaCopyWizardNumCopies)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CMediaCopyWizardNumCopies::~CMediaCopyWizardNumCopies()
{
}

void CMediaCopyWizardNumCopies::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMediaCopyWizardNumCopies)
    DDX_Control(pDX, IDC_SPIN_MEDIA_COPIES, m_SpinMediaCopies);
    DDX_Control(pDX, IDC_EDIT_MEDIA_COPIES, m_EditMediaCopies);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMediaCopyWizardNumCopies, CSakWizardPage)
    //{{AFX_MSG_MAP(CMediaCopyWizardNumCopies)
    ON_EN_CHANGE(IDC_EDIT_MEDIA_COPIES, OnChangeEditMediaCopies)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardNumCopies message handlers

BOOL CMediaCopyWizardNumCopies::OnInitDialog() 
{
    CSakWizardPage::OnInitDialog();

    //
    // Set the limit on the spinner, and initial value.
    //
    CMediaCopyWizard* pSheet = (CMediaCopyWizard*)m_pSheet;

    m_SpinMediaCopies.SetRange (0, 3);
    m_SpinMediaCopies.SetPos( pSheet->m_numMediaCopiesOrig );
    m_EditMediaCopies.LimitText( 1 );

    return TRUE;
}

HRESULT CMediaCopyWizardNumCopies::GetNumMediaCopies( USHORT* pNumMediaCopies, USHORT* pEditMediaCopies )
{
    WsbTraceIn( L"CMediaCopyWizardSelect::GetNumMediaCopies", L"" );
    
    HRESULT hr = S_OK;

    BOOL translated = TRUE;
    UINT editVal = GetDlgItemInt( IDC_EDIT_MEDIA_COPIES, &translated );

    //
    // Need to be careful since we get called here before dialog object
    // is constructed
    //
    if( translated && m_SpinMediaCopies.m_hWnd ) {

        //
        // If Ok, always return what the spin says.
        //

        *pNumMediaCopies = (USHORT)m_SpinMediaCopies.GetPos( );
        if( pEditMediaCopies ) {

            *pEditMediaCopies = (USHORT)editVal;

        }
    }

    WsbTraceOut( L"CMediaCopyWizardNumCopies::GetNumMediaCopies", L"hr = <%ls>, *pNumMediaCopies = <%hd>", WsbHrAsString( hr ), *pNumMediaCopies  );
    return( hr );
}

void
CMediaCopyWizardNumCopies::SetButtons()
{
    WsbTraceIn( L"CMediaCopyWizardSelect::SetButtons", L"" );

    USHORT numMediaCopies = 0;
    GetNumMediaCopies( &numMediaCopies );

    if( numMediaCopies > 0 ) {

        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    } else {

        m_pSheet->SetWizardButtons( PSWIZB_BACK );

    }

    WsbTraceOut( L"CMediaCopyWizardNumCopies::SetButtons", L""  );
}


BOOL CMediaCopyWizardNumCopies::OnSetActive() 
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive();
    SetButtons();

    WsbTraceOut( L"CMediaCopyWizardNumCopies::OnSetActive", L""  );
    return( retval );
}

BOOL CMediaCopyWizardNumCopies::OnKillActive() 
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnKillActive", L"" );

    BOOL retval = FALSE;

    //
    // Need to handle  case where a user can enter a value within
    // the parameters of the number of digits allowed, but the value can
    // be out of range. This is detected by the spin box which will
    // return an error if its buddy control is out of range.
    //
    if( HIWORD( m_SpinMediaCopies.GetPos( ) ) > 0 ) {

        // Control reports on error...
        retval = FALSE;

        CString message;
        AfxFormatString2( message, IDS_ERR_COPYSET_RANGE, 
            CString( WsbLongAsString( (LONG)(HSMADMIN_MIN_COPY_SETS+1) ) ),
            CString( WsbLongAsString( (LONG)HSMADMIN_MAX_COPY_SETS ) ) );
        AfxMessageBox( message, MB_OK | MB_ICONWARNING );

    } else {

        retval = CSakWizardPage::OnKillActive();

    }

    WsbTraceOut( L"CMediaCopyWizardNumCopies::OnKillActive", L""  );
    return( retval );
}   


void CMediaCopyWizardNumCopies::OnChangeEditMediaCopies() 
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnChangeEditMediaCopies", L"" );

    SetButtons();

    WsbTraceOut( L"CMediaCopyWizardNumCopies::OnChangeEditMediaCopies", L""  );
}
/////////////////////////////////////////////////////////////////////////////
// CCopySetList

CCopySetList::CCopySetList( CMediaCopyWizardSelect * pPage )
{
    WsbTraceIn( L"CCopySetList::CCopySetList", L"" );

    for( INT index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

        m_CopySetInfo[index].m_Updated      = WsbLLtoFT( 0 );
        m_CopySetInfo[index].m_NumOutOfDate = 0;
        m_CopySetInfo[index].m_NumMissing   = 0;

    }

    m_pPage   = pPage;

    WsbTraceOut( L"CCopySetList::CCopySetList", L"" );
}

CCopySetList::~CCopySetList()
{
    WsbTraceIn( L"CCopySetList::~CCopySetList", L"" );
    WsbTraceOut( L"CCopySetList::~CCopySetList", L"" );
}


BEGIN_MESSAGE_MAP(CCopySetList, CListCtrl)
    //{{AFX_MSG_MAP(CCopySetList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCopySetList message handlers
void
CCopySetList::UpdateView(
    )
{
    WsbTraceIn( L"CCopySetList::UpdateView", L"" );
    HRESULT hr = S_OK;

    try {


        USHORT numMediaCopies;
        CMediaCopyWizard* pSheet = (CMediaCopyWizard*)(m_pPage->m_pSheet);
 
        //
        // Get the number of media copies from either the media copies
        // page or RMS.
        //
        if( pSheet->m_numMediaCopiesOrig == 0 ) {

            pSheet->m_pageNumCopies.GetNumMediaCopies( &numMediaCopies );

        } else {

            numMediaCopies = pSheet->m_numMediaCopiesOrig;

        }

        CString tmpString;

        INT oldCurSel = GetSelectedSet( );
        INT newCurSel = oldCurSel;
        LockWindowUpdate( );

        DeleteAllItems( );

        for( INT index = 0; index < numMediaCopies; index++ ) {

            //
            // Add the entries to each column
            //
            tmpString.Format( IDS_WIZ_CAR_COPY_SEL_TEXT, index + 1 );
            this->InsertItem( index, tmpString, 0 );
            tmpString.Format( L"%d", m_CopySetInfo[index].m_NumOutOfDate );
            this->SetItemText( index, m_UpdateCol, tmpString );
            tmpString.Format( L"%d", m_CopySetInfo[index].m_NumMissing );
            this->SetItemText( index, m_CreateCol, tmpString );

        }

        if( CB_ERR == oldCurSel ) {

            //
            // No selection before, find the most likely to need updating - most out of date
            //

            newCurSel = 1;
            FILETIME latestTime = WsbLLtoFT( (LONGLONG)-1 );

            for( INT index = 0; index < numMediaCopies; index++ ) {

                if( CompareFileTime( &latestTime, &(m_CopySetInfo[index].m_Updated) ) > 0 ) {

                    latestTime = m_CopySetInfo[index].m_Updated;
                    newCurSel  = index + 1;

                }

            }

        } else if( oldCurSel > numMediaCopies ) {

            newCurSel = numMediaCopies;

        }

        SelectSet( newCurSel );
        UnlockWindowUpdate( );

    } WsbCatch( hr );

    WsbTraceOut( L"CCopySetList::UpdateView", L"" );
}

INT
CCopySetList::GetSelectedSet(
    )
{
    INT retval = GetNextItem( -1, LVIS_SELECTED );

    if( CB_ERR != retval ) {

        retval++;

    }

    return( retval );
}

void
CCopySetList::SelectSet(
    INT SetNum
    )
{
    if( SetNum > 0 ) {

        SetItemState( SetNum - 1, LVIS_SELECTED, LVIS_SELECTED );

    }
}

void CCopySetList::PreSubclassWindow() 
{
    WsbTraceIn( L"CCopySetList::PreSubclassWindow", L"" );
    HRESULT hr = S_OK;

    CComPtr<IWsbDb> pDb;
    CComPtr<IWsbDbSession> pDbSession;
    CComPtr<IMediaInfo> pMediaInfo;

    try {

        //
        // Set the style appropriately
        //
        ListView_SetExtendedListViewStyle( GetSafeHwnd( ), LVS_EX_FULLROWSELECT );

        //
        // Also need to calculate some buffer space
        // Use 4 dialog units (for numeral)
        //
        CRect padRect( 0, 0, 8, 8 );
        m_pPage->MapDialogRect( padRect );

        //
        // Set up columns
        //
        INT column = 0;
        CString titleString;
        LVCOLUMN lvc;
        memset( &lvc, 0, sizeof( lvc ) );
        lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lvc.fmt  = LVCFMT_CENTER;


        m_CopySetCol = column;
        titleString.LoadString( IDS_COPYSET_COPYSET );
        lvc.cx      = GetStringWidth( titleString ) + padRect.Width( ) * 2;
        lvc.pszText = (LPTSTR)(LPCTSTR)titleString;
        InsertColumn( m_CopySetCol, &lvc );
        column++;

        m_UpdateCol = column;
        titleString.LoadString( IDS_COPYSET_OUT_OF_DATE );
        lvc.cx      = GetStringWidth( titleString ) + padRect.Width( );
        lvc.pszText = (LPTSTR)(LPCTSTR)titleString;
        InsertColumn( m_UpdateCol, &lvc );
        column++;

        m_CreateCol = column;
        titleString.LoadString( IDS_COPYSET_DO_NOT_EXIST );
        lvc.cx      = GetStringWidth( titleString ) + padRect.Width( );
        lvc.pszText = (LPTSTR)(LPCTSTR)titleString;
        InsertColumn( m_CreateCol, &lvc );
        column++;

        //
        // Hook up to DB and get info
        //

        CComPtr<IHsmServer> pHsmServer;
        CComPtr<IRmsServer> pRmsServer;
        WsbAffirmHrOk( m_pPage->m_pSheet->GetHsmServer( &pHsmServer ) );
        WsbAffirmHrOk( m_pPage->m_pSheet->GetRmsServer( &pRmsServer ) );

        CMediaInfoObject mio;
        mio.Initialize( GUID_NULL, pHsmServer, pRmsServer );

        HRESULT hrEnum = mio.First( );
        WsbAffirm( SUCCEEDED( hrEnum ) || ( WSB_E_NOTFOUND == hrEnum ), hrEnum );

        while( SUCCEEDED( hrEnum ) ) {

            if( S_OK == mio.IsViewable( FALSE ) ) {

                for( INT index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                    if( S_OK != mio.DoesCopyExist( index ) ) {

                        m_CopySetInfo[index].m_NumMissing++;

                    } else {

                        //
                        // And check to see if out of date
                        //
                        if( S_OK != mio.IsCopyInSync( index ) ) {

                            m_CopySetInfo[index].m_NumOutOfDate++;

                        }

                        //
                        // Look for latest date of update per set
                        //
                        if( CompareFileTime( &(m_CopySetInfo[index].m_Updated), &(mio.m_CopyInfo[index].m_ModifyTime) ) < 0 ) {

                            m_CopySetInfo[index].m_Updated = (mio.m_CopyInfo[index].m_ModifyTime);

                        }

                    }

                }
            }


            hrEnum = mio.Next( );
        }
    
    } WsbCatch( hr );

    CListCtrl::PreSubclassWindow();

    WsbTraceOut( L"CCopySetList::PreSubclassWindow", L"" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\device\prmedset.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrMedSet.h

Abstract:

    Media Set Property Pages.

Author:

    Rohde Wakefield [rohde]   15-Sep-1997

Revision History:

--*/

#ifndef _PRMEDSET_H
#define _PRMEDSET_H

/////////////////////////////////////////////////////////////////////////////
// CPrMedSet dialog

class CPrMedSet : public CSakPropertyPage
{
// Construction
public:
    CPrMedSet();
    ~CPrMedSet();

// Dialog Data
    //{{AFX_DATA(CPrMedSet)
    enum { IDD = IDD_PROP_MEDIA_COPIES };
    CSpinButtonCtrl m_spinMediaCopies;
    UINT    m_numMediaCopies;
    CString m_szDescription;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrMedSet)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrMedSet)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditMediaCopies();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CComPtr<IHsmStoragePool> m_pStoragePool;
    CComPtr<IRmsServer>      m_pRmsServer;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\device\prmedset.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrMedSet.cpp

Abstract:

    Media Set Property Page.

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PrMedSet.h"
#include "WzMedSet.h"

static DWORD pHelpIds[] = 
{

    IDC_EDIT_MEDIA_COPIES,      idh_media_number_of_copy_sets,
    IDC_SPIN_MEDIA_COPIES,      idh_media_number_of_copy_sets,
    IDC_TEXT_MEDIA_COPIES,      idh_media_number_of_copy_sets,

    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPrMedSet property page

CPrMedSet::CPrMedSet() : CSakPropertyPage(CPrMedSet::IDD)
{
    //{{AFX_DATA_INIT(CPrMedSet)
    m_numMediaCopies = 0;
    //}}AFX_DATA_INIT
    m_pHelpIds = pHelpIds;
}

CPrMedSet::~CPrMedSet()
{
}

void CPrMedSet::DoDataExchange(CDataExchange* pDX)
{
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrMedSet)
    DDX_Control(pDX, IDC_SPIN_MEDIA_COPIES, m_spinMediaCopies);
    DDX_Text(pDX, IDC_EDIT_MEDIA_COPIES, m_numMediaCopies);
    DDV_MinMaxUInt(pDX, m_numMediaCopies, 0, 3);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPrMedSet, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPrMedSet)
    ON_WM_DESTROY()
    ON_EN_CHANGE(IDC_EDIT_MEDIA_COPIES, OnChangeEditMediaCopies)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrMedSet message handlers

BOOL CPrMedSet::OnInitDialog() 
{
    HRESULT hr = S_OK;
    HRESULT hrSupported = S_OK;
    CSakPropertyPage::OnInitDialog();
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        //
        // Set the limit on the spinner
        //
        m_spinMediaCopies.SetRange( 0, 3 );

        //
        // Get the single storage pool pointer
        //
        CComPtr<IHsmServer> pEngine;
        WsbAffirmHr( m_pParent->GetHsmServer( &pEngine ) );
        WsbAffirmHr( RsGetStoragePool( pEngine, &m_pStoragePool ) );
        WsbAffirmHr( m_pParent->GetRmsServer( &m_pRmsServer ) );

        GUID mediaSetId;
        CWsbBstrPtr mediaName;
        WsbAffirmHr( m_pStoragePool->GetMediaSet( &mediaSetId, &mediaName ) );

        CComPtr<IRmsMediaSet> pMediaSet;
        WsbAffirmHr( m_pRmsServer->CreateObject( mediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void**)&pMediaSet ) );

        //
        // Set up control states
        // If we support media copies, enable controls
        // If we don't support media copies, disable and show reason text
        // If error, disable and don't show reason text
        //
        hrSupported = pMediaSet->IsMediaCopySupported( );
        GetDlgItem( IDC_TEXT_MEDIA_COPIES )->EnableWindow( S_OK == hrSupported );
        GetDlgItem( IDC_EDIT_MEDIA_COPIES )->EnableWindow( S_OK == hrSupported );
        GetDlgItem( IDC_SPIN_MEDIA_COPIES )->EnableWindow( S_OK == hrSupported );

        //
        // And initialize control
        //
        USHORT numMediaCopies;
        WsbAffirmHr( m_pStoragePool->GetNumMediaCopies( &numMediaCopies ) );
        m_numMediaCopies = numMediaCopies;
        UpdateData( FALSE );

    } WsbCatch( hr );

    GetDlgItem( IDC_TEXT_DISABLED )->ShowWindow( S_FALSE == hrSupported ? SW_SHOW : SW_HIDE );
    return TRUE;
}

void CPrMedSet::OnChangeEditMediaCopies() 
{
    SetModified( TRUE );
}

BOOL CPrMedSet::OnApply() 
{
    HRESULT hr = 0;

    UpdateData( TRUE );
    try {

        WsbAffirmHr( m_pStoragePool->SetNumMediaCopies( (USHORT)m_numMediaCopies ) );
        
        //
        // Tell it to save
        //
        CComPtr<IHsmServer> pServer;
        WsbAffirmHr( m_pParent->GetHsmServer( &pServer ) );
        WsbAffirmHr( pServer->SavePersistData( ) );

        //
        // Find the media node - updating the root node is useless
        // since we need to change the media node contents.
        //
        CComPtr<ISakSnapAsk> pAsk;
        CComPtr<ISakNode>    pNode;
        WsbAffirmHr( m_pParent->GetSakSnapAsk( &pAsk ) );
        WsbAffirmHr( pAsk->GetNodeOfType( cGuidMedSet, &pNode ) );

        //
        // Now notify the nodes
        //
        m_pParent->OnPropertyChange( m_hConsoleHandle, pNode );

    } WsbCatch( hr );

    return CSakPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\ielist.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    IeList.cpp

Abstract:

    CIeList is a subclassed (owner-draw) list control that groups items into
    a 3D panel that have the same information in the indicated 
    sortColumn.

    The panels are created from tiles.  Each tile corresponds to one subitem
    in the list, and has the appropriate 3D edges so that the tiles together
    make up a panel.

    NOTE: The control must be initialized with the number of columns and the
    sort column.  The parent dialog must implement OnMeasureItem and call
    GetItemHeight to set the row height for the control.

Author:

    Art Bragg [artb]   01-DEC-1997

Revision History:

--*/

#include "stdafx.h"
#include "IeList.h"

// Position of a tile in it's panel
#define POS_LEFT        100
#define POS_RIGHT       101
#define POS_TOP         102
#define POS_BOTTOM      103
#define POS_MIDDLE      104
#define POS_SINGLE      105


/////////////////////////////////////////////////////////////////////////////
// CIeList

BEGIN_MESSAGE_MAP(CIeList, CListCtrl)
    //{{AFX_MSG_MAP(CIeList)
    ON_NOTIFY_REFLECT(NM_CLICK, OnClick)
    ON_WM_SETFOCUS()
    ON_WM_KILLFOCUS()
    //}}AFX_MSG_MAP
    ON_WM_SYSCOLORCHANGE()

END_MESSAGE_MAP()

CIeList::CIeList()
/*++

Routine Description:

    Sets default dimensions for the control.

Arguments:

    none.

Return Value:

    none.

--*/
{
    //
    // Initializations
    //
    m_ColCount = 0;
    m_SortCol = 0;
    m_pVertPos = NULL;
    //
    // Drawing dimensions
    //
    // If these are altered, the visual aspects of the control
    // should be checked (especially the focus rectangle), 
    // as some minor adjustments may need to be made.
    //
    m_VertRaisedSpace           = 1;
    m_BorderThickness           = 2;
    m_VerticalTextOffsetTop     = 1;

    // The text height will be set later (based on the font size)
    m_Textheight                = 0;
    m_VerticalTextOffsetBottom  = 1;

    // Total height will be set later
    m_TotalHeight               = 0;
    m_HorzRaisedSpace           = 1;
    m_HorzTextOffset            = 3;

}

CIeList::~CIeList()
/*++

Routine Description:

    Cleanup.

Arguments:

    none.

Return Value:

    none.

--*/
{
    // Cleanup the array of vertical positions
    if( m_pVertPos ) free ( m_pVertPos );
}

/////////////////////////////////////////////////////////////////////////////
// CIeList message handlers

void CIeList::Initialize( 
    IN int colCount, 
    IN int sortCol 
    )
/*++

Routine Description:

    Sets the number of columns (not easily available from MFC) and
    the sort column.

Arguments:

    colCount        - number of columns to display
    sortCol         - column to sort on

Return Value:

    none.

--*/
{

    m_ColCount = colCount;
    m_SortCol = sortCol;
}

void CIeList::DrawItem(
    IN LPDRAWITEMSTRUCT lpDrawItemStruct
    ) 
/*++

Routine Description:

    This is the callback for an owner draw control.
    Draws the appropriate text and/or 3D lines depending on the
    item number and clipping rectangle supplied by MFC in lpDrawItemStruct 

Arguments:

    lpDrawItemStruct - MFC structure that tells us what and where to draw

Return Value:

    none.

--*/
{
    CDC dc;
    int saveDc;

    int colWidth = 0;                   // Width of current column
    int horzPos = POS_MIDDLE;           // Horz position in the panel
    int vertPos = POS_SINGLE;           // Vert position in the panel
    BOOL bSelected = FALSE;             // Is this item selected
    CRect rcAllLabels;                  // Used to find left position of focus rectangle
    CRect itemRect;                     // Rectangle supplied in lpDrawItemStruct
    CRect textRect;                     // Rectangle for text
    CRect boxRect;                      // Rectangle for 3D box (the panel)
    CRect clipRect;                     // Current clipping rectangle
    LPTSTR pszText;                    // Text to display
    COLORREF clrTextSave = 0;           // Save the current color
    COLORREF clrBkSave = 0;             // Save the background color
    int leftStart = 0;                  // Left edge of where we're currently drawing
    BOOL bFocus = (GetFocus() == this); // Do we have focus?

    //
    // Get the current scroll position
    //
    int nHScrollPos = GetScrollPos( SB_HORZ );

    //
    // Get the item ID from the list for the item we're drawing
    //
    int itemID = lpDrawItemStruct->itemID;

    //
    // Get item data for the item we're drawing
    //
    LV_ITEM lvi;
    lvi.mask = LVIF_IMAGE | LVIF_STATE;
    lvi.iItem = itemID;
    lvi.iSubItem = 0;
    lvi.stateMask = 0xFFFF;     // get all state flags
    GetItem(&lvi);

    //
    // Determine focus and selected states
    //
    bSelected = (bFocus || (GetStyle() & LVS_SHOWSELALWAYS)) && lvi.state & LVIS_SELECTED;

    //
    // Get the rectangle to draw in
    //
    itemRect = lpDrawItemStruct->rcItem;

    dc.Attach( lpDrawItemStruct->hDC );
    saveDc = dc.SaveDC();
    //
    // Get the clipping rectangle - we use it's vertical edges
    // to optimize what we draw
    //
    dc.GetClipBox( &clipRect );
    boxRect = clipRect;

    //
    // For each column, paint it's text and the section of the 3D panel
    //
    for ( int col = 0; col < m_ColCount; col++ ) {

        colWidth = GetColumnWidth( col );
        //
        // Only paint this column if it's in the clipping rectangle
        //
        if( ( ( leftStart + colWidth ) > clipRect.left ) || ( leftStart < clipRect.right ) ) {

            //
            // Determine the horizontal position based on the column
            //
            horzPos = POS_MIDDLE;
            if( col == 0 )                  horzPos = POS_LEFT;
            if( col == m_ColCount - 1 )     horzPos = POS_RIGHT;

            //
            // Calculate the rectangle for this tile
            //
            boxRect.top = itemRect.top;
            boxRect.bottom = itemRect.bottom;
            boxRect.left = itemRect.left + leftStart;
            boxRect.right = itemRect.left + leftStart + colWidth;

            //
            // Get the vertical position from the array.  It was saved there
            // during SortItem for performance reasons.
            //
            if( m_pVertPos ) { 

                vertPos = m_pVertPos[ itemID ];

            }

            //
            // Draw the tile for this item.
            //
            Draw3dRectx ( &dc, boxRect, horzPos, vertPos, bSelected );

            //
            // If this item is selected, change the text colors
            //
            if( bSelected ) {

                clrTextSave = dc.SetTextColor( m_clrHighlightText );
                clrBkSave = dc.SetBkColor( m_clrHighlight );

            }

            //
            // Calculate the text rectangle
            //
            textRect.top =      itemRect.top + m_VertRaisedSpace + m_BorderThickness + m_VerticalTextOffsetTop;
            textRect.bottom =   itemRect.bottom;    // Text is top justified, no need to adjust bottom
            textRect.left =     leftStart - nHScrollPos + m_HorzRaisedSpace + m_BorderThickness + m_HorzTextOffset;
            textRect.right =    itemRect.right;

            //
            // Get the text and put in the "..." if we need them
            //
            CString pszLongText = GetItemText( itemID, col );
            pszText = NULL;
            MakeShortString(&dc, (LPCTSTR) pszLongText,
                textRect.right - textRect.left, 4, &pszText);
            BOOL bFree = TRUE;
            if (pszText == NULL) {
                // Failure of some kind...
                pszText = (LPTSTR)(LPCTSTR)pszLongText;
                bFree = FALSE;
            }

            //
            // Now draw the text using the correct color
            //
            COLORREF saveTextColor;
            if( bSelected ) {

                saveTextColor = dc.SetTextColor( m_clrHighlightText );

            } else {

                saveTextColor = dc.SetTextColor( m_clrText );

            }
            int textheight = dc.DrawText( pszText, textRect, DT_NOCLIP | DT_LEFT | DT_TOP | DT_SINGLELINE  );
            dc.SetTextColor( saveTextColor );

            if (pszText && bFree) {
                free(pszText);
            }

        }

        //
        // Move to the next column
        //
        leftStart += colWidth;
    }
    //
    // draw focus rectangle if item has focus.  Use LVIR_BOUNDS rectangle
    // to bound it.
    //
    GetItemRect(itemID, rcAllLabels, LVIR_BOUNDS);
    if( lvi.state & LVIS_FOCUSED && bFocus ) {

        CRect focusRect;
        focusRect.left = rcAllLabels.left + m_HorzRaisedSpace + m_BorderThickness;
        focusRect.right = min( rcAllLabels.right, (itemRect.right - m_HorzRaisedSpace * 2 - 3) );
        focusRect.top = boxRect.top + m_VertRaisedSpace + m_BorderThickness;
        focusRect.bottom = boxRect.top + m_TotalHeight - m_BorderThickness + 1;

        dc.DrawFocusRect( focusRect );

    }

    // Restore colors
    if( bSelected ) {

        dc.SetTextColor( clrTextSave );
        dc.SetBkColor( clrBkSave );

    }

    dc.RestoreDC( saveDc );
    dc.Detach();
}


void CIeList::MakeShortString(
    IN CDC* pDC, 
    IN LPCTSTR lpszLong, 
    IN int nColumnLen, 
    IN int nDotOffset,
    OUT LPTSTR *ppszShort
    )
/*++

Routine Description:

    Determines it the supplied string fits in it's column.  If not truncates
    it and adds "...".  From MS sample code.

Arguments:

    pDC         - Device context
    lpszLong    - Original String
    nColumnLen  - Width of column
    nDotOffset  - Space before dots

Return Value:

    Shortened string

--*/
{
    static const _TCHAR szThreeDots[] = _T("...");

    int nStringLen = lstrlen(lpszLong);

    *ppszShort = (_TCHAR *)malloc((nStringLen + 1) * sizeof(_TCHAR) + sizeof(szThreeDots));
    if (*ppszShort == NULL)
        return;

    _TCHAR *szShort = *ppszShort;
    if(nStringLen == 0) {
        lstrcpy(szShort, _T(""));
    } else {
        lstrcpy(szShort, lpszLong);
    }

    if(nStringLen == 0 ||
        (pDC->GetTextExtent(lpszLong, nStringLen).cx + nDotOffset) <= nColumnLen)
    {
        // return long format
        return;
    }

    int nAddLen = pDC->GetTextExtent(szThreeDots,sizeof(szThreeDots)).cx;

    for(int i = nStringLen-1; i > 0; i--)
    {
        szShort[i] = 0;
        if((pDC->GetTextExtent(szShort, i).cx + nDotOffset + nAddLen)
            <= nColumnLen)
        {
            break;
        }
    }

    lstrcat(szShort, szThreeDots);
    return;
}

void CIeList::Draw3dRectx ( 
    IN CDC *pDc, 
    IN CRect &rect, 
    IN int horzPos, 
    IN int vertPos, 
    IN BOOL bSelected 
) 
/*++

Routine Description:

    Draws the appropriate portion (tile) of a panel for a given cell in the
    list.  The edges of the panel portion are determined by the horzPos
    and vertPos parameters.

Arguments:

    pDc         - Device context
    rect        - Rectangle to draw the panel portion in
    horzPos     - Where the portion is horizontally
    vertPos     - Where the portion is vertically
    bSelected   - Is the item selected

Return Value:

    none.

--*/

{

    CPen *pSavePen;
    int topOffset = 0;
    int rightOffset = 0;
    int leftOffset = 0;

    //
    // If a given edge of the tile is to be drawn, set an offset to that
    // edge.  If we don't draw a given edge, the offset is 0.
    //
    switch ( horzPos )
    {
    case POS_LEFT:
        leftOffset = m_HorzRaisedSpace;
        rightOffset = 0;
        break;
    case POS_MIDDLE:
        leftOffset = 0;
        rightOffset = 0;
        break;
    case POS_RIGHT:
        leftOffset = 0;
        rightOffset = m_HorzRaisedSpace + 3;
        break;
    }
    
    switch ( vertPos )
    {

    case POS_TOP:
        topOffset = m_VertRaisedSpace;
        break;
    case POS_MIDDLE:
        topOffset = 0;
        break;
    case POS_BOTTOM:
        topOffset = 0;
        break;
    case POS_SINGLE:
        topOffset = m_VertRaisedSpace;
        break;

    }
    //
    // Erase 
    //
    if( !bSelected ) pDc->FillSolidRect( rect, m_clrBkgnd );
    //
    // Highlight the selected area
    //
    if (bSelected)
    {
        CRect selectRect;
        if (leftOffset == 0)
            selectRect.left = rect.left;
        else
            selectRect.left = rect.left + leftOffset + m_BorderThickness;
        if (rightOffset == 0)
            selectRect.right = rect.right;
        else
            selectRect.right = rect.right - rightOffset - m_BorderThickness + 1;
        selectRect.top = rect.top + m_VertRaisedSpace + m_BorderThickness;
        selectRect.bottom = rect.top + m_TotalHeight - m_BorderThickness + 1;

        pDc->FillSolidRect( selectRect, m_clrHighlight );
    }

    // Select a pen to save the original pen
    pSavePen = pDc->SelectObject( &m_ShadowPen );

    // left edge
    if( horzPos == POS_LEFT ) {
        // Outside lighter line
        pDc->SelectObject( &m_ShadowPen );
        pDc->MoveTo( rect.left + leftOffset, rect.top + topOffset );
        pDc->LineTo( rect.left + leftOffset, rect.top + m_TotalHeight + 1);
        // Inside edge - darker line
        pDc->SelectObject( &m_DarkShadowPen );
        pDc->MoveTo( rect.left + leftOffset + 1, rect.top + topOffset);
        pDc->LineTo( rect.left + leftOffset + 1, rect.top + m_TotalHeight + 1);
    }
    // right edge
    if( horzPos == POS_RIGHT ) {
        // Outside line
        pDc->SelectObject( &m_HiLightPen );
        pDc->MoveTo( rect.right - rightOffset, rect.top + topOffset );
        pDc->LineTo( rect.right - rightOffset, rect.top + m_TotalHeight + 1 );
        // Inside line
        pDc->SelectObject( &m_LightPen );// note - this is usually the same color as btnface
        if( vertPos == POS_TOP )
            pDc->MoveTo( rect.right - rightOffset - 1, rect.top + topOffset + 1 );
        else
            pDc->MoveTo( rect.right - rightOffset - 1, rect.top + topOffset );
        pDc->LineTo( rect.right - rightOffset - 1, rect.top + m_TotalHeight + 2 );
    }
    // top edge
    if( ( vertPos == POS_TOP ) || ( vertPos == POS_SINGLE ) ) {
        // Outside lighter
        pDc->SelectObject( &m_ShadowPen );
        pDc->MoveTo( rect.left + leftOffset, rect.top + topOffset );
        pDc->LineTo( rect.right - rightOffset + 1, rect.top + topOffset );
        // Inside edge darker
        pDc->SelectObject( &m_DarkShadowPen );
        if( horzPos == POS_LEFT )
            pDc->MoveTo( rect.left + leftOffset + 1, rect.top + topOffset + 1 );
        else
            pDc->MoveTo( rect.left + leftOffset - 3, rect.top + topOffset + 1 );
        pDc->LineTo( rect.right - rightOffset, rect.top + topOffset + 1);
    }
    // bottom edge
    if( ( vertPos == POS_BOTTOM ) || ( vertPos == POS_SINGLE ) ) {
        // Outside line
        pDc->SelectObject( &m_HiLightPen );
        if( horzPos == POS_LEFT )
            pDc->MoveTo( rect.left + leftOffset + 1, rect.top + m_TotalHeight );
        else
            pDc->MoveTo( rect.left + leftOffset - 1, rect.top + m_TotalHeight );
        pDc->LineTo( rect.right - rightOffset, rect.top + m_TotalHeight );
        // Inside line
        pDc->SelectObject( &m_LightPen );
        if( horzPos == POS_LEFT )
            pDc->MoveTo( rect.left + leftOffset + 2, rect.top + m_TotalHeight - 1 );
        else
            pDc->MoveTo( rect.left + leftOffset - 2, rect.top + m_TotalHeight - 1 );
        pDc->LineTo( rect.right - rightOffset - 1, rect.top + m_TotalHeight - 1 );

    }
    pDc->SelectObject( pSavePen );

}

void CIeList::OnClick(
    NMHDR* /* pNMHDR */, LRESULT* pResult
) 
/*++

Routine Description:
    When the list is clicked, we invalidate the 
    rectangle for the currently selected item

Arguments:

    pResult     - ununsed

Return Value:

    none.

--*/
{
    CRect rect;

    // Get the selected item
    int curIndex = GetNextItem( -1, LVNI_SELECTED );
    if( curIndex != -1 ) {
        GetItemRect( curIndex, &rect, LVIR_BOUNDS );
        InvalidateRect( rect );
        UpdateWindow();
    }

    *pResult = 0;
}
/*++

Routine Description:
    Repaint the currently selected item if the style is LVS_SHOWSELALWAYS.

Arguments:

    none.

Return Value:

    none.

--*/

void CIeList::RepaintSelectedItems()
{
    CRect rcItem, rcLabel;
    //
    // invalidate focused item so it can repaint properly
    //
    int nItem = GetNextItem(-1, LVNI_FOCUSED);

    if(nItem != -1)
    {
        GetItemRect(nItem, rcItem, LVIR_BOUNDS);
        GetItemRect(nItem, rcLabel, LVIR_LABEL);
        rcItem.left = rcLabel.left;

        InvalidateRect(rcItem, FALSE);
    }
    //
    // if selected items should not be preserved, invalidate them
    //
    if(!(GetStyle() & LVS_SHOWSELALWAYS))
    {
        for(nItem = GetNextItem(-1, LVNI_SELECTED);
            nItem != -1; nItem = GetNextItem(nItem, LVNI_SELECTED))
        {
            GetItemRect(nItem, rcItem, LVIR_BOUNDS);
            GetItemRect(nItem, rcLabel, LVIR_LABEL);
            rcItem.left = rcLabel.left;

            InvalidateRect(rcItem, FALSE);
        }
    }

    // update changes 

    UpdateWindow();
}

int CIeList::GetItemHeight(
    IN LONG fontHeight
    ) 
/*++

Routine Description:
    Calculates the item height (the height of each drawing
    rectangle in the control) based on the supplied fontHeight.  This
    function is used by the parent to set the item height for the
    control.

Arguments:

    fontHeight - The height of the current font.

Return Value:

    Item height.

--*/

{


     int itemHeight = 
         m_VertRaisedSpace +
         m_BorderThickness +
         m_VerticalTextOffsetTop +
         fontHeight +
         2 +
         m_VerticalTextOffsetBottom +
         m_BorderThickness + 
         1;
     return itemHeight;
    
}

void CIeList::OnSetFocus(
    CWnd* pOldWnd
    ) 
/*++

Routine Description:
    Repaint the selected item.

Arguments:

    pOldWnd - Not used by this function

Return Value:

    none

--*/
{
    CListCtrl::OnSetFocus(pOldWnd);
    
    // repaint items that should change appearance
    RepaintSelectedItems();
        
}

void CIeList::OnKillFocus(
    CWnd* pNewWnd
) 
/*++

Routine Description:
    Repaint the selected item.

Arguments:

    pOldWnd - Not used by this function

Return Value:

    none

--*/
{
    CListCtrl::OnKillFocus(pNewWnd);
    
    // repaint items that should change appearance
    RepaintSelectedItems();
}

void CIeList::PreSubclassWindow() 
/*++

Routine Description:
    Calculate height parameters based on the font size.  Set
    colors for the control.

Arguments:

    none.

Return Value:

    none

--*/
{
    CFont *pFont;
    LOGFONT logFont; 

    pFont = GetFont( );
    pFont->GetLogFont( &logFont );

    LONG fontHeight = abs ( logFont.lfHeight );

    m_Textheight = fontHeight + 2;

    m_TotalHeight = 
         m_VertRaisedSpace +
         m_BorderThickness +
         m_VerticalTextOffsetTop +
         m_Textheight +
         m_VerticalTextOffsetBottom +
         m_BorderThickness; 

    SetColors();
    CListCtrl::PreSubclassWindow();
}

void CIeList::OnSysColorChange() 
/*++

Routine Description:
    Set the system colors and invalidate the control.

Arguments:

    none.

Return Value:

    none

--*/
{
    SetColors();
    Invalidate();
}

void CIeList::SetColors()
/*++

Routine Description:
    Store the system colors and create pens.

Arguments:

    none.

Return Value:

    none

--*/
{

    // Text colors
    m_clrText =             ::GetSysColor(COLOR_WINDOWTEXT);
    m_clrTextBk =           ::GetSysColor(COLOR_BTNFACE);
    m_clrBkgnd =            ::GetSysColor(COLOR_BTNFACE);
    m_clrHighlightText =    ::GetSysColor(COLOR_HIGHLIGHTTEXT);
    m_clrHighlight  =       ::GetSysColor(COLOR_HIGHLIGHT);

    // Line colors
    m_clr3DDkShadow =       ::GetSysColor( COLOR_3DDKSHADOW );
    m_clr3DShadow =         ::GetSysColor( COLOR_3DSHADOW );
    m_clr3DLight =          ::GetSysColor( COLOR_3DLIGHT );
    m_clr3DHiLight =        ::GetSysColor( COLOR_3DHIGHLIGHT );

    SetBkColor( m_clrBkgnd );
    SetTextColor( m_clrText );
    SetTextBkColor( m_clrTextBk );

    // Pens for 3D rectangles
    if( m_DarkShadowPen.GetSafeHandle() != NULL )
        m_DarkShadowPen.DeleteObject();
    m_DarkShadowPen.CreatePen ( PS_SOLID, 1, m_clr3DDkShadow );

    if( m_ShadowPen.GetSafeHandle() != NULL )
        m_ShadowPen.DeleteObject();
    m_ShadowPen.CreatePen ( PS_SOLID, 1, m_clr3DShadow );

    if( m_LightPen.GetSafeHandle() != NULL )
        m_LightPen.DeleteObject();
    m_LightPen.CreatePen ( PS_SOLID, 1, m_clr3DLight );

    if( m_HiLightPen.GetSafeHandle() != NULL )
        m_HiLightPen.DeleteObject();
    m_HiLightPen.CreatePen ( PS_SOLID, 1, m_clr3DHiLight );

}

BOOL CIeList::SortItems( 
    IN PFNLVCOMPARE pfnCompare, 
    IN DWORD dwData 
    )
/*++

Routine Description:
    Override for SortItems.  Checks the text of the sortColumn
    for each line in the control against it's neighbors (above and
    below) and assigns each line a position within it's panel.

Arguments:

    pfnCompare          - sort callback function
    dwData              - Unused

Return Value:

    TRUE, FALSE

--*/
{
    BOOL retVal = FALSE;
    BOOL bEqualAbove = FALSE;
    BOOL bEqualBelow = FALSE;
    CString thisText;
    CString aboveText;
    CString belowText;

    int numItems = GetItemCount();
    //
    // Call the base class to sort the items
    //
    if( CListCtrl::SortItems( pfnCompare, dwData ) ) {
        //
        // Get the vertical position (position within a panel) by comparing the text
        // of the sort column and stash it in the array of vertical positions
        //
        if( m_pVertPos ) {

            free( m_pVertPos );

        }
        m_pVertPos = (int *) malloc( numItems * sizeof( int ) );
        if( m_pVertPos ) {

            retVal = TRUE;

            for( int itemID = 0; itemID < numItems; itemID++ ) {
                //
                // Get the text of the item and it's neighbors
                //
                thisText = GetItemText( itemID, m_SortCol );
                aboveText = GetItemText( itemID - 1, m_SortCol );
                belowText = GetItemText( itemID + 1, m_SortCol );
                //
                // Set booleans for the relationship of this item to it's
                // neighbors
                //
                if( ( itemID == 0) || (  thisText.CompareNoCase( aboveText ) != 0 ) ){

                    bEqualAbove = FALSE;

                } else {

                    bEqualAbove = TRUE;

                }
                if( ( itemID == GetItemCount() - 1 ) || ( thisText.CompareNoCase( belowText ) != 0 ) ) {

                    bEqualBelow = FALSE;

                } else {

                    bEqualBelow = TRUE;

                }
                //
                // Determine the position in the panel
                //
                if      ( bEqualAbove && bEqualBelow )  m_pVertPos[ itemID ] = POS_MIDDLE;
                else if( bEqualAbove && !bEqualBelow ) m_pVertPos[ itemID ] = POS_BOTTOM;
                else if( !bEqualAbove && bEqualBelow ) m_pVertPos[ itemID ] = POS_TOP;
                else                                    m_pVertPos[ itemID ] = POS_SINGLE;
            }
        }
    }
    return( retVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\ielist.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    IeList.h

Abstract:

    CIeList is a subclassed (owner-draw) list control that groups items into
    a 3D panel that have the same information in the indicated 
    sortColumn.

    The panels are created from tiles.  Each tile corresponds to one subitem
    in the list, and has the appropriate 3D edges so that the tiles together
    make up a panel.

    NOTE: The control must be initialized with the number of columns and the
    sort column.  The parent dialog must implement OnMeasureItem and call
    GetItemHeight to set the row height for the control.

Author:

    Art Bragg [artb]   01-DEC-1997

Revision History:

--*/


#ifndef IELIST_H
#define IELIST_H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CIeList window

class CIeList : public CListCtrl
{

// Construction
public:
    CIeList();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CIeList)
    protected:
    virtual void PreSubclassWindow();
    //}}AFX_VIRTUAL

    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
    virtual ~CIeList();
    int GetItemHeight( LONG fontHeight );
    BOOL SortItems( PFNLVCOMPARE pfnCompare, DWORD dwData );

    // Generated message map functions
protected:
    //{{AFX_MSG(CIeList)
    afx_msg void OnClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    //}}AFX_MSG
    afx_msg void OnSysColorChange();
    DECLARE_MESSAGE_MAP()

private:
    // functions
    void Draw3dRectx ( CDC *pDc, CRect &rect, int horzPos, int vertPos, BOOL bSelected );
    void SetColors();
    void CIeList::MakeShortString(CDC* pDC, LPCTSTR lpszLong, int nColumnLen, int nOffset, LPTSTR *ppszShort);
    void RepaintSelectedItems();

    // Dimensions for creating panels (in pixels)
    int m_VertRaisedSpace;              // Vertical size of raised space between panels
    int m_BorderThickness;              // Thickness of border in pixels
    int m_VerticalTextOffsetTop;        // Distance between top of text and border
    int m_Textheight;                   // Height of text
    int m_VerticalTextOffsetBottom;     // Distance between bottom of text and border
    int m_HorzRaisedSpace;              // Horiz raised space between panels
    int m_HorzTextOffset;               // Distance between left edge of text and border
    int m_TotalHeight;                  // Total height of line (for convenience)
    int m_ColCount;                     // Number of columns
    int m_SortCol;                      // Which column to use when sorting into panels

    int *m_pVertPos;                    // Array of vertical positions within a panel

    // Colors
    COLORREF m_clrText;
    COLORREF m_clrTextBk;
    COLORREF m_clrBkgnd;
    COLORREF m_clrHighlightText;
    COLORREF m_clrHighlight;
    COLORREF m_clr3DDkShadow;
    COLORREF m_clr3DShadow;
    COLORREF m_clr3DLight;
    COLORREF m_clr3DHiLight;

    // Pens for 3D rectangles
    CPen m_DarkShadowPen;
    CPen m_ShadowPen;
    CPen m_LightPen;
    CPen m_HiLightPen;

public:
    void CIeList::Initialize( int colCount, int sortCol = 0 );


};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif // !defined(IELIST_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\dll\makefile.inc ===
$(O)\hsmadmin.res:                        \
                   ..\res\BlueSakk.ico    \
                   ..\res\ContOpen.ico    \
                   ..\res\devlst.ico      \
                   ..\res\devlstX.ico     \
                   ..\res\Li.ico          \
                   ..\res\LiX.ico         \
                   ..\res\manvol.ico      \
                   ..\res\manvolD.ico     \
                   ..\res\manvolX.ico     \
                   ..\res\Media.ico       \
                   ..\res\MoveUp.ico      \
                   ..\res\MoveUp2.ico     \
                   ..\res\MoveDown.ico    \
                   ..\res\MoveDwn2.ico    \
                   ..\res\about.rgs       \
                   ..\res\Ca.rgs          \
                   ..\res\HsmCom.rgs      \
                   ..\res\ManVol.rgs      \
                   ..\res\ManVolLs.rgs    \
                   ..\res\Mese.rgs        \
                   ..\res\hsmadmin.rgs    \
                   ..\res\hsmdatax.rgs    \
                   ..\res\hsmdata.rgs     \
                   ..\res\QStartEx.bmp    \
                   ..\res\QStartIn.bmp    \
                   ..\res\ManageEx.bmp    \
                   ..\res\ManageIn.bmp    \
                   ..\res\MdSyncEx.bmp    \
                   ..\res\MdSyncIn.bmp    \
                   ..\res\UnMngExt.bmp    \
                   ..\res\UnMngInt.bmp    \
                   ..\res\RedSakLg.bmp    \
                   ..\res\RedSakSm.bmp    \
                   ..\res\TbCar.bmp       \
                   ..\res\TbMese.bmp      \
                   ..\res\TbVolume.bmp    \
                   ..\res\TbVolLst.bmp    \
                   ..\$(O)\HsmAdmin.tlb 

..\stdafx.cpp: ..\..\inc\rsutil.cpp
..\stdafx.h: ..\..\inc\rsutil.h

$(O)\hsmadmin_i.c: ..\mergeps\$(O)\hsmadmin_i.c
    copy ..\mergeps\$(O)\hsmadmin_i.c $(O)\.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\mergeps\dlldatax.c ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    dlldataX.c

Abstract:

    wrapper for dlldata.c

Author:

    Rohde Wakefield [rohde]   19-Aug-1997

Revision History:

--*/

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#undef  _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#define _purecall _purecallx

#include "dlldata.c"
#include "hsmadmin_p.c"


#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\device\wzmedset.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WzMedSet.h

Abstract:

    Wizard for Media Set - Copy Set Wizard.

Author:

    Rohde Wakefield [rohde]   23-09-1997

Revision History:

--*/

#ifndef _WZMEDSET_H
#define _WZMEDSET_H

//
// Use CMediaInfoObject
//
#include "ca.h"

// Pre-declare
class CMediaCopyWizard;
class CMediaCopyWizardSelect;

/////////////////////////////////////////////////////////////////////////////
// CCopySetList window

class CCopySetList : public CListCtrl
{
// Construction
public:
    CCopySetList( CMediaCopyWizardSelect * pPage );

// Attributes
public:

// Operations
public:
    void UpdateView( );
    INT GetSelectedSet( );
    void SelectSet( INT SetNum );

private:
    INT m_CopySetCol;
    INT m_UpdateCol;
    INT m_CreateCol;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCopySetList)
    protected:
    virtual void PreSubclassWindow();
    //}}AFX_VIRTUAL

// Implementation
    struct CopySetInfo {
        
        FILETIME m_Updated;
        INT      m_NumOutOfDate;
        INT      m_NumMissing;

    };

    CopySetInfo m_CopySetInfo[HSMADMIN_MAX_COPY_SETS];

private:
    CMediaCopyWizardSelect * m_pPage;

public:
    virtual ~CCopySetList();

    // Generated message map functions
protected:
    //{{AFX_MSG(CCopySetList)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardSelect dialog

class CMediaCopyWizardSelect : public CSakWizardPage
{
// Construction
public:
    CMediaCopyWizardSelect();
    ~CMediaCopyWizardSelect();

// Dialog Data
    //{{AFX_DATA(CMediaCopyWizardSelect)
    enum { IDD = IDD_WIZ_CAR_COPY_SELECT };
    CCopySetList m_List;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMediaCopyWizardSelect)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation

protected:
    // Generated message map functions
    //{{AFX_MSG(CMediaCopyWizardSelect)
    virtual BOOL OnInitDialog();
    afx_msg void OnSelchangeCopyList();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    void SetButtons();

public:

};

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardNumCopies dialog

class CMediaCopyWizardNumCopies : public CSakWizardPage
{
// Construction
public:
    CMediaCopyWizardNumCopies();
    ~CMediaCopyWizardNumCopies();

// Dialog Data
    //{{AFX_DATA(CMediaCopyWizardNumCopies)
    enum { IDD = IDD_WIZ_CAR_COPY_NUM_COPIES };
    CSpinButtonCtrl m_SpinMediaCopies;
    CEdit   m_EditMediaCopies;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMediaCopyWizardNumCopies)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
public:
    HRESULT GetNumMediaCopies( USHORT* pNumMediaCopies, USHORT* pEditMediaCopies = 0 );

private:
    void SetButtons();

protected:
    // Generated message map functions
    //{{AFX_MSG(CMediaCopyWizardNumCopies)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditMediaCopies();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardIntro dialog

class CMediaCopyWizardIntro : public CSakWizardPage
{
// Construction
public:
    CMediaCopyWizardIntro();
    ~CMediaCopyWizardIntro();

// Dialog Data
    //{{AFX_DATA(CMediaCopyWizardIntro)
    enum { IDD = IDD_WIZ_CAR_COPY_INTRO };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMediaCopyWizardIntro)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation

protected:
    // Generated message map functions
    //{{AFX_MSG(CMediaCopyWizardIntro)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardFinish dialog

class CMediaCopyWizardFinish : public CSakWizardPage
{
// Construction
public:
    CMediaCopyWizardFinish();
    ~CMediaCopyWizardFinish();

// Dialog Data
    //{{AFX_DATA(CMediaCopyWizardFinish)
    enum { IDD = IDD_WIZ_CAR_COPY_FINISH };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMediaCopyWizardFinish)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation

protected:
    // Generated message map functions
    //{{AFX_MSG(CMediaCopyWizardFinish)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};


class CMediaCopyWizard : public CSakWizardSheet
{
// Construction
public:
    CMediaCopyWizard();
    virtual ~CMediaCopyWizard();

public:
    // Property Pages
    CMediaCopyWizardIntro       m_pageIntro;
    CMediaCopyWizardNumCopies   m_pageNumCopies;
    CMediaCopyWizardSelect      m_pageSelect;
    CMediaCopyWizardFinish      m_pageFinish;

// Attributes
public:
    USHORT m_numMediaCopiesOrig;  // Number of media copies from RMS
        
// Operations
public:

// Implementation
public:
    virtual HRESULT OnFinish( void );
    STDMETHOD( AddWizardPages ) ( IN RS_PCREATE_HANDLE Handle, IN IUnknown* pPropSheetCallback, IN ISakSnapAsk* pSakSnapAsk );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\manvol.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    ManVol.h

Abstract:

    Node representing a Managed Volume.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _MANVOL_H
#define _MANVOL_H

#include "PrMrSts.h"
#include "PrMrIE.h"
#include "PrMrLvl.h"
#include "SakNodeI.h"

class ATL_NO_VTABLE CUiManVol : 
    public CSakNodeImpl<CUiManVol>,
    public CComCoClass<CUiManVol,&CLSID_CUiManVol>,
    public CComDualImpl<IManVolProp, &IID_IManVolProp, &LIBID_HSMADMINLib>
{

public:
// constructor/destructor
    CUiManVol(void) {};
BEGIN_COM_MAP(CUiManVol)
    COM_INTERFACE_ENTRY2(IDispatch, IManVolProp)
    COM_INTERFACE_ENTRY2(ISakNodeProp, IManVolProp)
    COM_INTERFACE_ENTRY(IHsmEvent)
    COM_INTERFACE_ENTRY(ISakNode)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CUiManVol)

    // for multiple-inheritance, forward all base implementations to CSakNode.
    FORWARD_BASEHSM_IMPLS 

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

public: 
    STDMETHOD( InvokeCommand )        ( SHORT sCmd, IDataObject *pDataObject );
    STDMETHOD( GetContextMenu )       ( BOOL bMultiSelect, HMENU *phMenu );

    // ISakNode methods
    STDMETHOD( InitNode )                  ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( TerminateNode )             ( void );
    STDMETHOD( AddPropertyPages )          ( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID* pEnumObjectId, IEnumUnknown *pEnumUnkNode );
    STDMETHOD( RefreshObject )             ( );
    STDMETHOD( OnToolbarButtonClick )      ( IDataObject *pDataObject, long cmdId );
    STDMETHOD( GetResultIcon )             ( IN BOOL bOK, OUT int* pIconIndex );
    STDMETHOD( SupportsProperties )        ( BOOL bMutliSelec );
    STDMETHOD( SupportsRefresh )           ( BOOL bMutliSelect );
    STDMETHOD( IsValid )                   ( );


    // IManVolProp methods
    STDMETHOD( get_DesiredFreeSpaceP )  ( BSTR *pszValue );
    STDMETHOD( get_DesiredFreeSpaceP_SortKey )( BSTR *pszValue );
    STDMETHOD( get_MinFileSizeKb )      ( BSTR *pszValue );
    STDMETHOD( get_AccessDays )         ( BSTR *pszValue );
    STDMETHOD( get_FreeSpaceP )         ( BSTR *pszValue );
    STDMETHOD( get_Capacity )           ( BSTR *pszValue );
    STDMETHOD( get_Capacity_SortKey )   ( BSTR *pszValue );
    STDMETHOD( get_FreeSpace )          ( BSTR *pszValue );
    STDMETHOD( get_FreeSpace_SortKey )  ( BSTR *pszValue );
    STDMETHOD( get_Premigrated )        ( BSTR *pszValue );
    STDMETHOD( get_Truncated )          ( BSTR *pszValue );

    // static, class-wide variables
    static INT  m_nScopeOpenIconIndex;  // virtual scope index of Open Icon
    static INT  m_nScopeCloseIconIndex; // virtual scope index of Close Icon
    static INT  m_nResultIconIndex; // virtual scope index of Close Icon

private:
    HRESULT RemoveObject( );
    HRESULT ShowManVolProperties (IDataObject *pDataObject, int initialPage);
    HRESULT CreateAndRunManVolJob (HSM_JOB_DEF_TYPE jobType);
    HRESULT HandleTask(IDataObject * pDataObject, HSM_JOB_DEF_TYPE jobType);
    HRESULT IsDataObjectMs              ( IDataObject *pDataObject );
    HRESULT IsDataObjectOt              ( IDataObject *pDataObject );
    HRESULT IsDataObjectMultiSelect     ( IDataObject *pDataObject );
    HRESULT GetOtFromMs                 ( IDataObject *pDataObject, IDataObject ** pOtDataObject );
    HRESULT GetTaskTypeMessageId        ( HSM_JOB_DEF_TYPE jobType, BOOL multiSelect, UINT* msgId );
    HRESULT IsAvailable                 ( );

    // Put properties
    HRESULT put_DesiredFreeSpaceP (int percent); 
    HRESULT put_MinFileSizeKb (LONG minFileSizeKb);
    HRESULT put_AccessDays (int accessTimeDays);
    HRESULT put_FreeSpaceP (int percent);
    HRESULT put_Capacity (LONGLONG capacity);
    HRESULT put_FreeSpace (LONGLONG freeSpace);
    HRESULT put_Premigrated (LONGLONG premigrated);
    HRESULT put_Truncated (LONGLONG truncated);
    HRESULT put_IsAvailable( BOOL Available );


    // Properties for display
    int m_DesiredFreeSpaceP;
    LONG m_MinFileSizeKb;
    int m_AccessDays;
    int m_FreeSpaceP;
    LONGLONG m_Capacity;
    LONGLONG m_FreeSpace;
    LONGLONG m_Premigrated;
    LONGLONG m_Truncated;
    HRESULT  m_HrAvailable;

    static int m_nResultIconD;    
    static UINT    m_MultiSelect;
    static UINT    m_ObjectTypes;


public:
    CComPtr <IFsaResource> m_pFsaResource;

};

class CUiManVolSheet : public CSakVolPropSheet
{
public:
    HRESULT AddPropertyPages( );
    HRESULT GetNextFsaResource( int *pBookMark, IFsaResource ** ppFsaResource );
    CUiManVolSheet( ) { };

private:
};


#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\manvol.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    ManVol.cpp

Abstract:

    Managed Volume node implementation.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include <mstask.h>

#include "ManVol.h"

#include "PrMrSts.h"
#include "PrMrIe.h"

#include "WzUnmang.h"

int CUiManVol::m_nResultIcon      = AddResultImage( IDI_NODEMANVOL );
int CUiManVol::m_nResultIconX     = AddResultImage( IDI_NODEMANVOLX );
int CUiManVol::m_nResultIconD     = AddResultImage( IDI_NODEMANVOLD );
// Not used
int CUiManVol::m_nScopeCloseIcon  = AddScopeImage( IDI_NODEMANVOL );
int CUiManVol::m_nScopeCloseIconX = AddScopeImage( IDI_NODEMANVOLX );
int CUiManVol::m_nScopeOpenIcon   = CUiManVol::m_nScopeCloseIcon;
int CUiManVol::m_nScopeOpenIconX  = CUiManVol::m_nScopeCloseIconX;

UINT CUiManVol::m_ObjectTypes    = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
UINT CUiManVol::m_MultiSelect    = RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);


/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CUiManVol::FinalConstruct( )
{
    WsbTraceIn( L"CUiManVol::FinalConstruct", L"" );

    m_rTypeGuid = &cGuidManVol;

    HRESULT hr = CSakNode::FinalConstruct( );
    m_bSupportsPropertiesSingle = TRUE;
    m_bSupportsPropertiesMulti  = TRUE;
    m_bSupportsDeleteSingle     = FALSE;
    m_bSupportsDeleteMulti      = FALSE;
    m_bSupportsRefreshSingle    = TRUE;
    m_bSupportsRefreshMulti     = FALSE;
    m_bIsContainer              = FALSE;
    m_pFsaResource              = NULL;
    m_HrAvailable               = S_FALSE;

    // Toolbar values
    INT i = 0;
#if 0 // MS does not want these toolbar buttons to show up
    m_ToolbarButtons[i].nBitmap = 0;
    m_ToolbarButtons[i].idCommand = TB_CMD_VOLUME_SETTINGS;
    m_ToolbarButtons[i].idButtonText = IDS_TB_TEXT_VOLUME_SETTINGS;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_VOLUME_SETTINGS;
    i++;

    m_ToolbarButtons[i].nBitmap = 1;
    m_ToolbarButtons[i].idCommand = TB_CMD_VOLUME_TOOLS;
    m_ToolbarButtons[i].idButtonText = IDS_TB_TEXT_VOLUME_TOOLS;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_VOLUME_TOOLS;
    i++;

    m_ToolbarButtons[i].nBitmap = 2;
    m_ToolbarButtons[i].idCommand = TB_CMD_VOLUME_RULES;
    m_ToolbarButtons[i].idButtonText = IDS_TB_TEXT_VOLUME_RULES;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_VOLUME_RULES;
    i++;
#endif

    m_ToolbarBitmap             = IDB_TOOLBAR_VOLUME;
    m_cToolbarButtons           = i;

    WsbTraceOut( L"CUiManVol::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CUiManVol::FinalRelease( )
{
    WsbTraceIn( L"CUiManVol::FinalRelease", L"" );

    CSakNode::FinalRelease( );

    WsbTraceOut( L"CUiManVol::FinalRelease", L"" );
}


/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         GetContextMenu
//
//  Return an HMENU to be used for context menus on this node.
//

STDMETHODIMP
CUiManVol::GetContextMenu( BOOL bMultiSelect, HMENU* phMenu )
{
    WsbTraceIn( L"CUiManVol::GetContextMenu", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( m_pFsaResource );

        LoadContextMenu( IDR_MANVOL, phMenu );

        CMenu* pRootMenu;
        CMenu* pTaskMenu;
        CMenu menu;
        menu.Attach( *phMenu );
        pRootMenu = menu.GetSubMenu( MENU_INDEX_ROOT );
        pTaskMenu = menu.GetSubMenu( MENU_INDEX_TASK );

        //
        // If multi-select, disable these items
        //
        //
        // else if engine down or resource is being unmanaged, or appears to be missing
        // (formatted new?), disable these items
        //

        BOOL bState = ( m_pSakSnapAsk->GetState( ) == S_OK );
        BOOL bDeletePending = ( m_pFsaResource->IsDeletePending( ) == S_OK );
        BOOL bAvailable = ( IsAvailable( ) == S_OK );

        if( bMultiSelect ) {

            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_RULES,  MF_GRAYED | MF_BYCOMMAND );
            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_REMOVE, MF_GRAYED | MF_BYCOMMAND );

        }
        else {

            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_LEVELS, MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_TASKS,  MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_RULES,  MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_REMOVE, MF_BYCOMMAND |
                ( ( !bState || bDeletePending ) ? MF_GRAYED : MF_ENABLED ) );

            pTaskMenu->EnableMenuItem( ID_MANVOL_ROOT_TOOLS_COPY, MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

            pTaskMenu->EnableMenuItem( ID_MANVOL_ROOT_TOOLS_VALIDATE, MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

            pTaskMenu->EnableMenuItem( ID_MANVOL_ROOT_TOOLS_CREATE_FREESPACE, MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

        }

        menu.Detach( );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::GetContextMenu", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         InvokeCommand
//
//  User has selected a command from the menu. Process it here.
//

STDMETHODIMP
CUiManVol::InvokeCommand( SHORT sCmd, IDataObject* pDataObject )
{
    WsbTraceIn( L"CUiManVol::InvokeCommand", L"sCmd = <%d>", sCmd );

    CString theString;
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        WsbAffirmPointer( m_pFsaResource );

        if( S_OK != m_pFsaResource->IsDeletePending( ) ) {

            switch( sCmd ) {

                case ID_MANVOL_ROOT_REMOVE:
                    //
                    // Should not be called for multi-select
                    //
                    RemoveObject();
                    break;

                case ID_MANVOL_ROOT_LEVELS:
                case ID_MANVOL_TASK_LEVELS:
                    ShowManVolProperties( pDataObject, 1 );
                    break;

                case ID_MANVOL_ROOT_RULES:
                case ID_MANVOL_TASK_RULES:
                    //
                    // Should not be called for multi-select
                    //
                    ShowManVolProperties( pDataObject, 2 );
                    break;

                case ID_MANVOL_ROOT_TOOLS_COPY :
                    HandleTask( pDataObject, HSM_JOB_DEF_TYPE_MANAGE );
                    break;

                case ID_MANVOL_ROOT_TOOLS_VALIDATE :
                    HandleTask( pDataObject, HSM_JOB_DEF_TYPE_VALIDATE );
                    break;

                case ID_MANVOL_ROOT_TOOLS_CREATE_FREESPACE :
                    HandleTask( pDataObject, HSM_JOB_DEF_TYPE_TRUNCATE );
                    break;

                default:
                    break;
            }

        } else {

            CString message;
            AfxFormatString1( message, IDS_ERR_VOLUME_DELETE_PENDING, m_szName );
            AfxMessageBox( message, RS_MB_ERROR );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::InvokeCommand", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVol::OnToolbarButtonClick( IDataObject *pDataObject, long cmdId )
{
    WsbTraceIn( L"CUiManVol::OnToolbarButtonClick", L"cmdId = <%d>", cmdId );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFsaResource );

        if( S_OK != m_pFsaResource->IsDeletePending( ) ) {

            try {

                switch( cmdId ) {

                case TB_CMD_VOLUME_SETTINGS:
                    ShowManVolProperties( pDataObject, 1 );
                    break;

                case TB_CMD_VOLUME_TOOLS:
                    ShowManVolProperties( pDataObject, 2 );
                    break;

                case TB_CMD_VOLUME_RULES:
                    ShowManVolProperties( pDataObject, 3 );
                    break;
                }

            } WsbCatch( hr );


        } else {

            CString message;
            AfxFormatString1( message, IDS_ERR_VOLUME_DELETE_PENDING, m_szName );
            AfxMessageBox( message, RS_MB_ERROR );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::OnToolbarButtonClick", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT CUiManVol::ShowManVolProperties( IDataObject *pDataObject, int initialPage )
{
    WsbTraceIn( L"CUiManVol::ShowManVolProperties", L"initialPage = <%d>", initialPage );

    HRESULT hr = S_OK;
    try {

        CComPtr<ISakNode> pSakNode;
        WsbAffirmHr( _InternalQueryInterface( IID_ISakNode, (void **) &pSakNode ) );
        WsbAffirmHr( m_pSakSnapAsk->ShowPropertySheet( pSakNode, pDataObject, initialPage ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::ShowManVolProperties", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiManVol::CreateAndRunManVolJob( HSM_JOB_DEF_TYPE jobType )
{
    WsbTraceIn( L"CUiManVol::CreateAndRunManVolJob", L"jobType = <0x%p>", jobType );

    HRESULT hr = 0;
    try {

        WsbAffirmPointer( m_pFsaResource );

        //
        // Get a pointer to the FsaResource interface
        //
        CComPtr<IHsmServer>   pHsmServer;

        WsbAffirmHrOk( m_pSakSnapAsk->GetHsmServer( &pHsmServer ) );

        RsCreateAndRunFsaJob( jobType, pHsmServer, m_pFsaResource );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::CreateAndRunManVolJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiManVol::HandleTask( IDataObject * pDataObject, HSM_JOB_DEF_TYPE jobType )
{
    WsbTraceIn( L"CUiManVol::HandleTask", L"pDataObject = <0x%p>, jobType = <0x%p>", pDataObject, jobType );

    HRESULT hr = 0;
    try {

        UINT nMsgId = 0;

        CComPtr<IHsmServer>   pHsmServer;

        WsbAffirmHrOk( m_pSakSnapAsk->GetHsmServer( &pHsmServer ) );

        //
        // Submit jobs for all selected FsaResource's
        //
        if ( IsDataObjectMultiSelect( pDataObject ) == S_OK )
        {
            CComPtr<IDataObject> pOtDataObject;

            if ( IsDataObjectMs( pDataObject ) == S_OK ) {
                WsbAffirmHr( GetOtFromMs( pDataObject, &pOtDataObject ) );
            }
            else {
                pOtDataObject = pDataObject;
            }

            // Get a pointer to a FsaResource attribute out of the data
            ULONG nElem = 1;
            CComPtr<IMsDataObject> pMsDataObject;
            CComPtr<IUnknown> pUnkNode;
            CComPtr<IEnumUnknown> pEnumUnkNode;

            WsbAffirmHr( pOtDataObject.QueryInterface( &pMsDataObject ) );
            WsbAffirmHr( pMsDataObject->GetNodeEnumerator( &pEnumUnkNode ) );

            // Prompt the user that we are about to submit the jobs.
            CString tempString;
            UINT msgId = 0;
            WsbAffirmHr( GetTaskTypeMessageId( jobType, TRUE, &msgId ) );
            CWsbStringPtr computerName;
            WsbAffirmHr( pHsmServer->GetName( &computerName ) );
            CString message;
            AfxFormatString1( message, msgId, computerName );

            tempString.LoadString( IDS_RUN_JOB_MULTI2 );
            message += tempString;

            if ( AfxMessageBox( message, MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON2 ) == IDOK )
            {

                while ( pEnumUnkNode->Next( nElem, &pUnkNode, NULL ) == S_OK )
                {
                    CComPtr<ISakNode> pNode;
                    WsbAffirmHr( pUnkNode.QueryInterface( &pNode ) );
                    pUnkNode.Release();

                    CComPtr<IUnknown> pUnk;
                    WsbAffirmHr( pNode->GetHsmObj( &pUnk ) );
                    CComPtr<IHsmManagedResource> pManRes;
                    WsbAffirmHr( pUnk.QueryInterface( &pManRes ) );

                    //
                    // Then Get Coresponding FSA resource
                    //
                    CComPtr<IUnknown> pUnkFsaRes;
                    WsbAffirmHr( pManRes->GetFsaResource( &pUnkFsaRes ) );
                    CComPtr<IFsaResource> pFsaResource;
                    WsbAffirmHr( pUnkFsaRes.QueryInterface( &pFsaResource ) );

                    RsCreateAndRunFsaJob( jobType, pHsmServer, pFsaResource, FALSE );

                }
            }
        }
        else
        {
            WsbAffirmPointer( m_pFsaResource );

            // Prompt the user that we are about to submit the jobs.
            UINT msgId = 0;
            WsbAffirmHr( GetTaskTypeMessageId( jobType, FALSE, &msgId ) );
            CWsbStringPtr computerName;
            WsbAffirmHr( pHsmServer->GetName( &computerName ) );

            CString message;
            AfxFormatString1( message, msgId, computerName );

            CString jobName;
            WsbAffirmHr( RsCreateJobName( jobType, m_pFsaResource, jobName ) );
            CString tempString;
            AfxFormatString1( tempString, IDS_MONITOR_TASK, jobName );

            message += tempString;

            if ( AfxMessageBox( message, MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON2 ) == IDOK ) {

              RsCreateAndRunFsaJob( jobType, pHsmServer, m_pFsaResource, FALSE );

            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::HandleTask", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT
CUiManVol::GetTaskTypeMessageId( HSM_JOB_DEF_TYPE jobType, BOOL multiSelect, UINT* msgId ) {
    WsbTraceIn( L"CUiManVol::GetTaskTypeMessageId", L"jobType = <%d>, msgId = <%d>, multiSelect = <%d>", jobType, msgId, multiSelect );

    HRESULT hr = 0;
    try {

        WsbAffirmPointer( msgId );

        switch ( jobType ) {

        case HSM_JOB_DEF_TYPE_MANAGE :
            if ( multiSelect )

                *msgId = IDS_RUN_MULTI_COPY_JOBS;

            else

                *msgId = IDS_RUN_COPY_JOB;

            break;

        case HSM_JOB_DEF_TYPE_VALIDATE :
            if ( multiSelect )

                *msgId = IDS_RUN_MULTI_VALIDATE_JOBS;

            else

                *msgId = IDS_RUN_VALIDATE_JOB;

            break;

        case HSM_JOB_DEF_TYPE_TRUNCATE :
            if ( multiSelect )

                *msgId = IDS_RUN_MULTI_CFS_JOBS;

            else

                *msgId = IDS_RUN_CFS_JOB;

            break;

        default:
            break;
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::GetTaskTypeMessageId", L"jobType = <%d>, msgId = <%d>, multiSelect = <%d>", jobType, msgId, multiSelect );

    return hr;
}

// Is the dataobject either type of multi-select dataobject?
HRESULT
CUiManVol::IsDataObjectMultiSelect   ( IDataObject *pDataObject )
{
    HRESULT hr = S_OK;
    hr = ( ( (IsDataObjectOt( pDataObject ) ) == S_OK ) ||
        ( (IsDataObjectMs( pDataObject ) ) == S_OK ) ) ? S_OK : S_FALSE;
    return hr;
}

// Is the dataobject an Object Types dataobject?
HRESULT
CUiManVol::IsDataObjectOt ( IDataObject *pDataObject )
{
    HRESULT hr = S_FALSE;

    // Is this a mutli-select data object?
    FORMATETC fmt = {(CLIPFORMAT)m_ObjectTypes, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

    if ( pDataObject->GetData( &fmt, &stgm ) == S_OK ) {
        hr = S_OK;
    }

    ReleaseStgMedium( &stgm );

    return hr;
}

// Is the dataobject a Mutli-Select dataobject?
HRESULT
CUiManVol::IsDataObjectMs ( IDataObject *pDataObject )
{
    HRESULT hr = S_FALSE;

    // Is this a mutli-select data object?
    FORMATETC fmt = {(CLIPFORMAT)m_MultiSelect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

    if ( pDataObject->GetData( &fmt, &stgm ) == S_OK ) {
        hr = S_OK;
    }

    ReleaseStgMedium( &stgm );

    return hr;
}

HRESULT
CUiManVol::GetOtFromMs( IDataObject * pDataObject, IDataObject ** ppOtDataObject )
{
    WsbTraceIn( L"CUiManVol::GetOtFromMs", L"pDataObject = <0x%p>, ppOtDataObject = <0x%p>", pDataObject, ppOtDataObject );

    HRESULT hr = S_OK;

    try {

        // We've got an MMC mutli-select data object.  Get the first
        // data object from it's array of data objects

        FORMATETC fmt = {(CLIPFORMAT)m_MultiSelect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

        WsbAffirmHr ( pDataObject->GetData( &fmt, &stgm ) == S_OK );
        DWORD count;
        memcpy( &count, stgm.hGlobal, sizeof (DWORD) );
        if ( count > 0 ) {

            //
            // The following code is admittedly UGLY
            // We have a data stream where we need to skip past the
            // first DWORD count and grab an interface pointer.
            // Other snapins code does it as follows:

//            IDataObject * pDO;
//            memcpy( &pDO, (DWORD *) stgm.hGlobal + 1, sizeof(IDataObject*) );

            //
            // However, since this code does an indirect cast (via memcpy)
            // from DWORD to IDataObject*, and does not keep a true reference
            // on the interface pointer, we will use a smart pointer.
            // The (DWORD*) and +1 operation bump our pointer past the count.
            // We then need to grab the next bytes in the buffer and use them
            // as a IDataObject *.
            //
            CComPtr<IDataObject> pOtDataObject;
            pOtDataObject = *( (IDataObject**)( (DWORD *) stgm.hGlobal + 1 ) );

            WsbAffirmHr( pOtDataObject->QueryInterface( IID_IDataObject, (void**) ppOtDataObject ) );

        }

        ReleaseStgMedium( &stgm );

    } WsbCatch ( hr );

    WsbTraceOut( L"CUiManVol::GetOtFromMs", L"pDataObject = <0x%p>, ppOtDataObject = <0x%p>", pDataObject, ppOtDataObject );
    return ( hr );
}

STDMETHODIMP
CUiManVol::AddPropertyPages( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID *pEnumObjectId, IEnumUnknown *pEnumUnkNode )
{
    WsbTraceIn( L"CUiManVol::AddPropertyPages", L"handle = <%ld>, pUnkPropSheetCallback = <0x%0.l8x>, pEnumObjectId = <0x%p>",
        handle, pUnkPropSheetCallback, pEnumObjectId );
    HRESULT hr = S_OK;
    try {

        //
        // Make sure we can still contact the engine before doing this
        // If not running, we shouldn't even exist so update parent
        //
        CComPtr<IHsmServer> pHsmServer;
        HRESULT hrRunning = m_pSakSnapAsk->GetHsmServer( &pHsmServer );
        if( S_FALSE == hrRunning ) {

            m_pSakSnapAsk->UpdateAllViews( m_pParent );

        }
        WsbAffirmHrOk( hrRunning );

        //
        // Create an object to hold the pages
        //
        CUiManVolSheet *pManVolPropertySheet = new CUiManVolSheet;
        WsbAffirmAlloc( pManVolPropertySheet );
        WsbAffirmHr( pManVolPropertySheet->InitSheet(
            handle,
            pUnkPropSheetCallback,
            this,
            m_pSakSnapAsk,
            pEnumObjectId,
            pEnumUnkNode
            ) );

        //
        // Tell the object to add it's pages
        //
        WsbAffirmHr( pManVolPropertySheet->AddPropertyPages( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}




//---------------------------------------------------------------------------
//
//         InitNode
//
//  Initialize single COM object. Derived objects frequently augment this
//  method by implementing it themselves.
//

STDMETHODIMP CUiManVol::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CUiManVol::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );

    HRESULT hr = S_OK;
    try {

        WsbAffirmHr( CSakNode::InitNode( pSakSnapAsk, pHsmObj, pParent ));

        //
        // Get the Fsa object pointer
        //
        CComQIPtr<IHsmManagedResource, &IID_IHsmManagedResource> pHsmManRes = m_pHsmObj;
        WsbAffirmPointer( pHsmManRes );
        CComPtr<IUnknown> pUnkFsaRes;
        WsbAffirmHr( pHsmManRes->GetFsaResource( &pUnkFsaRes ) );
        m_pFsaResource.Release( );
        WsbAffirmHr( RsQueryInterface( pUnkFsaRes, IFsaResource, m_pFsaResource ) );

        //
        // Get and save the unique Id for this volume
        //
        WsbAffirmHr( m_pFsaResource->GetIdentifier( &m_ObjectId ) );

        //
        // Set up the connection point
        //
        CSakNode::SetConnection( pUnkFsaRes );

        //
        // Set object properties
        //
        RefreshObject();

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CUiManVol::TerminateNode(
    )
/*++

Routine Description:

    Free any interface connections or other resources
    that would prevent correct shutdown of node (would
    keep ref count from going to 0).

Arguments:

    CopySet - copy set of interest.

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_* - Some error occurred.

--*/
{
    WsbTraceIn( L"CUiManVol::TerminateNode", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Release any interface pointers kept so that circular references
        // are broken
        //
        m_pFsaResource.Release( );

        //
        // call the base class for it's pieces
        //
        CSakNode::TerminateNode( );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::TerminateNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CUiManVol::RemoveObject()
{
    WsbTraceIn( L"CUiManVol::RemoveObject", L"" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    try {

        //
        // use wizard to create manage volume
        //
        CComObject<CUnmanageWizard>* pWizard = new CComObject<CUnmanageWizard>;
        WsbAffirmAlloc( pWizard );

        WsbAffirmHr( pWizard->SetNode( this ) );

        CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
        WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );

        //
        // Refresh will take place when called back from FSA
        //

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::RemoveObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

//---------------------------------------------------------------------------------
//
//                  RefreshObject
//
//  Refresh data in the object.  This function is used for data that can change
//  (for example, volume utilization).
//
//
STDMETHODIMP
CUiManVol::RefreshObject()
{
    WsbTraceIn( L"CUiManVol::RefreshObject", L"" );

    HRESULT     hr = S_OK;
    ULONG       hsmLevel = 0;
    LONGLONG    fileSize = 0;
    BOOL        isRelative = TRUE; // assumed to be TRUE
    FILETIME    accessTime;
    UINT        accessTimeDays;
    LONGLONG    total = 0;
    LONGLONG    free = 0;
    LONGLONG    premigrated = 0;
    LONGLONG    truncated = 0;
    int         percent;

    CString sFormat;

    try {

        WsbAffirmPointer( m_pFsaResource );

        // Get and format the volume name and label
        CString addString;
        WsbAffirmHr( RsGetVolumeDisplayName( m_pFsaResource, addString ) );
        WsbAffirmHr( put_DisplayName( (LPTSTR)(LPCTSTR)addString ) );

        WsbAffirmHr( RsGetVolumeSortKey( m_pFsaResource, addString ) );
        WsbAffirmHr( put_DisplayName_SortKey( (LPTSTR)(LPCTSTR)addString ) );

        // Get level settings
        WsbAffirmHr( m_pFsaResource->GetHsmLevel( &hsmLevel ) );
        put_DesiredFreeSpaceP( hsmLevel / FSA_HSMLEVEL_1 );

        WsbAffirmHr( m_pFsaResource->GetManageableItemLogicalSize( &fileSize ) );
        put_MinFileSizeKb( (LONG) (fileSize / 1024) );  // Show KBytes

        WsbAffirmHr( m_pFsaResource->GetManageableItemAccessTime( &isRelative, &accessTime ) );
        WsbAssert( isRelative, E_FAIL );  // We only do relative time

        // Convert FILETIME to days
        LONGLONG temp = WSB_FT_TICKS_PER_DAY;
        accessTimeDays = (UINT) ( WsbFTtoLL( accessTime ) / temp );

        if (accessTimeDays > 999 ) {
            accessTimeDays = 0;
        }
        put_AccessDays( accessTimeDays );

        // Get statistics
        WsbAffirmHr( m_pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );
        percent = (int) ( ( free * 100 ) / total );

        put_FreeSpaceP( percent );
        put_Capacity( total );
        put_FreeSpace( free );
        put_Premigrated( premigrated );
        put_Truncated( truncated );
        put_IsAvailable( IsAvailable( ) == S_OK );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::RefreshObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

//-----------------------------------------------------------------------------
//
//  get and put functions for object properties
//
HRESULT CUiManVol::put_DesiredFreeSpaceP( int percent )
{
    m_DesiredFreeSpaceP = percent;
    return S_OK;
}
HRESULT CUiManVol::put_MinFileSizeKb( LONG minFileSizeKb )
{
    m_MinFileSizeKb = minFileSizeKb;
    return S_OK;
}
HRESULT CUiManVol::put_AccessDays( int accessTimeDays )
{
    m_AccessDays = accessTimeDays;
    return S_OK;
}
HRESULT CUiManVol::put_FreeSpaceP( int percent )
{
    m_FreeSpaceP = percent;
    return S_OK;
}
HRESULT CUiManVol::put_Capacity( LONGLONG capacity )
{
    m_Capacity = capacity;
    return S_OK;
}
HRESULT CUiManVol::put_FreeSpace( LONGLONG freeSpace )
{
    m_FreeSpace = freeSpace;
    return S_OK;
}
HRESULT CUiManVol::put_Premigrated( LONGLONG premigrated )
{
    m_Premigrated = premigrated;
    return S_OK;
}
HRESULT CUiManVol::put_Truncated( LONGLONG truncated )
{
    m_Truncated = truncated;
    return S_OK;
}

STDMETHODIMP CUiManVol::get_DesiredFreeSpaceP( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            CString sFormat;
            WCHAR buffer[256];

            // Format the byte value
            RsGuiFormatLongLong4Char( ( m_Capacity / (LONGLONG)100 ) * (LONGLONG)(m_DesiredFreeSpaceP), sFormat );

            // Format the percent value
            _itow( m_DesiredFreeSpaceP, buffer, 10 );
            sFormat = sFormat + L"  (" + buffer + L"%)";

            // Allocate the string
            *pszValue = SysAllocString( sFormat );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_DesiredFreeSpaceP_SortKey( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            *pszValue = SysAlloc64BitSortKey( ( m_Capacity / (LONGLONG)100 ) * (LONGLONG)(m_DesiredFreeSpaceP) );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_MinFileSizeKb( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            WCHAR buffer[256];

            // Format the value
            _ltow( m_MinFileSizeKb, buffer, 10 );
            wcscat( buffer, L"KB" );

            // Allocate the string
            *pszValue = SysAllocString( buffer );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_AccessDays( BSTR *pszValue )
{
    HRESULT hr = S_OK;
    WCHAR buffer[256];

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        if( S_OK == IsAvailable( ) ) {

            // Format the value
            _itow( m_AccessDays, buffer, 10 );
            CString sDays;
            sDays.LoadString( IDS_DAYS );
            wcscat( buffer, L" " );
            wcscat( buffer, sDays );

            // Allocate the string
            *pszValue = SysAllocString( buffer );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_FreeSpaceP( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            WCHAR buffer[256];

            // Format the value
            _itow( m_FreeSpaceP, buffer, 10 );
            wcscat( buffer, L"%" );

            // Allocate the string
            *pszValue = SysAllocString( buffer );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_Capacity( BSTR *pszValue )
{
    WsbTraceIn( L"CUiManVol::get_Capacity", L"" );
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            CString sFormat;

            // Format the value
            WsbAffirmHr( RsGuiFormatLongLong4Char( m_Capacity, sFormat ) );

            // Allocate the string
            *pszValue = SysAllocString( sFormat );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::get_Capacity", L"hr = <%ls>, *pszValue = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pszValue ) );
    return( hr );
}

STDMETHODIMP CUiManVol::get_Capacity_SortKey( BSTR *pszValue )
{
    WsbTraceIn( L"CUiManVol::get_Capacity_SortKey", L"" );
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            *pszValue = SysAlloc64BitSortKey( m_Capacity );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::get_Capacity_SortKey", L"hr = <%ls>, *pszValue = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pszValue ) );
    return( hr );
}

STDMETHODIMP CUiManVol::get_FreeSpace( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            CString sFormat;
            WCHAR buffer[256];

            // Format the byte value
            WsbAffirmHr( RsGuiFormatLongLong4Char( m_FreeSpace, sFormat ) );

            // Format the percent value
            _itow( m_FreeSpaceP, buffer, 10 );
            sFormat = sFormat + L"  (" + buffer + L"%)";

            // Allocate the string
            *pszValue = SysAllocString( sFormat );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_FreeSpace_SortKey( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            *pszValue = SysAlloc64BitSortKey( m_FreeSpace );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP CUiManVol::get_Premigrated( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            CString sFormat;

            // Format the value
            WsbAffirmHr( RsGuiFormatLongLong4Char( m_Premigrated, sFormat ) );

            // Allocate the string
            *pszValue = SysAllocString( sFormat );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_Truncated( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            CString sFormat;

            // Format the value
            WsbAffirmHr( RsGuiFormatLongLong4Char( m_Truncated, sFormat ) );

            // Allocate the string
            *pszValue = SysAllocString( sFormat );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// class CUiManVolSheet
//
HRESULT CUiManVolSheet::AddPropertyPages( )
{
    WsbTraceIn( L"CUiManVolSheet::AddPropertyPages", L"" );

    HRESULT hr = S_OK;

    try {

        AFX_MANAGE_STATE( AfxGetStaticModuleState() );

        //
        //-----------------------------------------------------------
        // Create the Hsm Statistics property page.
        //
        CPrMrSts *pPropPageStatus = new CPrMrSts();
        WsbAffirmAlloc( pPropPageStatus );

        AddPage( pPropPageStatus );

        //
        //----------------------------------------------------------
        // Create the Hsm levels property page.
        //
        CPrMrLvl *pPropPageLevels = new CPrMrLvl();
        WsbAffirmAlloc( pPropPageLevels );

        AddPage( pPropPageLevels );

        if( IsMultiSelect() != S_OK ) {

            //
            //----------------------------------------------------------
            // Create the Hsm Include/Exclude property page.
            //
            CPrMrIe *pPropPageIncExc = new CPrMrIe();
            WsbAffirmAlloc( pPropPageIncExc );

            AddPage( pPropPageIncExc );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolSheet::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVolSheet::GetNextFsaResource( int *pBookMark, IFsaResource **ppFsaResource )
{
    WsbTraceIn( L"CUiManVolSheet::GetNextFsaResource", L"*pBookMark = <%ld>", WsbPtrToLongAsString( (LONG*)pBookMark ) );

    HRESULT hr = S_OK;
    GUID objectId;

    try {

        WsbAffirmPointer( pBookMark );
        WsbAffirm( *pBookMark >= 0, E_FAIL );

        //
        // Get the Fsa Server so we can get Fsa Resources
        //
        CComPtr <IFsaServer> pFsaServer;
        WsbAffirmHr( GetFsaServer( &pFsaServer ) );

        if( *pBookMark <= m_ObjectIdList.GetUpperBound( ) ) {

            objectId = m_ObjectIdList[ *pBookMark ];
            (*pBookMark)++;
            WsbAffirmHr( pFsaServer->FindResourceById( objectId, ppFsaResource ) );

        } else {

            hr = S_FALSE;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolSheet::GetNextFsaResource", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}


STDMETHODIMP
CUiManVol::GetResultIcon(
    IN  BOOL bOK,
    OUT int* pIconIndex
    )
{
    WsbTraceIn( L"CUiManVol::GetResultIcon", L"" );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFsaResource );

        if( S_OK == IsAvailable( ) ) {

            //
            // Check to make sure it's not deleted (or being deleted)
            // If so, put on the X
            //
            bOK = ( S_FALSE == m_pFsaResource->IsDeletePending( ) && S_OK == m_pFsaResource->IsManaged( ) );
            WsbAffirmHr( CSakNodeImpl<CUiManVol>::GetResultIcon( bOK, pIconIndex ) );

        } else {

            *pIconIndex = m_nResultIconD;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::GetResultIcon", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );

}

STDMETHODIMP
CUiManVol::SupportsProperties(
    BOOL bMultiSelect
    )
{
    WsbTraceIn( L"CUiManVol::SupportsProperties", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFsaResource );

        if( !bMultiSelect &&
            ( S_OK == m_pFsaResource->IsDeletePending( ) || S_OK != IsAvailable( ) ) ) {

            hr = S_FALSE;

        } else {

            hr = CSakNode::SupportsProperties( bMultiSelect );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::SupportsProperties", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CUiManVol::SupportsRefresh( BOOL bMultiSelect )
{
    WsbTraceIn( L"CUiManVol::SupportsRefresh", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFsaResource );

        if( !bMultiSelect && S_OK == m_pFsaResource->IsDeletePending( ) ) {

            hr = S_FALSE;

        } else {

            hr = CSakNode::SupportsRefresh( bMultiSelect );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::SupportsRefresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CUiManVol::IsValid( void )
{
    WsbTraceIn( L"CUiManVol::IsValid", L"" );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFsaResource );

        //
        // Still valid if managed.
        //
        WsbAffirmHrOk( m_pFsaResource->IsManaged( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::IsValid", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVol::IsAvailable( void )
{
    WsbTraceIn( L"CUiManVol::IsAvailable", L"" );

    HRESULT hr = S_FALSE;

    try {

        WsbAffirmPointer( m_pFsaResource );

        //
        // Under certain circumstances we can't get a good answer back, so
        // we have to rely on the last answer we got.
        //
        HRESULT hrAvailable = m_pFsaResource->IsAvailable( );
        if( RPC_E_CANTCALLOUT_ININPUTSYNCCALL == hrAvailable ) {

            hrAvailable = m_HrAvailable;

        }

        hr = hrAvailable;
        m_HrAvailable = hrAvailable;

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::IsAvailable", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVol::put_IsAvailable( BOOL Available )
{
    WsbTraceIn( L"CUiManVol::put_IsAvailable", L"Available = <%ls>", WsbBoolAsString( Available ) );

    HRESULT hr = S_FALSE;

    try {

        m_HrAvailable = Available ? S_OK : S_FALSE;

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::put_IsAvailable", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\manvolls.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    ManVolLs.h

Abstract:

    Node representing Managed Volumes as a whole.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _MANVOLLST_H
#define _MANVOLLST_H

#include "PrMrLsRc.h"
#include "SakNodeI.h"

class ATL_NO_VTABLE CUiManVolLst : 
    public CSakNodeImpl<CUiManVolLst>,
    public CComCoClass<CUiManVolLst,&CLSID_CUiManVolLst>
{

public:
// constructor/destructor
    CUiManVolLst(void) {};

BEGIN_COM_MAP(CUiManVolLst)
    COM_INTERFACE_ENTRY2(IDispatch, ISakNodeProp)
    COM_INTERFACE_ENTRY(ISakNode)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(ISakNodeProp)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CUiManVolLst)

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

public: 
    STDMETHOD( InvokeCommand )        ( SHORT sCmd, IDataObject *pDataObject );
    STDMETHOD( GetContextMenu )       ( BOOL bMultiSelect, HMENU *phMenu );

    // ISakNode methods
    STDMETHOD( CreateChildren )            ( ); 
    STDMETHOD( TerminateNode )             ( void );
    STDMETHOD( InitNode )                  ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( AddPropertyPages )          ( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID* pEnumObjectId, IEnumUnknown *pEnumUnkNode );
    STDMETHOD( RefreshObject )             ( );
    STDMETHOD( SetupToolbar )               ( IToolbar *pToolbar );
    STDMETHOD( OnToolbarButtonClick )      ( IDataObject *pDataObject, long cmdId );

// data members
    
    // static, class-wide variables
    static INT  m_nScopeOpenIconIndex;  // virtual scope index of Open Icon
    static INT  m_nScopeCloseIconIndex; // virtual scope index of Close Icon
    static INT  m_nResultIconIndex; // virtual scope index of Close Icon

    CComPtr <IFsaServer>            m_pFsaServer; 
    CComPtr <IWsbIndexedCollection> m_pManResCollection;
    CComPtr <IHsmServer>            m_pHsmServer;
    CComPtr <IFsaFilter>            m_pFsaFilter;
    CComPtr <ISchedulingAgent>      m_pSchedAgent;
    CComPtr <ITask>                 m_pTask;
    CComPtr <ITaskTrigger>          m_pTrigger;

private:
    HRESULT ShowManVolLstProperties (IDataObject *pDataObject, int initialPage);
};

class CUiManVolLstSheet : public CSakVolPropSheet
{
public:
    HRESULT AddPropertyPages( );
    HRESULT GetNextFsaResource ( int *pBookMark, IFsaResource ** ppFsaResource );
    HRESULT GetManResCollection( IWsbIndexedCollection ** ppFsaFilter );

private:
    CComPtr <IWsbIndexedCollection> m_pManResCollection;
};

#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\prmrlsrc.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrLsRc.cpp

Abstract:

    Recall limit Property Page

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PrMrLsRc.h"

static DWORD pHelpIds[] = 
{

    IDC_EXEMPT_ADMINS,              idh_runaway_recall_exemption,
    IDC_EDIT_RECALL_LIMIT,          idh_runaway_recall_limit,
    IDC_SPIN_RECALL_LIMIT,          idh_runaway_recall_limit,
    IDC_EDIT_RECALL_LIMIT_LABEL,    idh_runaway_recall_limit,
    IDC_EDIT_COPYFILES_LIMIT,       idh_concurrent_drives_limit,
    IDC_SPIN_COPYFILES_LIMIT,       idh_concurrent_drives_limit,
    IDC_SPIN_COPYFILES_LIMIT_LABEL, idh_concurrent_drives_limit,

    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPrMrLsRec property page

CPrMrLsRec::CPrMrLsRec() : CSakPropertyPage(IDD)
{
    WsbTraceIn( L"CPrMrLsRec::CPrMrLsRec", L"" );
    //{{AFX_DATA_INIT(CPrMrLsRec)
    m_RecallLimit = 0;
    m_ExemptAdmins = FALSE;
	m_CopyFilesLimit = 1;
	//}}AFX_DATA_INIT
    m_RecallChanged = FALSE;
    m_CopyFilesChanged = FALSE;
    m_pHelpIds      = pHelpIds;
    WsbTraceOut( L"CPrMrLsRec::CPrMrLsRec", L"" );
}

CPrMrLsRec::~CPrMrLsRec()
{
}

void CPrMrLsRec::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CPrMrLsRec::DoDataExchange", L"" );
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrMrLsRec)
	DDX_Control(pDX, IDC_SPIN_COPYFILES_LIMIT, m_spinCopyFilesLimit);
	DDX_Control(pDX, IDC_EDIT_COPYFILES_LIMIT, m_editCopyFilesLimit);
    DDX_Control(pDX, IDC_EDIT_RECALL_LIMIT, m_editRecallLimit);
    DDX_Control(pDX, IDC_SPIN_RECALL_LIMIT, m_spinRecallLimit);
    DDX_Text(pDX, IDC_EDIT_RECALL_LIMIT, m_RecallLimit);
    DDV_MinMaxUInt(pDX, m_RecallLimit, 0, 9999);
    DDX_Check(pDX, IDC_EXEMPT_ADMINS, m_ExemptAdmins);
	DDX_Text(pDX, IDC_EDIT_COPYFILES_LIMIT, m_CopyFilesLimit);
	DDV_MinMaxDWord(pDX, m_CopyFilesLimit, 1, 99);
	//}}AFX_DATA_MAP
    WsbTraceOut( L"CPrMrLsRec::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CPrMrLsRec, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPrMrLsRec)
    ON_EN_CHANGE(IDC_EDIT_RECALL_LIMIT, OnChangeEditRecallLimit)
    ON_BN_CLICKED(IDC_EXEMPT_ADMINS, OnExemptAdmins)
	ON_EN_CHANGE(IDC_EDIT_COPYFILES_LIMIT, OnChangeEditCopyfilesLimit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrMrLsRec message handlers

BOOL CPrMrLsRec::OnInitDialog() 
{
    WsbTraceIn( L"CPrMrLsRec::OnInitDialog", L"" );
    CSakPropertyPage::OnInitDialog();
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_spinRecallLimit.SetRange( 0, 9999 );
    m_editRecallLimit.SetLimitText( 4 );

    m_spinCopyFilesLimit.SetRange( 1, 99 );
    m_editCopyFilesLimit.SetLimitText( 2 );

    HRESULT hr = S_OK;

    try {

        // Get HSM relevant objects
        WsbAffirmHr( m_pParent->GetFsaFilter( &m_pFsaFilter ) );
        WsbAffirmHr( m_pParent->GetHsmServer( &m_pHsmServer ) );

        // Set controls to values from the object
        WsbAffirmHr( m_pFsaFilter->GetAdminExemption( &m_ExemptAdmins ) );
        ULONG lMaxRecalls;
        WsbAffirmHr( m_pFsaFilter->GetMaxRecalls( &lMaxRecalls ) );
        m_RecallLimit = lMaxRecalls;
        WsbAffirmHr(m_pHsmServer->GetCopyFilesUserLimit(&m_CopyFilesLimit));

        UpdateData( FALSE );
        m_RecallChanged = FALSE;
        m_CopyFilesChanged = FALSE;

    } WsbCatch( hr );

    WsbTraceOut( L"CPrMrLsRec::OnInitDialog", L"" );
    return TRUE;
}

BOOL CPrMrLsRec::OnApply() 
{
    WsbTraceIn( L"CPrMrLsRec::OnApply", L"" );
    HRESULT hr = S_OK;
    UpdateData( TRUE );

    try {

        if( m_RecallChanged ) {
            WsbAffirmHr( m_pFsaFilter->SetMaxRecalls( m_RecallLimit ) );
            m_RecallChanged = FALSE;
            WsbAffirmHr( m_pFsaFilter->SetAdminExemption( m_ExemptAdmins ) );

            // Save it
            CComPtr<IFsaServer> pFsaServer;
            WsbAffirmHr( m_pParent->GetFsaServer( &pFsaServer ) );
            WsbAffirmHr( RsServerSaveAll( pFsaServer ) );
        } 

        if( m_CopyFilesChanged ) {
            WsbAffirmHr(m_pHsmServer->SetCopyFilesUserLimit(m_CopyFilesLimit));
            m_CopyFilesChanged = FALSE;

            // Save it
            WsbAffirmHr(RsServerSaveAll(m_pHsmServer));
        } 

    } WsbCatch( hr );

    WsbTraceOut( L"CPrMrLsRec::OnApply", L"" );
    return CSakPropertyPage::OnApply();
}

void CPrMrLsRec::OnChangeEditRecallLimit() 
{
    WsbTraceIn( L"CPrMrLsRec::OnChangeEditRecallLimit", L"" );

    SetModified( TRUE );
    m_RecallChanged = TRUE;

    WsbTraceOut( L"CPrMrLsRec::OnChangeEditRecallLimit", L"" );
}


void CPrMrLsRec::OnExemptAdmins() 
{
    WsbTraceIn( L"CPrMrLsRec::OnExemptAdmins", L"" );

    SetModified( TRUE );
    m_RecallChanged = TRUE;

    WsbTraceOut( L"CPrMrLsRec::OnExemptAdmins", L"" );
}

void CPrMrLsRec::OnChangeEditCopyfilesLimit() 
{
    WsbTraceIn( L"CPrMrLsRec::OnChangeEditCopyfilesLimit", L"" );

    SetModified( TRUE );
    m_CopyFilesChanged = TRUE;

    WsbTraceOut( L"CPrMrLsRec::OnChangeEditCopyfilesLimit", L"" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\prmrlsrc.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrLsRc.h

Abstract:

    Managed Volume List Recall limit and schedule page.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#ifndef _PRMRLSRC_H
#define _PRMRLSRC_H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CPrMrLsRec dialog

class CPrMrLsRec : public CSakPropertyPage
{
// Construction
public:
    CPrMrLsRec();
    ~CPrMrLsRec();

// Dialog Data
    //{{AFX_DATA(CPrMrLsRec)
	enum { IDD = IDD_PROP_RECALL_LIMIT };
	CSpinButtonCtrl	m_spinCopyFilesLimit;
	CEdit	m_editCopyFilesLimit;
    CEdit   m_editRecallLimit;
    CSpinButtonCtrl m_spinRecallLimit;
    ULONG   m_RecallLimit;
    BOOL    m_ExemptAdmins;
	ULONG	m_CopyFilesLimit;
	//}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrMrLsRec)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrMrLsRec)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditRecallLimit();
    afx_msg void OnExemptAdmins();
	afx_msg void OnChangeEditCopyfilesLimit();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    // Unmarshalled pointer to Fsa Filter
    CComPtr<IFsaFilter> m_pFsaFilter;

    // pointer to Engine server
    CComPtr<IHsmServer> m_pHsmServer;

private:
    BOOL m_RecallChanged;
    BOOL m_CopyFilesChanged;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\manvolls.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    ManVolLs.cpp

Abstract:

    Node representing Managed Volumes as a whole.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include "WzMnVlLs.h"           // managed Resource creation wizard
#include "PrMrSts.h"
#include "ManVolLs.h"

int CUiManVolLst::m_nScopeCloseIcon  = AddScopeImage( IDI_DEVLST );
int CUiManVolLst::m_nScopeCloseIconX = AddScopeImage( IDI_DEVLSTX );
int CUiManVolLst::m_nScopeOpenIcon   = AddScopeImage( IDI_NODEOPENFOLDER );
int CUiManVolLst::m_nScopeOpenIconX  = CUiManVolLst::m_nScopeCloseIconX;
int CUiManVolLst::m_nResultIcon      = AddResultImage( IDI_DEVLST );
int CUiManVolLst::m_nResultIconX     = AddResultImage( IDI_DEVLSTX );

/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CUiManVolLst::FinalConstruct( )
{
    WsbTraceIn( L"CUiManVolLst::FinalConstruct", L"" );

    m_rTypeGuid = &cGuidManVolLst;

    HRESULT hr = CSakNode::FinalConstruct( );
    m_bSupportsPropertiesSingle = TRUE;
    m_bSupportsPropertiesMulti  = FALSE;
    m_bSupportsDeleteSingle     = FALSE;
    m_bSupportsDeleteMulti      = FALSE;
    m_bSupportsRefreshSingle    = TRUE;
    m_bSupportsRefreshMulti     = FALSE;
    m_bIsContainer              = TRUE;
    m_bHasDynamicChildren       = TRUE;

    // Toolbar values
    INT i = 0;
#if 0 // MS does not want us to have schedule toolbar button
    m_ToolbarButtons[i].nBitmap = 0;
    m_ToolbarButtons[i].idCommand =     TB_CMD_VOLUME_LIST_SCHED;
    m_ToolbarButtons[i].idButtonText =  IDS_TB_TEXT_VOLUME_LIST_SCHED;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_VOLUME_LIST_SCHED;
    i++;
#endif

    m_ToolbarButtons[i].nBitmap       = 0;
    m_ToolbarButtons[i].idCommand     = TB_CMD_VOLUME_LIST_NEW;
    m_ToolbarButtons[i].idButtonText  = IDS_TB_TEXT_VOLUME_LIST_NEW;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_VOLUME_LIST_NEW;
    i++;

    m_ToolbarBitmap             = IDB_TOOLBAR_VOLUME_LIST;
    m_cToolbarButtons           = i;

    WsbTraceOut( L"CUiManVolLst::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CUiManVolLst::FinalRelease( )
{
    WsbTraceIn( L"CUiManVolLst::FinalRelease", L"" );

    CSakNode::FinalRelease( );

    WsbTraceOut( L"CUiManVolLst::FinalRelease", L"" );
}


/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         GetContextMenu
//
//  Return an HMENU to be used for context menus on this node.
//  Set the state of the menus according to the engine state.
//

STDMETHODIMP 
CUiManVolLst::GetContextMenu( BOOL /* bMultiSelect */, HMENU* phMenu )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    try {
        LoadContextMenu( IDR_MANVOLLST, phMenu );
        CMenu* pRootMenu, *pNewMenu, *pTaskMenu;
        CMenu menu;
        menu.Attach( *phMenu );
        pRootMenu = menu.GetSubMenu( MENU_INDEX_ROOT );
        pNewMenu  = menu.GetSubMenu( MENU_INDEX_NEW );
        pTaskMenu = menu.GetSubMenu( MENU_INDEX_TASK );

        //
        // If engine down, disable these items
        //
        if ( m_pSakSnapAsk->GetState() != S_OK ) {

            pNewMenu->EnableMenuItem( ID_MANVOLLST_NEW_MANVOL, MF_GRAYED | MF_BYCOMMAND );

        }
        menu.Detach();

    } WsbCatch( hr );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         InvokeCommand
//
//  User has selected a command from the menu. Process it here.
//

STDMETHODIMP 
CUiManVolLst::InvokeCommand( SHORT sCmd, IDataObject* /* pDataObject */ )
{
    WsbTraceIn( L"CUiManVolLst::InvokeCommand", L"sCmd = <%d>", sCmd );

    CString theString;
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {
        switch (sCmd) {

            case MMC_VERB_REFRESH:
                RefreshObject( );
                RefreshScopePane( );
                break;

            case ID_MANVOLLST_ROOT_MANVOL:
            case ID_MANVOLLST_NEW_MANVOL:
            {
                //
                // use wizard to create manage volume
                //
                CComObject<CWizManVolLst>* pWizard = new CComObject<CWizManVolLst>;
                WsbAffirmAlloc( pWizard );

                CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
                WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );

                if( S_OK == pWizard->m_HrFinish ) {

                    WsbAffirmHr( RefreshScopePane( ) );

                }
                break;
            }
            
            default:
                WsbThrow( S_FALSE );
                break;
        }

    } WsbCatch( hr ); 

    WsbTraceOut( L"CUiManVolLst::InvokeCommand", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVolLst::SetupToolbar( IToolbar *pToolbar ) 
{
    WsbTraceIn( L"CUiManVolLst::SetupToolbar", L"pToolbar = <0x%p>", pToolbar );
    HRESULT hr = S_OK;

    try {

        for( INT i = 0; i < m_cToolbarButtons; i++ ) {

            m_ToolbarButtons[i].fsState = (UCHAR)( ( S_OK == m_pSakSnapAsk->GetState( ) ) ? TBSTATE_ENABLED : 0 );

        }

        WsbAffirmHr( CSakNode::SetupToolbar( pToolbar ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::SetupToolbar", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiManVolLst::OnToolbarButtonClick( IDataObject* /* pDataObject */, long cmdId )
{
    WsbTraceIn( L"CUiManVolLst::OnToolbarButtonClick", L"cmdId = <%d>", cmdId );
    HRESULT hr = S_OK;
    try {

        switch ( cmdId ) {
        
        case TB_CMD_VOLUME_LIST_NEW:

            {
                //
                // use wizard to create manage volume
                //
                CComObject<CWizManVolLst>* pWizard = new CComObject<CWizManVolLst>;
                WsbAffirmAlloc( pWizard );

                CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
                WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );

                if( S_OK == pWizard->m_HrFinish ) {

                WsbAffirmHr( RefreshScopePane() );

            }
            break;
        }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::OnToolbarButtonClick", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------------
//
//                  RefreshObject
//
//  Refresh data in the object.  This function is used for data that can change
//  (for example, volume utilization).
//
STDMETHODIMP CUiManVolLst::RefreshObject ()
{
    WsbTraceIn( L"CUiManVolLst::RefreshObject", L"" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    try {

        //
        // Get the server objects
        //
        m_pHsmServer.Release( );
        m_pFsaServer.Release( );
        m_pFsaFilter.Release( );
        m_pManResCollection.Release( );

        if( m_pSakSnapAsk->GetHsmServer( &m_pHsmServer ) == S_OK) {

            // Get the FsaServer object
            if ( m_pSakSnapAsk->GetFsaServer( &m_pFsaServer ) == S_OK) {

                // Get the Fsa Filter object
                WsbAffirmHr( m_pFsaServer->GetFilter( &m_pFsaFilter ) );

                // Tell FSA to rescan (updates properties)
                WsbAffirmHr( m_pFsaServer->ScanForResources( ) );

                // Get Managed Volumes collection from HSM server
                WsbAffirmHr( m_pHsmServer->GetManagedResources( &m_pManResCollection ) );

            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::RefreshObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVolLst::ShowManVolLstProperties (IDataObject *pDataObject, int initialPage)
{
    WsbTraceIn( L"CUiManVolLst::ShowManVolLstProperties", L"initialPage = <%d>", initialPage );

    HRESULT hr = S_OK;
    try {

        CComPtr <ISakNode> pSakNode;
        WsbAffirmHr( _InternalQueryInterface( IID_ISakNode, (void **) &pSakNode ) );
        WsbAffirmHr( m_pSakSnapAsk->ShowPropertySheet( pSakNode, pDataObject, initialPage ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::ShowManVolLstProperties", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//----------------------------------------------------------------------------
//
//      AddPropertyPages
//
STDMETHODIMP 
CUiManVolLst::AddPropertyPages( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID *pEnumObjectId, IEnumUnknown *pEnumUnkNode )
{
    WsbTraceIn( L"CUiManVolLst::AddPropertyPages", L"handle = <%ld>, pUnkPropSheetCallback = <0x%0.l8x>, pEnumObjectId = <0x%p>", 
        handle, pUnkPropSheetCallback, pEnumObjectId );
    HRESULT hr = S_OK;
    try {

        //
        // Create an object to hold the pages
        //
        CUiManVolLstSheet *pManVolPropertySheet = new CUiManVolLstSheet;
        WsbAffirmAlloc( pManVolPropertySheet );
        WsbAffirmHr( pManVolPropertySheet->InitSheet(
            handle, 
            pUnkPropSheetCallback, 
            (CSakNode *) this,
            m_pSakSnapAsk,
            pEnumObjectId,
            pEnumUnkNode
            ) );

        //
        // Tell the object to add it's pages
        //
        WsbAffirmHr( pManVolPropertySheet->AddPropertyPages( ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CUiManVolLst::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}



//---------------------------------------------------------------------------
//
//         CreateChildren
//
//  Create and initialize all the children of the Managed Resource List node.
//

STDMETHODIMP CUiManVolLst::CreateChildren( )
{
    WsbTraceIn( L"CUiManVolLst::CreateChildren", L"" );


    // Initialize the children of this node (no recursion. Decendents of children
    // are NOT created here)
    CComPtr<IUnknown> pUnkChild;            // IUnknown pointer to new child.
    CComPtr<ISakNode> pNode;
    HRESULT hr = S_OK;

    try {

        //
        // Get pointer to Hsm Managed Resource Collection object stored
        // in this UI node. This may be NULL in the case of the service
        // being down, in which case we don't want to do anything.
        //
        if( m_pManResCollection ) {

            ULONG count = 0;    // number of managed Resources in server
            WsbAffirmHr( m_pManResCollection->GetEntries( &count ) );

            CComPtr<IUnknown> pUnkHsmManRes;                // unknown pointer to Hsm volume
            for( int i = 0; i < (int)count; i++ ) {

                pUnkChild.Release( );
                pNode.Release( );
                pUnkHsmManRes.Release( );

                // Create a managed Resource UI node for each managed volume in the HsmServer.
                WsbAffirmHr( NewChild( cGuidManVol, &pUnkChild ) );
                WsbAffirmHr( RsQueryInterface( pUnkChild, ISakNode, pNode ) );

                WsbAffirmHr( m_pManResCollection->At( i, IID_IUnknown, (void**)&pUnkHsmManRes ) );
                // Initialize the child UI COM object, putting the Hsm managed Resource 
                // object inside the UI object.
                WsbAffirmHr( pNode->InitNode( m_pSakSnapAsk, pUnkHsmManRes, this ) );
    
                // Add the child COM object to the parent's list of children.
                WsbAffirmHr( AddChild( pNode ) );

            }

        }

    } WsbCatch( hr );

    // Indicate that this node's children are valid and up-to-date (even if there ARE
    // no children - at least now we know it).
    m_bChildrenAreValid = TRUE;

    // indicate that this parent node needs to be re-enumerated
    m_bEnumState = FALSE;

    WsbTraceOut( L"CUiManVolLst::CreateChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         InitNode
//
//  Initialize single COM object without using the registry. Derived
//  objects frequently augment this method by implementing it themselves.
//

STDMETHODIMP CUiManVolLst::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CUiManVolLst::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );

    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        WsbAffirmHr( CSakNode::InitNode( pSakSnapAsk, NULL, pParent ) );

        //
        // Set the object properties
        // Display Name
        //
        CString sDisplayName;
        sDisplayName.LoadString( IDS_MANVOLLST_DISPLAY_NAME );
        CWsbStringPtr szWsbDisplayName( sDisplayName );
        WsbAffirmHr( put_DisplayName( szWsbDisplayName ) );

        //
        // Description
        //
        CString sDescription;
        sDescription.LoadString( IDS_MANVOLLST_DESCRIPTION );
        CWsbStringPtr szWsbDescription( sDescription );
        WsbAffirmHr( put_Description( szWsbDescription ) );

        //
        // Set up the result view columns
        //
        WsbAffirmHr( SetChildProps( RS_STR_RESULT_PROPS_MANRESLST_IDS,
                                    IDS_RESULT_PROPS_MANRESLST_TITLES,
                                    IDS_RESULT_PROPS_MANRESLST_WIDTHS));
        
        
        WsbAffirmHr( RefreshObject( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CUiManVolLst::TerminateNode(
    )
/*++

Routine Description:

    Free any interface connections or other resources
    that would prevent correct shutdown of node (would
    keep ref count from going to 0).

Arguments:

    CopySet - copy set of interest.

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_* - Some error occurred. 

--*/
{
    WsbTraceIn( L"CUiManVolLst::TerminateNode", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Release any interface pointers kept so that circular references
        // are broken
        //
        m_pFsaServer.Release( ); 
        m_pManResCollection.Release( );
        m_pHsmServer.Release( );
        m_pFsaFilter.Release( );
        m_pSchedAgent.Release( );
        m_pTask.Release( );
        m_pTrigger.Release( );


        //
        // And call the base class for it's pieces
        //
        WsbAffirmHr( CSakNode::TerminateNode( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::TerminateNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// class CUiManVolLstSheet
//
HRESULT CUiManVolLstSheet::AddPropertyPages ( )
{
    WsbTraceIn( L"CUiManVolLstSheet::AddPropertyPages", L"" ); 
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    try {

        // --------------------- Statistics Page ----------------------------------

        // NOTE: We now use the same page as the volume property sheet !!

        CPrMrSts *pPropPageStatus = new CPrMrSts( TRUE );
        WsbAffirmAlloc( pPropPageStatus );

        AddPage( pPropPageStatus );


        // Add more pages here.
        // ....

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLstSheet::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVolLstSheet::GetNextFsaResource ( int *pBookMark, IFsaResource **ppFsaResource )
{
    WsbTraceIn( L"CUiManVolLstSheet::GetNextFsaResource", L"*pBookMark = <%d>", *pBookMark ); 

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;

    try {

        WsbAffirm ( *pBookMark >= 0, E_FAIL );

        CComPtr <IWsbIndexedCollection> pManResCollection;
        WsbAffirmHr( GetManResCollection( &pManResCollection ) );

        CComPtr <IHsmManagedResource> pHsmManRes;
        CComPtr <IUnknown> pUnkFsaRes;
        hr = pManResCollection->At(*pBookMark, IID_IHsmManagedResource, (void**) &pHsmManRes);
        if ( hr == S_OK ) {

            (*pBookMark)++;
            WsbAffirmHr( pHsmManRes->GetFsaResource( &pUnkFsaRes ));
            WsbAffirmHr( pUnkFsaRes->QueryInterface( IID_IFsaResource, (void**) ppFsaResource ) );

        }

    } WsbCatch (hr);

    WsbTraceOut( L"CUiManVolLstSheet::GetNextFsaResource", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}


// This function is to be called from the page thread
HRESULT CUiManVolLstSheet::GetManResCollection( IWsbIndexedCollection **ppManResCollection )
{
    WsbTraceIn( L"CUiManVolLstSheet::GetManResCollection", L"" ); 
    HRESULT hr = S_OK;

    try {

        CComPtr <IHsmServer> pHsmServer;
        WsbAffirmHrOk( GetHsmServer( &pHsmServer ) );

        //
        // Get Managed Volumes collection from HSM server
        // 
        WsbAffirmHr( pHsmServer->GetManagedResources( ppManResCollection ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLstSheet::GetManResCollection", L"hr = <%ls>, *ppManResCollection = <0x%p>", 
        WsbHrAsString( hr ), *ppManResCollection );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\prmrie.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrIe.cpp

Abstract:

    Inclusion / Exclusion property Page.

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PrMrIe.h"
#include "Rule.h"
#include "joblib.h"
#include "manvol.h"
#include "IeList.h"

static DWORD pHelpIds[] = 
{

    IDC_LIST_IE_LABEL,  idh_rule_list,
    IDC_LIST_IE,        idh_rule_list,
    IDC_BTN_ADD,        idh_new_rule_button,    
    IDC_BTN_REMOVE,     idh_rule_delete_button, 
    IDC_BTN_EDIT,       idh_rule_edit_button,   
    IDC_BTN_UP,         idh_rule_up_button, 
    IDC_BTN_DOWN,       idh_rule_down_button,   

    0, 0
};

// Columns for listview control
#define IE_COLUMN_ACTION        0
#define IE_COLUMN_FILE_TYPE     1
#define IE_COLUMN_PATH          2
#define IE_COLUMN_ATTRS         3

int CALLBACK CompareFunc( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort );
int PathCollate( CString PathA, CString PathB );

/////////////////////////////////////////////////////////////////////////////
// CPrMrIe property page

CPrMrIe::CPrMrIe( ) : CSakVolPropPage( CPrMrIe::IDD )
{
    //{{AFX_DATA_INIT( CPrMrIe )
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_hConsoleHandle = NULL;
    m_LineCount      = 0;
    m_pHelpIds       = pHelpIds;
}

CPrMrIe::~CPrMrIe( )
{
    int i;
    // Clean up old lines
    for( i = 0; i < m_LineCount; i++ ) {
        if( m_LineList[ i ] ) {
            delete m_LineList[ i ];
        }
    }
    m_LineCount = 0;
}

void CPrMrIe::DoDataExchange( CDataExchange* pDX )
{
    CSakVolPropPage::DoDataExchange( pDX );
    //{{AFX_DATA_MAP( CPrMrIe )
    DDX_Control( pDX, IDC_BTN_UP, m_BtnUp );
    DDX_Control( pDX, IDC_BTN_REMOVE, m_BtnRemove );
    DDX_Control( pDX, IDC_BTN_EDIT, m_BtnEdit );
    DDX_Control( pDX, IDC_BTN_DOWN, m_BtnDown );
    DDX_Control( pDX, IDC_BTN_ADD, m_BtnAdd );
    DDX_Control( pDX, IDC_LIST_IE, m_listIncExc );
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP( CPrMrIe, CSakVolPropPage )
    //{{AFX_MSG_MAP( CPrMrIe )
    ON_BN_CLICKED( IDC_BTN_ADD, OnBtnAdd )
    ON_BN_CLICKED( IDC_BTN_DOWN, OnBtnDown )
    ON_BN_CLICKED( IDC_BTN_REMOVE, OnBtnRemove )
    ON_BN_CLICKED( IDC_BTN_UP, OnBtnUp )
    ON_BN_CLICKED( IDC_BTN_EDIT, OnBtnEdit )
    ON_WM_DESTROY( )
    ON_NOTIFY( NM_DBLCLK, IDC_LIST_IE, OnDblclkListIe )
    ON_NOTIFY( NM_CLICK, IDC_LIST_IE, OnClickListIe )
    ON_NOTIFY( LVN_ITEMCHANGED, IDC_LIST_IE, OnItemchangedListIe )
    ON_WM_VSCROLL( )
    ON_WM_DRAWITEM( )
    ON_WM_MEASUREITEM( )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CPrMrIe message handlers

BOOL CPrMrIe::OnApply( ) 
{
    ULONG           count = 0;  
    int             i;
    CComPtr<IHsmRule> pLocalRule;
    CString         path;
    CString         name;
    BOOL            bInclude;
    BOOL            bSubdirs;
    BOOL            bUserDefined;
    HRESULT         hr;
    CComPtr<IHsmRule>               pRemoteRule;
    CComPtr<IWsbCreateLocalObject>  pLocalObject;
    CComPtr<IHsmCriteria>           pCriteria;
    CComPtr<IWsbCollection>         pCriteriaCollection;
    CComPtr <IUnknown>              pUnkRule;
    CComPtr <IWsbCollection>        pRulesCollection;

    try {

        // Empty the collection of rules
        WsbAffirmPointer( m_pRulesIndexedCollection );
        WsbAffirmHr( m_pRulesIndexedCollection->QueryInterface( IID_IWsbCollection,( void ** ) &pRulesCollection ) );
        pRulesCollection->RemoveAllAndRelease( );

        //
        // Get a CreateLocalobject interface with which to create the
        // new rule( s ).
        //
        WsbAffirmPointer( m_pFsaServer );
        WsbAffirmHr( m_pFsaServer->QueryInterface( IID_IWsbCreateLocalObject,( void ** ) &pLocalObject ) );

        //
        // Now go through the list box and add the rules in the list box to the 
        // collection. Must do this backwards to be considered correctly by 
        // job mechanism
        //
        int listCount = m_listIncExc.GetItemCount( );
        int insertIndex = 0;

        for( i = listCount - 1; i >= 0; i-- ) {

            //
            // Get the pointer to the rule from the list box
            //
            pLocalRule.Release( );
            pLocalRule = (IHsmRule *) m_listIncExc.GetItemData( i );
            if( pLocalRule ) {

                //
                // Get rule data from the local object
                //
                WsbAffirmHr( GetRuleFromObject( pLocalRule, path,
                    name, &bInclude, &bSubdirs, &bUserDefined ) );
                
                //
                // Create a new remote rule object in the Fsa
                //
                pRemoteRule.Release( );
                WsbAffirmHr( pLocalObject->CreateInstance( CLSID_CHsmRule, IID_IHsmRule,( void** ) &pRemoteRule ) );
                
                //
                // Set the data in the remote rule object
                //
                WsbAffirmHr( SetRuleInObject( pRemoteRule, path, name, bInclude, bSubdirs, bUserDefined ) );
                
                //
                // Add the rule pointer to the collection of rules
                //
                pUnkRule.Release( );
                WsbAffirmHr( pRemoteRule->QueryInterface( IID_IUnknown, (void **) &pUnkRule ) );
                WsbAffirmHr( m_pRulesIndexedCollection->AddAt( pUnkRule, insertIndex++ ) );
                
                //
                // Get the criteria collection pointer
                //
                pCriteriaCollection.Release( );
                WsbAffirmHr( pRemoteRule->Criteria( &pCriteriaCollection ) );
                
                //
                // Add the appropriate criterion to the rule
                //
                pCriteria.Release( );
                switch( bInclude ) {
                case TRUE:
                    //
                    // Include 
                    //
                    WsbAffirmHr( pLocalObject->CreateInstance( CLSID_CHsmCritManageable, IID_IHsmCriteria,( void** ) &pCriteria ) );
                    WsbAffirmHr( pCriteria->SetIsNegated( FALSE ) );
                    break;
                
                case FALSE:
                    //
                    // Exclude
                    //
                    WsbAffirmHr( pLocalObject->CreateInstance( CLSID_CHsmCritAlways, IID_IHsmCriteria,( void** ) &pCriteria ) );
                    WsbAffirmHr( pCriteria->SetIsNegated( FALSE ) );
                    break;

                }
                
                WsbAffirmHr( pCriteriaCollection->Add( pCriteria ) );

            }


        }

        //
        // Tell the FSA to save itself.
        //
        WsbAffirmHr( RsServerSaveAll( m_pFsaServer ) );

    } WsbCatch( hr );

    return CSakVolPropPage::OnApply( );
}
HRESULT CPrMrIe::SetRuleInObject( 
                    IHsmRule *pHsmRule, 
                    CString Path, 
                    CString Name, 
                    BOOL bInclude, 
                    BOOL bSubdirs, 
                    BOOL bUserDefined )
{
    HRESULT hr = S_OK;

    try {
        CWsbStringPtr wsbPath = Path;
        CWsbStringPtr wsbName = Name;
        WsbAffirmHr( pHsmRule->SetPath( ( OLECHAR * )wsbPath ) );
        WsbAffirmHr( pHsmRule->SetName( ( OLECHAR * )wsbName ) );
        WsbAffirmHr( pHsmRule->SetIsInclude( bInclude ) );
        WsbAffirmHr( pHsmRule->SetIsUsedInSubDirs( bSubdirs ) );
        WsbAffirmHr( pHsmRule->SetIsUserDefined( bUserDefined ) );
    } WsbCatch( hr );
    return( hr );
}

BOOL CPrMrIe::OnInitDialog( ) 
{
    CSakVolPropPage::OnInitDialog( );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    ULONG           count = 0;  
    int             index = 0;
    HRESULT         hr = S_OK;
    CString path;
    CString name;
    BOOL bInclude;
    BOOL bSubdirs;
    BOOL bUserDefined;
    RECT rect;
    CString *columnWidths[20];
    int cColumns;
    int columnWidth[20];
    CString *columnTitles[20];
    CSize size;

    try {
    
        //
        // Set the icons into the buttons
        //
        HRESULT hrAlternateIcon = RsIsWhiteOnBlack( );
        HICON downIcon, upIcon;
        downIcon = (HICON)LoadImage( _Module.m_hInstResource,
            S_OK == hrAlternateIcon ? MAKEINTRESOURCE( IDI_MOVEDOWN2 ) : MAKEINTRESOURCE( IDI_MOVEDOWN ),
            IMAGE_ICON, 16, 16, 0 );
        upIcon   = (HICON)LoadImage( _Module.m_hInstResource,
            S_OK == hrAlternateIcon ? MAKEINTRESOURCE( IDI_MOVEUP2 ) : MAKEINTRESOURCE( IDI_MOVEUP ),
            IMAGE_ICON, 16, 16, 0 );

        m_BtnDown.SetIcon( downIcon );
        m_BtnUp.SetIcon( upIcon );

        //
        // Setup up rules listview
        //
        CString sTitle;
        m_listIncExc.GetClientRect( &rect );
        ULONG totalWidth = rect.right;

        RsGetInitialLVColumnProps( 
            IDS_LISTVIEW_WIDTHS_IE,
            IDS_LISTVIEW_TITLES_IE,
            columnWidths, 
            columnTitles,
            &cColumns
            );

        //
        // NOTE: We shouldn't throw any errors until the DC is released
        //
        for( int col = 0; col < cColumns; col++ ) {

            size = m_listIncExc.GetStringWidth( *columnWidths[col] );
            columnWidth[col] = size.cx + 12;
            m_listIncExc.InsertColumn( col, *columnTitles[col], LVCFMT_LEFT, columnWidth[col] );

            // Free the CStrings
            delete columnTitles[col];
            delete columnWidths[col];

        }

        m_listIncExc.Initialize( cColumns, IE_COLUMN_PATH );

        // Set the Path column to fit
        int leftOver = totalWidth - columnWidth[IE_COLUMN_ACTION] - 
            columnWidth[IE_COLUMN_FILE_TYPE] - columnWidth[IE_COLUMN_ATTRS]; 
        m_listIncExc.SetColumnWidth( IE_COLUMN_PATH, leftOver );

        // Note: this page is only implemented for single select
        WsbAffirm( ( m_pParent->IsMultiSelect( ) != S_OK ), E_FAIL );

        // Get the FsaServer interface - Apply will need it
        WsbAffirmHr( m_pParent->GetFsaServer( &m_pFsaServer ) );
        // Get the resource pointer from the sheet object
        WsbAffirmHr( m_pVolParent->GetFsaResource( &m_pFsaResource ) );

        // Get the rules collection from the resource
        CComPtr <IWsbCollection> pRulesCollection;
        WsbAffirmHr( m_pFsaResource->GetDefaultRules( &pRulesCollection ) );
        WsbAffirmHr( pRulesCollection->QueryInterface( IID_IWsbIndexedCollection, (void **) &m_pRulesIndexedCollection ) );

        CString resourceName;
        WsbAffirmHr( RsGetVolumeDisplayName( m_pFsaResource, resourceName ) );
        m_pResourceName = resourceName;

        // Itterate through the indexed collection
        WsbAffirmHr( m_pRulesIndexedCollection->GetEntries( &count ) );

        CComPtr <IHsmRule> pLocalRule;
        CComPtr <IHsmRule> pHsmRule;

        // Put the rules in the collection in reverse order
        for( INT i =( int ) count - 1; i >= 0; i-- ) {

            pHsmRule.Release( );
            pLocalRule.Release( );
            WsbAffirmHr( m_pRulesIndexedCollection->At( i, IID_IHsmRule,( void** )&pHsmRule ) );

            //
            // Create a local rule object and copy the remote object to it
            //
            WsbAffirmHr( pLocalRule.CoCreateInstance( CLSID_CHsmRule ) );
            WsbAffirmHr( GetRuleFromObject( pHsmRule, path, name, &bInclude, &bSubdirs, &bUserDefined ) );
            WsbAffirmHr( SetRuleInObject( pLocalRule, path, name, bInclude, bSubdirs, bUserDefined ) );

            //
            // Insert rule in list box
            //
            index = m_listIncExc.InsertItem( count - 1 - i, TEXT( "" ) );

            //
            // Set the item data to the local object
            //
            m_listIncExc.SetItemData( index, (UINT_PTR) pLocalRule.Detach( ) );

            //
            // Show the rule in the list box
            //
            WsbAffirmHr( DisplayUserRuleText( &m_listIncExc, index ) );

        } // for

        SortList( );

    } WsbCatch( hr );

    SetBtnState( );
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//HRESULT CPrMrIe::CreateImageList( )
//{
//  HICON hIcon;
//  int nImage;
//  HRESULT hr;
//
//  AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
//
//  try {
//  
//      CWinApp* pApp = AfxGetApp( );
//
//      WsbAffirm( m_ImageList.Create( ::GetSystemMetrics( SM_CXSMICON ),
//                              ::GetSystemMetrics( SM_CYSMICON ),
//                              ILC_COLOR | ILC_MASK, 2,5 ), E_FAIL );
//
//      hIcon = pApp->LoadIcon( IDI_LOCKED );
//      WsbAffirm( hIcon, E_FAIL );
//      nImage = m_ImageList.Add( hIcon );
//      ::DeleteObject( hIcon );
//
//      hIcon = pApp->LoadIcon( IDI_UNLOCKED );
//      WsbAffirm( hIcon, E_FAIL );
//      nImage = m_ImageList.Add( hIcon );
//      ::DeleteObject( hIcon );
//
//      m_listIncExc.SetImageList( &m_ImageList, LVSIL_SMALL );
//  } WsbCatch( hr );
//  return( hr );
//}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// Display the rule contained in the supplied object in the supplied list at the indicated
// index.  The itemdata must be set to the object with correct data in it.
//
HRESULT  CPrMrIe::DisplayUserRuleText( 
        CListCtrl *pListControl,
        int index )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;
    try {

        CString textString, tempString;
        CString path, name;
        BOOL bInclude;
        BOOL bSubdirs;
        BOOL bUserDefined;
        CComPtr<IHsmRule> pHsmRule;

        //
        // Get the rule from the object 
        //
        pHsmRule = (IHsmRule *) m_listIncExc.GetItemData( index );
        WsbAssertPointer( pHsmRule );
        WsbAffirmHr( GetRuleFromObject( pHsmRule, path, name, &bInclude, &bSubdirs, &bUserDefined ) );

        //
        // Show the values in the list box
        //

        // ACTION
        textString.LoadString( bInclude ? IDS_INCLUDE : IDS_EXCLUDE );
        WsbAffirm( pListControl->SetItemText( index, IE_COLUMN_ACTION, textString ), E_FAIL );

        // FILE TYPE
        WsbAffirm( pListControl->SetItemText( index, IE_COLUMN_FILE_TYPE, name ), E_FAIL );

        // PATH
        WsbAffirm( pListControl->SetItemText( index, IE_COLUMN_PATH, path ), E_FAIL );

        // ATTRS
        textString.LoadString( bSubdirs ? IDS_RULE_SUBDIRS_USE : IDS_RULE_SUBDIRS_IGNORE );
        tempString.LoadString( bUserDefined ? IDS_RULE_TYPE_USER : IDS_RULE_TYPE_SYSTEM );
        textString.TrimLeft( );
        tempString.TrimLeft( );
        textString += tempString;
        WsbAffirm( pListControl->SetItemText( index, IE_COLUMN_ATTRS, textString ), E_FAIL );

    } WsbCatch( hr );

    return( hr );
}

HRESULT CPrMrIe::GetRuleFromObject( 
        IHsmRule *pHsmRule, 
        CString& Path,
        CString& Name,
        BOOL *bInclude,
        BOOL *bSubdirs,
        BOOL *bUserDefined )
{
    CWsbStringPtr wsbName;
    CWsbStringPtr wsbPath;
    HRESULT hr = S_OK;

    try {

        // Get the values from the object
        WsbAffirmHr( pHsmRule->GetName( &wsbName, 0 ) );
        Name = wsbName;
        WsbAffirmHr ( pHsmRule->GetPath( &wsbPath, 0 ) );
        Path = wsbPath;
        *bInclude =( pHsmRule->IsInclude( ) == S_OK ) ? TRUE : FALSE;
        *bSubdirs =( pHsmRule->IsUsedInSubDirs( ) == S_OK ) ? TRUE : FALSE;
        *bUserDefined =( pHsmRule->IsUserDefined( ) == S_OK ) ? TRUE : FALSE;
    } WsbCatch( hr );
    return( hr );
}
void CPrMrIe::OnBtnAdd( ) 
{
    LRESULT nRet;
    int index;
    BOOL fDone = FALSE;
    HRESULT hr;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    CRule ruleDlg;
    ruleDlg.m_subDirs = FALSE;
    ruleDlg.m_includeExclude = 0; // Exclude
    ruleDlg.m_path = TEXT( "" );
    ruleDlg.m_fileSpec = TEXT( "" );
    ruleDlg.m_pResourceName = m_pResourceName;

    try {
        while( !fDone )
        {
            nRet = ruleDlg.DoModal( );
            if( nRet == IDOK ) {

                //
                // OK was pressed
                // Check for dupes( in entire list )
                //
                if( !IsRuleInList( ruleDlg.m_path,  ruleDlg.m_fileSpec, -1 ) ) {

                    fDone = TRUE;

                    //
                    // Create a new local rule object
                    //
                    CComPtr <IHsmRule> pLocalRule;
                    WsbAffirmHr( pLocalRule.CoCreateInstance( CLSID_CHsmRule ) );

                    //
                    // Set the data in the local object
                    //
                    WsbAffirmHr( SetRuleInObject( pLocalRule, ruleDlg.m_path, ruleDlg.m_fileSpec,
                                ruleDlg.m_includeExclude, ruleDlg.m_subDirs, TRUE ) );

                    //
                    // Insert the rule and put the pointer in the list.
                    // We will sort the list later
                    //
                    index = m_listIncExc.InsertItem( 0, TEXT( "" ) );

                    //
                    // Set the item data to the local object
                    //
                    m_listIncExc.SetItemData( index, (UINT_PTR) pLocalRule.Detach( ) );
            
                    //
                    // Show the rule in the list box
                    //
                    WsbAffirmHr( DisplayUserRuleText( &m_listIncExc, index ) );

                    //
                    // Sort the list
                    //
                    SortList( );
                    SetSelectedItem( (ULONG_PTR)(void *) pLocalRule );
                    SetModified( );

                } else {

                    //
                    // Rule is a duplicate
                    //
                    CString sText;
                    AfxFormatString2( sText, IDS_ERR_RULE_DUPLICATE, ruleDlg.m_path, ruleDlg.m_fileSpec );
                    AfxMessageBox( sText, RS_MB_ERROR );

                }

            } else {

                //
                // Cancel was pressed
                //
                fDone = TRUE;

            }

        } // while
    } WsbCatch( hr )

    SetBtnState( );
}

// Select the item corresponding to the supplied item data
void CPrMrIe::SetSelectedItem( ULONG_PTR itemData )
{

    int listCount = m_listIncExc.GetItemCount( );
    for( int i = 0; i < listCount; i++ ) {

        // Get the pointer to the rule from the list box
        if( itemData ==( m_listIncExc.GetItemData( i ) ) ) {

            // Mark the item as selected
            m_listIncExc.SetItemState( i, LVIS_SELECTED, LVIS_SELECTED );
            m_listIncExc.EnsureVisible( i, FALSE );
            break;

        }
    }
}

void CPrMrIe::OnBtnDown( ) 
{

    MoveSelectedListItem( &m_listIncExc, + 1 );
    SetBtnState( );
}

void CPrMrIe::SortList( )
{
    m_listIncExc.SortItems( CompareFunc, NULL );
}

int CALLBACK CompareFunc( LPARAM lParam1, LPARAM lParam2, 
    LPARAM /*lParamSort*/ )
{
    CComPtr<IHsmRule> pHsmRule;
    CWsbStringPtr   wsbPathA;
    CWsbStringPtr   wsbPathB;

    // Get data for RuleA
    pHsmRule = (IHsmRule *) lParam1;
    WsbAffirmHr( pHsmRule->GetPath( &wsbPathA, 0 ) );
    CString pathA = wsbPathA;

    // Get data for RuleB
    pHsmRule = (IHsmRule *) lParam2;
    WsbAffirmHr ( pHsmRule->GetPath( &wsbPathB, 0 ) );
    CString pathB = wsbPathB;

    // Upper case the paths
    pathA.MakeUpper( );
    pathB.MakeUpper( );

    // Compare the two paths
    int rVal = PathCollate( pathA, pathB );
//  int rVal = pathA.Collate( pathB );
//  int rVal = pathB.Compare( pathA );

    return rVal;
}

int PathCollate( CString PathA, CString PathB )
{
    CString charA;
    CString charB;
    int compareLen;
    int rVal;

    int lenA = PathA.GetLength( );
    int lenB = PathB.GetLength( );

    compareLen = min( lenA, lenB );

    for( int i = 0; i < compareLen; i++ )
    {
        charA = PathA.GetAt( i );
        charB = PathB.GetAt( i );

        // If either is a \, we bypass Collate
        if( ( charA == L"\\" ) &( charB != L"\\" ) ) {

            // A is \ and B is not - A is less than B
            return -1;

        }
        if( ( charA != L"\\" ) &( charB == L"\\" ) ) {

            // A is not \ and B is - B is less than A
            return 1;

        }

        // NOTE: If both are \, the CString Collate result is correct

        rVal = charA.Collate( charB );
        if( rVal != 0 )  {

            return rVal;

        }

    }
    // If we get here, the strings are equal as far as the shorter string.
    rVal = ( lenA < lenB ) ? -1 : ( lenB < lenA ) ? 1 : 0;

    return rVal;
}

void CPrMrIe::MoveSelectedListItem( CListCtrl *pList, int moveAmount )
{

    int curIndex = -1;
    int itemCount = 0;
    CString         pathA;
    CString         pathB;
    CString         path;
    CString         name;
    BOOL            bInclude;
    BOOL            bSubdirs;
    BOOL            bUserDefined;
    CComPtr<IHsmRule> pLocalRule;

    // Get the current index
    curIndex = pList->GetNextItem( -1, LVNI_SELECTED );

    // Is an item selected?
    if( curIndex != -1 ) {

        // Is this a user-defined rule?
        pLocalRule =( IHsmRule * ) m_listIncExc.GetItemData( curIndex );

        GetRuleFromObject( pLocalRule, path, name, &bInclude, &bSubdirs, &bUserDefined );
        if( bUserDefined ) 
        {
            // Get the item count
            itemCount = pList->GetItemCount( );

            // Is there more than one item in the list?
            if( itemCount > 1 )
            {
                // Make sure where we're moving to is in range
                if( ( ( curIndex + moveAmount ) < itemCount ) &&
                   ( ( curIndex + moveAmount ) >= 0 ) ) {

                    // Does the rule we're moving to have the same path?
                    pathA = pList->GetItemText( curIndex, IE_COLUMN_PATH );
                    pathB = pList->GetItemText( curIndex + moveAmount, IE_COLUMN_PATH );

                    if( pathA.CompareNoCase( pathB ) == 0 ) {
                        // Swap the lines
                        SwapLines( pList, curIndex, curIndex + moveAmount );
                        // Select the orignal line in it's new position and make
                        // sure it's shown.
                        pList->SetItemState( curIndex + moveAmount, LVIS_SELECTED, LVIS_SELECTED );
                        pList->EnsureVisible( curIndex + moveAmount, FALSE );

                        SetModified( );
                    }
                    else {
                        MessageBeep( MB_OK );
                    }

                } else {
                    MessageBeep( MB_OK );
                }
            }
            else { 
                MessageBeep( MB_OK );
            }

        } else {
            MessageBeep( MB_OK );
        }
    } else {
        MessageBeep( MB_OK );
    }
}
void CPrMrIe::SwapLines( CListCtrl *pListControl, int indexA, int indexB )
{

    CComPtr<IHsmRule> pHsmRuleA;
    CComPtr<IHsmRule> pHsmRuleB;

    //-------------------- Get data from list ----------------------------------
    // LIST A
    // Get the item data
    pHsmRuleA = (IHsmRule *) pListControl->GetItemData( indexA );

    // LIST B
    // Get the item data
    pHsmRuleB = (IHsmRule *) pListControl->GetItemData( indexB );

    //--------------------- Show data in list ------------------------------------

    // Set the item data
    m_listIncExc.SetItemData( indexA,( DWORD_PTR )( void * ) pHsmRuleB );

    // Show the rule
    DisplayUserRuleText( pListControl,  indexA );

    // Set the item data
    m_listIncExc.SetItemData( indexB,( DWORD_PTR )( void * ) pHsmRuleA );

    // Show the rule
    DisplayUserRuleText( pListControl,  indexB );

}
    
void CPrMrIe::SetBtnState( )
{
    CString         path;
    CString         name;
    CWsbStringPtr   pathAbove;
    CWsbStringPtr   pathBelow;
    BOOL            bInclude;
    BOOL            bSubdirs;
    BOOL            bUserDefined;
    int             curIndex;
    CComPtr<IHsmRule> pLocalRule;
    CComPtr<IHsmRule> pLocalRuleAbove;
    CComPtr<IHsmRule> pLocalRuleBelow;


    curIndex = m_listIncExc.GetNextItem( -1, LVNI_SELECTED ); 
    if( curIndex != -1 ) {
        // An item is selected.  Is it User-Defined?
        pLocalRule =( IHsmRule * ) m_listIncExc.GetItemData( curIndex );
        if( !pLocalRule ) {

            // Seperator
            m_BtnRemove.EnableWindow( FALSE );
            m_BtnEdit.EnableWindow( FALSE );
            m_BtnAdd.EnableWindow( TRUE );
            m_BtnUp.EnableWindow( FALSE );
            m_BtnDown.EnableWindow( FALSE );

        } else {

            GetRuleFromObject( pLocalRule, path, name, &bInclude, &bSubdirs, &bUserDefined );
            if( bUserDefined ) {
                // User-Defined Rule is editable
                m_BtnRemove.EnableWindow( TRUE );
                m_BtnEdit.EnableWindow( TRUE );
                m_BtnAdd.EnableWindow( TRUE );
                // Are we at the top?
                if( curIndex == 0 ) {

                    m_BtnUp.EnableWindow( FALSE );

                } else {

                    // Does the rule above have the same path? or is separator
                    pLocalRuleAbove =( IHsmRule * ) m_listIncExc.GetItemData( curIndex - 1 );
                    if( pLocalRuleAbove ) {
                        pLocalRuleAbove->GetPath( &pathAbove, 0 );
                        if( path.CompareNoCase( pathAbove ) == 0 ) {
                            m_BtnUp.EnableWindow( TRUE );
                        } else {
                            m_BtnUp.EnableWindow( FALSE );
                        }
                    } else {
                        m_BtnUp.EnableWindow( FALSE );
                    }

                }
                // Are we at the bottom?
                if( curIndex ==( m_listIncExc.GetItemCount( ) - 1 ) ) {
                    m_BtnDown.EnableWindow( FALSE );
                } else {
                    // Does the rule below have the same path?
                    pLocalRuleBelow =( IHsmRule * ) m_listIncExc.GetItemData( curIndex + 1 );
                    if( pLocalRuleBelow ) {
                        pLocalRuleBelow->GetPath( &pathBelow, 0 );
                        if( path.CompareNoCase( pathBelow ) == 0 ) {
                            m_BtnDown.EnableWindow( TRUE );
                        } else {
                            m_BtnDown.EnableWindow( FALSE );
                        }
                    } else {
                        m_BtnDown.EnableWindow( FALSE );
                    }
                }
            }
            else {
                // System rule.  Cannot be moved or modified.
                m_BtnUp.EnableWindow( FALSE );
                m_BtnRemove.EnableWindow( FALSE );
                m_BtnEdit.EnableWindow( FALSE );
                m_BtnDown.EnableWindow( FALSE );
                m_BtnAdd.EnableWindow( TRUE );
            }
        }
    }
    else {
        // No items selected
        m_BtnUp.EnableWindow( FALSE );
        m_BtnRemove.EnableWindow( FALSE );
        m_BtnEdit.EnableWindow( FALSE );
        m_BtnDown.EnableWindow( FALSE );
        m_BtnAdd.EnableWindow( TRUE );
    }
}
    
void CPrMrIe::OnBtnRemove( ) 
{
    int curIndex;
    CString         path;
    CString         name;
    BOOL            bInclude;
    BOOL            bSubdirs;
    BOOL            bUserDefined;
    IHsmRule        *pHsmRule; // OK to not use smart pointer
    HRESULT hr;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {
        // Is there an item selected?
        curIndex = m_listIncExc.GetNextItem( -1, LVNI_SELECTED ); 
        if( curIndex != -1 )
        {
            // Is the rule User-Defined?
            pHsmRule =( IHsmRule * ) m_listIncExc.GetItemData( curIndex );
            GetRuleFromObject( pHsmRule, path, name, &bInclude, &bSubdirs, &bUserDefined );

            if( bUserDefined )
            {

                // Confirm with user
                CString sMessage;
                AfxFormatString2( sMessage, IDS_CONFIRM_DELETE_RULE, path, name );
                if( AfxMessageBox( sMessage, MB_ICONQUESTION | MB_DEFBUTTON2 | MB_YESNO ) == IDYES )
                {
                    // Get and release the local object pointer
                    WsbAffirmPointer( pHsmRule );
                    pHsmRule->Release( );

                    // Remove from the list control
                    m_listIncExc.DeleteItem( curIndex );
                    int setIndex;
                    if( curIndex >= m_listIncExc.GetItemCount( ) ) {
                        setIndex = m_listIncExc.GetItemCount( ) - 1;
                    } else {
                        setIndex = curIndex;
                    }

                    // Select the item above the removed item
                    m_listIncExc.SetItemState( setIndex, LVIS_SELECTED, LVIS_SELECTED );
                    m_listIncExc.EnsureVisible( setIndex, FALSE );
                    SortList( );
                    SetModified( );
                }
            }
            else {
                MessageBeep( MB_OK );
            }
        }
        else {

            // No item selected
            AfxMessageBox( IDS_ERR_NO_ITEM_SELECTED, RS_MB_ERROR );
        }
    } WsbCatch( hr );
    SetBtnState( );
}

void CPrMrIe::OnBtnUp( ) 
{
    MoveSelectedListItem( &m_listIncExc, - 1 );
    SetBtnState( );
}

void CPrMrIe::OnBtnEdit( ) 
{
    BOOL fDone = FALSE;
    LRESULT nRet;
    int curIndex;
    CString path;
    CString name;
    BOOL bInclude;
    BOOL bSubdirs;
    BOOL bUserDefined;

    HRESULT hr;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );


    try {

        // Get the currently selected item
        curIndex = m_listIncExc.GetNextItem( -1, LVNI_SELECTED );
        if( curIndex == -1 ) {

            // No item selected
            AfxMessageBox( IDS_ERR_NO_ITEM_SELECTED, RS_MB_ERROR );

        } else {

            // Create the rule dialog
            CRule ruleDlg;

            // Get the local object from the list itemdata
            CComPtr<IHsmRule> pLocalRule;
            pLocalRule = (IHsmRule *) m_listIncExc.GetItemData( curIndex );
            WsbAffirmPointer( pLocalRule );

            // Get the rule from the local object
            WsbAffirmHr( GetRuleFromObject( pLocalRule, path, name, &bInclude, &bSubdirs, &bUserDefined ) );

            // Is this a user-defined rule?
            if( bUserDefined ) {

                // Set the rule info in the rule dialog
                ruleDlg.m_subDirs = bSubdirs;
                ruleDlg.m_includeExclude = bInclude; 
                ruleDlg.m_path = path;
                ruleDlg.m_fileSpec = name;
                ruleDlg.m_pResourceName = m_pResourceName;


                while( !fDone ) {

                    // Show the dialog
                    nRet = ruleDlg.DoModal( );
                    if( nRet == IDOK ) {
                        // OK was pressed

                        // Check for duplicates - but don't check against the rule we edited
                        // in case the path and fileSpec are stil the same
                        
                        if( !IsRuleInList( ruleDlg.m_path, ruleDlg.m_fileSpec, curIndex ) ) {

                            fDone = TRUE;
                            SetModified( );

                            // Set the data in the local object
                            WsbAffirmHr( SetRuleInObject( pLocalRule, ruleDlg.m_path, ruleDlg.m_fileSpec,
                                ruleDlg.m_includeExclude, ruleDlg.m_subDirs, TRUE ) );
                            
                            // Show the edited rule in the list box
                            WsbAffirmHr( DisplayUserRuleText( &m_listIncExc, curIndex ) ); 

                            // Resort the list
                            SortList( );
                            SetSelectedItem( (ULONG_PTR)(IHsmRule*) pLocalRule );

                        } else {

                            CString sText;
                            AfxFormatString2( sText, IDS_ERR_RULE_DUPLICATE, ruleDlg.m_path, ruleDlg.m_fileSpec );
                            AfxMessageBox( sText, RS_MB_ERROR );

                        }

                    } else {

                        fDone = TRUE;

                    }

                } // while

            } else { // Not user defined

                MessageBeep( MB_OK );

            }

        }

    } WsbCatch( hr );
    SetBtnState( );
}

BOOL CPrMrIe::IsRuleInList( CString Path, CString Name, int ignoreIndex )
{
    int i;
    int count;
    short result;
    HRESULT hr;
    BOOL fDuplicate = FALSE;
    CWsbStringPtr wsbPath;
    CWsbStringPtr wsbName;

    count = m_listIncExc.GetItemCount( );
    for( i = 0; i < count; i++ ) {
        // Make sure we're not comparing the rule to itself
        if( i != ignoreIndex ) {

            // Get the pointer to the rule from the list box
            CComPtr<IHsmRule> pHsmRule;
            pHsmRule = (IHsmRule *) m_listIncExc.GetItemData( i );
            if( !pHsmRule ) continue;

            // Convert name and path to wsb strings
            wsbPath = Path;
            wsbName = Name;

            hr = pHsmRule->CompareToPathAndName( wsbPath, wsbName, &result );
            if( result == 0 ) {

                // The rules are the same
                fDuplicate = TRUE;
                break;
            }

        }
    } // for
    return fDuplicate;
}

void CPrMrIe::OnDestroy( ) 
{
    HRESULT hr;
    CSakVolPropPage::OnDestroy( );
    IHsmRule *pHsmRule; //OK not to be smart pointer
    ULONG lRefCount;

    try {

        //  Release all local object pointers in the list box
        int listCount = m_listIncExc.GetItemCount( );
        for( int i = 0; i < listCount; i++ )
        {
            // Get the pointer to the rule from the list box
            pHsmRule = (IHsmRule *) m_listIncExc.GetItemData( i );
            if( pHsmRule ) {

                lRefCount = pHsmRule->Release( );

            }

        }

    } WsbCatch( hr );
}

void CPrMrIe::OnDblclkListIe( NMHDR* /*pNMHDR*/, LRESULT* pResult ) 
{
    OnBtnEdit( );
    *pResult = 0;
}

void CPrMrIe::OnClickListIe( NMHDR* /*pNMHDR*/, LRESULT* pResult ) 
{
    SetBtnState( );
    *pResult = 0;
}

void CPrMrIe::OnItemchangedListIe( NMHDR* pNMHDR, LRESULT* pResult ) 
{
    NM_LISTVIEW* pNMListView =( NM_LISTVIEW* )pNMHDR;
    SetBtnState( );
    *pResult = 0;
}


void CPrMrIe::OnVScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar ) 
{
    // TODO: Add your message handler code here and/or call default
    
    CSakVolPropPage::OnVScroll( nSBCode, nPos, pScrollBar );
}

void CPrMrIe::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
    // TODO: Add your message handler code here and/or call default
    
    CSakVolPropPage::OnDrawItem( nIDCtl, lpDrawItemStruct );
}

void CPrMrIe::OnMeasureItem( int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
    CFont *pFont;
    LOGFONT logFont; 

    pFont = GetFont( );
    pFont->GetLogFont( &logFont );

    LONG fontHeight = abs( logFont.lfHeight );

    // Ask the list how high to make each row.  It needs to know the font
    // height at this point because it's window is not yet created.
    lpMeasureItemStruct->itemHeight = m_listIncExc.GetItemHeight( fontHeight );
    
    CSakVolPropPage::OnMeasureItem( nIDCtl, lpMeasureItemStruct );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\prmrie.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrIe.h

Abstract:

    Inclusion / Exclusion property Page.

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#ifndef _PRMRIE_H
#define _PRMRIE_H

/////////////////////////////////////////////////////////////////////////////
// CPrMrIe dialog

#include "stdafx.h"
#include "IeList.h"

#define MAX_RULES 512

class CPrMrIe : public CSakVolPropPage
{
// Construction
public:
    CPrMrIe();
    ~CPrMrIe();

// Dialog Data
    //{{AFX_DATA(CPrMrIe)
    enum { IDD = IDD_PROP_MANRES_INCEXC };
    CButton m_BtnUp;
    CButton m_BtnRemove;
    CButton m_BtnEdit;
    CButton m_BtnDown;
    CButton m_BtnAdd;
    CIeList m_listIncExc;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrMrIe)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrMrIe)
    virtual BOOL OnInitDialog();
    afx_msg void OnBtnAdd();
    afx_msg void OnBtnDown();
    afx_msg void OnBtnRemove();
    afx_msg void OnBtnUp();
    afx_msg void OnBtnEdit();
    afx_msg void OnDestroy();
    afx_msg void OnDblclkListIe(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnClickListIe(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemchangedListIe(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
    afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    // Unmarshalled pointer to managed resource 
    CComPtr     <IFsaResource> m_pFsaResource;

    // UnMarshalled pointer to FsaServer
    CComPtr     <IFsaServer> m_pFsaServer;

private:
    CStatic         *m_LineList[MAX_RULES];
    USHORT          m_LineCount;


    CWsbStringPtr   m_pResourceName; // Name of this resource

    // Collection of rules for this managed resource
    CComPtr <IWsbIndexedCollection> m_pRulesIndexedCollection;

//  CImageList m_ImageList;
    

    HRESULT  DisplayUserRuleText (
        CListCtrl *pListControl,
        int index);

    HRESULT GetRuleFromObject (
        IHsmRule *pHsmRule, 
        CString& szPath,
        CString& szName,
        BOOL *bInclude,
        BOOL *bSubdirs,
        BOOL *bUserDefined);

    HRESULT CPrMrIe::SetRuleInObject (
        IHsmRule *pHsmRule, 
        CString szPath, 
        CString szName, 
        BOOL bInclude, 
        BOOL bSubdirs, 
        BOOL bUserDefined);

//  HRESULT CreateImageList(void);

    void MoveSelectedListItem(CListCtrl *pList, int moveAmount);
    void SwapLines(CListCtrl *pListControl, int indexA, int indexB);
    void SetBtnState(void);
    void SortList(void);
    void FixRulePath (CString& sPath);
    BOOL IsRuleInList(CString sPath, CString sFileSpec, int ignoreIndex);
    void SetSelectedItem( ULONG_PTR itemData );

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\prmrlvl.h ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrMrLvl.h

Abstract:

    Header file for Managed Resource Level 
    property page.

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/

#ifndef _PRMRLV_H
#define _PRMRLV_H

#pragma once


/////////////////////////////////////////////////////////////////////////////
// CPrMrLvl dialog

class CPrMrLvl : public CSakVolPropPage
{
// Construction
public:
    CPrMrLvl();
    ~CPrMrLvl();

// Dialog Data
    //{{AFX_DATA(CPrMrLvl)
    enum { IDD = IDD_PROP_MANRES_LEVELS };
    CStatic m_staticActual4Digit;
    CStatic m_staticDesired4Digit;
    CEdit   m_editTime;
    CEdit   m_editSize;
    CEdit   m_editLevel;
    CSpinButtonCtrl m_spinTime;
    CSpinButtonCtrl m_spinSize;
    CSpinButtonCtrl m_spinLevel;
    long    m_hsmLevel;
    DWORD   m_fileSize;
    UINT    m_accessTime;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrMrLvl)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrMrLvl)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditLevel();
    afx_msg void OnChangeEditSize();
    afx_msg void OnChangeEditTime();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    CComPtr<IFsaResource> m_pFsaResource;

private:
    void        SetDesiredFreePctControl (int desiredPct);
    HRESULT     InitDialogMultiSelect();
    HRESULT     OnApplyMultiSelect();
    BOOL        m_fChangingByCode;
    LONGLONG    m_capacity;
    BOOL        m_bMultiSelect;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\prmrsts.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrSts.cpp

Abstract:

    Managed Volume Status Page.

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "fsaint.h"
#include "PrMrSts.h"
#include "manvol.h"

//#define RS_SHOW_ALL_PCTS

static DWORD pHelpIds[] = 
{

    IDC_STATIC_VOLUME_NAME,                     idh_volume_name,
#ifdef RS_SHOW_ALL_PCTS
    IDC_STATIC_USED_PCT,                        idh_volume_percent_local_data,
    IDC_STATIC_USED_PCT_UNIT,                   idh_volume_percent_local_data,
#endif
    IDC_STATIC_USED_SPACE_4DIGIT,               idh_volume_capacity_local_data,
    IDC_STATIC_USED_SPACE_4DIGIT_LABEL,         idh_volume_capacity_local_data,
    IDC_STATIC_USED_SPACE_4DIGIT_HELP,          idh_volume_capacity_local_data,
#ifdef RS_SHOW_ALL_PCTS
    IDC_STATIC_PREMIGRATED_PCT,                 idh_volume_percent_remote_data_cached,
    IDC_STATIC_PREMIGRATED_PCT_UNIT,            idh_volume_percent_remote_data_cached,
#endif
    IDC_STATIC_PREMIGRATED_SPACE_4DIGIT,        idh_volume_capacity_remote_data_cached,
    IDC_STATIC_PREMIGRATED_SPACE_4DIGIT_LABEL,  idh_volume_capacity_remote_data_cached,
    IDC_STATIC_FREE_PCT,                        idh_volume_percent_free_space,
    IDC_STATIC_FREE_PCT_UNIT,                   idh_volume_percent_free_space,
    IDC_STATIC_FREE_SPACE_4DIGIT,               idh_volume_capacity_free_space,
    IDC_STATIC_FREE_SPACE_4DIGIT_LABEL,         idh_volume_capacity_free_space,
    IDC_STATIC_MANAGED_SPACE_4DIGIT,            idh_volume_disk_capacity,
    IDC_STATIC_MANAGED_SPACE_4DIGIT_LABEL,      idh_volume_disk_capacity,
    IDC_STATIC_REMOTE_STORAGE_4DIGIT,           idh_volume_data_remote_storage,
    IDC_STATIC_RS_DATA_LABEL,                   idh_volume_data_remote_storage,
    
    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPrMrSts property page

CPrMrSts::CPrMrSts( BOOL doAll ) : CSakVolPropPage(CPrMrSts::IDD)
{
    //{{AFX_DATA_INIT(CPrMrSts)
    //}}AFX_DATA_INIT
    m_DoAll          = doAll;
    m_hConsoleHandle = NULL;
    m_pHelpIds       = pHelpIds;
}

CPrMrSts::~CPrMrSts()
{
}

void CPrMrSts::DoDataExchange(CDataExchange* pDX)
{
    CSakVolPropPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrMrSts)
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPrMrSts, CSakVolPropPage)
    //{{AFX_MSG_MAP(CPrMrSts)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrMrSts message handlers

BOOL CPrMrSts::OnInitDialog() 
{


    CSakVolPropPage::OnInitDialog();

    // set the dll context so that MMC can find the resource.
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    LONGLONG    total = 0;
    LONGLONG    free = 0;
    LONGLONG    premigrated = 0;
    LONGLONG    truncated = 0;
    LONGLONG    totalTotal = 0;
    LONGLONG    totalFree = 0;
    LONGLONG    totalPremigrated = 0;
    LONGLONG    totalTruncated = 0;
    LONGLONG    remoteStorage = 0;
    CString     sFormat;

    CString sText;

    CSakVolPropPage::OnInitDialog();

    HRESULT hr = S_OK;

    try {

        if ( ( m_pParent->IsMultiSelect() != S_OK ) && !m_DoAll ) {

            // SINGLE SELECT
            WsbAffirmHr( m_pVolParent->GetFsaResource( &m_pFsaResource ) );
            WsbAffirmPointer( m_pFsaResource );

            // Get statistics
            WsbAffirmHr( m_pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );

            // Show the volume name
            CString sText;
            WsbAffirmHr( RsGetVolumeDisplayName( m_pFsaResource, sText ) );
            SetDlgItemText( IDC_STATIC_VOLUME_NAME, sText );

        } else {

            // MULTI_SELECT or DoAll mode
            int bookMark = 0;
            int numVols  = 0;
            CComPtr<IFsaResource> pFsaResource;
            while( m_pVolParent->GetNextFsaResource( &bookMark, &pFsaResource ) == S_OK ) {

                WsbAffirmHr( pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );
                numVols++;
                totalTotal       += total;
                totalFree        += free;
                totalPremigrated += premigrated;
                totalTruncated   += truncated;

                pFsaResource.Release( );

            }

            total = totalTotal;
            free = totalFree;
            premigrated = totalPremigrated;
            truncated =  totalTruncated;

            // Show the number of volumes
            sText.Format( ( 1 == numVols ) ? IDS_VOLUME : IDS_VOLUMES, numVols );
            SetDlgItemText( IDC_STATIC_VOLUME_NAME, sText );

        }


        LONGLONG normal = max( ( total - free - premigrated ), (LONGLONG)0 );
        
        // Calculate percents
        int freePct;
        int premigratedPct;
        if( total == 0 ) {

            freePct = 0;
            premigratedPct = 0;

        } else {

            freePct        = (int) ((free * 100) / total);
            premigratedPct = (int) ((premigrated * 100) / total);

        }

#ifdef RS_SHOW_ALL_PCTS
        int normalPct = 100 - freePct - premigratedPct;
#endif

        remoteStorage = premigrated + truncated;

        //
        // Show the statistics in percent
        //
        sFormat.Format (L"%d", freePct);
        SetDlgItemText (IDC_STATIC_FREE_PCT, sFormat);

#ifdef RS_SHOW_ALL_PCTS
        sFormat.Format (L"%d", normalPct);
        SetDlgItemText (IDC_STATIC_USED_PCT, sFormat);

        sFormat.Format (L"%d", premigratedPct);
        SetDlgItemText (IDC_STATIC_PREMIGRATED_PCT, sFormat);

#else
        //
        // Can't change resources, so just hide the controls
        //
        GetDlgItem( IDC_STATIC_USED_PCT             )->ShowWindow( SW_HIDE );
        GetDlgItem( IDC_STATIC_USED_PCT_UNIT        )->ShowWindow( SW_HIDE );
        GetDlgItem( IDC_STATIC_PREMIGRATED_PCT      )->ShowWindow( SW_HIDE );
        GetDlgItem( IDC_STATIC_PREMIGRATED_PCT_UNIT )->ShowWindow( SW_HIDE );
#endif

        //
        // Show the statistics in 4-character format
        //
        WsbAffirmHr (RsGuiFormatLongLong4Char (total, sFormat));
        SetDlgItemText (IDC_STATIC_MANAGED_SPACE_4DIGIT, sFormat);

        WsbAffirmHr (RsGuiFormatLongLong4Char (free, sFormat));
        SetDlgItemText (IDC_STATIC_FREE_SPACE_4DIGIT, sFormat);

        WsbAffirmHr (RsGuiFormatLongLong4Char (normal, sFormat));
        SetDlgItemText (IDC_STATIC_USED_SPACE_4DIGIT, sFormat);

        WsbAffirmHr (RsGuiFormatLongLong4Char (premigrated, sFormat));
        SetDlgItemText (IDC_STATIC_PREMIGRATED_SPACE_4DIGIT, sFormat);

        WsbAffirmHr (RsGuiFormatLongLong4Char (remoteStorage, sFormat));
        SetDlgItemText (IDC_STATIC_REMOTE_STORAGE_4DIGIT, sFormat);

        UpdateData( FALSE );

    } WsbCatch ( hr );
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\prmrlvl.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrLvl.cpp

Abstract:

    Managed Volume Levels Page

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PrMrLvl.h"
#include "manvol.h"

static DWORD pHelpIds[] = 
{

    IDC_STATIC_ACTUAL_FREE_PCT,             idh_actual_free_space_percent,
    IDC_STATIC_ACTUAL_FREE_PCT_LABEL,       idh_actual_free_space_percent,
    IDC_STATIC_ACTUAL_FREE_PCT_UNIT,        idh_actual_free_space_percent,
    IDC_STATIC_FREE_ACTUAL_4DIGIT,          idh_actual_free_space_capacity,
    IDC_EDIT_LEVEL,                         idh_desired_free_space_percent,
    IDC_SPIN_LEVEL,                         idh_desired_free_space_percent,
    IDC_EDIT_LEVEL_LABEL,                   idh_desired_free_space_percent,
    IDC_EDIT_LEVEL_UNIT,                    idh_desired_free_space_percent,
    IDC_STATIC_FREE_DESIRED_4DIGIT,         idh_desired_free_space_capacity,
    IDC_EDIT_SIZE,                          idh_min_file_size_criteria,
    IDC_SPIN_SIZE,                          idh_min_file_size_criteria,
    IDC_EDIT_SIZE_LABEL,                    idh_min_file_size_criteria,
    IDC_EDIT_SIZE_UNIT,                     idh_min_file_size_criteria,
    IDC_EDIT_TIME,                          idh_file_access_date_criteria,
    IDC_SPIN_TIME,                          idh_file_access_date_criteria,
    IDC_EDIT_TIME_LABEL,                    idh_file_access_date_criteria,
    IDC_EDIT_TIME_UNIT,                     idh_file_access_date_criteria,

    0, 0
};


/////////////////////////////////////////////////////////////////////////////
// CPrMrLvl property page

CPrMrLvl::CPrMrLvl() : CSakVolPropPage(CPrMrLvl::IDD)
{
    //{{AFX_DATA_INIT(CPrMrLvl)
    m_hsmLevel = 0;
    m_fileSize = 0;
    m_accessTime = 0;
    //}}AFX_DATA_INIT
    m_hConsoleHandle    = NULL;
    m_capacity          = 0;
    m_fChangingByCode   = FALSE;
    m_pHelpIds          = pHelpIds;
}

CPrMrLvl::~CPrMrLvl()
{
}

void CPrMrLvl::DoDataExchange(CDataExchange* pDX)
{
    CSakVolPropPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrMrLvl)
    DDX_Control(pDX, IDC_STATIC_FREE_ACTUAL_4DIGIT, m_staticActual4Digit);
    DDX_Control(pDX, IDC_STATIC_FREE_DESIRED_4DIGIT, m_staticDesired4Digit);
    DDX_Control(pDX, IDC_EDIT_TIME, m_editTime);
    DDX_Control(pDX, IDC_EDIT_SIZE, m_editSize);
    DDX_Control(pDX, IDC_EDIT_LEVEL, m_editLevel);
    DDX_Control(pDX, IDC_SPIN_TIME, m_spinTime);
    DDX_Control(pDX, IDC_SPIN_SIZE, m_spinSize);
    DDX_Control(pDX, IDC_SPIN_LEVEL, m_spinLevel);
    //}}AFX_DATA_MAP

    // blank is valid for multi-select
    if( m_bMultiSelect ) {

        CString szLevel;
        CString szSize;
        CString szDays; 

        m_editLevel.GetWindowText( szLevel );
        m_editSize.GetWindowText( szSize );
        m_editTime.GetWindowText( szDays );

        if( szLevel != L"" ) {

            DDX_Text( pDX, IDC_EDIT_LEVEL, m_hsmLevel );
            DDV_MinMaxLong( pDX, m_hsmLevel, HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );

        } else {

            m_hsmLevel = HSMADMIN_DEFAULT_MINSIZE;

        }

        if( szSize != L"" ) {

            DDX_Text( pDX, IDC_EDIT_SIZE, m_fileSize );
            DDV_MinMaxDWord( pDX, m_fileSize, HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );

        } else {

            m_fileSize = HSMADMIN_DEFAULT_FREESPACE;

        }

        if( szDays != L"" ) {

            DDX_Text( pDX, IDC_EDIT_TIME, m_accessTime );
            DDV_MinMaxUInt( pDX, m_accessTime, HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );

        } else {

            m_accessTime = HSMADMIN_DEFAULT_INACTIVITY;

        }

    } else {

        //
        // Normal validation for single select
        //
        DDX_Text( pDX, IDC_EDIT_LEVEL, m_hsmLevel );
        DDV_MinMaxLong( pDX, m_hsmLevel, HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );
        DDX_Text( pDX, IDC_EDIT_TIME, m_accessTime );
        DDV_MinMaxUInt( pDX, m_accessTime, HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );
        DDX_Text( pDX, IDC_EDIT_SIZE, m_fileSize );

        //
        // Since we limit the number of characters in the buddy edits, we 
        // don't expect the previous two DDV's to ever really kick in. 
        // However, it is possible to enter bad minumum size since both
        // '0' and '1' can be entered, but are not in the valid range.

        //
        // Code is equivalent to:
        // DDV_MinMaxDWord( pDX, m_fileSize, HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
        //

        if( pDX->m_bSaveAndValidate &&
          ( m_fileSize < HSMADMIN_MIN_MINSIZE ||
            m_fileSize > HSMADMIN_MAX_MINSIZE ) ) {

            CString message;
            AfxFormatString2( message, IDS_ERR_MINSIZE_RANGE, 
                CString( WsbLongAsString( (LONG)HSMADMIN_MIN_MINSIZE ) ),
                CString( WsbLongAsString( (LONG)HSMADMIN_MAX_MINSIZE ) ) );
            AfxMessageBox( message, MB_OK | MB_ICONWARNING );
            pDX->Fail();

        }

    }
}


BEGIN_MESSAGE_MAP(CPrMrLvl, CSakVolPropPage)
    //{{AFX_MSG_MAP(CPrMrLvl)
    ON_EN_CHANGE(IDC_EDIT_LEVEL, OnChangeEditLevel)
    ON_EN_CHANGE(IDC_EDIT_SIZE, OnChangeEditSize)
    ON_EN_CHANGE(IDC_EDIT_TIME, OnChangeEditTime)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrMrLvl message handlers

BOOL CPrMrLvl::OnInitDialog() 
{
    HRESULT hr = 0;
    CSakVolPropPage::OnInitDialog();
    int freePct;
    try {

        m_bMultiSelect = ( m_pParent->IsMultiSelect() == S_OK );    

        // Set the spinner ranges
        m_spinTime.SetRange( HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );
        m_spinSize.SetRange( HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
        m_spinLevel.SetRange( HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );

        // Set text limits
        m_editTime.SetLimitText( 3 );
        m_editSize.SetLimitText( 5 );
        m_editLevel.SetLimitText( 2 );

        if( !m_bMultiSelect )
        {
            // Single Select
            // Show the byte display of desired free space
            m_staticDesired4Digit.ShowWindow( SW_SHOW );
            m_staticActual4Digit.ShowWindow( SW_SHOW );

            // Get the single Fsa Resource pointer
            WsbAffirmHr ( m_pVolParent->GetFsaResource( &m_pFsaResource ) );
            WsbAffirmPointer (m_pFsaResource);

            ULONG       hsmLevel = 0;
            LONGLONG    fileSize = 0;
            BOOL        isRelative = TRUE; // assumed to be TRUE
            FILETIME    accessTime;

            // Get data from the Fsa object and assign to controls
            WsbAffirmHr( m_pFsaResource->GetHsmLevel( &hsmLevel ) );
            m_hsmLevel = hsmLevel / FSA_HSMLEVEL_1;

            WsbAffirmHr( m_pFsaResource->GetManageableItemLogicalSize( &fileSize ) );
            m_fileSize = (DWORD)(fileSize / 1024);  // Show KBytes

            WsbAffirmHr( m_pFsaResource->GetManageableItemAccessTime( &isRelative, &accessTime ) );
            WsbAssert( isRelative, E_FAIL );  // We only do relative time

            // Convert FILETIME to days
            LONGLONG temp = WSB_FT_TICKS_PER_DAY;
            m_accessTime = (UINT) (WsbFTtoLL (accessTime) / temp);
            if( m_accessTime > 999 ) {

                m_accessTime = 0;

            }

            LONGLONG total = 0;
            LONGLONG free = 0;
            LONGLONG premigrated = 0;
            LONGLONG truncated = 0;

            // Get actual free space and show in % and 4-digit formats
            WsbAffirmHr( m_pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );
            m_capacity = total;

            freePct = (int) ((free * 100) / total);
            CString sFormat;
            sFormat.Format( L"%d", freePct );
            SetDlgItemText( IDC_STATIC_ACTUAL_FREE_PCT, sFormat );

            WsbAffirmHr( RsGuiFormatLongLong4Char( free, sFormat ) );
            SetDlgItemText( IDC_STATIC_FREE_ACTUAL_4DIGIT, sFormat );

            // Show the desired in 4-digit - based on the %
            SetDesiredFreePctControl( m_hsmLevel );

            // Update the controls
            UpdateData( FALSE );

        } else {

            // MULTI-SELECT
            // Hide the byte display of desired free space
            m_staticDesired4Digit.ShowWindow( SW_HIDE );
            m_staticActual4Digit.ShowWindow( SW_HIDE );
            InitDialogMultiSelect( );

        }

    } WsbCatch (hr);

    return( TRUE );
}

BOOL CPrMrLvl::OnApply() 
{
    HRESULT hr = S_OK;

    try {

        if( !m_bMultiSelect ) {
            LONGLONG    fileSize = 0;

            // Single Select
            UpdateData( TRUE );
            WsbAffirmHr( m_pFsaResource->SetHsmLevel( m_hsmLevel * FSA_HSMLEVEL_1 ) );
            fileSize = ((LONGLONG)m_fileSize) * 1024;
            WsbAffirmHr( m_pFsaResource->SetManageableItemLogicalSize( fileSize ) );

            // Convert days to FILETIME
            FILETIME accessTime;
            LONGLONG temp = WSB_FT_TICKS_PER_DAY;
            accessTime = WsbLLtoFT( ( (LONGLONG) m_accessTime ) * temp );
            WsbAffirmHr( m_pFsaResource->SetManageableItemAccessTime( TRUE, accessTime ) );


        } else {

            // Multi-Select
            WsbAffirmHr( OnApplyMultiSelect( ) );

        }

        //
        // Tell to save
        //
        CComPtr<IFsaServer>   pFsaServer;
        WsbAffirmHr( m_pParent->GetFsaServer( &pFsaServer ) );
        WsbAffirmHr( RsServerSaveAll( pFsaServer ) );

        //
        // Now notify all the nodes
        //
        m_pParent->OnPropertyChange( m_hConsoleHandle );


    } WsbCatch( hr );

    return CSakVolPropPage::OnApply();

}

///////////////////////////////////////////////////////////////////////////////
//
// OnChangeEditLevel
//
// Change the display of actual bytes according to the percent setting
//
void CPrMrLvl::OnChangeEditLevel() 
{
    BOOL fTrans;
    int freePct;

    freePct = GetDlgItemInt( IDC_EDIT_LEVEL, &fTrans );
    if( fTrans ) {

        SetDesiredFreePctControl( freePct );

    }

    if( !m_fChangingByCode ) {

        SetModified( TRUE );

    }
}

void CPrMrLvl::OnChangeEditSize() 
{
    if( !m_fChangingByCode ) {

        SetModified( TRUE );

    }
}

void CPrMrLvl::OnChangeEditTime() 
{
    if( !m_fChangingByCode ) {

        SetModified( TRUE );

    }
}

//////////////////////////////////////////////////////////////////////////
//
//      SetDesiredFreePctControl
//
// Converts the supplied desired percent to bytes (using m_capacity) and
// displays in the appropriate edit box
//
//
void CPrMrLvl::SetDesiredFreePctControl (int desiredPct)
{
    HRESULT hr = 0;
    CString sFormat;

    LONGLONG desired = (m_capacity * desiredPct) / 100;
    try {
        WsbAffirmHr (RsGuiFormatLongLong4Char (desired, sFormat));
        SetDlgItemText (IDC_STATIC_FREE_DESIRED_4DIGIT, sFormat);

    } WsbCatch (hr)
}

//////////////////////////////////////////////////////////////////////////
//
//
HRESULT CPrMrLvl::InitDialogMultiSelect()
{
    LONGLONG    total;
    LONGLONG    free;
    LONGLONG    premigrated;
    LONGLONG    truncated;
    BOOL        fLevelSame = TRUE;
    BOOL        fSizeSame  = TRUE;
    BOOL        fDaysSame  = TRUE;
    BOOL        fFirst     = TRUE;
    CString     szLevel;
    CString     szSize;
    CString     szDays;
    ULONG       hsmLevel = 0;
    LONGLONG    fileSize = 0;
    BOOL        isRelative = TRUE; // assumed to be TRUE
    FILETIME    accessTime;
    int         hsmLevelPct;
    ULONG       fileSizeKb;
    int         accessTimeDays;
    int         hsmLevelPctSave = 0;
    ULONG       fileSizeKbSave = 0;
    int         accessTimeDaysSave = 0;
    int         freePct;

    HRESULT hr = S_OK;

    try {
        // Set this flag to true because SetEditContents will cause the edit boxes to
        // fire a change event, and we don't want that to cause the Finish button to
        // be enabled.

        m_fChangingByCode = TRUE;

        // For each managed resource

        int bookMark = 0;
        CComPtr<IFsaResource> pFsaResource;
        LONGLONG totalCapacity = 0;
        LONGLONG totalFree = 0;

        while( m_pVolParent->GetNextFsaResource( &bookMark, &pFsaResource ) == S_OK ) {

            // Total up volume statistics
            WsbAffirmHr (pFsaResource->GetSizes(&total, &free, &premigrated, &truncated));
            totalCapacity += total;
            totalFree += free;

            // Get the levels in the resource
            WsbAffirmHr( pFsaResource->GetHsmLevel( &hsmLevel) );
            hsmLevelPct = (hsmLevel / FSA_HSMLEVEL_1);

            if( ! fFirst ) {

                if( hsmLevelPct != hsmLevelPctSave ) {
                     
                    fLevelSame = FALSE;

                }
            }
            hsmLevelPctSave = hsmLevelPct;

            WsbAffirmHr( pFsaResource->GetManageableItemLogicalSize( &fileSize ) );
            fileSizeKb = (LONG) ( fileSize / 1024 );
            if( !fFirst ) {

                if( fileSizeKb != fileSizeKbSave ) {
                    
                    fSizeSame = FALSE;

                }
            }
            fileSizeKbSave = fileSizeKb;

            WsbAffirmHr( pFsaResource->GetManageableItemAccessTime( &isRelative, &accessTime ) );
            accessTimeDays = (UINT) ( WsbFTtoLL( accessTime ) / WSB_FT_TICKS_PER_DAY );

            if( ! fFirst ) {

                if( accessTimeDays != accessTimeDaysSave ) {
                    
                    fDaysSame = FALSE;

                }
            }

            accessTimeDaysSave = accessTimeDays;

            fFirst = FALSE;

            pFsaResource.Release( );

        } // While

        // If all same, put the value in
        if( fLevelSame ) {

            szLevel.Format( L"%d", hsmLevelPctSave );

        } else {

            szLevel = L"";

        }

        if( fSizeSame ) {

            szSize.Format( L"%d", fileSizeKbSave );

        } else {

            szSize = L"";

        }
        if( fDaysSame ) {

            szDays.Format( L"%d", accessTimeDaysSave );

        } else {

            szDays = L"";

        }

        // Show volume statistics
        if( totalCapacity == 0 ) {
            
            freePct = 0;
            
        } else {

            freePct = (int) ( ( totalFree * 100 ) / totalCapacity );

        }

        CString sFormat;
        sFormat.Format( L"%d", freePct );
        SetDlgItemText( IDC_STATIC_ACTUAL_FREE_PCT, sFormat );

        m_editLevel.SetWindowText( szLevel );
        m_editSize.SetWindowText( szSize );
        m_editTime.SetWindowText( szDays );
        m_fChangingByCode = FALSE;

    } WsbCatch( hr );

    return( hr );
}
    

HRESULT CPrMrLvl::OnApplyMultiSelect()
{

    HRESULT hr = S_OK;
    CComPtr <IFsaResource> pFsaResource;

    try {

        // For each managed resource

        int bookMark = 0;
        CComPtr<IFsaResource> pFsaResource;
        while( m_pVolParent->GetNextFsaResource( &bookMark, &pFsaResource ) == S_OK ) {

            // Set the levels in the resource - only if the edit box was not blank
            CString szLevel;
            CString szSize;
            CString szDays; 

            m_editLevel.GetWindowText( szLevel );
            m_editSize.GetWindowText( szSize );
            m_editTime.GetWindowText( szDays );


            if( szLevel != L"" ) {

                WsbAffirmHr( pFsaResource->SetHsmLevel( m_spinLevel.GetPos( ) * FSA_HSMLEVEL_1 ) );

            }

            if( szSize != L"" ) {

                WsbAffirmHr( pFsaResource->SetManageableItemLogicalSize( (LONGLONG) m_spinSize.GetPos( ) * 1024 ) );

            }

            if( szDays != L"" ) {

                // Convert days to FILETIME
                FILETIME accessTime;
                accessTime = WsbLLtoFT( ( (LONGLONG) m_spinTime.GetPos( ) ) * WSB_FT_TICKS_PER_DAY);
                WsbAffirmHr (pFsaResource->SetManageableItemAccessTime (TRUE, accessTime));

            }
            pFsaResource.Release( );

        }

    } WsbCatch (hr);
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\rule.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    Rule.cpp

Abstract:

    Rule object for use in inclusion exclusion.

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "Rule.h"



/////////////////////////////////////////////////////////////////////////////
// CRule dialog

static DWORD pHelpIds[] = 
{

    IDC_EDIT_RESOURCE_NAME,                 idh_rule_edit_name,
    IDC_EDIT_PATH,                          idh_rule_edit_path,
    IDC_EDIT_FILESPEC,                      idh_rule_edit_file_type,
    IDC_RADIO_EXCLUDE,                      idh_rule_edit_exclude,
    IDC_RADIO_INCLUDE,                      idh_rule_edit_include,
    IDC_CHECK_SUBDIRS,                      idh_rule_edit_apply_subfolders,

    0, 0
};


CRule::CRule(CWnd* pParent /*=NULL*/)
    : CRsDialog(CRule::IDD, pParent)
{
    //{{AFX_DATA_INIT(CRule)
    m_subDirs = FALSE;
    m_fileSpec = _T("");
    m_path = _T("");
    m_includeExclude = -1;
    m_pResourceName = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIds          = pHelpIds;
}


void CRule::DoDataExchange(CDataExchange* pDX)
{
    CRsDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRule)
    DDX_Check(pDX, IDC_CHECK_SUBDIRS, m_subDirs);
    DDX_Text(pDX, IDC_EDIT_FILESPEC, m_fileSpec);
    DDX_Text(pDX, IDC_EDIT_PATH, m_path);
    DDX_Radio(pDX, IDC_RADIO_EXCLUDE, m_includeExclude);
    DDX_Text(pDX, IDC_EDIT_RESOURCE_NAME, m_pResourceName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRule, CRsDialog)
    //{{AFX_MSG_MAP(CRule)
    ON_BN_CLICKED(IDC_RADIO_EXCLUDE, OnRadioExclude)
    ON_BN_CLICKED(IDC_RADIO_INCLUDE, OnRadioInclude)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRule message handlers

void CRule::OnRadioExclude() 
{
    // TODO: Add your control notification handler code here
    
}

void CRule::OnRadioInclude() 
{
    // TODO: Add your control notification handler code here
    
}

BOOL CRule::OnInitDialog() 
{
    CRsDialog::OnInitDialog();
    
    UpdateData (FALSE);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//////////////////////////////////////////////////////////////////////////
//
// Returns: False if path is not legal
//
BOOL CRule::FixRulePath (CString& sPath)
{
    BOOL fOk = TRUE;
    TCHAR c;
    int length = 0;
    int i;

    // Test for illegal characters
    length = sPath.GetLength();
    for (i = 0; i < length; i++)
    {
        c = sPath[i];
        if (c == ':') {
            fOk = FALSE;
            break;
        }
    }

    if (fOk) {

        // Convert all "/" to "\"
        length = sPath.GetLength();
        for (i = 0; i < length; i++)
        {
            c = sPath[i];
            if (c == '/') sPath.SetAt (i, '\\');
        }

        // Make sure path starts with a "\"
        c = sPath[0];
        if (c != '\\')
        {
            sPath = "\\" + sPath;
        }

        // If path has at least one dir, clean up final "\" if there is one
        length = sPath.GetLength();
        if (length > 1) {
            c = sPath[length - 1];
            if (c == '\\') {
                sPath = sPath.Left (length - 1);
            }
        }
                
        
    }
    return fOk;
}
void CRule::OnOK() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    UpdateData (TRUE);

    // Verify the path and name fields
    if (m_path != "")
    {
        if (m_fileSpec != "")
        {
            // Fix up the path
            if (FixRulePath (m_path)) {
                
                // Show the new data - because when we call OnOK the variables
                // will get updated again.
                UpdateData (FALSE);
                CRsDialog::OnOK();
            } else {
                AfxMessageBox (IDS_ERR_RULE_ILLEGAL_PATH, RS_MB_ERROR);
            }
        }
        else {
            AfxMessageBox (IDS_ERR_RULE_NO_FILESPEC, RS_MB_ERROR);
        }
    }
    else {
        AfxMessageBox (IDS_ERR_RULE_NO_PATH, RS_MB_ERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\prsched.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrSched.h

Abstract:

    Schedule page.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#ifndef _PRSCHED_H
#define _PRSCHED_H

#pragma once

#include "schdtask.h"

/////////////////////////////////////////////////////////////////////////////
// CPrSchedule dialog

class CPrSchedule : public CSakPropertyPage
{
// Construction
public:
    CPrSchedule();
    ~CPrSchedule();

// Dialog Data
    //{{AFX_DATA(CPrSchedule)
    enum { IDD = IDD_PROP_SCHEDULE };
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrSchedule)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrSchedule)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeSched();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    // Unmarshalled pointer to Hsm Server
    CComPtr<IHsmServer> m_pHsmServer;

private:
    CSchdTask* m_pCSchdTask;
    BOOL m_SchedChanged;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\rule.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Rule.h

Abstract:

    Rule functionality

Author:

    Art Bragg 10/8/97

Revision History:

--*/

#ifndef RULE_H
#define RULE_H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CRule dialog

class CRule : public CRsDialog
{
// Construction
public:
    CRule(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CRule)
    enum { IDD = IDD_DLG_RULE_EDIT };
    BOOL    m_subDirs;
    CString m_fileSpec;
    CString m_path;
    int     m_includeExclude;
    CString m_pResourceName;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRule)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation

protected:

    // Generated message map functions
    //{{AFX_MSG(CRule)
    afx_msg void OnRadioExclude();
    afx_msg void OnRadioInclude();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    BOOL FixRulePath (CString& sPath);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\prsched.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrSched.cpp

Abstract:

    Schedule page.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PrSched.h"
#include "rsstrdef.h"

static DWORD pHelpIds[] = 
{

    IDC_SCHED_TEXT,                 idh_current_schedule,
    IDC_SCHED_LABEL,                idh_current_schedule,
    IDC_CHANGE_SCHED,               idh_change_schedule_button,

    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPrSchedule property page

CPrSchedule::CPrSchedule() : CSakPropertyPage(IDD)
{
    WsbTraceIn( L"CPrSchedule::CPrSchedule", L"" );
    //{{AFX_DATA_INIT(CPrSchedule)
    //}}AFX_DATA_INIT
    m_SchedChanged  = FALSE;
    m_pHelpIds      = pHelpIds;
    WsbTraceOut( L"CPrSchedule::CPrSchedule", L"" );
}

CPrSchedule::~CPrSchedule()
{
}

void CPrSchedule::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CPrSchedule::DoDataExchange", L"" );
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrSchedule)
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CPrSchedule::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CPrSchedule, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPrSchedule)
    ON_BN_CLICKED(IDC_CHANGE_SCHED, OnChangeSched)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrSchedule message handlers

BOOL CPrSchedule::OnInitDialog() 
{
    WsbTraceIn( L"CPrSchedule::OnInitDialog", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CSakPropertyPage::OnInitDialog();
    
    HRESULT hr = S_OK;

    try {

        //
        // TEST
        //
        WsbAffirmHr( m_pParent->GetHsmServer( &m_pHsmServer) );

        //
        // Get the computer name
        //
        CWsbStringPtr szWsbHsmName;
        CWsbStringPtr taskName, taskComment;

        WsbAffirmHr( m_pHsmServer->GetName( &szWsbHsmName ) );
        WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_TASK_TITLE, &taskName));
        WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_COMMENT, &taskComment));

        //
        // Create the scheduled task object
        //
        CEdit *pEdit = (CEdit *) GetDlgItem( IDC_SCHED_TEXT );
        m_pCSchdTask = new CSchdTask(
                                CString(szWsbHsmName),
                                taskName, 
                                IDS_SCHED_MANAGE_TITLE,
                                RS_STR_KICKOFF_PARAMS,
                                taskComment,
                                pEdit ); 


        //
        // Create the task.  The task should exist!
        //
        WsbAffirmHr( m_pCSchdTask->CheckTaskExists( TRUE ) );

        // Show the task data
        m_pCSchdTask->UpdateDescription( );

        // ToDo: Set the users list

    } WsbCatch( hr );

    WsbTraceOut( L"CPrSchedule::OnInitDialog", L"" );
    return( TRUE );
}

BOOL CPrSchedule::OnApply() 
{
    WsbTraceIn( L"CPrSchedule::OnApply", L"" );
    HRESULT hr = S_OK;
    UpdateData( TRUE );

    if( m_SchedChanged ) {

        try {
            
            WsbAffirmHr( m_pCSchdTask->Save() );
            m_SchedChanged = FALSE;

        } WsbCatch( hr );
    }

    WsbTraceOut( L"CPrSchedule::OnApply", L"" );
    return CSakPropertyPage::OnApply();
}

void CPrSchedule::OnChangeSched() 
{
    WsbTraceIn( L"CPrSchedule::OnChangeSched", L"" );

    m_pCSchdTask->ShowPropertySheet();

    //
    // Update the property sheet
    //
    m_pCSchdTask->UpdateDescription();

    SetModified( TRUE );
    m_SchedChanged = TRUE;

    WsbTraceOut( L"CPrSchedule::OnChangeSched", L"" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\prmrsts.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrSts.h

Abstract:

    Status page for single select, multiple select, and folder of volumes.

Author:

    Art Bragg [artb]   01-DEC-1997

Revision History:

--*/

#ifndef _PRMRSTS_H
#define _PRMRSTS_H

#pragma once


/////////////////////////////////////////////////////////////////////////////
// CPrMrSts dialog

class CPrMrSts : public CSakVolPropPage
{
// Construction
public:
    CPrMrSts( BOOL doAll = FALSE);
    ~CPrMrSts();

// Dialog Data
    //{{AFX_DATA(CPrMrSts)
    enum { IDD = IDD_PROP_MANRES_STATUS };
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrMrSts)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrMrSts)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    // Unmarshalled pointer to managed resource 
    CComPtr     <IFsaResource> m_pFsaResource;
    CComPtr     <IFsaResource> m_pFsaResourceList;

private:
    BOOL m_DoAll;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\valwait.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    valwait.cpp

Abstract:

    Implements Validate Wait Dialog class

Author:

    Ran Kalach          [rankala]         23-May-2000

Revision History:

--*/

// valwait.cpp : implementation file
//

#include "stdafx.h"
#include "valwait.h"
#include "wzunmang.h"

/////////////////////////////////////////////////////////////////////////////
// CValWaitDlg dialog


CValWaitDlg::CValWaitDlg(CUnmanageWizard *pSheet, CWnd* pParent)
	: CDialog(CValWaitDlg::IDD, pParent)
{
    WsbTraceIn( L"CValWaitDlg::CValWaitDlg", L"" );

	//{{AFX_DATA_INIT(CValWaitDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    // Store volume name
    m_pSheet = pSheet;

    WsbTraceOut( L"CValWaitDlg::CValWaitDlg", L"" );
}


void CValWaitDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CValWaitDlg)
	DDX_Control(pDX, IDC_ANIMATE_VALIDATE, m_Animation);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CValWaitDlg, CDialog)
	//{{AFX_MSG_MAP(CValWaitDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CValWaitDlg message handlers

void CValWaitDlg::OnCancel() 
{
    WsbTraceIn( L"CValWaitDlg::OnCancel", L"" );

    HRESULT         hr = S_OK;

    try {
        CComPtr<IHsmServer>  pHsmServer;

	    // Cancel the Validate job - the wizard will close this dialog when the job finishes
        WsbAffirmPointer(m_pSheet);
        WsbAffirmHrOk(m_pSheet->GetHsmServer(&pHsmServer));
        WsbAffirmHr(RsCancelDirectFsaJob(HSM_JOB_DEF_TYPE_VALIDATE, pHsmServer, 
                        m_pSheet->m_pFsaResource));

    } WsbCatch(hr);

    WsbTraceOut( L"CValWaitDlg::OnCancel", L"" );
}

void CValWaitDlg::PostNcDestroy() 
{
	CDialog::PostNcDestroy();

    // Delete the object - required for modeless dialogbox
    delete( this );
}

BOOL CValWaitDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    // Start up the animation
    if (m_Animation.Open( IDR_VALIDATE_ANIM )) {
        m_Animation.Play( 0, -1, -1 );
    }
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\wzmnvlls.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WzMnVlLs.cpp

Abstract:

    Managed Volume wizard.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include "ManVolLs.h"
#include "WzMnVlLs.h"

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLst

CWizManVolLst::CWizManVolLst( )
{
    m_TitleId     = IDS_WIZ_MANVOLLST_TITLE;
    m_HeaderId    = IDB_MANAGE_HEADER;
    m_WatermarkId = IDB_MANAGE_WATERMARK;
}

STDMETHODIMP
CWizManVolLst::AddWizardPages(
    IN RS_PCREATE_HANDLE Handle,
    IN IUnknown*         pCallback,
    IN ISakSnapAsk*      pSakSnapAsk
    )
{
    WsbTraceIn( L"CWizManVolLst::AddWizardPages", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Initialize the Sheet
        //
        WsbAffirmHr( InitSheet( Handle, pCallback, 0, pSakSnapAsk, 0, 0 ) );

        //
        // Load pages 
        //
        WsbAffirmHr( AddPage( &m_PageIntro ) );
        WsbAffirmHr( AddPage( &m_PageSelect ) );
        WsbAffirmHr( AddPage( &m_PageSelectX ) );
        WsbAffirmHr( AddPage( &m_PageLevels ) );
        WsbAffirmHr( AddPage( &m_PageFinish ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CWizManVolLst::AddWizardPages", L"" );
    return( hr );
}

CWizManVolLst::~CWizManVolLst()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLst", L"" );
    WsbTraceOut( L"CWizManVolLst::~CWizManVolLst", L"" );
}

HRESULT CWizManVolLst::OnFinish( )
{
    WsbTraceIn( L"CWizManVolLst::OnFinish", L"" );

    BOOL doAll = FALSE;
    //
    // The sheet really owns the process as a whole,
    // so it will do the final assembly
    //

    HRESULT hr = S_OK;

    try {

        //
        // Get the HSM service interface for creating local objects
        //
        CComPtr<IWsbCreateLocalObject>  pCreateLocal;
        CComPtr<IWsbIndexedCollection> pCollection;
        CComPtr<IHsmManagedResource> pHsmResource;

        CComPtr<IHsmServer> pHsmServer;
        WsbAffirmHrOk( m_pSakSnapAsk->GetHsmServer( &pHsmServer ) );

        WsbAffirmHr( pHsmServer.QueryInterface( &pCreateLocal ) );
        WsbAffirmHr( pHsmServer->GetManagedResources( &pCollection ) );

        //
        // Pull out the default levels for all resources to be managed
        //
        ULONG    defaultFreeSpace =  (m_PageLevels.GetHsmLevel() * FSA_HSMLEVEL_1);
        LONGLONG defaultMinSize = ( (LONGLONG)m_PageLevels.GetFileSize()) * ((LONGLONG)1024);
        FILETIME defaultAccess = WsbLLtoFT ((LONGLONG)m_PageLevels.GetAccessDays() * (LONGLONG)WSB_FT_TICKS_PER_DAY );
    
        // Is the "all" radio button selected?
        if( !m_PageSelect.m_radioSelect.GetCheck() ) {

            doAll = TRUE;

        }

        //
        // Make sure FSA has most up-to-date status on resources
        //
        CComPtr<IFsaServer> pFsaServer;
        WsbAffirmHrOk( m_pSakSnapAsk->GetFsaServer( &pFsaServer ) );
        WsbAffirmHr( pFsaServer->ScanForResources( ) );

        //
        // Go through the listbox and pull out the checked resources.
        // Create HSM managed volumes for them.
        //
        // Note that we wrap the management in a try/catch so that if an error
        // occurs (like a volume not available) that we still do the rest
        // of the volumes. We will throw the error after attempting all volumes.
        //
        HRESULT hrLoop = S_OK;
        CSakVolList *pListBox = &(m_PageSelect.m_listBox);

        INT index;
        for( index = 0; index < pListBox->GetItemCount( ); index++ ) {

            if( ( pListBox->GetCheck( index ) ) || ( doAll ) ) {

                try {

                    CResourceInfo* pResInfo = (CResourceInfo*)pListBox->GetItemData( index );

                    //
                    // Create Local to server since it will eventually own it.
                    //

                    WsbAffirmHr( pCreateLocal->CreateInstance( 
                        CLSID_CHsmManagedResource, 
                        IID_IHsmManagedResource, 
                        (void**)&pHsmResource ) );

                    //
                    // Initialize Fsa object to its initial values.
                    //

                    WsbAffirmHr( (pResInfo->m_pResource)->SetHsmLevel( defaultFreeSpace ) );
                    WsbAffirmHr( (pResInfo->m_pResource)->SetManageableItemLogicalSize( defaultMinSize ) );
                    WsbAffirmHr( (pResInfo->m_pResource)->SetManageableItemAccessTime( TRUE, defaultAccess ) );

                    //
                    // Associate HSM Managed Resource with the FSA resource
                    // (also adds to HSM collection)
                    //

                    WsbAffirmHr( pHsmResource->InitFromFsaResource( pResInfo->m_pResource ) );
                    WsbAffirmHr( pCollection->Add( pHsmResource ) );

                } WsbCatch( hrLoop );

                pHsmResource.Release( );
            }

        }

        //
        // Force a persistant save of the hsm man vol list
        //
        WsbAffirmHr( RsServerSaveAll( pHsmServer ) );
        WsbAffirmHr( RsServerSaveAll( pFsaServer ) );

        //
        // And check to see if there were any problems doing the manage
        //
        WsbAffirmHr( hrLoop );

    } WsbCatchAndDo( hr,

        CString errString;
        AfxFormatString1( errString, IDS_ERR_MANVOLWIZ_FINISH, WsbHrAsString( hr ) );
        AfxMessageBox( errString, RS_MB_ERROR ); 

    );

    m_HrFinish = S_OK;

    WsbTraceOut( L"CWizManVolLst::OnFinish", L"hr = <%ls>", WsbHrAsString( m_HrFinish ) );
    return(m_HrFinish);
}

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstLevels property page

CWizManVolLstLevels::CWizManVolLstLevels()
    : CSakWizardPage_InitBaseInt( WIZ_MANVOLLST_LEVELS )
{
    //{{AFX_DATA_INIT(CWizManVolLstLevels)
    m_HsmLevel = 0;
    m_AccessDays = 0;
    m_FileSize = 0;
    //}}AFX_DATA_INIT

}

CWizManVolLstLevels::~CWizManVolLstLevels()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLstLevels", L"" );
    WsbTraceOut( L"CWizManVolLst::~CWizManVolLstLevels", L"" );
}

void CWizManVolLstLevels::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizManVolLstLevels)
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_SPIN_SIZE, m_SpinSize);
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_SPIN_LEVEL, m_SpinLevel);
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_SPIN_DAYS, m_SpinDays);
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_EDIT_SIZE, m_EditSize);
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_EDIT_LEVEL, m_EditLevel);
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_EDIT_DAYS, m_EditDays);
    DDX_Text(pDX, IDC_WIZ_MANVOLLST_EDIT_LEVEL, m_HsmLevel);
    DDX_Text(pDX, IDC_WIZ_MANVOLLST_EDIT_DAYS, m_AccessDays);
    DDX_Text(pDX, IDC_WIZ_MANVOLLST_EDIT_SIZE, m_FileSize);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizManVolLstLevels, CSakWizardPage)
    //{{AFX_MSG_MAP(CWizManVolLstLevels)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstLevels message handlers

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstIntro property page

CWizManVolLstIntro::CWizManVolLstIntro()
    : CSakWizardPage_InitBaseExt( WIZ_MANVOLLST_INTRO )
{
    //{{AFX_DATA_INIT(CWizManVolLstIntro)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CWizManVolLstIntro::~CWizManVolLstIntro()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLstIntro", L"" );
    WsbTraceOut( L"CWizManVolLst::~CWizManVolLstIntro", L"" );
}

void CWizManVolLstIntro::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizManVolLstIntro)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizManVolLstIntro, CSakWizardPage)
    //{{AFX_MSG_MAP(CWizManVolLstIntro)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstIntro message handlers

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstFinish property page

CWizManVolLstFinish::CWizManVolLstFinish()
    : CSakWizardPage_InitBaseExt( WIZ_MANVOLLST_FINISH )
{
    //{{AFX_DATA_INIT(CWizManVolLstFinish)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CWizManVolLstFinish::~CWizManVolLstFinish()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLstFinish", L"" );
    WsbTraceOut( L"CWizManVolLst::~CWizManVolLstFinish", L"" );
}

void CWizManVolLstFinish::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizManVolLstFinish)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizManVolLstFinish, CSakWizardPage)
    //{{AFX_MSG_MAP(CWizManVolLstFinish)
    ON_EN_SETFOCUS(IDC_WIZ_FINAL_TEXT, OnSetfocusWizManvollstFinalEdit)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstFinish message handlers



/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstSelect property page

CWizManVolLstSelect::CWizManVolLstSelect()
    : CSakWizardPage_InitBaseInt( WIZ_MANVOLLST_SELECT )
{
    //{{AFX_DATA_INIT(CWizManVolLstSelect)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CWizManVolLstSelect::~CWizManVolLstSelect()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLstSelect", L"" );

    WsbTraceOut( L"CWizManVolLst::~CWizManVolLstSelect", L"" );
}

void CWizManVolLstSelect::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizManVolLstSelect)
    DDX_Control(pDX, IDC_RADIO_SELECT, m_radioSelect);
    DDX_Control(pDX, IDC_MANVOLLST_FSARESLBOX, m_listBox);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizManVolLstSelect, CSakWizardPage)
    //{{AFX_MSG_MAP(CWizManVolLstSelect)
    ON_BN_CLICKED(IDC_RADIO_SELECT, OnRadioSelect)
    ON_BN_CLICKED(IDC_RADIO_MANAGE_ALL, OnRadioManageAll)
    ON_WM_DESTROY()
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_MANVOLLST_FSARESLBOX, OnItemchangedManVollstFsareslbox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CWizManVolLstIntro::OnInitDialog() 
{
    CSakWizardPage::OnInitDialog();
    
    return TRUE;
}

BOOL CWizManVolLstLevels::OnInitDialog() 
{
    CSakWizardPage::OnInitDialog();

    CString titleText;

    // Set the default initial values for management
    // levels

    m_SpinLevel.SetRange( HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );
    m_SpinSize.SetRange( HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
    m_SpinDays.SetRange( HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );

    m_SpinLevel.SetPos( HSMADMIN_DEFAULT_FREESPACE );
    m_SpinSize.SetPos( HSMADMIN_DEFAULT_MINSIZE );
    m_SpinDays.SetPos( HSMADMIN_DEFAULT_INACTIVITY );

    m_EditLevel.SetLimitText( 2 );
    m_EditSize.SetLimitText( 5 );
    m_EditDays.SetLimitText( 3 );

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    return( TRUE );
}


void CWizManVolLstLevels::SetWizardFinish()
{
}

BOOL CWizManVolLstSelect::OnInitDialog() 
{
    WsbTraceIn( L"CWizManVolLstSelect::OnInitDialog", L"" );

    CSakWizardPage::OnInitDialog();
    HRESULT hr = S_OK;


    try {

        CComPtr<IFsaServer> pFsaServer;
        WsbAffirmHr( m_pSheet->GetFsaServer( &pFsaServer ) );
        WsbAffirmHr( FillListBoxSelect( pFsaServer, &m_listBox ) );

        // Check the "Select" radio button
        CheckRadioButton( IDC_RADIO_MANAGE_ALL, IDC_RADIO_SELECT, 
            IDC_RADIO_SELECT );

    } WsbCatch (hr);

    WsbTraceOut( L"CWizManVolLstSelect::OnInitDialog", L"hr = <%ls>", WsbHrAsString( hr ) );
    return TRUE;
}

//-----------------------------------------------------------------------------
//
//                      FillListBoxSelect
//
//  Fill the selection list box with non-configured managed resources
//
//
HRESULT CWizManVolLstSelect::FillListBoxSelect (IFsaServer *pFsaServer, CSakVolList *pListBox)
{
    WsbTraceIn( L"CWizManVolLstSelect::FillListBoxSelect", L"" );

    BOOL           gotOne   = FALSE;
    HRESULT        hr       = S_OK;
    CResourceInfo* pResInfo = 0;

    try {
        //
        // Connect to the FSA for this machine
        //

        WsbAffirmPointer( pFsaServer );

        CComPtr<IWsbEnum> pEnum;
        WsbAffirmHr(pFsaServer->EnumResources( &pEnum ) );

        HRESULT hrEnum;
        CComPtr<IFsaResource> pResource;

        hrEnum = pEnum->First( IID_IFsaResource, (void**)&pResource );
        WsbAffirm( SUCCEEDED( hrEnum ) || ( WSB_E_NOTFOUND == hrEnum ), hrEnum );

        INT index = 0;
        while( SUCCEEDED( hrEnum ) ) {

            //
            // Is the volume managed?
            //
            if( pResource->IsManaged() != S_OK ) {

                //
                // If path is blank, do not show this volume
                //
                if( S_OK == RsIsVolumeAvailable( pResource ) ) {

                    gotOne = TRUE;

                    pResInfo = new CResourceInfo( pResource );
                    WsbAffirmAlloc( pResInfo );
                    WsbAffirmHr( pResInfo->m_HrConstruct );

                    //
                    // Set Name, Capacity and Free Space columns.
                    //                    
                    LONGLONG    totalSpace  = 0;
                    LONGLONG    freeSpace   = 0;
                    LONGLONG    premigrated = 0;
                    LONGLONG    truncated   = 0;
                    WsbAffirmHr( pResource->GetSizes( &totalSpace, &freeSpace, &premigrated, &truncated ) );
                    CString totalString, freeString;
                    RsGuiFormatLongLong4Char( totalSpace, totalString );
                    RsGuiFormatLongLong4Char( freeSpace, freeString );                  

                    WsbAffirm( pListBox->AppendItem( pResInfo->m_DisplayName, totalString, freeString, &index ), E_FAIL );
                    WsbAffirm( -1 != index, E_FAIL );

                    //
                    // Store struct pointer in listbox
                    //                                      
                    WsbAffirm( pListBox->SetItemData( index, (DWORD_PTR)pResInfo ), E_FAIL );
                    pResInfo = 0;

                    //
                    // Initialize selected array
                    //
                    m_listBoxSelected[ index ] = FALSE;

                }
            }

            //
            // Prepare for next iteration
            //
            pResource.Release( );
            hrEnum = pEnum->Next( IID_IFsaResource, (void**)&pResource );
        }

        m_listBox.SortItems( CResourceInfo::Compare, 0 );

        //
        // Set the button AFTER we fill the box
        //
        CheckRadioButton( IDC_RADIO_MANAGE_ALL, IDC_RADIO_SELECT, IDC_RADIO_SELECT );

    } WsbCatch( hr );

    if( pResInfo )  delete pResInfo;
    
    WsbTraceOut( L"CWizManVolLstSelect::FillListBoxSelect", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


BOOL CWizManVolLstIntro::OnSetActive() 
{
    WsbTraceIn( L"CWizManVolLstIntro::OnSetActive", L"" );

    m_pSheet->SetWizardButtons( PSWIZB_NEXT );

    BOOL retval = CSakWizardPage::OnSetActive();

    WsbTraceOut( L"CWizManVolLstIntro::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

BOOL CWizManVolLstLevels::OnSetActive() 
{
    WsbTraceIn( L"CWizManVolLstLevels::OnSetActive", L"" );

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    BOOL retval = CSakWizardPage::OnSetActive();

    WsbTraceOut( L"CWizManVolLstLevels::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

BOOL CWizManVolLstLevels::OnKillActive() 
{
    WsbTraceIn( L"CWizManVolLstLevels::OnKillActive", L"" );

    BOOL retval = FALSE;

    //
    // Need to handle strange case where a user can enter a value within
    // the parameters of the number of digits allowed, but the value can
    // be out of range. This is detected by the spin box which will
    // return an error if its buddy control is out of range.
    //
    if( HIWORD( m_SpinSize.GetPos( ) ) > 0 ) {

        // Control reports on error...
        retval = FALSE;

        CString message;
        AfxFormatString2( message, IDS_ERR_MINSIZE_RANGE, 
            CString( WsbLongAsString( (LONG)HSMADMIN_MIN_MINSIZE ) ),
            CString( WsbLongAsString( (LONG)HSMADMIN_MAX_MINSIZE ) ) );
        AfxMessageBox( message, MB_OK | MB_ICONWARNING );

    } else {

        retval = CSakWizardPage::OnKillActive();

    }

    WsbTraceOut( L"CWizManVolLstLevels::OnKillActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

BOOL CWizManVolLstSelect::OnSetActive() 
{
    WsbTraceIn( L"CWizManVolLstSelect::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    if( m_listBox.GetItemCount( ) <= 0 ) {

        retval = FALSE;

    }

    SetBtnStates( );

    WsbTraceOut( L"CWizManVolLstSelect::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

BOOL CWizManVolLstFinish::OnSetActive() 
{
    BOOL doAll = FALSE;
    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
    
    //
    // Fill in text of configuration
    //

    CString formattedString, buildString, tempString, indentString;
    indentString.LoadString( IDS_QSTART_FINISH_INDENT );

#define FORMAT_TEXT( cid, arg )              \
    AfxFormatString1( formattedString, cid, arg ); \
    buildString += formattedString;

    //
    // Add Resources
    //

    FORMAT_TEXT( IDS_QSTART_MANRES_TEXT,    0 );
    buildString += L"\r\n";

    CWizManVolLst* pSheet = (CWizManVolLst*) m_pSheet;
    CSakVolList *pListBox = &(pSheet->m_PageSelect.m_listBox);

    INT index, managedCount = 0;
    for( index = 0; index < pListBox->GetItemCount( ); index++ ) {

        if( pListBox->GetCheck( index ) ) {

            buildString += indentString;
            tempString = pListBox->GetItemText( index, 0);
            buildString += tempString;
            buildString += L"\r\n";

            managedCount++;

        }

    }

    if( 0 == managedCount ) {

        FORMAT_TEXT( IDS_QSTART_MANAGE_NO_VOLUMES, 0 );
        buildString += L"\r\n\r\n";

    } else {

        buildString += L"\r\n";

        //
        // The levels
        //
        
        FORMAT_TEXT( IDS_QSTART_FREESPACE_TEXT, WsbLongAsString( pSheet->m_PageLevels.m_SpinLevel.GetPos( ) ) );
        buildString += L"\r\n\r\n";
        
        AfxFormatString2( formattedString, IDS_QSTART_CRITERIA_TEXT,
            CString( WsbLongAsString( pSheet->m_PageLevels.m_SpinSize.GetPos( ) ) ),
            CString( WsbLongAsString( pSheet->m_PageLevels.m_SpinDays.GetPos( ) ) ) );
        buildString += formattedString;

    }

    CEdit * pEdit = (CEdit*)GetDlgItem( IDC_WIZ_FINAL_TEXT );
    pEdit->SetWindowText( buildString );

    //
    // Now check to see if we should add a scroll bar
    //

    pEdit->SetMargins( 4, 4 );

    //
    // It seems the only way to know that an edit control needs a scrollbar
    // is to force it to scroll to the bottom and see if the first
    // visible line is the first actual line
    //

    pEdit->LineScroll( MAXSHORT );
    if( pEdit->GetFirstVisibleLine( ) > 0 ) {

        //
        // Add the scroll styles
        //

        pEdit->ModifyStyle( 0, WS_VSCROLL | ES_AUTOVSCROLL, SWP_DRAWFRAME );


    } else {

        //
        // Remove the scrollbar (set range to 0)
        //

        pEdit->SetScrollRange( SB_VERT, 0, 0, TRUE );

    }

    // Scroll to the top
    pEdit->PostMessage( EM_SETSEL, 0, 0 );
    pEdit->PostMessage( EM_SCROLLCARET, 0, 0 );
    pEdit->PostMessage( EM_SETSEL, -1, 0 );

    BOOL fRet = CSakWizardPage::OnSetActive();


    return fRet;
}

void CWizManVolLstFinish::OnSetfocusWizManvollstFinalEdit() 
{

    // Deselect the text
    CEdit *pEdit = (CEdit *) GetDlgItem( IDC_WIZ_FINAL_TEXT );
    pEdit->SetSel( -1, 0, FALSE );
    
}

ULONG CWizManVolLstLevels::GetFileSize()
{
    return( m_SpinSize.GetPos( ) );
}
        
INT CWizManVolLstLevels::GetHsmLevel() 
{
    return( m_SpinLevel.GetPos( ) );
}

INT CWizManVolLstLevels::GetAccessDays() 
{
    return( m_SpinDays.GetPos( ) );
}

void CWizManVolLstSelect::OnItemchangedManVollstFsareslbox(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    SetBtnStates();
    
    *pResult = 0;
}

void CWizManVolLstSelect::SetBtnStates()
{
    BOOL fChecked = FALSE;
    INT count;

    // Is the "all" radio checked?
    if( !( m_radioSelect.GetCheck() == 1 ) ) {

        fChecked = TRUE;

    } else {

        // If one or more selected in the list box, set next button
        count = m_listBox.GetItemCount();
        for( INT index = 0; index < count; index++ ) {
            if( m_listBox.GetCheck( index ) == 1 ) {

                fChecked = TRUE;

            }
        }
    }

    if( fChecked ) {

        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    } else {

        m_pSheet->SetWizardButtons( PSWIZB_BACK );

    }
}


void CWizManVolLstSelect::OnRadioSelect() 
{
    INT i;

    //
    // Get saved selection from itemdata array
    //
    for( i = 0; i < m_listBox.GetItemCount(); i++ ) {

        m_listBox.SetCheck( i, m_listBoxSelected[ i ] );

    }

    m_listBox.EnableWindow( TRUE );

    SetBtnStates();
}


void CWizManVolLstSelect::OnRadioManageAll() 
{
    INT i;

    //
    // Save the current selection in the itemData array
    // Check all the boxes for display purposes only
    //
    for( i = 0; i < m_listBox.GetItemCount(); i++ ) {

        m_listBoxSelected[ i ] = m_listBox.GetCheck( i );
        m_listBox.SetCheck( i, TRUE );

    }

    m_listBox.EnableWindow( FALSE );

    SetBtnStates();
}

void CWizManVolLstSelect::OnDestroy() 
{
    WsbTraceIn( L"CWizManVolLstSelect::OnDestroy", L"" );
    CSakWizardPage::OnDestroy();
    
    //
    // Need to free info held by list box
    //

    INT index;
    for( index = 0; index < m_listBox.GetItemCount( ); index++ ) {

        CResourceInfo* pResInfo = (CResourceInfo*)m_listBox.GetItemData( index );
        delete pResInfo;

    }

    WsbTraceOut( L"CWizManVolLstSelect::OnDestroy", L"" );
}
/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstSelectX property page

CWizManVolLstSelectX::CWizManVolLstSelectX()
    : CSakWizardPage_InitBaseInt( WIZ_MANVOLLST_SELECTX )
{
    //{{AFX_DATA_INIT(CWizManVolLstSelectX)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CWizManVolLstSelectX::~CWizManVolLstSelectX()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLstSelectX", L"" );

    WsbTraceOut( L"CWizManVolLst::~CWizManVolLstSelectX", L"" );
}

void CWizManVolLstSelectX::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizManVolLstSelectX)
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizManVolLstSelectX, CSakWizardPage)
    //{{AFX_MSG_MAP(CWizManVolLstSelectX)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CWizManVolLstSelectX::OnSetActive() 
{
    WsbTraceIn( L"CWizManVolLstSelectX::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    CWizManVolLst* pSheet = (CWizManVolLst*) m_pSheet;
    if( pSheet->m_PageSelect.m_listBox.GetItemCount( ) > 0 ) {

        retval = FALSE;

    }

    m_pSheet->SetWizardButtons( PSWIZB_BACK );

    WsbTraceOut( L"CWizManVolLstSelectX::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\valwait.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    valwait.h

Abstract:

    Implements Validate Wait Dialog class

Author:

    Ran Kalach          [rankala]         23-May-2000

Revision History:

--*/
#ifndef _VALWAIT_
#define _VALWAIT_

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CValWaitDlg dialog
class CUnmanageWizard;

class CValWaitDlg : public CDialog
{
// Construction
public:
	CValWaitDlg(CUnmanageWizard *pSheet, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CValWaitDlg)
	enum { IDD = IDD_VALIDATE_WAIT };
	CAnimateCtrl	m_Animation;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CValWaitDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL

// Implementation
protected:

    CUnmanageWizard *m_pSheet;

	// Generated message map functions
	//{{AFX_MSG(CValWaitDlg)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
//}}AFX

#endif // _VALWAIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\wzunmang.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WzUnmang.cpp

Abstract:

    Wizard for Unmanaging media - Copy Set Wizard.

Author:

    Rohde Wakefield [rohde]   26-09-1997

Revision History:

--*/

#include "stdafx.h"

#include "ManVol.h"
#include "WzUnmang.h"
#include "valwait.h"
#include "objidl.h"

// Thread function for running Validate job
static DWORD   RunValidateJob(void* pVoid);

typedef struct {
    DWORD dwResourceCookie;
    DWORD dwHsmServerCookie;
} RUN_VALIDATE_PARAM;

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizard

CUnmanageWizard::CUnmanageWizard( )
{
    WsbTraceIn( L"CUnmanageWizard::CUnmanageWizard", L"" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;

    //
    // Get interfaces to needed objects
    //
    try {

        m_TitleId     = IDS_WIZ_UNMANAGE_TITLE;
        m_HeaderId    = IDB_UNMANAGE_HEADER;
        m_WatermarkId = IDB_UNMANAGE_WATERMARK;

    } WsbCatch( hr );

    WsbTraceOut( L"CUnmanageWizard::CUnmanageWizard", L"" );
}

STDMETHODIMP
CUnmanageWizard::AddWizardPages(
    IN RS_PCREATE_HANDLE Handle,
    IN IUnknown*         pCallback,
    IN ISakSnapAsk*      pSakSnapAsk
    )
{
    WsbTraceIn( L"CUnmanageWizard::AddWizardPages", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Initialize the Sheet
        //
        WsbAffirmHr( InitSheet( Handle, pCallback, 0, pSakSnapAsk, 0, 0 ) );

        //
        // Load pages 
        //
        WsbAffirmHr( AddPage( &m_IntroPage  ) );
        WsbAffirmHr( AddPage( &m_SelectPage ) );
        WsbAffirmHr( AddPage( &m_FinishPage ) );


    } WsbCatch( hr );

    WsbTraceOut( L"CUnmanageWizard::AddWizardPages", L"" );
    return( hr );
}

CUnmanageWizard::~CUnmanageWizard()
{
    WsbTraceIn( L"CUnmanageWizard::~CUnmanageWizard", L"" );
    WsbTraceOut( L"CUnmanageWizard::~CUnmanageWizard", L"" );
}

void
CUnmanageWizard::DoThreadSetup(
    )
{
    WsbTraceIn( L"CUnmanageWizard::DoThreadSetup", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Get the HSM and FSA objects for resource
        //
        CComPtr<IUnknown> pUnkHsmResource;
        WsbAffirmHr( GetHsmObj( &pUnkHsmResource ) );
        WsbAffirmHr( pUnkHsmResource.QueryInterface( &m_pHsmResource) );

        CComPtr<IUnknown> pUnkFsaResource;
        WsbAffirmHr( m_pHsmResource->GetFsaResource( &pUnkFsaResource ) );
        WsbAffirmHr( pUnkFsaResource.QueryInterface( &m_pFsaResource ) );

        //
        // Grab the name of resource
        //
        WsbAffirmHr( RsGetVolumeDisplayName( m_pFsaResource, m_DisplayName ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUnmanageWizard::DoThreadSetup", L"hr = <%ls>", WsbHrAsString( hr ) );
}

HRESULT CUnmanageWizard::OnFinish( )
{
    WsbTraceIn( L"CUnmanageWizard::OnFinish", L"" );
    //
    // The sheet really owns the process as a whole,
    // so it will do the final assembly
    //

    HRESULT hr = S_OK;

    try {

        CComPtr<IHsmServer> pHsmServer;
        WsbAffirmHrOk( GetHsmServer( &pHsmServer ) );

        int selected = m_SelectPage.GetCheckedRadioButton( IDC_NOMANAGE, IDC_FULL );
        switch( selected ) {
        
        case IDC_NOMANAGE:
            //
            // Get the Engine's managed resource collection
            //
            {

                CComPtr<IWsbIndexedCollection> pCollection;
                WsbAffirmHr( pHsmServer->GetManagedResources( &pCollection ) );
                WsbAffirmHr( pCollection->RemoveAndRelease( m_pHsmResource ) );
                WsbAffirmHr( pHsmServer->SavePersistData( ) );

                CComPtr<IFsaServer> pFsaServer;
                WsbAffirmHr( GetFsaServer( &pFsaServer ) );
                WsbAffirmHr( RsServerSaveAll( pFsaServer ) );

            }
            break;
        
        case IDC_FULL:
            WsbAffirmHr( RsCreateAndRunFsaJob( HSM_JOB_DEF_TYPE_FULL_UNMANAGE, pHsmServer, m_pFsaResource, FALSE ) );
            break;
        
        }

    } WsbCatch( hr );

    m_HrFinish = hr;

    WsbTraceOut( L"CUnmanageWizard::OnFinish", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardIntro property page

CUnmanageWizardIntro::CUnmanageWizardIntro()
    : CSakWizardPage_InitBaseExt( WIZ_UNMANAGE_INTRO )
{
    WsbTraceIn( L"CUnmanageWizardIntro::CUnmanageWizardIntro", L"" );
    //{{AFX_DATA_INIT(CUnmanageWizardIntro)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CUnmanageWizardIntro::CUnmanageWizardIntro", L"" );
}

CUnmanageWizardIntro::~CUnmanageWizardIntro()
{
    WsbTraceIn( L"CUnmanageWizardIntro::~CUnmanageWizardIntro", L"" );
    WsbTraceOut( L"CUnmanageWizardIntro::~CUnmanageWizardIntro", L"" );
}

void CUnmanageWizardIntro::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CUnmanageWizardIntro::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CUnmanageWizardIntro)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CUnmanageWizardIntro::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CUnmanageWizardIntro, CSakWizardPage)
    //{{AFX_MSG_MAP(CUnmanageWizardIntro)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardIntro message handlers

BOOL CUnmanageWizardIntro::OnInitDialog( )
{
    WsbTraceIn( L"CUnmanageWizardIntro::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );

    //
    // Really, first chance that we know we're in the new thread
    // Get sheet to initialize as needed
    //
    CUnmanageWizard* pSheet = (CUnmanageWizard*) m_pSheet;
    pSheet->DoThreadSetup( );
    
    WsbTraceOut( L"CUnmanageWizardIntro::OnInitDialog", L"" );
    return( TRUE );
}

BOOL CUnmanageWizardIntro::OnSetActive( )
{
    WsbTraceIn( L"CUnmanageWizardIntro::OnSetActive", L"" );
    m_pSheet->SetWizardButtons( PSWIZB_NEXT );
    
    BOOL retval = CSakWizardPage::OnSetActive( );

    WsbTraceOut( L"CUnmanageWizardIntro::OnSetActive", L"" );
    return( retval );
}

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardSelect property page

CUnmanageWizardSelect::CUnmanageWizardSelect()
    : CSakWizardPage_InitBaseInt( WIZ_UNMANAGE_SELECT )
{
    WsbTraceIn( L"CUnmanageWizardSelect::CUnmanageWizardSelect", L"" );
    //{{AFX_DATA_INIT(CUnmanageWizardSelect)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CUnmanageWizardSelect::CUnmanageWizardSelect", L"" );
}

CUnmanageWizardSelect::~CUnmanageWizardSelect()
{
    WsbTraceIn( L"CUnmanageWizardSelect::~CUnmanageWizardSelect", L"" );
    WsbTraceOut( L"CUnmanageWizardSelect::~CUnmanageWizardSelect", L"" );
}

void CUnmanageWizardSelect::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CUnmanageWizardSelect::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CUnmanageWizardSelect)
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CUnmanageWizardSelect::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CUnmanageWizardSelect, CSakWizardPage)
    //{{AFX_MSG_MAP(CUnmanageWizardSelect)
	ON_BN_CLICKED(IDC_BUTTON_REFRESH, OnButtonRefresh)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardSelect message handlers


BOOL CUnmanageWizardSelect::OnInitDialog( )
{
    WsbTraceIn( L"CUnmanageWizardSelect::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );
    HRESULT hr = S_OK;

    try {

        m_hrAvailable = ((CUnmanageWizard*)m_pSheet)->m_pFsaResource->IsAvailable( );
        CheckRadioButton( IDC_NOMANAGE, IDC_FULL, IDC_FULL );

    } WsbCatch( hr );

    WsbTraceOut( L"CUnmanageWizardSelect::OnInitDialog", L"" );
    return TRUE;
}

BOOL CUnmanageWizardSelect::OnSetActive( )
{
    WsbTraceIn( L"CUnmanageWizardSelect::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    SetButtons( );

    WsbTraceOut( L"CUnmanageWizardSelect::OnSetActive", L"" );
    return( retval );
}

void CUnmanageWizardSelect::SetButtons()
{
    WsbTraceIn( L"CUnmanageWizardSelect::SetButtons", L"" );

    HRESULT hr = S_OK;

    try {

        CUnmanageWizard * pSheet = (CUnmanageWizard*)m_pSheet;

        //
        // Check if volume is still around (could be formatted now).
        // If it is not available, then we don't want to let a job
        // be started against it, so set up radio buttons appropriately.
        //
        if( S_OK == m_hrAvailable ) {

            CString  string;
            LONGLONG total, free, premigrated, truncated;
            WsbAffirmHr( pSheet->m_pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );

            WsbAffirmHr( RsGuiFormatLongLong4Char( free, string ) );
            SetDlgItemText( IDC_UNMANAGE_FREE_SPACE, string );

            WsbAffirmHr( RsGuiFormatLongLong4Char( truncated, string ) );
            SetDlgItemText( IDC_UNMANAGE_TRUNCATE, string );

            //
            // See if there is enough room to bring everything back
            //

            BOOL disableRecall = free < truncated;

            if( disableRecall ) {

                switch( GetCheckedRadioButton( IDC_NOMANAGE, IDC_FULL ) ) {

                case IDC_FULL:
                    CheckRadioButton( IDC_NOMANAGE, IDC_FULL, IDC_NOMANAGE );

                    break;
                }

                // Show the Refresh button and related items on every selection
                GetDlgItem( IDC_BUTTON_REFRESH )->ShowWindow( SW_SHOW );
                GetDlgItem( IDC_REFRESH_DESCRIPTION )->ShowWindow( SW_SHOW );

            } else {

                // Hide the Refresh button and related items
                GetDlgItem( IDC_BUTTON_REFRESH )->ShowWindow( SW_HIDE );
                GetDlgItem( IDC_REFRESH_DESCRIPTION )->ShowWindow( SW_HIDE );
            }

            GetDlgItem( IDC_FULL )->EnableWindow( !disableRecall );
            GetDlgItem( IDC_UNMANAGE_FULL_DESCRIPTION )->EnableWindow( !disableRecall );

        } else {

            CheckRadioButton( IDC_NOMANAGE, IDC_FULL, IDC_NOMANAGE );
            GetDlgItem( IDC_FULL )->EnableWindow( FALSE );
            GetDlgItem( IDC_UNMANAGE_FULL_DESCRIPTION )->EnableWindow( FALSE );
            GetDlgItem( IDC_UNMANAGE_FREE_SPACE_LABEL )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_UNMANAGE_TRUNCATE_LABEL )->ShowWindow( SW_HIDE );

            // Hide the Refresh button and related items
            GetDlgItem( IDC_BUTTON_REFRESH )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_REFRESH_DESCRIPTION )->ShowWindow( SW_HIDE );
        }

        //
        // Enable the next / back buttons
        //

        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    } WsbCatchAndDo( hr,
        
        m_pSheet->SetWizardButtons( PSWIZB_BACK );

    );

    WsbTraceOut( L"CUnmanageWizardSelect::SetButtons", L"" );
}


LRESULT CUnmanageWizardSelect::OnWizardNext() 
{
    WsbTraceIn( L"CUnmanageWizardSelect::SetDescription", L"" );

    LRESULT retval = -1;

    CUnmanageWizard * pSheet = (CUnmanageWizard*)m_pSheet;

    if( S_OK == m_hrAvailable ) {

        int boxReturn = IDNO;
        const UINT type = MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2;
        CString warning;

        switch( GetCheckedRadioButton( IDC_NOMANAGE, IDC_FULL ) ) {

        case IDC_NOMANAGE:
            AfxFormatString1( warning, IDS_WIZ_UNMANAGE_CONFIRM_NOMANAGE, pSheet->m_DisplayName );
            break;

        case IDC_FULL:
            AfxFormatString1( warning, IDS_WIZ_UNMANAGE_CONFIRM_FULL, pSheet->m_DisplayName );
            break;

        }

        boxReturn = AfxMessageBox( warning, type );
        if( boxReturn == IDYES ) {

            retval = CSakWizardPage::OnWizardNext();

        }

    } else {

        //
        // Assume the only action was to delete and the volume
        // doesn't exist, so this is OK.
        //
        retval = 0;

    }

    WsbTraceOut( L"CUnmanageWizardSelect::SetDescription", L"retval = <%ld>", retval );
    return( retval );
}

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardFinish property page

CUnmanageWizardFinish::CUnmanageWizardFinish()
    : CSakWizardPage_InitBaseExt( WIZ_UNMANAGE_FINISH )
{
    WsbTraceIn( L"CUnmanageWizardFinish::CUnmanageWizardFinish", L"" );
    //{{AFX_DATA_INIT(CUnmanageWizardFinish)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CUnmanageWizardFinish::CUnmanageWizardFinish", L"" );
}

CUnmanageWizardFinish::~CUnmanageWizardFinish()
{
    WsbTraceIn( L"CUnmanageWizardFinish::~CUnmanageWizardFinish", L"" );
    WsbTraceOut( L"CUnmanageWizardFinish::~CUnmanageWizardFinish", L"" );
}

void CUnmanageWizardFinish::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CUnmanageWizardFinish::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CUnmanageWizardFinish)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CUnmanageWizardFinish::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CUnmanageWizardFinish, CSakWizardPage)
    //{{AFX_MSG_MAP(CUnmanageWizardFinish)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardFinish message handlers




BOOL CUnmanageWizardFinish::OnInitDialog( )
{
    WsbTraceIn( L"CUnmanageWizardFinish::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );
    HRESULT hr = S_OK;

    WsbTraceOut( L"CUnmanageWizardFinish::OnInitDialog", L"" );
    return TRUE;
}

BOOL CUnmanageWizardFinish::OnSetActive( )
{
    WsbTraceIn( L"CUnmanageWizardFinish::OnSetActive", L"" );

    HRESULT hr = S_OK;
    BOOL fRet = CSakWizardPage::OnSetActive( );

    try {

        CUnmanageWizard * pSheet = (CUnmanageWizard*)m_pSheet;
        int selected = pSheet->m_SelectPage.GetCheckedRadioButton( IDC_NOMANAGE, IDC_FULL );
        
        CString actionString, jobName, taskString;
        BOOL    entersTask = TRUE;
        
        switch( selected ) {
        
        case IDC_NOMANAGE:
            AfxFormatString1( actionString, IDS_WIZ_UNMANAGE_SEL_NOMANAGE, pSheet->m_DisplayName );
            entersTask = FALSE;
            taskString.LoadString( IDS_WIZ_UNMANAGE_NOMANAGE_TASK_TEXT );
            break;
        
        case IDC_FULL:
            AfxFormatString1( actionString, IDS_WIZ_UNMANAGE_SEL_FULL, pSheet->m_DisplayName );
            RsCreateJobName( HSM_JOB_DEF_TYPE_FULL_UNMANAGE, pSheet->m_pFsaResource, jobName );
            break;
        
        }

        CString selectString;
        AfxFormatString1( selectString, IDS_WIZ_UNMANAGE_SELECT, actionString );
        SetDlgItemText( IDC_SELECT_TEXT, selectString );

        if( entersTask ) {

            CWsbStringPtr        computerName;
            CComPtr<IHsmServer>  pHsmServer;
            WsbAffirmHrOk( pSheet->GetHsmServer( &pHsmServer ) );

            WsbAffirmHr( pHsmServer->GetName( &computerName ) );
            AfxFormatString2( taskString, IDS_WIZ_FINISH_RUN_JOB, jobName, computerName );

        }
        SetDlgItemText( IDC_TASK_TEXT, taskString );


    } WsbCatch( hr );

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
    
    WsbTraceOut( L"CUnmanageWizardFinish::OnSetActive", L"" );
    return fRet;
}




void CUnmanageWizardSelect::OnButtonRefresh() 
{
    WsbTraceIn( L"CUnmanageWizardFinish::OnButtonRefresh", L"" );

    HRESULT                         hr = S_OK;
    CValWaitDlg*                    pWaitDlg = 0;
    HANDLE                          hJobThread[1] = { NULL };
    BOOL                            bRunning = TRUE;

    CComPtr<IGlobalInterfaceTable>  pGIT;
    RUN_VALIDATE_PARAM*             pThreadParam = NULL;
    BOOL                            bResCookieCreated = FALSE;
    BOOL                            bHsmCookieCreated = FALSE;
    CComPtr<IHsmServer>             pHsmServer;


    try {
        CUnmanageWizard* pSheet = (CUnmanageWizard*)m_pSheet;
        WsbAffirmHrOk(pSheet->GetHsmServer(&pHsmServer));

        // Register interfaces so they can be used in other threads
        pThreadParam = new RUN_VALIDATE_PARAM;
        WsbAffirm(pThreadParam, E_OUTOFMEMORY);
        WsbAffirmHr(CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, 
                        CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&pGIT));
        WsbAffirmHr(pGIT->RegisterInterfaceInGlobal((IUnknown *)(IFsaResource *)(pSheet->m_pFsaResource),
                                IID_IFsaResource, &(pThreadParam->dwResourceCookie)));
        bResCookieCreated = TRUE;
        WsbAffirmHr(pGIT->RegisterInterfaceInGlobal((IUnknown *)(IHsmServer *)pHsmServer,
                                IID_IHsmServer, &(pThreadParam->dwHsmServerCookie)));
        bHsmCookieCreated = TRUE;

        // Create a thread that runs a Validate job
        hJobThread[0] = CreateThread(0, 0, RunValidateJob, (void *)pThreadParam, 0, 0);
        if (!hJobThread[0]) {
            WsbThrow(HRESULT_FROM_WIN32(GetLastError()));
        }

        // Open Validate Wait dialog
        pWaitDlg = new CValWaitDlg(pSheet, this);
        WsbAffirm(pWaitDlg, E_OUTOFMEMORY);
        if (! pWaitDlg->Create(CValWaitDlg::IDD, this)) {
            // Dialog creation failed
            WsbThrow(E_FAIL);
        }

        while (bRunning) {
            DWORD dwStatus;

            // Wait for that thread to finish, dispatch messages while it's working
            dwStatus = MsgWaitForMultipleObjects(1, hJobThread, FALSE, INFINITE, QS_ALLEVENTS);

            switch (dwStatus) {
                case WAIT_OBJECT_0: {
                    //  The thread ended get it's exit code
                    DWORD dwExitCode;
                    if (GetExitCodeThread(hJobThread[0], &dwExitCode)) {
                        if (STILL_ACTIVE == dwExitCode) {
                            //  This shouldn't happen
                            hr = E_FAIL;
                        } else {
                            // Thread return code
                            hr = static_cast<HRESULT>(dwExitCode);
                        }
                    } else {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }

                    bRunning = FALSE;

                    break;
                }

                case (WAIT_OBJECT_0 + 1): {
                    // Message in the queue
                    MSG   msg;

                    while (PeekMessage(&msg, pWaitDlg->m_hWnd, 0, 0, PM_REMOVE)) {
                        DispatchMessage(&msg);
                    }

                    while (PeekMessage(&msg, NULL, 0, 0, (PM_REMOVE | PM_QS_PAINT))) {
                        DispatchMessage(&msg);
                    }

                    break;
                }

                case 0xFFFFFFFF:
                default:
                    // Error
                    hr = HRESULT_FROM_WIN32(GetLastError());

                    bRunning = FALSE;

                    break;
            }
        }

        // Close Wait dialog
        pWaitDlg->DestroyWindow( );

        // Reset buttons
        SetButtons();

    } WsbCatch(hr);

    // Check err code
    if (SUCCEEDED(hr)) {
        WsbTrace(L"CUnmanageWizardFinish::OnButtonRefresh: hr = <%ls>\n", WsbHrAsString(hr));
    } else {
        // Failure should happen only under sever resource conditions so 
        // display a messagebox on Refresh failure
        WsbTraceAlways(L"CUnmanageWizardFinish::OnButtonRefresh: hr = <%ls>\n", WsbHrAsString(hr));
        CString errString;
        AfxFormatString1(errString, IDS_ERR_REFRESH_FAILED, WsbHrAsString(hr));
        AfxMessageBox(errString, RS_MB_ERROR); 
    }

    if (hJobThread[0]) {
        CloseHandle(hJobThread[0]);
    }

    // Clean object registration staff
    if (bResCookieCreated) {
        pGIT->RevokeInterfaceFromGlobal(pThreadParam->dwResourceCookie);
    }
    if (bHsmCookieCreated) {
        pGIT->RevokeInterfaceFromGlobal(pThreadParam->dwHsmServerCookie);
    }
    if (pThreadParam) {
        delete pThreadParam;
    }

    WsbTraceOut( L"CUnmanageWizardFinish::OnButtonRefresh", L"" );
}

static DWORD RunValidateJob(void* pVoid)
{
    WsbTraceIn( L"RunValidateJob", L"" );

    HRESULT             hr = S_OK;
    HRESULT             hrCom = S_OK;

    try {
        RUN_VALIDATE_PARAM*             pThreadParam = NULL;
        CComPtr<IHsmServer>             pHsmServer;
        CComPtr<IFsaResource>           pFsaResource;
        CComPtr<IGlobalInterfaceTable>  pGIT;

        hrCom = CoInitialize( 0 );
        WsbAffirmHr( hrCom );

        pThreadParam = (RUN_VALIDATE_PARAM*)pVoid;
        WsbAffirmPointer(pThreadParam);

        // Get Fsa Resource & HSM Server interface pointers for this thread
        WsbAffirmHr(CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, 
                        CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&pGIT));
        WsbAffirmHr(pGIT->GetInterfaceFromGlobal(pThreadParam->dwResourceCookie,
                                IID_IFsaResource, (void **)&pFsaResource));
        WsbAffirmHr(pGIT->GetInterfaceFromGlobal(pThreadParam->dwHsmServerCookie,
                                IID_IHsmServer, (void **)&pHsmServer));

        // Run job
        WsbTrace(L"RunValidateJob: Got interface pointers, running Validate job\n");
        WsbAffirmHr(RsCreateAndRunDirectFsaJob(HSM_JOB_DEF_TYPE_VALIDATE, pHsmServer,
                        pFsaResource, TRUE));

    } WsbCatch(hr);

    if (SUCCEEDED(hrCom)) {
        CoUninitialize();
    }
 
    WsbTraceOut( L"RunValidateJob", L"hr = <%ls>", WsbHrAsString( hr ) );

    return(static_cast<DWORD>(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\inc\proppage.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PropPage.h

Abstract:

    Generic Property Page base class.

Author:

    Rohde Wakefield [rohde]   04-Aug-1997

Revision History:

--*/

#ifndef _PROPPAGE_H
#define _PROPPAGE_H

#pragma once

#define IDC_WIZ_TITLE                    32000
#define IDC_WIZ_SUBTITLE                 32001
#define IDC_WIZ_FINAL_TEXT               32006

#define IDS_WIZ_WINGDING_FONTSIZE        32100
#define IDS_WIZ_TITLE1_FONTNAME          32101
#define IDS_WIZ_TITLE1_FONTSIZE          32102

#ifndef RC_INVOKED

/////////////////////////////////////////////////////////////////////////////
// CRsDialog dialog

class CRsDialog : public CDialog
{
// Construction
public:
    CRsDialog( UINT nIDTemplate, CWnd* pParent = NULL);   // standard constructor
    ~CRsDialog();

// Dialog Data
    //{{AFX_DATA(CRsDialog)
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CRsDialog)
    protected:
    //}}AFX_VIRTUAL

protected:
    const DWORD * m_pHelpIds;
    // Generated message map functions
    //{{AFX_MSG(CRsDialog)
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CRsPropertyPage dialog

class CRsPropertyPage : public CPropertyPage
{
// Construction
public:
    CRsPropertyPage( UINT nIDTemplate, UINT nIDCaption = 0 );
    ~CRsPropertyPage();

// Dialog Data
    //{{AFX_DATA(CRsPropertyPage)
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CRsPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    LPFNPSPCALLBACK      m_pMfcCallback; // Original MFC callback from psp
    static UINT CALLBACK PropPageCallback( HWND hWnd, UINT uMessage, LPPROPSHEETPAGE  ppsp );
    virtual void OnPageCreate( ) { };
    virtual void OnPageRelease( ) { delete this; };

#define RSPROPPAGE_FONT_DECL(name) \
    static CFont m_##name##Font;   \
    CFont* Get##name##Font( void );\
    void   Init##name##Font( void );

    RSPROPPAGE_FONT_DECL( Shell )
    RSPROPPAGE_FONT_DECL( BoldShell )
    RSPROPPAGE_FONT_DECL( WingDing )
    RSPROPPAGE_FONT_DECL( LargeTitle )
    RSPROPPAGE_FONT_DECL( SmallTitle )

    LPCTSTR GetWingDingFontName( )  { return( _T("Marlett") ); };
    LPCTSTR GetWingDingCheckChar( ) { return( _T("b") ); };
    LPCTSTR GetWingDingExChar( )    { return( _T("r") ); };

protected:
    const DWORD * m_pHelpIds;
    // Generated message map functions
    //{{AFX_MSG(CRsPropertyPage)
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//
// The following is to work around MFC not supporting Wiz97 pages.
// We create our own struct which is the correct Wiz97 struct and
// on creation do the "right thing" (copy over old PSP into new PSP
// and do the create). This is adapted from prsht.h in sdk\inc
//

typedef struct _PROPSHEETPAGEW97 {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCWSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        }DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCWSTR      pszIcon;
        }DUMMYUNIONNAME2;
        LPCWSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT FAR * pcRefParent;

//#if (_WIN32_IE >= 0x0400)
        LPCWSTR pszHeaderTitle;    // this is displayed in the header
        LPCWSTR pszHeaderSubTitle; ///
//#endif
} PROPSHEETPAGEW97, FAR *LPPROPSHEETPAGEW97;

#ifndef PSP_HIDEHEADER
#  define PSP_HIDEHEADER             0x00000800
#  define PSP_USEHEADERTITLE         0x00001000
#  define PSP_USEHEADERSUBTITLE      0x00002000
#endif

//
// Constructor wrapper macros to allow easy description of dialog resource and
// associated string resources
//

#define CRsWizardPage_InitBaseInt( DlgId )  CRsWizardPage( IDD_##DlgId, FALSE, IDS_##DlgId##_TITLE, IDS_##DlgId##_SUBTITLE )
#define CRsWizardPage_InitBaseExt( DlgId )  CRsWizardPage( IDD_##DlgId, TRUE )

class CRsWizardPage : public CRsPropertyPage  
{
public:
    CRsWizardPage( UINT nIDTemplate, BOOL bExterior = FALSE, UINT nIdTitle = 0, UINT nIdSubtitle = 0 );
    virtual ~CRsWizardPage();

// Dialog Data
    //{{AFX_DATA(CRsWizardPage)
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CRsWizardPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    PROPSHEETPAGEW97 m_psp97;

    BOOL    m_ExteriorPage;
    UINT    m_TitleId,
            m_SubtitleId;
    CString m_Title,
            m_SubTitle;

protected:

    // Generated message map functions
    //{{AFX_MSG(CRsWizardPage)
    virtual BOOL OnInitDialog();
    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
public:
    void SetCaption( CString& strCaption );
    HPROPSHEETPAGE CreatePropertyPage( );

};




//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif // !RC_INVOKED


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\wzmnvlls.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WzMnVlLs.h

Abstract:

    Managed Volume wizard.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#ifndef _WZMNVLLS_H
#define _WZMNVLLS_H

#include "SakVlLs.h"

// Pre-declare
class CWizManVolLst;

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstLevels dialog

class CWizManVolLstLevels : public CSakWizardPage
{
// Construction
public:
    CWizManVolLstLevels( );
    ~CWizManVolLstLevels();

// Dialog Data
    //{{AFX_DATA(CWizManVolLstLevels)
    enum { IDD = IDD_WIZ_MANVOLLST_LEVELS };
    CSpinButtonCtrl m_SpinSize;
    CSpinButtonCtrl m_SpinLevel;
    CSpinButtonCtrl m_SpinDays;
    CEdit   m_EditSize;
    CEdit   m_EditLevel;
    CEdit   m_EditDays;
    long    m_HsmLevel;
    UINT    m_AccessDays;
    DWORD   m_FileSize;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWizManVolLstLevels)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CWizManVolLstLevels)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    void SetWizardFinish(void);

public:
    ULONG GetFileSize();
    int GetHsmLevel();
    int GetAccessDays();

};

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstIntro dialog

class CWizManVolLstIntro : public CSakWizardPage
{
// Construction
public:
    CWizManVolLstIntro( );
    ~CWizManVolLstIntro();

// Dialog Data
    //{{AFX_DATA(CWizManVolLstIntro)
    enum { IDD = IDD_WIZ_MANVOLLST_INTRO };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWizManVolLstIntro)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CWizManVolLstIntro)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstFinish dialog

class CWizManVolLstFinish : public CSakWizardPage
{
// Construction
public:
    CWizManVolLstFinish( );
    ~CWizManVolLstFinish();

// Dialog Data
    //{{AFX_DATA(CWizManVolLstFinish)
    enum { IDD = IDD_WIZ_MANVOLLST_FINISH };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWizManVolLstFinish)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CWizManVolLstFinish)
    afx_msg void OnSetfocusWizManvollstFinalEdit();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstSelect dialog

class CWizManVolLstSelect : public CSakWizardPage
{
// Construction
public:
    CWizManVolLstSelect( );
    ~CWizManVolLstSelect();

// Dialog Data
    //{{AFX_DATA(CWizManVolLstSelect)
    enum { IDD = IDD_WIZ_MANVOLLST_SELECT };
    CButton m_radioSelect;
    CSakVolList   m_listBox;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWizManVolLstSelect)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CWizManVolLstSelect)
    virtual BOOL OnInitDialog();
    afx_msg void OnItemchangedManVollstFsareslbox(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnRadioSelect();
    afx_msg void OnRadioManageAll();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fChangingByCode;
    void SetBtnStates();
    BOOL m_listBoxSelected[HSMADMIN_MAX_VOLUMES];
    HRESULT FillListBoxSelect (IFsaServer *pFsaServer,CSakVolList *pListBox);
};

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstSelectX dialog

class CWizManVolLstSelectX : public CSakWizardPage
{
// Construction
public:
    CWizManVolLstSelectX( );
    ~CWizManVolLstSelectX();

// Dialog Data
    //{{AFX_DATA(CWizManVolLstSelectX)
    enum { IDD = IDD_WIZ_MANVOLLST_SELECTX };
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWizManVolLstSelectX)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CWizManVolLstSelectX)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLst

class CUiManVolLst;


class CWizManVolLst : public CSakWizardSheet
{
// Construction
public:
    CWizManVolLst();
    virtual ~CWizManVolLst();

public:
// Property Pages
    CWizManVolLstIntro    m_PageIntro;
    CWizManVolLstSelect   m_PageSelect;
    CWizManVolLstSelectX  m_PageSelectX;
    CWizManVolLstLevels   m_PageLevels;
    CWizManVolLstFinish   m_PageFinish;

// Attributes
public:
    ULONG m_defMgtLevel;    // default management level percentage - 100% == 1 billion

// Operations
public:
    virtual HRESULT OnFinish( void );
    STDMETHOD( AddWizardPages ) ( IN RS_PCREATE_HANDLE Handle, IN IUnknown* pPropSheetCallback, IN ISakSnapAsk* pSakSnapAsk );



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\volume\wzunmang.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WzUnmang.h

Abstract:

    Wizard for Unmanaging media - Copy Set Wizard.

Author:

    Rohde Wakefield [rohde]   26-09-1997

Revision History:

--*/

#ifndef _WZUNMANG_H
#define _WZUNMANG_H

// Pre-declare
class CUnmanageWizard;

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardSelect dialog

class CUnmanageWizardSelect : public CSakWizardPage
{
// Construction
public:
    CUnmanageWizardSelect( );
    ~CUnmanageWizardSelect();

// Dialog Data
    //{{AFX_DATA(CUnmanageWizardSelect)
    enum { IDD = IDD_WIZ_UNMANAGE_SELECT };
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CUnmanageWizardSelect)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    HRESULT           m_hrAvailable;

protected:
    // Generated message map functions
    //{{AFX_MSG(CUnmanageWizardSelect)
    virtual BOOL OnInitDialog();
	afx_msg void OnButtonRefresh();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    void SetButtons();

public:

};

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardIntro dialog

class CUnmanageWizardIntro : public CSakWizardPage
{
// Construction
public:
    CUnmanageWizardIntro( );
    ~CUnmanageWizardIntro();

// Dialog Data
    //{{AFX_DATA(CUnmanageWizardIntro)
    enum { IDD = IDD_WIZ_UNMANAGE_INTRO };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CUnmanageWizardIntro)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CUnmanageWizardIntro)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardFinish dialog

class CUnmanageWizardFinish : public CSakWizardPage
{
// Construction
public:
    CUnmanageWizardFinish( );
    ~CUnmanageWizardFinish();

// Dialog Data
    //{{AFX_DATA(CUnmanageWizardFinish)
    enum { IDD = IDD_WIZ_UNMANAGE_FINISH };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CUnmanageWizardFinish)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CUnmanageWizardFinish)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};


class CUnmanageWizard : public CSakWizardSheet
{
// Construction
public:
    CUnmanageWizard();
    virtual ~CUnmanageWizard();

public:
    // Property Pages
    CUnmanageWizardIntro         m_IntroPage;
    CUnmanageWizardSelect        m_SelectPage;
    CUnmanageWizardFinish        m_FinishPage;

    CString                      m_DisplayName;

// Attributes
public:
    CComPtr<IHsmManagedResource> m_pHsmResource;
    CComPtr<IFsaResource>        m_pFsaResource;

// Operations
public:
    virtual HRESULT OnFinish( void );
    STDMETHOD( AddWizardPages ) ( IN RS_PCREATE_HANDLE Handle, IN IUnknown* pPropSheetCallback, IN ISakSnapAsk* pSakSnapAsk );
    void DoThreadSetup( );



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\inc\rshelpid.h ===
/*++

Module Name:

    rshelpid.h

Abstract:

    Help ids for all of HSM UI

Author:

    Ran Kalach [rankala]   11-Sep-2000

Revision History:

--*/

#ifndef _RSHELPID_H
#define _RSHELPID_H

/////////////////////////////////////////////////////////////////////////////
//
//  Help IDs - these should be removed before final ship and use an rsadmin.hm
//
/////////////////////////////////////////////////////////////////////////////
#define idh_status 9047
#define idh_total_managed_volumes 9069
#define idh_total_cartridges_used 9071
#define idh_total_data_remote_storage 9073
#define idh_version 9088
#define idh_change_schedule_button 9003
#define idh_runaway_recall_limit 1106
#define idh_concurrent_drives_limit 1107
#define idh_volume_name 9087
#define idh_volume_percent_local_data 1174
#define idh_volume_capacity_local_data 1169
#define idh_volume_percent_remote_data_cached 1175
#define idh_volume_capacity_remote_data_cached 1167
#define idh_volume_percent_free_space 1173
#define idh_volume_capacity_free_space 1166
#define idh_volume_disk_capacity 1165
#define idh_volume_data_remote_storage 1171
#define idh_actual_free_space_capacity 1177
#define idh_actual_free_space_percent 1117
#define idh_desired_free_space_percent 1176
#define idh_desired_free_space_capacity 1118
#define idh_min_file_size_criteria 1119
#define idh_file_access_date_criteria 9057
#define idh_new_rule_button 1128
#define idh_rule_delete_button 1132
#define idh_rule_edit_button 1129
#define idh_rule_up_button 1130
#define idh_rule_down_button 9015
#define idh_media_master_name 9017
#define idh_media_master_status 9018
#define idh_media_master_capacity 9019
#define idh_media_master_free_space 9045
#define idh_media_master_last_modified 9028
#define idh_media_copy1_name 9030
#define idh_media_copy2_name 9036
#define idh_media_copy3_name 9000
#define idh_media_number_of_copy_sets 9025
#define idh_media_copy1_status 9033
#define idh_media_copy2_status 9039
#define idh_media_copy3_status 9029
#define idh_media_copy1_delete_button 9035
#define idh_media_copy2_delete_button 9041
#define idh_media_copy3_delete_button 9026
#define idh_media_copy1_last_modified 9034
#define idh_media_copy2_last_modified 9040
#define idh_media_copy3_last_modified 9023
#define idh_instance 9093
#define idh_current_schedule 9002
#define idh_runaway_recall_exemption 9090
#define idh_media_synch_copies_now_button 9137
#define idh_media_recreate_master_button 9021
#define idh_rule_list 1180
#define idh_rule_edit_name 1143
#define idh_rule_edit_path 1136
#define idh_rule_edit_file_type 1137
#define idh_rule_edit_exclude 1139
#define idh_rule_edit_include 1138
#define idh_rule_edit_apply_subfolders 1140

#endif // _RSHELPID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\inc\rsutil.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsUtil.cpp

Abstract:

    Utility functions for GUI

    NOTENOTENOTENOTE:

    Do not use any WSB functions in this file, as it is included in
    recall notify which must run without WSB. It must also be able to
    build as UNICODE or non-UNICODE

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "shlwapi.h"

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define HINST_THISDLL   AfxGetInstanceHandle()

// Local function prototypes

HRESULT ShortSizeFormat64(__int64 dw64, LPTSTR szBuf);
LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen);
HRESULT RsGuiFormatLongLong (
        IN LONGLONG number, 
        IN BOOL bIncludeUnits,
        OUT CString& sFormattedNumber)

/*++

Routine Description:

    Formats a LONGLONG number into a locale-sensitive string with no decimal
    fraction.  Option is given for adding units at the end.

Arguments:

    number              I: Number to format
    bIncludeUnits       I: TRUE - add "bytes" at the end
    sFormattedNumber    O: Formatted number

Return Value:

    S_OK - Success.
    E_* - Failure occured 

--*/
{

    HRESULT hr = S_OK;
    TCHAR sBuf [256];
    TCHAR lpLCData [256];
    TCHAR lpLCDataDecimal[256];
    TCHAR lpLCDataThousand[256];
    LPTSTR pBuffer;
    int bufSize;
    NUMBERFMT format;

    try {
        // Set up the parameters for the conversion function.

        // Don't show fractions
        format.NumDigits = 0;
    
        // Get current setting for the rest of the parameters
        WsbAffirmStatus (GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_ILZERO, lpLCData, 256 ));
        format.LeadingZero = _ttoi(lpLCData);
    
        WsbAffirmStatus (GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_SGROUPING, lpLCData, 256 ));
        lpLCData[1] = 0;
        format.Grouping = _ttoi(lpLCData);

        WsbAffirmStatus (GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, lpLCDataDecimal, 256 ));
        format.lpDecimalSep = lpLCDataDecimal; 

        WsbAffirmStatus (GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, lpLCDataThousand, 256 ));
        format.lpThousandSep = lpLCDataThousand; 
    
        WsbAffirmStatus (GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_INEGNUMBER, lpLCData, 256 ));
        format.NegativeOrder = _ttoi(lpLCData);

        // Convert the number to a non-localized string
        _i64tot( number, sBuf, 10 );

        // Get the size of the localized converted number
        bufSize = GetNumberFormat (LOCALE_SYSTEM_DEFAULT, 0, sBuf, &format, NULL, 0);
        WsbAffirmStatus (bufSize);

        // Allocate the buffer in the CString
        pBuffer = sFormattedNumber.GetBufferSetLength( bufSize );

        // Convert non-localized string to a localized string
        WsbAffirmStatus (GetNumberFormat (LOCALE_SYSTEM_DEFAULT, 0, sBuf, &format, pBuffer, bufSize));

        // Release the CString buffer
        sFormattedNumber.ReleaseBuffer (-1);

        // If caller requested, append units
        if (bIncludeUnits) {
            sFormattedNumber = sFormattedNumber + L" bytes";
        }
    } WsbCatch (hr);
    return hr;
}


HRESULT RsGuiFormatLongLong4Char (
        IN LONGLONG number,                 // in bytes
        OUT CString& sFormattedNumber)
/*++

Routine Description:

    Formats a LONGLONG number into a locale-sensitive string that can be
    displayed in 4 chars.  Option is given for adding units at the end.

Arguments:

    number              I: Number to format
    sFormattedNumber    O: Formatted number

Return Value:

    S_OK - Success.
    E_* - Failure occured 

--*/
{

    // We call a function cloned from MS code

    LPTSTR p;
    p = sFormattedNumber.GetBuffer( 30 );
    HRESULT hr = ShortSizeFormat64(number, p);
    sFormattedNumber.ReleaseBuffer();
    return hr;

}   

const int pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB,
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

/* converts numbers into sort formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */

// NOTE: This code is cloned from MS source /shell/shelldll/util.c - AHB

HRESULT ShortSizeFormat64(__int64 dw64, LPTSTR szBuf)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    int i;
    UINT wInt, wLen, wDec;
    TCHAR szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000) {
        wsprintf(szTemp, TEXT("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
    }

    for (i = 1; i<ARRAYSIZE(pwOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    AddCommas(wInt, szTemp, 10);
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, TEXT("%02d"));

        szFormat[2] = (TCHAR)( TEXT('0') + 3 - wLen );
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, ARRAYSIZE(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
    }

AddOrder:
    LoadString(HINST_THISDLL, pwOrders[i], szOrder, ARRAYSIZE(szOrder));
    wsprintf(szBuf, szOrder, (LPTSTR)szTemp);

    return S_OK;
}

void RsGuiMakeVolumeName (CString szName, CString szLabel, CString& szDisplayName)
/*++

Routine Description:

    Formats a string showing the drive letter and volume label for a volume.

Arguments:

    szName          I: Name of volume i.e. "E:"
    szLabel         I: Volume label i.i "Art's Volume"
    szDisplayName   O: "Art's Volume (E:)"

Return Value: None
_* - Failure occured 

--*/
{
    szDisplayName.Format( TEXT ("%ls (%.1ls:)"), szLabel, szName );
}


// NOTE: This code is cloned from MS source /shell/shelldll/util.c - AHB

// takes a DWORD add commas etc to it and puts the result in the buffer
LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen)
{
    TCHAR  szTemp[20];  // more than enough for a DWORD
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = _tcstol(szSep, NULL, 10);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    wsprintf(szTemp, TEXT("%lu"), dw);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, nResLen) == 0)
        lstrcpy(pszResult, szTemp);

    return pszResult;
}


CString RsGuiMakeShortString(
    IN CDC* pDC, 
    IN const CString& StrLong,
    IN int Width
    )
/*++

Routine Description:

    Determines if the supplied string fits in it's column.  If not truncates
    it and adds "...".  From MS sample code.

Arguments:

    pDC         - Device context
    str         - Original String
    width       - Width of column

Return Value:

    Shortened string

--*/
{

    CString strShort  = StrLong;
    int     stringLen = strShort.GetLength( );

    //
    // See if we need to shorten the string
    //
    if( ( stringLen > 0 ) &&
        ( pDC->GetTextExtent( strShort, stringLen ).cx > Width ) ) {

        CString threeDots = _T("...");
        int     addLen    = pDC->GetTextExtent( threeDots, threeDots.GetLength( ) ).cx;

        for( int i = stringLen - 1; i > 0; i-- ) {

            if( ( pDC->GetTextExtent( strShort, i ).cx + addLen ) <= Width ) {

                break;

            }
        }

        strShort = strShort.Left( i ) + threeDots;

    }

    return( strShort );
}

/////////////////////////////////////////////////////////////////////////////
// CRsGuiOneLiner

CRsGuiOneLiner::CRsGuiOneLiner()
{
    m_pToolTip = 0;
}

CRsGuiOneLiner::~CRsGuiOneLiner()
{
    EnableToolTip( FALSE );
}


BEGIN_MESSAGE_MAP(CRsGuiOneLiner, CStatic)
	//{{AFX_MSG_MAP(CRsGuiOneLiner)
	//}}AFX_MSG_MAP
    ON_MESSAGE( WM_SETTEXT, OnSetText )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRsGuiOneLiner message handlers

LRESULT
CRsGuiOneLiner::OnSetText(
    WPARAM /*wParam*/,
    LPARAM lParam
    )
{
    LRESULT lResult = 0;
	ASSERT(lParam == 0 || AfxIsValidString((LPCTSTR)lParam));

    m_LongTitle = (LPCTSTR)lParam;
    m_Title = m_LongTitle;

    //
    // See if this is too long to show, and shorten if so
    //
    CRect rect;
    GetClientRect( &rect );

    CDC* pDc = GetDC( );
    if( pDc ) {

        CFont* pFont = GetFont( );
        CFont* pSaveFont = pDc->SelectObject( pFont );
        if( pSaveFont ) {

            m_Title = RsGuiMakeShortString( pDc, m_LongTitle, rect.right );
            pDc->SelectObject( pSaveFont );

        }
        ReleaseDC( pDc );

    }
    if( m_hWnd ) {

        lResult = DefWindowProc( WM_SETTEXT, 0, (LPARAM)(LPCTSTR)m_Title );

    }

    //
    // Enable the tooltip if the titles are not the same
    //
    EnableToolTip( m_Title != m_LongTitle, m_LongTitle );

    return( lResult );
}

void CRsGuiOneLiner::EnableToolTip( BOOL Enable, const TCHAR* pTipText )
{
    if( Enable ) {

        //
        // Make sure the tooltip does not exist before creating new one
        //
        EnableToolTip( FALSE );

        m_pToolTip = new CToolTipCtrl;
        if( m_pToolTip ) {

            m_pToolTip->Create( this );

            //
            // Can't use the CToolTipCtrl methods for adding tool
            // since these tie the control into sending messages
            // to the parent, and don't allow subclassing option
            //
            // BTW, the subclassing option allows the control to
            // automatically see our messages. Otherwise, we have
            // to go through complicated message interception and
            // relaying these to the tooltip (which doesn't work
            // anyway)
            //
            TOOLINFO ti;
            ZeroMemory( &ti, sizeof( ti ) );
            ti.cbSize   = sizeof( ti );
            ti.uFlags   = TTF_IDISHWND|TTF_CENTERTIP|TTF_SUBCLASS;
            ti.hwnd     = GetSafeHwnd( );
            ti.uId      = (WPARAM)GetSafeHwnd( );
            ti.lpszText = (LPTSTR)(LPCTSTR)pTipText;
            m_pToolTip->SendMessage( TTM_ADDTOOL, 0, (LPARAM)&ti );

            //
            // Set delays so that the tooltip comes up right away
            // and doesn't go away until 15 seconds.
            //
            m_pToolTip->SendMessage( TTM_SETDELAYTIME, TTDT_AUTOPOP, 15000 );
            m_pToolTip->SendMessage( TTM_SETDELAYTIME, TTDT_INITIAL, 0 );

            //
            // And activate and top the tooltip
            //
            m_pToolTip->Activate( TRUE );
			m_pToolTip->SetWindowPos( &wndTop, 0, 0, 0, 0,
				SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOMOVE|SWP_NOOWNERZORDER );

        }

    } else if( !Enable && m_pToolTip ) {

        m_pToolTip->Activate( FALSE );

        delete m_pToolTip;
        m_pToolTip = 0;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\inc\rstrace.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsTrace.h

Abstract:

    Simple tracing functionality for components that cannot use standard
    WsbTrace in RsCommon.dll

Author:

    Rohde Wakefield   [rohde]   20-Feb-1998

Revision History:

--*/

#pragma once

#ifndef _RSTRACE_H
#define _RSTRACE_H

#define RsBoolAsString(b) ((b) ? "TRUE" : "FALSE" )

#ifdef TRACE
#undef TRACE 
#endif
#define TRACE if( CRsFuncTrace::m_TraceEnabled ) CRsFuncTrace::Trace

#define TRACEFN( __FuncName )      CRsFuncTrace __FnTrace( __FuncName );
#define TRACEFNHR( __FuncName )    HRESULT hrRet   = S_OK;  CRsFuncTraceHr    __FnTrace( __FuncName, &hrRet );
#define TRACEFNDW( __FuncName )    DWORD   dwRet   = 0;     CRsFuncTraceDw    __FnTrace( __FuncName, &dwRet );
#define TRACEFNLONG( __FuncName )  LONG    lRet    = 0;     CRsFuncTraceLong  __FnTrace( __FuncName, &lRet );
#define TRACEFNSHORT( __FuncName ) SHORT   sRet    = 0;     CRsFuncTraceShort __FnTrace( __FuncName, &sRet );
#define TRACEFNBOOL( __FuncName )  BOOL    boolRet = FALSE; CRsFuncTraceBool  __FnTrace( __FuncName, &boolRet );

/////////////////////////////////////////////////////////////////////////////
// CRsRegKey - A minimal subset of ATL's CRegKey class

class CRsRegKey
{
public:
    CRsRegKey()  {m_hKey = NULL;}
    ~CRsRegKey() {Close();}

// Attributes
public:
    operator HKEY() const {return m_hKey;}

    HKEY m_hKey;

// Operations
public:
    LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
    {
        DWORD dwType = NULL;
        DWORD dwCount = sizeof(DWORD);
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
            (LPBYTE)&dwValue, &dwCount);
#if 0  // we check for sometimes non-existent values
        _ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
        _ASSERTE((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
#endif
        
        return lRes;
    }

    LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
    {
        _ASSERTE(pdwCount != NULL);
        DWORD dwType = NULL;
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
            (LPBYTE)szValue, pdwCount);
#if 0  // we check for sometimes non-existent values
        _ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
                 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
#endif
        return lRes;
    }

    LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName)
    {
	    _ASSERTE(m_hKey != NULL);
	    return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		    (BYTE * const)&dwValue, sizeof(DWORD));
    }

    LONG DeleteValue(LPCTSTR lpszValue)
    {
	    ATLASSERT(m_hKey != NULL);
	    return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
    }

    LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
        REGSAM samDesired = KEY_ALL_ACCESS)
    {
        _ASSERTE(hKeyParent != NULL);
        HKEY hKey = NULL;
        LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
        if (lRes == ERROR_SUCCESS)
        {
            lRes = Close();
            _ASSERTE(lRes == ERROR_SUCCESS);
            m_hKey = hKey;
        }
        return lRes;
    }

    LONG Close()
    {
        LONG lRes = ERROR_SUCCESS;
        if (m_hKey != NULL)
        {
            lRes = RegCloseKey(m_hKey);
            m_hKey = NULL;
        }
        return lRes;
    }
};

//
// Base class for function tracing. Core tracing behavior.
//
class CRsFuncTraceBase
{
public:
    CRsFuncTraceBase( const char * FuncName ) : m_FuncName( FuncName )
    {
        m_IndentLevel++;
    }

    ~CRsFuncTraceBase( void )
    {
        m_IndentLevel--;
    }

    static void TraceInner( const _TCHAR * Fmt, ... )
    {
        va_list list;
        va_start( list, Fmt );

        TraceV( 1, Fmt, list );

        va_end( list );
    }

    static void TraceOuter( const _TCHAR * Fmt, ... )
    {
        va_list list;
        va_start( list, Fmt );

        TraceV( -1, Fmt, list );

        va_end( list );
    }

    static void Trace( const _TCHAR * Fmt, ... )
    {
        va_list list;
        va_start( list, Fmt );

        TraceV( 0, Fmt, list );

        va_end( list );
    }

    static void TraceV( LONG IndentMod, const _TCHAR * Fmt, va_list List )
    {
        _TCHAR buf[1024];

        LONG charIndent =  max( 0, ( m_IndentLevel  + IndentMod ) * m_IndentChars );

        for( LONG i = 0; i < charIndent; i++ ) {
 
            *(buf + i) = _T(' ');

        }

        _vstprintf( buf + charIndent, Fmt, List );

        OutputDebugString( buf );
        OutputDebugString( _T("\n") );
    }

    static BOOL CheckRegEnabled( _TCHAR * Module )
    {
        BOOL retval = FALSE;
        CRsRegKey keySoftware, keyCompany, keyModule, keyModule2;

        if( ERROR_SUCCESS == keySoftware.Open( HKEY_LOCAL_MACHINE, _T("Software")  )   &&
            ERROR_SUCCESS == keyCompany.Open(  keySoftware,        _T("Microsoft") )   &&
            ERROR_SUCCESS == keyModule.Open(   keyCompany,         _T("RemoteStorage") ) &&
            ERROR_SUCCESS == keyModule2.Open(  keyModule,          Module ) ) {

            DWORD dw;
            if( ERROR_SUCCESS == keyModule2.QueryValue( dw, _T("Trace") ) ) {

                if( dw != 0 ) {

                    retval = TRUE;

                }
            } else {
                
                TCHAR buf[128];
                dw = 128;
                if( ERROR_SUCCESS == keyModule2.QueryValue( buf, _T("Trace"), &dw ) ) {

                    if( ( dw > 0 ) && ( _T('0') != buf[0] ) ) {

                        retval = TRUE;

                    }
                }
            }
        }
        return( retval );
    }

protected:
    const char * m_FuncName;

private:
    static LONG m_IndentLevel;
    static const LONG m_IndentChars;

public:
    static BOOL m_TraceEnabled;
};

//
// Trace Functions w/o any result data printed
//
class CRsFuncTrace : public CRsFuncTraceBase
{
public:
    CRsFuncTrace( const char * FuncName ) :
        CRsFuncTraceBase( FuncName )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTrace( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName );
    }

private:
    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};

//
// Trace Functions with HRESULT
//
class CRsFuncTraceHr : public CRsFuncTraceBase
{
public:
    CRsFuncTraceHr( const char * FuncName, const HRESULT * pHr ) :
        CRsFuncTraceBase( FuncName ), m_pHr( pHr )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTraceHr( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName, *m_pHr );
    }

private:
    const HRESULT * m_pHr;

    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};

//
// Trace Functions with DWORD return
//
class CRsFuncTraceDw : public CRsFuncTraceBase
{
public:
    CRsFuncTraceDw( const char * FuncName, const DWORD * pDw ) :
        CRsFuncTraceBase( FuncName ), m_pDw( pDw )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTraceDw( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName, *m_pDw, *m_pDw );
    }

private:
    const DWORD * m_pDw;

    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};

//
// Trace Functions with LONG return
//
class CRsFuncTraceLong : public CRsFuncTraceBase
{
public:
    CRsFuncTraceLong( const char * FuncName, const LONG * pLong ) :
        CRsFuncTraceBase( FuncName ), m_pLong( pLong )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTraceLong( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName, *m_pLong );
    }

private:
    const LONG * m_pLong;

    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};

//
// Trace Functions with SHORT return
//
class CRsFuncTraceShort : public CRsFuncTraceBase
{
public:
    CRsFuncTraceShort( const char * FuncName, const SHORT * pShort ) :
        CRsFuncTraceBase( FuncName ), m_pShort( pShort )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTraceShort( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName, *m_pShort );
    }

private:
    const SHORT * m_pShort;

    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};

//
// Trace Functions with BOOL return
//
class CRsFuncTraceBool : public CRsFuncTraceBase
{
public:
    CRsFuncTraceBool( const char * FuncName, const BOOL * pBool ) :
        CRsFuncTraceBase( FuncName ), m_pBool( pBool )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTraceBool( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName, RsBoolAsString( *m_pBool ) );
    }

private:
    const BOOL * m_pBool;

    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};


#define RSTRACE_INIT(Module)                                                             \
    LONG CRsFuncTrace::m_IndentLevel = 0;                                                \
    const LONG CRsFuncTrace::m_IndentChars = 2;                                          \
    BOOL CRsFuncTrace::m_TraceEnabled = CRsFuncTrace::CheckRegEnabled( _T(Module) );     \
    const _TCHAR * CRsFuncTrace::m_TraceInFmt       = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTrace::m_TraceOutFmt      = _T("Exit  <%hs>");       \
    const _TCHAR * CRsFuncTraceHr::m_TraceInFmt     = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTraceHr::m_TraceOutFmt    = _T("Exit  <%hs> <0x%p>");       \
    const _TCHAR * CRsFuncTraceDw::m_TraceInFmt     = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTraceDw::m_TraceOutFmt    = _T("Exit  <%hs> <0x%p><%lu>");  \
    const _TCHAR * CRsFuncTraceLong::m_TraceInFmt   = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTraceLong::m_TraceOutFmt  = _T("Exit  <%hs> <%ld>");  \
    const _TCHAR * CRsFuncTraceShort::m_TraceInFmt  = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTraceShort::m_TraceOutFmt = _T("Exit  <%hs> <%hd>");  \
    const _TCHAR * CRsFuncTraceBool::m_TraceInFmt   = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTraceBool::m_TraceOutFmt  = _T("Exit  <%hs> <%hs>");            \

#endif // _RSTRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\note.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Note.h

Abstract:

    This class represents the notify dialog that is shown to the user.

Author:

    Rohde Wakefield   [rohde]   27-May-1997

Revision History:

--*/

#ifndef _NOTE_H_
#define _NOTE_H_

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CRecallNote dialog

class CRecallNote : public CDialog
{
// Construction
public:
    CRecallNote( IFsaRecallNotifyServer * pRecall, CWnd * pParent = NULL );

// Dialog Data
    //{{AFX_DATA(CRecallNote)
    enum { IDD = IDD_RECALL_NOTE };
    CStatic m_Progress;
    CEdit   m_FileName;
    CAnimateCtrl    m_Animation;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRecallNote)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRecallNote();
    CComPtr<IFsaRecallNotifyServer> m_pRecall;
    GUID                            m_RecallId;
    HRESULT                         m_hrCreate;
    BOOL                            m_bCancelled;

private:
    CString                   m_Name;
    LONGLONG                  m_Size;

    HICON                     m_hIcon;

protected:

    // Generated message map functions
    //{{AFX_MSG(CRecallNote)
    virtual BOOL OnInitDialog();
    afx_msg void OnClose();
    afx_msg void OnTimer(UINT nIDEvent);
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\inc\wizsht.h ===
// WizSht.h: interface for the CRsWizardSheet class.
//
//////////////////////////////////////////////////////////////////////
#include "PropPage.h"

#if !defined(AFX_WIZSHT_H__A4135C61_8B78_11D1_B9A1_00A0C9190447__INCLUDED_)
#define AFX_WIZSHT_H__A4135C61_8B78_11D1_B9A1_00A0C9190447__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CRsWizardSheet : public CPropertySheet  
{
public:
    CRsWizardSheet( UINT nIDCaption, CWnd *pParentWnd = NULL, UINT iSelectPage = 0 );
    virtual ~CRsWizardSheet();
protected:
    void AddPage( CRsWizardPage* pPage );
private:
    UINT m_IdCaption;
};

#endif // !defined(AFX_WIZSHT_H__A4135C61_8B78_11D1_B9A1_00A0C9190447__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\inc\rsutil.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsUtil.h

Abstract:

    Utility formatting functions.

Author:

    Art Bragg 10/8/97

Revision History:

--*/

#define IDS_BYTES       33000
#define IDS_ORDERKB     33001
#define IDS_ORDERMB     33002
#define IDS_ORDERGB     33003
#define IDS_ORDERTB     33004
#define IDS_ORDERPB     33005
#define IDS_ORDEREB     33006

#ifndef RC_INVOKED

HRESULT RsGuiFormatLongLong(
    IN LONGLONG number, 
    IN BOOL bIncludeUnits,
    OUT CString& sFormattedNumber
    );

HRESULT RsGuiFormatLongLong4Char(
    IN LONGLONG number,                 // in bytes
    OUT CString& sFormattedNumber
    );

void RsGuiMakeVolumeName(
    CString szName,
    CString szLabel,
    CString& szDisplayName
    );

CString RsGuiMakeShortString(
    IN CDC* pDC, 
    IN const CString& StrLong,
    IN int Width
    );


/////////////////////////////////////////////////////////////////////////////
// CRsGuiOneLiner window

class CRsGuiOneLiner : public CStatic
{
// Construction
public:
	CRsGuiOneLiner();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRsGuiOneLiner)
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CRsGuiOneLiner();
    CToolTipCtrl* m_pToolTip;
    void EnableToolTip( BOOL enable, const TCHAR* pTipText = 0 );


	// Generated message map functions
protected:
	//{{AFX_MSG(CRsGuiOneLiner)
	//}}AFX_MSG
    LRESULT OnSetText( WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

    CString m_LongTitle;
    CString m_Title;
};

/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rsrecall.rc
//
#define IDS_CANCEL_ERROR                1
#define IDS_CANCEL_ERROR2               2
#define IDR_MAINFRAME                   128
#define IDR_CNotifyClient               133
#define IDR_CNotifyClientDll            134
#define IDR_CNotifyClientApp            135
#define IDR_CNotifyClientAppDll         136
#define IDR_RECALL_ANIM                 137
#define IDD_RECALL_NOTE                 4352
#define IDC_ANIMATION                   4353
#define IDC_FILENAME                    4354

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        139
#define _APS_NEXT_COMMAND_VALUE         32778
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\clientob.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    clientob.cpp

Abstract:

    This component is the client object the recall filter system contacts
    to notify when a recall starts.

Author:

    Rohde Wakefield   [rohde]   27-May-1997

Revision History:

--*/

#include "stdafx.h"
#include "fsantfy.h"

static BOOL VerifyPipeName(IN OLECHAR * szPipeName);


HRESULT
CNotifyClient::IdentifyWithServer(
    IN OLECHAR * szPipeName
    )

/*++

Implements:

  IFsaRecallNotifyClient::IdentifyWithServer

--*/
{
TRACEFNHR( "IdentifyWithServer" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        HANDLE handle = INVALID_HANDLE_VALUE;

        //
        // Parse the object and verify it looks like an HSM server named pipe
        // Note that we cannot assume anything on the string besides it being null-terminated
        //
        if (! VerifyPipeName(szPipeName)) {
            // Wrong name - possible attack - abort
            RecThrow(E_INVALIDARG);
        }

        //
        // Open the pipe and send a response
        //
        handle = CreateFileW( szPipeName, // Pipe name.
                GENERIC_WRITE,              // Generic access, read/write.
                FILE_SHARE_WRITE,
                NULL,                       // No security.
                OPEN_EXISTING,              // Fail if not existing.
                SECURITY_SQOS_PRESENT   | 
                SECURITY_IDENTIFICATION,    // No overlap, No pipe impersonation
                NULL );                     // No template.
        
        RecAffirmHandle( handle );

        //
        // Verify that what we just opened is a pipe
        //
        DWORD dwType = GetFileType(handle);
        if (dwType != FILE_TYPE_PIPE) {
            // Object is not a pipe - close and abort
            CloseHandle(handle);
            handle = INVALID_HANDLE_VALUE;
            RecThrow(E_INVALIDARG);
        }

        WSB_PIPE_MSG        pmsg;
        DWORD               len, bytesWritten;

        pmsg.msgType = WSB_PMSG_IDENTIFY;
        len = MAX_COMPUTERNAME_LENGTH + 1;
    
        RecAffirmStatus(GetComputerNameW( pmsg.msg.idrp.clientName, &len ));
        BOOL code = WriteFile( handle, &pmsg, sizeof(WSB_PIPE_MSG),
               &bytesWritten, 0 );
        
        CloseHandle(handle);

    } RecCatch( hrRet );

    return(hrRet);
}


HRESULT
CNotifyClient::OnRecallStarted(
    IN IFsaRecallNotifyServer * pRecall
    )

/*++

Implements:

  IFsaRecallNotifyClient::OnRecallStarted

--*/
{
TRACEFNHR( "OnRecallStarted" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    hrRet = RecApp->AddRecall( pRecall );

    return( hrRet );
}


HRESULT
CNotifyClient::OnRecallFinished(
    IN IFsaRecallNotifyServer * pRecall,
    IN HRESULT                  hrError
    )

/*++

Implements:

  IFsaRecallNotifyClient::OnRecallFinished

--*/
{
TRACEFNHR( "CNotifyClient::OnRecallFinished" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    hrRet = RecApp->RemoveRecall( pRecall );

    return( hrRet );
}


HRESULT
CNotifyClient::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
TRACEFNHR( "CNotifyClient::FinalConstruct" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
        
    try {

        RecAffirmHr( CComObjectRoot::FinalConstruct( ) );

    } RecCatch( hrRet );

    return( hrRet );
}
    

void
CNotifyClient::FinalRelease(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
TRACEFN( "CNotifyClient::FinalRelease" );
        
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    CComObjectRoot::FinalRelease( );
}
    
//
// Verifies that pipe name matches the expected RSS named pipe
//   \\<machine-name>\pipe\HSM_PIPE
//
// Returns TRUE for a valid pipe name and FALSE otherwise
//
static BOOL VerifyPipeName(IN OLECHAR * szPipeName)
{
    if (wcslen(szPipeName) < 3)
        return FALSE;
    if ((szPipeName[0] != L'\\') || (szPipeName[1] != L'\\'))
        return FALSE;

    OLECHAR *pTemp1 = NULL;
    OLECHAR *pTemp2 = NULL;

    pTemp1 = wcschr(&(szPipeName[2]), L'/');
    if (pTemp1 != NULL)
        return FALSE;

    pTemp1 = wcschr(&(szPipeName[2]), L'\\');
    if (pTemp1 == NULL)
        return FALSE;
    pTemp1++;

    pTemp2 = wcschr(pTemp1, L'\\');
    if (pTemp2 == NULL)
        return FALSE;
    *pTemp2 = L'\0';

    if (0 != _wcsicmp(pTemp1, L"pipe")) {
        *pTemp2 = L'\\';
        return FALSE;
    }
    *pTemp2 = L'\\';

    pTemp2++;
    if (0 != _wcsicmp(pTemp2, WSB_PIPE_NAME))
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\note.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    Note.cpp

Abstract:

    Main module file - defines the overall COM server.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/



#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CRecallNote dialog


CRecallNote::CRecallNote( IFsaRecallNotifyServer * pRecall, CWnd * pParent )
    : CDialog( CRecallNote::IDD, pParent )
{
    //{{AFX_DATA_INIT(CRecallNote)
    //}}AFX_DATA_INIT

TRACEFNHR( "CRecallNote::CRecallNote" );

    RecApp->LockApp( );

    try {

        //
        // Store the interface pointer back to the recall object
        //
        m_pRecall = pRecall;
        RecAffirmHr( pRecall->GetIdentifier( &m_RecallId ) );

        //
        // Get the file size and its name
        //

        RecAffirmHr( pRecall->GetSize( &m_Size ) );

        RecComString pathName, drive;
        RecAffirmHr( pRecall->GetPath( &pathName, 0 ) );

#if 0
        CComPtr<IFsaResource> pResource;
        RecAffirmHr( pRecall->GetResource( &pResource ) );
        RecAffirmHr( pResource->GetPath( &drive, 0 ) );

        m_Name.Format( TEXT( "%.1ls:%ls" ), drive, pathName );
#else
        m_Name = pathName;
#endif

        //
        // Create the dialog
        //

        Create( CRecallNote::IDD, pParent );

    } RecCatch( hrRet );

    m_hrCreate = hrRet;
    m_bCancelled = FALSE;
}

CRecallNote::~CRecallNote( )
{
TRACEFN( "CRecallNote::~CRecallNote" );
    //
    // Remove the lock count on the app
    //

    RecApp->UnlockApp( );

    CDialog::~CDialog( );
}

void CRecallNote::DoDataExchange(CDataExchange* pDX)
{
TRACEFN( "CRecallNote::DoDataExchange" );

    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRecallNote)
    DDX_Control(pDX, IDC_FILENAME, m_FileName);
    DDX_Control(pDX, IDC_ANIMATION, m_Animation);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRecallNote, CDialog)
    //{{AFX_MSG_MAP(CRecallNote)
    ON_WM_CLOSE()
    ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRecallNote message handlers

BOOL CRecallNote::OnInitDialog() 
{
TRACEFNBOOL( "CRecallNote::OnInitDialog" );
    CDialog::OnInitDialog();

    boolRet = TRUE;
    CString fileName;

    //  Set a timer to delay displaying myself in case the
    //  recall is quick and the dialog is unnecessary
    SetTimer( 2, RSRECALL_TIME_DELAY_DISPLAY * 1000, 0 );

    //
    // Initialize all the text
    //

    int pos = m_Name.ReverseFind( TEXT( '\\' ) );
    if( pos >= 0 ) {

        fileName = m_Name.Mid( pos + 1 );

    } else {

        fileName = m_Name;

    }
    m_FileName.SetWindowText( fileName );

    //
    // Set up the icon for the dialog (big and small)
    //

    m_hIcon = RecApp->LoadIcon( IDR_MAINFRAME );
    SetIcon( m_hIcon, TRUE );
    SetIcon( m_hIcon, FALSE );

    //
    // Start up the animation
    //

    m_Animation.Open( IDR_RECALL_ANIM );
    m_Animation.Play( 0, -1, -1 );

    return( boolRet );
}

void CRecallNote::OnClose() 
{
TRACEFNHR( "CRecallNote::OnClose" );

    hrRet = RecApp->RemoveRecall( m_pRecall );

    //
    // If we failed to find and remove the recall from our list,
    // destroy the window anyway.
    //

    if( hrRet != S_OK ) {

        DestroyWindow( );

    }
}

void CRecallNote::PostNcDestroy() 
{
TRACEFNHR( "CRecallNote::PostNcDestroy" );
    //
    // Delete the object (CDialogs don't automatically do this)
    //

    CDialog::PostNcDestroy();

    delete( this );
}

void CRecallNote::OnTimer(UINT nIDEvent) 
{
TRACEFNHR( "CRecallNote::OnTimer" );

    //  Kill the timer so we don't get called again
    KillTimer( nIDEvent );

    //  Display the window
    EnableWindow( );
    ShowWindow( SW_SHOW );
    SetForegroundWindow( );

    CDialog::OnTimer( nIDEvent );
}

void CRecallNote::OnCancel() 
{
TRACEFNHR( "CRecallNote::OnCancel" );

    // Use a local pointer because m_pRecall may not be valid after the call to RemoveRecall
    CComPtr<IFsaRecallNotifyServer> pRecall = m_pRecall;

    // Remove recall from queue.
    // This ensure that the popup is closed and the recall is removed even if there are 
    // connection problems with FSA
    RecApp->RemoveRecall( pRecall );

    // The object might be already destroyed here but it shouldn't matter 
    // because we use only local data
    pRecall->Cancel( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\clientob.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    clientob.h

Abstract:

    This component is the client object the recall filter system contacts
    to notify when a recall starts.

Author:

    Rohde Wakefield   [rohde]   27-May-1997

Revision History:

--*/

#include "fsaint.h"
#include "fsalib.h"

#ifndef _CLIENTOBJ_
#define _CLIENTOBJ_

/*++

Class Name:
    
    CWsbShort

Class Description:

    An object representations of the SHORT standard type. It
    is both persistable and collectable.

--*/

class CNotifyClient : 
    public IFsaRecallNotifyClient,
    public CComCoClass<CNotifyClient,&CLSID_CFsaRecallNotifyClient >,
    public CComObjectRoot
{
public:
    CNotifyClient() {}
BEGIN_COM_MAP( CNotifyClient )
    COM_INTERFACE_ENTRY( IFsaRecallNotifyClient )
END_COM_MAP()

#ifdef _USRDLL
DECLARE_REGISTRY_RESOURCEID( IDR_CNotifyClientDll )
#else
DECLARE_REGISTRY_RESOURCEID( IDR_CNotifyClient )
#endif

// CComObjectRoot
public:
    HRESULT FinalConstruct(void);
    void FinalRelease(void);


// IFsaRecallNotifyClient
public:
    STDMETHOD(IdentifyWithServer)( IN OLECHAR * szServerName );
    STDMETHOD(OnRecallStarted)   ( IN IFsaRecallNotifyServer * pRecall );
    STDMETHOD(OnRecallFinished)  ( IN IFsaRecallNotifyServer * pRecall, HRESULT hr );

protected:

};

#endif // _CLIENTOBJ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\rsrecall.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RsRecall.cpp

Abstract:

    Main module file - defines the overall COM server.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/


#include "stdafx.h"

#include "aclapi.h"


BEGIN_OBJECT_MAP( ObjectMap )
    OBJECT_ENTRY( CLSID_CFsaRecallNotifyClient, CNotifyClient )
END_OBJECT_MAP()

const CString regString   = TEXT( "reg" );
const CString unregString = TEXT( "unreg" );
HRESULT RegisterServer(void);
HRESULT UnregisterServer(void);


#ifdef _USRDLL

/////////////////////////////////////////////////////////////////////////////
// Setup to use if we are a DLL /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define RecRegId IDR_CNotifyClientAppDll

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
TRACEFNHR( "DllCanUnloadNow" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    hrRet = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    return( hrRet );
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
TRACEFNHR( "DllGetClassObject" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    hrRet = _Module.GetClassObject(rclsid, riid, ppv);
    return( hrRet );
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
TRACEFNHR( "DllRegisterServer" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // registers object, typelib and all interfaces in typelib
    hrRet = RegisterServer( );
    return( hrRet );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
TRACEFNHR( "DllUnregisterServer" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    hrRet = UnregisterServer( );
    return( hrRet );
}



#else

/////////////////////////////////////////////////////////////////////////////
// Setup to use if we are a standalone app //////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define RecRegId IDR_CNotifyClientApp

class CRecallParse : public CCommandLineInfo {

    virtual void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );

public:
    BOOL m_RegAction;
    CRecallParse( ) { m_RegAction = FALSE; };

};

void CRecallParse::ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast )
{
TRACEFN( "CRecallParse::ParseParam" );

    CString cmdLine = lpszParam;
    if( bFlag ) {

        if( cmdLine.Left( unregString.GetLength( ) ) == unregString ) {

            UnregisterServer( );
            m_RegAction = TRUE;


        } else if( cmdLine.Left( regString.GetLength( ) ) == regString ) {

            RegisterServer( );
            m_RegAction = TRUE;

        }
    }
}

#endif

/////////////////////////////////////////////////////////////////////////////
// RegisterServer - Adds entries to the system registry

HRESULT RegisterServer(void)
{
TRACEFNHR( "RegisterServer" );

    try {

        //
        // Add the object entries
        //

        RecAffirmHr( _Module.RegisterServer( FALSE ) );

        //
        // Add server entries
        //

        RecAffirmHr( _Module.UpdateRegistryFromResource( RecRegId, TRUE ) );

        //
        // Set up access to be allowed by everyone (NULL DACL)
        // Appears we need some owner and group, so use the current one.
        //
        CSecurityDescriptor secDesc;
        PSECURITY_DESCRIPTOR pSDSelfRelative = 0;

        RecAffirmHr( secDesc.InitializeFromProcessToken( ) );

        DWORD secDescSize = 0;
        MakeSelfRelativeSD( secDesc, pSDSelfRelative, &secDescSize );
        pSDSelfRelative = (PSECURITY_DESCRIPTOR) new char[secDescSize];
        if( MakeSelfRelativeSD( secDesc, pSDSelfRelative, &secDescSize ) ) {

            CString keyName = TEXT( "AppID\\{D68BD5B2-D6AA-11d0-9EDA-00A02488FCDE}" );
            CRegKey regKey;
            regKey.Open( HKEY_CLASSES_ROOT, keyName, KEY_SET_VALUE );
            RegSetValueEx( regKey.m_hKey, TEXT( "LaunchPermission" ), 0, REG_BINARY, (LPBYTE)pSDSelfRelative, secDescSize );

        }

    } RecCatch( hrRet );

    return( hrRet );
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterServer - Removes entries from the system registry

HRESULT UnregisterServer(void)
{
TRACEFNHR( "UnregisterServer" );
    try {

        RecAffirmHr( _Module.UnregisterServer() );

        //
        // Remove server entries
        //

        RecAffirmHr( _Module.UpdateRegistryFromResource( RecRegId, FALSE ) );

    } RecCatch( hrRet );

    return( hrRet );
}

/////////////////////////////////////////////////////////////////////////////
// CRecallApp

BEGIN_MESSAGE_MAP(CRecallApp, CWinApp)
    //{{AFX_MSG_MAP(CRecallApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRecallApp construction

CRecallApp::CRecallApp()
{
TRACEFN( "CRecallApp::CRecallApp" );

    m_IdleCount = 0;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRecallApp object

CRecallApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CRecallApp initialization

BOOL CRecallApp::InitInstance()
{
TRACEFNHR( "CRecallApp::InitInstance" );

LPTSTR cmdLine = GetCommandLine( );
TRACE( cmdLine );

    try {

        _Module.Init( ObjectMap, m_hInstance );

        InitCommonControls();

        m_dwMaxConcurrentNotes = MAX_CONCURRENT_RECALL_NOTES_DEFAULT;

#ifndef _USRDLL
        //
        // Initialize the COM module (no point to continue if it fails)
        //

        hrRet = CoInitialize( 0 );
        if (!SUCCEEDED(hrRet)) {

            return FALSE;

        }

        //
        // Parse the command line
        //

        CRecallParse parse;
        ParseCommandLine( parse );

        if( parse.m_RegAction ) {

            return FALSE;

        }

        //
        // This provides a NULL DACL which will allow access to everyone.
        //

        RecAffirmHr( CoInitializeSecurity( 0, -1, 0, 0, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IDENTIFY, 0, EOAC_NONE, 0 ) );

        //
        // Register the Fsa callback object
        //

        RecAffirmHr( _Module.RegisterClassObjects( CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE ) );

#endif

//      m_Wnd.Create( 0, TEXT( "Remote Storage Recall Notification Wnd" ) );
//      m_pMainWnd = &m_Wnd;

        CRecallWnd *pWnd = new CRecallWnd; // will auto delete
        RecAffirmPointer( pWnd );

        pWnd->Create( 0, TEXT( "Remote Storage Recall Notification Wnd" ) );
        m_pMainWnd = pWnd;

        // Check to see if there is any custom setting in the Registry for max recall popups 
        // (ignore errors - just use default)
        HKEY hRegKey;
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, RSNTFY_REGISTRY_STRING, 0, KEY_QUERY_VALUE, &hRegKey) == ERROR_SUCCESS) {
            DWORD dwType, dwValue;
            DWORD cbData = sizeof(DWORD);
            if (RegQueryValueEx(hRegKey, MAX_CONCURRENT_RECALL_NOTES, 0, &dwType, (BYTE*)&dwValue, &cbData) == ERROR_SUCCESS) {
                if (REG_DWORD == dwType) {
                    // custom setting
                    m_dwMaxConcurrentNotes = dwValue;
                }
            }

            RegCloseKey(hRegKey);
        }

    } RecCatch( hrRet );

    return TRUE;
}

int CRecallApp::ExitInstance()
{
TRACEFN("CRecallApp::ExitInstance");

    _Module.Term();

#ifndef _USRDLL

    CoUninitialize();

#endif

    return CWinApp::ExitInstance();
}

void CRecallApp::LockApp( )
{
TRACEFNLONG( "CRecallApp::LockApp" );

    lRet = _Module.Lock( );
}

void CRecallApp::UnlockApp( )
{
TRACEFNLONG( "CRecallApp::UnlockApp" );

    lRet = _Module.Unlock( );

    // Don't call AfxPostQuitMessage when ref. count drops to zero
    // The timer mechanism is responsible for terminating this application.
    // Also, when the ref count drops to zero, COM terminates the process after some time.
}


HRESULT CRecallApp::AddRecall( IFsaRecallNotifyServer* pRecall )
{
TRACEFNHR( "CRecallApp::AddRecall" );

    CRecallNote * pNote = 0;

    try {

        //
        // Create a new note to show - only if we didn't pass the max number for concurrent notes
        // Note: We return S_OK and not S_FALSE even if the recall popup is not displayed in order
        //       not to break the server (S_FALSE will cause unnecessary retries)
        //
        if (m_Recalls.GetCount() < (int)m_dwMaxConcurrentNotes) {

            pNote = new CRecallNote( pRecall, CWnd::GetDesktopWindow( ) );

            RecAffirmHr( pNote->m_hrCreate );

            m_Recalls.AddTail( pNote );

        } else {
            TRACE( _T("Recall not added - reached max number of recalls"));
        }

    } RecCatchAndDo( hrRet,

        if( 0 != pNote ) delete pNote;

    );

    return( hrRet );
}

//
// Note: 
// No CS is used here because the RsNotify is initialized as a single threaded application
//
HRESULT CRecallApp::RemoveRecall( IFsaRecallNotifyServer* pRecall )
{
TRACEFNHR( "CRecallApp::RemoveRecall" );

    hrRet = S_FALSE;

    if( ( m_Recalls.IsEmpty() ) ) {

        return( hrRet );

    }

    CRecallNote* pNote = 0; 
    POSITION     pos = m_Recalls.GetHeadPosition( );
    POSITION     currentPos = 0;

    //
    // Look through the list and find this one
    //
    GUID recallId;
    pRecall->GetIdentifier( &recallId );
    while( pos != 0 ) {
        currentPos = pos;
        pNote = m_Recalls.GetNext( pos );

        if( IsEqualGUID( recallId, pNote->m_RecallId ) ) {
            if (pNote->m_bCancelled)  {
                //
                // This means that somebody is already removing this recall 
                // The Remove may be called up to 3 times for the same recall in case
                // of a recall cancellation
                //
                hrRet = S_OK;
                pos = 0; // exit loop

            } else {
                pNote->m_bCancelled = TRUE;
                //
                // Remove and delete. Return OK.
                //
                m_Recalls.RemoveAt( currentPos );

                pNote->DestroyWindow( );
                pos = 0; // exit loop
                hrRet = S_OK;
            }
        }
    }

    return( hrRet );
}

//  CRecallApp::Tick - called every second (after an initial delay
//    for startup) to keep track of idle time
void CRecallApp::Tick( )
{
TRACEFN( "CRecallApp::Tick");

    // Check for pending recalls
    if( m_Recalls.GetCount( ) ) {

        //  We have pending recalls, reset the idle count
        TRACE( _T("m_Recalls.GetCount != 0") );
        m_IdleCount = 0;

    } else {

        //  We don't have pending recalls, increment the idle count
        TRACE( _T("m_Recalls.GetCount == 0") );
        m_IdleCount++;

        if( m_IdleCount > RSRECALL_TIME_MAX_IDLE ) {

            TRACE( _T("m_IdleCount > 0") );
            // Nothing's happin', say "Goodbye"
            m_pMainWnd->PostMessage( WM_CLOSE );
            TRACE( _T("after PostMessage(WM_CLOSE)") );
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CRecallWnd

CRecallWnd::CRecallWnd()
{
TRACEFN( "CRecallWnd::CRecallWnd" );
}

CRecallWnd::~CRecallWnd()
{
TRACEFN( "CRecallWnd::~CRecallWnd" );
}


BEGIN_MESSAGE_MAP(CRecallWnd, CWnd)
    //{{AFX_MSG_MAP(CRecallWnd)
    ON_WM_TIMER()
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRecallWnd message handlers

void CRecallWnd::OnTimer(UINT nIDEvent)
{
TRACEFN("CRecallWnd::OnTimer");

    if (1 == nIDEvent) {

        // Initial timer. Kill it and start one for every second
        TRACE( _T("nIDEvent == 1") );
        KillTimer( nIDEvent );
        SetTimer( 2, 1000, NULL );

    } else {

        // One second timer. Notify the app object
        RecApp->Tick();

    }
    CWnd::OnTimer( nIDEvent );
}

int CRecallWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
TRACEFN("CRecallWnd::OnCreate" );

    if (CWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    // Set the initial timer to allow time for startup
    if (!SetTimer(1, RSRECALL_TIME_FOR_STARTUP * 1000, NULL))
        return -1;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\dll\makefile.inc ===
$(O)\RsRecall.res: \
    ..\RsRecall.rc2      \
    ..\RsRecall.ico      \
    ..\recall1.avi       \
    ..\ClientOb.rgs      \
    ..\ClntDll.rgs       \
    ..\RsRecall.rgs      \
    ..\RsRecDll.rgs      \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\stdafx.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    StdAfx.cpp

Abstract:

    Takes care of implementation (.cpp) includes (atlimpl.cpp, statreg.cpp)

Author:

    Rohde Wakefield   [rohde]   20-Feb-1998

Revision History:

--*/

#include "stdafx.h"

#define WsbAffirmStatus RecAffirmStatus
#define WsbCatch        RecCatch
#define WsbThrow        RecThrow

#pragma warning(4:4701)
#include <atlimpl.cpp>
#include <statreg.cpp>
#pragma warning(3:4701)

#include "rsutil.cpp"

CComModule _Module;
RSTRACE_INIT( "RsNotify" )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\rsrecall.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    rsrecall.h

Abstract:

    This class represents the recall application.

Author:

    Rohde Wakefield   [rohde]   27-May-1997

Revision History:

--*/

#ifndef _RSRECALL_H_
#define _RSRECALL_H_

#pragma once

//  Times are in seconds
#define RSRECALL_TIME_DELAY_DISPLAY   3   // Delay showing dialog
#define RSRECALL_TIME_FOR_STARTUP     5   // Time to allow for app. startup
#define RSRECALL_TIME_MAX_IDLE        3   // Idle time before shutting down app.

// Max concurrent recall popups
#define RSNTFY_REGISTRY_STRING                  (_T("Software\\Microsoft\\RemoteStorage\\RsNotify"))
#define MAX_CONCURRENT_RECALL_NOTES             (_T("ConcurrentRecallNotes"))  
#define MAX_CONCURRENT_RECALL_NOTES_DEFAULT     5   

/////////////////////////////////////////////////////////////////////////////
// CRecallWnd window

class CRecallWnd : public CFrameWnd
{
// Construction
public:
    CRecallWnd();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRecallWnd)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRecallWnd();

    // Generated message map functions
protected:
    //{{AFX_MSG(CRecallWnd)
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CRecallApp:
// See rsrecall.cpp for the implementation of this class
//

class CRecallNote;

class CRecallApp : public CWinApp
{
public:
    CRecallApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRecallApp)
    public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    //}}AFX_VIRTUAL

// Implementation
//  CRecallWnd m_Wnd;  // Hidden window needed for MFC to hang around
    UINT       m_IdleCount;  // Number of seconds we've been idle

    //{{AFX_MSG(CRecallApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    CList<CRecallNote*, CRecallNote*> m_Recalls;

    DWORD   m_dwMaxConcurrentNotes;

    HRESULT AddRecall( IFsaRecallNotifyServer* );
    HRESULT RemoveRecall( IFsaRecallNotifyServer* );

    void    LockApp( );
    void    UnlockApp( );

    void    Tick(void);
};

#define RecApp ((CRecallApp*)AfxGetApp())

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\exe\makefile.inc ===
$(O)\RsRecall.res: \
    ..\RsRecall.rc2      \
    ..\RsRecall.ico      \
    ..\recall1.avi       \
    ..\ClientOb.rgs      \
    ..\ClntDll.rgs       \
    ..\RsRecall.rgs      \
    ..\RsRecDll.rgs      \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\stdafx.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    StdAfx.cpp

Abstract:

    Precompiled header root.

Author:

    Rohde Wakefield   [rohde]   20-Feb-1998

Revision History:

--*/

#ifndef RECALL_STDAFX_H
#define RECALL_STDAFX_H

#pragma once

//#define VC_EXTRALEAN      // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>
#include <afxext.h>
#include <afxcmn.h>
#include <afxtempl.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <statreg.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#include "RsTrace.h"
#include "resource.h"
#include "rsutil.h"
#include "fsaint.h"
#include "RsRecall.h"
#include "clientob.h"
#include "note.h"

// Don't do module state tracking if just an exe
#ifndef _USRDLL
#undef AFX_MANAGE_STATE
#define AFX_MANAGE_STATE(a)
#endif

#define RecDebugOut CRsFuncTrace::Trace

#define RecAssert(cond, hr)             if (!(cond)) RecThrow(hr)
#define RecThrow(hr)                    throw( CRecThrowContext( __FILE__, __LINE__, hr ) );

#define RecAffirm(cond, hr)             if (!(cond)) RecThrow(hr)
#define RecAffirmHr(hr)                 \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        RecAffirm(SUCCEEDED(lHr), lHr); \
    }

#define RecAffirmHrOk(hr)               \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        RecAffirm(S_OK == lHr, lHr);    \
    }

#define RecAssertHr(hr)                 \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        RecAssert(SUCCEEDED(lHr), lHr); \
    }

#define RecAssertStatus(status)         \
    {                                   \
        BOOL bStatus;                   \
        bStatus = (status);             \
        if (!bStatus) {                 \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            RecAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

#define RecAssertHandle(hndl)           \
    {                                   \
        HANDLE hHndl;                   \
        hHndl = (hndl);                 \
        if (hHndl == INVALID_HANDLE_VALUE) {            \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            RecAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

#define RecAssertPointer( ptr )         \
    {                                   \
        RecAssert( ptr != 0, E_POINTER);\
    }

#define RecAffirmStatus(status)         \
    {                                   \
        BOOL bStatus;                   \
        bStatus = (status);             \
        if (!bStatus) {                 \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            RecAffirm(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

#define RecAffirmHandle(hndl)           \
    {                                   \
        HANDLE hHndl;                   \
        hHndl = (hndl);                 \
        if (hHndl == INVALID_HANDLE_VALUE) {          \
            DWORD dwErr = GetLastError();             \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);  \
            RecAffirm(SUCCEEDED(lHr), lHr);           \
        }                               \
    }

#define RecAffirmPointer( ptr )         \
    {                                   \
        RecAffirm( ptr != 0, E_POINTER);\
    }

#define RecCatchAndDo(hr, code)         \
    catch(CRecThrowContext context) {   \
        hr = context.m_Hr;              \
        TRACE( _T("Throw <0x%p> on line [%ld] of %hs"), context.m_Hr, (long)context.m_Line, context.m_File); \
        { code }                        \
    }

// Turn on In-Your-Trace error messages for debugging.

class CRecThrowContext {
public:
    CRecThrowContext( char * File, long Line, HRESULT Hr ) :
        m_File(File), m_Line(Line), m_Hr(Hr) { }
    char *  m_File;
    long    m_Line;
    HRESULT m_Hr;
};

#define RecCatch(hr)                    \
    catch(CRecThrowContext context) {   \
        hr = context.m_Hr;              \
        TRACE( _T("Throw <0x%p> on line [%ld] of %hs"), context.m_Hr, (long)context.m_Line, context.m_File); \
    }


class RecComString {
public:
    RecComString( ) : m_sz( 0 ) { }
    RecComString( const OLECHAR * sz ) { m_sz = (OLECHAR*)CoTaskMemAlloc( ( wcslen( sz ) + 1 ) * sizeof( OLECHAR ) ); }
    ~RecComString( ) { Free( ); }

    void Free( ) { if( m_sz ) CoTaskMemFree( m_sz ); }

    operator OLECHAR * () { return( m_sz ); }
    OLECHAR** operator &() { return( &m_sz ); }

private:
    OLECHAR * m_sz;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsntfy\sources.inc ===
!IF 0

Copyright (c) 1989 Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETPATH=$(BASEP_HSM_DIR)\bin\$(_OBJ_DIR)
NTTARGETFILE0=

INCLUDES=$(BASEP_HSM_DIR)\inc;$(BASEP_HSM_DIR)\inc\$(O);..\..\inc

UMTYPE=windows
UMENTRY=winmain

#
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.RsNotify
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=rsnotify.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1


TARGETLIBS= \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\ntdll.lib    \
    $(SDK_LIB_PATH)\ole32.lib    \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\uuid.lib     \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(BASEP_HSM_DIR)\lib\$(O)\FsaGuid.lib \

USE_NATIVE_EH=1
USE_MFCUNICODE=1
MFC_VER=42
USE_ATL=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_SOURCEFILE=..\stdafx.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\ladate.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    LaDate.cpp

Abstract:

    Implementation of CLaDate, a class representing the enabled or
    disabled state of last access date updating of NTFS files. Last
    access date updating on NTFS files can be disabled through the
    registry for performance reasons. This class implements updating
    and reporting of the state of the registry value that contols last
    access date. The following states are used to represent the registry
    value:

        LAD_DISABLED: last access date is disabled, registry value is 1
        LAD_ENABLED: last access date is enabled, registry value is not 1
        LAD_UNSET: last access date is enabled, no registry value

Author:

    Carl Hagerstrom [carlh]   01-Sep-1998

--*/

#include <StdAfx.h>
#include <LaDate.h>

/*++

    Implements: 

        CLaDate Constructor

    Routine Description: 

        Initialize object state and open registry key. If the registry key cannot
        be opened, we will assume that the last access state is LAD_UNSET.

--*/

CLaDate::CLaDate( )
{
TRACEFN( "CLaDate::CLaDate" );

    HKEY regKey = 0;

    m_regPath  = L"System\\CurrentControlSet\\Control\\FileSystem";
    m_regEntry = L"NtfsDisableLastAccessUpdate";
    m_regKey   = (HKEY)0;

    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                       m_regPath,
                                       (DWORD)0,
                                       KEY_ALL_ACCESS,
                                       &regKey ) ) {

        m_regKey = regKey;
    }
}

/*++

    Implements: 

        CLaDate Destructor

    Routine Description: 

        Close registry key.

--*/

CLaDate::~CLaDate( )
{
TRACEFN( "CLaDate::~CLaDate" );

    if ( m_regKey ) {

        RegCloseKey( m_regKey );
    }
}

/*++

    Implements: 

        CLaDate::UnsetLadState

    Routine Description: 

        Removes the registry value.

    Arguments: 

        None

    Return Value:

        S_OK - Success
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT
CLaDate::UnsetLadState( )
{
TRACEFNHR( "CLaDate::UnsetLadState" );

    try {
        if( m_regKey ) {

            RsOptAffirmWin32( RegDeleteValue( m_regKey, m_regEntry ) );
        }
    } RsOptCatch( hrRet );

    return( hrRet );
}

/*++

    Implements: 

        CLaDate::SetLadState

    Routine Description: 

        Sets the registry value according to the input parameter.

    Arguments: 

        ladState - LAD_ENABLED or LAD_DISABLED

    Return Value:

        S_OK - Success
        E_NOTIMPL - Operation not supported
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT
CLaDate::SetLadState( 
    IN LAD_STATE ladState
    )
{
TRACEFNHR( "CLaDate::SetLadState" );

    DWORD newVal = (DWORD)0;

    try {
        if ( !m_regKey ) {

            RsOptThrow( E_NOTIMPL );
        }

        if ( ladState == LAD_DISABLED ) {

            newVal = (DWORD)1;
        }

        RsOptAffirmWin32( RegSetValueEx( m_regKey,
                                         m_regEntry,
                                         (DWORD)0,
                                         REG_DWORD,
                                         (BYTE*)&newVal,
                                         (DWORD)sizeof( DWORD ) ) );

    } RsOptCatch( hrRet );

    return( hrRet );
}

/*++

    Implements: 

        CLaDate::GetLadState

    Routine Description: 

        Returns the current state of registry value.

    Arguments: 

        ladState - LAD_ENABLED, LAD_DISABLED or LAD_UNSET

    Return Value:

        S_OK - Success
        E_FAIL - Registry value is of bad type or size
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT
CLaDate::GetLadState(
    OUT LAD_STATE* ladState
    )
{
TRACEFNHR( "CLaDate::GetLadState" );

    DWORD regType;
    BYTE  regData[sizeof( DWORD )];
    DWORD dataSize = sizeof( DWORD );

    try {
        if( !m_regKey ) {

            *ladState = LAD_UNSET;

        } else {

            RsOptAffirmWin32( RegQueryValueEx( m_regKey,
                                               m_regEntry,
                                               (LPDWORD)0,
                                               &regType,
                                               regData,
                                               &dataSize ) );

            if( regType != REG_DWORD || dataSize != sizeof( DWORD ) ) {

                   *ladState = LAD_ENABLED;

            } else {

                if ( (DWORD)1 == *( (DWORD*)regData ) ) {

                    *ladState = LAD_DISABLED;

                } else {

                   *ladState = LAD_ENABLED;
                }
            }
        }
    } RsOptCatch( hrRet );

    return( hrRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\ladate.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    LaDate.h

Abstract:

    Definition of CLaDate, a class representing the enabled or
    disabled state of last access date updating of NTFS files.
    See the implementation file for more details.

Author:

    Carl Hagerstrom [carlh]   01-Sep-1998

--*/

#ifndef _LADATE_H
#define _LADATE_H

class CLaDate
{
private:

    WCHAR* m_regPath;
    WCHAR* m_regEntry;
    HKEY   m_regKey;

public:

    enum LAD_STATE  {

        LAD_ENABLED,  // registry value is not one
        LAD_DISABLED, // registry value is one
        LAD_UNSET     // registry value does not exist
    };

    CLaDate( );
    ~CLaDate( );

    HRESULT
    UnsetLadState( );

    HRESULT
    SetLadState( 
        IN LAD_STATE
        );

    HRESULT
    GetLadState( 
        OUT LAD_STATE*
        );
};

#endif // _LADATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\opcommon.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    OpCommon.cpp

Abstract:

    Nada.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rsoptcom.rc
//
#define IDS_ITEM_DESCRIPTION            8
#define IDS_POSSIBLE_DATA_LOSS          11
#define IDS_LA_DATE_CHANGE              12
#define IDS_CANNOT_STOP_SERVICES        13
#define IDS_PRODUCT_NAME                14
#define IDD_SCAN_WAIT                   110
#define IDB_RSTORAGE_SMALL              132
#define IDB_HOURGLASS                   135
#define IDD_UNINSTALL_ERROR_FILES       156
#define IDC_DIRTY_VOLUMES               1002
#define IDC_REMOVE_EXECUTABLES          1003
#define IDC_REMOVE_EVERYTHING           1004
#define IDC_STATIC_REM_OPTS             1009
#define IDC_FILELIST                    1010
#define IDD_WIZ_UNINSTALL_CHECK         7004
#define IDS_RS_INSTALL_SVCS             32103
#define IDS_RS_REMOVE_SVCS              32104
#define IDS_RS_UPGRADE_SVCS             32105
#define IDS_RS_DESCRIPTION              32110

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        157
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\optcom.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    OptCom.cpp

Abstract:

    Base Class for optional component work.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/


#ifndef _OPTCOM_H
#define _OPTCOM_H

#pragma once

class CRsOptCom
{
public:

    CRsOptCom();
    virtual ~CRsOptCom();

    DWORD
    SetupProc(
        IN     LPCVOID  ComponentId,
        IN     LPCVOID  SubcomponentId,
        IN     UINT     Function,
        IN     UINT_PTR Param1,
        IN OUT PVOID    Param2
        );

    virtual DWORD PreInitialize( IN DWORD Flags );
    virtual DWORD InitComponent( IN PSETUP_INIT_COMPONENT SetupInitComponent );
    virtual SubComponentState DetectInitialState( IN SHORT SubcomponentId );
    virtual SubComponentState QueryState( IN SHORT SubcomponentId );
    virtual BOOL SetLanguage( WORD LangId );
    virtual HBITMAP QueryImage( IN SHORT SubcomponentId, IN SubComponentInfo WhichImage, IN WORD Width, IN WORD Height );
    virtual BOOL QueryImageEx( IN SHORT SubcomponentId, IN OC_QUERY_IMAGE_INFO *pQueryImageInfo, OUT HBITMAP *phBitmap );
    virtual LONG RequestPages( IN WizardPagesType Type, IN OUT PSETUP_REQUEST_PAGES RequestPages );
    virtual BOOL QuerySkipPage( IN OcManagerPage Page );
    virtual BOOL QueryChangeSelState( IN SHORT SubcomponentId, IN BOOL NewState, IN DWORD Flags );
    virtual DWORD CalcDiskSpace( IN SHORT SubcomponentId, IN BOOL AddSpace, IN HDSKSPC hDiskSpace );
    virtual DWORD QueueFileOps( IN SHORT SubcomponentId, IN HSPFILEQ hFileQueue );
    virtual LONG QueryStepCount( IN SHORT SubcomponentId );
    virtual DWORD AboutToCommitQueue( IN SHORT SubcomponentId );
    virtual DWORD CompleteInstallation( IN SHORT SubcomponentId );
    virtual void CleanUp( void );

    //
    // Maps from string to constant ID and back
    //
    virtual SHORT IdFromString( LPCTSTR SubcomponentId ) = 0;
    virtual LPCTSTR StringFromId( SHORT SubcomponentId ) = 0;


    //
    // Helper functions to wrap functionality
    //
    DWORD DoCalcDiskSpace( IN BOOL AddSpace, IN HDSKSPC hDiskSpace, IN LPCTSTR SectionName );
    DWORD DoQueueFileOps( IN SHORT SubcomponentId, IN HSPFILEQ hFileQueue, IN LPCTSTR InstallSectionName, IN LPCTSTR UninstallSectionName );
    DWORD DoRegistryOps( IN SHORT SubcomponentId, IN RSOPTCOM_ACTION actionForReg, IN LPCTSTR SectionName );

    LPCWSTR StringFromFunction( UINT Function );
    LPCWSTR StringFromPageType( WizardPagesType PageType );
    LPCWSTR StringFromAction( RSOPTCOM_ACTION );

    RSOPTCOM_ACTION GetSubAction( SHORT SubcomponentId );

    HRESULT CreateLink( LPCTSTR lpszProgram, LPCTSTR lpszArgs, LPTSTR lpszLink, LPCTSTR lpszDir, LPCTSTR lpszDesc, 
                        int nItemDescId, int nDescId, LPCTSTR lpszIconPath, int iIconIndex );
    BOOL    DeleteLink( LPTSTR lpszShortcut );
    HRESULT GetGroupPath( int nFolder, LPTSTR szPath );
    void    AddItem( int nFolder, LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir, LPCTSTR szDesc, 
                        int nItemDescId, int nDescId, LPCTSTR szIconPath = 0, int iIconIndex = 0 );
    void    DeleteItem( int nFolder, LPCTSTR szAppName );

    typedef HRESULT (WINAPI *PFN_DLLENTRYPOINT)( void );
    HRESULT CallDllEntryPoint( LPCTSTR pszDLLName, LPCSTR pszEntryPoint );

    //
    // Information for SETUP_INIT_COMPONENT
    //
    UINT       m_OCManagerVersion;
    UINT       m_ComponentVersion;
    HINF       m_OCInfHandle;
    HINF       m_ComponentInfHandle;
    SETUP_DATA m_SetupData;

    OCMANAGER_ROUTINES m_HelperRoutines;

    //
    // Quick access to manager routines
    //
    void TickGauge( void )
            { m_HelperRoutines.TickGauge( m_HelperRoutines.OcManagerContext ); };

    void SetProgressText( IN LPCTSTR Text )
            { m_HelperRoutines.SetProgressText( m_HelperRoutines.OcManagerContext, Text ); };

    void SetPrivateData( IN LPTSTR Name, PVOID Data, IN UINT Size, IN UINT Type )
            { m_HelperRoutines.SetPrivateData( m_HelperRoutines.OcManagerContext, Name, Data, Size, Type ); };

    UINT GetPrivateData( IN SHORT SubcomponentId OPTIONAL, IN LPTSTR Name, PVOID Data OPTIONAL, IN OUT PUINT pSize, OUT PUINT pType )
            { return m_HelperRoutines.GetPrivateData( m_HelperRoutines.OcManagerContext, StringFromId( SubcomponentId ), Name, Data, pSize, pType ); };

    UINT SetSetupMode( IN DWORD SetupMode )
            { return m_HelperRoutines.SetSetupMode( m_HelperRoutines.OcManagerContext, SetupMode ); };

    UINT GetSetupMode( void )
            { return m_HelperRoutines.GetSetupMode( m_HelperRoutines.OcManagerContext ); };

    BOOL QuerySelectionState( IN SHORT SubcomponentId, IN UINT StateType )
            { return m_HelperRoutines.QuerySelectionState( m_HelperRoutines.OcManagerContext, StringFromId( SubcomponentId ), StateType ); };

    BOOL ConfirmCancel( IN HWND ParentWindow )
            { return m_HelperRoutines.ConfirmCancelRoutine( ParentWindow ); };

    HWND QueryWizardDialogHandle( void )
            { return m_HelperRoutines.QueryWizardDialogHandle( m_HelperRoutines.OcManagerContext ); };

    BOOL SetReboot( void )
            { return m_HelperRoutines.SetReboot( m_HelperRoutines.OcManagerContext, FALSE ); };


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\rscln.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsCln.h

Abstract:

    This header is local to the GUI module and is referenced by the RsCln
    and RsOptCom modules.  It contains defined constants and the definition
    of class CRsClnServer. See the implementation file for a description
    of this class.

Author:

    Carl Hagerstrom   [carlh]   20-Aug-1998

Revision History:

--*/

#ifndef _RSCLN_H
#define _RSCLN_H

#define MAX_STICKY_NAME 80

#include <afxtempl.h>

/////////////////////////////////////////////////////////////////////////////
// CRsClnErrorFiles dialog

typedef CList<CString, CString&> CRsStringList;

class CRsClnErrorFiles : public CDialog
{
// Construction
public:
    CRsClnErrorFiles(CRsStringList* pFileList);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CRsClnErrorFiles)
    enum { IDD = IDD_UNINSTALL_ERROR_FILES };
    CListBox    m_FileList;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRsClnErrorFiles)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    CRsStringList m_ErrorFileList;


protected:

    // Generated message map functions
    //{{AFX_MSG(CRsClnErrorFiles)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    
};

class CRsClnServer
{
public:

    CRsClnServer();
    ~CRsClnServer();

    HRESULT ScanServer(DWORD*);
    HRESULT CleanServer();
    HRESULT FirstDirtyVolume(WCHAR**);
    HRESULT NextDirtyVolume(WCHAR**);
    HRESULT RemoveDirtyVolumes();
    HRESULT AddErrorFile(CString&);

private:

    struct dirtyVolume
    {
        WCHAR stickyName[MAX_STICKY_NAME];
        WCHAR bestName[MAX_STICKY_NAME];
        struct dirtyVolume* next;
    };

    HRESULT AddDirtyVolume(WCHAR*, WCHAR*);

    struct dirtyVolume* m_head;
    struct dirtyVolume* m_tail;
    struct dirtyVolume* m_current;

    CRsStringList m_ErrorFileList;

};

#endif // _RSCLN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\optcom.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    OptCom.cpp

Abstract:

    Base Class for optional component work.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/



#include "stdafx.h"
#include "rsoptcom.h"
#include "OptCom.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRsOptCom::CRsOptCom()
{
TRACEFN( "CRsOptCom::CRsOptCom" );
}

CRsOptCom::~CRsOptCom()
{
TRACEFN( "CRsOptCom::CRsOptCom" );

}

DWORD
CRsOptCom::SetupProc(
    IN     LPCVOID  /*ComponentId*/,
    IN     LPCVOID  SubcomponentId,
    IN     UINT     Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID    Param2
    )
{
TRACEFN( "CRsOptCom::SetupProc" );
TRACE( L"Function = <%ls><%p>", StringFromFunction( Function ), Function );

    SHORT subcomponentId = IdFromString( (LPCTSTR)SubcomponentId );

    DWORD dwRet = 0;

    switch( Function ) {
    case OC_PREINITIALIZE:
        dwRet = PreInitialize( (DWORD)Param1 );
        break;

    case OC_INIT_COMPONENT:
        dwRet = InitComponent( (PSETUP_INIT_COMPONENT)Param2 );
        break;

    case OC_SET_LANGUAGE:
        dwRet = (DWORD)SetLanguage( (WORD)Param1 );
        break;

#ifndef _WIN64
    case OC_QUERY_IMAGE:
        // Note: The casting of the return value from HBITMAP to DWORD is broken on IA64,
        //  however, Setup avoids calling with OC_QUERY_IMAGE on IA64, rather it uses OC_QUERY_IMAGE_EX
        dwRet = (DWORD)QueryImage( subcomponentId, (SubComponentInfo)Param1, LOWORD(Param2), HIWORD(Param2) );
        break;
#endif

#ifdef _WIN64
    case OC_QUERY_IMAGE_EX:
        dwRet = (DWORD)QueryImageEx( subcomponentId, (OC_QUERY_IMAGE_INFO *)Param1, (HBITMAP *)Param2 );
        break;
#endif

    case OC_REQUEST_PAGES:
        dwRet = (DWORD)RequestPages( (WizardPagesType)Param1, (PSETUP_REQUEST_PAGES)Param2 );
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        dwRet = (DWORD)QueryChangeSelState( subcomponentId, Param1 != 0, (ULONG)((ULONG_PTR)Param2) );
        break;

    case OC_CALC_DISK_SPACE:
        dwRet = CalcDiskSpace( subcomponentId, Param1 != 0, (HDSKSPC)Param2 );
        break;

    case OC_QUEUE_FILE_OPS:
        dwRet = QueueFileOps( subcomponentId, (HSPFILEQ)Param2 );
        break;

    case OC_QUERY_STEP_COUNT:
        dwRet = (DWORD)QueryStepCount( subcomponentId );
        break;

    case OC_COMPLETE_INSTALLATION:
        dwRet = CompleteInstallation( subcomponentId );
        break;

    case OC_CLEANUP:
        CleanUp( );
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        dwRet = AboutToCommitQueue( subcomponentId );
        break;

    case OC_QUERY_SKIP_PAGE:
        dwRet = (DWORD)QuerySkipPage( (OcManagerPage)Param1 );
        break;

    case OC_QUERY_STATE:
        dwRet = (DWORD)QueryState( subcomponentId );
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
    case OC_NEED_MEDIA:
    case OC_WIZARD_CREATED:
        break;

    default:
        break;
    }

    return( dwRet );
}

DWORD
CRsOptCom::PreInitialize(
    IN DWORD /*Flags*/
    )
{
TRACEFNDW( "CRsOptCom::PreInitialize" );

#ifdef UNICODE
    dwRet = OCFLAG_UNICODE;
#else
    dwRet = OCFLAG_ANSI;
#endif

    return( dwRet );
}

DWORD
CRsOptCom::InitComponent(
    IN PSETUP_INIT_COMPONENT SetupInitComponent )
{
TRACEFNDW( "CRsOptCom::InitComponent" );

    dwRet = NO_ERROR;

    m_OCManagerVersion   = SetupInitComponent->OCManagerVersion;
    m_ComponentVersion   = SetupInitComponent->ComponentVersion;
    m_OCInfHandle        = SetupInitComponent->OCInfHandle;
    m_ComponentInfHandle = SetupInitComponent->ComponentInfHandle;
    m_SetupData          = SetupInitComponent->SetupData;
    m_HelperRoutines     = SetupInitComponent->HelperRoutines;

    return( dwRet );
}


SubComponentState
CRsOptCom::DetectInitialState(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFN( "CRsOptCom::DetectInitialState" );
    SubComponentState retval = SubcompUseOcManagerDefault;
    return( retval );
}


SubComponentState
CRsOptCom::QueryState(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFN( "CRsOptCom::QueryState" );
    SubComponentState retval = SubcompUseOcManagerDefault;
    return( retval );
}


BOOL
CRsOptCom::SetLanguage(
    WORD /*LangId*/
    )
{
TRACEFNBOOL( "CRsOptCom::SetLanguage" );

    boolRet = TRUE;
    return( boolRet );
}


HBITMAP
CRsOptCom::QueryImage(
    IN SHORT /*SubcomponentId*/,
    IN SubComponentInfo /*WhichImage*/,
    IN WORD /*Width*/,
    IN WORD /*Height*/
    )
{
TRACEFN( "CRsOptCom::QueryImage" );
    HBITMAP retval = 0;
    return( retval );
}

BOOL
CRsOptCom::QueryImageEx( 
    IN SHORT /*SubcomponentId*/, 
    IN OC_QUERY_IMAGE_INFO* /*pQueryImageInfo*/, 
    OUT HBITMAP *phBitmap
    )
{
TRACEFNBOOL( "CRsOptCom::QueryImageEx" );

    if (phBitmap) {
        *phBitmap = NULL;
    }

    boolRet = FALSE;
    return( boolRet );
}

LONG
CRsOptCom::RequestPages(
    IN WizardPagesType /*Type*/,
    IN OUT PSETUP_REQUEST_PAGES /*RequestPages*/
    )
{
TRACEFNLONG( "CRsOptCom::RequestPages" );
    lRet = 0;
    return( lRet );
}


BOOL
CRsOptCom::QuerySkipPage(
    IN OcManagerPage /*Page*/
    )
{
TRACEFNBOOL( "CRsOptCom::QuerySkipPage" );
    boolRet = FALSE;
    return( boolRet );
}


BOOL
CRsOptCom::QueryChangeSelState(
    IN SHORT /*SubcomponentId*/,
    IN BOOL  /*NewState*/,
    IN DWORD /*Flags*/
    )
{
TRACEFNBOOL( "CRsOptCom::QueryChangeSelState" );
    boolRet = TRUE;
    return( boolRet );
}


DWORD
CRsOptCom::CalcDiskSpace(
    IN SHORT   /*SubcomponentId*/,
    IN BOOL    /*AddSpace*/,
    IN HDSKSPC /*hDiskSpace*/
    )
{
TRACEFNDW( "CRsOptCom::CalcDiskSpace" );
    dwRet = 0;
    return( dwRet );
}


DWORD
CRsOptCom::QueueFileOps(
    IN SHORT    /*SubcomponentId*/,
    IN HSPFILEQ /*hFileQueue*/
    )
{
TRACEFNDW( "CRsOptCom::QueueFileOps" );
    dwRet = 0;
    return( dwRet );
}


LONG
CRsOptCom::QueryStepCount(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFNLONG( "CRsOptCom::QueryStepCount" );
    lRet = 0;
    return( lRet );
}


DWORD
CRsOptCom::AboutToCommitQueue(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFNDW( "CRsOptCom::AboutToCommitQueue" );
    dwRet = 0;
    return( dwRet );
}


DWORD
CRsOptCom::CompleteInstallation(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFNDW( "CRsOptCom::CompleteInstallation" );
    dwRet = 0;
    return( dwRet );
}


void
CRsOptCom::CleanUp(
    void
    )
{
TRACEFN( "CRsOptCom::CleanUp" );
}


DWORD
CRsOptCom::DoCalcDiskSpace(
    IN BOOL AddSpace,
    IN HDSKSPC hDiskSpace,
    IN LPCTSTR SectionName
    )
{
TRACEFNDW( "CRsOptCom::DoCalcDiskSpace" );

    dwRet = NO_ERROR;

    HINF hLayoutInf = SetupOpenInfFile( L"layout.inf", 0, INF_STYLE_WIN4 | INF_STYLE_OLDNT , 0 );

    if( INVALID_HANDLE_VALUE == hLayoutInf) {

        dwRet = GetLastError( );
        TRACE( _T("CRsOptCom::AboutToCommitQueue Error opening LAYOUT.INF") );

    }

    if( NO_ERROR == dwRet ) {

        if( AddSpace ) {

            if( SetupAddInstallSectionToDiskSpaceList( hDiskSpace, m_ComponentInfHandle, hLayoutInf, SectionName, 0, 0 ) ) {

                dwRet = GetLastError( );

            }

        } else {

            if ( SetupRemoveInstallSectionFromDiskSpaceList( hDiskSpace, m_ComponentInfHandle, hLayoutInf, SectionName, 0, 0 ) ) {

                dwRet = GetLastError( );

            }
        }
    }

    if( INVALID_HANDLE_VALUE != hLayoutInf) {

        SetupCloseInfFile( hLayoutInf );

    }

    return( dwRet );
}

DWORD
CRsOptCom::DoQueueFileOps(
    IN SHORT SubcomponentId,
    IN HSPFILEQ hFileQueue,
    IN LPCTSTR InstallSectionName,
    IN LPCTSTR UninstallSectionName
    )
{
TRACEFNDW( "CRsOptCom::DoQueueFileOps" );

    BOOL success = TRUE;
    RSOPTCOM_ACTION action = GetSubAction( SubcomponentId );

    switch( action ) {
    case ACTION_INSTALL:

        success = SetupInstallFilesFromInfSection( m_ComponentInfHandle, 0, hFileQueue, InstallSectionName, 0, SP_COPY_FORCE_NEWER );
        break;

    case ACTION_UNINSTALL:

        success = SetupInstallFilesFromInfSection( m_ComponentInfHandle, 0, hFileQueue, UninstallSectionName, 0, 0 );
        break;

    case ACTION_UPGRADE:

       success = SetupInstallFilesFromInfSection( m_ComponentInfHandle, 0, hFileQueue, InstallSectionName, 0, SP_COPY_FORCE_NEWER );
       break;

    }

    dwRet = success ? NO_ERROR : GetLastError( );
    return( dwRet );
}

DWORD
CRsOptCom::DoRegistryOps(
    IN SHORT SubcomponentId,
    IN RSOPTCOM_ACTION actionForReg,
    IN LPCTSTR SectionName
    )
{
TRACEFNDW( "CRsOptCom::DoRegistryOps" );

    BOOL success = TRUE;
    RSOPTCOM_ACTION action = GetSubAction( SubcomponentId );

    if ( action == actionForReg ) {
        success = SetupInstallFromInfSection(
                                NULL, m_ComponentInfHandle, SectionName,
                                SPINST_REGISTRY, NULL, NULL,
                                0, NULL, NULL, NULL, NULL );
    }

    dwRet = success ? NO_ERROR : GetLastError( );
    return( dwRet );
}

LPCWSTR
CRsOptCom::StringFromFunction(
    UINT Function
    )
{
#define CASE_FUNCTION( a ) case a: return( OLESTR( #a ) );

    switch( Function ) {

        CASE_FUNCTION( OC_PREINITIALIZE           )
        CASE_FUNCTION( OC_INIT_COMPONENT          )
        CASE_FUNCTION( OC_SET_LANGUAGE            )
        CASE_FUNCTION( OC_QUERY_IMAGE             )
        CASE_FUNCTION( OC_REQUEST_PAGES           )
        CASE_FUNCTION( OC_QUERY_CHANGE_SEL_STATE  )
        CASE_FUNCTION( OC_CALC_DISK_SPACE         )
        CASE_FUNCTION( OC_QUEUE_FILE_OPS          )
        CASE_FUNCTION( OC_NOTIFICATION_FROM_QUEUE )
        CASE_FUNCTION( OC_QUERY_STEP_COUNT        )
        CASE_FUNCTION( OC_COMPLETE_INSTALLATION   )
        CASE_FUNCTION( OC_CLEANUP                 )
        CASE_FUNCTION( OC_QUERY_STATE             )
        CASE_FUNCTION( OC_NEED_MEDIA              )
        CASE_FUNCTION( OC_ABOUT_TO_COMMIT_QUEUE   )
        CASE_FUNCTION( OC_QUERY_SKIP_PAGE         )
        CASE_FUNCTION( OC_WIZARD_CREATED          )

    }
    return( TEXT( "Unknown" ) );
}

LPCWSTR
CRsOptCom::StringFromPageType(
    WizardPagesType PageType
    )
{
#define CASE_PAGETYPE( a ) case a: return( OLESTR( #a ) );

    switch( PageType ) {

        CASE_PAGETYPE( WizPagesWelcome )
        CASE_PAGETYPE( WizPagesMode    )
        CASE_PAGETYPE( WizPagesEarly   )
        CASE_PAGETYPE( WizPagesPrenet  )
        CASE_PAGETYPE( WizPagesPostnet )
        CASE_PAGETYPE( WizPagesLate    )
        CASE_PAGETYPE( WizPagesFinal   )
        CASE_PAGETYPE( WizPagesTypeMax )

    }
    return( TEXT( "Unknown" ) );
}


LPCWSTR
CRsOptCom::StringFromAction(
    RSOPTCOM_ACTION Action
    )
{
#define CASE_ACTION( a ) case a: return( OLESTR( #a ) );

    switch( Action ) {

        CASE_ACTION( ACTION_NONE )
        CASE_ACTION( ACTION_INSTALL )
        CASE_ACTION( ACTION_UNINSTALL )
        CASE_ACTION( ACTION_REINSTALL )
        CASE_ACTION( ACTION_UPGRADE )

    }
    return( TEXT( "Unknown" ) );
}

RSOPTCOM_ACTION
CRsOptCom::GetSubAction(
    SHORT SubcomponentId
    )
{
TRACEFN( "CRsOptCom::GetSubAction" );

    RSOPTCOM_ACTION retval = ACTION_NONE;
    UINT setupMode = GetSetupMode( );
    DWORDLONG operationFlags = m_SetupData.OperationFlags;

    BOOL originalState = QuerySelectionState( SubcomponentId, OCSELSTATETYPE_ORIGINAL );
    BOOL currentState = QuerySelectionState( SubcomponentId, OCSELSTATETYPE_CURRENT );

    if( !originalState && currentState ) {

        retval = ACTION_INSTALL;

    } else if( originalState && !currentState ) {

        retval = ACTION_UNINSTALL;

    } else if( ( SETUPOP_NTUPGRADE & operationFlags ) && originalState && currentState ) {

        retval = ACTION_UPGRADE;

    }

    TRACE( L"SubcomponentId = <%hd>, originalState = <%hs>, currentState = <%hs>", SubcomponentId, RsBoolAsString( originalState ), RsBoolAsString( currentState ) );
    TRACE( L"OperationsFlags = <0x%0.16I64x>, setupMode = <0x%p>", operationFlags, setupMode );
    TRACE( L"retval = <%ls>", StringFromAction( retval ) );
    return( retval );
}

HRESULT
CRsOptCom::CreateLink(
    LPCTSTR lpszProgram,
    LPCTSTR lpszArgs,
    LPTSTR lpszLink,
    LPCTSTR lpszDir,
    LPCTSTR lpszDesc,
    int nItemDescId, 
    int nDescId,
    LPCTSTR lpszIconPath,
    int iIconIndex
    )
{
TRACEFNHR( "CRsOptCom::CreateLink" );

    CComPtr<IShellLink> pShellLink;

    TCHAR szSystemPath[MAX_PATH];
    TCHAR szResourceString[MAX_PATH+128];
    UINT uLen = 0;

    szSystemPath[0] = _T('\0');
    szResourceString[0] = _T('\0');

    // CoInitialize must be called before this
    // Get a pointer to the IShellLink interface.
    hrRet = CoInitialize( 0 );
    if( SUCCEEDED( hrRet ) ) {
        hrRet = CoCreateInstance(   CLSID_ShellLink, 0, CLSCTX_SERVER, IID_IShellLink, (void**)&pShellLink );
        if( SUCCEEDED( hrRet ) ) {

            CComPtr<IPersistFile> pPersistFile;

            // Set the path to the shortcut target, and add the description.
            pShellLink->SetPath( lpszProgram );
            pShellLink->SetArguments( lpszArgs );
            pShellLink->SetWorkingDirectory( lpszDir );
            pShellLink->SetIconLocation( lpszIconPath, iIconIndex );

            // Description should be set using the resource id in order to support MUI
            uLen = GetSystemDirectory(szSystemPath, MAX_PATH);
            if ((uLen > 0) && (uLen < MAX_PATH)) {
                wsprintf(szResourceString, TEXT("@%s\\setup\\RsOptCom.dll,-%d"), szSystemPath, nDescId);
                pShellLink->SetDescription(szResourceString);
            } else {
                // Set English description
                pShellLink->SetDescription(lpszDesc);
            }

            // Query IShellLink for the IPersistFile interface for saving the
            // shortcut in persistent storage.
            hrRet = pShellLink->QueryInterface( IID_IPersistFile, (void**)&pPersistFile );

            if( SUCCEEDED( hrRet ) ) {

                CComBSTR wsz = lpszLink;

                // Save the link by calling IPersistFile::Save.
                hrRet = pPersistFile->Save( wsz, TRUE );

                if( SUCCEEDED(hrRet) && (uLen > 0) && (uLen < MAX_PATH)) {

                    // Shortcut created - set MUI name.
                    wsprintf(szResourceString, TEXT("%s\\setup\\RsOptCom.dll"), szSystemPath);

                    hrRet = SHSetLocalizedName(lpszLink, szResourceString, nItemDescId);
                }
            }

        }

        CoUninitialize();
    }

    return( hrRet );
}

BOOL
CRsOptCom::DeleteLink(
    LPTSTR lpszShortcut
    )
{
TRACEFNBOOL( "CRsOptCom::DeleteLink" );

    boolRet = TRUE;

    TCHAR  szFile[_MAX_PATH];
    SHFILEOPSTRUCT fos;

    ZeroMemory( szFile, sizeof(szFile) );
    lstrcpy( szFile, lpszShortcut );

    if( DoesFileExist( szFile ) ) {

        ZeroMemory( &fos, sizeof(fos) );
        fos.hwnd   = NULL;
        fos.wFunc  = FO_DELETE;
        fos.pFrom  = szFile;
        fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
        SHFileOperation( &fos );
    }

    return( boolRet );
}

HRESULT
CRsOptCom::GetGroupPath(
    int    nFolder,
    LPTSTR szPath
    )
{
TRACEFNHR( "CRsOptCom::GetGroupPath" );
    szPath[0] = _T('\0');
    hrRet = SHGetFolderPath( 0, nFolder | CSIDL_FLAG_CREATE, 0, 0, szPath );
    TRACE( L"szPath = <%ls>", szPath );
    return( hrRet );
}

void
CRsOptCom::AddItem(
    int     nFolder,
    LPCTSTR szItemDesc,
    LPCTSTR szProgram,
    LPCTSTR szArgs,
    LPCTSTR szDir,
    LPCTSTR szDesc,
    int nItemDescId, 
    int nDescId,
    LPCTSTR szIconPath,
    int     iIconIndex
    )
{
TRACEFN( "CRsOptCom::AddItem" );

    TCHAR szPath[_MAX_PATH];

    if( S_OK == GetGroupPath( nFolder, szPath ) ) {

        lstrcat( szPath, _T("\\") );
        lstrcat( szPath, szItemDesc );
        lstrcat( szPath, _T(".lnk") );

        CreateLink( szProgram, szArgs, szPath, szDir, szDesc, nItemDescId, nDescId, szIconPath, iIconIndex );
    }
}

void
CRsOptCom::DeleteItem(
    int     nFolder,
    LPCTSTR szAppName
    )
{
 TRACEFN( "CRsOptCom::DeleteItem" );

   TCHAR szPath[_MAX_PATH];

    if( S_OK == GetGroupPath( nFolder, szPath ) ) {

        lstrcat( szPath, _T("\\") );
        lstrcat( szPath, szAppName );
        lstrcat( szPath, _T(".lnk") );
    
        DeleteLink( szPath );
    }
}

typedef
HRESULT
(WINAPI *PFN_DLLENTRYPOINT)(
    void
    );

HRESULT
CRsOptCom::CallDllEntryPoint(
    LPCTSTR pszDLLName,
    LPCSTR pszEntryPoint
    )
{
TRACEFNHR( "CRsOptCom::CallDllEntryPoint" );
TRACE( _T("Dll <%s> Func <%hs>"), pszDLLName, pszEntryPoint );

    HINSTANCE           hDLL = 0;
    PFN_DLLENTRYPOINT   pfnEntryPoint;

    try {

        hDLL = LoadLibrary( pszDLLName );
        RsOptAffirmStatus( hDLL );

        pfnEntryPoint = (PFN_DLLENTRYPOINT)GetProcAddress( hDLL, pszEntryPoint );
        RsOptAffirmStatus( pfnEntryPoint );

        hrRet = pfnEntryPoint();

    } RsOptCatch( hrRet );

    if( hDLL ) FreeLibrary( hDLL );

    return( hrRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\rsopt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsOpt.h

Abstract:

    Special error handling macros for RsOptCom and RsCln.

Author:

    Carl Hagerstrom [carlh]   20-Aug-1998

Revision History:

--*/

#ifndef _RSOPT_H
#define _RSOPT_H

#define RsOptThrow(hr)          throw ((HRESULT)hr)
#define RsOptLastError          (HRESULT_FROM_WIN32(GetLastError()))
#define RsOptAffirm(cond,hr)    if (!(cond)) RsOptThrow(hr)
#define RsOptAffirmStatus(stat) RsOptAffirm(stat, RsOptLastError)
#define RsOptAffirmPointer(ptr) RsOptAffirm(ptr, E_POINTER)
#define RsOptAffirmAlloc(ptr)   RsOptAffirm(ptr, E_OUTOFMEMORY)
#define RsOptAffirmHr(hr)                 \
    {                                     \
        HRESULT     lHr;                  \
        lHr = (hr);                       \
        RsOptAffirm(SUCCEEDED(lHr), lHr); \
    }

      
#define RsOptAffirmHandle(hndl)                                              \
    {                                                                        \
        HANDLE _hndl;                                                        \
        _hndl = (hndl);                                                      \
        RsOptAffirm(_hndl && _hndl != INVALID_HANDLE_VALUE, RsOptLastError); \
    }

#define RsOptAffirmNtStatus(ntstat)                                          \
    {                                                                        \
        NTSTATUS _ntstat;                                                    \
        _ntstat = (ntstat);                                                  \
        RsOptAffirm(NT_SUCCESS(_ntstat), HRESULT_FROM_NT(_ntstat));          \
    }

#define RsOptAffirmDw(hr)                                                    \
    {                                                                        \
        HRESULT _hr;                                                         \
        _hr = (hr);                                                          \
        RsOptAffirm(SUCCEEDED(_hr), _hr);                                    \
    }

#define RsOptAffirmWin32(stat)                                               \
    {                                                                        \
        LONG _stat;                                                          \
        _stat = (stat);                                                      \
        RsOptAffirm(_stat == ERROR_SUCCESS, HRESULT_FROM_WIN32(_stat));      \
    }

#define RsOptCatch(retval)                                                   \
    catch(HRESULT _retval)                                                   \
    {                                                                        \
        retval = _retval;                                                    \
    }

#endif // _RSOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\rsoptcom.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsOptCom.h

Abstract:

    Main module for Optional Component install

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#include "stdafx.h"
#include "rsoptcom.h"
#include "OptCom.h"
#include "Uninstal.h"

/////////////////////////////////////////////////////////////////////////////
// CRsoptcomApp

BEGIN_MESSAGE_MAP(CRsoptcomApp, CWinApp)
    //{{AFX_MSG_MAP(CRsoptcomApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRsoptcomApp construction

BOOL CRsoptcomApp::InitInstance()
{
TRACEFNBOOL( "CRsoptcomApp::InitInstance" );

    //
    // Initialize COM in case we need to call back to HSM
    // 
    // This code is commented out:
    //  - There's no need today to call back to HSM
    //  - A DLL should avoid calling CoInitialize from its DLLMain
    //
/***    HRESULT hrCom = CoInitialize( 0 );
    if (!SUCCEEDED(hrCom)) {
        boolRet = FALSE;
        return( boolRet );
    }   ***/

    boolRet = CWinApp::InitInstance( );

    if (! boolRet) {
        OutputDebugString(L"RSOPTCOM: Init instance FAILED\n");
    } 
        
    return( boolRet );
}

int CRsoptcomApp::ExitInstance()
{
TRACEFN( "CRsoptcomApp::ExitInstance" );

//  _Module.Term();
    int retval = CWinApp::ExitInstance();
    return( retval );
}

CRsoptcomApp::CRsoptcomApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRsoptcomApp object

CRsoptcomApp gApp;

CRsUninstall gOptCom;

extern "C" {

DWORD
OcEntry(
        IN     LPCVOID  ComponentId,
        IN     LPCVOID  SubcomponentId,
        IN     UINT     Function,
        IN     UINT_PTR Param1,
        IN OUT PVOID    Param2
    )
{
TRACEFN( "OcEntry" );
    return( gOptCom.SetupProc( ComponentId, SubcomponentId, Function, Param1, Param2 ) );
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\stdafx.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Singletons and consts placed here.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#include "stdafx.h"

RSTRACE_INIT( "RsOptCom" )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\rsoptcom.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsOptCom.h

Abstract:

    Main module for Optional Component install

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#ifndef _RSOPTCOM_H
#define _RSOPTCOM_H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CRsoptcomApp
// See rsoptcom.cpp for the implementation of this class
//

class CRsoptcomApp : public CWinApp
{
public:
    CRsoptcomApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRsoptcomApp)
    //}}AFX_VIRTUAL

    //{{AFX_MSG(CRsoptcomApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    virtual BOOL InitInstance();
    virtual int ExitInstance();
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

typedef enum {
    ACTION_NONE,
    ACTION_INSTALL,
    ACTION_UNINSTALL,
    ACTION_REINSTALL,
    ACTION_UPGRADE
} RSOPTCOM_ACTION;


#endif // !defined(AFX_RSOPTCOM_H__20A76545_40B8_11D1_9F11_00A02488FCDE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\stdafx.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Precompiled header starting point

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#ifndef _STDAFX_H
#define _STDAFX_H
#pragma once

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>         // MFC support for Windows Common Controls

#include <setupapi.h>
#include <ocmanage.h>
#undef _WIN32_IE
#define _WIN32_IE 0x0500
#include <shlobj.h>

#include <rsopt.h>

#include "Wsb.h"
#include "RsTrace.h"
#include "Resource.h"
#include "RsOptCom.h"
#include "OptCom.h"

#define WsbBoolAsString( boolean ) (boolean ? OLESTR("TRUE") : OLESTR("FALSE"))
#define DoesFileExist( strFile )   (GetFileAttributes( strFile ) != 0xFFFFFFFF)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#define RSOPTCOM_EXPORT __declspec(dllexport) /*__cdecl*/

#define RSOPTCOM_SUB_ROOT               TEXT("RSTORAGE")

#define RSOPTCOM_SECT_INSTALL_ROOT      TEXT("RSInstall")
#define RSOPTCOM_SECT_UNINSTALL_ROOT    TEXT("RSUninstall")
#define RSOPTCOM_SECT_INSTALL_FILTER    TEXT("RSInstall.Services")
#define RSOPTCOM_SECT_UNINSTALL_FILTER  TEXT("RSUninstall.Services")

#define RSOPTCOM_ID_ERROR   (-1)
#define RSOPTCOM_ID_NONE    (0)
#define RSOPTCOM_ID_ROOT    (1)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\uninschk.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    UnInsCheck.h

Abstract:

    Dialog to check for type of uninstall.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#ifndef _UNINSCHK_H
#define _UNINSCHK_H

#pragma once

#include "uninstal.h"
#include <rscln.h>

/////////////////////////////////////////////////////////////////////////////
// CUninstallCheck dialog

class CUninstallCheck : public CDialog
{
// Construction
public:
    CUninstallCheck( CRsOptCom * pOptCom );
    ~CUninstallCheck();

// Dialog Data
    //{{AFX_DATA(CUninstallCheck)
    enum { IDD = IDD_WIZ_UNINSTALL_CHECK };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CUninstallCheck)
    public:
    virtual INT_PTR DoModal();

    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
     CRsOptCom*    m_pOptCom;
     CRsUninstall* m_pUninst;  // allows access to CRsUninstall state
     BOOL          m_dataLoss; // TRUE if Remote Storage data exists
     CFont         m_boldShellFont;


protected:
    // Generated message map functions
    //{{AFX_MSG(CUninstallCheck)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\uninschk.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    UnInsCheck.cpp

Abstract:

    Dialog to check for type of uninstall.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

    Carl Hagerstrom [carlh]   20-Aug-1998

        Changed the dialog for uninstalling Remote Storage. All local fixed
        volumes on the Remote Storage server are scanned for the existence
        of Remote Storage reparse points. If Remote Storage data exists, the
        user is told, on the Remote Storage Uninstall Check Wizard Page,
        which volumes contain this data. The user is given the choice of
        deleting only Remote Storage executables, deleting executables and
        Remote Storage data, or cancelling from "Add or Remove Optional
        Components".

    Mike Moore      [mmoore]  20-Oct-1998

        Changed the property page to a dialog.

--*/

#include "stdafx.h"
#include "UnInsChk.h"

/////////////////////////////////////////////////////////////////////////////
// CUninstallCheck property page

/*++

    Implements:

        CUninstallCheck Constructor

    Routine Description:

        Performs initialization.

    Arguments:

        pOptCom - points to optional component object

--*/

CUninstallCheck::CUninstallCheck(CRsOptCom* pOptCom) :
    CDialog(IDD), m_pOptCom(pOptCom)
{
    m_dataLoss = FALSE;
    m_pUninst  = (CRsUninstall*)m_pOptCom;
    //{{AFX_DATA_INIT(CUninstallCheck)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

/*++

    Implements:

        CUninstallCheck Destructor

--*/

CUninstallCheck::~CUninstallCheck()
{
}

/*++

    Implements:

        CUninstallCheck::DoDataExchange

    Routine Description:

        Calls CRsPropertyPage::DoDataExchange.

    Arguments:

        pDx - a pointer to a CDataExchange object

--*/

void CUninstallCheck::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUninstallCheck)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CUninstallCheck, CDialog)
//BEGIN_MESSAGE_MAP(CUninstallCheck, CDialog)
    //{{AFX_MSG_MAP(CUninstallCheck)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CUninstallCheck message handlers

/*++

    Implements:

        CUninstallCheck::OnInitDialog

    Routine Description:

        Call the CDialog::OnInitDialog, check the remove executables radio button,
        uncheck the remove everything button, and fill the list box with volumes.

    Return Value:

        TRUE if no exceptions are thrown.

--*/
BOOL CUninstallCheck::OnInitDialog()
{

    BOOL bRet = CDialog::OnInitDialog();

    HRESULT hr           = S_OK;
    WCHAR*  volName      = (WCHAR*)0;
    DWORD   volCount     = 0;
    CRsClnServer* pRsCln = m_pUninst->m_pRsCln;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try
    {
        // Set the font to bold for Remove Options
        LOGFONT logfont;
        CFont * tempFont = GetFont( );
        tempFont->GetLogFont( &logfont );

        logfont.lfWeight = FW_BOLD;

        m_boldShellFont.CreateFontIndirect( &logfont );

        CStatic* pRemOpts = (CStatic*)GetDlgItem(IDC_STATIC_REM_OPTS);
        pRemOpts->SetFont( &m_boldShellFont );

        CListBox* pListBox = (CListBox*)GetDlgItem(IDC_DIRTY_VOLUMES);
        pListBox->ResetContent();

        CButton* pBtn;
        pBtn = (CButton*)GetDlgItem(IDC_REMOVE_EXECUTABLES);
        pBtn->SetCheck(1);
        pBtn = (CButton*)GetDlgItem(IDC_REMOVE_EVERYTHING);
        pBtn->SetCheck(0);

        RsOptAffirmDw(pRsCln->FirstDirtyVolume(&volName));
        while (volName)
        {
            pListBox->AddString(volName);
            RsOptAffirmDw(pRsCln->NextDirtyVolume(&volName));
        }
    }
    RsOptCatch(hr);

    if ( FALSE == bRet )
    {
        EndDialog( IDCANCEL );
    }

    return bRet;

}
/////////////////////////////////////////////////////////////////////////////
// CUninstallCheck message handlers

/*++

    Implements:

        CUninstallCheck::DoModal

    Routine Description:

        Determine whether the Uninstall Check dialog should be made active,
        and if so, what should be displayed on it.

        The local fixed disk volumes are scanned for Remote Storage data.
        During the scan, an hourglass cursor and a modeless dialog,
        explaining that the scan is in progress, appear. If there is Remote
        Storage data, the Uninstall Check dialog will show a list box containing the
        volumes with Remote Storage data, instructions, and a set of radio buttons
        with uninstall options.

    Return Value:

        S_OK if no exceptions are thrown and the user selected OK.
        RSOPTCOM_ID_CANCELLED if the user selected cancel.

--*/
INT_PTR CUninstallCheck::DoModal()
{
    HRESULT hr           = S_OK;
    WCHAR*  volName      = (WCHAR*)0;
    DWORD   volCount     = 0;
    CRsClnServer* pRsCln = m_pUninst->m_pRsCln;
    INT_PTR nRet         = IDOK;

    try {

        //
        // Enclose wait cursor in its own block of applicable
        // code. We want it gone before we Go Modal
        //
        {
            CWaitCursor cursor;
            CDialog dialog(IDD_SCAN_WAIT);
            dialog.Create(IDD_SCAN_WAIT);
            Sleep(1000); // allow the user to see the dialog for at
                         // least a second when the scan is very fast
            RsOptAffirmDw(pRsCln->ScanServer(&volCount));
        }

        if( volCount > 0 ) {

            m_dataLoss = TRUE;
            nRet = CDialog::DoModal();

        }

    } RsOptCatch( hr );
    return( nRet );
}

/*++

    Implements:

        CUninstallCheck::OnOk

    Routine Description:

        When the OK button is pushed, check the radio button. If the
        user wants everything removed, set a flag in the uninstall object
        to reflect this.
        When this flag is set, uninstall will remove all Remote Storage
        reparse points, all truncated files and the Remote Storage directory.
        A message box will give the user a final warning before removing data.

    Return Value:

        void

--*/
void CUninstallCheck::OnOK()
{

    TRACEFN("CUninstallCheck::OnOK");

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT  hr   = S_OK;
    CButton* pBtn = (CButton*)GetDlgItem(IDC_REMOVE_EVERYTHING);

    if (m_dataLoss)
    {
        try
        {
            if (1 == pBtn->GetCheck())
            {
                if (IDCANCEL == AfxMessageBox(IDS_POSSIBLE_DATA_LOSS, MB_ICONSTOP | MB_OKCANCEL))
                {
                    m_pUninst->m_removeRsData = FALSE;
                }
                else
                {
                    m_pUninst->m_removeRsData = TRUE;
                    CDialog::OnOK();
                }
            }
            else
            {
                m_pUninst->m_removeRsData = FALSE;
                CDialog::OnOK();
            }
        }
        RsOptCatch(hr);
    }
}

/*++

    Implements:

        CUninstallCheck::OnCancel

    Routine Description:

        When the Cancel button is pushed, the user has decided to unmanaged the
        volumes himself.  So, from this point on the admin and engine pieces should not
        be removed if requested.

    Return Value:

        void

--*/
void CUninstallCheck::OnCancel()
{
    m_pUninst->m_removeRsData = FALSE;

    CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\uninstal.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Uninstal.h

Abstract:

    Implementation of uninstall.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

    Carl Hagerstrom [carlh]   01-Sep-1998

        Added QueryChangeSelState and modified CompleteInstallation
        to force enabling of last access date updating.

    Carl Hagerstrom [carlh]   25-Sep-1998

        Added the check for and recovery from partial uninstalls when
        services will not stop.

--*/

#include "stdafx.h"
#include "Uninstal.h"
#include "UnInsChk.h"
#include "rsevents.h"
#include <mstask.h>

int StopServiceAndDependencies(LPCTSTR ServiceName);
HRESULT CallExeWithParameters(LPCTSTR pszEXEName, LPCTSTR pszParameters );


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRsUninstall::CRsUninstall()
{
    m_removeRsData = TRUE;
    m_stopUninstall = FALSE;
    m_win2kUpgrade = FALSE;
}

CRsUninstall::~CRsUninstall()
{

}

LPCTSTR
CRsUninstall::StringFromId( SHORT SubcomponentId )
{
    switch( SubcomponentId ) {

    case RSOPTCOM_ID_NONE:
    case RSOPTCOM_ID_ROOT:
        return( RSOPTCOM_SUB_ROOT );

    }

    return( TEXT("") );
}

SHORT
CRsUninstall::IdFromString( LPCTSTR SubcomponentId )
{
    if( !SubcomponentId ) {

        return( RSOPTCOM_ID_NONE );

    } else if( _tcsicmp( SubcomponentId, RSOPTCOM_SUB_ROOT ) == 0 ) {

        return( RSOPTCOM_ID_ROOT );

    }

    return( RSOPTCOM_ID_ERROR );
}

HBITMAP
CRsUninstall::QueryImage(
    IN SHORT SubcomponentId,
    IN SubComponentInfo /*WhichImage*/,
    IN WORD /*Width*/,
    IN WORD /*Height*/
    )
{
TRACEFN( "CRsUninstall::QueryImage" );
TRACE( _T("SubcomponentId = <%hd>"), SubcomponentId );

    HBITMAP retval = 0;
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );


    switch( SubcomponentId ) {

    case RSOPTCOM_ID_NONE:
    case RSOPTCOM_ID_ROOT:
        retval = ::LoadBitmap( AfxGetApp( )->m_hInstance, MAKEINTRESOURCE( IDB_RSTORAGE_SMALL ) );
        break;

    }
    return( retval );
}

BOOL 
CRsUninstall::QueryImageEx( 
    IN SHORT SubcomponentId, 
    IN OC_QUERY_IMAGE_INFO* /*pQueryImageInfo*/, 
    OUT HBITMAP *phBitmap 
    )
{
TRACEFNBOOL( "CRsUninstall::QueryImageEx" );
TRACE( _T("SubcomponentId = <%hd>, phBitmap = <0x%p>"), SubcomponentId, phBitmap );

    boolRet = FALSE;

    if (phBitmap) {
        *phBitmap = NULL;
        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

        switch( SubcomponentId ) {

        case RSOPTCOM_ID_NONE:
        case RSOPTCOM_ID_ROOT:
            *phBitmap = ::LoadBitmap( AfxGetApp( )->m_hInstance, MAKEINTRESOURCE( IDB_RSTORAGE_SMALL ) );
            if ((*phBitmap) != NULL) {
                boolRet = TRUE;
            }
            break;
        }
    }

    return (boolRet);
}

LONG
CRsUninstall::QueryStepCount(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFNLONG( "CRsUninstall::QueryStepCount" );
    DWORD retval = 2;
    return( retval );
}

BOOL
CRsUninstall::QueryChangeSelState(
    IN SHORT SubcomponentId,
    IN BOOL  SelectedState,
    IN DWORD Flags
    )
{
TRACEFNBOOL( "CRsUninstall::QueryChangeSelState" );

    HRESULT   hrRet   = S_OK;
    DWORDLONG opFlags = m_SetupData.OperationFlags;

    boolRet = TRUE;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {
        // When the user attempts to check the box for installing Remote Storage,
        // and updating last access date is disabled in the registry, force
        // the user to agree to changing the registry before the box is checked.
        // The message box does not appear during unattended install but the
        // registry will be changed anyway. The registry change occurs in
        // CompleteInstallation.

        if( SubcomponentId == RSOPTCOM_ID_ROOT
            && SelectedState
            && Flags & OCQ_ACTUAL_SELECTION ) {

            CLaDate lad;
            CLaDate::LAD_STATE ladState;

            RsOptAffirmDw( lad.GetLadState( &ladState ) );

            if( ladState == CLaDate::LAD_DISABLED ) {

                if( !( opFlags & SETUPOP_BATCH ) ) {

                    if( IDNO == AfxMessageBox( IDS_LA_DATE_CHANGE, MB_YESNO ) ) {

                        boolRet = FALSE;
                    }
                }
            }
        }
    } RsOptCatch( hrRet );

    if( hrRet != S_OK ) {

        // If the registry cannot be accessed, user will be
        // allowed to select Remote Storage install anyway.
        boolRet = TRUE;
    }

    return( boolRet );
}

DWORD
CRsUninstall::CalcDiskSpace(
    IN SHORT   SubcomponentId,
    IN BOOL    AddSpace,
    IN HDSKSPC hDiskSpace
    )
{
TRACEFNDW( "CRsUninstall::CalcDiskSpace" );

    dwRet = NO_ERROR;

    switch( SubcomponentId ) {

    case RSOPTCOM_ID_ROOT:
        dwRet = DoCalcDiskSpace( AddSpace, hDiskSpace, RSOPTCOM_SECT_INSTALL_ROOT );
        break;

    }
    return( dwRet );
}

DWORD
CRsUninstall::QueueFileOps(
    IN SHORT SubcomponentId,
    IN HSPFILEQ hFileQueue
    )
{
TRACEFNDW( "CRsUninstall::QueueFileOps" );


    HRESULT hrRet = S_OK;

    dwRet = NO_ERROR;


    RSOPTCOM_ACTION action = GetSubAction( SubcomponentId );

    if( !m_stopUninstall ) {        

        try {

            switch( SubcomponentId ) {

            case RSOPTCOM_ID_ROOT:

                switch( action ) {
    
                case ACTION_UPGRADE : 
                    {
                        CRsRegKey keyRSEngine;
    
                        // Check if Win2K services exist, if so - stop them
                        if( NO_ERROR == keyRSEngine.Open( HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_Engine"), KEY_QUERY_VALUE) ) {
                            m_win2kUpgrade = TRUE;
                            RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_Engine") ) );
                        }
                        if( NO_ERROR == keyRSEngine.Open( HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_File_System_Agent"), KEY_QUERY_VALUE) ) {
                            m_win2kUpgrade = TRUE;
                            RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_File_System_Agent") ) );
                        }
                        if( NO_ERROR == keyRSEngine.Open( HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_Subsystem"), KEY_QUERY_VALUE) ) {
                            m_win2kUpgrade = TRUE;
                            RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_Subsystem") ) );
                        }
                    
                        // Stop the current RS services
                        // Note: in case of upgrade from Win2K, these services don't exist but 
                        //  StopServiceAndDependencies ignores such a case (no error returned)
                        RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_Server") ) );
                        RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_User_Link") ) );
                    }

                    // fall through...
    
                case ACTION_INSTALL :                
    
                    RsOptAffirmDw( DoQueueFileOps( SubcomponentId, hFileQueue, RSOPTCOM_SECT_INSTALL_ROOT, RSOPTCOM_SECT_UNINSTALL_ROOT ) );
                    break;
                
                case ACTION_UNINSTALL :
                    {
                        AFX_MANAGE_STATE(AfxGetStaticModuleState());
                        CUninstallCheck dlg( this );
                        m_pRsCln = new CRsClnServer();
                        RsOptAffirmPointer( m_pRsCln );

                        if( dlg.DoModal() == IDOK ) {

                            // stop the services
                            RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_Server") ) );
                            RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_User_Link") ) );

                            // Queue the file operations
                            RsOptAffirmDw( DoQueueFileOps( SubcomponentId, hFileQueue, RSOPTCOM_SECT_INSTALL_ROOT, RSOPTCOM_SECT_UNINSTALL_ROOT ) );

                        } else {

                            m_stopUninstall = TRUE;

                        }
                    }
                    break;
    
                }

            }
    
        } RsOptCatch( hrRet );

        if( FAILED( hrRet ) ) {

            m_stopUninstall = TRUE;

        }

    }

    return( dwRet );
}

//
// On Install, register all our stuff that we want
//
DWORD
CRsUninstall::CompleteInstallation(
    IN SHORT SubcomponentId
    )
{
TRACEFNDW( "CRsUninstall::CompleteInstallation" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    HRESULT hrRet = S_OK;

    dwRet = NO_ERROR;

    RSOPTCOM_ACTION action = GetSubAction( SubcomponentId );
    if( m_stopUninstall ) {

        action = ACTION_NONE;
    }

    CString szStatus;

    switch( action ) {

    case ACTION_UPGRADE:
    case ACTION_INSTALL:

        switch( SubcomponentId ) {

        case RSOPTCOM_ID_ROOT:
            
            szStatus.LoadString( ( action == ACTION_INSTALL ) ? IDS_RS_INSTALL_SVCS : IDS_RS_UPGRADE_SVCS );
            SetProgressText( szStatus );
    
            // Change NtfsDisableLastAccessUpdate registry
            // value if it was previously set. Updating last
            // access date cannot be disabled or Remote Storage
            // will not work.
    
            try {
    
                CLaDate lad;
                CLaDate::LAD_STATE ladState;
    
                RsOptAffirmDw( lad.GetLadState( &ladState ) );
    
                if( ladState == CLaDate::LAD_DISABLED ) {
    
                    RsOptAffirmDw( lad.SetLadState( CLaDate::LAD_ENABLED ) );
                }
    
            } RsOptCatch( hrRet );
    
            if( hrRet != S_OK ) {
    
                // Failure to read or update registry is not serious
                // enough to fail installation.
                dwRet = NO_ERROR;
            }
    
            // Register the filter
            HRESULT hrRegister;
            BOOL registered = SetupInstallServicesFromInfSection( m_ComponentInfHandle, RSOPTCOM_SECT_INSTALL_FILTER, SPSVCINST_TAGTOFRONT );
            hrRegister = ( registered ) ? S_OK : HRESULT_FROM_WIN32( RsOptLastError );
    
            // If Rsfilter does not register correctly we need to set the error code.
            // Usually this is caused by the user not rebooting after unregistering RsFilter.
            // If it is marked for deletion then we cannot register it again. We also don't
            // want the component manager to think everything worked.
            if( FAILED( hrRegister ) ) {
                 
                if( FACILITY_WIN32 == HRESULT_FACILITY( hrRegister ) ) {
    
                    dwRet = HRESULT_CODE( hrRegister );
                    if( ERROR_SERVICE_EXISTS == dwRet ) {
    
                        dwRet = NO_ERROR;
    
                    }
    
                } else {
    
                    dwRet = ERROR_SERVICE_NOT_FOUND;
    
                }
    
                RsOptAffirmDw( dwRet );
    
            }
    
            // Register the dlls                
            CallDllEntryPoint( TEXT("RsEngPs.dll"),  "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsSubPs.dll"),  "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsServPs.dll"), "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsAdmin.dll"),  "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsCommon.dll"), "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsShell.dll"),  "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsJob.dll"),    "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsIdb.dll"),    "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsTask.dll"),   "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsMover.dll"),  "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsSub.dll"),    "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsFsa.dll"),    "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsEng.dll"),    "DllRegisterServer" );
    
            // Register the services
            CallExeWithParameters( TEXT("RsServ.exe"), TEXT(" /regserver") );
            CallExeWithParameters( TEXT("RsLnk.exe"), TEXT(" /regserver") );
    
            // Ensure NT Backup settings (exclude some RS files from backup)
            //
            // Note: In Whistler NTBackup, these setting apply only when the backup
            //  is a non-snapshot backup. In this case, we still want to exclude the files.
            //  In case of a snapshot backup, the exclude settings are determined by
            //  the writer class in the Engine.
            EnsureBackupSettings ();

            // If we get this far,
            // we should go ahead and set to reboot if needed
            if( ( S_OK == hrRegister ) && ( ACTION_INSTALL == action ) ) {
    
                // Tell the user they do need to reboot
                SetReboot();
    
            }

            // Add shortcut to start menu
            CString itemDesc, desc;
            itemDesc.LoadString( IDS_ITEM_DESCRIPTION );
            desc.LoadString( IDS_RS_DESCRIPTION );
            AddItem( CSIDL_COMMON_ADMINTOOLS, itemDesc, TEXT("%SystemRoot%\\System32\\RsAdmin.msc"), TEXT(""), TEXT("%HOMEDRIVE%%HOMEPATH%"), desc, 
                        IDS_ITEM_DESCRIPTION, IDS_RS_DESCRIPTION, TEXT("%SystemRoot%\\System32\\RsAdmin.dll"), 0 );

            break;

        }
        break;


    case ACTION_UNINSTALL:

        switch( SubcomponentId ) {

        case RSOPTCOM_ID_ROOT:

            // removing shortcut from start menu
            CString itemDesc;
            itemDesc.LoadString( IDS_ITEM_DESCRIPTION );
            DeleteItem( CSIDL_COMMON_ADMINTOOLS, itemDesc );
    
            try {
    
                // For some reason, rscommon.dll is not getting removed. This
                // will schedule it to be removed on the next system startup.
                
                CString path( getenv( "SystemRoot" ) );
                path += "\\system32\\rscommon.dll";
                RsOptAffirmStatus( MoveFileEx( path, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) );
    
            } RsOptCatch( hrRet );
    
            if( m_removeRsData ) {
    
                // user chose to remove all data managed by Remote Storage
                szStatus.LoadString( IDS_RS_REMOVE_SVCS );
                SetProgressText( szStatus );
    
                // remove reparse points and truncated files
                m_pRsCln->CleanServer();
                delete m_pRsCln;
    
                // remove our subdirectory
                //
                // TBD (ravisp): in a clustering environment the RemoteStorage directory
                // is relocatable. We would need to get the real metadata path
                // and blow it away
                //
                CallExeWithParameters( TEXT("CMD.EXE"), TEXT(" /C del %SystemRoot%\\system32\\RemoteStorage\\*.* /q") );
                CallExeWithParameters( TEXT("CMD.EXE"), TEXT(" /C rd %SystemRoot%\\system32\\RemoteStorage /s /q") );
            
            }
            break;

        }

        break;
    }


    TickGauge(  );

    return( dwRet );
}

void RemoveTasks()
{
TRACEFNHR( "RemoveTasks" ); 

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    CComPtr <ITaskScheduler>    pSchedAgent;            // Pointer to Scheduling Agent
    CComPtr <IEnumWorkItems>    pEnumWorkItems;         // Pointer to Scheduling Agent

    LPWSTR *rgpwszName;
    ULONG   celtFetched;

    CString creatorName;
    creatorName.LoadString( IDS_PRODUCT_NAME );

    try {

        hrRet = CoInitialize ( NULL );
        RsOptAffirmHr(hrRet);

        hrRet = CoCreateInstance( CLSID_CSchedulingAgent, 0, CLSCTX_SERVER,
                IID_ISchedulingAgent, (void **) &pSchedAgent ) ;
        RsOptAffirmHr(hrRet);
        
        pSchedAgent->Enum( &pEnumWorkItems );

        pEnumWorkItems->Next( 1, &rgpwszName , &celtFetched ) ;
        while( 1 == celtFetched ) {

            CComPtr <ITask> pTask;          // Pointer to a specific task
            CComPtr <IUnknown> pIU;
            LPWSTR pwszCreator;

            // using pSchedAgent->Activate( )
            // Get the task we're interested in
            if( S_OK == pSchedAgent->Activate( *rgpwszName, IID_ITask, &pIU) ) {

                // QI to the task interface
                hrRet = pIU->QueryInterface(IID_ITask, (void **) &pTask);
                RsOptAffirmHr(hrRet);

                //
                // If it matches then we need to delete it
                //
                pTask->GetCreator( &pwszCreator );

                // dereference
                pTask.Release();

                if( 0 == creatorName.Compare( pwszCreator ) ) {

                    pSchedAgent->Delete( *rgpwszName );
                    //then delete using pSchedAgent->Delete()
                    pEnumWorkItems->Reset();

                }
                CoTaskMemFree( pwszCreator );
                pwszCreator = 0;
            }

            // Free the memory from the Next
            CoTaskMemFree( *rgpwszName );
            rgpwszName = 0;
            pEnumWorkItems->Next( 1, &rgpwszName, &celtFetched ) ;

        }

    } RsOptCatch( hrRet );
}

//
// On Uninstall, unregister everything and get us cleaned up
//
DWORD
CRsUninstall::AboutToCommitQueue(
    IN SHORT SubcomponentId
    )
{
TRACEFNHR( "CRsUninstall::AboutToCommitQueue" );

    RSOPTCOM_ACTION action = GetSubAction( SubcomponentId );
    if( m_stopUninstall ) {        

        action = ACTION_NONE;
    }

    CString szStatus;
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        switch( action ) {
        case ACTION_INSTALL:
            break;

        case ACTION_UNINSTALL:

            switch( SubcomponentId ) {

            case RSOPTCOM_ID_ROOT:

                // remove our entries from Directory Services
                // MGL: To do 
                // Remove Display specifier for our node and our node on the computer
                // CallDllEntryPoint( TEXT("RsConn.dll"),   "RsDirectoryServiceUninstall" );
    
                szStatus.LoadString( IDS_RS_REMOVE_SVCS );
                SetProgressText( szStatus );
    
                // Unregister the filter and indicate that the system must be rebooted
                SetupInstallServicesFromInfSection( m_ComponentInfHandle, RSOPTCOM_SECT_UNINSTALL_FILTER, 0 );
                SetReboot();
    
                // Unregister the services
                CallExeWithParameters( TEXT("RsServ.exe"), TEXT(" /unregserver") );
                CallExeWithParameters( TEXT("RsLnk.exe"), TEXT(" /unregserver") );
    
                // Unregister the dlls              
                CallDllEntryPoint( TEXT("RsEngPs.dll"),  "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsSubPs.dll"),  "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsServPs.dll"), "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsAdmin.dll"),  "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsShell.dll"),  "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsJob.dll"),    "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsIdb.dll"),    "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsTask.dll"),   "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsMover.dll"),  "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsSub.dll"),    "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsFsa.dll"),    "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsEng.dll"),    "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsCommon.dll"), "DllUnregisterServer" );
    
                // remove our jobs from the job scheduler if we are removing the 
                // Remote Storage Data.
                if( m_removeRsData ) {
    
                    RemoveTasks();
    
                }

                break;

            }
            break;

        case ACTION_UPGRADE:

            switch( SubcomponentId ) {

            case RSOPTCOM_ID_ROOT:

                // Check if this is an upgrade from Win2K, if so:
                //  1. Unregister obsolete services
                //  2. Delete obsolete binary files
                if (m_win2kUpgrade) {
                    CallExeWithParameters( TEXT("RsEng.exe"), TEXT(" /unregserver") );
                    CallExeWithParameters( TEXT("RsFsa.exe"), TEXT(" /unregserver") );
                    CallExeWithParameters( TEXT("RsSub.exe"), TEXT(" /unregserver") );

                    CString path( getenv( "SystemRoot" ) );
                    path += TEXT("\\system32\\");
                    CString fileName = path;
                    fileName += TEXT("RsEng.exe");
                    DeleteFile(fileName);
                    fileName = path;
                    fileName += TEXT("rsFsa.exe");
                    DeleteFile(fileName);
                    fileName = path;
                    fileName += TEXT("RsSub.exe");
                    DeleteFile(fileName);
                }

                break;

            }
            break;

        }

    } RsOptCatch( hrRet ) ;
        
    TickGauge(  );

    return( SUCCEEDED( hrRet ) ? NO_ERROR : HRESULT_CODE( hrRet ) );
}

//
// If there is a problem with install or uninstall which might leave it
// in a partially installed or uninstalled state, set the subcomponent
// state to redo this install or uninstall.
//
SubComponentState
CRsUninstall::QueryState(
    IN SHORT SubcomponentId
    )
{
TRACEFN( "CRsUninstall::QueryState" );

    SubComponentState retval = SubcompUseOcManagerDefault;
    RSOPTCOM_ACTION   action = GetSubAction( SubcomponentId );

    //
    // Need to check and see if we are upgrading from previous to
    // 393 build which had rsengine entry, but no rstorage entry.
    //
    if( RSOPTCOM_ID_ROOT == SubcomponentId ) {

        BOOL originalState = QuerySelectionState( SubcomponentId, OCSELSTATETYPE_ORIGINAL );
        if( !originalState ) {

            CRsRegKey keyRSEngine;
            LONG regRet = keyRSEngine.Open( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents") );
            if( NO_ERROR == regRet ) {

                DWORD engineState;
                regRet = keyRSEngine.QueryValue( engineState, TEXT("rsengine") );

                if( ( NO_ERROR == regRet ) && engineState ) {

                    //
                    // Had old style engine entry, and was on, so do fix up
                    //
                    retval = SubcompOn;
                    regRet = keyRSEngine.SetValue( engineState, TEXT("rstorage") );
                    if( NO_ERROR == regRet ) {

                        keyRSEngine.DeleteValue( TEXT("rsengine") );
                        keyRSEngine.DeleteValue( TEXT("rsui") );

                    }
                }
            }
        }
    }

    switch( action ) {

    case ACTION_UPGRADE:
    case ACTION_INSTALL:

        if( m_stopUninstall ) {

            retval = SubcompOff;
        }
        break;

    case ACTION_UNINSTALL:

        if( m_stopUninstall ) {

            retval = SubcompOn;
        }
        break;
    }

    return( retval );
}

//
//Routine Description:
//    Stop the named service and all those services which depend upon it
//
//Arguments:
//    ServiceName (Name of service to stop)
//
//Return Status:
//    TRUE - Indicates service successfully stopped
//    FALSE - Timeout occurred.
//
int StopServiceAndDependencies(LPCTSTR ServiceName)
{
TRACEFNHR( "StopServiceAndDependencies" );
TRACE( _T("ServiceName <%s>"), ServiceName );

    DWORD          err = NO_ERROR;
    SC_HANDLE      hScManager = 0;
    SC_HANDLE      hService = 0;
    SERVICE_STATUS statusService;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        //
        // Open a handle to the Service.
        //
        hScManager = OpenSCManager( NULL,NULL,SC_MANAGER_CONNECT );
        RsOptAffirmStatus( hScManager );

        hService = OpenService(hScManager,ServiceName,SERVICE_QUERY_STATUS | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_STOP | SERVICE_QUERY_CONFIG );
        if( !hService ) {

            err = GetLastError();
            RsOptAffirm( ERROR_SERVICE_DOES_NOT_EXIST == err, HRESULT_FROM_WIN32( err ) );
            RsOptThrow( S_OK );

        }


        //
        // Ask the service to stop.
        //
        if( !ControlService( hService, SERVICE_CONTROL_STOP, &statusService) ) {

            err = GetLastError();
            switch( err ) {

            case ERROR_DEPENDENT_SERVICES_RUNNING:
            {
                //
                // If there are dependent services running,
                //  determine their names and stop them.
                //

                BYTE ConfigBuffer[4096];
                LPENUM_SERVICE_STATUS ServiceConfig = (LPENUM_SERVICE_STATUS) &ConfigBuffer;
                DWORD BytesNeeded, ServiceCount, ServiceIndex;

                //
                // Get the names of the dependent services.
                //
                RsOptAffirmStatus(
                    EnumDependentServices( hService, SERVICE_ACTIVE, ServiceConfig, sizeof(ConfigBuffer), &BytesNeeded, &ServiceCount ) );

                //
                // Stop those services.
                //
                for( ServiceIndex = 0; ServiceIndex < ServiceCount; ServiceIndex++ ) {

                    StopServiceAndDependencies( ServiceConfig[ServiceIndex].lpServiceName );

                }

                //
                // Ask the original service to stop.
                //
                RsOptAffirmStatus( ControlService( hService, SERVICE_CONTROL_STOP, &statusService ) );

                break;
            }

            case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
            case ERROR_SERVICE_NOT_ACTIVE:

                //
                // check if the service is already stopped..
                //
                RsOptAffirmStatus( QueryServiceStatus( hService, &statusService ) );

                if( SERVICE_STOPPED == statusService.dwCurrentState || SERVICE_STOP_PENDING == statusService.dwCurrentState ) {

                    RsOptThrow( S_OK );

                }
                // Fall through

            default:
                RsOptThrow( HRESULT_FROM_WIN32( err ) );

            }

        }

        //
        // Loop waiting for the service to stop.
        //
        for( DWORD Timeout = 0; Timeout < 45; Timeout++ ) {

            //
            // Return or continue waiting depending on the state of
            //  the service.
            //
            if( SERVICE_STOPPED == statusService.dwCurrentState ) {

                break;

            }

            //
            // Wait a second for the service to finish stopping.
            //
            Sleep( 1000 );

            //
            // Query the status of the service again.
            //
            RsOptAffirmStatus( QueryServiceStatus( hService, &statusService ) );

        }

        if( SERVICE_STOPPED != statusService.dwCurrentState ) {

            RsOptThrow( HRESULT_FROM_WIN32( ERROR_SERVICE_REQUEST_TIMEOUT ) );

        }

    } RsOptCatch( hrRet );

    if( hScManager )  CloseServiceHandle( hScManager );
    if( hService )    CloseServiceHandle( hService );

    if ( FAILED( hrRet ) ) {

        CString message;
        AfxFormatString1( message, IDS_CANNOT_STOP_SERVICES, ServiceName );
        AfxMessageBox( message, MB_OK | MB_ICONEXCLAMATION );
    }

    return( hrRet );
}


HRESULT
CallExeWithParameters(
    LPCTSTR pszEXEName,
    LPCTSTR pszParameters
    )
{
TRACEFNHR( "CallExeWithParameters" );
TRACE( _T("Exe <%s> Params <%s>"), pszEXEName, pszParameters );

    PROCESS_INFORMATION exeInfo;
    STARTUPINFO startupInfo;
    memset( &startupInfo, 0, sizeof( startupInfo ) );
        
    startupInfo.cb          = sizeof( startupInfo );
    startupInfo.wShowWindow = SW_HIDE;
    startupInfo.dwFlags     = STARTF_USESHOWWINDOW;
        
    CString exeCmd( pszEXEName );
    exeCmd += pszParameters;

    try {

        RsOptAffirmStatus( CreateProcess( 0, (LPWSTR)(LPCWSTR)exeCmd, 0, 0, FALSE, 0, 0, 0, &startupInfo, &exeInfo ) );
        RsOptAffirmStatus( WAIT_FAILED != WaitForSingleObject( exeInfo.hProcess, 30000 ) );

    } RsOptCatch( hrRet ) ;

    return( hrRet );
}

//
//Method Description:
//    Ensure that NT Backup Registry settings exclude some RS files from backup
//     Don't check faiures since we want to install even if there are errors here
//
void CRsUninstall::EnsureBackupSettings ()
{
    HKEY regKey = 0;
    WCHAR *regPath  = L"System\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup";

    // open backup key
    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, regPath, (DWORD)0, 
            KEY_ALL_ACCESS, &regKey) ) {

        // prepare strings

        //
        // Don't add the additional \0 at the end, the compiler will add 
        // the additional NULL. This ensures that when we use sizeof on the string
        // we get the right size (including 2 NULLs at the end)
        //
        WCHAR regData[] = L"%SystemRoot%\\System32\\RemoteStorage\\*.col\0"
                          L"%SystemRoot%\\System32\\RemoteStorage\\EngDb\\*\0"
                          L"%SystemRoot%\\System32\\RemoteStorage\\FsaDb\\*\0"
                          L"%SystemRoot%\\System32\\RemoteStorage\\Trace\\*\0";

        // set RS exclude values
        RegSetValueEx( regKey, RSS_BACKUP_NAME, (DWORD)0, REG_MULTI_SZ, (BYTE*)regData, sizeof(regData));
        
        // close opened key
        RegCloseKey (regKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\dll\makefile.inc ===
$(O)\RsOptCom.res: ..\res\RsOptCom.rc2   \

$(O)\PreComp.obj: ..\resource.h

$(O)\OptCom.obj   \
$(O)\RsOptCom.obj \
$(O)\StdAfx.obj   \
$(O)\UninsChk.obj \
$(O)\Uninstal.obj : $(O)\PreComp.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\uninstal.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Uninstal.h

Abstract:

    Implementation of uninstall.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/


#ifndef _UNINSTAL_H
#define _UNINSTAL_H

#pragma once

#include <rscln.h>
#include <ladate.h>

class CRsUninstall : public CRsOptCom
{
public:
    CRsUninstall();
    virtual ~CRsUninstall();

    virtual SHORT IdFromString( LPCTSTR SubcomponentId );
    virtual LPCTSTR StringFromId( SHORT SubcomponentId );
    void EnsureBackupSettings ();

    virtual
    HBITMAP
    QueryImage(
        IN SHORT SubcomponentId,
        IN SubComponentInfo WhichImage,
        IN WORD Width,
        IN WORD Height
        );

    virtual 
    BOOL 
    QueryImageEx( 
        IN SHORT SubcomponentId, 
        IN OC_QUERY_IMAGE_INFO *pQueryImageInfo, 
        OUT HBITMAP *phBitmap 
        );

    virtual
    DWORD
    CalcDiskSpace(
        IN SHORT SubcompentId,
        IN BOOL AddSpace,
        IN HDSKSPC hDiskSpace
        );

    virtual
    BOOL
    QueryChangeSelState(
        IN SHORT,
        IN BOOL,
        IN DWORD
    );

    virtual
    LONG
    QueryStepCount(
        IN SHORT SubcomponentId
    );

    virtual
    DWORD
    QueueFileOps(
        IN SHORT SubcomponentId,
        IN HSPFILEQ hFileQueue
        );

    virtual 
    DWORD 
    AboutToCommitQueue( 
        IN SHORT SubcomponentId 
        );

    virtual 
    DWORD 
    CompleteInstallation( 
        IN SHORT SubcomponentId 
        );

    virtual
    SubComponentState
    QueryState(
        IN SHORT SubcomponentId
        );

    CRsClnServer* m_pRsCln;
    BOOL m_removeRsData;       // TRUE if Remote Storage data should be removed.
                               // Set by CUninstallCheck.
    BOOL m_stopUninstall;      // Flag used to say the user has stopped the
                               // uninstall of the engine files
    BOOL m_win2kUpgrade;      // Flag used to indicate upgrading from Win2K services
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\rscln\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#undef _WIN32_IE
#define _WIN32_IE    0x0500
//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
}
extern "C" {
#include <ntrtl.h>
}
extern "C" {
#include <nturtl.h>
}

#include <rpdata.h>

#undef ASSERT
#define VC_EXTRALEAN
#include <afx.h>
#include <afxwin.h>
#include <atlbase.h>

#include "resource.h"
#include "rsopt.h"
#include "rstrace.h"
#include "rscln.h"
#include "rscln2.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\rscln\rsclnsrv.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsClnSrv.cpp

Abstract:

    Implementation of CRsClnServer.  This class represents a Remote
    Storage server whose local volumes are to be scanned for Remote
    Storage data and possibly cleaned. Cleaning means removing all
    Remote Storage reparse points truncated files from all local fixed
    disk volumes. CRsClnServer creates one or more instances of
    CRsClnVolume.

Author:

    Carl Hagerstrom [carlh]   20-Aug-1998

Revision History:

--*/

#include <stdafx.h>
#include <ntseapi.h>

/*++

    Implements: 

        CRsClnServer Constructor

    Routine Description: 

        Initializes list of volumes containing Remote Storage data.

--*/

CRsClnServer::CRsClnServer()
{
    TRACEFN("CRsClnServer::CRsClnServer");

    m_head    = (struct dirtyVolume*)0;
    m_tail    = (struct dirtyVolume*)0;
    m_current = (struct dirtyVolume*)0;
}

/*++

    Implements: 

        CRsClnServer Destructor

    Routine Description: 

        Cleans up memory used by list of volumes containging Remote
        Storage data.

--*/

CRsClnServer::~CRsClnServer()
{
    TRACEFN("CRsClnServer::~CRsClnServer");

    RemoveDirtyVolumes();
}

/*++

    Implements: 

        CRsClnServer::ScanServer

    Routine Description: 

        Scans this server for volumes containing Remote Storage data.
        If so, the sticky name and a user friendly name is added to
        a list of such volumes.

    Arguments: 

        volCount - returned: number of volumes containing Remote
                   Storage data

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::ScanServer(DWORD *volCount)
{
    TRACEFNHR("CRsClnServer::ScanServer");

    WCHAR   stickyName[MAX_STICKY_NAME];
    HANDLE  hScan = INVALID_HANDLE_VALUE;
    BOOL    hasData;

    *volCount = 0;
    
    try {    

        for( BOOL firstLoop = TRUE;; firstLoop = FALSE ) {

            if( firstLoop ) {

                hScan = FindFirstVolume(stickyName, (sizeof(stickyName) / sizeof(stickyName[0])) );
                RsOptAffirmHandle(hScan);

            } else {

                if( !FindNextVolume(hScan, stickyName, (sizeof(stickyName) / sizeof(stickyName[0])) ) ) {
                    break;
                }
            }

            CRsClnVolume volObj( this, stickyName );

            RsOptAffirmDw( volObj.VolumeHasRsData( &hasData ) );
            if( hasData ) {

                RsOptAffirmDw( AddDirtyVolume( stickyName, (LPTSTR)(LPCTSTR)volObj.GetBestName( ) ) );
                ++(*volCount);

            }
        }
    }
    RsOptCatch( hrRet );

    if (INVALID_HANDLE_VALUE != hScan) {
        FindVolumeClose( hScan );
    }

    return( hrRet );
}

/*++

    Implements: 

        CRsClnServer::FirstDirtyVolume

    Routine Description: 

        Return the name of the first volume on this server
        containing Remote Storage data.

    Arguments: 

        bestName - returned: user friendly volume name if one exists
                   or the sticky name

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::FirstDirtyVolume(WCHAR** bestName)
{
    TRACEFNHR("CRsClnServer::FirstDirtyVolume");

    *bestName = (WCHAR*)0;

    m_current = m_head;

    if (m_current)
    {
        *bestName = m_current->bestName;
    }

    return hrRet;
}

/*++

    Implements: 

        CRsClnServer::NextDirtyVolume

    Routine Description: 

        Return the name of the next volume on this server
        containing Remote Storage data.

    Arguments: 

        bestName - returned: user friendly volume name if one exists
                   or the sticky name

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::NextDirtyVolume(WCHAR** bestName)
{
    TRACEFNHR("CRsClnServer::NextDirtyVolume");

    m_current = m_current->next;

    if( m_current ) {

        *bestName = m_current->bestName;

    } else {

        *bestName = (WCHAR*)0;

    }

    return( hrRet );
}

/*++

    Implements: 

        CRsClnServer::RemoveDirtyVolumes()

    Routine Description: 

        Cleans up memory used by list of volumes containging Remote
        Storage data.

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::RemoveDirtyVolumes()
{
    TRACEFNHR("CRsClnServer::RemoveDirtyVolumes");

    struct dirtyVolume* p;
    struct dirtyVolume* pnext;

    for( p = m_head; p; p = pnext ) {

        pnext = p->next;
        delete p;
    }

    m_head    = (struct dirtyVolume*)0;
    m_tail    = (struct dirtyVolume*)0;
    m_current = (struct dirtyVolume*)0;

    return( hrRet );
}

/*++

    Implements: 

        CRsClnServer::CleanServer

    Routine Description: 

        For each volume on this server which contains Remote Storage data,
        remove all the Remote Storage reparse points and any truncated files.

     Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::CleanServer()
{
    TRACEFNHR("CRsClnServer::CleanServer");

    HANDLE              tokenHandle = 0;

    try {

        // Enable the backup operator privilege.  This is required to insure that we 
        // have full access to all resources on the system.
        TOKEN_PRIVILEGES    newState;
        HANDLE              pHandle;
        LUID                backupValue;
        pHandle = GetCurrentProcess();
        RsOptAffirmStatus( OpenProcessToken( pHandle, MAXIMUM_ALLOWED, &tokenHandle ) );

        // adjust backup token privileges
        RsOptAffirmStatus( LookupPrivilegeValueW( NULL, L"SeBackupPrivilege", &backupValue ) );
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        RsOptAffirmStatus( AdjustTokenPrivileges( tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL ) );


        // Do the cleaning
        for( m_current = m_head; m_current; m_current = m_current->next ) {

            CRsClnVolume volObj( this, m_current->stickyName );
            RsOptAffirmDw( volObj.RemoveRsDataFromVolume( ) );

        }

    } RsOptCatch( hrRet );

    if( tokenHandle )   CloseHandle( tokenHandle );

    //
    // And if we had errors on a file, 
    // show them up in a dialog
    //
    if( ! m_ErrorFileList.IsEmpty( ) ) {

        CRsClnErrorFiles dialog( &m_ErrorFileList );
        dialog.DoModal( );

    }

    return( hrRet );
}

/*++

    Implements: 

        CRsClnServer::AddDirtyVolume

    Routine Description: 

        Add the specified volume names to the list of volumes containing
        Remote Storage data.

    Arguments: 

        stickyName - long volume name guaranteed to exist for every volume
        bestName - user friendly volume name or sticky name if there is
                   no DOS drive letter or volume name

    Return Value:

        S_OK - Success
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::AddDirtyVolume(WCHAR* stickyName, WCHAR* bestName)
{
    TRACEFNHR("CRsClnServer::AddDirtyVolume");

    try {

        struct dirtyVolume* dv = new struct dirtyVolume;
        RsOptAffirmPointer(dv);

        wcscpy(dv->stickyName, stickyName);
        wcscpy(dv->bestName, bestName);
        dv->next = (struct dirtyVolume*)0;

        if (!m_head)
        {
            m_head = dv;
        }
        else
        {
            m_tail->next = dv;
        }
        m_tail = dv;

    } RsOptCatch( hrRet );

    return( hrRet );
}

/*++

    Implements: 

        CRsClnServer::AddErrorFile

    Routine Description: 

        Add the specified file name to the list of files that an error
        occurred on while trying to remove Remote Storage.

    Arguments: 

        FileName - Name of file to be added to the list

    Return Value:

        S_OK - Success
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT
CRsClnServer::AddErrorFile(
    CString& FileName
    )
{
TRACEFNHR( "CRsClnServer::AddErrorFile" );
TRACE( L"FileName = <%ls>", FileName );

    m_ErrorFileList.AddTail( FileName );

    return( hrRet );
}
/////////////////////////////////////////////////////////////////////////////
// CRsClnErrorFiles dialog


CRsClnErrorFiles::CRsClnErrorFiles(CRsStringList* pFileList)
    : CDialog(CRsClnErrorFiles::IDD)
{
    //{{AFX_DATA_INIT(CRsClnErrorFiles)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_ErrorFileList.AddHead( pFileList );
}


void CRsClnErrorFiles::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRsClnErrorFiles)
    DDX_Control(pDX, IDC_FILELIST, m_FileList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRsClnErrorFiles, CDialog)
    //{{AFX_MSG_MAP(CRsClnErrorFiles)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRsClnErrorFiles message handlers

BOOL CRsClnErrorFiles::OnInitDialog() 
{
    CDialog::OnInitDialog();

    //
    // Need to iterate through the list, adding each element to the listbox
    // and looking for the widest string so that we can set the horizontal
    // extent
    //
    int maxWidth = 0;
    CClientDC DC( &m_FileList );
    CFont* pFont    = m_FileList.GetFont( );
    CFont* pOldFont = DC.SelectObject( pFont );

    while( ! m_ErrorFileList.IsEmpty( ) ) {

        CString fileName = m_ErrorFileList.RemoveHead( );

        m_FileList.AddString( fileName );

        CSize extent = DC.GetTextExtent( fileName );
        if( extent.cx > maxWidth )  maxWidth = extent.cx;

    }
    
    DC.SelectObject( pOldFont );
    m_FileList.SetHorizontalExtent( maxWidth );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\rscln\rscln2.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsCln2.h

Abstract:

    This header is local to the RsCln module.  It contains defined constants
    and the class definitions for CRsClnVolume and CRsClnFile. See the
    implementation files for descriptions of these classes.

Author:

    Carl Hagerstrom   [carlh]   20-Aug-1998

Revision History:

--*/

#ifndef _RSCLN2_H
#define _RSCLN2_H

#include <stdafx.h>

#define MAX_VOLUME_NAME 64
#define MAX_FS_NAME     16
#define MAX_DOS_NAME    4

class CRsClnVolume
{
public:

    CRsClnVolume( CRsClnServer* pServer, WCHAR* StickyName );
    ~CRsClnVolume();

    HRESULT VolumeHasRsData( BOOL* );
    CString GetBestName( );
    HRESULT RemoveRsDataFromVolume( );

    HANDLE  GetHandle( );
    CString GetStickyName( );

private:

    HRESULT GetVolumeInfo( );
    HRESULT FirstRsReparsePoint(LONGLONG*, BOOL*);
    HRESULT NextRsReparsePoint(LONGLONG*, BOOL*);

    WCHAR       m_fsName[MAX_FS_NAME];
    WCHAR       m_bestName[MAX_STICKY_NAME];
    WCHAR       m_volumeName[MAX_VOLUME_NAME];
    WCHAR       m_dosName[MAX_DOS_NAME];
    CString     m_StickyName;

    DWORD       m_fsFlags;
    HANDLE      m_hRpi;
    HANDLE      m_hVolume;

    CRsClnServer* m_pServer;

};

class CRsClnFile
{
public:

    CRsClnFile( CRsClnVolume* pVolume, LONGLONG FileID );
    ~CRsClnFile();

    HRESULT RemoveReparsePointAndFile();
    CString GetFileName( );

    HRESULT ClearReadOnly( );
    HRESULT RestoreAttributes( );

private:

    HRESULT GetFileInfo( LONGLONG FileID );

    CString                 m_FileName;
    CString                 m_FullPath;
    CRsClnVolume*           m_pVolume;

    UCHAR                   m_ReparseData[ sizeof(REPARSE_DATA_BUFFER) + sizeof(RP_DATA) ];
    PREPARSE_DATA_BUFFER    m_pReparseData;
    PRP_DATA                m_pHsmData;

    FILE_BASIC_INFORMATION  m_BasicInfo;

};

#endif // _RSCLN2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\rscln\rsclnvol.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsClnVol.cpp

Abstract:

    Implements CRsClnVolume. This class represents a volume on a Remote
    Storage server which might contain Remote Storage files.  This class
    examines the volume for Remote Storage files and cleans it upon request.
    Cleaning means removing all Remote Storage reparse points and truncated
    files. CRsClnVolume creates zero or more instances of CRsClnFile and is
    created by CRsClnServer.

Author:

    Carl Hagerstrom [carlh]   20-Aug-1998

Revision History:

--*/

#include <stdafx.h>

/*++

    Implements: 

        CRsClnVolume Constructor

    Routine Description: 

        Initializes object.

--*/

CRsClnVolume::CRsClnVolume( CRsClnServer* pServer, WCHAR* StickyName ) :
    m_pServer( pServer ), m_StickyName( StickyName )
{
    TRACEFN("CRsClnVolume::CRsClnVolume");

    memset((void *)m_fsName,     0, sizeof(m_fsName));
    memset((void *)m_bestName,   0, sizeof(m_bestName));
    memset((void *)m_volumeName, 0, sizeof(m_volumeName));
    memset((void *)m_dosName,    0, sizeof(m_dosName));


    m_fsFlags = 0;
    m_hRpi    = INVALID_HANDLE_VALUE;
    m_hVolume = INVALID_HANDLE_VALUE;
}

/*++

    Implements: 

        CRsClnVolume Destructor

--*/

CRsClnVolume::~CRsClnVolume()
{
    TRACEFN("CRsClnVolume::~CRsClnVolume");

    if( INVALID_HANDLE_VALUE != m_hVolume )     CloseHandle( m_hVolume );
}

/*++

    Implements: 

        CRsClnVolume::VolumeHasRsData

    Routine Description: 

        Determines whether this volume contains Remote Storage data.

        If this volume is on a fixed local disk, and it is an
        NTFS volume which supports reparse points and sparce
        files, and it has at least one Remote Storage reparse point,
        it contains Remote Storage data.

    Arguments: 

        hasData - returned: whether volume contains Remote
                  Storage data

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnVolume::VolumeHasRsData(BOOL *hasData)
{
    TRACEFNHR("CRsClnVolume::VolumeHasRsData");

    LONGLONG fileReference;
    BOOL     foundOne;

    *hasData = FALSE;

    try {

        if( DRIVE_FIXED == GetDriveType( m_StickyName ) ) {

            RsOptAffirmDw( GetVolumeInfo( ) );

            if( _wcsicmp( m_fsName, L"NTFS" ) == 0 &&
                m_fsFlags & FILE_SUPPORTS_REPARSE_POINTS &&
                m_fsFlags & FILE_SUPPORTS_SPARSE_FILES ) {

                RsOptAffirmDw( FirstRsReparsePoint( &fileReference, &foundOne ) );

                if( foundOne ) {

                    *hasData = TRUE;

                }
            }
        }
    }
    RsOptCatch( hrRet );

    return hrRet;
}

/*++

    Implements: 

        CRsClnVolume::GetBestName

    Routine Description: 

        Returns the best user friendly name for this volume.  The best
        name is either the DOS drive letter if one exists, the user
        assigned volume name if one exists, or the sticky name which
        always exists.

    Arguments: 

        bestName - returned: user friendly volume name

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

CString CRsClnVolume::GetBestName( )
{
    TRACEFNHR("CRsClnVolume::GetBestName");

    return( m_bestName );
}

/*++

    Implements: 

        CRsClnVolume::RemoveRsDataFromVolume

    Routine Description: 

        Removes all Remote Storage data from this volume.

        - Opens this volume using the sticky name.
        - Enumerates each file in the reparse point index
          with a Remote Storage reparse point. In the reparse
          index, each file is represented by a number called the
          file reference.
        - Removes the reparse point and the file if it is
          truncated.

    Arguments: 


    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnVolume::RemoveRsDataFromVolume( )
{
    TRACEFNHR("CRsClnVolume::RemoveRsDataFromVolume");

    LONGLONG fileReference;
    BOOL     foundOne;

    try
    {
        RsOptAffirmDw( GetVolumeInfo( ) );

        for( BOOL firstLoop = TRUE;; firstLoop = FALSE ) {

            if( firstLoop ) {

                RsOptAffirmDw( FirstRsReparsePoint( &fileReference, &foundOne ) );

            } else {

                RsOptAffirmDw( NextRsReparsePoint( &fileReference, &foundOne ) );
            }

            if( !foundOne ) {

                break;
            }

            //
            // Just in case something strange happens in removing reparse
            // point or such, wrap in its own try block
            //
            HRESULT hrRemove = S_OK;
            try {

                CRsClnFile fileObj( this, fileReference );

                if( FAILED( fileObj.RemoveReparsePointAndFile( ) ) ) {

                    m_pServer->AddErrorFile( fileObj.GetFileName( ) );

                }

            } RsOptCatch( hrRemove );
            // Do not affirm hrRemove - we don't want to stop on an error

        }

    } RsOptCatch( hrRet );

    return( hrRet );
}

/*++

    Implements: 

        CRsClnVolume::GetVolumeInfo

    Routine Description: 

        Load information about this volume.

        - Get the sticky name and the user assigned volume name,
          if one exists.
        - See if there is a DOS drive letter for this volume.
          For each possible drive letter, see if it represents
          a volume whose sticky name matches this volume.
        - Choose the best user friendly volume name according
          to the following precedence: DOS drive letter, user
          assigned volume name, sticky name.

    Arguments: 


    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnVolume::GetVolumeInfo( )
{
    TRACEFNHR("CRsClnVolume::GetVolumeInfo");

    WCHAR   dosName[MAX_DOS_NAME];
    WCHAR   stickyName2[MAX_STICKY_NAME];
    DWORD   volumeSerial;
    DWORD   maxCompLen;
    BOOL    bStatus;

    try {

        bStatus = GetVolumeInformation( m_StickyName,
                                       m_volumeName,
                                       (sizeof(m_volumeName)) / (sizeof(m_volumeName[0])),
                                       &volumeSerial,
                                       &maxCompLen,
                                       &m_fsFlags,
                                       m_fsName,
                                       (sizeof(m_fsName)) / (sizeof(m_fsName[0])) 
                                       );
        RsOptAffirmStatus(bStatus);

        for (wcscpy(dosName, L"A:\\"); dosName[0] <= L'Z'; ++(dosName[0]))
        {
            if (GetVolumeNameForVolumeMountPoint(dosName,
                                                 stickyName2,
                                                 (sizeof(stickyName2) / sizeof(stickyName2[0])) ))
            {
                if( m_StickyName.CompareNoCase( stickyName2 ) == 0 )
                {
                    wcscpy(m_dosName, dosName);
                    break;
                }
            }
        }

        if (*m_dosName != L'\0')
        {
            wcscpy(m_bestName, m_dosName);
        }
        else if (*m_volumeName != L'\0')
        {
            wcscpy(m_bestName, m_volumeName);
        }
        else
        {
            wcscpy(m_bestName, m_StickyName);
        }

        m_hVolume = CreateFile( m_StickyName.Left( m_StickyName.GetLength() - 1 ),
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                (LPSECURITY_ATTRIBUTES)0,
                                OPEN_EXISTING,
                                (DWORD)0,
                                (HANDLE)0 );
        RsOptAffirmHandle( m_hVolume );

    }
    RsOptCatch(hrRet);

    return hrRet;
}

/*++

    Implements: 

        CRsClnVolume::FirstRsReparsePoint

    Routine Description: 

        Returns the file reference of the first file in the
        reparse point index which contains a Remote Storage
        reparse point, if one exists.

        - Construct the name of the reparse point index from
          the sticky name.
        - Open the index.
        - Read the first entry. If it is a Remote Storage
          entry, return it. Otherwise, try the next one.

    Arguments: 

        stickyName - long volume name
        fileReference - returned: file reference from first
                        Remote Storage reparse index entry.
                        The file reference is a number which
                        can be used to open a file.
        foundOne - returned: TRUE if there is at least one
                   Remote Storage reparse point

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnVolume::FirstRsReparsePoint(
    LONGLONG* fileReference,
    BOOL*     foundOne)
{
    TRACEFNHR("CRsClnVolume::FirstRsReparsePoint");

    NTSTATUS                       ntStatus;
    IO_STATUS_BLOCK                ioStatusBlock;
    FILE_REPARSE_POINT_INFORMATION reparsePointInfo;

    WCHAR rpiSuffix[] = L"\\$Extend\\$Reparse:$R:$INDEX_ALLOCATION";
    WCHAR rpiName[MAX_STICKY_NAME + (sizeof(rpiSuffix) / sizeof(WCHAR))];

    wcscpy(rpiName, m_StickyName);
    wcscat(rpiName, rpiSuffix);

    *foundOne = FALSE;

    try
    {
        m_hRpi = CreateFile(rpiName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            (LPSECURITY_ATTRIBUTES)0,
                            OPEN_EXISTING,
                            FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                            (HANDLE)0);

        if (m_hRpi != INVALID_HANDLE_VALUE)
        {
            ntStatus = NtQueryDirectoryFile(m_hRpi,
                                            (HANDLE)0,
                                            (PIO_APC_ROUTINE)0,
                                            (PVOID)0,
                                            &ioStatusBlock,
                                            &reparsePointInfo,
                                            sizeof(reparsePointInfo),
                                            FileReparsePointInformation, 
                                            TRUE,
                                            (PUNICODE_STRING)0,
                                            TRUE);

            if (ntStatus == STATUS_NO_MORE_FILES)
            {
                RsOptAffirmStatus(CloseHandle(m_hRpi));
            }
            else
            {
                RsOptAffirmNtStatus(ntStatus);

                if (reparsePointInfo.Tag == IO_REPARSE_TAG_HSM)
                {
                    *fileReference = reparsePointInfo.FileReference;
                    *foundOne = TRUE;
                }
                else
                {
                    RsOptAffirmDw(NextRsReparsePoint(fileReference, foundOne));
                }
            }
        }
    }
    RsOptCatch(hrRet);

    return hrRet;
}

/*++

    Implements: 

        CRsClnVolume::NextRsReparsePoint

    Routine Description: 

        Continue searching the reparse point index on this volume and
        return the file reference for the next Remote Storage reparse
        point.

    Arguments: 

        fileReference - returned: file reference from first
                        Remote Storage reparse index entry.
                        The file reference is a number which
                        can be used to open a file.
        foundOne - returned: FALSE if there are no more Remote
                   Storage reparse points

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnVolume::NextRsReparsePoint(
    LONGLONG* fileReference,
    BOOL*     foundOne)
{
    TRACEFNHR("CRsClnVolume::NextRsReparsePoint");

    NTSTATUS                       ntStatus;
    IO_STATUS_BLOCK                ioStatusBlock;
    FILE_REPARSE_POINT_INFORMATION reparsePointInfo;

    *foundOne = FALSE;

    try
    {
        for (;;)
        {
            ntStatus = NtQueryDirectoryFile(m_hRpi,
                                            (HANDLE)0,
                                            (PIO_APC_ROUTINE)0,
                                            (PVOID)0,
                                            &ioStatusBlock,
                                            &reparsePointInfo,
                                            sizeof(reparsePointInfo),
                                            FileReparsePointInformation, 
                                            TRUE,
                                            (PUNICODE_STRING)0,
                                            FALSE);

            if (ntStatus == STATUS_NO_MORE_FILES)
            {
                RsOptAffirmStatus(CloseHandle(m_hRpi));
                break;
            }
            else
            {
                RsOptAffirmNtStatus(ntStatus);

                if (reparsePointInfo.Tag == IO_REPARSE_TAG_HSM)
                {
                    *fileReference = reparsePointInfo.FileReference;
                    *foundOne = TRUE;
                    break;
                }
            }
        }
    }
    RsOptCatch(hrRet);

    return hrRet;
}

/*++

    Implements: 

        CRsClnVolume::GetHandle

    Routine Description: 

        Returns a handle to the volume.

    Arguments: 


    Return Value:

        Volume HANDLE

--*/

HANDLE CRsClnVolume::GetHandle( )
{
    return( m_hVolume );
}

/*++

    Implements: 

        CRsClnVolume::GetStickyName

    Routine Description: 

        Returns the sticky name of the volume.

    Arguments: 


    Return Value:

        Volume sticky name

--*/

CString CRsClnVolume::GetStickyName( )
{
    return( m_StickyName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\rsoptcom\rscln\rsclnfil.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsClnFil.cpp

Abstract:

    Implementation of CRsClnFile. This class represents a file on
    a local volume of a Remote Storage server, which is going to be
    cleaned.  Cleaning means removing the file if it has been truncated
    and removing its reparse point. Each instance of CRsClnFile is created
    by CRsClnVolume.

Author:

    Carl Hagerstrom [carlh]   20-Aug-1998

Revision History:

--*/

#include <stdafx.h>

/*++

    Implements:
    
        CRsClnFile Constructor

    Routine Description: 

        Loads file information.

    Arguments: 

        hVolume - handle of volume on which this file resides
        fileReference - file reference for this file.  This is
                        a numerical handle which can be used
                        to uniquely identify and open a file.

--*/

CRsClnFile::CRsClnFile( 
    IN CRsClnVolume* pVolume,
    IN LONGLONG      FileReference
    ) :
    m_pVolume( pVolume )
{
TRACEFN( "CRsClnFile::CRsClnFile" );

    m_pReparseData = 0;
    m_pHsmData     = 0;

    RsOptAffirmDw( GetFileInfo( FileReference ) );
}

/*++

    Implements:

        CRsClnFile Destructor

--*/

CRsClnFile::~CRsClnFile( )
{
TRACEFN( "CRsClnFile::~CRsClnFile" );
}

/*++

    Implements: 

        CRsClnFile::RemoveReparsePointAndFile

    Routine Description: 

        Removes the reparse point for this file and removes
        the file itself if it has been truncated.

        - Read the reparse point for this file.
        - Determine from reparse data whether the file has been truncated.
        - If truncated, close and remove it.
        - If not truncated, remove reparse point and close file.

    Arguments: 

        stickyName - name of volume on which this file resides

    Return Value:

        S_OK - success
        E_*  - any unexpected exceptions from lower level routines

--*/

HRESULT
CRsClnFile::RemoveReparsePointAndFile(
    )
{
TRACEFNHR( "CRsClnFile::RemoveReparsePointAndFile" );
    
    DWORD  actualSize;
    BOOL   bStatus;
    HANDLE hFile = INVALID_HANDLE_VALUE;


    try {

        RsOptAffirmDw( ClearReadOnly( ) );

        if ( RP_FILE_IS_TRUNCATED( m_pHsmData->data.bitFlags ) ) {

            //
            // Clear the file attributes in case they are read only
            //
            RsOptAffirmStatus( DeleteFile( m_FullPath ) );

        } else {

            hFile = CreateFile( m_FullPath,
                                FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                0,
                                OPEN_EXISTING,
                                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,
                                0 );

            RsOptAffirmHandle( hFile );

            //
            // Set the time flags so that when we close the handle the
            // time are not updated on the file and the FileAttributes 
            // indicate the file is offline
            //
            IO_STATUS_BLOCK         ioStatusBlock;
            FILE_BASIC_INFORMATION  basicInfo;

            RsOptAffirmNtStatus( NtQueryInformationFile( hFile,
                                                         &ioStatusBlock,
                                                         (PVOID) &basicInfo,
                                                         sizeof( basicInfo ),
                                                         FileBasicInformation ) );

            basicInfo.CreationTime.QuadPart   = -1;
            basicInfo.LastAccessTime.QuadPart = -1;
            basicInfo.LastWriteTime.QuadPart  = -1;
            basicInfo.ChangeTime.QuadPart     = -1;

            RsOptAffirmNtStatus( NtSetInformationFile( hFile,
                                                       &ioStatusBlock,
                                                       (PVOID)&basicInfo,
                                                       sizeof( basicInfo ),
                                                       FileBasicInformation ) );

            //
            // Nuke the reparse point
            //
            m_pReparseData->ReparseTag        = IO_REPARSE_TAG_HSM;
            m_pReparseData->ReparseDataLength = 0;

            bStatus = DeviceIoControl( hFile,
                                       FSCTL_DELETE_REPARSE_POINT,
                                       (LPVOID) m_pReparseData,
                                       REPARSE_DATA_BUFFER_HEADER_SIZE,
                                       (LPVOID) 0,
                                       (DWORD)  0,
                                       &actualSize,
                                       (LPOVERLAPPED) 0 );

            RsOptAffirmStatus( bStatus );

        }

    } RsOptCatch( hrRet );

    if( INVALID_HANDLE_VALUE != hFile )   CloseHandle( hFile );

    if( ! RP_FILE_IS_TRUNCATED( m_pHsmData->data.bitFlags ) ) {

        //
        // Restore file attributes
        //
        RestoreAttributes( );

    }

    return( hrRet );
}

/*++

    Implements: 

        CRsClnFile::GetFileInfo

    Routine Description: 

        Obtain file information for file specified by volume and
        file reference.

        - Open file using volume handle and file reference.
        - Obtain the file name and the length of the file name.
          Since the length of the file name is unknown the first time
          NtQueryInformationFile is called, it might have to be called
          again once the correct buffer size can be determined.

    Arguments: 

        hVolume - handle of volume on which this file resides
        fileReference - file reference for this file.  This is
                        a numerical handle which can be used
                        to uniquely identify and open a file.

    Return Value:

        S_OK - Success
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT
CRsClnFile::GetFileInfo( 
    IN LONGLONG fileReference
    )
{
TRACEFNHR( "CRsClnFile::GetFileInfo" );

    UNICODE_STRING         objectName;
    OBJECT_ATTRIBUTES      objectAttributes;
    NTSTATUS               ntStatus;
    IO_STATUS_BLOCK        ioStatusBlock;
    PFILE_NAME_INFORMATION pfni;
    HANDLE                 hFile = INVALID_HANDLE_VALUE;
    DWORD                  actualSize;
    ULONG                  fileNameLength;
    PVOID                  fileNameInfo = 0;

    m_pReparseData = (PREPARSE_DATA_BUFFER) m_ReparseData;
    m_pHsmData     = (PRP_DATA)&( m_pReparseData->GenericReparseBuffer.DataBuffer[0] );

    try {
        
        RtlInitUnicodeString( &objectName, (WCHAR*)&fileReference );
        objectName.Length = 8;
        objectName.MaximumLength = 8;

        HANDLE hVolume = m_pVolume->GetHandle( );
        RsOptAffirmHandle( hVolume );
        InitializeObjectAttributes( &objectAttributes,
                                    &objectName,
                                    OBJ_CASE_INSENSITIVE,
                                    hVolume,
                                    (PVOID)0 );

        ULONG desiredAccess = FILE_READ_ATTRIBUTES;
        ULONG shareAccess   = FILE_SHARE_READ | FILE_SHARE_WRITE;
        ULONG createOptions = FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT;
        ntStatus = NtCreateFile( &hFile,
                                 desiredAccess,
                                 &objectAttributes,
                                 &ioStatusBlock,
                                 (PLARGE_INTEGER)0,
                                 FILE_ATTRIBUTE_NORMAL,
                                 shareAccess,
                                 FILE_OPEN,
                                 createOptions,
                                 (PVOID)0,
                                 (ULONG)0 );
        RsOptAffirmNtStatus( ntStatus );

        RsOptAffirmNtStatus( NtQueryInformationFile( hFile,
                                                     &ioStatusBlock,
                                                     (PVOID) &m_BasicInfo,
                                                     sizeof( m_BasicInfo ),
                                                     FileBasicInformation ) );
        //
        // Get the file name
        //
        size_t bufSize  = 256;
        fileNameInfo = malloc( bufSize );
        RsOptAffirmAlloc( fileNameInfo );

        ntStatus = NtQueryInformationFile( hFile,
                                           &ioStatusBlock,
                                           fileNameInfo,
                                           bufSize - sizeof(WCHAR),
                                           FileNameInformation );

        if( ntStatus == STATUS_BUFFER_OVERFLOW ) {

            pfni = (PFILE_NAME_INFORMATION)fileNameInfo;
            bufSize = sizeof(ULONG) + pfni->FileNameLength + sizeof(WCHAR);

            PVOID tmpFileNameInfo = realloc( fileNameInfo, bufSize );
            if( !tmpFileNameInfo ) {
                
                free( fileNameInfo );
                fileNameInfo = 0;

            } else {

                fileNameInfo = tmpFileNameInfo;

            }


            RsOptAffirmAlloc( fileNameInfo );

            RsOptAffirmNtStatus( NtQueryInformationFile( hFile,
                                                         &ioStatusBlock,
                                                         fileNameInfo,
                                                         bufSize,
                                                         FileNameInformation ) );

        } else {

            RsOptAffirmNtStatus( ntStatus );
        }

        pfni = (PFILE_NAME_INFORMATION) fileNameInfo;
        fileNameLength = pfni->FileNameLength / (ULONG)sizeof(WCHAR);
        pfni->FileName[ fileNameLength ] = L'\0';
        m_FileName = pfni->FileName;
        m_FullPath = m_pVolume->GetStickyName( ) + m_FileName;

        //
        // And grab the reparse point data
        //
        BOOL bStatus = DeviceIoControl( hFile,
                                        FSCTL_GET_REPARSE_POINT,
                                        (LPVOID) 0,
                                        (DWORD)  0,
                                        (LPVOID) m_ReparseData,
                                        (DWORD)  sizeof(m_ReparseData),
                                        &actualSize,
                                        (LPOVERLAPPED) 0 );
        RsOptAffirmStatus( bStatus );

    } RsOptCatch( hrRet );

    if( INVALID_HANDLE_VALUE != hFile )    CloseHandle( hFile );
    if( fileNameInfo )                     free( fileNameInfo );

    return( hrRet );
}


CString CRsClnFile::GetFileName( )
{
    CString displayName;

    displayName = m_pVolume->GetBestName( );
    displayName += m_FileName.Mid( 1 ); // Gotta strip first backslash
    
    return( displayName );
}


HRESULT CRsClnFile::ClearReadOnly( )
{
TRACEFNHR( "CRsClnFile::ClearReadOnly" );
    
    try {

        RsOptAffirmStatus(
            SetFileAttributes( m_FullPath,
                               ( m_BasicInfo.FileAttributes & ~FILE_ATTRIBUTE_READONLY ) | FILE_ATTRIBUTE_NORMAL ) );

    } RsOptCatch( hrRet );

    return( hrRet );
}


HRESULT CRsClnFile::RestoreAttributes( )
{
TRACEFNHR( "CRsClnFile::RestoreAttributes" );
    
    try {

        RsOptAffirmStatus(
            SetFileAttributes( m_FullPath,
                               ( m_BasicInfo.FileAttributes & ~FILE_ATTRIBUTE_OFFLINE ) | FILE_ATTRIBUTE_NORMAL ) );

    } RsOptCatch( hrRet );

    return( hrRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\shellext\hsmshell.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HSMShell.cpp

Abstract:

    Base file for HSM shell extensions

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/

  
#include "stdafx.h"

CComModule  _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_PrDrive, CPrDrive)
END_OBJECT_MAP()

class CHSMShellApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CHSMShellApp theApp;

BOOL CHSMShellApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);
    return CWinApp::InitInstance();
}

int CHSMShellApp::ExitInstance()
{
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    LONG lockCount = _Module.GetLockCount(); // For debugging
    return( lockCount == 0 ) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    // registers object
    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        hr = _Module.RegisterServer( FALSE );
        CoUninitialize( );
    }

    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\shellext\stdafx.h ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Base include file

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/


#ifndef STDAFX_H
#define STDAFX_H

#pragma once

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>         // MFC support for Windows Common Controls
#include <afxdisp.h>
#include <shlobj.h>
#define WSB_TRACE_IS        WSB_TRACE_BIT_UI
#include "wsb.h"
#include "Fsa.h"                    // Fsa interface
#include "HSMConn.h"
#include "RsUtil.h"

#include "resource.h"
#include "hsmshell.h"
#include "PrDrive.h"

#define HSMADMIN_MIN_MINSIZE        2
#define HSMADMIN_MAX_MINSIZE        32000

#define HSMADMIN_MIN_FREESPACE      0
#define HSMADMIN_MAX_FREESPACE      99

#define HSMADMIN_MIN_INACTIVITY     0
#define HSMADMIN_MAX_INACTIVITY     999

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\shellext\stdafx.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.cpp

Abstract:

    grab implementations for ATL and such

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#pragma warning(4:4701)
#include <atlimpl.cpp>
#pragma warning(3:4701)

#include "RsUtil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\shellext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HSMShell.rc
//
#define IDS_PROJNAME                    100
#define IDS_ERR_MINSIZE_RANGE           101
#define IDR_PRDRIVE                     102
#define IDS_PAGETITLE                   103
#define IDS_NO_FSA                      104
#define IDS_NOT_MANAGED                 105
#define IDS_NOT_NTFS                    106
#define IDS_HELPFILEPOPUP               107
#define IDD_PRDRIVE                     201
#define IDD_PRDRIVEX                    202
#define IDI_BLUESAKKARA                 203
#define IDC_EDIT_LEVEL                  205
#define IDC_EDIT_SIZE                   208
#define IDC_EDIT_TIME                   209
#define IDC_STATIC_TOTAL_4DIGIT         210
#define IDC_STATIC_FREE_4DIGIT          211
#define IDC_STATIC_REMOTE_STORAGE_4DIGIT 212
#define IDC_STATIC_CACHED_4DIGIT        213
#define IDC_STATIC_LOCAL_4DIGIT         214
#define IDC_STATIC_LOCAL_PCT            215
#define IDC_STATIC_CACHED_PCT           216
#define IDC_SPIN_LEVEL                  217
#define IDC_SPIN_SIZE                   218
#define IDC_SPIN_TIME                   219
#define IDC_STATIC_FREE_PCT             220
#define IDC_STATIC_ERROR                245
#define IDC_STATIC_STATS_LABEL          246
#define IDC_STATIC_TOTAL_4DIGIT_LABEL   250
#define IDC_STATIC_FREE_4DIGIT_LABEL    251
#define IDC_STATIC_FREE_PCT_UNIT        252
#define IDC_STATIC_CACHED_4DIGIT_LABEL  253
#define IDC_STATIC_LOCAL_4DIGIT_LABEL   254
#define IDC_STATIC_LOCAL_4DIGIT_HELP    255
#define IDC_STATIC_CACHED_PCT_UNIT      256
#define IDC_STATIC_LOCAL_PCT_UNIT       257
#define IDC_EDIT_LEVEL_LABEL            258
#define IDC_EDIT_LEVEL_UNIT             259
#define IDC_EDIT_SIZE_LABEL             260
#define IDC_EDIT_SIZE_UNIT              261
#define IDC_EDIT_TIME_LABEL             262
#define IDC_EDIT_TIME_UNIT              263

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         264
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\shellext\dll\makefile.inc ===
$(O)\hsmshell.res: ..\res\nodehsma.ico    \
                   ..\res\prdrive.rgs      

$(O)\hsmshell_i.c: ..\$(O)\hsmshell_i.c
    copy ..\$(O)\hsmshell_i.c $(O)\.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\shellext\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=gui
MINORCOMP=ShellExt

INCLUDES=$(BASEP_HSM_DIR)\inc;$(BASEP_HSM_DIR)\inc\$(O);..;..\$(O);..\PropPage;..\..\inc

C_DEFINES=$(C_DEFINES)

UMTYPE=windows

USE_NATIVE_EH=1

#USE_MSVCRT40=1
USE_MFCUNICODE=1
MFC_USRDLL=1
MFC_VER=42
USE_ATL=1

MIDL_UUIDDIR=$(O)
PASS0_SOURCEDIR=$(O)
PASS0_HEADERDIR=..\$(O)
MIDL_TLBDIR=$(O)

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_PCH=precomp.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\shellext\proppage\prdrive.h ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrDrive.h

Abstract:

    Base file for HSM shell extensions on drives

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/


#ifndef __PRDRIVE_H_
#define __PRDRIVE_H_

#define NO_STATE        0
#define REMOTE          1
#define NO_FSA          2
#define NOT_MANAGED     3
#define MANAGED         4
#define MULTI_SELECT    5
#define NOT_NTFS        6
#define NOT_ADMIN       7

/////////////////////////////////////////////////////////////////////////////
// CPrDrive
class  CPrDrive : 
    public CComCoClass<CPrDrive, &CLSID_PrDrive>,
    public IShellPropSheetExt,
    public IShellExtInit,
    public CComObjectRoot
{
public:

DECLARE_REGISTRY_RESOURCEID( IDR_PRDRIVE )
DECLARE_NOT_AGGREGATABLE( CPrDrive )

    CPrDrive() { };

BEGIN_COM_MAP(CPrDrive)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY(IShellExtInit)
END_COM_MAP()

protected:
    CComPtr<IDataObject> m_pDataObj;

public:

    // IShellExtInit
    STDMETHOD( Initialize ) (
        LPCITEMIDLIST pidlFolder,
        IDataObject * lpdobj, 
        HKEY          hkeyProgID
        );

    // IShellPropSheetExt
    STDMETHOD( AddPages ) ( 
        LPFNADDPROPSHEETPAGE lpfnAddPage, 
        LPARAM lParam ); 

    STDMETHOD( ReplacePage ) (
        UINT uPageID, 
        LPFNADDPROPSHEETPAGE lpfnReplacePage, 
        LPARAM lParam ); 

};

/////////////////////////////////////////////////////////////////////////////
// CPrDrivePg dialog

class CPrDrivePg : public CPropertyPage
{
// Construction
public:
    CPrDrivePg();
    ~CPrDrivePg();

// Dialog Data
    //{{AFX_DATA(CPrDrivePg)
    enum { IDD = IDD_PRDRIVE };
    CEdit   m_editSize;
    CEdit   m_editLevel;
    CEdit   m_editTime;
    CSpinButtonCtrl m_spinTime;
    CSpinButtonCtrl m_spinSize;
    CSpinButtonCtrl m_spinLevel;
    UINT    m_accessTime;
    UINT    m_hsmLevel;
    DWORD   m_fileSize;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrDrivePg)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    static UINT CALLBACK PropPageCallback( HWND hWnd, UINT uMessage, LPPROPSHEETPAGE  ppsp );
    // Generated message map functions
    //{{AFX_MSG(CPrDrivePg)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditAccess();
    afx_msg void OnChangeEditLevel();
    afx_msg void OnChangeEditSize();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    LPFNPSPCALLBACK       m_pMfcCallback; // Original MFC callback from psp
    int                   m_nState;
    CComPtr<IFsaResource> m_pFsaResource;

protected:
    CString               m_pszHelpFilePath;

};


/////////////////////////////////////////////////////////////////////////////
// CPrDriveXPg dialog

class CPrDriveXPg : public CPropertyPage
{
// Construction
public:
    CPrDriveXPg();
    ~CPrDriveXPg();

// Dialog Data
    //{{AFX_DATA(CPrDriveXPg)
    enum { IDD = IDD_PRDRIVEX };
    CString m_szError;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrDriveXPg)
    public:
    protected:
    //}}AFX_VIRTUAL

// Implementation
protected:
    static UINT CALLBACK PropPageCallback( HWND hWnd, UINT uMessage, LPPROPSHEETPAGE  ppsp );
    // Generated message map functions
    //{{AFX_MSG(CPrDriveXPg)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    LPFNPSPCALLBACK m_pMfcCallback;         // Original MFC callback from psp
    int             m_nState;


};

#endif //__PRDRIVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\hsmconn\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\shellext\proppage\prdrive.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrDrive.cpp

Abstract:

    Base file for HSM shell extensions on drives

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/


#include "stdafx.h"
#include "rshelpid.h"

//#define RS_SHOW_ALL_PCTS

// Help Ids
#define RS_WINDIR_SIZE (2*MAX_PATH)
static DWORD pHelpIds[] = 
{
#ifdef RS_SHOW_ALL_PCTS
    IDC_STATIC_LOCAL_PCT,                       idh_volume_percent_local_data,
    IDC_STATIC_LOCAL_PCT_UNIT,                  idh_volume_percent_local_data,
#endif
    IDC_STATIC_LOCAL_4DIGIT,                    idh_volume_capacity_local_data,
    IDC_STATIC_LOCAL_4DIGIT_LABEL,              idh_volume_capacity_local_data,
    IDC_STATIC_LOCAL_4DIGIT_HELP,               idh_volume_capacity_local_data,
#ifdef RS_SHOW_ALL_PCTS
    IDC_STATIC_CACHED_PCT,                      idh_volume_percent_remote_data_cached,
    IDC_STATIC_CACHED_PCT_UNIT,                 idh_volume_percent_remote_data_cached,
#endif
    IDC_STATIC_CACHED_4DIGIT,                   idh_volume_capacity_remote_data_cached,
    IDC_STATIC_CACHED_4DIGIT_LABEL,             idh_volume_capacity_remote_data_cached,
    IDC_STATIC_FREE_PCT,                        idh_volume_percent_free_space,
    IDC_STATIC_FREE_PCT_UNIT,                   idh_volume_percent_free_space,
    IDC_STATIC_FREE_4DIGIT,                     idh_volume_capacity_free_space,
    IDC_STATIC_FREE_4DIGIT_LABEL,               idh_volume_capacity_free_space,
    IDC_STATIC_TOTAL_4DIGIT,                    idh_volume_disk_capacity,
    IDC_STATIC_TOTAL_4DIGIT_LABEL,              idh_volume_disk_capacity,
    IDC_STATIC_REMOTE_STORAGE_4DIGIT,           idh_volume_data_remote_storage,
    IDC_STATIC_STATS_LABEL,                     idh_volume_data_remote_storage,

    IDC_EDIT_LEVEL,                             idh_desired_free_space_percent,
    IDC_SPIN_LEVEL,                             idh_desired_free_space_percent,
    IDC_EDIT_LEVEL_LABEL,                       idh_desired_free_space_percent,
    IDC_EDIT_LEVEL_UNIT,                        idh_desired_free_space_percent,
    IDC_EDIT_SIZE,                              idh_min_file_size_criteria,
    IDC_SPIN_SIZE,                              idh_min_file_size_criteria,
    IDC_EDIT_SIZE_LABEL,                        idh_min_file_size_criteria,
    IDC_EDIT_SIZE_UNIT,                         idh_min_file_size_criteria,
    IDC_EDIT_TIME,                              idh_file_access_date_criteria,
    IDC_SPIN_TIME,                              idh_file_access_date_criteria,
    IDC_EDIT_TIME_LABEL,                        idh_file_access_date_criteria,
    IDC_EDIT_TIME_UNIT,                         idh_file_access_date_criteria,

    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPrDrive

// IShellExtInit
STDMETHODIMP 
CPrDrive::Initialize( 
    LPCITEMIDLIST /*pidlFolder*/,
    IDataObject * pDataObj, 
    HKEY /*hkeyProgID*/
    )
{
    //
    // Initialize can be called more than once
    //
    m_pDataObj.Release(  );

    //
    // duplicate the object pointer
    //
    m_pDataObj = pDataObj;

    return( NOERROR );
}

//////////////////////////////////////////////////////////////////////////////
//
// AddPages
//
//
STDMETHODIMP CPrDrive::AddPages( 
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState(  ) );
    HRESULT hr = S_OK;

    HPROPSHEETPAGE hPage = NULL; // Windows property page handle
    TCHAR szFileSystemName [256];
    TCHAR szDrive [MAX_PATH];
    int nState;
    CComPtr<IFsaResource> pFsaRes;

    FORMATETC fmte = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM medium;
    CPrDrivePg  * pPageDrive  = 0;
    CPrDriveXPg * pPageXDrive = 0;

    try {
        //
        // Find out how many files the user has selected...
        //
        UINT cbFiles = 0;
        BOOL bMountedVol = FALSE;
        WsbAssertPointer( m_pDataObj );  //Paranoid check, m_pDataObj should have something by now...
        hr = m_pDataObj->GetData( &fmte, &medium ) ; // Returns hr

        if (FAILED(hr)) {
            //
            // Isn't a normal volume name. Maybe it's a mounted volume.
            // Mounted volume names come in on a different clipboard format
            // so we can treat them differently from normal volume
            // names like "C:\".  A mounted volume name will be the path
            // to the folder hosting the mounted volume.
            // For mounted volumes, the DataObject provides CF "MountedVolume".
            //
            fmte.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_MOUNTEDVOLUME);
            WsbAffirmHr(m_pDataObj->GetData(&fmte, &medium));
            bMountedVol = TRUE;
        }

        cbFiles = DragQueryFile( ( HDROP )medium.hGlobal,( UINT )-1, NULL, 0 );

        if( 1 == cbFiles ) {

            //
            // Do we have admin privileges?
            //
            if( SUCCEEDED( WsbCheckAccess( WSB_ACCESS_TYPE_ADMINISTRATOR ) ) ) {

                //
                //OK, the user has only selected a single file, so lets go ahead
                //and get more information
                //
                //Get the name of the file the user has clicked on
                //
                DragQueryFile( (HDROP)medium.hGlobal, 
                              0, (USHORT *)szDrive,
                              (sizeof szDrive)/(sizeof szDrive[0]) );

                //
                // Is this a local drive? 
                //
                if( ( GetDriveType( szDrive ) )!= DRIVE_REMOTE ) {

                    //
                    // Is this an NTFS drive?
                    //
                    GetVolumeInformation( 
                                        szDrive,
                                        NULL,
                                        0,
                                        NULL, // Serial Number
                                        NULL, // Filename length
                                        NULL, // flags
                                        szFileSystemName,
                                        256 );
                    if( wcscmp( szFileSystemName, L"NTFS" ) == 0 ) {

                        //
                        // Make sure the Fsa is running - if not do not do anything that
                        // could cause it to load.
                        //
                        if( WsbCheckService( NULL, APPID_RemoteStorageFileSystemAgent ) == S_OK ) {

                            //
                            // Try to get the FSA object for the drive.  If we fail, we don't
                            // put up the property page.
                            //
                            CWsbStringPtr computerName;

                            WsbAffirmHr( WsbGetComputerName( computerName ) );

                            CString szFullResName = computerName;
                            CString szResName = szDrive;
                            //
                            // If a drive letter is present, the format to connect is:
                            // <computer-name>\NTFS\<drive-letter>, no trailing '\' or ':'
                            // i.e. RAVI\NTFS\D
                            // If it's a sticky vol. name however the format is:
                            // <computer-name>\NTFS\<volume-name>\ (WITH the trailing '\'
                            // i.e. RAVI\NTFS\Volume{445a4110-60aa-11d3-0060b0ededdb\
                            //
                            if (bMountedVol) {
                                //
                                // Remove the leading \\?\
                                //
                                szResName = szResName.Right(szResName.GetLength() - 4);
                                szFullResName = szFullResName + "\\" + "NTFS" + "\\" + szResName;
                            } else {
                                szFullResName = szFullResName + "\\" + "NTFS" + "\\" + szDrive;                       
                                //
                                // Remove trailing \ and or :
                                //
                                if( szFullResName [szFullResName.GetLength()- 1] == '\\' ) {
                                     szFullResName = szFullResName.Left( szFullResName.GetLength(  ) - 1 );
                                }

                                if( szFullResName [szFullResName.GetLength(  )- 1] == ':' ) {
                                    szFullResName = szFullResName.Left( szFullResName.GetLength(  ) - 1 );
                                }
                            }

                            if( HsmConnectFromName( HSMCONN_TYPE_RESOURCE, szFullResName, IID_IFsaResource,( void** )&pFsaRes ) == S_OK ) {

                                //
                                // Connected to Hsm
                                // Is the resource managed?
                                //
                                if( pFsaRes->IsManaged(  ) == S_OK ) {

                                    nState = MANAGED;

                                } else {

                                    nState = NOT_MANAGED;

                                }

                            } else {

                                //
                                // Couldn't connect to Fsa
                                //
                                nState = NO_FSA;

                            }

                        } else {

                            //
                            // Fsa is not running
                            //
                            nState = NO_FSA;

                        }

                    } else {

                        nState = NOT_NTFS;

                    }

                } else {

                    //
                    // Remote volume
                    //
                    nState = REMOTE;
                }

            } else {

                nState = NOT_ADMIN;

            }

        } else {

            nState = MULTI_SELECT;

        }

        //
        // For Not admin, Remote and Multi-Select, we don't even show the page
        //
        switch( nState ) {
        
        case NOT_NTFS:
        case NOT_ADMIN:
        case REMOTE:
        case MULTI_SELECT:
            //
            // For Not admin, Remote and Multi-Select, we don't even show the page
            //
            break;

        case MANAGED:
            {
                /////////////////////////////////////////////////////////////
                // Create the property page

                WsbAssertPointer( pFsaRes );

                //
                // Create the Drive property page.
                //
                pPageDrive = new CPrDrivePg(  );
                WsbAffirmPointer( pPageDrive );

                //
                // Assign the Fsa object to the page
                //
                pPageDrive->m_pFsaResource = pFsaRes;

                //
                // Set the state
                //
                pPageDrive->m_nState = nState;

                hPage = CreatePropertySheetPage( &pPageDrive->m_psp );
                WsbAffirmHandle( hPage );

                //
                // Call the callback function with the handle to the new
                // page
                //
                WsbAffirm( lpfnAddPage( hPage, lParam ), E_UNEXPECTED );
                break;
            }

        default:
            {
                /////////////////////////////////////////////////////////////
                // Create the property page
                pPageXDrive = new CPrDriveXPg(  );
                WsbAffirmPointer( pPageXDrive );

                //
                // Set the state
                //
                pPageXDrive->m_nState = nState;
                hPage = CreatePropertySheetPage( &pPageXDrive->m_psp );
                WsbAffirmHandle( hPage );

                // Call the callback function with the handle to the new
                // page
                WsbAffirm( lpfnAddPage( hPage, lParam ), E_UNEXPECTED );
            }
        }

    } WsbCatchAndDo( hr,
             
        if( pPageDrive )  delete pPageDrive;
        if( pPageXDrive ) delete pPageXDrive;
    );

    return( hr );
}

//
//  FUNCTION: CPrDrive::ReplacePage( UINT, LPFNADDPROPSHEETPAGE, LPARAM )
//
//  PURPOSE: Called by the shell only for Control Panel property sheet 
//           extensions
//
//  PARAMETERS:
//    uPageID         -  ID of page to be replaced
//    lpfnReplaceWith -  Pointer to the Shell's Replace function
//    lParam          -  Passed as second parameter to lpfnReplaceWith
//
//  RETURN VALUE:
//
//    E_FAIL, since we don't support this function.  It should never be
//    called.

//  COMMENTS:
//

STDMETHODIMP 
CPrDrive::ReplacePage( 
    UINT /*uPageID*/, 
    LPFNADDPROPSHEETPAGE /*lpfnReplaceWith*/, 
    LPARAM /*lParam*/
    )
{
    return( E_FAIL );
}

/////////////////////////////////////////////////////////////////////////////
// CPrDrivePg property page

CPrDrivePg::CPrDrivePg(  ): CPropertyPage( CPrDrivePg::IDD )
{
    //{{AFX_DATA_INIT( CPrDrivePg )
    m_accessTime = 0;
    m_hsmLevel = 0;
    m_fileSize = 0;
    //}}AFX_DATA_INIT

    //
    // Lock the module while this object lives.
    // Otherwise, modules can call CoFreeUnusedLibraries( )
    // and cause us to unload before our page gets destroyed,
    // which causes an AV in the common control.
    //
    _Module.Lock( );

    //
    // initialize state
    //
    m_nState       = NO_STATE;

    //
    // Get and save the MFC callback function.
    // This is so we can delete the class the dialog never gets created.
    //
    m_pMfcCallback = m_psp.pfnCallback;

    //
    // Set the call back to our callback
    //
    m_psp.pfnCallback = PropPageCallback;

}

CPrDrivePg::~CPrDrivePg(  )
{
    _Module.Unlock( );
}

void CPrDrivePg::DoDataExchange( CDataExchange* pDX )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState(  ) );

    CPropertyPage::DoDataExchange( pDX );
    //{{AFX_DATA_MAP( CPrDrivePg )
    DDX_Control( pDX, IDC_EDIT_SIZE, m_editSize );
    DDX_Control( pDX, IDC_EDIT_LEVEL, m_editLevel );
    DDX_Control( pDX, IDC_EDIT_TIME, m_editTime );
    DDX_Control( pDX, IDC_SPIN_TIME, m_spinTime );
    DDX_Control( pDX, IDC_SPIN_SIZE, m_spinSize );
    DDX_Control( pDX, IDC_SPIN_LEVEL, m_spinLevel );
    DDX_Text( pDX, IDC_EDIT_TIME, m_accessTime );
    DDV_MinMaxUInt( pDX, m_accessTime, HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );
    DDX_Text( pDX, IDC_EDIT_LEVEL, m_hsmLevel );
    DDV_MinMaxUInt( pDX, m_hsmLevel, HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );
    DDX_Text( pDX, IDC_EDIT_SIZE, m_fileSize );
    //}}AFX_DATA_MAP

    //
    // Since we limit the number of characters in the buddy edits, we 
    // don't expect the previous two DDV's to ever really kick in. 
    // However, it is possible to enter bad minumum size since both
    // '0' and '1' can be entered, but are not in the valid range.
    //

    //
    // Code is equivalent to:
    // DDV_MinMaxDWord( pDX, m_fileSize, HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
    //

    if( pDX->m_bSaveAndValidate &&
      ( m_fileSize < HSMADMIN_MIN_MINSIZE ||
        m_fileSize > HSMADMIN_MAX_MINSIZE ) ) {

        CString message;
        AfxFormatString2( message, IDS_ERR_MINSIZE_RANGE, 
            CString( WsbLongAsString( (LONG)HSMADMIN_MIN_MINSIZE ) ),
            CString( WsbLongAsString( (LONG)HSMADMIN_MAX_MINSIZE ) ) );
        AfxMessageBox( message, MB_OK | MB_ICONWARNING );
        pDX->Fail();

    }

}


BEGIN_MESSAGE_MAP( CPrDrivePg, CPropertyPage )
//{{AFX_MSG_MAP( CPrDrivePg )
ON_EN_CHANGE( IDC_EDIT_TIME, OnChangeEditAccess )
ON_EN_CHANGE( IDC_EDIT_LEVEL, OnChangeEditLevel )
ON_EN_CHANGE( IDC_EDIT_SIZE, OnChangeEditSize )
ON_WM_DESTROY(  )
	ON_WM_CONTEXTMENU()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP(  )

/////////////////////////////////////////////////////////////////////////////
// CPrDrivePg message handlers

BOOL CPrDrivePg::OnInitDialog(  )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState(  ) );

    HRESULT         hr = S_OK;

    LONGLONG total = 0;
    LONGLONG free = 0;
    LONGLONG premigrated = 0;
    LONGLONG truncated = 0;
    LONGLONG remoteStorage = 0;
    ULONG totalMB = 0;
    ULONG freeMB = 0;
    ULONG premigratedMB = 0;
    ULONG truncatedMB = 0;
    CString sFormat;
    CString sBufFormat;


    CPropertyPage::OnInitDialog(  );

    try {

        WsbAffirmPointer( m_pFsaResource );

        //
        // Set the spinner ranges
        //
        m_spinTime.SetRange( HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );
        m_spinSize.SetRange( HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
        m_spinLevel.SetRange( HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );

        //
        // Set text limits
        //
        m_editTime.SetLimitText( 3 );
        m_editSize.SetLimitText( 5 );
        m_editLevel.SetLimitText( 2 );


        //
        // Get statistics
        //
        WsbAffirmHr( m_pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );

        //
        // "Local" data
        //
        LONGLONG local = max( ( total - free - premigrated ),( LONGLONG )0 );

        //
        // Calculate percents
        //
        int freePct;
        int premigratedPct;
        if( 0 == total ) {

            freePct = 0;
            premigratedPct = 0;

        } else {

            freePct        = (int)( ( free * 100 )/ total );
            premigratedPct = (int)( ( premigrated * 100 )/ total );

        }

        int localPct = 100 - freePct - premigratedPct;
        remoteStorage = premigrated + truncated;

        //
        // Show the statistics in 4-char format
        //
        RsGuiFormatLongLong4Char( local, sBufFormat );
        SetDlgItemText( IDC_STATIC_LOCAL_4DIGIT, sBufFormat );

        RsGuiFormatLongLong4Char( premigrated, sBufFormat );
        SetDlgItemText( IDC_STATIC_CACHED_4DIGIT, sBufFormat );

        RsGuiFormatLongLong4Char( free, sBufFormat );
        SetDlgItemText( IDC_STATIC_FREE_4DIGIT, sBufFormat );

        RsGuiFormatLongLong4Char( total, sBufFormat );
        SetDlgItemText( IDC_STATIC_TOTAL_4DIGIT, sBufFormat );

        RsGuiFormatLongLong4Char( remoteStorage, sBufFormat );
        SetDlgItemText( IDC_STATIC_REMOTE_STORAGE_4DIGIT, sBufFormat );

        //
        // Show Percents
        //
#ifdef RS_SHOW_ALL_PCTS
        sFormat.Format( L"%d", localPct );
        SetDlgItemText( IDC_STATIC_LOCAL_PCT, sFormat );

        sFormat.Format( L"%d", premigratedPct );
        SetDlgItemText( IDC_STATIC_CACHED_PCT, sFormat );
#endif

        sFormat.Format( L"%d", freePct );
        SetDlgItemText( IDC_STATIC_FREE_PCT, sFormat );

        //
        // Get levels
        //
        ULONG       hsmLevel = 0;
        LONGLONG    fileSize = 0;
        BOOL        isRelative = TRUE; // assumed to be TRUE
        FILETIME    accessTime;

        WsbAffirmHr( m_pFsaResource->GetHsmLevel( &hsmLevel ) );
        m_hsmLevel = hsmLevel / FSA_HSMLEVEL_1;
        WsbAffirmHr( m_pFsaResource->GetManageableItemLogicalSize( &fileSize ) );
        m_fileSize = (DWORD)(fileSize / 1024);  // Show KBytes
        WsbAffirmHr( m_pFsaResource->GetManageableItemAccessTime( &isRelative, &accessTime ) );
        WsbAssert( isRelative, E_FAIL );  // We only do relative time
        // Convert FILETIME to days
        m_accessTime = (UINT)( WsbFTtoLL( accessTime ) / WSB_FT_TICKS_PER_DAY );
        if(m_accessTime > HSMADMIN_MAX_INACTIVITY ) {

            m_accessTime = HSMADMIN_MAX_INACTIVITY;

        }

        UpdateData( FALSE );

        // Get help file name
        CString helpFile;
        helpFile.LoadString(IDS_HELPFILEPOPUP);

        CWsbStringPtr winDir;
        WsbAffirmHr( winDir.Alloc( RS_WINDIR_SIZE ) );
        WsbAffirmStatus( ::GetWindowsDirectory( (WCHAR*)winDir, RS_WINDIR_SIZE ) != 0 );

        m_pszHelpFilePath = CString(winDir) + L"\\help\\" + helpFile;

    } WsbCatch( hr )

    return( TRUE );
}

void CPrDrivePg::OnChangeEditAccess(  )
{
    SetModified(  );  
}

void CPrDrivePg::OnChangeEditLevel(  )
{
    SetModified(  );  
}

void CPrDrivePg::OnChangeEditSize(  )
{
    SetModified(  );  
}

BOOL CPrDrivePg::OnApply(  )
{
    HRESULT hr;

    try {

        //
        // m_pFsaResource is NULL if we didn't show any properties, in which case there is nothing
        // to apply.. Note that apply may have been enabled by another page in the sheet.
        //
        if( m_pFsaResource ) {
            LONGLONG    fileSize = 0;

            UpdateData( TRUE );
            WsbAffirmHr( m_pFsaResource->SetHsmLevel( m_hsmLevel * FSA_HSMLEVEL_1 ) );
            fileSize = ((LONGLONG)m_fileSize) * 1024;
            WsbAffirmHr( m_pFsaResource->SetManageableItemLogicalSize( fileSize ) );

            //
            // Convert days to FILETIME
            //
            FILETIME accessTime;
            accessTime = WsbLLtoFT( ( LONGLONG )m_accessTime * WSB_FT_TICKS_PER_DAY );
            WsbAffirmHr( m_pFsaResource->SetManageableItemAccessTime( TRUE, accessTime ) );

        }

    } WsbCatch( hr );

    return( CPropertyPage::OnApply(  ) );
}

UINT CALLBACK
CPrDrivePg::PropPageCallback(
    HWND hWnd,
    UINT uMessage,
    LPPROPSHEETPAGE  ppsp )
{

    UINT rVal = 0;
    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( ppsp );
        WsbAffirmPointer( ppsp->lParam );

        //
        // Get the page object from lParam
        //
        CPrDrivePg* pPage = (CPrDrivePg*)ppsp->lParam;

        WsbAssertPointer( pPage->m_pMfcCallback );

        rVal = ( pPage->m_pMfcCallback )( hWnd, uMessage, ppsp );

        switch( uMessage ) {
        case PSPCB_CREATE:
            break;

        case PSPCB_RELEASE:
            delete pPage;
            break;
        }

    } WsbCatch( hr );

    return( rVal );
}

void CPrDrivePg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    UNREFERENCED_PARAMETER(pWnd);
    UNREFERENCED_PARAMETER(point);

    if(pHelpIds && (m_pszHelpFilePath != L"")) {

        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
        ::WinHelp(m_hWnd, m_pszHelpFilePath, HELP_CONTEXTMENU, (DWORD_PTR)pHelpIds);

    }
	
}

BOOL CPrDrivePg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if( (HELPINFO_WINDOW == pHelpInfo->iContextType) && 
        pHelpIds                                     && 
        (m_pszHelpFilePath != L"") ) {
        
        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

        //
        // Look through list to see if we have help for this control
        // If not, we want to avoid the "No Help Available" box
        //
        DWORD *pTmp = pHelpIds;
        DWORD helpId    = 0;
        DWORD tmpHelpId = 0;
        DWORD tmpCtrlId = 0;

        while( pTmp && *pTmp ) {
            //
            // Array is a pairing of control ID and help ID
            //
            tmpCtrlId = pTmp[0];
            tmpHelpId = pTmp[1];
            pTmp += 2;
            if(tmpCtrlId == (DWORD)pHelpInfo->iCtrlId) {
                helpId = tmpHelpId;
                break;
            }
        }

        if( helpId != 0 ) {
            ::WinHelp(m_hWnd, m_pszHelpFilePath, HELP_CONTEXTPOPUP, helpId);
        }
    }
	
	return CPropertyPage ::OnHelpInfo(pHelpInfo);
}

/////////////////////////////////////////////////////////////////////////////
// CPrDriveXPg property page

CPrDriveXPg::CPrDriveXPg(  ): CPropertyPage( CPrDriveXPg::IDD )
{
    //{{AFX_DATA_INIT( CPrDriveXPg )
    //}}AFX_DATA_INIT

    //
    // Lock the module while this object lives.
    // Otherwise, modules can call CoFreeUnusedLibraries( )
    // and cause us to unload before our page gets destroyed,
    // which causes an AV in the common control.
    //
    _Module.Lock( );
    m_nState       = NO_STATE;

    //
    // Get and save the MFC callback function.
    // This is so we can delete the class the dialog never gets created.
    //
    m_pMfcCallback = m_psp.pfnCallback;

    //
    // Set the call back to our callback
    //
    m_psp.pfnCallback = PropPageCallback;
}

CPrDriveXPg::~CPrDriveXPg(  )
{
    _Module.Unlock( );
}

BEGIN_MESSAGE_MAP( CPrDriveXPg, CPropertyPage )
//{{AFX_MSG_MAP( CPrDriveXPg )
//}}AFX_MSG_MAP
END_MESSAGE_MAP(  )

/////////////////////////////////////////////////////////////////////////////
// CPrDriveXPg message handlers

BOOL CPrDriveXPg::OnInitDialog(  )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState(  ) );

    HRESULT hr = S_OK;

    CPropertyPage::OnInitDialog(  );

    try {

        switch( m_nState ) {

        case NO_FSA:
            m_szError.LoadString( IDS_NO_FSA );
            break;
        case NOT_MANAGED:
            m_szError.LoadString( IDS_NOT_MANAGED );
            break;
        case NOT_NTFS:
            m_szError.LoadString( IDS_NOT_NTFS );
            break;
        }

        SetDlgItemText( IDC_STATIC_ERROR, m_szError );

    } WsbCatch( hr )

    return( TRUE );
}

UINT CALLBACK
CPrDriveXPg::PropPageCallback(
    HWND hWnd,
    UINT uMessage,
    LPPROPSHEETPAGE  ppsp )
{

    UINT rVal = 0;
    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( ppsp );
        WsbAffirmPointer( ppsp->lParam );

        //
        // Get the page object from lParam
        //
        CPrDriveXPg* pPage = (CPrDriveXPg*)ppsp->lParam;

        WsbAssertPointer( pPage->m_pMfcCallback );

        rVal = ( pPage->m_pMfcCallback )( hWnd, uMessage, ppsp );

        switch( uMessage ) {
        case PSPCB_CREATE:
            break;

        case PSPCB_RELEASE:
            delete pPage;
            break;
        }

    } WsbCatch( hr );

    return( rVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\utility\proppage.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PropPage.cpp

Abstract:

    Node representing our Media Set (Media Pool) within NTMS.

Author:

    Rohde Wakefield [rohde]   04-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PropPage.h"
#include "wizsht.h"


/////////////////////////////////////////////////////////////////////////////
// CRsDialog property page

CRsDialog::CRsDialog( UINT nIDTemplate, CWnd* pParent ) : CDialog( nIDTemplate, pParent )
{
    //{{AFX_DATA_INIT(CRsDialog)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_pHelpIds = 0;
}

CRsDialog::~CRsDialog()
{
}

BEGIN_MESSAGE_MAP(CRsDialog, CDialog)
    //{{AFX_MSG_MAP(CRsDialog)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CRsDialog::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if( ( HELPINFO_WINDOW == pHelpInfo->iContextType ) && m_pHelpIds ) {
        
        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

        //
        // Look through list to see if we have help for this control
        // If not, we want to avoid the "No Help Available" box
        //
        const DWORD * pTmp = m_pHelpIds;
        DWORD helpId    = 0;
        DWORD tmpHelpId = 0;
        DWORD tmpCtrlId = 0;

        while( pTmp && *pTmp ) {

            //
            // Array is a pairing of control ID and help ID
            //
            tmpCtrlId = pTmp[0];
            tmpHelpId = pTmp[1];
            pTmp += 2;
            if( tmpCtrlId == (DWORD)pHelpInfo->iCtrlId ) {

                helpId = tmpHelpId;
                break;

            }

        }

        if( helpId != 0 ) {

            ::WinHelp( m_hWnd, AfxGetApp( )->m_pszHelpFilePath, HELP_CONTEXTPOPUP, helpId );

        }

    }
    
    return CDialog::OnHelpInfo(pHelpInfo);
}

void CRsDialog::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if( m_pHelpIds ) {

        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
        ::WinHelp( m_hWnd, AfxGetApp( )->m_pszHelpFilePath, HELP_CONTEXTMENU, (UINT_PTR)m_pHelpIds );

    }
}

/////////////////////////////////////////////////////////////////////////////
// CRsPropertyPage property page

CRsPropertyPage::CRsPropertyPage( UINT nIDTemplate, UINT nIDCaption ) : CPropertyPage( nIDTemplate, nIDCaption )
{
    //{{AFX_DATA_INIT(CRsPropertyPage)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_pHelpIds = 0;

    //
    // Get and save the MFC callback function.
    // This is so we can delete the class the dialog never gets created.
    //
    m_pMfcCallback = m_psp.pfnCallback;

    //
    // Set the call back to our callback
    //
    m_psp.pfnCallback = PropPageCallback;

}

CRsPropertyPage::~CRsPropertyPage()
{
}

void CRsPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRsPropertyPage)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRsPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CRsPropertyPage)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

UINT CALLBACK
CRsPropertyPage::PropPageCallback(
    HWND hWnd,
    UINT uMessage,
    LPPROPSHEETPAGE  ppsp )
{

    UINT rVal = 0;

    if( ( ppsp ) && ( ppsp->lParam ) ) {

        //
        // Get the page object from lParam
        //
        CRsPropertyPage* pPage = (CRsPropertyPage*)ppsp->lParam;

        if( pPage->m_pMfcCallback ) {

            rVal = ( pPage->m_pMfcCallback )( hWnd, uMessage, ppsp );

        }

        switch( uMessage ) {
        
        case PSPCB_CREATE:
            pPage->OnPageCreate( );
            break;

        case PSPCB_RELEASE:
            pPage->OnPageRelease( );
            break;
        }

    }

    return( rVal );
}


/////////////////////////////////////////////////////////////////////////////
// CRsPropertyPage Font Accessor Functions

#define RSPROPPAGE_FONT_IMPL( name )    \
CFont CRsPropertyPage::m_##name##Font;  \
CFont*                                  \
CRsPropertyPage::Get##name##Font(       \
    void                                \
    )                                   \
{                                       \
    if( 0 == (HFONT)m_##name##Font ) {  \
        Init##name##Font( );            \
    }                                   \
    return( &m_##name##Font );          \
}

RSPROPPAGE_FONT_IMPL( Shell )
RSPROPPAGE_FONT_IMPL( BoldShell )
RSPROPPAGE_FONT_IMPL( WingDing )
RSPROPPAGE_FONT_IMPL( LargeTitle )
RSPROPPAGE_FONT_IMPL( SmallTitle )

void
CRsPropertyPage::InitShellFont(          
    void                                
    )                                   
{                                       
    LOGFONT logfont;
    CFont*  tempFont = GetFont( );
    tempFont->GetLogFont( &logfont );

    m_ShellFont.CreateFontIndirect( &logfont );
}

void
CRsPropertyPage::InitBoldShellFont(          
    void                                
    )                                   
{                                       
    LOGFONT logfont;
    CFont*  tempFont = GetFont( );
    tempFont->GetLogFont( &logfont );

    logfont.lfWeight = FW_BOLD;

    m_BoldShellFont.CreateFontIndirect( &logfont );
}

void
CRsPropertyPage::InitWingDingFont(          
    void                                
    )                                   
{
    CString faceName = GetWingDingFontName( );
    CString faceSize;
    faceSize.LoadString( IDS_WIZ_WINGDING_FONTSIZE );

    LONG height;
    height = _wtol( faceSize );

    LOGFONT logFont;
    memset( &logFont, 0, sizeof(LOGFONT) );
    logFont.lfCharSet = SYMBOL_CHARSET;
    logFont.lfHeight  = height;
    lstrcpyn( logFont.lfFaceName, faceName, LF_FACESIZE );

    m_WingDingFont.CreatePointFontIndirect( &logFont );
}

void
CRsPropertyPage::InitLargeTitleFont(          
    void                                
    )                                   
{                                       
    CString fontname;
    fontname.LoadString( IDS_WIZ_TITLE1_FONTNAME );

    CString faceSize;
    faceSize.LoadString( IDS_WIZ_TITLE1_FONTSIZE );

    LONG height;
    height = _wtol( faceSize );

    LOGFONT logFont;
    memset( &logFont, 0, sizeof(LOGFONT) );
    logFont.lfCharSet = DEFAULT_CHARSET;
    logFont.lfHeight  = height;
    logFont.lfWeight  = FW_BOLD;
    lstrcpyn( logFont.lfFaceName, fontname, LF_FACESIZE );

    m_LargeTitleFont.CreatePointFontIndirect( &logFont );
}

void
CRsPropertyPage::InitSmallTitleFont(          
    void                                
    )                                   
{                                       
    CString fontname;
    fontname.LoadString( IDS_WIZ_TITLE1_FONTNAME );

    LOGFONT logFont;
    memset( &logFont, 0, sizeof(LOGFONT) );
    logFont.lfCharSet = DEFAULT_CHARSET;
    logFont.lfHeight  = 80;
    logFont.lfWeight  = FW_BOLD;
    lstrcpyn( logFont.lfFaceName, fontname, LF_FACESIZE );

    m_SmallTitleFont.CreatePointFontIndirect( &logFont );
}

/////////////////////////////////////////////////////////////////////////////
// CRsPropertyPage message handlers


//////////////////////////////////////////////////////////////////////
// CRsWizardPage Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRsWizardPage::CRsWizardPage( UINT nIDTemplate, BOOL bExterior, UINT nIDTitle, UINT nIDSubtitle )
:   CRsPropertyPage( nIDTemplate, 0 ),
    m_TitleId( nIDTitle ),
    m_SubtitleId( nIDSubtitle ),
    m_ExteriorPage( bExterior )
{

    //{{AFX_DATA_INIT(CRsWizardPage)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CRsWizardPage::~CRsWizardPage()
{
}

void CRsWizardPage::DoDataExchange(CDataExchange* pDX)
{
    CRsPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRsWizardPage)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRsWizardPage, CRsPropertyPage)
    //{{AFX_MSG_MAP(CRsWizardPage)
    ON_WM_CTLCOLOR( )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CRsWizardPage::OnInitDialog() 
{
    CRsPropertyPage::OnInitDialog();

    if( m_ExteriorPage ) {

        CWnd* pMainTitle  = GetDlgItem( IDC_WIZ_TITLE );

        //
        // Set fonts
        //
        if( pMainTitle )   pMainTitle->SetFont( GetLargeTitleFont( ) );

    }
    
    return TRUE;
}

void CRsWizardPage::SetCaption( CString& strCaption )
{
    CPropertyPage::m_strCaption = strCaption;
    CPropertyPage::m_psp.pszTitle = strCaption;
    CPropertyPage::m_psp.dwFlags |= PSP_USETITLE;
}

BOOL CRsPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if( ( HELPINFO_WINDOW == pHelpInfo->iContextType ) && m_pHelpIds ) {
        
        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

        //
        // Look through list to see if we have help for this control
        // If not, we want to avoid the "No Help Available" box
        //
        const DWORD * pTmp = m_pHelpIds;
        DWORD helpId    = 0;
        DWORD tmpHelpId = 0;
        DWORD tmpCtrlId = 0;

        while( pTmp && *pTmp ) {

            //
            // Array is a pairing of control ID and help ID
            //
            tmpCtrlId = pTmp[0];
            tmpHelpId = pTmp[1];
            pTmp += 2;
            if( tmpCtrlId == (DWORD)pHelpInfo->iCtrlId ) {

                helpId = tmpHelpId;
                break;

            }

        }

        if( helpId != 0 ) {

            ::WinHelp( m_hWnd, AfxGetApp( )->m_pszHelpFilePath, HELP_CONTEXTPOPUP, helpId );

        }

    }
    
    return CPropertyPage::OnHelpInfo(pHelpInfo);
}

void CRsPropertyPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if( m_pHelpIds ) {

        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
        ::WinHelp( m_hWnd, AfxGetApp( )->m_pszHelpFilePath, HELP_CONTEXTMENU, (UINT_PTR)m_pHelpIds );

    }
}

HPROPSHEETPAGE CRsWizardPage::CreatePropertyPage( )
{
    HPROPSHEETPAGE hRet = 0;

    //
    // Copy over values of m_psp into m_psp97
    //
    m_psp97.dwFlags     = m_psp.dwFlags;
    m_psp97.hInstance   = m_psp.hInstance;
    m_psp97.pszTemplate = m_psp.pszTemplate;
    m_psp97.pszIcon     = m_psp.pszIcon;
    m_psp97.pszTitle    = m_psp.pszTitle;
    m_psp97.pfnDlgProc  = m_psp.pfnDlgProc;
    m_psp97.lParam      = m_psp.lParam;
    m_psp97.pfnCallback = m_psp.pfnCallback;
    m_psp97.pcRefParent = m_psp.pcRefParent;

    //
    // And fill in the other values needed
    //
    m_psp97.dwSize = sizeof( m_psp97 );

    if( m_ExteriorPage ) {

        m_psp97.dwFlags |= PSP_HIDEHEADER;

    } else {

        m_Title.LoadString(    m_TitleId );
        m_SubTitle.LoadString( m_SubtitleId );
        m_psp97.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    }

    m_psp97.pszHeaderTitle    = m_Title;
    m_psp97.pszHeaderSubTitle = m_SubTitle;

    //
    // And do the create
    //
    hRet = ::CreatePropertySheetPage( (PROPSHEETPAGE*) &m_psp97 );

    return( hRet );
}

HBRUSH CRsWizardPage::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
    int controlId = pWnd->GetDlgCtrlID( );
    HBRUSH hbr = CRsPropertyPage::OnCtlColor( pDC, pWnd, nCtlColor );

    if( IDC_WIZ_FINAL_TEXT == controlId ) {

        pDC->SetBkMode( OPAQUE );
        hbr = (HBRUSH)::GetStockObject( WHITE_BRUSH );

    }

    return( hbr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\utility\stdafx.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Precompiled header starting point

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#ifndef _STDAFX_H
#define _STDAFX_H

#pragma once

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>         // MFC support for Windows Common Controls


#endif // !defined(_STDAFX_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\hsmconn\cname.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CName.h

Abstract:

    This is the implementation of the CNames classes, which
    handle how server and object names and paths are put
    together.

Author:

    Rohde Wakefield    [rohde]   14-Oct-1997

Revision History:

--*/

#ifndef HSMCONN_CNAME_H
#define HSMCONN_CNAME_H



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\hsmservr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\utility\wizsht.cpp ===
// WizSht.cpp: implementation of the CRsWizardSheet class.
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "WizSht.h"
#include "PropPage.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRsWizardSheet::CRsWizardSheet( UINT nIDCaption, CWnd *pParentWnd, UINT iSelectPage ) :
        CPropertySheet( nIDCaption, pParentWnd, iSelectPage )
{
    // save the caption
    m_IdCaption = nIDCaption;
}

void CRsWizardSheet::AddPage( CRsWizardPage* pPage ) 
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    CString strCaption;

    // Take the caption from our sheet class and put it in the page
    strCaption.LoadString( m_IdCaption );
    pPage->SetCaption( strCaption );

    CPropertySheet::AddPage( pPage );

}

CRsWizardSheet::~CRsWizardSheet()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\hsmconn\hsmconn.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmConn.cpp

Abstract:

    This is the main implementation of the HsmConn dll. This dll provides
    functions for accessing Directory Services and for connecting to
    our services.

Author:

    Rohde Wakefield    [rohde]   21-Oct-1996

Revision History:

--*/


#include "stdafx.h"
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

// Required by SECURITY.H
#define SECURITY_WIN32
#include <security.h>

// HsmConnPoint objects are used only here
#include "hsmservr.h"

//
// Tracing information
//

#define WSB_TRACE_IS WSB_TRACE_BIT_HSMCONN

//
// _Module instantiation for ATL
//

CComModule _Module;

/////////////////////////////////////////////////////////////////////////////

#define REG_PATH        OLESTR("SOFTWARE\\Microsoft\\RemoteStorage")
#define REG_USE_DS      OLESTR("UseDirectoryServices")

//  Local data
static OLECHAR CNEqual[]                = L"CN=";
static OLECHAR ComputersNodeName[]      = L"Computers";
static OLECHAR DCsNodeName[]            = L"Domain Controllers";
static OLECHAR ContainerType[]          = L"Container";
static OLECHAR DisplaySpecifierName[]   = L"displaySpecifier";
static OLECHAR GuidAttrName[]           = L"remoteStorageGUID";
static OLECHAR RsDisplaySpecifierName[] = L"remoteStorageServicePoint-Display";
static OLECHAR RsNodeName[]             = L"RemoteStorage";
static OLECHAR RsNodeType[]             = L"remoteStorageServicePoint";
static OLECHAR ServiceBindAttrName[]    = L"serviceBindingInformation";
static OLECHAR ServiceBindValue[]       = L"Rsadmin.msc /ds ";

static ADS_ATTR_INFO   aaInfo[2];    // For use in IDirectoryObject
static ADSVALUE        adsValue[2];  // For use in IDirectoryObject
static OLECHAR         DomainName[MAX_COMPUTERNAME_LENGTH];
static BOOL            DSIsWritable = FALSE;          // Default to "NO"
static BOOL            UseDirectoryServices = FALSE;  // Default to "NO"

#if defined(HSMCONN_DEBUG)
    //  We use this and OutputDebugString when we can't use our normal 
    //  tracing.
    OLECHAR dbg_string[200];
#endif



extern "C"
{

//  Local functions
static void    GetDSState(void);
static HRESULT HsmConnectToServer(HSMCONN_TYPE type, 
        const OLECHAR * Server, REFIID riid, void ** ppv);
static const OLECHAR *HsmConnTypeAsString(HSMCONN_TYPE type);
static GUID    HsmConnTypeToGuid(IN HSMCONN_TYPE type);
static HRESULT HsmGetComputerNode(const OLECHAR * compName, 
        IADsContainer **pContainer);
static HRESULT HsmGetDsChild(IADsContainer * pContainer, const OLECHAR * Name,
        REFIID riid, void **ppv);




BOOL WINAPI
DllMain (
    IN  HINSTANCE hInst, 
    IN  ULONG     ulReason,
        LPVOID    /*lpReserved*/
    )

/*++

Routine Description:

    This routine is called whenever a new process and thread attaches
    to this DLL. Its purpose is to initialize the _Module object,
    necessary for ATL.

Arguments:

    hInst - HINSTANCE of this dll.

    ulReason - Context of the attaching/detaching

Return Value:

    non-zero - success
    
    0        - prevent action

--*/

{

    switch ( ulReason ) {

    case DLL_PROCESS_ATTACH:

        //
        // Initialize the ATL module, and prevent
        // any of the additional threads from sending
        // notifications through
        //

        _Module.Init ( 0, hInst );
        DisableThreadLibraryCalls ( hInst );
        GetDSState();
        break;

    case DLL_PROCESS_DETACH:

        //
        // Tell ATL module to terminate
        //

        _Module.Term ( );
        break;

    }

    return ( TRUE );

}


static HRESULT
HsmConnectToServer (
    IN  HSMCONN_TYPE type,
    IN  const OLECHAR * Server,
    IN  REFIID   riid,
    OUT void ** ppv
    )

/*++

Routine Description:

    Given a generic server (connected via HsmConnPoint class)
    connect to it and return back the requested interface 'riid'.

Arguments:

    type - Type of server to connect
    Server - Name of machine on which server is running.

    riid - The interface type to return.

    ppv - Returned interface pointer of the Server.

Return Value:

    S_OK - Connection made, Success.

    E_NOINTERFACE - Requested interface not supported by Server.

    E_POINTER - ppv is not a valid pointer.

    E_OUTOFMEMORY - Low memory condition prevented connection.

    HSM_E_NOT_READY - Engine is not running or not initialized yet

    FSA_E_NOT_READY - Fsa is not running or not initialized yet

--*/

{
    WsbTraceIn ( L"HsmConnectToServer",
        L"type = '%ls' , Server = '%ls', riid = '%ls', ppv = 0x%p",
        HsmConnTypeAsString ( type ), Server, WsbStringCopy ( WsbGuidAsString ( riid ) ), ppv );

    HRESULT hr = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != Server, E_POINTER );
        WsbAssert ( 0 != ppv,    E_POINTER );


        //
        // We will specify the provided HSM as the machine to contact,
        // so Construct a COSERVERINFO with Server.
        //

        REFCLSID rclsid = CLSID_HsmConnPoint;
        COSERVERINFO csi;

        memset ( &csi, 0, sizeof ( csi ) );
        csi.pwszName = (OLECHAR *) Server; // must cast to remove constness

        //
        // Build a MULTI_QI structure to obtain desired interface (necessary for 
        // CoCreateInstanceEx). In our case, we need only one interface.
        //

        MULTI_QI mqi[1];

        memset ( mqi, 0, sizeof ( mqi ) );
        mqi[0].pIID = &IID_IHsmConnPoint;

        //
        // The HsmConnPoint object ic created in the scope of the main HSM service and
        // provides access for HSM server objects
        //

        WsbAffirmHr( CoCreateInstanceEx ( rclsid, 0, CLSCTX_SERVER, &csi, 1, mqi ) );

        //
        // Put returned interfaces in smart pointers so we
        // don't leak a reference in case off throw
        //
        CComPtr<IHsmConnPoint> pConn;

        if( SUCCEEDED( mqi[0].hr ) ) {
            
            pConn = (IHsmConnPoint *)(mqi[0].pItf);
            (mqi[0].pItf)->Release( );

            hr   = mqi[0].hr;

#if 0  // This is now done at the COM process-wide security layer

        /* NOTE: In case that a per-connection security will be require,
           the method CheckAccess should be implemented in CHsmConnPoint */
                   
        //
        // Check the security first
        //
        WsbAffirmHr( mqi[1].hr );
        WsbAffirmHr( pServer->CheckAccess( WSB_ACCESS_TYPE_ADMINISTRATOR ) );
#endif

            // get the server object itself
            switch (type) {

            case HSMCONN_TYPE_HSM: {
                WsbAffirmHr( pConn->GetEngineServer((IHsmServer **)ppv) );
                break;
                }

            case HSMCONN_TYPE_FSA:
            case HSMCONN_TYPE_RESOURCE: {
                WsbAffirmHr( pConn->GetFsaServer((IFsaServer **)ppv) );
                break;
                }

            default: {
                WsbThrow ( E_INVALIDARG );
                break;
                }
            } 

        } else {

            // Make sure interface pointer is safe (NULL) when failing
            *ppv = 0;
        }

    } WsbCatchAndDo ( hr, 

        // Make sure interface pointer is safe (NULL) when failing
        *ppv = 0;
    
    ) // WsbCatchAndDo

    WsbTraceOut ( L"HsmConnectToServer",
        L"HRESULT = %ls, *ppv = %ls",
        WsbHrAsString ( hr ), WsbPtrToPtrAsString ( ppv ) );

    return ( hr );

}

HRESULT
HsmGetComputerNameFromADsPath(
    IN  const OLECHAR * szADsPath,
    OUT OLECHAR **      pszComputerName
)

/*++

Routine Description:

    Extract the computer name from the ADs path of the RemoteStorage node.
    The assumption here is that the full ADs path will contain this substring:
        "CN=RemoteStorage,CN=computername,CN=Computers"
    where computername is what we want to return.

Arguments:

    szADsPath       - The ADs path.

    pszComputerName - The returned computer name.

Return Value:

    S_OK    - Computer name returned OK.

--*/
{
    HRESULT  hr = S_FALSE;
    WCHAR*   pContainerNode;
    WCHAR*   pRSNode;

    WsbTraceIn(OLESTR("HsmGetComputerNameFromADsPath"),
        OLESTR("AdsPath = <%ls>"), szADsPath);

    //  Find the RemoteStorage node name and the computers node name
    //  in the ADs path. If the machine is a DC, then we have to 
    //  check for a "Domain Controllers" level instead.
    *pszComputerName = NULL;
    pRSNode = wcsstr(szADsPath, RsNodeName);
    pContainerNode = wcsstr(szADsPath, ComputersNodeName);
    if(!pContainerNode) {
        pContainerNode = wcsstr(szADsPath, DCsNodeName);
    }
    if (pRSNode && pContainerNode && pRSNode < pContainerNode) {
        WCHAR*  pWc;

        //  Find the "CN=" before the computer name
        pWc = wcsstr(pRSNode, CNEqual);
        if (pWc && pWc < pContainerNode) {
            WCHAR*  pComma;

            //  Skip the "CN="
            pWc += wcslen(CNEqual);

            //  Find the "," after the computer name
            pComma = wcschr(pWc, OLECHAR(','));

            //  Extract the computer name
            if (pWc < pContainerNode && pComma && pComma < pContainerNode) {
                int len;

                len = (int)(pComma - pWc);

                //  Remove '$' from end of name???
                if (0 < len && OLECHAR('$') == pWc[len - 1]) {
                    len--;
                }
                *pszComputerName = static_cast<OLECHAR *>(WsbAlloc(
                        (len + 1) * sizeof(WCHAR)));
                if (*pszComputerName) {
                    wcsncpy(*pszComputerName, pWc, len);
                    (*pszComputerName)[len] = 0;
                    hr = S_OK;
                }
            }
        }
    }

    WsbTraceOut (OLESTR("HsmGetComputerNameFromADsPath"),
        OLESTR("HRESULT = %ls, Computername = <%ls>"),
        WsbHrAsString(hr), (*pszComputerName ? *pszComputerName : OLESTR("")));

    return(hr);
}


static HRESULT HsmGetComputerNode(
    const OLECHAR * Name,
    IADsContainer **ppContainer
)

/*++

Routine Description:

    Return the computer node for the given computer name in the current Domain

Arguments:

    Name        - Computer name.

    ppContainer - Returned interface pointer of the node.

Return Value:

    S_OK - Success.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn ( L"HsmGetComputerNode", L"Name = <%ls>", Name);

    try {
        WsbAssert(UseDirectoryServices, E_NOTIMPL);

        WCHAR         ComputerDn[MAX_PATH];
        CWsbStringPtr temp;
        ULONG         ulen;

        //  Construct the SamCompatible (whatever that means) name
        temp = DomainName;
        temp.Append("\\");
        temp.Append(Name);
        temp.Append("$");
        WsbTrace(L"HsmGetComputerNode: Domain\\computer = <%ls>\n", 
                static_cast<OLECHAR*>(temp));

        //  Translate that name to a fully qualified one
        ulen = MAX_PATH;
        ComputerDn[0] = WCHAR('\0');
        if (TranslateName(temp, NameSamCompatible,
                NameFullyQualifiedDN, ComputerDn, &ulen)) {
            WsbTrace(L"HsmGetComputerNode: ComputerDn = <%ls>\n", ComputerDn);

            //  Get the computer node
            temp = "LDAP://";
            temp.Append(ComputerDn);
            WsbTrace(L"HsmGetComputerNode: calling ADsGetObject with <%ls>\n", 
                    static_cast<OLECHAR*>(temp));
            WsbAffirmHr(ADsGetObject(temp, IID_IADsContainer, 
                    (void**)ppContainer));
        } else {
            DWORD  err = GetLastError();

            WsbTrace(L"HsmGetComputerNode: TranslateName failed; ComputerDn = <%ls>, err = %ld\n", 
                    ComputerDn, err);
            if (err) {
                WsbThrow(HRESULT_FROM_WIN32(err));
            } else {
                WsbThrow(E_UNEXPECTED);
            }
        }

        WsbTrace(OLESTR("HsmGetComputerNode: got computer node\n"));

    } WsbCatch( hr )

    WsbTraceOut ( L"HsmGetComputerNode", L"HRESULT = %ls, *ppContainer = '%ls'", 
        WsbHrAsString ( hr ), WsbPtrToPtrAsString ( (void**)ppContainer ) );

    return ( hr );
}


static HRESULT
HsmGetDsChild (
    IN  IADsContainer * pContainer,
    IN  const OLECHAR * Name,
    IN  REFIID          riid,
    OUT void **         ppv
    )

/*++

Routine Description:

    This routine returns back the requested child node.

Arguments:

    pContainer - The parent container.

    Name       - The childs name (i.e. value of Name attribute or CN=Name)

    riid       - Desired interface to return.

    ppv        - Returned interface.

Return Value:

    S_OK      - Connection made, Success.

    E_POINTER - Invalid pointer passed in as parameter.

    E_*       - Error

--*/

{
    WsbTraceIn ( L"HsmGetDsChild",
        L"pContainer = '0x%p', Name = '%ls', riid = '%ls', ppv = '0x%p'",
        pContainer, Name, WsbGuidAsString ( riid ), ppv );

    HRESULT hr = S_OK;

    try {
        CWsbStringPtr                 lName;
        CComPtr<IDispatch>            pDispatch;

        // Validate params
        WsbAssert ( 0 != pContainer, E_POINTER );
        WsbAssert ( 0 != Name,       E_POINTER );
        WsbAssert ( 0 != ppv,        E_POINTER );
        WsbAssert(UseDirectoryServices, E_NOTIMPL);

        //  Check to see if the child exists
        lName = Name;
        hr = pContainer->GetObject(NULL, lName, &pDispatch);
        if (FAILED(hr)) {
            hr = S_OK;
            lName.Prepend(CNEqual);
            WsbAffirmHr(pContainer->GetObject(NULL, lName, &pDispatch));
        }

        //  Convert to the correct interface
        WsbAffirmHr(pDispatch->QueryInterface(riid, ppv));

    } WsbCatch( hr )

    WsbTraceOut ( L"HsmGetDsChild", L"HRESULT = %ls, *ppv = '%ls'", 
        WsbHrAsString ( hr ), WsbPtrToPtrAsString ( ppv ) );

    return ( hr );
}


static const OLECHAR *
HsmConnTypeAsString (
    IN  HSMCONN_TYPE type
    )

/*++

Routine Description:

    Gives back a static string representing the connection type. 
    Note return type is strictly ANSI. This is intentional to make
    macro work possible.

Arguments:

    type - the type to return a string for.

Return Value:

    NULL - invalid type passed in.

    Otherwise, a valid char *.

--*/

{
#define STRINGIZE(_str) (OLESTR( #_str ))
#define RETURN_STRINGIZED_CASE(_case) \
case _case:                           \
    return ( STRINGIZE( _case ) );

    //
    // Do the Switch
    //

    switch ( type ) {

    RETURN_STRINGIZED_CASE( HSMCONN_TYPE_HSM );
    RETURN_STRINGIZED_CASE( HSMCONN_TYPE_FSA );
    RETURN_STRINGIZED_CASE( HSMCONN_TYPE_FILTER );
    RETURN_STRINGIZED_CASE( HSMCONN_TYPE_RESOURCE );

    default:

        return ( OLESTR("Invalid Value") );

    }
}

static GUID 
HsmConnTypeToGuid(IN HSMCONN_TYPE type)
{
    GUID serverGuid = GUID_NULL;

    switch ( type ) {
    case HSMCONN_TYPE_HSM:
        serverGuid = CLSID_HsmServer;
        break;
    case HSMCONN_TYPE_FSA:
    case HSMCONN_TYPE_RESOURCE:
        serverGuid = CLSID_CFsaServerNTFS;
        break;
    }
    return(serverGuid);
}


HRESULT
HsmConnectFromName (
    IN  HSMCONN_TYPE type,
    IN  const OLECHAR * Name,
    IN  REFIID riid,
    OUT void ** ppv
    )

/*++

Routine Description:

    When given an name, connect and return the object representing the 
    Server, providing the specified interface.

Arguments:

    type - The type of service / object we are connecting too.

    Name - UNICODE string describing the Server to connect to.

    riid - The interface type to return.

    ppv - Returned interface pointer of the Server.

Return Value:

    S_OK - Connection made, Success.

    E_NOINTERFACE - Requested interface not supported by Server.

    E_POINTER - ppv or Name is not a valid pointer.

    E_OUTOFMEMORY - Low memory condition prevented connection.

    E_INVALIDARG - The given name does not corespond to a known Server.

--*/

{
    WsbTraceIn ( L"HsmConnectFromName",
        L"type = '%ls', Name = '%ls', riid = '%ls', ppv = 0x%p",
        HsmConnTypeAsString ( type ), Name, WsbGuidAsString ( riid ), ppv );
    WsbTrace(OLESTR("HsmConnectFromName: UseDirectoryServices = %ls\n"),
        WsbBoolAsString(UseDirectoryServices));

    HRESULT hr = S_OK;

    try {
        BOOLEAN    done = FALSE;

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != Name, E_POINTER );
        WsbAssert ( 0 != ppv,    E_POINTER );

        if (!done) { // Try without Directory Services

            CWsbStringPtr ComputerName = Name;
            int           i;

            //  Get the computer/server name
            i = wcscspn(Name, OLESTR("\\"));
            ComputerName[i] = 0;

            if (HSMCONN_TYPE_RESOURCE == type) {
                CWsbStringPtr         Path;
                OLECHAR *             rscName;
                CComPtr<IFsaResource> pFsaResource;
                CComPtr<IFsaServer>   pFsaServer;

                WsbAffirmHr(HsmConnectToServer(type, ComputerName, 
                        IID_IFsaServer, (void**)&pFsaServer));

                // Determine if we have a logical name or a sticky name format.
                // The logical name is a format like ("server\NTFS\d") and a sticky name
                // format is like ("server\NTFS\Volume{GUID}\").
                // Find the start of the last section and determine if there is only a single
                // character after it or not.
                rscName = wcsstr ( Name, L"NTFS\\" );
                WsbAssert ( 0 != rscName, E_INVALIDARG );

                // Now point just past the "NTFS\" part of the string. So we are pointing at
                // either a single character, indicating the drive, or the "Volume{GUID}\".
                rscName += 5;       
                Path = rscName;
                if (wcslen (rscName) == 1)  {
                    //  Logical name ("server\NTFS\d") so convert to path and find resource
                    WsbAffirmHr(Path.Append(":\\"));
                    WsbAffirmHr(pFsaServer->FindResourceByPath(Path, &pFsaResource));
                }
                else {
                    // Sticky name ("server\NTFS\Volume{GUID}\") so find resource for it.
                    WsbAffirmHr(pFsaServer->FindResourceByStickyName(Path, &pFsaResource));
                }

                WsbAffirmHr(pFsaResource->QueryInterface(riid, ppv));

            } else {
                WsbAffirmHr(HsmConnectToServer(type, ComputerName, riid, ppv));
            }
        }

    } WsbCatch ( hr )

    WsbTraceOut ( L"HsmConnectFromName",
        L"HRESULT = %ls, *ppv = %ls",
        WsbHrAsString ( hr ), WsbPtrToPtrAsString ( ppv ) );

    return ( hr );

}


HRESULT
HsmConnectFromId (
    IN  HSMCONN_TYPE type,
    IN  REFGUID rguid,
    IN  REFIID riid,
    OUT void ** ppv
    )

/*++

Routine Description:

    Connects to the specified service or object. See HSMCONN_TYPE for
    the types of services and objects. 

Arguments:

    type - The type of service / object we are connecting too.

    rguid - The unique ID of the service / object to connect too.

    riid - The interface type to return.

    ppv - Returned interface pointer of the HSM Server.

Return Value:

    S_OK - Connection made, Success.

    E_NOINTERFACE - Requested interface not supported by HSM Server.

    E_POINTER - ppv or Hsm is not a valid pointer.

    E_OUTOFMEMORY - Low memory condition prevented connection.

    E_INVALIDARG - The given ID and type do not correspond to a known 
                   service or object.

--*/

{
    WsbTraceIn ( L"HsmConnectFromId",
        L"type = '%ls', rguid = '%ls', riid = '%ls', ppv = 0x%p",
        HsmConnTypeAsString ( type ), WsbStringCopy ( WsbGuidAsString ( rguid ) ),
        WsbStringCopy ( WsbGuidAsString ( riid ) ), ppv );
    WsbTrace(OLESTR("HsmConnectFromId: UseDirectoryServices = %ls\n"),
        WsbBoolAsString(UseDirectoryServices));

    HRESULT hr = S_OK;

    try {
        BOOLEAN          DSUsed = FALSE;
        CWsbVariant      guidVariant;
        CComPtr < IADs > pObject;
        CWsbStringPtr    serverName;
        CWsbVariant      serverVariant;

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != ppv,   E_POINTER );

        switch ( type ) {

        case HSMCONN_TYPE_HSM:
        case HSMCONN_TYPE_FSA:
        case HSMCONN_TYPE_FILTER:

            if (DSUsed) {

            } else {

                WsbAffirmHr( WsbGetComputerName( serverName ) );

            }

            //
            // Connect to the server
            //

            WsbAffirmHr ( HsmConnectToServer ( type, serverName, riid, ppv ) );

            break;

        case HSMCONN_TYPE_RESOURCE:
            {
                CComPtr< IFsaServer > pFsaServer;
                GUID serverGuid;
    
                serverGuid = HsmConnTypeToGuid(type);
                WsbAffirmHr ( HsmConnectFromId ( HSMCONN_TYPE_FSA, serverGuid, IID_IFsaServer, (void**)&pFsaServer ) );

                CComPtr< IFsaResource > pFsaResource;

                WsbAffirmHr ( pFsaServer->FindResourceById ( rguid, &pFsaResource ) );
                WsbAffirmHr ( pFsaResource->QueryInterface ( riid, ppv ) );
            }
            break;

        default:

            WsbThrow ( E_INVALIDARG );

        }

    } WsbCatch ( hr )

    WsbTraceOut ( L"HsmConnectFromId",
        L"HRESULT = %ls, *ppv = %ls",
        WsbHrAsString ( hr ), WsbPtrToPtrAsString ( ppv ) );

    return ( hr );

}


HRESULT
HsmPublish (
    IN  HSMCONN_TYPE type,
    IN  const OLECHAR * Name,
    IN  REFGUID rguidObjectId,
    IN  const OLECHAR * Server,
    IN  REFGUID rguid
    )

/*++

Routine Description:

    Publish (i.e. store) information about the service/object in
    Directory Services.

Arguments:

    type - The type of service/object.

    Name - Name (possibly preceded by a subpath) of the Service/Object.

    rguidObjectId - The ID that the object is known by.

    Server - The server (computer name) on which the service actually exists. 
            For resources, this will be NULL since it is implicit in the
            FSA specified by rguid.

    rguid - For resources, the ID of the FSA. For services, the CLSID of
            the service's class factory ie. CLSID_HsmServer.

Return Value:

    S_OK - Connection made, Success.

    E_POINTER - Name or Server is not a valid pointer.

    E_OUTOFMEMORY - Low memory condition prevented connection.

--*/

{
    HRESULT hr = S_OK;

    WsbTraceIn ( L"HsmPublish",
        L"type = '%ls', Name = '%ls', rguidObjectId = '%ls', Server = '%ls', rguid = '%ls'",
        HsmConnTypeAsString ( type ), Name, 
        WsbStringCopy ( WsbGuidAsString ( rguidObjectId ) ), Server,
        WsbStringCopy ( WsbGuidAsString ( rguid ) ) );
    WsbTrace(OLESTR("HsmPublish: UseDirectoryServices = %ls\n"),
        WsbBoolAsString(UseDirectoryServices));

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != Name, E_POINTER );
        WsbAssert ( ( HSMCONN_TYPE_RESOURCE == type ) || ( 0 != Server ), E_POINTER );

        // Perhaps we should output a log event if the DS is not writable

        //  We now only publish the Engine service.  Perhaps in the future we
        //  will publish additional information
        if (HSMCONN_TYPE_HSM == type && UseDirectoryServices && DSIsWritable) {
            CWsbStringPtr    pathToName;

            try {
                DWORD                         aSet;
                CWsbStringPtr                 guidString(rguidObjectId);
                HRESULT                       hrGetNode;
                CComPtr<IADsContainer>        pComputer;
                CComPtr<IDispatch>            pDispatch;
                CComPtr<IDirectoryObject>     pDirObj;
                CComPtr<IADs>                 pNode;

                //  Save the node name for the event log message
                pathToName = Name;
                pathToName.Append("\\");
                pathToName.Append(RsNodeName);

                //  Get the computer node
                WsbAffirmHr(HsmGetComputerNode(Name, &pComputer));

                //  See if we're already published
                hrGetNode = HsmGetDsChild(pComputer, RsNodeName, 
                        IID_IADs, (void**)&pNode);

                //  If not, add our node
                if (HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) == hrGetNode) {
                    CWsbBstrPtr                relPath(RsNodeName);

                    relPath.Prepend(CNEqual);

                    WsbAffirmHr(pComputer->Create(RsNodeType, relPath, &pDispatch));
                    WsbAffirmHr(pDispatch->QueryInterface(IID_IADs, 
                            (void**)&pNode));

                    //  Force info out of cache
                    WsbAffirmHr(pNode->SetInfo());
                } else {
                    WsbAffirmHr(hrGetNode);
                }

                //  Set the GUID & ServiceBinding values
                adsValue[0].dwType = ADSTYPE_CASE_IGNORE_STRING;
                adsValue[0].CaseIgnoreString = (WCHAR*)guidString;

                aaInfo[0].pszAttrName = GuidAttrName;
                aaInfo[0].dwControlCode = ADS_ATTR_UPDATE;
                aaInfo[0].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
                aaInfo[0].pADsValues = &adsValue[0];
                aaInfo[0].dwNumValues = 1;

                adsValue[1].dwType = ADSTYPE_CASE_IGNORE_STRING;
                adsValue[1].CaseIgnoreString = ServiceBindValue;

                aaInfo[1].pszAttrName = ServiceBindAttrName;
                aaInfo[1].dwControlCode = ADS_ATTR_UPDATE;
                aaInfo[1].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
                aaInfo[1].pADsValues = &adsValue[1];
                aaInfo[1].dwNumValues = 1;

                WsbAffirmHr(pNode->QueryInterface(IID_IDirectoryObject, 
                       (void**)&pDirObj));
                WsbAffirmHr(pDirObj->SetObjectAttributes(aaInfo, 2, &aSet));
                WsbTrace(L"HsmPublish: after SetObjectAttributes, aSet = %ld\n",
                        aSet);

                WsbLogEvent(WSB_MESSAGE_PUBLISH_IN_DS, 0, NULL,
                        static_cast<OLECHAR*>(pathToName), NULL);
            } WsbCatchAndDo(hr, 
                WsbLogEvent(WSB_MESSAGE_PUBLISH_FAILED, 0, NULL,
                        static_cast<OLECHAR*>(pathToName), NULL);
                hr = S_OK;  // Don't stop service just for this
            )
        }

    } WsbCatch ( hr )

    WsbTraceOut ( L"HsmPublish", L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );

}



//  GetDSState - determine if we're using Directory Services or not
static void GetDSState(void)
{

    BOOL                     CheckForDS = TRUE;
    DOMAIN_CONTROLLER_INFO * dc_info;
    DWORD                    size;
    OLECHAR                  vstr[32];
    DWORD                    status;

    UseDirectoryServices = FALSE;

    //  Should we attempt to use directory services in this module?
    //  (Setting the registry value to "0" allows us to avoid Directory
    //  Services completely

    if (S_OK == WsbGetRegistryValueString(NULL, REG_PATH, REG_USE_DS,
            vstr, 32, &size)) {
        OLECHAR *stop;
        ULONG   value;

        value = wcstoul(vstr,  &stop, 10 );
        if (0 == value) {
            CheckForDS = FALSE;
        }
    }

    //  Get the account domain name
    WsbGetAccountDomainName(DomainName, MAX_COMPUTERNAME_LENGTH );

#if defined(HSMCONN_DEBUG)
    swprintf(dbg_string, L"Account domain name = <%ls>\n", DomainName);
    OutputDebugString(dbg_string);
#endif

    //  Check if Directory Services is available
    if (CheckForDS) {
        status = DsGetDcName(NULL, NULL, NULL, NULL, 
                DS_DIRECTORY_SERVICE_REQUIRED | DS_IS_FLAT_NAME | 
                DS_RETURN_FLAT_NAME, &dc_info);

#if defined(HSMCONN_DEBUG)
        swprintf(dbg_string, L"DsGetDcName status = %d\n", status);
        OutputDebugString(dbg_string);
#endif

        if (NO_ERROR == status) {

#if defined(HSMCONN_DEBUG)
            swprintf(dbg_string, L"dc_info->DomainName = <%ls>\n", dc_info->DomainName);
            OutputDebugString(dbg_string);
#endif

            if (dc_info->Flags & DS_DS_FLAG) {
                wcscpy(DomainName, dc_info->DomainName);
                UseDirectoryServices = TRUE;
                if (dc_info->Flags & DS_WRITABLE_FLAG) {
                    DSIsWritable = TRUE;
                }
            }
            NetApiBufferFree(dc_info);
        }
    }

#if defined(HSMCONN_DEBUG)
    swprintf(dbg_string, L"dHsmConn - GetDSState: UseDirectoryServices = %ls\n", 
           WsbBoolAsString(UseDirectoryServices));
    OutputDebugString(dbg_string);
#endif
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\hsmconn\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H

/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Common include file for all of HsmConn DLL files.

Author:

    Rohde Wakefield    [rohde]   14-Oct-1997

Revision History:

--*/

#define WSB_TRACE_IS WSB_TRACE_BIT_HSMCONN



#include "Wsb.h"
#include "CName.h"
#include "HsmConn.h"
#include "FsaLib.h"

//
// This must be after the Wsb.h is include for the static registry stuff to be there.
//
#include <activeds.h>
#include <atlimpl.cpp>

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\hsmservr\hsmconpt.h ===
// hsmconpt.h : Declaration of the CHsmConnPoint

#ifndef __HSMCONNPOINT_H_
#define __HSMCONNPOINT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CHsmConnPoint
class ATL_NO_VTABLE CHsmConnPoint : 
	public CComObjectRoot,  //  this may change in the future to CWsbObject
	public CComCoClass<CHsmConnPoint, &CLSID_HsmConnPoint>,
	public IHsmConnPoint
{
public:
	CHsmConnPoint()	{}

DECLARE_REGISTRY_RESOURCEID(IDR_HSMCONNPOINT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHsmConnPoint)
	COM_INTERFACE_ENTRY(IHsmConnPoint)
END_COM_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IHsmConnPoint
public:
	STDMETHOD(GetFsaServer)(/*[out]*/ IFsaServer **ppFsaServer);
	STDMETHOD(GetEngineServer)(/*[out]*/ IHsmServer **ppHsmServer);
};

#endif //__HSMCONNPOINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\hsmservr\hsmconpt.cpp ===
// hsmconpt.cpp : Implementation of CHsmConnPoint
#include "stdafx.h"
#include "Hsmservr.h"
#include "hsmconpt.h"

// define for access to global server objects
extern IHsmServer *g_pEngServer;
extern IFsaServer *g_pFsaServer;

extern CRITICAL_SECTION g_FsaCriticalSection;
extern CRITICAL_SECTION g_EngCriticalSection;

extern BOOL g_bEngInitialized;
extern BOOL g_bFsaInitialized;

static USHORT iCount = 0;  // Count of existing objects

/////////////////////////////////////////////////////////////////////////////
// CHsmConnPoint


STDMETHODIMP CHsmConnPoint::FinalConstruct(void)
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT        hr = S_OK;

    WsbTraceIn(OLESTR("CHsmConnPoint::FinalConstruct"), OLESTR(""));

    try {

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        // currently, no private initialization

        //  Add class to object table
        WSB_OBJECT_ADD(CLSID_CFsaScanItemNTFS, this);

    } WsbCatch(hr);

    iCount++;

    WsbTraceOut(OLESTR("CHsmConnPoint::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
            WsbHrAsString(hr), iCount);

    return(hr);
}

STDMETHODIMP CHsmConnPoint::FinalRelease(void)
/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmConnPoint::FinalRelease"), OLESTR(""));

    //  Subtract class from object table
    WSB_OBJECT_SUB(CLSID_CFsaScanItemNTFS, this);

    // currently, no private cleanup

    // Let the parent class do his thing.
    CComObjectRoot::FinalRelease();

    iCount--;

    WsbTraceOut(OLESTR("CHsmConnPoint::FinalRelease"), OLESTR("hr = <%ls>, Count is <%d>"), 
            WsbHrAsString(hr), iCount);
    return (hr);
}



STDMETHODIMP CHsmConnPoint::GetEngineServer(IHsmServer **ppHsmServer)
{
    // If Engine server has been created, return the pointer. Otherwise, fail.
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmConnPoint::GetEngineServer"), OLESTR(""));

    try {
        // verify that pointers are valid
        WsbAssert (ppHsmServer !=  0, E_POINTER);
        WsbAffirm (g_pEngServer != 0, HSM_E_NOT_READY);

        // assign in a safe manner (only if manager object is already initializaed)
        EnterCriticalSection(&g_EngCriticalSection);
        if (g_bEngInitialized) {
            _ASSERTE(g_pEngServer != 0);    // shouldn't happen
            *ppHsmServer = g_pEngServer;
            g_pEngServer->AddRef();
        } else {
            hr = HSM_E_NOT_READY;
        }
        LeaveCriticalSection (&g_EngCriticalSection);

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmConnPoint::GetEngineServer"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
	return (hr);
}

STDMETHODIMP CHsmConnPoint::GetFsaServer(IFsaServer **ppFsaServer)
{
    // If Fsa server has been created, return the pointer. Otherwise, fail.
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmConnPoint::GetFsaServer"), OLESTR(""));

    try {
        // verify that pointers are valid
        WsbAssert (ppFsaServer !=  0, E_POINTER);
        WsbAffirm (g_pFsaServer != 0, FSA_E_NOT_READY);

        // assign in a safe manner (only if manager object is already initializaed)
        EnterCriticalSection(&g_FsaCriticalSection);
        if (g_bFsaInitialized) {
            _ASSERTE(g_pFsaServer != 0);    // shouldn't happen
            *ppFsaServer = g_pFsaServer;
            g_pFsaServer->AddRef();
        } else {
            hr = FSA_E_NOT_READY;
        }
        LeaveCriticalSection(&g_FsaCriticalSection);

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmConnPoint::GetFsaServer"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\hsmservr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hsmservr.rc
//
#define IDS_SERVICENAME                 100
#define IDR_Hsmservr                    100
#define IDS_SERVICE_DISPLAYNAME         101
#define IDS_SERVICE_DESCRIPTION         102
#define IDS_PRODUCT_NAME                103
#define IDR_HSMCONNPOINT                104
#define IDR_Serv2Proc                   105
#define IDR_Proc2Serv                   106
#define IDC_CURSOR1                     201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\hsmservr\service\makefile.inc ===
$(O)\hsmservr.res: ..\hsmservr.rgs   \
	           ..\hsmconpt.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Wsb.rc
//
#define IDR_CWsbDbKey                   12
#define IDS_WSBDBKEY_DESC               14
#define IDR_CWsbDbSys                   20
#define IDS_WSBDBSYS_DESC               20


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\makefile.inc ===
$(O)\rsidb.res:  \
              wsbdbkey.rgs   \
              wsbdbsys.rgs

stdafx.h: ..\inc\wsb.h ..\inc\wsbdb.h

clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\hsmservr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _STDAFX_H
#define _STDAFX_H

//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#define WSB_TRACE_IS WSB_TRACE_BIT_HSMSERV
#define WSB_ATL_COM_SERVICE

#include <wsb.h>
#include "resource.h"
#include "esent.h"

extern CComPtr<IWsbTrace> g_pTrace;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !ifndef _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\rsidb.cpp ===
// WsbIdb.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      Modify the custom build rule for Wsb.idl by adding the following 
//      files to the Outputs.  You can select all of the .IDL files by 
//      expanding each project and holding Ctrl while clicking on each of them.
//          Wsb_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f Wsbps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "wsb.h"
#include "wsbdbsys.h"
#include "wsbdbent.h"
#include "wsbdbkey.h"

//#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CWsbDbKey, CWsbDbKey)
    OBJECT_ENTRY(CLSID_CWsbDbSys, CWsbDbSys)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

    }

    else if (dwReason == DLL_PROCESS_DETACH) {

        _Module.Term();

    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
    // Add service entries
//    hRes = _Module.UpdateRegistryFromResourceS(IDR_Wsb, TRUE);
//  if (FAILED(hRes))
//      return hRes;

#endif
    HRESULT hr;

    // registers object, typelib and all interfaces in typelib
    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
        hr = _Module.RegisterServer( FALSE );
        CoUninitialize( );
    }
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    // Remove service entries
//    _Module.UpdateRegistryFromResourceS(IDR_Wsb, FALSE);

    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        hr = S_OK;
    }
    CoUninitialize( );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\hsmservr\hsmservr.cpp ===
/*++

Module Name:

    hsmservr.cpp

Abstract:

    Provides the Service and main executable implementation.

Author:

    Ran Kalach [rankala]

Revision History:

--*/

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f hsmservrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"

#include "engcommn.h"

// This include is here due to a MIDL bug - it should have been in the created file hsmservr.h
#include "fsalib.h"

#include "hsmservr.h"

#include <stdio.h>
#include "hsmconpt.h"

// Service dependencies for the HSM server service

#define ENG_DEPENDENCIES  L"EventLog\0RpcSs\0Schedule\0NtmsSvc\0\0"

// Service name
#define SERVICE_LOGICAL_NAME    _T("Remote_Storage_Server")
#define SERVICE_DISPLAY_NAME    L"Remote Storage Server"


CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_HsmConnPoint, CHsmConnPoint)
END_OBJECT_MAP()

// The global server objects
IHsmServer *g_pEngServer;
IFsaServer *g_pFsaServer;

BOOL g_bEngCreated = FALSE;
BOOL g_bEngInitialized = FALSE;
BOOL g_bFsaCreated = FALSE;
BOOL g_bFsaInitialized = FALSE;

CRITICAL_SECTION g_FsaCriticalSection;
CRITICAL_SECTION g_EngCriticalSection;

#define HSM_SERVER_TRACE_FILE_NAME       OLESTR("rsserv.trc")

CComPtr<IWsbTrace>  g_pTrace;

// Global functions for console handling
static void ConsoleApp(void);
BOOL WINAPI ConsoleHandler(DWORD dwCtrlType);

static void DebugRelease (void);


// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib)
{
    WsbTraceIn ( L"CServiceModule::RegisterServer", L"bRegTypeLib = %ls", WsbBoolAsString ( bRegTypeLib ) );

    HRESULT hr = S_OK;
    try {

        WsbAssertHr ( CoInitialize ( NULL ) );

        //
        // Do not try to remove any previous service since this can cause a delay
        // in the registration to happen when another process is trying to get
        // this program to self register
        //

        //
        // Add service entries
        //
        WsbAssertHr( UpdateRegistryFromResource( IDR_Hsmservr, TRUE ) );

        //
        // Create service
        //
        WsbAssert( Install(), E_FAIL ) ;

        //
        // Add object entries
        //
        WsbAssertHr ( CComModule::RegisterServer( bRegTypeLib ) );

        CoUninitialize();

    }WsbCatch ( hr )

    WsbTraceOut ( L"CServiceModule::RegisterServer", L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return( hr );
}

inline HRESULT CServiceModule::UnregisterServer()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(IDR_Hsmservr, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer();

    CoUninitialize();
    return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
    WsbTraceIn ( L"CServiceModule::Init", L"" );

    CComModule::Init(p, h);

    m_bService = TRUE;

    _tcscpy(m_szServiceName, SERVICE_LOGICAL_NAME);

    // set up the initial service status
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN |
                                  SERVICE_ACCEPT_POWEREVENT | SERVICE_ACCEPT_PAUSE_CONTINUE;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    WsbTraceOut ( L"CServiceModule::Init", L"" );
}

LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();

/*  This line put in comment since it causes the process to immediately exit
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);   */

    return l;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL) {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL) {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
/*++

Routine Description:

    Install service module.

Arguments:

    None.

Return Value:

    TRUE    - Service installed successfully

    FALSE   - Service install failed

--*/
{

    BOOL bResult = FALSE;
    CWsbStringPtr errorMessage;
    CWsbStringPtr displayName;
    CWsbStringPtr description;

    if (!IsInstalled()) {

        displayName = SERVICE_DISPLAY_NAME;
        description.LoadFromRsc(_Module.m_hInst, IDS_SERVICE_DESCRIPTION );

        SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (hSCM) {

            // Get the executable file path
            TCHAR szFilePath[_MAX_PATH+1];
            ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

            SC_HANDLE hService = ::CreateService(
                                                hSCM, m_szServiceName, (OLECHAR *) displayName,
                                                SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
                                                SERVICE_AUTO_START, SERVICE_ERROR_NORMAL,
                                                szFilePath, NULL, NULL, ENG_DEPENDENCIES, NULL, NULL);

            if (hService) {

                // the service was successfully installed.
                bResult = TRUE;

                SERVICE_DESCRIPTION svcDesc;
                svcDesc.lpDescription = description;

                ::ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &svcDesc);
                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hSCM);

            } else {
                errorMessage = WsbHrAsString(HRESULT_FROM_WIN32( GetLastError() ) );
                ::CloseServiceHandle(hSCM);
                MessageBox(NULL, errorMessage, (OLECHAR *) displayName, MB_OK);
            }

        } else {
            MessageBox(NULL, WsbHrAsString(HRESULT_FROM_WIN32( GetLastError() ) ), (OLECHAR *) displayName, MB_OK);
        }

    } else {

        // service already install, just return TRUE.
        bResult = TRUE;
    }

    return bResult;
}

inline BOOL CServiceModule::Uninstall()
/*++

Routine Description:

    Uninstall service module.

Arguments:

    None.

Return Value:

    TRUE    - Service successfully uninstalled.

    FALSE   - Unable to uninstall service.

--*/
{

    BOOL bResult = FALSE;
    CWsbStringPtr errorMessage;
    CWsbStringPtr displayName;

    if (IsInstalled()) {

        displayName = SERVICE_DISPLAY_NAME;

        SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (hSCM) {

            SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, DELETE);
            if (hService) {

                BOOL bDelete = ::DeleteService(hService);
                // if it did not delete then get the error message
                if (!bDelete)
                    errorMessage = WsbHrAsString(HRESULT_FROM_WIN32( GetLastError() ) );

                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hSCM);

                if (bDelete) {

                    // the service was deleted.
                    bResult = TRUE;

                } else {
                    MessageBox(NULL, errorMessage, (OLECHAR *) displayName, MB_OK);
                }

            } else {
                errorMessage = WsbHrAsString(HRESULT_FROM_WIN32( GetLastError() ) );
                ::CloseServiceHandle(hSCM);
                MessageBox(NULL, errorMessage, (OLECHAR *) displayName, MB_OK);
            }

        } else {
            MessageBox(NULL, WsbHrAsString(HRESULT_FROM_WIN32( GetLastError() ) ), (OLECHAR *) displayName, MB_OK);
        }

    } else {
        // service not installed, just return TRUE.
        bResult = TRUE;
    }

    return bResult;

}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions
//

void
CServiceModule::LogEvent(
                        DWORD       eventId,
                        ...
                        )
/*++

Routine Description:

    Log data to event log.

Arguments:

    eventId    - The message Id to log.
    Inserts    - Message inserts that are merged with the message description specified by
                   eventId.  The number of inserts must match the number specified by the
                   message description.  The last insert must be NULL to indicate the
                   end of the insert list.

Return Value:

    None.

--*/
{
    if (m_bService) {
        // Report the event.

        va_list         vaList;

        va_start(vaList, eventId);
        WsbLogEventV( eventId, 0, NULL, &vaList );
        va_end(vaList);
    } else {
        // Just write the error to the console, if we're not running as a service.

        va_list         vaList;
        const OLECHAR * facilityName = 0;
        OLECHAR *       messageText = 0;

        switch ( HRESULT_FACILITY( eventId ) ) {
        
        case WSB_FACILITY_PLATFORM:
        case WSB_FACILITY_RMS:
        case WSB_FACILITY_HSMENG:
        case WSB_FACILITY_JOB:
        case WSB_FACILITY_HSMTSKMGR:
        case WSB_FACILITY_FSA:
        case WSB_FACILITY_GUI:
        case WSB_FACILITY_MOVER:
        case WSB_FACILITY_LAUNCH:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;
        }

        if ( facilityName ) {
            // Print out the variable arguments

            // NOTE: Positional parameters in the inserts are not processed.  These
            //       are done by ReportEvent() only.
            HMODULE hLib =  LoadLibraryEx( facilityName, NULL, LOAD_LIBRARY_AS_DATAFILE );
            if (hLib != NULL) {
                va_start(vaList, eventId);
                FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                               hLib,
                               eventId,
                               MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                               (LPTSTR) &messageText,
                               0,
                               &vaList );
                va_end(vaList);
                FreeLibrary(hLib);
            } 

            if ( messageText ) {
                _putts(messageText);
                LocalFree( messageText );
            } else {
                _tprintf( OLESTR("!!!!! ERROR !!!!! - Message <0x%08x> could not be translated.\n"), eventId );
            }

        } else {
            _tprintf( OLESTR("!!!!! ERROR !!!!! - Message File for <0x%08x> could not be found.\n"), eventId );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain},
        { NULL, NULL}
    };
    if (!::StartServiceCtrlDispatcher(st)) {
        m_bService = FALSE;
        m_status.dwWin32ExitCode = GetLastError();
    }
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    SetServiceStatus(SERVICE_START_PENDING);

    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandlerEx(m_szServiceName, _HandlerEx,
                                                    NULL);
    if (m_hServiceStatus == NULL) {
        LogEvent( HSM_MESSAGE_SERVICE_HANDLER_NOT_INSTALLED, NULL );
        return;
    }

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
    LogEvent( HSM_MESSAGE_SERVICE_STOPPED, NULL );
}

inline DWORD CServiceModule::HandlerEx(DWORD dwOpcode, DWORD fdwEventType,
                                       LPVOID /* lpEventData */, LPVOID /* lpContext */)
{
    DWORD                    dwRetCode = 0;
    HRESULT                  hr = S_OK;
    HRESULT                  hr1 = S_OK;
    HSM_SYSTEM_STATE         SysState;

    WsbTraceIn(OLESTR("CServiceModule::HandlerEx"), OLESTR("opCode=%lx"),
               dwOpcode );

    switch (dwOpcode) {
    case SERVICE_CONTROL_STOP:  {
            SetServiceStatus(SERVICE_STOP_PENDING);
            PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        }
        break;

    case SERVICE_CONTROL_PAUSE:
        SetServiceStatus(SERVICE_PAUSE_PENDING);
        SysState.State = HSM_STATE_SUSPEND;
        if (g_pEngServer && g_bEngInitialized) {
            g_pEngServer->ChangeSysState(&SysState);
        }
        if (g_pFsaServer && g_bFsaInitialized) {
            g_pFsaServer->ChangeSysState(&SysState);
        }
        SetServiceStatus(SERVICE_PAUSED);
        break;

    case SERVICE_CONTROL_CONTINUE:
        SetServiceStatus(SERVICE_CONTINUE_PENDING);
        SysState.State = HSM_STATE_RESUME;
        if (g_pFsaServer && g_bFsaInitialized) {
            g_pFsaServer->ChangeSysState(&SysState);
        }
        if (g_pEngServer && g_bEngInitialized) {
            g_pEngServer->ChangeSysState(&SysState);
        }
        SetServiceStatus(SERVICE_RUNNING);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    case SERVICE_CONTROL_SHUTDOWN:
        // Prepare Eng server for releasing
        if (g_pEngServer && g_bEngInitialized) {
            SysState.State = HSM_STATE_SHUTDOWN;
            if (!SUCCEEDED(hr = g_pEngServer->ChangeSysState(&SysState))) {
                LogEvent( HSM_MESSAGE_SERVICE_FAILED_TO_SHUTDOWN, WsbHrAsString(hr), NULL );
            }
        }

        // Prepare Fsa server for releasing
        if (g_pFsaServer && g_bFsaInitialized) {
            CComPtr<IWsbServer> pWsbServer;
            SysState.State = HSM_STATE_SHUTDOWN;

            // If it was initialized, then we should try to save the current state.
            hr = g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                hr = pWsbServer->SaveAll();
            }
            if (FAILED(hr)) {
               LogEvent(FSA_MESSAGE_SERVICE_FAILED_TO_SAVE_DATABASE, WsbHrAsString(hr), NULL );
            }

            hr = g_pFsaServer->ChangeSysState(&SysState);
            if (FAILED(hr)) {
                LogEvent( FSA_MESSAGE_SERVICE_FAILED_TO_SHUTDOWN, WsbHrAsString(hr), NULL );
            }
        }

        // Release Eng server
        if (g_bEngCreated  && (g_pEngServer != 0)) {
            // Free server inside a crit. section thus avoid conflicts with accessing clients
            EnterCriticalSection(&g_EngCriticalSection);
            g_bEngInitialized = FALSE;
            g_bEngCreated = FALSE;

            // Disconnect all remote clients
            (void)CoDisconnectObject(g_pEngServer, 0);

            // Forse object destroy, ignore reference count here
            IWsbServer *pWsbServer;
            hr = g_pEngServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                pWsbServer->Release();
                pWsbServer->DestroyObject();
            }
            g_pEngServer = 0;
            LeaveCriticalSection (&g_EngCriticalSection);
        }

        // Release Fsa server
        if (g_bFsaCreated && (g_pFsaServer != 0)) {
            // Free server inside a crit. section thus avoid conflicts with accessing clients
            EnterCriticalSection(&g_FsaCriticalSection);
            g_bFsaInitialized = FALSE;
            g_bFsaCreated = FALSE;

            // Disconnect all remote clients
            (void)CoDisconnectObject(g_pFsaServer, 0);

            // Forse object destroy, ignore reference count here
            IWsbServer *pWsbServer;
            hr = g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                pWsbServer->Release();
                pWsbServer->DestroyObject();
            }
            g_pFsaServer = 0;
            LeaveCriticalSection(&g_FsaCriticalSection);
        }

        break;

    case SERVICE_CONTROL_POWEREVENT:
        if (S_OK == WsbPowerEventNtToHsm(fdwEventType, &SysState.State)) {
            WsbTrace(OLESTR("CServiceModule::HandlerEx: power event, fdwEventType = %lx\n"),
                     fdwEventType);

            if (g_pEngServer && g_bEngInitialized) {
                hr = g_pEngServer->ChangeSysState(&SysState);
            }
            if (g_pFsaServer && g_bFsaInitialized) {
                hr1 = g_pFsaServer->ChangeSysState(&SysState);
            }

            if ((S_FALSE == hr) || (S_FALSE == hr1)) {
                dwRetCode = BROADCAST_QUERY_DENY;
            }
        }
        break;

    default:
        LogEvent( HSM_MESSAGE_SERVICE_RECEIVED_BAD_REQUEST, NULL );
    }

    WsbTraceOut(OLESTR("CServiceModule::HandlerEx"), OLESTR("dwRetCode = %lx"),
                dwRetCode );

    return(dwRetCode);
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}

DWORD WINAPI CServiceModule::_HandlerEx(DWORD dwOpcode, DWORD fdwEventType,
                                        LPVOID lpEventData, LPVOID lpContext)
{
    return(_Module.HandlerEx(dwOpcode, fdwEventType, lpEventData, lpContext));
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
    HRESULT hr = S_OK;

    try {
        // Initialize both servers critical section.
        if (! InitializeCriticalSectionAndSpinCount (&g_FsaCriticalSection, 1000)) {
            m_status.dwWin32ExitCode = GetLastError();
            hr = HRESULT_FROM_WIN32(m_status.dwWin32ExitCode);  
            LogEvent( HSM_MESSAGE_SERVICE_INITIALIZATION_FAILED, WsbHrAsString(hr), NULL );
            return;
        }
        if (! InitializeCriticalSectionAndSpinCount (&g_EngCriticalSection, 1000)) {
            m_status.dwWin32ExitCode = GetLastError();
            hr = HRESULT_FROM_WIN32(m_status.dwWin32ExitCode);  
            LogEvent( HSM_MESSAGE_SERVICE_INITIALIZATION_FAILED, WsbHrAsString(hr), NULL );
            DeleteCriticalSection(&g_FsaCriticalSection);
            return;
        }

        _Module.dwThreadID = GetCurrentThreadId();

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        _ASSERTE(SUCCEEDED(hr));
        if (hr != S_OK) {
            m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;
            LogEvent( HSM_MESSAGE_SERVICE_FAILED_COM_INIT, OLESTR("CoInitializeEx"), 
                      WsbHrAsString(hr), NULL );
            DeleteCriticalSection(&g_EngCriticalSection);
            DeleteCriticalSection(&g_FsaCriticalSection);
            return;
        }

        // This provides Admin only access.
        CWsbSecurityDescriptor sd;
        sd.InitializeFromThreadToken();
        WsbAffirmHr(sd.AllowRid( SECURITY_LOCAL_SYSTEM_RID, COM_RIGHTS_EXECUTE ));
        WsbAffirmHr(sd.AllowRid( DOMAIN_ALIAS_RID_ADMINS,   COM_RIGHTS_EXECUTE ));
        hr = CoInitializeSecurity(sd, -1, NULL, NULL,
                                  RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_NONE, NULL);
        _ASSERTE(SUCCEEDED(hr));
        if (hr != S_OK) {
            m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;
            LogEvent( HSM_MESSAGE_SERVICE_FAILED_COM_INIT, OLESTR("CoInitializeSecurity"), 
                      WsbHrAsString(hr), NULL );
            CoUninitialize();
            DeleteCriticalSection(&g_EngCriticalSection);
            DeleteCriticalSection(&g_FsaCriticalSection);
            return;
        }


        // Create the trace object and initialize it
        hr = CoCreateInstance(CLSID_CWsbTrace, 0, CLSCTX_SERVER, IID_IWsbTrace, (void **) &g_pTrace);
        _ASSERTE(SUCCEEDED(hr));
        if (hr != S_OK) {
            m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;
            LogEvent( HSM_MESSAGE_SERVICE_INITIALIZATION_FAILED, WsbHrAsString(hr), NULL );
            CoUninitialize();
            DeleteCriticalSection(&g_EngCriticalSection);
            DeleteCriticalSection(&g_FsaCriticalSection);
            return;
        }

        // Figure out where to store information and initialize trace.
        //  Currently, Engine & Fsa share the same trace file
        WsbGetServiceTraceDefaults(m_szServiceName, HSM_SERVER_TRACE_FILE_NAME, g_pTrace);

        WsbTraceIn(OLESTR("CServiceModule::Run"), OLESTR(""));

        hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
        if (hr != S_OK) {
            m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;
            LogEvent( HSM_MESSAGE_SERVICE_FAILED_COM_INIT, OLESTR("CoRegisterClassObjects"), 
                      WsbHrAsString(hr), NULL );
            g_pTrace = 0;
            CoUninitialize();
            DeleteCriticalSection(&g_EngCriticalSection);
            DeleteCriticalSection(&g_FsaCriticalSection);
            return;
        }

        // Now we need to get the HSM Server initialized
        // First Fsa server is initialized, ONLY if it succeeds, Engine 
        // server is initialized as well
        m_status.dwCheckPoint = 1;
        m_status.dwWaitHint = 60000;
        SetServiceStatus(SERVICE_START_PENDING);

        // initialize Fsa server
        if (! g_pFsaServer) {
            try {
                //
                // Create and initialize the server.
                //
                WsbAffirmHr( CoCreateInstance(CLSID_CFsaServerNTFS, 0, CLSCTX_SERVER, IID_IFsaServer, (void**) &g_pFsaServer) );

                // Created the server, now initialize it
                g_bFsaCreated = TRUE;

                CComPtr<IWsbServer>      pWsbServer;
                WsbAffirmHr(g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer));
                WsbAffirmHrOk(pWsbServer->SetTrace(g_pTrace));

                hr = g_pFsaServer->Init();
                WsbAffirmHrOk(hr);

                g_bFsaInitialized = TRUE;

            }WsbCatchAndDo( hr,

                            // If the error is a Win32 make it back to a Win32 error else send
                            // the HR in the service specific exit code
                            if ( FACILITY_WIN32 == HRESULT_FACILITY(hr) ){
                            m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;}else{
                          m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
                          m_status.dwServiceSpecificExitCode = hr ;}
                          LogEvent( FSA_MESSAGE_SERVICE_INITIALIZATION_FAILED , WsbHrAsString(hr), NULL );
                          );

        }

        WsbTrace (OLESTR("Fsa: Created=%ls , Initialized=%ls\n"), 
                  WsbBoolAsString(g_bFsaCreated), WsbBoolAsString(g_bFsaInitialized));

        // initialize Engine server
        if ((! g_pEngServer) && (hr == S_OK)) {
            try {
                //
                // Create and initialize the server.
                //
                WsbAffirmHr( CoCreateInstance( CLSID_HsmServer, 0, CLSCTX_SERVER,  IID_IHsmServer, (void **)&g_pEngServer ) );
                g_bEngCreated = TRUE;

                CComPtr<IWsbServer>      pWsbServer;
                WsbAffirmHr(g_pEngServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer));
                WsbAffirmHrOk(pWsbServer->SetTrace(g_pTrace));

                WsbAffirmHr(g_pEngServer->Init());
                g_bEngInitialized = TRUE;

            }WsbCatchAndDo(hr,

                           // If the error is a Win32 make it back to a Win32 error else send
                           // the HR in the service specific exit code
                           if ( FACILITY_WIN32 == HRESULT_FACILITY(hr) ){
                           m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;}else{
                          m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
                          m_status.dwServiceSpecificExitCode = hr ;}
                          LogEvent( HSM_MESSAGE_SERVICE_CREATE_FAILED, WsbHrAsString(hr), NULL );
                          );

        }

        WsbTrace (OLESTR("Engine: Created=%ls , Initialized=%ls\n"), 
                  WsbBoolAsString(g_bEngCreated), WsbBoolAsString(g_bEngInitialized));

        if (hr == S_OK) {

            SetServiceStatus(SERVICE_RUNNING);
            LogEvent( HSM_MESSAGE_SERVICE_STARTED, NULL );

            MSG msg;
            while (GetMessage(&msg, 0, 0, 0)) {
                // If something has changed with the devices, then rescan. At somepoint we
                // may want to do a more limited scan (i.e. just update what changed), but this
                // should cover it for now.
                //
                // Since something has changed, we will also force a rewrite of the persistant data.
                if (WM_DEVICECHANGE == msg.message) {

                    CComPtr<IWsbServer> pWsbServer;
                    try {

                        WsbAffirmHr(g_pFsaServer->ScanForResources());

                        WsbAffirmHr(g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer));
                        WsbAffirmHr(pWsbServer->SaveAll());

                    }WsbCatchAndDo(hr,

                        // If we had a problem then log a message and exit the service. We don't
                        // want to leave the service running, since we might have invalid drive
                        // mappings.
                        LogEvent(FSA_MESSAGE_RESCANFAILED, WsbHrAsString(hr), NULL);
                        PostMessage(NULL, WM_QUIT, 0, 0);
                        );

                    pWsbServer = 0;
                }

                DispatchMessage(&msg);
            }
        }

        LogEvent( HSM_MESSAGE_SERVICE_EXITING, NULL );

        // TEMPORARY - call a function so we can break before release.
        DebugRelease ();

        // prepare for releasing Eng server
        if ((g_pEngServer != 0) && g_bEngCreated && g_bEngInitialized) {
            // Save out server data 
            HSM_SYSTEM_STATE    SysState;

            SysState.State = HSM_STATE_SHUTDOWN;
            hr = g_pEngServer->ChangeSysState(&SysState);
            if (FAILED(hr)) {
                LogEvent( HSM_MESSAGE_SERVICE_FAILED_TO_SHUTDOWN, WsbHrAsString(hr), NULL );
            }
        }

        // Prepare for releasing Fsa server
        if ((g_pFsaServer != 0) && g_bFsaCreated && g_bFsaInitialized) {
            CComPtr<IWsbServer>      pWsbServer;
            HSM_SYSTEM_STATE         SysState;

            hr = g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                hr = pWsbServer->SaveAll();
            }

            if (FAILED(hr)) {
                LogEvent( FSA_MESSAGE_SERVICE_FAILED_TO_SAVE_DATABASE, WsbHrAsString(hr), NULL );
            }

            pWsbServer = 0;

            // Persist the databases and release everything
            SysState.State = HSM_STATE_SHUTDOWN;
            hr =  g_pFsaServer->ChangeSysState(&SysState);
            if (FAILED(hr)) {
                LogEvent( FSA_MESSAGE_SERVICE_FAILED_TO_SHUTDOWN, WsbHrAsString(hr), NULL );
            }
        }

        // Release Eng server
        if (g_bEngCreated  && (g_pEngServer != 0)) {
            // Free server inside a crit. section thus avoid conflicts with accessing clients
            EnterCriticalSection(&g_EngCriticalSection);
            g_bEngInitialized = FALSE;
            g_bEngCreated = FALSE;

            // Disconnect all remote clients
            (void)CoDisconnectObject(g_pEngServer, 0);

            // Forse object destroy, ignore reference count here
            IWsbServer *pWsbServer;
            hr = g_pEngServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                pWsbServer->Release();
                pWsbServer->DestroyObject();
            }
            g_pEngServer = 0;
            LeaveCriticalSection (&g_EngCriticalSection);
        }

        // Release Fsa server
        if (g_bFsaCreated && (g_pFsaServer != 0)) {
            // Free server inside a crit. section thus avoid conflicts with accessing clients
            EnterCriticalSection(&g_FsaCriticalSection);
            g_bFsaInitialized = FALSE;
            g_bFsaCreated = FALSE;

            // Disconnect all remote clients
            (void)CoDisconnectObject(g_pFsaServer, 0);

            // Forse object destroy, ignore reference count here
            IWsbServer *pWsbServer;
            hr = g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                pWsbServer->Release();
                pWsbServer->DestroyObject();
            }
            g_pFsaServer = 0;
            LeaveCriticalSection(&g_FsaCriticalSection);
        }

        _Module.RevokeClassObjects();

        WsbTraceOut(OLESTR("CServiceModule::Run"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
        g_pTrace = 0;

        CoUninitialize();

        // Delete the server critical section
        DeleteCriticalSection(&g_EngCriticalSection);
        DeleteCriticalSection(&g_FsaCriticalSection);
    }WsbCatch(hr);
}


//
//	Tries to start the service as a console application 
//	(not through SCM calls)
//
static void ConsoleApp()
{
    HRESULT hr;

    ::SetConsoleCtrlHandler(ConsoleHandler, TRUE) ;

    // set Registry for process
    hr = CoInitialize (NULL);
    if (SUCCEEDED(hr)) {
        hr = _Module.UpdateRegistryFromResourceD(IDR_Serv2Proc, TRUE);
        CoUninitialize();

        _Module.Run();
        //
        // set Registry back for service
        hr = CoInitialize (NULL);
        if (SUCCEEDED(hr)) {
            hr = _Module.UpdateRegistryFromResourceD(IDR_Proc2Serv, TRUE);
            CoUninitialize();
        }
    }
}

//
//	Callback function for handling console events
//

BOOL WINAPI ConsoleHandler(DWORD dwCtrlType)
{
    switch (dwCtrlType) {
    
    case CTRL_BREAK_EVENT:
    case CTRL_C_EVENT:
    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
        PostThreadMessage(_Module.dwThreadID, WM_QUIT, 0, 0);
        return TRUE;
    }

    return FALSE ;
}


/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance,
                                HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    _Module.Init(ObjectMap, hInstance);

    TCHAR szTokens[] = _T("-/");

    LPTSTR lpszToken = _tcstok(lpCmdLine, szTokens);
    while (lpszToken != NULL) {
        if (_tcsicmp(lpszToken, _T("UnregServer"))==0) {
            return _Module.UnregisterServer();
        }
        if (_tcsicmp(lpszToken, _T("RegServer"))==0) {
            return _Module.RegisterServer(FALSE);
        }
#ifdef DBG
        if (_tcsicmp(lpszToken, _T("D"))==0) {
            _Module.m_bService = FALSE;
        }
#endif
        lpszToken = _tcstok(NULL, szTokens);
    }

    //
    // Cheap hack to force the ESE.DLL to be loaded before any other threads are started
    //
    LoadLibrary( L"RsIdb.dll" );

    if (_Module.m_bService) {
        _Module.Start();
    } else {
        ConsoleApp ();
    }

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}


void DebugRelease ()
{
    WsbTrace(OLESTR("DebugRelease in"));

    WsbTrace(OLESTR("DebugRelease out"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\wsbdbkey.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbkey.h

Abstract:

    The CWsbDbKey class, which provides support for IDB entities.

Author:

    Ron White   [ronw]   23-Dec-1996

Revision History:

--*/


#ifndef _WSBDBKEY_
#define _WSBDBKEY_

#include "resource.h"
#include "wsbdb.h"



/*++

Class Name:
    
    CWsbDbKey

Class Description:

    A data base key object.

--*/

class CWsbDbKey : 
    public CWsbObject,
    public IWsbDbKey,
    public IWsbDbKeyPriv,
    public CComCoClass<CWsbDbKey,&CLSID_CWsbDbKey>
{
friend class CWsbDbEntity;
public:
    CWsbDbKey() {}
BEGIN_COM_MAP(CWsbDbKey)
    COM_INTERFACE_ENTRY(IWsbDbKey)
    COM_INTERFACE_ENTRY(IWsbDbKeyPriv)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbDbKey)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbDbKey
public:
    STDMETHOD(AppendBool)(BOOL value);
    STDMETHOD(AppendBytes)(UCHAR* value, ULONG size);
    STDMETHOD(AppendFiletime)(FILETIME value);
    STDMETHOD(AppendGuid)(GUID value);
    STDMETHOD(AppendLonglong)(LONGLONG value);
    STDMETHOD(AppendString)(OLECHAR* value);
    STDMETHOD(GetType)(ULONG* pType);
    STDMETHOD(SetToBool)(BOOL value);
    STDMETHOD(SetToBytes)(UCHAR* value, ULONG size);
    STDMETHOD(SetToFiletime)(FILETIME value);
    STDMETHOD(SetToGuid)(GUID value);
    STDMETHOD(SetToLonglong)(LONGLONG value);
    STDMETHOD(SetToString)(OLECHAR* value);
    STDMETHOD(SetToUlong)(ULONG value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

// Internal helper functions
public:
    STDMETHOD(GetBytes)(UCHAR** ppBytes, ULONG* pSize);
    STDMETHOD(SetType)(ULONG type) { 
        m_type = type; return(S_OK); }
protected:
    BOOL make_key(ULONG size);

protected:
    ULONG           m_max;   // Max size of m_value
    ULONG           m_size;  // Number of bytes in m_value being used
    UCHAR*          m_value;
    ULONG           m_type;  // Key type
};


#endif // _WSBDBKEY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#define WSB_TRACE_IS        WSB_TRACE_BIT_IDB

#include "wsb.h"

#include "esent.h"

#include "wsbdb.h"


#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\wsbdbent.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbent.cpp

Abstract:

    The CWsbDbEntity and CWsbDbKey classes.

Author:

    Ron White   [ronw]   11-Dec-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbdbsys.h"
#include "wsbdbkey.h"


// Flags for binary search
#define BIN_EQ              0x0001
#define BIN_GT              0x0002
#define BIN_LT              0x0004
#define BIN_GTE             (BIN_EQ | BIN_GT)
#define BIN_LTE             (BIN_EQ | BIN_LT)

//  Flags for CopyValues/GetValue/SetValue functions
#define EV_DERIVED_DATA    0x0001
#define EV_INDEX           0x0002
#define EV_POS             0x0004
#define EV_ASNEW           0x0008
#define EV_USEKEY          0x0010
#define EV_SEQNUM          0x0020
#define EV_ALL             0xFFFF



HRESULT
CWsbDbEntity::Clone(
    IN REFIID riid,
    OUT void** ppEntity
    )

/*++

Implements:

  IWsbDbEntity::Clone

--*/
{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::Clone(IWsbEntity)"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);

    try {
        CLSID                    clsid;
        CComPtr<IWsbDbEntity>    pEntity;
        CComPtr<IWsbDbEntityPriv> pEntityPriv;
        CComPtr<IPersistStream>  pIPersistStream;
        IUnknown*                pIUnknown;

        WsbAssert(0 != ppEntity, E_POINTER);

        // Create a new entity instance.
        pIUnknown = (IUnknown *)(IWsbPersistable *)(CWsbCollectable *)this;
        WsbAffirmHr(pIUnknown->QueryInterface(IID_IPersistStream, 
                (void**) &pIPersistStream));
        WsbAffirmHr(pIPersistStream->GetClassID(&clsid));
        WsbAffirmHr(CoCreateInstance(clsid, NULL, CLSCTX_ALL, 
                IID_IWsbDbEntity, (void**) &pEntity));
        WsbAffirmHr(pEntity->QueryInterface(IID_IWsbDbEntityPriv, 
                (void**)&pEntityPriv))

        // Initialize the clone
        if (m_pDb) {
            WsbAffirmHr(pEntityPriv->Init(m_pDb, m_pDbSys, m_RecInfo.Type, m_SessionId));
        }

        // Copy data into the clone
        WsbAffirmHr(pEntityPriv->CopyValues(EV_ALL, this));

        // Get the requested interface
        WsbAffirmHr(pEntity->QueryInterface(riid, (void**)ppEntity));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::Clone(IWbEntity)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::Copy(
    IWsbDbEntity* pEntity
    )

/*++

Implements:

  IWsbDbEntityPriv::Copy

Comments:

  Copy the data in the derived object.

--*/

{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::Copy(IWsbDbEntity)"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);

    try {
        HGLOBAL                  hMem;
        CComPtr<IPersistStream>  pIPersistStream1;
        CComPtr<IPersistStream>  pIPersistStream2;
        CComPtr<IStream>         pIStream;
        IUnknown*                pIUnknown;

        WsbAssert(0 != pEntity, E_POINTER);

        // Get PersistStream interfaces for myself
        pIUnknown = (IUnknown *)(IWsbPersistable *)(CWsbCollectable *)this;
        WsbAffirmHr(pIUnknown->QueryInterface(IID_IPersistStream, (void**) &pIPersistStream1));
        WsbAffirmHr(pEntity->QueryInterface(IID_IPersistStream, (void**) &pIPersistStream2));

        // Create a memory stream
        WsbAffirmHr(getMem(&hMem));
        WsbAffirmHr(CreateStreamOnHGlobal(hMem, FALSE, &pIStream));

        // Save the other entity to the stream
        WsbAffirmHr(pIPersistStream2->Save(pIStream, FALSE));
        pIStream = 0;

        // Load myself from the memory
        WsbAffirmHr(fromMem(hMem));
        GlobalFree(hMem);

        SetIsDirty(TRUE);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::Copy(IWbEntity)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::CopyValues(
    ULONG flags,
    IWsbDbEntity* pEntity
    )

/*++

Implements:

  IWsbDbEntityPriv::CopyValues

Comments:

  Selectively copy some DBEntity values from one entity to another.

--*/

{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::CopyValues(IWsbEntity)"), OLESTR(""));

    try {
        ULONG  value;

        CComPtr<IWsbDbEntityPriv> pEntityPriv;

        // Copy derived data
        if (flags & EV_DERIVED_DATA) {
            WsbAffirmHr(Copy(pEntity));
        }
        WsbAffirmHr(pEntity->QueryInterface(IID_IWsbDbEntityPriv,
                (void**)&pEntityPriv));

        // Copy DbEntity specific data
        if (flags & EV_USEKEY) {
            WsbAffirmHr(pEntityPriv->GetValue(EV_USEKEY, &value));
            if (m_pKeyInfo[m_UseKeyIndex].Type != value) {
                WsbAffirmHr(UseKey(value));
            }
        }

        if (flags & EV_SEQNUM) {
            WsbAffirmHr(pEntityPriv->GetValue(EV_SEQNUM, &value));
            m_SeqNum = (LONG)value;
        }

        if (flags & EV_ASNEW) {
            WsbAffirmHr(pEntityPriv->GetValue(EV_ASNEW, &value));
            if (value) {
                WsbAffirmHr(MarkAsNew());
            }
        }
        SetIsDirty(TRUE);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::CopyValues(IWbEntity)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Disconnect(
    void
    )

/*++

Implements:

  IWsbDbEntityPriv::Disconnect

Comments:

    Disconnect the entity from its database (to reduce the DBs
    reference count).

--*/

{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::Disconnect()"), OLESTR(""));

    try {
        if (m_pDb) {
//          WsbAffirmHr(m_pDb->Release());
            m_pDb = NULL;   // Release is automatic
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::Disconnect()"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::GetCurKey(
    IWsbDbKey** ppKey
    )

/*++

Implements:

  IWsbDbEntityPriv::GetCurKey

Comments:

  Return the current key.

--*/

{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::GetCurKey"), OLESTR(""));

    try {
        ULONG kType = 0;

        if (m_pKeyInfo) {
            kType = m_pKeyInfo[m_UseKeyIndex].Type;
        }
        WsbAffirmHr(GetKey(kType, ppKey));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::GetCurKey(IWbEntity)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::GetKey(
    ULONG       KeyType,
    IWsbDbKey** ppKey
    )

/*++

Implements:

  IWsbDbEntityPriv::GetKey

Comments:

  Return the specified key.

--*/

{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::GetKey"), OLESTR(""));

    try {
        CComPtr<IWsbDbKey> pKey;
        CComPtr<IWsbDbKeyPriv> pKeyPriv;

        WsbAssert(0 != ppKey, E_POINTER);

        WsbAffirmHr(CoCreateInstance(CLSID_CWsbDbKey, 0, CLSCTX_SERVER, 
                  IID_IWsbDbKey, (void **)&pKey ));
        WsbAffirmHr(pKey->QueryInterface(IID_IWsbDbKeyPriv, 
                (void**)&pKeyPriv));
        WsbAffirmHr(pKeyPriv->SetType(KeyType));
        WsbAffirmHr(UpdateKey(pKey));
        *ppKey = pKey;
        (*ppKey)->AddRef();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::GetKey(IWbEntity)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FindEQ(
    void
    )

/*++

Implements:

  IWsbDbEntity::FindEQ

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::FindEQ"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_seek(JET_bitSeekEQ));
        WsbAffirmHr(jet_get_data());

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::FindEQ"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FindGT(
    void
    )

/*++

Implements:

  IWsbDbEntity::FindGT

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::FindGT"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_seek(JET_bitSeekGT));
        WsbAffirmHr(jet_get_data());

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::FindGT"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FindGTE(
    void
    )

/*++

Implements:

  IWsbDbEntity::FindGTE

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::FindGTE"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_seek(JET_bitSeekGE));
        WsbAffirmHr(jet_get_data());
    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::FindGTE"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FindLT(
    void
    )

/*++

Implements:

  IWsbDbEntity::FindLT

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::FindLT"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_seek(JET_bitSeekLT));
        WsbAffirmHr(jet_get_data());
    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::FindLT"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FindLTE(
    void
    )

/*++

Implements:

  IWsbDbEntity::FindLTE

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::FindLTE"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_seek(JET_bitSeekLE));
        WsbAffirmHr(jet_get_data());
    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::FindLTE"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::First(
    void
    )

/*++

Implements:

  IWsbDbEntity::First.

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::First"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_move(JET_MoveFirst));
        WsbAffirmHr(jet_get_data());
        m_SaveAsNew = FALSE;

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::First"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::GetValue(
    ULONG flag, 
    ULONG* pValue
    )

/*++

Implements:

  IWsbDbEntityPriv::GetValue

Comments:

  Get a specific (based on flag) value from a DBEntity.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::GetValue"), OLESTR(""));
    
    try {
        switch (flag) {
        case EV_INDEX:
            break;
        case EV_POS:
            break;
        case EV_ASNEW:
            *pValue = m_SaveAsNew;
            break;
        case EV_USEKEY:
            *pValue = m_pKeyInfo[m_UseKeyIndex].Type;
            break;
        case EV_SEQNUM:
            *pValue = (ULONG)m_SeqNum;
            break;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::GetValue"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CWsbDbEntity::SetSequentialScan(
    void
    )

/*++

Implements:

  IWsbDbEntity::SetSequentialScan.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::SetSequentialScan"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"), m_SessionId, m_TableId);
    
    try {
        JET_ERR jstat = JET_errSuccess;

        // Set to sequential traversing
        jstat = JetSetTableSequential(m_SessionId, m_TableId, 0);
        WsbAffirmHr(jet_error(jstat));

        m_Sequential = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::SetSequentialScan"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CWsbDbEntity::ResetSequentialScan(
    void
    )

/*++

Implements:

  IWsbDbEntity::ResetSequentialScan.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::ResetSequentialScan"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"), m_SessionId, m_TableId);
    
    try {
        JET_ERR jstat = JET_errSuccess;

        // Set to sequential traversing
        jstat = JetResetTableSequential(m_SessionId, m_TableId, 0);
        WsbAffirmHr(jet_error(jstat));

        m_Sequential = FALSE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::ResetSequentialScan"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Init(
    IN IWsbDb* pDb,
    IN IWsbDbSys *pDbSys, 
    IN ULONG   RecType,
    IN JET_SESID SessionId
    )

/*++

Implements:

  IWsbDbEntity::Init

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::Init"), OLESTR(""));
    
    try {

        WsbAssert(0 != pDb, E_POINTER);
        WsbAssert(0 != pDbSys, E_POINTER);

        // Don't allow DB Sys switch
        if (pDbSys != m_pDbSys) {
            m_pDbSys = pDbSys;  // Automatic AddRef() on Db Sys object
        }

        // Don't allow DB switch
        if (pDb != m_pDb) {
            CComPtr<IWsbDbPriv>  pDbImp;
//            CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = pSession;

            WsbAssert(m_pDb == 0, WSB_E_INVALID_DATA);
            m_pDb = pDb;  // Automatic AddRef() on Db object
//            WsbAssertHr(pSessionPriv->GetJetId(&m_Session));

            //  Get info about myself from the IDB object
            WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
            WsbAffirmHr(pDbImp->GetRecInfo(RecType, &m_RecInfo));
            WsbAssert(m_RecInfo.nKeys > 0, E_INVALIDARG);

            //  Get info about my keys
            m_pKeyInfo = (COM_IDB_KEY_INFO*)WsbAlloc(sizeof(COM_IDB_KEY_INFO) * 
                    m_RecInfo.nKeys);
            WsbAffirmHr(pDbImp->GetKeyInfo(RecType, m_RecInfo.nKeys, m_pKeyInfo));

            //  Get the maximum amount of memory need to hold a streamed
            //  copy of the user data
//          ULONG                minSize;
//          WsbAffirmHr(pDbImp->GetRecSize(m_RecInfo.Type, &minSize, &m_RecInfo.MaxSize));

            m_SeqNum = -1;
            m_PosOk = FALSE;
            m_SessionId = SessionId;

            //  Get Jet IDs (and a new table ID unique to this entity)
            WsbAffirmHr(pDbImp->GetJetIds(m_SessionId, m_RecInfo.Type, 
                    &m_TableId, &m_ColId));

            WsbAffirmHr(getMem(&m_hMem));

            //  Set the first key as the default
            UseKey(m_pKeyInfo[0].Type);
        }

    } WsbCatch(hr);

    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    WsbTraceOut(OLESTR("CWsbDbEntity::Init"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Last(
    void
    )

/*++

Implements:

  IWsbDbEntity::Last.

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::Last"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_move(JET_MoveLast));
        WsbAffirmHr(jet_get_data());
        m_SaveAsNew = FALSE;

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::Last"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::MarkAsNew(
    void
    )

/*++

Implements:

  IWsbDbEntity::MarkAsNew

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::MarkAsNew"), OLESTR(""));
    
    try {

        m_SaveAsNew = TRUE;

        m_SeqNum = -1;
        m_PosOk = FALSE;
        SetIsDirty(TRUE);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::MarkAsNew"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Next(
    void
    )

/*++

Implements:

  IWsbDbEntity::Next.

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::Next"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_make_current());
        WsbAffirmHr(jet_move(JET_MoveNext));
        WsbAffirmHr(jet_get_data());
        m_SaveAsNew = FALSE;

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::Next"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Previous(
    void
    )

/*++

Implements:

  IWsbDbEntity::Previous.

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::Previous"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_make_current());
        WsbAffirmHr(jet_move(JET_MovePrevious));
        WsbAffirmHr(jet_get_data());
        m_SaveAsNew = FALSE;

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::Previous"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Print(
    IStream* pStream
    )

/*++

Implements:

  IWsbDbEntity::Print.

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::Print"), OLESTR(""));
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" (IDB SeqNum = %6ld) "), m_SeqNum));

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CWsbDbEntity::Print"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::Remove(
    void
    )

/*++

Implements:

  IWsbDbEntity::Remove

--*/
{
    HRESULT              hr = S_OK;
    CComPtr<IWsbDbPriv>  pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::Remove"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IUnknown>         pIUn;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        JET_ERR                         jstat;

        //  Make sure this record is the current record.
        WsbAffirmHr(jet_make_current());

        //  Delete the record
        jstat = JetDelete(m_SessionId, m_TableId);
        WsbAffirmHr(jet_error(jstat));

        CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pDbSys;
        WsbAffirmPointer(pDbSysPriv);
        WsbAffirmHr(pDbSysPriv->IncrementChangeCount());
    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::Remove"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::SetValue(
    ULONG flag, 
    ULONG value
    )

/*++

Implements:

  IWsbDbEntityPriv::SetValue

Comments:

  Set a specific data value (base on flag).

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::SetValue"), OLESTR(""));
    
    try {
        CComPtr<IWsbDbPriv>             pDbImp;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        switch (flag) {
        case EV_INDEX:
            break;
        case EV_POS:
            break;
        case EV_ASNEW:
            if (value) {
                m_SaveAsNew = TRUE;
            } else {
                m_SaveAsNew = FALSE;
            }
            break;
        case EV_USEKEY:
            m_pKeyInfo[m_UseKeyIndex].Type = value;
            break;
        case EV_SEQNUM:
            m_SeqNum = (LONG)value;
            break;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::SetValue"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::UseKey(
    IN ULONG type
    )

/*++

Implements:

  IWsbDbEntity::UseKey

--*/
{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::UseKey"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);

    try {
        CComPtr<IWsbDbPriv>    pDbImp;

        // Check that this is a valid key type
        for (int i = 0; i < m_RecInfo.nKeys; i++) {
            // Special case for type == 0; this means to use the
            // sequence number key
            if (0 == type) break;
            if (m_pKeyInfo[i].Type == type) break;
        }
        WsbAssert(i < m_RecInfo.nKeys, E_INVALIDARG);
        m_UseKeyIndex = (USHORT)i;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        size_t                          ilen;
        char *                          index_name_a;
        CWsbStringPtr                   index_name_w;
        JET_ERR                         jstat;

        WsbAffirmHr(index_name_w.Alloc(20));
        WsbAffirmHr(pDbImp->GetJetIndexInfo(m_SessionId, m_RecInfo.Type, type, NULL, 
                &index_name_w, 20));
        ilen = wcslen(index_name_w);
        index_name_a = (char *)WsbAlloc(sizeof(WCHAR) * ilen + 1);
        WsbAffirm(0 != index_name_a, E_FAIL);
        WsbAffirm(0 < wcstombs(index_name_a, index_name_w, ilen + 1), E_FAIL);

        //  Set the current index
        jstat = JetSetCurrentIndex(m_SessionId, m_TableId, index_name_a);
        WsbFree(index_name_a);
        WsbAffirmHr(jet_error(jstat));
        m_PosOk = FALSE;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::UseKey"), OLESTR(""));

    return(hr);
}



HRESULT
CWsbDbEntity::Write(
    void
    )

/*++

Implements:

  IWsbDbEntity::Write

--*/
{
    HRESULT               hr = S_OK;
    CComPtr<IWsbDbPriv>   pDbImp;
    UCHAR   temp_bytes1[IDB_MAX_KEY_SIZE + 4];

    WsbTraceIn(OLESTR("CWsbDbEntity::Write"), OLESTR("SaveAsNew = %ls"), 
            WsbBoolAsString(m_SaveAsNew));

    JET_ERR                         jstat;

    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);

    jstat = JetBeginTransaction(m_SessionId);
    WsbTrace(OLESTR("CWsbDbEntity::Write: JetBeginTransaction = %ld\n"), jstat);
    
    try {
        CComPtr<IWsbDbEntity>     pEntity;
        CComPtr<IWsbDbEntityPriv> pEntityPriv;
        ULONG                     save_key_type;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());
        save_key_type = m_pKeyInfo[m_UseKeyIndex].Type;

        VOID*                           addr;
        ULONG                           Size;

        // Save the entity data to memory
        WsbAffirmHr(toMem(m_hMem, &Size));

        // Write the data to the current record
        addr = GlobalLock(m_hMem);
        WsbAffirm(addr, E_HANDLE);

        if (m_SaveAsNew) {
            jstat = JetPrepareUpdate(m_SessionId, m_TableId, JET_prepInsert);
        } else {
            //  Make sure this record is the current record.
            WsbAffirmHr(jet_make_current());
            jstat = JetPrepareUpdate(m_SessionId, m_TableId, JET_prepReplace);
        }
        WsbAffirmHr(jet_error(jstat));
        WsbTrace(OLESTR("Setting binary record data\n"));
        jstat = JetSetColumn(m_SessionId, m_TableId, m_ColId, addr, Size,
                0, NULL);
        WsbAffirmHr(jet_error(jstat));

        // Release the memory
        GlobalUnlock(m_hMem);

        // Set keys in current record
        for (int i = 0; i < m_RecInfo.nKeys; i++) {
            JET_COLUMNID  col_id;
            BOOL          do_set = FALSE;
            ULONG         size;

            WsbAffirmHr(pDbImp->GetJetIndexInfo(m_SessionId, m_RecInfo.Type, m_pKeyInfo[i].Type,
                    &col_id, NULL, 0));
            WsbAffirmHr(get_key(m_pKeyInfo[i].Type, temp_bytes1, &size));
            if (m_SaveAsNew) {
                do_set = TRUE;
            } else {
                HRESULT       hrEqual;

                hrEqual = jet_compare_field(col_id, temp_bytes1, size);
                WsbAffirm(S_OK == hrEqual || S_FALSE == hrEqual, hrEqual);
                if (S_FALSE == hrEqual && 
                        (m_pKeyInfo[i].Flags & IDB_KEY_FLAG_PRIMARY)) {
                    //  Changing the primary key is not allowed
                    WsbThrow(WSB_E_IDB_PRIMARY_KEY_CHANGED);
                }
                do_set = (S_FALSE == hrEqual) ? TRUE : FALSE;
            }
            if (do_set) {
                WsbTrace(OLESTR("Setting key %ld\n"), m_pKeyInfo[i].Type);
                jstat = JetSetColumn(m_SessionId, m_TableId, col_id, temp_bytes1, 
                        size, 0, NULL);
                WsbAffirmHr(jet_error(jstat));
            }
        }

        // Insert/update the record
        WsbTrace(OLESTR("Updating/writing record\n"));
        jstat = JetUpdate(m_SessionId, m_TableId, NULL, 0, NULL);
        WsbAffirmHr(jet_error(jstat));

        CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pDbSys;
        WsbAffirmPointer(pDbSysPriv);
        WsbAffirmHr(pDbSysPriv->IncrementChangeCount());
        m_SaveAsNew = FALSE;
        SetIsDirty(FALSE);
    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }

    if (SUCCEEDED(hr)) {
        jstat = JetCommitTransaction(m_SessionId, 0);
        WsbTrace(OLESTR("CWsbDbEntity::Write: JetCommitTransaction = %ld\n"), jstat);
    } else {
        jstat = JetRollback(m_SessionId, 0);
        WsbTrace(OLESTR("CWsbDbEntity::Write: JetRollback = %ld\n"), jstat);
    }

    WsbTraceOut(OLESTR("CWsbDbEntity::Write"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::FinalConstruct"), OLESTR("") );

    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_pDb = NULL;
        m_SaveAsNew = FALSE;
        m_pKeyInfo = NULL;
        m_RecInfo.MaxSize = 0;

        m_SeqNum = -1;
        m_PosOk = FALSE;
        m_SessionId = 0;
        m_TableId = 0;
        m_hMem = 0;

        m_Sequential = FALSE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::FinalConstruct"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



void
CWsbDbEntity::FinalRelease(
    void
    )

/*++

Routine Description:

  This method does some cleanup of the object that is necessary
  during destruction.

Arguments:

  None.

Return Value:

  None.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::FinalRelease"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);

    try {

        if (m_hMem) {
            GlobalFree(m_hMem);
        }
        if (m_SessionId && m_TableId) {
            if (m_Sequential) {
                (void)ResetSequentialScan();
            }
            m_SessionId = 0;
            m_TableId = 0;
        }
        if (m_pDb) {
            //  Release IDB objects
            m_pDb = 0;
            m_pDbSys = 0;
        }
        if (m_pKeyInfo) {
            WsbFree(m_pKeyInfo);
            m_pKeyInfo = NULL;
        }

        CWsbObject::FinalRelease();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::FinalRelease"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
}


HRESULT
CWsbDbEntity::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = S_FALSE;
    IWsbDbEntity*   pEntity;

    WsbTraceIn(OLESTR("CWsbDbEntity::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbDbEntity interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbDbEntity, (void**) &pEntity));

        hr = compare(pEntity, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


// CWsbDbEntity internal helper functions


// compare - compare control key to control key of another entity
HRESULT CWsbDbEntity::compare(IWsbDbEntity* pEntity, SHORT* pResult)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::compare"), OLESTR(""));
    
    try {
        CComPtr<IWsbCollectable>  pCollectable;
        CComPtr<IWsbDbEntityPriv> pEntityPriv;
        CComPtr<IWsbDbKey>        pKey1;
        CComPtr<IWsbDbKey>        pKey2;
        SHORT                     result;

        WsbAffirmHr(GetCurKey(&pKey1));
        WsbAffirmHr(pKey1->QueryInterface(IID_IWsbCollectable,
                (void**)&pCollectable));
        WsbAffirmHr(pEntity->QueryInterface(IID_IWsbDbEntityPriv, 
                (void**)&pEntityPriv))
        WsbAffirmHr(pEntityPriv->GetCurKey(&pKey2));
        WsbAffirmHr(pCollectable->CompareTo(pKey2, &result));
        if (pResult) {
            *pResult = result;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::compare"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// fromMem - load entity data from memory
HRESULT CWsbDbEntity::fromMem(HGLOBAL hMem)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::fromMem"), OLESTR(""));
    
    try {
        CComPtr<IPersistStream>  pIPersistStream;
        CComPtr<IStream>         pIStream;
        IUnknown*                pIUnknown;

        WsbAssert(0 != hMem, E_POINTER);

        // Get PersistStream interfaces for myself
        pIUnknown = (IUnknown *)(IWsbPersistable *)(CWsbCollectable *)this;
        WsbAffirmHr(pIUnknown->QueryInterface(IID_IPersistStream, 
                (void**) &pIPersistStream));

        // Create a memory stream
        WsbAffirmHr(CreateStreamOnHGlobal(hMem, FALSE, &pIStream));

        // Load myself from the stream
        WsbAffirmHr(pIPersistStream->Load(pIStream));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::fromMem"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

//  get_key - get the byte array & size for the given key
HRESULT CWsbDbEntity::get_key(ULONG key_type, UCHAR* bytes, ULONG* pSize)
{
    HRESULT   hr = S_OK;

    try {
        ULONG        expected_size;
        ULONG        size;

        if (0 != key_type) {
            UCHAR*                 pbytes;
            CComPtr<IWsbDbKey>     pKey;
            CComPtr<IWsbDbKeyPriv> pKeyPriv;

            // Check that this is a valid key type
            for (int i = 0; i < m_RecInfo.nKeys; i++) {
                if (m_pKeyInfo[i].Type == key_type) break;
            }
            WsbAssert(i < m_RecInfo.nKeys, E_INVALIDARG);
            WsbAssert(0 != bytes, E_POINTER);

            //  Create a key of the right type
            WsbAffirmHr(CoCreateInstance(CLSID_CWsbDbKey, 0, CLSCTX_SERVER, 
                      IID_IWsbDbKey, (void **)&pKey ));
            WsbAffirmHr(pKey->QueryInterface(IID_IWsbDbKeyPriv, 
                    (void**)&pKeyPriv));
            WsbAffirmHr(pKeyPriv->SetType(key_type));

            //  Get the key's value from the derived code
            WsbAffirmHr(UpdateKey(pKey));

            //  Convert key to bytes
            pbytes = bytes;
            WsbAffirmHr(pKeyPriv->GetBytes(&pbytes, &size));

            expected_size = m_pKeyInfo[i].Size;
            WsbAffirm(size <= expected_size, WSB_E_INVALID_DATA);
            while (size < expected_size) {
                //  Fill with zeros
                pbytes[size] = '\0';
                size++;
            }

        //  0 == key_type
        //  This is a special case, allowed only for Jet, to
        //  get the sequence number as a key.  We can't use
        //  WsbConvertToBytes because the bytes end up in the 
        //  wrong order.
        } else {
            size = sizeof(m_SeqNum);
            memcpy(bytes, (void*)&m_SeqNum, size);

        }

        if (pSize) {
            *pSize = size;
        }
    } WsbCatch(hr);

    return(hr);
}

//  getMem - allocate enough memory for this entity
HRESULT CWsbDbEntity::getMem(HGLOBAL* phMem)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::getMem"), OLESTR(""));
    
    try {
        HGLOBAL                  hMem;

        WsbAssert(0 != phMem, E_POINTER);
        WsbAffirm(0 < m_RecInfo.MaxSize, WSB_E_NOT_INITIALIZED);

        hMem = GlobalAlloc(GHND, m_RecInfo.MaxSize);
        WsbAffirm(hMem, E_OUTOFMEMORY);
        *phMem = hMem;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::getMem"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

//  toMem - save this entity to memory
HRESULT CWsbDbEntity::toMem(HGLOBAL hMem, ULONG* pSize)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::toMem"), OLESTR(""));
    
    try {
        CComPtr<IPersistStream>  pIPersistStream;
        CComPtr<IStream>         pIStream;
        IUnknown*                pIUnknown;
        ULARGE_INTEGER           seek_pos;
        LARGE_INTEGER            seek_pos_in;

        WsbAssert(0 != hMem, E_POINTER);
        WsbAssert(0 != pSize, E_POINTER);

        // Get PersistStream interfaces for myself
        pIUnknown = (IUnknown *)(IWsbPersistable *)(CWsbCollectable *)this;
        WsbAffirmHr(pIUnknown->QueryInterface(IID_IPersistStream, 
                (void**) &pIPersistStream));

        // Create a memory stream
        WsbAffirmHr(CreateStreamOnHGlobal(hMem, FALSE, &pIStream));

        // Save to the stream
        WsbAffirmHr(pIPersistStream->Save(pIStream, FALSE));

        //  Get the size
        seek_pos_in.QuadPart = 0;
        WsbAffirmHr(pIStream->Seek(seek_pos_in, STREAM_SEEK_CUR, &seek_pos));
        *pSize = seek_pos.LowPart;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::toMem"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


// jet_compare_field - compare a string of bytes to the a column
//   value in the current Jet record
//  Return S_OK for equal, S_FALSE for not equal, other for an error.
HRESULT 
CWsbDbEntity::jet_compare_field(ULONG col_id, UCHAR* bytes, ULONG size)
{
    VOID*               addr = NULL;
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::jet_compare_field"), OLESTR(""));
    
    try {
        ULONG                           actualSize;
        JET_ERR                         jstat;
        CComPtr<IWsbDbPriv>             pDbImp;

        //  Get some Jet DB info
        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        //  Get the column value
        addr = GlobalLock(m_hMem);
        WsbAffirm(addr, E_HANDLE);
        jstat = JetRetrieveColumn(m_SessionId, m_TableId, col_id, addr,
                size, &actualSize, 0, NULL);
        WsbAffirmHr(jet_error(jstat));

        //  Compare them
        if (memcmp(bytes, addr, size)) {
            hr = S_FALSE;
        }
    } WsbCatch(hr);

    if (NULL != addr) {
        GlobalUnlock(m_hMem);
    }

    WsbTraceOut(OLESTR("CWsbDbEntity::jet_compare_field"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// jet_get_data - retrieve record data from the current Jet record
HRESULT 
CWsbDbEntity::jet_get_data(void)
{
    VOID*               addr = NULL;
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::jet_get_data"), OLESTR(""));
    
    try {
        ULONG                           actualSize;
        JET_COLUMNID                    col_id;
        JET_ERR                         jstat;
        CComPtr<IWsbDbPriv>             pDbImp;

        //  Get some Jet DB info
        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        //  Get data
        addr = GlobalLock(m_hMem);
        WsbAffirm(addr, E_HANDLE);
        jstat = JetRetrieveColumn(m_SessionId, m_TableId, m_ColId, addr,
                m_RecInfo.MaxSize, &actualSize, 0, NULL);
        WsbAffirmHr(jet_error(jstat));
        WsbAffirmHr(fromMem(m_hMem));

        //  Get the sequence number
        WsbAffirmHr(pDbImp->GetJetIndexInfo(m_SessionId, m_RecInfo.Type, 0, &col_id, NULL, 0));
        jstat = JetRetrieveColumn(m_SessionId, m_TableId, col_id, &m_SeqNum,
                sizeof(m_SeqNum), &actualSize, 0, NULL);
        WsbAffirmHr(jet_error(jstat));

    } WsbCatch(hr);

    if (NULL != addr) {
        GlobalUnlock(m_hMem);
    }

    WsbTraceOut(OLESTR("CWsbDbEntity::jet_get_data"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// jet_make_current - make sure this is the current Jet record
//   NOTE: This function, despite its name, does not attempt to force
//   the JET "cursor" to be on the correct record because this can mess
//   up too many things that can't necessarily be controlled at this
//   level.  For one thing, if the current key allows duplicates, we can't
//   be sure to get to the correct record using the index for that key.
//   If we try to use the sequence number as the key, we'd then be using
//   the wrong index if we do a Next or Previous.  If the user code is
//   doing a Write or Remove, it's better for that code to make sure via
//   the Find functions that the cursor is position correctly.
HRESULT 
CWsbDbEntity::jet_make_current(void)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::jet_make_current"), OLESTR(""));
    
    try {
        ULONG                           actualSize;
        JET_COLUMNID                    col_id;
        JET_ERR                         jstat;
        CComPtr<IWsbDbPriv>             pDbImp;
        LONG                            seq_num;

        //  Get some Jet DB info
        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->GetJetIndexInfo(m_SessionId, m_RecInfo.Type, 0, &col_id, NULL, 0));

        //  Make sure this record is still the current record.
        //  We do this by comparing the sequence numbers
        jstat = JetRetrieveColumn(m_SessionId, m_TableId, col_id, &seq_num,
                sizeof(seq_num), &actualSize, 0, NULL);
        WsbAffirmHr(jet_error(jstat));
        if (!m_PosOk || seq_num != m_SeqNum) {
            WsbThrow(WSB_E_IDB_IMP_ERROR);
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::jet_make_current"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// jet_move - move current Jet record
HRESULT 
CWsbDbEntity::jet_move(LONG pos)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::jet_move"), OLESTR(""));
    
    try {
        JET_ERR                         jstat;
        CComPtr<IWsbDbPriv>             pDbImp;

        //  Get some Jet DB info
        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        //  Do the move
        jstat = JetMove(m_SessionId, m_TableId, pos, 0);
        if (jstat == JET_errNoCurrentRecord) {
            WsbThrow(WSB_E_NOTFOUND);
        }
        WsbAffirmHr(jet_error(jstat));
        m_PosOk = TRUE;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::jet_move"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// jet_seek - find Jet record based on current key and seek_flag;
//    sets the current Jet record on success
HRESULT 
CWsbDbEntity::jet_seek(ULONG seek_flag)
{
    UCHAR           temp_bytes1[IDB_MAX_KEY_SIZE + 4];
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::jet_seek"), OLESTR(""));
    
    try {
        JET_ERR                         jstat;
        CComPtr<IWsbDbPriv>             pDbImp;
        ULONG                           size;

        //  Get some Jet DB info
        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        //  Get the current key & give it to Jet
        WsbAffirmHr(get_key(m_pKeyInfo[m_UseKeyIndex].Type, temp_bytes1, &size));
        jstat = JetMakeKey(m_SessionId, m_TableId, temp_bytes1, size,
                JET_bitNewKey);
        WsbAffirmHr(jet_error(jstat));

        //  Do the seek
        jstat = JetSeek(m_SessionId, m_TableId, seek_flag);
        if (jstat == JET_errRecordNotFound) {
            WsbThrow(WSB_E_NOTFOUND);
        } else if (jstat == JET_wrnSeekNotEqual) {
            jstat = JET_errSuccess;
        }
        WsbAffirmHr(jet_error(jstat));
        m_PosOk = TRUE;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::jet_seek"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\wsbdb.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdb.cpp

Abstract:

    These classes provide support for data bases.

Author:

    Ron White   [ronw]   19-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbdbsys.h"
#include "wsbdbses.h"
#include "wsbdbkey.h"


#include <mbstring.h>

#define JET_DATA_COLUMN_NAME    "Data"
#define JET_INDEX_COLUMN_NAME   "Index"
#define JET_INFO_TABLE_NAME     "Info"
#define JET_SEQNUM_COLUMN_NAME  "SeqNum"
#define SESSION_INFO_INITIAL_SIZE  4
#define SESSION_INFO_EXPANSION     6

#define JET_CURRENT_SESSION  (pDbInfo->SessionInfo[m_SessionIndex].SessionId)
#define JET_CURRENT_DB       (pDbInfo->SessionInfo[m_SessionIndex].DbId)

#define CATCH_ANY_EXCEPTION  catch (...) { \
        WsbTraceAndLogEvent(WSB_MESSAGE_IDB_EXCEPTION, 0, NULL, NULL); \
        WsbTrace(OLESTR("GetLastError = %ld\n"), GetLastError()); \
        hr = WSB_E_IDB_EXCEPTION;    }


// Local stuff

// These structures hold extra implementation data
typedef struct {
} IMP_KEY_INFO;

typedef struct {
    IMP_KEY_INFO* Key;
} IMP_REC_INFO;

// IMP_TABLE_INFO holds information for each open table
typedef struct {
    JET_TABLEID   TableId;
    JET_COLUMNID  ColId;
} IMP_TABLE_INFO;

// IMP_SESSION_INFO holds information for each thread
typedef struct {
    JET_SESID   SessionId;  // The Jet session
    JET_DBID    DbId;       // The session's DB ID for this DB
    IMP_TABLE_INFO* pTableInfo;  // Array of table information
} IMP_SESSION_INFO;


typedef struct {
    BOOL              IsLoaded;   // DB info is loaded into memory
    USHORT            OpenCount;  // Open ref. count
    IMP_REC_INFO*     RecInfo;    // Array of record info

    SHORT             nSessions;
    IMP_SESSION_INFO* SessionInfo;
} IMP_DB_INFO;

// These structures are saved in the data file
typedef struct {
    ULONG  Type;       // Key type ID
    ULONG  Size;       // Key size in bytes
    ULONG  Flags;      // IDB_KEY_FLAG_* flags
} FILE_KEY_INFO;

typedef struct {
    ULONG  Type;          // Record type ID
    CLSID  EntityClassId; // Derived entity class ID
    ULONG  Flags;         // IDB_REC_FLAG_* flags
    ULONG  MinSize;       // (Minimum) record size in bytes
    ULONG  MaxSize;       // Maximum record size
    USHORT nKeys;         // Number of keys in this record type
    FILE_KEY_INFO Key[IDB_MAX_KEYS_PER_REC];
} FILE_REC_INFO;

typedef struct {
    USHORT    nRecTypes;  // Number of record types
    ULONG     version;    // DB version
} FILE_DB_INFO;


//***************************************************************
//  Local function prototypes

static HRESULT jet_get_column_id(JET_SESID jet_session, JET_DBID DbId, 
        char* pTableName, char* pColumnName, JET_COLUMNID* pColId);



//***************************************************************
//  Function definitions


HRESULT
CWsbDb::Create(
    IN OLECHAR* path,
    ULONG flags
    )

/*++

Implements:

  IWsbDb::Create

--*/
{
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Create"), OLESTR("path = <%ls>"), path);
    
    try {
        int           key_index;
        ULONG         memSize;
        int           rec_index;

        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != m_RecInfo, WSB_E_NOT_INITIALIZED);
        WsbAssert(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();
        WsbAffirm(!pDbInfo->IsLoaded, WSB_E_NOT_INITIALIZED);
        WsbAffirm(!pDbInfo->RecInfo, WSB_E_NOT_INITIALIZED);

        // Save the path
        m_path = path;

        // Check validity of some info that the derived class is
        // suppose to supply.
        WsbAffirm(m_version != 0, WSB_E_NOT_INITIALIZED);
        WsbAffirm(m_nRecTypes > 0, WSB_E_NOT_INITIALIZED);
        WsbAffirm(m_nRecTypes <= IDB_MAX_REC_TYPES, WSB_E_INVALID_DATA);
        pDbInfo->IsLoaded = TRUE;

        //  Allocate the RecInfo array
        memSize = m_nRecTypes * sizeof(IMP_REC_INFO);
        pDbInfo->RecInfo = (IMP_REC_INFO*)WsbAlloc(memSize);
        WsbAffirm(pDbInfo->RecInfo, E_OUTOFMEMORY);
        ZeroMemory(pDbInfo->RecInfo, memSize);

        char             index_names[IDB_MAX_KEYS_PER_REC + 1][20];
        JET_COLUMNCREATE jet_columns[IDB_MAX_KEYS_PER_REC + 2];
        JET_INDEXCREATE  jet_indices[IDB_MAX_KEYS_PER_REC + 1];
        JET_TABLECREATE  jet_table;
        JET_ERR          jstat;
        char             key_names[IDB_MAX_KEYS_PER_REC + 1][22];
        char*            name;
        char             table_name[20];
        JET_GRBIT        createFlags = 0;

        //  Start a Jet session for this thread
        WsbAffirmHr(jet_init());

        //  Make sure there's room for another DB
        CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pWsbDbSys;
        WsbAffirmPointer(pDbSysPriv);
        WsbAffirmHr(pDbSysPriv->DbAttachedAdd(path, FALSE));

        // Set creation flag
        if (flags & IDB_CREATE_FLAG_NO_TRANSACTION) {
            // Setting this flag stil allow transaction calls - they are just being ignored and MT-safe is not guaranteed 
            createFlags |= (JET_bitDbVersioningOff & JET_bitDbRecoveryOff);
        }     

        //  Create the DB
        WsbAffirmHr(wsb_db_jet_fix_path(path, L"." IDB_DB_FILE_SUFFIX, &name));
        jstat = JetCreateDatabase(JET_CURRENT_SESSION, name, NULL, &JET_CURRENT_DB, createFlags);
        WsbTrace(OLESTR("JetCreateDB = %ld\n"), (LONG)jstat);
        WsbFree(name);
        WsbAffirmHr(jet_error(jstat));

        //  Set up constant part of table structure
        jet_table.cbStruct = sizeof(JET_TABLECREATE);
        jet_table.szTemplateTableName = NULL;
        jet_table.ulPages = 4;  // ????
        jet_table.ulDensity = 50; // ?????
        jet_table.rgcolumncreate = jet_columns;
        jet_table.rgindexcreate = jet_indices;
        jet_table.grbit = 0;

        //  Set up the constant part of the column structures
        ZeroMemory(&jet_columns, sizeof(jet_columns));
        ZeroMemory(&jet_indices, sizeof(jet_indices));
        jet_columns[0].cbStruct = sizeof(JET_COLUMNCREATE);
        jet_columns[0].szColumnName = JET_DATA_COLUMN_NAME;
        jet_columns[1].cbStruct = sizeof(JET_COLUMNCREATE);

        //  Create a "table" to hold info about this DB
        jet_table.szTableName = JET_INFO_TABLE_NAME;
        jet_table.cColumns = 2;
        jet_table.cIndexes = 1;
        jet_columns[0].coltyp = JET_coltypLongBinary;
        jet_columns[0].cbMax = sizeof(FILE_REC_INFO);
        jet_columns[1].szColumnName = JET_INDEX_COLUMN_NAME;
        jet_columns[1].coltyp = JET_coltypShort;
        jet_columns[1].cbMax = sizeof(SHORT);
        jet_indices[0].cbStruct = sizeof(JET_INDEXCREATE);
        jet_indices[0].szIndexName = JET_INDEX_COLUMN_NAME;
        ZeroMemory(key_names[0], 22);
        sprintf(key_names[0], "+%s", JET_INDEX_COLUMN_NAME);
        jet_indices[0].szKey = key_names[0];
        jet_indices[0].cbKey  = strlen(key_names[0]) + 2;
        jet_indices[0].grbit |= JET_bitIndexPrimary;
        jet_indices[0].ulDensity = 90;
        jstat = JetCreateTableColumnIndex(JET_CURRENT_SESSION, JET_CURRENT_DB, &jet_table);
        WsbTrace(OLESTR("CWsbDb::Create: JetCreateTableColumnIndex status = %ld\n"), jstat);
        if (JET_errSuccess != jstat) {
            WsbTrace(OLESTR("CWsbDb::Create: JetCreateTableColumnIndex, cCreated = %ld\n"), jet_table.cCreated);
        }
        WsbAffirmHr(jet_error(jstat));
        jstat = JetCloseTable(JET_CURRENT_SESSION, jet_table.tableid);
        WsbTrace(OLESTR("CWsbDb::Create: close TableId = %ld, jstat = %ld\n"),
               jet_table.tableid, jstat);

        //  Write DB info
        jstat = JetBeginTransaction(JET_CURRENT_SESSION);
        WsbTrace(OLESTR("CWsbDb::Create: JetBeginTransaction = %ld\n"), jstat);
        jstat = jet_save_info();
        if (JET_errSuccess == jstat) {
            jstat = JetCommitTransaction(JET_CURRENT_SESSION, 0);
            WsbTrace(OLESTR("CWsbDb::Create: JetCommitTransaction = %ld\n"), jstat);
        } else {
            HRESULT hr2 = jet_error(jstat);

            jstat = JetRollback(JET_CURRENT_SESSION, 0);
            WsbTrace(OLESTR("CWsbDb::Create: JetRollback = %ld\n"), jstat);
            WsbThrow(hr2);
        }

        //  We create a table for each record type.  The first column of each
        //  table is the record (stored as a blob).  The second column is a
        //  unique sequence number for each record.  The rest of the columns are for
        //  key values used as indices.
        jet_columns[1].szColumnName = JET_SEQNUM_COLUMN_NAME;
        jet_columns[1].coltyp = JET_coltypLong;
        jet_columns[1].cbMax = sizeof(ULONG);
        jet_columns[1].grbit = JET_bitColumnAutoincrement;
        jet_indices[0].cbStruct = sizeof(JET_INDEXCREATE);
        strcpy(index_names[0], JET_SEQNUM_COLUMN_NAME);
        jet_indices[0].szIndexName = index_names[0];
        ZeroMemory(key_names[0], 22);
        sprintf(key_names[0], "+%s", index_names[0]);
        jet_indices[0].szKey = key_names[0];
        jet_indices[0].cbKey  = strlen(key_names[0]) + 2;
        jet_indices[0].grbit = 0;
        jet_indices[0].ulDensity = 90;

        //  Loop over record types
        for (rec_index = 0; rec_index < m_nRecTypes; rec_index++) {
            WsbAffirm(m_RecInfo[rec_index].Type > 0, WSB_E_NOT_INITIALIZED);
            WsbAffirm(m_RecInfo[rec_index].nKeys > 0, WSB_E_NOT_INITIALIZED);
            WsbAffirm(m_RecInfo[rec_index].nKeys <= IDB_MAX_KEYS_PER_REC, WSB_E_INVALID_DATA);

            //  Allocate the Key array
            memSize = m_RecInfo[rec_index].nKeys * sizeof(IMP_KEY_INFO);
            pDbInfo->RecInfo[rec_index].Key = (IMP_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(pDbInfo->RecInfo[rec_index].Key, E_OUTOFMEMORY);
            ZeroMemory(pDbInfo->RecInfo[rec_index].Key, memSize);

            //  Fill in the table structure with info specific to this
            //  record type
            WsbAffirmHr(jet_make_table_name(m_RecInfo[rec_index].Type, table_name, 20));
            jet_table.szTableName = table_name;
            jet_table.cColumns = m_RecInfo[rec_index].nKeys + 2;
            jet_table.cIndexes = m_RecInfo[rec_index].nKeys + 1;

            //  Fill in the column structure for the record itself
            if (m_RecInfo[rec_index].MaxSize < 255) {
                jet_columns[0].coltyp = JET_coltypBinary;
            } else {
                jet_columns[0].coltyp = JET_coltypLongBinary;
            }
            jet_columns[0].cbMax = m_RecInfo[rec_index].MaxSize;


            //  Loop over keys
            for (key_index = 0; key_index < m_RecInfo[rec_index].nKeys;
                    key_index++) {
                WsbAffirm(m_RecInfo[rec_index].Key[key_index].Type > 0, WSB_E_NOT_INITIALIZED);
                WsbAffirm(m_RecInfo[rec_index].Key[key_index].Size <= IDB_MAX_KEY_SIZE, 
                        WSB_E_NOT_INITIALIZED);
                WsbAffirm(!(m_RecInfo[rec_index].Key[key_index].Flags & IDB_KEY_FLAG_PRIMARY) ||
                        !(m_RecInfo[rec_index].Key[key_index].Flags & IDB_KEY_FLAG_DUP_ALLOWED),
                        WSB_E_IDB_PRIMARY_UNIQUE);


                //  Fill in a column structure for each key
                jet_columns[key_index + 2].cbStruct = sizeof(JET_COLUMNCREATE);
                WsbAffirmHr(jet_make_index_name(m_RecInfo[rec_index].Key[key_index].Type, 
                        index_names[key_index + 1], 20));
                jet_columns[key_index + 2].szColumnName = index_names[key_index + 1];
                jet_columns[key_index + 2].grbit = JET_bitColumnFixed;
                jet_columns[key_index + 2].pvDefault = NULL;
                jet_columns[key_index + 2].cbDefault = 0;
                if (m_RecInfo[rec_index].Key[key_index].Size < 255) {
                    jet_columns[key_index + 2].coltyp = JET_coltypBinary;
                } else {
                    jet_columns[key_index + 2].coltyp = JET_coltypLongBinary;
                }
                jet_columns[key_index + 2].cbMax = m_RecInfo[rec_index].Key[key_index].Size;

                //  Fill in an index structure for each key
                jet_indices[key_index + 1].cbStruct = sizeof(JET_INDEXCREATE);
                jet_indices[key_index + 1].szIndexName = index_names[key_index + 1];
                ZeroMemory(key_names[key_index + 1], 22);
                sprintf(key_names[key_index + 1], "+%s\0", index_names[key_index + 1]);
                jet_indices[key_index + 1].szKey = key_names[key_index + 1];
                jet_indices[key_index + 1].cbKey  = strlen(key_names[key_index + 1]) + 2;
                if (m_RecInfo[rec_index].Key[key_index].Flags & IDB_KEY_FLAG_DUP_ALLOWED) {
                    jet_indices[key_index + 1].grbit = 0;
                } else {
                    jet_indices[key_index + 1].grbit = JET_bitIndexUnique;
                }
                if (m_RecInfo[rec_index].Key[key_index].Flags & IDB_KEY_FLAG_PRIMARY) {
                    jet_indices[key_index + 1].grbit |= JET_bitIndexPrimary;
                }
                jet_indices[key_index + 1].ulDensity = 50;
            }  // End of key loop

            // Set table creation flags
            if (flags & IDB_CREATE_FLAG_FIXED_SCHEMA) {
                jet_table.grbit |= JET_bitTableCreateFixedDDL;
            }

            //  Create the "table" for each record type; this call defines
            //  the columns (fields) and index keys
            jstat = JetCreateTableColumnIndex(JET_CURRENT_SESSION, JET_CURRENT_DB, &jet_table);
            WsbTrace(OLESTR("JetCreateTableColumnIndex = %ld\n"), jstat);
            WsbAffirmHr(jet_error(jstat));
            jstat = JetCloseTable(JET_CURRENT_SESSION, jet_table.tableid);
            WsbTrace(OLESTR("CWsbDb::Create: close TableId = %ld, jstat = %ld\n"),
                   jet_table.tableid, jstat);
        }  // End of record loop

        jstat = JetCloseDatabase(JET_CURRENT_SESSION, JET_CURRENT_DB, 0);
        WsbTrace(OLESTR("CWsbDb::Create: JetCloseDatabase = %ld\n"),
                (LONG)jstat);
        JET_CURRENT_DB = 0;

        pDbInfo->OpenCount = 0;

    } WsbCatchAndDo(hr, 
            WsbLogEvent(WSB_MESSAGE_IDB_CREATE_FAILED, 0, NULL,
            WsbAbbreviatePath(path, 120), NULL); 
        )
    CATCH_ANY_EXCEPTION

    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::Create"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDb::Delete(
    IN OLECHAR *path,
    ULONG flags
    )

/*++

Implements:

  IWsbDb::Delete

--*/
{
    HRESULT             hr = S_OK;
    char*               name = NULL;
    IMP_DB_INFO*        pDbInfo = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Delete"), OLESTR("path = <%ls>"), 
            WsbStringAsString(path));
    
    try {
        CWsbStringPtr  DeletePath;

        WsbAssert(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();

        // Can't delete it if it's open
        WsbAffirm(pDbInfo->OpenCount == 0, E_UNEXPECTED);

        if (NULL == path) {
            path = m_path;
        }
        WsbAffirm(path && wcslen(path), S_FALSE);
        WsbAffirmHr(wsb_db_jet_fix_path(path, L"." IDB_DB_FILE_SUFFIX, &name));

        // Detach (if attached)
        CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pWsbDbSys;
        WsbAffirmPointer(pDbSysPriv);
        WsbAffirmHr(pDbSysPriv->DbAttachedRemove(path));

        // Now delete it
        DeletePath = name;
        if (!DeleteFile(DeletePath)) {
            DWORD err = GetLastError();
            WsbTrace(OLESTR("CWsbDb::Delete: DeleteFile(%ls) failed, error = %ld\n"),
                    static_cast<OLECHAR*>(DeletePath), err);
            WsbThrow(HRESULT_FROM_WIN32(err));
        }

        // Put message in event log
        if (flags & IDB_DELETE_FLAG_NO_ERROR) {
            WsbLogEvent(WSB_E_IDB_DATABASE_DELETED_NO_ERROR, 0, NULL,
                    WsbAbbreviatePath(DeletePath, 120), NULL);
        } else {
            WsbLogEvent(WSB_E_IDB_DATABASE_DELETED, 0, NULL,
                    WsbAbbreviatePath(DeletePath, 120), NULL);
        }
    }
    WsbCatch(hr)

    if (pDbInfo) {
        Unlock();
    }
    if (name) {
        WsbFree(name);
    }

    WsbTraceOut(OLESTR("CWsbDb::Delete"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CWsbDb::Dump(
    IN OLECHAR* Filename,
    IN ULONG    Flags,
    IN ULONG    Data
    )

/*++

Implements:

  IWsbDb::Dump

--*/
{
    HANDLE              hFile = 0;       
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;
    CComPtr<IWsbDbSession> pSession;

    WsbTraceIn(OLESTR("CWsbDb::Dump"), OLESTR("path = <%ls>"), Filename);
    
    try {
        DWORD                 CreateFlags;
        int                   i;
        int                   index;
        CComPtr<IWsbDbEntity> pIRec;
        CComPtr<IStream>      pStream;

        WsbAssert(0 != Filename, E_POINTER);
        WsbAssert(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();
//        WsbAffirmHr(session_current_index(Session));

        //  Open the Db
        // SteveW
        //  added code to ensure that a database was opened
        //  if not go on to the next database, but do not 
        //  throw an exception.
        //
        hr = Open(&pSession);
        if (hr == S_OK) {

            // Open/create the output file
            if (Flags & IDB_DUMP_FLAG_APPEND_TO_FILE) {
                CreateFlags = OPEN_ALWAYS;
            } else {
                CreateFlags = CREATE_ALWAYS;
            }
            hFile = CreateFile(Filename, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                    CreateFlags, FILE_ATTRIBUTE_NORMAL, NULL);
            WsbAffirmHandle(hFile);
            if (Flags & IDB_DUMP_FLAG_APPEND_TO_FILE) {
                //  Position to the end of the file
                SetFilePointer(hFile, 0, NULL, FILE_END);
            }

            // Create the output stream
            WsbAffirmHr(CreateStreamOnHGlobal(NULL, TRUE, &pStream));

            //  Dump general DB info
            if (Flags & IDB_DUMP_FLAG_DB_INFO) {
                WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("Dump of DB: %ls\n"),
                        static_cast<WCHAR *>(m_path)));
                WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("  version = %ld, # record types = %d\n"),
                        m_version, m_nRecTypes));
                WsbAffirmHr(WsbStreamToFile(hFile, pStream, TRUE));
            }

            //  Loop over record types
            for (i = 0; i < m_nRecTypes; i++) {

                //  Dump record info
                if (Flags & IDB_DUMP_FLAG_REC_INFO) {
                    WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("RecType = %8ld, Flags = %0.8lx, "),
                            m_RecInfo[i].Type, m_RecInfo[i].Flags));
                    WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("MaxSize = %8ld, # keys = %4d\n"),
                            m_RecInfo[i].MaxSize, m_RecInfo[i].nKeys));
                    WsbAffirmHr(WsbStreamToFile(hFile, pStream, TRUE));
                }

                //  Dump key info
                if (Flags & IDB_DUMP_FLAG_KEY_INFO) {
                    for (int j = 0; j < m_RecInfo[i].nKeys; j++) {
                        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("  KeyType = %8ld, Size = %8ld, Flags = %0.8lx\n"),
                                m_RecInfo[i].Key[j].Type, m_RecInfo[i].Key[j].Size, m_RecInfo[i].Key[j].Flags));
                    }
                    WsbAffirmHr(WsbStreamToFile(hFile, pStream, TRUE));
                }
            }

            //  Dump records
            if (Flags & (IDB_DUMP_FLAG_RECORDS | IDB_DUMP_FLAG_RECORD_TYPE)) {
                for (i = 0; i < m_nRecTypes; i++) {
                    if (!(Flags & IDB_DUMP_FLAG_RECORDS) &&
                           m_RecInfo[i].Type != Data) {
                        continue;
                    }
                    WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("\n*** Dump of records of Type = %ld ***\n"),
                            m_RecInfo[i].Type));

                    // Get a DB entity
                    pIRec = 0;
                    WsbAffirmHr(GetEntity(pSession, m_RecInfo[i].Type, IID_IWsbDbEntity, 
                            (void**)&pIRec));

                    //  Loop over records
                    index = 0;
                    hr = pIRec->First();
                    while (S_OK == hr) {
                        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("%0.5d "), index));
                        WsbAffirmHr(pIRec->Print(pStream));
                        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("\n")));
                        WsbAffirmHr(WsbStreamToFile(hFile, pStream, TRUE));

                        hr = pIRec->Next();
                        index++;
                    }
                    if (WSB_E_NOTFOUND == hr) {
                        hr = S_OK;
                    } else {
                        WsbAffirmHr(hr);
                    }
                }
            }
        } 

    } WsbCatch(hr)
    CATCH_ANY_EXCEPTION

    if (hFile) {
        CloseHandle(hFile);
    }
    if (pSession) {
        Close(pSession);
    }
    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::Dump"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDb::Locate(
    IN OLECHAR *path
    )

/*++

Implements:

  IWsbDb::Locate

--*/
{
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Locate"), OLESTR("path = <%ls>"), path);
    
    try {
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();
        WsbAffirm(pDbInfo->OpenCount == 0, E_UNEXPECTED);
        m_path = path;

        JET_ERR jstat;
        char*   name;

        //  Start a Jet session for this thread
        WsbAffirmHr(jet_init());

        WsbAffirmHr(wsb_db_jet_fix_path(path, L"." IDB_DB_FILE_SUFFIX, &name));

        hr = S_OK;
        try {
            CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pWsbDbSys;
            WsbAffirmPointer(pDbSysPriv);
            WsbAffirmHr(pDbSysPriv->DbAttachedAdd(path, TRUE));
            jstat = JetOpenDatabase(JET_CURRENT_SESSION, name, NULL, &JET_CURRENT_DB, 0);
            if (jstat == JET_errDatabaseNotFound) {
                WsbThrow(STG_E_FILENOTFOUND);
            } else {
                WsbAffirmHr(jet_error(jstat));
            }
        } WsbCatch(hr);
        WsbFree(name);
        WsbAffirmHr(hr);

        // Load information about this DB
        hr = jet_load_info();
        jstat = JetCloseDatabase(JET_CURRENT_SESSION, JET_CURRENT_DB, 0);
        WsbTrace(OLESTR("CWsbDb::Locate: JetCloseDatabase = %ld\n"),
                (LONG)jstat);
        JET_CURRENT_DB = 0;

        pDbInfo = (IMP_DB_INFO*)m_pImp;
        pDbInfo->OpenCount = 0;

    } WsbCatch(hr)
    CATCH_ANY_EXCEPTION

    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::Locate"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDb::Open(
    OUT IWsbDbSession** ppSession
    )

/*++

Implements:

  IWsbDb::Open

--*/
{
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Open"), OLESTR(""));
    
    try {
        ULONG         Size = 0;

        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();

        WsbAffirmHr(m_path.GetLen(&Size));
        WsbAffirm(Size > 0, WSB_E_NOT_INITIALIZED);

        //  Make sure we have a session
        WsbAffirm(0 != ppSession, E_POINTER);
        if (0 == *ppSession) {
            WsbAffirmHr(m_pWsbDbSys->NewSession(ppSession));
            WsbTrace(OLESTR("CWsbDb::Open: session created\n"));
        }



        int               i;
        JET_ERR           jstat;
        ULONG             memSize;
        char*             name;
        JET_SESID         SessionId;
        int               s_index;
        IMP_SESSION_INFO* s_info = pDbInfo->SessionInfo;
        CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = *ppSession;

        WsbAffirm(0 < pDbInfo->nSessions, WSB_E_NOT_INITIALIZED);
        WsbAffirm(pSessionPriv, E_FAIL);

        //  Get the JET session ID
        WsbAffirmHr(pSessionPriv->GetJetId(&SessionId));

        //  We need to save session info; look for an empty slot.
        WsbTrace(OLESTR("CWsbDb::Open: nSessions = %d, SessionId = %lx\n"), (
                int)pDbInfo->nSessions, SessionId);
        s_index = pDbInfo->nSessions;
        for (i = 0; i < pDbInfo->nSessions; i++) {
            WsbTrace(OLESTR("CWsbDb::Open: s_info[%d] = %lx\n"), i,
                    s_info[i].SessionId);

            //  Check for a duplicate session ID already in the table
            if (SessionId == s_info[i].SessionId) {
                s_index = i;
                break;

            //  Check for an unused slot
            } else if (0 == s_info[i].SessionId && 0 == s_info[i].DbId &&
                    s_index == pDbInfo->nSessions) {
                s_index = i;
            }
        }
        WsbTrace(OLESTR("CWsbDb::Open: s_index = %d\n"), s_index);

        if (s_index == pDbInfo->nSessions) {
            SHORT newNum;

            //  Didn't find an empty slot; expand the array
            newNum =  (SHORT) ( s_index + SESSION_INFO_EXPANSION );
            WsbTrace(OLESTR("CWsbDb::Open: expanding session table from %d to %d\n"),
                    s_index, newNum);
            memSize = newNum * sizeof(IMP_SESSION_INFO);
            s_info = (IMP_SESSION_INFO*)WsbRealloc(pDbInfo->SessionInfo, 
                    memSize);
            WsbAffirm(s_info, E_OUTOFMEMORY);
            ZeroMemory(&s_info[s_index], SESSION_INFO_EXPANSION * 
                    sizeof(IMP_SESSION_INFO));
            pDbInfo->SessionInfo = s_info;
            pDbInfo->nSessions = newNum;
        }

        //  Save the session ID and index
        m_SessionIndex = s_index;
        s_info[s_index].SessionId = SessionId;
        WsbTrace(OLESTR("CWsbDB::Open, s_info = %lx, SessionId[%d] = %lx\n"),
                (LONG)s_index, m_SessionIndex, JET_CURRENT_SESSION);

        WsbAffirmHr(wsb_db_jet_fix_path(m_path, L"." IDB_DB_FILE_SUFFIX, &name));

        CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pWsbDbSys;
        WsbAffirmPointer(pDbSysPriv);
        WsbAffirmHr(pDbSysPriv->DbAttachedAdd(m_path, TRUE));
        jstat = JetOpenDatabase(JET_CURRENT_SESSION, name, NULL, 
                &JET_CURRENT_DB, 0);
        WsbFree(name);
        if (jstat == JET_errDatabaseNotFound) {
            WsbThrow(STG_E_FILENOTFOUND);
        } else {
            WsbAffirmHr(jet_error(jstat));
        }

        //  Allocate/zero the table info array
        memSize = m_nRecTypes * sizeof(IMP_TABLE_INFO);
        WsbTrace(OLESTR("CWsbDb::Open: pTableInfo = %lx\n"), 
            s_info[m_SessionIndex].pTableInfo);
        if (NULL == s_info[m_SessionIndex].pTableInfo) {
            s_info[m_SessionIndex].pTableInfo = (IMP_TABLE_INFO*)WsbAlloc(memSize);
            WsbAffirm(s_info[m_SessionIndex].pTableInfo, E_OUTOFMEMORY);
            WsbTrace(OLESTR("CWsbDb::Open: new pTableInfo = %lx\n"), 
                s_info[m_SessionIndex].pTableInfo);
        }
        ZeroMemory(s_info[m_SessionIndex].pTableInfo, memSize);

        pDbInfo->OpenCount++;

    } WsbCatchAndDo(hr, 
            WsbLogEvent(WSB_MESSAGE_IDB_OPEN_FAILED, 0, NULL,
            WsbAbbreviatePath(m_path, 120), NULL);
        )
    CATCH_ANY_EXCEPTION

    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::Open"), OLESTR("hr =<%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDb::Close(
    IN IWsbDbSession*  pSession
    )

/*++

Implements:

  IWsbDb::Close
        - The element was added.

--*/
{
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Close"), OLESTR(""));
    
    try {
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();

        WsbAffirm(pDbInfo->OpenCount, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(session_current_index(pSession));

        pDbInfo->OpenCount--;

        JET_ERR           jstat;
        IMP_SESSION_INFO* s_info = pDbInfo->SessionInfo;

        WsbTrace(OLESTR("CWsbDb::Close: closing DB, SessionId = %lx, DbId = %lx\n"),
                (LONG)s_info[m_SessionIndex].SessionId, (LONG)s_info[m_SessionIndex].DbId);
        jstat = JetCloseDatabase(s_info[m_SessionIndex].SessionId, 
                s_info[m_SessionIndex].DbId, 0);
        WsbTrace(OLESTR("CWsbDb::Close: JetCloseDatabase = %ld\n"),
            (LONG)jstat);
        if (s_info[m_SessionIndex].pTableInfo) {
            WsbTrace(OLESTR("CWsbDb::Close: releasing pTableInfo\n"));
            WsbFree(s_info[m_SessionIndex].pTableInfo);
            s_info[m_SessionIndex].pTableInfo = NULL;
        }
        s_info[m_SessionIndex].SessionId = 0;
        s_info[m_SessionIndex].DbId = 0;

    } WsbCatch(hr)
    CATCH_ANY_EXCEPTION

    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::Close"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDb::GetEntity(
    IN IWsbDbSession* pSession,
    IN ULONG    RecId,
    IN REFIID   riid,
    OUT void**  ppEntity
    )

/*++

Implements:

  IWsbDb::GetEntity

--*/
{
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;
    CComPtr<IWsbDbEntityPriv> pEntity;

    WsbTraceIn(OLESTR("CWsbDb::GetEntity"), OLESTR(""));
    
    try {
        CComQIPtr<IWsbDb, &IID_IWsbDb> pIWsbDb = (IWsbDbPriv*)this;
        int               rec_index;

        WsbAssert(0 != ppEntity, E_POINTER);
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();
        WsbAffirmHr(session_current_index(pSession));

        // Find the record info
        for (rec_index = 0; rec_index < m_nRecTypes; rec_index++) {
            if (m_RecInfo[rec_index].Type == RecId) break;
        }
        WsbAffirm(rec_index < m_nRecTypes, E_INVALIDARG);

        // Create the instance, initialize it to point to this DB, and
        // return the pointer to the caller.
        WsbAffirmHr(CoCreateInstance(m_RecInfo[rec_index].EntityClassId, NULL, 
                CLSCTX_SERVER | CLSCTX_INPROC_HANDLER, 
                IID_IWsbDbEntityPriv, (void**) &pEntity));
        WsbAffirmHr(pEntity->Init(pIWsbDb, m_pWsbDbSys, RecId, JET_CURRENT_SESSION));
        WsbAffirmHr(pEntity->QueryInterface(riid, (void**)ppEntity));

    } WsbCatch(hr)
    CATCH_ANY_EXCEPTION

    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::GetEntity"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDb::GetKeyInfo(
    IN ULONG RecType,
    IN USHORT nKeys, 
    OUT COM_IDB_KEY_INFO* pKeyInfo
    )

/*++

Implements:

  IWsbDbPriv::GetKeyInfo

--*/
{
    HRESULT             hr = E_FAIL;

    WsbTraceIn(OLESTR("CWsbDb::GetKeyInfo"), OLESTR(""));
    
    try {
        IMP_DB_INFO*  pDbInfo;
    
        WsbAssert(0 < nKeys, E_INVALIDARG);
        WsbAssert(0 != pKeyInfo, E_POINTER);
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        for (int i = 0; i < m_nRecTypes; i++) {
            if (m_RecInfo[i].Type == RecType) {
                USHORT n = min(nKeys, m_RecInfo[i].nKeys);

                for (int j = 0; j < n; j++) {
                    pKeyInfo[j].Type = m_RecInfo[i].Key[j].Type;
                    pKeyInfo[j].Size = m_RecInfo[i].Key[j].Size;
                    pKeyInfo[j].Flags = m_RecInfo[i].Key[j].Flags;
                }
                hr = S_OK;
                break;
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::GetKeyInfo"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDb::GetRecInfo(
    IN ULONG RecType,
    OUT COM_IDB_REC_INFO* pRecInfo 
    )

/*++

Implements:

  IWsbDbPriv::GetRecInfo

--*/
{
    HRESULT             hr = E_FAIL;

    WsbTraceIn(OLESTR("CWsbDb::GetRecInfo"), OLESTR(""));
    
    try {
        IMP_DB_INFO*  pDbInfo;
    
        WsbAssert(0 != pRecInfo, E_POINTER);
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        for (int i = 0; i < m_nRecTypes; i++) {
            if (m_RecInfo[i].Type == RecType) {
                pRecInfo->Type = m_RecInfo[i].Type;
                pRecInfo->EntityClassId = m_RecInfo[i].EntityClassId;
                pRecInfo->Flags = m_RecInfo[i].Flags;
                pRecInfo->MinSize = m_RecInfo[i].MinSize;
                pRecInfo->MaxSize = m_RecInfo[i].MaxSize;
                pRecInfo->nKeys = m_RecInfo[i].nKeys;
                hr = S_OK;
                break;
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::GetRecInfo"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


// GetJetIds - for a given record type, return the session ID,
//    the table ID, and the data column ID
HRESULT CWsbDb::GetJetIds(JET_SESID SessionId, ULONG RecType, 
                JET_TABLEID* pTableId, ULONG* pDataColId)
{
    HRESULT             hr = WSB_E_INVALID_DATA;

    WsbTraceIn(OLESTR("CWsbDb::GetJetIds"), OLESTR(""));
    
    try {
        JET_DBID      DbId = 0;
        IMP_DB_INFO*  pDbInfo;
    
        WsbAssert(0 != pTableId || 0 != pDataColId, E_POINTER);
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        WsbTrace(OLESTR("CWsbDb::GetJetIds: this = %p, pDbInfo = %p\n"), 
                this, pDbInfo);

        for (int index = 0; index < pDbInfo->nSessions; index++) {
            if (pDbInfo->SessionInfo[index].SessionId == SessionId) {
                DbId = pDbInfo->SessionInfo[index].DbId;
                break;
            }
        }
        WsbTrace(OLESTR("CWsbDb::GetJetIds: index = %d, DbId = %ld\n"), index, (LONG)DbId);
        WsbAffirm(index < pDbInfo->nSessions, E_FAIL);
        WsbAffirm(pDbInfo->SessionInfo[index].pTableInfo, WSB_E_NOT_INITIALIZED);
        for (int i = 0; i < m_nRecTypes; i++) {
            if (m_RecInfo[i].Type == RecType) {
                JET_ERR         jstat;
                char            table_name[20];
                IMP_TABLE_INFO* t_info = pDbInfo->SessionInfo[index].pTableInfo;

                WsbAffirmHr(jet_make_table_name(m_RecInfo[i].Type,
                        table_name, 20));
                WsbTrace(OLESTR("CWsbDb::GetJetIds: t_info = %p, i = %d, table_name = <%hs>\n"), 
                        t_info, i, table_name);
                if (0 == t_info[i].TableId && 0 == t_info[i].ColId) {

                    //  Open the table for this record type
                    WsbTrace(OLESTR("CWsbDb::GetJetIds: opening Jet table, SessionId = %lx, DbId = %ld, table_name = <%hs>, &TableId = %p\n"),
                            (LONG)SessionId, (LONG)DbId, table_name, (&t_info[i].TableId));
                    jstat = JetOpenTable(SessionId, DbId, table_name,
                            NULL, 0, 0, &t_info[i].TableId);
                    WsbTrace(OLESTR("CWsbDb::GetJetIds: TableId = %ld\n"),
                            t_info[i].TableId);
                    WsbAffirmHr(jet_error(jstat));

                    //  Get the column ID for the data column
                    WsbAffirmHr(jet_get_column_id(SessionId, DbId, table_name,
                            JET_DATA_COLUMN_NAME, &t_info[i].ColId));
                }

                if (0 != pTableId) {
                    *pTableId = t_info[i].TableId;
                }
                if (0 != pDataColId) {
                    *pDataColId = t_info[i].ColId;
                }
                hr = S_OK;
                break;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::GetJetIds"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// GetJetIndexInfo - for a given record type and key type, return information
//    about the key/index: the key size (in bytes), the column ID,
//    the index name
HRESULT CWsbDb::GetJetIndexInfo(JET_SESID SessionId, ULONG RecType, ULONG KeyType,
                ULONG* pColId, OLECHAR** pName, ULONG bufferSize)
{
    HRESULT             hr = WSB_E_INVALID_DATA;

    WsbTraceIn(OLESTR("CWsbDb::GetJetIndexInfo"), OLESTR(""));
    
    try {
        JET_DBID      DbId = 0;
        IMP_DB_INFO*  pDbInfo;
    
        WsbAssert(0 != pColId || 0 != pName, E_POINTER);
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        for (int index = 0; index < pDbInfo->nSessions; index++) {
            if (pDbInfo->SessionInfo[index].SessionId == SessionId) {
                DbId = pDbInfo->SessionInfo[index].DbId;
                break;
            }
        }
        WsbAffirm(index < pDbInfo->nSessions, E_FAIL);
        for (int i = 0; i < m_nRecTypes; i++) {
            if (m_RecInfo[i].Type == RecType) {
                char index_name[20];
                char table_name[20];

                WsbAffirmHr(jet_make_table_name(RecType, table_name, 20));

                if (0 == KeyType) {
                    if (0 != pName) {
                        WsbAffirm(bufferSize > strlen(JET_SEQNUM_COLUMN_NAME), E_FAIL);
                        WsbAffirm(0 < mbstowcs(*pName, JET_SEQNUM_COLUMN_NAME, 
                                strlen(JET_SEQNUM_COLUMN_NAME) + 1), E_FAIL);
                    }
                    if (0 != pColId) {
                        WsbAffirmHr(jet_get_column_id(SessionId, DbId, table_name,
                                JET_SEQNUM_COLUMN_NAME, pColId));
                    }
                    hr = S_OK;
                } else {
                    //  Search for the given key type
                    for (int j = 0; j < m_RecInfo[i].nKeys; j++) {
                        if (m_RecInfo[i].Key[j].Type == KeyType) {
                            WsbAffirmHr(jet_make_index_name(KeyType, index_name, 20));
                            if (0 != pName) {
                                WsbAffirm(bufferSize > strlen(index_name), E_FAIL);
                                WsbAffirm(0 < mbstowcs(*pName, index_name, 
                                        strlen(index_name) + 1), E_FAIL);
                            }
                            if (0 != pColId) {
                                WsbAffirmHr(jet_get_column_id(SessionId, DbId, table_name,
                                        index_name, pColId));
                            }
                            hr = S_OK;
                            break;
                        }
                    }
                }
                break;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::GetJetIndexInfo"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDb::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDb::FinalConstruct"), OLESTR("") );

    try {
        IMP_DB_INFO*  pDbInfo;

        WsbAffirmHr(CWsbPersistable::FinalConstruct());
        m_nRecTypes = 0;
        m_version = 0;
        m_pImp = NULL;
        m_RecInfo = NULL;

        m_SessionIndex = 0;

        // Allocate space for DB info & set
        pDbInfo = (IMP_DB_INFO*)WsbAlloc(sizeof(IMP_DB_INFO));
        m_pImp = pDbInfo;
        WsbAffirm(pDbInfo, E_OUTOFMEMORY);
        ZeroMemory(pDbInfo, sizeof(IMP_DB_INFO));
        pDbInfo->IsLoaded = FALSE;
        pDbInfo->OpenCount = 0;

        pDbInfo->nSessions = 0;
        pDbInfo->SessionInfo = NULL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::FinalConstruct"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



void
CWsbDb::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDb::FinalRelease"), OLESTR(""));

    try {
        if (m_pImp) {
            int          i;
            IMP_DB_INFO* pDbInfo;

            pDbInfo = (IMP_DB_INFO*)m_pImp;

            if (pDbInfo->RecInfo) {
                for (i = 0; i < m_nRecTypes; i++) {

                    if (pDbInfo->RecInfo[i].Key) {
                        WsbFree(pDbInfo->RecInfo[i].Key);
                    }
                }
                WsbFree(pDbInfo->RecInfo);
            }

            //  Make sure Jet resources are released
            if (NULL != pDbInfo->SessionInfo) {
                IMP_SESSION_INFO* s_info = pDbInfo->SessionInfo;

                for (i = 0; i < pDbInfo->nSessions; i++) {
                    if (0 != s_info[i].SessionId && 0 != s_info[i].DbId) {
                        JET_ERR       jstat;

                        jstat = JetCloseDatabase(s_info[i].SessionId, 
                                s_info[i].DbId, 0);
                        WsbTrace(OLESTR("CWsbDb::FinalRelease: JetCloseDatabase[%d] = %ld\n"),
                                i, (LONG)jstat);
                    }
                    if (s_info[i].pTableInfo) {
                        WsbFree(s_info[i].pTableInfo);
                        s_info[i].pTableInfo = NULL;
                    }
                    s_info[i].SessionId = 0;
                    s_info[i].DbId = 0;
                }

                WsbFree(pDbInfo->SessionInfo);
                pDbInfo->SessionInfo = NULL;
            }
            pDbInfo->nSessions = 0;

            WsbFree(pDbInfo);
            m_pImp = NULL;
        }


        if (m_RecInfo) {
            for (int i = 0; i < m_nRecTypes; i++) {
                if (m_RecInfo[i].Key) {
                    WsbFree(m_RecInfo[i].Key);
                }
            }
            WsbFree(m_RecInfo);
            m_RecInfo = NULL;
        }

        CWsbPersistable::FinalRelease();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::FinalRelease"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
}



HRESULT
CWsbDb::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDb::GetClassID"), OLESTR(""));

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbDb;
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CWsbDb::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbDb::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT             hr = S_OK;
    OLECHAR*            name = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Load"), OLESTR(""));
    
    try {
        ULONG         Bytes;
        ULONG         len = 0;
        IMP_DB_INFO*  pDbInfo;
        FILE_DB_INFO  db_file_block;   // Used to move info to/from file
        CComQIPtr<IWsbDb, &IID_IWsbDb> pIWsbDb = (IWsbDbPriv*)this;

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        // Don't allow loading into an already open DB
        WsbAffirm(pDbInfo->OpenCount == 0, WSB_E_INVALID_DATA);

        // Read the DB file name
        WsbAffirmHr(WsbLoadFromStream(pStream, &name, 0));
        if (name) {
            len = wcslen(name);
        }

        // If the DB name is empty, there is no more info
        if (0 < len) {
            // Alloc space and read DB info
            WsbAffirmHr(pStream->Read((void*)&db_file_block, sizeof(FILE_DB_INFO), &Bytes));
            WsbAffirm(Bytes == sizeof(FILE_DB_INFO), WSB_E_STREAM_ERROR);

            // Check DB version for match
            WsbAffirm(db_file_block.version == m_version, WSB_E_IDB_WRONG_VERSION);

            // Locate the DB
            WsbAffirmHr(db_info_from_file_block(&db_file_block));
            hr = Locate(name);
            if (S_OK != hr) {
                if (pDbInfo->RecInfo) {
                    WsbFree(pDbInfo->RecInfo);
                    pDbInfo->RecInfo = NULL;
                }
            }
        } else {
            hr = S_FALSE;
        }
    } WsbCatch(hr);

    WsbFree(name);

    WsbTraceOut(OLESTR("CWsbDb::Load"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDb::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDb::Save"), OLESTR(""));
    
    try {
        ULONG         Bytes;
        ULONG         len = 0;
        FILE_DB_INFO  db_file_block;   // Used to move info to/from file

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(m_pImp, WSB_E_NOT_INITIALIZED);

        // Save the DB name
        WsbAffirmHr(WsbSaveToStream(pStream, m_path));
        WsbAffirmHr(m_path.GetLen(&len));

        // If the name is empty, none of the other information is likely
        // to be useful
        if (0 < len) {
            // Write some DB info
            WsbAffirm(m_nRecTypes, WSB_E_NOT_INITIALIZED);
            WsbAffirmHr(db_info_to_file_block(&db_file_block));
            WsbAffirmHr(pStream->Write((void*)&db_file_block, sizeof(FILE_DB_INFO), &Bytes));
            WsbAffirm(Bytes == sizeof(FILE_DB_INFO), WSB_E_STREAM_ERROR);
        }

        if (clearDirty) {
            SetIsDirty(FALSE);
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::Save"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

//
// Private functions
//

//  db_info_from_file_block - copy data from DB info file block
HRESULT
CWsbDb::db_info_from_file_block(void* block)
{
    HRESULT hr = S_OK;

    try {
        IMP_DB_INFO*  pDbInfo;
        ULONG         Size;
        FILE_DB_INFO *pDbFileBlock = (FILE_DB_INFO*)block;

        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        WsbAssert(0 != pDbFileBlock, E_POINTER);
        m_version = pDbFileBlock->version;
        m_nRecTypes = pDbFileBlock->nRecTypes;

        //  Allocate record arrays
        if (NULL == m_RecInfo) {
            Size = m_nRecTypes * sizeof(IDB_REC_INFO);
            m_RecInfo = (IDB_REC_INFO*)WsbAlloc(Size);
            WsbAffirm(m_RecInfo, E_OUTOFMEMORY);
            ZeroMemory(m_RecInfo, Size);
        }
        if (NULL == pDbInfo->RecInfo) {
            Size = m_nRecTypes * sizeof(IMP_REC_INFO);
            pDbInfo->RecInfo = (IMP_REC_INFO*)WsbAlloc(Size);
            WsbAffirm(pDbInfo->RecInfo, E_OUTOFMEMORY);
            ZeroMemory(pDbInfo->RecInfo, Size);
        }
    } WsbCatch(hr);

    return(hr);
}

//  db_info_to_file_block - copy data to DB info file block
HRESULT 
CWsbDb::db_info_to_file_block(void* block)
{
    HRESULT hr = S_OK;

    try {
        FILE_DB_INFO *pDbFileBlock = (FILE_DB_INFO*)block;

        WsbAssert (0 != pDbFileBlock, E_POINTER);
        pDbFileBlock->version = m_version;
        pDbFileBlock->nRecTypes = m_nRecTypes;
    } WsbCatch(hr);

    return hr;
}

//  rec_info_from_file_block - copy record data from rec info file block
HRESULT
CWsbDb::rec_info_from_file_block(int index, void* block)
{
    HRESULT hr = S_OK;

    try {
        IMP_DB_INFO*  pDbInfo;
        ULONG         Size;
        FILE_REC_INFO *pRecFileBlock = (FILE_REC_INFO*)block;

        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        WsbAssert (0 != pRecFileBlock, E_POINTER);
        m_RecInfo[index].Type = pRecFileBlock->Type;
        m_RecInfo[index].EntityClassId = pRecFileBlock->EntityClassId;
        m_RecInfo[index].Flags = pRecFileBlock->Flags;
        m_RecInfo[index].MinSize = pRecFileBlock->MinSize;
        m_RecInfo[index].MaxSize = pRecFileBlock->MaxSize;
        m_RecInfo[index].nKeys = pRecFileBlock->nKeys;

        //  Allocate Key arrays
        if (NULL == m_RecInfo[index].Key) {
            Size = m_RecInfo[index].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[index].Key = (IDB_KEY_INFO*)WsbAlloc(Size);
            WsbAffirm(m_RecInfo[index].Key, E_OUTOFMEMORY);
            ZeroMemory(m_RecInfo[index].Key, Size);
        }
        if (NULL == pDbInfo->RecInfo[index].Key) {
            Size = m_RecInfo[index].nKeys * sizeof(IMP_KEY_INFO);
            pDbInfo->RecInfo[index].Key = (IMP_KEY_INFO*)WsbAlloc(Size);
            WsbAffirm(pDbInfo->RecInfo[index].Key, E_OUTOFMEMORY);
            ZeroMemory(pDbInfo->RecInfo[index].Key, Size);
        }

        for (int j = 0; j < pRecFileBlock->nKeys; j++) {
            m_RecInfo[index].Key[j].Type = pRecFileBlock->Key[j].Type;
            m_RecInfo[index].Key[j].Size = pRecFileBlock->Key[j].Size;
            m_RecInfo[index].Key[j].Flags = pRecFileBlock->Key[j].Flags;
        }
    } WsbCatch(hr);

    return(hr);
}

//  rec_info_to_file_block - copy record data to rec info file block
HRESULT 
CWsbDb::rec_info_to_file_block(int index, void* block)
{
    HRESULT hr = S_OK;
    try {
        FILE_REC_INFO *pRecFileBlock = (FILE_REC_INFO*)block;

        WsbAssert (0 != pRecFileBlock, E_POINTER);

//      pRecFileBlock->SeqNum = m_RecInfo[index].SeqNum;
        pRecFileBlock->Type = m_RecInfo[index].Type;
        pRecFileBlock->EntityClassId = m_RecInfo[index].EntityClassId;
        pRecFileBlock->Flags = m_RecInfo[index].Flags;
        pRecFileBlock->MinSize = m_RecInfo[index].MinSize;
        pRecFileBlock->MaxSize = m_RecInfo[index].MaxSize;
        pRecFileBlock->nKeys = m_RecInfo[index].nKeys;
        for (int j = 0; j < pRecFileBlock->nKeys; j++) {
            pRecFileBlock->Key[j].Type = m_RecInfo[index].Key[j].Type;
            pRecFileBlock->Key[j].Size = m_RecInfo[index].Key[j].Size;
            pRecFileBlock->Key[j].Flags = m_RecInfo[index].Key[j].Flags;
        }
    } WsbCatch(hr);

    return hr;
}

//  session_current_index - find the index into the session info array.
//    Sets m_SessionIndex if it's OK
HRESULT 
CWsbDb::session_current_index(IWsbDbSession* pSession)
{
    HRESULT       hr = WSB_E_INVALID_DATA;
    IMP_DB_INFO*  pDbInfo;
    CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = pSession;

    WsbTraceIn(OLESTR("CWsbDB::session_current_index"), OLESTR(""));
    pDbInfo = (IMP_DB_INFO*)m_pImp;
    if (NULL != pDbInfo && NULL != pDbInfo->SessionInfo && pSessionPriv) {
        JET_SESID SessionId;

        if (S_OK == pSessionPriv->GetJetId(&SessionId)) {
            for (int index = 0; index < pDbInfo->nSessions; index++) {
                if (pDbInfo->SessionInfo[index].SessionId == SessionId) {
                    hr = S_OK;
                    m_SessionIndex = index;
                    break;
                }
            }
        }
    }

    WsbTraceOut(OLESTR("CWsbDB::session_current_index"), OLESTR("sessionID[%ld] = %lx"),
                m_SessionIndex, pDbInfo->SessionInfo[m_SessionIndex].SessionId);
    return(hr);
}


// jet_init - make sure this IDB object is initialized for JET
HRESULT
CWsbDb::jet_init(void)
{
    HRESULT    hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDb::jet_init"), OLESTR(""));

    try {
        IMP_DB_INFO*  pDbInfo;

        pDbInfo = (IMP_DB_INFO*)m_pImp;
        WsbTrace(OLESTR("CWsbDB::jet_init, nSessions = %d\n"),
                (int)pDbInfo->nSessions);
        if (0 == pDbInfo->nSessions) {
            ULONG        memSize;

            //  Allocate the thread info array
            WsbAffirm(m_pWsbDbSys, E_FAIL);
            memSize = SESSION_INFO_INITIAL_SIZE * sizeof(IMP_SESSION_INFO);
            pDbInfo->SessionInfo = (IMP_SESSION_INFO*)WsbAlloc(memSize);
            WsbAffirm(pDbInfo->SessionInfo, E_OUTOFMEMORY);
            pDbInfo->nSessions = SESSION_INFO_INITIAL_SIZE;
            ZeroMemory(pDbInfo->SessionInfo, memSize);
            WsbTrace(OLESTR("CWsbDB::jet_init, SessionInfo(%ld bytes) allocated & zeroed\n"),
                    memSize);

            //  Begin a JET session for the IDB
            m_SessionIndex = 0;

            JET_SESID               sid;
            CComPtr<IWsbDbSession>  pSession;
            WsbAffirmHr(m_pWsbDbSys->GetGlobalSession(&pSession));

            CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = pSession;
            WsbAffirmPointer(pSessionPriv);
            WsbAffirmHr(pSessionPriv->GetJetId(&sid));
            pDbInfo->SessionInfo[m_SessionIndex].SessionId = sid;
            WsbTrace(OLESTR("CWsbDB::jet_init, SessionId[0] = %lx\n"),
                    pDbInfo->SessionInfo[m_SessionIndex].SessionId);
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::jet_init"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}

// jet_load_info - load DB info from database
HRESULT
CWsbDb::jet_load_info(void)
{
    HRESULT       hr = S_OK;
    IMP_DB_INFO*  pDbInfo = NULL;
    JET_TABLEID   table_id = 0;
    JET_ERR       jstat;

    WsbTraceIn(OLESTR("CWsbDb::jet_load_info"), OLESTR(""));

    try {
        JET_COLUMNID  col_id_data;
        ULONG         size;
        FILE_DB_INFO  db_file_block;   // Used to move info to/from file
        FILE_REC_INFO rec_file_block;  // Used to move record info

        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        // Open the info table
        jstat = JetOpenTable(JET_CURRENT_SESSION, JET_CURRENT_DB, JET_INFO_TABLE_NAME,
                NULL, 0, 0, &table_id);
        if (jstat != JET_errSuccess) {
            table_id = 0;
        }
        WsbTrace(OLESTR("CWsbDb::jet_load_info: open TableId = %ld\n"),
               table_id);
        WsbAffirmHr(jet_error(jstat));
        WsbAffirmHr(jet_get_column_id(JET_CURRENT_SESSION, JET_CURRENT_DB, JET_INFO_TABLE_NAME,
                JET_DATA_COLUMN_NAME, &col_id_data));
        jstat = JetSetCurrentIndex(JET_CURRENT_SESSION, table_id, NULL);
        WsbAffirmHr(jet_error(jstat));

        // Get the DB info and check for match
        jstat = JetRetrieveColumn(JET_CURRENT_SESSION, table_id, col_id_data,
                &db_file_block, sizeof(FILE_DB_INFO), &size, 0, NULL);
        WsbAffirmHr(jet_error(jstat));
        WsbAffirm(db_file_block.nRecTypes > 0, WSB_E_INVALID_DATA);
        WsbAffirm(db_file_block.version == m_version, WSB_E_IDB_WRONG_VERSION);
        WsbAffirmHr(db_info_from_file_block(&db_file_block));
        
        // Get the record/key info
        for (int i = 0; i < m_nRecTypes; i++) {
            jstat = JetMove(JET_CURRENT_SESSION, table_id, JET_MoveNext, 0);
            WsbAffirmHr(jet_error(jstat));
            jstat = JetRetrieveColumn(JET_CURRENT_SESSION, table_id, col_id_data,
                    &rec_file_block, sizeof(FILE_REC_INFO), &size, 0, NULL);
            WsbAffirmHr(jet_error(jstat));
            WsbAffirmHr(rec_info_from_file_block(i, &rec_file_block));
        }
    } WsbCatch(hr);

    if (table_id) {
        jstat = JetCloseTable(JET_CURRENT_SESSION, table_id);
        WsbTrace(OLESTR("CWsbDb::jet_load_info: close TableId = %ld, jstat = %ld\n"),
               table_id, jstat);
    }

    WsbTraceOut(OLESTR("CWsbDb::jet_load_info"), OLESTR("hr =<%ls>"), 
            WsbHrAsString(hr));
    return(hr);
}

// jet_make_index_name - convert key type to index name
HRESULT 
CWsbDb::jet_make_index_name(ULONG key_type, char* pName, ULONG bufsize)
{
    HRESULT       hr = E_FAIL;
    char          lbuf[20];

    if (pName != NULL) {
        sprintf(lbuf, "%ld", key_type);
        if (bufsize > strlen(lbuf)) {
            strcpy(pName, lbuf);
            hr = S_OK;
        }
    }
    return(hr);
}

// jet_make_table_name - convert record type to table name
HRESULT 
CWsbDb::jet_make_table_name(ULONG rec_type, char* pName, ULONG bufsize)
{
    HRESULT       hr = E_FAIL;
    char          lbuf[20];

    if (pName != NULL) {
        sprintf(lbuf, "%ld", rec_type);
        if (bufsize > strlen(lbuf)) {
            strcpy(pName, lbuf);
            hr = S_OK;
        }
    }
    return(hr);
}

// jet_save_info - save DB info to database
HRESULT
CWsbDb::jet_save_info()
{
    HRESULT       hr = S_OK;
    IMP_DB_INFO*  pDbInfo = NULL;
    JET_TABLEID   table_id = 0;
    JET_ERR       jstat;

    try {
        JET_COLUMNID  col_id_data;
        JET_COLUMNID  col_id_index;
        SHORT         data_number;
        FILE_DB_INFO  db_file_block;   // Used to move info to/from file
        FILE_REC_INFO rec_file_block;  // Used to move record info

        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        // Open the table
        jstat = JetOpenTable(JET_CURRENT_SESSION, JET_CURRENT_DB, JET_INFO_TABLE_NAME,
                NULL, 0, 0, &table_id);
        WsbTrace(OLESTR("CWsbDb::jet_save_info: open TableId = %ld\n"),
               table_id);
        WsbAffirmHr(jet_error(jstat));
        WsbAffirmHr(jet_get_column_id(JET_CURRENT_SESSION, JET_CURRENT_DB, JET_INFO_TABLE_NAME,
                JET_INDEX_COLUMN_NAME, &col_id_index));
        WsbAffirmHr(jet_get_column_id(JET_CURRENT_SESSION, JET_CURRENT_DB, JET_INFO_TABLE_NAME,
                JET_DATA_COLUMN_NAME, &col_id_data));

        // Put the DB info
        jstat = JetPrepareUpdate(JET_CURRENT_SESSION, table_id, JET_prepInsert);
        WsbAffirmHr(jet_error(jstat));
        WsbAffirmHr(db_info_to_file_block(&db_file_block));
        data_number = 0;
        jstat = JetSetColumn(JET_CURRENT_SESSION, table_id, col_id_index, &data_number,
                sizeof(data_number), 0, NULL);
        WsbAffirmHr(jet_error(jstat));
        jstat = JetSetColumn(JET_CURRENT_SESSION, table_id, col_id_data, &db_file_block,
                sizeof(FILE_DB_INFO), 0, NULL);
        WsbAffirmHr(jet_error(jstat));
        jstat = JetUpdate(JET_CURRENT_SESSION, table_id, NULL, 0, NULL);
        WsbAffirmHr(jet_error(jstat));

        // Put the record/key info
        for (int i = 0; i < m_nRecTypes; i++) {
            jstat = JetPrepareUpdate(JET_CURRENT_SESSION, table_id, JET_prepInsert);
            WsbAffirmHr(jet_error(jstat));
            WsbAffirmHr(rec_info_to_file_block(i, &rec_file_block));
            data_number = (SHORT) ( i + 1 );
            jstat = JetSetColumn(JET_CURRENT_SESSION, table_id, col_id_index, &data_number,
                    sizeof(data_number), 0, NULL);
            WsbAffirmHr(jet_error(jstat));
            jstat = JetSetColumn(JET_CURRENT_SESSION, table_id, col_id_data, &rec_file_block,
                sizeof(FILE_REC_INFO), 0, NULL);
            WsbAffirmHr(jet_error(jstat));
            jstat = JetUpdate(JET_CURRENT_SESSION, table_id, NULL, 0, NULL);
            WsbAffirmHr(jet_error(jstat));
        }
    } WsbCatch(hr);

    if (table_id) {
        jstat = JetCloseTable(JET_CURRENT_SESSION, table_id);
        WsbTrace(OLESTR("CWsbDb::jet_save_info: close TableId = %ld, jstat = %ld\n"),
               table_id, jstat);
    }
    return(hr);
}

//  Local functions

//  jet_get_column_id - convert a column name to a column ID
static HRESULT jet_get_column_id(JET_SESID jet_session, JET_DBID DbId, 
        char* pTableName, char* pColumnName, JET_COLUMNID* pColId)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("jet_get_column_id"), OLESTR("SessId = %lx, DbId = %lx"),
        (ULONG)jet_session, (ULONG)DbId);

    try {
        JET_COLUMNBASE col_base;
        JET_ERR        jstat;

        WsbAssert(NULL != pColId, E_POINTER);
        jstat = JetGetColumnInfo(jet_session, DbId, pTableName, pColumnName,
                &col_base, sizeof(col_base), JET_ColInfoBase);
        WsbAssertHr(jet_error(jstat));
        *pColId = col_base.columnid;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("jet_get_column_id"), OLESTR("col_id = %ld"),
        (LONG)*pColId);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\wsbdbses.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbses.h

Abstract:

    The CWsbDbSes class.

Author:

    Ron White   [ronw]   20-Jun-1997

Revision History:

--*/


#ifndef _WSBDBSES_
#define _WSBDBSES_

#include "wsbdb.h"
#include "wsbdbses.h"



/*++

Class Name:

    CWsbDbSession

Class Description:

    A data base session object.

--*/

class CWsbDbSession :
    public CComObjectRoot,
    public IWsbDbSession,
    public IWsbDbSessionPriv
{
friend class CWsbDb;
public:
    CWsbDbSession() {}
BEGIN_COM_MAP(CWsbDbSession)
    COM_INTERFACE_ENTRY(IWsbDbSession)
    COM_INTERFACE_ENTRY(IWsbDbSessionPriv)
END_COM_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbDbSession
public:
    STDMETHOD(TransactionBegin)(void);
    STDMETHOD(TransactionCancel)(void);
    STDMETHOD(TransactionEnd)(void);

//  IWsbDbSessionPriv
    STDMETHOD(Init)(JET_INSTANCE *pInstance);
    STDMETHOD(GetJetId)(JET_SESID *pSessionId);

// Data
protected:

    JET_SESID  m_SessionId;   // Jet session ID

};


#endif // _WSBDBSES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\wsbdbses.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbses.cpp

Abstract:

    The CWsbDbSession class

Author:

    Ron White   [ronw]   20-Jun-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsbdbsys.h"
#include "wsbdbses.h"


static USHORT iCountSes = 0;  // Count of existing objects



HRESULT
CWsbDbSession::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::FinalConstruct"), OLESTR("") );

    m_SessionId = JET_sesidNil;

    iCountSes++;

    WsbTraceOut(OLESTR("CWsbDbSession::FinalConstruct"), OLESTR("hr =<%ls>, Count is <%d>"), 
            WsbHrAsString(hr), iCountSes);

    return(hr);
}



void
CWsbDbSession::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::FinalRelease"), OLESTR(""));

    try {
        JET_ERR          jstat;

        WsbTrace(OLESTR("CWsbDbSession::FinalRelease, SessionId = %p\n"), (LONG_PTR)m_SessionId);
        if (JET_sesidNil != m_SessionId) {
            jstat = JetEndSession(m_SessionId, 0);
            WsbAffirmHr(jet_error(jstat));
            m_SessionId = JET_sesidNil;
        }
    } WsbCatch(hr);

    iCountSes--;

    WsbTraceOut(OLESTR("CWsbDbSession::FinalRelease"), OLESTR("hr =<%ls>, Count is <%d>"), 
            WsbHrAsString(hr), iCountSes);
}

HRESULT
CWsbDbSession::Init(
    JET_INSTANCE *pInstance
    )

/*++

Implements:

  IWsbDbSessionPriv::Init

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::Init"), OLESTR("") );

    try {
        JET_ERR          jstat;

        // Create the Jet session here instead of in FinalConstract
        // because we need the Jet instance
        WsbAffirm(NULL != pInstance, E_POINTER);
        WsbTrace(OLESTR("CWsbDbSession::Init, calling JetBeginSession, JetInstance = %p\n"),
                (LONG_PTR)*pInstance );
        jstat = JetBeginSession(*pInstance, &m_SessionId, NULL, NULL);
        WsbTrace(OLESTR("CWsbDbSession::FinalConstruct, SessionId = %p\n"), (LONG_PTR)m_SessionId);
        WsbAffirmHr(jet_error(jstat));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSession::Init"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbSession::GetJetId(
    JET_SESID* pSessionId
    )

/*++

Implements:

  IWsbDbSessionPriv::GetJetId

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::GetJetId"), OLESTR("") );

    *pSessionId = m_SessionId;

    WsbTraceOut(OLESTR("CWsbDbSession::GetJetId"), OLESTR("hr =<%ls>, Id = %lx"), 
            WsbHrAsString(hr), *pSessionId);

    return(hr);
}



HRESULT
CWsbDbSession::TransactionBegin(
    void
    )

/*++

Implements:

  IWsbDbSession::TransactionBegin

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::TransactionBegin"), OLESTR(""));
    
    try {
        JET_ERR   jstat;

        jstat = JetBeginTransaction(m_SessionId);
        WsbAffirmHr(jet_error(jstat));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSession::TransactionBegin"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbSession::TransactionCancel(
    void
    )

/*++

Implements:

  IWsbDbSession::TransactionCancel

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::TransactionCancel"), OLESTR(""));
    
    try {
        JET_ERR   jstat;

        jstat = JetRollback(m_SessionId, 0);
        WsbAffirmHr(jet_error(jstat));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSession::TransactionCancel"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbSession::TransactionEnd(
    void
    )

/*++

Implements:

  IWsbDbSession::TransactionEnd

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::TransactionEnd"), OLESTR(""));
    
    try {
        JET_ERR   jstat;

        jstat = JetCommitTransaction(m_SessionId, 0);
        WsbAffirmHr(jet_error(jstat));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSession::TransactionEnd"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\wsbdbkey.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbkey.cpp

Abstract:

    The CWsbDbKey class.

Author:

    Ron White   [ronw]   1-Jul-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsbdbkey.h"

// Local stuff



HRESULT
CWsbDbKey::AppendBool(
    BOOL value
    )

/*++

Implements:

  IWsbDbKey::AppendBool

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendBool"), OLESTR("value = <%ls>"), WsbBoolAsString(value));
    
    try {
        WsbAssert(make_key(m_size + WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(&m_value[m_size], value, &size));
        m_size += size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendBool"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbKey::AppendBytes(
    UCHAR* value, 
    ULONG size
    )

/*++

Implements:

  IWsbDbKey::AppendBytes

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendBytes"), OLESTR("size = <%ld>"), size);
    
    try {
        WsbAssert(size > 0, E_UNEXPECTED);
        WsbAssert(make_key(size + m_size), WSB_E_RESOURCE_UNAVAILABLE);
        memcpy(&m_value[m_size], value, size);
        m_size += size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendBytes"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::AppendFiletime(
    FILETIME value
    )

/*++

Implements:

  IWsbDbKey::AppendFiletime

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendFiletime"), OLESTR(""));
    
    try {
        WsbAssert(make_key(m_size + WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(&m_value[m_size], value, &size));
        m_size += size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendFiletime"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::AppendGuid(
    GUID value
    )

/*++

Implements:

  IWsbDbKey::AppendGuid

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendGuid"), OLESTR("value = <%ls>"), WsbGuidAsString(value));
    
    try {
        WsbAssert(make_key(m_size + WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(&m_value[m_size], value, &size));
        m_size += size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendGuid"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::AppendLonglong(
    LONGLONG value
    )

/*++

Implements:

  IWsbDbKey::AppendLonglong

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendLonglong"), OLESTR("value = <%ls>"), 
            WsbLonglongAsString(value));
    
    try {
        WsbAssert(make_key(m_size + WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(&m_value[m_size], value, &size));
        m_size += size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendLonglong"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::AppendString(
    OLECHAR* value
    )

/*++

Implements:

  IWsbDbKey::AppendString

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendString"), OLESTR(""));
    
    try {
        ULONG size;

        size = wcslen(value) * sizeof(OLECHAR);
        WsbAffirmHr(AppendBytes((UCHAR *)value, size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendString"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT             hr = S_FALSE;

    WsbTraceIn(OLESTR("CWsbDbKey::CompareTo"), OLESTR(""));
    
    try {
        UCHAR*             bytes2;
        CComPtr<IWsbDbKey> pKey2;
        CComPtr<IWsbDbKeyPriv> pKeyPriv2;
        SHORT              result;
        ULONG              size2;

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbDbKey interface to get the value.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbDbKey, (void**) &pKey2));
        WsbAffirmHr(pKey2->QueryInterface(IID_IWsbDbKeyPriv, 
                (void**)&pKeyPriv2));

        // Get the other key's bytes
        bytes2 = NULL;
        WsbAffirmHr(pKeyPriv2->GetBytes(&bytes2, &size2));

        // Do compare
        if (size2 == 0 && m_size == 0) {
            result = 0;
        } else if (size2 == 0) {
            result = 1;
        } else if (m_size == 0) {
            result = -1;
        } else {
            result = WsbSign( memcmp(m_value, bytes2, min(m_size, size2)) );
            if (result == 0 && m_size != size2) {
                result = (m_size > size2) ? (SHORT)1 : (SHORT)-1;
            }
        }
        WsbFree(bytes2);

        // If the aren't equal, then return false.
        if (result != 0) {
            hr = S_FALSE;
        }
        else {
            hr = S_OK;
        }
        *pResult = result;
            
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::CompareTo"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbKey::GetBytes(
    OUT UCHAR** ppBytes,
    OUT ULONG* pSize
    )

/*++

Implements:

  IWsbDbKey::GetBytes
    
--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::GetBytes"), OLESTR(""));

    try {
        if (ppBytes && m_size) {
            if (*ppBytes == NULL) {
                *ppBytes = (UCHAR *)WsbAlloc(m_size);
            }
            if (*ppBytes) {
                memcpy(*ppBytes, m_value, m_size);
            } else {
                WsbThrow(E_OUTOFMEMORY);
            }
        }
        if (pSize) {
            *pSize = m_size;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::GetBytes"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));
    
    return(hr);
}


HRESULT
CWsbDbKey::GetType(
    OUT ULONG* pType
    )

/*++

Implements:

  IWsbDbKey::GetType
    
--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::GetType"), OLESTR(""));

    try {
        WsbAffirm(pType != NULL, E_POINTER);
        *pType = m_type;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::GetType"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}



HRESULT
CWsbDbKey::SetToBool(
    BOOL value
    )

/*++

Implements:

  IWsbDbKey::SetToBool

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToBool"), OLESTR("value = <%ls>"), 
            WsbBoolAsString(value));
    
    try {
        WsbAssert(make_key(WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(m_value, value, &m_size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToBool"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToBytes(
    UCHAR* value, 
    ULONG size
    )

/*++

Implements:

  IWsbDbKey::SetToBytes

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToBytes"), OLESTR("size = <%ld>"), size);
    
    try {
        WsbAssert(size > 0, E_UNEXPECTED);
        WsbAssert(make_key(size), WSB_E_RESOURCE_UNAVAILABLE);
        memcpy(m_value, value, size);
        m_size = size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToBytes"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToFiletime(
    FILETIME value
    )

/*++

Implements:

  IWsbDbKey::SetToFiletime

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToFiletime"), OLESTR(""));
    
    try {
        WsbAssert(make_key(WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(m_value, value, &m_size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToFiletime"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToGuid(
    GUID value
    )

/*++

Implements:

  IWsbDbKey::SetToGuid

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToGuid"), OLESTR("value = <%ls>"), 
            WsbGuidAsString(value));
    
    try {
        WsbAssert(make_key(WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(m_value, value, &m_size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToGuid"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToLonglong(
    LONGLONG value
    )

/*++

Implements:

  IWsbDbKey::SetToLonglong

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToLonglong"), OLESTR("value = <%ls>"), 
            WsbLonglongAsString(value));
    
    try {
        WsbAssert(make_key(WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(m_value, value, &m_size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToLonglong"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToUlong(
    ULONG value
    )

/*++

Implements:

  IWsbDbKey::SetToUlong

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToUlong"), OLESTR("value = <%ld>"), value);
    
    try {
        WsbAssert(make_key(WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(m_value, value, &m_size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToUlong"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToString(
    OLECHAR* value
    )

/*++

Implements:

  IWsbDbKey::SetToString

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToString"), OLESTR(""));
    
    try {
        ULONG size;

        size = wcslen(value) * sizeof(OLECHAR);
        WsbAffirmHr(SetToBytes((UCHAR *)value, size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToString"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::FinalConstruct"), OLESTR("") );

    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_value = NULL;
        m_size = 0;
        m_max = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::FinalConstruct"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



void
CWsbDbKey::FinalRelease(
    void
    )

/*++

Routine Description:

  This method does some cleanup of the object that is necessary
  during destruction.

Arguments:

  None.

Return Value:

  None.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::FinalRelease"), OLESTR(""));

    try {
        if (m_value) {
            WsbFree(m_value);
            m_value = NULL;
        }
        CWsbObject::FinalRelease();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::FinalRelease"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
}


HRESULT
CWsbDbKey::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::GetClassID"), OLESTR(""));

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbDbKey;
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CWsbDbKey::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbDbKey::GetSizeMax(
    OUT ULARGE_INTEGER* /*pSize*/
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT             hr = E_NOTIMPL;
    return(hr);
}


HRESULT
CWsbDbKey::Load(
    IN IStream* /*pStream*/
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = E_NOTIMPL;
    return(hr);
}


HRESULT
CWsbDbKey::Save(
    IN IStream* /*pStream*/,
    IN BOOL /*clearDirty*/
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = E_NOTIMPL;
    return(hr);
}


// CWsbDbKey internal helper functions

// make_key - create a key of the specified size
BOOL
CWsbDbKey::make_key(
    ULONG size
    )
{
    BOOL status = FALSE;
    LPVOID pTemp;

    if ( (size > IDB_MAX_KEY_SIZE) || (size == 0) ) {
        status = FALSE;
    } else if (m_value && m_max >= size) {
        status = TRUE;
    } else {
        pTemp = WsbRealloc(m_value, size);
        if ( pTemp ) {
            m_value = (PUCHAR) pTemp;
            status = TRUE;
            m_max = size;
        } 
    }
    return(status);
}



HRESULT
CWsbDbKey::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbDbKey>      pDbKey1;

    WsbTraceIn(OLESTR("CWsbDbKey::Test"), OLESTR(""));

    try {

        try {
            WsbAssertHr(((IUnknown*) (IWsbDbKey*) this)->QueryInterface(IID_IWsbDbKey, (void**) &pDbKey1));

            // Set o a ULONG value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAssertHr(pDbKey1->SetToUlong(0xffffffff));
//              ULONG value;
//              WsbAssertHr(pDbKey1->GetUlong(&value));
//              WsbAssert(value == 0xffffffff, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }

        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }
    
    } WsbCatch(hr);


    // Tally up the results
    if (*failed) {
        hr = S_FALSE;
    } else {
        hr = S_OK;
    }

    WsbTraceOut(OLESTR("CWsbDbKey::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif  // WSB_NO_TEST

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\wsbdbsys.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbsys.cpp

Abstract:

    CWsbDbSys class.

Author:

    Ron White   [ronw]   1-Jul-1997

Revision History:

--*/

#include "stdafx.h"

#include "rsevents.h"
#include "wsbdbsys.h"
#include "wsbdbses.h"


#include <mbstring.h>
#include <limits.h>

#define MAX_ATTACHED_DB            6    // Set by ESE/JET engine (suppose to be 7)

#if !defined(BACKUP_TEST_TIMES)
//  Normal values
#define DEFAULT_AUTOBACKUP_INTERVAL        (3 * 60 * 60 * 1000)  // 3 hours
#define DEFAULT_AUTOBACKUP_IDLE_MINUTES       5
#define DEFAULT_AUTOBACKUP_COUNT_MIN          100
#define DEFAULT_AUTOBACKUP_LOG_COUNT          10

#else
//  Test values
#define DEFAULT_AUTOBACKUP_INTERVAL        (4 * 60 * 1000)  // 4 minutes
#define DEFAULT_AUTOBACKUP_IDLE_MINUTES       1
#define DEFAULT_AUTOBACKUP_COUNT_MIN          5
#define DEFAULT_AUTOBACKUP_LOG_COUNT          4
#endif

#define DEFAULT_AUTOBACKUP_COUNT_MAX          500

// Local stuff

//  ATTACHED_DB_DATA holds information about currently attached DBs
typedef struct {
    CWsbStringPtr  Name;       // Database name
    LONG           LastOpen;   // Sequence number of last open
} ATTACHED_DB_DATA;

// This static data manages a list of attached databases for this process.
// (Future: If we want this list to be managed on a per instance basis, all of 
//  this data should become class members and handled appropriately)
static ATTACHED_DB_DATA   Attached[MAX_ATTACHED_DB];
static LONG               AttachedCount = 0;
static CRITICAL_SECTION   AttachedCritSect;
static BOOL               CritSectCreated = FALSE;
static BOOL               AttachedInit = FALSE;
static SHORT              AttachedCritSectUsers = 0;

static CComCreator< CComObject<CWsbDbSession>  >  SessionFactory;

// Local functions
static HRESULT AddExtension(OLECHAR** pPath, OLECHAR* Ext);
static HRESULT ClearDirectory(const OLECHAR* DirPath);
static HRESULT CopyDirectory(const OLECHAR* DirSource, const OLECHAR* DirTarget);
static HRESULT DirectoryHasFullBackup(const OLECHAR* DirPath);
static HRESULT FileCount(const OLECHAR* DirPath, const OLECHAR* Pattern,
                    ULONG* Count);
static HRESULT RenameDirectory(const OLECHAR* OldDir, const OLECHAR* NewDir);



//  Non-member function initially called for autobackup thread
static DWORD WsbDbSysStartAutoBackup(
    void* pVoid
    )
{
    return(((CWsbDbSys*) pVoid)->AutoBackup());
}


HRESULT
CWsbDbSys::AutoBackup(
    void
    )

/*++

Routine Description:

  Implements an auto-backup loop.

Arguments:

  None.
  
Return Value:

  Doesn't matter.


--*/
{
    HRESULT    hr = S_OK;

    try {
        ULONG   SleepPeriod = DEFAULT_AUTOBACKUP_INTERVAL;
        BOOL    exitLoop = FALSE;

        while (! exitLoop) {

            // Wait for termination event, if timeout occurs, check the sleep period criteria
            switch (WaitForSingleObject(m_terminateEvent, SleepPeriod)) {
                case WAIT_OBJECT_0:
                    // Need to terminate
                    WsbTrace(OLESTR("CWsbDbSys::AutoBackup: signaled to terminate\n"));
                    exitLoop = TRUE;
                    break;

                case WAIT_TIMEOUT: 
                    // Check if backup need to be performed
                    WsbTrace(OLESTR("CWsbDbSys::AutoBackup awakened, ChangeCount = %ld\n"), m_ChangeCount);

                    //  Don't do a backup if there hasn't been much activity
                    if (DEFAULT_AUTOBACKUP_COUNT_MIN < m_ChangeCount) {
                        LONG     DiffMinutes;
                        FILETIME ftNow;
                        LONGLONG NowMinutes;
                        LONGLONG ThenMinutes;

                        //  Wait for an idle time
                        GetSystemTimeAsFileTime(&ftNow);
                        NowMinutes = WsbFTtoLL(ftNow) / WSB_FT_TICKS_PER_MINUTE;
                        ThenMinutes = WsbFTtoLL(m_LastChange) / WSB_FT_TICKS_PER_MINUTE;
                        DiffMinutes = static_cast<LONG>(NowMinutes - ThenMinutes);

                        WsbTrace(OLESTR("CWsbDbSys::AutoBackup idle minutes = %ld\n"),
                        DiffMinutes);
                        if (DEFAULT_AUTOBACKUP_IDLE_MINUTES < DiffMinutes ||
                                DEFAULT_AUTOBACKUP_COUNT_MAX < m_ChangeCount) {
                            hr = Backup(NULL, 0);
                            if (S_OK != hr) {
                                // Just trace and go back to wait for the next round...
                                WsbTrace(OLESTR("CWsbDbSys::AutoBackup: Backup failed, hr=<%ls>\n"), WsbHrAsString(hr));
                            }
                            SleepPeriod = DEFAULT_AUTOBACKUP_INTERVAL;;
                        } else {
                            //  Reduce the sleep time so we catch the next idle time
                            ULONG SleepMinutes = SleepPeriod / (1000 * 60);

                            if (SleepMinutes > (DEFAULT_AUTOBACKUP_IDLE_MINUTES * 2)) {
                                SleepPeriod /= 2;
                            }
                        }
                    }

                    break;  // end of timeout case

                case WAIT_FAILED:
                default:
                    WsbTrace(OLESTR("CWsbDbSys::AutoBackup: WaitForSingleObject returned error %lu\n"), GetLastError());
                    exitLoop = TRUE;
                    break;

            } // end of switch

        } // end of while

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CWsbDbSys::Backup(
    IN OLECHAR* path,
    IN ULONG    flags
    )

/*++

Implements:

  IWsbDbSys::Backup

--*/
{
    HRESULT    hr = S_OK;
    char*      backup_path = NULL;

    WsbTraceIn(OLESTR("CWsbDbSys::Backup"), OLESTR("path = <%ls>, flags = %lx"), 
            path, flags);
    
    try {

        CWsbStringPtr   BackupDir;
        JET_ERR         jstat = JET_errSuccess;

        WsbAffirm(m_jet_initialized, WSB_E_NOT_INITIALIZED);

        //  Set and save the backup path; make sure it exists
        if (NULL != path) {
            m_BackupPath = path;
        }
        CreateDirectory(m_BackupPath, NULL);

        //  Start the automatic backup thread if requested
        if (flags & IDB_BACKUP_FLAG_AUTO) {

            //  Don't start AutoBackup thread if it's already running
            if (0 == m_AutoThread) {
                DWORD  threadId;

                // Create termination event for auto-backup thread
                WsbAffirmHandle(m_terminateEvent = CreateEvent(NULL, TRUE, FALSE, NULL));

                WsbAffirm((m_AutoThread = CreateThread(0, 0, WsbDbSysStartAutoBackup, 
                        (void*) this, 0, &threadId)) != 0, HRESULT_FROM_WIN32(GetLastError()));
            }

        //  Do a full backup to a temporary directory
        } else if (flags & IDB_BACKUP_FLAG_FORCE_FULL) {
            BOOL            UsedTempDir = FALSE;

            //  Don't wipe out an existing backup -- if the normal backup
            //  directory contains a full backup, do the full backup to
            //  the .ful directory
            BackupDir = m_BackupPath;
            WsbAffirm(0 != (WCHAR *)BackupDir, E_OUTOFMEMORY);
            if (S_OK == DirectoryHasFullBackup(BackupDir)) {
                WsbAffirmHr(AddExtension(&BackupDir, L".ful"));
                UsedTempDir = TRUE;
            }

            //  Make sure the directory exists (should check for errors?)
            CreateDirectory(BackupDir, NULL);

            //  Make sure the directory is empty (the call to JetBackup will
            //  fail if it's not)
            WsbAffirmHr(ClearDirectory(BackupDir));

            //  Convert to narrow char string for parameter
            WsbAffirmHr(wsb_db_jet_fix_path(BackupDir, NULL, &backup_path));
            WsbTrace(OLESTR("CWsbDbSys::Backup: backup_path = <%hs>\n"), backup_path);

            //  Do backup
            WsbAffirm(NULL != m_BackupEvent, WSB_E_IDB_WRONG_BACKUP_SETTINGS);
            DWORD status = WaitForSingleObject(m_BackupEvent, EVENT_WAIT_TIMEOUT);
            DWORD errWait;
            switch(status) {
                case WAIT_OBJECT_0:
                    // Expected case - do Backup
                    jstat = JetBackupInstance(m_jet_instance, backup_path, 0, NULL);
                    if (! SetEvent(m_BackupEvent)) {
                        // Don't abort, just trace error
                        WsbTraceAlways(OLESTR("CWsbDbSys::Backup: SetEvent returned unexpected error %lu\n"), GetLastError());
                    }
                    WsbAffirmHr(jet_error(jstat));
                    break;

                case WAIT_TIMEOUT: 
                    // Timeout - don't do backup
                    WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object timed out after %lu ms\n"), EVENT_WAIT_TIMEOUT);
                    WsbThrow(E_ABORT);
                    break;                      

                case WAIT_FAILED:
                    errWait = GetLastError();
                    WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object returned error %lu\n"), errWait);
                    WsbThrow(HRESULT_FROM_WIN32(errWait));
                    break;

                default:
                    WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object returned unexpected status %lu\n"), status);
                    WsbThrow(E_UNEXPECTED);
                    break;
            }

            //  Full backup worked -- copy to real backup directory
            if (UsedTempDir) {
                try {
                    WsbAffirmHr(ClearDirectory(m_BackupPath));
                    WsbAffirmHr(CopyDirectory(BackupDir, m_BackupPath));
                    WsbAffirmHr(ClearDirectory(BackupDir));

                    //  Try to delete temporary directory (may fail)
                    DeleteFile(BackupDir);
                    BackupDir = m_BackupPath;
                } WsbCatch(hr);
            }
            WsbLogEvent(WSB_MESSAGE_IDB_BACKUP_FULL, 0, NULL,
                WsbAbbreviatePath(BackupDir, 120), NULL);
            m_ChangeCount = 0;
            WsbAffirmHr(hr);

        //  Try an incremental backup
        } else {
            ULONG   LogCount;
            BOOL    TryFullBackup = FALSE;

            WsbAffirmHr(FileCount(m_BackupPath, L"*.log", &LogCount));

            if (LogCount > DEFAULT_AUTOBACKUP_LOG_COUNT ||
                    S_FALSE == DirectoryHasFullBackup(m_BackupPath)) {
                //  Do a full backup instead of the incremental if there
                //  are already too many log files, or there's no full
                //  backup in the backup directory (which means the incremental
                //  wouldn't work anyway)
                TryFullBackup = TRUE;
            } else {
                WsbTrace(OLESTR("CWsbDbSys::Backup, trying incremental backup\n"));

                //  Convert to narrow char string for parameter
                WsbAffirmHr(wsb_db_jet_fix_path(m_BackupPath, NULL, &backup_path));
                WsbTrace(OLESTR("CWsbDbSys::Backup: backup_path = <%hs>\n"), backup_path);

                WsbAffirm(NULL != m_BackupEvent, WSB_E_IDB_WRONG_BACKUP_SETTINGS);
                DWORD status = WaitForSingleObject(m_BackupEvent, EVENT_WAIT_TIMEOUT);
                DWORD errWait;
                switch(status) {
                    case WAIT_OBJECT_0:
                        // Expected case - do Backup
                        jstat = JetBackupInstance(m_jet_instance, backup_path, JET_bitBackupIncremental, NULL);
                        if (! SetEvent(m_BackupEvent)) {
                            // Don't abort, just trace error
                            WsbTraceAlways(OLESTR("CWsbDbSys::Backup: SetEvent returned unexpected error %lu\n"), GetLastError());
                        }
                        break;

                    case WAIT_TIMEOUT: 
                        // Timeout - don't do backup
                        WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object timed out after %lu ms\n"), EVENT_WAIT_TIMEOUT);
                        WsbThrow(E_ABORT);
                        break;                      

                    case WAIT_FAILED:
                        errWait = GetLastError();
                        WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object returned error %lu\n"), errWait);
                        WsbThrow(HRESULT_FROM_WIN32(errWait));
                        break;

                    default:
                        WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object returned unexpected status %lu\n"), status);
                        WsbThrow(E_UNEXPECTED);
                        break;
                }

                //  Check for an error.
                if (JET_errSuccess != jstat) {
                    if (JET_errMissingFullBackup == jstat) {
                        // Full backup need to be performed
                        WsbLogEvent(WSB_MESSAGE_IDB_MISSING_FULL_BACKUP, 0, NULL, 
                                WsbAbbreviatePath(m_BackupPath, 120), NULL);
                    } else {
                        // Unknown error of incremental backup. Try a full backup anyway
                        WsbLogEvent(WSB_MESSAGE_IDB_INCREMENTAL_BACKUP_FAILED, 0, NULL, 
                                WsbAbbreviatePath(m_BackupPath, 120),
                                WsbLongAsString(jstat), NULL );
                    }
                    TryFullBackup = TRUE;
                } else {
                    //  The incremental backup worked
                    WsbLogEvent(WSB_MESSAGE_IDB_BACKUP_INCREMENTAL, 0, NULL,
                        WsbAbbreviatePath(m_BackupPath, 120), NULL);
                    m_ChangeCount = 0;
                }
            }

            //  Try full backup?
            if (TryFullBackup) {
                WsbAffirmHr(Backup(NULL, IDB_BACKUP_FLAG_FORCE_FULL));
            }
        }

    } WsbCatchAndDo(hr, 
            WsbLogEvent(WSB_MESSAGE_IDB_BACKUP_FAILED, 0, NULL,
            WsbAbbreviatePath(m_BackupPath, 120), NULL);
        );

    if (NULL != backup_path) {
        WsbFree(backup_path);
    }

    WsbTraceOut(OLESTR("CWsbDbSys::Backup"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbSys::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::FinalConstruct"), OLESTR("") );

    try {
        m_AutoThread = 0;
        m_terminateEvent = NULL;
        m_ChangeCount = 0;

        m_jet_initialized = FALSE;
        m_jet_instance = JET_instanceNil;

        m_BackupEvent = NULL;

        try {
            // Initialize critical sections (global resource, so init only for first user)
            if (AttachedCritSectUsers == 0) {
                WsbAffirmStatus(InitializeCriticalSectionAndSpinCount (&AttachedCritSect, 1000));
                CritSectCreated = TRUE;
            }
            AttachedCritSectUsers++;
        } catch(DWORD status) {
                AttachedCritSectUsers--;
                WsbLogEvent(status, 0, NULL, NULL);
                switch (status) {
                case STATUS_NO_MEMORY:
                    WsbThrow(E_OUTOFMEMORY);
                    break;
                default:
                    WsbThrow(E_UNEXPECTED);
                    break;
                }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSys::FinalConstruct"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



void
CWsbDbSys::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::FinalRelease"), OLESTR(""));

    try {
        // Make sure that Terminate was called
        if (m_jet_initialized == TRUE) {
            WsbAffirmHr(Terminate());
        }
    } WsbCatch(hr);

    // Global resource, so delete only for last user
    AttachedCritSectUsers--;
    if ((AttachedCritSectUsers == 0) && CritSectCreated) {
        DeleteCriticalSection(&AttachedCritSect);
    }

    WsbTraceOut(OLESTR("CWsbDbSys::FinalRelease"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
}


HRESULT
CWsbDbSys::Init(
    IN OLECHAR* path,
    IN ULONG    flags
    )

/*++

Implements:

  IWsbDbSys::Init

--*/
{
    HRESULT             hr = S_OK;
    char*               log_path = NULL;
    static BOOL         bFirstTime = TRUE;
    static int          nInstance = 0;

    WsbTraceIn(OLESTR("CWsbDbSys::Init"), OLESTR("path = <%ls>"), path);
    
    try {

        CWsbStringPtr   dir;
        JET_ERR         jstat = JET_errSuccess;

        // Initialize the Jet engine just once per Jet instance
        WsbAffirm(!m_jet_initialized, E_FAIL);

        // Initialize backup event, unless Jet backup is not required for this isntance
        if (! (flags & IDB_SYS_INIT_FLAG_NO_BACKUP)) {
            // Event should already exist - it is created in the CRssJetWriter constructor
            WsbAffirmHandle(m_BackupEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, HSM_IDB_STATE_EVENT));
        }

        // WsbDbSys represents one Jet instance.
        // However, some Jet initialization should be done only once per process,
        //  before the first instance is being created.
        if (bFirstTime) {
            bFirstTime = FALSE;

            // Increase the default number of maximum Jet sesions for the process
            //  TEMPORARY: Can this be set separately per instance?
            jstat = JetSetSystemParameter(0, 0, JET_paramCacheSizeMin , (IDB_MAX_NOF_SESSIONS*4), NULL);
            WsbTrace(OLESTR("CWsbDbSys::Init, JetSetSystemParameter(CacheSizeMax) = %ld\n"), jstat);
            WsbAffirmHr(jet_error(jstat));
            jstat = JetSetSystemParameter(0, 0, JET_paramMaxSessions, IDB_MAX_NOF_SESSIONS, NULL);
            WsbTrace(OLESTR("CWsbDbSys::Init, JetSetSystemParameter(MaxSessions) = %ld\n"), jstat);
            WsbAffirmHr(jet_error(jstat));

            // Tell Jet we are going to use multiple instances
            jstat = JetEnableMultiInstance(NULL, 0, NULL);
            WsbAffirmHr(jet_error(jstat));
        }

        // Here start the per-instance initialization. 
        // First step is creating the instance
        //  Use a numeric counter as instance name - we care only that the name is unique
        WsbAssert(JET_instanceNil == m_jet_instance, E_FAIL);
        nInstance++;
        char szInstance[10];
        sprintf(szInstance, "%d", nInstance);
        WsbTrace(OLESTR("CWsbDbSys::Init, Jet instance name = <%hs>\n"), szInstance);
        jstat = JetCreateInstance(&m_jet_instance, szInstance);
        WsbAffirmHr(jet_error(jstat));


        // Set some per-instance parameters:
            
        //  Create path for log directory (same path is also used for system files and temp files)
        WsbAffirm(NULL != path, E_INVALIDARG);
        m_InitPath = path;
        m_BackupPath = m_InitPath;
        WsbAffirmHr(AddExtension(&m_BackupPath, L".bak"));
        WsbTrace(OLESTR("CWsbDbSys::Init, BackupPath = <%ls>\n"),  (WCHAR *)m_BackupPath);
        WsbAffirmHr(wsb_db_jet_fix_path(path, OLESTR(""), &log_path));
        dir = log_path;  // Convert to WCHAR

        //  Make sure the directory exists.
        WsbTrace(OLESTR("CWsbDbSys::Init, Creating dir = <%ls>\n"), (WCHAR *)dir);
        if (! CreateDirectory(dir, NULL)) {
            DWORD status = GetLastError();
            if ((status == ERROR_ALREADY_EXISTS) || (status == ERROR_FILE_EXISTS)) {
                status = NO_ERROR;
            }
            WsbAffirmNoError(status);
        }

        ULONG  checkpointDepth;
        ULONG  logFileSize = 128;        // In kilobytes

        if (! (flags & IDB_SYS_INIT_FLAG_NO_LOGGING)) {

            WsbTrace(OLESTR("CWsbDbSys::Init, LogFilePath = <%hs>\n"), log_path);
            jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramLogFilePath, 0, log_path);
            WsbTrace(OLESTR("CWsbDbSys::Init, JetSetSystemParameter(LogFilePath) = %ld\n"), jstat);
            WsbAffirmHr(jet_error(jstat));

            // Use circular logging for "limited" logging
            if (flags & IDB_SYS_INIT_FLAG_LIMITED_LOGGING) {
                logFileSize = 512;   // Increase the log file size
                jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramCircularLog, 1, NULL);
                WsbAffirmHr(jet_error(jstat));
                WsbTrace(OLESTR("CWsbDbSys::Init: set circular logging\n"));

                //  Set the amount of logging allowed before a check point
                //  to allow about 4 log files
                //  (the check point depth is set in bytes.)
                checkpointDepth = 4 * logFileSize * 1024;
                jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramCheckpointDepthMax, 
                                checkpointDepth, NULL);
                WsbAffirmHr(jet_error(jstat));
                WsbTrace(OLESTR("CWsbDbSys::Init: set CheckpointDepthMax = %ld\n"), checkpointDepth);
            }

        } else {
            jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramRecovery, 
                            0, "off");
            WsbAffirmHr(jet_error(jstat));
            WsbTrace(OLESTR("CWsbDbSys::Init: set JET_paramRecovery to 0 (no logging)\n"));
        }

        //  Set parameters for where to put auxiliary data
        WsbTrace(OLESTR("CWsbDbSys::Init, SystemPath = <%hs>\n"), log_path);
        jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramSystemPath, 0, log_path);
        WsbAffirmHr(jet_error(jstat));

        // The next one, for some unknown reason, needs a file name at the end of the path
        WsbAffirmHr(dir.Append("\\temp.edb"));
        WsbAffirmHr(dir.CopyTo(&log_path));
        WsbTrace(OLESTR("CWsbDbSys::Init, TempPath = <%hs>\n"), log_path);
        jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramTempPath, 0, log_path);
        WsbAffirmHr(jet_error(jstat));

        if (! (flags & IDB_SYS_INIT_FLAG_NO_LOGGING)) {

            //  Set the log file size (in KB). The minimum seems to be 128KB.
            jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramLogFileSize, 
                            logFileSize, NULL);
            WsbAffirmHr(jet_error(jstat));
            WsbTrace(OLESTR("CWsbDbSys::Init: set logFileSize to %ld Kb\n"), logFileSize);
        }

        // Set parameter for deleting out-of-range log files. 
        // These files may exist after a restore from a db backup without clearing the db directory first
        if (! (flags & IDB_SYS_INIT_FLAG_NO_BACKUP)) {
            jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramDeleteOutOfRangeLogs, 1, NULL);
            WsbAffirmHr(jet_error(jstat));
            WsbTrace(OLESTR("CWsbDbSys::Init: set delete out-of-range logs\n"));
        }

        // Initialize the DB instance
        jstat = JetInit(&m_jet_instance);
        hr = jet_error(jstat);

        // If this failed, report the error
        if (!SUCCEEDED(hr)) {
            if (flags & IDB_SYS_INIT_FLAG_SPECIAL_ERROR_MSG) {
                // Special message for FSA
                WsbLogEvent(WSB_E_IDB_DELETABLE_DATABASE_CORRUPT, 0, NULL, NULL);
                WsbThrow(WSB_E_RESOURCE_UNAVAILABLE);
            } else {
                WsbThrow(hr);
            }
        }
        WsbTrace(OLESTR("CWsbDbSys::Init: jet instance = %p\n"), (LONG_PTR)m_jet_instance);
        m_jet_initialized = TRUE;

        //  Create a session for internal use of this instance
        WsbAffirmHr(NewSession(&m_pWsbDbSession));
        WsbTrace(OLESTR("CWsbDbSys::Init, m_pWsbDbSession = %p\n"), (IWsbDbSession*)m_pWsbDbSession);

    } WsbCatchAndDo(hr, 
            WsbLogEvent(WSB_MESSAGE_IDB_INIT_FAILED, 0, NULL,
            WsbAbbreviatePath(m_InitPath, 120), NULL);
        );

    if (NULL != log_path) {
        WsbFree(log_path);
    }

    WsbTraceOut(OLESTR("CWsbDbSys::Init"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CWsbDbSys::Terminate(
    void
    )

/*++

Implements:

  IWsbDbSys::Terminate

--*/
{
    HRESULT             hr = S_OK;
    WsbTraceIn(OLESTR("CWsbDbSys::Terminate"), OLESTR(""));

    try {
        // If wasn't initialized or alreday cleaned up - just get out
        if (m_jet_initialized == FALSE) {
            WsbTrace(OLESTR("CWsbDbSys::Terminate - this insatnce is not initialized"));
            WsbThrow(S_OK);
        }

        // Terminate the auto-backup thread
        if (m_AutoThread) {
            // Signal thread to terminate
            SetEvent(m_terminateEvent);

            // Wait for the thread, if it doesn't terminate gracefully - kill it
            switch (WaitForSingleObject(m_AutoThread, 20000)) {
                case WAIT_FAILED: {
                    WsbTrace(OLESTR("CWsbDbSys::Terminate: WaitForSingleObject returned error %lu\n"), GetLastError());
                }
                // fall through...

                case WAIT_TIMEOUT: {
                    WsbTrace(OLESTR("CWsbDbSys::Terminate: force terminating of auto-backup thread.\n"));

                    DWORD dwExitCode;
                    if (GetExitCodeThread( m_AutoThread, &dwExitCode)) {
                        if (dwExitCode == STILL_ACTIVE) {   // thread still active
                            if (!TerminateThread (m_AutoThread, 0)) {
                                WsbTrace(OLESTR("CWsbDbSys::Terminate: TerminateThread returned error %lu\n"), GetLastError());
                            }
                        }
                    } else {
                        WsbTrace(OLESTR("CWsbDbSys::Terminate: GetExitCodeThread returned error %lu\n"), GetLastError());
                    }

                    break;
                }

                default:
                    // Thread terminated gracefully
                    break;
            }

            // Best effort done for terminating auto-backup thread
            CloseHandle(m_AutoThread);
            m_AutoThread = 0;
        }
        if (m_terminateEvent != NULL) {
            CloseHandle(m_terminateEvent);
            m_terminateEvent = NULL;
        }

        //  Detach DBs before exiting so they don't automatically get
        //  reattached the next time we start up
        if (m_pWsbDbSession) {
            JET_SESID sid;

            CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = m_pWsbDbSession;
            WsbAffirmPointer(pSessionPriv);
            WsbAffirmHr(pSessionPriv->GetJetId(&sid));

            // Clean up the Attached data
            if (AttachedInit) {
                EnterCriticalSection(&AttachedCritSect);
                for (int i = 0; i < MAX_ATTACHED_DB; i++) {
                    Attached[i].Name.Free();
                    Attached[i].LastOpen = 0;
                }
                JetDetachDatabase(sid, NULL);
                AttachedInit = FALSE;
                LeaveCriticalSection(&AttachedCritSect);
            }

            // Release the global session for this instance
            m_pWsbDbSession = 0;
        }

        // Terminate Jet
        JetTerm(m_jet_instance);
        m_jet_initialized = FALSE;
        m_jet_instance = JET_instanceNil;

    } WsbCatch(hr);

    if (m_BackupEvent) {
        CloseHandle(m_BackupEvent);
        m_BackupEvent = NULL;
    }

    WsbTraceOut(OLESTR("CWsbDbSys::Terminate"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return (hr);
}


HRESULT
CWsbDbSys::NewSession(
    OUT IWsbDbSession** ppSession
    )

/*++

Implements:

  IWsbDbSys::NewSession

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::NewSession"), OLESTR(""));
    
    try {
        WsbAffirm(0 != ppSession, E_POINTER);
        WsbAffirmHr(SessionFactory.CreateInstance(NULL, IID_IWsbDbSession, 
                (void**)ppSession));

        CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = *ppSession;
        WsbAffirmPointer(pSessionPriv);
        WsbAffirmHr(pSessionPriv->Init(&m_jet_instance));

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CWsbDbSys::NewSession"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CWsbDbSys::GetGlobalSession(
    OUT IWsbDbSession** ppSession
    )
/*++

Implements:

  IWsbDbSys::GetGlobalSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CWsbDbSys::GetGlobalSession"), OLESTR(""));

    //
    // If the Task Manager has been created, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppSession, E_POINTER);
        *ppSession = m_pWsbDbSession;
        WsbAffirm(m_pWsbDbSession != 0, E_FAIL);
        m_pWsbDbSession.p->AddRef();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSys::GetGlobalSession"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return (hr);
}


HRESULT
CWsbDbSys::Restore(
    IN OLECHAR* fromPath,
    IN OLECHAR* toPath
    )

/*++

Implements:

  IWsbDbSys::Restore

--*/
{
    HRESULT    hr = S_OK;
    char*      backup_path = NULL;
    char*      restore_path = NULL;

    WsbTraceIn(OLESTR("CWsbDbSys::Restore"), OLESTR("fromPath = <%ls>, toPath = <%ls>"), 
            fromPath, toPath);
    
    try {

        CWsbStringPtr   dir;
        JET_ERR         jstat;

        //  This is only allowed before Init
        WsbAffirm(!m_jet_initialized, E_UNEXPECTED);
        WsbAffirm(NULL != fromPath, E_POINTER);
        WsbAffirm(NULL != toPath, E_POINTER);

        //  Convert pathes
        WsbAffirmHr(wsb_db_jet_fix_path(fromPath, OLESTR(""), &backup_path));
        WsbAffirmHr(wsb_db_jet_fix_path(toPath, OLESTR(""), &restore_path));

        //  Make sure the target directory exists.  Should check for error.
        dir = restore_path;
        CreateDirectory(dir, NULL);

        jstat = JetRestoreInstance(m_jet_instance, backup_path, restore_path, NULL);
        WsbAffirmHr(jet_error(jstat));

    } WsbCatch(hr);

    if (NULL != backup_path) {
        WsbFree(backup_path);
    }
    if (NULL != restore_path) {
        WsbFree(restore_path);
    }

    WsbTraceOut(OLESTR("CWsbDbSys::Restore"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CWsbDbSys::IncrementChangeCount(
    void
    )

/*++

Implements:

  IWsbDbSysPriv::IncrementChangeCount

Routine Description:

  Increments the write count used by AutoBackup.

Arguments:

  None.
  
Return Value:

  S_OK

--*/
{

    HRESULT   hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::IncrementChangeCount"), 
            OLESTR("count = %ld"), m_ChangeCount);

    try {
        m_ChangeCount++;
        GetSystemTimeAsFileTime(&m_LastChange);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSys::IncrementChangeCount"), 
            OLESTR("count = %ld"), m_ChangeCount);

    return(hr);
}


HRESULT
CWsbDbSys::DbAttachedAdd(
    OLECHAR* name, 
    BOOL attach)
/*++

Implements:

  IWsbDbSysPriv::DbAttachedAdd

Routine Description:

  Make sure DB is attached and update the last-used count.

--*/
{
    HRESULT hr = S_OK;
    char*   jet_name = NULL;

    WsbTraceIn(OLESTR("CWsbDbSys::DbAttachedAdd"), OLESTR("name = %ls, attach = %ls"), 
            name, WsbBoolAsString(attach));

    try {
        int           i;
        int           i_empty = -1;
        int           i_found = -1;
        LONG          min_count = AttachedCount + 1;
        CWsbStringPtr match_name;

        WsbAssert(name, E_POINTER);

        //  Make sure the list is initialized
        if (!AttachedInit) {
            WsbAffirmHr(DbAttachedInit());
        }

        //  Convert the name
        WsbAffirmHr(wsb_db_jet_fix_path(name, L"." IDB_DB_FILE_SUFFIX, &jet_name));
        match_name = jet_name;

        //  See if it's already in the list; look for an empty slot; find the
        //  least-recently used DB
        EnterCriticalSection(&AttachedCritSect);
        for (i = 0; i < MAX_ATTACHED_DB; i++) {

            //  Empty slot?
            if (!Attached[i].Name) {
                if (-1 == i_empty) {
                    //  Save the first one found
                    i_empty = i;
                }
            } else {

                //  Gather some data for later
                if (Attached[i].LastOpen < min_count) {
                    min_count = Attached[i].LastOpen;
                }

                //  Already in list?
                if (match_name.IsEqual(Attached[i].Name)) {
                    i_found = i;
                }
            }
        }

        //  Make sure the count isn't going to overflow
        if (LONG_MAX == AttachedCount + 1) {
            WsbAffirm(0 < min_count, E_FAIL);

            //  Adjust counts down to avoid overflow
            for (i = 0; i < MAX_ATTACHED_DB; i++) {
                if (min_count <= Attached[i].LastOpen) {
                    Attached[i].LastOpen -= min_count;
                }
            }
            AttachedCount -= min_count;
        }
        AttachedCount++;

        //  If it's already in the list, update the info
        if (-1 != i_found) {
            WsbTrace(OLESTR("CWsbDbSys::DbAttachedAdd: i_found = %d\n"), i_found);
            Attached[i_found].LastOpen = AttachedCount;

        //  If there's an empty slot, use it
        } else if (-1 != i_empty) {
            WsbTrace(OLESTR("CWsbDbSys::DbAttachedAdd: i_empty = %d\n"), i_empty);
            if (attach) {
                JET_ERR       jstat;
                JET_SESID sid;

                WsbAffirm(m_pWsbDbSession, WSB_E_NOT_INITIALIZED);
                CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = m_pWsbDbSession;
                WsbAffirmPointer(pSessionPriv);
                WsbAffirmHr(pSessionPriv->GetJetId(&sid));

                jstat = JetAttachDatabase(sid, jet_name, 0);
                if (JET_errFileNotFound == jstat) {
                    WsbThrow(STG_E_FILENOTFOUND);
                } else if (JET_wrnDatabaseAttached == jstat) {
                    WsbTrace(OLESTR("CWsbDbSys::DbAttachedAdd: DB is already attached\n"));
                    // No problem
                } else {
                    WsbAffirmHr(jet_error(jstat));
                }
            }
            Attached[i_empty].Name = match_name;
            Attached[i_empty].LastOpen = AttachedCount;

        //  Try to detach the oldest DB first
        } else {
            WsbAffirmHr(DbAttachedEmptySlot());
            WsbAffirmHr(DbAttachedAdd(name, attach));
        }
    } WsbCatch(hr);

    if (jet_name) {
        WsbFree(jet_name);
    }
    LeaveCriticalSection(&AttachedCritSect);

    WsbTraceOut(OLESTR("CWsbDbSys::DbAttachedAdd"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CWsbDbSys::DbAttachedEmptySlot(
    void)
/*++

Implements:

  IWsbDbSysPriv::DbAttachedEmptySlot

Routine Description:

  Force an empty slot in the attached list even if this means detaching a DB.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::DbAttachedEmptySlot"), OLESTR(""));

    //  Don't worry about it if we're not initialized yet --
    //  all the slots are empty
    if (AttachedInit) {
        EnterCriticalSection(&AttachedCritSect);

        try {
            BOOL  has_empty = FALSE;
            int   i;
            int   i_oldest;
            LONG  oldest_count;

            //  Find an empty slot or the oldest that is not currently open
reloop:
            i_oldest = -1;
            oldest_count = AttachedCount;
            for (i = 0; i < MAX_ATTACHED_DB; i++) {
                if (!Attached[i].Name) {
                    has_empty = TRUE;
                    break;
                } else if (Attached[i].LastOpen < oldest_count) {
                    i_oldest = i;
                    oldest_count = Attached[i].LastOpen;
                }
            }

            //  If there's no empty slot, try detaching the oldest
            WsbTrace(OLESTR("CWsbDbSys::DbAttachedEmptySlot: has_empty = %ls, i = %d, i_oldest = %d\n"), 
                WsbBoolAsString(has_empty), i, i_oldest);
            if (!has_empty) {
                JET_ERR       jstat;
                char*         name;
                JET_SESID     sid;

                WsbAffirm(m_pWsbDbSession, WSB_E_NOT_INITIALIZED);
                CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = m_pWsbDbSession;
                WsbAffirmPointer(pSessionPriv);
                WsbAffirmHr(pSessionPriv->GetJetId(&sid));

                WsbAffirm(-1 != i_oldest, WSB_E_IDB_TOO_MANY_DB);
                WsbAffirmHr(wsb_db_jet_fix_path(Attached[i_oldest].Name, L"." IDB_DB_FILE_SUFFIX, &name));
                jstat = JetDetachDatabase(sid, name);
                WsbFree(name);
                WsbTrace(OLESTR("CWsbDbSys::DbAttachedEmptySlot: JetDetachDatabase = %ld\n"),
                        (LONG)jstat);
                if (JET_errDatabaseInUse == jstat) {
                    WsbTrace(OLESTR("CWsbDbSys::DbAttachedEmptySlot: DB in use; try again\n"));
                    Attached[i_oldest].LastOpen = AttachedCount;
                    goto reloop;
                } else if (JET_errDatabaseNotFound != jstat) {
                    WsbAffirmHr(jet_error(jstat));
                }
                Attached[i_oldest].Name.Free();
                Attached[i_oldest].LastOpen = 0;
            }
        } WsbCatch(hr);
        LeaveCriticalSection(&AttachedCritSect);
    }

    WsbTraceOut(OLESTR("CWsbDbSys::DbAttachedEmptySlot"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT 
CWsbDbSys::DbAttachedInit(
    void)
/*++

Implements:

  IWsbDbSysPriv::DbAttachedInit

Routine Description:

  Initialize the attached-DB-list data.

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::DbAttachedInit"), OLESTR(""));

    EnterCriticalSection(&AttachedCritSect);

    try {
        if (!AttachedInit) {
            ULONG   actual = 0;
            int     i;
            JET_ERR jstat;
            JET_SESID sid;

            WsbAffirm(m_pWsbDbSession, WSB_E_NOT_INITIALIZED);
            CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = m_pWsbDbSession;
            WsbAffirmPointer(pSessionPriv);
            WsbAffirmHr(pSessionPriv->GetJetId(&sid));

            //  Initialize data
            for (i = 0; i < MAX_ATTACHED_DB; i++) {
                Attached[i].Name.Free();
                Attached[i].LastOpen = 0;
            }

            //  Make sure there aren't pre-attached DBs
            jstat = JetDetachDatabase(sid, NULL);
            WsbTrace(OLESTR("CWsbDbSys::DbAttachedInit: JetDetachDatabase(NULL) = %ld\n"), (LONG)jstat);
            WsbAffirmHr(jet_error(jstat));

            AttachedInit = TRUE;
        }
    } WsbCatch(hr);

    LeaveCriticalSection(&AttachedCritSect);

    WsbTraceOut(OLESTR("CWsbDbSys::DbAttachedInit"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT 
CWsbDbSys::DbAttachedRemove(
    OLECHAR* name)
/*++

Implements:

  IWsbDbSysPriv::DbAttachedRemove

Routine Description:

  Detach a DB (if attached).

--*/
{
    HRESULT hr = S_FALSE;
    char*   jet_name = NULL;

    WsbTraceIn(OLESTR("CWsbDbSys::DbAttachedRemove"), OLESTR("name = %ls"), 
            name);

    try {
        int           i;
        CWsbStringPtr match_name;

        WsbAssert(name, E_POINTER);
        WsbAffirm(AttachedInit, S_FALSE);

        //  Convert the name
        WsbAffirmHr(wsb_db_jet_fix_path(name, L"." IDB_DB_FILE_SUFFIX, &jet_name));
        match_name = jet_name;

        //  See if it's in the list
        EnterCriticalSection(&AttachedCritSect);
        for (i = 0; i < MAX_ATTACHED_DB; i++) {
            if (Attached[i].Name) {
                if (match_name.IsEqual(Attached[i].Name)) {
                    JET_ERR       jstat;
                    JET_SESID     sid;

                    WsbTrace(OLESTR("CWsbDbSys::DbAttachedRemove: found DB, index = %d\n"), i);
                    WsbAffirm(m_pWsbDbSession, WSB_E_NOT_INITIALIZED);
                    CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = m_pWsbDbSession;
                    WsbAffirmPointer(pSessionPriv);
                    WsbAffirmHr(pSessionPriv->GetJetId(&sid));

                    jstat = JetDetachDatabase(sid, jet_name);
                    WsbTrace(OLESTR("CWsbDbSys::DbAttachedRemove: JetDetachDatabase = %ld\n"),
                            (LONG)jstat);
                    if (JET_errDatabaseNotFound != jstat) {
                        WsbAffirmHr(jet_error(jstat));
                        hr = S_OK;
                    }
                    Attached[i].Name.Free();
                    Attached[i].LastOpen = 0;
                    break;
                }
            }
        }
    } WsbCatch(hr);

    if (jet_name) {
        WsbFree(jet_name);
    }
    LeaveCriticalSection(&AttachedCritSect);

    WsbTraceOut(OLESTR("CWsbDbSys::DbAttachedRemove"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}

//  wsb_db_jet_check_error - check for a jet error; return S_OK for no error;
//    print error to trace otherwise
HRESULT wsb_db_jet_check_error(LONG jstat, char *fileName, DWORD lineNo)
{
    HRESULT hr = S_OK;

    if (jstat != JET_errSuccess) {
        WsbTrace(OLESTR("Jet error = %ld (%hs line %ld)\n"), jstat,
                fileName, lineNo);

        //  Convert JET error to IDB error for some common values
        switch (jstat) {
        case JET_errDiskFull:
        case JET_errLogDiskFull:
            hr = WSB_E_IDB_DISK_FULL;
            break;
        case JET_errDatabaseNotFound:
            hr = WSB_E_IDB_FILE_NOT_FOUND;
            break;
        case JET_errDatabaseInconsistent:
        case JET_errPageNotInitialized:
        case JET_errReadVerifyFailure:
        case JET_errDatabaseCorrupted:
        case JET_errBadLogSignature:
        case JET_errBadDbSignature:
        case JET_errBadCheckpointSignature:
        case JET_errCheckpointCorrupt:
        case JET_errMissingPatchPage:
        case JET_errBadPatchPage:
            hr = WSB_E_IDB_DATABASE_CORRUPT;
            break;
        case JET_errWriteConflict:
            hr = WSB_E_IDB_UPDATE_CONFLICT;
            break;
        default:
            hr = WSB_E_IDB_IMP_ERROR;
            break;
        }

        //  Log this error in the event log
        if (g_WsbLogLevel) {
            CWsbStringPtr str;

            WsbSetEventInfo(fileName, lineNo, VER_PRODUCTBUILD, RS_BUILD_VERSION); \
            str = WsbLongAsString(jstat);
            if (WSB_E_IDB_IMP_ERROR != hr) {
                str.Prepend(" (");
                str.Prepend(WsbHrAsString(hr));
                str.Append(")");
            }
            WsbTraceAndLogEvent(WSB_MESSAGE_IDB_ERROR, 0, NULL,
                static_cast<OLECHAR *>(str), NULL);
        }
    }
    return(hr);
}

// wsb_db_jet_fix_path - convert database path name from OLESTR to char*,
//    change (or add) extension.
//    Returns HRESULT
//
//  NOTE: OLECHAR* is passed in, but char* is returned
HRESULT 
wsb_db_jet_fix_path(OLECHAR* path, OLECHAR* ext, char** new_path)
{
    HRESULT hr = S_OK;

    try {
        CWsbStringPtr  string;
        int            tlen;

        WsbAssertPointer(path);
        WsbAssertPointer(new_path);

        //  Add extension if given
        string = path;
        WsbAffirm(0 != (WCHAR *)string, E_OUTOFMEMORY);
        if (ext) {
            WsbAffirmHr(AddExtension(&string, ext));
        }

        // Allocate char string
        tlen = (wcslen(string) + 1) * sizeof(OLECHAR);
        *new_path = (char*)WsbAlloc(tlen);
        WsbAffirm(*new_path, E_OUTOFMEMORY);

        //  Convert from wide char to char
        if (wcstombs(*new_path, string, tlen) == (size_t)-1) {
            WsbFree(*new_path);
            *new_path = NULL;
            WsbThrow(WSB_E_STRING_CONVERSION);
        }
    } WsbCatch(hr);

    return(hr);
}


//  Local functions

//  AddExtension - add (or replace) the file extension to the path.
//    If Ext is NULL, remove the existing extension.
//
//    Return S_OK if no errors occurred.
static HRESULT AddExtension(OLECHAR** pPath, OLECHAR* Ext)
{
    HRESULT           hr = S_OK;

    WsbTraceIn(OLESTR("AddExtension(wsbdbsys)"), OLESTR("Path = \"%ls\", Ext = \"%ls\""),
            WsbAbbreviatePath(*pPath, 120), Ext );

    try {
        int      elen;
        int      len;
        OLECHAR* new_path;
        OLECHAR* pc;
        OLECHAR* pc2;
        int      tlen;

        WsbAssertPointer(pPath);
        WsbAssertPointer(*pPath);

        // Allocate string and copy path
        len = wcslen(*pPath);
        if (Ext) {
            elen = wcslen(Ext);
        } else {
            elen = 0;
        }
        tlen = (len + elen + 1) * sizeof(OLECHAR);
        new_path = static_cast<OLECHAR*>(WsbAlloc(tlen));
        WsbAffirm(new_path, E_OUTOFMEMORY);
        wcscpy(new_path, *pPath);

        //  Remove old extension (if there)
        pc = wcsrchr(new_path, L'.');
        pc2 = wcsrchr(new_path, L'\\');
        if (pc && (!pc2 || pc2 < pc)) {
            *pc = L'\0';
        }

        //  Add the new extension (if given)
        if (Ext) {
            wcscat(new_path, Ext);
        }

        //  Return the new path
        WsbFree(*pPath);
        *pPath = new_path;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("AddExtension(wsbdbsys)"), OLESTR("hr =<%ls>, new path = \"%ls\""), 
            WsbHrAsString(hr), WsbAbbreviatePath(*pPath, 120));

    return(hr);
}

//  ClearDirectory - delete all files in a directory
//    Return S_OK if no errors occurred.
static HRESULT ClearDirectory(const OLECHAR* DirPath)
{
    DWORD             err;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind = 0;
    HRESULT           hr = S_OK;
    int               nDeleted = 0;
    int               nSkipped = 0;
    CWsbStringPtr     SearchPath;

    WsbTraceIn(OLESTR("ClearDirectory(wsbdbsys)"), OLESTR("Path = <%ls>"),
            WsbAbbreviatePath(DirPath, 120));

    try {
        SearchPath = DirPath;
        SearchPath.Append("\\*");

        hFind =  FindFirstFile(SearchPath, &FindData);
        if (INVALID_HANDLE_VALUE == hFind) {
            hFind = 0;
            err = GetLastError();
            WsbTrace(OLESTR("ClearDirectory(wsbdbsys): FindFirstFile(%ls) failed, error = %ld\n"),
                    static_cast<OLECHAR*>(SearchPath), err);
            WsbThrow(HRESULT_FROM_WIN32(err));
        }

        while (TRUE) {

            if (FindData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY |
                    FILE_ATTRIBUTE_HIDDEN)) {
                nSkipped++;
            } else {
                CWsbStringPtr     DeletePath;

                DeletePath = DirPath;
                DeletePath.Append("\\");
                DeletePath.Append(FindData.cFileName);
                if (!DeleteFile(DeletePath)) {
                    err = GetLastError();
                    WsbTrace(OLESTR("ClearDirectory(wsbdbsys): DeleteFile(%ls) failed, error = %ld\n"),
                            static_cast<OLECHAR*>(DeletePath), err);
                    WsbThrow(HRESULT_FROM_WIN32(err));
                }
                nDeleted++;
            }
            if (!FindNextFile(hFind, &FindData)) { 
                err = GetLastError();
                if (ERROR_NO_MORE_FILES == err) break;
                WsbTrace(OLESTR("ClearDirectory(wsbdbsys): FindNextFile failed, error = %ld\n"),
                        err);
                WsbThrow(HRESULT_FROM_WIN32(err));
            }
        }
    } WsbCatch(hr);

    if (0 != hFind) {
        FindClose(hFind);
    }

    WsbTraceOut(OLESTR("ClearDirectory(wsbdbsys)"), OLESTR("hr =<%ls>, # deleted = %d, # skipped = %d"), 
            WsbHrAsString(hr), nDeleted, nSkipped);

    return(hr);
}

//  CopyDirectory - copy files from one directory to another
//    Return S_OK if no errors occurred.
static HRESULT CopyDirectory(const OLECHAR* DirSource, const OLECHAR* DirTarget)
{
    DWORD             err;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind = 0;
    HRESULT           hr = S_OK;
    int               nCopied = 0;
    int               nSkipped = 0;
    CWsbStringPtr     SearchPath;

    WsbTraceIn(OLESTR("CopyDirectory(wsbdbsys)"), OLESTR("OldPath = \"%ls\", NewPath = \"%ls\""),
            WsbQuickString(WsbAbbreviatePath(DirSource, 120)), 
            WsbQuickString(WsbAbbreviatePath(DirTarget, 120)));

    try {
        SearchPath = DirSource;
        SearchPath.Append("\\*");

        hFind =  FindFirstFile(SearchPath, &FindData);
        if (INVALID_HANDLE_VALUE == hFind) {
            hFind = 0;
            err = GetLastError();
            WsbTrace(OLESTR("ClearDirectory(wsbdbsys): FindFirstFile(%ls) failed, error = %ld\n"),
                    static_cast<OLECHAR*>(SearchPath), err);
            WsbThrow(HRESULT_FROM_WIN32(err));
        }

        while (TRUE) {

            if (FindData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY |
                    FILE_ATTRIBUTE_HIDDEN)) {
                nSkipped++;
            } else {
                CWsbStringPtr     NewPath;
                CWsbStringPtr     OldPath;

                OldPath = DirSource;
                OldPath.Append("\\");
                OldPath.Append(FindData.cFileName);
                NewPath = DirTarget;
                NewPath.Append("\\");
                NewPath.Append(FindData.cFileName);
                if (!CopyFile(OldPath, NewPath, FALSE)) {
                    err = GetLastError();
                    WsbTrace(OLESTR("ClearDirectory(wsbdbsys): CopyFile(%ls, %ls) failed, error = %ld\n"),
                            static_cast<OLECHAR*>(OldPath), 
                            static_cast<OLECHAR*>(NewPath), err);
                    WsbThrow(HRESULT_FROM_WIN32(err));
                }
                nCopied++;
            }
            if (!FindNextFile(hFind, &FindData)) { 
                err = GetLastError();
                if (ERROR_NO_MORE_FILES == err) break;
                WsbTrace(OLESTR("ClearDirectory(wsbdbsys): FindNextFile failed, error = %ld\n"),
                        err);
                WsbThrow(HRESULT_FROM_WIN32(err));
            }
        }
    } WsbCatch(hr);

    if (0 != hFind) {
        FindClose(hFind);
    }

    WsbTraceOut(OLESTR("CopyDirectory(wsbdbsys)"), OLESTR("hr =<%ls>, copied = %ld, skipped = %ld"), 
            WsbHrAsString(hr), nCopied, nSkipped);

    return(hr);
}

//  DirectoryHasFullBackup - try to determine if the directory contains a full backup
//    Return 
//      S_OK    if it contains a full backup
//      S_FALSE if it doesn't
//      E_*     on errors
//
//  The technique use here is somewhat ad hoc since it expects the full backup
//  filename to end in IDB_DB_FILE_SUFFIX

static HRESULT DirectoryHasFullBackup(const OLECHAR* DirPath)
{
    HRESULT           hr = S_OK;

    WsbTraceIn(OLESTR("DirectoryHasFullBackup(wsbdbsys)"), OLESTR("Path = <%ls>"),
            WsbAbbreviatePath(DirPath, 120));

    try {
        ULONG         Count;

        WsbAffirmHr(FileCount(DirPath, L"*." IDB_DB_FILE_SUFFIX, &Count));
        if (0 == Count) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("DirectoryHasFullBackup(wsbdbsys)"), OLESTR("hr =<%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}

//  FileCount - count all files in a directory matching a pattern.  Skip
//    directories and hidden files.
//    Return S_OK if no errors occurred.
static HRESULT FileCount(const OLECHAR* DirPath, const OLECHAR* Pattern,
                    ULONG* Count)
{
    DWORD             err;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind = 0;
    HRESULT           hr = S_OK;
    int               lCount = 0;
    int               nSkipped = 0;
    CWsbStringPtr     SearchPath;

    WsbTraceIn(OLESTR("FileCount(wsbdbsys)"), OLESTR("Path = <%ls>"),
            WsbAbbreviatePath(DirPath, 120));

    try {
        SearchPath = DirPath;
        SearchPath.Append("\\");
        SearchPath.Append(Pattern);
        *Count = 0;

        hFind =  FindFirstFile(SearchPath, &FindData);
        if (INVALID_HANDLE_VALUE == hFind) {
            hFind = 0;
            err = GetLastError();
            if (ERROR_FILE_NOT_FOUND == err) WsbThrow(S_OK);
            WsbTrace(OLESTR("FileCount(wsbdbsys): FindFirstFile(%ls) failed, error = %ld\n"),
                    static_cast<OLECHAR*>(SearchPath), err);
            WsbThrow(HRESULT_FROM_WIN32(err));
        }

        while (TRUE) {

            if (FindData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY |
                    FILE_ATTRIBUTE_HIDDEN)) {
                nSkipped++;
            } else {
                lCount++;
            }
            if (!FindNextFile(hFind, &FindData)) { 
                err = GetLastError();
                if (ERROR_NO_MORE_FILES == err) break;
                WsbTrace(OLESTR("FileCount(wsbdbsys): FindNextFile failed, error = %ld\n"),
                        err);
                WsbThrow(HRESULT_FROM_WIN32(err));
            }
        }
    } WsbCatch(hr);

    if (0 != hFind) {
        FindClose(hFind);
    }

    if (S_OK == hr) {
        *Count = lCount;
    }

    WsbTraceOut(OLESTR("FileCount(wsbdbsys)"), OLESTR("hr =<%ls>, # skipped = %d, Count = %ld"), 
            WsbHrAsString(hr), nSkipped, *Count);

    return(hr);
}

//  RenameDirectory - rename a directory
//    Return S_OK if no errors occurred.
static HRESULT RenameDirectory(const OLECHAR* OldDir, const OLECHAR* NewDir)
{
    DWORD             err;
    HRESULT           hr = S_OK;

    WsbTraceIn(OLESTR("RenameDirectory(wsbdbsys)"), OLESTR("OldPath = \"%ls\", NewPath = \"%ls\""),
            WsbQuickString(WsbAbbreviatePath(OldDir, 120)), 
            WsbQuickString(WsbAbbreviatePath(NewDir, 120)));

    try {
        if (!MoveFile(OldDir, NewDir)) {
            err = GetLastError();
            WsbTrace(OLESTR("RenameDirectory(wsbdbsys): MoveFile failed, error = %ld\n"), err);
            WsbThrow(HRESULT_FROM_WIN32(err));
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("RenameDirectory(wsbdbsys)"), OLESTR("hr =<%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idl\mvrguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
    -del *_i.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idl\fsaguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idl\rmsguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idl\hsmsguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idl\hsmguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idb\wsbdbsys.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbsys.h

Abstract:

    The CWsbDbSys class.

Author:

    Ron White   [ronw]   7-May-1997

Revision History:

--*/


#ifndef _WSBDBSYS_
#define _WSBDBSYS_

#include "wsbdb.h"
#include "wsbdbses.h"
#include "resource.h"


#define IDB_DB_FILE_SUFFIX    L"jet"

// Default no. of Jet sessions per process is currently 128 which may not be enough for HSM
#define IDB_MAX_NOF_SESSIONS    32

/*++

Class Name:

    CWsbDbSys

Class Description:

    The IDB system object.  One must be created for each process
    that wants to use the IDB system.  The Init method needs to be
    called after the object is created.

--*/

class CWsbDbSys :
    public IWsbDbSys,
    public IWsbDbSysPriv,
    public CComObjectRoot,
    public CComCoClass<CWsbDbSys,&CLSID_CWsbDbSys>
{
friend class CWsbDb;
friend class CWsbDbSes;

public:
    CWsbDbSys() {}
BEGIN_COM_MAP( CWsbDbSys )
    COM_INTERFACE_ENTRY( IWsbDbSys )
    COM_INTERFACE_ENTRY( IWsbDbSysPriv )
END_COM_MAP( )

DECLARE_REGISTRY_RESOURCEID( IDR_CWsbDbSys )


// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbDbSys
public:
    STDMETHOD(Backup)(OLECHAR* path, ULONG flags);
    STDMETHOD(Init)(OLECHAR* path, ULONG flags);
    STDMETHOD(Terminate)(void);
    STDMETHOD(NewSession)(IWsbDbSession** ppSession);
    STDMETHOD(GetGlobalSession)(IWsbDbSession** ppSession);
    STDMETHOD(Restore)(OLECHAR* fromPath, OLECHAR* toPath);
    STDMETHOD(IncrementChangeCount)(void);

// IWsbDbSysPriv
public:
    STDMETHOD(DbAttachedAdd)(OLECHAR* name, BOOL attach);
    STDMETHOD(DbAttachedEmptySlot)(void);
    STDMETHOD(DbAttachedInit)(void);
    STDMETHOD(DbAttachedRemove)(OLECHAR* name);

//  Internal
    STDMETHOD(AutoBackup)(void);

//  Data
private:
    HANDLE                      m_AutoThread;
    CWsbStringPtr               m_BackupPath;       // File path for backup directory
    CWsbStringPtr               m_InitPath;         // File path from Init() call
    LONG                        m_ChangeCount;      // Count of DB changes since last backup
    FILETIME                    m_LastChange;       // Time of last DB change
    CComPtr<IWsbDbSession>      m_pWsbDbSession;    // A global Jet session for this Jet instance
    HANDLE                      m_BackupEvent;      // An event to sync Jet backups
    HANDLE                      m_terminateEvent;   // An event for signaling termination to the auto-backup thread
    BOOL                        m_bLogErrors;       // Whether to log errors or not     

    BOOL                        m_jet_initialized;
    JET_INSTANCE                m_jet_instance;
};

HRESULT wsb_db_jet_check_error(LONG jstat, char *fileName, DWORD lineNo);
HRESULT wsb_db_jet_fix_path(OLECHAR* path, OLECHAR* ext, char** new_path);

//  Capture FILE/LINE info on a JET error
#define jet_error(_jstat) \
        wsb_db_jet_check_error(_jstat, __FILE__, __LINE__)

#endif // _WSBDBSYS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idl\wsbguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\idl\rmsps\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\fsatrace.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FsaTrace.h

Abstract:

    This header file defines the part of the FSA code that is
    responsible for tracing FSA specific parameters.

Author:

    Cat Brant       [cbrant]   7-Det-1996

Revision History:

--*/

#ifndef _FSATRACE_
#define _FSATRACE_

#ifdef __cplusplus
extern "C" {
#endif

// Helper Functions
//
// NOTE: Be careful with some of these helper functions, since they
// use static memory and a second call to the function will overwrite
// the results of the first call to the function. 
extern const OLECHAR* FsaRequestActionAsString(FSA_REQUEST_ACTION requestAction);
extern const OLECHAR* FsaResultActionAsString(FSA_RESULT_ACTION resultAction);

#ifdef __cplusplus
}
#endif


#endif // _FSATRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\engine.h ===
#ifndef _ENGINE_H
#define _ENGINE_H

/*++

Copyright (c) 1997  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Engine.h

Abstract:

    Include file for all the public Engine files.

Author:

    Rohde Wakefield [rohde]     23-Apr-1997

Revision History:

--*/


#include "HsmEng.h"


// Engine lives in Remote Storage Server service thus its appid apply here
// RsServ AppID {FD0E2EC7-4055-4A49-9AA9-1BF34B39438E} 
static const GUID APPID_RemoteStorageEngine = 
{ 0xFD0E2EC7, 0x4055, 0x4A49, { 0x9A, 0xA9, 0x1B, 0xF3, 0x4B, 0x39, 0x43, 0x8E } };

// The name of the default manage job.
# define HSM_DEFAULT_MANAGE_JOB_NAME        OLESTR("Manage")
//
// Key types for the metadata database
//
#define HSM_SEG_REC_TYPE          1    
#define HSM_MEDIA_INFO_REC_TYPE   2
#define HSM_BAG_INFO_REC_TYPE     3
#define HSM_BAG_HOLE_REC_TYPE     4
#define HSM_VOL_ASSIGN_REC_TYPE   5

//
// Mask options for segment record flags
//
#define		SEG_REC_NONE				0x0000

#define		SEG_REC_INDIRECT_RECORD     0x0001
#define		SEG_REC_MARKED_AS_VALID		0x0002

//
// Maximum number of copies supported by this engine
//
#define HSM_MAX_NUMBER_MEDIA_COPIES 3

//
// Strings for session names that are written to media
//
#define HSM_BAG_NAME            OLESTR("Remote Storage Set - ")
#define HSM_ENGINE_ID           OLESTR("Remote Storage ID - ")
#define HSM_METADATA_NAME       OLESTR("Remote Storage Metadata")   // Currently, in use only for Optical media

//
// Engine's Registry location
//
#define HSM_ENGINE_REGISTRY_STRING      OLESTR("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_Server\\Parameters")

//
// Engine's external Registry value names
#define HSM_MAX_FILE_TO_MIGRATE         OLESTR("MaximumFileSizeToMigrate")

#endif // _ENGINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\cli.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CLI.H

Abstract:

    This module defines the prototype for the Command Line Interface
    for HSM. These are interfaces the parse module of the CLI would
    call 

Author:

    Ravisankar Pudipeddi (ravisp)  2/23/00

Environment:

    User Mode

--*/

#ifndef _RSCLI_
#define _RSCLI_

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _HSM_JOB_TYPE {
    InvalidJobType = 0,
    CopyFiles,
    CreateFreeSpace,
    Validate,
    Unmanage
}  HSM_JOB_TYPE;

typedef enum _HSM_JOB_FREQUENCY {
    InvalidJobFrequency = 0,
    Daily,
    Weekly,
    Monthly,
    Once,
    SystemStartup,
    Login,
    WhenIdle
} HSM_JOB_FREQUENCY;
    
    
typedef struct _HSM_JOB_SCHEDULE {
    HSM_JOB_FREQUENCY Frequency;
    union {
        struct {
            SYSTEMTIME  Time;
            DWORD       Occurrence;
        } Daily;
        struct {
            SYSTEMTIME  Time;
            DWORD       Occurrence;
        } Weekly;
        struct {
            SYSTEMTIME  Time;
        } Monthly;
        struct {
            SYSTEMTIME  Time;
        } Once;
        struct {
        } SystemStartup;
        struct {
        } Login;
        struct {
            DWORD       Occurrence;
        } WhenIdle;
    } Parameters;
} HSM_JOB_SCHEDULE, *PHSM_JOB_SCHEDULE;
    
#define INVALID_DWORD_ARG       ((DWORD) -1)
#define INVALID_POINTER_ARG     NULL
#define CLI_ALL_STR             L"*"

#ifdef CLI_IMPL
#define CLI_EXPORT      __declspec(dllexport)
#else
#define CLI_EXPORT      __declspec(dllimport)
#endif

CLI_EXPORT HRESULT
AdminSet(
   IN DWORD RecallLimit,
   IN DWORD AdminExempt,
   IN DWORD MediaCopies,
   IN DWORD Concurrency,
   IN PVOID Schedule
);
          

CLI_EXPORT HRESULT
AdminShow(
   IN BOOL RecallLimit,
   IN BOOL AdminExempt,
   IN BOOL MediaCopies,
   IN BOOL Concurrency,
   IN BOOL Schedule,
   IN BOOL General,
   IN BOOL Manageables,
   IN BOOL Managed,
   IN BOOL Media
);

CLI_EXPORT HRESULT
AdminJob(
   IN BOOL Enable
);

CLI_EXPORT HRESULT
VolumeManage(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN DWORD  Dfs,
   IN DWORD  Size,
   IN DWORD  Access,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec,
   IN BOOL   Include,
   IN BOOL   Recursive
);

CLI_EXPORT HRESULT
VolumeUnmanage(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN BOOL   Full
);

CLI_EXPORT HRESULT
VolumeSet(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN DWORD  Dfs,
   IN DWORD  Size,
   IN DWORD  Access,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec,
   IN BOOL   Include,
   IN BOOL   Recursive
);

CLI_EXPORT HRESULT
VolumeShow(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN BOOL   Dfs, 
   IN BOOL   Size,
   IN BOOL   Access,
   IN BOOL   Rules,
   IN BOOL   Statistics
);

CLI_EXPORT HRESULT
VolumeDeleteRule(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec
);

CLI_EXPORT HRESULT
VolumeJob(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN HSM_JOB_TYPE Job,
   IN BOOL  RunOrCancel,
   IN BOOL  Synchronous
);  

CLI_EXPORT HRESULT
FileRecall(
   IN LPWSTR *FileSpecs,
   IN DWORD NumberOfFileSpecs
);

CLI_EXPORT HRESULT
MediaSynchronize(
   IN DWORD CopySetNumber,
   IN BOOL  Synchronous
);

CLI_EXPORT HRESULT
MediaRecreateMaster(
   IN LPWSTR MediaName,
   IN DWORD  CopySetNumber,
   IN BOOL   Synchronous
);

CLI_EXPORT HRESULT
MediaDelete(
   IN LPWSTR *MediaNames,
   IN DWORD  NumberOfMedia,
   IN DWORD  CopySetNumber
);

CLI_EXPORT HRESULT
MediaShow(
   IN LPWSTR *MediaNames,
   IN DWORD  NumberOfMedia,
   IN BOOL   Name,
   IN BOOL   Status,
   IN BOOL   Capacity,
   IN BOOL   FreeSpace,
   IN BOOL   Version,
   IN BOOL   Copies
);

#ifdef __cplusplus
}
#endif

#endif // _RSCLI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\hsmconn.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmFind.h

Abstract:

    This is the header file for HsmConn.dll

Author:

    Rohde Wakefield    [rohde]   21-Oct-1996

Revision History:

--*/




#ifndef __HSMFIND__
#define __HSMFIND__

// Need for IEnumGUID
#include "activeds.h"
#include "inetsdk.h"

#include "HsmEng.h"

#ifdef __cplusplus
extern "C"
{
#endif

#ifdef HSMCONN_IMPL
#define HSMCONN_EXPORT __declspec(dllexport)
#else
#define HSMCONN_EXPORT __declspec(dllimport)
#endif

#define HSMCONN_API __stdcall

typedef enum _hsmconn_type {

    HSMCONN_TYPE_HSM,
    HSMCONN_TYPE_FSA,
    HSMCONN_TYPE_RESOURCE,
    HSMCONN_TYPE_FILTER,
    HSMCONN_TYPE_RMS        //stays just as literal for GUI needs, but NOT supported
                            //by HsmConn anymore
} HSMCONN_TYPE;


HSMCONN_EXPORT HRESULT HSMCONN_API
HsmConnectFromId (
    IN  HSMCONN_TYPE type,
    IN  REFGUID rguid,
    IN  REFIID riid,
    OUT void ** ppv
    );

HSMCONN_EXPORT HRESULT HSMCONN_API
HsmConnectFromName (
    IN  HSMCONN_TYPE type,
    IN  const OLECHAR * szName,
    IN  REFIID riid,
    OUT void ** ppv
    );

HSMCONN_EXPORT HRESULT HSMCONN_API
HsmPublish (
    IN  HSMCONN_TYPE type,
    IN  const OLECHAR * szName,
    IN  REFGUID rguidObjectId,
    IN  const OLECHAR * szServer,
    IN  REFGUID rguid
    );

HSMCONN_EXPORT HRESULT HSMCONN_API
HsmGetComputerNameFromADsPath(
    IN  const OLECHAR * szADsPath,
    OUT OLECHAR **      pszComputerName
    );

#ifdef __cplusplus
}
#endif

#endif //__HSMFIND__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\fsantfy.h ===
#ifndef _FSANTFY_
#define _FSANTFY_

// fsantfy.h
//
// This header file has the definitions needed for recall notification
//

//
// The name of the mailslot, created by the client, that notification messages are sent to
//
#define WSB_MAILSLOT_NAME       L"HSM_MAILSLOT"

//
// The following messages will be sent between the FSA and the recall notification client
//
//
// Request to identify yourself
//
typedef struct wsb_identify_req {
WCHAR           fsaName[MAX_COMPUTERNAME_LENGTH + 1];       // Name of machine that FSA is on
ULONG           holdOff;                                    // Wait period before attempting ID response (milliseconds)
} WSB_IDENTIFY_REQ, *PWSB_IDENTIFY_REQ;


//
// Recall notification message
//
typedef struct wsb_notify_recall {
WCHAR           fsaName[MAX_COMPUTERNAME_LENGTH + 1];   // Name of server the FSA is on
LONGLONG        fileSize;                               // Size of file being recalled
HSM_JOB_STATE   state;                                  // Job state 
GUID            identifier;                             // ID of this recall
//
// TBD - need more information here (or make them get it via recall object) ??
//
} WSB_NOTIFY_RECALL, *PWSB_NOTIFY_RECALL;

typedef union wsb_msg {
WSB_IDENTIFY_REQ        idrq;
WSB_NOTIFY_RECALL       ntfy;
} WSB_MSG, *PWSB_MSG;

typedef struct wsb_mailslot_msg {
ULONG           msgType;
ULONG           msgCount;
WSB_MSG         msg;
} WSB_MAILSLOT_MSG, *PWSB_MAILSLOT_MSG;

//
// msgType values
//

#define WSB_MSG_IDENTIFY        1
#define WSB_MSG_NOTIFY          2

//
// Holdoff increment (milliseconds)
//
#define WSB_HOLDOFF_INCREMENT   300

//
// The following message is sent by the notification client via a named pipe 
// in response to a identification request.
//
typedef struct wsb_identify_rep {
WCHAR           clientName[MAX_COMPUTERNAME_LENGTH + 1];    // Name of server that notification client is on
} WSB_IDENTIFY_REP, *PWSB_IDENTIFY_REP;


typedef union wsb_pmsg {
WSB_IDENTIFY_REP        idrp;
} WSB_PMSG, *PWSB_PMSG;

typedef struct wsb_pipe_msg {
ULONG           msgType;
WSB_PMSG        msg;
} WSB_PIPE_MSG, *PWSB_PIPE_MSG;

//
// msgType values
//

#define WSB_PMSG_IDENTIFY       1


//
// FSA pipe name used for identification response
//
#define WSB_PIPE_NAME   L"HSM_PIPE"
//
// Pipe defines
//
#define     WSB_MAX_PIPES       32      // Bug 558180: limit the number of concurrent instances such that
                                        // malicious clients cannot drain the server resources

#define     WSB_PIPE_BUFF_SIZE  sizeof(WSB_PIPE_MSG)
#define     WSB_PIPE_TIME_OUT   5000



#endif // _FSANTFY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\fsa.h ===
#ifndef _FSA_
#define _FSA_

// fsa.h
//
// This header file collects up all the FSA and related objects
// and common function definitions. The COM objects are available in
// FSA.EXE.

#include "wsb.h"

// A definition for 1% and 100% as used by the resource's configured HsmLevel.
#define FSA_HSMLEVEL_1              10000000
#define FSA_HSMLEVEL_100            1000000000

// Records types for FSA Unmanage database
#define UNMANAGE_REC_TYPE                   1

// Macros to convert the Hsm management levels into percentages (and the inverse 
// macro, as well)
#define CONVERT_TO_PCT(__x) ( (__x) / FSA_HSMLEVEL_1 )
#define CONVERT_TO_HSMNUM(__x) ( (__x) * FSA_HSMLEVEL_1 )

// COM Interface & LibraryDefintions
#include "fsadef.h"
#include "fsaint.h"
#include "fsalib.h"

// Common Functions
#include "fsatrace.h"

// Recall notification
#include "fsantfy.h"

// Fsa lives now in Remote Storage Server service thus its appid apply here
// (This may change in the future if Fsa may reside in Client service as well)
// RsServ AppID {FD0E2EC7-4055-4A49-9AA9-1BF34B39438E} 
static const GUID APPID_RemoteStorageFileSystemAgent = 
{ 0xFD0E2EC7, 0x4055, 0x4A49, { 0x9A, 0xA9, 0x1B, 0xF3, 0x4B, 0x39, 0x43, 0x8E } };

#endif // _FSA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\job.h ===
// job.h
//
// This header file collects up all the HSM Job and related objects
// and common function definitions. The COM objects are available in
// RSJOB.DLL, and the functions in RSJOB.LIB.

// A definition for 1% and 100% as used by the job policies scale.
#define HSM_JOBSCALE_1              0x0010
#define HSM_JOBSCALE_100            0x0640

// Error codes
#include "wsb.h"

// COM Interface & LibraryDefintions
#include "jobdef.h"
#include "jobint.h"
#include "joblib.h"

// Common Functions

// Defines for groups of job states.
#define HSM_JOB_STATE_IS_ACTIVE(state)  ((HSM_JOB_STATE_ACTIVE == state) || \
                                         (HSM_JOB_STATE_CANCELLING == state) || \
                                         (HSM_JOB_STATE_PAUSING == state) || \
                                         (HSM_JOB_STATE_RESUMING == state) || \
                                         (HSM_JOB_STATE_STARTING == state) || \
                                         (HSM_JOB_STATE_SUSPENDING == state))

#define HSM_JOB_STATE_IS_DONE(state)    ((HSM_JOB_STATE_DONE == state) || \
                                         (HSM_JOB_STATE_CANCELLED == state) || \
                                         (HSM_JOB_STATE_FAILED == state) || \
                                         (HSM_JOB_STATE_SKIPPED == state) || \
                                         (HSM_JOB_STATE_SUSPENDED == state))

#define HSM_JOB_STATE_IS_PAUSED(state)  (HSM_JOB_STATE_PAUSED == state)


// This bits tell the session when to log events.
#define HSM_JOB_LOG_EVENT               0x00000001
#define HSM_JOB_LOG_ITEMMOSTFAIL        0x00000002
#define HSM_JOB_LOG_ITEMALLFAIL         0x00000004
#define HSM_JOB_LOG_ITEMALL             0x00000008
#define HSM_JOB_LOG_HR                  0x00000010
#define HSM_JOB_LOG_MEDIASTATE          0x00000020
#define HSM_JOB_LOG_PRIORITY            0x00000040
#define HSM_JOB_LOG_STATE               0x00000080
#define HSM_JOB_LOG_STRING              0x00000100

#define HSM_JOB_LOG_NONE                0x0
#define HSM_JOB_LOG_NORMAL              HSM_JOB_LOG_ITEMMOSTFAIL | HSM_JOB_LOG_HR | HSM_JOB_LOG_STATE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\mover.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Mover.h

Abstract:

    Data Mover defines

Author:

    Brian Dodd          [brian]         01-Apr-1997

Revision History:

--*/

#ifndef _MVR_
#define _MVR_

// Are we defining imports or exports?
#ifdef MVRDLL
#define MVRAPI  __declspec(dllexport)
#else
#define MVRAPI  __declspec(dllimport)
#endif

#include "Wsb.h"
#include "Rms.h"
#include "MvrLib.h"

////////////////////////////////////////////////////////////////////////////////////////
//
//  Mvr enumerations
//


/*++

Enumeration Name:

    

Description:

    

--*/


////////////////////////////////////////////////////////////////////////////////////////
//
//  MVR defines
//

// Session options

#define MVR_SESSION_APPEND_TO_DATA_SET      0x000000001
#define MVR_SESSION_OVERWRITE_DATA_SET      0x000000002
#define MVR_SESSION_AS_LAST_DATA_SET        0x000000004

#define MVR_SESSION_TYPE_TRANSFER           0x000000010
#define MVR_SESSION_TYPE_COPY               0x000000020
#define MVR_SESSION_TYPE_NORMAL             0x000000040
#define MVR_SESSION_TYPE_DIFFERENTIAL       0x000000080
#define MVR_SESSION_TYPE_INCREMENTAL        0x000000100
#define MVR_SESSION_TYPE_DAILY              0x000000200

#define MVR_SESSION_METADATA                0x000001000

// The following is used to select only
// session type from the session options
#define MVR_SESSION_TYPES (MVR_SESSION_TYPE_TRANSFER     | \
                           MVR_SESSION_TYPE_COPY         | \
                           MVR_SESSION_TYPE_NORMAL       | \
                           MVR_SESSION_TYPE_DIFFERENTIAL | \
                           MVR_SESSION_TYPE_INCREMENTAL  | \
                           MVR_SESSION_TYPE_DAILY)




// Stream modes / StoreData flags

#define MVR_MODE_READ                       0x000000001
#define MVR_MODE_WRITE                      0x000000002
#define MVR_MODE_APPEND                     0x000000004
#define MVR_MODE_RECOVER                    0x000000008
#define MVR_MODE_FORMATTED                  0x000000010
#define MVR_MODE_UNFORMATTED                0x000000020

#define MVR_FLAG_BACKUP_SEMANTICS           0x000000100
#define MVR_FLAG_HSM_SEMANTICS              0x000000200
#define MVR_FLAG_POSIX_SEMANTICS            0x000000400
#define MVR_FLAG_WRITE_PARENT_DIR_INFO      0x000000800
#define MVR_FLAG_COMMIT_FILE                0x000001000
#define MVR_FLAG_NO_CACHING                 0x000002000
#define MVR_FLAG_SAFE_STORAGE               0x000004000


// Verification types

#define MVR_VERIFICATION_TYPE_NONE          0x000000000
#define MVR_VERIFICATION_TYPE_HEADER_CRC    0x000000001
#define MVR_VERIFICATION_TYPE_DATA_CRC      0x000000002
#define MVR_VERIFICATION_TYPE_HEADER_CRC32  0x000000004
#define MVR_VERIFICATION_TYPE_DATA_CRC32    0x000000008




// Duplication options

#define MVR_DUPLICATE_UPDATE                0x000000001
#define MVR_DUPLICATE_REFRESH               0x000000002


// Misc defines
#define MVR_UNDEFINED_STRING                OLESTR("Uninitialized String")
#define MVR_NULL_STRING                     OLESTR("")

#define MVR_RSDATA_PATH                     OLESTR("RSData\\")
#define MVR_LABEL_FILENAME                  OLESTR("MediaLabel")
#define MVR_DATASET_FILETYPE                OLESTR(".bkf")
#define MVR_RECOVERY_FILETYPE               OLESTR(".$")
#define MVR_SAFE_STORAGE_FILETYPE           OLESTR(".bak")
#define MVR_VOLUME_LABEL                    OLESTR("RSS")


/*++

Structure Name:

    MVR_HINTS

Description:

    Structure used to specify a locate of file and unamed data in remote storage.

--*/
typedef struct _MVR_REMOTESTORAGE_HINTS {
    ULARGE_INTEGER  DataSetStart;
    ULARGE_INTEGER  FileStart;
    ULARGE_INTEGER  FileSize;
    ULARGE_INTEGER  DataStart;
    ULARGE_INTEGER  DataSize;
    DWORD           VerificationType;
    ULARGE_INTEGER  VerificationData;
    DWORD           DatastreamCRCType;
    ULARGE_INTEGER  DatastreamCRC;
    ULARGE_INTEGER  FileUSN;
} MVR_REMOTESTORAGE_HINTS, *LP_MVR_REMOTESTORAGE_HINTS;



#endif // _MVR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rpdata.h ===
/*++

   (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpData.h

Abstract:

    Contains structure definitions for the interface between RsFilter and the Fsa

Environment:

    User and  Kernel mode

--*/

#if !defined (RPDATA_H)

#define  RPDATA_H

/*
 Reparse point information for placeholder files

 The version must be changed whenever the structure of the reparse point
 data has changed.  Initial version is 100
*/

#define RP_VERSION    101


//
// Used to verify that the placeholder data is valid
//
#define RP_GEN_QUALIFIER(hsmData, qual) {UCHAR * __cP;  ULONG __ix;\
__cP = (UCHAR *) &(hsmData)->version;\
(qual) = 0L;\
for (__ix = 0; __ix < sizeof(RP_DATA) - sizeof(ULONG) - sizeof(GUID) ; __ix++){\
qual += (ULONG) *__cP;\
__cP++;}}


//
// Bit flag defined that indicates state of data: Truncated or Premigrated
// Use macros to test the bits.
//
// The following bits are mutually exclusive - if the file is truncated then truncate on close
// or premigrate on close make no sense, and if the file is set to truncate on close it is not
// truncated now and should not be added to the premigrated list on close...
//
   #define RP_FLAG_TRUNCATED            0x00000001  // File is a placeholder
   #define RP_FLAG_TRUNCATE_ON_CLOSE    0x00000002  // Truncate this file when closed   
   #define RP_FLAG_PREMIGRATE_ON_CLOSE 0x00000004   // Add to premigrated list on close
//
// The following flag is never to be written to media.  It is set by the engine after
// the CRC has been calculated and is cleared by the filter.  It is used to indicate that
// it is the engine that is setting the reparse point.
//
   #define RP_FLAG_ENGINE_ORIGINATED    0x80000000

   #define RP_FILE_IS_TRUNCATED( bitFlag )   ( bitFlag & RP_FLAG_TRUNCATED)
   #define RP_FILE_IS_PREMIGRATED( bitFlag ) ( !( bitFlag & RP_FLAG_TRUNCATED ) )
   #define RP_INIT_BITFLAG( bitflag )        ( ( bitflag ) = 0 )
   #define RP_SET_TRUNCATED_BIT( bitflag )   ( ( bitflag ) |= RP_FLAG_TRUNCATED)
   #define RP_CLEAR_TRUNCATED_BIT( bitflag)  ( ( bitflag ) &= ~RP_FLAG_TRUNCATED)

   #define RP_IS_ENGINE_ORIGINATED( bitFlag ) ( ( bitFlag & RP_FLAG_ENGINE_ORIGINATED) )
   #define RP_SET_ORIGINATOR_BIT( bitflag )   ( ( bitflag ) |= RP_FLAG_ENGINE_ORIGINATED)
   #define RP_CLEAR_ORIGINATOR_BIT( bitflag)  ( ( bitflag ) &= ~RP_FLAG_ENGINE_ORIGINATED)

   #define RP_FILE_DO_TRUNCATE_ON_CLOSE( bitFlag )   ( bitFlag & RP_FLAG_TRUNCATE_ON_CLOSE)
   #define RP_SET_TRUNCATE_ON_CLOSE_BIT( bitflag )   ( ( bitflag ) |= RP_FLAG_TRUNCATE_ON_CLOSE)
   #define RP_CLEAR_TRUNCATE_ON_CLOSE_BIT( bitflag)  ( ( bitflag ) &= ~RP_FLAG_TRUNCATE_ON_CLOSE)

   #define RP_FILE_DO_PREMIGRATE_ON_CLOSE( bitFlag )   ( bitFlag & RP_FLAG_PREMIGRATE_ON_CLOSE)
   #define RP_SET_PREMIGRATE_ON_CLOSE_BIT( bitflag )   ( ( bitflag ) |= RP_FLAG_PREMIGRATE_ON_CLOSE)
   #define RP_CLEAR_PREMIGRATE_ON_CLOSE_BIT( bitflag)  ( ( bitflag ) &= ~RP_FLAG_PREMIGRATE_ON_CLOSE)

   #define RP_RESV_SIZE 52

//
// Some important shared limits
//

//
// Number of outstanding IOCTLs FSA has pending with RsFilter used
// for communication. The cost is basically thenon-paged pool that is 
// sizeof(IRP) multiplied by this number 
// (i.e. approx. 100 * RP_MAX_RECALL_BUFFERS is the Non-paged pool outstanding)
//
#define RP_MAX_RECALL_BUFFERS           20  
#define RP_DEFAULT_RUNAWAY_RECALL_LIMIT 60

//
// Placeholder data - all versions unioned together
//
typedef struct _RP_PRIVATE_DATA {
   CHAR           reserved[RP_RESV_SIZE];        // Must be 0
   ULONG          bitFlags;            // bitflags indicating status of the segment
   LARGE_INTEGER  migrationTime;       // When migration occurred
   GUID           hsmId;
   GUID           bagId;
   LARGE_INTEGER  fileStart;
   LARGE_INTEGER  fileSize;
   LARGE_INTEGER  dataStart;
   LARGE_INTEGER  dataSize;
   LARGE_INTEGER  fileVersionId;
   LARGE_INTEGER  verificationData;
   ULONG          verificationType;
   ULONG          recallCount;
   LARGE_INTEGER  recallTime;
   LARGE_INTEGER  dataStreamStart;
   LARGE_INTEGER  dataStreamSize;
   ULONG          dataStream;
   ULONG          dataStreamCRCType;
   LARGE_INTEGER  dataStreamCRC;
} RP_PRIVATE_DATA, *PRP_PRIVATE_DATA;



typedef struct _RP_DATA {
   GUID              vendorId;         // Unique HSM vendor ID -- This is first to match REPARSE_GUID_DATA_BUFFER
   ULONG             qualifier;        // Used to checksum the data
   ULONG             version;          // Version of the structure
   ULONG             globalBitFlags;   // bitflags indicating status of the file
   ULONG             numPrivateData;   // number of private data entries
   GUID              fileIdentifier;   // Unique file ID
   RP_PRIVATE_DATA   data;             // Vendor specific data
} RP_DATA, *PRP_DATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rpfilt.h ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpFilt.h

Abstract:

  Contains service related definitions for the RsFilter service

Environment:

    Kernel mode


Revision History:


--*/

/*
  Registry defines for RsFilter component.  These are not required but will
  be read if there.                                                        
*/

/* Service configuration information */
//
// Name of the executable
//
#define RSFILTER_APPNAME            "RsFilter"
#define RSFILTER_EXTENSION          ".sys"
#define RSFILTER_FULLPATH           "%SystemRoot%\\System32\\Drivers\\RsFilter.Sys"
//
// Internal name of the service
//
#define RSFILTER_SERVICENAME        "RsFilter"
//
// Displayed name of the service
//
#define RSFILTER_DISPLAYNAME "Remote Storage Recall Support"
//
// List of service dependencies - "dep1\0dep2\0\0"
//
#define RSFILTER_DEPENDENCIES       "\0\0"
//
// Load order group
//
#define RSFILTER_GROUP              "Filter"


LONG RpInstallFilter(
    UCHAR  *machine,    /* I Machine to install on */
    UCHAR  *path,       /* I points to dir with RsFilter.sys */
    LONG  doCopy); /* I TRUE = copy file even if service exists (upgrade) */


LONG RpGetSystemDirectory(
    UCHAR *machine,  /* I machine name */
    UCHAR *sysPath); /* O System root */


LONG RpCheckService(
    UCHAR *machine,      // I Machine name
    UCHAR *serviceName,  // I Service to look for
    UCHAR *path,         // O Path where found
    LONG *isThere);      // O True if the service was there
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rpfsa.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2001
(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpFsa.h

Abstract:

    Contains function declarations and structures for the File System Filter for Remote Storage

Author:

    Rick Winter

Environment:

    Kernel mode


Revision History:

	X-13	108353		Michael C. Johnson		 3-May-2001
		When checking a file to determine the type of recall also
		check a the potential target disk to see whether or not
		it is writable. This is necessary now that we have read-only
		NTFS volumes.

	X-12	365077		Michael C. Johnson		 1-May-2001
		Revert to previous form of RsOpenTarget() with extra access
		parameter to allow us to apply the desired access bypassing 
		the access check.

	X-11	194325		Michael C. Johnson		 1-Mar-2001
		Clean up RsMountCompletion() and RsLoadFsCompletion() to 
		ensure they don't call routines such as IoDeleteDevice()
		if not running at PASSIVE_LEVEL.

		Add in memory trace mechanism in preparation for attempts
		to flush out lingering reparse point deletion troubles.


	X-10	326345		Michael C. Johnson		26-Feb-2001
		Only send a single RP_RECALL_WAITING to the fsa on any one
		file object. Use the new flag RP_NOTIFICATION_SENT to record 
		when notification has been done.



--*/


/* Defines */

// memory allocation Tags for debug usage
#define    RP_RQ_TAG    'SFSR'    // Recall queue
#define    RP_FN_TAG    'NFSR'    // File name cache
#define    RP_SE_TAG    'ESSR'    // Security info
#define    RP_WQ_TAG    'QWSR'    // Work queue
#define    RP_QI_TAG    'IQSR'    // Work Q info
#define    RP_LT_TAG    'TLSR'    // Long term memory
#define    RP_IO_TAG    'OISR'    // IOCTL queue
#define    RP_FO_TAG    'OFSR'    // File Object Queue
#define    RP_VO_TAG    'OVSR'    // Validate Queue
#define    RP_ER_TAG    'RESR'    // Error log data
#define    RP_CC_TAG    'CCSR'    // Cache buffers
#define    RP_US_TAG    'SUSR'    // Usn record
#define    RP_CX_TAG    'CCSR'    // Completion context
#define    RP_TC_TAG    'CTSR'    // Trace control block
#define    RP_TE_TAG    'ETSR'    // Trace entry buffer
#define    RP_RD_TAG    'DRSR'    // Root directory path



//
// Device extension for the RsFilter device object
//
typedef enum _RP_VOLUME_WRITE_STATUS {
    RsVolumeStatusUnknown = 0,		// No attempt has been made to determine volume writeability 
					// or attempt to determine volume writeability failed
    RsVolumeStatusReadOnly,		// volume is readonly
    RsVolumeStatusReadWrite		// Volume is writeable
} RP_VOLUME_WRITE_STATUS;

typedef struct _DEVICE_EXTENSION {
   CSHORT Type;
   CSHORT Size;
   PDEVICE_OBJECT FileSystemDeviceObject;

   PDEVICE_OBJECT RealDeviceObject;

   BOOLEAN Attached;

   BOOLEAN AttachedToNtfsControlDevice;

   volatile RP_VOLUME_WRITE_STATUS WriteStatus;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


#define RSFILTER_PARAMS_KEY            L"RsFilter\\Parameters"
#define RS_TRACE_LEVEL_VALUE_NAME      L"TraceLevel"
#define RS_TRACE_LEVEL_DEFAULT         0


extern PDEVICE_OBJECT FsDeviceObject;


// Fsa validate job registry entry location

#define FSA_VALIDATE_LOG_KEY_NAME L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_File_System_Agent\\Validate"

#define  FT_VOL_LEN  32

/* First guess at device name length */
#define     AV_DEV_OBJ_NAME_SIZE    (40 * sizeof(wchar_t))

/* Space for a NULL and a delimiter */
#define     AV_NAME_OVERHEAD        (2 * sizeof(wchar_t))

#define RP_NTFS_NAME L"\\FileSystem\\NTFS"

// FILE_HSM_ACTION_ACCESS is any access that requires HSM action (delete or recall or both)

#ifdef WHEN_WE_HANDLE_DELETE
   #define FILE_HSM_ACTION_ACCESS (FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE | DELETE)
#else
   #define FILE_HSM_ACTION_ACCESS (FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE)
#endif

/* FILE_HSM_RECALL_ACCESS is any access that allows the data to be read. */

#define FILE_HSM_RECALL_ACCESS (FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE)

//
// Timeout and retry values when waiting for the FSA to issue an IOCTL
// Represents the amount of time - under multiple concurrent recall situations -
// that an app will have to wait before the i/o it issued completes with
// STATUS_FILE_IS_OFFLINE because RsFilter couldn't get any IOCTLs to 
// communicate with the FSA
//
#define RP_WAIT_FOR_FSA_IO_TIMEOUT        -((LONGLONG) 4800000000) // 8 minutes

/* Module ID defines for error/event logging */

#define AV_MODULE_RPFILTER    1
#define AV_MODULE_RPFILFUN    2
#define AV_MODULE_RPSEC       3
#define AV_MODULE_RPZW        4
#define AV_MODULE_RPCACHE     5

#define AV_BUFFER_SIZE 1024


#ifndef BooleanFlagOn
#define BooleanFlagOn(F,SF) ( (BOOLEAN)(((F) & (SF)) != 0) )
#endif


#define AV_FT_TICKS_PER_SECOND      ((LONGLONG) 10000000)
#define AV_FT_TICKS_PER_MINUTE      ((LONGLONG) ((LONGLONG) 60  * AV_FT_TICKS_PER_SECOND))
#define AV_FT_TICKS_PER_HOUR        ((LONGLONG) ((LONGLONG) 60  * AV_FT_TICKS_PER_MINUTE))


//
// The filter ID tracks recalls and no-recalls as follows:
// The id is a longlong where the highest order bit identifies the type of recall
// (no-recall or recall).  The remaining part of the high order long identifies the
// read RP_IRP_QUEUE entry (for no-recall) or the file object entry (for recall).
// The lower long identifies the file context entry.
//

#define    RP_TYPE_RECALL       (ULONGLONG) 0x8000000000000000
#define    RP_CONTEXT_MASK      (ULONGLONG) 0x00000000ffffffff
#define    RP_READ_MASK         0x7fffffff
#define    RP_FILE_MASK         (ULONGLONG) 0xffffffff00000000

typedef struct _RP_CREATE_INFO {
   PIRP                        irp;
   PIO_STACK_LOCATION          irpSp;
   POBJECT_NAME_INFORMATION    str;
   ULONG                       options;
   //
   // Reparse point data
   //
   RP_DATA                     rpData;
   LONGLONG                    fileId;
   LONGLONG                    objIdHi;
   LONGLONG                    objIdLo;
   ULONG                       serial;
   ULONG                       action;
   ULONG                       desiredAccess;
} RP_CREATE_INFO, *PRP_CREATE_INFO;


typedef struct _RP_PENDING_CREATE {
   //
   // Filter id
   //
   ULONGLONG     filterId;
   //
   //
   //
   PRP_CREATE_INFO  qInfo;
   //
   // Event used to signal irp completion
   //
   KEVENT        irpCompleteEvent;
   //
   // File object for irp
   //
   PFILE_OBJECT  fileObject;
   //
   // Device object for irp
   //
   PDEVICE_OBJECT  deviceObject;
   //
   // Open options
   //
   ULONG         options;


   //
   // Indicates if oplocks should not be granted (to CI for instance..)
   //
#define RP_PENDING_NO_OPLOCK        0x1
   //
   // Indicates if IRP should be sent down again
   //
#define RP_PENDING_RESEND_IRP       0x2
   //
   // Indicates if we should wait for irp to complete
   //
#define RP_PENDING_WAIT_FOR_EVENT   0x4
   //
   //  Indicates if this is a recall
   //
#define RP_PENDING_IS_RECALL        0x8
   //
   //  Indicates if we should reset the offline attribute of the file
   //
#define RP_PENDING_RESET_OFFLINE    0x10
   ULONG         flags;
} RP_PENDING_CREATE, *PRP_PENDING_CREATE;


#define RP_IRP_NO_RECALL                1

typedef struct _RP_IRP_QUEUE {
   LIST_ENTRY      list;
   PIRP            irp;
   PDEVICE_EXTENSION deviceExtension;
   ULONG           flags;
   //
   // For regular read and write, offset and length
   // denote the offset and length within the file
   // For no-recall reads, offset and length would
   // denote the offset/length within the cacheBuffer
   //
   ULONGLONG       offset;
   ULONGLONG       length;
   //
   // These fields are used only for no-recall reads
   // filterId for no-recall (see filterid description)
   ULONGLONG       readId;
   ULONGLONG       recallOffset;
   ULONGLONG       recallLength;
   //
   // User buffer for data from read-no-recall
   // 
   PVOID           userBuffer; 
   //
   // Cache block buffer for no recall data
   //
   PVOID           cacheBuffer;
} RP_IRP_QUEUE, *PRP_IRP_QUEUE;

//
// Structure tracking the no-recall master IRP and associated irps
//
typedef struct _RP_NO_RECALL_MASTER_IRP {
   LIST_ENTRY AssocIrps;
   PIRP       MasterIrp;
} RP_NO_RECALL_MASTER_IRP, *PRP_NO_RECALL_MASTER_IRP;

//
// User security info structure: this is required for HSM 
// to do the pop-up for clients indicating the file is being recalled
//
typedef struct _RP_USER_SECURITY_INFO {
   //
   // Sid info
   //
   PCHAR                       userInfo;
   ULONG                       userInfoLen;
   LUID                        userAuthentication;
   LUID                        userInstance;
   LUID                        tokenSourceId;
   //
   // Token source info for user
   //
   CHAR                        tokenSource[TOKEN_SOURCE_LENGTH];
   //
   // Indicates if this was opened by user with admin privileges
   //
   BOOLEAN                     isAdmin;
   //
   // Indicates if this is a local proc
   //
   BOOLEAN                     localProc;

} RP_USER_SECURITY_INFO, *PRP_USER_SECURITY_INFO;

//
// Associated macro for above
//
#define RsFreeUserSecurityInfo(UserSecurityInfo)           {    \
    if (UserSecurityInfo) {                                     \
        if (UserSecurityInfo->userInfo) {                       \
            ExFreePool(UserSecurityInfo->userInfo);             \
        }                                                       \
        ExFreePool(UserSecurityInfo);                           \
    }                                                           \
}

//
// The file object entry keeps track of an open instance of a file.
// For each NTFS file object there is one of these (if the file has an HSM tag)
// This structure points to a FS_CONTEXT entry for which there is one for each file.
// For instance if 3 clients open \\server\share\foo there will be 3 file object
// structures and they will all point to the same FS_CONTEXT structure.
//
// The file objects we are tracking will have a pointer to one of there structures attached via
// FsRtlInsertFilterContext.  From there one can find the file context entry via the pointer to it.
//
typedef struct _RP_FILE_OBJ {
   //
   // Link to next file object
   //
   LIST_ENTRY                  list;
   //
   // File object itself
   //
   PFILE_OBJECT                fileObj;
   //
   // Device object
   //
   PDEVICE_OBJECT              devObj;
   //
   // Pointer to the RP_FILE_CONTEXT entry - there's one such entry for every *file*
   //
   PVOID                       fsContext;
   //
   // Resource protecting this entry
   //
   ERESOURCE                   resource;
   //
   // Spin lock protecting read/write IRP queues
   //
   KSPIN_LOCK                  qLock;
   //
   // Pending read IRP queue
   //
   LIST_ENTRY                  readQueue;
   //
   // Pending write IRP queue
   //
   LIST_ENTRY                  writeQueue;
   //
   // File create options specified when opening it
   //
   ULONG                       openOptions;
   //
   // File desired access spcecified when opening it
   //
   ULONG                       desiredAccess;
   //
   // Flags (descriptions below)
   //
   ULONG                       flags;
   //
   // Object id
   //
   LONGLONG                    objIdHi;
   LONGLONG                    objIdLo;
   //
   // File Id if available
   //
   LONGLONG                    fileId;
   //
   // Unique ID we generate for the file object
   //
   ULONGLONG                   filterId;
   //
   // Recall action flags (see rpio.h - RP_RECALL_ACTION..)
   //
   ULONG                       recallAction;
   PRP_USER_SECURITY_INFO      userSecurityInfo;
}  RP_FILE_OBJ, *PRP_FILE_OBJ;

//
// RP_FILE_OBJ Flags
//
//
// File was not opened for read or write access
//
#define RP_NO_DATA_ACCESS    1
//
// Opener is admin equivalent
//
#define RP_OPEN_BY_ADMIN     2
//
// Opened by local process
//
#define RP_OPEN_LOCAL        4
//
// Recall waiting notification already sent
//
#define RP_NOTIFICATION_SENT 8


//
// Recall state
//
typedef enum _RP_RECALL_STATE {
   RP_RECALL_INVALID   = -1,
   RP_RECALL_NOT_RECALLED,
   RP_RECALL_STARTED,
   RP_RECALL_COMPLETED
} RP_RECALL_STATE, *PRP_RECALL_STATE;

//
// Filter context for RsFilter:
// Since filter contexts are attached to the SCB (stream control block) we need to use
// the instance ID to indicate which file object we are interested in.  We attach this
// structure to and use myFileObjEntry to point to the RP_FILE_OBJ struct that
// represents this file object.
//
typedef struct _RP_FILTER_CONTEXT {
   FSRTL_PER_STREAM_CONTEXT       context;
   PVOID                          myFileObjEntry;
} RP_FILTER_CONTEXT, *PRP_FILTER_CONTEXT;

//
// File context: one per *file*
//
typedef struct _RP_FILE_CONTEXT {
   //
   // Links to next/prev file (hanging off RsFileObjQHead)
   //
   LIST_ENTRY                  list;
   //
   // Lock protecting file object queue
   //
   KSPIN_LOCK                  qLock;
   //
   // Queue of all related file object entries
   //
   LIST_ENTRY                  fileObjects;
   //
   // Recalled data is written using this file object
   //
   PFILE_OBJECT                fileObjectToWrite;
   //
   // Handle for the file object we use to write to
   //
   HANDLE                      handle;

   PDEVICE_OBJECT              devObj;

   PDEVICE_OBJECT              FilterDeviceObject;

   //
   // Unicode name of file
   //
   POBJECT_NAME_INFORMATION    uniName;
   //
   // From the file object - unique file identifier
   //
   PVOID                       fsContext;
   //
   // Buffer to write out to file
   //
   PVOID                       nextWriteBuffer;
   //
   // Size of next write to the file  (of recall data)
   //
   ULONG                       nextWriteSize;
   //
   // Lock protecting this entry
   //
   ERESOURCE                   resource;
   //
   // This notification event is signalled when recall completes for this file
   //
   KEVENT                      recallCompletedEvent;
   //
   // File id if available
   //
   LONGLONG                    fileId;
   //
   // Size in bytes of  recall needed
   //
   LARGE_INTEGER               recallSize;
   //
   // All bytes up to this offset have been recalled
   //
   LARGE_INTEGER               currentOffset;
   //
   // Lower half of filter id (unique per file)
   //
   ULONGLONG                   filterId;
   //
   // filterId for last completion
   //
   ULONGLONG                   lastRecallCompletionFilterId;
   //
   // Volume serial number
   //
   ULONG                       serial;
   //
   // If the recall is complete this is the status
   //
   NTSTATUS                    recallStatus;
   //
   // Recall state
   //
   RP_RECALL_STATE             state;
   //
   // Flags (see below for description)
   //
   ULONG                       flags;
   //
   // Reference count for the file context
   //
   ULONG                       refCount;
   //
   // Usn of the file
   //
   USN                         usn;
   //
   // Tracks create section lock
   //
   LONG                        createSectionLock;
   //
   // Reparse point data
   //
   RP_DATA                     rpData;

} RP_FILE_CONTEXT, *PRP_FILE_CONTEXT;

//
// RP_FILE_CONTEXT Flags
//
// We have seen a write to this file
#define RP_FILE_WAS_WRITTEN                  1
#define RP_FILE_INITIALIZED                  2
#define RP_FILE_REPARSE_POINT_DELETED        4

/*++

VOID
RsInitializeFileContextQueueLock()

Routine Description

Initializes lock guarding the file context queue

Arguments

none

Return Value

none

--*/
#define RsInitializeFileContextQueueLock()  {             \
        DebugTrace((DPFLTR_RSFILTER_ID, DBG_LOCK,"RsFilter: RsInitializeFileContextQueueLock.\n"));\
        ExInitializeFastMutex(&RsFileContextQueueLock);      \
}

/*++

VOID
RsAcquireFileContextQueueLock()

Routine Description

Acquire lock guarding  the file context queue

Arguments

none

Return Value

none

--*/
#define RsAcquireFileContextQueueLock()  {                \
        ExAcquireFastMutex(&RsFileContextQueueLock);      \
        DebugTrace((DPFLTR_RSFILTER_ID, DBG_LOCK, "RsFilter: RsAcquireFileContextQueueLock.\n"));\
}

/*++

VOID
RsReleaseFileContextQueueLock()

Routine Description

Release lock guarding  the file context queue

Arguments

none

Return Value

none

--*/
#define RsReleaseFileContextQueueLock()  {                \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsReleaseFileContextQueueLock.\n"));\
        ExReleaseFastMutex(&RsFileContextQueueLock);      \
}



/*++

VOID
RsAcquireFileObjectLockExclusive()

Routine Description

Acquire lock guarding a file object entry

Arguments

none

Return Value

none

--*/
#define RsAcquireFileObjectEntryLockExclusive(entry)  {                \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileObjectEntryLockExclusive Waiting (%x).\n", entry));\
        FsRtlEnterFileSystem();                                   \
        ExAcquireResourceExclusiveLite(&(entry)->resource, TRUE); \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileObjectEntryLockExclusive Owned (%x).\n", entry));\
}

/*++
VOID
RsAcquireFileObjectEntryLockShared()

Routine Description

Acquire lock guarding a file object entry

Arguments

none

Return Value

none

--*/
#define RsAcquireFileObjectEntryLockShared(entry)  {                 \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileObjectEntryLockShared Waiting (%x).\n", entry));\
        FsRtlEnterFileSystem();                                      \
        ExAcquireResourceSharedLite(&(entry)->resource, TRUE);       \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileObjectEntryLockShared Owned (%x).\n", entry));\
}

/*++

VOID
RsReleaseFileObjectEntryLock()

Routine Description

Release lock guarding a file object entry

Arguments

none

Return Value

none

--*/
#define RsReleaseFileObjectEntryLock(entry)  {           \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsReleaseFileObjectEntryLock (%x).\n", entry));\
        ExReleaseResourceLite(&(entry)->resource);           \
        FsRtlExitFileSystem();                          \
}


/*++

VOID
RsAcquireFileContextEntryLockExclusive()

Routine Description

Acquire lock guarding a file context entry

Arguments

none

Return Value

none

--*/
#define RsAcquireFileContextEntryLockExclusive(entry)  {                \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileContextEntryLockExclusive Waiting (%x).\n", entry));\
        FsRtlEnterFileSystem();                                   \
        ExAcquireResourceExclusiveLite(&(entry)->resource, TRUE); \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileContextEntryLockExclusive Owned (%x).\n", entry));\
}

/*++

VOID
RsAcquireFileContextEntryLockShared()

Routine Description

Acquire lock guarding a file context entry

Arguments

none

Return Value

none

--*/
#define RsAcquireFileContextEntryLockShared(entry)  {                \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileContextEntryLockShared Waiting (%x).\n", entry));\
        FsRtlEnterFileSystem();                                      \
        ExAcquireResourceSharedLite(&(entry)->resource, TRUE);       \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileContextEntryLockShared Owned (%x).\n", entry));\
}

/*++

VOID
RsReleaseFileContextEntryLock()

Routine Description

Release lock guarding a file context entry

Arguments

none

Return Value

none

--*/
#define RsReleaseFileContextEntryLock(entry)  {           \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsReleaseFileContextEntryLock. (%x)\n", entry));\
        ExReleaseResourceLite(&(entry)->resource);            \
        FsRtlExitFileSystem();                           \
}

/*++

VOID
RsGetValidateLock(PKIRQL irql)

Routine Description:

   Get a lock on the validate queue

Arguments:
   Place to save irql

Return Value:
    None

--*/
#define RsGetValidateLock(irql)  ExAcquireSpinLock(&RsValidateQueueLock, irql)

/*++

VOID
RsPutValidateLock(KIRQL oldIrql)

Routine Description:

   Free a lock on the validate queue

Arguments:
   Saved irql

Return Value:
    None

--*/

#define RsPutValidateLock(oldIrql)  ExReleaseSpinLock(&RsValidateQueueLock, oldIrql)

/*++

VOID
RsGetIoLock(PKIRQL irql)

Routine Description:

    Lock the IO queue

Arguments:

    Variable to receive current irql

Return Value:

    0

Note:

--*/

#define RsGetIoLock(irql)   ExAcquireSpinLock(&RsIoQueueLock, irql)

/*++

VOID
RsPutIoLock(KIRQL oldIrql)

Routine Description:

    Unlock the IO queue

Arguments:

    oldIrql - Saved irql

Return Value:

    0

Note:

--*/

#define RsPutIoLock(oldIrql)   ExReleaseSpinLock(&RsIoQueueLock, oldIrql)

#define RP_IS_NO_RECALL_OPTION(OpenOptions) \
      (RsNoRecallDefault?!((OpenOptions) & FILE_OPEN_NO_RECALL) : ((OpenOptions) & FILE_OPEN_NO_RECALL))

#define RP_SET_NO_RECALL_OPTION(OpenOptions)   \
      (RsNoRecallDefault ? ((OpenOptions) &=  ~FILE_OPEN_NO_RECALL):((OpenOptions) |= FILE_OPEN_NO_RECALL))

#define RP_RESET_NO_RECALL_OPTION(OpenOptions) \
      (RsNoRecallDefault ?((OpenOptions) |=  FILE_OPEN_NO_RECALL) : ((OpenOptions) &= ~FILE_OPEN_NO_RECALL))


#define RP_IS_NO_RECALL(Entry)                           \
       (RP_IS_NO_RECALL_OPTION((Entry)->openOptions) && !(((PRP_FILE_CONTEXT) (Entry)->fsContext)->flags & RP_FILE_WAS_WRITTEN))

#define RP_SET_NO_RECALL(Entry)                          \
         RP_SET_NO_RECALL_OPTION((Entry)->openOptions)

#define RP_RESET_NO_RECALL(Entry)                        \
        RP_RESET_NO_RECALL_OPTION(Entry->openOptions)


typedef struct _RP_VALIDATE_INFO {
   LIST_ENTRY                 list;
   LARGE_INTEGER              lastSetTime;    // Last time a RP was set.
   ULONG                      serial;         // Volume serial number
} RP_VALIDATE_INFO, *PRP_VALIDATE_INFO;

typedef struct _AV_ERR {
   ULONG   line;
   ULONG   file;
   ULONG   code;
   WCHAR   string[1];  /* Actual size will vary */
} AV_ERR, *PAV_ERR;

//
// Possible create flags:
//
#define SF_FILE_CREATE_PATH     1
#define SF_FILE_CREATE_ID       2
#define SF_FILE_READ            3


typedef enum _RP_FILE_BUF_STATE {
    RP_FILE_BUF_INVALID=0,
    RP_FILE_BUF_IO,
    RP_FILE_BUF_VALID,
    RP_FILE_BUF_ERROR
} RP_FILE_BUF_STATE, *PRP_FILE_BUF_STATE;

//
// Define the cache buffer structure
//
typedef struct _RP_FILE_BUF {
   //
   // IRPs waiting on this block
   //
   LIST_ENTRY   WaitQueue;
   //
   // Volume serial number for the volume on which the file
   // this block maps to resides
   //
   ULONG      VolumeSerial;
   //
   // File id uniquely indicating which file this block
   // belongs to
   //
   ULONGLONG   FileId;
   //
   // Block number this buffer maps to
   //
   ULONGLONG   Block;
   //
   // Lock for the buffer
   //
   ERESOURCE   Lock;
   //
   // Links in the hash queue this buffer belongs
   //
   LIST_ENTRY  BucketLinks;
   //
   // Links in the lru  list
   //
   LIST_ENTRY  LruLinks;
   //
   // Indicates the current buffer state
   //
   RP_FILE_BUF_STATE  State;
   //
   // If i/o completed with errors, this is useful
   //
   NTSTATUS    IoStatus;
   //
   // Actual buffer contents themselves
   //
   PUCHAR       Data;
   //
   // Usn used to validate block
   //
   LONGLONG     Usn;

} RP_FILE_BUF, *PRP_FILE_BUF;

//
// The hash bucket structure
//
typedef struct _RP_CACHE_BUCKET {
   //
   // Link to the head of the entries in this bucket
   //
   LIST_ENTRY FileBufHead;

} RP_CACHE_BUCKET, *PRP_CACHE_BUCKET;

//
// Cache LRU structure
//
typedef struct _RP_CACHE_LRU {
    //
    // Pointer to head of LRU
    //
    LIST_ENTRY FileBufHead;
    //
    // Lock structure for protecting the LRU
    //
    FAST_MUTEX Lock;
    //
    // Total number of buffers in the cache
    //
    //
    ULONG   TotalCount;
    //
    // Number of buffers in LRU (just for bookkeeping)
    //
    ULONG   LruCount;
    //
    // Counting semaphore used to signal availability (and number)
    // of buffers in LRU
    //
    KSEMAPHORE AvailableSemaphore;

} RP_CACHE_LRU, *PRP_CACHE_LRU;




//
// Completion Context used by Mount and LoadFs completion routines.
//

typedef struct _RP_COMPLETION_CONTEXT {
    LIST_ENTRY		        leQueueHead;
    PIO_WORKITEM		pIoWorkItem;
    PIRP			pIrp;
    PIO_WORKITEM_ROUTINE	prtnWorkItemRoutine;
    union {
        struct {
            PVPB		pvpbOriginalVpb;
            PDEVICE_OBJECT	pdoRealDevice;
            PDEVICE_OBJECT	pdoNewFilterDevice;
        } Mount;

        struct {
            PVOID               pvDummy;
        } LoadFs;
    } Parameters;
} RP_COMPLETION_CONTEXT, *PRP_COMPLETION_CONTEXT;


//
// Some utility macros
//

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) > (b) ? (b) : (a))

//
// Debug support
//
#define DBG_INFO        DPFLTR_INFO_LEVEL
#define DBG_ERROR       DPFLTR_ERROR_LEVEL
#define DBG_VERBOSE     DPFLTR_TRACE_LEVEL
#define DBG_LOCK        DPFLTR_TRACE_LEVEL

#define DebugTrace(MSG)  DbgPrintEx MSG                              


//
// Function prototypes
//


NTSTATUS
RsAddQueue(IN  ULONG          Serial,
           OUT PULONGLONG     RecallId,
           IN  ULONG          OpenOption,
           IN  PFILE_OBJECT   FileObject,
           IN  PDEVICE_OBJECT DevObj,
           IN  PDEVICE_OBJECT FilterDeviceObject,
           IN  PRP_DATA       PhData,
           IN  LARGE_INTEGER  RecallStart,
           IN  LARGE_INTEGER  RecallSize,
           IN  LONGLONG       FileId,
           IN  LONGLONG       ObjIdHi,
           IN  LONGLONG       ObjIdLo,
           IN  ULONG          DesiredAccess,
           IN  PRP_USER_SECURITY_INFO UserSecurityInfo);

NTSTATUS
RsAddFileObj(IN PFILE_OBJECT   fileObj,
             IN PDEVICE_OBJECT FilterDeviceObject,
             IN RP_DATA        *phData,
             IN ULONG          openOption);


NTSTATUS
RsQueueCancel(IN ULONGLONG filterId);

NTSTATUS
RsMakeContext(IN PFILE_OBJECT fileObj,
              OUT PRP_FILE_CONTEXT *context);

NTSTATUS
RsReleaseFileContext(IN PRP_FILE_CONTEXT context);

NTSTATUS
RsFreeFileObject(IN PLIST_ENTRY FilterContext);

PRP_FILE_CONTEXT
RsAcquireFileContext(IN ULONGLONG FilterId,
                     IN BOOLEAN   Exclusive);

VOID
RsReleaseFileObject(IN PRP_FILE_OBJ entry);

NTSTATUS
RsGenerateDevicePath(IN PDEVICE_OBJECT deviceObject,
                     OUT POBJECT_NAME_INFORMATION *nameInfo
                    );

NTSTATUS
RsGenerateFullPath(IN POBJECT_NAME_INFORMATION fileName,
                   IN PDEVICE_OBJECT deviceObject,
                   OUT POBJECT_NAME_INFORMATION *nameInfo
                  );

ULONG
RsRemoveQueue(IN PFILE_OBJECT fileObj);

NTSTATUS
RsCompleteRecall(IN PDEVICE_OBJECT DeviceObject,
                 IN ULONGLONG FilterId,
                 IN NTSTATUS  Status,
                 IN ULONG     RecallAction,
                 IN BOOLEAN   CancellableRead);

NTSTATUS
RsCompleteReads(IN PRP_FILE_CONTEXT Context);


NTSTATUS
RsPreserveDates(IN PRP_FILE_CONTEXT Context);

NTSTATUS
RsMarkUsn(IN PRP_FILE_CONTEXT Context);

NTSTATUS
RsOpenTarget(IN PRP_FILE_CONTEXT  Context,
             IN ULONG             OpenAccess,
	     IN  ULONG            AdditionalAccess,
             OUT HANDLE          *Handle,
             OUT PFILE_OBJECT    *FileObject);


ULONG
RsIsNoRecall(IN  PFILE_OBJECT fileObj,
             OUT PRP_DATA *rpData);

NTSTATUS
RsPartialData(IN PDEVICE_OBJECT   DeviceObject,
              IN ULONGLONG filterId,
              IN NTSTATUS status,
              IN CHAR *buffer,
              IN ULONG bytesRead,
              IN ULONGLONG offset);

NTSTATUS
RsPartialWrite(IN PDEVICE_OBJECT   DeviceObject,
               IN PRP_FILE_CONTEXT Context,
               IN CHAR *Buffer,
               IN ULONG BufLen,
               IN ULONGLONG Offset);

NTSTATUS
RsDoWrite(IN PDEVICE_OBJECT   DeviceObject,
          IN PRP_FILE_CONTEXT Context);


NTSTATUS
RsQueueRecall(IN ULONGLONG filterId,
              IN ULONGLONG recallStart,
              IN ULONGLONG recallSize);


NTSTATUS
RsQueueNoRecall(IN PFILE_OBJECT FileObject,
                IN PIRP      Irp,
                IN ULONGLONG RecallStart,
                IN ULONGLONG RecallSize,
                IN ULONG     BufferOffset,
                IN ULONG     BufferLength,
                IN PRP_FILE_BUF CacheBuffer,
                IN PVOID     UserBuffer);

NTSTATUS
RsQueueNoRecallOpen(IN PRP_FILE_OBJ entry,
                    IN ULONGLONG filterId,
                    IN ULONGLONG offset,
                    IN ULONGLONG size);
NTSTATUS
RsQueueRecallOpen(IN PRP_FILE_CONTEXT Context,
                  IN PRP_FILE_OBJ Entry,
                  IN ULONGLONG FilterId,
                  IN ULONGLONG Offset,
                  IN ULONGLONG Size,
                  IN ULONG     Command);

NTSTATUS
RsGetFileInfo(IN PRP_FILE_OBJ    Entry,
              IN PDEVICE_OBJECT  DeviceObject);

NTSTATUS
RsGetFileId(IN PRP_FILE_OBJ entry,
            IN PDEVICE_OBJECT  DeviceObject);

NTSTATUS
RsGetFileName(IN PRP_FILE_OBJ entry,
              IN PDEVICE_OBJECT  DeviceObject);

NTSTATUS
RsCloseFile(IN ULONGLONG filterId);

NTSTATUS
RsCleanupFileObject(IN ULONGLONG filterId);

NTSTATUS
RsCompleteIrp(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp,
             IN PVOID Context);

NTSTATUS
RsCheckRead(IN PIRP irp,
            IN PFILE_OBJECT fileObject,
            IN PDEVICE_EXTENSION deviceExtension);

NTSTATUS
RsCheckWrite(IN PIRP irp,
             IN PFILE_OBJECT fileObject,
             IN PDEVICE_EXTENSION deviceExtension);

NTSTATUS
RsFailAllRequests(IN PRP_FILE_CONTEXT Context,
                  IN BOOLEAN          Norecall);

NTSTATUS
RsCompleteAllRequests(
                     IN PRP_FILE_CONTEXT Context,
                     IN PRP_FILE_OBJ Entry,
                     IN NTSTATUS Status
                     );

NTSTATUS
RsWriteReparsePointData(IN PRP_FILE_CONTEXT Context);

NTSTATUS
RsTruncateFile(IN PRP_FILE_CONTEXT Context);


NTSTATUS
RsSetEndOfFile(IN PRP_FILE_CONTEXT Context,
               IN ULONGLONG size);

BOOLEAN
RsIsFastIoPossible(IN PFILE_OBJECT fileObj);

PIRP
RsGetFsaRequest(VOID);

PRP_FILE_OBJ
RsFindQueue(IN ULONGLONG filterId);


NTSTATUS
RsAddIo(IN PIRP irp);

PIRP
RsRemoveIo(VOID);

VOID
RsCompleteRead(IN PRP_IRP_QUEUE Irp,
               IN BOOLEAN unlock);


BOOLEAN
RsIsFileObj(IN PFILE_OBJECT fileObj,
            IN BOOLEAN      returnContextData,
            OUT PRP_DATA *rpData,
            OUT POBJECT_NAME_INFORMATION *str,
            OUT LONGLONG *fileId,
            OUT LONGLONG *objIdHi,
            OUT LONGLONG *objIdLo,
            OUT ULONG *options,
            OUT ULONGLONG *filterId,
            OUT USN       *usn);

VOID
RsCancelRecalls(VOID);

VOID
RsCancelIo(VOID);

VOID
RsLogValidateNeeded(IN ULONG serial);

BOOLEAN
RsAddValidateObj(IN  ULONG serial,
                 IN  LARGE_INTEGER cTime);
BOOLEAN
RsRemoveValidateObj(IN ULONG serial);

NTSTATUS
RsQueueValidate(IN ULONG serial);

ULONG
RsTerminate(VOID);

NTSTATUS
RsGetRecallInfo(IN OUT PRP_MSG              Msg,
                OUT    PULONG_PTR           InfoSize,
                IN     KPROCESSOR_MODE      RequestorMode);


VOID
RsCancelReadRecall(IN PDEVICE_OBJECT DeviceObject,
                   IN PIRP Irp);
VOID
RsCancelWriteRecall(IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp);

VOID
RsLogError(IN  ULONG line,
           IN  ULONG file,
           IN  ULONG code,
           IN  NTSTATUS ioError,
           IN  PIO_STACK_LOCATION irpSp,
           IN  WCHAR *msgString);



ULONG
RsGetReparseData(IN  PFILE_OBJECT fileObject,
                 IN  PDEVICE_OBJECT deviceObject,
                 OUT PRP_DATA rpData);


NTSTATUS
RsCheckVolumeReadOnly (IN     PDEVICE_OBJECT FilterDeviceObject,
		       IN OUT PBOOLEAN       pbReturnedFlagReadOnly);


NTSTATUS
RsQueryValueKey (
                IN PUNICODE_STRING KeyName,
                IN PUNICODE_STRING ValueName,
                IN OUT PULONG ValueLength,
                IN OUT PKEY_VALUE_FULL_INFORMATION *KeyValueInformation,
                IN OUT PBOOLEAN DeallocateKeyValue);


NTSTATUS
RsCacheInitialize(
 VOID
);

VOID
RsCacheFsaPartialData(
    IN PRP_IRP_QUEUE ReadIo,
    IN PUCHAR        Buffer,
    IN ULONGLONG     Offset,
    IN ULONG     Length,
    IN NTSTATUS  Status
);

VOID
RsCacheFsaIoComplete(
    IN PRP_IRP_QUEUE ReadIo,
    IN NTSTATUS      Status
);

NTSTATUS
RsGetNoRecallData(
      IN PFILE_OBJECT FileObject,
      IN PIRP         Irp,
      IN USN          Usn,
      IN LONGLONG     FileOffset,
      IN LONGLONG     Length,
      IN PUCHAR       UserBuffer
);

LONG
RsExceptionFilter(
    IN WCHAR *FunctionName,
    IN PEXCEPTION_POINTERS ExceptionPointer);

NTSTATUS
RsTruncateOnClose(
    IN PRP_FILE_CONTEXT Context
    );

NTSTATUS
RsSetPremigratedState(IN PRP_FILE_CONTEXT Context);

NTSTATUS
RsDeleteReparsePoint(IN PRP_FILE_CONTEXT Context);
NTSTATUS
RsSetResetAttributes(IN PFILE_OBJECT     FileObject,
                     IN ULONG            SetAttributes,
                     IN ULONG            ResetAttributes);
BOOLEAN
RsSetCancelRoutine(IN PIRP Irp,
                   IN PDRIVER_CANCEL CancelRoutine);
BOOLEAN
RsClearCancelRoutine (
                     IN PIRP Irp
                     );
NTSTATUS
RsGetFileUsn(IN PRP_FILE_CONTEXT Context,
             IN PFILE_OBJECT     FileObject,
             IN PDEVICE_OBJECT   FilterDeviceObject);
VOID
RsInterlockedRemoveEntryList(PLIST_ENTRY Entry,
                             PKSPIN_LOCK Lock);
VOID
RsGetUserInfo(
              IN  PSECURITY_SUBJECT_CONTEXT SubjectContext,
              OUT PRP_USER_SECURITY_INFO    UserSecurityInfo);





typedef enum _RpModuleCode
    {
     ModRpFilter = 100
    ,ModRpFilfun
    ,ModRpCache
    ,ModRpzw
    ,ModRpSec
    } RpModuleCode;

typedef struct _RP_TRACE_ENTRY
    {
    RpModuleCode	ModuleCode;
    USHORT		usLineNumber;
    USHORT		usIrql;
    LARGE_INTEGER	Timestamp;
    ULONG_PTR		Value1;
    ULONG_PTR		Value2;
    ULONG_PTR		Value3;
    ULONG_PTR		Value4;
    } RP_TRACE_ENTRY, *PRP_TRACE_ENTRY;


typedef struct _RP_TRACE_CONTROL_BLOCK
    {
    KSPIN_LOCK		Lock;
    PRP_TRACE_ENTRY	EntryBuffer;
    ULONG		EntryMaximum;
    ULONG		EntryNext;
    } RP_TRACE_CONTROL_BLOCK, *PRP_TRACE_CONTROL_BLOCK;



#define RsTrace0(_ModuleCode)						RsTrace4 ((_ModuleCode), 0,         0,         0,         0)
#define RsTrace1(_ModuleCode, _Value1)					RsTrace4 ((_ModuleCode), (_Value1), 0,         0,         0)
#define RsTrace2(_ModuleCode, _Value1, _Value2)				RsTrace4 ((_ModuleCode), (_Value1), (_Value2), 0,         0)
#define RsTrace3(_ModuleCode, _Value1, _Value2, _Value3)		RsTrace4 ((_ModuleCode), (_Value1), (_Value2), (_Value3), 0)

#if DBG
#define RsTrace4(_ModuleCode, _Value1, _Value2, _Value3, _Value4)	RsTraceAddEntry ((_ModuleCode),			\
											 ((USHORT)(__LINE__)),		\
											 ((ULONG_PTR)(_Value1)),	\
											 ((ULONG_PTR)(_Value2)),	\
											 ((ULONG_PTR)(_Value3)),	\
											 ((ULONG_PTR)(_Value4)))
#else
#define RsTrace4(_ModuleCode, _Value1, _Value2, _Value3, _Value4)
#endif


#if DBG
#define DEFAULT_TRACE_ENTRIES	(0x4000)
#else
#define DEFAULT_TRACE_ENTRIES	(0)
#endif

VOID RsTraceAddEntry (RpModuleCode ModuleCode,
		      USHORT       usLineNumber,
		      ULONG_PTR    Value1,
		      ULONG_PTR    Value2,
		      ULONG_PTR    Value3,
		      ULONG_PTR    Value4);

NTSTATUS RsTraceInitialize (ULONG ulRequestedTraceEntries);

extern PRP_TRACE_CONTROL_BLOCK RsTraceControlBlock;
extern ULONG                   RsDefaultTraceEntries;

NTSTATUS RsLookupContext (PFILE_OBJECT        pFileObject, 
			  PRP_FILE_OBJ       *pReturnedRpFileObject,
			  PRP_FILE_CONTEXT   *pReturnedRpFileContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rms.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Rms.h

Abstract:

    Remote Media Service defines

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMS_
#define _RMS_

// Are we defining imports or exports?
#ifdef RMSDLL
#define RMSAPI  __declspec(dllexport)
#else
#define RMSAPI  __declspec(dllimport)
#endif

#include "Wsb.h"
#include "HsmConn.h"
#include "Mover.h"
#include "RmsLib.h"

////////////////////////////////////////////////////////////////////////////////////////
//
//  Rms enumerations
//


/*++

Enumeration Name:

    RmsFindBy

Description:

    Specifies a type of find to perform using CompareTo.

--*/
typedef enum RmsFindBy {
    RmsFindByUnknown,               // Unknown (or default) find
    RmsFindByCartridgeId,           // Find by Cartridge Id.
    RmsFindByClassId,               // Find by Class Id.
    RmsFindByDescription,           // Find by Description.
    RmsFindByDeviceAddress,         // Find by Device Address.
    RmsFindByDeviceInfo,            // Find by unique device information.
    RmsFindByDeviceName,            // Find by Device Name.
    RmsFindByDeviceType,            // Find by Device Type.
    RmsFindByDriveClassId,          // Find by Drive Class Id.
    RmsFindByElementNumber,         // Find by Element Number.
    RmsFindByExternalLabel,         // Find by External Label.
    RmsFindByExternalNumber,        // Find by External Number.
    RmsFindByLibraryId,             // Find by Library Id.
    RmsFindByLocation,              // Find by Location.
    RmsFindByMediaSupported,        // Find by Media Supported.
    RmsFindByMediaType,             // Find by Media Type.
    RmsFindByScratchMediaCriteria,  // Find by Scratch Media Criteria.
    RmsFindByName,                  // Find by Name.
    RmsFindByObjectId,              // Find by Object Id.
    RmsFindByPartitionNumber,       // Find by Partition Number.
    RmsFindByMediaSetId,            // Find by Media Set Id.
    RmsFindByRequestNo,             // Find by Request Number.
    RmsFindBySerialNumber           // Find by Serial Number.
};


/*++

Enumeration Name:

    RmsObject

Description:

    Specifies a type of Rms object.

--*/
typedef enum RmsObject {
    RmsObjectUnknown = 0,
    RmsObjectCartridge,
    RmsObjectClient,
    RmsObjectDrive,
    RmsObjectDriveClass,
    RmsObjectDevice,
    RmsObjectIEPort,
    RmsObjectLibrary,
    RmsObjectMedia,
    RmsObjectMediaSet,
    RmsObjectNTMS,
    RmsObjectPartition,
    RmsObjectRequest,
    RmsObjectServer,
    RmsObjectCartridgeSide,
    RmsObjectStorageSlot,

    NumberOfRmsObjectTypes
};


/*++

Enumeration Name:

    RmsServerState

Description:

    Specifies the state of the Rms server object.

--*/
typedef enum RmsServerState {
    RmsServerStateUnknown = 0,
    RmsServerStateStarting,
    RmsServerStateStarted,
    RmsServerStateInitializing,
    RmsServerStateReady,
    RmsServerStateStopping,
    RmsServerStateStopped,
    RmsServerStateSuspending,
    RmsServerStateSuspended,
    RmsServerStateResuming,

    NumberOfRmsServerStates
};


/*++

Enumeration Name:

    RmsNtmsState

Description:

    Specifies the state of the Rms NTMS object.

--*/
typedef enum RmsNtmsState {
    RmsNtmsStateUnknown = 0,
    RmsNtmsStateStarting,
    RmsNtmsStateStarted,
    RmsNtmsStateInitializing,
    RmsNtmsStateReady,
    RmsNtmsStateStopping,
    RmsNtmsStateStopped,
    RmsNtmsStateSuspending,
    RmsNtmsStateSuspended,
    RmsNtmsStateResuming,

    NumberOfRmsNtmsStates
};


/*++

Enumeration Name:

    RmsElement

Description:

    Specifies a type of cartridge storage location.

--*/
typedef enum RmsElement {
    RmsElementUnknown,              // Unknown storage location
    RmsElementStage,                // A storage slot used for staging media.
    RmsElementStorage,              // A normal storage slot element within a
                                    //   library device.
    RmsElementShelf,                // A local shelf storage element.  Alternate
                                    //   position specifiers further delineate
                                    //   location.
    RmsElementOffSite,              // An off-site storage element.  Alternate
                                    //   position specifiers further delineate
                                    //   location.
    RmsElementDrive,                // A data transport element.
    RmsElementChanger,              // A medium transport element.
    RmsElementIEPort                // An import/export element.
};


/*++

Enumeration Name:

    RmsChanger

Description:

    Specifies a type of medium changer.

--*/
typedef enum RmsChanger {
    RmsChangerUnknown,              // Unknown medium changer.
    RmsChangerAutomatic,            // A robotic medium changer device.
    RmsChangerManual                // A human jukebox.
};


/*++

Enumeration Name:

    RmsPort

Description:

    Specifies a type of import / export element.

--*/
typedef enum RmsPort {
    RmsPortUnknown,                 // port type unknown
    RmsPortImport,                  // The portal can be used to import media
    RmsPortExport,                  // The portal can be used to export media
    RmsPortImportExport             // The portal is capable of importing and
                                    //   exporting media
};


/*++

Enumeration Name:

    RmsSlotSelect

Description:

    Specifies the slot selection policy.

--*/
typedef enum RmsSlotSelect {
    RmsSlotSelectUnknown,           // Selection policy unknown.
    RmsSlotSelectMinMount,          // Select slot that minimizes mount times.
    RmsSlotSelectGroup,             // Select slot that groups cartridges by
                                    //   application.
    RmsSlotSelectSortName,          // Select slot by sorting cartridges by
                                    //   name.
    RmsSlotSelectSortBarCode,       // Select slot by sorting cartridges by
                                    //   bar code label.
    RmsSlotSelectSortLabel          // Select slot by sorting cartridges by
                                    //   their on-media label.

};


/*++

Enumeration Name:

    RmsStatus

Description:

    Specifies the status for a cartridge.

--*/
typedef enum RmsStatus {
    RmsStatusUnknown,               // The cartridge is unknown to Rms.
    RmsStatusPrivate,               // The Cartridge is labeled and owned by an
                                    //   application.
    RmsStatusScratch,               // The Cartridge is blank, unlabeled, can be
                                    //   used for scratch media requests from
                                    //   any application.
    RmsStatusCleaning               // The cartridge is a cleaning cartridge.
};


/*++

Enumeration Name:

    RmsAttributes

Description:

    Specifies the attributes of a cartridge partition.

--*/
typedef enum RmsAttribute {
    RmsAttributesUnknown,           // Attributes are unknown.
    RmsAttributesRead,              // Data on the partition can be read by an
                                    //   owning application.
    RmsAttributesWrite,             // Data can be written to the partition by
                                    //   an owning application.
    RmsAttributesReadWrite,         // The partition can be read from and
                                    //   written to.
    RmsAttributesVerify             // The partition can only be mounted to read
                                    //   on-media Id or data verification.
};


/*++

Enumeration Name:

    RmsDriveSelect

Description:

    Specifies the drive selection policy.

--*/
typedef enum RmsDriveSelect {
    RmsDriveSelectUnknown,          // Drive selection policy unknown.
    RmsDriveSelectRandom,           // Select drives randomly.
    RmsDriveSelectLRU,              // Select the least recently used drive.
    RmsDriveSelectRoundRobin        // Select drives in round robin order.
};


/*++

Enumeration Name:

    RmsState

Description:

    Specifies the state of an Rms object.

--*/
typedef enum RmsState {
    RmsStateUnknown,                // State unknown.
    RmsStateEnabled,                // Normal access to the object is enabled.
    RmsStateDisabled,               // Normal access to the object is disabled.
    RmsStateError                   // Normal access disabled due to an error
                                    //   condition.
};


/*++

Enumeration Name:

    RmsMedia

Description:

    Specifies the type of RMS media.

--*/
typedef enum RmsMedia {
    RmsMediaUnknown =       0,          // Media type unknown.
    RmsMedia8mm     =       0x0001,     // 8mm tape.
    RmsMedia4mm     =       0x0002,     // 4mm tape.
    RmsMediaDLT     =       0x0004,     // DLT tape.
    RmsMediaOptical =       0x0008,     // All types of read-write (rewriteable) optical disks.
    RmsMediaMO35    =       0x0010,     // 3 1/2 inch magneto-optical. (not used)
    RmsMediaWORM    =       0x0020,     // 5 1/4 inch two-sided write-once optical.
    RmsMediaCDR     =       0x0040,     // 5 1/4 inch compact-disc, recordable.
    RmsMediaDVD     =       0x0080,     // All types of read-write (rewriteable) DVD.
    RmsMediaDisk    =       0x0100,     // Removable hard disk of various formats.
    RmsMediaFixed   =       0x0200,     // Fixed Hard disk.
    RmsMediaTape   =        0x0400      // Generic tape
};

#define     RMSMAXMEDIATYPES   12       // Number of enum's from RmsMedia


/*++

Enumeration Name:

    RmsDevice

Description:

    Specifies a type of RMS supported device.

--*/
typedef enum RmsDevice {
    RmsDeviceUnknown,               // unknown device type.
    RmsDeviceFixedDisk,             // Direct access fixed disk.
    RmsDeviceRemovableDisk,         // Direct access removable disk.
    RmsDeviceTape,                  // Sequential access tape.
    RmsDeviceCDROM,                 // Read only, CDROM.
    RmsDeviceWORM,                  // Write once, WORM.
    RmsDeviceOptical,               // Optical memory/disk.
    RmsDeviceChanger                // MediumChanger.
};


/*++

Enumeration Name:

    RmsMode

Description:

    Specifies the access mode supported by a drive or specified when
    mounting a Cartridge.

--*/
typedef enum RmsMode {
    RmsModeUnknown,                 // access mode supported unknown.
    RmsModeRead,                    // Read operations.
    RmsModeReadWrite,               // Read or write operations.
    RmsModeWriteOnly                // Write only operations.
};


/*++

Enumeration Name:

    RmsMediaSet

Description:

    Specifies the type of a Media Set.

--*/
typedef enum RmsMediaSet {
    RmsMediaSetUnknown = 1300,      // Unknown.
    RmsMediaSetFolder,              // Contains for other media sets.
    RmsMediaSetLibrary,             // Cartridges in the media set are accessible via
                                    //   robotic device.
    RmsMediaSetShelf,               // Cartridges are shelved locally, and
                                    //   accessible via human intervention.
    RmsMediaSetOffSite,             // Cartridges are stored at an off-site
                                    //   location, and are not directly
                                    //   accessible for mounting.
    RmsMediaSetNTMS,                // Cartridges are accessible through NTMS.
    RmsMediaSetLAST
};

/*++

Enumeration Name:

    RmsMediaManager

Description:

    Specifies the media manager that controls a resource.

--*/
typedef enum RmsMediaManager {
    RmsMediaManagerUnknown = 1400,      // Unknown.
    RmsMediaManagerNative,              // Resource managed by RMS (native).
    RmsMediaManagerNTMS,                // Resource managed by NTMS.
    RmsMediaManagerLAST
};

/*++

Enumeration Name:

    RmsCreate

Description:

    Specifies the create disposition for objects.

--*/
typedef enum RmsCreate {
    RmsCreateUnknown,
    RmsOpenExisting,                // Opens an existing object.
    RmsOpenAlways,                  // Opens an existing object, or creates a new one.
    RmsCreateNew                    // Creates a new object if it doesn't exists.
};

/*++

Enumeration Name:

    RmsOnMediaIdentifier

Description:

    Specifies the type on media identifier.

--*/
typedef enum RmsOnMediaIdentifier {
    RmsOnMediaIdentifierUnknown,
    RmsOnMediaIdentifierMTF,                // MTF Media Identifier
    RmsOnMediaIdentifierWIN32               // WIN32 Filesystem Identifier
};

////////////////////////////////////////////////////////////////////////////////////////
//
//  Rms structs
//

/*++

Structure Name:

    RMS_FILESYSTEM_INFO

Description:

    Structure used to specify on media file system information.

    NOTE:  This is a dup of the NTMS_FILESYSTEM_INFO struct.

--*/
typedef struct _RMS_FILESYSTEM_INFO {
    WCHAR FileSystemType[64];
    WCHAR VolumeName[256];
    DWORD SerialNumber;
} RMS_FILESYSTEM_INFO, *LP_RMS_FILESYSTEM_INFO;

////////////////////////////////////////////////////////////////////////////////////////
//
//  Rms defines
//
#define RMS_DUPLICATE_RECYCLEONERROR    0x00010000  // DuplicateCartridge option used to
                                                    // recyle a new cartridge if an error occurs.

#define RMS_STR_MAX_CARTRIDGE_INFO      128     // Max string len for Cartridge info
#define RMS_STR_MAX_CARTRIDGE_NAME       64     // Max string len for Cartridge Name
#define RMS_STR_MAX_EXTERNAL_LABEL       32     // Max string len for External Label
#define RMS_STR_MAX_MAIL_STOP            64     // Max string len for Mail Stop
#define RMS_STR_MAX_LENGTH              128     // Max string length of any string

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network

//
// Default object names
//

#define RMS_DEFAULT_FIXEDDRIVE_LIBRARY_NAME     OLESTR("Fixed Drive Library")
#define RMS_DEFAULT_FIXEDDRIVE_MEDIASET_NAME    OLESTR("Fixed Drive Media (Testing Only !!)")
#define RMS_DEFAULT_OPTICAL_LIBRARY_NAME        OLESTR("Optical Library")
#define RMS_DEFAULT_OPTICAL_MEDIASET_NAME       OLESTR("Optical Media")
#define RMS_DEFAULT_TAPE_LIBRARY_NAME           OLESTR("Tape Library")
#define RMS_DEFAULT_TAPE_MEDIASET_NAME          OLESTR("Tape Media")

#define RMS_UNDEFINED_STRING                    OLESTR("Uninitialized String")
#define RMS_NULL_STRING                         OLESTR("")

#define RMS_DIR_LEN                             256
#define RMS_TRACE_FILE_NAME                     OLESTR("rms.trc")
#define RMS_NTMS_REGISTRY_STRING                OLESTR("SYSTEM\\CurrentControlSet\\Services\\NtmsSvc")

// Currently, RMS Registry location points to same location of Engine parameters
//  keeping this literal enables moving RMS parameters to another key easily.
#define RMS_REGISTRY_STRING                     OLESTR("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_Server\\Parameters")

// Registry parameters (all parameters are string values in the registry)
#define RMS_PARAMETER_HARD_DRIVES_TO_USE        OLESTR("HardDrivesToUse")       // "ABCDEFG", if "" defaults to any volume with "RS", "RemoteStor", "Remote Stor"
#define RMS_PARAMETER_NTMS_SUPPORT              OLESTR("NTMSSupport")           // 1 | 0
#define RMS_PARAMETER_NEW_STYLE_IO              OLESTR("NewStyleIo")            // 1 | 0
#define RMS_PARAMETER_BLOCK_SIZE                OLESTR("BlockSize")             // Must be mod 512
#define RMS_PARAMETER_BUFFER_SIZE               OLESTR("BufferSize")            // Must be mod 512
#define RMS_PARAMETER_COPY_BUFFER_SIZE          OLESTR("MediaCopyBufferSize")   // Buffer size for media copy on FS-media like optical
#define RMS_PARAMETER_FORMAT_COMMAND            OLESTR("FormatCommand")         // Full pathname specifier to format command
#define RMS_PARAMETER_FORMAT_OPTIONS            OLESTR("FormatOptions")         // Format command options
#define RMS_PARAMETER_FORMAT_OPTIONS_ALT1       OLESTR("FormatOptionsAlt1")     // Format command options - alternate
#define RMS_PARAMETER_FORMAT_OPTIONS_ALT2       OLESTR("FormatOptionsAlt2")     // Format command options - second alternate
#define RMS_PARAMETER_FORMAT_WAIT_TIME          OLESTR("FormatWaitTime")        // Format time-out interval, in milliseconds
#define RMS_PARAMETER_TAPE                      OLESTR("Tape")                  // 1 | 0
#define RMS_PARAMETER_OPTICAL                   OLESTR("Optical")               // 1 | 0
#define RMS_PARAMETER_FIXED_DRIVE               OLESTR("FixedDrive")            // 1 | 0
#define RMS_PARAMETER_DVD                       OLESTR("DVD")                   // 1 | 0
#define RMS_PARAMETER_ADDITIONAL_TAPE           OLESTR("TapeTypesToSupport")   // Additional media types to support (REG_MULTI_SZ)
#define RMS_PARAMETER_DEFAULT_MEDIASET          OLESTR("DefaultMediaSet")       // The name of the media set to use for unspecified scratch media requests.
#define RMS_PARAMETER_MEDIA_TYPES_TO_EXCLUDE    OLESTR("MediaTypesToExclude")   // A delimited list of media types to exclude.  First char is delimiter.
#define RMS_PARAMETER_NOTIFICATION_WAIT_TIME    OLESTR("NotificationWaitTime")  // Milliseconds to wait for an object notification
#define RMS_PARAMETER_ALLOCATE_WAIT_TIME        OLESTR("AllocateWaitTime")      // Milliseconds to wait for a media allocation
#define RMS_PARAMETER_MOUNT_WAIT_TIME           OLESTR("MountWaitTime")         // Milliseconds to wait for a mount
#define RMS_PARAMETER_REQUEST_WAIT_TIME         OLESTR("RequestWaitTime")       // Milliseconds to wait for a request
#define RMS_PARAMETER_DISMOUNT_WAIT_TIME        OLESTR("DismountWaitTime")      // Milliseconds to wait before dismount
#define RMS_PARAMETER_AFTER_DISMOUNT_WAIT_TIME  OLESTR("AfterDismountWaitTime") // Milliseconds to wait after dismount
#define RMS_PARAMETER_AFTER_DISABLE_WAIT_TIME   OLESTR("AfterDisableWaitTime")  // Milliseconds to wait after disable
#define RMS_PARAMETER_SHORT_WAIT_TIME           OLESTR("ShortWaitTime")         // Milliseconds when asked to wait for short periods
#define RMS_PARAMETER_MEDIA_COPY_TOLERANCE      OLESTR("MediaCopyTolerance")    // Percent copy media can be shorter than original

// Default parameter values
#define RMS_DEFAULT_HARD_DRIVES_TO_USE          OLESTR("")
#define RMS_DEFAULT_NTMS_SUPPORT                TRUE
#define RMS_DEFAULT_NEW_STYLE_IO                TRUE
#define RMS_DEFAULT_BLOCK_SIZE                  1024
#define RMS_DEFAULT_BUFFER_SIZE                 (64*1024)
#define RMS_DEFAULT_FORMAT_COMMAND              OLESTR("%SystemRoot%\\System32\\format.com")
#define RMS_DEFAULT_FORMAT_OPTIONS              OLESTR("/fs:ntfs /force /q /x")
#define RMS_DEFAULT_FORMAT_OPTIONS_ALT1         OLESTR("/fs:ntfs /force /x")
#define RMS_DEFAULT_FORMAT_OPTIONS_ALT2         OLESTR("")
#define RMS_DEFAULT_FORMAT_WAIT_TIME            (20*60*1000)
#define RMS_DEFAULT_TAPE                        TRUE
#define RMS_DEFAULT_OPTICAL                     TRUE
#define RMS_DEFAULT_FIXED_DRIVE                 FALSE
#define RMS_DEFAULT_DVD                         FALSE
#define RMS_DEFAULT_MEDIASET                    OLESTR("")
#define RMS_DEFAULT_MEDIA_TYPES_TO_EXCLUDE      OLESTR("")
#define RMS_DEFAULT_NOTIFICATION_WAIT_TIME      (10000)
#define RMS_DEFAULT_ALLOCATE_WAIT_TIME          (3600000)
#define RMS_DEFAULT_MOUNT_WAIT_TIME             (14400000)
#define RMS_DEFAULT_REQUEST_WAIT_TIME           (3600000)
#define RMS_DEFAULT_DISMOUNT_WAIT_TIME          (5000)
#define RMS_DEFAULT_AFTER_DISMOUNT_WAIT_TIME    (1000)
#define RMS_DEFAULT_AFTER_DISABLE_WAIT_TIME     (5000)
#define RMS_DEFAULT_SHORT_WAIT_TIME             (1800000)
#define RMS_DEFAULT_MEDIA_COPY_TOLERANCE        (2)         // Percent copy media can be shorter than original

#define RMS_DEFAULT_DATA_BASE_FILE_NAME         OLESTR("RsSub.col")
#define RMS_NTMS_ROOT_MEDIA_POOL_NAME           OLESTR("Remote Storage")

#define RMS_NTMS_OBJECT_NAME                    OLESTR("NTMS")
#define RMS_NTMS_OBJECT_DESCRIPTION             OLESTR("NT Media Services")


//	RMS media status
#define		RMS_MEDIA_ENABLED			0x00000001
#define		RMS_MEDIA_ONLINE    		0x00000002
#define		RMS_MEDIA_AVAILABLE 		0x00000004

//	RMS Options - Flags literal
//		Keep the default for each flag value as zero, i.e. RM_NONE should always be the
//		default mask for all methods		
#define		RMS_NONE					0x0

#define		RMS_MOUNT_NO_BLOCK			0x00000001
#define		RMS_DISMOUNT_IMMEDIATE		0x00000002
#define     RMS_SHORT_TIMEOUT           0x00000004
#define     RMS_DISMOUNT_DEFERRED_ONLY  0x00000008
#define     RMS_ALLOCATE_NO_BLOCK       0x00000010
#define     RMS_USE_MOUNT_NO_DEADLOCK   0x00000020
#define     RMS_SERIALIZE_MOUNT         0x00000040
#define     RMS_FAIL_ALLOCATE_ON_SIZE   0x00000080

//
// CRmsSink helper class
//
class CRmsSink : 
    public IRmsSinkEveryEvent,
    public CComObjectRoot
{
    public:
        // constructor/destructor
            CRmsSink(void) {};

        BEGIN_COM_MAP(CRmsSink)
            COM_INTERFACE_ENTRY(IRmsSinkEveryEvent)
        END_COM_MAP()

        HRESULT FinalConstruct( void ) {
            HRESULT hr = S_OK;
            try {
                m_Cookie = 0;
                m_hReady = 0;
                WsbAffirmHr( CComObjectRoot::FinalConstruct( ) );
            } WsbCatch( hr );
            return hr;
        }

        void FinalRelease( void ) {
            DoUnadvise( );
            CComObjectRoot::FinalRelease( );
        }


    public: 
        STDMETHOD( ProcessObjectStatusChange ) ( IN BOOL isEnabled, IN LONG state, IN HRESULT statusCode ) {
            HRESULT hr = S_OK;
            UNREFERENCED_PARAMETER(statusCode);
            if( isEnabled ) {
                switch( state ) {
                case RmsServerStateStarting:
                case RmsServerStateStarted:
                case RmsServerStateInitializing:
                    break;
                default:
                    SetEvent( m_hReady );
                }
            } else {
                SetEvent( m_hReady );
            }
            return hr;
        }

        HRESULT Construct( IN IUnknown * pUnk ) {
            HRESULT hr = S_OK;
            try {
                WsbAffirmHr( FinalConstruct( ) );
                WsbAffirmHr( DoAdvise( pUnk ) );
            } WsbCatch( hr );
            return hr;
        }

        HRESULT DoAdvise( IN IUnknown * pUnk ) {
            HRESULT hr = S_OK;
            try {
#define         RmsQueryInterface( pUnk, interf, pNew )  (pUnk)->QueryInterface( IID_##interf, (void**) static_cast<interf **>( &pNew ) )
                WsbAffirmHr( RmsQueryInterface( pUnk, IRmsServer, m_pRms ) );
#if 0
                WCHAR buf[100];
                static int count = 0;
                swprintf( buf, L"CRmsSinkEvent%d", count++ );
#else
                WCHAR* buf = 0;
#endif
                m_hReady = CreateEvent( 0, TRUE, FALSE, buf );
                WsbAffirmStatus( ( 0 != m_hReady ) );
                WsbAffirmHr( AtlAdvise( pUnk, (IUnknown*)(IRmsSinkEveryEvent*)this, IID_IRmsSinkEveryEvent, &m_Cookie ) );
            } WsbCatch( hr );
            return hr;
        }

        HRESULT DoUnadvise( void ) {
            HRESULT hr = S_OK;
            if( m_hReady ) {
                CloseHandle( m_hReady );
                m_hReady = 0;
            }
            if( m_Cookie ) {
                hr = AtlUnadvise( m_pRms, IID_IRmsSinkEveryEvent, m_Cookie );
                m_Cookie = 0;
            }
            return hr;
        }

        HRESULT WaitForReady( void ) {
            HRESULT hr = S_OK;
            try {
                DWORD waitResult;
                HRESULT hrReady = m_pRms->IsReady( );
                switch( hrReady ) {
                case RMS_E_NOT_READY_SERVER_STARTING:
                case RMS_E_NOT_READY_SERVER_STARTED:
                case RMS_E_NOT_READY_SERVER_INITIALIZING:
                case RMS_E_NOT_READY_SERVER_LOCKED:
                    //
                    // We must wait, but the message queue must be pumped so that
                    // the COM Apartment model calls can be made in (like the
                    // call into the connection point)
                    //
                    while( TRUE ) {
                        waitResult = MsgWaitForMultipleObjects( 1, &m_hReady, FALSE, INFINITE, QS_ALLINPUT );
                        if( WAIT_OBJECT_0 == waitResult ) {
                            break;
                        } else {
                            MSG msg;
                            while( PeekMessage( &msg, 0, 0, 0, PM_REMOVE ) ) {
                                DispatchMessage( &msg );
                            }
                        }
                    };
                    WsbAffirmHr( m_pRms->IsReady( ) );
                    break;
                case S_OK:
                    break;
                default:
                    WsbThrow( hrReady );
                }
            } WsbCatch( hr );
            return hr;
        }

    private:
        CComPtr<IRmsServer>       m_pRms;
        DWORD                     m_Cookie;
        HANDLE                    m_hReady;
};

#endif // _RMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\mll.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Mll.h

Abstract:

    RemoteStorage Media Label Library defines

Author:

    Brian Dodd          [brian]         09-Jun-1997

Revision History:

--*/

#ifndef _MLL_H
#define _MLL_H

#include <ntmsmli.h>
#include <tchar.h>
#include "resource.h"

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifdef MLL_IMPL
#define MLL_API __declspec(dllexport)
#else
#define MLL_API __declspec(dllimport)
#endif

// Defines for media label identification
#define REMOTE_STORAGE_MLL_SOFTWARE_NAME         L"Remote Storage version 6.0"
#define REMOTE_STORAGE_MLL_SOFTWARE_NAME_SIZE    wcslen(REMOTE_STORAGE_MLL_SOFTWARE_NAME)

// API prototypes
MLL_API DWORD ClaimMediaLabel(const BYTE * const pBuffer,
                              const DWORD nBufferSize,
                              MediaLabelInfo * const pLabelInfo);

MLL_API DWORD MaxMediaLabel (DWORD * const pMaxSize);

#ifdef __cplusplus
}
#endif

#endif // _MLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rpguid.h ===
/*++

   (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpGuid.h

Abstract:

    Contains GUID definitions for filter

Environment:

    User and  Kernel mode

--*/
#ifndef _RPGUID_H_
#define _RPGUID_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//
// HSM vendor ID for Sakkara
// {12268890-64D1-11d0-A9B0-00A0248903EA}
//
DEFINE_GUID( RP_MSFT_VENDOR_ID, 0x12268890L, 0x64d1, 0x11d0,  0xa9, 0xb0, 
0x0,  0xa0, 0x24, 0x89, 0x3, 0xea);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rsevents.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

    rsevents.h

Abstract:

    This module defines names of events that are used to synchronize HSM components,
    which are located in different units.

Author:

    Ran Kalach (rankala)  4/5/00

--*/


#ifndef _RSEVENTS_
#define _RSEVENTS_


// State event parameters
#define     SYNC_STATE_EVENTS_NUM       3
#define     HSM_ENGINE_STATE_EVENT      OLESTR("HSM Engine State Event")
#define     HSM_FSA_STATE_EVENT         OLESTR("HSM Fsa State Event")
#define     HSM_IDB_STATE_EVENT         OLESTR("HSM Idb State Event")
#define     EVENT_WAIT_TIMEOUT          (10*60*1000)    // 10 minutes

// RSS backup name

// Note: The Backup/Snapshot writer string should be the same as the name written to the 
//       Registry for NTBackup exclude list (FilesNotToBackup value)
#define     RSS_BACKUP_NAME             OLESTR("Remote Storage")



#endif // _RSEVENTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rsstrdef.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    rsstrdef.h

Abstract:

    This module defines common string identifiers that are held in Wsb resources

Author:

    Ran Kalach (rankala)  3/23/00

--*/

#ifndef _RSSTRDEF_
#define _RSSTRDEF_

// Gloabl HSM string identifiers    (reserved range: 1024 - 2047)

#define IDS_HSM_SCHED_TASK_TITLE             1024
#define IDS_HSM_SCHED_COMMENT                1025

#endif // _RSSTRDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rsbuild.h ===
#ifndef _RSBUILD_H
#define _RSBUILD_H 

/*++

Copyright (c) 1997  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    rsbuild.h

Abstract:

    Include file to identify the code build 

Author:

    Cat Brant   [cbrant@avail.com]      09-OCT-1997

Revision History:

    Brian Dodd  [brian@avail.com]       20-Aug-1998
        Added Major, Minor macros

--*/

//
// These need to be update each time a build is released
//
#define RS_BUILD_NUMBER 611
#define RS_BUILD_REVISION 0


//
//
//
//  RS_BUILD_VERSION is a 32 bit value layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-------------------------------+-------------------------------+
//  |           Revision            |             Number            |
//  +-------------------------------+-------------------------------+
//
//  where
//
//      Revision - is the build revision number, or dot release.
//
//      Number   - is the build number
//
//
//  The version is typically displayed as: Number.Revision
//
//


//
//  Return the build version
//

#define RS_BUILD_VERSION ((RS_BUILD_REVISION << 16) | RS_BUILD_NUMBER)


//
//  Return the revision, and number
//

#define RS_BUILD_REV(ver)  ((ver) >> 16)
#define RS_BUILD_NUM(ver)  ((ver) & 0x0000ffff)


//
//  Return the static build version as a string
//

#define RS_STRINGIZE(a) OLESTR(#a)
#define RS_BUILD_VERSION_STR(num, rev) \
    ((0 == rev) ? RS_STRINGIZE(num) : (RS_STRINGIZE(num)L"."RS_STRINGIZE(rev)))

#define RS_BUILD_VERSION_STRING (RS_BUILD_VERSION_STR(RS_BUILD_NUMBER, RS_BUILD_REVISION))


//
//  Inline to return dyncamic build version as a string
//

inline WCHAR * RsBuildVersionAsString(ULONG ver) {
    static WCHAR string[16];

    if (RS_BUILD_REV(ver) > 0) {
        swprintf(string, L"%d.%d", RS_BUILD_NUM(ver), RS_BUILD_REV(ver));
    }
    else {
        swprintf(string, L"%d", RS_BUILD_NUM(ver));
    }

    return string;
}


//
//  Persistency Files versions
//
#define  FSA_WIN2K_DB_VERSION           1
#define  ENGINE_WIN2K_DB_VERSION        2
#define  RMS_WIN2K_DB_VERSION           2

#define  FSA_CURRENT_DB_VERSION         1
#define  ENGINE_CURRENT_DB_VERSION      3

#endif // _RSBUILD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rpio.h ===
/*++

   (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpIo.h

Abstract:

    Contains structure definitions for the interface between RsFilter and the Fsa

Author:

    Rick Winter

Environment:

    Kernel mode

Revision History:

	X-10	244816		Michael C. Johnson		 5-Dec-2000
		Change device name from \Device\RsFilter to \FileSystem\Filters\RsFilter

--*/


#define RS_FILTER_DEVICE_NAME       L"\\FileSystem\\Filters\\RsFilter"
#define RS_FILTER_INTERNAL_SYM_LINK L"\\??\\RsFilter"
#define RS_FILTER_SYM_LINK          L"\\\\.\\RsFilter"
#define USER_NAME_LEN      128


// The following messages pass between the WIN32 component (FsAgent)
// and the File System Filter component (RsFilter.sys) via FSCTL calls.
//
// (See ntioapi.h for FSCTL defines FSCTL_HSM_MSG and FSCTL_HSM_DATA)
// 

//
// FSCTL_HSM_MSG
//
// Events are passed to user mode by completing the IRP for a RP_GET_REQUEST with the output buffer 
// containing the event information.  The FsAgent issues several of these and waits for any of them to complete.
//
#define RP_GET_REQUEST           1   

//
// FSCTL_HSM_DATA
//
//
// Signals the completion of the data transfer for a recall.
//
#define RP_RECALL_COMPLETE       3  

//
// FSCTL_HSM_DATA
//
//
// Tells the filter to suspend recall events.  Any file accesses that require offline data will return error.
//
#define RP_SUSPEND_NEW_RECALLS   4  

//
// FSCTL_HSM_DATA
//
//
// Tells the filter to resume recall events
//
#define RP_ALLOW_NEW_RECALLS     5  

//
// FSCTL_HSM_DATA
//
//
// Cancel all active recall requests.  Any pending file io that requires offline data will return error.
//
#define RP_CANCEL_ALL_RECALLS    6  

//
// FSCTL_HSM_DATA
//
//
// Cancel all pending device io requests (RP_GET_REQUEST).
//
#define RP_CANCEL_ALL_DEVICEIO   7  

//
// FSCTL_HSM_DATA
//
//
// Returns variable size information for a recall request such as the file path and user information needed for recall notification.
//
#define RP_GET_RECALL_INFO       8  

//
// FSCTL_HSM_DATA
//
//
// Obosolete
//
#define RP_SET_ADMIN_SID         9  

//
// FSCTL_HSM_DATA
//
//
//  Passes recall data for a portion of a file.  The data will be written to the file or used to complete a read request, depending
//  on the type of recall.
//
#define RP_PARTIAL_DATA          10 

//
// FSCTL_HSM_MSG
//
//
// Returns TRUE if a given file is currently memory mapped.
//
#define RP_CHECK_HANDLE          11 



//
// The following events are sent by the filter to the FSA (by completion of a RP_GET_REQUEST)
//

//
// A file was opened for either a normal or FILE_OPEN_NO_RECALL access
//
#define RP_OPEN_FILE             20    
//
// Offline data is required for this file.  For a normal open this will initiate transfer of the complete file sequentially.  
// If the file was opened with FILE_OPEN_NO_RECALL this indicates the amount of data required and what portion of the file.
//
#define RP_RECALL_FILE           21    
//
// Not used
//
#define RP_CLOSE_FILE            22    
//
// A request for a recall was cancelled.  The data is no longer required.
//
#define RP_CANCEL_RECALL         23    
//
// A validate job should be run because some application other than HSM has written HSM reparse point information.
//
#define RP_RUN_VALIDATE          24    
//
// Not used
//
#define RP_START_NOTIFY          25    
//
// Not used
//
#define RP_END_NOTIFY            26    

//
// Waiting for a recall
//
#define RP_RECALL_WAITING        27    


//
// This information is returned information output buffer for a FSCTL messages issued by the FSA
//

//
// RP_GET_REQUEST
//
// File open event.  Sent when a placeholder is opened or when data is needed for a part of a file opened with FILE_OPEN_NO_RECALL
// Data transfer does not start until _RP_NT_RECALL_REQUEST is sent.
//
// For normal opens this sets up the recall notification information.
//
typedef struct _RP_NT_OPEN_REQ {
   LUID               userAuthentication;           /* Unique to this instance of this user */
   LUID               userInstance;
   LUID               tokenSourceId;
   LARGE_INTEGER      offset;                       /* Offset of data in the target file. */
   LARGE_INTEGER      size;                         /* Number of bytes needed */
   //
   // If the file was opened by ID then it is either the file Id or an object ID.  It is assumed
   // that one or the other will not be NULL.
   //
   LONGLONG           fileId;                        
   LONGLONG           objIdHi;                        
   LONGLONG           objIdLo;
   ULONGLONG          filterId;                     /* Unique ID  (lives while file is open) */
   ULONG              localProc;                    /* True if recall is from local process */
   ULONG              userInfoLen;                  /* Size of SID info in bytes */
   ULONG              isAdmin;                      /* TRUE = user is admin */
   ULONG              nameLen;                      /* Size of file path\name (in CHARacters)*/
   ULONG              options;                      /* Create options */
   ULONG              action;                       /* RP_OPEN or RP_READ_NO_RECALL */
   ULONG              serial;                       /* Serial number of volume */
   RP_DATA            eaData;                       /* PH info from file */
   CHAR               tokenSource[TOKEN_SOURCE_LENGTH]; 
} RP_NT_OPEN_REQ, *PRP_NT_OPEN_REQ;

//
// Not used
//
typedef struct _RP_NT_CLOSE_REQ {
   ULONGLONG          filterId;                     // Unique ID  (lives while file is open) 
   BOOLEAN            wasModified;                  // TRUE if the file was modified by the user.
} RP_NT_CLOSE_REQ, *PRP_NT_CLOSE_REQ;

//
// RP_GET_REQUEST
//
//
// Recall request - for previously opened file.  This initiates the data transfer from secondary
// storage to the file.
//
typedef struct _RP_NT_RECALL_REQ {
   ULONGLONG          filterId;                     // Unique ID passed to FSA by open request. 
   ULONGLONG          offset;                       // Offset to recall from
   ULONGLONG          length;                       // Length of recall
   ULONG              threadId;                     // id of thread causing recall
} RP_NT_RECALL_REQ, *PRP_NT_RECALL_REQ;

//
// Not used - Start recall notification for this user.
//
typedef struct _RP_NT_START_NOTIFY {
   ULONGLONG          filterId;                     // Unique ID passed to FSA by open request. 
} RP_NT_START_NOTIFY, *PRP_NT_START_NOTIFY;

// End recall notification for this user.
//
typedef struct _RP_NT_END_NOTIFY {
   ULONGLONG          filterId;                     // Unique ID passed to FSA by open request. 
} RP_NT_END_NOTIFY, *PRP_NT_END_NOTIFY;

//
// RP_RECALL_COMPLETE
//
// Recall completion information.
//
typedef struct _RP_NT_RECALL_REP {
   ULONGLONG        filterId;                   // Unique ID 
   BOOLEAN          recallCompleted;            // TRUE if data has been transferred - false if open processing complete
   ULONG            actionFlags;                // See below
} RP_NT_RECALL_REP, *PRP_NT_RECALL_REP;

//
// Action flags for recall completion 
//
#define RP_RECALL_ACTION_TRUNCATE   1           // Truncate on close - **** Not currently implemented ****

//
// RP_PARTIAL_DATA 
//
// Partial data recall reply.  Used by both normal recalls and FILE_OPEN_NO_RECALL to transfer some
// or all of the data requested.  The filter knows (by the id) what to do with the data.
//
typedef struct _RP_NT_PARTIAL_REP {
   ULONGLONG    filterId;                     // Unique ID 
   ULONG        bytesRead;                    // Number of bytes read (partial recalls) 
   ULONGLONG    byteOffset;                   // Offset of this data chunk
   ULONG        offsetToData;                 // Offset to the data - must be aligned for non-cached writes
} RP_NT_PARTIAL_REP, *PRP_NT_PARTIAL_REP;

//
// RP_GET_RECALL_INFO
//
// The following message is used to get the recall information that is
// variable in size.  The offset in the structure for userToken marks the
// beginning of the SID info.  After the SID the UNICODE file name can be
// found.  The size of the SID and file name is returned on the recall
// request.  Note that the size of the file path\name is in CHARacters.
// Since these are UNICODE CHARacters the actual buffer size in bytes is
// 2 times the file name length.

typedef struct _RP_NT_INFO_REQ {
   ULONGLONG  filterId;               // Unique ID 
   LONGLONG   fileId;                 // File ID
   CHAR       userToken;              // Actual size varies 
   CHAR       unicodeName;            // Actual size varies 
} RP_NT_INFO_REQ, *PRP_NT_INFO_REQ;

typedef struct _RP_NT_SET_SID {
   CHAR   adminSid;               // Actual size varies 
} RP_NT_SET_SID, *PRP_NT_SET_SID;


//
// RP_GET_REQUEST
//
// Recall cancelled message.
// Sent when the Irp for a pending recall is cancelled.
// No reply expected.
//
typedef struct _RP_NT_RECALL_CANCEL_REQ {
   ULONGLONG  filterId;                     /* Unique ID from original recall request */
} RP_NT_RECALL_CANCEL_REQ, *PRP_NT_RECALL_CANCEL_REQ;

//
// RP_GET_RECALL_INFO
//
// Returns TRUE or FALSE based on check if file is memory mapped
//
typedef struct _RP_CHECK_HANDLE_REP {
   BOOLEAN      canTruncate;
} RP_CHECK_HANDLE_REP, *PRP_CHECK_HANDLE_REP;


#define RP_MAX_MSG   1024  /* Max data size */

/* A pad to set the union size */
typedef struct _RP_NT_MSG_PAD {
   CHAR     padd[RP_MAX_MSG];
} RP_NT_MSG_PAD, *PRP_NT_MSG_PAD;

/* Union of possible commands */

typedef union _RP_MSG_UN {
   RP_NT_OPEN_REQ          oReq;
   RP_NT_CLOSE_REQ         clReq;
   RP_NT_START_NOTIFY      snReq;
   RP_NT_END_NOTIFY        enReq;
   RP_NT_RECALL_REQ        rReq;
   RP_NT_RECALL_REP        rRep;
   RP_NT_PARTIAL_REP       pRep;
   RP_NT_INFO_REQ          riReq;
   RP_NT_SET_SID           sReq;
   RP_NT_RECALL_CANCEL_REQ cReq;
   RP_CHECK_HANDLE_REP     hRep;
   RP_NT_MSG_PAD           pad;
} RP_MSG_UN, *PRP_MSG_UN;

typedef struct _RP_CMD {
   ULONG        command;    /* Requested function */
   ULONG        status;     /* Result code */
} RP_CMD, *PRP_CMD;


typedef struct _RP_MSG {
   RP_CMD      inout;
   RP_MSG_UN   msg;
} RP_MSG, *PRP_MSG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rslimits.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    rslimits.h

Abstract:

    This module defines the limits for various configurable parameters in HSM.
    These definitions should be used by:
    1) The UI
    2) The CLI
    3) The corresponding implementing objects

Author:

    Ran Kalach (rankala)  3/6/00

--*/

#ifndef _RSLIMITS_
#define _RSLIMITS_

#define HSMADMIN_DEFAULT_MINSIZE        12
#define HSMADMIN_DEFAULT_FREESPACE      5
#define HSMADMIN_DEFAULT_INACTIVITY     180

#define HSMADMIN_MIN_MINSIZE            2
#define HSMADMIN_MAX_MINSIZE            32000

#define HSMADMIN_MIN_FREESPACE          0
#define HSMADMIN_MAX_FREESPACE          99

#define HSMADMIN_MIN_INACTIVITY         0
#define HSMADMIN_MAX_INACTIVITY         999

#define HSMADMIN_MIN_COPY_SETS          0
#define HSMADMIN_MAX_COPY_SETS          3

#define HSMADMIN_MIN_RECALL_LIMIT       1
#define HSMADMIN_MIN_CONCURRENT_TASKS   1

#define HSMADMIN_MAX_VOLUMES        512 // This ought to be plenty

#endif // _RSLIMITS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\task.h ===
#ifndef _TASK_
#define _TASK_

// task.h
//
// This header file collects up all the task manager and related objects
// and common function definitions. The COM objects are available in
// TASK.DLL.

// COM Interface & LibraryDefintions
//#include "tskdef.h"
#include "tskdef.h"
#include "tskint.h"
#include "tsklib.h"

// Common Functions
#include "tsktrace.h"

#endif // _TASK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rss_hash.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    rss_hash.hxx

Abstract:

    Template for a hash table class.

Author:

    Ran Kalach

Revision History:

    04/22/2002  rankala     Copying from vss project nt\drivers\storage\volsnap\vss\server\inc\vs_hash.hxx
	06/03/2000	aoltean		Porting it from ATL code in order to add string comparison

--*/


#ifndef _RSSHASH_
#define _RSSHASH_


////////////////////////////////////////////////////////////////////////////////////////
//  Utilities
//

inline BOOL RssHashAreKeysEqual( const LPCWSTR& lhK, const LPCWSTR& rhK ) 
{ 
    return (::wcscmp(lhK, rhK) == 0); 
}

inline BOOL RssHashAreKeysEqual( const LPWSTR& lhK, const LPWSTR& rhK ) 
{ 
    return (::wcscmp(lhK, rhK) == 0); 
}

template < class KeyType >
inline BOOL RssHashAreKeysEqual( const KeyType& lhK, const KeyType& rhK ) 
{ 
    return lhK == rhK; 
}



////////////////////////////////////////////////////////////////////////////////////////
//  Definitions
//

/*++

Class:

    CRssSimpleMap

Description:

    Intended for small number of simple types or pointers. 
    Adapted from the ATL class to work with strings also.

--*/

template <class TKey, class TVal>
class CRssSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CRssSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CRssSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;

		// Call destructors in all cases (Bug 470439)
		m_aKey[nIndex].~TKey();
        m_aVal[nIndex].~TVal();
		if(nIndex != (m_nSize - 1))
		{
			memmove((void*)(m_aKey + nIndex), (void*)(m_aKey + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)(m_aVal + nIndex), (void*)(m_aVal + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aKey != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
			{
				m_aKey[i].~TKey();
				m_aVal[i].~TVal();
			}
			free(m_aKey);
			m_aKey = NULL;
		}
		if(m_aVal != NULL)
		{
			free(m_aVal);
			m_aVal = NULL;
		}

		m_nSize = 0;
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation

	template <typename T>
	class Wrapper
	{
	public:
		Wrapper(T& _t) : t(_t)
		{
		}
		template <typename _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		template <typename _Ty>
        void operator delete(void * /*pMem*/, _Ty* /*p*/)
        {
        }

		T t;
	};
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(m_aKey + nIndex) Wrapper<TKey>(key);
		new(m_aVal + nIndex) Wrapper<TVal>(val);
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
            // [aoltean] Comparing strings also
            if(::RssHashAreKeysEqual(m_aKey[i], key))
				return i;
		}
		return -1;  // not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
            // [aoltean] Comparing strings also
			if(::RssHashAreKeysEqual(m_aVal[i], val))
				return i;
		}
		return -1;  // not found
	}
};


#endif  // _RSSHASH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\rss_cs.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    rss_cs.hxx

Abstract:

    CS wrapper class.

Author:

    Ran Kalach

Revision History:

    04/22/2002  rankala     Copying with some modifications from vss project nt\drivers\storage\volsnap\vss\server\inc\vs_types.hxx

--*/


#ifndef _RSSCS_
#define _RSSCS_

class CRssCriticalSection
{
    CRssCriticalSection(const CRssCriticalSection&);

public:
    // Creates and initializes the critical section
    CRssCriticalSection(
        IN  BOOL bThrowOnError = TRUE
        ):
        m_bInitialized(FALSE),
        m_lLockCount(0),
        m_bThrowOnError(bThrowOnError)
    {
        HRESULT hr = S_OK;

        try
        {
            // May throw STATUS_NO_MEMORY if memory is low.
            WsbAffirmStatus(InitializeCriticalSectionAndSpinCount(&m_sec, 1000));
        }
        WsbCatch(hr)

        m_bInitialized = SUCCEEDED(hr);
    }

    // Destroys the critical section
    ~CRssCriticalSection()
    {
        if (m_bInitialized)
            DeleteCriticalSection(&m_sec);
    }


    // Locks the critical section
    void Lock() 
    {
        if (!m_bInitialized)
            if (m_bThrowOnError)
                WsbThrow( E_OUTOFMEMORY );

        EnterCriticalSection(&m_sec);

        InterlockedIncrement((LPLONG)&m_lLockCount);
    }

    // Unlocks the critical section
    void Unlock()
    {
        if (!m_bInitialized)
            if (m_bThrowOnError)
                WsbThrow( E_OUTOFMEMORY );

        InterlockedDecrement((LPLONG) &m_lLockCount);
        LeaveCriticalSection(&m_sec);
    }

    BOOL IsLocked() const { return (m_lLockCount > 0); };

    BOOL IsInitialized() const { return m_bInitialized; };

private:
    CRITICAL_SECTION    m_sec;
    BOOL                m_bInitialized;
    BOOL                m_bThrowOnError;
    LONG volatile       m_lLockCount;
};


#endif  // _RSSCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\tsktrace.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    tskTrace.h

Abstract:

    This header file defines the part of the task manager code that is
    responsible for tracing task manager specific parameters.

Author:

    Cat Brant       [cbrant]   7-Det-1996

Revision History:

--*/

#ifndef _TSKTRACE_H_
#define _TSKTRACE_H_

// Helper Functions
//
// NOTE: Be careful with some of these helper functions, since they
// use static memory and a second call to the function will overwrite
// the results of the first call to the function. 
extern const OLECHAR* TmFsaRequestActionAsString(FSA_REQUEST_ACTION requestAction);
extern const OLECHAR* TmFsaResultActionAsString(FSA_RESULT_ACTION resultAction);

#endif // _TSKTRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsb.h ===
#ifndef _WSB_H
#define _WSB_H

/*++

Copyright (c) 1996 Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsb.h

Abstract:

    This module defines very basic error results, as well as
    helper macros for exception handling.

Author:

    Chuck Bardeen   [cbardeen]      29-Oct-1996

Revision History:

    Christopher J. Timmes   [ctimmes]   24-Jun-1997
        - added new header file 'wsbfile.h' to list of includes.  This is the header
          for the new common file manipulation routines source file (wsbfile.cpp).

--*/

// First Wsb header that should be included. Sets up special initialization.
#include "wsbfirst.h"

#include "wsbint.h"
#include "wsblib.h"

#include "wsbtrak.h"
#include "wsbassrt.h"
#include "wsbbstrg.h"
#include "wsbcltbl.h"
#include "wsberror.h"
#include "wsbfile.h"
#include "wsbport.h"
#include "wsbpstbl.h"
#include "wsbpstrg.h"
#include "wsbregty.h"
#include "wsbtrace.h"
#include "wsbvar.h"
#include "wsbserv.h"


// Generic Wsb header that should always be last
#include "wsbgen.h"

#endif // _WSB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\tskmgr.h ===
// TskMgr.h : Declaration of the CTskMgr

#include "resource.h"       // main symbols
#include "wsb.h"            // Wsb structure definitions


#ifndef __TSKMGR__
#define __TSKMGR__

#define HsmWorkQueueArrayBumpSize  10

/////////////////////////////////////////////////////////////////////////////
// task

typedef struct _HSM_WORK_QUEUES {
    //
    // Note: First 2 fields (sessionId and pSession)
    // are not used for demand recall queues. 
    //
    GUID                    sessionId;      // GUID of the session
    CComPtr<IHsmSession>    pSession;       // Session interface
    CComPtr<IHsmWorkQueue>    pWorkQueue;   // WorkQueue for the session
    CComPtr<IHsmRecallQueue>  pRecallQueue; // Demand RecallQueue
    HSM_WORK_QUEUE_TYPE     queueType;      // Type of queue
    HSM_WORK_QUEUE_STATE    queueState;     // State of the queue
    FILETIME                birthDate;      // Birth of queue
} HSM_WORK_QUEUES, *PHSM_WORK_QUEUES;

typedef struct {
    HSM_WORK_QUEUE_TYPE  Type;
    ULONG                MaxActiveAllowed;
    ULONG                NumActive;
} HSM_WORK_QUEUE_TYPE_INFO, *PHSM_WORK_QUEUE_TYPE_INFO;

class CHsmTskMgr :
    public CComObjectRoot,
    public IHsmFsaTskMgr,
    public CComCoClass<CHsmTskMgr,&CLSID_CHsmTskMgr>
{
public:
    CHsmTskMgr() {}
BEGIN_COM_MAP(CHsmTskMgr)
    COM_INTERFACE_ENTRY(IHsmFsaTskMgr)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_CHsmTskMgr )

// IHsmFsaTskMgr
public:
    STDMETHOD(ContactOk)( void );
    STDMETHOD(DoFsaWork)(IFsaPostIt *fsaWorkItem );
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);
    STDMETHOD(Init)(IUnknown *pServer);

    STDMETHOD(WorkQueueDone)(IHsmSession *pSession, HSM_WORK_QUEUE_TYPE type, GUID *pMediaId);

private:
    STDMETHOD(IncreaseWorkQueueArraySize)(ULONG numToAdd);
    STDMETHOD(StartQueues)( void );
    STDMETHOD(StartFsaQueueType)(HSM_WORK_QUEUE_TYPE type);
    STDMETHOD(FindOldestQueue)(HSM_WORK_QUEUE_TYPE type, ULONG *pIndex);
    STDMETHOD(EnsureQueueForFsaSession)(IHsmSession *pSession, FSA_REQUEST_ACTION fsaAction, IHsmWorkQueue **ppWorkQueue, BOOL *bCreated);
    STDMETHOD(AddToRecallQueueForFsaSession)(IHsmSession *pSession, IHsmRecallQueue **ppWorkQueue, BOOL *bCreated, GUID *pMediaId, GUID *pBagId, LONGLONG dataSetStart, IFsaPostIt *pFsaWorkItem);
    STDMETHOD(AddWorkQueueElement)(IHsmSession *pSession, HSM_WORK_QUEUE_TYPE type, ULONG *pIndex);
    STDMETHOD(FindWorkQueueElement)(IHsmSession *pSession, HSM_WORK_QUEUE_TYPE type, ULONG *pIndex, GUID *pMediaId);
    STDMETHOD(FindRecallQueueElement(IN IHsmSession *pSession, IN GUID  *pMediaId,  OUT IHsmRecallQueue **ppWorkQueue, OUT BOOL *bCreated));
    STDMETHOD(GetWorkQueueElement)(ULONG index, IHsmSession **ppSession, IHsmWorkQueue **ppWorkQueue, HSM_WORK_QUEUE_TYPE *pType, HSM_WORK_QUEUE_STATE *pState, FILETIME *pBirthDate);
    STDMETHOD(SetWorkQueueElement)(ULONG index, IHsmSession *pSession, IHsmWorkQueue *pWorkQueue, HSM_WORK_QUEUE_TYPE type, HSM_WORK_QUEUE_STATE state, FILETIME birthdate);
    STDMETHOD(GetRecallQueueElement)(ULONG index, IHsmRecallQueue **ppWorkQueue, HSM_WORK_QUEUE_STATE *pState, FILETIME *pBirthDate);
    STDMETHOD(SetRecallQueueElement)(ULONG index, IHsmRecallQueue *pWorkQueue,  HSM_WORK_QUEUE_TYPE queueType, HSM_WORK_QUEUE_STATE state, FILETIME birthdate);
    STDMETHOD(RemoveWorkQueueElement)(ULONG index);

    STDMETHOD(FindRecallMediaToUse)(IN IFsaPostIt *pFsaWorkItem, OUT GUID *pMediaToUse, OUT GUID *pBagId, OUT LONGLONG *pDataSetStart);

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

    // We want the next two pointers (to the Hsm Server) to be weak
    // references and **not** add ref the server.  This is so shutting
    // down the server really works.
//  CComPtr<IHsmServer>             m_pServer;              // Server owning TskMgr
//  CComPtr<IWsbCreateLocalObject>  m_pHsmServerCreate;     // Server object creater
    IHsmServer              *m_pServer;                     // Server owning TskMgr
    IWsbCreateLocalObject   *m_pHsmServerCreate;            // Server object creater

    PHSM_WORK_QUEUES                m_pWorkQueues;          // Work delegated by TskMgr
    ULONG                           m_NumWorkQueues;        // Number of work queues

    CRITICAL_SECTION                m_WorkQueueLock;        // Protect array access and update
                                                            // from multiple thread access
    CRITICAL_SECTION                m_CurrentRunningLock;   // Protect starting queues
                                                            // from multiple thread access
    CRITICAL_SECTION                m_CreateWorkQueueLock;  // Protect creating queues
                                                            // from multiple thread access
    BOOL                            m_bCritSecCreated;      // Indicates whether all CritSec were
                                                            // created successfully (for cleanup)
    PHSM_WORK_QUEUE_TYPE_INFO       m_pWorkQueueTypeInfo;   // Info about work queue types
    ULONG                           m_nWorkQueueTypes;      // Number of work queue types
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbcltbl.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbCollectable.h

Abstract:

    Abstract classes that provide methods that allow the derived objects to
    be stored in collections.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "WsbPstbl.h"

#ifndef _WSBCLTBL_
#define _WSBCLTBL_


/*++

Class Name:
    
    CWsbObject

Class Description:

    Base class for collectable objects that are persistable
    to/from a stream.

--*/

class WSB_EXPORT CWsbObject : 
    public CWsbPersistStream,
    public IWsbCollectable,
    public IWsbTestable
{
// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    STDMETHOD(IsEqual)(IUnknown* pCollectable);
};

#define WSB_FROM_CWSBOBJECT \
    STDMETHOD(IsEqual)(IUnknown* pObject) \
    {return(CWsbObject::IsEqual(pObject));}

/*++

Class Name:
    
    CWsbCollectable

Class Description:

    Base class for collectable objects that are persistable
    to/from stream, storage, or file.  CWsbObject should be used instead of
    this object unless storage and/or file persistence is absolutely necessary!
    If the object is persisted as part of a parent
    object, then only the parent object (or its parent) needs to support
    persistence to storage and/or file.

--*/

class WSB_EXPORT CWsbCollectable : 
    public CWsbPersistable,
    public IWsbCollectable,
    public IWsbTestable
{
// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    STDMETHOD(IsEqual)(IUnknown* pCollectable);
};

#define WSB_FROM_CWSBCOLLECTABLE \
    STDMETHOD(IsEqual)(IUnknown* pCollectable) \
    {return(CWsbCollectable::IsEqual(pCollectable));}

#endif // _WSBCLTBL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbassrt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbassrt.h

Abstract:

    This header file defines the part of the platform code that is
    responsible for the low level error handling used by all other
    modules.

Author:

    Rohde Wakefield    [rohde]   23-Oct-1996

Revision History:

    Brian Dodd         [brian]    6-Dec-1996
        added WsbAssertStatus, WsbAssertNoError, WsbAssertHandle
        added WsbAffirmStatus, WsbAffirmNoError, WsbAffirmHandle
    Michael Lotz       [lotz]     3-Mar-1997
        added WsbAffirmNtStatus
    Cat Brant          [cbrant]   10-Feb-1998
        added WsbAssertNtStatus

--*/

#include "stdio.h"
#include "crtdbg.h"

#include "wsbtrace.h"

#ifndef _WSBASSRT_
#define _WSBASSRT_

//
// The following macros should be used when dealing with
// many HRESULT return values in C++ exception handling.

/*++

Macro Name:

    WsbAssert

Macro Description:

    Should be used for checking conditions that if seen
    would be considered coding errors (i.e. the conditions should
    never occur).

Arguments:

    cond - A boolean expression for the condition to check.

    hr   - The result parameter to throw if the condition is false.

--*/

#define WsbAssert(cond, hr)         \
    if (!(cond)) {                  \
        WsbLogEvent(WSB_MESSAGE_PROGRAM_ASSERT, 0, NULL, WsbHrAsString(hr), NULL); \
        _ASSERTE(cond);             \
        WsbThrow(hr);               \
    }


/*++

Macro Name:

    WsbThrow

Macro Description:

    Throw the argument.

Arguments:

    hr - Parameter to throw.

--*/

#ifdef WSB_TRACE_IS
#define WsbThrow(hr)                                            \
    {                                                           \
        WsbTrace(OLESTR("WsbThrow <%hs>, <%d>, hr = <%ls>.\n"), __FILE__, __LINE__, WsbHrAsString(hr)); \
        throw((HRESULT)hr); \
    }
#else
#define WsbThrow(hr)                    throw((HRESULT)hr)
#endif


/*++

Macro Name:

    WsbAffirm

Macro Description:

    Should be used for checking conditions that are
    considered errors to the function (and the function should not
    continue), but are the result of errors that are allowable (although
    potentially rare). This function has failed, but the caller needs to
    determine whether this is a fatal problem, a problem that needs to
    be logged an worked around, or whether it can handle the problem.

Arguments:

    cond - A boolean expression for the condition to check.

    hr   - The result parameter to throw if the condition is false.

--*/

#define WsbAffirm(cond, hr)             if (!(cond)) WsbThrow(hr)

/*++

Macro Name:

    WsbAffirmHr

Macro Description:

   
    Similar to WsbAffirm(), but is used to wrap functions
    that return an HRESULT (normally COM methods).
   
    A sample use is:
   
        HRESULT hr = S_OK;
   
        try {
   
            WsbAssert(0 != pUnk);
            
            WsbAffirmHr(CoCreateInstance(...));
            
   
        } WsbCatch(hr)
   
        return (hr);
   

Arguments:

    hr  - Result from a function call.

--*/


#define WsbAffirmHr(hr)                 \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        WsbAffirm(SUCCEEDED(lHr), lHr); \
    }

#define WsbAffirmHrOk(hr)               \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        WsbAffirm(S_OK == lHr, lHr);    \
    }

/*++

Macro Name:

    WsbAssertHr

Macro Description:

    Similar to WsbAssert(), but is used to wrap functions
    that return an HRESULT (normally COM methods).

Arguments:

    hr  - Result from a function call.

--*/

#define WsbAssertHr(hr)                 \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        WsbAssert(SUCCEEDED(lHr), lHr); \
    }

/*++

Macro Name:

    WsbAssertHrOk

Macro Description:

    Checks that a function result is S_OK.

Arguments:

    hr  - Result from a function call.

--*/

#define WsbAssertHrOk(hr)               \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        WsbAssert(S_OK == lHr, lHr);    \
    }


/*++

Macro Name:

    WsbAssertStatus

Macro Description:

    Similar to WsbAssert(), but is used to wrap Win32 functions
    that return a BOOL status.

    This macro checks the status, and if FALSE, gets the
    last error and converts it to HRESULT, then asserts
    the result.

Arguments:

    status  - a BOOL result from a function call.

See Also:

    WsbAffirmStatus

--*/

#define WsbAssertStatus(status)         \
    {                                   \
        BOOL bStatus;                   \
        bStatus = (status);             \
        if (!bStatus) {                 \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAssertWin32

Macro Description:

    Similar to WsbAssert(), but is used to wrap Win32 functions
    that return a Win32 status.

    This macro checks the status, and if not ERROR_SUCCESS, 
    converts it to HRESULT, then asserts the result.

Arguments:

    status  - a Win32 result from a function call.

See Also:

    WsbAffirmStatus

--*/

#define WsbAssertWin32( status )        \
    {                                   \
        LONG lStatus;                   \
        lStatus = (status);             \
        if ( lStatus != ERROR_SUCCESS ) {               \
            HRESULT lHr = HRESULT_FROM_WIN32( lStatus );    \
            WsbAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAssertNoError

Macro Description:

    Similar to WsbAssert(), but is used to wrap Win32 functions
    that return a DWORD error code.  These functions return NO_ERROR
    if the function completed successfully.

    This macro checks the return value and if an error condition
    is detected, the error is converted to an HRESULT, then asserts
    the result.

Arguments:

    err - a DWORD result from a function call.

See Also:

    WsbAffirmNoError

--*/

#define WsbAssertNoError(retval)        \
    {                                   \
        DWORD dwErr;                    \
        dwErr = (retval);               \
        if (dwErr != NO_ERROR) {        \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAssertHandle

Macro Description:

    Similar to WsbAssert(), but is used to wrap Win32 functions
    that return a HANDLE.

    This macro checks the handle and if it is invalid, gets the
    last error, converts it to an HRESULT, then asserts the result.

Arguments:

    hndl    - a HANDLE result from a function call.

See Also:

    WsbAffirmHandle

--*/

#define WsbAssertHandle(hndl)           \
    {                                   \
        HANDLE hHndl;                   \
        hHndl = (hndl);                 \
        if ((hHndl == INVALID_HANDLE_VALUE) || (hHndl == NULL)) { \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAssertPointer

Macro Description:

    Similar to WsbAssert(), but is used specifically to check for
    a valid pointer.

    This macro asserts that the pointer is non-zero, and throws
    E_POINTER if it is not.

Arguments:

    ptr     - the pointer to test.

See Also:

    WsbAffirmPointer

--*/

#define WsbAssertPointer( ptr )         \
    {                                   \
        WsbAssert( ptr != 0, E_POINTER);\
    }

/*++

Macro Name:

    WsbAssertAlloc

Macro Description:

    Similar to WsbAssert(), but is used specifically to check for
    a valid memory allocation.

    This macro asserts that the pointer is non-zero, and throws
    E_OUTOFMEMORY if it is not.

Arguments:

    ptr     - the pointer to test.

See Also:

    WsbAffirmAlloc

--*/

#define WsbAssertAlloc( ptr )         \
    {                                   \
        WsbAssert( (ptr) != 0, E_OUTOFMEMORY );\
    }

/*++

Macro Name:

    WsbAffirmStatus

Macro Description:

    Similar to WsbAffirm(), but is used to wrap Win32 functions
    that return a BOOL status.

    This macro checks the status, and if FALSE, gets the
    last error and converts it to HRESULT, then affirms
    the result.

Arguments:

    status  - a BOOL result from a function call.

See Also:

    WsbAssertStatus

--*/

#define WsbAffirmStatus(status)         \
    {                                   \
        BOOL bStatus;                   \
        bStatus = (status);             \
        if (!bStatus) {                 \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAffirm(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAffirmWin32

Macro Description:

    Similar to WsbAssert(), but is used to wrap Win32 functions
    that return a Win32 status.

    This macro checks the status, and if not ERROR_SUCCESS, 
    converts it to HRESULT, then asserts the result.

Arguments:

    status  - a Win32 result from a function call.

See Also:

    WsbAffirmStatus

--*/

#define WsbAffirmWin32( status )        \
    {                                   \
        LONG lStatus;                   \
        lStatus = (status);             \
        if ( lStatus != ERROR_SUCCESS ) {               \
            HRESULT lHr = HRESULT_FROM_WIN32( lStatus );    \
            WsbAffirm(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAffirmNtStatus

Macro Description:

    Similar to WsbAffirm(), but is used to wrap NT System functions
    that return a NTSTATUS result.

    This macro checks the status, and if not successful, gets the
    last error and converts it to HRESULT, then affirms
    the result.

Arguments:

    status  - a NTSTATUS result from a function call.

See Also:

    WsbAffirmStatus

--*/
#define WsbAffirmNtStatus(status)           \
    {                                   \
        NTSTATUS _ntStatus;             \
        _ntStatus = (NTSTATUS)( status );           \
        if ( !NT_SUCCESS( _ntStatus ) ) {           \
            HRESULT _lHr = HRESULT_FROM_NT( _ntStatus );    \
            WsbAffirm(SUCCEEDED(_lHr), _lHr);               \
        }                               \
    }

/*++

Macro Name:

    WsbAssertNtStatus

Macro Description:

    Similar to WsbAssert(), but is used to wrap NT System functions
    that return a NTSTATUS result.

    This macro checks the status, and if not successful, gets the
    last error and converts it to HRESULT, then affirms
    the result.

Arguments:

    status  - a NTSTATUS result from a function call.

See Also:

    WsbAssertStatus

--*/
#define WsbAssertNtStatus(status)           \
    {                                   \
        NTSTATUS _ntStatus;             \
        _ntStatus = (NTSTATUS)( status );           \
        if ( !NT_SUCCESS( _ntStatus ) ) {           \
            HRESULT _lHr = HRESULT_FROM_NT( _ntStatus );    \
            WsbAssert(SUCCEEDED(_lHr), _lHr);               \
        }                               \
    }
/*++

Macro Name:

    WsbAffirmLsaStatus

Macro Description:

    Similar to WsbAffirm(), but is used to wrap NT System functions
    that return a NTSTATUS result.

    This macro checks the status, and if not successful, gets the
    last error and converts it to HRESULT, then affirms
    the result.

Arguments:

    status  - a NTSTATUS result from a function call.

See Also:

    WsbAffirmStatus

--*/
#define WsbAffirmLsaStatus(status)          \
    {                                   \
        NTSTATUS _ntStatus;             \
        _ntStatus = (NTSTATUS)( status );           \
        if ( !NT_SUCCESS( _ntStatus ) ) {           \
            HRESULT _lHr = HRESULT_FROM_WIN32( LsaNtStatusToWinError(_ntStatus) );  \
            WsbAffirm(SUCCEEDED(_lHr), _lHr);               \
        }                               \
    }

/*++

Macro Name:

    WsbAffirmNoError

Macro Description:

    Similar to WsbAffirm(), but is used to wrap Win32 functions
    that return a DWORD error code.  These functions return NO_ERROR
    if the function completed successfully.

    This macro checks the return value and if an error condition
    is detected, the error is converted to an HRESULT, then affirms
    the result.

Arguments:

    err - a DWORD result from a function call.

See Also:

    WsbAssertNoError

--*/

#define WsbAffirmNoError(retval)        \
    {                                   \
        DWORD dwErr;                    \
        dwErr = (retval);               \
        if (dwErr != NO_ERROR) {        \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAffirm(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAffirmHandle

Macro Description:

    Similar to WsbAffirm(), but is used to wrap Win32 functions
    that return a HANDLE.

    This macro checks the handle and if it is invalid, gets the
    last error, converts it to an HRESULT, then affirms the result.

Arguments:

    hndl    - a HANDLE result from a function call.

See Also:

    WsbAssertHandle

--*/

#define WsbAffirmHandle(hndl)           \
    {                                   \
        HANDLE hHndl;                   \
        hHndl = (hndl);                 \
        if ((hHndl == INVALID_HANDLE_VALUE) || (hHndl == NULL)) { \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAffirm(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAffirmPointer

Macro Description:

    Similar to WsbAffirm(), but is used specifically to check for
    a valid pointer.

    This macro affrims that the pointer is non-zero, and returns
    E_POINTER if it is not.

Arguments:

    ptr     - the pointer to test.

See Also:

    WsbAssertPointer

--*/

#define WsbAffirmPointer( ptr )         \
    {                                   \
        WsbAffirm( ptr != 0, E_POINTER);\
    }

/*++

Macro Name:

    WsbAffirmAlloc

Macro Description:

    Similar to WsbAffirm(), but is used specifically to check for
    a valid memory allocation.

    This macro affrims that the pointer is non-zero, and returns
    E_OUTOFMEMORY if it is not.

Arguments:

    ptr     - the pointer to test.

See Also:

    WsbAssertAlloc

--*/

#define WsbAffirmAlloc( ptr )         \
    {                                   \
        WsbAffirm( (ptr) != 0, E_OUTOFMEMORY );\
    }

/*++

Macro Name:

    WsbCatchAndDo

Macro Description:

    Catch an exception and execute some code.

Arguments:

    hr   - The result value that was thrown.

    code - Code to execute.

--*/

#define WsbCatchAndDo(hr, code)         \
    catch (HRESULT catchHr) {           \
        hr = catchHr;                   \
        { code }                        \
    }

/*++

Macro Name:

    WsbCatch

Macro Description:

    Catch an exception and save the error code value.

Arguments:

    hr   - The result value that was thrown.

--*/

#define WsbCatch(hr)                    \
    catch(HRESULT catchHr) {            \
        hr = catchHr;                   \
    }

#endif // _WSBASSRT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbbstrg.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbbstrg.h

Abstract:

    This component is C++ object representations a smart BSTR pointer. It
    is similar to the CComPtr, in that it takes care of allocating and
    freeing the memory needed to represent the string automatically. This
    simplifies cleanup of functions in error handling cases and it limits
    the need for FinalConstruct() and FinalRelease() calls in objects that
    derive from CComObjectRoot. It is similar to the CWsbStringPtr class.

Author:

    Chuck Bardeen   [cbardeen]   11-Dec-1996

Revision History:

--*/

#ifndef _WSBBSTRG_
#define _WSBBSTRG_

/*++

Class Name:
    
    CWsbBstrPtr

Class Description:

    This component is C++ object representations a smart BSTR pointer. It
    is similar to the CComPtr, in that it takes care of allocating and
    freeing the memory needed to represent the string automatically. This
    simplifies cleanup of functions in error handling cases and it limits
    the need for FinalConstruct() and FinalRelease() calls in objects that
    derive from CComObjectRoot. It is similar to the CWsbStringPtr class.

--*/

class WSB_EXPORT CWsbBstrPtr
{

// Constructors
public:
    CWsbBstrPtr();
    CWsbBstrPtr(const CHAR* pChar);
    CWsbBstrPtr(const WCHAR* pWchar);
    CWsbBstrPtr(const CWsbBstrPtr& pString);
    CWsbBstrPtr(REFGUID rguid);

// Destructor
public:
    ~CWsbBstrPtr();

// Operator Overloading
public:
    operator BSTR();
    WCHAR& operator *();
    BSTR* operator &();
    WCHAR& operator [](const int i);
    CWsbBstrPtr& operator =(const CHAR* pChar);
    CWsbBstrPtr& operator =(const WCHAR* pWchar);
    CWsbBstrPtr& operator =(REFGUID rguid);
    CWsbBstrPtr& operator =(const CWsbBstrPtr& pString);
    BOOL operator !();

// Memory Allocation
public:
    HRESULT Alloc(ULONG size);
    HRESULT Free(void);
    HRESULT GetSize(ULONG* size);
    HRESULT Realloc(ULONG size);

// String Manipulation
public:
    HRESULT Append(const CHAR* pChar);
    HRESULT Append(const WCHAR* pWchar);
    HRESULT Append(const CWsbBstrPtr& pString);
    HRESULT CopyTo(CHAR** pChar);
    HRESULT CopyTo(WCHAR** pWchar);
    HRESULT CopyTo(GUID * pguid);
    HRESULT CopyToBstr(BSTR* pBstr);
    HRESULT CopyTo(CHAR** pChar, ULONG bufferSize);
    HRESULT CopyTo(WCHAR** pWchar,ULONG bufferSize);
    HRESULT CopyToBstr(BSTR* pBstr,ULONG bufferSize);
    HRESULT FindInRsc(ULONG startId, ULONG idsToCheck, ULONG* pMatchId);
    HRESULT GiveTo(BSTR* pBstr);
    HRESULT LoadFromRsc(HINSTANCE instance, ULONG id);
    HRESULT Prepend(const CHAR* pChar);
    HRESULT Prepend(const WCHAR* pWchar);
    HRESULT Prepend(const CWsbBstrPtr& pString);
    HRESULT TakeFrom(BSTR bstr, ULONG bufferSize);

// Guid Translation
public:

// Member Data
protected:
    BSTR                    m_pString;
    ULONG                   m_givenSize;
};

#endif // _WSBBSTRG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbdb.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdb.h

Abstract:

    These classes provide support for data bases.

Author:

    Ron White   [ronw]   19-Nov-1996

Revision History:

--*/


#ifndef _WSBDB_
#define _WSBDB_

// Are we defining imports or exports?
#if defined(IDB_IMPL)
#define IDB_EXPORT      __declspec(dllexport)
#else
#define IDB_EXPORT      __declspec(dllimport)
#endif

#include "wsbdef.h"
#include "wsbdbent.h"

#define IDB_MAX_REC_TYPES     16
#define IDB_MAX_KEYS_PER_REC  10

// Maximum key size in bytes; Jet limit is currently 255 so we limit
// all implementations
#define IDB_MAX_KEY_SIZE      255

//  IDB_SYS_INIT_FLAG_* flags for use with IWsbDbSys::Init
#define IDB_SYS_INIT_FLAG_FULL_LOGGING       0x00000000  // I.e. the default
#define IDB_SYS_INIT_FLAG_LIMITED_LOGGING    0x00000001
#define IDB_SYS_INIT_FLAG_SPECIAL_ERROR_MSG  0x00000002
#define IDB_SYS_INIT_FLAG_NO_BACKUP          0x00000004
#define IDB_SYS_INIT_FLAG_NO_LOGGING         0x00000008

//  IDB_CREATE_FLAG_* flags for use with IWsbDb::Create
#define IDB_CREATE_FLAG_NO_TRANSACTION       0x00000001
#define IDB_CREATE_FLAG_FIXED_SCHEMA         0x00000002

//  IDB_DELETE_FLAG_* flags for use with IWsbDb::Delete
#define IDB_DELETE_FLAG_NO_ERROR             0x00000001

//  IDB_DUMP_FLAG_* flags for use with IWsbDB::Dump
#define IDB_DUMP_FLAG_DB_INFO        0x00000001
#define IDB_DUMP_FLAG_REC_INFO       0x00000002
#define IDB_DUMP_FLAG_KEY_INFO       0x00000004
#define IDB_DUMP_FLAG_RECORDS        0x00000008
#define IDB_DUMP_FLAG_EVERYTHING     0x0000000F
#define IDB_DUMP_FLAG_RECORD_TYPE    0x00000010
#define IDB_DUMP_FLAG_APPEND_TO_FILE 0x00000100

//  IDB_KEY_FLAG_* flags for use in IDB_KEY_INFO structure:
#define IDB_KEY_FLAG_DUP_ALLOWED     0x00000001   // Duplicate keys allowed
#define IDB_KEY_FLAG_PRIMARY         0x00000002   // Primary key

//  IDB_KEY_INFO - data about record keys
//    Note: Only one key per record type can be a primary key.  The primary
//    key can not be modified in a record.  In general, the primary key is
//    used for the physical clustering of the records in the DB.

typedef struct : _COM_IDB_KEY_INFO {
//  ULONG  Type;       // Key type ID; must be > 0
//  ULONG  Size;       // Key size in bytes
//  ULONG  Flags;      // IDB_KEY_FLAG_* values
} IDB_KEY_INFO;


//  IDB_REC_FLAG_* flags for use in IDB_REC_INFO structur
#define IDB_REC_FLAG_VARIABLE   0x00000001 // Record size is not fixed

//  IDB_REC_INFO - data about IDB records
//    Note: It there are multiple keys, the first key is taken as the
//    default key to use for a new entity created by GetEntity.

typedef struct : _COM_IDB_REC_INFO {
    IDB_KEY_INFO *Key;    // Key info (must be allocated by derived DB object)
} IDB_REC_INFO;

//  IDB_BACKUP_FLAG_* flags for use with IWsbDbSys::Backup
#define IDB_BACKUP_FLAG_AUTO        0x00000001  // Start auto backup thread
#define IDB_BACKUP_FLAG_FORCE_FULL  0x00000002  // Force a full backup




/*++

Class Name:

    CWsbDb

Class Description:

    The base class for a data base object.

--*/

class IDB_EXPORT CWsbDb :
    public CWsbPersistable,
    public IWsbDbPriv
{
public:

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* /*pSize*/) {
            return(E_NOTIMPL); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbDb
public:
    STDMETHOD(Close)(IWsbDbSession* pSession);
    STDMETHOD(Create)(OLECHAR* path, ULONG flags = 0);
    STDMETHOD(Delete)(OLECHAR* path, ULONG flags = 0);
    STDMETHOD(Dump)(OLECHAR* Filename, ULONG Flags, ULONG Data);
    STDMETHOD(GetEntity)(IWsbDbSession* pSession, ULONG RecId, REFIID riid, void** ppEntity);
    STDMETHOD(GetName)(OLECHAR** /*pName*/) { return(E_NOTIMPL); }
    STDMETHOD(GetPath)(OLECHAR** /*pPath*/) { return(E_NOTIMPL); }
    STDMETHOD(GetVersion)(ULONG* /*pVer*/) { return(E_NOTIMPL); }
    STDMETHOD(Locate)(OLECHAR* path);
    STDMETHOD(Open)(IWsbDbSession** ppSession);

    // IWsbDbPriv - For internal use only!
    STDMETHOD(GetKeyInfo)(ULONG RecType, USHORT nKeys, COM_IDB_KEY_INFO* pKeyInfo);
    STDMETHOD(GetRecInfo)(ULONG RecType, COM_IDB_REC_INFO* pRecInfo);
    STDMETHOD(Lock)(void) { CWsbPersistable::Lock(); return(S_OK); }
    STDMETHOD(Unlock)(void) { CWsbPersistable::Unlock(); return(S_OK); }

    STDMETHOD(GetJetIds)(JET_SESID SessionId, ULONG RecType,
                JET_TABLEID* pTableId, ULONG* pDataColId);
    STDMETHOD(GetJetIndexInfo)(JET_SESID SessionId, ULONG RecType, ULONG KeyType,
                ULONG* pColId, OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetNewSQN)(ULONG /*RecType*/, ULONG* /*pSeqNum*/)
            { return(E_NOTIMPL); }

private:
    HRESULT db_info_from_file_block(void* block);
    HRESULT db_info_to_file_block(void* block);
    HRESULT rec_info_from_file_block(int index, void* block);
    HRESULT rec_info_to_file_block(int index, void* block);
    HRESULT session_current_index(IWsbDbSession* pSession);

    HRESULT jet_init(void);
    HRESULT jet_make_index_name(ULONG key_type, char* pName, ULONG bufsize);
    HRESULT jet_make_table_name(ULONG rec_type, char* pName, ULONG bufsize);
    HRESULT jet_load_info(void);
    HRESULT jet_save_info(void);

protected:
// Values to be supplied by derived class:

    CComPtr<IWsbDbSys>  m_pWsbDbSys;    // Strong reference to DbSys object - ensures that 
                                        //  this object dies after the DBs
                                        // Note: CWsbDbSys must NOT have strong reference to 
                                        //  objects of this class (WsbDb)
    ULONG               m_version;      // DB version
    USHORT              m_nRecTypes;    // Number of record (object) types
    IDB_REC_INFO*       m_RecInfo;      // Record/key info (must be allocated
                                        //  by derived DB object)

// Not to be changed by derived class:
    CWsbStringPtr   m_path;
    void *          m_pImp;  // Secret stuff

    ULONG           m_SessionIndex;

};

#define WSB_FROM_CWSBDB \
    STDMETHOD(Close)(IWsbDbSession* pSession) \
    {return(CWsbDb::Close(pSession));} \
    STDMETHOD(Create)(OLECHAR* path, ULONG flags = 0) \
    {return(CWsbDb::Create(path, flags));} \
    STDMETHOD(Delete)(OLECHAR* path, ULONG flags = 0) \
    {return(CWsbDb::Delete(path, flags));} \
    STDMETHOD(Dump)(OLECHAR* Filename, ULONG Flags, ULONG Data) \
    {return(CWsbDb::Dump(Filename, Flags, Data));} \
    STDMETHOD(GetEntity)(IWsbDbSession* pSession, ULONG RecId, REFIID riid, void** ppEntity) \
    {return(CWsbDb::GetEntity(pSession, RecId, riid, ppEntity));} \
    STDMETHOD(GetName)(OLECHAR** pName) \
    {return(CWsbDb::GetName(pName)); } \
    STDMETHOD(GetPath)(OLECHAR** pPath) \
    {return(CWsbDb::GetPath(pPath)); } \
    STDMETHOD(GetVersion)(ULONG* pVer) \
    {return(CWsbDb::GetVersion(pVer)); } \
    STDMETHOD(Locate)(OLECHAR* path) \
    {return(CWsbDb::Locate(path));} \
    STDMETHOD(Open)(IWsbDbSession** ppSession) \
    {return(CWsbDb::Open(ppSession));} \




#endif // _WSBDB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbdate.h ===
#ifndef __WSBDATE_H__
#define __WSBDATE_H__

#include "time.h"

// WSBAPI is used on global public functions
#ifndef WSBAPI
        #define WSBAPI __stdcall
#endif


//      #ifdef _WSB_NO_WSB_SUPPORT
//          #error WSB classes not supported in this library variant.
//      #endif
//
//      #ifndef __WSBWIN_H__
//          #include <afxwin.h>
//      #endif
//
//      // include necessary WSB headers
//      #ifndef _OBJBASE_H_
//          #include <objbase.h>
//      #endif
//      #ifndef _WSBAUTO_H_
//          #include <oleauto.h>
//      #endif
//      #ifndef _WSBCTL_H_
//          #include <olectl.h>
//      #endif
//      //REVIEW: This header has no symbol to prevent repeated includes
//      #include <olectlid.h>
//      #ifndef __ocidl_h__
//          #include <ocidl.h>
//      #endif
//
//      #ifdef _WSB_MINREBUILD
//      #pragma component(minrebuild, off)
//      #endif
//      #ifndef _WSB_FULLTYPEINFO
//      #pragma component(mintypeinfo, on)
//      #endif
//
//      #ifndef _WSB_NOFORCE_LIBS
//      #ifndef _MAC
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Win32 libraries
//
//      #ifdef _WSBDLL
//          #if defined(_DEBUG) && !defined(_WSB_MONOLITHIC)
//              #ifndef _UNICODE
//                  #pragma comment(lib, "mfco42d.lib")
//              #else
//                  #pragma comment(lib, "mfco42ud.lib")
//              #endif
//          #endif
//      #endif
//
//      #pragma comment(lib, "oledlg.lib")
//      #pragma comment(lib, "ole32.lib")
//      #pragma comment(lib, "olepro32.lib")
//      #pragma comment(lib, "oleaut32.lib")
//      #pragma comment(lib, "uuid.lib")
//      #pragma comment(lib, "urlmon.lib")
//
//      #else //!_MAC
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Mac libraries
//
//      #ifdef _WSBDLL
//          #ifdef _DEBUG
//              #pragma comment(lib, "mfco42pd.lib")
//          #else
//              #pragma comment(lib, "mfco42p.lib")
//          #endif
//      #endif
//
//      #if !defined(_WSBDLL) && !defined(_USRDLL)
//          #ifdef _DEBUG
//              #pragma comment(lib, "wlmoled.lib")
//              #pragma comment(lib, "ole2uid.lib")
//          #else
//              #pragma comment(lib, "wlmole.lib")
//              #pragma comment(lib, "ole2ui.lib")
//          #endif
//          #pragma comment(linker, "/macres:ole2ui.rsc")
//      #else
//          #ifdef _DEBUG
//              #pragma comment(lib, "oledlgd.lib")
//              #pragma comment(lib, "msvcoled.lib")
//          #else
//              #pragma comment(lib, "oledlg.lib")
//              #pragma comment(lib, "msvcole.lib")
//          #endif
//      #endif
//
//      #pragma comment(lib, "uuid.lib")
//
//      #ifdef _DEBUG
//          #pragma comment(lib, "ole2d.lib")
//          #pragma comment(lib, "ole2autd.lib")
//      #else
//          #pragma comment(lib, "ole2.lib")
//          #pragma comment(lib, "ole2auto.lib")
//      #endif
//
//      #endif //_MAC
//      #endif //!_WSB_NOFORCE_LIBS
//
//      /////////////////////////////////////////////////////////////////////////////
//
//      #ifdef _WSB_PACKING
//      #pragma pack(push, _WSB_PACKING)
//      #endif
//
//      /////////////////////////////////////////////////////////////////////////////
//      // WSBDATE - MFC IDispatch & ClassFactory support
//
//      // Classes declared in this file
//
//      //CCmdTarget
//          class CWsbObjectFactory;    // glue for IClassFactory -> runtime class
//          class CWsbTemplateServer;       // server documents using CDocTemplate
//
//      class CWsbDispatchDriver;       // helper class to call IDispatch


//      class CWsbCurrency;     // Based on OLE CY
//      class CWsbSafeArray;    // Based on WSB VARIANT

//      //CException
//          class CWsbException;            // caught by client or server
//          class CWsbDispatchException;    // special exception for IDispatch calls


class CWsbDVariant;                     // WSB VARIANT wrapper
class CWsbDateTime;                     // Based on WSB DATE
class CWsbDateTimeSpan;                 // Based on a double

/////////////////////////////////////////////////////////////////////////////

//      // WSBDLL support
//      #undef WSB_DATA
//      #define WSB_DATA WSB_DATA
//
//      /////////////////////////////////////////////////////////////////////////////
//      // WSB COM (Component Object Model) implementation infrastructure
//      //      - data driven QueryInterface
//      //      - standard implementation of aggregate AddRef and Release
//      // (see CCmdTarget in WSBWIN.H for more information)
//
//      #define METHOD_PROLOGUE(theClass, localClass) \
//          theClass* pThis = \
//              ((theClass*)((BYTE*)this - offsetof(theClass, m_x##localClass))); \
//          WSB_MANAGE_STATE(pThis->m_pModuleState) \
//
//      #define METHOD_PROLOGUE_(theClass, localClass) \
//          theClass* pThis = \
//              ((theClass*)((BYTE*)this - offsetof(theClass, m_x##localClass))); \
//
//      #ifndef _WSB_NO_NESTED_DERIVATION
//      #define METHOD_PROLOGUE_EX(theClass, localClass) \
//          theClass* pThis = ((theClass*)((BYTE*)this - m_nOffset)); \
//          WSB_MANAGE_STATE(pThis->m_pModuleState) \
//
//      #define METHOD_PROLOGUE_EX_(theClass, localClass) \
//          theClass* pThis = ((theClass*)((BYTE*)this - m_nOffset)); \
//
//      #else
//      #define METHOD_PROLOGUE_EX(theClass, localClass) \
//          METHOD_PROLOGUE(theClass, localClass) \
//
//      #define METHOD_PROLOGUE_EX_(theClass, localClass) \
//          METHOD_PROLOGUE_(theClass, localClass) \
//
//      #endif
//
//      // Provided only for compatibility with CDK 1.x
//      #define METHOD_MANAGE_STATE(theClass, localClass) \
//          METHOD_PROLOGUE_EX(theClass, localClass) \
//
//      #define BEGIN_INTERFACE_PART(localClass, baseClass) \
//          class X##localClass : public baseClass \
//          { \
//          public: \
//              STDMETHOD_(ULONG, AddRef)(); \
//              STDMETHOD_(ULONG, Release)(); \
//              STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj); \
//
//      #ifndef _WSB_NO_NESTED_DERIVATION
//      #define BEGIN_INTERFACE_PART_DERIVE(localClass, baseClass) \
//          class X##localClass : public baseClass \
//          { \
//          public: \
//
//      #else
//      #define BEGIN_INTERFACE_PART_DERIVE(localClass, baseClass) \
//          BEGIN_INTERFACE_PART(localClass, baseClass) \
//
//      #endif
//
//      #ifndef _WSB_NO_NESTED_DERIVATION
//      #define INIT_INTERFACE_PART(theClass, localClass) \
//              size_t m_nOffset; \
//              INIT_INTERFACE_PART_DERIVE(theClass, localClass) \
//
//      #define INIT_INTERFACE_PART_DERIVE(theClass, localClass) \
//              X##localClass() \
//                  { m_nOffset = offsetof(theClass, m_x##localClass); } \
//
//      #else
//      #define INIT_INTERFACE_PART(theClass, localClass)
//      #define INIT_INTERFACE_PART_DERIVE(theClass, localClass)
//
//      #endif
//
//      // Note: Inserts the rest of WSB functionality between these two macros,
//      //  depending upon the interface that is being implemented.  It is not
//      //  necessary to include AddRef, Release, and QueryInterface since those
//      //  member functions are declared by the macro.
//
//      #define END_INTERFACE_PART(localClass) \
//          } m_x##localClass; \
//          friend class X##localClass; \
//
//      #ifdef _WSBDLL
//      #define BEGIN_INTERFACE_MAP(theClass, theBase) \
//          const WSB_INTERFACEMAP* PASCAL theClass::_GetBaseInterfaceMap() \
//              { return &theBase::interfaceMap; } \
//          const WSB_INTERFACEMAP* theClass::GetInterfaceMap() const \
//              { return &theClass::interfaceMap; } \
//          const WSB_DATADEF WSB_INTERFACEMAP theClass::interfaceMap = \
//              { &theClass::_GetBaseInterfaceMap, &theClass::_interfaceEntries[0], }; \
//          const WSB_DATADEF WSB_INTERFACEMAP_ENTRY theClass::_interfaceEntries[] = \
//          { \
//
//      #else
//      #define BEGIN_INTERFACE_MAP(theClass, theBase) \
//          const WSB_INTERFACEMAP* theClass::GetInterfaceMap() const \
//              { return &theClass::interfaceMap; } \
//          const WSB_DATADEF WSB_INTERFACEMAP theClass::interfaceMap = \
//              { &theBase::interfaceMap, &theClass::_interfaceEntries[0], }; \
//          const WSB_DATADEF WSB_INTERFACEMAP_ENTRY theClass::_interfaceEntries[] = \
//          { \
//
//      #endif
//
//      #define INTERFACE_PART(theClass, iid, localClass) \
//              { &iid, offsetof(theClass, m_x##localClass) }, \
//
//      #define INTERFACE_AGGREGATE(theClass, theAggr) \
//              { NULL, offsetof(theClass, theAggr) }, \
//
//      #define END_INTERFACE_MAP() \
//              { NULL, (size_t)-1 } \
//          }; \

//      /////////////////////////////////////////////////////////////////////////////
//      // CWsbException - unexpected or rare WSB error returned
//
//      class CWsbException : public CException
//      {
//          DECLARE_DYNAMIC(CWsbException)
//
//      public:
//          SCODE m_sc;
//          static SCODE PASCAL Process(const CException* pAnyException);
//
//      // Implementation (use WsbThrowWsbException to create)
//      public:
//          CWsbException();
//          virtual ~CWsbException();
//
//          virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
//              PUINT pnHelpContext = NULL);
//      };
//
//      void WSBAPI WsbThrowWsbException(SCODE sc);

//      /////////////////////////////////////////////////////////////////////////////
//      // IDispatch specific exception
//
//      class CWsbDispatchException : public CException
//      {
//          DECLARE_DYNAMIC(CWsbDispatchException)
//
//      public:
//      // Attributes
//          WORD m_wCode;               // error code (specific to IDispatch implementation)
//          CString m_strDescription;   // human readable description of the error
//          DWORD m_dwHelpContext;      // help context for error
//
//          // usually empty in application which creates it (eg. servers)
//          CString m_strHelpFile;      // help file to use with m_dwHelpContext
//          CString m_strSource;        // source of the error (name of server)
//
//      // Implementation
//      public:
//          CWsbDispatchException(LPCTSTR lpszDescription, UINT nHelpID, WORD wCode);
//          virtual ~CWsbDispatchException();
//          static void PASCAL Process(
//              EXCEPINFO* pInfo, const CException* pAnyException);
//
//          virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
//              PUINT pnHelpContext = NULL);
//
//          SCODE m_scError;        // SCODE describing the error
//      };
//
//      void WSBAPI WsbThrowWsbDispatchException(WORD wCode, LPCTSTR lpszDescription,
//          UINT nHelpID = 0);
//      void WSBAPI WsbThrowWsbDispatchException(WORD wCode, UINT nDescriptionID,
//          UINT nHelpID = (UINT)-1);

//      /////////////////////////////////////////////////////////////////////////////
//      // Macros for CCmdTarget IDispatchable classes
//
//      #ifdef _WSBDLL
//      #define BEGIN_DISPATCH_MAP(theClass, baseClass) \
//          const WSB_DISPMAP* PASCAL theClass::_GetBaseDispatchMap() \
//              { return &baseClass::dispatchMap; } \
//          const WSB_DISPMAP* theClass::GetDispatchMap() const \
//              { return &theClass::dispatchMap; } \
//          const WSB_DISPMAP theClass::dispatchMap = \
//              { &theClass::_GetBaseDispatchMap, &theClass::_dispatchEntries[0], \
//                &theClass::_dispatchEntryCount, &theClass::_dwStockPropMask };  \
//          UINT theClass::_dispatchEntryCount = (UINT)-1; \
//          DWORD theClass::_dwStockPropMask = (DWORD)-1; \
//          const WSB_DISPMAP_ENTRY theClass::_dispatchEntries[] = \
//          { \
//
//      #else
//      #define BEGIN_DISPATCH_MAP(theClass, baseClass) \
//          const WSB_DISPMAP* theClass::GetDispatchMap() const \
//              { return &theClass::dispatchMap; } \
//          const WSB_DISPMAP theClass::dispatchMap = \
//              { &baseClass::dispatchMap, &theClass::_dispatchEntries[0], \
//                &theClass::_dispatchEntryCount, &theClass::_dwStockPropMask }; \
//          UINT theClass::_dispatchEntryCount = (UINT)-1; \
//          DWORD theClass::_dwStockPropMask = (DWORD)-1; \
//          const WSB_DISPMAP_ENTRY theClass::_dispatchEntries[] = \
//          { \
//
//      #endif
//
//      #define END_DISPATCH_MAP() \
//          { VTS_NONE, DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)NULL, (WSB_PMSG)NULL, (size_t)-1, afxDispCustom } }; \
//
//      // parameter types: by value VTs
//      #define VTS_I2          "\x02"      // a 'short'
//      #define VTS_I4          "\x03"      // a 'long'
//      #define VTS_R4          "\x04"      // a 'float'
//      #define VTS_R8          "\x05"      // a 'double'
//      #define VTS_CY          "\x06"      // a 'CY' or 'CY*'
//      #define VTS_DATE        "\x07"      // a 'DATE'
//      #define VTS_WBSTR       "\x08"      // an 'LPCWSBSTR'
//      #define VTS_DISPATCH    "\x09"      // an 'IDispatch*'
//      #define VTS_SCODE       "\x0A"      // an 'SCODE'
//      #define VTS_BOOL        "\x0B"      // a 'BOOL'
//      #define VTS_VARIANT     "\x0C"      // a 'const VARIANT&' or 'VARIANT*'
//      #define VTS_UNKNOWN     "\x0D"      // an 'IUnknown*'
//      #if defined(_UNICODE) || defined(WSB2ANSI)
//          #define VTS_BSTR        VTS_WBSTR// an 'LPCWSBSTR'
//          #define VT_BSTRT        VT_BSTR
//      #else
//          #define VTS_BSTR        "\x0E"  // an 'LPCSTR'
//          #define VT_BSTRA        14
//          #define VT_BSTRT        VT_BSTRA
//      #endif
//
//      // parameter types: by reference VTs
//      #define VTS_PI2         "\x42"      // a 'short*'
//      #define VTS_PI4         "\x43"      // a 'long*'
//      #define VTS_PR4         "\x44"      // a 'float*'
//      #define VTS_PR8         "\x45"      // a 'double*'
//      #define VTS_PCY         "\x46"      // a 'CY*'
//      #define VTS_PDATE       "\x47"      // a 'DATE*'
//      #define VTS_PBSTR       "\x48"      // a 'BSTR*'
//      #define VTS_PDISPATCH   "\x49"      // an 'IDispatch**'
//      #define VTS_PSCODE      "\x4A"      // an 'SCODE*'
//      #define VTS_PBOOL       "\x4B"      // a 'VARIANT_BOOL*'
//      #define VTS_PVARIANT    "\x4C"      // a 'VARIANT*'
//      #define VTS_PUNKNOWN    "\x4D"      // an 'IUnknown**'
//
//      // special VT_ and VTS_ values
//      #define VTS_NONE        NULL        // used for members with 0 params
//      #define VT_MFCVALUE     0xFFF       // special value for DISPID_VALUE
//      #define VT_MFCBYREF     0x40        // indicates VT_BYREF type
//      #define VT_MFCMARKER    0xFF        // delimits named parameters (INTERNAL USE)
//
//      // variant handling (use V_BSTRT when you have ANSI BSTRs, as in DAO)
//      #ifndef _UNICODE
//          #define V_BSTRT(b)  (LPSTR)V_BSTR(b)
//      #else
//          #define V_BSTRT(b)  V_BSTR(b)
//      #endif
//
//      /////////////////////////////////////////////////////////////////////////////
//      // WSB control parameter types
//
//      #define VTS_COLOR           VTS_I4      // WSB_COLOR
//      #define VTS_XPOS_PIXELS     VTS_I4      // WSB_XPOS_PIXELS
//      #define VTS_YPOS_PIXELS     VTS_I4      // WSB_YPOS_PIXELS
//      #define VTS_XSIZE_PIXELS    VTS_I4      // WSB_XSIZE_PIXELS
//      #define VTS_YSIZE_PIXELS    VTS_I4      // WSB_YSIZE_PIXELS
//      #define VTS_XPOS_HIMETRIC   VTS_I4      // WSB_XPOS_HIMETRIC
//      #define VTS_YPOS_HIMETRIC   VTS_I4      // WSB_YPOS_HIMETRIC
//      #define VTS_XSIZE_HIMETRIC  VTS_I4      // WSB_XSIZE_HIMETRIC
//      #define VTS_YSIZE_HIMETRIC  VTS_I4      // WSB_YSIZE_HIMETRIC
//      #define VTS_TRISTATE        VTS_I2      // WSB_TRISTATE
//      #define VTS_OPTEXCLUSIVE    VTS_BOOL    // WSB_OPTEXCLUSIVE
//
//      #define VTS_PCOLOR          VTS_PI4     // WSB_COLOR*
//      #define VTS_PXPOS_PIXELS    VTS_PI4     // WSB_XPOS_PIXELS*
//      #define VTS_PYPOS_PIXELS    VTS_PI4     // WSB_YPOS_PIXELS*
//      #define VTS_PXSIZE_PIXELS   VTS_PI4     // WSB_XSIZE_PIXELS*
//      #define VTS_PYSIZE_PIXELS   VTS_PI4     // WSB_YSIZE_PIXELS*
//      #define VTS_PXPOS_HIMETRIC  VTS_PI4     // WSB_XPOS_HIMETRIC*
//      #define VTS_PYPOS_HIMETRIC  VTS_PI4     // WSB_YPOS_HIMETRIC*
//      #define VTS_PXSIZE_HIMETRIC VTS_PI4     // WSB_XSIZE_HIMETRIC*
//      #define VTS_PYSIZE_HIMETRIC VTS_PI4     // WSB_YSIZE_HIMETRIC*
//      #define VTS_PTRISTATE       VTS_PI2     // WSB_TRISTATE*
//      #define VTS_POPTEXCLUSIVE   VTS_PBOOL   // WSB_OPTEXCLUSIVE*
//
//      #define VTS_FONT            VTS_DISPATCH    // IFontDispatch*
//      #define VTS_PICTURE         VTS_DISPATCH    // IPictureDispatch*
//
//      #define VTS_HANDLE          VTS_I4      // WSB_HANDLE
//      #define VTS_PHANDLE         VTS_PI4     // WSB_HANDLE*
//
//      // these DISP_ macros cause the framework to generate the DISPID
//      #define DISP_FUNCTION(theClass, szExternalName, pfnMember, vtRetVal, vtsParams) \
//          { _T(szExternalName), DISPID_UNKNOWN, vtsParams, vtRetVal, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnMember, (WSB_PMSG)0, 0, \
//              afxDispCustom }, \
//
//      #define DISP_PROPERTY(theClass, szExternalName, memberName, vtPropType) \
//          { _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, (WSB_PMSG)0, (WSB_PMSG)0, \
//              offsetof(theClass, memberName), afxDispCustom }, \
//
//      #define DISP_PROPERTY_NOTIFY(theClass, szExternalName, memberName, pfnAfterSet, vtPropType) \
//          { _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, (WSB_PMSG)0, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnAfterSet, \
//              offsetof(theClass, memberName), afxDispCustom }, \
//
//      #define DISP_PROPERTY_EX(theClass, szExternalName, pfnGet, pfnSet, vtPropType) \
//          { _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnGet, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \
//
//      #define DISP_PROPERTY_PARAM(theClass, szExternalName, pfnGet, pfnSet, vtPropType, vtsParams) \
//          { _T(szExternalName), DISPID_UNKNOWN, vtsParams, vtPropType, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnGet, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \
//
//      // these DISP_ macros allow the app to determine the DISPID
//      #define DISP_FUNCTION_ID(theClass, szExternalName, dispid, pfnMember, vtRetVal, vtsParams) \
//          { _T(szExternalName), dispid, vtsParams, vtRetVal, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnMember, (WSB_PMSG)0, 0, \
//              afxDispCustom }, \
//
//      #define DISP_PROPERTY_ID(theClass, szExternalName, dispid, memberName, vtPropType) \
//          { _T(szExternalName), dispid, NULL, vtPropType, (WSB_PMSG)0, (WSB_PMSG)0, \
//              offsetof(theClass, memberName), afxDispCustom }, \
//
//      #define DISP_PROPERTY_NOTIFY_ID(theClass, szExternalName, dispid, memberName, pfnAfterSet, vtPropType) \
//          { _T(szExternalName), dispid, NULL, vtPropType, (WSB_PMSG)0, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnAfterSet, \
//              offsetof(theClass, memberName), afxDispCustom }, \
//
//      #define DISP_PROPERTY_EX_ID(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType) \
//          { _T(szExternalName), dispid, NULL, vtPropType, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnGet, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \
//
//      #define DISP_PROPERTY_PARAM_ID(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType, vtsParams) \
//          { _T(szExternalName), dispid, vtsParams, vtPropType, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnGet, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \
//
//      // the DISP_DEFVALUE is a special case macro that creates an alias for DISPID_VALUE
//      #define DISP_DEFVALUE(theClass, szExternalName) \
//          { _T(szExternalName), DISPID_UNKNOWN, NULL, VT_MFCVALUE, \
//              (WSB_PMSG)0, (WSB_PMSG)0, 0, afxDispCustom }, \
//
//      #define DISP_DEFVALUE_ID(theClass, dispid) \
//          { NULL, dispid, NULL, VT_MFCVALUE, (WSB_PMSG)0, (WSB_PMSG)0, 0, \
//              afxDispCustom }, \
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Macros for creating "creatable" automation classes.
//
//      #define DECLARE_WSBCREATE(class_name) \
//      public: \
//          static WSB_DATA CWsbObjectFactory factory; \
//          static WSB_DATA const GUID guid; \
//
//      #define IMPLEMENT_WSBCREATE(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
//          WSB_DATADEF CWsbObjectFactory class_name::factory(class_name::guid, \
//              RUNTIME_CLASS(class_name), FALSE, _T(external_name)); \
//          const WSB_DATADEF GUID class_name::guid = \
//              { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }; \
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Helper class for driving IDispatch
//
//      class CWsbDispatchDriver
//      {
//      // Constructors
//      public:
//          CWsbDispatchDriver();
//          CWsbDispatchDriver(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
//          CWsbDispatchDriver(const CWsbDispatchDriver& dispatchSrc);
//
//      // Attributes
//          LPDISPATCH m_lpDispatch;
//          BOOL m_bAutoRelease;
//
//      // Operations
//          BOOL CreateDispatch(REFCLSID clsid, CWsbException* pError = NULL);
//          BOOL CreateDispatch(LPCTSTR lpszProgID, CWsbException* pError = NULL);
//
//          void AttachDispatch(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
//          LPDISPATCH DetachDispatch();
//              // detach and get ownership of m_lpDispatch
//          void ReleaseDispatch();
//
//          // helpers for IDispatch::Invoke
//          void WSB_CDECL InvokeHelper(DISPID dwDispID, WORD wFlags,
//              VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...);
//          void WSB_CDECL SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
//          void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;
//
//          // special operators
//          operator LPDISPATCH();
//          const CWsbDispatchDriver& operator=(const CWsbDispatchDriver& dispatchSrc);
//
//      // Implementation
//      public:
//          ~CWsbDispatchDriver();
//          void InvokeHelperV(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
//              void* pvRet, const BYTE* pbParamInfo, va_list argList);
//      };
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Class Factory implementation (binds WSB class factory -> runtime class)
//      //  (all specific class factories derive from this class factory)
//
//      class CWsbObjectFactory : public CCmdTarget
//      {
//          DECLARE_DYNAMIC(CWsbObjectFactory)
//
//      // Construction
//      public:
//          CWsbObjectFactory(REFCLSID clsid, CRuntimeClass* pRuntimeClass,
//              BOOL bMultiInstance, LPCTSTR lpszProgID);
//
//      // Attributes
//          virtual BOOL IsRegistered() const;
//          REFCLSID GetClassID() const;
//
//      // Operations
//          virtual BOOL Register();
//          void Revoke();
//          void UpdateRegistry(LPCTSTR lpszProgID = NULL);
//              // default uses m_lpszProgID if not NULL
//          BOOL IsLicenseValid();
//
//          static BOOL PASCAL RegisterAll();
//          static void PASCAL RevokeAll();
//          static BOOL PASCAL UpdateRegistryAll(BOOL bRegister = TRUE);
//
//      // Overridables
//      protected:
//          virtual CCmdTarget* OnCreateObject();
//          virtual BOOL UpdateRegistry(BOOL bRegister);
//          virtual BOOL VerifyUserLicense();
//          virtual BOOL GetLicenseKey(DWORD dwReserved, BSTR* pbstrKey);
//          virtual BOOL VerifyLicenseKey(BSTR bstrKey);
//
//      // Implementation
//      public:
//          virtual ~CWsbObjectFactory();
//      #ifdef _DEBUG
//          void AssertValid() const;
//          void Dump(CDumpContext& dc) const;
//      #endif
//
//      public:
//          CWsbObjectFactory* m_pNextFactory;  // list of factories maintained
//
//      protected:
//          DWORD m_dwRegister;         // registry identifier
//          CLSID m_clsid;          // registered class ID
//          CRuntimeClass* m_pRuntimeClass; // runtime class of CCmdTarget derivative
//          BOOL m_bMultiInstance;      // multiple instance?
//          LPCTSTR m_lpszProgID;       // human readable class ID
//          BYTE m_bLicenseChecked;
//          BYTE m_bLicenseValid;
//          BYTE m_bRegistered;         // is currently registered w/ system
//          BYTE m_bReserved;           // reserved for future use
//
//      // Interface Maps
//      public:
//          BEGIN_INTERFACE_PART(ClassFactory, IClassFactory2)
//              INIT_INTERFACE_PART(CWsbObjectFactory, ClassFactory)
//              STDMETHOD(CreateInstance)(LPUNKNOWN, REFIID, LPVOID*);
//              STDMETHOD(LockServer)(BOOL);
//              STDMETHOD(GetLicInfo)(LPLICINFO);
//              STDMETHOD(RequestLicKey)(DWORD, BSTR*);
//              STDMETHOD(CreateInstanceLic)(LPUNKNOWN, LPUNKNOWN, REFIID, BSTR,
//                  LPVOID*);
//          END_INTERFACE_PART(ClassFactory)
//
//          DECLARE_INTERFACE_MAP()
//
//          friend SCODE WSBAPI WsbDllGetClassObject(REFCLSID, REFIID, LPVOID*);
//          friend SCODE STDAPICALLTYPE DllGetClassObject(REFCLSID, REFIID, LPVOID*);
//      };
//
//      // Define CWsbObjectFactoryEx for compatibility with old CDK
//      #define CWsbObjectFactoryEx CWsbObjectFactory
//
//      //////////////////////////////////////////////////////////////////////////////
//      // CWsbTemplateServer - CWsbObjectFactory using CDocTemplates
//
//      // This enumeration is used in WsbWsbRegisterServerClass to pick the
//      //  correct registration entries given the application type.
//      enum WSB_APPTYPE
//      {
//          OAT_INPLACE_SERVER = 0,     // server has full server user-interface
//          OAT_SERVER = 1,         // server supports only embedding
//          OAT_CONTAINER = 2,      // container supports links to embeddings
//          OAT_DISPATCH_OBJECT = 3,    // IDispatch capable object
//          OAT_DOC_OBJECT_SERVER = 4,  // sever supports DocObject embedding
//          OAT_DOC_OBJECT_CONTAINER =5,// container supports DocObject clients
//      };
//
//      class CWsbTemplateServer : public CWsbObjectFactory
//      {
//      // Constructors
//      public:
//          CWsbTemplateServer();
//
//      // Operations
//          void ConnectTemplate(REFCLSID clsid, CDocTemplate* pDocTemplate,
//              BOOL bMultiInstance);
//              // set doc template after creating it in InitInstance
//          void UpdateRegistry(WSB_APPTYPE nAppType = OAT_INPLACE_SERVER,
//              LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL);
//              // may want to UpdateRegistry if not run with /Embedded
//          BOOL Register();
//
//      // Implementation
//      protected:
//          virtual CCmdTarget* OnCreateObject();
//          CDocTemplate* m_pDocTemplate;
//
//      private:
//          void UpdateRegistry(LPCTSTR lpszProgID);
//              // hide base class version of UpdateRegistry
//      };
//
//      /////////////////////////////////////////////////////////////////////////////
//      // System registry helpers
//
//      // Helper to register server in case of no .REG file loaded
//      BOOL WSBAPI WsbWsbRegisterServerClass(
//          REFCLSID clsid, LPCTSTR lpszClassName,
//          LPCTSTR lpszShortTypeName, LPCTSTR lpszLongTypeName,
//          WSB_APPTYPE nAppType = OAT_SERVER,
//          LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL,
//          int nIconIndex = 0, LPCTSTR lpszLocalFilterName = NULL);
//
//      // WsbWsbRegisterHelper is a worker function used by WsbWsbRegisterServerClass
//      //  (available for advanced registry work)
//      BOOL WSBAPI WsbWsbRegisterHelper(LPCTSTR const* rglpszRegister,
//          LPCTSTR const* rglpszSymbols, int nSymbols, BOOL bReplace,
//          HKEY hKeyRoot = ((HKEY)0x80000000)); // HKEY_CLASSES_ROOT
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Connection maps
//
//      #define BEGIN_CONNECTION_PART(theClass, localClass) \
//          class X##localClass : public CConnectionPoint \
//          { \
//          public: \
//              X##localClass() \
//                  { m_nOffset = offsetof(theClass, m_x##localClass); }
//
//      #define CONNECTION_IID(iid) \
//              REFIID GetIID() { return iid; }
//
//      #define END_CONNECTION_PART(localClass) \
//          } m_x##localClass; \
//          friend class X##localClass;
//
//      #ifdef _WSBDLL
//      #define BEGIN_CONNECTION_MAP(theClass, theBase) \
//          const WSB_CONNECTIONMAP* PASCAL theClass::_GetBaseConnectionMap() \
//              { return &theBase::connectionMap; } \
//          const WSB_CONNECTIONMAP* theClass::GetConnectionMap() const \
//              { return &theClass::connectionMap; } \
//          const WSB_DATADEF WSB_CONNECTIONMAP theClass::connectionMap = \
//              { &theClass::_GetBaseConnectionMap, &theClass::_connectionEntries[0], }; \
//          const WSB_DATADEF WSB_CONNECTIONMAP_ENTRY theClass::_connectionEntries[] = \
//          { \
//
//      #else
//      #define BEGIN_CONNECTION_MAP(theClass, theBase) \
//          const WSB_CONNECTIONMAP* theClass::GetConnectionMap() const \
//              { return &theClass::connectionMap; } \
//          const WSB_DATADEF WSB_CONNECTIONMAP theClass::connectionMap = \
//              { &(theBase::connectionMap), &theClass::_connectionEntries[0], }; \
//          const WSB_DATADEF WSB_CONNECTIONMAP_ENTRY theClass::_connectionEntries[] = \
//          { \
//
//      #endif
//
//      #define CONNECTION_PART(theClass, iid, localClass) \
//              { &iid, offsetof(theClass, m_x##localClass) }, \
//
//      #define END_CONNECTION_MAP() \
//              { NULL, (size_t)-1 } \
//          }; \
//
//      /////////////////////////////////////////////////////////////////////////////
//      // CConnectionPoint
//
//      class CConnectionPoint : public CCmdTarget
//      {
//      // Constructors
//      public:
//          CConnectionPoint();
//
//      // Operations
//          POSITION GetStartPosition() const;
//          LPUNKNOWN GetNextConnection(POSITION& pos) const;
//          const CPtrArray* GetConnections();  // obsolete
//
//      // Overridables
//          virtual LPCONNECTIONPOINTCONTAINER GetContainer();
//          virtual REFIID GetIID() = 0;
//          virtual void OnAdvise(BOOL bAdvise);
//          virtual int GetMaxConnections();
//          virtual LPUNKNOWN QuerySinkInterface(LPUNKNOWN pUnkSink);
//
//      // Implementation
//          ~CConnectionPoint();
//          void CreateConnectionArray();
//          int GetConnectionCount();
//
//      protected:
//          size_t m_nOffset;
//          LPUNKNOWN m_pUnkFirstConnection;
//          CPtrArray* m_pConnections;
//
//      // Interface Maps
//      public:
//          BEGIN_INTERFACE_PART(ConnPt, IConnectionPoint)
//              INIT_INTERFACE_PART(CConnectionPoint, ConnPt)
//              STDMETHOD(GetConnectionInterface)(IID* pIID);
//              STDMETHOD(GetConnectionPointContainer)(
//                  IConnectionPointContainer** ppCPC);
//              STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD* pdwCookie);
//              STDMETHOD(Unadvise)(DWORD dwCookie);
//              STDMETHOD(EnumConnections)(LPENUMCONNECTIONS* ppEnum);
//          END_INTERFACE_PART(ConnPt)
//      };
//
//      /////////////////////////////////////////////////////////////////////////////
//      // EventSink Maps
//
//      #ifndef _WSB_NO_OCC_SUPPORT
//
//      #ifdef _WSBDLL
//      #define BEGIN_EVENTSINK_MAP(theClass, baseClass) \
//          const WSB_EVENTSINKMAP* PASCAL theClass::_GetBaseEventSinkMap() \
//              { return &baseClass::eventsinkMap; } \
//          const WSB_EVENTSINKMAP* theClass::GetEventSinkMap() const \
//              { return &theClass::eventsinkMap; } \
//          const WSB_EVENTSINKMAP theClass::eventsinkMap = \
//              { &theClass::_GetBaseEventSinkMap, &theClass::_eventsinkEntries[0], \
//                  &theClass::_eventsinkEntryCount }; \
//          UINT theClass::_eventsinkEntryCount = (UINT)-1; \
//          const WSB_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
//          { \
//
//      #else
//      #define BEGIN_EVENTSINK_MAP(theClass, baseClass) \
//          const WSB_EVENTSINKMAP* theClass::GetEventSinkMap() const \
//              { return &theClass::eventsinkMap; } \
//          const WSB_EVENTSINKMAP theClass::eventsinkMap = \
//              { &baseClass::eventsinkMap, &theClass::_eventsinkEntries[0], \
//                  &theClass::_eventsinkEntryCount }; \
//          UINT theClass::_eventsinkEntryCount = (UINT)-1; \
//          const WSB_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
//          { \
//
//      #endif
//
//      #define END_EVENTSINK_MAP() \
//          { VTS_NONE, DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)NULL, (WSB_PMSG)NULL, (size_t)-1, afxDispCustom, \
//              (UINT)-1, 0 } }; \
//
//      #define ON_EVENT(theClass, id, dispid, pfnHandler, vtsParams) \
//          { _T(""), dispid, vtsParams, VT_BOOL, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnHandler, (WSB_PMSG)0, 0, \
//              afxDispCustom, id, (UINT)-1 }, \
//
//      #define ON_EVENT_RANGE(theClass, idFirst, idLast, dispid, pfnHandler, vtsParams) \
//          { _T(""), dispid, vtsParams, VT_BOOL, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnHandler, (WSB_PMSG)0, 0, \
//              afxDispCustom, idFirst, idLast }, \
//
//      #define ON_PROPNOTIFY(theClass, id, dispid, pfnRequest, pfnChanged) \
//          { _T(""), dispid, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(BOOL*))&pfnRequest, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(void))&pfnChanged, \
//              1, afxDispCustom, id, (UINT)-1 }, \
//
//      #define ON_PROPNOTIFY_RANGE(theClass, idFirst, idLast, dispid, pfnRequest, pfnChanged) \
//          { _T(""), dispid, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(UINT, BOOL*))&pfnRequest, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(UINT))&pfnChanged, \
//              1, afxDispCustom, idFirst, idLast }, \
//
//      #define ON_DSCNOTIFY(theClass, id, pfnNotify) \
//          { _T(""), DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(DSCSTATE, DSCREASON, BOOL*))&pfnNotify, (WSB_PMSG)0, \
//              1, afxDispCustom, id, (UINT)-1 }, \
//
//      #define ON_DSCNOTIFY_RANGE(theClass, idFirst, idLast, pfnNotify) \
//          { _T(""), DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(UINT, DSCSTATE, DSCREASON, BOOL*))&pfnNotify, (WSB_PMSG)0, \
//              1, afxDispCustom, idFirst, idLast }, \
//
//      #define ON_EVENT_REFLECT(theClass, dispid, pfnHandler, vtsParams) \
//          { _T(""), dispid, vtsParams, VT_BOOL, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnHandler, (WSB_PMSG)0, 0, \
//              afxDispCustom, (UINT)-1, (UINT)-1 }, \
//
//      #define ON_PROPNOTIFY_REFLECT(theClass, dispid, pfnRequest, pfnChanged) \
//          { _T(""), dispid, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(BOOL*))&pfnRequest, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(void))&pfnChanged, \
//              1, afxDispCustom, (UINT)-1, (UINT)-1 }, \
//
//      #endif // !_WSB_NO_OCC_SUPPORT
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Macros for type library information
//
//      CTypeLibCache* WSBAPI WsbGetTypeLibCache(const GUID* pTypeLibID);
//
//      #define DECLARE_WSBTYPELIB(class_name) \
//          protected: \
//              virtual UINT GetTypeInfoCount(); \
//              virtual HRESULT GetTypeLib(LCID, LPTYPELIB*); \
//              virtual CTypeLibCache* GetTypeLibCache(); \
//
//      #define IMPLEMENT_WSBTYPELIB(class_name, tlid, wVerMajor, wVerMinor) \
//          UINT class_name::GetTypeInfoCount() \
//              { return 1; } \
//          HRESULT class_name::GetTypeLib(LCID lcid, LPTYPELIB* ppTypeLib) \
//              { return ::LoadRegTypeLib(tlid, wVerMajor, wVerMinor, lcid, ppTypeLib); } \
//          CTypeLibCache* class_name::GetTypeLibCache() \
//              { WSB_MANAGE_STATE(m_pModuleState); return WsbGetTypeLibCache(&tlid); } \
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Init & Term helpers
//
//      BOOL WSBAPI WsbWsbInit();
//      void WSBAPI WsbWsbTerm(BOOL bJustRevoke = FALSE);
//      void WSBAPI WsbWsbTermOrFreeLib(BOOL bTerm = TRUE, BOOL bJustRevoke = FALSE);
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Memory management helpers (for WSB task allocator memory)
//
//      #define WsbAllocTaskMem(nSize) CoTaskMemAlloc(nSize)
//      #define WsbFreeTaskMem(p) CoTaskMemFree(p)
//
//      LPWSTR WSBAPI WsbAllocTaskWideString(LPCWSTR lpszString);
//      LPWSTR WSBAPI WsbAllocTaskWideString(LPCSTR lpszString);
//      LPSTR WSBAPI WsbAllocTaskAnsiString(LPCWSTR lpszString);
//      LPSTR WSBAPI WsbAllocTaskAnsiString(LPCSTR lpszString);
//
//      #ifdef _UNICODE
//          #define WsbAllocTaskString(x) WsbAllocTaskWideString(x)
//      #else
//          #define WsbAllocTaskString(x) WsbAllocTaskAnsiString(x)
//      #endif
//
//      #ifdef WSB2ANSI
//          #define WsbAllocTaskWsbString(x) WsbAllocTaskAnsiString(x)
//      #else
//          #define WsbAllocTaskWsbString(x) WsbAllocTaskWideString(x)
//      #endif
//
//      HRESULT WSBAPI WsbGetClassIDFromString(LPCTSTR lpsz, LPCLSID lpClsID);
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Special in-proc server APIs
//
//      SCODE WSBAPI WsbDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
//      SCODE WSBAPI WsbDllCanUnloadNow(void);

/////////////////////////////////////////////////////////////////////////////
// CWsbDVariant class helpers

#define WSB_TRUE (-1)
#define WSB_FALSE 0

class CLongBinary;                      // forward reference (see afxdb_.h)

/////////////////////////////////////////////////////////////////////////////
// CWsbDVariant class - wraps VARIANT types

typedef const VARIANT* LPCVARIANT;

class CWsbDVariant : public tagVARIANT
{
// Constructors
public:
    CWsbDVariant();

    CWsbDVariant(const VARIANT& varSrc);
    CWsbDVariant(LPCVARIANT pSrc);
    CWsbDVariant(const CWsbDVariant& varSrc);

    CWsbDVariant(LPCTSTR lpszSrc);
    CWsbDVariant(LPCTSTR lpszSrc, VARTYPE vtSrc); // used to set to ANSI string
//  CWsbDVariant(CString& strSrc);

    CWsbDVariant(BYTE nSrc);
    CWsbDVariant(short nSrc, VARTYPE vtSrc = VT_I2);
    CWsbDVariant(long lSrc, VARTYPE vtSrc = VT_I4);
//  CWsbDVariant(const CWsbCurrency& curSrc);

    CWsbDVariant(float fltSrc);
    CWsbDVariant(double dblSrc);
    CWsbDVariant(const CWsbDateTime& timeSrc);

//  CWsbDVariant(const CByteArray& arrSrc);
//  CWsbDVariant(const CLongBinary& lbSrc);

// Operations
public:
    void Clear();
    void ChangeType(VARTYPE vartype, LPVARIANT pSrc = NULL);
    void Attach(VARIANT& varSrc);
    VARIANT Detach();

    BOOL operator==(const VARIANT& varSrc) const;
    BOOL operator==(LPCVARIANT pSrc) const;

    const CWsbDVariant& operator=(const VARIANT& varSrc);
    const CWsbDVariant& operator=(LPCVARIANT pSrc);
    const CWsbDVariant& operator=(const CWsbDVariant& varSrc);

    const CWsbDVariant& operator=(const LPCTSTR lpszSrc);
//  const CWsbDVariant& operator=(const CString& strSrc);

    const CWsbDVariant& operator=(BYTE nSrc);
    const CWsbDVariant& operator=(short nSrc);
    const CWsbDVariant& operator=(long lSrc);
//  const CWsbDVariant& operator=(const CWsbCurrency& curSrc);

    const CWsbDVariant& operator=(float fltSrc);
    const CWsbDVariant& operator=(double dblSrc);
    const CWsbDVariant& operator=(const CWsbDateTime& dateSrc);

//  const CWsbDVariant& operator=(const CByteArray& arrSrc);
//  const CWsbDVariant& operator=(const CLongBinary& lbSrc);

    void SetString(LPCTSTR lpszSrc, VARTYPE vtSrc); // used to set ANSI string

    operator LPVARIANT();
    operator LPCVARIANT() const;

//      // Implementation
    public:
        ~CWsbDVariant();
};

// CWsbDVariant diagnostics and serialization
//      #ifdef _DEBUG
//      CDumpContext& WSBAPI operator<<(CDumpContext& dc, CWsbDVariant varSrc);
//      #endif
//      CArchive& WSBAPI operator<<(CArchive& ar, CWsbDVariant varSrc);
//      CArchive& WSBAPI operator>>(CArchive& ar, CWsbDVariant& varSrc);

// Helper for initializing VARIANT structures
void WSBAPI WsbDVariantInit(LPVARIANT pVar);

//      /////////////////////////////////////////////////////////////////////////////
//      // CWsbCurrency class
//
//      class CWsbCurrency
//      {
//      // Constructors
//      public:
//          CWsbCurrency();
//
//          CWsbCurrency(CURRENCY cySrc);
//          CWsbCurrency(const CWsbCurrency& curSrc);
//          CWsbCurrency(const VARIANT& varSrc);
//          CWsbCurrency(long nUnits, long nFractionalUnits);
//
//      // Attributes
//      public:
//          enum CurrencyStatus
//          {
//              valid = 0,
//              invalid = 1,    // Invalid currency (overflow, div 0, etc.)
//              null = 2,       // Literally has no value
//          };
//
//          CURRENCY m_cur;
//          CurrencyStatus m_status;
//
//          void SetStatus(CurrencyStatus status);
//          CurrencyStatus etStatus() const;
//
//      // Operations
//      public:
//          const CWsbCurrency& operator=(CURRENCY cySrc);
//          const CWsbCurrency& operator=(const CWsbCurrency& curSrc);
//          const CWsbCurrency& operator=(const VARIANT& varSrc);
//
//          BOOL operator==(const CWsbCurrency& cur) const;
//          BOOL operator!=(const CWsbCurrency& cur) const;
//          BOOL operator<(const CWsbCurrency& cur) const;
//          BOOL operator>(const CWsbCurrency& cur) const;
//          BOOL operator<=(const CWsbCurrency& cur) const;
//          BOOL operator>=(const CWsbCurrency& cur) const;
//
//          // Currency math
//          CWsbCurrency operator+(const CWsbCurrency& cur) const;
//          CWsbCurrency operator-(const CWsbCurrency& cur) const;
//          const CWsbCurrency& operator+=(const CWsbCurrency& cur);
//          const CWsbCurrency& operator-=(const CWsbCurrency& cur);
//          CWsbCurrency operator-() const;
//
//          CWsbCurrency operator*(long nOperand) const;
//          CWsbCurrency operator/(long nOperand) const;
//          const CWsbCurrency& operator*=(long nOperand);
//          const CWsbCurrency& operator/=(long nOperand);
//
//          operator CURRENCY() const;
//
//          // Currency definition
//          void SetCurrency(long nUnits, long nFractionalUnits);
//          BOOL ParseCurrency(LPCTSTR lpszCurrency, DWORD dwFlags = 0,
//              LCID = LANG_USER_DEFAULT);
//
//          // formatting
//          CString Format(DWORD dwFlags = 0, LCID lcid = LANG_USER_DEFAULT) const;
//      };
//
//      // CWsbCurrency diagnostics and serialization
//      #ifdef _DEBUG
//      CDumpContext& WSBAPI operator<<(CDumpContext& dc, CWsbCurrency curSrc);
//      #endif
//      CArchive& WSBAPI operator<<(CArchive& ar, CWsbCurrency curSrc);
//      CArchive& WSBAPI operator>>(CArchive& ar, CWsbCurrency& curSrc);

/////////////////////////////////////////////////////////////////////////////
// CWsbDateTime class helpers

#define WSB_DATETIME_ERROR (-1)

/////////////////////////////////////////////////////////////////////////////
// CWsbDateTime class

class CWsbDateTime
{
// Constructors
public:
    static CWsbDateTime PASCAL GetCurrentTime();

    CWsbDateTime();

    CWsbDateTime(const CWsbDateTime& dateSrc);
    CWsbDateTime(const VARIANT& varSrc);
    CWsbDateTime(DATE dtSrc);

    CWsbDateTime(time_t timeSrc);
    CWsbDateTime(const SYSTEMTIME& systimeSrc);
    CWsbDateTime(const FILETIME& filetimeSrc);

    CWsbDateTime(int nYear, int nMonth, int nDay,
        int nHour, int nMin, int nSec);
    CWsbDateTime(WORD wDosDate, WORD wDosTime);

// Attributes
public:
    enum DateTimeStatus
    {
        valid = 0,
        invalid = 1,    // Invalid date (out of range, etc.)
        null = 2,       // Literally has no value
    };

    DATE m_dt;
    DateTimeStatus m_status;

    void SetStatus(DateTimeStatus status);
    DateTimeStatus GetStatus() const;

    int GetYear() const;
    int GetMonth() const;       // month of year (1 = Jan)
    int GetDay() const;         // day of month (0-31)
    int GetHour() const;        // hour in day (0-23)
    int GetMinute() const;      // minute in hour (0-59)
    int GetSecond() const;      // second in minute (0-59)
    int GetDayOfWeek() const;   // 1=Sun, 2=Mon, ..., 7=Sat
    int GetDayOfYear() const;   // days since start of year, Jan 1 = 1

// Operations
public:
    const CWsbDateTime& operator=(const CWsbDateTime& dateSrc);
    const CWsbDateTime& operator=(const VARIANT& varSrc);
    const CWsbDateTime& operator=(DATE dtSrc);

    const CWsbDateTime& operator=(const time_t& timeSrc);
    const CWsbDateTime& operator=(const SYSTEMTIME& systimeSrc);
    const CWsbDateTime& operator=(const FILETIME& filetimeSrc);

    BOOL operator==(const CWsbDateTime& date) const;
    BOOL operator!=(const CWsbDateTime& date) const;
    BOOL operator<(const CWsbDateTime& date) const;
    BOOL operator>(const CWsbDateTime& date) const;
    BOOL operator<=(const CWsbDateTime& date) const;
    BOOL operator>=(const CWsbDateTime& date) const;

    // DateTime math
    CWsbDateTime operator+(const CWsbDateTimeSpan& dateSpan) const;
    CWsbDateTime operator-(const CWsbDateTimeSpan& dateSpan) const;
    const CWsbDateTime& operator+=(const CWsbDateTimeSpan dateSpan);
    const CWsbDateTime& operator-=(const CWsbDateTimeSpan dateSpan);

    // DateTimeSpan math
    CWsbDateTimeSpan operator-(const CWsbDateTime& date) const;

    operator DATE() const;

    BOOL SetDateTime(int nYear, int nMonth, int nDay,
        int nHour, int nMin, int nSec);
    BOOL SetDate(int nYear, int nMonth, int nDay);
    BOOL SetTime(int nHour, int nMin, int nSec);

//  BOOL ParseDateTime(LPCTSTR lpszDate, DWORD dwFlags = 0,
//      LCID lcid = LANG_USER_DEFAULT);

    // formatting
//          CString Format(DWORD dwFlags = 0, LCID lcid = LANG_USER_DEFAULT) const;
//          CString Format(LPCTSTR lpszFormat) const;
//          CString Format(UINT nFormatID) const;

// Implementation
protected:
    void CheckRange();
    friend CWsbDateTimeSpan;
};

// CWsbDateTime diagnostics and serialization
//      #ifdef _DEBUG
//      CDumpContext& WSBAPI operator<<(CDumpContext& dc, CWsbDateTime dateSrc);
//      #endif
//      CArchive& WSBAPI operator<<(CArchive& ar, CWsbDateTime dateSrc);
//      CArchive& WSBAPI operator>>(CArchive& ar, CWsbDateTime& dateSrc);

/////////////////////////////////////////////////////////////////////////////
// CWsbDateTimeSpan class
class CWsbDateTimeSpan
{
// Constructors
public:
    CWsbDateTimeSpan();

    CWsbDateTimeSpan(double dblSpanSrc);
    CWsbDateTimeSpan(const CWsbDateTimeSpan& dateSpanSrc);
    CWsbDateTimeSpan(long lDays, int nHours, int nMins, int nSecs);

// Attributes
public:
    enum DateTimeSpanStatus
    {
        valid = 0,
        invalid = 1,    // Invalid span (out of range, etc.)
        null = 2,       // Literally has no value
    };

    double m_span;
    DateTimeSpanStatus m_status;

    void SetStatus(DateTimeSpanStatus status);
    DateTimeSpanStatus GetStatus() const;

    double GetTotalDays() const;    // span in days (about -3.65e6 to 3.65e6)
    double GetTotalHours() const;   // span in hours (about -8.77e7 to 8.77e6)
    double GetTotalMinutes() const; // span in minutes (about -5.26e9 to 5.26e9)
    double GetTotalSeconds() const; // span in seconds (about -3.16e11 to 3.16e11)

    long GetDays() const;           // component days in span
    long GetHours() const;          // component hours in span (-23 to 23)
    long GetMinutes() const;        // component minutes in span (-59 to 59)
    long GetSeconds() const;        // component seconds in span (-59 to 59)

// Operations
public:
    const CWsbDateTimeSpan& operator=(double dblSpanSrc);
    const CWsbDateTimeSpan& operator=(const CWsbDateTimeSpan& dateSpanSrc);

    BOOL operator==(const CWsbDateTimeSpan& dateSpan) const;
    BOOL operator!=(const CWsbDateTimeSpan& dateSpan) const;
    BOOL operator<(const CWsbDateTimeSpan& dateSpan) const;
    BOOL operator>(const CWsbDateTimeSpan& dateSpan) const;
    BOOL operator<=(const CWsbDateTimeSpan& dateSpan) const;
    BOOL operator>=(const CWsbDateTimeSpan& dateSpan) const;

    // DateTimeSpan math
    CWsbDateTimeSpan operator+(const CWsbDateTimeSpan& dateSpan) const;
    CWsbDateTimeSpan operator-(const CWsbDateTimeSpan& dateSpan) const;
    const CWsbDateTimeSpan& operator+=(const CWsbDateTimeSpan dateSpan);
    const CWsbDateTimeSpan& operator-=(const CWsbDateTimeSpan dateSpan);
    CWsbDateTimeSpan operator-() const;

    operator double() const;

    void SetDateTimeSpan(long lDays, int nHours, int nMins, int nSecs);

    // formatting
//          CString Format(LPCTSTR pFormat) const;
//          CString Format(UINT nID) const;

// Implementation
public:
    void CheckRange();
    friend CWsbDateTime;
};

// CWsbDateTimeSpan diagnostics and serialization
//      #ifdef _DEBUG
//      CDumpContext& WSBAPI operator<<(CDumpContext& dc,CWsbDateTimeSpan dateSpanSrc);
//      #endif
//      CArchive& WSBAPI operator<<(CArchive& ar, CWsbDateTimeSpan dateSpanSrc);
//      CArchive& WSBAPI operator>>(CArchive& ar, CWsbDateTimeSpan& dateSpanSrc);

/////////////////////////////////////////////////////////////////////////////
// Helper for initializing CWsbSafeArray
//      void WSBAPI WsbSafeArrayInit(CWsbSafeArray* psa);

//      /////////////////////////////////////////////////////////////////////////////
//      // CSafeArray class
//
//      typedef const SAFEARRAY* LPCSAFEARRAY;
//
//      class CWsbSafeArray : public tagVARIANT
//      {
//      //Constructors
//      public:
//          CWsbSafeArray();
//          CWsbSafeArray(const SAFEARRAY& saSrc, VARTYPE vtSrc);
//          CWsbSafeArray(LPCSAFEARRAY pSrc, VARTYPE vtSrc);
//          CWsbSafeArray(const CWsbSafeArray& saSrc);
//          CWsbSafeArray(const VARIANT& varSrc);
//          CWsbSafeArray(LPCVARIANT pSrc);
//          CWsbSafeArray(const CWsbDVariant& varSrc);
//
//      // Operations
//      public:
//          void Clear();
//          void Attach(VARIANT& varSrc);
//          VARIANT Detach();
//
//          CWsbSafeArray& operator=(const CWsbSafeArray& saSrc);
//          CWsbSafeArray& operator=(const VARIANT& varSrc);
//          CWsbSafeArray& operator=(LPCVARIANT pSrc);
//          CWsbSafeArray& operator=(const CWsbDVariant& varSrc);
//
//          BOOL operator==(const SAFEARRAY& saSrc) const;
//          BOOL operator==(LPCSAFEARRAY pSrc) const;
//          BOOL operator==(const CWsbSafeArray& saSrc) const;
//          BOOL operator==(const VARIANT& varSrc) const;
//          BOOL operator==(LPCVARIANT pSrc) const;
//          BOOL operator==(const CWsbDVariant& varSrc) const;
//
//          operator LPVARIANT();
//          operator LPCVARIANT() const;
//
//          // One dim array helpers
//          void CreateOneDim(VARTYPE vtSrc, DWORD dwElements,
//              void* pvSrcData = NULL, long nLBound = 0);
//          DWORD GetOneDimSize();
//          void ResizeOneDim(DWORD dwElements);
//
//          // Multi dim array helpers
//          void Create(VARTYPE vtSrc, DWORD dwDims, DWORD* rgElements);
//
//          // SafeArray wrapper classes
//          void Create(VARTYPE vtSrc, DWORD dwDims, SAFEARRAYBOUND* rgsabounds);
//          void AccessData(void** ppvData);
//          void UnaccessData();
//          void AllocData();
//          void AllocDescriptor(DWORD dwDims);
//          void Copy(LPSAFEARRAY* ppsa);
//          void GetLBound(DWORD dwDim, long* pLBound);
//          void GetUBound(DWORD dwDim, long* pUBound);
//          void GetElement(long* rgIndices, void* pvData);
//          void PtrOfIndex(long* rgIndices, void** ppvData);
//          void PutElement(long* rgIndices, void* pvData);
//          void Redim(SAFEARRAYBOUND* psaboundNew);
//          void Lock();
//          void Unlock();
//          DWORD GetDim();
//          DWORD GetElemSize();
//          void Destroy();
//          void DestroyData();
//          void DestroyDescriptor();
//
//      //Implementation
//      public:
//          ~CWsbSafeArray();
//
//          // Cache info to make element access (operator []) faster
//          DWORD m_dwElementSize;
//          DWORD m_dwDims;
//      };
//
//      // CWsbSafeArray diagnostics and serialization
//      #ifdef _DEBUG
//      CDumpContext& WSBAPI operator<<(CDumpContext& dc, CWsbSafeArray saSrc);
//      #endif
//      CArchive& WSBAPI operator<<(CArchive& ar, CWsbSafeArray saSrc);
//      CArchive& WSBAPI operator>>(CArchive& ar, CWsbSafeArray& saSrc);

//      /////////////////////////////////////////////////////////////////////////////
//      // DDX_ functions for WSB controls on dialogs
//
//      #ifndef _WSB_NO_OCC_SUPPORT
//
//      void WSBAPI DDX_OCText(CDataExchange* pDX, int nIDC, DISPID dispid,
//          CString& value);
//      void WSBAPI DDX_OCTextRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          CString& value);
//      void WSBAPI DDX_OCBool(CDataExchange* pDX, int nIDC, DISPID dispid,
//          BOOL& value);
//      void WSBAPI DDX_OCBoolRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          BOOL& value);
//      void WSBAPI DDX_OCInt(CDataExchange* pDX, int nIDC, DISPID dispid,
//          int &value);
//      void WSBAPI DDX_OCIntRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          int &value);
//      void WSBAPI DDX_OCInt(CDataExchange* pDX, int nIDC, DISPID dispid,
//          long &value);
//      void WSBAPI DDX_OCIntRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          long &value);
//      void WSBAPI DDX_OCShort(CDataExchange* pDX, int nIDC, DISPID dispid,
//          short& value);
//      void WSBAPI DDX_OCShortRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          short& value);
//      void WSBAPI DDX_OCColor(CDataExchange* pDX, int nIDC, DISPID dispid,
//          WSB_COLOR& value);
//      void WSBAPI DDX_OCColorRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          WSB_COLOR& value);
//      void WSBAPI DDX_OCFloat(CDataExchange* pDX, int nIDC, DISPID dispid,
//          float& value);
//      void WSBAPI DDX_OCFloatRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          float& value);
//      void WSBAPI DDX_OCFloat(CDataExchange* pDX, int nIDC, DISPID dispid,
//          double& value);
//      void WSBAPI DDX_OCFloatRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//                                double& value);
//
//      #endif // !_WSB_NO_OCC_SUPPORT
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Function to enable containment of WSB controls
//
//      #ifndef _WSB_NO_OCC_SUPPORT
//      void WSB_CDECL WsbEnableControlContainer(COccManager* pOccManager=NULL);
//      #else
//      #define WsbEnableControlContainer()
//      #endif
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Inline function declarations
//
//      #ifdef _WSB_PACKING
//      #pragma pack(pop)
//      #endif
//
//      #ifdef _WSB_ENABLE_INLINES
//      #define _WSBDATE_INLINE inline
//      #include <afxole.inl>
//      #undef _WSBDATE_INLINE
//      #endif
//
//      #undef WSB_DATA
//      #define WSB_DATA
//
//      #ifdef _WSB_MINREBUILD
//      #pragma component(minrebuild, on)
//      #endif
//      #ifndef _WSB_FULLTYPEINFO
//      #pragma component(mintypeinfo, off)
//      #endif
//


//
// Low level sanity checks for memory blocks
//
//     this was copied from afx.h

BOOL WSBAPI WsbIsValidAddress(const void* lp,
                        UINT nBytes, BOOL bReadWrite = TRUE);


//
// Inline Functions
//
//     These were copied from afxole.inl
//

#define _WSBDISP_INLINE inline

// CWsbDVariant
_WSBDISP_INLINE CWsbDVariant::CWsbDVariant()
    { WsbDVariantInit(this); }
_WSBDISP_INLINE CWsbDVariant::~CWsbDVariant()
    { ::VariantClear(this); }
_WSBDISP_INLINE CWsbDVariant::CWsbDVariant(LPCTSTR lpszSrc)
    { vt = VT_EMPTY; *this = lpszSrc; }
//      _WSBDISP_INLINE CWsbDVariant::CWsbDVariant(CString& strSrc)
//          { vt = VT_EMPTY; *this = strSrc; }
//      _WSBDISP_INLINE CWsbDVariant::CWsbDVariant(BYTE nSrc)
//          { vt = VT_UI1; bVal = nSrc; }
//      _WSBDISP_INLINE CWsbDVariant::CWsbDVariant(const CWsbCurrency& curSrc)
//          { vt = VT_CY; cyVal = curSrc.m_cur; }
_WSBDISP_INLINE CWsbDVariant::CWsbDVariant(float fltSrc)
    { vt = VT_R4; fltVal = fltSrc; }
_WSBDISP_INLINE CWsbDVariant::CWsbDVariant(double dblSrc)
    { vt = VT_R8; dblVal = dblSrc; }
_WSBDISP_INLINE CWsbDVariant::CWsbDVariant(const CWsbDateTime& dateSrc)
    { vt = VT_DATE; date = dateSrc.m_dt; }
//      _WSBDISP_INLINE CWsbDVariant::CWsbDVariant(const CByteArray& arrSrc)
//          { vt = VT_EMPTY; *this = arrSrc; }
//      _WSBDISP_INLINE CWsbDVariant::CWsbDVariant(const CLongBinary& lbSrc)
//          { vt = VT_EMPTY; *this = lbSrc; }
_WSBDISP_INLINE BOOL CWsbDVariant::operator==(LPCVARIANT pSrc) const
    { return *this == *pSrc; }
_WSBDISP_INLINE CWsbDVariant::operator LPVARIANT()
    { return this; }
_WSBDISP_INLINE CWsbDVariant::operator LPCVARIANT() const
    { return this; }


// CWsbDateTime
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime()
    { m_dt = 0; SetStatus(valid); }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(const CWsbDateTime& dateSrc)
    { m_dt = dateSrc.m_dt; m_status = dateSrc.m_status; }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(const VARIANT& varSrc)
    { *this = varSrc; }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(DATE dtSrc)
    { m_dt = dtSrc; SetStatus(valid); }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(time_t timeSrc)
    { *this = timeSrc; }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(const SYSTEMTIME& systimeSrc)
    { *this = systimeSrc; }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(const FILETIME& filetimeSrc)
    { *this = filetimeSrc; }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(int nYear, int nMonth, int nDay,
    int nHour, int nMin, int nSec)
    { SetDateTime(nYear, nMonth, nDay, nHour, nMin, nSec); }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(WORD wDosDate, WORD wDosTime)
    { m_status = DosDateTimeToVariantTime(wDosDate, wDosTime, &m_dt) ?
        valid : invalid; }
_WSBDISP_INLINE const CWsbDateTime& CWsbDateTime::operator=(const CWsbDateTime& dateSrc)
    { m_dt = dateSrc.m_dt; m_status = dateSrc.m_status; return *this; }
_WSBDISP_INLINE CWsbDateTime::DateTimeStatus CWsbDateTime::GetStatus() const
    { return m_status; }
_WSBDISP_INLINE void CWsbDateTime::SetStatus(DateTimeStatus status)
    { m_status = status; }
_WSBDISP_INLINE BOOL CWsbDateTime::operator==(const CWsbDateTime& date) const
    { return (m_status == date.m_status && m_dt == date.m_dt); }
_WSBDISP_INLINE BOOL CWsbDateTime::operator!=(const CWsbDateTime& date) const
    { return (m_status != date.m_status || m_dt != date.m_dt); }
_WSBDISP_INLINE const CWsbDateTime& CWsbDateTime::operator+=(
    const CWsbDateTimeSpan dateSpan)
    { *this = *this + dateSpan; return *this; }
_WSBDISP_INLINE const CWsbDateTime& CWsbDateTime::operator-=(
    const CWsbDateTimeSpan dateSpan)
    { *this = *this - dateSpan; return *this; }
_WSBDISP_INLINE CWsbDateTime::operator DATE() const
    { return m_dt; }
_WSBDISP_INLINE CWsbDateTime::SetDate(int nYear, int nMonth, int nDay)
    { return SetDateTime(nYear, nMonth, nDay, 0, 0, 0); }
_WSBDISP_INLINE CWsbDateTime::SetTime(int nHour, int nMin, int nSec)
    // Set date to zero date - 12/30/1899
    { return SetDateTime(1899, 12, 30, nHour, nMin, nSec); }

// CWsbDateTimeSpan
_WSBDISP_INLINE CWsbDateTimeSpan::CWsbDateTimeSpan()
    { m_span = 0; SetStatus(valid); }
_WSBDISP_INLINE CWsbDateTimeSpan::CWsbDateTimeSpan(double dblSpanSrc)
    { m_span = dblSpanSrc; SetStatus(valid); }
_WSBDISP_INLINE CWsbDateTimeSpan::CWsbDateTimeSpan(
    const CWsbDateTimeSpan& dateSpanSrc)
    { m_span = dateSpanSrc.m_span; m_status = dateSpanSrc.m_status; }
_WSBDISP_INLINE CWsbDateTimeSpan::CWsbDateTimeSpan(
    long lDays, int nHours, int nMins, int nSecs)
    { SetDateTimeSpan(lDays, nHours, nMins, nSecs); }
_WSBDISP_INLINE CWsbDateTimeSpan::DateTimeSpanStatus CWsbDateTimeSpan::GetStatus() const
    { return m_status; }
_WSBDISP_INLINE void CWsbDateTimeSpan::SetStatus(DateTimeSpanStatus status)
    { m_status = status; }
_WSBDISP_INLINE double CWsbDateTimeSpan::GetTotalDays() const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA); return m_span; }
_WSBDISP_INLINE double CWsbDateTimeSpan::GetTotalHours() const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA); return m_span * 24; }
_WSBDISP_INLINE double CWsbDateTimeSpan::GetTotalMinutes() const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA); return m_span * 24 * 60; }
_WSBDISP_INLINE double CWsbDateTimeSpan::GetTotalSeconds() const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA); return m_span * 24 * 60 * 60; }
_WSBDISP_INLINE long CWsbDateTimeSpan::GetDays() const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA); return (long)m_span; }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator==(
    const CWsbDateTimeSpan& dateSpan) const
    { return (m_status == dateSpan.m_status &&
        m_span == dateSpan.m_span); }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator!=(
    const CWsbDateTimeSpan& dateSpan) const
    { return (m_status != dateSpan.m_status ||
        m_span != dateSpan.m_span); }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator<(
    const CWsbDateTimeSpan& dateSpan) const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA);
        WsbAssert(dateSpan.GetStatus() == valid, WSB_E_INVALID_DATA);
        return m_span < dateSpan.m_span; }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator>(
    const CWsbDateTimeSpan& dateSpan) const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA);
        WsbAssert(dateSpan.GetStatus() == valid, WSB_E_INVALID_DATA);
        return m_span > dateSpan.m_span; }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator<=(
    const CWsbDateTimeSpan& dateSpan) const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA);
        WsbAssert(dateSpan.GetStatus() == valid, WSB_E_INVALID_DATA);
        return m_span <= dateSpan.m_span; }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator>=(
    const CWsbDateTimeSpan& dateSpan) const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA);
        WsbAssert(dateSpan.GetStatus() == valid, WSB_E_INVALID_DATA);
        return m_span >= dateSpan.m_span; }
_WSBDISP_INLINE const CWsbDateTimeSpan& CWsbDateTimeSpan::operator+=(
    const CWsbDateTimeSpan dateSpan)
    { *this = *this + dateSpan; return *this; }
_WSBDISP_INLINE const CWsbDateTimeSpan& CWsbDateTimeSpan::operator-=(
    const CWsbDateTimeSpan dateSpan)
    { *this = *this - dateSpan; return *this; }
_WSBDISP_INLINE CWsbDateTimeSpan CWsbDateTimeSpan::operator-() const
    { return -this->m_span; }
_WSBDISP_INLINE CWsbDateTimeSpan::operator double() const
    { return m_span; }

#undef _WSBDISP_INLINE

#endif //__WSBDATE_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbfirst.h ===
#ifndef _WSBFIRST_H
#define _WSBFIRST_H

/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbfirst.h

Abstract:

    This module defines some absolutely necessary stuff for WSB and other modules. This header is expected
    to be the first one included by Wsb.h

Author:

    Michael Lotz    [lotz]      12-Apr-1997

Revision History:

--*/

//
// Override values in \nt\public\inc\warning.h and other gotcha's
//
#pragma warning(3:4101)   // Unreferenced local variable
#pragma warning(3:4100)   // Unreferenced formal parameter
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4706)   // assignment w/i conditional expression
#pragma warning(3:4709)   // command operator w/o index expression
#pragma warning(3:4244)   // 'int' conversion warnings

// Demote warnings about: The string for a title or subtitle pragma exceeded the
// maximum allowable length and was truncated. These show up when generating
// browser info for ATL code.
#pragma warning(4:4786)   // command operator w/o index expression

// This supresses warning messages that come from exporting
// abstract classes derived from CComObjectRoot and that use
// COM templates.
#pragma warning(disable:4251 4275)

#include <atlbase.h>

//
// If you are building a service, make sure your precompiled header defines WSB_ATL_COM_SERVICE. Then _Module
// will be defined correctly for a service. Otherwise it we default to _Module being set correctly for a
// standard module.
//
#ifdef WSB_ATL_COM_SERVICE
// You may derive a class from CComModule and use it if you want to override
// something, but do not change the name of _Module
//

class CServiceModule : public CComModule
{
public:
    HRESULT RegisterServer(BOOL bRegTypeLib);
    HRESULT UnregisterServer();
    void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h);
    void Start();
    void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    DWORD HandlerEx(DWORD dwOpcode, DWORD fdwEventType,
            LPVOID lpEventData, LPVOID lpContext);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
    LONG Unlock();
    void LogEvent(DWORD eventId, ...);
    void SetServiceStatus(DWORD dwState);

//Implementation
private:
    static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static DWORD WINAPI _HandlerEx(DWORD dwOpcode, DWORD fdwEventType,
            LPVOID lpEventData, LPVOID lpContext);

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
    DWORD dwThreadID;
    BOOL m_bService;
};

extern CServiceModule _Module;

#else
//
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
//
extern CComModule _Module;

#endif

//
// Include the basic AtlCom.h file for the rest of the COM definitions
//
#include <atlcom.h>

// Are we defining imports or exports?
#ifdef WSB_IMPL
#define WSB_EXPORT      __declspec(dllexport)
#else
#define WSB_EXPORT      __declspec(dllimport)
#endif

//  Flag values used in HSM_SYSTEM_STATE structure
#define HSM_STATE_NONE        0x00000000
#define HSM_STATE_SHUTDOWN    0x00000001
#define HSM_STATE_SUSPEND     0x00000002
#define HSM_STATE_RESUME      0x00000004

//  Defines for memory alloc/realloc/free functions so we can track
//  memory usage
#if defined(WSB_TRACK_MEMORY)

#define WsbAlloc(_cb)                       WsbMemAlloc(_cb, __FILE__, __LINE__)
#define WsbFree(_pv)                        WsbMemFree(_pv, __FILE__, __LINE__)
#define WsbRealloc(_pv, _cb)                WsbMemRealloc(_pv, _cb, __FILE__, __LINE__)

#define WsbAllocString(_sz)                 WsbSysAllocString(_sz, __FILE__, __LINE__)
#define WsbAllocStringLen(_sz, _cc)         WsbSysAllocStringLen(_sz, _cc, __FILE__, __LINE__)
#define WsbFreeString(_bs)                  WsbSysFreeString(_bs, __FILE__, __LINE__)
#define WsbReallocString(_pb, _sz)          WsbSysReallocString(_pb, _sz, __FILE__, __LINE__)
#define WsbReallocStringLen(_pb, _sz, _cc)  WsbSysReallocStringLen(_pb, _sz, _cc, __FILE__, __LINE__)

#else

#define WsbAlloc(_cb)                       CoTaskMemAlloc(_cb)
#define WsbFree(_pv)                        CoTaskMemFree(_pv)
#define WsbRealloc(_pv, _cb)                CoTaskMemRealloc(_pv, _cb)

#define WsbAllocString(_sz)                 SysAllocString(_sz)
#define WsbAllocStringLen(_sz, _cc)         SysAllocStringLen(_sz, _cc)
#define WsbFreeString(_bs)                  SysFreeString(_bs)
#define WsbReallocString(_pb, _sz)          SysReAllocString(_pb, _sz)
#define WsbReallocStringLen(_pb, _sz, _cc)  SysReAllocStringLen(_pb, _sz, _cc)
#endif

#endif // _WSBFIRST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbdbent.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbent.h

Abstract:

    The CWsbDbEntity class.

Author:

    Ron White   [ronw]   11-Dec-1996

Revision History:

--*/


#ifndef _WSBDBENT_
#define _WSBDBENT_

#include "wsbdb.h"


/*++

Class Name:

    CWsbDbEntity

Class Description:

    A data base entity.

--*/

class IDB_EXPORT CWsbDbEntity :
    public CWsbObject,
    public IWsbDbEntity,
    public IWsbDbEntityPriv
{

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbDbEntity
public:
    STDMETHOD(Clone)(REFIID riid, void** ppEntity);
    STDMETHOD(Disconnect)(void);
    STDMETHOD(FindEQ)(void);
    STDMETHOD(FindGT)(void);
    STDMETHOD(FindGTE)(void);
    STDMETHOD(FindLT)(void);
    STDMETHOD(FindLTE)(void);
    STDMETHOD(First)(void);
    STDMETHOD(Last)(void);
    STDMETHOD(MarkAsNew)(void);
    STDMETHOD(Next)(void);
    STDMETHOD(Previous)(void);
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(Remove)(void);
    STDMETHOD(UseKey)(ULONG type);
    STDMETHOD(Write)(void);
    STDMETHOD(SetSequentialScan)(void);
    STDMETHOD(ResetSequentialScan)(void);

// IWsbDbPriv - For internal use only!
    STDMETHOD(Copy)(IWsbDbEntity* pEntity);
    STDMETHOD(CopyValues)(ULONG flags, IWsbDbEntity* pEntity);
    STDMETHOD(GetCurKey)(IWsbDbKey** ppKey);
    STDMETHOD(GetKey)(ULONG KeyType, IWsbDbKey** ppKey);
    STDMETHOD(GetValue)(ULONG flag, ULONG* pValue);
    STDMETHOD(Init)(IWsbDb* pDb, IWsbDbSys *pDbSys, ULONG RecType, JET_SESID SessionId);
    STDMETHOD(SetValue)(ULONG flag, ULONG value);

// Derived Entity needs to define this:
    STDMETHOD(UpdateKey)(IWsbDbKey* /*pKey*/) { return(E_NOTIMPL); }

// Private utility functions
private:
    HRESULT compare(IWsbDbEntity* pEntity, SHORT* pResult);
    HRESULT fromMem(HGLOBAL hMem);
    HRESULT get_key(ULONG key_type, UCHAR* bytes, ULONG* pSize);
    HRESULT getMem(HGLOBAL* phMem);
    HRESULT toMem(HGLOBAL hMem, ULONG*  pSize);

    HRESULT jet_compare_field(ULONG col_id, UCHAR* bytes, ULONG size);
    HRESULT jet_get_data(void);
    HRESULT jet_make_current(void);
    HRESULT jet_move(LONG pos);
    HRESULT jet_seek(ULONG seek_flag);

protected:
    CComPtr<IWsbDbSys>  m_pDbSys;      // Pointer to associated Instance
    CComPtr<IWsbDb>     m_pDb;         // Pointer to associated DB
    COM_IDB_KEY_INFO*   m_pKeyInfo;    // Info. about rec. keys
    COM_IDB_REC_INFO    m_RecInfo;     // Rec. type, size, etc.
    BOOL                m_SaveAsNew;   // AsNew flag
    USHORT              m_UseKeyIndex; // Index into m_pKeyInfo of current control key

    ULONG               m_ColId;       // Jet column ID for record data
    HGLOBAL             m_hMem;        // Mem block for DB I/O
    LONG                m_SeqNum;      // Unique sequence number (for ID)
    BOOL                m_PosOk;       // Cursor is at current record?
    JET_SESID           m_SessionId;   // Jet session ID
    JET_TABLEID         m_TableId;     // Jet table ID

    BOOL                m_Sequential;  // Flag for sequential scan settings
};

#define WSB_FROM_CWSBDBENTITY_BASE \
    STDMETHOD(Clone)(REFIID riid, void** ppEntity) \
    {return(CWsbDbEntity::Clone(riid, ppEntity));} \
    STDMETHOD(Copy)(IWsbDbEntity* pEntity) \
    {return(CWsbDbEntity::Copy(pEntity)); } \
    STDMETHOD(Disconnect)(void) \
    {return(CWsbDbEntity::Disconnect());} \
    STDMETHOD(FindEQ)(void) \
    {return(CWsbDbEntity::FindEQ());} \
    STDMETHOD(FindGT)(void) \
    {return(CWsbDbEntity::FindGT());} \
    STDMETHOD(FindGTE)(void) \
    {return(CWsbDbEntity::FindGTE());} \
    STDMETHOD(FindLT)(void) \
    {return(CWsbDbEntity::FindLT());} \
    STDMETHOD(FindLTE)(void) \
    {return(CWsbDbEntity::FindLTE());} \
    STDMETHOD(First)(void) \
    {return(CWsbDbEntity::First());} \
    STDMETHOD(GetCurKey)(IWsbDbKey** ppKey) \
    {return(CWsbDbEntity::GetCurKey(ppKey)); } \
    STDMETHOD(Init)(IWsbDb* pDb, IWsbDbSys *pDbSys, ULONG RecType, ULONG Session) \
    {return(CWsbDbEntity::Init(pDb, pDbSys, RecType, Session)); } \
    STDMETHOD(Last)(void) \
    {return(CWsbDbEntity::Last());} \
    STDMETHOD(MarkAsNew)(void) \
    {return(CWsbDbEntity::MarkAsNew());} \
    STDMETHOD(Next)(void) \
    {return(CWsbDbEntity::Next());} \
    STDMETHOD(Previous)(void) \
    {return(CWsbDbEntity::Previous());} \
    STDMETHOD(Remove)(void) \
    {return(CWsbDbEntity::Remove());} \
    STDMETHOD(UseKey)(ULONG type) \
    {return(CWsbDbEntity::UseKey(type)); } \
    STDMETHOD(Write)(void) \
    {return(CWsbDbEntity::Write());} \
    STDMETHOD(SetSequentialScan)(void) \
    {return(CWsbDbEntity::SetSequentialScan());} \
    STDMETHOD(ResetSequentialScan)(void) \
    {return(CWsbDbEntity::ResetSequentialScan());} \


#define WSB_FROM_CWSBDBENTITY_IMP \
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult) \
    {return(CWsbDbEntity::CompareTo(pCollectable, pResult)); } \
    STDMETHOD(IsEqual)(IUnknown* pCollectable) \
    {return(CWsbDbEntity::IsEqual(pCollectable)); } \


#define WSB_FROM_CWSBDBENTITY \
    WSB_FROM_CWSBDBENTITY_BASE \
    WSB_FROM_CWSBDBENTITY_IMP


#endif // _WSBDBENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbfile.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbfile.h

Abstract:

    This module defines very specific CRC algorithm code

Author:

    Christopher J. Timmes    [ctimmes@avail.com]   23 Jun 1997

Revision History:
    Michael Lotz    [lotz]      30-Sept-1997

--*/


#ifndef _WSBFILE_H
#define _WSBFILE_H

extern   unsigned long crc_32_tab[];



extern "C"
{
extern
WSB_EXPORT
HRESULT  WsbCRCReadFile    (  BYTE*                                     pchCurrent,
                              ULONG*                                    oldcrc32       );
}
            

// ---------- implementation code for WsbCalcCRCofFile() ----------

// This is the CRC calculation algorythm.
// It is called with the current byte in the file and the current CRC value,
// and uses the 'crc_32_tab[]' table. The crc_32_tab[] look up table is externed above and resides
// in the wsbfile.obj object module. Any function or method using the macro below must include
// the wsbfile.obj in the link list.
//
// For example, it can be used in the following way:
// unsigned long ulCRC ;
//    
//      INITIALIZE_CRC( ulCRC );
//      for( all *bytes* that are to be CRCed )
//          CALC_CRC( current_byte, ulCRC );
//      FINIALIZE_CRC( ulCRC );
// 
// at this point ulCRC is the CRC value and can be used as the calculated CRC value
// 

#define INITIALIZE_CRC( crc )  ((crc) = 0xFFFFFFFF )
#define CALC_CRC( octet, crc ) ((crc) = ( crc_32_tab[((crc)^ (octet)) & 0xff] ^ ((crc) >> 8) ) )
#define FINIALIZE_CRC( crc )   ((crc) = ~(crc) )

// ---------------------- Defines to identify the CRC calculation types -------------
#define WSB_CRC_CALC_NONE               0x00000000
// Identify this algorithm and the Microsoft 32 bit CRC calculation
#define WSB_CRC_CALC_MICROSOFT_32       0x00000001

#endif // _WSBFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbfmt.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wsbfmt.h

Abstract:

    Definitions for  file-system formatting support routines

Author:

    Ravisankar Pudipeddi [ravisp] 19, January 2000

Revision History:

--*/

#ifndef _WSBFMT_
#define _WSBFMT_

#ifdef __cplusplus
extern "C" {
#endif

#define FSTYPE_FAT      1
#define FSTYPE_FAT32    2
#define FSTYPE_NTFS     3

//
// Flags definition
//
#define WSBFMT_ENABLE_VOLUME_COMPRESSION 1


WSB_EXPORT HRESULT
FormatPartition(
    IN PWSTR volumeSpec, 
    IN LONG fsType, 
    IN PWSTR label,
    IN ULONG fsflags, 
    IN BOOLEAN quick, 
    IN BOOLEAN force,
    IN ULONG allocationUnitSize
);

#ifdef __cplusplus
}
#endif

#endif // _WSBFMT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbport.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbPort.h

Abstract:

    Macros, functions, and classes to support portability.

Author:

    Ron White   [ronw]   19-Dec-1996

Revision History:

--*/


#ifndef _WSBPORT_
#define _WSBPORT_

// Portable sizes of standard types
#define WSB_BYTE_SIZE_BOOL           1
#define WSB_BYTE_SIZE_BYTE           1
#define WSB_BYTE_SIZE_DATE           8
#define WSB_BYTE_SIZE_FILETIME       8
#define WSB_BYTE_SIZE_GUID           16
#define WSB_BYTE_SIZE_LONG           4
#define WSB_BYTE_SIZE_LONGLONG       8
#define WSB_BYTE_SIZE_ULONGLONG      8
#define WSB_BYTE_SIZE_SHORT          2
#define WSB_BYTE_SIZE_ULARGE_INTEGER 8
#define WSB_BYTE_SIZE_ULONG          4
#define WSB_BYTE_SIZE_USHORT         2

// Functions for determinining how many bytes the standard types use
// when portably converted
inline size_t WsbByteSize(BOOL value) { value; return(WSB_BYTE_SIZE_BOOL); }
inline size_t WsbByteSize(GUID value) { value; return(WSB_BYTE_SIZE_GUID); }
inline size_t WsbByteSize(LONG value) { value; return(WSB_BYTE_SIZE_LONG); }
inline size_t WsbByteSize(LONGLONG value) { value; return(WSB_BYTE_SIZE_LONGLONG); }
inline size_t WsbByteSize(ULONGLONG value) { value; return(WSB_BYTE_SIZE_ULONGLONG); }
inline size_t WsbByteSize(DATE value) { value; return(WSB_BYTE_SIZE_DATE); }
inline size_t WsbByteSize(FILETIME value) { value; return(WSB_BYTE_SIZE_FILETIME); }
inline size_t WsbByteSize(SHORT value) { value; return(WSB_BYTE_SIZE_SHORT); }
inline size_t WsbByteSize(BYTE value) { value; return(WSB_BYTE_SIZE_BYTE); }
inline size_t WsbByteSize(ULONG value) { value; return(WSB_BYTE_SIZE_ULONG); }
inline size_t WsbByteSize(USHORT value) { value; return(WSB_BYTE_SIZE_USHORT); }
inline size_t WsbByteSize(ULARGE_INTEGER value) { value; return(WSB_BYTE_SIZE_ULARGE_INTEGER); }

// Functions for converting standard types from bytes for portablity and WsbDbKey
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, BOOL* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, GUID* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, LONG* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, LONGLONG* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, ULONGLONG* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, DATE* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, FILETIME* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, SHORT* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, ULONG* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, USHORT* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, ULARGE_INTEGER* pValue, ULONG* pSize);

extern WSB_EXPORT HRESULT WsbOlestrFromBytes(UCHAR* pBytes, OLECHAR* pValue, ULONG* pSize);

// Functions for converting standard types to bytes for portablity and WsbDbKey
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, BOOL value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, GUID value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, LONG value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, LONGLONG value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, ULONGLONG value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, DATE value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, FILETIME value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, SHORT value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, ULONG value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, USHORT value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, ULARGE_INTEGER value, ULONG* pSize);

extern WSB_EXPORT HRESULT WsbOlestrToBytes(UCHAR* pBytes, OLECHAR* value, ULONG* pSize);


#endif // _WSBPORT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbgtarg.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbGtArg.h

Abstract:

    Header file for Process command line arguments

Author:

    Greg White          [gregw]          1-Mar-1997

Revision History:

--*/

#if !defined(_WSBGTARG_)                // expand header only once
#define _WSBGTARG_

typedef     struct
{
    int     argType;                    // type of argument
    void    *argValue;                  // argument value ptr
    char    *argString;                 // argument identifier
}   WSB_COMMAND_LINE_ARGS;

typedef     struct
{
    int         argType;                // type of argument
    void        *argValue;              // argument value ptr
    wchar_t     *argString;             // argument identifier
}   WSB_WCOMMAND_LINE_ARGS;

#define WSB_ARG_FLAG        0           // argument is a flag
#define WSB_ARG_IFLAG       1           // argument is an inverted flag
#define WSB_ARG_CHAR        2           // argument has a char value
#define WSB_ARG_NUM         3           // argument has a number value
#define WSB_ARG_STR         4           // argument has a string value
#define WSB_ARG_PROC        5           // argument needs procedure evaluaton

#define EOS             (char) 0x00     // end of string

#define WEOS            (wchar_t) 0x00  // wide end of string



extern  int     WsbGetArgs (int argc, char **argv, WSB_COMMAND_LINE_ARGS *argdefs, int num_argdefs);

extern  void    WsbGetEnvArgs (int *old_argc, char ***old_argv, char *env_var);

extern  void    WsbSetArgUsage (char *msg);

extern  void    WsbBldErrMsg (char  *wOption, char  *wErrMsg);

extern  void    WsbArgUsage (char *msg);

extern  int     WsbWGetArgs (int argc, wchar_t **argv, WSB_WCOMMAND_LINE_ARGS *argdefs, int num_argdefs);

extern  void    WsbWGetEnvArgs (int *old_argc, wchar_t ***old_argv, char *env_var);

extern  void    WsbWSetArgUsage (wchar_t *msg);

extern  void    WsbWBldErrMsg (wchar_t  *wOption, wchar_t  *wErrMsg);

extern  void    WsbWArgUsage (wchar_t *msg);


#endif                                  // end of header expansion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbgen.h ===
#ifndef _WSBGEN_H
#define _WSBGEN_H

/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbgen.h

Abstract:

    This module defines very basic WSB functions and defines that are general to WSB

Author:

    Michael Lotz    [lotz]      12-Apr-1997

Revision History:

--*/

// These macros define the module assignments for the error facilities.
// See also Facility Names, below.
#define WSB_FACILITY_PLATFORM           0x100
#define WSB_FACILITY_RMS                0x101
#define WSB_FACILITY_HSMENG             0x103
#define WSB_FACILITY_JOB                0x104
#define WSB_FACILITY_HSMTSKMGR          0x105
#define WSB_FACILITY_FSA                0x106
#define WSB_FACILITY_GUI                0x10a
#define WSB_FACILITY_MOVER              0x10b
#define WSB_FACILITY_LAUNCH             0x10c
#define WSB_FACILITY_TEST               0x10d
#define WSB_FACILITY_USERLINK           0x10e
#define WSB_FACILITY_CLI                0x10f

// Facility Names
#define WSB_FACILITY_PLATFORM_NAME      OLESTR("RsCommon.dll")
#define WSB_FACILITY_RMS_NAME           OLESTR("RsSub.dll")
#define WSB_FACILITY_HSMENG_NAME        OLESTR("RsEng.dll")
#define WSB_FACILITY_JOB_NAME           OLESTR("RsJob.dll")
#define WSB_FACILITY_HSMTSKMGR_NAME     OLESTR("RsTask.dll")
#define WSB_FACILITY_FSA_NAME           OLESTR("RsFsa.dll")
#define WSB_FACILITY_GUI_NAME           OLESTR("RsAdmin.dll")
#define WSB_FACILITY_MOVER_NAME         OLESTR("RsMover.dll")
#define WSB_FACILITY_LAUNCH_NAME        OLESTR("RsLaunch.exe")
#define WSB_FACILITY_TEST_NAME          OLESTR("RsTools.dll")
#define WSB_FACILITY_USERLINK_NAME      OLESTR("RsLnk.exe")
#define WSB_FACILITY_CLI_NAME           OLESTR("RsCli.dll")
#define WSB_FACILITY_NTDLL_NAME         OLESTR("ntdll.dll")

// COM Interface & Library Defintions
#define WSB_COLLECTION_MIN_INDEX        0
#define WSB_COLLECTION_MAX_INDEX        0xfffffffe

#define WSB_MAX_SERVICE_NAME            255

// Guids used to store User and Password for scheduled tasks
// Username {DC2D7CF0-6298-11d1-9F17-00A02488FCDE}
static const GUID GUID_Username = 
{ 0xdc2d7cf0, 0x6298, 0x11d1, { 0x9f, 0x17, 0x0, 0xa0, 0x24, 0x88, 0xfc, 0xde } };
// Password {DC2D7CF1-6298-11d1-9F17-00A02488FCDE}
static const GUID GUID_Password = 
{ 0xdc2d7cf1, 0x6298, 0x11d1, { 0x9f, 0x17, 0x0, 0xa0, 0x24, 0x88, 0xfc, 0xde } };

// Strings used to register event log categories
#define WSB_SVC_BASE         OLESTR("SYSTEM\\CurrentControlSet\\Services")
#define WSB_LOG_BASE         OLESTR("SYSTEM\\CurrentControlSet\\Services\\EventLog")
#define WSB_LOG_APP          OLESTR("Application")
#define WSB_LOG_SYS          OLESTR("System")
#define WSB_LOG_CAT_COUNT    OLESTR("CategoryCount")
#define WSB_LOG_CAT_FILE     OLESTR("CategoryMessageFile")
#define WSB_LOG_MESSAGE_FILE OLESTR("EventMessageFile")
#define WSB_LOG_TYPES        OLESTR("TypesSupported")

#define WSB_LOG_SOURCE_NAME  OLESTR("Remote Storage")
#define WSB_LOG_FILTER_NAME  OLESTR("RsFilter")

#define WSB_LOG_SVC_CATCOUNT 11
#define WSB_LOG_SVC_CATFILE  OLESTR("%SystemRoot%\\System32\\RsCommon.Dll")
#define WSB_LOG_SVC_MSGFILES OLESTR("%SystemRoot%\\System32\\RsCommon.Dll")

//
// Common Functions

// File/Directory
extern WSB_EXPORT HRESULT WsbCreateAllDirectories(OLECHAR* path);
extern WSB_EXPORT HRESULT WsbCreateAllDirectoriesForFile(OLECHAR* path);
extern WSB_EXPORT HRESULT WsbGetWin32PathAsBstr(OLECHAR* path, BSTR* pWin32Path);
extern WSB_EXPORT HRESULT WsbGetPathFromWin32AsBstr(OLECHAR* win32Path, BSTR* pPath);

inline char WsbSign( INT Val ) {
    return( Val > 0 ? (char)1 : ( ( Val < 0 ) ? (char)-1 : (char)0 ) );
}

// String & Buffer Copy
extern "C" {
    extern WSB_EXPORT HRESULT   WsbAllocAndCopyComString(OLECHAR** dest, OLECHAR* src, ULONG bufferSize);
    extern WSB_EXPORT HRESULT   WsbAllocAndCopyComString2(OLECHAR** dest, OLECHAR* src, ULONG bufferSize, BOOL inOrder);
    extern WSB_EXPORT HRESULT   WsbGetComBuffer(OLECHAR** dest, ULONG requestedSize, ULONG neededSize, BOOL* pWasAllocated);
    extern WSB_EXPORT HRESULT   WsbLoadComString(HINSTANCE hInstance, UINT uId, LPOLESTR* pszDest, ULONG ulBufferSize);
    extern WSB_EXPORT HRESULT   WsbMatchComString(OLECHAR* end, UINT uId, USHORT checks, UINT* idMatch);
}



// Filetime Manipulations

// NOTE: TICKS_PER_MONTH and TICKS_PER_YEAR are just approximations.
#define WSB_FT_TYPES_MAX            7
#define WSB_FT_TICKS_PER_SECOND     ((LONGLONG) 10000000)
#define WSB_FT_TICKS_PER_MINUTE     ((LONGLONG) ((LONGLONG) 60  * WSB_FT_TICKS_PER_SECOND))
#define WSB_FT_TICKS_PER_HOUR       ((LONGLONG) ((LONGLONG) 60  * WSB_FT_TICKS_PER_MINUTE))
#define WSB_FT_TICKS_PER_DAY        ((LONGLONG) ((LONGLONG) 24  * WSB_FT_TICKS_PER_HOUR))
#define WSB_FT_TICKS_PER_WEEK       ((LONGLONG) ((LONGLONG) 7   * WSB_FT_TICKS_PER_DAY))
#define WSB_FT_TICKS_PER_MONTH      ((LONGLONG) ((LONGLONG) 31  * WSB_FT_TICKS_PER_DAY))
#define WSB_FT_TICKS_PER_YEAR       ((LONGLONG) ((LONGLONG) 365 * WSB_FT_TICKS_PER_DAY))

extern "C" {
    extern WSB_EXPORT FILETIME  WsbFtSubFt(FILETIME ft1, FILETIME ft2);
    extern WSB_EXPORT SHORT     WsbCompareFileTimes(FILETIME ft1, FILETIME ft2, BOOL isRelative, BOOL isNewer);
}

// File name manipulations
extern WSB_EXPORT HRESULT SquashFilepath(WCHAR* pPath, UCHAR* pKey, ULONG keySize);

// Guid Manipulations

// Constant that can be used to determine necessary buffer size in doing
// GUID string operations. This includes the terminating L'\0'.

#define WSB_GUID_STRING_SIZE \
    (sizeof(L"{00000000-0000-0000-0000-000000000000}")/sizeof(wchar_t))

extern "C" {
    extern WSB_EXPORT int       WsbCompareGuid(REFGUID guid1, REFGUID guid2);
    extern WSB_EXPORT HRESULT   WsbStringFromGuid(REFGUID rguid, OLECHAR* sz);
    extern WSB_EXPORT HRESULT   WsbGuidFromString(const OLECHAR*, GUID * pguid);
}


// Type Conversion
#define WSB_FT_TO_WCS_ABS_STRLEN        20
#define WSB_VDATE_TO_WCS_ABS_STRLEN     20

extern "C" {
    extern WSB_EXPORT HRESULT   WsbWCStoFT(OLECHAR* wcs, BOOL* pIsRelative, FILETIME* pTime);
    extern WSB_EXPORT HRESULT   WsbWCStoLL(OLECHAR* wcs, LONGLONG* pvalue);
    extern WSB_EXPORT LONGLONG  WsbFTtoLL(FILETIME time);
    extern WSB_EXPORT FILETIME  WsbLLtoFT(LONGLONG value);
    extern WSB_EXPORT HRESULT   WsbFTtoWCS(BOOL isRelative, FILETIME time, OLECHAR** wcs, ULONG bufferSize);
    extern WSB_EXPORT HRESULT   WsbLLtoWCS(LONGLONG value, OLECHAR** wcs, ULONG ulBufferSize);
    extern WSB_EXPORT LONGLONG  WsbHLtoLL(LONG high, LONG low);
    extern WSB_EXPORT void      WsbLLtoHL(LONGLONG ll, LONG* pHigh, LONG* pLow);
    extern WSB_EXPORT HRESULT   WsbDatetoFT(DATE date, LONG ticks, FILETIME* pFt);
    extern WSB_EXPORT HRESULT   WsbFTtoDate(FILETIME ft, DATE* pDate, LONG* pTicks);
    extern WSB_EXPORT HRESULT   WsbLocalDateTicktoUTCFT(DATE date, LONG ticks, FILETIME* pFT);
    extern WSB_EXPORT HRESULT   WsbUTCFTtoLocalDateTick(FILETIME ft, DATE* pDate, LONG* pTicks);
    extern WSB_EXPORT HRESULT   WsbDateToString(DATE date, OLECHAR** string);
    extern WSB_EXPORT HRESULT   WsbStringToDate(OLECHAR* string, DATE* date);
}

// Account Helper functions
extern "C" {

extern WSB_EXPORT 
HRESULT
WsbGetAccountDomainName(
    OLECHAR * szDomainName,
    DWORD     cSize
    );

extern WSB_EXPORT
HRESULT
WsbGetServiceInfo(
    IN  GUID            guidApp,
    OUT OLECHAR **      pszServiceName, OPTIONAL
    OUT OLECHAR **      pszAccountName  OPTIONAL
    );

extern WSB_EXPORT
HRESULT
WsbGetServiceTraceDefaults(
    IN  OLECHAR* serviceName,
    IN  OLECHAR* traceName,
    IN  IUnknown* pUnk
    );

extern WSB_EXPORT
HRESULT
WsbGetMetaDataPath(
    OUT CWsbStringPtr & Path
    );


extern WSB_EXPORT
HRESULT
WsbGetComputerName(
    OUT CWsbStringPtr & String
    );

extern WSB_EXPORT
HRESULT
WsbGetLocalSystemName(
    OUT CWsbStringPtr & String
    );

}


// WsbSvc.h

extern WSB_EXPORT
HRESULT
WsbCheckService(
    IN  const OLECHAR * computer,
    IN  GUID            guidApp
    );

extern WSB_EXPORT
HRESULT
WsbGetServiceName(
    IN  const OLECHAR   *computer,
    IN  GUID            guidApp,
    IN  DWORD           cSize,
    OUT OLECHAR         *serviceName
    );

extern WSB_EXPORT
HRESULT
WsbGetServiceStatus(
    IN  const OLECHAR   *computer,
    IN  GUID            guidApp,
    OUT DWORD           *serviceStatus
    );


extern WSB_EXPORT HRESULT
WsbRegisterEventLogSource(
    IN  const WCHAR * LogName,
    IN  const WCHAR * SourceName,
    IN  DWORD         CategoryCount,
    IN  const WCHAR * CategoryMsgFile OPTIONAL,
    IN  const WCHAR * MsgFiles
    );

extern WSB_EXPORT HRESULT
WsbUnregisterEventLogSource(
    IN  const WCHAR * LogName,
    IN  const WCHAR * SourceName
    );

extern WSB_EXPORT HRESULT
WsbUnregisterRsFilter (
    BOOL bDisplay
    );

extern WSB_EXPORT HRESULT
WsbRegisterRsFilter (
    BOOL bDisplay
    );


extern WSB_EXPORT
HRESULT 
WsbGetServiceId(
    OLECHAR* serviceName, 
    GUID* pGuid 
    );

extern WSB_EXPORT
HRESULT 
WsbCreateServiceId(
    OLECHAR* serviceName, 
    GUID* pGuid 
    );

extern WSB_EXPORT
HRESULT 
WsbConfirmServiceId(
    OLECHAR* serviceName, 
    GUID guidConfirm 
    );

extern WSB_EXPORT
HRESULT 
WsbSetServiceId(
    OLECHAR* serviceName, 
    GUID guid 
    );

extern WSB_EXPORT
HRESULT
WsbCheckAccess(
    WSB_ACCESS_TYPE AccessType
    );

extern WSB_EXPORT
HRESULT
WsbCheckUsnJournalForChanges(
    OLECHAR*        volName,
    ULONGLONG       fileUsnJournalId,
    LONGLONG        FileId,
    LONGLONG        StartUsn,
    LONGLONG        StopUsn,
    BOOL*           pChanged
    );  


extern WSB_EXPORT
HRESULT 
WsbMarkUsnSource(
    HANDLE          changeHandle,
    OLECHAR*        volName
    );

extern WSB_EXPORT
HRESULT 
WsbGetUsnFromFileHandle(
    HANDLE          hFile,
    BOOL            ForceClose,
    LONGLONG*       pFileUsn
    );

extern WSB_EXPORT
HRESULT
WsbCreateUsnJournal(
    OLECHAR*        volName,
    ULONGLONG       usnSize
    );  

extern WSB_EXPORT
HRESULT
WsbGetResourceString(
    ULONG           id,
    WCHAR           **ppString
    );

extern WSB_EXPORT
HRESULT
WsbGetUsnJournalId(
    OLECHAR*        volName,
    ULONGLONG*      usnId
    );

class WSB_EXPORT CWsbSecurityDescriptor : public CSecurityDescriptor
{
public:
    HRESULT AllowRid( DWORD Rid, DWORD dwAccessMask );
};


#endif // _WSBGEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbserv.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbpstbl.h

Abstract:

    Abstract classes that provides persistence methods.

Author:

    Cat Brant       [cbrant]    24-Sep-1997

Revision History:

--*/

#ifndef _WSBSERV_
#define _WSBSERV_

extern WSB_EXPORT HRESULT WsbPowerEventNtToHsm(DWORD NtEvent, 
        ULONG * pHsmEvent);
extern WSB_EXPORT HRESULT WsbServiceSafeInitialize(IWsbServer* pServer,
    BOOL bVerifyId, BOOL bPrimaryId, BOOL* pWasCreated);


//
// This macro is used to encapsulate what was a CoCreateInstanceEx call that
// we were dependent on the class factory being on the same thread.
// 
// The macro simply calls the class factory directly. Thus, the class factory
// must be exposed to where this macro is used.
//

#define WsbCreateInstanceDirectly( _Class, _Interface, _pObj, _Hr )                      \
{                                                                                        \
    CComPtr<IClassFactory> pFactory;                                                     \
    _Hr = CComObject<_Class>::_ClassFactoryCreatorClass::CreateInstance(                 \
        _Class::_CreatorClass::CreateInstance, IID_IClassFactory, (void**)static_cast<IClassFactory **>(&pFactory) );        \
    if( SUCCEEDED( _Hr ) ) {                                                              \
                                                                                         \
        _Hr = pFactory->CreateInstance(                                                  \
        0, IID_##_Interface, (void**)static_cast<_Interface **>(&_pObj) );               \
    }                                                                                    \
}


#endif // _WSBSERV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbstrg.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbstrg.h

Abstract:

    This component is an object representations of the STRING standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"
#include "wsbpstrg.h"

#ifndef _WSBSTRG_
#define _WSBSTRG_

/*++

Class Name:
    
    CWsbString

Class Description:

    An object representations of the STRING standard type. It
    is both persistable and collectable.

--*/

class CWsbString : 
    public CWsbObject,
    public IWsbString,
    public CComCoClass<CWsbString,&CLSID_CWsbString>
{
public:
    CWsbString() {}
BEGIN_COM_MAP(CWsbString)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbString)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbString)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbString)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbString
public:
    STDMETHOD(CompareToString)(OLECHAR* value, SHORT* pResult);
    STDMETHOD(CompareToIString)(IWsbString* pString, SHORT* pResult);
    STDMETHOD(GetString)(OLECHAR** pValue, ULONG bufferSize);
    STDMETHOD(GetStringAndCase)(OLECHAR** pValue, BOOL* pIsCaseDependent, ULONG bufferSize);
    STDMETHOD(IsCaseDependent)(void);
    STDMETHOD(SetIsCaseDependent)(BOOL isCaseDependent);
    STDMETHOD(SetString)(OLECHAR* value);
    STDMETHOD(SetStringAndCase)(OLECHAR* value, BOOL isCaseDependent);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    CWsbStringPtr   m_value;
    BOOL            m_isCaseDependent;
};

#endif // _WSBSTRG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbpstbl.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbpstbl.h

Abstract:

    Abstract classes that provides persistence methods.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#ifndef _WSBPSTBL_
#define _WSBPSTBL_

#include "wsbpstrg.h"

// The name of the stream that is created when objects are persisted
// to structured storage files.
#define WSB_PERSIST_DEFAULT_STREAM_NAME     OLESTR("WsbStuff")

// The size of the overhead associated with persisting an object.
#define WSB_PERSIST_BASE_SIZE           sizeof(CLSID)

// Times used for autosave functionality
#define DEFAULT_AUTOSAVE_INTERVAL  (5 * 60 * 1000)    // 5 minutes
#define MAX_AUTOSAVE_INTERVAL  (24 * 60 * 60 * 1000)  // 24 hours

// Macros to help determine how much space is needed to persist an
// object or a portion of an object.
#define WsbPersistSize(a)               (WSB_PERSIST_BASE_SIZE + a)
#define WsbPersistSizeOf(a)             (WsbPersistSize(sizeof(a)))

/*++

Enumeration Name:
    WSB_PERSIST_STATE

Description:

 An enumeration that indicates the state of the persistance object. The
 states actually used depend on the type of persistance which is used.

--*/
typedef enum {
    WSB_PERSIST_STATE_UNINIT        = 0,   // Uninitialized
    WSB_PERSIST_STATE_NORMAL        = 1,   // Normal state
    WSB_PERSIST_STATE_NOSCRIBBLE    = 2,   // No scribble state
    WSB_PERSIST_STATE_RELEASED      = 3    // File was released
} WSB_PERSIST_STATE;



/*++

Class Name:
    
    CWsbPersistStream

Class Description:

    An object persistable to/from a stream.

    This is really an abstract class, but is constructable so that
    other class can delegate to it.

--*/

class WSB_EXPORT CWsbPersistStream : 
    public CComObjectRoot,
    public IPersistStream,
    public IWsbPersistStream
{
BEGIN_COM_MAP(CWsbPersistStream)
    COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
END_COM_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

#if defined(WSB_TRACK_MEMORY)
    ULONG InternalAddRef( );
    ULONG InternalRelease( );
#endif

// IPersistStream
public:
    STDMETHOD(IsDirty)(void);

// IWsbPersistStream
public:
    STDMETHOD(SetIsDirty)(BOOL bIsDirty);

protected:
    BOOL                        m_isDirty;
};


/*++

Class Name:
    
    CWsbPersistable 

Class Description:

    A object persistable to/from a stream, storage, or file.

    This is really an abstract class, but is constructable so that
    other class can delegate to it.  CWsbPersistStream should be used
    instead of this class unless storage and/or file persistence is
    absolutely necessary! If the object is persisted as part of a parent
    object, then only the parent object (or its parent) needs to support
    persistence to storage and/or file.

--*/

class WSB_EXPORT CWsbPersistable : 
    public CWsbPersistStream,
    public IPersistFile,
    public IWsbPersistable
{
BEGIN_COM_MAP(CWsbPersistable)
    COM_INTERFACE_ENTRY2(IPersist, CWsbPersistStream)
    COM_INTERFACE_ENTRY2(IPersistStream, CWsbPersistStream)
    COM_INTERFACE_ENTRY2(IWsbPersistStream, CWsbPersistStream)
    COM_INTERFACE_ENTRY(IPersistFile)
    COM_INTERFACE_ENTRY(IWsbPersistable)
END_COM_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersistFile
public:
    STDMETHOD(GetCurFile)(LPOLESTR* pszFileName);
    STDMETHOD(Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD(Save)(LPCOLESTR pszFileName, BOOL bRemember);
    STDMETHOD(SaveCompleted)(LPCOLESTR pszFileName);

// IWsbPersistStream
    STDMETHOD(IsDirty)(void)
        { return(CWsbPersistStream::IsDirty()); }
    STDMETHOD(SetIsDirty)(BOOL bIsDirty)
        { return(CWsbPersistStream::SetIsDirty(bIsDirty)); }

// IWsbPersistable
public:
    STDMETHOD(GetDefaultFileName)(LPOLESTR* pszFileName, ULONG ulBufferSize);
    STDMETHOD(ReleaseFile)(void);
    STDMETHOD(SetDefaultFileName)(LPOLESTR pszFileName);

protected:
    WSB_PERSIST_STATE           m_persistState;
    CWsbStringPtr               m_persistFileName;
    CWsbStringPtr               m_persistDefaultName;
    CComPtr<IStorage>           m_persistStorage;
    CComPtr<IStream>            m_persistStream;
};


// Persistence Helper Functions
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, BOOL* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, GUID* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, LONG* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, SHORT* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, BYTE* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, UCHAR* pValue, ULONG bufferSize);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, OLECHAR** pValue, ULONG bufferSize);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, ULONG* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, USHORT* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, LONGLONG* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, ULONGLONG* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, DATE* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, FILETIME* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, ULARGE_INTEGER* pValue);

extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, BOOL value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, GUID value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, LONG value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, SHORT value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, BYTE value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, UCHAR* value, ULONG bufferSize);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, OLECHAR* value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, ULONG value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, USHORT value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, LONGLONG value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, ULONGLONG value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, DATE value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, FILETIME value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, ULARGE_INTEGER value);

extern WSB_EXPORT HRESULT WsbBstrFromStream(IStream* pStream, BSTR* pValue);
extern WSB_EXPORT HRESULT WsbBstrToStream(IStream* pStream, BSTR value);

extern WSB_EXPORT HRESULT WsbPrintfToStream(IStream* pStream, OLECHAR* fmtString, ...);
extern WSB_EXPORT HRESULT WsbStreamToFile(HANDLE hFile, IStream* pStream, BOOL AddCR);

extern WSB_EXPORT HRESULT WsbSafeCreate(OLECHAR *, IPersistFile* pIPFile);
extern WSB_EXPORT HRESULT WsbSafeLoad(OLECHAR *, IPersistFile* pIPFile, BOOL UseBackup);
extern WSB_EXPORT HRESULT WsbSafeSave(IPersistFile* pIPFile);
extern WSB_EXPORT HRESULT WsbMakeBackupName(OLECHAR* pSaveName, OLECHAR* pExtension,
        OLECHAR** ppBackupName);


#endif // _WSBPSTBL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbtrace.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbTrace.h

Abstract:

    This header file defines the part of the platform code that is
    responsible for function tracing.

Author:

    Chuck Bardeen       [cbardeen]  29-Oct-1996

Revision History:

    Brian Dodd      [brian]      09-May-1996  - Added event logging

--*/

#ifndef _WSBTRACE_
#define _WSBTRACE_

#include "wsb.h"
#include "rsbuild.h"
#include "ntverp.h"

#ifdef __cplusplus
extern "C" {
#endif
// The size of the trace statement buffer including NULL termination
#define WSB_TRACE_BUFF_SIZE  1024

// These define the event log levels
#define     WSB_LOG_LEVEL_NONE              0  // Nothing is written the the event log
#define     WSB_LOG_LEVEL_ERROR             1  // Errors only (severity 3)
#define     WSB_LOG_LEVEL_WARNING           2  // Errors and Warnings (severity 2)
#define     WSB_LOG_LEVEL_INFORMATION       3  // Errors, Warnings, and Information (severity 1)
#define     WSB_LOG_LEVEL_COMMENT           4  // All Message Types (includes severity 0)
#define     WSB_LOG_LEVEL_DEFAULT           3  // Something reasonable.

// These define where the trace output should be written.
#define     WSB_TRACE_OUT_NONE              0x00000000L     // No output
#define     WSB_TRACE_OUT_DEBUG_SCREEN      0x00000001L     // Output to the debug screen
#define     WSB_TRACE_OUT_FILE              0x00000002L     // Output to a file
#define     WSB_TRACE_OUT_STDOUT            0x00000004L     // Output to standard out
#define     WSB_TRACE_OUT_FILE_COPY         0x00000008L     // Save copy of trace file
#define     WSB_TRACE_OUT_MULTIPLE_FILES    0x00000010L     // Output to multiple files
#define     WSB_TRACE_OUT_FLAGS_SET         0x00010000L     // Indicates other flags are set
#define     WSB_TRACE_OUT_ALL               0xffffffffL

// These macros define the module assignments for the bits used to
// control whether tracing is enabled. Each bit should only be used once,
// the granularity will be fairly large.
#define     WSB_TRACE_BIT_NONE              0x0000000000000000L
#define     WSB_TRACE_BIT_PLATFORM          0x0000000000000001L
#define     WSB_TRACE_BIT_RMS               0x0000000000000002L
#define     WSB_TRACE_BIT_SEG               0x0000000000000004L  // Remove when dependencies are gone
#define     WSB_TRACE_BIT_META              0x0000000000000004L
#define     WSB_TRACE_BIT_HSMENG            0x0000000000000008L
#define     WSB_TRACE_BIT_JOB               0x0000000000000010L
#define     WSB_TRACE_BIT_HSMTSKMGR         0x0000000000000020L
#define     WSB_TRACE_BIT_FSA               0x0000000000000040L
#define     WSB_TRACE_BIT_DATAMIGRATER      0x0000000000000080L
#define     WSB_TRACE_BIT_DATARECALLER      0x0000000000000100L
#define     WSB_TRACE_BIT_DATAVERIFIER      0x0000000000000200L
#define     WSB_TRACE_BIT_UI                0x0000000000000400L
#define     WSB_TRACE_BIT_HSMCONN           0x0000000000000800L
#define     WSB_TRACE_BIT_DATAMOVER         0x0000000000001000L
#define     WSB_TRACE_BIT_IDB               0x0000000000002000L
#define     WSB_TRACE_BIT_TEST              0x0000000000004000L
#define     WSB_TRACE_BIT_COPYMEDIA         0x0000000000008000L
#define     WSB_TRACE_BIT_PERSISTENCE       0x0000000000010000L
#define     WSB_TRACE_BIT_HSMSERV           0x0000000000020000L
#define     WSB_TRACE_BIT_ALL               0xffffffffffffffffL


// These macros are used to provide function call trace information into
// the log. Each function (method) that wants to be traceable needs at a
// minimum to use the following three macros. The first macro needs to be
// put at the top of the source code file and defines to which module the
// code in that file belongs.
//
//      #define     WSB_TRACE_IS        WSB_TRACE_BIT_PLATFORM
//
// The next two macros are used once per function. They are variable
// macros, which allows the writer of the function to list the values
// of the input and output parameters.
//
//      HRESULT CWsbSample::Do(BOOL shouldWrite) {
//          HRESULT     hr = S_OK;
//
//          WsbTraceIn("CWsbSample::Do", "shouldWrite = <%ls>", WsbBoolAsString(shouldWrite));
//
//          ... some code ....
//
//          WsbTraceOut("CWsbSample::Do", "hr = <%ls>", WsbHrAsString(hr));
//
//          return(hr);
//      }
//          
// Notice that some helper functions have been defined to help provide an
// a written description for the value of certain types. Additional helper
// helper functions should be created as needed.

/*++

Macro Name:

    WsbTraceIn

Macro Description:

    This macro is used to provide function call trace information into
    the log. It should be put at the start of the function.

Arguments:

    methodName - The name of the function.
    
    argString - A printf type format string. Additional arguments can
        follow.

--*/

#define     WsbTraceIn  if ((g_WsbTraceEntryExit == TRUE) && ((g_WsbTraceModules & WSB_TRACE_IS) != 0)) WsbTraceEnter

/*++

Macro Name:

    WsbTraceOut    

Macro Description:

    This macro is used to provide function call trace information into
    the log. It should be put at the end of the function.

Arguments:

    methodName - The name of the function.
    
    argString - A printf type format string. Additional arguments can
        follow.

--*/

#define     WsbTraceOut if ((g_WsbTraceEntryExit == TRUE) && ((g_WsbTraceModules & WSB_TRACE_IS) != 0)) WsbTraceExit


/*++

Macro Name:

    WsbLogEvent

Macro Description:

    This routine writes a message into the system event log.  The message
    is also written to the application trace file.

Arguments:

    eventId    - The message Id to log.
    dataSize   - Size of arbitrary data.
    data       - Arbitrary data buffer to display with the message.
    Inserts    - Message inserts that are merged with the message description specified by
                   eventId.  The number of inserts must match the number specified by the
                   message description.  The last insert must be NULL to indicate the
                   end of the insert list.

Notes:

    It's a small optimization to check if logging is turned on, first.  Determining if the
    message is actually logged still requires the first parameter.  Unlike trace, log activity
    should be minimal and only when there are problems.  The overhead of the calls seems
    reasonable.

--*/

#define     WsbLogEvent \
                if ( g_WsbLogLevel ) WsbSetEventInfo( __FILE__, __LINE__, VER_PRODUCTBUILD, RS_BUILD_VERSION ); \
                if ( g_WsbLogLevel ) WsbTraceAndLogEvent

/*++

Macro Name:

    WsbLogEventV

Macro Description:

    This macro is used to write a message into the system event log.  The message
    is also written to the application trace file.

    This macro is similar to WsbLogEvent, but takes a va_list as the fourth argument.

Arguments:

    eventId    - The message Id to log.
    dataSize   - Size of arbitrary data.
    data       - Arbitrary data buffer to display with the message.
    inserts    - An array of message inserts that are merged with the message description
                   specified by eventId.  The number of inserts must match the number
                   specified by the message description.  The last insert must be NULL,
                   to indicate the end of the insert list.

Notes:

    It's a small optimization to check if logging is turned on, first.  Determining if the
    message is actually logged still requires the first parameter.  Unlike trace, log activity
    should be minimal and only when there are problems.  The overhead of the calls seems
    reasonable.

--*/

#define     WsbLogEventV \
                if ( g_WsbLogLevel ) WsbSetEventInfo( __FILE__, __LINE__, VER_PRODUCTBUILD, RS_BUILD_VERSION ); \
                if ( g_WsbLogLevel ) WsbTraceAndLogEventV

/*++

Macro Name:

    WsbTrace    

Macro Description:

    This macro is used to provide a printf style message into the trace file.

Arguments:

    argString - A printf type format string. Additional arguments can
        follow.

--*/

#define     WsbTrace if ((g_WsbTraceModules & WSB_TRACE_IS) != 0) WsbTracef


/*++

Macro Name:

    WsbTraceAlways

Macro Description:

    This macro is used to provide a printf style message into the trace file.  
    The trace is printed if tracing has been started regardless of the
    WSB_TRACE_IS settings.

Arguments:

    argString - A printf type format string. Additional arguments can
        follow.

--*/

#define     WsbTraceAlways WsbTracef




/*++

Macro Name:

    WsbTraceBuffer

Macro Description:

    This macro is used to provide buffer dump to the trace file.  

Arguments:

    Same as WsbTraceBufferAsBytes

--*/

#define     WsbTraceBuffer if ((g_WsbTraceModules & WSB_TRACE_IS) != 0) WsbTraceBufferAsBytes


// The following global variable is used to compare against to determine
// the modules for which debugging should be enabled.
extern WSB_EXPORT LONGLONG              g_WsbTraceModules;
extern WSB_EXPORT IWsbTrace             *g_pWsbTrace;
extern WSB_EXPORT LONG                  g_WsbTraceCount;
extern WSB_EXPORT BOOL                  g_WsbTraceEntryExit;
extern WSB_EXPORT WORD                  g_WsbLogLevel;
extern WSB_EXPORT BOOL                  g_WsbLogSnapShotOn;
extern WSB_EXPORT WORD                  g_WsbLogSnapShotLevel;
extern WSB_EXPORT OLECHAR               g_pWsbLogSnapShotPath[];
extern WSB_EXPORT BOOL                  g_WsbLogSnapShotResetTrace;


// Trace functions
extern WSB_EXPORT void WsbSetEventInfo( char *fileName, DWORD lineNo, DWORD ntBuild, DWORD rsBuild );
extern WSB_EXPORT void WsbTraceInit( void );
extern WSB_EXPORT void WsbTraceCleanupThread(void);
extern WSB_EXPORT void WsbTraceEnter(OLECHAR* methodName, OLECHAR* argString,  ...);
extern WSB_EXPORT void WsbTraceExit(OLECHAR* methodName, OLECHAR* argString, ...);
extern WSB_EXPORT void WsbTracef(OLECHAR* argString, ...);
extern WSB_EXPORT void WsbTraceAndLogEvent(DWORD eventId, DWORD dataSize, LPVOID data, ... /* last argument is NULL */);
extern WSB_EXPORT void WsbTraceAndLogEventV(DWORD eventId, DWORD dataSize, LPVOID data, va_list *arguments /* last element is NULL */);
extern WSB_EXPORT void WsbTraceAndPrint(DWORD eventId, ... /* last argument is NULL */);
extern WSB_EXPORT void WsbTraceAndPrintV(DWORD eventId, va_list *arguments /* last element is NULL */);
extern WSB_EXPORT void WsbTraceBufferAsBytes( DWORD size, LPVOID bufferP );
extern WSB_EXPORT void WsbTraceTerminate(void);
extern WSB_EXPORT ULONG WsbTraceThreadOff(void);
extern WSB_EXPORT ULONG WsbTraceThreadOffCount(void);
extern WSB_EXPORT ULONG WsbTraceThreadOn(void);


// Helper Functions
//
// NOTE: Be careful with some of these helper functions, since they
// use static memory and a second call to the function will overwrite
// the results of the first call to the function. Also, some functions
// end up calling each other and sharing memory between them (i.e.
// WsbPtrToGuidAsString() calls WsbGuidAsString()).
extern WSB_EXPORT const OLECHAR* WsbBoolAsString(BOOL boolean);
extern WSB_EXPORT const OLECHAR* WsbFiletimeAsString(BOOL isRelative, FILETIME filetime);
extern WSB_EXPORT const OLECHAR* WsbHrAsString(HRESULT hr);
extern WSB_EXPORT const OLECHAR* WsbLongAsString(LONG inLong);
extern WSB_EXPORT const OLECHAR* WsbLonglongAsString(LONGLONG llong);
extern WSB_EXPORT const OLECHAR* WsbStringAsString(OLECHAR* pStr);

extern WSB_EXPORT const OLECHAR* WsbPtrToBoolAsString(BOOL* pBool);
extern WSB_EXPORT const OLECHAR* WsbPtrToFiletimeAsString(BOOL isRelative, FILETIME *pFiletime);
extern WSB_EXPORT const OLECHAR* WsbPtrToHrAsString(HRESULT *pHr);
extern WSB_EXPORT const OLECHAR* WsbPtrToLonglongAsString(LONGLONG *pLlong);
extern WSB_EXPORT const OLECHAR* WsbPtrToLongAsString(LONG* pLong);
extern WSB_EXPORT const OLECHAR* WsbPtrToShortAsString(SHORT* pShort);
extern WSB_EXPORT const OLECHAR* WsbPtrToByteAsString(BYTE* pByte);
extern WSB_EXPORT const OLECHAR* WsbPtrToStringAsString(OLECHAR** pString);
extern WSB_EXPORT const OLECHAR* WsbPtrToUliAsString(ULARGE_INTEGER* pUli);
extern WSB_EXPORT const OLECHAR* WsbPtrToUlongAsString(ULONG* pUlong);
extern WSB_EXPORT const OLECHAR* WsbPtrToUshortAsString(USHORT* pUshort);
extern WSB_EXPORT const OLECHAR* WsbPtrToPtrAsString(void** ppVoid);
extern WSB_EXPORT const OLECHAR* WsbAbbreviatePath(const OLECHAR* path, USHORT length);

extern WSB_EXPORT const OLECHAR* WsbGuidAsString(GUID guid);
extern WSB_EXPORT const OLECHAR* WsbPtrToGuidAsString(GUID* pGuid);

// MT safe version of guid-to-string utilities
class CWsbStringPtr;
extern WSB_EXPORT HRESULT WsbSafeGuidAsString(GUID guid, CWsbStringPtr &strOut);
extern WSB_EXPORT HRESULT WsbSafePtrToGuidAsString(GUID* pGuid, CWsbStringPtr &strOut);

extern WSB_EXPORT HRESULT WsbShortSizeFormat64(__int64 dw64, LPTSTR szBuf);

#ifdef __cplusplus

/*++

Class Name:
    
    WsbQuickString 

Class Description:

    Quick string storage class

--*/

class WSB_EXPORT WsbQuickString {
public:
    WsbQuickString ( const OLECHAR * sz ) { m_sz = WsbAllocString ( sz ); }
    ~WsbQuickString ( ) { if ( m_sz ) WsbFreeString ( m_sz ); }
    operator OLECHAR * () { return ( m_sz ); }

private:
    BSTR m_sz;
    WsbQuickString ( ) { m_sz = 0; }
};

#define WsbStringCopy( a ) ((OLECHAR *)WsbQuickString ( a ) )

}
#endif
#endif // _WSBTRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbpstrg.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbpstrg.h

Abstract:

    This component is C++ object representations a smart string pointer. It
    is similar to the CComPtr, in that it takes care of allocating and
    freeing the memory needed to represent the string automatically. This
    simplifies cleanup of functions in error handling cases and it limits
    the need for FinalConstruct() and FinalRelease() calls in objects that
    derive from CComObjectRoot.

Author:

    Chuck Bardeen   [cbardeen]   11-Dec-1996

Revision History:

--*/

#ifndef _WSBPSTRG_
#define _WSBPSTRG_

/*++

Class Name:
    
    CWsbStringPtr

Class Description:

    This component is C++ object representations a smart string pointer. It
    is similar to the CComPtr, in that it takes care of allocating and
    freeing the memory needed to represent the string automatically. This
    simplifies cleanup of functions in error handling cases and it limits
    the need for FinalConstruct() and FinalRelease() calls in objects that
    derive from CComObjectRoot.

--*/

class WSB_EXPORT CWsbStringPtr
{

// Constructors
public:
    CWsbStringPtr();
    CWsbStringPtr(const CHAR* pChar);
    CWsbStringPtr(const WCHAR* pWchar);
    CWsbStringPtr(const CWsbStringPtr& pString);
    CWsbStringPtr(REFGUID rguid);

// Destructor
public:
    ~CWsbStringPtr();

// Operator Overloading
public:
    operator WCHAR*();
    WCHAR& operator *();
    WCHAR** operator &();
    WCHAR& operator [](const int i);
    CWsbStringPtr& operator =(const CHAR* pChar);
    CWsbStringPtr& operator =(const WCHAR* pWchar);
    CWsbStringPtr& operator =(REFGUID rguid);
    CWsbStringPtr& operator =(const CWsbStringPtr& pString);
    BOOL operator !();
#if 0
    BOOL operator==(LPCWSTR s2);
    BOOL operator!=(LPCWSTR s2);
    BOOL operator==(const CWsbStringPtr& s2);
    BOOL operator!=(const CWsbStringPtr& s2);
#else
    int  Compare( LPCWSTR s2 );
    int  CompareIgnoreCase( LPCWSTR s2 );
    BOOL IsEqual( LPCWSTR s2 );
    BOOL IsNotEqual( LPCWSTR s2 );
#endif


// Memory Allocation
public:
    HRESULT Alloc(ULONG size);
    HRESULT Free(void);
    HRESULT GetSize(ULONG* size);    // Size of allocated buffer
    HRESULT Realloc(ULONG size);

// String Manipulation
public:
    HRESULT Append(const CHAR* pChar);
    HRESULT Append(const WCHAR* pWchar);
    HRESULT Append(const CWsbStringPtr& pString);
    HRESULT CopyTo(CHAR** pChar);
    HRESULT CopyTo(WCHAR** pWchar);
    HRESULT CopyTo(GUID * pguid);
    HRESULT CopyToBstr(BSTR* pBstr);
    HRESULT CopyTo(CHAR** pChar, ULONG bufferSize);
    HRESULT CopyTo(WCHAR** pWchar,ULONG bufferSize);
    HRESULT CopyToBstr(BSTR* pBstr,ULONG bufferSize);
    HRESULT FindInRsc(ULONG startId, ULONG idsToCheck, ULONG* pMatchId);
    HRESULT GetLen(ULONG* size);      // Length, in chars, of string
    HRESULT GiveTo(WCHAR** ppWchar);
    HRESULT LoadFromRsc(HINSTANCE instance, ULONG id);
    HRESULT Prepend(const CHAR* pChar);
    HRESULT Prepend(const WCHAR* pWchar);
    HRESULT Prepend(const CWsbStringPtr& pString);
    HRESULT Printf(const WCHAR* fmtString, ...);
    HRESULT TakeFrom(WCHAR* pWchar, ULONG bufferSize);
    HRESULT VPrintf(const WCHAR* fmtString, va_list vaList);

// Member Data
protected:
    WCHAR*                  m_pString;
    ULONG                   m_givenSize;
    static CComPtr<IMalloc> m_pMalloc;
};


inline
HRESULT CWsbStringPtr::GetLen(ULONG* size)
{
    HRESULT     hr = S_OK;

    if (0 == size) {
        hr = E_POINTER;
    } else if (0 == m_pString) {
        *size = 0;
    } else {
        *size = wcslen(m_pString);
    }
    return(hr);
}

inline
HRESULT CWsbStringPtr::Printf(const WCHAR* fmtString, ...)
{
    HRESULT     hr;
    va_list     vaList;

    va_start(vaList, fmtString);
    hr = VPrintf(fmtString, vaList);
    va_end(vaList);
    return(hr);
}
#if 0
// Compare Operators (allow to be compared when on the right)
BOOL operator==(LPCWSTR s1, const CWsbStringPtr& s2);
BOOL operator!=(LPCWSTR s1, const CWsbStringPtr& s2);

inline
BOOL CWsbStringPtr::operator==(LPCWSTR s2)
{
    return( wcscmp( m_pString, s2 ) == 0 );
}

inline
BOOL CWsbStringPtr::operator!=(LPCWSTR s2)
{
    return( wcscmp( m_pString, s2 ) != 0 );
}

inline
BOOL CWsbStringPtr::operator==(const CWsbStringPtr& s2)
{
    return( wcscmp( m_pString, s2.m_pString ) == 0 );
}

inline
BOOL CWsbStringPtr::operator!=(const CWsbStringPtr& s2)
{
    return( wcscmp( m_pString, s2.m_pString ) != 0 );
}

inline
BOOL operator==(LPCWSTR s1, const CWsbStringPtr& s2)
{
    return( wcscmp( s1, (CWsbStringPtr)s2 ) == 0 );
}

inline
BOOL operator!=(LPCWSTR s1, const CWsbStringPtr& s2)
{
    return( wcscmp( s1, (CWsbStringPtr)s2 ) != 0 );
}
#else

inline
int CWsbStringPtr::Compare( LPCWSTR s2 )
{
    if( m_pString && s2 )   return( wcscmp( m_pString, s2 ) );

    if( !m_pString && s2 )  return( -1 );

    if( m_pString && !s2 )  return( 1 );

    return( 0 );
}

inline
int CWsbStringPtr::CompareIgnoreCase( LPCWSTR s2 )
{
    if( m_pString && s2 )   return( _wcsicmp( m_pString, s2 ) );

    if( !m_pString && s2 )  return( -1 );

    if( m_pString && !s2 )  return( 1 );

    return( 0 );
}

inline
BOOL CWsbStringPtr::IsEqual( LPCWSTR s2 )
{
    return( Compare( s2 ) == 0 );
}

inline
BOOL CWsbStringPtr::IsNotEqual( LPCWSTR s2 )
{
    return( Compare( s2 ) != 0 );
}



#endif


#endif // _WSBPSTRG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbregty.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbRegty.h

Abstract:

    This is the header file for registry access functions.

Author:

    Rohde Wakefield    [rohde]   21-Oct-1996

Revision History:

--*/




#ifndef __WSBREG__
#define __WSBREG__

#ifdef __cplusplus
extern "C"
{
#endif

// Defines for common registry keys/values
#define WSB_CURRENT_VERSION_REGISTRY_KEY            WSB_WINDOWSNT_CURRENT_VERSION_REGISTRY_KEY // Backwards compatibility

#define WSB_PROFILELIST_REGISTRY_KEY                OLESTR("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define WSB_WINDOWSNT_CURRENT_VERSION_REGISTRY_KEY  OLESTR("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")
#define WSB_WINDOWS_CURRENT_VERSION_REGISTRY_KEY    OLESTR("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define WSB_SYSTEM_ROOT_REGISTRY_VALUE              OLESTR("SystemRoot")
#define WSB_PROFILES_DIR_REGISTRY_VALUE             OLESTR("ProfilesDirectory")


#define WSB_CONTROL_REGISTRY_KEY                    OLESTR("System\\CurrentControlSet\\Control\\RemoteStorage")
#define WSB_METADATA_REGISTRY_VALUE                 OLESTR("RemoteStorageData")


#define WSB_RSM_CONTROL_REGISTRY_KEY                    OLESTR("System\\CurrentControlSet\\Control\\NTMS")
#define WSB_RSM_METADATA_REGISTRY_VALUE                 OLESTR("NtmsData")

WSB_EXPORT HRESULT
WsbOpenRegistryKey (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  REGSAM sam,
    OUT HKEY * phKeyMachine,
    OUT HKEY * phKey
    );

WSB_EXPORT HRESULT
WsbCloseRegistryKey (
    IN OUT HKEY * phKeyMachine,
    IN OUT HKEY * phKey
    );

WSB_EXPORT HRESULT
WsbSetRegistryValueData (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN  const BYTE *pData,
    IN  DWORD cbData
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueData (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT BYTE *pData,
    IN  DWORD cbData,
    OUT DWORD * pcbData OPTIONAL
    );

WSB_EXPORT HRESULT
WsbSetRegistryValueString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN  const OLECHAR * szString,
    IN        DWORD     dwType = REG_SZ
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT OLECHAR * szString,
    IN  DWORD cSize,
    OUT DWORD *pcLength OPTIONAL
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueMultiString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT OLECHAR * szMultiString,
    IN  DWORD cSize,
    OUT DWORD *pcLength OPTIONAL
    );

WSB_EXPORT HRESULT
WsbSetRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        DWORD     dw
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       DWORD *   pdw
    );

WSB_EXPORT HRESULT
WsbAddRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        DWORD     adw
    );

WSB_EXPORT HRESULT
WsbIncRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue
    );

WSB_EXPORT HRESULT
WsbRemoveRegistryValue (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue
    );

WSB_EXPORT HRESULT
WsbRemoveRegistryKey (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szKey
    );

WSB_EXPORT HRESULT
WsbCheckIfRegistryKeyExists(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath
    );

WSB_EXPORT HRESULT
WsbEnsureRegistryKeyExists (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath
    );

WSB_EXPORT HRESULT
WsbSetRegistryValueUlongAsString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        ULONG     value
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueUlongAsMultiString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       ULONG **  ppValues,
    OUT       ULONG *   pNumValues
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueUlongAsString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       ULONG *   pvalue
    );

WSB_EXPORT HRESULT
WsbRegistryValueUlongAsString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN OUT    ULONG *   pvalue
    );

#ifdef __cplusplus
}
#endif

#endif //__WSBREG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbtrc.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbTrc.h

Abstract:

    This header file defines the part of the platform code that is
    responsible for function tracing.

Author:

    Chuck Bardeen       [cbardeen]  29-Oct-1996

Revision History:

    Brian Dodd          [brian]     09-May-1996  - Added event logging

--*/

#ifndef _WSBTRC_
#define _WSBTRC_

#include "wsb.h"
#include "resource.h"

//Registry strings for trace settings
#define WSB_TRACE_COUNT                 OLESTR("WsbTraceCount")
#define WSB_TRACE_TIMESTAMP             OLESTR("WsbTraceTimestamp")
#define WSB_TRACE_THREADID              OLESTR("WsbTraceThreadId")
#define WSB_TRACE_ON                    OLESTR("WsbTraceOn")
#define WSB_TRACE_TO_DEBUG              OLESTR("WsbTraceToDebug")
#define WSB_TRACE_TO_STDOUT             OLESTR("WsbTraceToStdOut")
#define WSB_TRACE_TO_FILE               OLESTR("WsbTraceToFile")
#define WSB_TRACE_FILE_NAME             OLESTR("WsbTraceFileName")
#define WSB_TRACE_FILE_MAX_SIZE         OLESTR("WsbTraceFileMaxSize")
#define WSB_TRACE_FILE_COMMIT           OLESTR("WsbTraceFileCommit")
#define WSB_TRACE_ENTRY_EXIT            OLESTR("WsbTraceEntryExit")
#define WSB_TRACE_FILE_COPY_NAME        OLESTR("WsbTraceFileCopyName")

#define WSB_LOG_LEVEL                   OLESTR("WsbLogLevel")
#define WSB_LOG_SNAP_SHOT_ON            OLESTR("WsbLogSnapShotOn")
#define WSB_LOG_SNAP_SHOT_LEVEL         OLESTR("WsbLogSnapShotLevel")
#define WSB_LOG_SNAP_SHOT_PATH          OLESTR("WsbLogSnapShotPath")
#define WSB_LOG_SNAP_SHOT_RESET_TRACE   OLESTR("WsbLogSnapShotResetTrace")
                                        
#define WSB_TRACE_DO_PLATFORM           OLESTR("WsbTraceDoPlatform")
#define WSB_TRACE_DO_RMS                OLESTR("WsbTraceDoRms") 
#define WSB_TRACE_DO_SEG                OLESTR("WsbTraceDoSeg") 
#define WSB_TRACE_DO_META               OLESTR("WsbTraceDoMeta") 
#define WSB_TRACE_DO_HSMENG             OLESTR("WsbTraceDoHsmEng") 
#define WSB_TRACE_DO_JOB                OLESTR("WsbTraceDoJob") 
#define WSB_TRACE_DO_HSMTSKMGR          OLESTR("WsbTraceDoHsmTskMgr")
#define WSB_TRACE_DO_FSA                OLESTR("WsbTraceDoFsa") 
#define WSB_TRACE_DO_DATAMIGRATER       OLESTR("WsbTraceDoDatamigrater")
#define WSB_TRACE_DO_DATARECALLER       OLESTR("WsbTraceDoDataRecaller")
#define WSB_TRACE_DO_DATAVERIFIER       OLESTR("WsbTraceDoDataVerifier")
#define WSB_TRACE_DO_UI                 OLESTR("WsbTraceDoUI")   
#define WSB_TRACE_DO_DATAMOVER          OLESTR("WsbTraceDoDataMover")
#define WSB_TRACE_DO_HSMCONN            OLESTR("WsbTraceDoHsmConn")
#define WSB_TRACE_DO_IDB                OLESTR("WsbTraceDoIDB")
#define WSB_TRACE_DO_COPYMEDIA          OLESTR("WsbTraceDoCopyMedia")
#define WSB_TRACE_DO_PERSISTENCE        OLESTR("WsbTraceDoPersistence")
#define WSB_TRACE_DO_HSMSERV            OLESTR("WsbTraceDoHsmServ") 

class CWsbTrace : 
    public IWsbTrace,
    public CComObjectRoot,
    public CComCoClass<CWsbTrace,&CLSID_CWsbTrace>
{

public:
    CWsbTrace() {}
BEGIN_COM_MAP( CWsbTrace )
    COM_INTERFACE_ENTRY( IWsbTrace )
END_COM_MAP( )


DECLARE_REGISTRY_RESOURCEID( IDR_CWsbTrace )

    HRESULT FinalConstruct( void );
    void FinalRelease( void );

// IWsbTrace
public:
    STDMETHOD( StartTrace )( void );
    STDMETHOD( StopTrace )( void );
    STDMETHOD( SetTraceOn )(  LONGLONG traceElement );
    STDMETHOD( SetTraceOff )( LONGLONG traceElement );
    STDMETHOD( GetTraceSettings )( LONGLONG *pTraceElements );
    STDMETHOD( GetTraceSetting )( LONGLONG traceElement, BOOL *pOn );
    STDMETHOD( SetTraceFileControls )( OLECHAR *pTraceFileName, 
            BOOL commitEachEntry, LONGLONG maxTraceFileSize, 
            OLECHAR *pTraceFileCopyName);
    STDMETHOD( GetTraceFileControls )( OLECHAR **ppTraceFileName, 
            BOOL *pCommitEachEntry, LONGLONG *pMaxTraceFileSize, 
            OLECHAR **ppTraceFileCopyName);
    STDMETHOD( DirectOutput )(ULONG output );
    STDMETHOD( SetOutputFormat )( BOOL timeStamp, BOOL traceCount, BOOL threadId );
    STDMETHOD( GetOutputFormat )( BOOL *pTimeStamp, BOOL *pTraceCount, BOOL *pThreadId );
    STDMETHOD( SetTraceEntryExit )( BOOL traceEntryExit );
    STDMETHOD( GetTraceEntryExit )( BOOL *pTraceEntryExit );
    STDMETHOD( SetLogLevel )( WORD logLevel );
    STDMETHOD( SetLogSnapShot)( BOOL on,    WORD level, OLECHAR *snapShotPath, BOOL resetTrace);
    STDMETHOD( GetLogSnapShot)( BOOL *pOn, WORD *pLevel, OLECHAR **pSnapShotPath, BOOL *pResetTrace);
    STDMETHOD( GetLogLevel )( WORD *pLogLevel );
    STDMETHOD( GetRegistryEntry )( OLECHAR **pTraceRegistrySetting );
    STDMETHOD( SetRegistryEntry )( OLECHAR *traceRegistrySetting );
    STDMETHOD( LoadFromRegistry )( void );
    STDMETHOD( SetTraceSettings )( LONGLONG traceElements );

    STDMETHOD( Print )(OLECHAR* traceString );


protected:
// Helper functions
    STDMETHOD( AdjustFileNames )( void );
    STDMETHOD( WrapTraceFile )( void );
    STDMETHOD( LoadFileSettings )( void );
    STDMETHOD( LoadTraceSettings )( void );
    STDMETHOD( LoadOutputDestinations )( void );
    STDMETHOD( LoadFormat )( void );
    STDMETHOD( LoadStart )( void );
    STDMETHOD( Write )(OLECHAR* pString );

    BOOL                m_TraceOn;
    LONGLONG            m_TraceSettings;
    CWsbStringPtr       m_TraceFileName;
    ULONG               m_TraceOutput;
    BOOL                m_CommitEachEntry;
    BOOL                m_TimeStamp;
    BOOL                m_TraceCount;
    BOOL                m_TraceThreadId;
    BOOL                m_TraceEntryExit;
    WORD                m_LogLevel;
    LONGLONG            m_MaxTraceFileSize;
    HANDLE              m_TraceFilePointer;
    BOOL                m_WrapMode;
    CWsbStringPtr       m_RegistrySetting;
    CWsbStringPtr       m_TraceFileCopyName;
    CWsbStringPtr       m_TraceMultipleFilePattern;  // printf style pattern
    ULONG               m_TraceMultipleFileCount;    // count inserted into pattern
    CWsbStringPtr       m_TraceFileDir;              // directory for trace file
    CWsbStringPtr       m_TraceFileCopyDir;          // directory for trace file copy
    HANDLE              m_TraceCountHandle;
    PLONG               m_pTraceCountGlobal;
};
#endif // _WSBTRC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbvar.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbvar.h

Abstract:

    This class is a wrapper for the VARIANT structure, providing
    conversion and cleanup automatically. Current supported types
    for conversion are OLECHAR * (BSTR), IUnknown / IDispatch, and
    GUID. GUIDs are represented internally as strings.

Author:

    Rohde Wakefield          [rohde]   21-Jan-1997

Revision History:

--*/

#ifndef _WSBVAR_
#define _WSBVAR_

class WSB_EXPORT CWsbVariant : public tagVARIANT
{
public:
    CWsbVariant ( )  { Init  ( ); }
    ~CWsbVariant ( ) { Clear ( ); }

    HRESULT Clear ( ) { return ( VariantClear ( this ) ); }
    void    Init  ( ) { VariantInit ( this ); }

    BOOL IsEmpty ( )
    {
        return ( VT_EMPTY == vt );
    }

    CWsbVariant & operator = ( const VARIANT & variant )
    {
        VariantCopy ( this, (VARIANT *)&variant );
        return ( *this );
    }


    BOOL IsBstr ( )
    {
        return ( VT_BSTR == vt );
    }

    CWsbVariant ( const OLECHAR * string );
    CWsbVariant & operator = ( const OLECHAR * string );
    operator OLECHAR * ( );


    BOOL IsInterface ( )
    {
        return ( ( VT_UNKNOWN == vt ) || ( VT_DISPATCH == vt ) );
    }

    BOOL IsDispatch ( )
    {
        return ( ( VT_DISPATCH == vt ) );
    }

    CWsbVariant ( IUnknown * );
    CWsbVariant ( IDispatch * );
    operator IUnknown * ( );
    operator IDispatch * ( );
    CWsbVariant & operator = ( IUnknown * pUnk );
    CWsbVariant & operator = ( IDispatch * pDisp );

    CWsbVariant ( REFGUID rguid );
    CWsbVariant & operator = ( REFGUID rguid );
    operator GUID ();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbtrak.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbtrak.h

Abstract:

    Utility functions to keep track of run-time information.

Author:

    Ron White   [ronw]   5-Dec-1997

Revision History:

--*/

#ifndef _WSBTRAK_
#define _WSBTRAK_

//  Flags for WsbObjectTracePointers
#define WSB_OTP_STATISTICS          0x00000001
#define WSB_OTP_SEQUENCE            0x00000002
#define WSB_OTP_ALLOCATED           0x00000004
#define WSB_OTP_ALL                 0x0000000f

//  Define these as macros so we can get rid of them for release code
#if defined(WSB_TRACK_MEMORY)
#define WSB_OBJECT_ADD(guid, addr)   WsbObjectAdd(guid, addr)
#define WSB_OBJECT_SUB(guid, addr)   WsbObjectSub(guid, addr)
#define WSB_OBJECT_TRACE_POINTERS(flags)    WsbObjectTracePointers(flags)
#define WSB_OBJECT_TRACE_TYPES       WsbObjectTraceTypes()

#else
#define WSB_OBJECT_ADD(guid, addr)   
#define WSB_OBJECT_SUB(guid, addr)   
#define WSB_OBJECT_TRACE_POINTERS(flags)
#define WSB_OBJECT_TRACE_TYPES       

#endif

// Tracker functions
#if defined(WSB_TRACK_MEMORY)
extern WSB_EXPORT HRESULT WsbObjectAdd(const GUID& guid, const void* addr);
extern WSB_EXPORT HRESULT WsbObjectSub(const GUID& guid, const void* addr);
extern WSB_EXPORT HRESULT WsbObjectTracePointers(ULONG flags);
extern WSB_EXPORT HRESULT WsbObjectTraceTypes(void);
#endif

// Memory replacement functions
#if defined(WSB_TRACK_MEMORY)
extern WSB_EXPORT LPVOID WsbMemAlloc(ULONG cb, const char * filename, int linenum);
extern WSB_EXPORT void   WsbMemFree(LPVOID pv, const char * filename, int linenum);
extern WSB_EXPORT LPVOID WsbMemRealloc(LPVOID pv, ULONG cb, 
        const char * filename, int linenum);

extern WSB_EXPORT BSTR    WsbSysAllocString(const OLECHAR FAR * sz, 
        const char * filename, int linenum);
extern WSB_EXPORT BSTR    WsbSysAllocStringLen(const OLECHAR FAR * sz, 
        unsigned int cc, const char * filename, int linenum);
extern WSB_EXPORT void    WsbSysFreeString(BSTR bs, const char * filename, int linenum);
extern WSB_EXPORT HRESULT WsbSysReallocString(BSTR FAR * pb, const OLECHAR FAR * sz, 
        const char * filename, int linenum);
extern WSB_EXPORT HRESULT WsbSysReallocStringLen(BSTR FAR * pb, 
        const OLECHAR FAR * sz, unsigned int cc, const char * filename, int linenum);

#endif

#endif // _WSBTRAK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbvol.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wsbvol.h

Abstract:

    Definitions for volume support routines

Author:

    Ran Kalach [rankala] 27, January 2000

Revision History:

--*/

#ifndef _WSBVOL_
#define _WSBVOL_

#ifdef __cplusplus
extern "C" {
#endif


WSB_EXPORT HRESULT
WsbGetFirstMountPoint(
    IN PWSTR volumeName, 
    OUT PWSTR firstMountPoint, 
    IN ULONG maxSize
);

#ifdef __cplusplus
}
#endif

#endif // _WSBFMT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\inc\wsbver.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
Copyright (c) Seagate Software Inc., 1997-1998

Module Name:

    WsbVer.h

Abstract:

    This module defines the correct copyright information for the Sakkara
    project executables / dlls / services / drivers / etc.

Author:

    Rohde Wakefield [rohde]     7-Dec-1997

Revision History:

--*/

#ifndef _WSBVER_
#define _WSBVER_

/*


In addition to including this file, it is necessary to define the 
following in the module's resource file:


VER_FILETYPE             - One of: VFT_APP, VFT_DLL, VFT_DRV

VER_FILESUBTYPE          - One of: VFT_UNKNOWN, VFT_DRV_SYSTEM, 
                         -         VFT_DRV_INSTALLABLE

VER_FILEDESCRIPTION_STR  - String describing module

VER_INTERNALNAME_STR     - Internal Name (Same as module name)

A Typical section would look like:


#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Remote Storage Engine"
#define VER_INTERNALNAME_STR        "RsEng.exe"

#include "WsbVer.h"

*/


//
// Include some needed defines
//

#include <winver.h>
#include <ntverp.h>


//
// Overide copyright
//

/*** NOT ANYMORE - use default copyright, which is defined in common.ver    ***/

//
// And finally, define the version resource
//

#include <common.ver>

#endif // _WSBVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\dlldatax.h ===
#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\dlldataz.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#include "jobprv_p.c"

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "jobint_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmactn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmactn.cpp

Abstract:

    This component represents the actions that can be performed by a policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"
#include "stdio.h"

#include "wsb.h"
#include "job.h"
#include "hsmactn.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmAction::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmAction::GetName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, m_nameId));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmAction::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmAction::GetSizeMax"), OLESTR(""));

    try {
       
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = WsbPersistSizeOf(ULONG);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmAction::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmAction::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmAction::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmAction::Load"), OLESTR("hr = <%ls>, nameId = <%lu>"), WsbHrAsString(hr), m_nameId);

    return(hr);
}


HRESULT
CHsmAction::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmAction::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmAction::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmAction::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmDirectedAction::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_storagePoolId = GUID_NULL;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmDirectedAction::GetStoragePoolId(
    OUT GUID* pId
    )

/*++

Implements:

  IHsmDirectedAction::GetStoragePoolId().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_storagePoolId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmDirectedAction::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmDirectedAction::GetSizeMax"), OLESTR(""));

    try {
       
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = WsbPersistSizeOf(ULONG) + WsbPersistSizeOf(GUID);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmDirectedAction::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmDirectedAction::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmDirectedAction::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_storagePoolId));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmDirectedAction::Load"), OLESTR("hr = <%ls>, nameId = <%lu>, storagePoolId = <%ls>"), WsbHrAsString(hr), m_nameId, WsbGuidAsString(m_storagePoolId));

    return(hr);
}


HRESULT
CHsmDirectedAction::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmDirectedAction::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_storagePoolId));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmDirectedAction::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmDirectedAction::SetStoragePoolId(
    IN GUID id
    )

/*++

Implements:

  IHsmDirectedAction::SetStoragePoolId().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_storagePoolId = id;
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(S_OK);
}



HRESULT
CHsmRelocateAction::ExpandPlaceholders(
    void
    )

/*++

Implements:

  IHsmRelocateAction::ExpandPlaceholders().

--*/
{
    return(m_expandPlaceholders ? S_OK : S_FALSE);
}


HRESULT
CHsmRelocateAction::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_retainHierarchy = FALSE;;
        m_expandPlaceholders = FALSE;;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelocateAction::GetDestination(
    OUT OLECHAR** pDest,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmRelocateAction::GetDestination().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pDest, E_POINTER);
        WsbAffirmHr(m_dest.CopyTo(pDest, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelocateAction::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRelocateAction::GetSizeMax"), OLESTR(""));

    try {
       
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = WsbPersistSizeOf(ULONG) + WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(BOOL) + WsbPersistSize((wcslen(m_dest) + 1) * sizeof(OLECHAR));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelocateAction::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmRelocateAction::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRelocateAction::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_expandPlaceholders));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_retainHierarchy));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_dest, 0));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelocateAction::Load"), OLESTR("hr = <%ls>, expandPlaceholders = <%ls>, retainHierarchy = <%ls>, destination = <%ls>"), WsbHrAsString(hr), m_nameId, WsbBoolAsString(m_expandPlaceholders), WsbBoolAsString(m_retainHierarchy), m_dest);

    return(hr);
}


HRESULT
CHsmRelocateAction::RetainHierarchy(
    void
    )

/*++

Implements:

  IHsmRelocateAction::RetainHierarchy().

--*/
{
    return(m_retainHierarchy ? S_OK : S_FALSE);
}


HRESULT
CHsmRelocateAction::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRelocateAction::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_expandPlaceholders));
        WsbAffirmHr(WsbSaveToStream(pStream, m_retainHierarchy));
        WsbAffirmHr(WsbSaveToStream(pStream, m_dest));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelocateAction::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRelocateAction::SetDestination(
    IN OLECHAR* dest
    )

/*++

Implements:

  IHsmRelocateAction::SetDestination().

--*/
{
    HRESULT     hr = S_OK;

    try {

        m_dest = dest;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelocateAction::SetExpandPlaceholders(
    IN BOOL expandPlaceholders
    )

/*++

Implements:

  IHsmRelocateAction::SetExpandPlaceholders().

--*/
{
    HRESULT     hr = S_OK;

    try {

        m_expandPlaceholders = expandPlaceholders;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelocateAction::SetRetainHierarchy(
    IN BOOL retainHierarchy
    )

/*++

Implements:

  IHsmRelocateAction::SetRetainHierarchy().

--*/
{
    HRESULT     hr = S_OK;

    try {

        m_retainHierarchy = retainHierarchy;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmActionDelete::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirmHr(pScanItem->Delete());

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionDelete::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONDELETE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionDelete::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionDelete::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionDelete;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionDelete::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionRecall::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT             hr = S_OK;
    LONGLONG            offset = 0;
    LONGLONG            size = 0;
    FSA_PLACEHOLDER     placeholder;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Iterate overall the reparsed areas.
        for (hr = pScanItem->FindFirstPlaceholder(&offset, &size, &placeholder);
            SUCCEEDED(hr);
            hr = pScanItem->FindNextPlaceholder(&offset, &size, &placeholder)) {

            WsbAffirmHr(pScanItem->Recall(offset, size, FALSE));
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionRecall::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONRECALL_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionRecall::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionRecall::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionRecall;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionRecall::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionRecycle::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirmHr(pScanItem->Recycle());

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionRecycle::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONRECYCLE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionRecycle::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionRecycle::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionRecycle;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionRecycle::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionTruncate::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        WsbAffirmHr(pScanItem->Truncate(0, size));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionTruncate::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONTRUNCATE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionTruncate::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionTruncate::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionTruncate;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionTruncate::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionUnmanage::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT             hr = S_OK;
    LONGLONG            offset;
    LONGLONG            size;
    FSA_PLACEHOLDER     placeholder;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Iterate overall the reparsed areas.
        for (hr = pScanItem->FindFirstPlaceholder(&offset, &size, &placeholder);
            SUCCEEDED(hr);
            hr = pScanItem->FindNextPlaceholder(&offset, &size, &placeholder)) {

            WsbAffirmHr(pScanItem->Unmanage(offset, size));
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionUnmanage::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONUNMANAGE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionUnmanage::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionUnmanage::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionUnmanage;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionUnmanage::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionValidate::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT             hr = S_OK;
    LONGLONG            offset;
    LONGLONG            size;
    FSA_PLACEHOLDER     placeholder;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Iterate overall the reparsed areas.
        for (hr = pScanItem->FindFirstPlaceholder(&offset, &size, &placeholder);
            SUCCEEDED(hr);
            hr = pScanItem->FindNextPlaceholder(&offset, &size, &placeholder)) {

            WsbAffirmHr(pScanItem->Validate(offset, size));
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionValidate::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONVALIDATE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionValidate::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionValidate::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionValidate;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionValidate::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionManage::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmActionManage::Do"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        WsbAffirmHr(pScanItem->Manage(0, size, m_storagePoolId, FALSE));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionManage::Do"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionManage::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmDirectedAction::FinalConstruct());
        m_nameId = IDS_HSMACTIONMANAGE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionManage::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionManage::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionManage;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionManage::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionMigrate::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        WsbAffirmHr(pScanItem->Manage(0, size, m_storagePoolId, TRUE));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionMigrate::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmDirectedAction::FinalConstruct());
        m_nameId = IDS_HSMACTIONMIGRATE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionMigrate::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionMigrate::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionMigrate;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionMigrate::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionCopy::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirmHr(pScanItem->Copy(m_dest, m_retainHierarchy, m_expandPlaceholders, TRUE));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionCopy::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelocateAction::FinalConstruct());
        m_nameId = IDS_HSMACTIONCOPY_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionCopy::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionCopy::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionCopy;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionCopy::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionMove::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirmHr(pScanItem->Move(m_dest, m_retainHierarchy, m_expandPlaceholders, TRUE));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionMove::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelocateAction::FinalConstruct());
        m_nameId = IDS_HSMACTIONMOVE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionMove::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionMove::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionMove;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionMove::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmacrsc.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmacrsc.cpp

Abstract:

    This component represents the actions that can be performed by a job
    on a resource either before or after the scan.

Author:

    Ronald G. White [ronw]       14-Aug-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"

#ifndef _HSMACRSC_
#define _HSMACRSC_


// Abstract Classes

/*++

Class Name:
    
    CHsmActionOnResource

Class Description:

    An abstract class that represents an action that can be performed
    on a resource. Specific actions are implemented as subclasses
    of this object.

--*/

class CHsmActionOnResource : 
    public CWsbObject,
    public IHsmActionOnResource
{
public:

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* /*pSize*/) {
            return(E_NOTIMPL); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT * /*passed*/, USHORT* /*failed*/) {
            return(E_NOTIMPL); }

// IHsmAction
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);

protected:
    ULONG       m_nameId;
};

/*++

Class Name:
    
    CHsmActionOnResourcePost

Class Description:

    An abstract class that represents an action that can be performed
    on a resource after a job. Specific actions are implemented as subclasses
    of this object.

--*/

class CHsmActionOnResourcePost : 
    public CHsmActionOnResource,
    public IHsmActionOnResourcePost
{
public:
};

/*++

Class Name:
    
    CHsmActionOnResourcePre

Class Description:

    An abstract class that represents an action that can be performed
    on a resource before a job starts. Specific actions are implemented as subclasses
    of this object.

--*/

class CHsmActionOnResourcePre : 
    public CHsmActionOnResource,
    public IHsmActionOnResourcePre
{
public:
};

/*++

Class Name:
    
    CHsmActionOnResourcePreScan

Class Description:

    An abstract class that represents an action that can be performed
    on a resource before scanning for a job starts. Specific actions are implemented as subclasses
    of this object.

--*/

class CHsmActionOnResourcePreScan : 
    public CHsmActionOnResource,
    public IHsmActionOnResourcePreScan
{
public:
};

// Concrete Classes : Inheriting from CHsmActionOnResource

/*++

Class Name:
    
    CHsmActionOnResourcePostValidate

Class Description:

    A class that represents the action required by the resource after
    a Validate job ends.

--*/

class CHsmActionOnResourcePostValidate :    
    public CHsmActionOnResourcePost,
    public CComCoClass<CHsmActionOnResourcePostValidate,&CLSID_CHsmActionOnResourcePostValidate>
{
public:
    CHsmActionOnResourcePostValidate() {}
BEGIN_COM_MAP(CHsmActionOnResourcePostValidate)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmActionOnResource)
    COM_INTERFACE_ENTRY(IHsmActionOnResourcePost)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionOnResourcePostValidate)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmActionOnResource
public:
    STDMETHOD(Do)(IHsmJobWorkItem* pWorkItem, HSM_JOB_STATE state);
};

/*++

Class Name:
    
    CHsmActionOnResourcePreValidate

Class Description:

    A class that represents the action required by the resource before
    a Validate job starts.

--*/

class CHsmActionOnResourcePreValidate : 
    public CHsmActionOnResourcePre,
    public CComCoClass<CHsmActionOnResourcePreValidate,&CLSID_CHsmActionOnResourcePreValidate>
{
public:
    CHsmActionOnResourcePreValidate() {}
BEGIN_COM_MAP(CHsmActionOnResourcePreValidate)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmActionOnResource)
    COM_INTERFACE_ENTRY(IHsmActionOnResourcePre)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionOnResourcePreValidate)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmActionOnResource
public:
    STDMETHOD(Do)(IHsmJobWorkItem* pWorkItem, IHsmJobDef* pJobDef);
};

/*++

Class Name:
    
    CHsmActionOnResourcePostUnmanage

Class Description:

    A class that represents the action required by the resource after
    a Unmanage job ends.

--*/

class CHsmActionOnResourcePostUnmanage :    
    public CHsmActionOnResourcePost,
    public CComCoClass<CHsmActionOnResourcePostUnmanage,&CLSID_CHsmActionOnResourcePostUnmanage>
{
public:
    CHsmActionOnResourcePostUnmanage() {}
BEGIN_COM_MAP(CHsmActionOnResourcePostUnmanage)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmActionOnResource)
    COM_INTERFACE_ENTRY(IHsmActionOnResourcePost)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionOnResourcePostUnmanage)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmActionOnResource
public:
    STDMETHOD(Do)(IHsmJobWorkItem* pWorkItem, HSM_JOB_STATE state);
};

/*++

Class Name:
    
    CHsmActionOnResourcePreUnmanage

Class Description:

    A class that represents the action required by the resource before
    an Unmanage job ends.

--*/

class CHsmActionOnResourcePreUnmanage : 
    public CHsmActionOnResourcePre,
    public CComCoClass<CHsmActionOnResourcePreUnmanage,&CLSID_CHsmActionOnResourcePreUnmanage>
{
public:
    CHsmActionOnResourcePreUnmanage() {}
BEGIN_COM_MAP(CHsmActionOnResourcePreUnmanage)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmActionOnResource)
    COM_INTERFACE_ENTRY(IHsmActionOnResourcePre)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionOnResourcePreUnmanage)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmActionOnResource
public:
    STDMETHOD(Do)(IHsmJobWorkItem* pWorkItem, IHsmJobDef* pJobDef);
};

/*++

Class Name:
    
    CHsmActionOnResourcePreScanUnmanage

Class Description:

    A class that represents the action required by the resource before 
    scanning for an Unmanage job ends.

--*/

class CHsmActionOnResourcePreScanUnmanage : 
    public CHsmActionOnResourcePreScan,
    public CComCoClass<CHsmActionOnResourcePreScanUnmanage,&CLSID_CHsmActionOnResourcePreScanUnmanage>
{
public:
    CHsmActionOnResourcePreScanUnmanage() {}
BEGIN_COM_MAP(CHsmActionOnResourcePreScanUnmanage)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmActionOnResource)
    COM_INTERFACE_ENTRY(IHsmActionOnResourcePreScan)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionOnResourcePreScanUnmanage)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmActionOnResourcePreScan
public:
    STDMETHOD(Do)(IFsaResource* pFsaResource, IHsmSession* pSession);
};

#endif // _HSMACRSC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmcrit.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmcrit.cpp

Abstract:

    This component represents the criteria that can be used to determine
    whether a given scanItem should have a policy applied to it.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"

#ifndef _HSMCRIT_
#define _HSMCRIT_


// Abstract Classes

/*++

Class Name:
    
    CHsmCriteria

Class Description:

    An abstract class that represents the criteria that can be used to determine
    whether a given FsaScanItem should have a policy applied to it. These criteria
    are based upon properties of an FsaScanItem.

--*/

class CHsmCriteria : 
    public CWsbObject,
    public IHsmCriteria
{
// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmCriteria
public:
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(IsIgnored)(void);
    STDMETHOD(IsNegated)(void);
    STDMETHOD(SetIsIgnored)(BOOL isIgnored);
    STDMETHOD(SetIsNegated)(BOOL isNegated);

protected:
    ULONG       m_nameId;
    BOOL        m_isIgnored;
    BOOL        m_isNegated;
};



/*++

Class Name:
    
    CHsmRelativeCriteria

Class Description:

    An abstract class that represents the criteria that compare the properties
    of the FsaScanItem to another value (or values) to determine whether the
    FsaScanItem matches.

--*/

class CHsmRelativeCriteria : 
    public CHsmCriteria,
    public IHsmRelativeCriteria
{
// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IHsmRelativeCriteria
public:
    STDMETHOD(ComparatorAsString)(OLECHAR** pComparator, ULONG bufferSize);
    STDMETHOD(ComparatorIsBinary)(void);
    STDMETHOD(GetArg1)(OLECHAR** pArg, ULONG bufferSize);
    STDMETHOD(GetArg2)(OLECHAR** pArg, ULONG bufferSize);
    STDMETHOD(GetComparator)(HSM_CRITERIACOMPARATOR* pComparator);
    STDMETHOD(SetComparator)(HSM_CRITERIACOMPARATOR comparator);
    STDMETHOD(SetArg1)(OLECHAR* arg);
    STDMETHOD(SetArg2)(OLECHAR* arg);

protected:
    HSM_CRITERIACOMPARATOR      m_comparator;
    OLECHAR*                    m_arg1;
    OLECHAR*                    m_arg2;
};


// Concrete Classes : Inheriting from CHsmAction

/*++

Class Name:
    
    CHsmCritAlways

Class Description:

    A criteria that matches all FsaScanItems.

--*/

class CHsmCritAlways : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritAlways,&CLSID_CHsmCritAlways>
{
public:
    CHsmCritAlways() {}
BEGIN_COM_MAP(CHsmCritAlways)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritAlways)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritCompressed

Class Description:

    A criteria that matches an FsaScanItems that is compressed.

--*/

class CHsmCritCompressed : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritCompressed,&CLSID_CHsmCritCompressed>
{
public:
    CHsmCritCompressed() {}
BEGIN_COM_MAP(CHsmCritCompressed)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritCompressed)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritLinked

Class Description:

    A criteria that matches an FsaScanItem that is a symbolic link or mount
    point.

--*/

class CHsmCritLinked : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritLinked,&CLSID_CHsmCritLinked>
{
public:
    CHsmCritLinked() {}
BEGIN_COM_MAP(CHsmCritLinked)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritLinked)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};

    
/*++

Class Name:
    
    CHsmCritMbit

Class Description:

    A criteria that matches an FsaScanItem whose mbit (modify bit) is set.

--*/

class CHsmCritMbit : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritMbit,&CLSID_CHsmCritMbit>
{
public:
    CHsmCritMbit() {}
BEGIN_COM_MAP(CHsmCritMbit)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritMbit)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};

    

/*++

Class Name:
    
    CHsmCritManageable

Class Description:

    A criteria that matches an FsaScanItem that the Fsa thinks is capable of
    migrated.

--*/

class CHsmCritManageable : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritManageable,&CLSID_CHsmCritManageable>
{
public:
    CHsmCritManageable() {}
BEGIN_COM_MAP(CHsmCritManageable)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritManageable)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritMigrated

Class Description:

    A criteria that matches an FsaScanItem that has been migrated.

--*/

class CHsmCritMigrated : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritMigrated,&CLSID_CHsmCritMigrated>
{
public:
    CHsmCritMigrated() {}
BEGIN_COM_MAP(CHsmCritMigrated)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritMigrated)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritPremigrated

Class Description:

    A criteria that matches an FsaScanItem that has been premigrated.

--*/

class CHsmCritPremigrated : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritPremigrated,&CLSID_CHsmCritPremigrated>
{
public:
    CHsmCritPremigrated() {}
BEGIN_COM_MAP(CHsmCritPremigrated)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritPremigrated)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritAccessTime

Class Description:

    A criteria that compares the configured time (either absolute or relative)
    to the FsaScanItem's last access time to determine if it matches.

--*/

class CHsmCritAccessTime : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritAccessTime,&CLSID_CHsmCritAccessTime>
{
public:
    CHsmCritAccessTime() {}
BEGIN_COM_MAP(CHsmCritAccessTime)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritAccessTime)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(SetArg1)(OLECHAR* arg);
    STDMETHOD(SetArg2)(OLECHAR* arg);
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);

protected:
    BOOL            m_isRelative;
    FILETIME        m_value1;
    FILETIME        m_value2;
};


/*++

Class Name:
    
    CHsmCritGroup

Class Description:

    A criteria that compares the group specified to the group indicated being
    the owner of the FsaScanItem.

--*/

class CHsmCritGroup : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritGroup,&CLSID_CHsmCritGroup>
{
public:
    CHsmCritGroup() {}
BEGIN_COM_MAP(CHsmCritGroup)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritGroup)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritLogicalSize

Class Description:

    A criteria that compares the logical size (uncompressed, not migrated, ...)
    of the FsaScanItem to the configured values.

--*/

class CHsmCritLogicalSize : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritLogicalSize,&CLSID_CHsmCritLogicalSize>
{
public:
    CHsmCritLogicalSize() {}
BEGIN_COM_MAP(CHsmCritLogicalSize)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritLogicalSize)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(SetArg1)(OLECHAR* arg);
    STDMETHOD(SetArg2)(OLECHAR* arg);
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);

protected:
    LONGLONG        m_value1;
    LONGLONG        m_value2;
};


/*++

Class Name:
    
    CHsmCritModifyTime

Class Description:

    A criteria that compares the configured time (either absolute or relative)
    to the FsaScanItem's last modification time to determine if it matches.

--*/

// Class:   CHsmCritModifyTime
class CHsmCritModifyTime : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritModifyTime,&CLSID_CHsmCritModifyTime>
{
public:
    CHsmCritModifyTime() {}
BEGIN_COM_MAP(CHsmCritModifyTime)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritModifyTime)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(SetArg1)(OLECHAR* arg);
    STDMETHOD(SetArg2)(OLECHAR* arg);
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);

protected:
    BOOL            m_isRelative;
    FILETIME        m_value1;
    FILETIME        m_value2;
};


/*++

Class Name:
    
    CHsmCritOwner

Class Description:

    A criteria that compares the owner specified to the owner of the FsaScanItem.

--*/

class CHsmCritOwner : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritOwner,&CLSID_CHsmCritOwner>
{
public:
    CHsmCritOwner() {}
BEGIN_COM_MAP(CHsmCritOwner)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritOwner)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritPhysicalSize

Class Description:

    A criteria that compares the physical size (compressed, migrated, ...)
    of the FsaScanItem to the configured values.

--*/

class CHsmCritPhysicalSize : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritPhysicalSize,&CLSID_CHsmCritPhysicalSize>
{
public:
    CHsmCritPhysicalSize() {}
BEGIN_COM_MAP(CHsmCritPhysicalSize)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritPhysicalSize)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(SetArg1)(OLECHAR* arg);
    STDMETHOD(SetArg2)(OLECHAR* arg);
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);

protected:
    LONGLONG        m_value1;
    LONGLONG        m_value2;
};

#endif // _HSMCRIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmacrsc.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmacrsc.cpp

Abstract:

    This component represents the actions that can be performed by a job
    on a resource either before or after the scan.

Author:

    Ronald G. White [ronw]       14-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "stdio.h"

#include "wsb.h"
#include "job.h"
#include "HsmConn.h"
#include "hsmacrsc.h"

#include "fsaprv.h"
#include "fsa.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmActionOnResource::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmActionOnResource::GetName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, m_nameId));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionOnResource::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResource::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResource::Load"), OLESTR("hr = <%ls>, nameId = <%lu>"), WsbHrAsString(hr), m_nameId);

    return(hr);
}


HRESULT
CHsmActionOnResource::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResource::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResource::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CHsmActionOnResourcePostValidate::Do(
    IHsmJobWorkItem* pWorkItem,
    HSM_JOB_STATE state
    )

/*++

Implements:

  IHsmActionOnResource::Do().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostValidate::Do"), 
            OLESTR("pWorkItem = %p, state = %ld"), pWorkItem,
            (LONG)state);

    try {
        GUID                      id;
        CComPtr<IFsaResource>     pResource;

        WsbAssertPointer(pWorkItem);

        //  Get resource associated with this work item
        WsbAffirmHr(pWorkItem->GetResourceId(&id));
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, id, IID_IFsaResource, (void**) &pResource));

        //  Tell the resource what's happening
        WsbAffirmHr(pResource->EndValidate(state));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostValidate::Do"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionOnResourcePostValidate::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostValidate::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionOnResourcePostValidate;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostValidate::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmActionOnResourcePostValidate::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostValidate::FinalConstruct"), OLESTR(""));
    
    try {

        WsbAffirmHr(CHsmActionOnResource::FinalConstruct());
        m_nameId = IDS_HSMACTIONONRESOURCEPOSTVALIDATE_ID;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostValidate::FinalConstruct"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CHsmActionOnResourcePreValidate::Do(
    IHsmJobWorkItem* pWorkItem,
    IHsmJobDef* pJobDef
    )

/*++

Implements:

  IHsmActionOnResource::Do().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreValidate::Do"), 
            OLESTR("pWorkItem = %p, pJobDef=%p"), pWorkItem, pJobDef);

    try {
        GUID                      id;
        CComPtr<IFsaResource>     pResource;

        WsbAssertPointer(pWorkItem);

        //  Get resource associated with this work item
        WsbAffirmHr(pWorkItem->GetResourceId(&id));
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, id, IID_IFsaResource, (void**) &pResource));

        //  Tell the resource what's happening
        WsbAffirmHr(pResource->BeginValidate());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreValidate::Do"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionOnResourcePreValidate::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreValidate::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionOnResourcePreValidate;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreValidate::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmActionOnResourcePreValidate::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreValidate::FinalConstruct"), 
            OLESTR(""));
    
    try {

        WsbAffirmHr(CHsmActionOnResource::FinalConstruct());
        m_nameId = IDS_HSMACTIONONRESOURCEPREVALIDATE_ID;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreValidate::FinalConstruct"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmActionOnResourcePostUnmanage::Do(
    IHsmJobWorkItem* pWorkItem,
    HSM_JOB_STATE state
    )

/*++

Implements:

  IHsmActionOnResource::Do().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostUnmanage::Do"), 
            OLESTR("pWorkItem = %p, state = %ld"), pWorkItem,
            (LONG)state);

    try {
        GUID                      id, hsmId;
        CComPtr<IFsaResource>     pResource;
        CComPtr<IFsaResourcePriv> pResourcePriv;
        CComPtr<IHsmServer>       pHsm;

        WsbAssertPointer(pWorkItem);

        //  Get resource associated with this work item
        WsbAffirmHr(pWorkItem->GetResourceId(&id));
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, id, IID_IFsaResource, (void**) &pResource));

        // Delete the temporary Unmanage database that we use for scanning in the right order (ignore errors)
        hr = pResource->QueryInterface(IID_IFsaResourcePriv, (void**) &pResourcePriv);
        if (SUCCEEDED(hr)) {
            // ignore errors
            (void)pResourcePriv->TerminateUnmanageDb();
        }

        // Get back to the HSM system so we can remove it

        WsbAffirmHr(pResource->GetManagingHsm(&hsmId));
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, hsmId, IID_IHsmServer, (void**) &pHsm));

        // Get the collection and find the coresponding object
        CComPtr<IWsbIndexedCollection> pCollection;
        WsbAffirmHr(pHsm->GetManagedResources(&pCollection));

        CComPtr<IWsbCreateLocalObject> pCreate;
        WsbAffirmHr(pHsm->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreate));

        CComPtr<IHsmManagedResource> pHsmResourceKey, pHsmResource;
        WsbAffirmHr(pCreate->CreateInstance(CLSID_CHsmManagedResource, IID_IHsmManagedResource, (void**) &pHsmResourceKey));
        WsbAffirmHr(pHsmResourceKey->SetResourceId(id));

        WsbAffirmHr(pCollection->Find(pHsmResourceKey, IID_IHsmManagedResource, (void**) &pHsmResource));

        // Remove the volume from management
        WsbAffirmHr(pCollection->RemoveAndRelease(pHsmResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostUnmanage::Do"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionOnResourcePostUnmanage::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostUnmanage::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionOnResourcePostUnmanage;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostUnmanage::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmActionOnResourcePostUnmanage::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostUnmanage::FinalConstruct"), OLESTR(""));
    
    try {

        WsbAffirmHr(CHsmActionOnResource::FinalConstruct());
        m_nameId = IDS_HSMACTIONONRESOURCEPOSTUNMANAGE_ID;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostUnmanage::FinalConstruct"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionOnResourcePreUnmanage::Do(
    IHsmJobWorkItem* pWorkItem,
    IHsmJobDef* pJobDef
    )

/*++

Implements:

  IHsmActionOnResource::Do().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreUnmanage::Do"), 
            OLESTR("pWorkItem = %p, pJobDef=%p"), pWorkItem, pJobDef);

    try {
        GUID                                        id;
        CComPtr<IFsaResource>                       pResource;

        CComPtr<IHsmServer>                         pHsm;
        CComPtr<IWsbCreateLocalObject>              pCreateObj;
        CComPtr<IHsmActionOnResourcePreScan>        pActionResourcePreScan;
        GUID                                        hsmId = GUID_NULL;

        WsbAssertPointer(pWorkItem);
        WsbAssertPointer(pJobDef);

        // Create a pre-scan action and assign to the job definition
        // Note: Naturally, creating the pre-scan action would have been done in CHsmJobDef::InitAs
        //       However, since we cannot add new persistent members to JobDef (.col files mismatch on upgrade...),
        //       we let the pre-action to create a pre-scan-action if necessary
        WsbAffirmHr(pJobDef->SetUseDbIndex(TRUE));

        // hsm-id is not used today in HsmConnectFromId for HSMCONN_TYPE_HSM
        // When it does - use IFsaResource::GetManagingHsm to get the hsm-id
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, hsmId, IID_IHsmServer, (void**) &pHsm));
        WsbAffirmHr(pHsm->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
        WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePreScanUnmanage,
                        IID_IHsmActionOnResourcePreScan, (void**) &pActionResourcePreScan));
        WsbAffirmHr(pJobDef->SetPreScanActionOnResource(pActionResourcePreScan));

        //  Get resource associated with this work item
        WsbAffirmHr(pWorkItem->GetResourceId(&id));
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, id, IID_IFsaResource, (void**) &pResource));

        //  Tell the resource what's happening
        WsbAffirmHr(pResource->SetIsDeletePending( TRUE ));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreUnmanage::Do"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionOnResourcePreUnmanage::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreUnmanage::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionOnResourcePreUnmanage;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreUnmanage::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmActionOnResourcePreUnmanage::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreUnmanage::FinalConstruct"), 
            OLESTR(""));
    
    try {

        WsbAffirmHr(CHsmActionOnResource::FinalConstruct());
        m_nameId = IDS_HSMACTIONONRESOURCEPREUNMANAGE_ID;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreUnmanage::FinalConstruct"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmActionOnResourcePreScanUnmanage::Do(
    IFsaResource* pFsaResource,
    IHsmSession* pSession
    )

/*++

Implements:

  IHsmActionOnResource::Do().

--*/
{
    HRESULT                     hr = S_OK;

    CComPtr<IFsaUnmanageDb>    pUnmanageDb;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IFsaUnmanageRec>    pUnmanageRec;
    BOOL                        bDbOpen = FALSE;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreScanUnmanage::Do"), OLESTR(""));

    try {
        CComPtr<IFsaResourcePriv>   pResourcePriv;
        CComPtr<IFsaScanItem>       pScanItem;
        CComPtr<IHsmServer>         pHsmServer;
        GUID                        hsmId = GUID_NULL;

        // Scan according to RP index and fill the Db
        // Don't need recursive scanning since we scan the RP index of the volume
        hr = pFsaResource->FindFirstInRPIndex(pSession, &pScanItem);

        if (SUCCEEDED(hr)) {
            // At least one managed file is found...
            // Initialize the Unmanaged Db for this resource
            WsbAffirmHr(pFsaResource->QueryInterface(IID_IFsaResourcePriv, (void**) &pResourcePriv));
            WsbAffirmHr(pResourcePriv->InitializeUnmanageDb());

            // Get and open the database
            WsbAffirmHr(pResourcePriv->GetUnmanageDb(IID_IFsaUnmanageDb, (void**) &pUnmanageDb));
            WsbAffirmHr(pUnmanageDb->Open(&pDbSession));
            bDbOpen = TRUE;

            // Get a record to work with 
            WsbAffirmHr(pUnmanageDb->GetEntity(pDbSession, UNMANAGE_REC_TYPE, IID_IFsaUnmanageRec, (void**) &pUnmanageRec));

            // Get HSM Server
            // Note: hsm-id is not used today in HsmConnectFromId for HSMCONN_TYPE_HSM
            // When it does - use IFsaResource::GetManagingHsm to get the hsm-id
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, hsmId, IID_IHsmServer, (void**) &pHsmServer));
        }

        while (SUCCEEDED(hr)) {
            LONGLONG        offset = 0;
            LONGLONG        size = 0;
            FSA_PLACEHOLDER placeholder;

            GUID            mediaId;
            LONGLONG        fileOffset;
            LONGLONG        fileId;  
            LONGLONG        segOffset;

            hr = pScanItem->GetPlaceholder(offset, size, &placeholder);
            if (S_OK == hr) {
                // File must be managed by HSM
                // If the file is truncated, then we need to add to the Db
                if (pScanItem->IsTruncated(offset, size) == S_OK) {

                    // Get segment details from the Engine and calculate absolute offset
                    WsbAffirmHr(pHsmServer->GetSegmentPosition(placeholder.bagId, placeholder.fileStart,
                             placeholder.fileSize, &mediaId, &segOffset));
                    fileOffset = segOffset + placeholder.fileStart + placeholder.dataStart;
                        
                    // Add to the Unmanage database
                    WsbAffirmHr(pScanItem->GetFileId(&fileId));
                    WsbAffirmHr(pUnmanageRec->SetMediaId(mediaId));
                    WsbAffirmHr(pUnmanageRec->SetFileOffset(fileOffset));
                    WsbAffirmHr(pUnmanageRec->SetFileId(fileId));

                    WsbAffirmHr(pUnmanageRec->MarkAsNew());
                    WsbAffirmHr(pUnmanageRec->Write());

                } else {

                    // Note: We will continue here even if we fail to cleanup non-truncated files, because  
                    // the auto-truncator is suspended (so no premigrated files will become truncated while 
                    // the job is running) and this piece of code will be tried again in CFsaScanItem::Unmanage
                    try {

                        //  For disaster recovery, it would be better to delete the placeholder
                        //  and THEN remove this file from the premigration list.  Unfortunately,
                        //  after deleting the placeholder, the RemovePremigrated call fails
                        //  because it needs to get some information from the placeholder (which
                        //  is gone).  So we do it in this order.
                        hr = pFsaResource->RemovePremigrated(pScanItem, offset, size);
                        if (WSB_E_NOTFOUND == hr) {
                            //  It's no tragedy if this file wasn't in the list since we were
                            //  going to delete it anyway (although it shouldn't happen) so
                            //  let's continue anyway
                            hr = S_OK;
                        }
                        WsbAffirmHr(hr);

                        WsbAffirmHr(pScanItem->DeletePlaceholder(offset, size));

                    } WsbCatchAndDo(hr, 
                            WsbTraceAlways(OLESTR("...PreScanUnmanage::Do: failed to handle premigrated file, hr = <%ls>\n"),
                                WsbHrAsString(hr));
                            hr = S_OK;
                    );
                }   
            }

            // Get next file
            hr = pFsaResource->FindNextInRPIndex(pScanItem);
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    if (bDbOpen) {
        pUnmanageRec = 0;
        (void)pUnmanageDb->Close(pDbSession);
    }

    if (! SUCCEEDED(hr)) {
        // Log an error message 
        CWsbStringPtr tmpString;
        hr = pFsaResource->GetPath(&tmpString, 0);
        if (hr != S_OK) {
            tmpString = OLESTR("");
        }
        WsbLogEvent(JOB_MESSAGE_UNMANAGE_PRESCAN_FAILED, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
    }

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreScanUnmanage::Do"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmActionOnResourcePreScanUnmanage::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreScanUnmanage::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionOnResourcePreScanUnmanage;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreScanUnmanage::GetClassID"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmActionOnResourcePreScanUnmanage::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreScanUnmanage::FinalConstruct"), OLESTR(""));
    
    try {

        WsbAffirmHr(CHsmActionOnResource::FinalConstruct());
        m_nameId = IDS_HSMACTIONONRESOURCEPRESCANUNMANAGE_ID;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreScanUnmanage::FinalConstruct"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmcrit.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmcrit.cpp

Abstract:

    This component represents the criteria that can be used to determine
    whether a given scanItem should have a policy applied to it.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"
#include "mapiutil.h"

#include "wsb.h"
#include "job.h"
#include "hsmcrit.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmCriteria::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_isIgnored = FALSE;
        m_isNegated = FALSE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCriteria::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::GetName().

--*/
{
    HRESULT     hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, m_nameId));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCriteria::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCriteria::GetSizeMax"), OLESTR(""));

    try {
       
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = WsbPersistSizeOf(GUID) + WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(BOOL);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCriteria::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmCriteria::IsIgnored(
    void
    )

/*++

Implements:

  IHsmCriteria::IsIgnored().

--*/
{
    return(m_isIgnored ? S_OK : S_FALSE);
}


HRESULT
CHsmCriteria::IsNegated(
    void
    )

/*++

Implements:

  IHsmCriteria::IsNegated().

--*/
{
    return(m_isNegated ? S_OK : S_FALSE);
}


HRESULT
CHsmCriteria::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCriteria::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isIgnored));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isNegated));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCriteria::Load"), OLESTR("hr = <%ls>, nameId = <%lu>"), WsbHrAsString(hr), m_nameId);

    return(hr);
}


HRESULT
CHsmCriteria::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCriteria::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isIgnored));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isNegated));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCriteria::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCriteria::SetIsIgnored(
    IN BOOL isIgnored
    )

/*++

Implements:

  IHsmCriteria::SetIsIgnored().

--*/
{
    m_isIgnored = isIgnored;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmCriteria::SetIsNegated(
    IN BOOL isNegated
    )

/*++

Implements:

  IHsmCriteria::SetIsNegated().

--*/
{
    m_isNegated = isNegated;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmCriteria::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmRelativeCriteria::ComparatorAsString(
    OUT OLECHAR** pComparator,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmRelativeCriteria::ComparatorAsString().

--*/
{
    HRESULT         hr = S_OK;

    try {
        
        WsbAssert(0 != pComparator, E_POINTER);
        WsbAffirmHr(WsbLoadComString(_Module.m_hInst, IDS_HSM_CRITERIACOMPARATOR_NOTSET + m_comparator, pComparator, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::ComparatorIsBinary(
    void
    )

/*++

Implements:

  IHsmRelativeCriteria::ComparatorIsBinary().

--*/
{
    HRESULT         hr = S_FALSE;

    if ((m_comparator == HSM_CRITERIACOMPARATOR_BETWEEN) ||
        (m_comparator == HSM_CRITERIACOMPARATOR_OUTSIDE)) {

        hr = S_OK;
    }

    return(hr);
}


HRESULT
CHsmRelativeCriteria::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());

        m_comparator = HSM_CRITERIACOMPARATOR_NOTSET;
        m_arg1 = 0;
        m_arg2 = 0;

    } WsbCatch(hr);

    return(hr);
}


void
CHsmRelativeCriteria::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    
    // Free the memory used by the arg1 string.
    if (0 != m_arg1) {
        WsbFree(m_arg1);
        m_arg1 = 0;
    }

    // Free the memory used by the arg2 string.
    if (0 != m_arg2) {
        WsbFree(m_arg2);
        m_arg2 = 0;
    }

    // Let the parent class do his thing.   
    CWsbObject::FinalRelease();
}


HRESULT
CHsmRelativeCriteria::GetArg1(
    OUT OLECHAR** pArg,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmRelativeCriteria::GetArg1().

--*/
{
    HRESULT         hr = S_OK;

    try {
        
        WsbAssert(0 != pArg, E_POINTER);
        WsbAffirmHr(WsbAllocAndCopyComString(pArg, m_arg1, bufferSize));

    } WsbCatch(hr);


    return(hr);
}


HRESULT
CHsmRelativeCriteria::GetArg2(
    OUT OLECHAR** pArg,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmRelativeCriteria::GetArg2().

--*/
{
    HRESULT         hr = S_OK;

    try {
        
        WsbAssert(0 != pArg, E_POINTER);
        WsbAffirmHr(WsbAllocAndCopyComString(pArg, m_arg2, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::GetComparator(
    OUT HSM_CRITERIACOMPARATOR* pComparator
    )

/*++

Implements:

  IHsmRelativeCriteria::GetComparator().

--*/
{
    HRESULT         hr = S_OK;

    try {
        
        WsbAssert(0 != pComparator, E_POINTER);
        *pComparator = m_comparator;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRelativeCriteria::GetSizeMax"), OLESTR(""));

    try {
       
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = WsbPersistSizeOf(GUID) + WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(BOOL) + WsbPersistSize((wcslen(m_arg1) + 1) * sizeof(OLECHAR)) + WsbPersistSize((wcslen(m_arg2) + 1) * sizeof(OLECHAR));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelativeCriteria::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmRelativeCriteria::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmp;

    WsbTraceIn(OLESTR("CHsmRelativeCriteria::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isIgnored));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isNegated));
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmp, 0));
        WsbAffirmHr(SetArg1(tmp));
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmp, 0));
        WsbAffirmHr(SetArg2(tmp));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelativeCriteria::Load"), OLESTR("hr = <%ls>, nameId = <%lu>"), WsbHrAsString(hr), m_nameId);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRelativeCriteria::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isIgnored));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isNegated));
        WsbAffirmHr(WsbSaveToStream(pStream, m_arg1));
        WsbAffirmHr(WsbSaveToStream(pStream, m_arg2));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelativeCriteria::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRelativeCriteria::SetArg1(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmRelativeCriteria::SetArg1().

--*/
{
    HRESULT         hr = S_OK;

    hr = WsbAllocAndCopyComString(&m_arg1, arg, 0);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::SetArg2(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmRelativeCriteria::SetArg2().

--*/
{
    HRESULT         hr = S_OK;

    hr = WsbAllocAndCopyComString(&m_arg2, arg, 0);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::SetComparator(
    IN HSM_CRITERIACOMPARATOR comparator
    )

/*++

Implements:

  IHsmRelativeCriteria::SetComparator().

--*/
{
    m_comparator = comparator;

    return(S_OK);
}





HRESULT
CHsmCritAlways::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITALWAYS_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritAlways::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritAlways::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritAlways;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritAlways::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritAlways::ShouldDo(
    IN IFsaScanItem* /*pScanItem*/,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritAlways::ShouldDo"), OLESTR(""));

    hr = m_isNegated ? S_FALSE : S_OK;

    WsbTraceOut(OLESTR("CHsmCritAlways::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmCritAlways::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;
    OLECHAR*    name = 0;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

        try {
            WsbAssertHr(GetName(&name, 0));
            WsbAssert(wcscmp(name, OLESTR("Always")) == 0, E_FAIL);
            (*passed)++;
        } WsbCatchAndDo(hr, (*failed)++;);

    } WsbCatch(hr);

    if (0 != name) {
        WsbFree(name);
    }

    return(hr);
}


HRESULT
CHsmCritAlways::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITALWAYS_VALUE_T, pValue, bufferSize);

    } WsbCatch(hr);


    return(hr);
}




HRESULT
CHsmCritCompressed::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITCOMPRESSED_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritCompressed::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritCompressed::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritAlways;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritCompressed::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritCompressed::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritCompressed::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        hr = pScanItem->IsCompressed();

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritCompressed::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritCompressed::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        hr = pScanItem->IsCompressed();

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITCOMPRESSED_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITCOMPRESSED_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritLinked::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITLINKED_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritLinked::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritLinked::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritLinked;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritLinked::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritLinked::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritLinked::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        hr = pScanItem->IsALink();

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritLinked::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritLinked::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        hr = pScanItem->IsALink();

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITLINKED_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITLINKED_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritMbit::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITMBIT_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritMbit::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritMbit::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritMbit;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritMbit::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritMbit::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritMbit::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        hr = pScanItem->IsMbit();

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritMbit::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritMbit::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        hr = pScanItem->IsMbit();

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMBIT_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMBIT_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritManageable::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITMANAGEABLE_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritManageable::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritManageable::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritManageable;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritManageable::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritManageable::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmCritManageable::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsManageable(0, size);

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritManageable::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritManageable::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsManageable(0, size);

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMANAGEABLE_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMANAGEABLE_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritMigrated::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITMIGRATED_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritMigrated::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritMigrated::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritMigrated;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritMigrated::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritMigrated::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmCritMigrated::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsTruncated(0, size);

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritMigrated::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritMigrated::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsTruncated(0, size);

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMIGRATED_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMIGRATED_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritPremigrated::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITPREMIGRATED_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritPremigrated::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritPremigrated::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritPremigrated;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritPremigrated::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritPremigrated::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmCritPremigrated::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsPremigrated(0, size);

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritPremigrated::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritPremigrated::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsPremigrated(0, size);

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITPREMIGRATED_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITPREMIGRATED_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritAccessTime::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITACCESSTIME_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritAccessTime::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritAccessTime::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritAccessTime;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritAccessTime::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritAccessTime::SetArg1(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg1().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoFT(arg, &m_isRelative, &m_value1));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg1(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritAccessTime::SetArg2(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoFT(arg, &m_isRelative, &m_value2));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg2(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritAccessTime::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    FILETIME    time;
    FILETIME    value1 = m_value1;
    FILETIME    value2 = m_value2;
    LONG        timeCompare1;
    LONG        timeCompare2;

    WsbTraceIn(OLESTR("CHsmCritAccessTime::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the time.
        WsbAffirmHr(pScanItem->GetAccessTime(&time));

        // If this is a relative time (i.e. and age), then we need
        // to know the present time before we can do the comparrison.
        if (m_isRelative) {
            FILETIME    present;

            WsbAffirmHr(CoFileTimeNow(&present));

            value1 = WsbFtSubFt(present, m_value1);
            value2 = WsbFtSubFt(present, m_value2);
        }

        // Compare the first arg.
        timeCompare1 = CompareFileTime(&value1, &time);

        // Now interpret the result based on the type of comparisson.
        hr = S_FALSE;
        switch (m_comparator) {

        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

         case HSM_CRITERIACOMPARATOR_LT:
            if (timeCompare1 < 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (timeCompare1 <= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (timeCompare1 == 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (timeCompare1 != 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (timeCompare1 >= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (timeCompare1 > 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            timeCompare2 = CompareFileTime(&value2, &time);
                
            if ((timeCompare1 >= 0) && (timeCompare2 <= 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            timeCompare2 = CompareFileTime(&value2, &time);
                
            if ((timeCompare1 < 0) || (timeCompare2 > 0)) {
                hr = S_OK;
            }
            break;
        }

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritAccessTime::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritAccessTime::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    FILETIME    time;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetAccessTime(&time));

        // If this is a relative time (i.e. and age), then we need
        // to know the present time before we can do the comparrison.
        if (m_isRelative) {
            FILETIME    present;

            WsbAffirmHr(CoFileTimeNow(&present));
            time = WsbFtSubFt(present, time);
        }

        hr = WsbFTtoWCS(m_isRelative, time, pValue, bufferSize);

    } WsbCatch(hr);

    return(hr);
}





HRESULT
CHsmCritGroup::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITGROUP_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritGroup::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritGroup::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritGroup;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritGroup::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritGroup::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    OLECHAR*    group = 0;
    int         stringCompare1;
    int         stringCompare2;

    WsbTraceIn(OLESTR("CHsmCritGroup::ShouldDo"), OLESTR(""));
    
    try {

        // We at least need one argument to be able to do a comparisson.
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the Group's name.
        WsbAffirmHr(pScanItem->GetGroup(&group, 0));

        hr = S_FALSE;
        stringCompare1 = wcscmp(m_arg1, group);

        switch (m_comparator) {
        
        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

        case HSM_CRITERIACOMPARATOR_LT:
            if (stringCompare1 < 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (stringCompare1 <= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (stringCompare1 == 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (stringCompare1 != 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (stringCompare1 >= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (stringCompare1 > 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert( 0 != m_arg2, E_INVALIDARG);

            stringCompare2 = wcscmp(m_arg2, group);
                
            if ((stringCompare1 >= 0) && (stringCompare2 <= 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert( 0 != m_arg2, E_INVALIDARG);

            stringCompare2 = wcscmp(m_arg2, group);
                
            if ((stringCompare1 < 0) || (stringCompare2 > 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_MEMBEROF:
            hr = pScanItem->IsGroupMemberOf(m_arg1);
            break;
        }

        WsbFree(group);

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritGroup::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritGroup::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetGroup(pValue, bufferSize));

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritLogicalSize::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITLOGICALSIZE_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritLogicalSize::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritLogicalSize::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritLogicalSize;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritLogicalSize::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritLogicalSize::SetArg1(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoLL(arg, &m_value1));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg1(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritLogicalSize::SetArg2(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoLL(arg, &m_value2));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg2(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritLogicalSize::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmCritLogicalSize::ShouldDo"), OLESTR(""));
    
    try {

        // We at least need one argument to be able to do a comparisson.
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the size.
        WsbAffirmHr(pScanItem->GetLogicalSize(&size));

        // See how it compares.
        hr = S_FALSE;

        switch (m_comparator) {

        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

        case HSM_CRITERIACOMPARATOR_LT:
            if (size < m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (size <= m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (size == m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (size != m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (size >= m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (size > m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            if ((m_value1 <= size) && (size <= m_value2)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            if ((size < m_value1) || (m_value2 > size)) {
                hr = S_OK;
            }

            break;
        }

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritLogicalSize::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmCritLogicalSize::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        WsbAffirmHr(WsbLLtoWCS(size, pValue, bufferSize));

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritModifyTime::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITMODIFYTIME_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritModifyTime::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritModifyTime::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritModifyTime;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritModifyTime::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritModifyTime::SetArg1(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg1().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoFT(arg, &m_isRelative, &m_value1));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg1(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritModifyTime::SetArg2(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoFT(arg, &m_isRelative, &m_value2));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg2(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritModifyTime::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    FILETIME    time;
    FILETIME    value1 = m_value1;
    FILETIME    value2 = m_value2;
    LONG        timeCompare1;
    LONG        timeCompare2;

    WsbTraceIn(OLESTR("CHsmCritModifyTime::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the time.
        WsbAffirmHr(pScanItem->GetModifyTime(&time));

        // If this is a relative time (i.e. and age), then we need
        // to know the present time before we can do the comparrison.
        if (m_isRelative) {
            FILETIME    present;

            WsbAffirmHr(CoFileTimeNow(&present));

            value1 = WsbFtSubFt(present, m_value1);
            value2 = WsbFtSubFt(present, m_value2);
        }

        // Compare the first arg.
        timeCompare1 = CompareFileTime(&value1, &time);

        // Now interpret the result based on the type of comparisson.
        hr = S_FALSE;
        switch (m_comparator) {

        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

         case HSM_CRITERIACOMPARATOR_LT:
            if (timeCompare1 < 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (timeCompare1 <= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (timeCompare1 == 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (timeCompare1 != 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (timeCompare1 >= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (timeCompare1 > 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            timeCompare2 = CompareFileTime(&value2, &time);
                
            if ((timeCompare1 >= 0) && (timeCompare2 <= 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            timeCompare2 = CompareFileTime(&value2, &time);
                
            if ((timeCompare1 < 0) || (timeCompare2 > 0)) {
                hr = S_OK;
            }
            break;
        }

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritModifyTime::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritModifyTime::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    FILETIME    time;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetModifyTime(&time));

        // If this is a relative time (i.e. and age), then we need
        // to know the present time before we can do the comparrison.
        if (m_isRelative) {
            FILETIME    present;

            WsbAffirmHr(CoFileTimeNow(&present));
            time = WsbFtSubFt(present, time);
        }

        hr = WsbFTtoWCS(m_isRelative, time, pValue, bufferSize);

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritOwner::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITOWNER_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritOwner::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritOwner::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritOwner;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritOwner::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritOwner::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    OLECHAR*    owner = 0;
    int         stringCompare1;
    int         stringCompare2;

    WsbTraceIn(OLESTR("CHsmCritOwner::ShouldDo"), OLESTR(""));
    
    try {

        // We at least need one argument to be able to do a comparisson.
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the Group's name.
        WsbAffirmHr(pScanItem->GetOwner(&owner, 0));

        hr = S_FALSE;
        stringCompare1 = wcscmp(m_arg1, owner);

        switch (m_comparator) {
        
        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

        case HSM_CRITERIACOMPARATOR_LT:
            if (stringCompare1 < 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (stringCompare1 <= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (stringCompare1 == 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (stringCompare1 != 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (stringCompare1 >= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (stringCompare1 > 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert( 0 != m_arg2, E_INVALIDARG);

            stringCompare2 = wcscmp(m_arg2, owner);
                
            if ((stringCompare1 >= 0) && (stringCompare2 <= 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert( 0 != m_arg2, E_INVALIDARG);

            stringCompare2 = wcscmp(m_arg2, owner);
                
            if ((stringCompare1 < 0) || (stringCompare2 > 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_MEMBEROF:
            hr = pScanItem->IsOwnerMemberOf(m_arg1);
            break;
        }

        WsbFree(owner);

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritOwner::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritOwner::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetOwner(pValue, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritPhysicalSize::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITPHYSICALSIZE_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritPhysicalSize::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritPhysicalSize::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritPhysicalSize;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritPhysicalSize::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritPhysicalSize::SetArg1(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoLL(arg, &m_value1));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg1(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritPhysicalSize::SetArg2(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoLL(arg, &m_value2));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg2(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritPhysicalSize::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmCritPhysicalSize::ShouldDo"), OLESTR(""));
    
    try {

        // We at least need one argument to be able to do a comparisson.
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the size.
        WsbAffirmHr(pScanItem->GetPhysicalSize(&size));

        // See how it compares.
        hr = S_FALSE;

        switch (m_comparator) {

        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

        case HSM_CRITERIACOMPARATOR_LT:
            if (size < m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (size <= m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (size == m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (size != m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (size >= m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (size > m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            if ((m_value1 <= size) && (size <= m_value2)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            if ((size < m_value1) || (m_value2 > size)) {
                hr = S_OK;
            }

            break;
        }

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritPhysicalSize::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmCritPhysicalSize::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetPhysicalSize(&size));
        WsbAffirmHr(WsbLLtoWCS(size, pValue, bufferSize));

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmactn.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmactn.cpp

Abstract:

    This component represents the actions that can be performed by a policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"

#ifndef _HSMACTN_
#define _HSMACTN_


// Abstract Classes

/*++

Class Name:
    
    CHsmAction

Class Description:

    An abstract class that represents an action that can be performed
    upon an FsaScanItem. Specific actions are implemented as subclasses
    of this object.

--*/

class CHsmAction : 
    public CWsbObject,
    public IHsmAction
{
public:

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IHsmAction
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

protected:
    ULONG       m_nameId;
};



/*++

Class Name:
    
    CHsmDirectedAction

Class Description:

    An abstract class that represents an action that can be performed
    upon an FsaScanItem that is directed towards a particular storage pool.

--*/

class CHsmDirectedAction : 
    public CHsmAction,
    public IHsmDirectedAction
{
public:
// CComObjectRoot
    STDMETHOD(FinalConstruct)(void);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IHsmDirectedAction
public:
    STDMETHOD(GetStoragePoolId)(GUID* pId);
    STDMETHOD(SetStoragePoolId)(GUID id);

protected:
    GUID    m_storagePoolId;
};

    
/*++

Class Name:
    
    CHsmRelocateAction

Class Description:

    An abstract class that represents an action that can be performed
    upon an FsaScanItem that relocates the item to a particular path.

--*/

class CHsmRelocateAction : 
    public CHsmAction,
    public IHsmRelocateAction
{
public:
// CComObjectRoot
    STDMETHOD(FinalConstruct)(void);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

public:
// IHsmRelocateAction
    STDMETHOD(ExpandPlaceholders)(void);
    STDMETHOD(GetDestination)(OLECHAR** pDest, ULONG bufferSize);
    STDMETHOD(RetainHierarchy)(void);
    STDMETHOD(SetDestination)(OLECHAR* dest);
    STDMETHOD(SetExpandPlaceholders)(BOOL expandPlaceholders);
    STDMETHOD(SetRetainHierarchy)(BOOL retainHierarchy);

protected:
    CWsbStringPtr   m_dest;
    BOOL            m_expandPlaceholders;
    BOOL            m_retainHierarchy;
};


// Concrete Classes : Inheriting from CHsmAction

/*++

Class Name:
    
    CHsmActionDelete

Class Description:

    A class that represents the action of deleting a scan item.

--*/

class CHsmActionDelete :    
    public CHsmAction,
    public CComCoClass<CHsmActionDelete,&CLSID_CHsmActionDelete>
{
public:
    CHsmActionDelete() {}
BEGIN_COM_MAP(CHsmActionDelete)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionDelete)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


/*++

Class Name:
    
    CHsmActionRecall

Class Description:

    A class that represents the action of recalling an item from
    secondary storage.

--*/

class CHsmActionRecall :    
    public CHsmAction,
    public CComCoClass<CHsmActionRecall,&CLSID_CHsmActionRecall>
{
public:
    CHsmActionRecall() {}
BEGIN_COM_MAP(CHsmActionRecall)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionRecall)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};

    
/*++

Class Name:
    
    CHsmActionRecycle

Class Description:

    A class that represents the action of recycling an item to the recycle
    bin.

--*/

class CHsmActionRecycle :   
    public CHsmAction,
    public CComCoClass<CHsmActionRecycle,&CLSID_CHsmActionRecycle>
{
public:
    CHsmActionRecycle() {}
BEGIN_COM_MAP(CHsmActionRecycle)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionRecycle)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


/*++

Class Name:
    
    CHsmActionTruncate

Class Description:

    A class that represents the action of truncating an item into a
    placeholder.

--*/

class CHsmActionTruncate :  
    public CHsmAction,
    public CComCoClass<CHsmActionTruncate,&CLSID_CHsmActionTruncate>
{
public:
    CHsmActionTruncate() {}
BEGIN_COM_MAP(CHsmActionTruncate)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionTruncate)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


/*++

Class Name:
    
    CHsmActionUnmanage

Class Description:

    A class that represents the action of "unmanaging" an item. This
    means recalling truncated files. removing any placeholder information and
    removing the item form any premigration list.

--*/

class CHsmActionUnmanage :  
    public CHsmAction,
    public CComCoClass<CHsmActionUnmanage,&CLSID_CHsmActionUnmanage>
{
public:
    CHsmActionUnmanage() {}
BEGIN_COM_MAP(CHsmActionUnmanage)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionUnmanage)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


/*++

Class Name:
    
    CHsmActionValidate

Class Description:

    A class that represents the action of checking an item's placeholder
    information to make sure that it is still correct, and correcting or
    deleting any inaccurate information.

--*/

class CHsmActionValidate :  
    public CHsmAction,
    public CComCoClass<CHsmActionValidate,&CLSID_CHsmActionValidate>
{
public:
    CHsmActionValidate() {}
BEGIN_COM_MAP(CHsmActionValidate)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionValidate)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};

    
// Concrete Classes : Inheriting from CHsmDirectedAction

/*++

Class Name:
    
    CHsmActionMigrate

Class Description:

    A class that represents the action of copying the migratable portion
    of an item to secondary storage and then truncating it.

--*/

class CHsmActionMigrate :   
    public CHsmDirectedAction,
    public CComCoClass<CHsmActionMigrate,&CLSID_CHsmActionMigrate>
{
public:
    CHsmActionMigrate() {}
BEGIN_COM_MAP(CHsmActionMigrate)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IHsmDirectedAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionMigrate)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


/*++

Class Name:
    
    CHsmActionManage

Class Description:

  A class that represents the action of copying the migratable portion of
  an item to secondary storage and then adding the item to the
  premigration list. This action is also known as the premigration action.

--*/

class CHsmActionManage :    
    public CHsmDirectedAction,
    public CComCoClass<CHsmActionManage,&CLSID_CHsmActionManage>
{
public:
    CHsmActionManage() {}
BEGIN_COM_MAP(CHsmActionManage)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IHsmDirectedAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionManage)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


// Concrete Classes : Inheriting from CHsmRelocateAction

/*++

Class Name:
    
    CHsmActionCopy

Class Description:

    A class that represents the action of copying item to another location.

--*/

class CHsmActionCopy :  
    public CHsmRelocateAction,
    public CComCoClass<CHsmActionCopy,&CLSID_CHsmActionCopy>
{
public:
    CHsmActionCopy() {}
BEGIN_COM_MAP(CHsmActionCopy)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IHsmRelocateAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionCopy)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};

    
/*++

Class Name:
    
    CHsmActionMove

Class Description:

    A class that represents the action of moving an item to another location
    (i.e. copy and delete).

--*/

class CHsmActionMove :  
    public CHsmRelocateAction,
    public CComCoClass<CHsmActionMove,&CLSID_CHsmActionMove>
{
public:
    CHsmActionMove() {}
BEGIN_COM_MAP(CHsmActionMove)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IHsmRelocateAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionMove)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};

#endif // _HSMACTN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmjob.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjob.cpp

Abstract:

    This class contains represents a job that can be performed by the HSM
    system.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "task.h"
#include "engine.h"
#include "HsmConn.h"
#include "hsmjob.h"


#define JOB_PARAMETER_MAX_ACTIVE_JOB    OLESTR("MaximumNumberOfActiveJobs")
#define MAX_ACTIVE_JOBS_DEFAULT         10

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCountJob = 0;  // Count of existing objects


HRESULT
CHsmJob::AdviseOfSessionState(
    IN IHsmSession* pSession,
    IN IHsmPhase* pPhase,
    IN OLECHAR* currentPath
    )

/*++

Implements:

  IHsmJobPriv::AdviseOfSessionState().

--*/
{
    HRESULT                             hr = S_OK;
    CONNECTDATA                         pConnectData;
    CComPtr<IConnectionPoint>           pCP;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IEnumConnections>           pConnection;
    CComPtr<IHsmJobSinkEverySession>    pSink;

    try {

        WsbAssert(0 != pSession, E_UNEXPECTED);

        // Tell everyone the new state of the session.
        WsbAffirmHr(((IUnknown*)(IHsmJob*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmJobSinkEverySession, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmJobSinkEverySession, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessJobSession(pSession, pPhase, currentPath));
            } WsbCatchAndDo(hr, hr = S_OK;);

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::Cancel(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmJob::Cancel().

--*/
{
    HRESULT                             hr = S_OK;
    HRESULT                             hr2;
    CComPtr<IHsmJobWorkItemPriv>        pWorkItem;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IWsbEnum>                   pEnum;

    WsbTraceIn(OLESTR("CHsmJob::Cancel"), OLESTR("Phase = <%d>"), phase);
    try {
        m_state = HSM_JOB_STATE_CANCELLING;
        WsbLogEvent(JOB_MESSAGE_JOB_CANCELLING, 0, NULL, (OLECHAR*) m_name, NULL);

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Tell all the session we have to cancel the phase(s).
        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetSession(&pSession));
            
            if (pSession != 0) {
                WsbAffirmHr(pSession->Cancel(phase));

                // If we are quiting the entire job, we need to cleanup in case
                // the session refuses to terminate properly (i.e. one of the
                // subordinates to the session is out to lunch).
                if (phase == HSM_JOB_PHASE_ALL) {

                    WsbTrace(OLESTR("CHsmJob::Cancel - Cancelling all.\n"));
                    m_isTerminating = TRUE;
                    // Fake the work item into thinking that the session completed, since we
                    // don't want to rely upon it completing normally
                    try {
                        CComPtr<IHsmPhase>                      pPhase;
                        CComPtr<IHsmPhasePriv>                  pPhasePriv;
                        CComPtr<IHsmSessionSinkEveryState>      pSink;

                        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
                        WsbAffirmHr(pPhasePriv->SetPhase(HSM_JOB_PHASE_ALL));
                        WsbAffirmHr(pPhasePriv->SetState(HSM_JOB_STATE_CANCELLED));
                        WsbAffirmHr(pPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pPhase));
                        WsbAffirmHr(pWorkItem->QueryInterface(IID_IHsmSessionSinkEveryState, (void**) &pSink));
                        WsbAffirmHr(pSink->ProcessSessionState(pSession, pPhase, OLESTR("")));
                    } WsbCatchAndDo(hr2, pSession->ProcessHr(phase, __FILE__, __LINE__, hr2););
                }
                pSession = 0;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

        m_state = HSM_JOB_STATE_CANCELLED;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmJob::CheckResourceNotInUse(
    IN GUID resid
    )

/*++

Routine Description:

    Determines if another job is using this resource or if too many jobs
    are already active.

Arguments:

    resid - Id of the resource in question.

Return Value:

    S_OK    - Resource is not in use.

    S_FALSE - Resource is in use.

    E_*     - An error occurred.

--*/
{
    HRESULT                        hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::CheckResourceNotInUse"), 
            OLESTR("resource id = <%ls>"), WsbGuidAsString(resid));
    try {
        ULONG                          nJobs;
        ULONG                          nJobsActive = 0;
        CComPtr<IHsmServer>            pHsmServer;
        CComPtr<IWsbIndexedCollection> pJobs;

        // Get list of jobs
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pHsmServer));
        WsbAffirmHr(pHsmServer->GetJobs(&pJobs));

        // Loop over jobs
        WsbAffirmHr(pJobs->GetEntries(&nJobs));
        for (ULONG i = 0; i < nJobs; i++) {
            CWsbStringPtr                  JobName;
            GUID                           l_guid;
            CComPtr<IHsmJob>               pJob;
            CComPtr<IHsmJobWorkItemPriv>   pWorkItem;
            CComPtr<IWsbEnum>              pEnum;
            HRESULT                        hrEnum;
            HSM_JOB_STATE                  state;

            pJob = 0;
            WsbAffirmHr(pJobs->At(i, IID_IHsmJob, (void**) &pJob));

            // Ignore this job if it's not active
            if (S_OK == pJob->GetName(&JobName, 0)) {
                WsbTrace(OLESTR("CHsmJob::CheckResourceNotInUse: job <%ls>\n"),
                        static_cast<OLECHAR*>(JobName));
                JobName.Free();
            }
            hr = pJob->IsActive();
            if (S_FALSE == hr) {
                hr = S_OK;
                continue;
            } else {
                WsbAffirmHr(hr);
            }

            // Ignore this job if it's suspended
            WsbAffirmHr(pJob->GetState(&state));
            if ((HSM_JOB_STATE_SUSPENDED == state) || (HSM_JOB_STATE_SUSPENDING == state)) {
                continue;
            }

            nJobsActive++;

            // The job is active, check against all of its active work items
            WsbAffirmHr(pJob->EnumWorkItems(&pEnum));
            for (hrEnum = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                 (hrEnum == S_OK);
                 hrEnum = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

                hr = pWorkItem->IsActiveItem();
                if (S_FALSE == hr) {
                    // work item is not active at all, skip it...
                    hr = S_OK;
                    pWorkItem = 0;
                    continue;
                } else {
                    WsbAffirmHr(hr);
                }

                // Get the resource (volume) id that the active work item is using
                // (or wants to use)
                WsbAffirmHr(pWorkItem->GetResourceId(&l_guid));
                WsbTrace(OLESTR("CHsmJob:: l_guid = <%ls>\n"), WsbGuidAsString(l_guid));
                if (l_guid == resid) {
                    WsbTrace(OLESTR("CHsmJob::CheckResourceNotInUse: resource in use\n"));
                    hr = S_FALSE;
                    break;
                }
                pWorkItem = 0;

            }
            pEnum = 0;

            if (hr == S_FALSE) {
                // resource in use, no need to continue enumerating jobs
                break;
            }

        }

        // Limit the number of active jobs
        WsbTrace(OLESTR("CHsmJob::CheckResourceNotInUse: total jobs = %lu, active jobs = %lu\n"),
                nJobs, nJobsActive);
        DWORD   size;
        OLECHAR tmpString[256];
        DWORD   maxJobs = MAX_ACTIVE_JOBS_DEFAULT;
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, JOB_PARAMETER_MAX_ACTIVE_JOB, tmpString, 256, &size))) {
            maxJobs = wcstol(tmpString, NULL, 10);
            if (0 == maxJobs) {
                // Illegal value, get back to default
                maxJobs = MAX_ACTIVE_JOBS_DEFAULT;
            }
        }
        WsbTrace(OLESTR("CHsmJob::CheckResourceNotInUse: max active jobs = %lu\n"), maxJobs);
        if (nJobsActive >= maxJobs) {
            WsbTrace(OLESTR("CHsmJob::CheckResourceNotInUse: too many active jobs\n"),
                    nJobsActive);
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::CheckResourceNotInUse"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmJob::DidFinish(
    void
    )

/*++

Implements:

  IHsmJob::DidFinish().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmJobWorkItem>    pWorkItem;
    CComPtr<IWsbEnum>           pEnum;
    HSM_JOB_STATE               state;

    try {

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // If any of the items aren't done then the work wasn't finished. This means
        // that we would want to try again on failed items.
        for (hr = pEnum->First(IID_IHsmJobWorkItem, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItem, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetState(&state));

            if ((HSM_JOB_STATE_DONE != state) && (HSM_JOB_STATE_SKIPPED != state) && (HSM_JOB_STATE_FAILED != state)) {
                hr = S_FALSE;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);


    return(hr);
}



HRESULT
CHsmJob::DidFinishOk(
    void
    )

/*++

Implements:

  IHsmJob::DidFinishOk().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmJobWorkItem>    pWorkItem;
    CComPtr<IWsbEnum>           pEnum;
    HSM_JOB_STATE               state;

    try {

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // If any of the items aren't done then the work wasn't finished. This means
        // that we would want to try again on failed items.
        for (hr = pEnum->First(IID_IHsmJobWorkItem, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItem, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetState(&state));

            if ((HSM_JOB_STATE_DONE != state) && (HSM_JOB_STATE_SKIPPED != state)) {
                hr = S_FALSE;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);


    return(hr);
}


HRESULT
CHsmJob::Do(
    void
    )

/*++

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;
    CComPtr<IFsaResource>               pResource;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IHsmSessionSinkEveryState>  pSink;
    CComPtr<IHsmJobWorkItemPriv>        pWorkItem;
    CComPtr<IHsmJobWorkItem>            pWorkItemScan;
    CComPtr<IWsbEnum>                   pEnum;
    CComPtr<IHsmServer>                 pHsmServer;
    HSM_JOB_STATE                       state;
    GUID                                managingHsm;
    ULONG                               i = 0;
    FILETIME                            fileTime;
    CWsbStringPtr                       startingPath;
    DWORD                               cookie;
    ULONG                               maxActiveSessions;
    CWsbStringPtr                       resourceName;
    GUID                                ResourceId = GUID_NULL;
    

    WsbTraceIn(OLESTR("CHsmJob::Do"), OLESTR(""));
    try {

        WsbAssert(m_pContext != 0, E_UNEXPECTED);

        // Check if jobs are disabled
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pHsmServer));
        hr = pHsmServer->AreJobsEnabled();
        if (S_FALSE == hr) {
            // Jobs are disabled; suspend the job
            WsbAffirmHr(Suspend(HSM_JOB_PHASE_ALL));
            WsbThrow(hr);
        } else {
            WsbAffirmHr(hr);
        }

        // The job will enumerate over the work list.
        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Go through the list of work items and start a session for anything that needs
        // work up to the limit of the number of sessions that can be active at one time.
        WsbAffirmHr(GetMaxActiveSessions(&maxActiveSessions));

        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             SUCCEEDED(hr) && (m_activeSessions < maxActiveSessions);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            // If we should do this item, then find it's resource.
            WsbAffirmHr(pWorkItem->GetState(&state));

            // Only do work for items that are currently idle.
            if (HSM_JOB_STATE_IDLE == state) {

                // Check if the required resource is in use by another job
                WsbAffirmHr(pWorkItem->GetResourceId(&ResourceId));
                hr = CheckResourceNotInUse(ResourceId);
                if (S_FALSE == hr) {
                    // Resource is not available; suspend the job
                    WsbAffirmHr(Suspend(HSM_JOB_PHASE_ALL));
                    break;
                } else {
                    WsbAffirmHr(hr);
                }

                // Indicate that we are trying to start a session. This prevents us from trying
                // again.
                WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_STARTING));

                try {

                    fileTime.dwHighDateTime = 0;
                    fileTime.dwLowDateTime = 0;
                    WsbAffirmHr(pWorkItem->SetFinishTime(fileTime));
                    WsbAffirmHr(CoFileTimeNow(&fileTime));
                    WsbAffirmHr(pWorkItem->SetStartTime(fileTime));

                    WsbTrace(OLESTR("CHsmJob::Do, resource id = %ls\n"),
                            WsbGuidAsString(ResourceId));
                    WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, 
                            ResourceId, IID_IFsaResource, (void**) &pResource));
                    //
                    // Get the resource name for event logging
                    try  {
                        WsbAffirmHr(pResource->GetName(&resourceName, 0));
                        WsbTrace(OLESTR("CHsmJob::Do, resource name = <%ls>\n"), resourceName);
                    } WsbCatch( hr );
                    
                
                    // We will only do jobs that come from the managing HSM.
                    WsbAffirmHr(pResource->GetManagingHsm(&managingHsm));
                    if (!IsEqualGUID(managingHsm, m_hsmId))  {
                        WsbTrace(OLESTR("CHsmJob::Do, HSM of resource = %ls\n"),
                                WsbGuidAsString(managingHsm));
                        WsbTrace(OLESTR("CHsmJob::Do, HSM of job = %ls\n"),
                                WsbGuidAsString(m_hsmId));
                         hr = JOB_E_NOTMANAGINGHSM;
                        WsbLogEvent(JOB_MESSAGE_JOB_FAILED_NOTMANAGINGHSM, 0, NULL, (OLECHAR*) m_name, (OLECHAR *)resourceName, WsbHrAsString(hr),NULL);
                    WsbThrow(hr);
                    }
                    m_state = HSM_JOB_STATE_ACTIVE;

                    // Set job item as active (started)
                    WsbAffirmHr(pWorkItem->SetActiveItem(TRUE));

                    // Do the pre-scan action if it exists
                    WsbAffirmHr(pWorkItem->QueryInterface(IID_IHsmJobWorkItem,
                            (void**)&pWorkItemScan));
                    WsbAffirmHr(pWorkItemScan->DoPreScan());

                    // Create a session (owned by the resource) that will do the scan of this
                    // resource.
                    i++;
                    WsbAffirmHr(pResource->StartJobSession((IHsmJob*) this, i, &pSession));
                    
                    // Ask the session to advise of every state changes.
                    WsbAffirmHr(pWorkItem->QueryInterface(IID_IHsmSessionSinkEveryState, (void**) &pSink));
                    WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
                    WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
                    WsbAffirmHr(pCP->Advise(pSink, &cookie));

                    // Now start the scanner of the resource
                    WsbAffirmHr(pWorkItem->GetStartingPath(&startingPath, 0));
                    WsbAffirmHr(pResource->StartJob(startingPath, pSession));

                    // Increment the count of active sessions.
                    m_activeSessions++;

                    // Update the information in the work list.
                    WsbAffirmHr(pWorkItem->SetSession(pSession));
                    WsbAffirmHr(pWorkItem->SetCookie(cookie));

                } WsbCatchAndDo(hr, pWorkItem->SetState(HSM_JOB_STATE_FAILED);
                        WsbLogEvent(JOB_MESSAGE_JOB_FAILED, 0, NULL, (OLECHAR*) m_name, (OLECHAR *) resourceName, WsbHrAsString(hr), NULL);
                );

                pCP = 0;
                pCPC = 0;
                pSession = 0;
                pResource = 0;
                pSink = 0;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;

            // If we got to the end of the list and no session are active, then we are done.
            if (m_activeSessions == 0) {
                m_isActive = FALSE;
                m_state = HSM_JOB_STATE_IDLE;
                WsbLogEvent(JOB_MESSAGE_JOB_COMPLETED, 0, NULL, (OLECHAR*) m_name, NULL);
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Do"), OLESTR("hr = <%ls>, isActive = <%ls>, activeSessions = <%lu>"),
        WsbHrAsString(hr), WsbBoolAsString(m_isActive), m_activeSessions);
    return(hr);
}


HRESULT
CHsmJob::DoNext(
    void
    )

/*++

Implements:

  IHsmJobPriv::DoNext().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::DoNext"), OLESTR("Active sessions = <%lu>, Terminating = <%ls>"),
                m_activeSessions, WsbBoolAsString(m_isTerminating));
    try {

        // Decrement the count of active sessions.
        if (m_activeSessions > 0)  {
            m_activeSessions--;
        
            // If we are not terminating look for more work
            if (FALSE == m_isTerminating)  {
                // See if there is anthing else to do.
                WsbAffirmHr(Do());
            } else  {
                m_isActive = FALSE;
                m_state = HSM_JOB_STATE_IDLE;
            }
        } else  {
            m_isActive = FALSE;
            m_state = HSM_JOB_STATE_IDLE;
        }
        
        // If we are done with the work, make sure we
        // clear the terminating flag
        if (0 == m_activeSessions)  {
            m_isTerminating = FALSE;
        }

        // Restart other jobs that may be suspended
        WsbAffirmHr(RestartSuspendedJobs());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::DoNext"), OLESTR("hr = <%ls>, isActive = <%ls>, activeSessions = <%lu>"),
        WsbHrAsString(hr), WsbBoolAsString(m_isActive), m_activeSessions);
    return(hr);
}


HRESULT
CHsmJob::EnumWorkItems(
    IN IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmJob::EnumWorkItems().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pWorkItems->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    WsbTraceIn(OLESTR("CHsmJob::FinalConstruct"),OLESTR(""));
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_state = HSM_JOB_STATE_IDLE;
        m_hsmId = GUID_NULL;
        m_isUserDefined = FALSE;
        m_activeSessions = 0;
        m_runId = 0;
        m_isActive = FALSE;
        m_isTerminating = FALSE;

        // Each instance should have its own unique identifier.
        WsbAffirmHr(CoCreateGuid(&m_id));

        // Create the work list collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pWorkItems));

    } WsbCatch(hr);

    iCountJob++;
    WsbTraceOut(OLESTR("CHsmJob::FinalConstruct"), OLESTR("Count is <%d>"), iCountJob);

    return(hr);
}
void
CHsmJob::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    WsbTraceIn(OLESTR("CHsmJob::FinalRelease"),OLESTR(""));

    // Let the parent class do his thing.   
    CWsbObject::FinalRelease();

    iCountJob--;
    WsbTraceOut(OLESTR("CHsmJob::FinalRelease"), OLESTR("Count is <%d>"), iCountJob);
}


HRESULT
CHsmJob::FindWorkItem(
    IN IHsmSession* pSession,
    OUT IHsmJobWorkItem** ppWorkItem
    )

/*++

Implements:

  IHsmJob::FindWorkItem().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSession>        pItemSession;
    CComPtr<IHsmJobWorkItem>    pWorkItem;
    CComPtr<IWsbEnum>           pEnum;
    GUID                        id;
    GUID                        id2;

    try {

        WsbAssert(0 != ppWorkItem, E_POINTER);

        // The job will enumerate over the work list.
        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Go through the list of work items and see if we have one with this session interface.
        *ppWorkItem = 0;
        WsbAffirmHr(pSession->GetIdentifier(&id));

        hr = pEnum->First(IID_IHsmJobWorkItem, (void**) &pWorkItem);

        while (SUCCEEDED(hr) && (*ppWorkItem == 0)) {


            // NOTE: Pointer comparisson is probably not going to work, since DCOM may change
            // the value of the pointer. We could cache the sessionId in the workItem to
            // make the loop a little faster, but it doesn't seem like a big performance issue.
            WsbAffirmHr(pWorkItem->GetSession(&pItemSession));

            if (pItemSession != 0) {

                WsbAffirmHr(pItemSession->GetIdentifier(&id2));

                if (memcmp(&id, &id2, sizeof(GUID)) == 0) {
                    *ppWorkItem = pWorkItem;
                    pWorkItem.p->AddRef();
                } else {
                    pWorkItem = 0;
                    pItemSession = 0;
                    hr = pEnum->Next(IID_IHsmJobWorkItem, (void**) &pWorkItem);
                }
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmJob;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmJob::GetContext(
    OUT IHsmJobContext** ppContext
    )

/*++

Implements:

  IHsmJob::GetContext().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != ppContext, E_POINTER);
        *ppContext = m_pContext;
        if (m_pContext != 0)  {
            m_pContext.p->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetDef(
    OUT IHsmJobDef** ppDef
    )

/*++

Implements:

  IHsmJob::GetDef().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != ppDef, E_POINTER);
        *ppDef = m_pDef;
        if (m_pDef != 0)  {
            m_pDef.p->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IHsmJob::GetIdentifier().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetHsmId(
    OUT GUID* pId
    )

/*++

Implements:

  IHsmJob::GetHsmId().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_hsmId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetMaxActiveSessions(
    OUT ULONG* pMaxActiveSessions
    )

/*++

Implements:

  IHsmJob::GetMaxActiveSessions().

--*/
{
    HRESULT                     hr = S_OK;

    try {
        CComPtr<IHsmServer>            pHsmServer;

        WsbAssert(0 != pMaxActiveSessions, E_POINTER);

        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pHsmServer));

        // Currently, the only job with more than one item is the default Copy Files job.
        //  Therefore, the limit is set according to the Copy Files limit
        WsbAffirmHr(pHsmServer->GetCopyFilesLimit(pMaxActiveSessions));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmJob::GetName().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetRunId(
    OUT ULONG* pRunId
    )

/*++

Implements:

  IHsmJob::GetRunId().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pRunId, E_POINTER);
        *pRunId = m_runId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    ULARGE_INTEGER              entrySize;

    WsbTraceIn(OLESTR("CHsmJob::GetSizeMax"), OLESTR(""));

    try {

        pSize->QuadPart = 2 * WsbPersistSizeOf(GUID) + 3 * WsbPersistSizeOf(BOOL) + 2 * WsbPersistSizeOf(ULONG) + WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR));

        if (m_pContext != 0) {
            WsbAffirmHr(m_pContext->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
            pPersistStream = 0;
            pSize->QuadPart += entrySize.QuadPart;
        }

        if (m_pDef != 0) {
            WsbAffirmHr(m_pDef->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
            pPersistStream = 0;
            pSize->QuadPart += entrySize.QuadPart;
        }

        WsbAffirmHr(m_pWorkItems->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pPersistStream = 0;
        pSize->QuadPart += entrySize.QuadPart;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmJob::GetState(
    OUT HSM_JOB_STATE* pState
    )
/*++

Implements:

  IHsmJob::GetState().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pState, E_POINTER);
        *pState = m_state;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::InitAs(
    IN OLECHAR* name,
    IN IHsmJobDef* pDef,
    IN HSM_JOB_DEF_TYPE type,
    IN GUID storagePool,
    IN IHsmServer* pServer,
    IN BOOL isUserDefined,
    IN IFsaResource* pResource
    )
                                                     
/*++

Implements:

  IHsmJob::InitAs().

--*/
{
    HRESULT                         hr = S_OK;
    GUID                            id;
    GUID                            hsmId;
    CComPtr<IHsmJobContext>         pContext;
    CComPtr<IWsbGuid>               pGuid;
    CComPtr<IWsbCollection>         pCollection;
    CComPtr<IWsbCreateLocalObject>  pCreateObj;

    try {

        WsbAssert(0 != pServer, E_POINTER);
        WsbAssert(0 != name, E_POINTER);

        // All objects created need to be owned by the engine, and also get some
        // information about the engine.
        WsbAssertHr(pServer->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
        WsbAssertHr(pServer->GetID(&hsmId));

        // If a definition was provided we use that one; otherwise, a new one is created.
        if (0 != pDef) {
            m_pDef = pDef;  
        } else {
            m_pDef = 0;
            WsbAssertHr(pCreateObj->CreateInstance(CLSID_CHsmJobDef, IID_IHsmJobDef, (void**) &m_pDef));
            WsbAffirmHr(m_pDef->InitAs(name, type, storagePool, pServer, isUserDefined));
        }

        // Create a job context, fill it out, and then add it to the job.
        WsbAssertHr(pCreateObj->CreateInstance(CLSID_CHsmJobContext, IID_IHsmJobContext, (void**) &pContext));

        // If a specific resource is target, then set up the context appropriately.
        if (0 != pResource) {
            WsbAssertHr(pContext->SetUsesAllManaged(FALSE));
            WsbAssertHr(pCreateObj->CreateInstance(CLSID_CWsbGuid, IID_IWsbGuid, (void**) &pGuid));
            WsbAssertHr(pContext->Resources(&pCollection));
            WsbAssertHr(pResource->GetIdentifier(&id));
            WsbAssertHr(pGuid->SetGuid(id));
            WsbAssertHr(pCollection->Add(pGuid));
        } else {
            WsbAssertHr(pContext->SetUsesAllManaged(TRUE));
        }

        m_pContext = pContext;

        // There are a couple of other fields to fill out in the job.
        m_hsmId = hsmId;
        m_isUserDefined = isUserDefined;
        m_name = name;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::IsActive(
    void
    )

/*++

Implements:

  IHsmJob::IsActive().

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CHsmJob::IsActive"), OLESTR(""));
    
    hr = (m_isActive ? S_OK : S_FALSE);
    
    WsbTraceOut(OLESTR("CHsmJob::IsActive"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}


HRESULT
CHsmJob::IsUserDefined(
    void
    )

/*++

Implements:

  IHsmJob::IsUserDefined().

--*/
{
    return(m_isUserDefined ? S_OK : S_FALSE);
}


HRESULT
CHsmJob::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IPersistStream>         pPersistStream;
    BOOL                            hasA;
    CComPtr<IHsmJobWorkItemPriv>    pWorkItem;
    CComPtr<IWsbEnum>               pEnum;
    CComPtr<IWsbCreateLocalObject>  pCreateObj;

    WsbTraceIn(OLESTR("CHsmJob::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbLoadFromStream(pStream, &m_hsmId);
        WsbLoadFromStream(pStream, &m_id);
        WsbLoadFromStream(pStream, &m_isUserDefined);
        WsbLoadFromStream(pStream, &m_runId);
        WsbLoadFromStream(pStream, &m_name, 0);

        WsbAffirm(memcmp(&GUID_NULL, &m_hsmId, sizeof(GUID)) != 0, JOB_E_NOTMANAGINGHSM);
#if 0        
        CComPtr<IHsmServer>             pServer;
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pServer));
        WsbAssertHr(pServer->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
#endif
        WsbLoadFromStream(pStream, &hasA);
        if (hasA) {
            m_pContext = 0;
//          WsbAssertHr(pCreateObj->CreateInstance(CLSID_CHsmJobContext, IID_IHsmJobContext, (void**) &m_pContext));
            WsbAssertHr(CoCreateInstance(CLSID_CHsmJobContext, NULL, CLSCTX_SERVER, IID_IHsmJobContext, (void**) &m_pContext));
            WsbAffirmHr(m_pContext->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->Load(pStream));
            pPersistStream = 0;
        }

        WsbLoadFromStream(pStream, &hasA);
        if (hasA) {
            m_pDef = 0;
//          WsbAssertHr(pCreateObj->CreateInstance(CLSID_CHsmJobDef, IID_IHsmJobDef, (void**) &m_pDef));
            WsbAssertHr(CoCreateInstance(CLSID_CHsmJobDef, NULL, CLSCTX_SERVER, IID_IHsmJobDef, (void**) &m_pDef));
            WsbAffirmHr(m_pDef->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->Load(pStream));
            pPersistStream = 0;
        }

        WsbAffirmHr(m_pWorkItems->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        
        pPersistStream = 0;

        // Tie the work items to the job.
        WsbAffirmHr(EnumWorkItems(&pEnum));
        hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);

        while (SUCCEEDED(hr)) {
            WsbAffirmHr(pWorkItem->Init((IHsmJob*) this));
            pWorkItem = 0;
            
            hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJob::Pause(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmJob::Pause().

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IHsmJobWorkItemPriv>        pWorkItem;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IWsbEnum>                   pEnum;

    try {

        WsbLogEvent(JOB_MESSAGE_JOB_PAUSING, 0, NULL, (OLECHAR*) m_name, NULL);

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Tell all the session we have to resume the phase(s).
        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetSession(&pSession));

            if (pSession != 0) {
                WsbAffirmHr(pSession->Pause(phase));

                if (phase == HSM_JOB_PHASE_ALL) {
                    WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_PAUSING));
                }

                pSession = 0;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::Restart(
    void
    )

/*++

Implements:

  IHsmJob::Restart().

Note:

  If a job is suspended, it is restarted from where it was otherwise it is
  restarted from the beginning.  This is controlled by the parameter to
  UpdateWorkItems.

--*/
{
    HRESULT                             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::Restart"), OLESTR(""));

    try {
        BOOL RestartFromBeginning = TRUE;

        if (m_state == HSM_JOB_STATE_SUSPENDED) {
            // Verify that none of the active work items (i.e. items that were active when
            // the job was suspended) uses a volume that is in use now by another active job
            CComPtr<IHsmJobWorkItemPriv>   pWorkItem;
            CComPtr<IWsbEnum>              pEnum;
            GUID                           ResourceId;
            HRESULT                        hrEnum;

            WsbAffirmHr(EnumWorkItems(&pEnum));
            for (hrEnum = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                 (hrEnum == S_OK);
                 hrEnum = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

                hr = pWorkItem->IsActiveItem();
                if (S_FALSE == hr) {
                    // work item is not active at all, skip it...
                    hr = S_OK;
                    pWorkItem = 0;
                    continue;
                } else {
                    WsbAffirmHr(hr);
                }       

                // check specific active item 
                WsbAffirmHr(pWorkItem->GetResourceId(&ResourceId));

                WsbTrace(OLESTR("CHsmJob::Restart: ResourceId = <%ls>\n"), WsbGuidAsString(ResourceId));
                hr = CheckResourceNotInUse(ResourceId);
                if (S_OK != hr) {
                    WsbThrow(hr);
                }

                pWorkItem = 0;
            }
            RestartFromBeginning = FALSE;

        } else {
            WsbAssert(!m_isActive, JOB_E_ALREADYACTIVE);
        }

        m_state = HSM_JOB_STATE_STARTING;
        m_isActive = TRUE;

        WsbLogEvent(JOB_MESSAGE_JOB_RESTARTING, 0, NULL, (OLECHAR*) m_name, NULL);

        // Make sure that information in the work list is up to date.
        WsbAffirmHr(UpdateWorkItems(RestartFromBeginning));

        // Start any sessions that need starting.
        WsbAffirmHr(Do());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Restart"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJob::RestartSuspendedJobs(
    void
    )

/*++

Routine Description:

    Restart suspended jobs (Implementation moved to Engine server...).

Arguments:

    None.

Return Value:

    S_OK    - Resource is not in use.

    E_*     - An error occurred.

--*/
{
    HRESULT                        hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::RestartSuspendedJobs"), OLESTR(""));
    try {
        CComPtr<IHsmServer>            pHsmServer;

        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pHsmServer));
        WsbAffirmHr(pHsmServer->RestartSuspendedJobs());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::RestartSuspendedJobs"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmJob::Resume(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmJob::Resume().

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IHsmJobWorkItemPriv>        pWorkItem;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IWsbEnum>                   pEnum;

    try {

        WsbLogEvent(JOB_MESSAGE_JOB_RESUMING, 0, NULL, (OLECHAR*) m_name, NULL);

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Tell all the session we have to resume the phase(s).
        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetSession(&pSession));

            if (pSession != 0) {
                WsbAffirmHr(pSession->Resume(phase));

                if (phase == HSM_JOB_PHASE_ALL) {
                    WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_RESUMING));
                }

                pSession = 0;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    BOOL                        hasA;

    WsbTraceIn(OLESTR("CHsmJob::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbSaveToStream(pStream, m_hsmId);
        WsbSaveToStream(pStream, m_id);
        WsbSaveToStream(pStream, m_isUserDefined);
        WsbSaveToStream(pStream, m_runId);
        WsbSaveToStream(pStream, m_name);

        if (m_pContext != 0) {
            hasA = TRUE;
            WsbSaveToStream(pStream, hasA);
            WsbAffirmHr(m_pContext->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
            pPersistStream = 0;
        } else {
            hasA = FALSE;
            WsbSaveToStream(pStream, hasA);
        }

        if (m_pDef != 0) {
            hasA = TRUE;
            WsbSaveToStream(pStream, hasA);
            WsbAffirmHr(m_pDef->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
            pPersistStream = 0;
        } else {
            hasA = FALSE;
            WsbSaveToStream(pStream, hasA);
        }

        WsbAffirmHr(m_pWorkItems->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJob::SetContext(
    IN IHsmJobContext* pContext
    )

/*++

Implements:

  IHsmJob::SetContext().

--*/
{
    m_pContext = pContext;

    return(S_OK);
}


HRESULT
CHsmJob::SetDef(
    IN IHsmJobDef* pDef
    )

/*++

Implements:

  IHsmJob::SetDef().

--*/
{
    m_pDef = pDef;

    return(S_OK);
}


HRESULT
CHsmJob::SetHsmId(
    IN GUID id
    )

/*++

Implements:

  IHsmJob::SetHsmId().

--*/
{
    m_hsmId = id;

    return(S_OK);
}


HRESULT
CHsmJob::SetIsUserDefined(
    IN BOOL isUserDefined
    )

/*++

Implements:

  IHsmJob::SetIsUserDefined().

--*/
{
    m_isUserDefined = isUserDefined;

    return(S_OK);
}


HRESULT
CHsmJob::SetName(
    IN OLECHAR* name
    )

/*++

Implements:

  IHsmJob::SetName().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        m_name = name;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::Start(
    void
    )

/*++

Implements:

  IHsmJob::Start().

--*/
{
    HRESULT                             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::Start"), OLESTR(""));

    try {

        if (m_isActive) {
            WsbLogEvent(JOB_MESSAGE_JOB_ALREADYACTIVE, 0, NULL, (OLECHAR*) m_name, NULL);
            WsbThrow(JOB_E_ALREADYACTIVE);
        }
        m_isActive = TRUE;
        m_state = HSM_JOB_STATE_STARTING;

        WsbLogEvent(JOB_MESSAGE_JOB_STARTING, 0, NULL, (OLECHAR*) m_name, NULL);

        // Make sure that information in the work list is up to date.
        WsbAffirmHr(UpdateWorkItems(FALSE));

        // Start any sessions that need starting.
        WsbAffirmHr(Do());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Start"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJob::Suspend(
    IN HSM_JOB_PHASE    phase
    )

/*++

Implements:

  IHsmJob::Suspend().

Note:

  This module assumes that the only reason this function is called is
  because the resource needed by the job is in use by another job.
  The function RestartSuspendedJobs will restart the job when the resource
  is available.

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IHsmJobWorkItemPriv>        pWorkItem;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IWsbEnum>                   pEnum;

    WsbTraceIn(OLESTR("CHsmJob::Suspend"), OLESTR(""));

    try {

        m_state = HSM_JOB_STATE_SUSPENDING;
        WsbLogEvent(JOB_MESSAGE_JOB_SUSPENDING, 0, NULL, (OLECHAR*) m_name, NULL);

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Tell all the sessions we have to suspend the phase(s).
        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetSession(&pSession));

            if (pSession != 0) {
                WsbAffirmHr(pSession->Suspend(HSM_JOB_PHASE_ALL));

                if (phase == HSM_JOB_PHASE_ALL) {
                    WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_SUSPENDING));
                }

                pSession = 0;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }
        m_state = HSM_JOB_STATE_SUSPENDED;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Suspend"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJob::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::UpdateWorkItems(
    BOOL isRestart
    )

/*++

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IWsbEnum>               pEnum;
    CComPtr<IWsbEnum>               pEnumContext;
    CComPtr<IWsbEnum>               pEnumManaged;
    CComPtr<IWsbIndexedCollection>  pManagedResources;
    CComPtr<IHsmJobWorkItemPriv>    pWorkItem;
    CComPtr<IHsmJobWorkItemPriv>    pFoundWorkItem;
    CComPtr<IWsbGuid>               pGuid;
    CComPtr<IWsbGuid>               pFoundGuid;
    CComPtr<IHsmManagedResource>    pManagedResource;
    CComPtr<IHsmManagedResource>    pFoundResource;
    CComPtr<IHsmServer>             pHsmServer;
    CComPtr<IWsbCollection>         pCollect;
    CComPtr<IFsaResource>           pResource;
    CComPtr<IUnknown>               pUnk;
    HRESULT                         didFinish;
    CWsbStringPtr                   tmpString;
    CWsbStringPtr                   currentPath;
    HSM_JOB_STATE                   state;
    GUID                            id;

    try {

        // We can't run a job without a context and a definition.
        WsbAssert(m_pContext != 0, E_UNEXPECTED);
        WsbAssert(m_pDef != 0, E_UNEXPECTED);

        // Get an enumerator for the work list.
        WsbAffirmHr(EnumWorkItems(&pEnum));

        // First we need to remove any items from the work list that are no longer listed
        // or have been deactivated.
        if (m_pContext->UsesAllManaged() == S_OK) {

            WsbAffirm(memcmp(&GUID_NULL, &m_hsmId, sizeof(GUID)) != 0, JOB_E_NOTMANAGINGHSM);
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pHsmServer));

            WsbAffirmHr(pHsmServer->GetManagedResources(&pManagedResources));
            WsbAffirmHr(pManagedResources->Enum(&pEnumManaged));

            WsbAffirmHr(CoCreateInstance(CLSID_CHsmManagedResource, 0,  CLSCTX_ALL, IID_IHsmManagedResource, (void**) &pManagedResource));

            hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
            while (SUCCEEDED(hr)) {

                WsbAffirmHr(pWorkItem->GetResourceId(&id));
                WsbAffirmHr(pManagedResource->SetResourceId(id));

                if (pEnumManaged->Find(pManagedResource, IID_IHsmManagedResource, (void**) &pFoundResource) == WSB_E_NOTFOUND) {
                    hr = S_OK;
                    m_pWorkItems->RemoveAndRelease(pWorkItem);
                    pWorkItem = 0;
                    hr = pEnum->This(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                } else {
                    pFoundResource = 0;
                    pWorkItem = 0;
                    hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                }
            }

            pManagedResource = 0;

            if (hr == WSB_E_NOTFOUND) {
                hr = S_OK;
            }

        } else {

            WsbAffirmHr(m_pContext->EnumResources(&pEnumContext));
            WsbAffirmHr(CoCreateInstance(CLSID_CWsbGuid, 0,  CLSCTX_ALL, IID_IWsbGuid, (void**) &pGuid));

            hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
            while (SUCCEEDED(hr)) {

                WsbAffirmHr(pWorkItem->GetResourceId(&id));
                WsbAffirmHr(pGuid->SetGuid(id));

                if (pEnumContext->Find(pGuid, IID_IWsbGuid, (void**) &pFoundGuid) == WSB_E_NOTFOUND) {
                    hr = S_OK;
                    m_pWorkItems->RemoveAndRelease(pWorkItem);
                    pWorkItem = 0;
                    hr = pEnum->This(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                } else {
                    pWorkItem = 0;
                    pFoundGuid = 0;
                    hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                }
            }

            pGuid = 0;

            if (hr == WSB_E_NOTFOUND) {
                hr = S_OK;
            }
        }

        // Based on the items that remain, determine whether this is a restart or a
        // continuation.
        WsbAffirmHr(didFinish = DidFinish());
        
        if ((didFinish == S_OK) || (isRestart)) {
            isRestart = TRUE;
            m_runId++;
        }

        // Add new work items for any items that are new or reactivated.
        if (m_pContext->UsesAllManaged() == S_OK) {

            // Enumerate all the managed resources, and make sure that they are listed
            // as work items.
            WsbAffirmHr(CoCreateInstance(CLSID_CHsmJobWorkItem, 0, CLSCTX_ALL, IID_IHsmJobWorkItemPriv, (void**) &pWorkItem));

            for (hr = pEnumManaged->First(IID_IHsmManagedResource, (void**) &pManagedResource);
                 (hr == S_OK);
                 pManagedResource = 0, hr = pEnumManaged->Next(IID_IHsmManagedResource, (void**) &pManagedResource)) {

                WsbAffirmHr(pManagedResource->GetFsaResource(&pUnk));
                WsbAffirmHr(pUnk->QueryInterface(IID_IFsaResource, (void**) &pResource));
                WsbAffirmHr(pResource->GetIdentifier(&id));
                WsbAffirmHr(pWorkItem->SetResourceId(id));

                pFoundWorkItem = 0;
                if (pEnum->Find(pWorkItem, IID_IHsmJobWorkItemPriv, (void**) &pFoundWorkItem) == WSB_E_NOTFOUND) {
                    hr = S_OK;
                    WsbAffirmHr(pWorkItem->Init((IHsmJob*) this));

                    WsbAffirmHr(m_pWorkItems->Add(pWorkItem));

                    pWorkItem = 0;
                    WsbAffirmHr(CoCreateInstance(CLSID_CHsmJobWorkItem, 0,  CLSCTX_ALL, IID_IHsmJobWorkItemPriv, (void**) &pWorkItem));
                }
                
                pUnk = 0;
                pResource = 0;
            }

            if (hr == WSB_E_NOTFOUND) {
                hr = S_OK;
            }
        } else {
            
            // Enumerate all the resources in the context, and make sure that they are listed
            // as work items.

            WsbAffirmHr(CoCreateInstance(CLSID_CHsmJobWorkItem, 0, CLSCTX_ALL, IID_IHsmJobWorkItemPriv, (void**) &pWorkItem));
            for (hr = pEnumContext->First(IID_IWsbGuid, (void**) &pGuid);
                 (hr == S_OK);
                 hr = pEnumContext->Next(IID_IWsbGuid, (void**) &pGuid)) {

                WsbAffirmHr(pGuid->GetGuid(&id));
                WsbAffirmHr(pWorkItem->SetResourceId(id));

                pFoundWorkItem = 0;
                if (pEnum->Find(pWorkItem, IID_IHsmJobWorkItemPriv, (void**) &pFoundWorkItem) == WSB_E_NOTFOUND) {
                    hr = S_OK;
                    WsbAffirmHr(pWorkItem->Init((IHsmJob*) this));
                    
                    WsbAffirmHr(m_pWorkItems->Add(pWorkItem));
                    pWorkItem = 0;
                    WsbAffirmHr(CoCreateInstance(CLSID_CHsmJobWorkItem, 0,  CLSCTX_ALL, IID_IHsmJobWorkItemPriv, (void**) &pWorkItem));
                }

                pGuid = 0;
            }

            if (hr == WSB_E_NOTFOUND) {
                hr = S_OK;
            }
        }

        pWorkItem = 0;
        
        // Check each item to see if work needs to be done for it.
        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            // Resources should be skipped if they are inactive, unavailable or in need of repair. If they
            // had been skipped but are ok now, then set them back to idle.
            WsbAffirmHr(pWorkItem->GetResourceId(&id));
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, id, IID_IFsaResource, (void**) &pResource));
            
            WsbAffirmHr(pWorkItem->GetState(&state));
            
            if (pResource->IsActive() != S_OK) {
                WsbAffirmHr(pResource->GetUserFriendlyName(&tmpString, 0));
                WsbLogEvent(JOB_MESSAGE_RESOURCE_INACTIVE, 0, NULL, (OLECHAR*) tmpString, (OLECHAR*) m_name, NULL);
                WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_SKIPPED));
            } else if (pResource->IsAvailable() != S_OK) {
                WsbAffirmHr(pResource->GetUserFriendlyName(&tmpString, 0));
                WsbLogEvent(JOB_MESSAGE_RESOURCE_UNAVAILABLE, 0, NULL, (OLECHAR*) tmpString, (OLECHAR*) m_name, NULL);
                WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_SKIPPED));
            } else if (pResource->NeedsRepair() == S_OK) {
                WsbAffirmHr(pResource->GetUserFriendlyName(&tmpString, 0));
                WsbLogEvent(JOB_MESSAGE_RESOURCE_NEEDS_REPAIR, 0, NULL, (OLECHAR*) tmpString, (OLECHAR*) m_name, NULL);
                WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_SKIPPED));
            } else if (HSM_JOB_STATE_SKIPPED == state) {
                WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_IDLE));
            }

            WsbAffirmHr(pWorkItem->GetState(&state));
            
            // Don't do anything for inactive resources.
            if (HSM_JOB_STATE_SKIPPED != state) {

                if (isRestart) {

                    // On a restart, all items need work to be done for them.
                    //
                    // NOTE: A null starting path means the root.
                    WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_IDLE));
                    WsbAffirmHr(pWorkItem->SetSubRunId(0));
                    WsbAffirmHr(pWorkItem->SetStartingPath(OLESTR("\\")));
                    WsbAffirmHr(pWorkItem->SetCurrentPath(OLESTR("\\")));

                    // Clear out the phases and session totals.
                    pCollect = 0;
                    WsbAffirmHr(pWorkItem->GetPhases(&pCollect));
                    WsbAffirmHr(pCollect->RemoveAllAndRelease());

                    pCollect = 0;
                    WsbAffirmHr(pWorkItem->GetTotals(&pCollect));
                    WsbAffirmHr(pCollect->RemoveAllAndRelease());

                } else {

                    // If we didn't finish it last time, then try it.
                    if ((HSM_JOB_STATE_DONE != state) && (HSM_JOB_STATE_FAILED != state)) {

                        WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_IDLE));
                        WsbAffirmHr(pWorkItem->SetSubRunId(0));

                        // If it was suspended, then begin where we left off. Otherwise,
                        // start from the beginning.
                        if (HSM_JOB_STATE_SUSPENDED == state) {
                            WsbAffirmHr(pWorkItem->GetCurrentPath(&currentPath, 0));
                        } else {
                            WsbAffirmHr(pWorkItem->SetCurrentPath(OLESTR("\\")));
                        }
                        WsbAffirmHr(pWorkItem->SetStartingPath(currentPath));
                        
                        // Clear out the phases and session totals.
                        pCollect = 0;
                        WsbAffirmHr(pWorkItem->GetPhases(&pCollect));
                        WsbAffirmHr(pCollect->RemoveAllAndRelease());

                        pCollect = 0;
                        WsbAffirmHr(pWorkItem->GetTotals(&pCollect));
                        WsbAffirmHr(pCollect->RemoveAllAndRelease());
                    }
                }
            }

            pResource = 0;
            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::WaitUntilDone(
    void
    )

/*++

Implements:

  IHsmJob::WaitUntilDone().

--*/
{
    HRESULT                             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::WaitUntilDone"), OLESTR(""));
    try {

        // For now, we are just going to be gross about this, and sit in a sleep loop
        // until the job finishes.
        // 
        // NOTE: We may want to do with events or something.
        while (m_isActive) {
            Sleep(5000);

            // Make sure the job gets restarted if it is suspended
            WsbAffirmHr(RestartSuspendedJobs());
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::WaitUntilDone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmjob.h ===
#ifndef _HSMJOB_
#define _HSMJOB_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjob.cpp

Abstract:

    This class contains properties that defines the context in which the job
    should be run.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "hsmeng.h"

/*++

Class Name:
    
    CHsmJob

Class Description:


--*/

class CHsmJob : 
    public CWsbObject,
    public IHsmJob,
    public IHsmJobPriv,
    public CComCoClass<CHsmJob,&CLSID_CHsmJob>,
    public IConnectionPointContainerImpl<CHsmJob>,
    public IConnectionPointImpl<CHsmJob, &IID_IHsmJobSinkEverySession, CComDynamicUnkArray>
{
public:
    CHsmJob() {}

BEGIN_COM_MAP(CHsmJob)
    COM_INTERFACE_ENTRY(IHsmJob)
    COM_INTERFACE_ENTRY(IHsmJobPriv)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()
                        
BEGIN_CONNECTION_POINT_MAP(CHsmJob)
    CONNECTION_POINT_ENTRY(IID_IHsmJobSinkEverySession)
END_CONNECTION_POINT_MAP()
                        
DECLARE_REGISTRY_RESOURCEID(IDR_CHsmJob)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// CHsmJob
    STDMETHOD(Do)();
    STDMETHOD(UpdateWorkItems)(BOOL isRestart);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmJobPriv
public:
    STDMETHOD(AdviseOfSessionState)(IHsmSession* pSession, IHsmPhase* pPhase, OLECHAR* currentPath);
    STDMETHOD(DoNext)();

// IHsmJob
public:
    STDMETHOD(Cancel)(HSM_JOB_PHASE phase);
    STDMETHOD(DidFinish)(void);
    STDMETHOD(DidFinishOk)(void);
    STDMETHOD(EnumWorkItems)(IWsbEnum** ppEnum);
    STDMETHOD(FindWorkItem)(IHsmSession* pSession, IHsmJobWorkItem** ppWorkItem);
    STDMETHOD(GetContext)(IHsmJobContext** ppContext);
    STDMETHOD(GetDef)(IHsmJobDef** ppDef);
    STDMETHOD(GetHsmId)(GUID* pId);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetMaxActiveSessions)(ULONG* pMaxActiveSessions);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetRunId)(ULONG* pRunId);
    STDMETHOD(GetState)(HSM_JOB_STATE* pState);
    STDMETHOD(InitAs)(OLECHAR* name, IHsmJobDef* pDef, HSM_JOB_DEF_TYPE type, GUID storagePool, IHsmServer* pServer, BOOL isUserDefined, IFsaResource* pResource);
    STDMETHOD(IsActive)(void);
    STDMETHOD(IsUserDefined)(void);
    STDMETHOD(Pause)(HSM_JOB_PHASE phase);
    STDMETHOD(Restart)(void);
    STDMETHOD(Resume)(HSM_JOB_PHASE phase);
    STDMETHOD(SetContext)(IHsmJobContext* pContext);
    STDMETHOD(SetDef)(IHsmJobDef* pDef);
    STDMETHOD(SetHsmId)(GUID id);
    STDMETHOD(SetIsUserDefined)(BOOL isUserDefined);
    STDMETHOD(SetName)(OLECHAR* name);
    STDMETHOD(Start)(void);
    STDMETHOD(Suspend)(HSM_JOB_PHASE phase);
    STDMETHOD(WaitUntilDone)(void);

// Private functions
    STDMETHOD(CheckResourceNotInUse)(GUID resid);
    STDMETHOD(RestartSuspendedJobs)(void);

protected:
    HSM_JOB_STATE               m_state;
    GUID                        m_hsmId;
    GUID                        m_id;
    BOOL                        m_isUserDefined;
    BOOL                        m_isActive;
    BOOL                        m_isTerminating;
    ULONG                       m_activeSessions;
    ULONG                       m_runId;
    CWsbStringPtr               m_name;
    CComPtr<IHsmJobContext>     m_pContext;
    CComPtr<IHsmJobDef>         m_pDef;
    CComPtr<IWsbCollection>     m_pWorkItems;
};

#endif // _HSMJOB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmjobcx.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobcx.cpp

Abstract:

    This class contains properties that defines the context in which the job
    should be run.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"

#ifndef _HSMJOBCX_
#define _HSMJOBCX_

/*++

Class Name:
    
    CHsmJobContext

Class Description:

    This class contains properties that defines the context in which the job
    should be run.

--*/

class CHsmJobContext : 
    public CWsbObject,
    public IHsmJobContext,
    public CComCoClass<CHsmJobContext,&CLSID_CHsmJobContext>
{
public:
    CHsmJobContext() {}
BEGIN_COM_MAP(CHsmJobContext)
    COM_INTERFACE_ENTRY(IHsmJobContext)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmJobContext)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmJobContext
public:
    STDMETHOD(Resources)(IWsbCollection** ppResources);
    STDMETHOD(EnumResources)(IWsbEnum** ppEnum);
    STDMETHOD(SetUsesAllManaged)(BOOL usesAllManaged);
    STDMETHOD(UsesAllManaged)(void);

protected:
    CComPtr<IWsbCollection>     m_pResources;
    BOOL                        m_usesAllManaged;
};

#endif  // _HSMJOBCX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmjobdf.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobcx.cpp

Abstract:

    This class contains properties that define the job, mainly the policies
    to be enacted by the job.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmjobdf.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmJobDef::EnumPolicies(
    IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmJobDef::EnumPolicies().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pPolicies->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_skipHiddenItems = TRUE;
        m_skipSystemItems = TRUE;
        m_useRPIndex = FALSE;
        m_useDbIndex = FALSE;

        // Each instance should have its own unique identifier.
        WsbAffirmHr(CoCreateGuid(&m_id));

        //Create the Policies collection (with no items).
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pPolicies));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJobDef::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmJobDef;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobDef::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmJobDef::GetIdentifier(
    GUID* pId
    )

/*++

Implements:

  IHsmJobDef::GetIdentifier().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::GetName(
    OLECHAR** pName,
    ULONG bufferSize
    )

/*++

Implements:

  IHsmJobDef::GetName().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::GetPostActionOnResource(
    OUT IHsmActionOnResourcePost** ppAction
    )

/*++

Implements:

  IHsmJobDef::GetPostActionOnResource().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssertPointer(ppAction);
        *ppAction = m_pActionResourcePost;
        if (m_pActionResourcePost) {
            m_pActionResourcePost.p->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::GetPreActionOnResource(
    OUT IHsmActionOnResourcePre** ppAction
    )

/*++

Implements:

  IHsmJobDef::GetPreActionOnResource().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssertPointer(ppAction);
        *ppAction = m_pActionResourcePre;
        if (m_pActionResourcePre) {
            m_pActionResourcePre.p->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CHsmJobDef::GetPreScanActionOnResource(
    OUT IHsmActionOnResourcePreScan** ppAction
    )

/*++

Implements:

  IHsmJobDef::GetPreScanActionOnResource().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssertPointer(ppAction);
        *ppAction = m_pActionResourcePreScan;
        if (m_pActionResourcePreScan) {
            m_pActionResourcePreScan.p->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    ULARGE_INTEGER              entrySize;

    WsbTraceIn(OLESTR("CHsmJobDef::GetSizeMax"), OLESTR(""));

    try {

        pSize->QuadPart = WsbPersistSizeOf(GUID) + 2 * WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(ULONG) + WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR));

        WsbAffirmHr(m_pPolicies->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pPersistStream = 0;
        pSize->QuadPart += entrySize.QuadPart;

        WsbAffirmHr(m_pPolicies->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pPersistStream = 0;
        pSize->QuadPart += entrySize.QuadPart;


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobDef::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmJobDef::InitAs(
    IN OLECHAR* name,
    IN HSM_JOB_DEF_TYPE type,
    IN GUID storagePool,
    IN IHsmServer* pServer,
    IN BOOL isUserDefined
    )

/*++

Implements:

  IHsmJobDef::InitAs().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IHsmJobContext>         pContext;
    CComPtr<IHsmPolicy>             pPolicy;
    CComPtr<IHsmRule>               pRule;
    CComPtr<IHsmCriteria>           pCriteria;
    CComPtr<IHsmAction>             pAction;
    CComPtr<IHsmDirectedAction>     pDirectedAction;
    CComPtr<IWsbGuid>               pGuid;
    CComPtr<IWsbCollection>         pRulesCollection;
    CComPtr<IWsbCollection>         pCriteriaCollection;
    CComPtr<IWsbCreateLocalObject>  pCreateObj;

    WsbTraceIn(OLESTR("CHsmJobDef::InitAs"), OLESTR("name = <%ls>, type = %ld"), 
            name, static_cast<LONG>(type));

    try {

        WsbAssert(0 != name, E_POINTER);

        // All objects created need to be owned by the engine.
        WsbAffirmHr(pServer->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));

        // All types will need a policy and at least one rule.
        WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmPolicy, IID_IHsmPolicy, (void**) &pPolicy));
        WsbAffirmHr(pPolicy->SetName(name));
        WsbAffirmHr(pPolicy->Rules(&pRulesCollection));
        WsbAffirmHr(m_pPolicies->Add(pPolicy));

        WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
        WsbAffirmHr(pRule->SetIsInclude(TRUE));
        WsbAffirmHr(pRule->SetIsUserDefined(isUserDefined));
        WsbAffirmHr(pRule->SetIsUsedInSubDirs(TRUE));
        WsbAffirmHr(pRule->SetName(OLESTR("*")));
        WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
        WsbAffirmHr(pRule->Criteria(&pCriteriaCollection));
        WsbAffirmHr(pRulesCollection->Add(pRule));

        // The criteria and the action vary upon the job type.
        switch(type) {
            case HSM_JOB_DEF_TYPE_MANAGE:
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionManage, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pAction->QueryInterface(IID_IHsmDirectedAction, (void**) &pDirectedAction));
                WsbAffirmHr(pDirectedAction->SetStoragePoolId(storagePool));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(TRUE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritManageable, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                break;

            case HSM_JOB_DEF_TYPE_RECALL:
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionRecall, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritMigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                break;

            case HSM_JOB_DEF_TYPE_TRUNCATE:
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionTruncate, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritPremigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                break;

            case HSM_JOB_DEF_TYPE_UNMANAGE:
                m_useRPIndex = TRUE;
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionUnmanage, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritPremigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                pCriteria = 0;
                pCriteriaCollection = 0;
                pRule = 0;

                //  Add an addition rule
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
                WsbAffirmHr(pRule->SetIsInclude(TRUE));
                WsbAffirmHr(pRule->SetIsUserDefined(isUserDefined));
                WsbAffirmHr(pRule->SetIsUsedInSubDirs(TRUE));
                WsbAffirmHr(pRule->SetName(OLESTR("*")));
                WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
                WsbAffirmHr(pRule->Criteria(&pCriteriaCollection));
                WsbAffirmHr(pRulesCollection->Add(pRule));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritMigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                break;

            case HSM_JOB_DEF_TYPE_FULL_UNMANAGE:
                m_useRPIndex = TRUE;
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionUnmanage, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritPremigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                pCriteria = 0;
                pCriteriaCollection = 0;
                pRule = 0;

                //  Add an addition rule
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
                WsbAffirmHr(pRule->SetIsInclude(TRUE));
                WsbAffirmHr(pRule->SetIsUserDefined(isUserDefined));
                WsbAffirmHr(pRule->SetIsUsedInSubDirs(TRUE));
                WsbAffirmHr(pRule->SetName(OLESTR("*")));
                WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
                WsbAffirmHr(pRule->Criteria(&pCriteriaCollection));
                WsbAffirmHr(pRulesCollection->Add(pRule));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritMigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));

                //  When done, remove the volume from management
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePostUnmanage,
                        IID_IHsmActionOnResourcePost, (void**) &m_pActionResourcePost));
                //  When starting, mark the resource as DeletePending
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePreUnmanage,
                        IID_IHsmActionOnResourcePre, (void**) &m_pActionResourcePre));
                break;

            case HSM_JOB_DEF_TYPE_QUICK_UNMANAGE:
                m_useRPIndex = TRUE;
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionUnmanage, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritPremigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));

                //  Clean out pointers so we can create more stuff
                pPolicy.Release();
                pAction.Release();
                pRulesCollection.Release();
                pCriteria.Release();
                pCriteriaCollection.Release();
                pRule.Release();


                //  Create a new policy for job to do the delete
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmPolicy, IID_IHsmPolicy, (void**) &pPolicy));
                WsbAffirmHr(pPolicy->SetName(name));
                WsbAffirmHr(pPolicy->Rules(&pRulesCollection));
                WsbAffirmHr(m_pPolicies->Add(pPolicy));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionDelete, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                //  Add an addition rule
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
                WsbAffirmHr(pRule->SetIsInclude(TRUE));
                WsbAffirmHr(pRule->SetIsUserDefined(isUserDefined));
                WsbAffirmHr(pRule->SetIsUsedInSubDirs(TRUE));
                WsbAffirmHr(pRule->SetName(OLESTR("*")));
                WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
                WsbAffirmHr(pRule->Criteria(&pCriteriaCollection));
                WsbAffirmHr(pRulesCollection->Add(pRule));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritMigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));

                //  When done, remove the volume from management
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePostUnmanage,
                        IID_IHsmActionOnResourcePost, (void**) &m_pActionResourcePost));
                //  When starting, mark the resource as DeletePending
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePreUnmanage,
                        IID_IHsmActionOnResourcePre, (void**) &m_pActionResourcePre));
                break;

            case HSM_JOB_DEF_TYPE_VALIDATE:
                m_useRPIndex = TRUE;
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionValidate, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritPremigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                pCriteria = 0;
                pCriteriaCollection = 0;
                pRule = 0;

                //  Add an addition rule
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
                WsbAffirmHr(pRule->SetIsInclude(TRUE));
                WsbAffirmHr(pRule->SetIsUserDefined(isUserDefined));
                WsbAffirmHr(pRule->SetIsUsedInSubDirs(TRUE));
                WsbAffirmHr(pRule->SetName(OLESTR("*")));
                WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
                WsbAffirmHr(pRule->Criteria(&pCriteriaCollection));
                WsbAffirmHr(pRulesCollection->Add(pRule));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritMigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));

                //  Add pre & post actions on resources
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePreValidate,
                        IID_IHsmActionOnResourcePre, (void**) &m_pActionResourcePre));
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePostValidate,
                        IID_IHsmActionOnResourcePost, (void**) &m_pActionResourcePost));
                WsbTrace(OLESTR("CHsmJobDef::InitAs(Validate): m_pActionResourcePre = %lx, m_pActionResourcePost = %lx\n"),
                    static_cast<void*>(m_pActionResourcePre), static_cast<void*>(m_pActionResourcePost));
        break;


        }

        // There are a couple of other fields to fill out in the job definition
        m_name = name;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobDef::InitAs"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobDef::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    BOOL                        hasA;
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobDef::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbLoadFromStream(pStream, &m_id);
        WsbLoadFromStream(pStream, &m_name, 0);
        WsbLoadFromStream(pStream, &m_skipHiddenItems);
        WsbLoadFromStream(pStream, &m_skipSystemItems);
        WsbLoadFromStream(pStream, &m_useRPIndex);

        WsbAffirmHr(m_pPolicies->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));

        // Is there a pre-scan resource action?
        WsbAffirmHr(WsbLoadFromStream(pStream, &hasA));
        if (hasA) {
            WsbAffirmHr(OleLoadFromStream(pStream, IID_IHsmActionOnResourcePre, 
                    (void**) &m_pActionResourcePre));
        }

        // Is there a post-scan resource action?
        WsbAffirmHr(WsbLoadFromStream(pStream, &hasA));
        if (hasA) {
            WsbAffirmHr(OleLoadFromStream(pStream, IID_IHsmActionOnResourcePost, 
                    (void**) &m_pActionResourcePost));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobDef::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobDef::Policies(
    IWsbCollection** ppPolicies
    )

/*++

Implements:

  IHsmJobDef::Policies().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppPolicies, E_POINTER);
        *ppPolicies = m_pPolicies;
        m_pPolicies.p->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    BOOL                        hasA;
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobDef::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbSaveToStream(pStream, m_id);
        WsbSaveToStream(pStream, m_name);
        WsbSaveToStream(pStream, m_skipHiddenItems);
        WsbSaveToStream(pStream, m_skipSystemItems);
        WsbSaveToStream(pStream, m_useRPIndex);
        
        WsbAffirmHr(m_pPolicies->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        //  Save pre-scan resource action if present        
        WsbTrace(OLESTR("CHsmJobDef::Save: m_pActionResourcePre = %lx, m_pActionResourcePost = %lx\n"),
                static_cast<void*>(m_pActionResourcePre), static_cast<void*>(m_pActionResourcePost));
        if (m_pActionResourcePre) {
            hasA = TRUE;
            WsbSaveToStream(pStream, hasA);
            WsbAffirmHr(m_pActionResourcePre->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(OleSaveToStream(pPersistStream, pStream));
            pPersistStream = 0;
        } else {
            hasA = FALSE;
            WsbSaveToStream(pStream, hasA);
        }

        //  Save post-scan resource action if present       
        if (m_pActionResourcePost) {
            hasA = TRUE;
            WsbSaveToStream(pStream, hasA);
            WsbAffirmHr(m_pActionResourcePost->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(OleSaveToStream(pPersistStream, pStream));
            pPersistStream = 0;
        } else {
            hasA = FALSE;
            WsbSaveToStream(pStream, hasA);
        }

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobDef::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobDef::SetName(
    OLECHAR* name
    )

/*++

Implements:

  IHsmJobDef::SetName().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        m_name = name;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::SetPostActionOnResource(
    IN IHsmActionOnResourcePost* pAction
    )

/*++

Implements:

  IHsmJobDef::SetPostActionOnResource

--*/
{
    m_pActionResourcePost = pAction;

    return(S_OK);
}


HRESULT
CHsmJobDef::SetPreActionOnResource(
    IN IHsmActionOnResourcePre* pAction
    )

/*++

Implements:

  IHsmJobDef::SetPreActionOnResource

--*/
{
    m_pActionResourcePre = pAction;

    return(S_OK);
}

HRESULT
CHsmJobDef::SetPreScanActionOnResource(
    IN IHsmActionOnResourcePreScan* pAction
    )

/*++

Implements:

  IHsmJobDef::SetPreScanActionOnResource

--*/
{
    m_pActionResourcePreScan = pAction;

    return(S_OK);
}


HRESULT
CHsmJobDef::SkipHiddenItems(
    void
    )

/*++

Implements:

  IHsmJobDef::SkipHiddenItems().

--*/
{
    return(m_skipHiddenItems ? S_OK : S_FALSE);
}


HRESULT
CHsmJobDef::SkipSystemItems(
    void
    )

/*++

Implements:

  IHsmJobDef::SkipSystemItems().

--*/
{
    return(m_skipSystemItems ? S_OK : S_FALSE);
}


HRESULT
CHsmJobDef::SetSkipHiddenItems(
    IN BOOL shouldSkip
    )

/*++

Implements:

  IHsmJobDef::SetSkipHiddenItems().

--*/
{
    m_skipHiddenItems = shouldSkip;

    return(S_OK);
}


HRESULT
CHsmJobDef::SetSkipSystemItems(
    IN BOOL shouldSkip
    )

/*++

Implements:

  IHsmJobDef::SetSkipSytemItems().

--*/
{
    m_skipSystemItems = shouldSkip;

    return(S_OK);
}


HRESULT
CHsmJobDef::SetUseRPIndex(
    IN BOOL useRPIndex
    )

/*++

Implements:

  IHsmJobDef::SetUseRPIndex().

--*/
{
    m_useRPIndex = useRPIndex;

    return(S_OK);
}

HRESULT
CHsmJobDef::SetUseDbIndex(
    IN BOOL useIndex
    )

/*++

Implements:

  IHsmJobDef::SetUseRPIndex().

--*/
{
    m_useDbIndex = useIndex;

    return(S_OK);
}


HRESULT
CHsmJobDef::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::UseRPIndex(
    void
    )

/*++

Implements:

  IHsmJobDef::UseRPIndex().

--*/
{
    return(m_useRPIndex ? S_OK : S_FALSE);
}

HRESULT
CHsmJobDef::UseDbIndex(
    void
    )

/*++

Implements:

  IHsmJobDef::UseDbIndex().

--*/
{
    return(m_useDbIndex ? S_OK : S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmjobwi.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobwi.cpp

Abstract:

    This component represents a resource that will is/was operated on by a job.

Author:

    Chuck Bardeen   [cbardeen]   09-Feb-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "hsmjobwi.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCountJobwi = 0;


HRESULT
CHsmJobWorkItem::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmJobWorkItem>    pWorkItem;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmJobWorkItem, (void**) &pWorkItem));

        // Compare the rules.
        hr = CompareToIWorkItem(pWorkItem, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmJobWorkItem::CompareToIWorkItem(
    IN IHsmJobWorkItem* pWorkItem,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmJobWorkItem::CompareToIWorkItem().

--*/
{
    HRESULT     hr = S_OK;
    GUID        id;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::CompareToIWorkItem"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pWorkItem, E_POINTER);

        // Get the identifier.
        WsbAffirmHr(pWorkItem->GetResourceId(&id));

        // Compare to the identifier.
        hr = CompareToResourceId(id, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::CompareToIWorkItem"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmJobWorkItem::CompareToResourceId(
    IN GUID id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmJobWorkItem::CompareToResourceId().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::CompareToResourceId"), OLESTR("resource id = <%ls>"), WsbGuidAsString(id));

    try {

        // Compare the guids.
        aResult = WsbSign( memcmp(&m_resourceId, &id, sizeof(GUID)) );

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::CompareToResourceId"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CHsmJobWorkItem::DoPostScan(
    void
    )

/*++

Implements:

  IPersist::DoPostScan().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::DoPostScan"), OLESTR(""));

    try {
        CComPtr<IHsmActionOnResourcePost> pActionPost;
        CComPtr<IHsmJobDef>               pJobDef;

        // Execute any post-scan action
        WsbAffirmHr(m_pJob->GetDef(&pJobDef));
        WsbAffirmHr(pJobDef->GetPostActionOnResource(&pActionPost));
        if (pActionPost) {
            WsbTrace(OLESTR("CHsmJobWorkItem::DoPostScan, doing post-scan action\n"), (void*)pJobDef);
            WsbAffirmHr(pActionPost->Do(static_cast<IHsmJobWorkItem*>(this), m_state));
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::DoPostScan"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobWorkItem::DoPreScan(
    void
    )

/*++

Implements:

  IPersist::DoPreScan().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::DoPreScan"), OLESTR(""));

    try {
        CComPtr<IHsmActionOnResourcePre>  pActionPre;
        CComPtr<IHsmJobDef>               pJobDef;

        // Execute any pre-scan action
        WsbAffirmHr(m_pJob->GetDef(&pJobDef));
        WsbTrace(OLESTR("CHsmJobWorkItem::DoPreScan, pJobDef = %lx\n"), (void*)pJobDef);
        WsbAffirmHr(pJobDef->GetPreActionOnResource(&pActionPre));
        if (pActionPre) {
            WsbTrace(OLESTR("CHsmJobWorkItem::DoPreScan, doing pre-scan action\n"));
            WsbAffirmHr(pActionPre->Do(static_cast<IHsmJobWorkItem*>(this), pJobDef));
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::DoPreScan"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobWorkItem::EnumPhases(
    IN IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmSession::EnumPhases().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pPhases->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::EnumTotals(
    IN IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmSession::EnumTotals().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pTotals->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmJobWorkItem::FinalConstruct"), OLESTR(""));
    try {
        
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_cookie = 0;
        m_resourceId = GUID_NULL;
        m_state = HSM_JOB_STATE_IDLE;
        m_subRunId = 0;
        m_bActive = FALSE;

        // Create the phase and totals collections.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pPhases));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pTotals));

    } WsbCatch(hr);
    
    iCountJobwi++;
    WsbTraceOut(OLESTR("CHsmJobWorkItem::FinalConstruct"), OLESTR("hr = <%ls>, count is <%d>"), WsbHrAsString(hr), iCountJobwi);
    return(hr);
}


void
CHsmJobWorkItem::FinalRelease(
    void
    )

/*++

Implements:

  CHsmJobWorkItem::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CHsmJobWorkItem::FinalRelease"), OLESTR(""));
    
    CWsbObject::FinalRelease();
    iCountJobwi--;
    
    WsbTraceOut(OLESTR("CHsmJobWorkItem:FinalRelease"), OLESTR("Count is <%d>"), iCountJobwi);
}

HRESULT
CHsmJobWorkItem::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmJobWorkItem;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetCookie(
    OUT DWORD* pCookie
    )
/*++

Implements:

  IHsmJobWorkItem::GetCookie().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pCookie, E_POINTER);
        *pCookie = m_cookie;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetCurrentPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmJobWorkItem::GetCurrentPath().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_currentPath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetFinishTime(
    OUT FILETIME* pTime
    )
/*++

Implements:

  IHsmJobWorkItem::GetFinishTime().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_finishTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetPhases(
    IN IWsbCollection** ppCollection
    )

/*++

Implements:

  IHsmJobWorkItemPriv::GetPhases().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pPhases;
        if (m_pPhases != 0)  {
            m_pPhases.p->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetResourceId(
    OUT GUID* pId
    )
/*++

Implements:

  IHsmJobWorkItem::GetResourceId().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_resourceId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetSession(
    OUT IHsmSession** ppSession
    )
/*++

Implements:

  IHsmJobWorkItem::GetSession().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppSession, E_POINTER);

        *ppSession = m_pSession;
        if (m_pSession != 0)  {
            m_pSession.p->AddRef();
        } else  {
            WsbTrace(OLESTR("CHsmJobWorkItem::GetSession - session pointer is null. \n"));
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetStartingPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmJobWorkItem::GetStartingPath().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_startingPath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;
    ULARGE_INTEGER          entrySize;


    WsbTraceIn(OLESTR("CHsmJobWorkItem::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = 4 * WsbPersistSizeOf(ULONG) + WsbPersistSize((wcslen(m_currentPath) + 1) * sizeof(OLECHAR)) + WsbPersistSize((wcslen(m_startingPath) + 1) * sizeof(OLECHAR)) + 2 * WsbPersistSizeOf(FILETIME) + WsbPersistSizeOf(GUID);

        // Now allocate space for the phase and totals.
        WsbAffirmHr(m_pPhases->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

        WsbAffirmHr(m_pTotals->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetStartTime(
    OUT FILETIME* pTime
    )
/*++

Implements:

  IHsmJobWorkItem::GetStartTime().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_startTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetState(
    OUT HSM_JOB_STATE* pState
    )
/*++

Implements:

  IHsmJobWorkItem::GetState().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pState, E_POINTER);
        *pState = m_state;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetStateAsString(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmJobWorkItem::GetStateAsString().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBSTATEACTIVE + m_state));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetSubRunId(
    OUT ULONG* pId
    )
/*++

Implements:

  IHsmJobWorkItem::GetSubRunId().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_subRunId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetTotals(
    IN IWsbCollection** ppCollection
    )

/*++

Implements:

  IHsmSessionPriv::GetTotals().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pTotals;
        if (m_pTotals != 0 )  {
            m_pTotals.p->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::Init(
    IN IHsmJob* pJob
    )

/*++

Implements:

  IHsmSessionPriv::Init().

--*/
{
    m_pJob = pJob;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::Load"), OLESTR(""));

    try {
        ULONG ul_tmp;

        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_currentPath, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_finishTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_resourceId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_startingPath, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_startTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_state = static_cast<HSM_JOB_STATE>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_subRunId));

        WsbAffirmHr(m_pPhases->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pTotals->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        // The session and cookie are not saved, since it is not likely to be alive on the load.
        m_pSession = 0;
        m_cookie = 0;

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmJobWorkItem::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobWorkItem::ProcessSessionState(
    IN IHsmSession* pSession,
    IN IHsmPhase* pPhase,
    IN OLECHAR* currentPath
    )

/*++

Implements:

  IHsmSessionSinkEveryState::ProcessSessionState().

--*/
{
    HRESULT                             hr = S_OK;
    HRESULT                             hrPhase = S_OK;
    CWsbStringPtr                       tmpString;
    CWsbStringPtr                       tmpString2;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;
    CComPtr<IHsmPhase>                  pFoundPhase;
    CComPtr<IHsmPhase>                  pClonedPhase;
    CComPtr<IHsmSessionTotals>          pSessionTotals;
    CComPtr<IHsmSessionTotals>          pClonedTotals;
    CComPtr<IWsbCollection>             pPhases;
    CComPtr<IWsbEnum>                   pEnum;
    CComPtr<IHsmJobPriv>                pJobPriv;
    HSM_JOB_PHASE                       phase;
    HSM_JOB_STATE                       state;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::ProcessSessionState"), OLESTR(""));
    try {

        WsbAssert(0 != pSession, E_POINTER);

        // Tell everyone the new state of the session.
        try {
            WsbAffirmHr(m_pJob->QueryInterface(IID_IHsmJobPriv, (void**) &pJobPriv));
            WsbAffirmHr(pJobPriv->AdviseOfSessionState(pSession, pPhase, currentPath));
        } WsbCatch(hr);

        // We only keep track of the ones that are for the session as a whole.
        WsbAffirmHr(pPhase->GetPhase(&phase));
        WsbAffirmHr(pPhase->GetState(&state));

        WsbAffirmHr(pPhase->GetName(&tmpString, 0));
        WsbAffirmHr(pPhase->GetStateAsString(&tmpString2, 0));
        WsbTrace(OLESTR("CHsmJobWorkItem::ProcessSessionState - Phase = <%ls>, State = <%ls>\n"), (OLECHAR *)tmpString, (OLECHAR *)tmpString2);

        if (HSM_JOB_PHASE_ALL == phase) {

            m_currentPath = currentPath;
            m_state = state;

            // If the session has finished, then we have some cleanup to do so that it can go
            // away.
            if (HSM_JOB_STATE_IS_DONE(state)) {

                //  Do the post-scan action, if any
                WsbAffirmHr(DoPostScan());
            
                WsbAffirmHr(CoFileTimeNow(&m_finishTime));

                // Collect all the phase and session totals information so that it can be
                // persistsed for later use.
                try {

                    WsbAffirmHr(pSession->EnumPhases(&pEnum));

                    for (hrPhase = pEnum->First(IID_IHsmPhase, (void**) &pFoundPhase);
                         SUCCEEDED(hrPhase);
                         hrPhase = pEnum->Next(IID_IHsmPhase, (void**) &pFoundPhase)) {

                        // Create the new instance.
                        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhase, (void**) &pClonedPhase));

                        // Fill it in with the new values.
                        WsbAffirmHr(pFoundPhase->CopyTo(pClonedPhase));
                        WsbAffirmHr(m_pPhases->Add(pClonedPhase));

                        pFoundPhase = 0;
                        pClonedPhase = 0;
                    }

                    WsbAssert(hrPhase == WSB_E_NOTFOUND, hrPhase);
                    pEnum = 0;

                    WsbAffirmHr(pSession->EnumTotals(&pEnum));

                    for (hrPhase = pEnum->First(IID_IHsmSessionTotals, (void**) &pSessionTotals);
                         SUCCEEDED(hrPhase);
                         hrPhase = pEnum->Next(IID_IHsmSessionTotals, (void**) &pSessionTotals)) {

                        WsbAffirmHr(pSessionTotals->GetName(&tmpString, 0));
                        WsbTrace(OLESTR("CHsmJobWorkItem::ProcessSessionState - Copying session totals <%ls>\n"), (OLECHAR *)tmpString);

                        // Create the new instance.
                        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSessionTotals, 0, CLSCTX_ALL, IID_IHsmSessionTotals, (void**) &pClonedTotals));

                        // Fill it in with the new values.
                        WsbAffirmHr(pSessionTotals->CopyTo(pClonedTotals));
                        WsbAffirmHr(m_pTotals->Add(pClonedTotals));

                        pSessionTotals = 0;
                        pClonedTotals = 0;
                    }

                    WsbAssert(hrPhase == WSB_E_NOTFOUND, hrPhase);
                    pEnum = 0;

                } WsbCatch(hr)

                if (0 != m_cookie)  {
                    // Tell the session that we don't want to be advised anymore.
                    WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
                    WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
                    WsbAffirmHr(pCP->Unadvise(m_cookie));
                } else  {
                    WsbTrace(OLESTR("CHsmJobWorkItem::ProcessSessionState - cookie was 0 so didn't unadvise.\n"));
                }
                

                // Let the session object go away.
                m_pSession = 0;
                m_cookie = 0;

                m_bActive = FALSE;

                // See if there is anymore work to do for this job.
                WsbAffirmHr(pJobPriv->DoNext());
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::ProcessSessionState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmJobWorkItem::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IWsbEnum>       pEnum;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_currentPath));
        WsbAffirmHr(WsbSaveToStream(pStream, m_finishTime));
        WsbAffirmHr(WsbSaveToStream(pStream, m_resourceId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_startingPath));
        WsbAffirmHr(WsbSaveToStream(pStream, m_startTime));
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_state)));
        WsbAffirmHr(WsbSaveToStream(pStream, m_subRunId));

        WsbAffirmHr(m_pPhases->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pTotals->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // The session and cookie are not saved, since it is not likely to be alive on the load.

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobWorkItem::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::SetCookie(
    IN DWORD cookie
    )
/*++

Implements:

  IHsmJobWorkItem::SetCookie().

--*/
{
    WsbTraceIn(OLESTR("CHsmJobWorkItem::SetCookie"), OLESTR(""));
    
    HRESULT hr = S_OK;
    m_cookie = cookie;
        
    WsbTraceOut(OLESTR("CHsmJobWorkItem::SetCookie"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmJobWorkItem::SetCurrentPath(
    IN OLECHAR* path
    )
/*++

Implements:

  IHsmJobWorkItem::SetCurrentPath().

--*/
{
    m_currentPath = path;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetFinishTime(
    IN FILETIME time
    )
/*++

Implements:

  IHsmJobWorkItem::SetFinishTime().

--*/
{
    m_finishTime = time;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetResourceId(
    IN GUID id
    )
/*++

Implements:

  IHsmJobWorkItem::SetResourceId().

--*/
{
    m_resourceId = id;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetSession(
    IN IHsmSession* pSession
    )
/*++

Implements:

  IHsmJobWorkItem::SetSession().

--*/
{
    HRESULT         hr = S_OK;

    if (m_pSession != 0)  {
        m_pSession = 0;
    }
    m_pSession = pSession;

    return(hr);
}


HRESULT
CHsmJobWorkItem::SetStartingPath(
    IN OLECHAR* path
    )
/*++

Implements:

  IHsmJobWorkItem::SetStartingPath().

--*/
{
    m_startingPath = path;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetStartTime(
    IN FILETIME time
    )
/*++

Implements:

  IHsmJobWorkItem::SetStartTime().

--*/
{
    m_startTime = time;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetState(
    IN HSM_JOB_STATE state
    )
/*++

Implements:

  IHsmJobWorkItem::SetState().

--*/
{
    m_state = state;
    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetSubRunId(
    IN ULONG id
    )
/*++

Implements:

  IHsmJobWorkItem::SetSubRunId().

--*/
{
    m_subRunId = id;

    return(S_OK);
}

HRESULT
CHsmJobWorkItem::IsActiveItem(
    void
    )

/*++

Implements:

  IHsmJobWorkItemPriv::IsActiveItem().

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CHsmJobWorkItem::IsActiveItem"), OLESTR(""));
    
    hr = (m_bActive ? S_OK : S_FALSE);
    
    WsbTraceOut(OLESTR("CHsmJobWorkItem::IsActiveItem"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}

HRESULT
CHsmJobWorkItem::SetActiveItem(
    BOOL bActive
    )

/*++

Implements:

  IHsmJobWorkItemPriv::SetActiveItem().

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( OLESTR("CHsmJobWorkItem::SetActiveItem"), OLESTR("bActive = %ls"), 
        WsbBoolAsString(bActive) );
    
    m_bActive = bActive;
    
    WsbTraceOut(OLESTR("CHsmJobWorkItem::SetActiveItem"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmjobcx.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobcx.cpp

Abstract:

    This class contains properties that defines the context in which the job
    should be run.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmjobcx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCount = 0;


HRESULT
CHsmJobContext::EnumResources(
    IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmJobContext::EnumResources().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pResources->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobContext::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmJobContext::FinalConstruct"), OLESTR(""));
    try {

        m_usesAllManaged = FALSE;

        //Create the Resources collection (with no items).
        WsbAffirmHr(CWsbObject::FinalConstruct());
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pResources));

    } WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CHsmJobContext::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
        WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmJobContext::FinalRelease(
    void
    )

/*++

Implements:

  CHsmJobContext::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CHsmJobContext::FinalRelease"), OLESTR(""));
    
    CWsbObject::FinalRelease();
    iCount--;
    
    WsbTraceOut(OLESTR("CHsmJobContext:FinalRelease"), OLESTR("Count is <%d>"), iCount);
}

HRESULT
CHsmJobContext::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJobContext::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmJobContext;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobContext::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmJobContext::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobContext::GetSizeMax"), OLESTR(""));

    try {

        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(pSize));

        pSize->QuadPart += WsbPersistSizeOf(BOOL);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobContext::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmJobContext::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobContext::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbLoadFromStream(pStream, &m_usesAllManaged);

        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobContext::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobContext::Resources(
    IWsbCollection** ppResources
    )

/*++

Implements:

  IHsmJobContext::Resources().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppResources, E_POINTER);
        *ppResources = m_pResources;
        m_pResources.p->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobContext::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobContext::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbSaveToStream(pStream, m_usesAllManaged);

        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobContext::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobContext::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobContext::SetUsesAllManaged(
    IN BOOL usesAllManaged
    )

/*++

Implements:

  IHsmJobContext::SetUsesAllManaged().

--*/
{
    m_usesAllManaged = usesAllManaged;

    return(S_OK);
}


HRESULT
CHsmJobContext::UsesAllManaged(
    void
    )

/*++

Implements:

  IHsmJobContext::UsesAllManaged().

--*/
{
    return(m_usesAllManaged ? S_OK : S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmjobwi.h ===
#ifndef _HSMJOBWI_
#define _HSMJOBWI_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobwi.h

Abstract:

    This component represents a resource that will is/was operated on by a job.

Author:

    Chuck Bardeen   [cbardeen]   09-Feb-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"


/*++

Class Name:
    
    CHsmJobWorkItem

Class Description:

    This component represents a resource that will is/was operated on by a job.

--*/

class CHsmJobWorkItem : 
    public IHsmJobWorkItem,
    public IHsmJobWorkItemPriv,
    public IHsmSessionSinkEveryState,
    public CWsbObject,
    public CComCoClass<CHsmJobWorkItem,&CLSID_CHsmJobWorkItem>
{
public:
    CHsmJobWorkItem() {}
BEGIN_COM_MAP(CHsmJobWorkItem)
    COM_INTERFACE_ENTRY(IHsmJobWorkItem)
    COM_INTERFACE_ENTRY(IHsmJobWorkItemPriv)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryState)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmJobWorkItem)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmSessionSinkEveryState
public:
    STDMETHOD(ProcessSessionState)(IHsmSession* pSession, IHsmPhase* pPhase, OLECHAR* currentPath);

// IHsmJobWorkItem
public:
    STDMETHOD(CompareToResourceId)(GUID id, SHORT* pResult);
    STDMETHOD(CompareToIWorkItem)(IHsmJobWorkItem* pWorkItem, SHORT* pResult);
    STDMETHOD(DoPostScan)(void);
    STDMETHOD(DoPreScan)(void);
    STDMETHOD(EnumPhases)(IWsbEnum** ppEnum);
    STDMETHOD(EnumTotals)(IWsbEnum** ppEnum);
    STDMETHOD(GetCurrentPath)(OLECHAR** pString, ULONG bufferSize);
    STDMETHOD(GetFinishTime)(FILETIME* pTime);
    STDMETHOD(GetResourceId)(GUID* pId);
    STDMETHOD(GetSession)(IHsmSession** ppSession);
    STDMETHOD(GetStartingPath)(OLECHAR** pString, ULONG bufferSize);
    STDMETHOD(GetStartTime)(FILETIME* pTime);
    STDMETHOD(GetState)(HSM_JOB_STATE* pState);
    STDMETHOD(GetStateAsString)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetSubRunId)(ULONG* pId);

// IHsmJobWorkItemPriv
public:
    STDMETHOD(GetCookie)(DWORD* pCookie);
    STDMETHOD(GetPhases)(IWsbCollection** pPhases);
    STDMETHOD(GetTotals)(IWsbCollection** pTotals);
    STDMETHOD(Init)(IHsmJob* pJob);
    STDMETHOD(SetCookie)(DWORD cookie);
    STDMETHOD(SetCurrentPath)(OLECHAR* string);
    STDMETHOD(SetFinishTime)(FILETIME time);
    STDMETHOD(SetResourceId)(GUID id);
    STDMETHOD(SetSession)(IHsmSession* pSession);
    STDMETHOD(SetStartingPath)(OLECHAR* string);
    STDMETHOD(SetStartTime)(FILETIME time);
    STDMETHOD(SetState)(HSM_JOB_STATE state);
    STDMETHOD(SetSubRunId)(ULONG id);
    STDMETHOD(IsActiveItem)(void);
    STDMETHOD(SetActiveItem)(BOOL bActive);

protected:
    DWORD                   m_cookie;
    CWsbStringPtr           m_currentPath;
    FILETIME                m_finishTime;
    GUID                    m_resourceId;
    CWsbStringPtr           m_startingPath;
    FILETIME                m_startTime;
    HSM_JOB_STATE           m_state;
    ULONG                   m_subRunId;
    CComPtr<IHsmSession>    m_pSession;
    IHsmJob*                m_pJob;         // Parent Pointer, Weak Reference
    CComPtr<IWsbCollection> m_pPhases;
    CComPtr<IWsbCollection> m_pTotals;
    BOOL                    m_bActive;       // specifies whether this item is active (started)
};

#endif // _HSMJOBWI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmphase.h ===
#ifndef _HSMPHASE_
#define _HSMPHASE_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsesst.h

Abstract:

    This class is the phase component, which keeps track the status/totals for a phase of a
    session.

Author:

    Chuck Bardeen   [cbardeen]   14-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "job.h"

/*++

Class Name:
    
    CHsmPhase

    This class is the phase component, which keeps track the status/totals for a phase of a
    session.

Class Description:


--*/

class CHsmPhase : 
    public CWsbObject,
    public IHsmPhase,
    public IHsmPhasePriv,
    public CComCoClass<CHsmPhase,&CLSID_CHsmPhase>
{
public:
    CHsmPhase() {} 

BEGIN_COM_MAP(CHsmPhase)
    COM_INTERFACE_ENTRY(IHsmPhase)
    COM_INTERFACE_ENTRY(IHsmPhasePriv)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()
                        
DECLARE_REGISTRY_RESOURCEID(IDR_CHsmPhase)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmPhase
public:
    STDMETHOD(Clone)(IHsmPhase** ppPhase);
    STDMETHOD(CompareToPhase)(HSM_JOB_PHASE phase, SHORT* pResult);
    STDMETHOD(CompareToIPhase)(IHsmPhase* pPhase, SHORT* pResult);
    STDMETHOD(CopyTo)(IHsmPhase* pPhase);
    STDMETHOD(GetElapsedTime)(ULONG* pDays, USHORT* pHours, USHORT* pMinutes, USHORT* pSeconds);
    STDMETHOD(GetMediaState)(HSM_JOB_MEDIA_STATE* pState);
    STDMETHOD(GetMediaStateAsString)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetPhase)(HSM_JOB_PHASE* pPhase);
    STDMETHOD(GetPriority)(HSM_JOB_PRIORITY* pPriority);
    STDMETHOD(GetPriorityAsString)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetState)(HSM_JOB_STATE* pState);
    STDMETHOD(GetStateAsString)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetStats)(LONGLONG* pItems, LONGLONG* pSize, LONGLONG* pSkippedItems, LONGLONG* pSkippedSize, LONGLONG* errorItems, LONGLONG* errorSize);
    STDMETHOD(GetStartTime)(FILETIME* pTime);
    STDMETHOD(GetStopTime)(FILETIME* pTime);

// IHsmPhasePriv
    STDMETHOD(AddItem)(IFsaScanItem* pItem, HRESULT hrItem);
    STDMETHOD(Clone)(IHsmPhasePriv** ppPhasePriv);
    STDMETHOD(CopyTo)(IHsmPhasePriv* pPhasePriv);
    STDMETHOD(SetInternalStuff)(ULONG mountCount, ULONG transferCount, LONGLONG elapsedTime, FILETIME startTime, FILETIME restartTime, FILETIME stopTime);
    STDMETHOD(SetPhase)(HSM_JOB_PHASE phase);
    STDMETHOD(SetMediaState)(HSM_JOB_MEDIA_STATE state);
    STDMETHOD(SetPriority)(HSM_JOB_PRIORITY priority);
    STDMETHOD(SetState)(HSM_JOB_STATE state);
    STDMETHOD(SetStats)(LONGLONG items, LONGLONG size, LONGLONG skippedItems, LONGLONG skippedSize, LONGLONG errorItems, LONGLONG errorSize);

protected:
    HSM_JOB_MEDIA_STATE m_mediaState;
    ULONG               m_mountCount;
    ULONG               m_transferCount;
    HSM_JOB_PHASE       m_phase;
    HSM_JOB_PRIORITY    m_priority;
    HSM_JOB_STATE       m_state;
    LONGLONG            m_items;
    LONGLONG            m_size;
    LONGLONG            m_skippedItems;
    LONGLONG            m_skippedSize;
    LONGLONG            m_errorItems;
    LONGLONG            m_errorSize;
    LONGLONG            m_elapsedTime;
    FILETIME            m_startTime;
    FILETIME            m_restartTime;
    FILETIME            m_stopTime;
};

#endif // _HSMPHASE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmjobdf.h ===
#ifndef _HSMJOBDF_
#define _HSMJOBDF_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobcx.cpp

Abstract:

    This class contains properties that define the job, mainly the policies
    to be enacted by the job.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "hsmeng.h"


/*++

Class Name:
    
    CHsmJobDef

Class Description:

    This class contains properties that define the job, mainly the policies
    to be enacted by the job.

--*/

class CHsmJobDef : 
    public CWsbObject,
    public IHsmJobDef,
    public CComCoClass<CHsmJobDef,&CLSID_CHsmJobDef>
{
public:
    CHsmJobDef() {}
BEGIN_COM_MAP(CHsmJobDef)
    COM_INTERFACE_ENTRY(IHsmJobDef)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmJobDef)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmJobDef
public:
    STDMETHOD(EnumPolicies)(IWsbEnum** ppEnum);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetPostActionOnResource)(IHsmActionOnResourcePost** ppAction);
    STDMETHOD(GetPreActionOnResource)(IHsmActionOnResourcePre** ppAction);
    STDMETHOD(GetPreScanActionOnResource)(IHsmActionOnResourcePreScan** ppAction);
    STDMETHOD(InitAs)(OLECHAR* name, HSM_JOB_DEF_TYPE type, GUID storagePool, IHsmServer* pServer, BOOL isUserDefined);
    STDMETHOD(Policies)(IWsbCollection** ppPolicies);
    STDMETHOD(SetName)(OLECHAR* szName);
    STDMETHOD(SetPostActionOnResource)(IHsmActionOnResourcePost* pAction);
    STDMETHOD(SetPreActionOnResource)(IHsmActionOnResourcePre* pAction);
    STDMETHOD(SetPreScanActionOnResource)(IHsmActionOnResourcePreScan* pAction);
    STDMETHOD(SetSkipHiddenItems)(BOOL shouldSkip);
    STDMETHOD(SetSkipSystemItems)(BOOL shouldSkip);
    STDMETHOD(SetUseRPIndex)(BOOL useIndex);
    STDMETHOD(SetUseDbIndex)(BOOL useIndex);
    STDMETHOD(SkipHiddenItems)(void);
    STDMETHOD(SkipSystemItems)(void);
    STDMETHOD(UseRPIndex)(void);
    STDMETHOD(UseDbIndex)(void);

protected:
    GUID                    m_id;
    CWsbStringPtr           m_name;
    BOOL                    m_skipHiddenItems;
    BOOL                    m_skipSystemItems;
    BOOL                    m_useRPIndex;                       // Scan should use Reparse Point Index
    BOOL                    m_useDbIndex;                       // Scan should use Db Index
    CComPtr<IWsbCollection> m_pPolicies;
    CComPtr<IHsmActionOnResourcePre>        m_pActionResourcePre;     // Can be NULL
    CComPtr<IHsmActionOnResourcePreScan>    m_pActionResourcePreScan; // Can be NULL
    CComPtr<IHsmActionOnResourcePost>       m_pActionResourcePost;    // Can be NULL
};

#endif // _HSMJOBDF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmphase.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsesst.cpp

Abstract:

    This class is the phase component, which keeps track the status/totals for a phase of a
    session.

Author:

    Chuck Bardeen   [cbardeen]   14-Feb-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmphase.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCount = 0;


HRESULT
CHsmPhase::AddItem(
    IN IFsaScanItem* pItem,
    IN HRESULT hrItem
    )

/*++

Implements:

  IHsmPhasePriv::AddItem().

--*/
{
    HRESULT                 hr = S_OK;
    LONGLONG                size;

    WsbTraceIn(OLESTR("CHsmPhase::AddItem"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pItem, E_POINTER);

        // Get the size of the file.
        WsbAffirmHr(pItem->GetLogicalSize(&size));

        // Update the appropriate stats.
        switch (hrItem) {
            case S_OK:
                m_items++;
                m_size += size;
                break;
            case S_FALSE:
            case JOB_E_FILEEXCLUDED:
            case JOB_E_DOESNTMATCH:
            case FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED:
            case HSM_E_FILE_CHANGED:
            case HSM_E_WORK_SKIPPED_FILE_TOO_BIG:
                m_skippedItems++;
                m_skippedSize += size;
                break;
            default:
                m_errorItems++;
                m_errorSize += size;
                break;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::AddItem"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::Clone(
    OUT IHsmPhase** ppPhase
    )

/*++

Implements:

  IHsmPhase::Clone().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmPhase>      pPhase;

    WsbTraceIn(OLESTR("CHsmPhase::Clone"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != ppPhase, E_POINTER);
        *ppPhase = 0;

        // Create the new instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhase, (void**) &pPhase));

        // Fill it in with the new values.
        WsbAffirmHr(CopyTo(pPhase));

        // Return it to the caller.
        *ppPhase = pPhase;
        pPhase.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::Clone(
    OUT IHsmPhasePriv** ppPhasePriv
    )

/*++

Implements:

  IHsmPhasePriv::Clone().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmPhasePriv>  pPhasePriv;

    WsbTraceIn(OLESTR("CHsmPhase::Clone"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != ppPhasePriv, E_POINTER);
        *ppPhasePriv = 0;

        // Create the new instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));

        // Fill it in with the new values.
        WsbAffirmHr(CopyTo(pPhasePriv));

        // Return it to the caller.
        *ppPhasePriv = pPhasePriv;
        pPhasePriv.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmPhase>          pPhase;

    WsbTraceIn(OLESTR("CHsmPhase::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmPhase, (void**) &pPhase));

        // Compare the rules.
        hr = CompareToIPhase(pPhase, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmPhase::CompareToPhase(
    IN HSM_JOB_PHASE phase,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmPhase::CompareToPhase().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CHsmPhase::CompareToPhase"), OLESTR(""));

    try {

        // Compare the guids.
        if (m_phase > phase) {
            aResult = 1;
        }
        else if (m_phase < phase) {
            aResult = -1;
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::CompareToPhase"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CHsmPhase::CompareToIPhase(
    IN IHsmPhase* pPhase,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmPhase::CompareToIPhase().

--*/
{
    HRESULT             hr = S_OK;
    HSM_JOB_PHASE       phase;

    WsbTraceIn(OLESTR("CHsmPhase::CompareToIPhase"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pPhase, E_POINTER);

        // Get the identifier.
        WsbAffirmHr(pPhase->GetPhase(&phase));

        // Compare to the identifier.
        hr = CompareToPhase(phase, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::CompareToIPhase"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmPhase::CopyTo(
    IN IHsmPhase* pPhase
    )

/*++

Implements:

  IHsmPhase::CopyTo().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IHsmPhasePriv>  pPhasePriv;

    WsbTraceIn(OLESTR("CHsmPhase::CopyTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != pPhase, E_POINTER);

        // Get the private interface for the destination and copy the values.
        WsbAffirmHr(pPhase->QueryInterface(IID_IHsmPhasePriv, (void**) &pPhasePriv));
        WsbAffirmHr(pPhasePriv->SetInternalStuff(m_mountCount, m_transferCount, m_elapsedTime, m_startTime, m_restartTime, m_stopTime));
        WsbAffirmHr(pPhasePriv->SetMediaState(m_mediaState));
        WsbAffirmHr(pPhasePriv->SetPhase(m_phase));
        WsbAffirmHr(pPhasePriv->SetPriority(m_priority));
        WsbAffirmHr(pPhasePriv->SetState(m_state));
        WsbAffirmHr(pPhasePriv->SetStats(m_items, m_size, m_skippedItems, m_skippedSize, m_errorItems, m_errorSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::CopyTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::CopyTo(
    IN IHsmPhasePriv* pPhasePriv
    )

/*++

Implements:

  IHsmPhase::CopyTo().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmPhase::CopyTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != pPhasePriv, E_POINTER);

        // Get the private interface for the destination and copy the values.
        WsbAffirmHr(pPhasePriv->SetInternalStuff(m_mountCount, m_transferCount, m_elapsedTime, m_startTime, m_restartTime, m_stopTime));
        WsbAffirmHr(pPhasePriv->SetMediaState(m_mediaState));
        WsbAffirmHr(pPhasePriv->SetPhase(m_phase));
        WsbAffirmHr(pPhasePriv->SetPriority(m_priority));
        WsbAffirmHr(pPhasePriv->SetState(m_state));
        WsbAffirmHr(pPhasePriv->SetStats(m_items, m_size, m_skippedItems, m_skippedSize, m_errorItems, m_errorSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::CopyTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmPhase::FinalConstruct"), OLESTR(""));
    try {
        
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_mediaState = HSM_JOB_MEDIA_STATE_IDLE;
        m_mountCount = 0;
        m_transferCount = 0;
        m_phase = HSM_JOB_PHASE_ALL;
        m_priority = HSM_JOB_PRIORITY_NORMAL;
        m_state = HSM_JOB_STATE_IDLE;
        m_items = 0;
        m_size = 0;
        m_skippedItems = 0;
        m_skippedSize = 0;
        m_errorItems = 0;
        m_errorSize = 0;
        m_elapsedTime = 0;
        m_startTime.dwLowDateTime = 0;
        m_startTime.dwHighDateTime = 0;
        m_restartTime.dwLowDateTime = 0;
        m_restartTime.dwHighDateTime = 0;
        m_stopTime.dwLowDateTime = 0;
        m_stopTime.dwHighDateTime = 0;

    } WsbCatch(hr);
    
    iCount++;
    WsbTraceOut(OLESTR("CHsmPhase::FinalConstruct"), OLESTR("hr = <%ls>, count is <%d>"), WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmPhase::FinalRelease(
    void
    )

/*++

Implements:

  CHsmPhase::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CHsmPhase::FinalRelease"), OLESTR(""));
    
    CWsbObject::FinalRelease();
    iCount--;
    
    WsbTraceOut(OLESTR("CHsmPhase::FinalRelease"), OLESTR("Count is <%d>"), iCount);
}


HRESULT
CHsmPhase::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmPhase::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmPhase;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmPhase::GetElapsedTime(
    OUT ULONG* pDays,
    OUT USHORT* pHours,
    OUT USHORT* pMinutes,
    OUT USHORT* pSeconds
    )
/*++

Implements:

  IHsmPhase::GetElapsedTime().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    remainingTime = 0;
    FILETIME    currentTime;

    try {

        WsbAssert(0 != pDays, E_POINTER);
        WsbAssert(0 != pHours, E_POINTER);
        WsbAssert(0 != pMinutes, E_POINTER);
        WsbAssert(0 != pSeconds, E_POINTER);

        // If the phase is still active, then add the time since the last start or restart.
        remainingTime = m_elapsedTime;

        if (HSM_JOB_STATE_IS_ACTIVE(m_state)) {
            WsbAffirmHr(CoFileTimeNow(&currentTime));

            if (WsbFTtoLL(m_restartTime) != 0) {
                remainingTime += WsbFTtoLL(currentTime) - WsbFTtoLL(m_restartTime);
            } else {
                remainingTime += WsbFTtoLL(currentTime) - WsbFTtoLL(m_startTime);
            }
        }

        *pDays = (ULONG) (remainingTime / WSB_FT_TICKS_PER_DAY);
        remainingTime = remainingTime % WSB_FT_TICKS_PER_DAY;

        *pHours = (USHORT) (remainingTime / (WSB_FT_TICKS_PER_HOUR));
        remainingTime = remainingTime % WSB_FT_TICKS_PER_HOUR;

        *pMinutes = (USHORT) (remainingTime / WSB_FT_TICKS_PER_MINUTE);
        *pSeconds = (USHORT) ((remainingTime % WSB_FT_TICKS_PER_MINUTE) / WSB_FT_TICKS_PER_SECOND);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetMediaState(
    OUT HSM_JOB_MEDIA_STATE* pState
    )
/*++

Implements:

  IHsmPhase::GetMediaState().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pState, E_POINTER);
        *pState = m_mediaState;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetMediaStateAsString(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmPhase::GetMediaStateAsString().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBMEDIASTATEIDLE + m_mediaState));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmPhase::GetName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBPHASEALL + m_phase));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetPhase(
    OUT HSM_JOB_PHASE* pPhase
    )
/*++

Implements:

  IHsmPhase::GetPhase().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pPhase, E_POINTER);
        *pPhase = m_phase;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetPriority(
    OUT HSM_JOB_PRIORITY* pPriority
    )
/*++

Implements:

  IHsmPhase::GetPriority().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pPriority, E_POINTER);
        *pPriority = m_priority;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetPriorityAsString(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmPhase::GetPriorityAsString().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBPRIORITY_IDLE + m_priority));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CHsmPhase::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = 5 * WsbPersistSizeOf(LONGLONG) + 6 * WsbPersistSizeOf(ULONG) + 3 * WsbPersistSizeOf(FILETIME);

        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // pSize->QuadPart += 2 * WsbPersistSizeOf(LONGLONG);
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmPhase::GetStartTime(
    OUT FILETIME* pTime
    )
/*++

Implements:

  IHsmPhase::GetStartTime().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_startTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetState(
    OUT HSM_JOB_STATE* pState
    )
/*++

Implements:

  IHsmPhase::GetState().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pState, E_POINTER);
        *pState = m_state;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetStateAsString(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmPhase::GetStateAsString().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBSTATEACTIVE + m_state));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetStats(
    OUT LONGLONG* pItems,
    OUT LONGLONG* pSize,
    OUT LONGLONG* pSkippedItems,
    OUT LONGLONG* pSkippedSize,
    OUT LONGLONG* pErrorItems,
    OUT LONGLONG* pErrorSize
    )
/*++

Implements:

  IHsmPhase::GetStats().

--*/
{
    HRESULT     hr = S_OK;

    if (0 != pItems) {
        *pItems = m_items;
    }

    if (0 != pSize) {
        *pSize = m_size;
    }

    if (0 != pSkippedItems) {
        *pSkippedItems = m_skippedItems;
    }

    if (0 != pSkippedSize) {
        *pSkippedSize = m_skippedSize;
    }

    if (0 != pErrorItems) {
        *pErrorItems = m_errorItems;
    }

    if (0 != pSize) {
        *pErrorSize = m_errorSize;
    }
    
    return(hr);
}


HRESULT
CHsmPhase::GetStopTime(
    OUT FILETIME* pTime
    )
/*++

Implements:

  IHsmPhase::GetStopTime().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_stopTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmPhase::Load"), OLESTR(""));

    try {
        ULONG ul_tmp;

        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_mediaState = static_cast<HSM_JOB_MEDIA_STATE>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_mountCount));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_transferCount));
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_phase = static_cast<HSM_JOB_PHASE>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_priority = static_cast<HSM_JOB_PRIORITY>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_state = static_cast<HSM_JOB_STATE>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_items));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_size));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_skippedItems));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_skippedSize));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_elapsedTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_startTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_restartTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_stopTime));

        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // changes in the persistant data.
        // WsbAffirmHr(WsbLoadFromStream(pStream, &m_errorItems));
        // WsbAffirmHr(WsbLoadFromStream(pStream, &m_errorSize));
        
    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmPhase::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmPhase::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_mediaState)));
        WsbAffirmHr(WsbSaveToStream(pStream, m_mountCount));
        WsbAffirmHr(WsbSaveToStream(pStream, m_transferCount));
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_phase)));
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_priority)));
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_state)));
        WsbAffirmHr(WsbSaveToStream(pStream, m_items));
        WsbAffirmHr(WsbSaveToStream(pStream, m_size));
        WsbAffirmHr(WsbSaveToStream(pStream, m_skippedItems));
        WsbAffirmHr(WsbSaveToStream(pStream, m_skippedSize));
        WsbAffirmHr(WsbSaveToStream(pStream, m_elapsedTime));
        WsbAffirmHr(WsbSaveToStream(pStream, m_startTime));
        WsbAffirmHr(WsbSaveToStream(pStream, m_restartTime));
        WsbAffirmHr(WsbSaveToStream(pStream, m_stopTime));

        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // changes in the persistant data.
        // WsbAffirmHr(WsbSaveToStream(pStream, m_errorItems));
        // WsbAffirmHr(WsbSaveToStream(pStream, m_errorSize));
        
        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::SetInternalStuff(
    IN ULONG mountCount,
    IN ULONG transferCount,
    IN LONGLONG elapsedTime,
    IN FILETIME startTime,
    IN FILETIME restartTime,
    IN FILETIME stopTime
    )
/*++

Implements:

  IHsmPhasePriv::SetInternalStuff().

--*/
{
    m_mountCount = mountCount;
    m_transferCount = transferCount;
    m_elapsedTime = elapsedTime;
    m_startTime = startTime;
    m_restartTime = restartTime;
    m_stopTime = stopTime;

    return(S_OK);
}


HRESULT
CHsmPhase::SetMediaState(
    IN HSM_JOB_MEDIA_STATE state
    )
/*++

Implements:

  IHsmPhasePriv::SetMediaState().

--*/
{
    HRESULT     hr = S_OK;

    // Determine whether the state being reported will cause the overall state to
    // change. The overall state should be mounted/transferring/transferred if any
    // media are mounted.

    switch (state) {
        case HSM_JOB_MEDIA_STATE_BUSY:
        case HSM_JOB_MEDIA_STATE_UNAVAILABLE:
            if ((HSM_JOB_MEDIA_STATE_IDLE == m_mediaState) ||
                (HSM_JOB_MEDIA_STATE_MOUNTING == m_mediaState)) {
                m_mediaState = state;
            }
            break;

        case HSM_JOB_MEDIA_STATE_MOUNTING:
            if ((HSM_JOB_MEDIA_STATE_MOUNTED != m_mediaState) &&
                (HSM_JOB_MEDIA_STATE_TRANSFERRED != m_mediaState) &&
                (HSM_JOB_MEDIA_STATE_TRANSFERRING != m_mediaState)) {
                m_mediaState = state;
            }
            break;

        case HSM_JOB_MEDIA_STATE_MOUNTED:
            if ((HSM_JOB_MEDIA_STATE_MOUNTED != m_mediaState) &&
                (HSM_JOB_MEDIA_STATE_TRANSFERRED != m_mediaState) &&
                (HSM_JOB_MEDIA_STATE_TRANSFERRING != m_mediaState)) {
                m_mediaState = state;
            }
            m_mountCount++;
            break;

        case HSM_JOB_MEDIA_STATE_TRANSFERRING:
            if ((HSM_JOB_MEDIA_STATE_TRANSFERRING != m_mediaState) &&
                (HSM_JOB_MEDIA_STATE_TRANSFERRED != m_mediaState)) {
                m_mediaState = state;
            }
            m_transferCount++;
            break;

        case HSM_JOB_MEDIA_STATE_TRANSFERRED:
            if (m_transferCount <= 1) {
                m_mediaState = state;
            }
            m_transferCount--;
            break;

        case HSM_JOB_MEDIA_STATE_DISMOUNTING:
            if (m_mountCount <= 1) {
                m_mediaState = state;
            }
            break;

        case HSM_JOB_MEDIA_STATE_DISMOUNTED:
            if (m_mountCount <= 1) {
                m_mediaState = state;
            }
            m_mountCount--;
            break;

        case HSM_JOB_MEDIA_STATE_FAILED:
            m_mediaState = state;
            break;

        default:
        case HSM_JOB_MEDIA_STATE_IDLE:
            break;
    }

    return(hr);
}


HRESULT
CHsmPhase::SetPhase(
    IN HSM_JOB_PHASE phase
    )
/*++

Implements:

  IHsmPhase::SetPhase().

--*/
{
    m_phase = phase;

    return(S_OK);
}


HRESULT
CHsmPhase::SetPriority(
    IN HSM_JOB_PRIORITY priority
    )
/*++

Implements:

  IHsmPhasePriv::SetPriority().

--*/
{
    m_priority = priority;

    return(S_OK);
}


HRESULT
CHsmPhase::SetState(
    IN HSM_JOB_STATE state
    )
/*++

Implements:

  IHsmPhasePriv::SetState().

--*/
{
    HRESULT     hr = S_OK;
    FILETIME    currentTime;
    LONGLONG    restartTicks;
    LONGLONG    stopTicks;

    try {

        GetSystemTimeAsFileTime(&currentTime);

        switch(state) {
            case HSM_JOB_STATE_ACTIVE:
                // If this is a resume, then update the restartTime not the startTime.
                if (HSM_JOB_STATE_RESUMING == m_state) {
                    m_restartTime = currentTime;
                } else {
                    m_restartTime = WsbLLtoFT(0);
                    m_startTime = currentTime;
                    m_elapsedTime = 0;
                }
                m_state = state;
                break;

            case HSM_JOB_STATE_CANCELLED:
            case HSM_JOB_STATE_DONE:
            case HSM_JOB_STATE_FAILED:
            case HSM_JOB_STATE_SKIPPED:
            case HSM_JOB_STATE_PAUSED:
            case HSM_JOB_STATE_SUSPENDED:
                // Record the stop time and update the elapsed time.
                m_stopTime = currentTime;
                restartTicks = WsbFTtoLL(m_restartTime);
                stopTicks = WsbFTtoLL(m_stopTime);
                if (restartTicks == 0) {
                    m_elapsedTime = stopTicks - WsbFTtoLL(m_startTime);
                } else {
                    m_elapsedTime += stopTicks - restartTicks;
                }
                m_state = state;
                break;
        
            case HSM_JOB_STATE_CANCELLING:
            case HSM_JOB_STATE_IDLE:
            case HSM_JOB_STATE_PAUSING:
            case HSM_JOB_STATE_RESUMING:
            case HSM_JOB_STATE_STARTING:
            case HSM_JOB_STATE_SUSPENDING:
                // Don't need to do anything for these other than record the state change.
                m_state = state;
                break;

            default:
                WsbAssert(FALSE, E_UNEXPECTED);
                break;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::SetStats(
    IN LONGLONG items,
    IN LONGLONG size,
    IN LONGLONG skippedItems,
    IN LONGLONG skippedSize,
    IN LONGLONG errorItems,
    IN LONGLONG errorSize
    )
/*++

Implements:

  IHsmPhasePriv::SetStats().

--*/
{
    m_items = items;
    m_size = size;
    m_skippedItems = skippedItems;
    m_skippedSize = skippedSize;
    m_errorItems = errorItems;
    m_errorSize = errorSize;

    return(S_OK);
}


HRESULT
CHsmPhase::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmpolcy.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmpolcy.cpp

Abstract:

    This component represents a job's policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmpolcy.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmPolicy::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IHsmPolicy> pPolicy;

    WsbTraceIn(OLESTR("CHsmPolicy::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmPolicy, (void**) &pPolicy));

        // Compare the rules.
        hr = CompareToIPolicy(pPolicy, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmPolicy::CompareToIPolicy(
    IN IHsmPolicy* pPolicy,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmPolicy::CompareToIPolicy().

--*/
{
    HRESULT     hr = S_OK;
    GUID        id;

    WsbTraceIn(OLESTR("CHsmPolicy::CompareToIPolicy"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pPolicy, E_POINTER);

        // Get the path and name.
        WsbAffirmHr(pPolicy->GetIdentifier(&id));

        // Compare to the path and name.
        hr = CompareToIdentifier(id, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::CompareToIPolicy"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmPolicy::CompareToIdentifier(
    IN GUID id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmPolicy::CompareToIdentifier().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CHsmPolicy::CompareToIdentifier"), OLESTR("id = <%ls>"), WsbGuidAsString(id));

    try {

        // Compare the guids.
        aResult = WsbSign( memcmp(&m_id, &id, sizeof(GUID)) );

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::CompareToIdentifier"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CHsmPolicy::EnumRules(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmPolicy::EnumRules().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pRules->Enum(ppEnum));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_scale = 1000;
        m_usesDefaultRules = FALSE;
    
        //Create the criteria collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pRules));

        // Each instance should have its own unique identifier.
        WsbAffirmHr(CoCreateGuid(&m_id));

    } WsbCatch(hr);
    
    return(hr);
}


HRESULT
CHsmPolicy::GetAction(
    OUT IHsmAction** ppAction
    )
/*++

Implements:

  IHsmPolicy::GetAction().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppAction, E_POINTER);
        *ppAction = m_pAction;
        m_pAction.p->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmPolicy::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmPolicy;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmPolicy::GetIdentifier(
    OUT GUID* pId
    )
/*++

Implements:

  IHsmPolicy::GetIdentifier().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pId, E_POINTER);
        *pId = m_id;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmPolicy::GetName().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::GetScale(
    OUT USHORT* pScale
    )
/*++

Implements:

  IHsmPolicy::GetScale().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pScale, E_POINTER);
        *pScale = m_scale;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;
    ULARGE_INTEGER          entrySize;


    WsbTraceIn(OLESTR("CHsmPolicy::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR)) + WsbPersistSizeOf(GUID) + WsbPersistSizeOf(USHORT) + 2 * WsbPersistSizeOf(BOOL);

        // If there is an action, how big is it?
        if (m_pAction != 0) {
            WsbAffirmHr(m_pAction->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
            pSize->QuadPart += entrySize.QuadPart;
            pPersistStream = 0;
        }

        // Now allocate space for the rules (assume they are all the
        // same size).
        WsbAffirmHr(m_pRules->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmPolicy::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    BOOL                        hasAction;

    WsbTraceIn(OLESTR("CHsmPolicy::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_name, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_scale));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_usesDefaultRules));

        // Is there an action?
        WsbAffirmHr(WsbLoadFromStream(pStream, &hasAction));
        if (hasAction) {
            WsbAffirmHr(OleLoadFromStream(pStream, IID_IHsmAction, (void**) &m_pAction));
        }

        WsbAffirmHr(m_pRules->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmPolicy::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPolicy::Rules(
    OUT IWsbCollection** ppRules
    )
/*++

Implements:

  IHsmPolicy::Rules().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppRules, E_POINTER);
        *ppRules = m_pRules;
        m_pRules.p->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IWsbEnum>       pEnum;
    CComPtr<IPersistStream> pPersistStream;
    BOOL                    hasAction = FALSE;

    WsbTraceIn(OLESTR("CHsmPolicy::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_name));
        WsbAffirmHr(WsbSaveToStream(pStream, m_scale));
        WsbAffirmHr(WsbSaveToStream(pStream, m_usesDefaultRules));

        // Is there an action?
        if (m_pAction != 0) {
            hasAction = TRUE;
            WsbAffirmHr(WsbSaveToStream(pStream, hasAction));
            WsbAffirmHr(m_pAction->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(OleSaveToStream(pPersistStream, pStream));
            pPersistStream = 0;
        } else {
            hasAction = FALSE;
            WsbAffirmHr(WsbSaveToStream(pStream, hasAction));
        }

        WsbAffirmHr(m_pRules->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));

        // The loop should terminate with a not found error.
        WsbAffirm(hr == WSB_E_NOTFOUND, hr);
        hr = S_OK;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPolicy::SetAction(
    IN IHsmAction* pAction
    )
/*++

Implements:

  IHsmPolicy::SetAction().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_pAction = pAction;
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::SetName(
    IN OLECHAR* name
    )
/*++

Implements:

  IHsmPolicy::SetName().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_name = name;
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::SetScale(
    IN USHORT scale
    )
/*++

Implements:

  IHsmPolicy::SetScale().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_scale = scale;
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::SetUsesDefaultRules(
    IN BOOL usesDefaultRules
    )
/*++

Implements:

  IHsmPolicy::SetUsesDefaultRules().

--*/
{
    m_usesDefaultRules = usesDefaultRules;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmPolicy::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::UsesDefaultRules(
    void
    )
/*++

Implements:

  IHsmPolicy::UsesDefaultRules().

--*/
{
    HRESULT     hr = S_OK;

    if (!m_usesDefaultRules) {
        hr = S_FALSE;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmrlstk.h ===
#ifndef _HSMRLSTK_
#define _HSMRLSTK_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmrlstk.cpp

Abstract:

    This component represents the set of rules that are in effect for directory currently
    being scanned for one policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"


/*++

Class Name:
    
    CHsmRuleStack

Class Description:

    This component represents the set of rules that are in effect for directory currently
    being scanned for one policy.

--*/

class CHsmRuleStack : 
    public IHsmRuleStack,
    public CWsbObject,
    public CComCoClass<CHsmRuleStack,&CLSID_CHsmRuleStack>
{
public:
    CHsmRuleStack() {}
BEGIN_COM_MAP(CHsmRuleStack)
    COM_INTERFACE_ENTRY(IHsmRuleStack)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmRuleStack)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmRuleStack
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
    STDMETHOD(DoesMatch)(IFsaScanItem* pScanItem, BOOL* pShouldDo);
    STDMETHOD(Init)(IHsmPolicy* pPolicy, IFsaResource* pResource);
    STDMETHOD(Pop)(OLECHAR* path);
    STDMETHOD(Push)(OLECHAR* path);

protected:
    USHORT                  m_scale;
    BOOL                    m_usesDefaults;
    CComPtr<IHsmAction>     m_pAction;
    CComPtr<IHsmPolicy>     m_pPolicy;
    CComPtr<IWsbEnum>       m_pEnumDefaultRules;
    CComPtr<IWsbEnum>       m_pEnumPolicyRules;
    CComPtr<IWsbEnum>       m_pEnumStackRules;
    CComPtr<IWsbCollection> m_pRules;
};

#endif // _HSMRLSTK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmrule.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmrule.cpp

Abstract:

    This component represents a rule for a job's policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmrule.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

// These are defined in nt.h, but it takes all sorts of grief to try to include them. Since
// they are just used internally, it isn't even inportant that we have the same definitions.
#if !defined(DOS_STAR)
    #define DOS_STAR        (L'<')
#endif

#if !defined(DOS_QM)
    #define DOS_QM          (L'>')
#endif

#if !defined(DOS_DOT)
    #define DOS_DOT         (L'"')
#endif



HRESULT
CHsmRule::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IHsmRule>   pRule;

    WsbTraceIn(OLESTR("CHsmRule::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmRule, (void**) &pRule));

        // Compare the rules.
        hr = CompareToIRule(pRule, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmRule::CompareToIRule(
    IN IHsmRule* pRule,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmRule::CompareToIRule().

--*/
{
    HRESULT     hr = S_OK;
    OLECHAR*    path = 0;
    OLECHAR*    name = 0;

    WsbTraceIn(OLESTR("CHsmRule::CompareToIRule"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pRule, E_POINTER);

        // Get the path and name.
        WsbAffirmHr(pRule->GetPath(&path, 0));
        WsbAffirmHr(pRule->GetName(&name, 0));

        // Compare to the path and name.
        hr = CompareToPathAndName(path, name, pResult);

    } WsbCatch(hr);

    if (0 != path) {
        WsbFree(path);
    }

    if (0 != name) {
        WsbFree(name);
    }

    WsbTraceOut(OLESTR("CHsmRule::CompareToIRule"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmRule::CompareToPathAndName(
    IN OLECHAR* path,
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmRule::CompareToPathAndName().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CHsmRule::CompareToPathAndName"), OLESTR("path = <%ls>, name = <%ls>"), path, name);

    try {

        // Compare the path.
        aResult = (SHORT)_wcsicmp(m_path, path);

        // Compare the name.
        if (0 == aResult) {
            aResult = (SHORT)_wcsicmp(m_name, name);
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::CompareToIRule"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CHsmRule::Criteria(
    OUT IWsbCollection** ppCriteria
    )
/*++

Implements:

  IHsmRule::Criteria().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != ppCriteria, E_POINTER);
        *ppCriteria = m_pCriteria;
        m_pCriteria.p->AddRef();
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::DoesNameContainWildcards(
    OLECHAR* name
    )
/*++

Implements:

  IHsmRule::DoesNameContainWildcards().

--*/
{
    HRESULT     hr = S_FALSE;

    try {
        WsbAssert(0 != name, E_POINTER);

        if (wcscspn(name, OLESTR("*?<>\"")) < wcslen(name)) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmRule::EnumCriteria(
    OUT IWsbEnum** ppEnum
    )
/*++

Implements:

  IHsmRule::EnumCriteria().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pCriteria->Enum(ppEnum));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_isInclude = TRUE;
        m_isUserDefined = TRUE;
        m_isUsedInSubDirs = TRUE;

        //Create the criteria collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pCriteria));

    } WsbCatch(hr);
    
    return(hr);
}


HRESULT
CHsmRule::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRule::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmRule;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmRule::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmRule::GetName().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::GetPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmRule::GetPath().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_path.CopyTo(pPath, bufferSize));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::GetSearchName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmRule::GetSearchName().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_searchName.CopyTo(pName, bufferSize));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;
    ULARGE_INTEGER          entrySize;


    WsbTraceIn(OLESTR("CHsmRule::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = WsbPersistSize((wcslen(m_path) + 1) * sizeof(OLECHAR)) + WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR)) + WsbPersistSize((wcslen(m_searchName) + 1) * sizeof(OLECHAR)) + 3 * WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(ULONG);

        // Now allocate space for the criteria (assume they are all the
        // same size).
        WsbAffirmHr(m_pCriteria->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmRule::IsUserDefined(
    void
    )
/*++

Implements:

  IHsmRule::IsUserDefined().

--*/
{
    HRESULT     hr = S_OK;

    if (!m_isUserDefined) {
        hr = S_FALSE;
    }

    return(hr);
}


HRESULT
CHsmRule::IsInclude(
    void
    )
/*++

Implements:

  IHsmRule::IsInclude().

--*/
{
    HRESULT     hr = S_OK;

    if (!m_isInclude) {
        hr = S_FALSE;
    }

    return(hr);
}


HRESULT
CHsmRule::IsNameInExpression(
    IN OLECHAR* expression,
    IN OLECHAR* name,
    IN BOOL ignoreCase
    )

/*++

Implements:

  CHsmRule::IsNameInExpression().

--*/
{
    HRESULT     hr = S_FALSE;
    USHORT      nameLength;
    USHORT      expressionLength;

    WsbTraceIn(OLESTR("CHsmRule::IsNameInExpression"), OLESTR("expression = %ls, name = %ls, ignoreCase = %ls"), expression, name, WsbBoolAsString(ignoreCase));

    try {

        // This is algorithm is from FsRtlIsNameInExpressionPrivate(), but has been rewritten to fit
        // our coding standards, data structures, and to remove other dependencies on Rtl...() code.

        //  The idea behind the algorithm is pretty simple.  We keep track of
        //  all possible locations in the regular expression that are matching
        //  the name.  If when the name has been exhausted one of the locations
        //  in the expression is also just exhausted, the name is in the language
        //  defined by the regular expression.
        WsbAssert(name != 0, E_POINTER);
        WsbAssert(expression != 0, E_POINTER);

        nameLength = (SHORT)wcslen(name);
        expressionLength = (SHORT)wcslen(expression);

        //  If one string is empty return FALSE.  If both are empty return TRUE.
        if ((nameLength == 0) && (expressionLength == 0)) {
            hr = S_OK;
        } else if ((nameLength != 0) && (expressionLength != 0)) {

            //  Special case by far the most common wild card search of *
            if ((expressionLength == 1) && (expression[0] == L'*')) {
                hr = S_OK;
            }
            
            //  Also special case expressions of the form *X.  With this and the prior
            //  case we have covered virtually all normal queries.
            else if (expression[0] == L'*') {

                //  Only special case an expression with a single *
                if (DoesNameContainWildcards(&expression[1]) == S_FALSE) {

                    // If the name is smaller than the expression, than it isn't a match. Otherwise,
                    // we need to check.
                    if (nameLength >= (expressionLength - 1)) {

                        //  Do a simple memory compare if case sensitive, otherwise
                        //  we have got to check this one character at a time.
                        if (ignoreCase) {
                            if (_wcsicmp(&expression[1], &name[nameLength - (expressionLength - 1)]) == 0) {
                                hr = S_OK;
                            }
                        } else {
                            if (wcscmp(&expression[1], &name[nameLength - (expressionLength - 1)]) == 0) {
                                hr = S_OK;
                            }
                        }
                    }
                }
            }

            else {

                // This is the general matching code. Since it is messy, it is put in its
                // own method.
                hr = IsNameInExpressionGuts(expression, expressionLength, name, nameLength, ignoreCase);
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::IsNameInExpression"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRule::IsNameInExpressionGuts(
    IN OLECHAR* expression,
    IN USHORT expressionLength,
    IN OLECHAR* name,
    IN USHORT nameLength,
    IN BOOL ignoreCase
    )

/*++

Implements:

  CHsmRule::IsNameInExpressionGuts().

--*/
{
    HRESULT     hr = S_FALSE;
    USHORT      nameOffset = 0;
    OLECHAR     nameChar = '0';
    USHORT      exprOffset = 0;
    OLECHAR     exprChar;
    BOOL        nameFinished = FALSE;
    ULONG       srcCount;
    ULONG       destCount;
    ULONG       previousDestCount;
    ULONG       matchesCount;
    USHORT*     previousMatches = 0;
    USHORT*     currentMatches = 0;
    USHORT      maxState;
    USHORT      currentState;

    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //      nameOffset  - The offset of the current name char being processed.
    //      exprOffset  - The offset of the current expression char being processed.
    //
    //      srcCount    - Prior match being investigated with current name char
    //      previousDestCount - This is used to prevent entry duplication, see comment
    //      previousMatches   - Holds the previous set of matches (the Src array)
    //
    //      destCount   - Next location to put a match assuming current name char
    //      currentMatches    - Holds the current set of matches (the Dest array)
    //
    //      nameFinished - Allows one more itteration through the Matches array
    //                     after the name is exhusted (to come *s for example)

    try {

        // Since you can get at most two matches per character in the expression, the
        // biggest arrays you will need is twice the expression length.
        currentMatches = (USHORT*)WsbAlloc(nameLength * 2 * expressionLength * sizeof(USHORT));
        WsbAffirm(0 != currentMatches, E_OUTOFMEMORY);
        previousMatches = (USHORT*)WsbAlloc(nameLength * 2 * expressionLength * sizeof(USHORT));
        WsbAffirm(0 != previousMatches, E_OUTOFMEMORY);

        previousMatches[0] = 0;
        matchesCount = 1;
        maxState = (USHORT)( expressionLength * 2 );

        while (!nameFinished) {

            if (nameOffset < nameLength) {
                nameChar = name[nameOffset];
                nameOffset++;
            } else {
                nameFinished = TRUE;

                //  If we have already exhasted the expression, cool.  Don't
                //  continue.
                if (previousMatches[matchesCount - 1] == maxState) {
                    break;
                }
            }

            //  Now, for each of the previous stored expression matches, see what
            //  we can do with this name character.
            srcCount = 0;
            destCount = 0;
            previousDestCount = 0;

            while (srcCount < matchesCount) {
                USHORT length;

                //  We have to carry on our expression analysis as far as possible
                //  for each character of name, so we loop here until the 
                //  expression stops matching.  A clue here is that expression
                //  cases that can match zero or more characters end with a
                //  continue, while those that can accept only a single character
                //  end with a break.
                exprOffset = (USHORT)( ( ( previousMatches[srcCount++] + 1 ) / 2 ) );
                length = 0;

                while (TRUE) {

                    if (exprOffset == expressionLength) {
                        break;
                    }

                    //  The first time through the loop we don't want
                    //  to increment ExprOffset.
                    exprOffset = (USHORT)( exprOffset + length );
                    length = 1;

                    currentState = (USHORT)( exprOffset * 2 );

                    if (exprOffset == expressionLength) {
                        currentMatches[destCount++] = maxState;
                        break;
                    }

                    exprChar = expression[exprOffset];

                    //  * matches any character zero or more times.
                    if (exprChar == L'*') {
                        currentMatches[destCount++] = currentState;
                        currentMatches[destCount++] = (USHORT)( currentState + 1 );
                        continue;
                    }

                    //  DOS_STAR matches any character except . zero or more times.
                    if (exprChar == DOS_STAR) {
                        BOOLEAN iCanEatADot = FALSE;

                        //  If we are at a period, determine if we are allowed to
                        //  consume it, ie. make sure it is not the last one.
                        if (!nameFinished && (nameChar == '.')) {
                            USHORT offset;

                            for (offset = nameOffset; offset < nameLength; offset++) {
                                if (name[offset] == L'.') {
                                    iCanEatADot = TRUE;
                                    break;
                                }
                            }
                        }

                        if (nameFinished || (nameChar != L'.') || iCanEatADot) {
                            currentMatches[destCount++] = currentState;
                            currentMatches[destCount++] = (USHORT)( currentState + 1 );
                            continue;
                        } else {
                            
                            //  We are at a period.  We can only match zero
                            //  characters (ie. the epsilon transition).
                            currentMatches[destCount++] = (USHORT)( currentState + 1 );
                            continue;
                        }
                    }

                    //  The following expreesion characters all match by consuming
                    //  a character, thus force the expression, and thus state
                    //  forward.
                    currentState += 2;

                    //  DOS_QM is the most complicated.  If the name is finished,
                    //  we can match zero characters.  If this name is a '.', we
                    //  don't match, but look at the next expression. Otherwise
                    //  we match a single character.
                    if (exprChar == DOS_QM) {

                        if (nameFinished || (nameChar == L'.')) {
                            continue;
                        }

                        currentMatches[destCount++] = currentState;
                        break;
                    }

                    //  A DOS_DOT can match either a period, or zero characters
                    //  beyond the end of name.
                    if (exprChar == DOS_DOT) {

                        if (nameFinished) {
                            continue;
                        }

                        if (nameChar == L'.') {
                            currentMatches[destCount++] = currentState;
                            break;
                        }
                    }

                    //  From this point on a name character is required to even
                    //  continue, let alone make a match.
                    if (nameFinished) {
                        break;
                    }

                    //  If this expression was a '?' we can match it once.
                    if (exprChar == L'?') {
                        currentMatches[destCount++] = currentState;
                        break;
                    }

                    //  Finally, check if the expression char matches the name char
                    if (ignoreCase) {
                        if (towlower(exprChar) == towlower(nameChar)) {
                            currentMatches[destCount++] = currentState;
                            break;
                        }
                    } else if (exprChar == nameChar) {
                        currentMatches[destCount++] = currentState;
                        break;
                    }

                    //  The expression didn't match so go look at the next
                    //  previous match.
                    break;
                }


                //  Prevent duplication in the destination array.
                //
                //  Each of the arrays is montonically increasing and non-
                //  duplicating, thus we skip over any source element in the src
                //  array if we just added the same element to the destination
                //  array.  This guarentees non-duplication in the dest. array.
                if ((srcCount < matchesCount) && (previousDestCount < destCount) ) {
                    while (previousDestCount < destCount) {
                        while (previousMatches[srcCount] < currentMatches[previousDestCount]) {
                            srcCount += 1;
                        }

                        previousDestCount += 1;
                    }
                }
            }

            //  If we found no matches in the just finished itteration, it's time
            //  to bail.

            if (destCount == 0) {
                WsbThrow(S_FALSE);
            }

            //  Swap the meaning the two arrays
            {
                USHORT*     tmp;

                tmp = previousMatches;
                previousMatches = currentMatches;
                currentMatches = tmp;
            }

            matchesCount = destCount;
        }

        currentState = previousMatches[matchesCount - 1];

        if (currentState == maxState) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    // Free the matches buffers that we allocated previously.
    if (0 != currentMatches) {
        WsbFree(currentMatches);
    }

    if (0 != previousMatches) {
        WsbFree(previousMatches);
    }

    return(hr);
}


HRESULT
CHsmRule::IsUsedInSubDirs(
    void
    )
/*++

Implements:

  IHsmRule::IsUsedInSubDirs().

--*/
{
    HRESULT     hr = S_OK;

    if (!m_isUsedInSubDirs) {
        hr = S_FALSE;
    }

    return(hr);
}


HRESULT
CHsmRule::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    CComPtr<IWsbCollectable>    pCollectable;

    WsbTraceIn(OLESTR("CHsmRule::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_path, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_name, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_searchName, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isUserDefined));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isInclude));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isUsedInSubDirs));

        // Load all the criteria.
        WsbAffirmHr(m_pCriteria->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmRule::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRule::MatchesName(
    IN OLECHAR* name
    )
/*++

Implements:

  IHsmRule::MatchesName().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRule::MatchesName"), OLESTR("name = <%ls>"), (OLECHAR *)name);

    try {

        WsbAssert(0 != name, E_POINTER);

        // It is assumed that these names have been converted from they way they
        // might have been input into proper names for IsNameInExpression()
        // function. See NameToSearchName().
        hr = IsNameInExpression(m_searchName, name, TRUE);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::MatchesName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRule::NameToSearchName(
    void
    )
/*++

Implements:

  CHsmRule::NameToSearchName().

--*/
{
    HRESULT     hr = S_OK;
    int         length;
    int         i;

    try {

        WsbAssert(m_name != 0, E_POINTER);

        // These name alterations are copied from the NT FindFirstFileExW() code;
        // although the code had to be changed to work with the data structures that
        // are available.
        //
        // *.* -> *
        // ? -> DOS_QM
        // . followed by ? or * -> DOS_DOT
        // * followed by a . -> DOS_STAR

        if (_wcsicmp(m_name, OLESTR("*.*")) == 0) {
            m_searchName = OLESTR("*");
        } else {
            m_searchName = m_name;
            length = wcslen(m_searchName);

            for (i = 0; i < length; i++) {
                if ((i != 0) && (m_searchName[i] == L'.') && (m_searchName[i-1] == L'*')) {
                    m_searchName[i-1] = DOS_STAR;
                }

                if ((m_searchName[i] == L'?') || (m_searchName[i] == L'*')) {
                    if (m_searchName[i] == L'?') {
                        m_searchName[i] = DOS_QM;
                    }

                    if ((i != 0) && (m_searchName[i-1] == L'.')) {
                        m_searchName[i-1] = DOS_DOT;
                    }
                }
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CHsmRule::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_path));
        WsbAffirmHr(WsbSaveToStream(pStream, m_name));
        WsbAffirmHr(WsbSaveToStream(pStream, m_searchName));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isUserDefined));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isInclude));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isUsedInSubDirs));

        // Save off all the criteria.
        WsbAffirmHr(m_pCriteria->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRule::SetIsInclude(
    IN BOOL isInclude
    )
/*++

Implements:

  IHsmRule::SetIsInclude().

--*/
{
    m_isInclude = isInclude;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmRule::SetIsUserDefined(
    IN BOOL isUserDefined
    )
/*++

Implements:

  IHsmRule::SetIsUserDefined().

--*/
{
    m_isUserDefined = isUserDefined;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmRule::SetIsUsedInSubDirs(
    IN BOOL isUsed
    )
/*++

Implements:

  IHsmRule::SetIsUsedInSubDirs().

--*/
{
    m_isUsedInSubDirs = isUsed;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmRule::SetName(
    IN OLECHAR* name
    )
/*++

Implements:

  IHsmRule::SetName().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_name = name;
        WsbAffirmHr(NameToSearchName());
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::SetPath(
    IN OLECHAR* path
    )
/*++

Implements:

  IHsmRule::SetPath().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_path = path;
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmpolcy.h ===
#ifndef _HSMPOLCY_
#define _HSMPOLCY_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmrule.cpp

Abstract:

    This component represents a job's policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"


/*++

Class Name:
    
    CHsmPolicy

Class Description:

    This component represents a job's policy.

--*/

class CHsmPolicy : 
    public IHsmPolicy,
    public CWsbObject,
    public CComCoClass<CHsmPolicy,&CLSID_CHsmPolicy>
{
public:
    CHsmPolicy() {}
BEGIN_COM_MAP(CHsmPolicy)
    COM_INTERFACE_ENTRY(IHsmPolicy)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmPolicy)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmPolicy
public:
    STDMETHOD(CompareToIdentifier)(GUID id, SHORT* pResult);
    STDMETHOD(CompareToIPolicy)(IHsmPolicy* pPolicy, SHORT* pResult);
    STDMETHOD(EnumRules)(IWsbEnum** ppEnum);
    STDMETHOD(GetAction)(IHsmAction** ppAction);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetScale)(USHORT* pScale);
    STDMETHOD(Rules)(IWsbCollection** ppWsbCollection);
    STDMETHOD(SetAction)(IHsmAction* pAction);
    STDMETHOD(SetName)(OLECHAR* name);
    STDMETHOD(SetScale)(USHORT scale);
    STDMETHOD(SetUsesDefaultRules)(BOOL usesDefaults);
    STDMETHOD(UsesDefaultRules)(void);

protected:
    GUID                        m_id;
    CWsbStringPtr               m_name;
    USHORT                      m_scale;
    BOOL                        m_usesDefaultRules;
    CComPtr<IHsmAction>         m_pAction;
    CComPtr<IWsbCollection>     m_pRules;
};

#endif // _HSMPOLCY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmscan.h ===
#ifndef _HSMSCAN_
#define _HSMSCAN_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmscan.h

Abstract:

    This class represents a scanning process that is being carried out upon one FsaResource for
    a job.

Author:

    Chuck Bardeen   [cbardeen]   16-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "job.h"

extern DWORD HsmStartScanner(void* pVoid);


/*++

Class Name:
    
    CHsmScanner

Class Description:

    This class represents a scanning process that is being carried out upon one FsaResource for
    a job.

--*/

class CHsmScanner : 
    public CComObjectRoot,
    public IHsmSessionSinkEveryEvent,
    public IHsmScanner,
    public CComCoClass<CHsmScanner,&CLSID_CHsmScanner>
{
public:
    CHsmScanner() {}
BEGIN_COM_MAP(CHsmScanner)
    COM_INTERFACE_ENTRY(IHsmScanner)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryEvent)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmScanner)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// CHsmScanner
    STDMETHOD(Cancel)(HSM_JOB_EVENT event);
    STDMETHOD(LowerPriority)(void);
    STDMETHOD(DoIfMatches)(IFsaScanItem* pScanItem);
    STDMETHOD(Pause)(void);
    STDMETHOD(PopRules)(OLECHAR* path);
    STDMETHOD(RaisePriority)(void);
    STDMETHOD(PushRules)(OLECHAR* path);
    STDMETHOD(Resume)(void);
    STDMETHOD(ScanPath)(OLECHAR* path);
    STDMETHOD(SetState)(HSM_JOB_STATE state);
    STDMETHOD(StartScan)(void);

// IHsmSessionSinkEveryEvent
    STDMETHOD(ProcessSessionEvent)(IHsmSession* pSession, HSM_JOB_PHASE phase, HSM_JOB_EVENT event);

// IHsmScanner
public:
    STDMETHOD(Start)(IHsmSession* pSession, OLECHAR* path);

protected:
    CWsbStringPtr               m_startingPath;
    CWsbStringPtr               m_stoppingPath;
    CWsbStringPtr               m_currentPath;
    HSM_JOB_STATE               m_state;
    HSM_JOB_PRIORITY            m_priority;
    HANDLE                      m_threadHandle;
    HANDLE                      m_event;        // Event for suspend/resume
    DWORD                       m_threadId;
    HRESULT                     m_threadHr;
    BOOL                        m_skipHiddenItems;
    BOOL                        m_skipSystemItems;
    BOOL                        m_useRPIndex;
    BOOL                        m_useDbIndex;
    DWORD                       m_eventCookie;
    CComPtr<IHsmSession>        m_pSession;
    CComPtr<IFsaResource>       m_pResource;
    CComPtr<IHsmJob>            m_pJob;
    CComPtr<IWsbCollection>     m_pRuleStacks;
    CComPtr<IWsbEnum>           m_pEnumStacks;
};

#endif  // _HSMSCAN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmrlstk.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmrlstk.cpp

Abstract:

    This component represents the set of rules that are in effect for directory currently
    being scanned for one policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmrlstk.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmRuleStack::Do(
    IN IFsaScanItem* pScanItem
    )
/*++

Implements:

  IHsmRuleStack::Do().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRuleStack::Do"), OLESTR(""));

    try {
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(m_pAction != 0, E_UNEXPECTED);

        WsbAffirmHr(m_pAction->Do(pScanItem));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRuleStack::Do"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRuleStack::DoesMatch(
    IN IFsaScanItem* pScanItem,
    OUT BOOL* pShouldDo
    )
/*++

Implements:

  IHsmRuleStack::DoesMatch().

--*/
{
    HRESULT                 hr = S_OK;
    HRESULT                 hrNameMatch = S_OK;     // Used for event logging only
    CComPtr<IWsbEnum>       pEnumCriteria;
    CComPtr<IHsmRule>       pRule;
    CComPtr<IHsmCriteria>   pCriteria;
    BOOL                    isMatched = FALSE;
    BOOL                    ruleMatched = FALSE;    // Used for event logging only
    BOOL                    shouldCheck;
    CWsbStringPtr           name;
    CWsbStringPtr           path;
    CWsbStringPtr           rulePath;
    BOOL                    shouldDo = FALSE;

    WsbTraceIn(OLESTR("CHsmRuleStack::DoesMatch"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pShouldDo, E_POINTER);

        *pShouldDo = FALSE;

        // NOTE: The matching code starts at the bottom of the list and looks for
        // the first rule that matches. This makes it important how the list is organized.
        // Currently, the Push() method does not make any attempts to organize the list, so
        // it is up to whoever configure the rules in the policy definition to have it
        // organized properly. A proper order within a directory would be to have the specific
        // rules (i.e. no wildcards) after the wildcard rules (i.e. specific searched first).

        // Start we the last rule in the collection, and search upwards until a
        // rule is found that matches or all rules have been checked.
        WsbAffirmHr(pScanItem->GetName(&name, 0));
        hr = m_pEnumStackRules->Last(IID_IHsmRule, (void**) &pRule);

        while (SUCCEEDED(hr) && !isMatched) {

            try {

                shouldCheck = TRUE;
            
                // If the rule only applies to the directory it was defined in, then make
                // sure that the item is from that directory.
                if (pRule->IsUsedInSubDirs() == S_FALSE) {

                    // Unfortunately, these two paths differ by an appended \ when they
                    // are otherwise the same, so make them the same.
                    WsbAffirmHr(pScanItem->GetPath(&path, 0));

                    if ((wcslen(path) > 1) && (path[(int) (wcslen(path) - 1)] == L'\\')) {
                        path[(int) (wcslen(path) - 1)] = 0;
                    }

                    rulePath.Free();
                    WsbAffirmHr(pRule->GetPath(&rulePath, 0));

                    if ((wcslen(rulePath) > 1) && (rulePath[(int) (wcslen(rulePath) - 1)] == L'\\')) {
                        rulePath[(int) (wcslen(rulePath) - 1)] = 0;
                    }

                    if (_wcsicmp(path, rulePath) != 0) {
                        shouldCheck = FALSE;
                    }
                }

                if (shouldCheck) {

                    
                    // Does the name of the rule match the name of the file?
                    hrNameMatch = pRule->MatchesName(name);
                    WsbAffirmHrOk(hrNameMatch);
                    
                    ruleMatched = TRUE;
                    // Do the criteria match the attributes of the file?
                    isMatched = TRUE;
                    pEnumCriteria = 0;
                    WsbAffirmHr(pRule->EnumCriteria(&pEnumCriteria));
                    pCriteria = 0;
                    WsbAffirmHr(pEnumCriteria->First(IID_IHsmCriteria, (void**) &pCriteria));
                    
                    while (isMatched) {
                        HRESULT hrShouldDo;

                        hrShouldDo = pCriteria->ShouldDo(pScanItem, m_scale);
                        if (S_FALSE == hrShouldDo) {
                            isMatched = FALSE;
                        } else if (S_OK == hrShouldDo) {
                            pCriteria = 0;
                            WsbAffirmHr(pEnumCriteria->Next(IID_IHsmCriteria, (void**) &pCriteria));
                        } else {
                            WsbThrow(hrShouldDo);
                        }
                    }
                }

            } WsbCatchAndDo(hr, if (WSB_E_NOTFOUND == hr) {hr = S_OK;} else {isMatched = FALSE;});

            // If it didn't match, then try the next rule.
            if (SUCCEEDED(hr) && !isMatched) {
                pRule = 0;
                WsbAffirmHr(m_pEnumStackRules->Previous(IID_IHsmRule, (void**) &pRule));
            }
        }

        // Include rules mean that we should do the operation and exclude rules
        // mean that we should not.
        if (SUCCEEDED(hr)) {
            if (isMatched) {
                hr = S_OK;
                if (pRule->IsInclude() == S_OK) {
                    shouldDo = TRUE;
                }
            } else {
                hr = S_FALSE;
            }
        }
        
        
        if ((FALSE == shouldDo) && (FALSE == ruleMatched))  {
            //
            // Log that we skipped the file because it didn't
            // match a rule
            //
            CWsbStringPtr           jobName;
            CWsbStringPtr           fileName;
            CComPtr<IHsmSession>    pSession;
        
            pScanItem->GetFullPathAndName( 0, 0, &fileName, 0);
            pScanItem->GetSession(&pSession);
            pSession->GetName(&jobName, 0);
        
            WsbLogEvent(JOB_MESSAGE_SCAN_FILESKIPPED_NORULE, 0, NULL, (OLECHAR *)jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hrNameMatch), NULL);
        }
        
        

    *pShouldDo = shouldDo;

    } WsbCatchAndDo(hr, if (WSB_E_NOTFOUND == hr) {hr = S_FALSE;});

    WsbTraceOut(OLESTR("CHsmRuleStack::DoesMatch"), OLESTR("hr = <%ls>, shouldDo = <%ls>"), WsbHrAsString(hr), WsbBoolAsString(shouldDo));

    return(hr);
}


HRESULT
CHsmRuleStack::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_scale = HSM_JOBSCALE_100;
        m_usesDefaults = TRUE;

        //Create the criteria collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pRules));
        WsbAffirmHr(m_pRules->Enum(&m_pEnumStackRules));

    } WsbCatch(hr);
    
    return(hr);
}


HRESULT
CHsmRuleStack::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRuleStack::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmRuleStack;

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CHsmRuleStack::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmRuleStack::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CHsmRuleStack::GetSizeMax"), OLESTR(""));
    WsbTraceOut(OLESTR("CHsmRuleStack::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmRuleStack::Init(
    IN IHsmPolicy* pPolicy,
    IN IFsaResource* pResource
    )
/*++

Implements:

  IHsmRuleStack::Init().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pPolicy, E_POINTER);

        WsbAffirmHr(pPolicy->GetScale(&m_scale));
        WsbAffirmHr(pPolicy->GetAction(&m_pAction));
        WsbAffirmHr(pPolicy->EnumRules(&m_pEnumPolicyRules));

        if (pPolicy->UsesDefaultRules() == S_OK) {
            m_usesDefaults = TRUE;
        } else {
            m_usesDefaults = FALSE;
        }

        m_pPolicy = pPolicy;

        WsbAffirmHr(pResource->EnumDefaultRules(&m_pEnumDefaultRules));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRuleStack::Load(
    IN IStream* /*pStream*/
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CHsmRuleStack::Load"), OLESTR(""));
    WsbTraceOut(OLESTR("CHsmRuleStack::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRuleStack::Pop(
    IN OLECHAR* path
    )
/*++

Implements:

  IHsmRuleStack::Pop().

--*/
{
    HRESULT             hr = S_OK;
    CWsbStringPtr       rulePath;
    CComPtr<IHsmRule>   pRule;

    WsbTraceIn(OLESTR("CHsmRuleStack::Pop"), OLESTR(""));

    try {

        WsbAssert(0 != path, E_POINTER);

        // Starting at the end of the list, remove any rules that have the same
        // path as the one specified.
        WsbAffirmHr(m_pEnumStackRules->Last(IID_IHsmRule, (void**) &pRule));
        WsbAffirmHr(pRule->GetPath(&rulePath, 0));

        while(_wcsicmp(path, rulePath) == 0) {
            WsbAffirmHr(m_pRules->RemoveAndRelease(pRule));
            pRule = 0;
            WsbAffirmHr(m_pEnumStackRules->Last(IID_IHsmRule, (void**) &pRule));
            rulePath.Free();
            WsbAffirmHr(pRule->GetPath(&rulePath, 0));
        }

    } WsbCatchAndDo(hr, if (WSB_E_NOTFOUND == hr) {hr = S_OK;});

    WsbTraceOut(OLESTR("CHsmRuleStack::Pop"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRuleStack::Push(
    IN OLECHAR* path
    )
/*++

Implements:

  IHsmRuleStack::Push().

--*/
{
    HRESULT                         hr = S_OK;
    CWsbStringPtr                   rulePath;
    CComPtr<IHsmRule>               pRule;
    CComPtr<IWsbIndexedCollection>  pCollection;

    WsbTraceIn(OLESTR("CHsmRuleStack::Push"), OLESTR(""));

    try {

        WsbAssert(0 != path, E_POINTER);

        // We need to preserve the order of the rules, so use the indexed collection interface.
        WsbAffirmHr(m_pRules->QueryInterface(IID_IWsbIndexedCollection, (void**) &pCollection));

        // Add any policy rules for this directory to the stack.
        //
        // NOTE: We may want to add some code to check for exclusion rules of the
        // entire directory (with no subdirectory inclusions and return the
        // JOB_E_DIREXCLUDED error to skip scanning of the directory.
        //
        // NOTE: It might be nice if the policy rules were a sorted collection to
        // speed up processing.
        hr = m_pEnumPolicyRules->First(IID_IHsmRule, (void**) &pRule);
        
        while (SUCCEEDED(hr)) {

            rulePath.Free();
            WsbAffirmHr(pRule->GetPath(&rulePath, 0));
            if (_wcsicmp(path, rulePath) == 0) {
                WsbAffirmHr(pCollection->Append(pRule));
                WsbTrace(OLESTR("CHsmRuleStack::Push - Using policy rule <%ls>.\n"), (OLECHAR *)rulePath);
                
            }

            pRule = 0;
            hr = m_pEnumPolicyRules->Next(IID_IHsmRule, (void**) &pRule);
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

        // Add any default rules for this directory to the stack.
        if (m_usesDefaults) {

            hr = m_pEnumDefaultRules->First(IID_IHsmRule, (void**) &pRule);
            
            while (SUCCEEDED(hr)) {

                rulePath.Free();
                WsbAffirmHr(pRule->GetPath(&rulePath, 0));
                if (_wcsicmp(path, rulePath) == 0) {
                    WsbAffirmHr(pCollection->Append(pRule));
                    WsbTrace(OLESTR("CHsmRuleStack::Push -- Using default rule <%ls>.\n"), (OLECHAR *)rulePath);
                }

                pRule = 0;
                hr = m_pEnumDefaultRules->Next(IID_IHsmRule, (void**) &pRule);
            }
        } else  {
            WsbTrace(OLESTR("CHsmRuleStack::Push -- Not using default rules.\n"));
            
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRuleStack::Push"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}


HRESULT
CHsmRuleStack::Save(
    IN IStream* /*pStream*/,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CHsmRuleStack::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    WsbTraceOut(OLESTR("CHsmRuleStack::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRuleStack::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmscan.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsascan.cpp

Abstract:

    This class represents a scanning process that is being carried out upon one FsaResource.

Author:

    Chuck Bardeen   [cbardeen]   16-Feb-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "hsmscan.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB



DWORD HsmStartScanner(
    void* pVoid
    )

/*++


--*/
{
    return(((CHsmScanner*) pVoid)->StartScan());
}




HRESULT
CHsmScanner::Cancel(
    HSM_JOB_EVENT       event
    )

/*++

Implements:

  IHsmScanner::Cancel().

--*/
{
    HRESULT                 hr = S_OK;

    try {

        // If we have started, but haven't finished, then change the state of the job. The thread
        // will exit on it's own.
        if ((HSM_JOB_STATE_IDLE != m_state) &&
            (HSM_JOB_STATE_DONE != m_state) &&
            (HSM_JOB_STATE_FAILED != m_state) &&
            (HSM_JOB_STATE_CANCELLED != m_state)) {

            if (HSM_JOB_EVENT_CANCEL == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_CANCELLED));
            } else if (HSM_JOB_EVENT_SUSPEND == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_SUSPENDED));
            } else if (HSM_JOB_EVENT_FAIL == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_FAILED));
            } else {
                WsbAssert(FALSE, E_UNEXPECTED);
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmScanner::DoIfMatches(
    IN IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmScanner::DoIfMatches().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hrDo = S_OK;
    HRESULT                     hrShould = S_OK;
    BOOL                        notMatched = TRUE;
    BOOL                        shouldDo = FALSE;
    CComPtr<IHsmRuleStack>      pRuleStack;

    WsbTraceIn(OLESTR("CFsaScanner::DoIfMatches"), OLESTR(""));

    try {

        // Each policy has it's own rule stack, check each one of until a match is found (if
        // one exists).
        WsbAffirmHr(m_pEnumStacks->First(IID_IHsmRuleStack, (void**) &pRuleStack));
        
        while (notMatched) {

            hr = pRuleStack->DoesMatch(pScanItem, &shouldDo);

            if (S_OK == hr) {
                notMatched = FALSE;
                if (!shouldDo) {
                    hrShould = JOB_E_FILEEXCLUDED;
                }
            } else if (S_FALSE == hr) {
                pRuleStack = 0;
                WsbAffirmHr(m_pEnumStacks->Next(IID_IHsmRuleStack, (void**) &pRuleStack));
            } else {
                //  Something totally unexpected happened so we'd better quit
                WsbThrow(hr);
            }
        }

    } WsbCatchAndDo(hr,

        if (WSB_E_NOTFOUND == hr) {
            hrShould = JOB_E_DOESNTMATCH;
            hr = S_OK;
        } else {
            hrShould = hr;
        }

    );

    // Just Do It!!
    if (SUCCEEDED(hr) && shouldDo) {

        hrDo = pRuleStack->Do(pScanItem);

        // Tell the session if we ended up skipping the file or not.
        m_pSession->ProcessItem(HSM_JOB_PHASE_SCAN, HSM_JOB_ACTION_SCAN, pScanItem, hrDo);  

    } else {

        // Tell the session if we decided to skip the file.
        m_pSession->ProcessItem(HSM_JOB_PHASE_SCAN, HSM_JOB_ACTION_SCAN, pScanItem, hrShould);  
    }

    WsbTraceOut(OLESTR("CFsaScanner::DoIfMatches"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
#pragma optimize("g", off)

HRESULT
CHsmScanner::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT                     hr = S_OK;
    
    try {

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        m_state = HSM_JOB_STATE_IDLE;
        m_priority = HSM_JOB_PRIORITY_NORMAL;
        m_threadHandle = 0;
        m_threadId = 0;
        m_threadHr = S_OK;
        m_eventCookie = 0;
        m_skipHiddenItems = TRUE;
        m_skipSystemItems = TRUE;
        m_useRPIndex = FALSE;
        m_useDbIndex = FALSE;
        m_event = 0;

        // Create a collection for the rule stacks, and store an enumerator to it.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pRuleStacks));
        WsbAffirmHr(m_pRuleStacks->Enum(&m_pEnumStacks));

    } WsbCatch(hr);

    return(hr);
}
#pragma optimize("", on)

void
CHsmScanner::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT                     hr = S_OK;
    
    // Cleanup the thread we were using.
    if (m_threadHandle != 0) {
        m_state = HSM_JOB_STATE_DONE;
        
        if (0 != m_event) {
            SetEvent(m_event);
        }

        //  Should we wait for the thread to end?
        CloseHandle(m_threadHandle);
        m_threadHandle = 0;
    }
    if (m_event) {
        CloseHandle(m_event);
        m_event = 0;
    }

    CComObjectRoot::FinalRelease();
}


HRESULT
CHsmScanner::LowerPriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    try {

        WsbAssert(0 != m_threadHandle, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_priority) {
            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_IDLE));
                m_priority = HSM_JOB_PRIORITY_IDLE;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_LOWEST));
                m_priority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_BELOW_NORMAL));
                m_priority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_NORMAL));
                m_priority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_ABOVE_NORMAL));
                m_priority = HSM_JOB_PRIORITY_HIGH;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_HIGHEST));
                m_priority = HSM_JOB_PRIORITY_HIGHEST;
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(HSM_JOB_PHASE_SCAN, m_priority));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmScanner::Pause(
    void
    )

/*++

Implements:

  IHsmScanner::Pause().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanner::Pause"), OLESTR(""));

//    Lock();
    try {

        // If we are running, then suspend the thread.
        WsbAssert((HSM_JOB_STATE_STARTING == m_state) || (HSM_JOB_STATE_ACTIVE == m_state) 
                || (HSM_JOB_STATE_RESUMING == m_state), E_UNEXPECTED);

        //  Set state to pausing -- the thread will pause itself when it
        //  sees the state
        WsbAffirmHr(SetState(HSM_JOB_STATE_PAUSING));

    } WsbCatch(hr);
//    Unlock();

    WsbTraceOut(OLESTR("CFsaScanner::Pause"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmScanner::PopRules(
    IN OLECHAR* path
    )

/*++

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmRuleStack>  pRuleStack;

    try {

        // Each policy has it's own rule stack, and each of them will need to have rules removed
        // from it for this directory (if any rules were added).
        for (hr =  m_pEnumStacks->First(IID_IHsmRuleStack, (void**) &pRuleStack);
             SUCCEEDED(hr);
             hr =  m_pEnumStacks->Next(IID_IHsmRuleStack, (void**) &pRuleStack)) {

            WsbAffirmHr(pRuleStack->Pop(path));
            pRuleStack = 0;
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);
        
    return(hr);
}


HRESULT
CHsmScanner::ProcessSessionEvent(
    IN IHsmSession* pSession,
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_EVENT event
    )

/*++

--*/
{
    HRESULT         hr = S_OK;

    try {
        
        WsbAssert(0 != pSession, E_POINTER);

        // If the phase applies to use (SCAN or ALL), then do any work required by the
        // event.
        if ((HSM_JOB_PHASE_ALL == phase) || (HSM_JOB_PHASE_SCAN == phase)) {

            switch(event) {

                case HSM_JOB_EVENT_SUSPEND:
                case HSM_JOB_EVENT_CANCEL:
                case HSM_JOB_EVENT_FAIL:
                    WsbAffirmHr(Cancel(event));
                    break;

                case HSM_JOB_EVENT_PAUSE:
                    WsbAffirmHr(Pause());
                    break;

                case HSM_JOB_EVENT_RESUME:
                    WsbAffirmHr(Resume());
                    break;

                case HSM_JOB_EVENT_RAISE_PRIORITY:
                    WsbAffirmHr(RaisePriority());
                    break;

                case HSM_JOB_EVENT_LOWER_PRIORITY:
                    WsbAffirmHr(LowerPriority());
                    break;

                default:
                case HSM_JOB_EVENT_START:
                    WsbAssert(FALSE, E_UNEXPECTED);
                    break;
            }
        }

    } WsbCatch(hr);

    return(S_OK);
}


HRESULT
CHsmScanner::PushRules(
    IN OLECHAR* path
    )

/*++

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmRuleStack>  pRuleStack;

    try {

        // Save an indicator to where we are in the scan, so we can use it if we are interrupted
        // or need to give an indication to the session.
        m_currentPath = path;

        // Each policy has it's own rule stack, and each of them will need to have rules added
        // for this directory (if any rules exist).
        for (hr =  m_pEnumStacks->First(IID_IHsmRuleStack, (void**) &pRuleStack);
             SUCCEEDED(hr);
             hr =  m_pEnumStacks->Next(IID_IHsmRuleStack, (void**) &pRuleStack)) {

            WsbAffirmHr(pRuleStack->Push(path));
            pRuleStack = 0;
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }
        
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmScanner::RaisePriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    try {

        WsbAssert(0 != m_threadHandle, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_priority) {

            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_LOWEST));
                m_priority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_BELOW_NORMAL));
                m_priority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_NORMAL));
                m_priority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_ABOVE_NORMAL));
                m_priority = HSM_JOB_PRIORITY_HIGH;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_HIGHEST));
                m_priority = HSM_JOB_PRIORITY_HIGHEST;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_TIME_CRITICAL));
                m_priority = HSM_JOB_PRIORITY_CRITICAL;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(HSM_JOB_PHASE_SCAN, m_priority));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmScanner::Resume(
    void
    )

/*++

Implements:

  IHsmScanner::Resume().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;

    WsbTraceIn(OLESTR("CFsaScanner::Resume"), OLESTR(""));

//    Lock();
    try {

        // If we are paused, then suspend the thread.
        WsbAffirm((HSM_JOB_STATE_PAUSING == m_state) || (HSM_JOB_STATE_PAUSED == m_state), E_UNEXPECTED);

        oldState = m_state;
        WsbAffirmHr(SetState(HSM_JOB_STATE_RESUMING));

        // If we are unable to resume, then return to the former state.
        try {
            WsbAffirm(SetEvent(m_event), HRESULT_FROM_WIN32(GetLastError()));
        } WsbCatchAndDo(hr, SetState(oldState););

    } WsbCatch(hr);
//    Unlock();

    WsbTraceOut(OLESTR("CFsaScanner::Resume"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmScanner::ScanPath(
    IN OLECHAR* dirPath
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaScanItem>   pScanItem;
    CWsbStringPtr           searchPath;

    WsbTraceIn(OLESTR("CFsaScanner::ScanPath"), OLESTR("%ls"), WsbAbbreviatePath(dirPath, WSB_TRACE_BUFF_SIZE));

    try {

        WsbAssert(0 != dirPath, E_POINTER);
        WsbAssert(0 != dirPath[0], E_INVALIDARG);

        // Pop the rules for this files. This sets the context for the scan to follow.
        WsbAffirmHr(PushRules(dirPath));

        try {

            // Iterate over all the files and directories in the specified path.
            searchPath = dirPath;
            if (searchPath[(int) (wcslen(searchPath) - 1)] == L'\\') {
                WsbAffirmHr(searchPath.Append("*"));
            } else {
                WsbAffirmHr(searchPath.Append("\\*"));
            }

            if (m_useDbIndex) {
                hr = m_pResource->FindFirstInDbIndex(m_pSession, &pScanItem);
            } else if (m_useRPIndex) {
                hr = m_pResource->FindFirstInRPIndex(m_pSession, &pScanItem);
            } else {
                hr = m_pResource->FindFirst(searchPath, m_pSession, &pScanItem);
            }
            while (SUCCEEDED(hr) && ((HSM_JOB_STATE_ACTIVE == m_state) || 
                    (HSM_JOB_STATE_RESUMING == m_state) ||
                    (HSM_JOB_STATE_PAUSING == m_state))) {
            
                //  Check for a pause request
//                Lock();
                if (HSM_JOB_STATE_PAUSING == m_state) {
                    hr = SetState(HSM_JOB_STATE_PAUSED);
//                    Unlock();
                    WsbAffirmHr(hr);

                    //  Suspend the thread here & wait for resume signal
                    WsbTrace(OLESTR("CHsmScanner::ScanPath: pausing\n"));
                    WaitForSingleObject(m_event, 0xffffffff);
                    WsbTrace(OLESTR("CHsmScanner::ScanPath: woke up, state = %d\n"),
                            (int)m_state);

//                    Lock();
                    if (HSM_JOB_STATE_RESUMING != m_state) {
//                        Unlock();
                        break;
                    }
                    hr = SetState(HSM_JOB_STATE_ACTIVE);
                    if (S_OK != hr) {
//                        Unlock();
                        WsbThrow(hr);
                    }
                }
//                Unlock();

                // Skip hidden and/or system items if so configured.
                if (!((m_skipHiddenItems && (pScanItem->IsHidden() == S_OK)) ||
                      (m_skipSystemItems && (pScanItem->IsSystem() == S_OK)))) {

                    // Ignore ".", "..", symbolic links and mount points.
                    if ((pScanItem->IsARelativeParent() == S_FALSE) &&
                        (pScanItem->IsALink() == S_FALSE))  {

                        // Recursively scan subdirectories.
                        if (pScanItem->IsAParent() == S_OK)  {
                            WsbAffirmHr(pScanItem->GetPathAndName(OLESTR(""), &searchPath, 0));
                            WsbAffirmHr(ScanPath(searchPath));
                        }

                        // If this file matches a policy then perform the action.
                        else {
                            WsbAffirmHr(DoIfMatches(pScanItem));
                        }
                    } else {
                        WsbTrace(OLESTR("CHsmScanner::ScanPath  skipping - symbolic link, '.', or '..'\n"));
                    }
                } else {
                    WsbTrace(OLESTR("CHsmScanner::ScanPath  skipping - hidden/system\n"));
                }
                if (m_useDbIndex) {
                    hr = m_pResource->FindNextInDbIndex(pScanItem);
                } else if (m_useRPIndex) {
                    hr = m_pResource->FindNextInRPIndex(pScanItem);
                } else {
                    hr = m_pResource->FindNext(pScanItem);
                }
            }

            // If we broke out as a result of end of scan or some other error ...
            if (hr != S_OK) {
                WsbAssert(hr == WSB_E_NOTFOUND, hr);
                hr = S_OK;
            }

        } WsbCatch(hr);

        // Pop the rules for this directory. This restores the context as we pop back up the directory
        // structure.
        WsbAffirmHr(PopRules(dirPath));

    } WsbCatchAndDo(hr, if (JOB_E_DIREXCLUDED == hr) {hr = S_OK;});

    WsbTraceOut(OLESTR("CFsaScanner::ScanPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmScanner::SetState(
    IN HSM_JOB_STATE state
    )

/*++

--*/
{
    HRESULT         hr = S_OK;
    BOOL            bLog = TRUE;

    WsbTraceIn(OLESTR("CFsaScanner::SetState"), OLESTR("old state = %d, new state = %d"),
            (int)m_state, (int)state);

//    Lock();
    try {

        // Change the state and report the change to the session.
        m_state = state;
        WsbAffirmHr(m_pSession->ProcessState(HSM_JOB_PHASE_SCAN, m_state, m_currentPath, bLog));

    } WsbCatch(hr);
//    Unlock();

    WsbTraceOut(OLESTR("CFsaScanner::SetState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmScanner::Start(
    IN IHsmSession* pSession,
    IN OLECHAR* path
    )

/*++

Implements:

  IHsmScanner::Start().

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IHsmJobDef>                 pDef;
    CComPtr<IHsmPolicy>                 pPolicy;
    CComPtr<IHsmRuleStack>              pRuleStack;
    CComPtr<IWsbEnum>                   pEnumPolicies;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;
    CComPtr<IHsmSessionSinkEveryEvent>  pSink;
    DWORD                               cookie;

    try {

        // Make sure that we were given a session, and that we haven't started already.
        WsbAssert(0 != pSession, E_POINTER);
        WsbAssert(HSM_JOB_STATE_IDLE == m_state, E_UNEXPECTED);

        // Store off the session.
        m_pSession = pSession;

        // If no directory was specified, then start in the root of the resource.
        if ((0 != path) && (0 != *path))  {
            m_startingPath = path;
        } else {
            m_startingPath = OLESTR("\\");
        }

        m_currentPath = m_startingPath;

        // Tell them we are starting.
        WsbAffirmHr(SetState(HSM_JOB_STATE_STARTING));

        // Create an event to control pause/resume for the scan.
        if (0 == m_event) {
            CWsbStringPtr       nameString;
            GUID                id;
            
            WsbAffirmHr(m_pSession->GetIdentifier(&id));
            nameString = id;
            nameString.Prepend(OLESTR("Scanner Pause and Resume Event for session "));
            m_event = CreateEvent(NULL, FALSE, FALSE, nameString);
        }
        
        // Ask the session to advise of every event.
        WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
        WsbAffirmHr(((IUnknown*) (IHsmScanner*) this)->QueryInterface(IID_IHsmSessionSinkEveryEvent, (void**) &pSink));
        WsbAffirmHr(pCP->Advise(pSink, &cookie));

        // Store off the information needed to latter unadvise.
        m_eventCookie = cookie;

        try {
            // Locate the resource that is being scanned.
            WsbAffirmHr(m_pSession->GetResource(&m_pResource));

            // Create and initialize a rule stack for each policy.
            WsbAffirmHr(pSession->GetJob(&m_pJob));
            WsbAffirmHr(m_pJob->GetDef(&pDef));
            WsbAffirmHr(pDef->EnumPolicies(&pEnumPolicies));

            for (hr =  pEnumPolicies->First(IID_IHsmPolicy, (void**) &pPolicy);
                 SUCCEEDED(hr);
                 hr =  pEnumPolicies->Next(IID_IHsmPolicy, (void**) &pPolicy)) {

                WsbAffirmHr(CoCreateInstance(CLSID_CHsmRuleStack, NULL, CLSCTX_ALL, IID_IHsmRuleStack, (void**) &pRuleStack));
                WsbAffirmHr(pRuleStack->Init(pPolicy, m_pResource));
                WsbAffirmHr(m_pRuleStacks->Add(pRuleStack));

                pRuleStack = 0;
                pPolicy = 0;
            }

            if (WSB_E_NOTFOUND == hr) {
                hr = S_OK;
            }

            // Determine whether hidden and system items should be skipped?
            if (pDef->SkipHiddenItems() == S_FALSE) {
                m_skipHiddenItems = FALSE;
            }

            if (pDef->SkipSystemItems() == S_FALSE) {
                m_skipSystemItems = FALSE;
            }

            // Determine whether to use the Reparse Point Index for the scan?
            if (pDef->UseRPIndex() == S_OK) {
                m_useRPIndex = TRUE;
            }
            // Determine whether to use the Database Index for the scan?
            if (pDef->UseDbIndex() == S_OK) {
                m_useDbIndex = TRUE;
            }

            try {
            
                // Now that we have prepared, create the thread that will do the scanning!
                WsbAffirm((m_threadHandle = CreateThread(0, 0, HsmStartScanner, (void*) this, 0, &m_threadId)) != 0, HRESULT_FROM_WIN32(GetLastError()));

            } WsbCatchAndDo(hr, SetState(HSM_JOB_STATE_FAILED););

            if (FAILED(hr)) {
                WsbThrow(hr);
            }

        } WsbCatchAndDo(hr,
            pCP->Unadvise(m_eventCookie);
            m_eventCookie = 0;
        );

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmScanner::StartScan(
    void
    )

/*++


--*/
{
    HRESULT                             hr = S_OK;
    HRESULT                             hr2 = S_OK;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;

    WsbTraceIn(OLESTR("CFsaScanner::StartScan"), OLESTR(""));

    try {
        CComPtr<IFsaTruncator>                  pTruncator;
        CComPtr<IHsmSession>                    pTruncatorSession;

        CComPtr<IHsmJobDef>                     pDef;
        CComPtr<IHsmActionOnResourcePreScan>    pActionPreScan;

        // The thread is running.
        WsbAffirmHr(SetState(HSM_JOB_STATE_ACTIVE));

        // To avoid having the RP Index order changed by the truncator,
        // we pause the truncator
        if (m_useRPIndex) {
            WsbAffirmHr(m_pResource->GetTruncator(&pTruncator));
            if (pTruncator) {
                WsbAffirmHr(pTruncator->GetSession(&pTruncatorSession));
                if (pTruncatorSession) {
                    WsbAffirmHr(pTruncatorSession->ProcessEvent(HSM_JOB_PHASE_ALL, 
                        HSM_JOB_EVENT_PAUSE));
                }
            }
        }

        // Get the pre-scan action and do it (if exists)
        WsbAffirmHr(m_pJob->GetDef(&pDef));
        WsbAffirmHr(pDef->GetPreScanActionOnResource(&pActionPreScan));
        if (pActionPreScan) {
            WsbTrace(OLESTR("CHsmScanner::StartScan: doing pre-scan action\n"));

            //Don't throw hr - we need the cleanup code that is done after the scanning
            hr = pActionPreScan->Do(m_pResource, m_pSession);
        }

        // Start with the first path and scan the resource (only if pre-scan succeeded)
        if (SUCCEEDED(hr)) {
            m_threadHr = ScanPath(m_startingPath);
        }

        // Resume the truncator if we paused it
        if (pTruncatorSession) {
            pTruncatorSession->ProcessEvent(HSM_JOB_PHASE_ALL, 
                HSM_JOB_EVENT_RESUME);
        }

        // Clear out the information about the thread;
        WsbAffirmStatus(CloseHandle(m_threadHandle));
        m_threadId = 0;
        m_threadHandle = 0;

    } WsbCatch(hr);

    // The thread is exiting, so record
    if (FAILED(hr) || FAILED(m_threadHr)) {
        hr2 = SetState(HSM_JOB_STATE_FAILED);
        if (FAILED(hr2)) {
            m_pSession->ProcessHr(HSM_JOB_PHASE_ALL, __FILE__, __LINE__, hr2);
        }
    } else {
        hr2 = SetState(HSM_JOB_STATE_DONE);
        if (FAILED(hr2)) {
            m_pSession->ProcessHr(HSM_JOB_PHASE_ALL, __FILE__, __LINE__, hr2);
        }
    }


    // Regardless of how this thread is exiting, we need to unadvise from the session.
    // Indicate that we no longer want to be advised of events.
    if ((m_pSession != 0) && (m_eventCookie != 0)) {
        try {
            WsbAffirmHr(m_pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            pCP->Unadvise(m_eventCookie);
        } WsbCatch(hr);
    }

    WsbTraceOut(OLESTR("CFsaScanner::StartScan"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmrule.h ===
#ifndef _HSMRULE_
#define _HSMRULE_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmrule.cpp

Abstract:

    This component represents a rule for a job's policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"


/*++

Class Name:
    
    CHsmRule

Class Description:

    This component represents a rule for a job's policy.

--*/

class CHsmRule : 
    public IHsmRule,
    public CWsbObject,
    public CComCoClass<CHsmRule,&CLSID_CHsmRule>
{
public:
    CHsmRule() {}
BEGIN_COM_MAP(CHsmRule)
    COM_INTERFACE_ENTRY(IHsmRule)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmRule)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// CHsmRule
    STDMETHOD(DoesNameContainWildcards)(OLECHAR* name);
    STDMETHOD(IsNameInExpression)(OLECHAR* expression, OLECHAR* name, BOOL ignoreCase);
    STDMETHOD(IsNameInExpressionGuts)(OLECHAR* expression, USHORT expresionLength, OLECHAR* name, USHORT nameLength, BOOL ignoreCase);
    STDMETHOD(NameToSearchName)(void);

// IHsmRule
public:
    STDMETHOD(CompareToIRule)(IHsmRule* pRule, SHORT* pResult);
    STDMETHOD(CompareToPathAndName)(OLECHAR* path, OLECHAR* name, SHORT* pResult);
    STDMETHOD(Criteria)(IWsbCollection** ppWsbCollection);
    STDMETHOD(EnumCriteria)(IWsbEnum** ppEnum);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetSearchName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(IsInclude)(void);
    STDMETHOD(IsUsedInSubDirs)(void);
    STDMETHOD(IsUserDefined)(void);
    STDMETHOD(MatchesName)(OLECHAR* name);
    STDMETHOD(SetIsInclude)(BOOL isIncluded);
    STDMETHOD(SetIsUsedInSubDirs)(BOOL isUsed);
    STDMETHOD(SetIsUserDefined)(BOOL isUserDefined);
    STDMETHOD(SetName)(OLECHAR* name);
    STDMETHOD(SetPath)(OLECHAR* path);

protected:
    CWsbStringPtr           m_name;
    CWsbStringPtr           m_searchName;
    CWsbStringPtr           m_path;
    BOOL                    m_isInclude;
    BOOL                    m_isUserDefined;
    BOOL                    m_isUsedInSubDirs;
    CComPtr<IWsbCollection> m_pCriteria;
};

#endif // _HSMRULE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmsess.h ===
#ifndef _HSMSESS_
#define _HSMSESS_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsess.h

Abstract:

    This module contains the session component. The session is the collator of information for the work being done on
    a resource (for a job, demand recall, truncate, ...).

Author:

    Chuck Bardeen   [cbardeen]   18-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "fsa.h"
#include "job.h"

/*++

Class Name:
    
    CHsmSession

Class Description:

    The session is the collator of information for the work being done on a resource (for a job, demand recall,
    truncate, ...).

--*/

class CHsmSession : 
    public CWsbObject,
    public IHsmSession,
    public CComCoClass<CHsmSession,&CLSID_CHsmSession>,
    public IConnectionPointContainerImpl<CHsmSession>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkEveryEvent, CComDynamicUnkArray>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkEveryItem, CComDynamicUnkArray>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkEveryMediaState, CComDynamicUnkArray>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkEveryPriority, CComDynamicUnkArray>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkEveryState, CComDynamicUnkArray>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkSomeItems, CComDynamicUnkArray>
{
public:
    CHsmSession() {} 

BEGIN_COM_MAP(CHsmSession)
    COM_INTERFACE_ENTRY(IHsmSession)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()
                        
BEGIN_CONNECTION_POINT_MAP(CHsmSession)
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkEveryEvent) 
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkEveryItem) 
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkEveryMediaState) 
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkEveryPriority) 
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkEveryState) 
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkSomeItems) 
END_CONNECTION_POINT_MAP()
                        
DECLARE_REGISTRY_RESOURCEID(IDR_CHsmSession)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// CHsmSession
    STDMETHOD(AdviseOfEvent)(HSM_JOB_PHASE phase, HSM_JOB_EVENT event);
    STDMETHOD(AdviseOfItem)(IHsmPhase* pPhase, IFsaScanItem* pScanItem, HRESULT hrItem, IHsmSessionTotals* pSessionTotals);
    STDMETHOD(AdviseOfMediaState)(IHsmPhase* pPhase, HSM_JOB_MEDIA_STATE state, OLECHAR* mediaName, HSM_JOB_MEDIA_TYPE mediaType, ULONG time);
    STDMETHOD(AdviseOfPriority)(IHsmPhase* pPhase);
    STDMETHOD(AdviseOfState)(IHsmPhase* pPhase, OLECHAR* currentPath);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmSession
public:
    STDMETHOD(Cancel)(HSM_JOB_PHASE phase);
    STDMETHOD(EnumPhases)(IWsbEnum** ppEnum);
    STDMETHOD(EnumTotals)(IWsbEnum** ppEnum);
    STDMETHOD(GetAdviseInterval)(LONGLONG* pFiletimeTicks);
    STDMETHOD(GetHsmId)(GUID* pId);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetJob)(IHsmJob** pJob);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetResource)(IFsaResource** pResource);
    STDMETHOD(GetRunId)(ULONG* pRunId);
    STDMETHOD(GetSubRunId)(ULONG* pRunId);
    STDMETHOD(IsCanceling)(void);
    STDMETHOD(Pause)(HSM_JOB_PHASE phase);
    STDMETHOD(ProcessEvent)(HSM_JOB_PHASE phase, HSM_JOB_EVENT event);
    STDMETHOD(ProcessHr)(HSM_JOB_PHASE phase, CHAR* file, ULONG line, HRESULT hr);
    STDMETHOD(ProcessItem)(HSM_JOB_PHASE phase, HSM_JOB_ACTION action, IFsaScanItem* pScanItem, HRESULT hrItem);  
    STDMETHOD(ProcessMediaState)(HSM_JOB_PHASE phase, HSM_JOB_MEDIA_STATE state, OLECHAR* mediaName, HSM_JOB_MEDIA_TYPE mediaType, ULONG time);
    STDMETHOD(ProcessPriority)(HSM_JOB_PHASE phase, HSM_JOB_PRIORITY priority);
    STDMETHOD(ProcessState)(HSM_JOB_PHASE phase, HSM_JOB_STATE state, OLECHAR* currentPath, BOOL bLog);
    STDMETHOD(ProcessString)(HSM_JOB_PHASE phase, OLECHAR* string);
    STDMETHOD(Resume)(HSM_JOB_PHASE phase);
    STDMETHOD(SetAdviseInterval)(LONGLONG filetimeTicks);
    STDMETHOD(Start)(OLECHAR* name, ULONG logControl, GUID hsmId, IHsmJob* pJob, IFsaResource* pResource, ULONG runId, ULONG subRunId);  
    STDMETHOD(Suspend)(HSM_JOB_PHASE phase);

protected:
    GUID                        m_id;
    CWsbStringPtr               m_name;
    GUID                        m_hsmId;
    LONGLONG                    m_adviseInterval;
    ULONG                       m_runId;
    ULONG                       m_subRunId;
    FILETIME                    m_lastAdviseFile;
    HSM_JOB_STATE               m_state;
    ULONG                       m_activePhases;
    ULONG                       m_logControl;
    CComPtr<IHsmJob>            m_pJob;
    CComPtr<IFsaResource>       m_pResource;
    CComPtr<IWsbCollection>     m_pPhases;
    CComPtr<IWsbCollection>     m_pTotals;
    BOOL                        m_isCanceling;
};

#endif // _HSMSESS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmsesst.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsesst.cpp

Abstract:

    This class is the session totals component, which keeps track of totals for a session
    on a per action basis.

Author:

    Chuck Bardeen   [cbardeen]   14-Feb-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmsesst.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCount = 0;


HRESULT
CHsmSessionTotals::AddItem(
    IN IFsaScanItem* pItem,
    IN HRESULT hrItem
    )

/*++

Implements:

  IHsmSessionTotalsPriv::AddItem().

--*/
{
    HRESULT                 hr = S_OK;
    LONGLONG                size;

    WsbTraceIn(OLESTR("CHsmSessionTotals::AddItem"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pItem, E_POINTER);

        // Get the size of the file.
        WsbAffirmHr(pItem->GetLogicalSize(&size));

        // Update the appropriate statistics.
        switch (hrItem) {
            case S_OK:
                m_items++;
                m_size += size;
                break;
            case S_FALSE:
            case JOB_E_FILEEXCLUDED:
            case JOB_E_DOESNTMATCH:
            case FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED:
            case HSM_E_FILE_CHANGED:
            case HSM_E_WORK_SKIPPED_FILE_TOO_BIG:
                m_skippedItems++;
                m_skippedSize += size;
                break;
            default:
                m_errorItems++;
                m_errorSize += size;
                break;
        }
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::AddItem"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::Clone(
    OUT IHsmSessionTotals** ppSessionTotals
    )

/*++

Implements:

  IHsmSessionTotals::Clone().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSessionTotals>  pSessionTotals;

    WsbTraceIn(OLESTR("CHsmSessionTotals::Clone"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != ppSessionTotals, E_POINTER);
        *ppSessionTotals = 0;

        // Create the new instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSessionTotals, 0, CLSCTX_ALL, IID_IHsmSessionTotals, (void**) &pSessionTotals));

        // Fill it in with the new values.
        WsbAffirmHr(CopyTo(pSessionTotals));

        // Return it to the caller.
        *ppSessionTotals = pSessionTotals;
        pSessionTotals.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::Clone(
    OUT IHsmSessionTotalsPriv** ppSessionTotalsPriv
    )

/*++

Implements:

  IHsmSessionTotalsPriv::Clone().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IHsmSessionTotalsPriv>  pSessionTotalsPriv;

    WsbTraceIn(OLESTR("CHsmSessionTotals::Clone"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != ppSessionTotalsPriv, E_POINTER);
        *ppSessionTotalsPriv = 0;

        // Create the new instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSessionTotals, 0, CLSCTX_ALL, IID_IHsmSessionTotalsPriv, (void**) &pSessionTotalsPriv));

        // Fill it in with the new values.
        WsbAffirmHr(CopyTo(pSessionTotalsPriv));

        // Return it to the caller.
        *ppSessionTotalsPriv = pSessionTotalsPriv;
        pSessionTotalsPriv.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSessionTotals>  pSessionTotals;

    WsbTraceIn(OLESTR("CHsmSessionTotals::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmSessionTotals, (void**) &pSessionTotals));

        // Compare the rules.
        hr = CompareToISessionTotals(pSessionTotals, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmSessionTotals::CompareToAction(
    IN HSM_JOB_ACTION action,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmSessionTotals::CompareToAction().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CHsmSessionTotals::CompareToAction"), OLESTR(""));

    try {

        // Compare the guids.
        if (m_action > action) {
            aResult = 1;
        }
        else if (m_action < action) {
            aResult = -1;
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::CompareToAction"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CHsmSessionTotals::CompareToISessionTotals(
    IN IHsmSessionTotals* pTotals,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmSessionTotals::CompareToISessionTotals().

--*/
{
    HRESULT             hr = S_OK;
    HSM_JOB_ACTION      action;

    WsbTraceIn(OLESTR("CHsmSessionTotals::CompareToISessionTotals"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pTotals, E_POINTER);

        // Get the identifier.
        WsbAffirmHr(pTotals->GetAction(&action));

        // Compare to the identifier.
        hr = CompareToAction(action, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::CompareToISessionTotals"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmSessionTotals::CopyTo(
    IN IHsmSessionTotals* pSessionTotals
    )

/*++

Implements:

  IHsmSessionTotals::CopyTo().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IHsmSessionTotalsPriv>  pSessionTotalsPriv;

    WsbTraceIn(OLESTR("CHsmSessionTotals::CopyTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != pSessionTotals, E_POINTER);

        // Get the private interface for the destination and copy the values.
        WsbAffirmHr(pSessionTotals->QueryInterface(IID_IHsmSessionTotalsPriv, (void**) &pSessionTotalsPriv));
        WsbAffirmHr(pSessionTotalsPriv->SetAction(m_action));
        WsbAffirmHr(pSessionTotalsPriv->SetStats(m_items, m_size, m_skippedItems, m_skippedSize, m_errorItems, m_errorSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::CopyTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::CopyTo(
    IN IHsmSessionTotalsPriv* pSessionTotalsPriv
    )

/*++

Implements:

  IHsmSessionTotals::CopyTo().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSessionTotals::CopyTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != pSessionTotalsPriv, E_POINTER);

        // Get the private interface for the destination and copy the values.
        WsbAffirmHr(pSessionTotalsPriv->SetAction(m_action));
        WsbAffirmHr(pSessionTotalsPriv->SetStats(m_items, m_size, m_skippedItems, m_skippedSize, m_errorItems, m_errorSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::CopyTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmSessionTotals::FinalConstruct"), OLESTR(""));
    try {
        
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_action = HSM_JOB_ACTION_UNKNOWN;
        m_items = 0;
        m_size = 0;
        m_skippedItems = 0;
        m_skippedSize = 0;
        m_errorItems = 0;
        m_errorSize = 0;

    } WsbCatch(hr);
    
    iCount++;
    WsbTraceOut(OLESTR("CHsmSessionTotals::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"), 
        WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmSessionTotals::FinalRelease(
    void
    )

/*++

Implements:

  CHsmSessionTotals::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CHsmSessionTotals::FinalRelease"), OLESTR(""));
    
    CWsbObject::FinalRelease();
    iCount--;
    
    WsbTraceOut(OLESTR("CHsmSessionTotals:FinalRelease"), OLESTR("Count is <%d>"), iCount);
}


HRESULT
CHsmSessionTotals::GetAction(
    OUT HSM_JOB_ACTION* pAction
    )
/*++

Implements:

  IHsmSessionTotals::GetAction().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pAction, E_POINTER);
        *pAction = m_action;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSessionTotals::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSessionTotals::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmSessionTotals;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmSessionTotals::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmSessionTotals::GetName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBACTION_UNKNOWN + m_action));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRES