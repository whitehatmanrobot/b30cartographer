,0x9e,0xa2,0xa0,
0x9d,0x9b,0x98,0x97,0x98,0x9c,0x9f,0xa2,0x9e,0x98,0x90,0x85,0x77,0x69,0x5b,0x50,
0x47,0x42,0x3d,0x39,0x37,0x36,0x36,0x37,0x39,0x3d,0x47,0x52,0x5f,0x6e,0x77,0x78,
0x72,0x6a,0x61,0x5a,0x5e,0x64,0x6b,0x73,0x77,0x7b,0x81,0x8b,0x97,0xa0,0x9e,0x92,
0x7e,0x69,0x58,0x53,0x58,0x64,0x72,0x7c,0x84,0x8a,0x92,0x9a,0xa0,0xa2,0xa1,0x9d,
0x9b,0x98,0x97,0x99,0x9a,0x9b,0x9d,0xa0,0xa2,0xa3,0xa0,0x96,0x89,0x7a,0x69,0x5b,
0x54,0x4f,0x47,0x3e,0x37,0x35,0x39,0x48,0x5b,0x70,0x7e,0x81,0x76,0x68,0x5a,0x53,
0x58,0x65,0x72,0x7c,0x7c,0x76,0x6c,0x65,0x61,0x62,0x64,0x67,0x6a,0x6b,0x6c,0x72,
0x7d,0x8b,0x99,0xa4,0xaa,0xac,0xa8,0xa2,0x9d,0x9a,0x98,0x99,0x9a,0x9c,0x9d,0xa0,
0xa0,0x9d,0x92,0x85,0x74,0x66,0x5b,0x51,0x4b,0x47,0x41,0x3a,0x35,0x32,0x32,0x36,
0x3a,0x3d,0x3e,0x3b,0x37,0x32,0x32,0x32,0x34,0x38,0x3a,0x3a,0x3a,0x3b,0x3a,0x3b,
0x3b,0x3a,0x39,0x38,0x37,0x37,0x36,0x37,0x37,0x37,0x37,0x35,0x35,0x35,0x35,0x36,
// Line 17
0x38,0x37,0x36,0x36,0x34,0x35,0x34,0x35,0x37,0x35,0x33,0x32,0x31,0x32,0x32,0x34,
0x34,0x36,0x36,0x36,0x33,0x33,0x32,0x34,0x37,0x38,0x37,0x36,0x34,0x34,0x34,0x36,
0x38,0x39,0x38,0x34,0x33,0x32,0x32,0x35,0x37,0x38,0x35,0x33,0x33,0x35,0x38,0x3b,
0x39,0x38,0x36,0x34,0x34,0x3e,0x4c,0x5f,0x70,0x7a,0x7b,0x76,0x6b,0x61,0x5e,0x61,
0x68,0x71,0x78,0x79,0x74,0x6c,0x64,0x5f,0x61,0x67,0x6e,0x75,0x78,0x76,0x71,0x6b,
0x66,0x64,0x65,0x6c,0x74,0x78,0x78,0x77,0x72,0x6a,0x64,0x60,0x63,0x6a,0x71,0x77,
0x77,0x75,0x6f,0x68,0x64,0x60,0x60,0x67,0x6c,0x72,0x75,0x75,0x71,0x6b,0x62,0x5e,
0x61,0x6a,0x71,0x77,0x7a,0x77,0x70,0x6a,0x64,0x60,0x64,0x6c,0x74,0x79,0x7a,0x78,
0x70,0x68,0x62,0x60,0x66,0x6c,0x71,0x75,0x73,0x71,0x75,0x7e,0x8a,0x99,0xa6,0xae,
0xaf,0xa9,0x9d,0x8b,0x7e,0x70,0x64,0x5c,0x54,0x4b,0x47,0x3e,0x37,0x36,0x39,0x42,
0x53,0x67,0x78,0x86,0x8f,0x95,0x98,0x9b,0x9d,0xa0,0xa2,0x9f,0x95,0x86,0x75,0x66,
0x5c,0x58,0x5b,0x65,0x70,0x78,0x7c,0x7a,0x73,0x68,0x5d,0x5a,0x5e,0x68,0x71,0x76,
0x75,0x6d,0x65,0x61,0x60,0x64,0x6b,0x70,0x70,0x6f,0x6f,0x74,0x7e,0x8b,0x99,0xa5,
0xac,0xac,0xa4,0x9e,0x99,0x96,0x9a,0x9d,0x9d,0x98,0x8b,0x7c,0x6d,0x61,0x58,0x50,
0x47,0x3d,0x36,0x38,0x40,0x51,0x64,0x74,0x7b,0x76,0x6b,0x60,0x5a,0x57,0x53,0x4e,
0x46,0x3b,0x32,0x39,0x4a,0x64,0x7c,0x89,0x88,0x7d,0x6e,0x62,0x5e,0x60,0x66,0x6c,
0x6f,0x72,0x79,0x82,0x8e,0x98,0xa2,0xa3,0xa1,0x9d,0x96,0x8d,0x80,0x71,0x64,0x5a,
0x52,0x4b,0x47,0x44,0x3f,0x3b,0x36,0x33,0x34,0x38,0x3e,0x46,0x50,0x5a,0x64,0x74,
0x7e,0x87,0x8e,0x96,0x9d,0xa3,0xa4,0xa2,0x9e,0x95,0x88,0x76,0x67,0x59,0x52,0x4f,
0x4b,0x43,0x3b,0x34,0x30,0x31,0x34,0x3a,0x40,0x41,0x3d,0x37,0x31,0x31,0x39,0x4a,
0x5e,0x71,0x7a,0x79,0x6f,0x64,0x5b,0x5c,0x64,0x71,0x7c,0x83,0x7f,0x76,0x6d,0x68,
0x67,0x66,0x60,0x54,0x45,0x38,0x30,0x31,0x3d,0x53,0x6b,0x81,0x8e,0x95,0x99,0x99,
0x93,0x8c,0x7f,0x72,0x62,0x54,0x46,0x3d,0x39,0x39,0x38,0x36,0x35,0x35,0x38,0x3e,
0x46,0x57,0x65,0x72,0x7c,0x7c,0x74,0x68,0x5f,0x5b,0x5e,0x69,0x74,0x75,0x76,0x6f,
0x65,0x5f,0x5c,0x5d,0x5c,0x56,0x49,0x3b,0x30,0x2e,0x32,0x3a,0x40,0x44,0x44,0x40,
0x3a,0x35,0x33,0x32,0x33,0x30,0x30,0x35,0x3e,0x4c,0x5c,0x6a,0x76,0x81,0x88,0x8f,
0x99,0xa2,0xa7,0xa8,0xa9,0xa5,0xa0,0x9f,0x9e,0x9e,0x9f,0xa0,0x9f,0x9f,0x9f,0xa0,
0x9e,0xa0,0x9d,0x9b,0x9d,0x9f,0xa2,0xa4,0xa2,0x9d,0x95,0x87,0x76,0x68,0x5c,0x54,
0x4f,0x47,0x3f,0x39,0x38,0x3e,0x4e,0x65,0x7a,0x85,0x85,0x7a,0x69,0x5a,0x54,0x5c,
0x6a,0x77,0x7b,0x79,0x6e,0x63,0x5b,0x58,0x57,0x58,0x54,0x4b,0x3b,0x2e,0x26,0x27,
0x31,0x3d,0x44,0x46,0x3f,0x36,0x30,0x33,0x3e,0x52,0x68,0x7a,0x83,0x81,0x78,0x6d,
0x62,0x5a,0x52,0x4e,0x46,0x3b,0x36,0x39,0x44,0x57,0x6b,0x80,0x8d,0x97,0x99,0x9a,
0x99,0x93,0x83,0x75,0x63,0x59,0x5c,0x65,0x72,0x7c,0x7c,0x76,0x6c,0x65,0x61,0x61,
0x5c,0x52,0x43,0x36,0x30,0x38,0x4c,0x66,0x7c,0x89,0x86,0x79,0x68,0x5a,0x4e,0x4a,
0x44,0x3e,0x37,0x32,0x2d,0x2e,0x32,0x39,0x3e,0x40,0x40,0x3d,0x3a,0x36,0x31,0x32,
0x31,0x34,0x3a,0x3e,0x3d,0x38,0x34,0x36,0x3f,0x50,0x65,0x77,0x81,0x7f,0x75,0x6b,
0x62,0x5f,0x64,0x6c,0x74,0x79,0x7d,0x83,0x8a,0x94,0x9a,0x9b,0x94,0x85,0x72,0x5e,
0x4c,0x40,0x3c,0x3c,0x3b,0x39,0x35,0x33,0x35,0x37,0x3c,0x41,0x48,0x52,0x5f,0x71,
0x83,0x8f,0x97,0x9a,0x97,0x8f,0x80,0x72,0x65,0x58,0x4a,0x3d,0x34,0x31,0x37,0x42,
0x4e,0x5c,0x6a,0x79,0x85,0x8e,0x95,0x96,0x97,0x91,0x81,0x6f,0x5d,0x54,0x57,0x62,
0x6f,0x78,0x7d,0x7a,0x70,0x67,0x5f,0x5a,0x5a,0x52,0x43,0x37,0x30,0x34,0x46,0x60,
0x78,0x83,0x82,0x76,0x66,0x59,0x53,0x51,0x4e,0x47,0x3b,0x34,0x35,0x46,0x60,0x7a,
0x87,0x87,0x7a,0x6a,0x5f,0x5b,0x5f,0x6a,0x72,0x77,0x79,0x7e,0x86,0x93,0x9e,0xa1,
0x9a,0x8a,0x74,0x60,0x54,0x53,0x59,0x67,0x74,0x7d,0x7d,0x76,0x6c,0x62,0x58,0x52,
0x4c,0x47,0x3f,0x36,0x2f,0x2c,0x2c,0x33,0x3c,0x48,0x55,0x5f,0x67,0x6f,0x79,0x82,
0x8e,0x98,0x9a,0x94,0x86,0x73,0x61,0x57,0x58,0x62,0x70,0x7c,0x7f,0x7b,0x71,0x67,
0x60,0x5c,0x57,0x50,0x44,0x37,0x30,0x35,0x47,0x60,0x79,0x86,0x85,0x77,0x67,0x5a,
0x58,0x5c,0x64,0x6c,0x71,0x75,0x7a,0x83,0x8f,0x98,0xa4,0xa8,0xa6,0xa2,0x99,0x8e,
0x83,0x75,0x66,0x5c,0x53,0x4b,0x43,0x3d,0x35,0x34,0x39,0x46,0x54,0x6a,0x7a,0x86,
0x91,0x96,0x96,0x91,0x87,0x79,0x6b,0x5e,0x50,0x47,0x3f,0x39,0x35,0x34,0x3a,0x49,
0x5d,0x72,0x7f,0x82,0x78,0x6a,0x5f,0x5c,0x62,0x6f,0x7a,0x81,0x7b,0x6e,0x62,0x5c,
0x5c,0x5d,0x57,0x4f,0x3d,0x2f,0x2b,0x34,0x46,0x60,0x75,0x81,0x81,0x77,0x67,0x5a,
0x53,0x4e,0x4a,0x43,0x38,0x2e,0x2e,0x2e,0x31,0x36,0x3c,0x3d,0x3b,0x34,0x2e,0x30,
0x38,0x44,0x54,0x65,0x75,0x85,0x90,0x98,0x99,0x96,0x8f,0x83,0x77,0x6a,0x5b,0x4e,
0x41,0x38,0x36,0x3b,0x44,0x50,0x5f,0x6d,0x7a,0x85,0x8f,0x95,0x96,0x92,0x88,0x7b,
0x6a,0x5a,0x4e,0x47,0x40,0x3e,0x39,0x36,0x34,0x34,0x37,0x3c,0x3e,0x3c,0x36,0x30,
0x2c,0x2f,0x3c,0x51,0x65,0x75,0x7c,0x79,0x71,0x66,0x5c,0x55,0x4e,0x46,0x3d,0x35,
0x2e,0x29,0x2d,0x31,0x38,0x42,0x47,0x48,0x47,0x40,0x38,0x36,0x35,0x37,0x3b,0x3e,
0x3d,0x38,0x33,0x2f,0x31,0x3c,0x4c,0x60,0x70,0x79,0x77,0x70,0x65,0x5b,0x55,0x53,
0x4e,0x47,0x3c,0x32,0x2d,0x2d,0x30,0x37,0x3d,0x41,0x40,0x3d,0x38,0x35,0x36,0x37,
0x37,0x39,0x39,0x38,0x34,0x32,0x31,0x35,0x3e,0x4e,0x5f,0x71,0x7a,0x79,0x74,0x6c,
0x62,0x5a,0x51,0x4b,0x43,0x3b,0x34,0x35,0x3e,0x51,0x68,0x7e,0x8c,0x95,0x97,0x95,
0x92,0x8c,0x81,0x73,0x62,0x51,0x42,0x3b,0x37,0x36,0x36,0x34,0x2f,0x2c,0x2f,0x38,
0x46,0x57,0x67,0x72,0x78,0x76,0x70,0x6a,0x62,0x5a,0x54,0x4d,0x44,0x39,0x33,0x33,
0x3c,0x4e,0x65,0x7b,0x8c,0x94,0x95,0x94,0x8f,0x88,0x7f,0x72,0x62,0x53,0x45,0x3d,
0x37,0x38,0x38,0x37,0x36,0x34,0x32,0x3b,0x42,0x4b,0x57,0x62,0x6d,0x79,0x84,0x8f,
0x99,0xa0,0xa5,0xa7,0xa6,0xa4,0xa0,0x9e,0x9b,0x99,0x98,0x95,0x8d,0x81,0x6e,0x5f,
0x58,0x59,0x62,0x71,0x7f,0x83,0x7d,0x70,0x63,0x5a,0x56,0x53,0x4c,0x45,0x36,0x27,
0x1f,0x20,0x29,0x36,0x3f,0x40,0x3c,0x34,0x2c,0x2c,0x34,0x46,0x5d,0x72,0x7e,0x7e,
0x76,0x68,0x5c,0x5a,0x61,0x6f,0x7b,0x7d,0x77,0x6d,0x64,0x5f,0x5e,0x5e,0x5b,0x52,
0x42,0x32,0x2b,0x34,0x47,0x61,0x77,0x82,0x82,0x78,0x6a,0x5a,0x51,0x4b,0x45,0x3b,
0x37,0x30,0x2e,0x30,0x32,0x36,0x3f,0x47,0x4e,0x5a,0x67,0x75,0x82,0x8b,0x8f,0x95,
0x9b,0xa2,0xa4,0xa2,0x9f,0x9d,0x9a,0x98,0x97,0x99,0x96,0x8f,0x82,0x72,0x64,0x5c,
0x5a,0x5e,0x68,0x74,0x7e,0x86,0x8c,0x94,0x9a,0xa0,0xa2,0xa2,0x9f,0x9b,0x98,0x96,
0x95,0x98,0x9c,0x9f,0xa0,0xa2,0xa2,0xa2,0x9d,0x9d,0x9b,0x9d,0x9d,0x99,0x8c,0x7c,
0x6b,0x5c,0x56,0x58,0x62,0x70,0x77,0x77,0x72,0x6b,0x63,0x5e,0x59,0x54,0x4e,0x43,
0x38,0x32,0x38,0x46,0x5a,0x70,0x81,0x8d,0x92,0x92,0x8f,0x93,0x98,0x9d,0x9b,0x96,
0x8c,0x80,0x72,0x67,0x5b,0x53,0x4c,0x47,0x41,0x3a,0x34,0x32,0x32,0x33,0x35,0x38,
0x38,0x33,0x31,0x31,0x36,0x3e,0x4b,0x5b,0x6c,0x7d,0x89,0x95,0x9a,0x9b,0x97,0x8d,
0x7c,0x6c,0x5e,0x53,0x48,0x41,0x3a,0x37,0x39,0x41,0x4f,0x66,0x76,0x80,0x81,0x78,
0x69,0x5e,0x57,0x5a,0x65,0x70,0x76,0x79,0x7e,0x83,0x8c,0x98,0xa5,0xad,0xae,0xa8,
0x9f,0x99,0x94,0x95,0x9a,0x9c,0x98,0x8f,0x81,0x70,0x61,0x57,0x56,0x5e,0x6c,0x79,
0x7e,0x7a,0x71,0x69,0x62,0x61,0x67,0x71,0x79,0x7c,0x76,0x6d,0x65,0x5e,0x59,0x58,
0x56,0x50,0x45,0x35,0x2e,0x2b,0x2f,0x38,0x40,0x43,0x43,0x3e,0x38,0x36,0x34,0x34,
0x34,0x35,0x34,0x37,0x40,0x51,0x62,0x73,0x7a,0x79,0x70,0x65,0x5a,0x5a,0x60,0x6c,
0x77,0x7d,0x7a,0x74,0x68,0x5f,0x5c,0x5d,0x5b,0x53,0x46,0x37,0x2c,0x29,0x2b,0x30,
0x38,0x3f,0x42,0x40,0x3b,0x35,0x31,0x30,0x2e,0x2f,0x30,0x34,0x3d,0x4b,0x5d,0x6d,
0x78,0x7c,0x76,0x6d,0x64,0x5f,0x63,0x6c,0x77,0x7e,0x7d,0x75,0x6b,0x63,0x61,0x64,
0x6b,0x70,0x73,0x75,0x76,0x7c,0x88,0x93,0x9c,0xa0,0x9a,0x8b,0x77,0x62,0x50,0x45,
0x3e,0x39,0x37,0x38,0x3f,0x4c,0x5e,0x6f,0x7e,0x8b,0x91,0x94,0x96,0x93,0x8e,0x84,
0x76,0x65,0x56,0x4a,0x42,0x3b,0x3c,0x3e,0x44,0x4f,0x5c,0x6c,0x7c,0x86,0x8b,0x8e,
0x8f,0x95,0x9b,0xa2,0xa4,0xa4,0x9f,0x9b,0x97,0x98,0x9a,0x97,0x8f,0x81,0x6e,0x5e,
0x54,0x56,0x62,0x6f,0x7a,0x7f,0x79,0x70,0x66,0x60,0x62,0x66,0x70,0x79,0x7a,0x79,
0x70,0x65,0x5c,0x58,0x56,0x54,0x4d,0x42,0x36,0x2c,0x26,0x28,0x2f,0x3a,0x3f,0x46,
0x42,0x3b,0x37,0x34,0x33,0x34,0x35,0x36,0x36,0x36,0x36,0x37,0x36,0x33,0x33,0x34,
0x35,0x35,0x37,0x38,0x38,0x38,0x37,0x36,0x34,0x34,0x35,0x37,0x37,0x37,0x36,0x36,
// Line 18
0x36,0x36,0x38,0x39,0x38,0x36,0x34,0x33,0x33,0x33,0x34,0x36,0x37,0x37,0x37,0x37,
0x35,0x34,0x36,0x36,0x37,0x3c,0x3c,0x3a,0x34,0x31,0x31,0x39,0x40,0x43,0x3e,0x36,
0x2d,0x27,0x2b,0x35,0x3f,0x45,0x40,0x36,0x2b,0x25,0x29,0x37,0x44,0x49,0x41,0x34,
0x27,0x21,0x28,0x33,0x40,0x4a,0x47,0x38,0x2a,0x23,0x28,0x37,0x46,0x4e,0x4a,0x3b,
0x2a,0x21,0x26,0x34,0x44,0x4a,0x47,0x3a,0x2c,0x24,0x28,0x37,0x45,0x4b,0x46,0x38,
0x28,0x22,0x26,0x34,0x43,0x4b,0x46,0x38,0x2a,0x23,0x28,0x38,0x46,0x4b,0x48,0x39,
0x29,0x22,0x27,0x34,0x42,0x49,0x44,0x38,0x2a,0x26,0x2a,0x3a,0x47,0x4d,0x49,0x3d,
0x30,0x29,0x2a,0x36,0x44,0x4b,0x48,0x3a,0x2b,0x23,0x26,0x34,0x42,0x4b,0x49,0x3c,
0x2b,0x24,0x26,0x33,0x43,0x4a,0x48,0x3b,0x2b,0x22,0x25,0x33,0x44,0x4e,0x4c,0x40,
0x30,0x2e,0x34,0x43,0x55,0x5f,0x5d,0x51,0x42,0x39,0x3e,0x4d,0x5e,0x63,0x5f,0x4f,
0x3d,0x34,0x38,0x49,0x59,0x5f,0x59,0x4d,0x3f,0x37,0x3c,0x4b,0x5c,0x66,0x61,0x53,
0x41,0x38,0x3b,0x4a,0x5a,0x63,0x5f,0x53,0x44,0x3b,0x40,0x4e,0x5c,0x65,0x61,0x52,
0x42,0x3a,0x40,0x4b,0x5c,0x63,0x5e,0x51,0x42,0x3a,0x42,0x4e,0x59,0x60,0x5c,0x4f,
0x41,0x39,0x3d,0x4b,0x5a,0x61,0x5e,0x51,0x42,0x3b,0x41,0x4f,0x5c,0x65,0x61,0x53,
0x43,0x3b,0x3f,0x4c,0x5a,0x63,0x61,0x56,0x49,0x41,0x46,0x57,0x68,0x74,0x72,0x66,
0x58,0x4f,0x51,0x60,0x71,0x7a,0x78,0x6a,0x5a,0x51,0x55,0x64,0x74,0x7c,0x78,0x69,
0x59,0x50,0x54,0x63,0x71,0x79,0x76,0x69,0x59,0x51,0x54,0x62,0x71,0x7a,0x77,0x67,
0x5a,0x50,0x53,0x62,0x71,0x78,0x78,0x6c,0x5b,0x53,0x56,0x64,0x73,0x7c,0x77,0x68,
0x58,0x50,0x52,0x5f,0x6d,0x75,0x74,0x68,0x58,0x50,0x54,0x62,0x71,0x79,0x73,0x64,
0x54,0x4b,0x50,0x5f,0x6f,0x79,0x76,0x69,0x5a,0x54,0x5a,0x6b,0x7e,0x86,0x82,0x77,
0x67,0x60,0x64,0x73,0x82,0x8b,0x87,0x79,0x68,0x62,0x67,0x75,0x85,0x8e,0x8a,0x7e,
0x6d,0x64,0x69,0x79,0x89,0x90,0x8c,0x7f,0x71,0x6b,0x6e,0x7b,0x8a,0x91,0x8d,0x7f,
0x6f,0x69,0x6f,0x7e,0x8c,0x91,0x8d,0x80,0x6f,0x67,0x68,0x75,0x83,0x89,0x83,0x78,
0x6b,0x63,0x69,0x78,0x87,0x91,0x8a,0x7c,0x6f,0x68,0x6b,0x78,0x85,0x8c,0x89,0x7d,
0x6d,0x64,0x69,0x77,0x86,0x8e,0x8a,0x7d,0x6f,0x66,0x69,0x78,0x87,0x91,0x8e,0x81,
0x71,0x6c,0x71,0x82,0x93,0x9d,0x9b,0x90,0x82,0x7a,0x7d,0x8f,0x9d,0xa4,0xa2,0x96,
0x87,0x7f,0x81,0x8e,0x9e,0xa6,0xa1,0x93,0x83,0x79,0x7c,0x8c,0x9b,0xa4,0xa1,0x93,
0x83,0x7c,0x81,0x8f,0x9e,0xa4,0x9d,0x90,0x81,0x7a,0x7f,0x8d,0x9b,0xa2,0x9e,0x90,
0x81,0x7b,0x7f,0x8d,0x9d,0xa5,0xa1,0x94,0x84,0x7c,0x81,0x90,0x9c,0xa2,0x9c,0x90,
0x81,0x7b,0x7e,0x8d,0x9e,0xa5,0xa0,0x93,0x85,0x7e,0x82,0x8e,0x9b,0xa2,0x9d,0x93,
0x82,0x7c,0x7e,0x8b,0x9b,0xa2,0x9d,0x97,0x89,0x83,0x8a,0x9a,0xaa,0xb3,0xb2,0xa7,
0x9a,0x91,0x95,0xa0,0xae,0xb5,0xb1,0xa6,0x99,0x91,0x96,0xa3,0xaf,0xb5,0xb2,0xa7,
0x9a,0x91,0x95,0xa2,0xb1,0xb7,0xb1,0xa4,0x96,0x90,0x96,0xa3,0xb1,0xb7,0xb3,0xa5,
0x99,0x92,0x98,0xa6,0xb3,0xb7,0xb2,0xa5,0x97,0x8f,0x95,0xa3,0xb0,0xb5,0xae,0xa0,
0x91,0x8b,0x8f,0x9e,0xad,0xb6,0xb3,0xa7,0x99,0x91,0x97,0xa5,0xb2,0xb7,0xb0,0xa3,
0x96,0x8f,0x93,0xa1,0xb0,0xb6,0xb2,0xa6,0x9a,0x95,0x98,0xa2,0xad,0xb3,0xb2,0xab,
0xa1,0x9c,0x9e,0xa4,0xaa,0xaa,0xaa,0xa6,0xa0,0x9e,0x9e,0xa0,0xa7,0xab,0xaa,0xa9,
0xa5,0xa5,0xa4,0xa4,0xa4,0xa5,0xa7,0xa9,0xaa,0xa9,0xa5,0xa4,0xa5,0xa6,0xa7,0xa8,
0xa6,0xa5,0xa6,0xa5,0xa5,0xa4,0xa4,0xa5,0xa6,0xa5,0xa2,0xa2,0xa3,0xa4,0xa4,0xa2,
0xa2,0xa2,0xa5,0xa6,0xa4,0xa4,0xa3,0xa5,0xa7,0xa5,0xa3,0xa3,0xa6,0xa6,0xa4,0xa3,
0xa4,0xa4,0xa6,0xa5,0xa3,0xa2,0xa3,0xa5,0xa6,0xa6,0xa5,0xa4,0xa2,0xa0,0x9e,0x9b,
0x96,0x90,0x89,0x81,0x75,0x6b,0x61,0x59,0x51,0x49,0x42,0x3e,0x3b,0x3a,0x36,0x34,
0x33,0x33,0x36,0x39,0x38,0x3a,0x37,0x36,0x36,0x35,0x34,0x37,0x38,0x39,0x3a,0x3a,
0x3b,0x3d,0x3d,0x3d,0x3d,0x3d,0x3b,0x3a,0x37,0x36,0x35,0x37,0x38,0x38,0x39,0x3a,
0x3b,0x3c,0x3c,0x3d,0x3d,0x3c,0x39,0x38,0x37,0x37,0x35,0x36,0x35,0x34,0x34,0x36,
0x36,0x38,0x39,0x3a,0x3a,0x39,0x39,0x36,0x38,0x38,0x39,0x3a,0x3a,0x39,0x39,0x3a,
0x3a,0x3a,0x3b,0x3b,0x3b,0x39,0x37,0x37,0x37,0x38,0x37,0x36,0x33,0x33,0x34,0x34,
0x34,0x35,0x36,0x35,0x35,0x33,0x33,0x34,0x35,0x34,0x36,0x37,0x37,0x36,0x36,0x38,
0x39,0x3b,0x3c,0x3b,0x39,0x33,0x2f,0x33,0x3d,0x4f,0x67,0x7f,0x93,0x9f,0xa0,0x99,
0x8b,0x7e,0x6f,0x63,0x57,0x49,0x3a,0x2d,0x27,0x27,0x2f,0x37,0x3c,0x3f,0x3c,0x37,
0x32,0x2e,0x2f,0x31,0x33,0x33,0x33,0x34,0x36,0x39,0x3c,0x3a,0x36,0x36,0x36,0x3a,
0x3b,0x3c,0x3b,0x3a,0x38,0x37,0x36,0x37,0x37,0x39,0x38,0x35,0x33,0x33,0x36,0x3b,
0x3e,0x3b,0x36,0x33,0x33,0x37,0x40,0x48,0x4b,0x49,0x3f,0x37,0x37,0x41,0x51,0x60,
0x68,0x61,0x51,0x44,0x41,0x4d,0x64,0x79,0x82,0x7a,0x64,0x4f,0x48,0x56,0x71,0x8f,
0x9b,0x90,0x73,0x56,0x4a,0x5a,0x7c,0x9b,0xa7,0x9a,0x79,0x59,0x4c,0x5b,0x7b,0x9a,
0xa4,0x93,0x71,0x51,0x44,0x50,0x70,0x87,0x8c,0x80,0x64,0x4b,0x44,0x4d,0x61,0x73,
0x75,0x68,0x53,0x42,0x3b,0x40,0x4c,0x54,0x50,0x4c,0x40,0x37,0x35,0x36,0x3a,0x40,
0x40,0x3c,0x3a,0x38,0x37,0x34,0x34,0x32,0x30,0x31,0x33,0x36,0x36,0x36,0x36,0x38,
0x38,0x3a,0x3a,0x3b,0x3b,0x3b,0x38,0x37,0x36,0x34,0x32,0x33,0x34,0x35,0x34,0x36,
0x35,0x35,0x36,0x36,0x37,0x3a,0x3a,0x3a,0x39,0x37,0x34,0x34,0x34,0x34,0x33,0x34,
0x35,0x34,0x38,0x39,0x3a,0x3b,0x3a,0x37,0x37,0x36,0x36,0x38,0x36,0x35,0x34,0x33,
0x33,0x35,0x36,0x38,0x37,0x35,0x33,0x33,0x36,0x37,0x37,0x38,0x36,0x35,0x36,0x38,
0x38,0x38,0x36,0x34,0x33,0x34,0x36,0x38,0x3b,0x3d,0x3f,0x46,0x4c,0x55,0x63,0x71,
0x81,0x8f,0x9b,0xa8,0xb3,0xba,0xbc,0xbe,0xbf,0xc1,0xc1,0xbf,0xbc,0xbd,0xbd,0xbc,
0xbd,0xbf,0xc1,0xc2,0xc2,0xbf,0xbc,0xba,0xb8,0xb8,0xb9,0xbb,0xbc,0xbb,0xba,0xba,
0xbb,0xbc,0xbe,0xbe,0xbf,0xbf,0xbe,0xbf,0xbe,0xbc,0xbc,0xbd,0xbc,0xbe,0xbe,0xbe,
0xbb,0xbb,0xbb,0xbc,0xbf,0xc0,0xbf,0xbf,0xbc,0xb9,0xb9,0xba,0xbb,0xbd,0xbc,0xb9,
0xb8,0xb8,0xba,0xbb,0xbb,0xbb,0xbb,0xbc,0xbb,0xb9,0xba,0xbb,0xbb,0xbb,0xba,0xbb,
0xbc,0xbc,0xbb,0xbb,0xbb,0xbc,0xbc,0xbc,0xbc,0xbc,0xbd,0xbc,0xbb,0xbb,0xbb,0xbc,
0xbd,0xbc,0xbb,0xb9,0xb9,0xb8,0xb9,0xbb,0xbc,0xbd,0xbc,0xba,0xb9,0xbb,0xbd,0xbe,
0xc0,0xbe,0xbc,0xbb,0xbb,0xbc,0xbc,0xbd,0xbc,0xbb,0xba,0xbb,0xbb,0xbc,0xbb,0xba,
0xba,0xb8,0xb8,0xb9,0xba,0xbb,0xbd,0xbd,0xbc,0xbc,0xbb,0xbc,0xbc,0xbc,0xbd,0xbd,
0xbc,0xba,0xb7,0xb8,0xb9,0xba,0xbc,0xbe,0xbe,0xbe,0xbd,0xbc,0xbc,0xbd,0xbe,0xbf,
0xbd,0xbc,0xba,0xbb,0xb9,0xba,0xbd,0xbf,0xc0,0xbf,0xbe,0xbd,0xbf,0xbe,0xbd,0xbc,
0xbb,0xb9,0xb9,0xbb,0xbc,0xbb,0xb9,0xb9,0xb9,0xbb,0xbc,0xbe,0xbf,0xbf,0xbc,0xbc,
0xbb,0xbc,0xbd,0xbf,0xbf,0xc1,0xbe,0xbc,0xbb,0xbb,0xbb,0xbb,0xbc,0xbd,0xbd,0xbc,
0xbb,0xbb,0xbc,0xbe,0xbe,0xbb,0xbd,0xbb,0xba,0xb8,0xb8,0xb9,0xbc,0xbb,0xb9,0xba,
0xbb,0xba,0xba,0xb9,0xb9,0xbb,0xba,0xb9,0xb7,0xb7,0xb7,0xb9,0xba,0xba,0xba,0xba,
0xb9,0xba,0xbc,0xbd,0xbe,0xbe,0xbc,0xbc,0xbd,0xbf,0xbf,0xbf,0xbd,0xbd,0xbc,0xbc,
0xbc,0xbd,0xbd,0xbc,0xba,0xbb,0xbb,0xbd,0xbf,0xbf,0xbd,0xbd,0xbc,0xbd,0xbd,0xbe,
0xbf,0xbd,0xbd,0xbc,0xbc,0xbd,0xbc,0xbc,0xbd,0xbd,0xbb,0xba,0xb7,0xb8,0xbb,0xbc,
0xbe,0xbd,0xbe,0xc0,0xc2,0xc2,0xc1,0xc1,0xc1,0xbe,0xbb,0xb9,0xb8,0xb9,0xba,0xbb,
0xbb,0xbc,0xbc,0xbe,0xbe,0xbd,0xbd,0xbe,0xbf,0xbe,0xbd,0xbd,0xbd,0xbc,0xbc,0xbe,
0xbf,0xbf,0xbc,0xbb,0xbd,0xbc,0xbc,0xbc,0xbc,0xbc,0xbb,0xbb,0xbc,0xbd,0xbf,0xbf,
0xbd,0xbd,0xbc,0xbc,0xbc,0xbc,0xbc,0xbf,0xbf,0xbd,0xbc,0xbb,0xbb,0xbd,0xbf,0xc1,
0xc0,0xbf,0xbe,0xbd,0xbd,0xbd,0xbe,0xbf,0xbe,0xbc,0xbc,0xbc,0xbc,0xb9,0xbc,0xbc,
0xbd,0xbd,0xbd,0xbd,0xc1,0xbf,0xbc,0xbc,0xbc,0xbc,0xbd,0xbb,0xba,0xbb,0xbb,0xbc,
0xbd,0xbc,0xbd,0xbe,0xbf,0xbe,0xbd,0xbe,0xbd,0xbc,0xbb,0xb9,0xb8,0xb8,0xb8,0xbb,
0xbc,0xbc,0xbd,0xbe,0xbd,0xbd,0xbd,0xbe,0xbf,0xbe,0xbf,0xbf,0xbd,0xbc,0xbb,0xbc,
0xbd,0xbc,0xbb,0xbd,0xbe,0xbf,0xbe,0xbc,0xbc,0xbc,0xbd,0xbe,0xbc,0xbc,0xbb,0xba,
0xb9,0xbb,0xbc,0xbe,0xbd,0xbd,0xbd,0xbd,0xbc,0xbb,0xbb,0xbb,0xbc,0xbd,0xbd,0xbe,
0xbf,0xbe,0xbd,0xbd,0xbc,0xbd,0xbe,0xbd,0xbc,0xbb,0xbb,0xbb,0xb9,0xbb,0xbb,0xbd,
0xbd,0xbc,0xba,0xbb,0xbc,0xbe,0xbf,0xc0,0xbf,0xbd,0xba,0xb8,0xb9,0xba,0xbb,0xbb,
0xbc,0xbb,0xbb,0xbc,0xbd,0xbc,0xbe,0xbf,0xbf,0xc0,0xbf,0xbf,0xc0,0xbf,0xbd,0xbb,
0xba,0xba,0xba,0xb9,0xb8,0xb7,0xb8,0xb9,0xba,0xb9,0xb6,0xb1,0xab,0xa2,0x98,0x8b,
0x7b,0x6d,0x62,0x57,0x4b,0x42,0x3b,0x37,0x36,0x36,0x35,0x36,0x38,0x39,0x38,0x39,
// Line 19
0x38,0x35,0x32,0x32,0x34,0x37,0x39,0x3b,0x3b,0x3b,0x39,0x39,0x3a,0x3c,0x3a,0x38,
0x36,0x34,0x33,0x36,0x38,0x3a,0x3d,0x41,0x45,0x4b,0x52,0x58,0x5b,0x5c,0x5f,0x61,
0x62,0x60,0x5f,0x60,0x5f,0x5f,0x5f,0x5f,0x5e,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5d,
0x61,0x5f,0x5d,0x60,0x62,0x61,0x63,0x60,0x60,0x62,0x63,0x64,0x65,0x62,0x60,0x61,
0x61,0x63,0x64,0x65,0x64,0x64,0x64,0x63,0x60,0x60,0x61,0x63,0x63,0x61,0x5f,0x5f,
0x5d,0x5d,0x5e,0x5f,0x62,0x63,0x63,0x61,0x5f,0x5f,0x60,0x61,0x62,0x61,0x5f,0x5f,
0x5d,0x5c,0x5c,0x5d,0x60,0x61,0x60,0x60,0x60,0x60,0x60,0x61,0x63,0x64,0x63,0x64,
0x62,0x60,0x61,0x60,0x60,0x60,0x61,0x60,0x61,0x61,0x60,0x5f,0x5d,0x5e,0x5f,0x61,
0x61,0x61,0x61,0x63,0x63,0x66,0x66,0x66,0x66,0x64,0x61,0x60,0x60,0x62,0x60,0x65,
0x64,0x63,0x63,0x65,0x67,0x69,0x68,0x64,0x65,0x65,0x65,0x65,0x66,0x65,0x66,0x65,
0x64,0x64,0x64,0x64,0x64,0x65,0x66,0x66,0x68,0x6a,0x6a,0x6c,0x6c,0x6a,0x6b,0x6c,
0x6c,0x6c,0x6c,0x6c,0x6d,0x6c,0x6a,0x6b,0x6d,0x6e,0x6d,0x70,0x70,0x72,0x74,0x74,
0x74,0x73,0x73,0x72,0x72,0x73,0x76,0x78,0x78,0x77,0x77,0x79,0x7b,0x7e,0x81,0x83,
0x83,0x83,0x83,0x85,0x86,0x86,0x87,0x88,0x88,0x89,0x89,0x8a,0x89,0x89,0x8a,0x8c,
0x8c,0x8d,0x8c,0x8e,0x90,0x90,0x90,0x92,0x93,0x92,0x93,0x91,0x91,0x8f,0x8c,0x8a,
0x87,0x84,0x84,0x86,0x89,0x86,0x84,0x82,0x80,0x7e,0x7c,0x7a,0x77,0x73,0x6e,0x69,
0x63,0x5f,0x5b,0x58,0x54,0x51,0x4c,0x48,0x42,0x3e,0x3d,0x3b,0x37,0x34,0x2f,0x2c,
0x2b,0x28,0x26,0x21,0x25,0x25,0x26,0x28,0x2a,0x2a,0x2f,0x33,0x36,0x3c,0x40,0x47,
0x4e,0x52,0x55,0x5a,0x5f,0x65,0x6a,0x72,0x76,0x7b,0x80,0x86,0x8a,0x8f,0x92,0x96,
0x9a,0x9b,0x9a,0x95,0x8e,0x89,0x86,0x82,0x7c,0x77,0x72,0x6c,0x63,0x5c,0x54,0x4d,
0x49,0x43,0x39,0x34,0x30,0x2c,0x2b,0x2a,0x29,0x2a,0x2b,0x30,0x35,0x3a,0x3f,0x45,
0x4d,0x55,0x5d,0x66,0x6f,0x78,0x81,0x88,0x8c,0x8e,0x8e,0x90,0x92,0x90,0x8a,0x83,
0x7c,0x72,0x68,0x60,0x59,0x51,0x49,0x43,0x3b,0x36,0x32,0x30,0x31,0x32,0x33,0x38,
0x3a,0x40,0x46,0x4f,0x58,0x61,0x6c,0x78,0x80,0x89,0x8c,0x8f,0x90,0x8f,0x8a,0x83,
0x79,0x71,0x6a,0x5e,0x52,0x47,0x3e,0x38,0x33,0x30,0x2e,0x2f,0x31,0x35,0x39,0x43,
0x4c,0x58,0x66,0x73,0x7d,0x86,0x8c,0x90,0x8f,0x8a,0x81,0x79,0x71,0x68,0x59,0x50,
0x44,0x3a,0x36,0x34,0x32,0x36,0x38,0x3c,0x44,0x4e,0x59,0x66,0x75,0x81,0x89,0x8f,
0x90,0x8d,0x84,0x79,0x6e,0x63,0x58,0x4d,0x43,0x3a,0x34,0x34,0x34,0x38,0x3f,0x49,
0x54,0x62,0x6f,0x7b,0x85,0x8c,0x8c,0x89,0x83,0x7a,0x6e,0x61,0x54,0x48,0x3e,0x36,
0x30,0x30,0x34,0x3c,0x47,0x54,0x63,0x73,0x81,0x89,0x8e,0x90,0x8d,0x84,0x78,0x68,
0x5a,0x4e,0x41,0x38,0x34,0x32,0x35,0x41,0x51,0x63,0x71,0x81,0x88,0x8b,0x8b,0x85,
0x79,0x70,0x60,0x54,0x47,0x3c,0x32,0x2f,0x32,0x3b,0x49,0x5b,0x6c,0x79,0x87,0x8a,
0x84,0x7f,0x75,0x6a,0x5d,0x4e,0x42,0x39,0x32,0x32,0x39,0x47,0x59,0x6c,0x7c,0x87,
0x89,0x86,0x7d,0x71,0x66,0x59,0x4a,0x3e,0x36,0x34,0x3a,0x47,0x59,0x6e,0x7d,0x88,
0x8b,0x87,0x7d,0x70,0x63,0x54,0x44,0x38,0x30,0x2f,0x36,0x44,0x56,0x6b,0x7b,0x86,
0x88,0x82,0x76,0x68,0x59,0x4c,0x40,0x39,0x38,0x3c,0x48,0x5a,0x6b,0x7b,0x83,0x83,
0x81,0x76,0x66,0x56,0x48,0x40,0x3c,0x3e,0x47,0x54,0x6b,0x7b,0x83,0x84,0x7d,0x70,
0x66,0x56,0x47,0x3f,0x3a,0x3b,0x43,0x50,0x60,0x71,0x7d,0x83,0x7c,0x6e,0x5d,0x4e,
0x44,0x40,0x40,0x45,0x50,0x5f,0x71,0x7e,0x83,0x7f,0x76,0x67,0x55,0x44,0x3a,0x3a,
0x42,0x4c,0x59,0x68,0x76,0x7e,0x81,0x77,0x66,0x56,0x49,0x44,0x43,0x4b,0x53,0x61,
0x6e,0x77,0x78,0x74,0x6a,0x5d,0x50,0x45,0x40,0x43,0x4e,0x5d,0x6b,0x76,0x78,0x76,
0x6d,0x61,0x53,0x4a,0x46,0x4a,0x53,0x5f,0x69,0x71,0x74,0x72,0x6c,0x5f,0x53,0x4e,
0x4c,0x50,0x57,0x61,0x6b,0x73,0x72,0x6d,0x63,0x58,0x4f,0x4a,0x4b,0x52,0x5c,0x68,
0x6d,0x6d,0x6a,0x64,0x5d,0x57,0x54,0x56,0x5c,0x65,0x6c,0x6e,0x6c,0x68,0x60,0x59,
0x52,0x4e,0x51,0x56,0x5d,0x65,0x6a,0x69,0x64,0x5d,0x57,0x53,0x55,0x59,0x5b,0x61,
0x64,0x64,0x61,0x5e,0x58,0x57,0x56,0x58,0x5c,0x60,0x65,0x68,0x64,0x5f,0x5b,0x57,
0x59,0x5f,0x66,0x6a,0x6b,0x68,0x61,0x5a,0x55,0x53,0x58,0x62,0x6a,0x6e,0x6e,0x69,
0x5f,0x58,0x52,0x52,0x56,0x5f,0x66,0x6b,0x6b,0x64,0x59,0x51,0x4c,0x4d,0x58,0x65,
0x70,0x74,0x6d,0x60,0x53,0x4a,0x49,0x51,0x61,0x70,0x78,0x76,0x6b,0x5a,0x4a,0x42,
0x45,0x55,0x65,0x73,0x78,0x72,0x60,0x50,0x46,0x48,0x54,0x66,0x76,0x7d,0x77,0x66,
0x4f,0x3f,0x3c,0x48,0x5e,0x73,0x80,0x7f,0x6e,0x56,0x41,0x3e,0x4a,0x60,0x78,0x83,
0x7e,0x6a,0x51,0x3d,0x3c,0x4a,0x61,0x7b,0x85,0x7c,0x65,0x49,0x39,0x3c,0x50,0x6c,
0x80,0x86,0x7a,0x60,0x45,0x37,0x3e,0x56,0x74,0x85,0x84,0x6f,0x53,0x3c,0x38,0x49,
0x66,0x80,0x8a,0x7e,0x60,0x43,0x36,0x42,0x5c,0x79,0x8b,0x85,0x6a,0x4d,0x38,0x3b,
0x53,0x71,0x84,0x87,0x73,0x55,0x3c,0x39,0x4a,0x67,0x7e,0x84,0x75,0x58,0x3f,0x38,
0x4a,0x68,0x80,0x87,0x76,0x59,0x40,0x39,0x47,0x64,0x7d,0x84,0x74,0x56,0x3e,0x39,
0x49,0x64,0x7a,0x80,0x6f,0x52,0x3d,0x3b,0x4e,0x6c,0x80,0x80,0x69,0x4e,0x3e,0x42,
0x5b,0x76,0x83,0x7c,0x63,0x47,0x3d,0x46,0x5f,0x78,0x80,0x72,0x58,0x44,0x42,0x55,
0x6e,0x7e,0x7c,0x68,0x4f,0x41,0x49,0x5f,0x76,0x7f,0x73,0x5d,0x4a,0x47,0x56,0x6e,
0x7c,0x77,0x63,0x4e,0x45,0x4e,0x63,0x76,0x78,0x6d,0x56,0x47,0x4a,0x5c,0x6f,0x78,
0x6d,0x5b,0x4d,0x4b,0x57,0x68,0x74,0x70,0x60,0x51,0x4b,0x54,0x64,0x6f,0x6f,0x64,
0x57,0x50,0x57,0x65,0x71,0x72,0x68,0x5b,0x53,0x56,0x62,0x6f,0x73,0x69,0x5b,0x53,
0x58,0x62,0x6e,0x71,0x6a,0x5c,0x51,0x50,0x5b,0x68,0x6e,0x6a,0x5e,0x54,0x52,0x5b,
0x65,0x6c,0x6a,0x62,0x59,0x56,0x5a,0x62,0x66,0x64,0x5d,0x58,0x58,0x5d,0x63,0x66,
0x65,0x60,0x5d,0x5f,0x64,0x6c,0x6e,0x6a,0x63,0x5e,0x5e,0x63,0x67,0x68,0x66,0x63,
0x5f,0x5d,0x60,0x64,0x67,0x65,0x60,0x5d,0x5d,0x5f,0x60,0x64,0x62,0x5e,0x5c,0x5c,
0x5e,0x62,0x63,0x62,0x60,0x5f,0x60,0x63,0x64,0x61,0x5d,0x5c,0x5b,0x5c,0x5f,0x62,
0x63,0x62,0x5f,0x5d,0x60,0x64,0x66,0x62,0x60,0x5c,0x59,0x5c,0x60,0x61,0x65,0x62,
0x5f,0x5f,0x60,0x63,0x64,0x65,0x63,0x60,0x5f,0x60,0x60,0x63,0x62,0x60,0x5f,0x5f,
0x5f,0x62,0x60,0x5f,0x5f,0x5e,0x5d,0x60,0x63,0x64,0x64,0x63,0x63,0x62,0x60,0x60,
0x61,0x62,0x61,0x60,0x5e,0x5f,0x5f,0x62,0x63,0x63,0x63,0x63,0x62,0x60,0x5f,0x60,
0x60,0x60,0x5f,0x5d,0x5d,0x5c,0x59,0x5d,0x5d,0x5c,0x5c,0x5c,0x5c,0x5e,0x60,0x60,
0x61,0x61,0x63,0x63,0x63,0x63,0x64,0x65,0x63,0x60,0x5d,0x5d,0x5f,0x61,0x63,0x62,
0x60,0x60,0x60,0x60,0x61,0x62,0x61,0x62,0x5f,0x5d,0x5d,0x5d,0x5c,0x5d,0x5e,0x5f,
0x5f,0x60,0x60,0x61,0x5f,0x5e,0x5f,0x60,0x62,0x62,0x60,0x60,0x60,0x61,0x61,0x62,
0x63,0x63,0x62,0x61,0x5f,0x5f,0x60,0x62,0x60,0x60,0x60,0x62,0x60,0x60,0x5f,0x60,
0x61,0x61,0x5f,0x5f,0x5c,0x5c,0x5e,0x5f,0x60,0x60,0x5f,0x5e,0x5e,0x5e,0x60,0x61,
0x62,0x61,0x61,0x60,0x60,0x61,0x63,0x64,0x61,0x60,0x5d,0x5c,0x5b,0x5c,0x5c,0x5d,
0x5d,0x5e,0x5e,0x5f,0x5e,0x60,0x61,0x60,0x5d,0x5c,0x5d,0x5d,0x61,0x62,0x60,0x60,
0x60,0x5f,0x60,0x61,0x63,0x62,0x5f,0x5c,0x5c,0x5e,0x60,0x60,0x65,0x64,0x61,0x61,
0x61,0x62,0x65,0x66,0x63,0x62,0x61,0x63,0x60,0x63,0x62,0x62,0x63,0x62,0x60,0x5f,
0x5e,0x5d,0x5f,0x5f,0x5f,0x5d,0x5d,0x5d,0x5f,0x5f,0x5f,0x60,0x5d,0x5c,0x5b,0x5d,
0x5e,0x5f,0x60,0x60,0x5f,0x5d,0x5d,0x5f,0x62,0x64,0x64,0x63,0x60,0x5f,0x5e,0x5e,
0x5e,0x60,0x61,0x64,0x63,0x60,0x5f,0x5f,0x61,0x61,0x61,0x63,0x61,0x5f,0x5e,0x5e,
0x60,0x61,0x62,0x63,0x64,0x63,0x60,0x5f,0x5f,0x5f,0x60,0x61,0x62,0x60,0x60,0x60,
0x5f,0x60,0x61,0x62,0x63,0x61,0x60,0x5f,0x60,0x61,0x60,0x63,0x62,0x60,0x5f,0x5f,
0x5f,0x5f,0x5e,0x5e,0x60,0x60,0x63,0x62,0x62,0x60,0x60,0x61,0x62,0x63,0x65,0x63,
0x60,0x5f,0x5e,0x5e,0x60,0x5f,0x5f,0x60,0x5e,0x5d,0x5d,0x5e,0x5f,0x5f,0x5f,0x5f,
0x5f,0x5d,0x5d,0x5d,0x5f,0x5e,0x5d,0x5d,0x5d,0x5c,0x5d,0x5f,0x5f,0x5f,0x5e,0x5c,
0x59,0x58,0x56,0x52,0x51,0x4b,0x44,0x40,0x3b,0x38,0x36,0x34,0x32,0x32,0x32,0x32,
0x32,0x32,0x33,0x35,0x37,0x38,0x38,0x39,0x38,0x38,0x38,0x38,0x36,0x35,0x33,0x35,
0x36,0x36,0x38,0x39,0x39,0x38,0x36,0x36,0x36,0x37,0x38,0x36,0x35,0x34,0x32,0x30,
0x30,0x31,0x32,0x35,0x35,0x36,0x36,0x36,0x35,0x35,0x36,0x35,0x33,0x32,0x32,0x30,
0x33,0x34,0x33,0x35,0x36,0x35,0x35,0x35,0x35,0x34,0x33,0x32,0x32,0x35,0x35,0x35,
0x36,0x36,0x36,0x36,0x33,0x31,0x2f,0x2f,0x2e,0x31,0x33,0x35,0x35,0x36,0x36,0x38,
0x39,0x39,0x38,0x36,0x34,0x33,0x34,0x34,0x33,0x32,0x30,0x2f,0x30,0x30,0x33,0x35,
// Line 20
0x38,0x38,0x39,0x3a,0x3a,0x39,0x37,0x37,0x38,0x38,0x39,0x37,0x34,0x33,0x32,0x32,
0x33,0x35,0x36,0x39,0x39,0x38,0x36,0x36,0x35,0x35,0x37,0x3a,0x3e,0x47,0x51,0x5c,
0x69,0x77,0x86,0x98,0xa7,0xb3,0xb9,0xbc,0xbe,0xc0,0xc3,0xc4,0xc4,0xc2,0xc0,0xbc,
0xbb,0xbb,0xbc,0xbe,0xbe,0xbb,0xba,0xb9,0xba,0xbb,0xbe,0xbf,0xbf,0xbe,0xbe,0xbf,
0xbe,0xbe,0xbc,0xbd,0xbc,0xbb,0xbb,0xbb,0xbc,0xbd,0xbd,0xbe,0xbc,0xbb,0xbb,0xbc,
0xbd,0xbe,0xbe,0xc0,0xc0,0xbf,0xc0,0xbe,0xbe,0xbf,0xbf,0xbe,0xbe,0xbe,0xbe,0xbd,
0xbe,0xbe,0xbe,0xbe,0xbd,0xbc,0xbc,0xbc,0xba,0xbc,0xbc,0xbc,0xbd,0xbc,0xbb,0xbc,
0xbc,0xbe,0xbe,0xbe,0xbd,0xbd,0xbd,0xbf,0xbf,0xbe,0xbe,0xbc,0xbd,0xbc,0xbd,0xbd,
0xbc,0xbb,0xbc,0xbd,0xbf,0xbe,0xbe,0xbe,0xbd,0xbe,0xbe,0xbc,0xc0,0xbf,0xbe,0xbd,
0xbc,0xbd,0xbd,0xbd,0xbd,0xbe,0xbd,0xbd,0xba,0xb8,0xb8,0xba,0xba,0xb9,0xba,0xba,
0xb9,0xb8,0xba,0xbb,0xbc,0xbd,0xbd,0xbc,0xbd,0xbd,0xbd,0xbe,0xbf,0xbf,0xbe,0xbe,
0xbd,0xbe,0xbf,0xbe,0xbc,0xbd,0xbd,0xbd,0xbc,0xba,0xba,0xbc,0xbc,0xbd,0xbe,0xbf,
0xbd,0xbc,0xbc,0xbb,0xb7,0xb5,0xb1,0xaa,0xa6,0xa0,0x99,0x92,0x8a,0x82,0x7d,0x79,
0x76,0x74,0x72,0x71,0x72,0x71,0x6f,0x6f,0x6f,0x6f,0x6e,0x6e,0x6b,0x6b,0x6c,0x6d,
0x6e,0x6f,0x70,0x71,0x70,0x6e,0x6e,0x71,0x73,0x74,0x71,0x73,0x70,0x6e,0x6e,0x6f,
0x70,0x73,0x72,0x6f,0x6e,0x6d,0x6e,0x70,0x72,0x73,0x74,0x75,0x71,0x6e,0x6e,0x6f,
0x70,0x71,0x70,0x6f,0x6e,0x6c,0x6b,0x6d,0x6f,0x73,0x72,0x72,0x73,0x77,0x7e,0x85,
0x87,0x8e,0x90,0x92,0x94,0x96,0x97,0x9a,0x99,0x96,0x94,0x93,0x91,0x91,0x8e,0x8b,
0x85,0x80,0x7c,0x78,0x73,0x6c,0x66,0x63,0x5d,0x58,0x55,0x53,0x51,0x50,0x4c,0x49,
0x46,0x45,0x45,0x47,0x48,0x48,0x47,0x49,0x4c,0x50,0x55,0x58,0x5c,0x63,0x64,0x64,
0x6a,0x71,0x78,0x7c,0x80,0x84,0x88,0x8b,0x8f,0x92,0x97,0x98,0x96,0x96,0x96,0x94,
0x94,0x94,0x94,0x94,0x93,0x91,0x8e,0x8b,0x87,0x85,0x84,0x80,0x7b,0x76,0x70,0x6b,
0x68,0x64,0x5f,0x5d,0x58,0x54,0x50,0x4c,0x4a,0x49,0x49,0x48,0x47,0x48,0x47,0x45,
0x49,0x4a,0x4a,0x4d,0x50,0x55,0x5a,0x5e,0x60,0x66,0x6d,0x74,0x7a,0x7e,0x80,0x85,
0x89,0x8b,0x8c,0x8e,0x90,0x93,0x94,0x95,0x96,0x96,0x96,0x95,0x94,0x93,0x92,0x92,
0x8e,0x8b,0x86,0x84,0x80,0x7b,0x78,0x73,0x6e,0x6b,0x65,0x5f,0x5d,0x57,0x52,0x51,
0x4e,0x4d,0x4c,0x4a,0x48,0x48,0x49,0x4a,0x4a,0x4c,0x4e,0x50,0x52,0x52,0x55,0x59,
0x5e,0x5f,0x63,0x69,0x6e,0x74,0x7a,0x80,0x86,0x8a,0x8d,0x92,0x96,0x99,0x98,0x9a,
0x9a,0x9b,0x99,0x97,0x96,0x96,0x96,0x94,0x91,0x8c,0x87,0x85,0x85,0x82,0x7b,0x77,
0x70,0x6c,0x69,0x66,0x63,0x61,0x5d,0x57,0x51,0x4c,0x4b,0x49,0x4b,0x49,0x47,0x46,
0x45,0x45,0x4a,0x4f,0x55,0x5d,0x62,0x67,0x6b,0x6c,0x6b,0x6c,0x6e,0x71,0x71,0x70,
0x6d,0x6b,0x6d,0x6f,0x70,0x72,0x75,0x75,0x75,0x74,0x73,0x72,0x73,0x71,0x71,0x70,
0x6f,0x70,0x70,0x70,0x71,0x73,0x71,0x6f,0x70,0x71,0x70,0x72,0x72,0x70,0x6f,0x6f,
0x6f,0x70,0x71,0x72,0x70,0x6f,0x6d,0x6c,0x6f,0x70,0x70,0x71,0x70,0x6f,0x6f,0x70,
0x71,0x73,0x71,0x70,0x6f,0x6e,0x6d,0x6e,0x6e,0x6f,0x70,0x73,0x73,0x73,0x72,0x73,
0x73,0x73,0x70,0x6e,0x6a,0x63,0x5d,0x59,0x56,0x55,0x52,0x55,0x57,0x5c,0x64,0x6e,
0x78,0x82,0x8b,0x91,0x94,0x94,0x8f,0x8b,0x84,0x7b,0x71,0x66,0x5d,0x55,0x4d,0x48,
0x47,0x49,0x4d,0x53,0x59,0x61,0x6b,0x77,0x82,0x8a,0x91,0x94,0x92,0x8e,0x89,0x84,
0x7a,0x70,0x64,0x5b,0x54,0x4e,0x49,0x46,0x47,0x4c,0x53,0x58,0x5d,0x67,0x74,0x80,
0x89,0x8e,0x91,0x90,0x90,0x87,0x7e,0x76,0x6f,0x66,0x5f,0x54,0x4b,0x48,0x49,0x4c,
0x51,0x54,0x58,0x63,0x6d,0x77,0x80,0x8a,0x91,0x95,0x94,0x8e,0x86,0x7f,0x75,0x6b,
0x62,0x57,0x4e,0x4a,0x47,0x46,0x48,0x4d,0x55,0x5d,0x64,0x6d,0x75,0x7e,0x89,0x8d,
0x92,0x91,0x8b,0x89,0x81,0x77,0x6c,0x63,0x5a,0x54,0x4e,0x4a,0x49,0x4a,0x4d,0x51,
0x5a,0x64,0x70,0x7b,0x84,0x8c,0x92,0x94,0x91,0x8d,0x85,0x7c,0x73,0x68,0x5f,0x57,
0x4f,0x4a,0x48,0x4b,0x4e,0x53,0x5a,0x5f,0x67,0x70,0x79,0x81,0x85,0x86,0x85,0x84,
0x80,0x7b,0x77,0x75,0x70,0x6e,0x6b,0x6c,0x6d,0x6e,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f,
0x6e,0x6d,0x6d,0x6e,0x6f,0x70,0x71,0x71,0x70,0x71,0x6f,0x6c,0x6e,0x6e,0x6d,0x6f,
0x6e,0x6c,0x6d,0x6d,0x6e,0x6f,0x6e,0x6f,0x6d,0x6f,0x6f,0x6f,0x70,0x71,0x6e,0x73,
0x71,0x70,0x71,0x70,0x70,0x6f,0x6e,0x6f,0x71,0x72,0x71,0x71,0x71,0x71,0x73,0x75,
0x75,0x76,0x73,0x70,0x6c,0x6b,0x69,0x67,0x64,0x62,0x63,0x68,0x6f,0x77,0x7e,0x82,
0x82,0x7e,0x76,0x6c,0x63,0x5d,0x57,0x53,0x54,0x5a,0x63,0x71,0x7e,0x87,0x8b,0x89,
0x83,0x79,0x6d,0x5e,0x52,0x4f,0x50,0x55,0x5e,0x6b,0x7a,0x87,0x8b,0x8a,0x84,0x7b,
0x70,0x67,0x5d,0x55,0x51,0x51,0x58,0x67,0x77,0x84,0x8c,0x8e,0x89,0x7e,0x72,0x67,
0x5e,0x58,0x52,0x51,0x56,0x60,0x6f,0x7c,0x88,0x8d,0x8a,0x80,0x75,0x6a,0x5f,0x57,
0x50,0x4f,0x52,0x5c,0x69,0x77,0x82,0x8b,0x8b,0x85,0x7b,0x6e,0x62,0x5a,0x54,0x51,
0x52,0x59,0x64,0x73,0x80,0x88,0x89,0x85,0x7b,0x6e,0x63,0x5b,0x53,0x50,0x51,0x57,
0x63,0x73,0x80,0x88,0x8e,0x88,0x7b,0x73,0x6a,0x61,0x5d,0x58,0x56,0x58,0x5d,0x64,
0x6b,0x75,0x7a,0x7a,0x78,0x75,0x70,0x71,0x6f,0x6c,0x6b,0x69,0x69,0x6c,0x6d,0x70,
0x71,0x72,0x70,0x6e,0x6b,0x6b,0x6e,0x71,0x71,0x70,0x70,0x6f,0x6f,0x71,0x73,0x73,
0x72,0x70,0x6d,0x6d,0x6d,0x70,0x6f,0x6f,0x6e,0x6e,0x6e,0x6f,0x70,0x74,0x70,0x6d,
0x6a,0x69,0x6a,0x70,0x78,0x7b,0x7b,0x74,0x6b,0x60,0x5f,0x63,0x6b,0x76,0x7f,0x80,
0x77,0x68,0x5c,0x5a,0x61,0x6b,0x76,0x7b,0x79,0x72,0x67,0x5e,0x5d,0x62,0x6c,0x76,
0x7e,0x7d,0x77,0x6e,0x63,0x5a,0x5c,0x63,0x70,0x7c,0x82,0x81,0x78,0x6c,0x60,0x5b,
0x60,0x6b,0x77,0x81,0x82,0x7a,0x6e,0x63,0x5b,0x5e,0x66,0x73,0x7c,0x7f,0x7a,0x71,
0x66,0x5b,0x57,0x5c,0x66,0x71,0x7b,0x7f,0x7b,0x74,0x66,0x5e,0x5e,0x66,0x71,0x7d,
0x82,0x7d,0x75,0x69,0x5e,0x57,0x5b,0x66,0x74,0x80,0x84,0x7e,0x75,0x66,0x5a,0x5a,
0x63,0x70,0x7d,0x84,0x81,0x76,0x68,0x5e,0x5b,0x63,0x6e,0x78,0x7b,0x77,0x6f,0x67,
0x61,0x63,0x6c,0x75,0x7b,0x7c,0x76,0x6e,0x67,0x66,0x67,0x6b,0x6f,0x73,0x75,0x73,
0x70,0x6d,0x6e,0x6c,0x6b,0x6e,0x70,0x71,0x72,0x71,0x70,0x70,0x6f,0x6e,0x6c,0x6d,
0x6e,0x70,0x71,0x71,0x6f,0x70,0x6f,0x6d,0x6c,0x6c,0x6e,0x6e,0x6d,0x6d,0x6d,0x6d,
0x6e,0x6e,0x70,0x71,0x73,0x71,0x70,0x71,0x73,0x75,0x75,0x75,0x73,0x6f,0x6c,0x6b,
0x6e,0x75,0x7a,0x78,0x70,0x66,0x5f,0x60,0x6a,0x77,0x81,0x81,0x75,0x65,0x5a,0x5c,
0x69,0x7b,0x86,0x85,0x76,0x61,0x51,0x52,0x63,0x7a,0x8b,0x8b,0x7b,0x64,0x54,0x54,
0x63,0x7c,0x8d,0x8e,0x7d,0x63,0x50,0x52,0x64,0x7c,0x8a,0x89,0x76,0x5e,0x4d,0x4e,
0x60,0x79,0x89,0x88,0x78,0x63,0x52,0x55,0x66,0x7e,0x8d,0x8c,0x7a,0x5f,0x4e,0x50,
0x62,0x79,0x89,0x86,0x7a,0x5f,0x4f,0x52,0x64,0x7c,0x8d,0x8a,0x76,0x60,0x51,0x55,
0x65,0x7c,0x8a,0x89,0x77,0x60,0x50,0x55,0x66,0x7b,0x87,0x86,0x77,0x63,0x55,0x57,
0x69,0x7e,0x89,0x87,0x77,0x64,0x58,0x5a,0x64,0x73,0x7b,0x7b,0x73,0x6a,0x64,0x67,
0x70,0x77,0x79,0x78,0x73,0x6d,0x67,0x69,0x6a,0x6d,0x6e,0x6e,0x6a,0x6e,0x6e,0x6f,
0x70,0x71,0x70,0x70,0x70,0x6f,0x6f,0x70,0x6f,0x6c,0x6b,0x6b,0x6c,0x6e,0x6e,0x6f,
0x6f,0x6d,0x6e,0x70,0x70,0x6f,0x70,0x70,0x70,0x71,0x73,0x75,0x75,0x75,0x73,0x73,
0x73,0x72,0x6f,0x6e,0x6d,0x6e,0x70,0x73,0x75,0x75,0x70,0x6c,0x6c,0x6f,0x73,0x76,
0x74,0x6f,0x69,0x66,0x66,0x6b,0x72,0x78,0x76,0x71,0x69,0x67,0x6b,0x72,0x77,0x79,
0x74,0x6b,0x64,0x65,0x6b,0x75,0x7c,0x7b,0x72,0x6a,0x66,0x6b,0x74,0x7a,0x78,0x73,
0x67,0x61,0x64,0x6e,0x76,0x7a,0x76,0x6c,0x66,0x68,0x6f,0x76,0x7a,0x75,0x6c,0x66,
0x66,0x6d,0x76,0x79,0x74,0x6c,0x67,0x6a,0x70,0x78,0x7b,0x77,0x6f,0x69,0x68,0x71,
0x79,0x7b,0x75,0x6b,0x63,0x66,0x6c,0x73,0x77,0x73,0x6b,0x63,0x67,0x71,0x7c,0x80,
0x7a,0x6c,0x65,0x64,0x6e,0x7a,0x7c,0x74,0x6a,0x5f,0x60,0x6e,0x7b,0x82,0x7d,0x6e,
0x60,0x5e,0x67,0x75,0x7b,0x77,0x6b,0x5f,0x5b,0x61,0x6f,0x7c,0x7e,0x75,0x69,0x63,
0x68,0x73,0x7b,0x7b,0x75,0x6c,0x67,0x6b,0x72,0x78,0x78,0x74,0x6e,0x6a,0x6c,0x70,
0x73,0x75,0x71,0x6c,0x67,0x69,0x6c,0x73,0x75,0x71,0x6c,0x6d,0x6f,0x72,0x74,0x71,
0x6e,0x6c,0x6d,0x70,0x74,0x75,0x75,0x71,0x6e,0x6d,0x70,0x75,0x75,0x72,0x6e,0x6a,
0x6a,0x6d,0x6f,0x71,0x71,0x6f,0x6b,0x6b,0x6d,0x70,0x6e,0x70,0x6d,0x6c,0x6d,0x6f,
0x70,0x71,0x6f,0x6d,0x6c,0x6e,0x6f,0x72,0x72,0x6f,0x6f,0x6f,0x70,0x71,0x73,0x72,
0x6f,0x6d,0x6b,0x6b,0x6c,0x6c,0x6c,0x6d,0x6d,0x6d,0x6d,0x6d,0x6d,0x6d,0x6a,0x66,
0x60,0x59,0x51,0x4c,0x47,0x43,0x3f,0x3c,0x39,0x37,0x36,0x33,0x31,0x35,0x37,0x37,
// Line 21
0x36,0x36,0x35,0x37,0x38,0x3a,0x38,0x37,0x36,0x35,0x36,0x38,0x37,0x37,0x38,0x3a,
0x3a,0x3a,0x3b,0x3b,0x3c,0x3a,0x38,0x38,0x37,0x36,0x36,0x37,0x38,0x37,0x36,0x36,
0x36,0x38,0x38,0x38,0x37,0x37,0x38,0x3a,0x3a,0x38,0x39,0x3c,0x3d,0x3f,0x3f,0x40,
0x41,0x43,0x43,0x44,0x47,0x4b,0x4d,0x53,0x54,0x57,0x5a,0x5e,0x60,0x62,0x60,0x60,
0x60,0x61,0x63,0x65,0x65,0x63,0x65,0x67,0x68,0x66,0x65,0x63,0x61,0x5f,0x5b,0x58,
0x55,0x51,0x4e,0x4c,0x4a,0x49,0x47,0x47,0x43,0x40,0x40,0x42,0x41,0x3f,0x3d,0x3c,
0x3a,0x38,0x38,0x3a,0x3d,0x3e,0x3e,0x3e,0x3f,0x3e,0x44,0x47,0x4b,0x4e,0x4f,0x4f,
0x51,0x53,0x55,0x59,0x5d,0x5e,0x5e,0x60,0x5f,0x5f,0x60,0x61,0x63,0x63,0x63,0x64,
0x66,0x65,0x64,0x62,0x5f,0x5d,0x5c,0x5b,0x58,0x56,0x54,0x51,0x4e,0x4b,0x4b,0x4a,
0x49,0x47,0x44,0x43,0x41,0x3f,0x40,0x3f,0x3f,0x41,0x41,0x40,0x3f,0x3f,0x3e,0x40,
0x42,0x45,0x47,0x49,0x47,0x47,0x4a,0x4d,0x50,0x53,0x57,0x5a,0x5c,0x5d,0x5e,0x62,
0x66,0x69,0x6c,0x6d,0x6b,0x68,0x66,0x65,0x65,0x65,0x64,0x61,0x5f,0x5c,0x58,0x58,
0x58,0x59,0x59,0x57,0x52,0x4e,0x4a,0x48,0x47,0x46,0x42,0x3f,0x3d,0x3c,0x3a,0x3a,
0x38,0x38,0x3a,0x3b,0x3a,0x3a,0x3a,0x3d,0x3f,0x40,0x41,0x43,0x43,0x45,0x47,0x4d,
0x4f,0x53,0x57,0x57,0x58,0x5b,0x5f,0x61,0x62,0x63,0x62,0x62,0x62,0x63,0x62,0x66,
0x65,0x62,0x63,0x65,0x65,0x63,0x60,0x5e,0x5d,0x5b,0x57,0x55,0x54,0x52,0x50,0x4d,
0x4b,0x4a,0x4a,0x48,0x47,0x46,0x44,0x41,0x3f,0x3e,0x3c,0x3e,0x40,0x40,0x3f,0x3f,
0x40,0x42,0x44,0x46,0x48,0x4a,0x4a,0x4b,0x4d,0x4f,0x51,0x56,0x57,0x57,0x59,0x5b,
0x5f,0x63,0x65,0x66,0x66,0x68,0x69,0x6b,0x6b,0x6a,0x69,0x69,0x68,0x65,0x62,0x60,
0x5f,0x5f,0x5e,0x59,0x55,0x53,0x51,0x4f,0x4c,0x4a,0x48,0x47,0x43,0x3f,0x3e,0x3e,
0x3e,0x3d,0x3a,0x38,0x39,0x39,0x3a,0x3b,0x3e,0x41,0x44,0x45,0x45,0x46,0x47,0x49,
0x4b,0x4d,0x4f,0x50,0x51,0x52,0x51,0x55,0x5b,0x60,0x63,0x65,0x65,0x66,0x66,0x66,
0x66,0x6b,0x6b,0x6a,0x69,0x67,0x65,0x65,0x63,0x61,0x62,0x60,0x5d,0x58,0x53,0x4e,
0x4c,0x4a,0x49,0x48,0x46,0x43,0x40,0x3f,0x40,0x40,0x41,0x41,0x3f,0x3f,0x3d,0x3c,
0x3c,0x3c,0x3d,0x41,0x42,0x44,0x43,0x47,0x48,0x4c,0x4e,0x50,0x52,0x57,0x59,0x58,
0x5b,0x5d,0x5e,0x60,0x61,0x65,0x69,0x6c,0x6e,0x6d,0x6c,0x6b,0x68,0x66,0x65,0x64,
0x61,0x5d,0x59,0x58,0x57,0x57,0x56,0x55,0x52,0x51,0x4e,0x4c,0x4a,0x48,0x47,0x45,
0x43,0x40,0x3d,0x3f,0x3c,0x3a,0x3a,0x3c,0x3b,0x3a,0x39,0x3a,0x3a,0x3a,0x39,0x3a,
0x3a,0x39,0x38,0x39,0x3a,0x3a,0x3a,0x38,0x38,0x3a,0x3b,0x3a,0x39,0x37,0x37,0x38,
0x37,0x35,0x34,0x36,0x36,0x34,0x34,0x35,0x37,0x39,0x3b,0x3a,0x3a,0x3a,0x3a,0x3a,
0x38,0x38,0x3a,0x3a,0x39,0x36,0x36,0x36,0x37,0x39,0x39,0x38,0x38,0x36,0x34,0x35,
0x36,0x38,0x3a,0x3a,0x37,0x37,0x37,0x38,0x38,0x37,0x37,0x37,0x38,0x39,0x3a,0x3a,
0x3a,0x3a,0x3a,0x3a,0x38,0x38,0x39,0x39,0x3a,0x38,0x38,0x37,0x3a,0x39,0x38,0x3a,
0x3a,0x38,0x38,0x38,0x39,0x3a,0x3c,0x3f,0x44,0x48,0x4b,0x53,0x59,0x5d,0x60,0x65,
0x68,0x6b,0x6b,0x6b,0x6a,0x6a,0x68,0x66,0x66,0x66,0x65,0x66,0x64,0x64,0x66,0x69,
0x69,0x68,0x67,0x65,0x66,0x67,0x68,0x69,0x6a,0x69,0x66,0x67,0x68,0x69,0x69,0x6a,
0x69,0x68,0x68,0x69,0x67,0x67,0x68,0x68,0x69,0x6a,0x6b,0x6b,0x69,0x65,0x61,0x5c,
0x58,0x55,0x4f,0x49,0x43,0x3c,0x37,0x34,0x34,0x36,0x35,0x36,0x37,0x3a,0x3a,0x3b,
0x3a,0x3a,0x3c,0x3d,0x3c,0x3a,0x39,0x3a,0x3a,0x38,0x34,0x34,0x38,0x3b,0x3b,0x37,
0x34,0x35,0x36,0x37,0x38,0x3a,0x39,0x3a,0x38,0x36,0x35,0x38,0x3b,0x3c,0x39,0x36,
0x34,0x37,0x3a,0x3b,0x3b,0x39,0x38,0x39,0x37,0x36,0x36,0x38,0x37,0x37,0x37,0x36,
0x35,0x37,0x38,0x38,0x37,0x36,0x36,0x3a,0x3b,0x38,0x38,0x3a,0x3a,0x3a,0x37,0x35,
0x33,0x34,0x36,0x35,0x37,0x36,0x37,0x3a,0x3a,0x3a,0x3a,0x3b,0x3a,0x3a,0x38,0x38,
0x38,0x38,0x37,0x38,0x36,0x34,0x33,0x34,0x34,0x35,0x38,0x38,0x38,0x39,0x3a,0x3a,
0x3a,0x3b,0x3a,0x3a,0x38,0x37,0x36,0x36,0x37,0x37,0x37,0x37,0x35,0x36,0x37,0x38,
0x38,0x38,0x37,0x3a,0x3a,0x3a,0x3a,0x38,0x36,0x36,0x35,0x36,0x37,0x35,0x34,0x33,
0x33,0x33,0x34,0x38,0x39,0x39,0x39,0x3a,0x39,0x3a,0x3b,0x3b,0x3a,0x38,0x36,0x35,
0x34,0x34,0x34,0x38,0x38,0x37,0x36,0x36,0x37,0x3a,0x3e,0x42,0x46,0x4a,0x4d,0x52,
0x58,0x5f,0x61,0x65,0x66,0x66,0x66,0x65,0x63,0x65,0x65,0x65,0x66,0x66,0x65,0x66,
0x66,0x64,0x65,0x68,0x69,0x68,0x66,0x65,0x64,0x66,0x67,0x69,0x6a,0x69,0x67,0x66,
0x65,0x64,0x65,0x68,0x68,0x69,0x6a,0x69,0x67,0x66,0x67,0x68,0x69,0x67,0x65,0x67,
0x62,0x5e,0x5a,0x59,0x58,0x54,0x4f,0x48,0x44,0x41,0x3f,0x3c,0x3c,0x3a,0x38,0x3a,
0x38,0x36,0x38,0x3a,0x39,0x39,0x37,0x35,0x34,0x35,0x35,0x37,0x38,0x39,0x38,0x37,
0x37,0x36,0x37,0x37,0x36,0x35,0x34,0x32,0x32,0x32,0x32,0x33,0x33,0x32,0x34,0x35,
0x36,0x35,0x36,0x36,0x38,0x39,0x39,0x38,0x38,0x37,0x36,0x36,0x36,0x36,0x36,0x34,
0x31,0x33,0x35,0x36,0x35,0x36,0x34,0x34,0x35,0x36,0x37,0x38,0x37,0x35,0x37,0x38,
0x39,0x3b,0x3b,0x3b,0x3a,0x3a,0x3b,0x3c,0x3a,0x39,0x37,0x36,0x35,0x34,0x33,0x34,
0x35,0x38,0x38,0x37,0x38,0x38,0x38,0x38,0x39,0x3a,0x38,0x3a,0x37,0x36,0x36,0x35,
0x33,0x34,0x37,0x3a,0x3e,0x40,0x43,0x49,0x4e,0x52,0x57,0x5d,0x61,0x63,0x63,0x62,
0x63,0x63,0x63,0x65,0x66,0x65,0x62,0x62,0x63,0x63,0x65,0x67,0x68,0x68,0x68,0x68,
0x66,0x66,0x67,0x69,0x69,0x68,0x65,0x67,0x66,0x66,0x66,0x65,0x65,0x66,0x66,0x66,
0x67,0x68,0x69,0x6a,0x68,0x67,0x68,0x69,0x69,0x68,0x67,0x66,0x65,0x65,0x64,0x64,
0x65,0x66,0x66,0x68,0x69,0x6b,0x69,0x67,0x66,0x67,0x68,0x6b,0x6c,0x6b,0x68,0x66,
0x67,0x67,0x67,0x6a,0x69,0x67,0x65,0x65,0x65,0x67,0x6a,0x6b,0x6b,0x6b,0x69,0x67,
0x68,0x66,0x66,0x68,0x65,0x65,0x67,0x69,0x68,0x68,0x67,0x69,0x68,0x67,0x65,0x65,
0x66,0x65,0x64,0x65,0x68,0x69,0x6a,0x68,0x67,0x67,0x65,0x64,0x65,0x68,0x6a,0x6b,
0x68,0x65,0x65,0x66,0x68,0x66,0x69,0x67,0x66,0x67,0x65,0x65,0x65,0x66,0x67,0x69,
0x68,0x66,0x65,0x63,0x64,0x66,0x69,0x6a,0x68,0x69,0x67,0x65,0x66,0x67,0x68,0x6a,
0x69,0x67,0x67,0x67,0x67,0x68,0x69,0x68,0x67,0x67,0x67,0x66,0x63,0x60,0x5c,0x5b,
0x57,0x52,0x4f,0x4c,0x47,0x44,0x41,0x3e,0x3c,0x3b,0x3a,0x3a,0x3d,0x3e,0x3c,0x3a,
0x37,0x37,0x38,0x38,0x37,0x37,0x36,0x35,0x34,0x33,0x36,0x39,0x3a,0x3b,0x3a,0x3a,
0x3a,0x3a,0x39,0x38,0x38,0x3a,0x37,0x35,0x35,0x37,0x37,0x38,0x38,0x37,0x36,0x35,
0x35,0x33,0x34,0x37,0x38,0x37,0x37,0x39,0x3e,0x43,0x47,0x4d,0x4f,0x53,0x59,0x5e,
0x62,0x66,0x68,0x69,0x68,0x69,0x68,0x69,0x6a,0x6a,0x68,0x67,0x65,0x65,0x66,0x66,
0x66,0x66,0x65,0x67,0x68,0x69,0x67,0x67,0x6b,0x6e,0x6e,0x70,0x6e,0x6c,0x6b,0x69,
0x66,0x66,0x68,0x6b,0x6b,0x68,0x65,0x65,0x63,0x63,0x66,0x68,0x68,0x67,0x63,0x5f,
0x5b,0x5a,0x5a,0x57,0x52,0x4c,0x46,0x41,0x3c,0x3a,0x3a,0x3a,0x39,0x3a,0x3a,0x3b,
0x3b,0x3b,0x3b,0x3a,0x3c,0x3c,0x3b,0x3a,0x37,0x33,0x32,0x32,0x33,0x35,0x38,0x37,
0x35,0x34,0x33,0x34,0x37,0x38,0x38,0x3a,0x37,0x34,0x33,0x34,0x36,0x38,0x38,0x39,
0x38,0x38,0x38,0x38,0x39,0x3b,0x3a,0x3a,0x38,0x37,0x37,0x36,0x34,0x33,0x32,0x33,
0x32,0x32,0x33,0x35,0x35,0x34,0x34,0x37,0x39,0x3a,0x3a,0x39,0x38,0x37,0x37,0x37,
0x37,0x37,0x37,0x37,0x34,0x31,0x32,0x35,0x37,0x37,0x37,0x38,0x36,0x38,0x37,0x37,
0x39,0x3a,0x38,0x36,0x35,0x34,0x34,0x34,0x35,0x34,0x37,0x37,0x37,0x38,0x38,0x38,
0x37,0x37,0x37,0x38,0x39,0x38,0x38,0x36,0x34,0x35,0x35,0x37,0x36,0x36,0x34,0x35,
0x36,0x36,0x35,0x36,0x35,0x34,0x35,0x37,0x36,0x35,0x34,0x33,0x34,0x34,0x35,0x33,
0x38,0x37,0x34,0x34,0x36,0x36,0x38,0x38,0x37,0x38,0x37,0x34,0x34,0x33,0x34,0x36,
0x34,0x34,0x34,0x36,0x36,0x35,0x34,0x35,0x35,0x37,0x36,0x38,0x3f,0x46,0x4a,0x4f,
0x51,0x56,0x5c,0x62,0x66,0x69,0x69,0x67,0x65,0x63,0x64,0x65,0x68,0x68,0x67,0x67,
0x66,0x65,0x66,0x67,0x68,0x6b,0x6a,0x69,0x68,0x68,0x67,0x68,0x69,0x6b,0x6a,0x6a,
0x68,0x66,0x66,0x67,0x67,0x68,0x68,0x68,0x67,0x66,0x65,0x65,0x66,0x66,0x67,0x67,
0x67,0x66,0x65,0x60,0x5b,0x59,0x55,0x50,0x4b,0x45,0x3f,0x3d,0x3b,0x3a,0x39,0x37,
0x36,0x37,0x37,0x38,0x38,0x39,0x38,0x36,0x37,0x37,0x37,0x38,0x37,0x35,0x34,0x34,
0x34,0x36,0x36,0x37,0x38,0x38,0x37,0x36,0x36,0x35,0x35,0x36,0x37,0x37,0x38,0x36,
0x34,0x36,0x38,0x3a,0x38,0x38,0x36,0x35,0x34,0x34,0x34,0x36,0x37,0x35,0x35,0x35,
0x35,0x36,0x35,0x35,0x37,0x36,0x33,0x33,0x32,0x33,0x33,0x33,0x33,0x34,0x33,0x33,
0x32,0x33,0x34,0x35,0x35,0x33,0x32,0x33,0x34,0x34,0x34,0x38,0x39,0x38,0x37,0x37,
//Field 3
// Line 10
0x38,0x38,0x39,0x3b,0x39,0x37,0x36,0x36,0x39,0x3a,0x39,0x36,0x34,0x33,0x34,0x33,
0x33,0x35,0x36,0x36,0x35,0x36,0x38,0x3b,0x3c,0x3b,0x3a,0x3b,0x3a,0x39,0x38,0x37,
0x37,0x39,0x39,0x38,0x37,0x35,0x35,0x36,0x37,0x36,0x35,0x34,0x33,0x34,0x36,0x37,
0x38,0x3b,0x39,0x37,0x36,0x36,0x36,0x36,0x38,0x36,0x34,0x34,0x36,0x36,0x37,0x36,
0x36,0x36,0x37,0x34,0x33,0x33,0x34,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x38,0x3a,
0x39,0x3b,0x3a,0x39,0x3a,0x3b,0x3d,0x3c,0x39,0x37,0x38,0x38,0x38,0x38,0x39,0x39,
0x37,0x36,0x35,0x34,0x38,0x38,0x37,0x36,0x34,0x33,0x35,0x36,0x39,0x3a,0x3a,0x39,
0x38,0x36,0x36,0x37,0x39,0x39,0x38,0x36,0x34,0x33,0x36,0x39,0x3b,0x3b,0x3b,0x3a,
0x3b,0x3b,0x3b,0x3b,0x3a,0x38,0x36,0x33,0x33,0x33,0x34,0x34,0x35,0x36,0x35,0x34,
0x36,0x37,0x36,0x38,0x38,0x37,0x39,0x39,0x37,0x38,0x3b,0x3c,0x3c,0x3b,0x3a,0x39,
0x37,0x37,0x37,0x36,0x33,0x32,0x33,0x33,0x34,0x35,0x36,0x37,0x37,0x37,0x39,0x3a,
0x3a,0x38,0x36,0x36,0x35,0x34,0x36,0x36,0x34,0x36,0x37,0x37,0x39,0x39,0x39,0x39,
0x38,0x39,0x39,0x38,0x36,0x35,0x36,0x34,0x33,0x33,0x32,0x33,0x35,0x34,0x34,0x34,
0x36,0x38,0x39,0x39,0x38,0x39,0x38,0x37,0x36,0x36,0x35,0x35,0x33,0x30,0x2f,0x31,
0x33,0x34,0x36,0x36,0x37,0x39,0x39,0x39,0x39,0x3a,0x3a,0x3b,0x3b,0x3a,0x37,0x3a,
0x37,0x36,0x37,0x38,0x37,0x38,0x36,0x34,0x36,0x36,0x37,0x36,0x37,0x36,0x36,0x37,
0x39,0x39,0x39,0x38,0x36,0x36,0x36,0x38,0x3b,0x3d,0x3e,0x40,0x3f,0x3d,0x3c,0x3a,
0x3a,0x39,0x37,0x37,0x37,0x36,0x35,0x34,0x36,0x38,0x39,0x39,0x38,0x37,0x38,0x37,
0x36,0x36,0x38,0x39,0x3a,0x39,0x37,0x35,0x34,0x33,0x33,0x34,0x37,0x36,0x37,0x36,
0x36,0x39,0x3c,0x3d,0x3d,0x3b,0x39,0x39,0x38,0x37,0x37,0x37,0x34,0x33,0x34,0x34,
0x34,0x34,0x35,0x36,0x37,0x37,0x37,0x36,0x39,0x3a,0x3b,0x3a,0x39,0x38,0x39,0x36,
0x33,0x35,0x36,0x37,0x38,0x36,0x34,0x35,0x35,0x36,0x3a,0x3e,0x3d,0x3d,0x3b,0x39,
0x38,0x38,0x39,0x39,0x3b,0x3a,0x37,0x36,0x33,0x33,0x37,0x3a,0x3b,0x3b,0x3a,0x37,
0x37,0x36,0x37,0x38,0x38,0x37,0x36,0x34,0x35,0x36,0x3a,0x3b,0x3c,0x3c,0x3b,0x3a,
0x39,0x3b,0x3b,0x39,0x38,0x38,0x38,0x38,0x37,0x37,0x39,0x3a,0x38,0x36,0x36,0x35,
0x36,0x36,0x36,0x36,0x36,0x37,0x38,0x38,0x38,0x38,0x39,0x38,0x36,0x35,0x37,0x39,
0x3b,0x39,0x37,0x39,0x3a,0x3a,0x39,0x3b,0x3c,0x3b,0x3a,0x3a,0x3b,0x3b,0x3b,0x39,
0x39,0x39,0x38,0x39,0x38,0x37,0x3a,0x3a,0x38,0x38,0x39,0x39,0x3b,0x3b,0x3b,0x3b,
0x3d,0x3b,0x3a,0x3b,0x3b,0x3b,0x3a,0x37,0x34,0x34,0x34,0x34,0x34,0x36,0x37,0x3a,
0x3b,0x3b,0x3b,0x40,0x3c,0x3a,0x3a,0x3a,0x39,0x37,0x37,0x36,0x37,0x39,0x3b,0x3b,
0x3b,0x38,0x36,0x35,0x36,0x37,0x38,0x38,0x36,0x36,0x36,0x36,0x35,0x35,0x36,0x36,
0x37,0x37,0x36,0x38,0x39,0x39,0x39,0x39,0x3a,0x3d,0x3d,0x3b,0x3a,0x39,0x38,0x38,
0x37,0x38,0x39,0x3a,0x39,0x39,0x38,0x38,0x39,0x3a,0x3a,0x39,0x3a,0x39,0x37,0x37,
0x36,0x36,0x36,0x35,0x35,0x36,0x39,0x39,0x39,0x38,0x38,0x38,0x39,0x3b,0x39,0x3b,
0x3a,0x39,0x39,0x38,0x39,0x3b,0x3b,0x3a,0x39,0x39,0x38,0x37,0x37,0x37,0x39,0x3a,
0x3a,0x39,0x39,0x37,0x35,0x35,0x36,0x37,0x39,0x38,0x36,0x35,0x35,0x36,0x38,0x39,
0x38,0x39,0x38,0x37,0x39,0x3a,0x3c,0x3c,0x3a,0x38,0x36,0x36,0x36,0x36,0x39,0x39,
0x37,0x34,0x34,0x33,0x34,0x36,0x37,0x37,0x36,0x35,0x34,0x34,0x35,0x37,0x3a,0x39,
0x37,0x37,0x37,0x38,0x37,0x36,0x36,0x38,0x39,0x39,0x39,0x39,0x38,0x39,0x3b,0x3b,
0x39,0x36,0x36,0x36,0x38,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x33,0x34,0x37,0x36,
0x34,0x35,0x36,0x39,0x3c,0x3b,0x3a,0x3a,0x3a,0x38,0x37,0x36,0x35,0x37,0x39,0x39,
0x38,0x36,0x36,0x36,0x37,0x38,0x38,0x3b,0x39,0x37,0x37,0x37,0x37,0x38,0x38,0x38,
0x38,0x38,0x39,0x38,0x39,0x37,0x36,0x37,0x37,0x38,0x3b,0x39,0x35,0x34,0x36,0x36,
0x35,0x35,0x36,0x37,0x37,0x36,0x34,0x37,0x39,0x3b,0x3b,0x3a,0x39,0x39,0x38,0x37,
0x38,0x38,0x37,0x36,0x33,0x32,0x34,0x36,0x37,0x38,0x3a,0x3a,0x39,0x39,0x3a,0x3a,
0x39,0x37,0x34,0x33,0x33,0x34,0x34,0x32,0x30,0x33,0x35,0x36,0x37,0x39,0x3b,0x3c,
0x3c,0x3a,0x37,0x37,0x36,0x35,0x36,0x37,0x36,0x34,0x32,0x30,0x31,0x32,0x33,0x36,
0x37,0x38,0x38,0x39,0x39,0x38,0x3d,0x3a,0x39,0x39,0x3a,0x3b,0x3b,0x39,0x38,0x39,
0x39,0x37,0x35,0x34,0x35,0x36,0x37,0x37,0x36,0x39,0x3b,0x39,0x3b,0x3b,0x3c,0x3b,
0x39,0x37,0x37,0x36,0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x37,0x38,0x38,0x36,0x38,
0x3b,0x3b,0x3d,0x39,0x37,0x37,0x37,0x37,0x34,0x35,0x37,0x39,0x38,0x36,0x34,0x36,
0x36,0x37,0x37,0x36,0x35,0x36,0x36,0x35,0x36,0x38,0x3a,0x37,0x36,0x34,0x36,0x39,
0x3a,0x3a,0x3b,0x3a,0x39,0x39,0x3a,0x3b,0x3c,0x38,0x34,0x34,0x34,0x34,0x35,0x37,
0x39,0x3b,0x3a,0x38,0x36,0x38,0x38,0x38,0x38,0x36,0x35,0x34,0x33,0x32,0x33,0x36,
0x37,0x36,0x37,0x34,0x33,0x34,0x33,0x34,0x36,0x38,0x38,0x38,0x38,0x38,0x39,0x3a,
0x38,0x39,0x3a,0x39,0x36,0x33,0x33,0x34,0x35,0x36,0x36,0x36,0x36,0x35,0x38,0x39,
0x3a,0x3a,0x39,0x36,0x34,0x34,0x35,0x36,0x36,0x35,0x35,0x35,0x34,0x35,0x37,0x38,
0x37,0x36,0x34,0x35,0x36,0x35,0x33,0x34,0x36,0x37,0x34,0x36,0x36,0x37,0x3a,0x39,
0x39,0x3b,0x3b,0x3a,0x3a,0x39,0x39,0x39,0x39,0x38,0x36,0x36,0x36,0x36,0x36,0x34,
0x33,0x34,0x33,0x33,0x34,0x36,0x37,0x36,0x35,0x36,0x38,0x37,0x36,0x37,0x3a,0x3a,
0x38,0x36,0x36,0x36,0x38,0x38,0x37,0x37,0x36,0x34,0x34,0x34,0x34,0x36,0x37,0x37,
0x37,0x38,0x39,0x39,0x38,0x37,0x37,0x38,0x36,0x35,0x36,0x36,0x36,0x37,0x37,0x38,
0x39,0x37,0x36,0x38,0x39,0x3b,0x3b,0x3a,0x36,0x34,0x34,0x35,0x36,0x38,0x39,0x38,
0x38,0x37,0x37,0x37,0x39,0x38,0x38,0x38,0x37,0x36,0x38,0x39,0x39,0x3b,0x3b,0x3b,
0x3e,0x3d,0x3b,0x3b,0x38,0x36,0x34,0x36,0x35,0x36,0x36,0x38,0x36,0x35,0x35,0x36,
0x39,0x3b,0x3b,0x3b,0x38,0x36,0x34,0x34,0x35,0x36,0x37,0x36,0x36,0x36,0x37,0x38,
0x37,0x38,0x38,0x37,0x33,0x30,0x30,0x31,0x30,0x33,0x33,0x34,0x35,0x36,0x36,0x36,
0x37,0x39,0x37,0x38,0x36,0x35,0x36,0x36,0x33,0x34,0x35,0x35,0x35,0x34,0x34,0x36,
0x38,0x38,0x39,0x3b,0x3d,0x3e,0x3b,0x39,0x37,0x39,0x38,0x36,0x36,0x37,0x37,0x37,
0x36,0x37,0x39,0x39,0x37,0x38,0x39,0x39,0x37,0x36,0x36,0x37,0x39,0x39,0x38,0x37,
0x36,0x34,0x35,0x34,0x34,0x36,0x37,0x37,0x37,0x38,0x3b,0x3b,0x39,0x38,0x38,0x3a,
0x3a,0x38,0x37,0x37,0x38,0x39,0x39,0x38,0x39,0x39,0x36,0x34,0x33,0x35,0x33,0x34,
0x33,0x33,0x37,0x38,0x37,0x37,0x36,0x35,0x35,0x33,0x33,0x34,0x36,0x37,0x37,0x37,
0x37,0x38,0x38,0x36,0x36,0x38,0x39,0x37,0x36,0x36,0x38,0x39,0x38,0x37,0x37,0x36,
0x34,0x34,0x35,0x36,0x37,0x37,0x37,0x37,0x39,0x3a,0x39,0x3d,0x3b,0x3a,0x3a,0x39,
0x37,0x37,0x37,0x36,0x37,0x37,0x39,0x39,0x38,0x36,0x36,0x38,0x38,0x38,0x38,0x37,
0x37,0x36,0x35,0x36,0x37,0x39,0x37,0x37,0x36,0x34,0x36,0x36,0x36,0x37,0x38,0x39,
0x38,0x37,0x37,0x38,0x3b,0x3d,0x3d,0x3d,0x3a,0x36,0x35,0x35,0x36,0x35,0x39,0x39,
0x38,0x39,0x39,0x39,0x3b,0x3a,0x3a,0x3c,0x3b,0x39,0x38,0x37,0x35,0x34,0x35,0x37,
0x38,0x38,0x36,0x35,0x37,0x39,0x39,0x39,0x39,0x36,0x37,0x35,0x35,0x37,0x38,0x38,
0x37,0x35,0x35,0x36,0x36,0x37,0x37,0x37,0x36,0x33,0x33,0x34,0x36,0x39,0x39,0x38,
0x37,0x36,0x36,0x38,0x39,0x39,0x37,0x38,0x36,0x36,0x38,0x38,0x37,0x34,0x32,0x32,
0x34,0x36,0x37,0x37,0x36,0x34,0x34,0x35,0x37,0x39,0x38,0x36,0x35,0x36,0x36,0x36,
0x36,0x38,0x39,0x3a,0x3a,0x3b,0x3c,0x3b,0x39,0x37,0x37,0x38,0x36,0x37,0x37,0x36,
0x36,0x35,0x37,0x39,0x39,0x3a,0x3b,0x39,0x37,0x37,0x38,0x38,0x39,0x38,0x39,0x38,
0x39,0x39,0x37,0x38,0x38,0x37,0x36,0x36,0x36,0x37,0x36,0x36,0x35,0x35,0x36,0x37,
0x37,0x36,0x34,0x36,0x35,0x34,0x38,0x39,0x39,0x3a,0x39,0x37,0x38,0x38,0x37,0x36,
0x35,0x34,0x34,0x34,0x34,0x36,0x37,0x36,0x35,0x37,0x39,0x3a,0x39,0x37,0x36,0x37,
0x36,0x35,0x37,0x38,0x37,0x36,0x35,0x35,0x33,0x34,0x36,0x37,0x38,0x37,0x37,0x39,
0x34,0x34,0x37,0x39,0x3a,0x39,0x39,0x37,0x38,0x37,0x38,0x36,0x39,0x38,0x36,0x36,
0x35,0x36,0x36,0x35,0x34,0x36,0x36,0x37,0x38,0x38,0x37,0x37,0x36,0x35,0x36,0x36,
0x36,0x34,0x36,0x38,0x39,0x38,0x37,0x37,0x39,0x39,0x39,0x39,0x38,0x37,0x36,0x36,
0x36,0x35,0x37,0x37,0x36,0x36,0x36,0x35,0x37,0x36,0x35,0x36,0x36,0x34,0x34,0x35,
0x37,0x38,0x39,0x38,0x37,0x36,0x34,0x33,0x33,0x32,0x33,0x32,0x30,0x30,0x34,0x37,
0x38,0x39,0x39,0x38,0x37,0x36,0x36,0x36,0x36,0x36,0x35,0x34,0x34,0x35,0x37,0x36,
0x34,0x36,0x39,0x39,0x37,0x37,0x36,0x36,0x36,0x37,0x38,0x37,0x35,0x33,0x31,0x30,
// Line 11
0x35,0x37,0x39,0x39,0x38,0x39,0x38,0x36,0x36,0x35,0x35,0x37,0x37,0x36,0x33,0x33,
0x35,0x37,0x39,0x38,0x37,0x37,0x38,0x37,0x37,0x37,0x39,0x39,0x37,0x33,0x34,0x36,
0x37,0x37,0x35,0x33,0x33,0x36,0x38,0x39,0x3a,0x3b,0x3b,0x39,0x35,0x32,0x32,0x33,
0x32,0x34,0x35,0x32,0x2f,0x30,0x37,0x44,0x57,0x69,0x76,0x7d,0x79,0x6a,0x5e,0x59,
0x5c,0x65,0x6e,0x75,0x77,0x73,0x6b,0x61,0x5a,0x5b,0x61,0x6b,0x71,0x72,0x72,0x6d,
0x67,0x61,0x5b,0x5b,0x60,0x67,0x6e,0x74,0x75,0x6f,0x66,0x5f,0x5a,0x5b,0x62,0x6c,
0x73,0x78,0x76,0x6f,0x69,0x62,0x5e,0x60,0x66,0x6b,0x72,0x76,0x75,0x6d,0x65,0x5e,
0x5a,0x5c,0x62,0x6b,0x71,0x76,0x75,0x6e,0x65,0x5e,0x5d,0x61,0x68,0x71,0x77,0x79,
0x76,0x6f,0x68,0x62,0x5f,0x60,0x63,0x68,0x6b,0x6c,0x6f,0x72,0x79,0x83,0x8f,0x99,
0xa3,0xaa,0xa8,0x9c,0x8a,0x79,0x6b,0x60,0x58,0x51,0x4f,0x4c,0x44,0x3e,0x38,0x3c,
0x48,0x57,0x67,0x79,0x85,0x8c,0x8f,0x92,0x97,0x9b,0x9d,0x9d,0x9b,0x9b,0x9b,0x9c,
0x9d,0x9b,0x94,0x88,0x79,0x6a,0x5e,0x57,0x4f,0x44,0x3b,0x32,0x2f,0x38,0x4b,0x61,
0x7a,0x83,0x81,0x77,0x69,0x5e,0x57,0x52,0x4a,0x41,0x37,0x31,0x32,0x3f,0x55,0x6d,
0x7f,0x84,0x7d,0x6f,0x60,0x55,0x4d,0x46,0x41,0x3c,0x37,0x31,0x2e,0x2e,0x32,0x38,
0x42,0x4f,0x5e,0x6b,0x73,0x73,0x72,0x69,0x60,0x5b,0x56,0x51,0x4a,0x40,0x35,0x34,
0x3b,0x4c,0x63,0x78,0x85,0x8e,0x92,0x94,0x93,0x8c,0x81,0x71,0x62,0x57,0x57,0x60,
0x6d,0x78,0x7d,0x7a,0x70,0x67,0x60,0x5e,0x5d,0x55,0x45,0x34,0x2c,0x2f,0x3f,0x59,
0x71,0x81,0x86,0x7b,0x69,0x5a,0x52,0x4f,0x4a,0x42,0x38,0x32,0x35,0x41,0x55,0x6b,
0x7d,0x84,0x7d,0x6d,0x5e,0x56,0x59,0x63,0x70,0x77,0x79,0x73,0x6b,0x61,0x5d,0x5d,
0x5b,0x54,0x46,0x37,0x2e,0x32,0x42,0x58,0x70,0x80,0x80,0x77,0x69,0x5c,0x53,0x4e,
0x48,0x41,0x39,0x34,0x35,0x42,0x59,0x70,0x80,0x84,0x7b,0x6b,0x5c,0x54,0x50,0x4e,
0x47,0x3e,0x35,0x2f,0x2f,0x35,0x3d,0x41,0x40,0x3c,0x38,0x35,0x35,0x38,0x3b,0x37,
0x32,0x32,0x3a,0x4c,0x5f,0x70,0x7b,0x7b,0x75,0x68,0x5c,0x5b,0x5b,0x60,0x69,0x6e,
0x72,0x7b,0x82,0x8e,0x9a,0xa4,0xaa,0xab,0xa8,0x9f,0x96,0x91,0x8f,0x91,0x94,0x98,
0x9b,0x9e,0x9e,0x9b,0x93,0x87,0x79,0x6d,0x5f,0x53,0x49,0x43,0x3f,0x3e,0x3e,0x3c,
0x37,0x33,0x33,0x36,0x3f,0x4a,0x58,0x69,0x75,0x79,0x75,0x6b,0x60,0x59,0x59,0x62,
0x6d,0x78,0x7c,0x76,0x6b,0x60,0x59,0x5d,0x69,0x76,0x80,0x83,0x7b,0x70,0x66,0x62,
0x61,0x63,0x60,0x59,0x4c,0x3a,0x2b,0x2a,0x38,0x50,0x6c,0x80,0x86,0x7e,0x6d,0x5c,
0x51,0x4c,0x4c,0x4c,0x45,0x3b,0x30,0x2c,0x30,0x39,0x41,0x44,0x41,0x3c,0x34,0x31,
0x37,0x44,0x55,0x65,0x74,0x82,0x8a,0x95,0x9a,0x9f,0xa5,0xa7,0xa5,0xa1,0x96,0x86,
0x77,0x69,0x5e,0x59,0x5a,0x60,0x69,0x71,0x7a,0x84,0x8e,0x97,0x9c,0x9b,0x91,0x82,
0x71,0x62,0x55,0x4d,0x45,0x3e,0x39,0x38,0x3f,0x4e,0x61,0x74,0x7e,0x7f,0x77,0x6a,
0x60,0x5d,0x5e,0x66,0x6c,0x74,0x7d,0x85,0x8d,0x97,0x9e,0x9e,0x95,0x86,0x75,0x61,
0x55,0x47,0x3b,0x35,0x33,0x36,0x40,0x4f,0x63,0x77,0x7e,0x7a,0x6e,0x60,0x56,0x50,
0x4e,0x4d,0x4a,0x42,0x38,0x31,0x30,0x36,0x3e,0x44,0x44,0x41,0x3b,0x35,0x34,0x3a,
0x46,0x54,0x65,0x74,0x83,0x90,0x9a,0x9d,0x98,0x8c,0x7e,0x6f,0x62,0x55,0x49,0x44,
0x3d,0x36,0x35,0x3d,0x4a,0x60,0x75,0x82,0x80,0x7b,0x6d,0x5e,0x57,0x59,0x62,0x6d,
0x75,0x78,0x75,0x6c,0x60,0x59,0x59,0x60,0x6b,0x72,0x76,0x76,0x72,0x6b,0x63,0x60,
0x5e,0x5d,0x58,0x4e,0x41,0x35,0x2d,0x2b,0x2f,0x36,0x3e,0x44,0x47,0x44,0x3d,0x35,
0x31,0x31,0x34,0x38,0x3b,0x3c,0x3d,0x3b,0x39,0x36,0x3b,0x4a,0x5e,0x70,0x7b,0x7b,
0x73,0x68,0x5c,0x53,0x4f,0x4f,0x4e,0x45,0x3d,0x31,0x2b,0x31,0x3a,0x44,0x48,0x44,
0x3b,0x32,0x2e,0x34,0x44,0x59,0x6b,0x77,0x7c,0x75,0x6a,0x5f,0x5b,0x5d,0x66,0x71,
0x79,0x7b,0x74,0x69,0x5e,0x59,0x58,0x59,0x55,0x4a,0x3c,0x31,0x2c,0x2e,0x33,0x3b,
0x42,0x45,0x41,0x3a,0x36,0x37,0x3a,0x3c,0x39,0x35,0x32,0x3c,0x4a,0x5c,0x6d,0x78,
0x79,0x70,0x62,0x57,0x56,0x5e,0x69,0x73,0x79,0x79,0x73,0x6b,0x64,0x63,0x63,0x60,
0x56,0x49,0x3c,0x31,0x2b,0x32,0x45,0x5f,0x76,0x86,0x8f,0x94,0x96,0x98,0x9a,0x9b,
0x9b,0x9b,0x9a,0x99,0x9a,0x9c,0x9b,0x96,0x8b,0x7c,0x70,0x64,0x59,0x50,0x46,0x3d,
0x37,0x33,0x35,0x40,0x50,0x62,0x72,0x81,0x8c,0x91,0x98,0x98,0x9b,0xa1,0xa4,0xa1,
0x9b,0x8d,0x7f,0x70,0x63,0x59,0x55,0x5a,0x60,0x6a,0x72,0x7b,0x84,0x8d,0x94,0x9a,
0xa2,0xa7,0xa7,0xa0,0x93,0x83,0x75,0x67,0x5c,0x54,0x4d,0x44,0x3d,0x37,0x33,0x37,
0x40,0x4f,0x60,0x75,0x86,0x91,0x98,0x9a,0x9c,0x9f,0xa2,0xa2,0x9d,0x97,0x8a,0x7a,
0x68,0x5a,0x54,0x5d,0x65,0x6d,0x79,0x7d,0x7c,0x77,0x6e,0x66,0x61,0x59,0x50,0x43,
0x37,0x2f,0x2f,0x3a,0x4d,0x63,0x77,0x86,0x90,0x96,0x99,0x98,0x90,0x82,0x71,0x62,
0x58,0x55,0x5c,0x69,0x74,0x7b,0x7b,0x73,0x69,0x64,0x63,0x62,0x65,0x68,0x6b,0x6f,
0x72,0x7d,0x8a,0x98,0xa3,0xa7,0xa9,0xa2,0x99,0x8d,0x7f,0x71,0x64,0x58,0x4e,0x49,
0x47,0x44,0x40,0x3b,0x35,0x34,0x34,0x36,0x3a,0x42,0x4c,0x57,0x63,0x71,0x7f,0x8a,
0x94,0x99,0x9a,0x94,0x89,0x7a,0x69,0x5b,0x56,0x59,0x61,0x6a,0x77,0x81,0x8c,0x96,
0x9d,0x9e,0x9c,0x8a,0x72,0x5f,0x53,0x52,0x5c,0x6b,0x78,0x7e,0x7a,0x70,0x66,0x60,
0x5d,0x5a,0x53,0x46,0x37,0x2c,0x2a,0x35,0x4a,0x62,0x79,0x8a,0x91,0x93,0x96,0x9a,
0x9e,0xa2,0xa2,0x9e,0x94,0x86,0x76,0x63,0x5b,0x51,0x48,0x43,0x40,0x3d,0x3c,0x3c,
0x42,0x53,0x65,0x76,0x82,0x8b,0x90,0x93,0x95,0x99,0x9e,0xa3,0xa2,0x99,0x8b,0x7a,
0x6b,0x60,0x5a,0x5b,0x61,0x6a,0x71,0x78,0x80,0x8a,0x93,0x98,0x96,0x90,0x87,0x76,
0x63,0x53,0x45,0x3c,0x39,0x35,0x35,0x3f,0x4c,0x59,0x68,0x76,0x83,0x8f,0x97,0x9b,
0x9b,0x94,0x88,0x79,0x6c,0x60,0x58,0x59,0x60,0x6a,0x77,0x84,0x8f,0x96,0x9a,0x9b,
0x9d,0x9f,0x9e,0x9b,0x95,0x8a,0x79,0x69,0x59,0x54,0x5a,0x63,0x6c,0x76,0x7a,0x77,
0x6e,0x65,0x60,0x60,0x5f,0x59,0x4f,0x42,0x36,0x32,0x3b,0x4d,0x65,0x7e,0x8c,0x93,
0x96,0x96,0x97,0x97,0x9b,0x9f,0xa0,0x9a,0x8d,0x7b,0x6b,0x5c,0x53,0x55,0x5e,0x6b,
0x77,0x7e,0x7c,0x76,0x6c,0x64,0x62,0x62,0x62,0x68,0x6b,0x6d,0x71,0x7a,0x86,0x94,
0x9f,0xa6,0xa8,0xa5,0x9d,0x91,0x88,0x7b,0x6d,0x62,0x5b,0x5b,0x63,0x70,0x7d,0x80,
0x7f,0x74,0x66,0x5d,0x59,0x5c,0x6b,0x73,0x77,0x77,0x72,0x6a,0x62,0x5f,0x62,0x6a,
0x6f,0x71,0x70,0x70,0x73,0x7b,0x88,0x96,0xa0,0xa0,0x94,0x7f,0x6a,0x5b,0x54,0x59,
0x63,0x6e,0x7b,0x86,0x8f,0x97,0x9c,0x9d,0x96,0x88,0x75,0x60,0x53,0x51,0x57,0x65,
0x74,0x7e,0x80,0x7a,0x6e,0x66,0x62,0x63,0x63,0x69,0x6b,0x6d,0x74,0x7c,0x87,0x92,
0x9d,0xa5,0xaa,0xa8,0x9f,0x92,0x82,0x71,0x64,0x59,0x53,0x4c,0x45,0x3e,0x37,0x33,
0x31,0x33,0x38,0x3b,0x3b,0x3b,0x39,0x39,0x3a,0x3b,0x39,0x37,0x32,0x31,0x33,0x3e,
0x4e,0x60,0x6e,0x76,0x73,0x6f,0x66,0x5f,0x5b,0x57,0x53,0x4c,0x42,0x39,0x35,0x35,
0x38,0x3c,0x40,0x40,0x3d,0x3b,0x3b,0x3a,0x3a,0x36,0x31,0x2f,0x33,0x3f,0x52,0x63,
0x72,0x7a,0x79,0x70,0x66,0x5f,0x5b,0x56,0x4f,0x44,0x37,0x33,0x33,0x3e,0x57,0x6e,
0x7f,0x83,0x7b,0x6d,0x5e,0x53,0x4e,0x4b,0x48,0x43,0x3c,0x37,0x34,0x35,0x3a,0x41,
0x49,0x54,0x5e,0x68,0x72,0x7d,0x87,0x91,0x97,0x99,0x92,0x89,0x7b,0x6a,0x5d,0x56,
0x59,0x65,0x71,0x78,0x7b,0x76,0x6d,0x63,0x5d,0x5b,0x60,0x68,0x6e,0x75,0x7b,0x83,
0x8c,0x96,0x9f,0xa4,0xa8,0xa8,0xa2,0x9a,0x8b,0x7b,0x6c,0x61,0x5b,0x5d,0x63,0x6c,
0x73,0x79,0x7d,0x84,0x8f,0x9a,0x9e,0x9b,0x8c,0x76,0x5f,0x51,0x4e,0x55,0x63,0x71,
0x7a,0x7b,0x75,0x6a,0x5e,0x57,0x51,0x4d,0x45,0x3e,0x37,0x32,0x2f,0x32,0x38,0x42,
0x4c,0x55,0x5c,0x66,0x71,0x7d,0x87,0x91,0x98,0x9a,0x94,0x87,0x75,0x63,0x58,0x52,
0x57,0x60,0x6e,0x7a,0x82,0x89,0x91,0x9a,0x9c,0x98,0x8f,0x7b,0x65,0x57,0x54,0x5c,
0x6c,0x7a,0x7f,0x7c,0x72,0x68,0x60,0x5d,0x5f,0x64,0x69,0x6c,0x6f,0x76,0x80,0x8d,
0x9a,0x9c,0x95,0x88,0x79,0x68,0x59,0x4c,0x42,0x3a,0x35,0x34,0x3b,0x49,0x5b,0x6c,
0x78,0x81,0x88,0x8f,0x92,0x93,0x91,0x88,0x77,0x64,0x57,0x53,0x56,0x63,0x71,0x7c,
0x80,0x7b,0x6d,0x62,0x5a,0x5b,0x63,0x6e,0x76,0x78,0x75,0x6b,0x63,0x5e,0x62,0x6a,
0x73,0x78,0x79,0x76,0x6e,0x67,0x62,0x60,0x5f,0x5d,0x55,0x49,0x3e,0x33,0x2c,0x2b,
0x2d,0x32,0x38,0x45,0x50,0x5c,0x6a,0x73,0x75,0x6f,0x64,0x5a,0x59,0x5e,0x67,0x73,
0x79,0x78,0x71,0x69,0x62,0x62,0x63,0x60,0x57,0x4a,0x3a,0x2f,0x2c,0x36,0x4b,0x65,
0x7c,0x8c,0x97,0x9b,0x98,0x91,0x87,0x7c,0x6e,0x5e,0x50,0x45,0x3e,0x3a,0x36,0x38,
0x36,0x37,0x3a,0x3b,0x3a,0x3a,0x39,0x35,0x33,0x32,0x36,0x3a,0x3b,0x39,0x39,0x3b,
0x3a,0x39,0x38,0x38,0x37,0x38,0x38,0x37,0x39,0x3b,0x3c,0x3c,0x3a,0x38,0x39,0x39,
// Line 12
0x39,0x39,0x39,0x39,0x39,0x39,0x38,0x36,0x36,0x37,0x38,0x37,0x35,0x35,0x34,0x35,
0x35,0x35,0x37,0x39,0x3a,0x39,0x37,0x35,0x34,0x35,0x37,0x38,0x39,0x39,0x38,0x38,
0x37,0x36,0x3a,0x3c,0x3c,0x3b,0x37,0x36,0x37,0x37,0x38,0x39,0x39,0x37,0x35,0x35,
0x37,0x38,0x39,0x35,0x31,0x33,0x39,0x46,0x57,0x6b,0x7a,0x7f,0x79,0x6c,0x5f,0x59,
0x58,0x5f,0x6d,0x76,0x78,0x75,0x6b,0x60,0x5b,0x5b,0x61,0x6a,0x71,0x73,0x71,0x6c,
0x65,0x5f,0x5b,0x5d,0x63,0x6c,0x72,0x75,0x73,0x6d,0x64,0x5f,0x59,0x58,0x5f,0x69,
0x70,0x73,0x72,0x6e,0x67,0x61,0x5d,0x5f,0x65,0x6d,0x72,0x73,0x70,0x6a,0x66,0x60,
0x5c,0x5c,0x60,0x69,0x70,0x73,0x71,0x6b,0x66,0x5e,0x58,0x5a,0x64,0x6f,0x79,0x7b,
0x78,0x72,0x68,0x61,0x5f,0x61,0x67,0x6c,0x6e,0x6f,0x70,0x73,0x79,0x84,0x92,0x9e,
0xa5,0xa8,0xa3,0x9a,0x8d,0x7e,0x6f,0x62,0x57,0x53,0x51,0x4c,0x44,0x3c,0x38,0x39,
0x3f,0x50,0x64,0x76,0x83,0x8b,0x8e,0x90,0x94,0x9a,0x9c,0x9f,0x9d,0x9c,0x9b,0x9b,
0x9b,0x99,0x93,0x88,0x7a,0x6a,0x5e,0x55,0x4d,0x44,0x3d,0x35,0x32,0x3a,0x4c,0x62,
0x75,0x7e,0x7e,0x75,0x68,0x5c,0x55,0x51,0x4b,0x44,0x39,0x31,0x32,0x41,0x58,0x6f,
0x7e,0x84,0x7d,0x6e,0x5f,0x52,0x4b,0x49,0x45,0x3f,0x3b,0x34,0x30,0x31,0x34,0x3b,
0x47,0x55,0x65,0x72,0x78,0x75,0x6f,0x68,0x61,0x5d,0x59,0x53,0x48,0x3e,0x34,0x32,
0x3b,0x4d,0x62,0x77,0x85,0x8e,0x8e,0x90,0x8c,0x88,0x7e,0x6e,0x5a,0x51,0x51,0x5a,
0x6a,0x76,0x7b,0x79,0x70,0x67,0x64,0x62,0x5f,0x55,0x45,0x35,0x2c,0x2f,0x41,0x5c,
0x77,0x83,0x81,0x76,0x68,0x5e,0x5a,0x54,0x4c,0x41,0x37,0x31,0x34,0x42,0x59,0x70,
0x81,0x81,0x74,0x68,0x5b,0x54,0x51,0x4d,0x43,0x3c,0x36,0x35,0x3d,0x50,0x68,0x7e,
0x8a,0x8e,0x90,0x92,0x97,0x9b,0xa1,0xa3,0xa2,0x9d,0x9a,0x9a,0x9c,0x9d,0x99,0x92,
0x83,0x6f,0x5e,0x53,0x55,0x60,0x6d,0x77,0x7a,0x77,0x70,0x67,0x60,0x5b,0x57,0x51,
0x47,0x39,0x30,0x2a,0x2b,0x32,0x39,0x3f,0x42,0x40,0x3c,0x38,0x36,0x36,0x37,0x36,
0x33,0x34,0x3c,0x4a,0x5d,0x72,0x7e,0x7f,0x77,0x69,0x5f,0x5d,0x61,0x68,0x6f,0x72,
0x72,0x76,0x7d,0x8b,0x9a,0xa3,0x9f,0x8e,0x78,0x62,0x53,0x51,0x58,0x65,0x73,0x7b,
0x7b,0x72,0x6e,0x65,0x5b,0x53,0x49,0x3e,0x37,0x31,0x2e,0x30,0x32,0x35,0x3b,0x46,
0x53,0x63,0x70,0x77,0x72,0x6d,0x62,0x59,0x55,0x53,0x51,0x4e,0x46,0x3a,0x33,0x31,
0x37,0x3f,0x44,0x44,0x41,0x3b,0x35,0x33,0x33,0x35,0x36,0x37,0x38,0x3e,0x4d,0x5f,
0x6f,0x7c,0x7d,0x74,0x67,0x5a,0x57,0x5f,0x6b,0x76,0x79,0x76,0x70,0x67,0x64,0x61,
0x61,0x61,0x5a,0x4b,0x3c,0x31,0x2e,0x37,0x49,0x5f,0x76,0x88,0x90,0x92,0x92,0x94,
0x97,0x9e,0xa3,0xa3,0x9c,0x8e,0x7c,0x6d,0x61,0x5b,0x5c,0x60,0x65,0x6d,0x76,0x80,
0x89,0x93,0x9a,0x9c,0x97,0x88,0x74,0x62,0x55,0x50,0x55,0x5f,0x6b,0x77,0x82,0x8b,
0x94,0x9c,0x9f,0x99,0x8c,0x77,0x62,0x53,0x4f,0x56,0x65,0x74,0x7d,0x7d,0x74,0x6a,
0x60,0x5c,0x5f,0x68,0x71,0x76,0x72,0x70,0x69,0x63,0x60,0x5c,0x57,0x53,0x4b,0x3e,
0x32,0x29,0x26,0x27,0x2e,0x38,0x47,0x56,0x64,0x6c,0x74,0x75,0x6f,0x68,0x62,0x5f,
0x60,0x64,0x69,0x71,0x76,0x7c,0x85,0x8e,0x95,0x99,0x98,0x8e,0x7a,0x64,0x50,0x41,
0x3a,0x35,0x33,0x35,0x37,0x39,0x3c,0x3d,0x3c,0x3c,0x39,0x38,0x38,0x3b,0x3d,0x39,
0x37,0x33,0x31,0x39,0x44,0x53,0x67,0x74,0x7c,0x83,0x88,0x92,0x9c,0xa2,0xa4,0xa3,
0xa0,0x9b,0x97,0x97,0x98,0x9a,0x9a,0x90,0x80,0x6d,0x5d,0x54,0x53,0x58,0x65,0x72,
0x7b,0x7b,0x72,0x66,0x5b,0x56,0x5b,0x64,0x6d,0x76,0x76,0x70,0x68,0x60,0x5c,0x62,
0x6a,0x6f,0x70,0x70,0x70,0x75,0x80,0x8d,0x97,0x9e,0x9c,0x90,0x7c,0x65,0x55,0x50,
0x53,0x5e,0x6a,0x78,0x87,0x94,0x9a,0x9a,0x97,0x8f,0x83,0x72,0x61,0x53,0x49,0x43,
0x3d,0x37,0x37,0x3b,0x44,0x53,0x64,0x75,0x81,0x89,0x8d,0x91,0x96,0x9b,0x9e,0xa3,
0x9f,0x95,0x88,0x77,0x65,0x5d,0x56,0x58,0x61,0x6c,0x75,0x7a,0x79,0x70,0x67,0x61,
0x5d,0x57,0x4e,0x46,0x3b,0x32,0x2a,0x26,0x2a,0x32,0x3d,0x41,0x3e,0x3c,0x38,0x33,
0x2e,0x30,0x34,0x39,0x3b,0x3b,0x38,0x37,0x36,0x35,0x38,0x48,0x58,0x6a,0x78,0x7b,
0x74,0x67,0x5b,0x55,0x58,0x64,0x72,0x7b,0x78,0x6f,0x64,0x5c,0x57,0x57,0x57,0x53,
0x49,0x3a,0x2c,0x23,0x23,0x29,0x35,0x3f,0x44,0x44,0x3d,0x34,0x2e,0x32,0x42,0x56,
0x68,0x76,0x79,0x72,0x66,0x59,0x54,0x57,0x61,0x6a,0x71,0x72,0x6f,0x69,0x63,0x5f,
0x5b,0x59,0x53,0x48,0x3e,0x35,0x30,0x2e,0x2e,0x32,0x39,0x45,0x53,0x61,0x6e,0x76,
0x76,0x6e,0x63,0x5a,0x5a,0x5e,0x62,0x67,0x6b,0x6f,0x75,0x7c,0x88,0x96,0x9d,0x98,
0x8a,0x76,0x64,0x51,0x46,0x3d,0x39,0x39,0x3a,0x3b,0x45,0x51,0x63,0x74,0x80,0x86,
0x8b,0x90,0x94,0x98,0x9d,0xa0,0x9e,0x95,0x85,0x73,0x65,0x5b,0x53,0x4e,0x48,0x43,
0x3e,0x38,0x32,0x30,0x30,0x33,0x38,0x39,0x38,0x32,0x2d,0x2b,0x31,0x43,0x57,0x67,
0x74,0x76,0x6c,0x61,0x57,0x51,0x52,0x50,0x48,0x3c,0x30,0x2e,0x37,0x49,0x60,0x77,
0x89,0x91,0x93,0x95,0x99,0x9f,0xa7,0xa9,0xa6,0xa0,0x99,0x94,0x94,0x97,0x9c,0x9e,
0x9d,0x98,0x96,0x97,0x98,0x98,0x98,0x97,0x91,0x88,0x7b,0x6d,0x60,0x56,0x4a,0x40,
0x36,0x30,0x2d,0x35,0x3f,0x4e,0x62,0x73,0x80,0x8a,0x91,0x96,0x98,0x92,0x85,0x74,
0x62,0x55,0x53,0x5c,0x6c,0x7a,0x80,0x7c,0x73,0x6c,0x65,0x61,0x5c,0x53,0x49,0x3d,
0x32,0x30,0x3a,0x4e,0x63,0x79,0x87,0x90,0x93,0x91,0x8c,0x83,0x78,0x6a,0x5b,0x4d,
0x44,0x3f,0x3d,0x39,0x35,0x33,0x35,0x38,0x3d,0x41,0x42,0x40,0x39,0x32,0x30,0x39,
0x49,0x5c,0x72,0x7b,0x7a,0x73,0x65,0x59,0x53,0x57,0x60,0x6c,0x71,0x71,0x6d,0x66,
0x5f,0x5a,0x5a,0x5a,0x55,0x4e,0x41,0x36,0x30,0x2d,0x2d,0x32,0x3b,0x44,0x4e,0x58,
0x61,0x67,0x73,0x7c,0x85,0x93,0x9d,0xa3,0xa4,0xa1,0x9e,0x9b,0x98,0x97,0x98,0x98,
0x94,0x88,0x78,0x66,0x56,0x4a,0x42,0x3d,0x3b,0x39,0x37,0x35,0x34,0x38,0x3f,0x44,
0x43,0x3e,0x38,0x32,0x30,0x35,0x40,0x4d,0x5f,0x6c,0x76,0x81,0x88,0x8e,0x98,0x9e,
0xa5,0xa9,0xa6,0x9b,0x8a,0x7a,0x6b,0x60,0x56,0x50,0x49,0x40,0x35,0x2e,0x34,0x44,
0x5b,0x70,0x7d,0x7f,0x79,0x6c,0x60,0x58,0x58,0x5d,0x65,0x6c,0x72,0x79,0x81,0x8a,
0x94,0xa0,0xa9,0xac,0xaa,0xa1,0x93,0x83,0x72,0x65,0x5b,0x56,0x50,0x4a,0x42,0x3b,
0x35,0x38,0x42,0x55,0x69,0x79,0x7f,0x79,0x69,0x5a,0x53,0x53,0x58,0x61,0x6a,0x72,
0x79,0x80,0x89,0x95,0xa0,0xa8,0xaa,0xa8,0xa0,0x95,0x89,0x79,0x6a,0x60,0x5a,0x59,
0x5c,0x65,0x6c,0x74,0x7c,0x85,0x8c,0x94,0x96,0x91,0x87,0x77,0x64,0x52,0x44,0x3e,
0x3c,0x3b,0x3b,0x3a,0x37,0x36,0x38,0x3d,0x43,0x4a,0x55,0x61,0x6d,0x79,0x84,0x8d,
0x93,0x97,0x99,0x9e,0xa0,0x9e,0x9b,0x9a,0x97,0x97,0x97,0x94,0x8e,0x84,0x76,0x65,
0x57,0x4c,0x45,0x41,0x3c,0x39,0x3d,0x45,0x51,0x64,0x76,0x83,0x8c,0x91,0x94,0x98,
0x9d,0xa0,0xa1,0x9e,0x98,0x94,0x93,0x94,0x97,0x96,0x8f,0x80,0x6c,0x5c,0x53,0x56,
0x60,0x6d,0x75,0x7b,0x78,0x6f,0x66,0x60,0x5a,0x57,0x4e,0x40,0x35,0x2e,0x30,0x3f,
0x53,0x69,0x7a,0x7e,0x77,0x68,0x59,0x4f,0x48,0x45,0x40,0x3a,0x35,0x30,0x2e,0x35,
0x3b,0x3f,0x3f,0x3c,0x38,0x38,0x37,0x38,0x36,0x32,0x2e,0x2e,0x36,0x46,0x5a,0x6d,
0x76,0x76,0x6f,0x67,0x5e,0x58,0x55,0x4e,0x47,0x3d,0x34,0x32,0x3d,0x4d,0x63,0x79,
0x8a,0x93,0x97,0x97,0x97,0x9a,0x9d,0x9d,0x9d,0x9b,0x99,0x97,0x95,0x95,0x97,0x99,
0x9a,0x9a,0x97,0x90,0x83,0x74,0x65,0x58,0x52,0x4c,0x44,0x3e,0x37,0x35,0x3c,0x4b,
0x5f,0x72,0x80,0x81,0x78,0x69,0x5b,0x54,0x57,0x5c,0x61,0x6a,0x70,0x77,0x81,0x8b,
0x94,0x9a,0x97,0x8a,0x76,0x62,0x52,0x44,0x3c,0x37,0x34,0x35,0x37,0x39,0x3d,0x3f,
0x3d,0x39,0x33,0x30,0x32,0x37,0x3a,0x39,0x35,0x30,0x30,0x37,0x46,0x59,0x71,0x7b,
0x79,0x72,0x64,0x5a,0x59,0x5f,0x68,0x73,0x78,0x77,0x72,0x6a,0x64,0x60,0x5f,0x5d,
0x56,0x4b,0x3b,0x2e,0x27,0x25,0x29,0x30,0x36,0x3b,0x3b,0x39,0x35,0x30,0x2d,0x2e,
0x31,0x35,0x37,0x39,0x3b,0x38,0x35,0x35,0x38,0x42,0x52,0x61,0x6f,0x7c,0x86,0x8e,
0x92,0x97,0x9c,0xa0,0xa2,0xa0,0x9d,0x9b,0x98,0x96,0x96,0x91,0x88,0x7b,0x6a,0x59,
0x4d,0x47,0x44,0x40,0x3c,0x39,0x36,0x35,0x36,0x38,0x3e,0x41,0x3c,0x35,0x30,0x2e,
0x36,0x43,0x55,0x69,0x76,0x7a,0x71,0x69,0x60,0x5b,0x5e,0x64,0x6a,0x73,0x75,0x77,
0x7d,0x88,0x95,0xa1,0xa7,0xa8,0xa4,0x9e,0x98,0x95,0x99,0x9d,0x9c,0x95,0x88,0x7a,
0x6c,0x5e,0x52,0x48,0x3d,0x33,0x2c,0x2b,0x33,0x47,0x5d,0x6f,0x7a,0x7b,0x74,0x69,
0x5d,0x55,0x4e,0x4d,0x48,0x3e,0x36,0x2e,0x2a,0x2a,0x2e,0x36,0x41,0x4c,0x56,0x5f,
0x6a,0x79,0x87,0x91,0x96,0x96,0x90,0x84,0x73,0x64,0x55,0x4a,0x41,0x3b,0x36,0x37,
0x38,0x39,0x38,0x37,0x36,0x38,0x38,0x37,0x32,0x35,0x36,0x35,0x36,0x36,0x36,0x38,
0x35,0x33,0x35,0x35,0x36,0x34,0x34,0x34,0x35,0x3a,0x3d,0x3e,0x3e,0x3b,0x38,0x38,
// Line 13
0x34,0x34,0x36,0x3b,0x3c,0x3b,0x3a,0x38,0x38,0x38,0x38,0x36,0x38,0x39,0x38,0x36,
0x34,0x36,0x38,0x39,0x37,0x36,0x36,0x38,0x38,0x3a,0x3a,0x3a,0x3a,0x38,0x38,0x38,
0x39,0x3a,0x3a,0x38,0x34,0x32,0x34,0x36,0x38,0x39,0x38,0x36,0x34,0x33,0x36,0x36,
0x3a,0x3b,0x3a,0x37,0x34,0x32,0x3a,0x48,0x5b,0x6d,0x78,0x7a,0x76,0x69,0x5d,0x57,
0x58,0x61,0x6c,0x74,0x74,0x71,0x6b,0x65,0x5f,0x5e,0x62,0x69,0x71,0x74,0x74,0x6f,
0x67,0x5e,0x5a,0x59,0x60,0x69,0x72,0x77,0x76,0x71,0x6a,0x61,0x5d,0x5e,0x65,0x6e,
0x74,0x75,0x74,0x6f,0x66,0x60,0x5d,0x60,0x67,0x6f,0x75,0x77,0x76,0x6f,0x64,0x5e,
0x57,0x57,0x5d,0x66,0x6e,0x74,0x73,0x6e,0x65,0x5d,0x5c,0x61,0x69,0x72,0x79,0x7c,
0x79,0x71,0x68,0x61,0x5f,0x62,0x66,0x6a,0x6c,0x6d,0x6e,0x73,0x79,0x84,0x91,0xa0,
0xaa,0xad,0xab,0xa2,0x91,0x7d,0x6d,0x60,0x59,0x53,0x4e,0x4a,0x43,0x3a,0x37,0x39,
0x44,0x56,0x6b,0x7c,0x87,0x8f,0x93,0x95,0x97,0x9a,0x9d,0x9f,0x9c,0x9a,0x99,0x9b,
0x9c,0x9b,0x94,0x88,0x79,0x68,0x5c,0x53,0x4d,0x46,0x3e,0x35,0x32,0x3b,0x50,0x66,
0x77,0x81,0x7e,0x72,0x65,0x5a,0x55,0x53,0x4e,0x43,0x38,0x30,0x34,0x3f,0x57,0x6e,
0x7c,0x83,0x7c,0x6b,0x5c,0x54,0x4e,0x4b,0x46,0x42,0x3a,0x34,0x2d,0x2d,0x32,0x3c,
0x44,0x55,0x60,0x6b,0x74,0x76,0x71,0x6b,0x63,0x5c,0x57,0x4f,0x45,0x3d,0x36,0x38,
0x41,0x52,0x67,0x7c,0x8b,0x93,0x98,0x9c,0x99,0x90,0x82,0x71,0x60,0x57,0x57,0x62,
0x71,0x7c,0x7e,0x79,0x70,0x66,0x5e,0x5d,0x58,0x4f,0x41,0x31,0x28,0x32,0x41,0x5b,
0x73,0x7f,0x80,0x79,0x6a,0x5d,0x56,0x53,0x4d,0x44,0x39,0x32,0x36,0x46,0x5e,0x73,
0x7f,0x82,0x7c,0x71,0x61,0x55,0x4d,0x48,0x43,0x3c,0x33,0x2c,0x29,0x2b,0x31,0x38,
0x45,0x56,0x66,0x73,0x77,0x75,0x71,0x6b,0x63,0x5d,0x57,0x50,0x46,0x3d,0x38,0x3a,
0x42,0x53,0x67,0x7e,0x8d,0x97,0x98,0x95,0x90,0x87,0x7a,0x6b,0x5d,0x51,0x45,0x3f,
0x3a,0x39,0x38,0x37,0x36,0x39,0x3d,0x40,0x3f,0x3d,0x3a,0x37,0x37,0x36,0x35,0x34,
0x33,0x31,0x36,0x44,0x59,0x6a,0x7a,0x7a,0x73,0x6b,0x62,0x5d,0x60,0x67,0x6e,0x73,
0x76,0x7a,0x83,0x8e,0x97,0x9b,0x97,0x8a,0x76,0x62,0x51,0x44,0x3c,0x36,0x33,0x36,
0x3e,0x49,0x57,0x67,0x76,0x82,0x8b,0x90,0x93,0x92,0x8c,0x80,0x72,0x61,0x55,0x4d,
0x48,0x41,0x3d,0x38,0x3a,0x48,0x5b,0x6e,0x7d,0x81,0x7a,0x6b,0x5c,0x55,0x5a,0x69,
0x77,0x7e,0x7e,0x74,0x67,0x5d,0x5a,0x5d,0x5e,0x58,0x4b,0x3c,0x32,0x34,0x44,0x5d,
0x76,0x86,0x8b,0x7e,0x6d,0x60,0x57,0x50,0x49,0x3f,0x34,0x2e,0x32,0x42,0x58,0x6f,
0x7d,0x81,0x7a,0x6d,0x60,0x57,0x53,0x4d,0x47,0x3f,0x38,0x36,0x3e,0x51,0x68,0x7e,
0x8c,0x93,0x95,0x95,0x95,0x9a,0x9f,0xa2,0x9f,0x9a,0x97,0x97,0x99,0x9c,0xa1,0xa3,
0xa3,0xa2,0x9c,0x95,0x8b,0x7d,0x6d,0x5e,0x51,0x48,0x42,0x41,0x3d,0x38,0x35,0x34,
0x36,0x3b,0x3e,0x3e,0x3c,0x37,0x33,0x32,0x35,0x3a,0x3d,0x3e,0x3b,0x36,0x38,0x39,
0x3a,0x3d,0x3f,0x3e,0x38,0x33,0x35,0x41,0x51,0x63,0x73,0x7b,0x79,0x72,0x68,0x5e,
0x57,0x54,0x51,0x4a,0x41,0x36,0x2d,0x2c,0x31,0x3b,0x45,0x48,0x44,0x3b,0x32,0x2f,
0x33,0x42,0x54,0x66,0x76,0x7d,0x82,0x8b,0x95,0x9f,0xa5,0xa4,0x9f,0x9c,0x9b,0x9b,
0x9b,0x9e,0x9e,0x98,0x8b,0x7a,0x6d,0x63,0x5a,0x51,0x48,0x3e,0x36,0x36,0x3e,0x4d,
0x62,0x73,0x7e,0x7c,0x71,0x63,0x57,0x50,0x4c,0x48,0x44,0x3a,0x2f,0x2b,0x2e,0x36,
0x3e,0x42,0x42,0x41,0x3d,0x3a,0x36,0x3a,0x3a,0x36,0x32,0x32,0x3a,0x4d,0x62,0x73,
0x7a,0x79,0x70,0x67,0x5c,0x54,0x51,0x4e,0x49,0x41,0x38,0x30,0x2e,0x34,0x3d,0x43,
0x45,0x45,0x40,0x3d,0x38,0x34,0x33,0x36,0x3a,0x3e,0x3e,0x3a,0x33,0x32,0x34,0x3d,
0x4a,0x5b,0x6a,0x79,0x79,0x70,0x66,0x5e,0x59,0x57,0x52,0x4b,0x44,0x3d,0x38,0x34,
0x34,0x38,0x3e,0x45,0x4b,0x53,0x5d,0x6a,0x76,0x81,0x8b,0x93,0x97,0x9d,0xa2,0xa5,
0xa0,0x95,0x84,0x73,0x64,0x5b,0x54,0x4f,0x48,0x42,0x38,0x30,0x34,0x42,0x57,0x6f,
0x7d,0x7f,0x77,0x6a,0x5c,0x54,0x57,0x61,0x6f,0x79,0x78,0x70,0x67,0x5f,0x5a,0x59,
0x58,0x54,0x4c,0x3e,0x30,0x2b,0x2d,0x36,0x3e,0x45,0x47,0x44,0x40,0x3b,0x36,0x36,
0x35,0x34,0x34,0x34,0x3a,0x49,0x5b,0x6a,0x75,0x79,0x73,0x65,0x5b,0x57,0x5c,0x67,
0x71,0x77,0x79,0x74,0x6b,0x63,0x61,0x64,0x68,0x6a,0x6b,0x6d,0x70,0x76,0x7f,0x8c,
0x97,0x9d,0x98,0x8a,0x76,0x61,0x51,0x43,0x3a,0x34,0x31,0x33,0x3a,0x45,0x5a,0x6e,
0x7c,0x7d,0x78,0x69,0x5b,0x53,0x54,0x5b,0x6b,0x74,0x77,0x73,0x69,0x5f,0x59,0x5a,
0x60,0x6b,0x74,0x77,0x72,0x69,0x61,0x5d,0x5c,0x5b,0x59,0x55,0x4c,0x3f,0x34,0x2d,
0x2c,0x31,0x36,0x3c,0x46,0x54,0x63,0x6f,0x74,0x75,0x71,0x69,0x5d,0x56,0x5b,0x65,
0x70,0x78,0x77,0x70,0x67,0x60,0x5b,0x5f,0x66,0x6c,0x6f,0x6e,0x6d,0x71,0x7a,0x87,
0x95,0xa0,0xa8,0xa9,0xa4,0x9c,0x96,0x93,0x91,0x91,0x92,0x91,0x8b,0x7d,0x6b,0x5a,
0x4e,0x47,0x44,0x41,0x3c,0x37,0x33,0x33,0x34,0x37,0x3d,0x3d,0x38,0x33,0x2f,0x30,
0x38,0x47,0x5a,0x6e,0x79,0x7a,0x72,0x69,0x60,0x5b,0x5c,0x60,0x66,0x6f,0x76,0x7a,
0x82,0x8c,0x97,0xa0,0xa4,0xa4,0xa3,0x9e,0x96,0x89,0x7a,0x69,0x5b,0x52,0x4f,0x57,
0x65,0x72,0x78,0x74,0x69,0x5d,0x54,0x56,0x5d,0x6b,0x77,0x7b,0x74,0x6e,0x66,0x63,
0x64,0x65,0x63,0x5c,0x4c,0x3c,0x30,0x2e,0x3a,0x4d,0x65,0x7a,0x8c,0x99,0x9c,0x98,
0x92,0x88,0x7c,0x6e,0x5f,0x51,0x48,0x41,0x3c,0x39,0x35,0x33,0x34,0x35,0x38,0x3e,
0x42,0x41,0x38,0x36,0x33,0x38,0x44,0x53,0x63,0x71,0x7c,0x83,0x88,0x8e,0x96,0x9c,
0x9d,0x9a,0x98,0x97,0x97,0x98,0x9a,0x9a,0x96,0x8d,0x7f,0x70,0x64,0x5a,0x50,0x46,
0x3b,0x34,0x32,0x3a,0x4b,0x61,0x76,0x81,0x81,0x79,0x6c,0x60,0x58,0x51,0x49,0x42,
0x39,0x32,0x34,0x3e,0x4f,0x65,0x79,0x89,0x93,0x97,0x97,0x93,0x8b,0x80,0x72,0x64,
0x55,0x48,0x42,0x3f,0x3c,0x3a,0x3a,0x3a,0x3b,0x3b,0x3c,0x3d,0x3b,0x38,0x33,0x36,
0x37,0x36,0x36,0x36,0x36,0x3f,0x4d,0x60,0x71,0x7c,0x7f,0x79,0x6b,0x60,0x5b,0x5e,
0x64,0x67,0x6f,0x75,0x7a,0x84,0x8e,0x97,0x9e,0x9a,0x8b,0x79,0x62,0x4f,0x3f,0x37,
0x32,0x33,0x37,0x3a,0x38,0x3a,0x3a,0x3c,0x40,0x4a,0x57,0x67,0x73,0x77,0x73,0x69,
0x60,0x5b,0x5d,0x60,0x67,0x6f,0x74,0x78,0x7f,0x87,0x94,0x9f,0xa5,0xa7,0xa5,0x9f,
0x94,0x89,0x7c,0x6c,0x5f,0x58,0x58,0x60,0x6d,0x77,0x7a,0x74,0x69,0x5e,0x5a,0x5d,
0x64,0x6c,0x71,0x74,0x76,0x79,0x82,0x91,0x9d,0xa2,0x9e,0x8f,0x79,0x60,0x55,0x50,
0x52,0x5d,0x6a,0x76,0x83,0x8e,0x98,0x9d,0x9b,0x94,0x86,0x74,0x5f,0x4e,0x45,0x41,
0x3d,0x3a,0x3a,0x38,0x38,0x36,0x38,0x3c,0x44,0x4f,0x59,0x63,0x6d,0x7a,0x87,0x92,
0x9a,0x9b,0x94,0x86,0x74,0x63,0x5a,0x59,0x5c,0x63,0x6f,0x79,0x81,0x8b,0x94,0x9c,
0x9f,0x97,0x87,0x72,0x5d,0x50,0x4b,0x56,0x63,0x71,0x7a,0x7a,0x71,0x69,0x60,0x59,
0x55,0x4f,0x47,0x3e,0x34,0x2c,0x2a,0x2d,0x36,0x3f,0x48,0x4f,0x57,0x63,0x70,0x7d,
0x89,0x94,0x9a,0x9b,0x92,0x85,0x77,0x67,0x56,0x49,0x3f,0x38,0x30,0x31,0x36,0x43,
0x55,0x69,0x77,0x7f,0x7b,0x6b,0x5e,0x56,0x58,0x64,0x71,0x79,0x79,0x73,0x6a,0x60,
0x5b,0x5b,0x60,0x67,0x6a,0x6c,0x6f,0x76,0x80,0x8c,0x95,0x98,0x95,0x89,0x74,0x5f,
0x4b,0x3f,0x38,0x33,0x30,0x30,0x32,0x33,0x34,0x38,0x3a,0x3a,0x38,0x34,0x30,0x32,
0x3a,0x49,0x5d,0x6f,0x7a,0x7a,0x75,0x68,0x5e,0x5d,0x60,0x65,0x6a,0x6e,0x72,0x78,
0x81,0x8c,0x97,0x9b,0x97,0x8b,0x77,0x63,0x53,0x48,0x43,0x3f,0x3c,0x38,0x33,0x31,
0x33,0x37,0x3d,0x3d,0x38,0x31,0x2c,0x2c,0x34,0x46,0x5d,0x70,0x79,0x77,0x6e,0x64,
0x5b,0x58,0x5b,0x62,0x68,0x6e,0x71,0x78,0x82,0x8d,0x97,0x9c,0x98,0x8c,0x77,0x66,
0x51,0x42,0x3c,0x3a,0x36,0x34,0x34,0x36,0x3a,0x3b,0x3b,0x3b,0x39,0x34,0x32,0x31,
0x33,0x34,0x3a,0x39,0x37,0x36,0x37,0x39,0x3d,0x3e,0x3d,0x3b,0x37,0x34,0x37,0x40,
0x4d,0x5e,0x6d,0x76,0x79,0x73,0x69,0x60,0x59,0x55,0x4e,0x46,0x3d,0x35,0x31,0x30,
0x34,0x3a,0x3e,0x3f,0x3c,0x39,0x38,0x35,0x38,0x36,0x31,0x2f,0x31,0x3a,0x4d,0x60,
0x71,0x79,0x78,0x6e,0x62,0x5a,0x57,0x57,0x55,0x4c,0x3f,0x34,0x32,0x3d,0x54,0x6e,
0x81,0x85,0x7a,0x69,0x5a,0x51,0x53,0x5d,0x6b,0x76,0x79,0x75,0x6d,0x66,0x60,0x5e,
0x61,0x6b,0x71,0x73,0x71,0x6b,0x65,0x60,0x5d,0x5a,0x57,0x55,0x4d,0x42,0x36,0x2c,
0x28,0x2c,0x32,0x3a,0x44,0x4d,0x55,0x5e,0x68,0x75,0x85,0x90,0x97,0x98,0x90,0x82,
0x71,0x62,0x55,0x49,0x43,0x3b,0x35,0x36,0x3d,0x49,0x5e,0x6f,0x7c,0x81,0x7b,0x6b,
0x57,0x4e,0x51,0x5d,0x6b,0x75,0x77,0x71,0x63,0x57,0x53,0x57,0x60,0x6b,0x72,0x73,
0x6f,0x68,0x60,0x5c,0x5a,0x5a,0x59,0x54,0x4b,0x3e,0x33,0x2c,0x29,0x2f,0x38,0x42,
0x45,0x42,0x3d,0x39,0x36,0x35,0x33,0x38,0x38,0x3a,0x3a,0x3a,0x36,0x39,0x38,0x34,
0x33,0x31,0x32,0x35,0x36,0x36,0x3a,0x3b,0x39,0x36,0x35,0x36,0x37,0x38,0x37,0x37,
// Line 14
0x3b,0x3c,0x3d,0x3b,0x3c,0x38,0x37,0x36,0x37,0x39,0x37,0x36,0x36,0x37,0x37,0x39,
0x38,0x38,0x39,0x38,0x36,0x34,0x36,0x38,0x3a,0x3a,0x38,0x37,0x37,0x36,0x34,0x34,
0x34,0x38,0x38,0x37,0x36,0x36,0x36,0x36,0x35,0x36,0x36,0x36,0x36,0x37,0x34,0x38,
0x36,0x34,0x35,0x35,0x35,0x38,0x3a,0x3d,0x45,0x4e,0x57,0x61,0x6d,0x79,0x83,0x8a,
0x8e,0x92,0x94,0x97,0x98,0x98,0x98,0x98,0x97,0x95,0x93,0x94,0x98,0x9a,0x98,0x95,
0x92,0x8d,0x88,0x83,0x7c,0x73,0x69,0x5d,0x56,0x4f,0x4c,0x49,0x45,0x41,0x3f,0x3e,
0x3d,0x39,0x3a,0x38,0x37,0x36,0x34,0x34,0x39,0x37,0x35,0x36,0x37,0x39,0x3b,0x3d,
0x42,0x4a,0x54,0x5d,0x64,0x6d,0x77,0x81,0x88,0x8e,0x94,0x99,0x99,0x97,0x95,0x93,
0x93,0x94,0x93,0x93,0x94,0x95,0x96,0x95,0x95,0x94,0x92,0x8c,0x83,0x79,0x72,0x67,
0x5d,0x54,0x4e,0x49,0x44,0x3e,0x39,0x38,0x3a,0x3a,0x38,0x37,0x36,0x35,0x34,0x32,
0x32,0x34,0x36,0x36,0x38,0x38,0x3a,0x3d,0x3f,0x45,0x4d,0x57,0x5f,0x67,0x6e,0x77,
0x80,0x89,0x8f,0x93,0x97,0x98,0x96,0x94,0x93,0x95,0x97,0x98,0x97,0x97,0x97,0x97,
0x96,0x93,0x90,0x8c,0x89,0x81,0x77,0x6f,0x65,0x5d,0x55,0x4e,0x49,0x45,0x40,0x3b,
0x39,0x3a,0x39,0x39,0x38,0x38,0x38,0x39,0x39,0x38,0x38,0x37,0x38,0x39,0x3a,0x3c,
0x40,0x44,0x47,0x50,0x5a,0x65,0x6d,0x75,0x7d,0x86,0x8d,0x92,0x94,0x97,0x9a,0x9a,
0x9b,0x99,0x98,0x99,0x9b,0x99,0x98,0x97,0x98,0x98,0x95,0x92,0x8c,0x86,0x7e,0x75,
0x6d,0x65,0x5c,0x54,0x4d,0x47,0x42,0x3b,0x36,0x37,0x39,0x3b,0x3c,0x3d,0x3b,0x3b,
0x3b,0x3a,0x38,0x38,0x39,0x39,0x3b,0x3b,0x3c,0x40,0x45,0x4a,0x53,0x5d,0x69,0x73,
0x7a,0x82,0x87,0x8d,0x92,0x94,0x98,0x99,0x99,0x97,0x95,0x94,0x95,0x95,0x93,0x95,
0x96,0x98,0x99,0x98,0x96,0x92,0x8c,0x83,0x78,0x6f,0x66,0x5d,0x55,0x4e,0x47,0x42,
0x3e,0x3b,0x3b,0x3b,0x3d,0x3d,0x3d,0x3a,0x37,0x37,0x38,0x37,0x39,0x3a,0x37,0x38,
0x38,0x3b,0x3d,0x42,0x47,0x50,0x59,0x63,0x6e,0x76,0x7e,0x86,0x8c,0x90,0x92,0x95,
0x97,0x97,0x97,0x95,0x94,0x95,0x95,0x95,0x97,0x99,0x9b,0x9b,0x98,0x92,0x8c,0x88,
0x81,0x7a,0x75,0x6a,0x5e,0x54,0x4c,0x44,0x42,0x41,0x3d,0x3b,0x3b,0x3a,0x38,0x38,
0x37,0x38,0x39,0x39,0x38,0x39,0x38,0x38,0x37,0x38,0x3d,0x43,0x48,0x4e,0x56,0x5f,
0x69,0x73,0x7a,0x82,0x8b,0x92,0x96,0x98,0x98,0x9a,0x9a,0x9a,0x99,0x97,0x97,0x96,
0x93,0x93,0x93,0x95,0x96,0x96,0x90,0x8a,0x83,0x7d,0x74,0x6c,0x63,0x5a,0x52,0x4b,
0x44,0x41,0x41,0x3f,0x3d,0x3b,0x3a,0x39,0x37,0x34,0x34,0x38,0x3b,0x3a,0x39,0x3a,
0x3b,0x3d,0x3d,0x3d,0x3d,0x3b,0x3a,0x3a,0x3a,0x3b,0x3b,0x3d,0x3b,0x3b,0x3b,0x3b,
0x3b,0x3d,0x3b,0x39,0x39,0x38,0x38,0x38,0x39,0x38,0x39,0x38,0x38,0x39,0x39,0x38,
0x39,0x3b,0x3a,0x39,0x38,0x36,0x36,0x38,0x39,0x3b,0x3c,0x3d,0x3b,0x3a,0x39,0x3b,
0x3e,0x3e,0x3b,0x39,0x39,0x3a,0x38,0x37,0x38,0x38,0x39,0x37,0x36,0x34,0x34,0x34,
0x37,0x39,0x3b,0x3b,0x3a,0x39,0x38,0x3a,0x3a,0x39,0x37,0x36,0x34,0x36,0x36,0x36,
0x37,0x37,0x37,0x38,0x38,0x37,0x37,0x39,0x3a,0x3b,0x41,0x49,0x4f,0x57,0x5f,0x69,
0x73,0x7a,0x83,0x8c,0x90,0x92,0x92,0x92,0x93,0x95,0x96,0x94,0x93,0x93,0x93,0x92,
0x90,0x91,0x92,0x96,0x96,0x93,0x92,0x92,0x92,0x94,0x95,0x96,0x96,0x95,0x94,0x94,
0x97,0x99,0x98,0x9b,0x98,0x96,0x97,0x99,0x9a,0x9b,0x99,0x93,0x91,0x91,0x92,0x93,
0x93,0x8f,0x88,0x82,0x7b,0x73,0x6a,0x63,0x5b,0x56,0x4e,0x45,0x3f,0x3b,0x39,0x3b,
0x3a,0x3a,0x39,0x39,0x38,0x38,0x37,0x38,0x39,0x3b,0x3b,0x38,0x39,0x38,0x38,0x39,
0x39,0x37,0x38,0x3b,0x3d,0x39,0x36,0x34,0x36,0x3a,0x3b,0x39,0x37,0x37,0x36,0x37,
0x36,0x37,0x38,0x39,0x38,0x37,0x34,0x34,0x36,0x39,0x3a,0x3a,0x3b,0x3d,0x3d,0x3b,
0x38,0x38,0x3b,0x3c,0x3b,0x3b,0x38,0x37,0x37,0x38,0x37,0x35,0x37,0x38,0x36,0x35,
0x34,0x32,0x34,0x34,0x34,0x37,0x38,0x39,0x3b,0x3b,0x3a,0x39,0x37,0x37,0x3a,0x3b,
0x39,0x37,0x38,0x39,0x38,0x37,0x37,0x38,0x3b,0x3b,0x39,0x37,0x36,0x37,0x39,0x38,
0x38,0x37,0x38,0x36,0x34,0x35,0x35,0x34,0x37,0x37,0x36,0x37,0x37,0x36,0x38,0x38,
0x38,0x37,0x38,0x38,0x38,0x39,0x37,0x34,0x34,0x35,0x36,0x36,0x36,0x36,0x39,0x3b,
0x3b,0x3b,0x3a,0x3a,0x3a,0x38,0x34,0x34,0x34,0x34,0x32,0x32,0x32,0x34,0x36,0x36,
0x36,0x3a,0x3b,0x3b,0x3b,0x3a,0x38,0x3a,0x38,0x38,0x38,0x3a,0x3a,0x3a,0x3e,0x45,
0x4f,0x58,0x61,0x6a,0x75,0x7e,0x84,0x8a,0x8f,0x94,0x97,0x97,0x95,0x94,0x94,0x95,
0x96,0x97,0x97,0x96,0x97,0x96,0x96,0x96,0x97,0x97,0x96,0x96,0x96,0x98,0x98,0x97,
0x95,0x97,0x96,0x93,0x93,0x93,0x94,0x93,0x92,0x92,0x96,0x99,0x9a,0x99,0x99,0x98,
0x9a,0x9a,0x99,0x97,0x97,0x98,0x97,0x97,0x96,0x97,0x97,0x93,0x92,0x93,0x93,0x95,
0x96,0x97,0x96,0x97,0x97,0x98,0x98,0x99,0x99,0x98,0x96,0x95,0x94,0x95,0x94,0x94,
0x97,0x99,0x98,0x98,0x97,0x96,0x96,0x96,0x95,0x95,0x96,0x97,0x96,0x94,0x93,0x92,
0x92,0x92,0x92,0x94,0x96,0x96,0x94,0x94,0x95,0x97,0x98,0x98,0x95,0x92,0x8c,0x85,
0x7e,0x76,0x6f,0x68,0x5d,0x53,0x4b,0x46,0x41,0x3d,0x38,0x36,0x38,0x3a,0x39,0x37,
0x38,0x39,0x39,0x39,0x38,0x35,0x39,0x36,0x35,0x37,0x38,0x39,0x38,0x38,0x38,0x39,
0x3a,0x39,0x37,0x37,0x38,0x39,0x39,0x39,0x39,0x39,0x38,0x36,0x38,0x3c,0x3e,0x3b,
0x38,0x36,0x36,0x38,0x37,0x36,0x36,0x34,0x34,0x32,0x33,0x34,0x34,0x34,0x34,0x35,
0x35,0x35,0x36,0x36,0x35,0x37,0x38,0x3a,0x39,0x3a,0x39,0x39,0x37,0x36,0x36,0x39,
0x38,0x35,0x34,0x36,0x36,0x35,0x34,0x36,0x38,0x38,0x38,0x37,0x36,0x34,0x36,0x39,
0x39,0x39,0x39,0x38,0x38,0x39,0x3a,0x3b,0x3c,0x3b,0x38,0x38,0x36,0x35,0x36,0x37,
0x3a,0x3e,0x44,0x4b,0x53,0x5f,0x68,0x6f,0x79,0x82,0x88,0x8f,0x90,0x90,0x93,0x96,
0x95,0x94,0x93,0x94,0x96,0x97,0x97,0x98,0x99,0x98,0x95,0x94,0x94,0x96,0x97,0x96,
0x94,0x95,0x95,0x94,0x94,0x95,0x95,0x95,0x94,0x94,0x94,0x95,0x94,0x92,0x93,0x96,
0x98,0x9b,0x9a,0x99,0x99,0x98,0x98,0x97,0x96,0x92,0x8b,0x82,0x76,0x6c,0x63,0x5c,
0x55,0x4e,0x47,0x41,0x3c,0x3a,0x39,0x3a,0x3b,0x3b,0x39,0x37,0x36,0x37,0x38,0x38,
0x38,0x39,0x38,0x36,0x38,0x3b,0x3b,0x3b,0x39,0x38,0x38,0x38,0x3b,0x3b,0x3d,0x3a,
0x37,0x37,0x35,0x35,0x38,0x39,0x39,0x38,0x37,0x38,0x3a,0x3b,0x3b,0x3b,0x3b,0x3b,
0x39,0x37,0x36,0x37,0x38,0x37,0x37,0x3a,0x3b,0x3b,0x3b,0x3b,0x3a,0x38,0x36,0x37,
0x39,0x3a,0x37,0x32,0x34,0x34,0x33,0x34,0x34,0x35,0x38,0x37,0x36,0x36,0x37,0x39,
0x3b,0x39,0x35,0x34,0x36,0x37,0x35,0x34,0x34,0x36,0x37,0x35,0x35,0x38,0x3b,0x3b,
0x3c,0x3b,0x3b,0x3b,0x39,0x38,0x37,0x37,0x38,0x37,0x34,0x35,0x37,0x38,0x36,0x35,
0x37,0x3b,0x3a,0x3a,0x3a,0x3b,0x3a,0x37,0x34,0x34,0x35,0x36,0x36,0x37,0x37,0x38,
0x3a,0x3a,0x38,0x3b,0x38,0x38,0x3b,0x3b,0x3a,0x38,0x35,0x33,0x34,0x37,0x39,0x37,
0x3b,0x3b,0x3b,0x3a,0x39,0x38,0x3a,0x3a,0x37,0x37,0x37,0x39,0x39,0x37,0x35,0x37,
0x37,0x37,0x38,0x37,0x36,0x35,0x36,0x37,0x37,0x39,0x38,0x37,0x37,0x35,0x36,0x37,
0x37,0x36,0x34,0x34,0x36,0x34,0x34,0x34,0x36,0x37,0x35,0x33,0x35,0x38,0x38,0x39,
0x38,0x38,0x38,0x37,0x37,0x38,0x3a,0x3b,0x39,0x39,0x37,0x38,0x3a,0x3a,0x38,0x37,
0x36,0x35,0x34,0x34,0x34,0x37,0x38,0x39,0x39,0x3b,0x3d,0x3d,0x3d,0x3c,0x3d,0x3f,
0x3f,0x3d,0x3d,0x39,0x36,0x36,0x35,0x34,0x36,0x36,0x34,0x34,0x36,0x37,0x37,0x38,
0x39,0x38,0x38,0x37,0x36,0x38,0x37,0x37,0x38,0x38,0x36,0x38,0x38,0x38,0x3a,0x3b,
0x3d,0x3d,0x3a,0x37,0x37,0x38,0x38,0x36,0x35,0x34,0x33,0x32,0x33,0x35,0x38,0x3a,
0x39,0x38,0x37,0x37,0x34,0x37,0x36,0x35,0x35,0x34,0x29,0x31,0x34,0x3c,0x3f,0x3f,
0x3b,0x3b,0x35,0x34,0x34,0x34,0x37,0x37,0x35,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
0x34,0x35,0x34,0x32,0x32,0x34,0x34,0x36,0x37,0x38,0x37,0x35,0x34,0x34,0x36,0x37,
0x37,0x38,0x36,0x34,0x35,0x37,0x39,0x3d,0x3d,0x3b,0x3a,0x38,0x38,0x39,0x39,0x38,
0x37,0x37,0x36,0x34,0x34,0x33,0x34,0x35,0x36,0x36,0x37,0x36,0x36,0x36,0x37,0x38,
0x37,0x37,0x37,0x35,0x34,0x35,0x34,0x34,0x36,0x37,0x39,0x37,0x36,0x37,0x37,0x36,
0x36,0x37,0x37,0x37,0x37,0x35,0x34,0x35,0x36,0x37,0x37,0x36,0x36,0x37,0x36,0x35,
0x35,0x36,0x36,0x36,0x36,0x34,0x34,0x34,0x34,0x36,0x38,0x39,0x39,0x39,0x37,0x36,
0x38,0x37,0x34,0x34,0x34,0x34,0x34,0x34,0x37,0x37,0x36,0x35,0x37,0x3a,0x3b,0x37,
0x35,0x34,0x32,0x34,0x34,0x35,0x38,0x39,0x38,0x37,0x36,0x39,0x3b,0x3d,0x3a,0x38,
0x37,0x36,0x35,0x34,0x34,0x34,0x34,0x31,0x30,0x30,0x32,0x34,0x36,0x37,0x38,0x37,
0x35,0x34,0x32,0x34,0x34,0x35,0x34,0x32,0x30,0x32,0x33,0x34,0x35,0x36,0x38,0x39,
0x37,0x36,0x36,0x37,0x37,0x37,0x38,0x39,0x37,0x36,0x34,0x35,0x39,0x3b,0x3b,0x3b,
// Line 15
0x3b,0x3b,0x38,0x37,0x37,0x38,0x3a,0x3a,0x3a,0x3a,0x3c,0x3c,0x3b,0x3a,0x3c,0x3d,
0x3b,0x3a,0x37,0x37,0x38,0x38,0x38,0x39,0x39,0x39,0x38,0x38,0x36,0x37,0x38,0x37,
0x36,0x37,0x37,0x38,0x39,0x38,0x37,0x38,0x38,0x38,0x39,0x3b,0x3b,0x3a,0x3a,0x3c,
0x3d,0x40,0x40,0x40,0x3e,0x39,0x34,0x35,0x3c,0x4d,0x63,0x75,0x7f,0x80,0x7a,0x6e,
0x64,0x60,0x66,0x71,0x7a,0x7e,0x7c,0x75,0x6c,0x65,0x64,0x67,0x6e,0x76,0x7b,0x7d,
0x79,0x72,0x69,0x62,0x5f,0x62,0x69,0x71,0x77,0x7a,0x78,0x72,0x69,0x64,0x62,0x66,
0x6f,0x77,0x7b,0x7a,0x76,0x70,0x68,0x63,0x61,0x64,0x6b,0x72,0x76,0x77,0x75,0x71,
0x6a,0x62,0x60,0x65,0x6c,0x73,0x78,0x79,0x74,0x6e,0x66,0x60,0x5e,0x63,0x6c,0x75,
0x7d,0x7f,0x7b,0x72,0x68,0x64,0x67,0x6c,0x71,0x72,0x75,0x74,0x73,0x77,0x80,0x8d,
0x9a,0xa6,0xaa,0xab,0xa5,0x9c,0x8e,0x80,0x71,0x66,0x5c,0x55,0x4e,0x48,0x41,0x3a,
0x37,0x3a,0x47,0x5b,0x6e,0x7f,0x8b,0x93,0x97,0x9a,0x9e,0xa2,0xa7,0xa8,0xa2,0x98,
0x88,0x78,0x6d,0x64,0x60,0x61,0x68,0x6e,0x75,0x7d,0x86,0x8e,0x96,0x9c,0xa2,0xa6,
0xa7,0xa4,0x9e,0x99,0x96,0x97,0x99,0x9b,0x98,0x90,0x80,0x6e,0x5f,0x59,0x5b,0x66,
0x73,0x7c,0x81,0x7d,0x73,0x67,0x61,0x62,0x67,0x6e,0x75,0x79,0x77,0x71,0x68,0x64,
0x62,0x66,0x6e,0x74,0x79,0x7c,0x7a,0x72,0x69,0x64,0x64,0x6a,0x73,0x7b,0x7d,0x7e,
0x78,0x6e,0x66,0x60,0x5f,0x5f,0x59,0x4b,0x40,0x35,0x2c,0x2b,0x2d,0x34,0x3c,0x45,
0x4f,0x5a,0x68,0x74,0x7a,0x7c,0x75,0x6a,0x60,0x5b,0x62,0x70,0x7b,0x81,0x7d,0x73,
0x66,0x5f,0x5e,0x64,0x6d,0x78,0x7e,0x7b,0x73,0x69,0x62,0x5e,0x5b,0x5a,0x58,0x53,
0x49,0x3c,0x30,0x29,0x2d,0x37,0x41,0x47,0x47,0x42,0x3a,0x33,0x30,0x3b,0x4d,0x60,
0x72,0x81,0x8a,0x91,0x97,0x9a,0x9f,0xa4,0xa6,0xa6,0xa1,0x9c,0x98,0x97,0x99,0x99,
0x96,0x90,0x81,0x6e,0x60,0x5a,0x5c,0x65,0x73,0x7e,0x83,0x80,0x75,0x69,0x62,0x60,
0x64,0x6d,0x75,0x79,0x77,0x70,0x68,0x64,0x61,0x64,0x6a,0x72,0x78,0x7a,0x79,0x74,
0x6b,0x64,0x62,0x66,0x71,0x7a,0x80,0x80,0x79,0x6d,0x64,0x5f,0x5c,0x5c,0x59,0x53,
0x49,0x3d,0x30,0x27,0x2b,0x34,0x3f,0x48,0x4a,0x43,0x3a,0x33,0x33,0x3d,0x51,0x66,
0x79,0x82,0x82,0x79,0x6d,0x60,0x59,0x53,0x4d,0x46,0x3e,0x38,0x33,0x30,0x30,0x34,
0x3c,0x4a,0x5c,0x68,0x73,0x77,0x77,0x71,0x69,0x60,0x5d,0x5a,0x53,0x4a,0x3d,0x32,
0x2d,0x2c,0x2f,0x3a,0x41,0x46,0x45,0x3e,0x36,0x33,0x33,0x34,0x37,0x3c,0x3e,0x3e,
0x3b,0x37,0x35,0x3a,0x43,0x52,0x64,0x75,0x7f,0x7f,0x76,0x69,0x60,0x5e,0x65,0x70,
0x7a,0x81,0x80,0x7a,0x6c,0x63,0x64,0x69,0x70,0x78,0x7f,0x80,0x7a,0x70,0x67,0x60,
0x60,0x62,0x5f,0x5c,0x4f,0x3d,0x30,0x28,0x28,0x31,0x3c,0x45,0x46,0x3f,0x34,0x2d,
0x2d,0x3b,0x54,0x6c,0x7d,0x83,0x80,0x77,0x6a,0x60,0x59,0x56,0x51,0x48,0x3e,0x36,
0x33,0x36,0x3b,0x3f,0x40,0x40,0x3c,0x3b,0x38,0x38,0x38,0x36,0x33,0x30,0x34,0x43,
0x56,0x68,0x76,0x7a,0x76,0x6c,0x61,0x5d,0x5d,0x5c,0x56,0x4a,0x3d,0x36,0x3a,0x4d,
0x65,0x7c,0x8e,0x8c,0x7e,0x6d,0x60,0x5f,0x64,0x6f,0x78,0x7d,0x7a,0x71,0x68,0x64,
0x61,0x5e,0x59,0x4f,0x43,0x3c,0x34,0x2e,0x2c,0x2f,0x36,0x40,0x4d,0x5a,0x6b,0x76,
0x79,0x72,0x6e,0x66,0x62,0x65,0x67,0x6a,0x6e,0x71,0x75,0x7d,0x87,0x92,0x9b,0x9d,
0x93,0x83,0x6f,0x5d,0x4c,0x41,0x3b,0x39,0x3b,0x3f,0x40,0x40,0x3d,0x3c,0x40,0x4a,
0x57,0x68,0x76,0x7e,0x7d,0x73,0x65,0x5b,0x5f,0x67,0x71,0x7b,0x7d,0x77,0x6e,0x65,
0x62,0x63,0x62,0x5c,0x53,0x46,0x37,0x30,0x35,0x45,0x5a,0x71,0x83,0x8f,0x96,0x9a,
0x9b,0x9b,0x9b,0x9b,0x9e,0x9d,0x96,0x88,0x75,0x64,0x5b,0x5a,0x5f,0x68,0x73,0x7c,
0x7f,0x79,0x6d,0x62,0x5c,0x59,0x54,0x4e,0x44,0x3c,0x36,0x31,0x2e,0x32,0x3a,0x45,
0x4b,0x52,0x5a,0x64,0x71,0x7e,0x88,0x94,0x9a,0x9f,0xa6,0xa9,0xa6,0xa0,0x94,0x84,
0x75,0x65,0x5c,0x5b,0x61,0x6d,0x77,0x7d,0x7c,0x76,0x6e,0x67,0x60,0x5c,0x56,0x4f,
0x44,0x36,0x2e,0x34,0x47,0x61,0x78,0x85,0x84,0x79,0x6a,0x5e,0x5b,0x63,0x6e,0x77,
0x7b,0x7d,0x82,0x8b,0x96,0x9e,0xa0,0x98,0x87,0x70,0x5d,0x54,0x57,0x64,0x71,0x7b,
0x7e,0x7b,0x74,0x6c,0x65,0x5f,0x58,0x4d,0x3e,0x34,0x32,0x39,0x47,0x5b,0x70,0x83,
0x91,0x99,0x99,0x9a,0x93,0x89,0x7f,0x73,0x64,0x56,0x4c,0x42,0x3c,0x3b,0x3f,0x46,
0x50,0x5d,0x6e,0x7d,0x88,0x92,0x9a,0x9b,0x99,0x90,0x84,0x76,0x67,0x59,0x4b,0x42,
0x3c,0x3b,0x3b,0x40,0x49,0x58,0x6a,0x7c,0x88,0x90,0x95,0x99,0x9c,0x9f,0xa1,0xa2,
0xa3,0x9f,0x9a,0x97,0x97,0x97,0x9a,0x9b,0x9a,0x9b,0x9b,0x9c,0x9e,0x9f,0xa0,0xa0,
0x9e,0x9f,0xa2,0xa6,0xa4,0xa4,0xa3,0xa2,0xa1,0xa0,0x9f,0x9f,0xa1,0xa0,0x9d,0x9a,
0x9a,0x9c,0x9e,0x9d,0x9c,0x9d,0x9e,0x9b,0x96,0x8d,0x84,0x74,0x68,0x5a,0x4f,0x48,
0x43,0x3f,0x3b,0x36,0x32,0x33,0x34,0x37,0x3a,0x3b,0x39,0x38,0x36,0x38,0x39,0x3a,
0x39,0x38,0x38,0x38,0x36,0x36,0x36,0x36,0x36,0x36,0x38,0x3a,0x3b,0x3c,0x3e,0x40,
0x40,0x3e,0x3a,0x36,0x33,0x35,0x3b,0x41,0x4d,0x5c,0x6c,0x7b,0x86,0x91,0x9a,0x9d,
0x98,0x8d,0x80,0x71,0x60,0x55,0x49,0x41,0x3e,0x3c,0x3a,0x3a,0x3a,0x3b,0x3d,0x3c,
0x3a,0x37,0x35,0x31,0x2f,0x30,0x34,0x36,0x35,0x33,0x32,0x34,0x37,0x3a,0x3c,0x3c,
0x3c,0x3d,0x3c,0x3e,0x43,0x4e,0x5c,0x6c,0x79,0x84,0x8e,0x96,0x9c,0xa1,0xa6,0xa7,
0xa4,0xa1,0x9e,0x9c,0x9b,0x99,0x99,0x93,0x8a,0x7c,0x6c,0x5d,0x52,0x49,0x44,0x3c,
0x38,0x38,0x38,0x3a,0x3c,0x3e,0x3f,0x3f,0x3c,0x3b,0x3a,0x37,0x34,0x33,0x33,0x35,
0x3b,0x44,0x4f,0x5d,0x6e,0x7d,0x88,0x90,0x96,0x9a,0x99,0x91,0x83,0x75,0x66,0x59,
0x4c,0x43,0x3f,0x3e,0x40,0x46,0x4f,0x60,0x72,0x80,0x8c,0x92,0x94,0x92,0x8e,0x87,
0x7d,0x6e,0x5c,0x4d,0x43,0x3f,0x3d,0x3d,0x3c,0x3b,0x3a,0x38,0x38,0x3c,0x45,0x4f,
0x5c,0x68,0x73,0x7f,0x8a,0x94,0x9b,0xa1,0xa4,0xa6,0xa6,0xa3,0x9e,0x9d,0x9c,0x9d,
0xa1,0xa2,0xa4,0xa5,0xa3,0xa1,0x9e,0x9e,0x9d,0x9f,0x9f,0xa1,0xa1,0xa0,0x9c,0x9a,
0x9a,0x9c,0x9e,0x9f,0x9b,0x94,0x8b,0x7d,0x6e,0x62,0x5e,0x61,0x68,0x70,0x79,0x82,
0x8a,0x92,0x98,0x9e,0x9b,0x91,0x83,0x6f,0x5c,0x4e,0x46,0x40,0x3e,0x3c,0x38,0x35,
0x36,0x3b,0x3e,0x40,0x3d,0x3b,0x3a,0x38,0x35,0x37,0x37,0x37,0x39,0x39,0x38,0x36,
0x33,0x34,0x38,0x42,0x52,0x65,0x75,0x7e,0x7d,0x76,0x6a,0x61,0x5f,0x61,0x68,0x71,
0x78,0x7a,0x7f,0x86,0x8e,0x9a,0xa3,0xaa,0xaa,0xa5,0x9a,0x8b,0x7d,0x71,0x65,0x5a,
0x52,0x4c,0x4c,0x49,0x41,0x3a,0x34,0x33,0x37,0x3d,0x43,0x44,0x3e,0x34,0x2b,0x2c,
0x3a,0x51,0x68,0x78,0x7d,0x7a,0x70,0x65,0x5e,0x5a,0x56,0x51,0x46,0x3b,0x35,0x3f,
0x50,0x67,0x7d,0x8b,0x89,0x80,0x6f,0x61,0x5e,0x61,0x66,0x6e,0x74,0x7b,0x85,0x90,
0x9a,0xa0,0x9f,0x94,0x80,0x6e,0x60,0x56,0x4d,0x45,0x3d,0x3b,0x3d,0x47,0x5a,0x6e,
0x7f,0x88,0x83,0x75,0x65,0x5a,0x58,0x5d,0x68,0x72,0x78,0x80,0x83,0x89,0x94,0x9d,
0x9f,0x98,0x89,0x76,0x64,0x52,0x49,0x41,0x41,0x3e,0x41,0x4a,0x5a,0x69,0x77,0x80,
0x87,0x8f,0x93,0x97,0x9d,0xa1,0xa3,0xa2,0x9c,0x98,0x98,0x9b,0x9b,0x98,0x90,0x84,
0x76,0x68,0x5b,0x52,0x4a,0x45,0x3e,0x3b,0x3c,0x45,0x54,0x64,0x74,0x7d,0x88,0x8e,
0x91,0x98,0x9c,0x9e,0x9f,0x9d,0x9b,0x9b,0x9a,0x99,0x99,0x9a,0x9b,0x9f,0x9f,0x9e,
0x99,0x92,0x86,0x79,0x6c,0x62,0x5a,0x53,0x4a,0x40,0x3c,0x3d,0x42,0x4e,0x5d,0x6e,
0x7d,0x88,0x8f,0x90,0x98,0x9d,0xa0,0xa4,0xa5,0xa5,0xa4,0x9f,0x9b,0x9c,0x9b,0x95,
0x89,0x7b,0x6d,0x61,0x54,0x4c,0x46,0x43,0x3f,0x3b,0x38,0x37,0x39,0x3d,0x41,0x47,
0x52,0x5d,0x6a,0x76,0x7e,0x85,0x8f,0x97,0x9c,0xa0,0xa1,0xa0,0x9b,0x98,0x97,0x9a,
0xa0,0x9e,0x97,0x8d,0x7e,0x6e,0x5e,0x53,0x4c,0x47,0x40,0x3c,0x3c,0x42,0x4f,0x5e,
0x70,0x80,0x8d,0x94,0x98,0x99,0x97,0x8f,0x82,0x74,0x65,0x5d,0x5c,0x60,0x6a,0x75,
0x80,0x8b,0x94,0x9b,0x9e,0x9b,0x92,0x83,0x6f,0x5f,0x52,0x48,0x41,0x3c,0x39,0x3c,
0x45,0x54,0x64,0x73,0x80,0x88,0x8e,0x92,0x97,0xa0,0xa3,0xa4,0xa3,0xa0,0x9c,0x99,
0x99,0x9a,0x9d,0x9e,0x9e,0x9e,0x9e,0x9b,0x96,0x8b,0x7e,0x70,0x65,0x5e,0x5f,0x67,
0x70,0x78,0x7f,0x86,0x8c,0x95,0x9f,0xa6,0xa7,0xa5,0xa1,0x9c,0x9a,0x9b,0x9c,0xa0,
0x9f,0x9f,0xa0,0xa1,0xa0,0x9c,0x92,0x84,0x75,0x66,0x59,0x4f,0x4a,0x44,0x3e,0x3b,
0x38,0x38,0x3a,0x3b,0x3c,0x40,0x4a,0x57,0x68,0x74,0x7b,0x7a,0x70,0x64,0x5a,0x5a,
0x64,0x71,0x7c,0x7f,0x7a,0x70,0x66,0x5f,0x5e,0x60,0x5f,0x57,0x49,0x3c,0x33,0x2d,
0x2d,0x33,0x3d,0x45,0x4d,0x56,0x60,0x6b,0x76,0x7f,0x88,0x91,0x97,0x99,0x93,0x86,
0x73,0x62,0x59,0x5a,0x64,0x73,0x7f,0x83,0x7f,0x74,0x69,0x64,0x64,0x67,0x6e,0x73,
0x76,0x77,0x7a,0x83,0x90,0x9e,0xa7,0xa9,0xa6,0xa2,0x9c,0x99,0x97,0x99,0xa0,0xa3,
0xa4,0xa6,0xa6,0xa3,0xa2,0x9f,0x9f,0xa1,0xa1,0x9d,0x94,0x86,0x76,0x65,0x58,0x4f,
// Line 16
0x35,0x37,0x39,0x39,0x38,0x38,0x37,0x3a,0x3c,0x3c,0x39,0x38,0x38,0x3a,0x3a,0x39,
0x39,0x39,0x3a,0x3a,0x39,0x37,0x36,0x35,0x37,0x37,0x36,0x37,0x35,0x34,0x34,0x34,
0x34,0x35,0x36,0x35,0x34,0x34,0x34,0x35,0x38,0x3a,0x3a,0x3b,0x39,0x37,0x35,0x34,
0x33,0x34,0x37,0x39,0x39,0x37,0x34,0x35,0x3f,0x50,0x62,0x73,0x7d,0x7c,0x74,0x66,
0x5b,0x58,0x5e,0x68,0x74,0x7b,0x7b,0x75,0x6a,0x60,0x5f,0x66,0x6e,0x75,0x7a,0x7b,
0x77,0x6f,0x64,0x5c,0x59,0x5e,0x66,0x6d,0x72,0x74,0x73,0x6d,0x65,0x5f,0x60,0x65,
0x6c,0x74,0x78,0x78,0x77,0x71,0x6a,0x62,0x60,0x61,0x67,0x6d,0x74,0x75,0x73,0x6b,
0x62,0x5e,0x5c,0x60,0x68,0x6f,0x73,0x75,0x70,0x68,0x60,0x5b,0x5a,0x5f,0x6a,0x75,
0x7b,0x7c,0x78,0x6f,0x68,0x64,0x64,0x66,0x69,0x6c,0x6e,0x6d,0x6d,0x72,0x7c,0x89,
0x97,0xa4,0xaa,0xa9,0xa3,0x96,0x86,0x78,0x6b,0x60,0x59,0x53,0x4d,0x49,0x42,0x3d,
0x3d,0x41,0x4a,0x58,0x68,0x79,0x86,0x8f,0x93,0x95,0x99,0x9c,0x9f,0x9f,0x9b,0x93,
0x88,0x78,0x68,0x5d,0x58,0x5b,0x63,0x6f,0x7a,0x7f,0x7d,0x73,0x66,0x5e,0x5d,0x60,
0x6b,0x73,0x77,0x77,0x70,0x67,0x61,0x60,0x63,0x69,0x6e,0x71,0x73,0x74,0x77,0x81,
0x8e,0x9e,0xa9,0xaf,0xac,0xa5,0x9f,0x9a,0x99,0x9c,0x9f,0x9d,0x96,0x89,0x7a,0x6b,
0x5e,0x51,0x48,0x40,0x37,0x30,0x35,0x42,0x55,0x6d,0x7d,0x83,0x7f,0x74,0x67,0x5e,
0x58,0x54,0x4c,0x42,0x35,0x31,0x38,0x4b,0x63,0x7a,0x86,0x85,0x7a,0x6a,0x5c,0x54,
0x50,0x4c,0x48,0x40,0x36,0x30,0x2f,0x33,0x3a,0x43,0x4b,0x52,0x5b,0x65,0x71,0x80,
0x8a,0x92,0x96,0x94,0x8b,0x80,0x71,0x60,0x4d,0x3f,0x38,0x35,0x36,0x38,0x37,0x34,
0x30,0x31,0x3b,0x4a,0x5c,0x6d,0x78,0x7e,0x7c,0x76,0x6d,0x65,0x5e,0x57,0x4c,0x42,
0x39,0x34,0x37,0x44,0x57,0x70,0x83,0x91,0x98,0x9a,0x94,0x90,0x88,0x7e,0x6f,0x61,
0x50,0x42,0x3b,0x38,0x37,0x39,0x3a,0x37,0x34,0x34,0x39,0x44,0x52,0x63,0x73,0x7b,
0x78,0x70,0x65,0x5e,0x5d,0x64,0x6d,0x76,0x7a,0x77,0x6f,0x66,0x60,0x5f,0x64,0x6c,
0x74,0x79,0x78,0x73,0x6e,0x6a,0x63,0x60,0x61,0x63,0x63,0x68,0x6a,0x70,0x7b,0x86,
0x91,0x9c,0xa4,0xab,0xad,0xab,0xa4,0x97,0x86,0x76,0x6a,0x64,0x62,0x65,0x69,0x6f,
0x74,0x7a,0x7e,0x84,0x8c,0x98,0xa1,0xa7,0xa6,0xa2,0x9f,0x9b,0x99,0x9a,0x9d,0x9c,
0x95,0x86,0x74,0x63,0x59,0x50,0x4a,0x43,0x3c,0x39,0x3b,0x43,0x50,0x62,0x74,0x7f,
0x86,0x8a,0x8d,0x91,0x97,0x9e,0xa0,0xa2,0xa0,0x9d,0x9b,0x9d,0x9d,0x9f,0x9b,0x92,
0x7f,0x71,0x61,0x5b,0x5c,0x66,0x74,0x7f,0x80,0x7b,0x72,0x67,0x60,0x60,0x65,0x6e,
0x75,0x78,0x74,0x6d,0x66,0x61,0x5f,0x5e,0x59,0x53,0x48,0x3e,0x33,0x2f,0x2e,0x31,
0x38,0x43,0x50,0x60,0x6d,0x77,0x78,0x79,0x72,0x6a,0x64,0x5e,0x56,0x4e,0x43,0x36,
0x30,0x32,0x3e,0x52,0x6a,0x81,0x93,0x9b,0x9b,0x97,0x90,0x85,0x78,0x6c,0x60,0x57,
0x4c,0x42,0x39,0x37,0x39,0x43,0x54,0x66,0x78,0x82,0x82,0x77,0x68,0x5c,0x59,0x5f,
0x66,0x6e,0x73,0x7a,0x7d,0x84,0x90,0x9b,0x9d,0x96,0x86,0x70,0x5b,0x4c,0x42,0x3b,
0x3c,0x3b,0x39,0x3a,0x38,0x37,0x3b,0x3e,0x45,0x53,0x62,0x72,0x7b,0x7a,0x72,0x67,
0x5c,0x59,0x5e,0x6c,0x76,0x7b,0x78,0x70,0x68,0x63,0x64,0x6a,0x71,0x75,0x74,0x73,
0x73,0x79,0x86,0x94,0x9d,0x9f,0x97,0x87,0x70,0x5e,0x55,0x54,0x61,0x6d,0x78,0x7d,
0x78,0x71,0x68,0x5f,0x57,0x52,0x4a,0x3f,0x35,0x33,0x38,0x45,0x58,0x70,0x84,0x92,
0x94,0x92,0x92,0x8e,0x87,0x7c,0x6d,0x5d,0x50,0x45,0x3e,0x3c,0x3b,0x3c,0x3c,0x3a,
0x36,0x34,0x3d,0x45,0x51,0x60,0x6c,0x72,0x75,0x6e,0x65,0x5d,0x59,0x5f,0x6b,0x76,
0x7b,0x78,0x71,0x68,0x60,0x5f,0x63,0x6f,0x7c,0x83,0x80,0x78,0x6c,0x64,0x62,0x64,
0x64,0x60,0x56,0x48,0x39,0x30,0x35,0x48,0x60,0x78,0x83,0x83,0x75,0x64,0x56,0x4d,
0x48,0x48,0x45,0x3e,0x33,0x2b,0x2b,0x34,0x3f,0x46,0x45,0x40,0x38,0x30,0x34,0x41,
0x53,0x66,0x73,0x79,0x78,0x70,0x68,0x60,0x5d,0x5c,0x5f,0x65,0x6b,0x72,0x7b,0x83,
0x8a,0x94,0xa1,0xab,0xad,0xa9,0x9f,0x95,0x88,0x7a,0x6b,0x64,0x60,0x62,0x66,0x6c,
0x73,0x7e,0x84,0x8a,0x92,0x9b,0xa3,0xa9,0xa7,0xa2,0x9d,0x99,0x96,0x96,0x97,0x98,
0x93,0x88,0x76,0x64,0x56,0x4c,0x45,0x42,0x3f,0x3e,0x3b,0x38,0x36,0x39,0x3c,0x40,
0x45,0x4b,0x54,0x61,0x6e,0x7b,0x86,0x91,0x99,0x9e,0xa1,0xa1,0xa0,0x9d,0x9a,0x98,
0x99,0x99,0x96,0x90,0x84,0x76,0x6a,0x5e,0x53,0x49,0x44,0x3f,0x3b,0x3a,0x39,0x39,
0x38,0x38,0x38,0x40,0x4a,0x58,0x65,0x75,0x7f,0x88,0x8f,0x96,0x9c,0xa6,0xa8,0xa6,
0xa3,0x9f,0x9b,0x9c,0x9b,0x9b,0x9f,0xa1,0xa1,0x9f,0x9a,0x92,0x87,0x7a,0x6d,0x63,
0x5d,0x5e,0x62,0x69,0x6e,0x76,0x81,0x89,0x91,0x99,0xa1,0xa6,0xa4,0x9f,0x9a,0x99,
0x9a,0x99,0x96,0x93,0x8e,0x84,0x78,0x6a,0x5d,0x54,0x4b,0x43,0x3d,0x39,0x34,0x30,
0x32,0x32,0x34,0x36,0x35,0x34,0x35,0x36,0x34,0x33,0x34,0x37,0x39,0x39,0x36,0x35,
0x34,0x35,0x39,0x3f,0x4b,0x5c,0x6d,0x7c,0x86,0x8f,0x95,0x96,0x92,0x89,0x7c,0x6d,
0x5d,0x4d,0x45,0x3f,0x3c,0x38,0x38,0x36,0x35,0x38,0x3b,0x3c,0x3f,0x3b,0x35,0x34,
0x34,0x3b,0x49,0x5b,0x6b,0x7a,0x84,0x8c,0x90,0x96,0x9d,0xa4,0xa8,0xa7,0x9f,0x93,
0x83,0x72,0x63,0x58,0x51,0x4f,0x48,0x3d,0x35,0x34,0x3a,0x49,0x5c,0x70,0x7f,0x81,
0x76,0x63,0x59,0x55,0x59,0x66,0x75,0x7d,0x7f,0x77,0x6a,0x62,0x5f,0x65,0x6c,0x73,
0x78,0x7a,0x77,0x71,0x6a,0x67,0x65,0x68,0x6c,0x6f,0x70,0x71,0x72,0x78,0x83,0x90,
0x9b,0x9e,0x97,0x88,0x72,0x5e,0x4d,0x42,0x3d,0x3b,0x3a,0x39,0x34,0x34,0x39,0x3c,
0x3b,0x39,0x34,0x2f,0x28,0x2f,0x3c,0x51,0x68,0x78,0x7c,0x78,0x70,0x68,0x62,0x5e,
0x58,0x51,0x46,0x3c,0x37,0x3a,0x46,0x59,0x6e,0x7e,0x89,0x91,0x94,0x94,0x95,0x9a,
0x9f,0xa0,0x98,0x8d,0x81,0x72,0x63,0x59,0x50,0x4c,0x45,0x41,0x3a,0x37,0x37,0x39,
0x39,0x3c,0x3e,0x43,0x4c,0x59,0x66,0x76,0x81,0x8c,0x93,0x98,0x9e,0xa2,0xa4,0xa4,
0xa0,0x97,0x8a,0x79,0x6b,0x60,0x5e,0x5f,0x62,0x69,0x72,0x7a,0x81,0x8a,0x93,0x9d,
0xa4,0xa9,0xaa,0xa8,0xa3,0x9a,0x8c,0x7c,0x6b,0x5f,0x5a,0x5a,0x5e,0x67,0x70,0x78,
0x80,0x8b,0x95,0x9d,0xa0,0xa2,0xa3,0xa2,0x9c,0x91,0x84,0x76,0x67,0x5e,0x5a,0x5d,
0x69,0x73,0x78,0x7a,0x76,0x6f,0x67,0x63,0x61,0x66,0x6d,0x74,0x78,0x7c,0x80,0x87,
0x90,0x99,0xa2,0xa8,0xa9,0xa3,0x9b,0x8e,0x81,0x73,0x66,0x5b,0x59,0x60,0x6c,0x75,
0x78,0x78,0x72,0x6a,0x5e,0x58,0x57,0x54,0x4c,0x43,0x39,0x30,0x2c,0x2c,0x2f,0x39,
0x44,0x4d,0x53,0x5a,0x63,0x6f,0x7d,0x89,0x93,0x9d,0xa4,0xa6,0xa6,0xa4,0xa1,0x9c,
0x99,0x96,0x94,0x93,0x8c,0x82,0x75,0x69,0x5b,0x51,0x48,0x43,0x3f,0x3e,0x3c,0x3b,
0x39,0x3c,0x3e,0x3f,0x40,0x48,0x54,0x63,0x70,0x7d,0x85,0x8c,0x91,0x96,0x9d,0xa3,
0xa3,0x9f,0x93,0x83,0x73,0x67,0x5e,0x59,0x55,0x4f,0x47,0x3d,0x34,0x30,0x34,0x39,
0x3d,0x3c,0x3c,0x39,0x35,0x34,0x36,0x40,0x4f,0x60,0x6e,0x7a,0x86,0x8e,0x93,0x97,
0x9b,0x9d,0xa1,0xa1,0x9f,0x9e,0x9a,0x98,0x99,0x9b,0x9f,0xa4,0xa5,0xa3,0x9d,0x93,
0x84,0x75,0x68,0x5c,0x55,0x50,0x48,0x3d,0x35,0x36,0x3f,0x50,0x65,0x77,0x81,0x7d,
0x6f,0x60,0x58,0x59,0x5b,0x67,0x70,0x75,0x7b,0x80,0x86,0x92,0x9a,0x9b,0x94,0x84,
0x71,0x5e,0x4c,0x3f,0x37,0x35,0x37,0x39,0x39,0x37,0x35,0x35,0x37,0x3e,0x4c,0x5e,
0x6e,0x79,0x7a,0x72,0x66,0x5d,0x59,0x5e,0x69,0x75,0x7b,0x79,0x70,0x68,0x63,0x60,
0x60,0x68,0x6d,0x6d,0x6e,0x72,0x79,0x83,0x91,0x9d,0xa7,0xad,0xad,0xa9,0xa1,0x97,
0x92,0x92,0x95,0x99,0x9e,0xa1,0xa1,0xa0,0x9b,0x9a,0x9b,0x9f,0x9f,0x9b,0x92,0x84,
0x74,0x66,0x59,0x51,0x4a,0x41,0x37,0x31,0x33,0x3e,0x53,0x67,0x77,0x7f,0x7e,0x73,
0x66,0x5e,0x5b,0x58,0x55,0x4a,0x3f,0x3b,0x3b,0x46,0x59,0x6f,0x80,0x8c,0x91,0x93,
0x94,0x98,0x9f,0xa4,0xa4,0x9f,0x93,0x84,0x73,0x65,0x5d,0x57,0x4d,0x43,0x39,0x34,
0x35,0x3c,0x4a,0x5c,0x6e,0x7e,0x88,0x8e,0x94,0x97,0x98,0x92,0x86,0x77,0x69,0x5b,
0x59,0x5f,0x6c,0x7a,0x81,0x7e,0x73,0x66,0x5c,0x5a,0x61,0x6d,0x76,0x7a,0x76,0x6d,
0x66,0x60,0x5d,0x5e,0x5b,0x54,0x49,0x3a,0x2f,0x2a,0x2b,0x32,0x3b,0x42,0x44,0x3f,
0x37,0x2f,0x2e,0x37,0x45,0x58,0x6d,0x7f,0x8b,0x94,0x98,0x98,0x93,0x8d,0x80,0x71,
0x60,0x4f,0x42,0x39,0x34,0x34,0x37,0x3a,0x3b,0x39,0x3a,0x3f,0x4a,0x58,0x67,0x75,
0x7c,0x7b,0x72,0x66,0x5c,0x5c,0x62,0x6a,0x70,0x78,0x7d,0x80,0x87,0x91,0x9b,0xa1,
0x9b,0x8b,0x72,0x5e,0x52,0x53,0x5f,0x6f,0x7a,0x7f,0x79,0x6e,0x64,0x5d,0x58,0x55,
0x4d,0x43,0x38,0x2f,0x2b,0x2f,0x36,0x3d,0x41,0x42,0x3e,0x39,0x34,0x31,0x32,0x37,
0x3b,0x3b,0x3b,0x3a,0x39,0x39,0x38,0x35,0x33,0x34,0x34,0x34,0x32,0x32,0x32,0x36,
0x35,0x33,0x35,0x37,0x38,0x39,0x37,0x36,0x38,0x39,0x38,0x38,0x38,0x37,0x34,0x33,
0x33,0x34,0x34,0x34,0x35,0x37,0x39,0x39,0x39,0x3a,0x3a,0x3b,0x3a,0x3a,0x3b,0x38,
// Line 17
0x3a,0x39,0x3a,0x3a,0x39,0x38,0x36,0x36,0x35,0x35,0x36,0x39,0x3b,0x3a,0x37,0x38,
0x39,0x3a,0x3c,0x3c,0x3b,0x3b,0x3c,0x3b,0x3a,0x3b,0x3c,0x3c,0x3a,0x39,0x38,0x39,
0x38,0x37,0x38,0x39,0x39,0x38,0x35,0x34,0x35,0x36,0x39,0x3b,0x3c,0x3b,0x37,0x34,
0x33,0x35,0x3b,0x3d,0x3a,0x37,0x33,0x32,0x38,0x46,0x58,0x6d,0x7a,0x7e,0x74,0x6b,
0x5f,0x5a,0x5e,0x69,0x74,0x7b,0x7a,0x74,0x6d,0x63,0x5e,0x60,0x66,0x6d,0x75,0x7a,
0x78,0x73,0x6d,0x66,0x61,0x62,0x67,0x6f,0x74,0x77,0x74,0x71,0x6c,0x67,0x66,0x66,
0x6a,0x72,0x78,0x7b,0x79,0x74,0x6d,0x67,0x62,0x61,0x67,0x6f,0x75,0x75,0x73,0x6d,
0x65,0x60,0x5d,0x5f,0x67,0x6f,0x77,0x77,0x78,0x72,0x6a,0x63,0x60,0x63,0x6d,0x75,
0x79,0x7c,0x79,0x73,0x6b,0x64,0x61,0x64,0x6a,0x6d,0x6e,0x6f,0x72,0x78,0x7f,0x89,
0x94,0xa0,0xa7,0xa9,0xa7,0xa1,0x95,0x85,0x74,0x66,0x5f,0x5a,0x54,0x4d,0x45,0x3b,
0x34,0x35,0x40,0x54,0x69,0x7c,0x88,0x90,0x94,0x98,0x9c,0x9e,0x9f,0x9f,0x9e,0x98,
0x8a,0x7e,0x72,0x66,0x5f,0x5e,0x65,0x70,0x7a,0x7e,0x7e,0x77,0x6a,0x60,0x5a,0x5d,
0x66,0x72,0x7b,0x7a,0x74,0x6b,0x63,0x61,0x63,0x6a,0x71,0x74,0x72,0x71,0x74,0x7c,
0x8a,0x98,0xa4,0xad,0xae,0xa9,0x9f,0x97,0x96,0x9a,0x9f,0x9e,0x96,0x8b,0x7c,0x6d,
0x60,0x55,0x4d,0x46,0x3c,0x33,0x33,0x3d,0x50,0x67,0x79,0x82,0x80,0x77,0x68,0x5c,
0x55,0x51,0x4c,0x44,0x3c,0x36,0x39,0x46,0x5b,0x75,0x87,0x8d,0x84,0x74,0x64,0x5c,
0x5c,0x63,0x68,0x73,0x79,0x7d,0x84,0x8f,0x9a,0xa5,0xa9,0xa9,0xa4,0x9c,0x90,0x83,
0x75,0x68,0x5d,0x53,0x4d,0x4a,0x49,0x46,0x40,0x3a,0x35,0x33,0x36,0x3c,0x45,0x50,
0x5a,0x64,0x6d,0x77,0x83,0x8f,0x9b,0x9d,0x94,0x86,0x76,0x67,0x5c,0x59,0x5f,0x6b,
0x77,0x82,0x8c,0x95,0x9d,0xa1,0xa1,0x99,0x8a,0x78,0x66,0x5a,0x56,0x5b,0x65,0x72,
0x7c,0x84,0x8d,0x96,0x9a,0x9c,0x98,0x8b,0x74,0x62,0x56,0x59,0x65,0x74,0x7e,0x85,
0x83,0x79,0x70,0x69,0x61,0x5c,0x51,0x43,0x37,0x31,0x33,0x40,0x53,0x6a,0x7f,0x8f,
0x97,0x9b,0x9a,0x96,0x8d,0x81,0x72,0x64,0x57,0x4b,0x41,0x3d,0x3b,0x3b,0x3c,0x3b,
0x3a,0x3a,0x3e,0x46,0x51,0x60,0x6f,0x7a,0x7e,0x78,0x6d,0x64,0x5e,0x60,0x6c,0x78,
0x7f,0x7d,0x77,0x6e,0x67,0x67,0x68,0x6c,0x6d,0x6f,0x6f,0x72,0x78,0x83,0x90,0x9c,
0xa4,0xac,0xb1,0xb1,0xab,0x9e,0x8d,0x7c,0x6d,0x62,0x5d,0x60,0x66,0x6b,0x72,0x78,
0x7e,0x89,0x94,0x9c,0x9d,0x97,0x8b,0x79,0x66,0x58,0x4e,0x47,0x41,0x3e,0x3d,0x40,
0x4a,0x5a,0x6c,0x7b,0x86,0x8b,0x8f,0x94,0x9c,0xa4,0xab,0xab,0xa7,0xa1,0x9d,0x9b,
0x9b,0x9d,0x9c,0x95,0x88,0x77,0x69,0x63,0x62,0x67,0x6f,0x77,0x7f,0x87,0x8f,0x96,
0x9c,0xa2,0xa5,0xa5,0xa5,0xa1,0x9c,0x9b,0x99,0x99,0x9b,0x9d,0x9f,0xa3,0xa4,0xa1,
0x95,0x87,0x79,0x6f,0x65,0x5c,0x52,0x49,0x42,0x3e,0x3f,0x44,0x4d,0x5d,0x6f,0x7d,
0x87,0x8f,0x96,0x9a,0x9b,0x9b,0x9c,0x9e,0x9e,0x9f,0xa1,0x9f,0x9d,0x9e,0xa2,0xa6,
0xa9,0xa9,0xa3,0x9c,0x91,0x83,0x72,0x63,0x58,0x56,0x5d,0x66,0x71,0x7d,0x87,0x8f,
0x94,0x9a,0x9f,0xa4,0xa5,0xa3,0x9d,0x94,0x89,0x7e,0x72,0x65,0x5e,0x60,0x66,0x72,
0x7c,0x80,0x7d,0x72,0x65,0x5d,0x5e,0x66,0x6e,0x77,0x7a,0x79,0x71,0x6a,0x63,0x60,
0x5f,0x5b,0x53,0x48,0x3b,0x31,0x2b,0x29,0x2b,0x33,0x40,0x4d,0x59,0x64,0x6f,0x78,
0x80,0x89,0x92,0x9b,0x9e,0x9a,0x8d,0x7a,0x66,0x58,0x55,0x5c,0x6b,0x78,0x7c,0x7a,
0x72,0x68,0x60,0x60,0x60,0x62,0x69,0x6f,0x73,0x7c,0x85,0x93,0x9f,0xa2,0x9a,0x8b,
0x7a,0x68,0x58,0x4b,0x3f,0x38,0x35,0x36,0x3d,0x4a,0x59,0x6c,0x7b,0x86,0x8d,0x94,
0x96,0x96,0x8f,0x82,0x6f,0x5d,0x50,0x46,0x3e,0x38,0x34,0x35,0x38,0x3a,0x3c,0x3f,
0x3e,0x3f,0x3f,0x3a,0x37,0x38,0x3b,0x3b,0x38,0x35,0x38,0x3d,0x48,0x55,0x63,0x73,
0x7e,0x85,0x8d,0x94,0x9b,0xa2,0xa4,0xa4,0xa2,0xa1,0xa0,0xa3,0xa5,0xa5,0xa5,0xa4,
0xa2,0xa0,0x9f,0x9b,0x8e,0x7d,0x6b,0x5b,0x54,0x55,0x61,0x6f,0x78,0x7d,0x7a,0x73,
0x6a,0x64,0x5d,0x55,0x4d,0x47,0x3e,0x35,0x30,0x2f,0x2f,0x35,0x3d,0x48,0x56,0x64,
0x70,0x78,0x79,0x75,0x6d,0x66,0x63,0x65,0x6c,0x73,0x74,0x76,0x78,0x7f,0x8c,0x98,
0xa4,0xac,0xae,0xa9,0xa1,0x99,0x97,0x9b,0x9f,0xa0,0x9b,0x93,0x84,0x74,0x64,0x59,
0x56,0x61,0x6d,0x75,0x79,0x77,0x6f,0x67,0x60,0x5b,0x54,0x50,0x46,0x3a,0x36,0x37,
0x40,0x52,0x69,0x7e,0x8f,0x96,0x98,0x9a,0x9b,0x9e,0xa3,0xa4,0xa2,0x9f,0x9d,0x9c,
0x9b,0x9b,0x97,0x8e,0x7e,0x6c,0x5c,0x53,0x4b,0x44,0x3e,0x39,0x35,0x33,0x34,0x37,
0x3a,0x3e,0x42,0x4b,0x57,0x65,0x71,0x7f,0x86,0x8d,0x96,0x9d,0xa1,0xa6,0xa5,0xa2,
0x9d,0x9a,0x9b,0x9e,0x9d,0x97,0x8a,0x7c,0x6d,0x60,0x56,0x4e,0x45,0x3f,0x39,0x35,
0x39,0x47,0x5b,0x72,0x80,0x82,0x7a,0x6d,0x61,0x5c,0x5e,0x65,0x6d,0x74,0x79,0x7c,
0x83,0x8c,0x96,0xa4,0xab,0xb0,0xae,0xa5,0x99,0x8a,0x7e,0x70,0x65,0x61,0x62,0x67,
0x6b,0x6f,0x77,0x81,0x8a,0x91,0x96,0x97,0x90,0x84,0x74,0x66,0x58,0x4d,0x46,0x41,
0x3f,0x40,0x45,0x50,0x5c,0x6c,0x7c,0x88,0x8d,0x91,0x94,0x98,0x9e,0xa3,0xa4,0xa1,
0x9d,0x9a,0x95,0x95,0x99,0x9d,0xa1,0x9e,0x98,0x96,0x96,0x98,0x9b,0x9c,0x9d,0x9b,
0x92,0x85,0x78,0x6b,0x61,0x5f,0x61,0x68,0x70,0x78,0x81,0x88,0x8f,0x97,0x9f,0xa5,
0xa5,0xa3,0x9d,0x98,0x96,0x97,0x9a,0x9b,0x96,0x8b,0x7e,0x6d,0x5d,0x50,0x47,0x46,
0x43,0x3d,0x38,0x35,0x35,0x39,0x3d,0x3e,0x3c,0x37,0x32,0x2f,0x31,0x3a,0x4a,0x5e,
0x6f,0x7c,0x7f,0x79,0x6d,0x61,0x58,0x52,0x4d,0x49,0x42,0x3c,0x35,0x31,0x30,0x37,
0x40,0x4a,0x54,0x5d,0x64,0x71,0x7f,0x8c,0x96,0x9b,0x98,0x92,0x85,0x77,0x66,0x58,
0x4c,0x43,0x3b,0x36,0x34,0x3d,0x4b,0x5d,0x71,0x7e,0x82,0x7a,0x6b,0x5c,0x56,0x5d,
0x6a,0x74,0x80,0x7f,0x74,0x67,0x5c,0x57,0x55,0x55,0x50,0x48,0x3a,0x30,0x29,0x29,
0x2d,0x39,0x42,0x4c,0x53,0x5d,0x66,0x72,0x7c,0x85,0x8f,0x99,0xa0,0xa5,0xa9,0xa9,
0xa7,0xa3,0x9d,0x99,0x9b,0x9e,0x9f,0x9d,0xa0,0x9f,0x9a,0x93,0x88,0x7c,0x6f,0x61,
0x52,0x4c,0x47,0x43,0x3c,0x38,0x33,0x33,0x32,0x33,0x36,0x3f,0x4a,0x57,0x63,0x6f,
0x7c,0x8a,0x94,0x97,0x98,0x94,0x89,0x79,0x67,0x58,0x4d,0x45,0x3e,0x3a,0x3a,0x3f,
0x47,0x55,0x65,0x74,0x80,0x88,0x8d,0x93,0x98,0x9f,0xa4,0xa6,0xa4,0xa2,0x9d,0x9a,
0x94,0x9a,0x9d,0xa1,0xa1,0xa1,0x9f,0x9f,0x9e,0x9e,0x9f,0x9e,0x9e,0xa0,0x9f,0x9f,
0x9f,0x9f,0x9e,0x9d,0x9c,0x9c,0x9b,0x94,0x84,0x71,0x60,0x55,0x54,0x5f,0x6d,0x7c,
0x80,0x7d,0x74,0x6d,0x67,0x67,0x67,0x6f,0x70,0x73,0x74,0x79,0x80,0x8e,0x97,0x9b,
0x98,0x8d,0x7e,0x6c,0x59,0x4b,0x42,0x3e,0x3b,0x3c,0x42,0x4d,0x5a,0x69,0x77,0x83,
0x8d,0x96,0x9b,0x9b,0x93,0x86,0x74,0x61,0x54,0x57,0x61,0x6f,0x78,0x7e,0x7c,0x76,
0x6d,0x67,0x63,0x63,0x56,0x45,0x36,0x2e,0x33,0x42,0x57,0x6d,0x82,0x90,0x96,0x97,
0x96,0x92,0x8c,0x82,0x72,0x61,0x53,0x49,0x42,0x41,0x3e,0x3a,0x38,0x39,0x3a,0x3f,
0x41,0x40,0x3a,0x33,0x30,0x33,0x3a,0x48,0x57,0x68,0x76,0x82,0x8c,0x96,0x9c,0x9e,
0x96,0x8a,0x7b,0x6d,0x61,0x5a,0x60,0x6a,0x74,0x7f,0x88,0x8f,0x96,0x9d,0xa0,0xa3,
0xa4,0xa4,0x9e,0x97,0x93,0x97,0x9c,0x9f,0x9c,0x91,0x83,0x73,0x64,0x5b,0x5c,0x62,
0x6b,0x73,0x7b,0x83,0x8d,0x99,0xa1,0xa3,0x9d,0x8f,0x7d,0x67,0x5e,0x5b,0x60,0x6c,
0x76,0x7e,0x8a,0x91,0x97,0x9a,0x99,0x94,0x88,0x74,0x5d,0x4d,0x44,0x40,0x3e,0x3d,
0x3b,0x3a,0x3a,0x3b,0x3e,0x40,0x42,0x40,0x3b,0x36,0x35,0x3b,0x46,0x56,0x68,0x78,
0x82,0x88,0x8d,0x92,0x98,0x9d,0x9f,0xa0,0x9f,0x96,0x88,0x79,0x6c,0x63,0x5d,0x55,
0x4a,0x43,0x3f,0x3e,0x3e,0x47,0x55,0x69,0x79,0x86,0x8f,0x96,0x96,0x93,0x8d,0x81,
0x72,0x62,0x53,0x47,0x3f,0x3a,0x36,0x34,0x38,0x45,0x59,0x6f,0x80,0x88,0x85,0x78,
0x67,0x5d,0x5e,0x69,0x78,0x82,0x81,0x79,0x6e,0x66,0x5f,0x66,0x6d,0x74,0x77,0x76,
0x74,0x78,0x80,0x8c,0x9a,0xa1,0x9d,0x92,0x7f,0x6b,0x5f,0x5b,0x60,0x69,0x73,0x7e,
0x88,0x91,0x98,0x9d,0x9d,0x97,0x8b,0x7c,0x69,0x5c,0x58,0x60,0x6a,0x78,0x80,0x82,
0x79,0x6c,0x60,0x5c,0x61,0x6a,0x72,0x77,0x77,0x71,0x69,0x62,0x5e,0x62,0x69,0x6f,
0x76,0x7a,0x78,0x6f,0x66,0x5e,0x5b,0x5d,0x5e,0x5b,0x52,0x44,0x34,0x2a,0x26,0x2d,
0x39,0x44,0x46,0x40,0x35,0x2d,0x2c,0x36,0x47,0x5d,0x73,0x7e,0x7b,0x72,0x66,0x5d,
0x58,0x54,0x4f,0x49,0x3d,0x33,0x34,0x42,0x58,0x6f,0x82,0x88,0x82,0x73,0x61,0x58,
0x5a,0x65,0x6f,0x78,0x7b,0x7e,0x83,0x8b,0x94,0x9c,0x9c,0x8f,0x7b,0x66,0x58,0x55,
0x5d,0x69,0x75,0x80,0x89,0x92,0x99,0x9f,0x9e,0x97,0x88,0x74,0x63,0x59,0x59,0x5f,
0x67,0x71,0x7c,0x88,0x90,0x98,0x9d,0x9b,0x93,0x86,0x72,0x5f,0x51,0x48,0x40,0x3e,
0x3b,0x3a,0x38,0x36,0x36,0x39,0x3c,0x3d,0x39,0x35,0x32,0x32,0x33,0x34,0x37,0x38,
0x36,0x34,0x34,0x33,0x35,0x36,0x37,0x35,0x35,0x37,0x39,0x3c,0x3d,0x3b,0x3a,0x39,
// Line 18
0x37,0x38,0x37,0x36,0x33,0x33,0x36,0x37,0x37,0x38,0x37,0x35,0x33,0x34,0x36,0x38,
0x37,0x36,0x34,0x35,0x34,0x33,0x33,0x33,0x34,0x37,0x37,0x37,0x37,0x38,0x37,0x35,
0x36,0x39,0x3d,0x41,0x43,0x44,0x49,0x4e,0x51,0x57,0x5a,0x5d,0x5d,0x5c,0x5a,0x55,
0x57,0x59,0x5a,0x5b,0x5b,0x59,0x5b,0x58,0x57,0x5a,0x5a,0x58,0x58,0x58,0x59,0x5a,
0x5a,0x5b,0x5b,0x5b,0x5a,0x5a,0x5a,0x5b,0x5a,0x5b,0x59,0x57,0x57,0x59,0x59,0x59,
0x56,0x56,0x57,0x57,0x58,0x5b,0x5d,0x5e,0x5c,0x5b,0x5a,0x5a,0x5b,0x5b,0x58,0x58,
0x57,0x56,0x55,0x55,0x56,0x59,0x5a,0x5a,0x56,0x58,0x57,0x58,0x59,0x5b,0x5d,0x5d,
0x5b,0x5a,0x5b,0x5a,0x57,0x55,0x54,0x56,0x59,0x59,0x59,0x59,0x59,0x58,0x57,0x57,
0x58,0x59,0x5a,0x58,0x55,0x55,0x55,0x57,0x5a,0x5a,0x5a,0x5a,0x5a,0x59,0x58,0x58,
0x57,0x57,0x57,0x57,0x55,0x58,0x56,0x57,0x59,0x5b,0x5b,0x5b,0x58,0x58,0x5a,0x5b,
0x5d,0x5d,0x5c,0x5b,0x5b,0x5b,0x5c,0x5d,0x5d,0x5b,0x59,0x59,0x58,0x59,0x5a,0x5b,
0x5b,0x5d,0x5d,0x5c,0x5b,0x5e,0x61,0x60,0x5e,0x5d,0x5a,0x5b,0x58,0x57,0x59,0x59,
0x59,0x58,0x55,0x55,0x57,0x5a,0x5d,0x5d,0x5c,0x5d,0x5d,0x5c,0x5b,0x5c,0x60,0x5c,
0x5a,0x5b,0x5a,0x59,0x58,0x56,0x56,0x58,0x58,0x58,0x58,0x57,0x57,0x57,0x57,0x56,
0x57,0x58,0x58,0x56,0x57,0x57,0x55,0x57,0x56,0x57,0x5a,0x5c,0x5b,0x5b,0x5b,0x5d,
0x5e,0x5f,0x60,0x5f,0x5e,0x5b,0x56,0x57,0x59,0x5b,0x5c,0x5a,0x58,0x58,0x57,0x57,
0x56,0x58,0x58,0x57,0x55,0x55,0x55,0x58,0x5a,0x5b,0x5d,0x5e,0x5d,0x5b,0x5a,0x5a,
0x5b,0x5b,0x5b,0x58,0x56,0x55,0x56,0x55,0x56,0x59,0x5b,0x5a,0x56,0x57,0x58,0x5b,
0x5d,0x5c,0x5b,0x5b,0x5c,0x5c,0x5b,0x5b,0x5a,0x5b,0x58,0x57,0x58,0x5c,0x5e,0x5e,
0x5c,0x59,0x55,0x56,0x57,0x5b,0x60,0x62,0x5d,0x55,0x4e,0x4e,0x57,0x68,0x7b,0x89,
0x8c,0x84,0x76,0x6a,0x65,0x66,0x6b,0x6a,0x64,0x5a,0x4f,0x4b,0x4e,0x58,0x61,0x66,
0x64,0x5e,0x55,0x53,0x52,0x53,0x57,0x5a,0x58,0x57,0x57,0x59,0x5b,0x5d,0x5b,0x58,
0x55,0x54,0x58,0x5b,0x5d,0x5b,0x5b,0x56,0x52,0x53,0x56,0x5a,0x5d,0x5b,0x59,0x5b,
0x5b,0x5d,0x60,0x62,0x61,0x5e,0x5d,0x5a,0x5a,0x5b,0x5b,0x58,0x58,0x58,0x58,0x59,
0x58,0x5a,0x5b,0x5c,0x5b,0x5a,0x58,0x56,0x56,0x56,0x57,0x58,0x5b,0x5b,0x58,0x57,
0x57,0x59,0x5b,0x5a,0x56,0x56,0x57,0x58,0x58,0x58,0x5a,0x5b,0x5b,0x5b,0x5b,0x5c,
0x5b,0x5a,0x5a,0x59,0x57,0x59,0x5a,0x5b,0x5b,0x5b,0x5a,0x58,0x55,0x56,0x58,0x5a,
0x5b,0x5c,0x5d,0x5e,0x5c,0x5e,0x5f,0x61,0x61,0x5e,0x5b,0x5a,0x58,0x57,0x54,0x55,
0x55,0x56,0x58,0x57,0x56,0x58,0x59,0x5a,0x5d,0x5f,0x60,0x61,0x5e,0x5c,0x5c,0x5d,
0x5d,0x5d,0x5b,0x57,0x54,0x55,0x57,0x5a,0x5c,0x5c,0x5b,0x5b,0x5b,0x5b,0x5c,0x5b,
0x5a,0x5a,0x5a,0x5a,0x58,0x57,0x58,0x5b,0x5c,0x5b,0x57,0x5b,0x5a,0x59,0x58,0x58,
0x58,0x5a,0x59,0x57,0x57,0x59,0x5b,0x5b,0x5a,0x5b,0x5a,0x5a,0x59,0x59,0x5b,0x58,
0x56,0x57,0x58,0x59,0x5b,0x5b,0x5a,0x5b,0x5b,0x5c,0x59,0x5a,0x59,0x5b,0x5d,0x5e,
0x5c,0x5b,0x5c,0x5c,0x5c,0x5c,0x5b,0x5b,0x59,0x57,0x56,0x58,0x58,0x59,0x59,0x59,
0x59,0x59,0x58,0x5a,0x5b,0x5c,0x5c,0x5c,0x5a,0x5a,0x5b,0x5a,0x59,0x59,0x59,0x5a,
0x56,0x56,0x55,0x58,0x5b,0x5b,0x5a,0x59,0x58,0x58,0x56,0x56,0x57,0x5a,0x5a,0x58,
0x56,0x57,0x59,0x5b,0x5a,0x5a,0x5a,0x5b,0x5a,0x57,0x57,0x57,0x58,0x5b,0x5c,0x5d,
0x5e,0x5e,0x5d,0x5d,0x5e,0x60,0x5e,0x5e,0x5a,0x59,0x59,0x58,0x56,0x57,0x55,0x55,
0x55,0x53,0x51,0x4f,0x4e,0x4b,0x4b,0x4a,0x49,0x4a,0x48,0x47,0x45,0x46,0x46,0x47,
0x47,0x47,0x44,0x43,0x42,0x43,0x45,0x45,0x44,0x46,0x46,0x46,0x43,0x42,0x42,0x43,
0x45,0x45,0x43,0x46,0x44,0x44,0x46,0x48,0x48,0x4a,0x48,0x45,0x42,0x40,0x42,0x46,
0x46,0x46,0x46,0x4a,0x4a,0x48,0x49,0x4a,0x49,0x4a,0x48,0x46,0x44,0x43,0x43,0x45,
0x46,0x46,0x45,0x45,0x46,0x48,0x49,0x48,0x44,0x43,0x44,0x43,0x43,0x43,0x43,0x46,
0x44,0x41,0x40,0x41,0x44,0x46,0x47,0x45,0x43,0x45,0x48,0x48,0x46,0x46,0x46,0x46,
0x43,0x42,0x43,0x45,0x43,0x43,0x43,0x43,0x44,0x44,0x45,0x46,0x46,0x47,0x45,0x45,
0x46,0x46,0x45,0x42,0x41,0x43,0x43,0x43,0x44,0x45,0x46,0x43,0x44,0x43,0x44,0x47,
0x49,0x48,0x48,0x46,0x45,0x45,0x43,0x43,0x46,0x47,0x46,0x45,0x43,0x44,0x46,0x47,
0x46,0x47,0x4a,0x4a,0x47,0x45,0x46,0x48,0x4a,0x48,0x48,0x48,0x46,0x44,0x44,0x45,
0x46,0x46,0x43,0x41,0x41,0x44,0x47,0x45,0x47,0x48,0x4a,0x4e,0x52,0x5a,0x65,0x71,
0x7e,0x8b,0x97,0xa0,0xa6,0xab,0xae,0xb2,0xb4,0xb6,0xb5,0xb2,0xb0,0xb0,0xb1,0xb1,
0xb2,0xb5,0xb6,0xb4,0xb2,0xb2,0xb4,0xb5,0xb4,0xb2,0xb0,0xb1,0xb2,0xb2,0xb1,0xaf,
0xaf,0xb0,0xaf,0xae,0xad,0xad,0xae,0xb0,0xae,0xae,0xae,0xb2,0xb2,0xb4,0xb6,0xb6,
0xb4,0xb5,0xb5,0xb4,0xb4,0xb1,0xae,0xad,0xac,0xac,0xac,0xad,0xae,0xae,0xad,0xac,
0xad,0xaf,0xb0,0xb2,0xb0,0xae,0xae,0xb0,0xb0,0xb1,0xb2,0xb2,0xb1,0xb2,0xb3,0xb2,
0xb2,0xb2,0xb1,0xb2,0xb4,0xb7,0xb7,0xb7,0xb4,0xb2,0xb2,0xb0,0xae,0xb0,0xb0,0xaf,
0xaf,0xae,0xb0,0xb1,0xb0,0xb0,0xb0,0xb2,0xb2,0xb4,0xb4,0xb2,0xb0,0xb0,0xb1,0xb1,
0xb0,0xb0,0xb2,0xb0,0xad,0xad,0xad,0xae,0xae,0xae,0xae,0xb1,0xb2,0xb0,0xb0,0xb0,
0xb3,0xb2,0xb0,0xb2,0xb0,0xb0,0xb1,0xb0,0xaf,0xb0,0xb0,0xae,0xac,0xae,0xb2,0xb4,
0xb3,0xb2,0xb2,0xb4,0xb4,0xb3,0xb2,0xb2,0xb2,0xb2,0xae,0xac,0xaa,0xac,0xad,0xb0,
0xb1,0xb2,0xb3,0xb2,0xaf,0xae,0xb0,0xb0,0xac,0xa9,0xa6,0xa4,0xa3,0xa3,0xa4,0xa3,
0xa2,0xa1,0x9f,0x9d,0x9e,0x9f,0xa0,0x9f,0x9d,0x9f,0xa0,0x9f,0x9f,0x9f,0x9f,0x9f,
0x9d,0x9f,0x9f,0x9f,0x9d,0x9c,0x9d,0x9f,0xa1,0xa3,0xa4,0xa4,0xa4,0xa2,0xa0,0x9f,
0x9f,0x9d,0x9d,0x9c,0x9c,0x9d,0x9d,0x9c,0x9b,0x9b,0x9d,0x9f,0x9f,0x9d,0x9d,0x9d,
0x9c,0x9c,0x9c,0x9d,0x9f,0xa1,0xa0,0x9f,0x9f,0x9e,0x9e,0x9e,0x9f,0xa0,0xa0,0xa1,
0x9f,0x9f,0xa1,0xa4,0xa4,0xa4,0xa3,0xa1,0xa1,0xa0,0x9f,0x9f,0x9e,0x9b,0x99,0x99,
0x9a,0x9a,0x9d,0x9d,0x9d,0x9f,0xa0,0xa0,0x9f,0xa0,0xa1,0xa2,0xa2,0xa2,0xa1,0xa1,
0xa0,0x9f,0x9f,0xa0,0xa1,0xa2,0xa0,0xa0,0xa1,0xa1,0xa0,0xa0,0x9f,0xa1,0xa2,0xa1,
0xa1,0xa1,0xa0,0x9e,0x9c,0x9d,0xa1,0xa1,0xa3,0xa2,0xa0,0xa1,0xa0,0xa0,0xa3,0xa4,
0xa4,0xa4,0xa1,0x9f,0x9a,0x9b,0x9b,0x9c,0x9b,0x9b,0x9b,0x9d,0x9e,0x9e,0x9f,0xa1,
0xa2,0xa2,0xa2,0xa1,0xa0,0xa0,0xa1,0xa1,0xa1,0xa0,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
0x9e,0x9f,0xa0,0xa0,0xa0,0xa0,0xa1,0xa4,0xa4,0xa2,0x9e,0x9f,0x9d,0x9d,0x9e,0x9f,
0x9e,0xa1,0xa1,0xa0,0xa0,0xa1,0xa2,0xa2,0xa1,0xa2,0xa4,0xa4,0xa1,0xa0,0xa1,0xa0,
0x9f,0x9f,0xa0,0xa1,0xa0,0x9e,0x9c,0x9d,0x9f,0xa0,0xa1,0xa0,0x9f,0xa0,0xa0,0xa0,
0xa0,0xa0,0xa0,0x9e,0x9c,0x9b,0x99,0x9d,0x9c,0x9c,0x9d,0x9d,0x9d,0xa1,0xa1,0xa1,
0xa2,0xa4,0xa3,0xa2,0xa2,0xa1,0xa2,0xa1,0xa0,0x9f,0x9f,0x9f,0x9d,0x9d,0x9e,0x9f,
0x9f,0x9e,0xa0,0xa1,0xa0,0x9e,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9e,0x9d,0x9c,0x9c,
0x9f,0x9f,0x9f,0x9d,0x9a,0x9b,0x9e,0xa1,0xa4,0xa5,0xa3,0xa0,0x9c,0x9a,0x9c,0xa1,
0xa3,0x9f,0x94,0x87,0x78,0x6e,0x6e,0x74,0x7e,0x8a,0x92,0x94,0x92,0x93,0x97,0x9f,
0xa7,0xaa,0xa7,0xa4,0x9c,0x97,0x97,0x9c,0xa1,0xa7,0xa7,0xa7,0xa4,0xa1,0x9f,0x9d,
0x9f,0x9e,0x9e,0x9c,0x9d,0x9f,0xa0,0x9e,0x9a,0x98,0x99,0x9a,0x9c,0x9e,0x9f,0xa0,
0xa0,0xa0,0x9f,0xa0,0xa1,0xa4,0xa4,0xa2,0xa1,0xa1,0xa0,0xa1,0xa2,0xa2,0xa2,0xa1,
0x9f,0x9e,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9e,0x9d,0x9b,0x9b,0x9b,0x9b,0x9c,0x9e,
0x9f,0x9f,0x9e,0x9c,0x9b,0xa0,0xa3,0xa4,0xa4,0xa4,0xa3,0xa4,0xa4,0xa4,0xa4,0xa4,
0xa1,0xa1,0xa1,0xa0,0x9f,0x9f,0x9e,0x9d,0x9d,0x9f,0xa0,0xa0,0x9e,0x9d,0x9d,0x9c,
0x9c,0x9d,0x9f,0xa0,0xa0,0xa1,0xa3,0xa4,0xa4,0xa2,0xa1,0xa3,0xa2,0xa2,0xa3,0xa1,
0xa0,0xa1,0xa0,0xa0,0x9f,0xa0,0xa0,0x9f,0x9f,0x9e,0x9f,0xa0,0x9f,0x9c,0x9e,0x9e,
0x9f,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0x9f,0xa1,0xa1,0x9f,0x9e,0x9d,0x9c,0x9f,0x9e,
0x9c,0x9e,0x9e,0x9e,0x9b,0x9b,0x9b,0x9f,0xa1,0xa0,0xa0,0xa1,0x9f,0x9f,0xa0,0xa2,
0xa2,0xa1,0xa0,0x9f,0x9f,0xa0,0xa0,0xa0,0x9f,0x9f,0xa1,0xa2,0xa2,0xa1,0xa1,0xa2,
0xa2,0xa2,0xa1,0xa2,0xa1,0x9e,0x9a,0x9a,0x9b,0x9d,0x9d,0x9e,0x9c,0x9d,0x9c,0x9e,
0x9f,0xa2,0xa2,0xa1,0x9f,0x9d,0x9d,0x9f,0x9f,0x9f,0xa0,0xa1,0x9f,0x9e,0x9c,0x9d,
0x9e,0x9f,0xa0,0xa0,0x9f,0x9e,0x9e,0x9d,0x9b,0x9b,0x9d,0x9f,0x9f,0x9f,0x9e,0x9f,
0x9e,0x9d,0x9d,0x9f,0xa1,0xa1,0xa0,0x9f,0x9e,0x9d,0x9c,0x9c,0x9e,0xa2,0xa2,0x9f,
0x9f,0x9e,0x9d,0x9c,0x9a,0x9a,0x9c,0x9f,0xa0,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0xa0,
0xa2,0xa2,0xa0,0x9f,0x9d,0x9d,0x9c,0x9b,0x9b,0x9f,0xa1,0xa1,0x9f,0x9e,0x9d,0x9b,
0x9a,0x97,0x92,0x8b,0x81,0x74,0x67,0x5c,0x52,0x4a,0x43,0x3d,0x38,0x36,0x34,0x33,
// Line 19
0x3a,0x36,0x35,0x37,0x39,0x38,0x37,0x36,0x35,0x34,0x34,0x35,0x37,0x39,0x3a,0x3a,
0x3a,0x3b,0x3c,0x3a,0x37,0x35,0x37,0x3b,0x3f,0x41,0x43,0x46,0x48,0x4c,0x51,0x58,
0x5f,0x62,0x61,0x61,0x61,0x61,0x62,0x64,0x64,0x65,0x65,0x62,0x5f,0x5f,0x61,0x62,
0x64,0x65,0x64,0x65,0x64,0x61,0x61,0x62,0x62,0x60,0x5f,0x5e,0x5d,0x5f,0x5f,0x5f,
0x5f,0x5f,0x60,0x60,0x5f,0x5e,0x5f,0x5f,0x5f,0x60,0x60,0x62,0x63,0x63,0x61,0x61,
0x61,0x61,0x5e,0x5e,0x5e,0x61,0x64,0x65,0x64,0x63,0x61,0x5e,0x5d,0x5d,0x5f,0x5f,
0x5f,0x5c,0x5d,0x60,0x61,0x62,0x66,0x67,0x65,0x65,0x63,0x61,0x61,0x61,0x62,0x62,
0x62,0x63,0x61,0x61,0x5e,0x5e,0x5f,0x60,0x5f,0x5e,0x5c,0x5c,0x5b,0x5b,0x5b,0x5c,
0x5d,0x5e,0x5d,0x5e,0x5e,0x5f,0x5d,0x5c,0x5d,0x5f,0x5f,0x5c,0x5d,0x5e,0x5c,0x5e,
0x5e,0x5f,0x61,0x62,0x61,0x61,0x61,0x61,0x5f,0x5f,0x5e,0x5e,0x5f,0x5e,0x5e,0x5d,
0x5c,0x5d,0x5e,0x5c,0x5b,0x5c,0x5c,0x5a,0x5a,0x59,0x5a,0x5b,0x5a,0x59,0x58,0x59,
0x57,0x57,0x57,0x56,0x56,0x58,0x57,0x57,0x56,0x57,0x56,0x56,0x55,0x55,0x52,0x54,
0x50,0x50,0x52,0x51,0x4e,0x4f,0x4e,0x4e,0x4e,0x4d,0x4b,0x4c,0x4a,0x48,0x46,0x45,
0x47,0x48,0x46,0x42,0x3e,0x40,0x40,0x40,0x3e,0x3d,0x3c,0x3d,0x39,0x36,0x35,0x35,
0x33,0x32,0x32,0x32,0x31,0x2f,0x2e,0x2f,0x2f,0x30,0x2e,0x2f,0x30,0x30,0x30,0x2e,
0x2e,0x30,0x32,0x34,0x35,0x35,0x37,0x38,0x39,0x3b,0x3d,0x42,0x45,0x47,0x49,0x4c,
0x4e,0x53,0x56,0x5b,0x5e,0x61,0x64,0x68,0x6c,0x72,0x75,0x79,0x7d,0x81,0x85,0x89,
0x8a,0x8e,0x92,0x94,0x97,0x99,0x99,0x9a,0x9a,0x98,0x96,0x95,0x94,0x92,0x8e,0x85,
0x7f,0x7c,0x79,0x73,0x6d,0x66,0x61,0x5d,0x56,0x4f,0x4a,0x46,0x41,0x3e,0x3b,0x38,
0x33,0x30,0x2e,0x2c,0x2d,0x2c,0x2f,0x31,0x32,0x34,0x39,0x3e,0x44,0x4d,0x54,0x5a,
0x5f,0x65,0x6f,0x7b,0x83,0x89,0x8d,0x92,0x96,0x98,0x9a,0x98,0x96,0x93,0x8d,0x85,
0x7e,0x78,0x71,0x6a,0x62,0x5a,0x50,0x4b,0x42,0x3d,0x3b,0x38,0x33,0x30,0x2c,0x2c,
0x30,0x32,0x35,0x3d,0x45,0x4d,0x55,0x5d,0x68,0x75,0x7f,0x88,0x8e,0x93,0x97,0x97,
0x94,0x8f,0x89,0x83,0x7a,0x70,0x67,0x5e,0x54,0x4c,0x45,0x41,0x3b,0x36,0x32,0x30,
0x32,0x36,0x38,0x3f,0x44,0x4c,0x57,0x63,0x6c,0x77,0x82,0x8a,0x8f,0x8f,0x8c,0x89,
0x83,0x7a,0x6f,0x64,0x59,0x4f,0x44,0x3b,0x33,0x33,0x33,0x34,0x35,0x3a,0x40,0x49,
0x52,0x5e,0x68,0x79,0x83,0x8a,0x8e,0x8f,0x89,0x87,0x7e,0x74,0x69,0x5b,0x4d,0x43,
0x39,0x34,0x33,0x35,0x37,0x3c,0x42,0x49,0x55,0x65,0x75,0x83,0x8b,0x8f,0x8f,0x8c,
0x87,0x7f,0x74,0x64,0x56,0x49,0x3c,0x32,0x2c,0x2c,0x31,0x38,0x41,0x4d,0x5b,0x69,
0x76,0x82,0x8b,0x8f,0x8c,0x87,0x7d,0x6f,0x61,0x53,0x46,0x3d,0x35,0x30,0x2f,0x34,
0x3f,0x4c,0x5c,0x6a,0x78,0x85,0x8a,0x8a,0x84,0x7d,0x74,0x69,0x5b,0x4c,0x40,0x38,
0x32,0x31,0x37,0x41,0x4e,0x60,0x71,0x7e,0x89,0x8e,0x8c,0x85,0x79,0x6b,0x5c,0x4f,
0x43,0x3b,0x33,0x2f,0x32,0x3e,0x51,0x64,0x7a,0x87,0x8d,0x90,0x88,0x7b,0x6d,0x61,
0x55,0x4d,0x40,0x37,0x32,0x36,0x42,0x56,0x6b,0x7d,0x87,0x89,0x81,0x76,0x6d,0x63,
0x58,0x4d,0x3f,0x36,0x33,0x39,0x46,0x5a,0x6d,0x7e,0x88,0x89,0x82,0x78,0x6f,0x61,
0x51,0x46,0x3f,0x39,0x39,0x40,0x4e,0x63,0x75,0x80,0x82,0x7e,0x72,0x64,0x56,0x4b,
0x41,0x3a,0x39,0x3c,0x49,0x5b,0x6e,0x7e,0x85,0x85,0x7e,0x71,0x60,0x52,0x48,0x40,
0x3b,0x3d,0x48,0x5a,0x6b,0x79,0x83,0x87,0x81,0x73,0x62,0x50,0x41,0x3a,0x39,0x3e,
0x45,0x57,0x6a,0x7a,0x82,0x81,0x77,0x6a,0x5b,0x4e,0x45,0x3f,0x3f,0x48,0x55,0x63,
0x72,0x7c,0x7f,0x79,0x6b,0x58,0x47,0x3e,0x3d,0x45,0x4e,0x57,0x64,0x73,0x7e,0x80,
0x77,0x6a,0x5c,0x51,0x48,0x46,0x4c,0x5b,0x68,0x73,0x79,0x7a,0x74,0x6e,0x5f,0x50,
0x47,0x44,0x48,0x52,0x5c,0x67,0x72,0x76,0x73,0x6a,0x5e,0x52,0x49,0x47,0x4d,0x58,
0x64,0x6e,0x73,0x74,0x6d,0x64,0x5b,0x52,0x4e,0x50,0x55,0x5c,0x66,0x6e,0x71,0x6c,
0x64,0x5b,0x52,0x51,0x50,0x54,0x5f,0x68,0x6e,0x6e,0x6a,0x63,0x5d,0x56,0x52,0x51,
0x56,0x5d,0x64,0x69,0x6c,0x6a,0x66,0x5e,0x55,0x53,0x56,0x5b,0x61,0x67,0x6b,0x6d,
0x66,0x5f,0x59,0x57,0x57,0x5d,0x62,0x66,0x68,0x67,0x61,0x5b,0x56,0x56,0x57,0x5e,
0x60,0x63,0x64,0x63,0x60,0x5b,0x57,0x59,0x5b,0x60,0x65,0x69,0x69,0x63,0x5b,0x54,
0x50,0x51,0x56,0x5f,0x68,0x70,0x71,0x6a,0x5e,0x54,0x50,0x54,0x5b,0x64,0x6c,0x70,
0x6c,0x61,0x55,0x4c,0x4b,0x54,0x62,0x6f,0x79,0x7a,0x70,0x5f,0x50,0x48,0x4c,0x59,
0x69,0x77,0x7d,0x75,0x64,0x53,0x47,0x45,0x52,0x61,0x72,0x7e,0x7b,0x6b,0x55,0x45,
0x40,0x49,0x5b,0x6e,0x7c,0x7e,0x71,0x5a,0x45,0x3f,0x47,0x5c,0x71,0x80,0x82,0x74,
0x5c,0x45,0x3a,0x41,0x57,0x71,0x81,0x80,0x6e,0x56,0x40,0x39,0x45,0x5e,0x79,0x86,
0x81,0x6d,0x52,0x3e,0x39,0x49,0x64,0x7e,0x87,0x7c,0x61,0x4a,0x3a,0x3e,0x52,0x6f,
0x82,0x84,0x6d,0x4e,0x38,0x35,0x46,0x64,0x7e,0x89,0x7f,0x64,0x45,0x36,0x3e,0x58,
0x75,0x86,0x81,0x68,0x49,0x33,0x35,0x50,0x71,0x88,0x89,0x73,0x52,0x3a,0x38,0x4d,
0x6a,0x85,0x89,0x74,0x54,0x3b,0x37,0x4e,0x6b,0x81,0x84,0x72,0x52,0x3a,0x38,0x4e,
0x6c,0x82,0x82,0x6d,0x51,0x3c,0x3c,0x54,0x71,0x83,0x7f,0x67,0x49,0x39,0x40,0x59,
0x75,0x84,0x7c,0x64,0x49,0x3e,0x49,0x65,0x7c,0x82,0x73,0x56,0x40,0x3f,0x50,0x6a,
0x7d,0x7d,0x6a,0x4f,0x40,0x45,0x5c,0x75,0x7d,0x72,0x5b,0x48,0x42,0x52,0x69,0x7a,
0x78,0x64,0x4b,0x40,0x46,0x5c,0x72,0x78,0x6e,0x5c,0x4e,0x4e,0x5b,0x6f,0x7a,0x73,
0x5f,0x4d,0x47,0x54,0x68,0x74,0x73,0x64,0x55,0x4c,0x56,0x65,0x73,0x77,0x6c,0x59,
0x4e,0x51,0x5f,0x6e,0x72,0x6b,0x5c,0x50,0x4f,0x5c,0x6a,0x71,0x6c,0x61,0x56,0x56,
0x5f,0x6a,0x6e,0x6a,0x5f,0x55,0x52,0x5a,0x63,0x6c,0x68,0x5d,0x53,0x53,0x5b,0x67,
0x6d,0x6c,0x66,0x5f,0x5a,0x5d,0x69,0x6f,0x6c,0x64,0x5a,0x57,0x5c,0x64,0x66,0x66,
0x5f,0x5a,0x55,0x5a,0x60,0x67,0x67,0x61,0x59,0x58,0x5c,0x63,0x66,0x66,0x61,0x5d,
0x5a,0x5c,0x61,0x65,0x66,0x62,0x5c,0x5a,0x5d,0x63,0x66,0x64,0x5f,0x5b,0x5b,0x5e,
0x61,0x64,0x66,0x63,0x5f,0x5f,0x61,0x66,0x67,0x66,0x61,0x5f,0x5e,0x5f,0x60,0x66,
0x64,0x60,0x5d,0x5c,0x5d,0x61,0x63,0x60,0x5f,0x5e,0x60,0x63,0x64,0x64,0x65,0x66,
0x65,0x65,0x64,0x65,0x64,0x63,0x5f,0x5f,0x61,0x63,0x62,0x61,0x5f,0x60,0x61,0x63,
0x63,0x63,0x61,0x60,0x5d,0x5c,0x5e,0x60,0x61,0x61,0x60,0x63,0x62,0x63,0x65,0x65,
0x65,0x65,0x63,0x61,0x5f,0x62,0x64,0x64,0x63,0x64,0x67,0x68,0x65,0x63,0x63,0x63,
0x61,0x61,0x60,0x60,0x5f,0x5d,0x5c,0x5d,0x5f,0x63,0x63,0x61,0x5f,0x5f,0x61,0x63,
0x62,0x64,0x64,0x62,0x60,0x5f,0x61,0x61,0x62,0x60,0x5f,0x61,0x61,0x60,0x61,0x5f,
0x5f,0x5e,0x5b,0x5b,0x5c,0x5e,0x5e,0x60,0x62,0x66,0x67,0x65,0x63,0x63,0x63,0x64,
0x61,0x5f,0x5f,0x5e,0x5c,0x5c,0x5f,0x63,0x65,0x65,0x64,0x63,0x61,0x61,0x5e,0x5c,
0x5c,0x5e,0x5e,0x5c,0x5e,0x61,0x62,0x64,0x62,0x61,0x62,0x63,0x60,0x61,0x62,0x64,
0x63,0x61,0x5c,0x5c,0x5f,0x61,0x61,0x61,0x61,0x61,0x61,0x60,0x60,0x62,0x64,0x64,
0x63,0x60,0x5f,0x5f,0x5f,0x5e,0x5f,0x63,0x64,0x64,0x62,0x61,0x63,0x64,0x64,0x63,
0x63,0x63,0x61,0x60,0x5f,0x60,0x61,0x62,0x5f,0x5f,0x61,0x63,0x5f,0x60,0x61,0x61,
0x63,0x61,0x60,0x60,0x5f,0x5f,0x61,0x63,0x64,0x66,0x66,0x64,0x61,0x61,0x62,0x63,
0x63,0x61,0x61,0x61,0x5e,0x5d,0x60,0x61,0x61,0x61,0x61,0x60,0x5f,0x5e,0x5c,0x5c,
0x5f,0x63,0x61,0x61,0x5f,0x60,0x61,0x61,0x60,0x62,0x63,0x62,0x60,0x5f,0x5e,0x60,
0x60,0x5f,0x5f,0x60,0x60,0x60,0x5f,0x61,0x61,0x64,0x63,0x63,0x63,0x64,0x64,0x65,
0x63,0x63,0x64,0x63,0x5f,0x5c,0x5d,0x5f,0x61,0x5f,0x5f,0x5d,0x5f,0x5f,0x5e,0x60,
0x60,0x60,0x60,0x5f,0x5e,0x5d,0x5f,0x5e,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x61,
0x61,0x63,0x63,0x63,0x61,0x63,0x62,0x63,0x63,0x64,0x61,0x5f,0x5e,0x60,0x61,0x60,
0x5e,0x5e,0x60,0x5f,0x5d,0x5e,0x60,0x61,0x63,0x63,0x61,0x5f,0x60,0x5f,0x5f,0x5f,
0x60,0x5f,0x61,0x5f,0x5f,0x62,0x61,0x61,0x63,0x63,0x62,0x60,0x5e,0x5e,0x61,0x61,
0x61,0x61,0x63,0x63,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x60,0x61,0x62,0x65,0x64,
0x62,0x61,0x60,0x5f,0x5b,0x55,0x4f,0x4a,0x43,0x3c,0x39,0x37,0x36,0x33,0x31,0x30,
0x31,0x33,0x35,0x37,0x35,0x3a,0x39,0x37,0x37,0x37,0x38,0x39,0x36,0x34,0x36,0x37,
0x35,0x38,0x38,0x35,0x35,0x35,0x37,0x39,0x39,0x39,0x36,0x36,0x35,0x34,0x34,0x34,
0x35,0x39,0x39,0x38,0x38,0x37,0x37,0x39,0x39,0x3a,0x3a,0x39,0x38,0x37,0x36,0x35,
0x34,0x35,0x35,0x35,0x37,0x37,0x36,0x37,0x36,0x37,0x38,0x37,0x37,0x37,0x35,0x33,
0x32,0x32,0x34,0x35,0x35,0x33,0x32,0x35,0x36,0x36,0x37,0x37,0x37,0x38,0x37,0x38,
0x39,0x3a,0x39,0x37,0x36,0x36,0x35,0x35,0x33,0x34,0x35,0x35,0x34,0x34,0x37,0x38,
// Line 20
0x3a,0x3c,0x3c,0x3b,0x3a,0x39,0x3a,0x3d,0x3e,0x3c,0x39,0x38,0x36,0x36,0x37,0x39,
0x3a,0x3b,0x39,0x37,0x38,0x39,0x3a,0x3a,0x39,0x38,0x38,0x38,0x37,0x38,0x3c,0x42,
0x47,0x50,0x5c,0x6b,0x7c,0x8a,0x99,0xa6,0xaf,0xb7,0xbc,0xc1,0xc2,0xc2,0xc1,0xbf,
0xbe,0xbf,0xbf,0xbf,0xc0,0xc2,0xc3,0xc5,0xc2,0xbe,0xbf,0xc0,0xbf,0xbc,0xbb,0xb9,
0xb9,0xb9,0xb9,0xb9,0xbc,0xbc,0xbb,0xbb,0xb9,0xba,0xbc,0xbc,0xbb,0xbd,0xbe,0xbe,
0xbc,0xbb,0xbc,0xbf,0xc0,0xc0,0xc0,0xc0,0xbf,0xbe,0xbe,0xbd,0xbd,0xbf,0xbc,0xb9,
0xbb,0xbd,0xbd,0xbc,0xba,0xba,0xbc,0xbc,0xba,0xb9,0xba,0xbb,0xbb,0xbc,0xbe,0xc1,
0xc3,0xc2,0xc0,0xc0,0xc0,0xbf,0xbf,0xbc,0xb9,0xba,0xbb,0xbb,0xbb,0xbd,0xbe,0xbd,
0xbc,0xbc,0xbe,0xc0,0xc0,0xbf,0xc0,0xc0,0xc0,0xc0,0xc2,0xc3,0xc4,0xc4,0xc2,0xbf,
0xbe,0xbf,0xbf,0xc0,0xbe,0xbd,0xbd,0xbc,0xbb,0xbc,0xbc,0xbd,0xbd,0xbb,0xb9,0xb9,
0xbb,0xba,0xb9,0xba,0xba,0xb9,0xb9,0xb9,0xba,0xbc,0xbd,0xbd,0xbe,0xbd,0xbd,0xbd,
0xbb,0xbb,0xbc,0xbe,0xbf,0xbc,0xbc,0xbd,0xbd,0xbe,0xbe,0xbd,0xbe,0xbc,0xba,0xbb,
0xbb,0xbc,0xbc,0xbb,0xba,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbd,0xbd,0xbc,0xbb,0xbb,
0xb9,0xb9,0xbc,0xc1,0xc2,0xbf,0xb9,0xb3,0xb1,0xb4,0xb8,0xb9,0xb5,0xac,0x9c,0x8b,
0x83,0x88,0x9a,0xa6,0xa9,0xa4,0x96,0x85,0x7c,0x84,0x96,0xa9,0xb1,0xac,0x96,0x82,
0x76,0x80,0x96,0xac,0xb6,0xaf,0x9b,0x81,0x74,0x7c,0x92,0xaa,0xb3,0xac,0x97,0x82,
0x76,0x7d,0x92,0xa8,0xb3,0xae,0x99,0x83,0x79,0x81,0x94,0xab,0xb4,0xae,0x99,0x83,
0x76,0x7d,0x91,0xa8,0xb2,0xac,0x98,0x83,0x76,0x7d,0x92,0xac,0xb5,0xad,0x98,0x82,
0x78,0x80,0x92,0xa7,0xb3,0xaf,0x9b,0x83,0x76,0x7c,0x90,0xa8,0xb1,0xac,0x98,0x83,
0x76,0x7c,0x90,0xa6,0xb3,0xac,0x98,0x83,0x76,0x7f,0x94,0xaa,0xb4,0xad,0x9a,0x83,
0x77,0x7d,0x91,0xa6,0xb3,0xaf,0x9d,0x88,0x7b,0x80,0x94,0xab,0xb7,0xb1,0x9c,0x85,
0x79,0x7f,0x93,0xab,0xb7,0xb2,0x9e,0x86,0x79,0x7f,0x93,0xa8,0xb4,0xaf,0x9d,0x86,
0x76,0x7f,0x91,0xa6,0xb1,0xac,0x96,0x82,0x74,0x78,0x8e,0xa7,0xb5,0xaf,0x9e,0x85,
0x79,0x82,0x97,0xac,0xb5,0xaf,0x9c,0x86,0x7a,0x80,0x94,0xa9,0xb4,0xad,0x9a,0x85,
0x7b,0x81,0x93,0xa7,0xb1,0xac,0x9a,0x86,0x7e,0x86,0x97,0xa5,0xa9,0xa4,0x96,0x8c,
0x8a,0x91,0x9e,0xa1,0x9a,0x8b,0x82,0x82,0x8d,0x98,0xa0,0x99,0x86,0x73,0x69,0x73,
0x8b,0xa0,0xa6,0x9a,0x7d,0x63,0x5c,0x6d,0x8b,0xa6,0xad,0x9b,0x79,0x5b,0x54,0x6b,
0x90,0xad,0xb3,0x9e,0x79,0x5c,0x56,0x6e,0x91,0xad,0xb3,0x9d,0x7b,0x5f,0x5c,0x70,
0x92,0xac,0xb1,0x9e,0x7d,0x60,0x5d,0x72,0x8f,0xaa,0xaf,0x9c,0x7c,0x61,0x59,0x6c,
0x8d,0xa9,0xb1,0x9f,0x7e,0x62,0x5c,0x6f,0x8e,0xa9,0xaf,0x9c,0x7a,0x5e,0x5a,0x70,
0x8f,0xa9,0xaf,0x9f,0x7e,0x60,0x59,0x6d,0x8f,0xaa,0xae,0x99,0x78,0x5c,0x56,0x6b,
0x8d,0xa9,0xae,0x9d,0x7a,0x5e,0x57,0x6c,0x8b,0xab,0xaf,0x9a,0x7b,0x5f,0x57,0x6b,
0x8c,0xa7,0xaf,0x9e,0x7c,0x61,0x59,0x6b,0x8b,0xa7,0xaf,0x9e,0x7d,0x5f,0x58,0x6d,
0x8d,0xa8,0xae,0x9c,0x7a,0x5e,0x58,0x6e,0x8f,0xaa,0xaf,0x9c,0x7d,0x61,0x59,0x6d,
0x8c,0xa6,0xad,0x9b,0x79,0x5e,0x59,0x6c,0x8d,0xa7,0xad,0x9a,0x7a,0x5e,0x58,0x6e,
0x8f,0xa9,0xaf,0x9b,0x7a,0x60,0x5a,0x6c,0x8d,0xa8,0xac,0x9a,0x7b,0x5f,0x58,0x6b,
0x8c,0xa6,0xad,0x9b,0x79,0x60,0x55,0x66,0x87,0xa5,0xae,0xa4,0x84,0x62,0x54,0x5f,
0x7b,0x96,0xa5,0x9a,0x7e,0x5f,0x4c,0x52,0x69,0x86,0x9b,0x9c,0x88,0x69,0x51,0x51,
0x67,0x89,0x9f,0xa1,0x8d,0x6f,0x56,0x54,0x68,0x88,0xa0,0xa3,0x91,0x71,0x57,0x51,
0x63,0x83,0x9e,0xa1,0x8e,0x6e,0x56,0x52,0x67,0x85,0x9e,0xa3,0x91,0x71,0x59,0x50,
0x62,0x85,0x9e,0xa1,0x8c,0x6c,0x54,0x52,0x65,0x84,0x9e,0xa3,0x90,0x71,0x55,0x51,
0x65,0x85,0x9c,0xa0,0x8d,0x70,0x56,0x50,0x61,0x80,0x9a,0x9f,0x8d,0x6e,0x54,0x4e,
0x61,0x84,0x9f,0xa1,0x90,0x70,0x55,0x52,0x65,0x81,0x9d,0xa3,0x90,0x72,0x57,0x52,
0x67,0x89,0xa1,0xa4,0x8f,0x70,0x57,0x52,0x64,0x83,0x9c,0xa1,0x8e,0x6f,0x54,0x4f,
0x65,0x84,0x9b,0x9f,0x8c,0x6d,0x53,0x50,0x65,0x85,0x9d,0x9f,0x8b,0x6f,0x56,0x52,
0x64,0x83,0x9c,0xa1,0x8d,0x6e,0x56,0x54,0x68,0x86,0x9c,0xa0,0x89,0x6e,0x53,0x4f,
0x65,0x86,0x9d,0xa4,0x8d,0x6d,0x56,0x53,0x65,0x84,0x9c,0x9f,0x8c,0x6e,0x57,0x56,
0x6a,0x86,0x9c,0x9e,0x8a,0x6e,0x57,0x55,0x67,0x83,0x97,0x98,0x89,0x73,0x62,0x5f,
0x6b,0x7f,0x8d,0x91,0x88,0x7a,0x70,0x6c,0x6c,0x6e,0x70,0x70,0x73,0x76,0x78,0x78,
0x71,0x63,0x56,0x52,0x5a,0x6b,0x7e,0x81,0x72,0x5c,0x46,0x41,0x51,0x6f,0x89,0x90,
0x7b,0x57,0x3b,0x38,0x4e,0x71,0x8b,0x91,0x7e,0x5c,0x41,0x3d,0x54,0x78,0x91,0x91,
0x79,0x56,0x40,0x40,0x56,0x76,0x8d,0x8f,0x7b,0x5e,0x47,0x44,0x5c,0x7b,0x90,0x94,
0x7e,0x5d,0x46,0x40,0x54,0x74,0x8d,0x8f,0x7c,0x5e,0x44,0x40,0x52,0x71,0x8c,0x92,
0x7e,0x5c,0x43,0x41,0x56,0x78,0x90,0x94,0x82,0x63,0x48,0x42,0x56,0x76,0x8f,0x93,
0x7f,0x60,0x49,0x45,0x56,0x77,0x90,0x93,0x80,0x5e,0x44,0x41,0x54,0x72,0x89,0x90,
0x7d,0x5f,0x46,0x43,0x55,0x76,0x8d,0x90,0x7c,0x5c,0x42,0x3f,0x52,0x70,0x8b,0x90,
0x7c,0x5c,0x42,0x41,0x56,0x75,0x8d,0x90,0x7c,0x5d,0x44,0x43,0x58,0x78,0x90,0x90,
0x7c,0x5f,0x48,0x44,0x54,0x74,0x8b,0x8f,0x7d,0x60,0x4a,0x48,0x5a,0x76,0x90,0x94,
0x80,0x60,0x46,0x40,0x54,0x72,0x8b,0x8f,0x7c,0x60,0x47,0x44,0x56,0x76,0x8d,0x8e,
0x79,0x5c,0x44,0x42,0x55,0x72,0x88,0x8d,0x7b,0x60,0x49,0x4b,0x5f,0x7b,0x8b,0x89,
0x72,0x57,0x45,0x47,0x5e,0x7a,0x87,0x7f,0x63,0x45,0x38,0x46,0x62,0x7d,0x85,0x76,
0x56,0x3a,0x31,0x46,0x68,0x85,0x8c,0x7a,0x57,0x39,0x31,0x46,0x68,0x85,0x8c,0x76,
0x51,0x33,0x2e,0x45,0x69,0x85,0x88,0x76,0x52,0x33,0x2f,0x43,0x67,0x85,0x8b,0x76,
0x55,0x3a,0x36,0x4a,0x69,0x83,0x89,0x76,0x54,0x39,0x35,0x49,0x67,0x83,0x8a,0x79,
0x58,0x3a,0x33,0x4a,0x6c,0x88,0x8c,0x78,0x56,0x3a,0x34,0x48,0x6a,0x85,0x89,0x75,
0x52,0x35,0x2f,0x46,0x67,0x80,0x86,0x72,0x51,0x33,0x32,0x49,0x6b,0x88,0x8d,0x7a,
0x57,0x3a,0x33,0x48,0x69,0x84,0x8a,0x76,0x53,0x37,0x31,0x47,0x68,0x84,0x8a,0x77,
0x56,0x3a,0x34,0x4a,0x6b,0x88,0x8d,0x7a,0x57,0x3c,0x34,0x47,0x67,0x85,0x8c,0x76,
0x54,0x39,0x36,0x4c,0x6d,0x84,0x8c,0x78,0x55,0x3a,0x32,0x46,0x68,0x83,0x88,0x74,
0x53,0x38,0x34,0x4a,0x6a,0x84,0x89,0x77,0x56,0x3b,0x35,0x49,0x6a,0x84,0x89,0x78,
0x56,0x3a,0x36,0x4b,0x6b,0x83,0x87,0x75,0x56,0x3c,0x35,0x44,0x68,0x81,0x87,0x77,
0x5b,0x43,0x3e,0x4b,0x60,0x79,0x82,0x7a,0x63,0x4b,0x3e,0x40,0x4e,0x60,0x6d,0x72,
0x66,0x53,0x42,0x38,0x39,0x44,0x53,0x5f,0x62,0x5b,0x4a,0x39,0x30,0x38,0x4e,0x63,
0x6d,0x67,0x54,0x3e,0x2e,0x33,0x46,0x5e,0x6d,0x6b,0x54,0x3c,0x2d,0x31,0x45,0x5d,
0x6b,0x69,0x55,0x3d,0x2c,0x36,0x4c,0x62,0x6e,0x67,0x52,0x3b,0x2d,0x32,0x47,0x60,
0x6c,0x67,0x51,0x38,0x2c,0x34,0x49,0x5f,0x69,0x64,0x50,0x3a,0x2e,0x35,0x4b,0x61,
0x6b,0x65,0x53,0x3e,0x30,0x34,0x48,0x60,0x6b,0x65,0x4e,0x3c,0x2f,0x33,0x47,0x5d,
0x69,0x66,0x54,0x3b,0x2e,0x33,0x49,0x60,0x6c,0x65,0x54,0x3e,0x31,0x33,0x47,0x5e,
0x6a,0x66,0x52,0x3a,0x2d,0x32,0x46,0x5e,0x6b,0x66,0x54,0x3b,0x2c,0x33,0x49,0x5f,
0x6b,0x66,0x53,0x3b,0x2d,0x31,0x44,0x5c,0x6a,0x66,0x54,0x3d,0x30,0x35,0x49,0x5f,
0x6c,0x69,0x55,0x3a,0x2d,0x33,0x47,0x5f,0x6b,0x69,0x56,0x3f,0x2e,0x33,0x48,0x5f,
0x6c,0x67,0x51,0x3a,0x2c,0x33,0x46,0x5e,0x6b,0x66,0x51,0x39,0x2d,0x35,0x4b,0x60,
0x6d,0x69,0x56,0x3f,0x31,0x35,0x4a,0x60,0x6b,0x62,0x53,0x3f,0x33,0x39,0x48,0x5a,
0x69,0x64,0x54,0x42,0x37,0x3a,0x46,0x52,0x56,0x55,0x4c,0x41,0x38,0x38,0x40,0x48,
0x4b,0x49,0x43,0x41,0x3d,0x3e,0x41,0x43,0x44,0x43,0x42,0x40,0x42,0x44,0x46,0x44,
0x42,0x40,0x40,0x43,0x46,0x45,0x46,0x48,0x44,0x43,0x42,0x43,0x44,0x43,0x41,0x40,
0x41,0x41,0x40,0x3f,0x40,0x43,0x46,0x46,0x44,0x44,0x43,0x42,0x43,0x44,0x46,0x46,
0x42,0x40,0x3f,0x3f,0x41,0x42,0x44,0x44,0x43,0x42,0x40,0x40,0x42,0x43,0x44,0x44,
0x42,0x41,0x41,0x40,0x3f,0x41,0x42,0x43,0x41,0x44,0x43,0x42,0x42,0x42,0x43,0x44,
0x44,0x44,0x44,0x42,0x3f,0x3e,0x3d,0x3d,0x3e,0x3e,0x3e,0x3c,0x3a,0x3b,0x3e,0x43,
0x43,0x40,0x3f,0x3e,0x3d,0x3f,0x41,0x42,0x44,0x44,0x41,0x40,0x42,0x46,0x45,0x45,
0x42,0x40,0x3f,0x3f,0x3f,0x42,0x42,0x40,0x3f,0x40,0x42,0x44,0x44,0x43,0x43,0x43,
0x41,0x3f,0x3e,0x3e,0x3f,0x42,0x43,0x43,0x42,0x44,0x44,0x44,0x44,0x45,0x45,0x44,
0x42,0x42,0x44,0x44,0x44,0x44,0x44,0x44,0x43,0x42,0x41,0x44,0x41,0x3f,0x3e,0x3f,
0x41,0x41,0x42,0x3f,0x3e,0x3f,0x40,0x42,0x42,0x41,0x40,0x41,0x40,0x3e,0x3e,0x40,
0x41,0x42,0x41,0x3f,0x3e,0x3e,0x3d,0x3d,0x3c,0x3b,0x38,0x34,0x31,0x33,0x35,0x37,
// Line 21
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//Field 4
// Line 10
0x36,0x39,0x3b,0x3a,0x37,0x36,0x38,0x39,0x39,0x38,0x38,0x37,0x36,0x34,0x33,0x36,
0x38,0x3a,0x3b,0x3a,0x38,0x37,0x3a,0x39,0x38,0x38,0x38,0x38,0x38,0x37,0x36,0x37,
0x38,0x38,0x39,0x3a,0x39,0x3a,0x3a,0x39,0x39,0x39,0x3a,0x3a,0x3d,0x3c,0x3b,0x3b,
0x37,0x37,0x38,0x38,0x37,0x37,0x37,0x36,0x37,0x38,0x3a,0x38,0x3a,0x37,0x34,0x34,
0x36,0x36,0x37,0x37,0x37,0x37,0x36,0x37,0x38,0x39,0x38,0x36,0x35,0x35,0x36,0x36,
0x38,0x38,0x39,0x3a,0x39,0x39,0x39,0x3a,0x3d,0x3d,0x3c,0x3a,0x38,0x38,0x38,0x38,
0x39,0x3a,0x3b,0x3a,0x39,0x3a,0x3b,0x3b,0x3c,0x3b,0x39,0x39,0x3a,0x39,0x38,0x36,
0x36,0x37,0x37,0x37,0x38,0x3a,0x39,0x38,0x38,0x3a,0x3a,0x39,0x37,0x35,0x37,0x38,
0x39,0x37,0x36,0x35,0x36,0x37,0x39,0x3a,0x3e,0x3d,0x3a,0x39,0x38,0x38,0x39,0x39,
0x39,0x3a,0x3b,0x3a,0x39,0x38,0x38,0x39,0x3a,0x3a,0x39,0x38,0x37,0x37,0x38,0x39,
0x39,0x39,0x39,0x3a,0x3b,0x3c,0x3c,0x3b,0x3a,0x39,0x37,0x37,0x37,0x36,0x38,0x38,
0x38,0x39,0x3a,0x3b,0x3d,0x3d,0x3d,0x3d,0x3d,0x3e,0x3d,0x3a,0x38,0x37,0x35,0x33,
0x34,0x36,0x37,0x37,0x38,0x38,0x38,0x37,0x36,0x36,0x39,0x3a,0x3a,0x37,0x37,0x38,
0x3a,0x39,0x39,0x39,0x3a,0x39,0x38,0x39,0x39,0x39,0x39,0x3a,0x3a,0x3c,0x3d,0x3c,
0x3a,0x38,0x36,0x34,0x37,0x38,0x38,0x39,0x38,0x36,0x36,0x37,0x39,0x3d,0x3d,0x3b,
0x3b,0x3b,0x3a,0x38,0x38,0x38,0x38,0x38,0x38,0x37,0x38,0x38,0x38,0x38,0x38,0x37,
0x38,0x37,0x38,0x38,0x39,0x3a,0x38,0x38,0x38,0x38,0x39,0x39,0x3a,0x39,0x37,0x35,
0x36,0x38,0x3a,0x3b,0x3a,0x3a,0x3a,0x3a,0x3b,0x3a,0x3a,0x3a,0x39,0x39,0x37,0x36,
0x37,0x39,0x3a,0x3b,0x3a,0x3b,0x3d,0x3d,0x3b,0x3b,0x3a,0x39,0x38,0x37,0x37,0x37,
0x38,0x38,0x38,0x3a,0x39,0x38,0x36,0x35,0x34,0x34,0x35,0x36,0x38,0x3a,0x3b,0x38,
0x38,0x38,0x3a,0x3b,0x3b,0x39,0x39,0x38,0x37,0x38,0x38,0x39,0x3b,0x3a,0x38,0x38,
0x38,0x3a,0x39,0x38,0x38,0x39,0x3a,0x39,0x3a,0x3b,0x3b,0x38,0x38,0x38,0x3c,0x3f,
0x3f,0x3b,0x3b,0x3a,0x3a,0x38,0x39,0x39,0x38,0x39,0x38,0x36,0x38,0x38,0x37,0x37,
0x36,0x34,0x34,0x35,0x34,0x36,0x38,0x39,0x3b,0x3d,0x3d,0x3d,0x3d,0x3c,0x3b,0x3b,
0x3b,0x3a,0x39,0x37,0x36,0x37,0x36,0x35,0x38,0x39,0x3a,0x38,0x37,0x37,0x38,0x39,
0x38,0x38,0x37,0x37,0x37,0x38,0x38,0x38,0x38,0x38,0x37,0x37,0x38,0x38,0x36,0x36,
0x36,0x37,0x3a,0x3c,0x3d,0x3f,0x3f,0x3d,0x3e,0x3d,0x3c,0x3c,0x39,0x37,0x37,0x38,
0x38,0x3a,0x3a,0x3b,0x3d,0x3e,0x3d,0x3b,0x3c,0x3c,0x3a,0x39,0x37,0x35,0x36,0x36,
0x33,0x33,0x33,0x35,0x35,0x36,0x36,0x38,0x3a,0x3c,0x3a,0x3b,0x39,0x38,0x39,0x39,
0x3a,0x3a,0x38,0x37,0x37,0x38,0x3a,0x3b,0x3c,0x3c,0x3c,0x3c,0x3b,0x3b,0x3d,0x3e,
0x3d,0x3d,0x3a,0x38,0x37,0x38,0x38,0x38,0x39,0x3a,0x3a,0x3a,0x3a,0x3c,0x3d,0x3d,
0x3b,0x3a,0x3b,0x3b,0x3c,0x3b,0x3b,0x39,0x37,0x35,0x36,0x39,0x3c,0x3d,0x3c,0x3a,
0x3a,0x3c,0x3e,0x3f,0x3f,0x3d,0x3a,0x38,0x37,0x38,0x3a,0x3b,0x3a,0x3a,0x37,0x38,
0x38,0x3a,0x3a,0x3b,0x3d,0x3d,0x3a,0x3b,0x3a,0x3a,0x3a,0x3a,0x38,0x38,0x37,0x36,
0x35,0x36,0x38,0x39,0x38,0x37,0x39,0x3c,0x3d,0x3d,0x3b,0x3b,0x39,0x38,0x37,0x38,
0x38,0x38,0x36,0x36,0x35,0x37,0x38,0x3a,0x3a,0x3c,0x3c,0x3a,0x38,0x38,0x38,0x38,
0x39,0x3a,0x3a,0x3d,0x3c,0x39,0x39,0x3b,0x3c,0x3c,0x39,0x36,0x36,0x37,0x37,0x37,
0x37,0x38,0x3a,0x3c,0x3d,0x3b,0x3b,0x3b,0x3a,0x39,0x38,0x37,0x3a,0x3a,0x37,0x35,
0x34,0x37,0x39,0x3b,0x3b,0x3c,0x3d,0x3b,0x3a,0x3b,0x3b,0x3b,0x3b,0x3a,0x37,0x34,
0x32,0x33,0x36,0x37,0x37,0x36,0x35,0x36,0x37,0x39,0x39,0x39,0x3a,0x3a,0x37,0x36,
0x36,0x38,0x3a,0x39,0x36,0x36,0x36,0x38,0x38,0x3a,0x3a,0x3b,0x3d,0x3d,0x3b,0x3a,
0x3b,0x3c,0x3b,0x37,0x36,0x37,0x38,0x37,0x37,0x3a,0x3b,0x39,0x3a,0x38,0x38,0x38,
0x38,0x38,0x3b,0x39,0x37,0x36,0x36,0x36,0x36,0x36,0x35,0x34,0x37,0x3a,0x3a,0x38,
0x3b,0x3d,0x40,0x3f,0x3e,0x3d,0x3e,0x3c,0x3b,0x3b,0x3c,0x3d,0x3c,0x39,0x38,0x37,
0x38,0x38,0x38,0x37,0x38,0x39,0x38,0x38,0x3b,0x3c,0x3b,0x3b,0x3a,0x3a,0x39,0x38,
0x37,0x38,0x38,0x38,0x37,0x35,0x36,0x37,0x38,0x38,0x38,0x38,0x37,0x37,0x37,0x37,
0x38,0x3a,0x39,0x37,0x36,0x36,0x37,0x38,0x3a,0x3b,0x3b,0x3b,0x39,0x37,0x37,0x38,
0x39,0x3b,0x3a,0x3a,0x38,0x37,0x37,0x38,0x3a,0x3d,0x3b,0x3b,0x38,0x37,0x39,0x3b,
0x3c,0x3e,0x3f,0x3d,0x3c,0x3a,0x39,0x3a,0x3a,0x39,0x37,0x36,0x37,0x37,0x38,0x38,
0x38,0x3a,0x38,0x37,0x39,0x3b,0x3a,0x38,0x38,0x39,0x3b,0x3b,0x39,0x3a,0x3b,0x3b,
0x38,0x38,0x37,0x38,0x3a,0x3a,0x39,0x38,0x39,0x39,0x3a,0x38,0x38,0x38,0x37,0x34,
0x32,0x32,0x33,0x34,0x35,0x36,0x37,0x39,0x39,0x3a,0x3a,0x39,0x39,0x3a,0x3a,0x3a,
0x3a,0x39,0x37,0x36,0x36,0x39,0x3a,0x3b,0x3a,0x39,0x39,0x38,0x37,0x37,0x39,0x3a,
0x3b,0x3a,0x39,0x3a,0x3a,0x3a,0x3a,0x39,0x3b,0x3a,0x38,0x36,0x35,0x36,0x36,0x36,
0x38,0x39,0x39,0x3a,0x38,0x37,0x37,0x36,0x34,0x35,0x36,0x37,0x35,0x36,0x37,0x38,
0x3b,0x3d,0x3c,0x3c,0x3b,0x3a,0x3b,0x3a,0x3a,0x3b,0x38,0x34,0x33,0x34,0x36,0x37,
0x37,0x38,0x38,0x38,0x38,0x38,0x3a,0x3a,0x3b,0x3b,0x38,0x37,0x36,0x37,0x36,0x36,
0x37,0x38,0x39,0x3a,0x38,0x37,0x38,0x39,0x38,0x38,0x39,0x38,0x38,0x37,0x36,0x38,
0x39,0x39,0x39,0x38,0x38,0x35,0x36,0x33,0x34,0x36,0x36,0x33,0x33,0x33,0x35,0x38,
0x3a,0x3b,0x3d,0x3c,0x3a,0x39,0x39,0x3a,0x3b,0x3a,0x38,0x37,0x37,0x36,0x36,0x36,
0x38,0x3b,0x3e,0x3c,0x39,0x39,0x39,0x3a,0x3a,0x39,0x38,0x38,0x36,0x33,0x32,0x33,
0x35,0x38,0x38,0x37,0x37,0x39,0x3a,0x3a,0x3b,0x3c,0x3b,0x39,0x37,0x38,0x38,0x37,
0x36,0x35,0x37,0x37,0x37,0x36,0x34,0x34,0x37,0x38,0x37,0x39,0x3b,0x3b,0x3a,0x39,
0x38,0x38,0x38,0x36,0x36,0x36,0x36,0x35,0x35,0x37,0x38,0x39,0x3a,0x3a,0x3b,0x3b,
0x3a,0x3b,0x3a,0x3a,0x38,0x3a,0x38,0x38,0x38,0x38,0x38,0x38,0x35,0x33,0x37,0x38,
0x38,0x38,0x38,0x3a,0x3a,0x39,0x39,0x3b,0x3c,0x3b,0x38,0x39,0x3b,0x3a,0x38,0x35,
0x35,0x37,0x38,0x38,0x38,0x38,0x38,0x38,0x37,0x38,0x38,0x38,0x37,0x36,0x37,0x36,
0x35,0x36,0x37,0x37,0x38,0x38,0x36,0x37,0x37,0x37,0x37,0x37,0x39,0x3a,0x3b,0x38,
0x37,0x38,0x39,0x38,0x38,0x38,0x37,0x38,0x39,0x3b,0x3a,0x38,0x37,0x38,0x38,0x38,
0x38,0x38,0x38,0x36,0x36,0x37,0x37,0x38,0x38,0x38,0x37,0x37,0x36,0x37,0x38,0x38,
0x3a,0x38,0x37,0x37,0x37,0x37,0x36,0x38,0x38,0x39,0x3a,0x38,0x36,0x37,0x38,0x37,
0x37,0x37,0x36,0x37,0x37,0x37,0x37,0x38,0x39,0x3a,0x3c,0x3b,0x38,0x37,0x36,0x35,
0x37,0x38,0x38,0x36,0x34,0x33,0x33,0x35,0x37,0x38,0x37,0x36,0x33,0x33,0x33,0x36,
0x38,0x37,0x35,0x35,0x35,0x36,0x35,0x37,0x38,0x3a,0x39,0x38,0x38,0x3a,0x39,0x37,
0x38,0x38,0x38,0x3a,0x37,0x35,0x36,0x35,0x35,0x35,0x36,0x36,0x37,0x37,0x36,0x36,
0x35,0x36,0x37,0x39,0x39,0x38,0x38,0x37,0x37,0x3a,0x3a,0x3a,0x3a,0x3a,0x39,0x38,
0x37,0x37,0x38,0x39,0x38,0x37,0x37,0x36,0x36,0x36,0x36,0x35,0x35,0x35,0x34,0x33,
0x33,0x34,0x36,0x37,0x37,0x38,0x3a,0x3a,0x39,0x39,0x3a,0x3a,0x39,0x37,0x36,0x36,
0x35,0x33,0x32,0x33,0x34,0x37,0x38,0x3a,0x39,0x3c,0x3b,0x3a,0x3a,0x3a,0x38,0x39,
0x37,0x35,0x34,0x34,0x37,0x37,0x38,0x38,0x38,0x38,0x36,0x34,0x34,0x35,0x37,0x38,
0x37,0x36,0x37,0x36,0x34,0x37,0x38,0x38,0x38,0x37,0x36,0x36,0x37,0x38,0x38,0x38,
0x3a,0x38,0x38,0x34,0x34,0x35,0x36,0x36,0x37,0x38,0x38,0x33,0x35,0x36,0x37,0x38,
0x38,0x38,0x37,0x35,0x33,0x35,0x37,0x38,0x3b,0x3a,0x38,0x3a,0x3c,0x3d,0x3d,0x3b,
0x3a,0x3a,0x39,0x37,0x37,0x37,0x38,0x39,0x39,0x39,0x38,0x39,0x38,0x37,0x37,0x38,
0x3a,0x3a,0x38,0x39,0x3b,0x3d,0x3d,0x3d,0x3d,0x3c,0x3a,0x38,0x38,0x38,0x39,0x37,
0x36,0x35,0x36,0x36,0x37,0x38,0x38,0x38,0x38,0x36,0x35,0x36,0x38,0x38,0x3b,0x3b,
0x3a,0x3b,0x3b,0x3b,0x3c,0x3d,0x3d,0x39,0x38,0x36,0x36,0x37,0x37,0x36,0x36,0x37,
0x37,0x37,0x37,0x39,0x3b,0x3b,0x3b,0x3b,0x3b,0x3a,0x38,0x39,0x38,0x38,0x39,0x3a,
0x37,0x39,0x39,0x38,0x39,0x38,0x38,0x3b,0x3a,0x3b,0x3a,0x38,0x3a,0x3a,0x39,0x37,
0x38,0x3b,0x3c,0x3a,0x3a,0x38,0x38,0x38,0x39,0x3a,0x3d,0x3d,0x3b,0x3a,0x38,0x37,
0x38,0x36,0x37,0x38,0x38,0x38,0x37,0x36,0x36,0x37,0x38,0x38,0x38,0x3a,0x3a,0x37,
0x37,0x38,0x38,0x38,0x36,0x35,0x36,0x36,0x37,0x38,0x39,0x38,0x39,0x39,0x38,0x38,
0x39,0x3a,0x3a,0x3a,0x3a,0x38,0x37,0x36,0x34,0x36,0x38,0x38,0x38,0x38,0x38,0x38,
0x38,0x38,0x38,0x3a,0x3b,0x3a,0x3a,0x39,0x38,0x39,0x36,0x35,0x37,0x39,0x3a,0x37,
0x37,0x37,0x38,0x39,0x39,0x3b,0x3f,0x3d,0x3a,0x39,0x38,0x37,0x38,0x37,0x34,0x35,
0x37,0x38,0x38,0x38,0x37,0x36,0x36,0x34,0x33,0x36,0x38,0x38,0x3a,0x39,0x38,0x3a,
// Line 11
0x38,0x39,0x3a,0x3a,0x37,0x36,0x38,0x39,0x38,0x36,0x36,0x36,0x37,0x38,0x38,0x38,
0x37,0x36,0x34,0x34,0x34,0x34,0x34,0x33,0x32,0x32,0x33,0x36,0x37,0x36,0x34,0x34,
0x34,0x34,0x36,0x37,0x36,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x38,0x38,0x37,0x3a,
0x36,0x33,0x34,0x39,0x44,0x57,0x6a,0x75,0x78,0x71,0x64,0x59,0x53,0x55,0x5f,0x6c,
0x77,0x7a,0x75,0x6c,0x63,0x5e,0x5d,0x60,0x67,0x6d,0x71,0x72,0x6e,0x67,0x60,0x5c,
0x5d,0x64,0x6c,0x73,0x76,0x74,0x6d,0x64,0x5f,0x5a,0x5c,0x63,0x6c,0x71,0x75,0x74,
0x6f,0x66,0x5f,0x5a,0x5c,0x63,0x6d,0x74,0x76,0x73,0x6c,0x66,0x5f,0x5c,0x5f,0x65,
0x6d,0x74,0x74,0x71,0x6a,0x63,0x5a,0x56,0x5a,0x66,0x71,0x7a,0x7c,0x75,0x71,0x6a,
0x63,0x64,0x66,0x68,0x6d,0x6c,0x6a,0x6a,0x6f,0x76,0x83,0x90,0x9d,0xa6,0xaa,0xa7,
0x9d,0x8f,0x7f,0x70,0x64,0x5a,0x55,0x52,0x4d,0x43,0x39,0x34,0x38,0x44,0x55,0x69,
0x7a,0x86,0x8d,0x91,0x96,0x9b,0x9e,0xa2,0x9e,0x9b,0x9a,0x99,0x97,0x97,0x95,0x8e,
0x83,0x73,0x67,0x5d,0x55,0x4b,0x42,0x3b,0x36,0x36,0x3d,0x4d,0x62,0x76,0x7e,0x7c,
0x74,0x67,0x5c,0x57,0x51,0x4a,0x40,0x35,0x2f,0x33,0x44,0x5b,0x71,0x80,0x83,0x7c,
0x6f,0x60,0x55,0x51,0x4d,0x47,0x40,0x38,0x32,0x2d,0x31,0x34,0x3b,0x47,0x57,0x65,
0x71,0x77,0x77,0x72,0x68,0x61,0x5a,0x53,0x4d,0x45,0x3a,0x33,0x31,0x3c,0x50,0x68,
0x7e,0x8e,0x96,0x97,0x94,0x90,0x8b,0x82,0x72,0x63,0x58,0x57,0x61,0x6e,0x7a,0x7d,
0x7b,0x70,0x64,0x5d,0x5b,0x56,0x50,0x41,0x30,0x29,0x30,0x43,0x5e,0x75,0x82,0x82,
0x75,0x66,0x5c,0x58,0x53,0x4c,0x43,0x39,0x34,0x39,0x49,0x60,0x78,0x86,0x85,0x79,
0x68,0x5b,0x56,0x56,0x59,0x5e,0x65,0x6c,0x75,0x83,0x91,0x99,0x9e,0x95,0x86,0x75,
0x62,0x55,0x4c,0x45,0x3d,0x38,0x37,0x3e,0x4b,0x5b,0x6b,0x7a,0x86,0x8d,0x91,0x96,
0x9a,0x9f,0xa4,0xa5,0x9d,0x91,0x80,0x71,0x62,0x56,0x4e,0x49,0x44,0x3d,0x37,0x34,
0x33,0x34,0x39,0x3d,0x3c,0x3b,0x3a,0x39,0x3a,0x39,0x39,0x37,0x33,0x30,0x32,0x3c,
0x4b,0x5e,0x71,0x7d,0x7e,0x73,0x66,0x5d,0x5d,0x62,0x6b,0x74,0x78,0x7b,0x7f,0x86,
0x8f,0x9a,0xa2,0x9e,0x8d,0x75,0x5c,0x4d,0x51,0x5c,0x6a,0x78,0x7e,0x7b,0x72,0x67,
0x60,0x5e,0x5a,0x54,0x47,0x38,0x2d,0x2f,0x3f,0x58,0x72,0x84,0x86,0x7e,0x70,0x62,
0x5a,0x5d,0x68,0x75,0x80,0x83,0x7d,0x72,0x68,0x62,0x60,0x66,0x6d,0x75,0x7b,0x78,
0x71,0x69,0x61,0x5e,0x63,0x6c,0x75,0x7d,0x7e,0x78,0x6e,0x67,0x61,0x5e,0x5e,0x5c,
0x55,0x4b,0x3d,0x30,0x2c,0x2c,0x31,0x38,0x42,0x4e,0x5c,0x69,0x73,0x78,0x77,0x71,
0x6a,0x63,0x5e,0x59,0x53,0x49,0x3e,0x36,0x36,0x40,0x53,0x6a,0x80,0x90,0x98,0x9a,
0x96,0x91,0x89,0x7f,0x73,0x64,0x55,0x49,0x3f,0x3b,0x3b,0x3c,0x3e,0x3e,0x3b,0x3a,
0x3e,0x46,0x51,0x61,0x6f,0x78,0x79,0x75,0x6a,0x60,0x5c,0x5f,0x68,0x75,0x7c,0x7c,
0x76,0x6c,0x62,0x5f,0x63,0x6a,0x6e,0x75,0x75,0x73,0x77,0x81,0x8c,0x9c,0xa4,0xa8,
0xa9,0xa4,0x9d,0x96,0x92,0x92,0x94,0x95,0x92,0x8c,0x81,0x71,0x5e,0x4d,0x43,0x40,
0x40,0x40,0x3d,0x3a,0x37,0x35,0x36,0x3d,0x47,0x57,0x66,0x72,0x79,0x78,0x71,0x6a,
0x63,0x5a,0x52,0x4b,0x45,0x3d,0x38,0x33,0x31,0x31,0x36,0x40,0x4f,0x5c,0x68,0x72,
0x78,0x78,0x73,0x6a,0x61,0x58,0x55,0x4f,0x46,0x3f,0x38,0x32,0x30,0x33,0x38,0x41,
0x4a,0x53,0x5c,0x64,0x6e,0x78,0x84,0x8e,0x95,0x9a,0x9f,0xa3,0xa6,0xa2,0x99,0x8a,
0x77,0x66,0x5c,0x5a,0x5e,0x64,0x6c,0x73,0x7a,0x82,0x8b,0x95,0x9c,0x9d,0x94,0x86,
0x73,0x63,0x58,0x53,0x55,0x5e,0x6c,0x79,0x84,0x8c,0x90,0x96,0x9d,0xa1,0xa1,0x9e,
0x99,0x95,0x95,0x96,0x96,0x96,0x93,0x8b,0x80,0x6f,0x61,0x59,0x59,0x5f,0x68,0x70,
0x7a,0x85,0x90,0x98,0x9a,0x97,0x90,0x85,0x75,0x61,0x4e,0x43,0x3d,0x3b,0x3a,0x3b,
0x3b,0x3a,0x39,0x38,0x3b,0x44,0x53,0x65,0x73,0x79,0x77,0x71,0x69,0x61,0x5c,0x57,
0x50,0x47,0x3e,0x37,0x39,0x44,0x57,0x6b,0x80,0x8c,0x91,0x96,0x97,0x95,0x90,0x84,
0x71,0x62,0x58,0x55,0x59,0x68,0x75,0x7e,0x7b,0x6f,0x61,0x5a,0x59,0x60,0x6c,0x74,
0x77,0x73,0x69,0x61,0x5f,0x61,0x61,0x5d,0x52,0x43,0x36,0x2d,0x30,0x3f,0x55,0x6c,
0x7d,0x8b,0x92,0x97,0x99,0x95,0x8c,0x80,0x70,0x60,0x55,0x53,0x5b,0x6a,0x75,0x7b,
0x77,0x6f,0x66,0x60,0x5c,0x59,0x53,0x4a,0x3d,0x31,0x2b,0x2c,0x31,0x38,0x40,0x47,
0x50,0x5b,0x66,0x74,0x82,0x8c,0x91,0x96,0x96,0x91,0x8b,0x7c,0x68,0x57,0x4a,0x42,
0x3b,0x3b,0x3b,0x3a,0x36,0x32,0x31,0x36,0x40,0x4c,0x59,0x64,0x73,0x82,0x8e,0x97,
0x9d,0x9b,0x93,0x84,0x71,0x62,0x59,0x56,0x58,0x5f,0x6b,0x78,0x84,0x8f,0x96,0x9a,
0x9a,0x91,0x81,0x70,0x62,0x53,0x45,0x3d,0x39,0x39,0x3b,0x3a,0x36,0x38,0x37,0x39,
0x40,0x49,0x55,0x67,0x75,0x80,0x8b,0x94,0x9a,0x98,0x90,0x82,0x72,0x64,0x5a,0x56,
0x59,0x62,0x6f,0x7d,0x8a,0x94,0x9d,0x9e,0x9a,0x90,0x83,0x73,0x60,0x4e,0x42,0x3e,
0x3c,0x3a,0x39,0x38,0x37,0x34,0x36,0x39,0x41,0x4d,0x57,0x60,0x6d,0x7b,0x88,0x91,
0x96,0x99,0x9d,0xa1,0xa4,0xa3,0x9d,0x90,0x7d,0x69,0x59,0x53,0x5a,0x66,0x71,0x78,
0x78,0x73,0x6a,0x61,0x5d,0x5c,0x59,0x50,0x43,0x38,0x31,0x2d,0x2e,0x31,0x38,0x40,
0x40,0x3c,0x37,0x36,0x37,0x36,0x35,0x32,0x33,0x3a,0x44,0x52,0x67,0x76,0x7e,0x7e,
0x75,0x6c,0x64,0x61,0x62,0x68,0x6e,0x71,0x75,0x7a,0x82,0x8e,0x97,0x99,0x93,0x86,
0x71,0x5c,0x4d,0x42,0x3c,0x3b,0x3d,0x3e,0x3e,0x3d,0x3d,0x3c,0x3d,0x41,0x4c,0x5c,
0x6a,0x72,0x77,0x72,0x68,0x61,0x5e,0x5f,0x65,0x6c,0x6f,0x75,0x7c,0x87,0x92,0x9d,
0xa3,0xa6,0xa8,0xa4,0x9d,0x94,0x89,0x7c,0x6f,0x61,0x5a,0x5c,0x66,0x73,0x7e,0x7e,
0x78,0x6c,0x61,0x59,0x5a,0x61,0x67,0x6a,0x6d,0x6f,0x73,0x80,0x8e,0x9b,0xa3,0x9e,
0x8d,0x77,0x61,0x53,0x4e,0x54,0x5d,0x6a,0x7a,0x87,0x92,0x98,0x9c,0x9c,0x97,0x89,
0x75,0x61,0x4f,0x43,0x3e,0x3e,0x3f,0x3e,0x3c,0x38,0x36,0x36,0x39,0x40,0x4d,0x5b,
0x67,0x74,0x7f,0x8b,0x96,0x9c,0x9a,0x94,0x86,0x75,0x64,0x58,0x52,0x55,0x60,0x6e,
0x7c,0x89,0x94,0x9c,0xa1,0x9f,0x97,0x8a,0x78,0x65,0x58,0x54,0x58,0x61,0x6c,0x78,
0x84,0x8e,0x94,0x95,0x95,0x8e,0x7f,0x70,0x5f,0x4f,0x45,0x42,0x3f,0x40,0x40,0x40,
0x39,0x38,0x37,0x3b,0x45,0x53,0x5f,0x6e,0x74,0x72,0x70,0x68,0x60,0x5c,0x5a,0x53,
0x4a,0x40,0x3b,0x3c,0x44,0x53,0x68,0x80,0x91,0x9a,0x9a,0x97,0x8e,0x86,0x7c,0x6f,
0x63,0x58,0x4e,0x46,0x3e,0x39,0x3a,0x40,0x4c,0x60,0x74,0x83,0x83,0x7c,0x69,0x59,
0x55,0x58,0x63,0x73,0x7c,0x7c,0x74,0x6a,0x61,0x5d,0x61,0x68,0x6f,0x75,0x77,0x75,
0x70,0x67,0x60,0x5c,0x5d,0x62,0x6d,0x75,0x79,0x75,0x6f,0x69,0x64,0x61,0x60,0x5e,
0x58,0x4e,0x40,0x36,0x2f,0x2e,0x32,0x37,0x40,0x4b,0x58,0x65,0x71,0x76,0x75,0x70,
0x66,0x5f,0x5e,0x63,0x6a,0x6d,0x6d,0x70,0x76,0x82,0x8c,0x96,0x9d,0x99,0x8b,0x76,
0x61,0x52,0x48,0x44,0x41,0x3e,0x3e,0x3e,0x3d,0x3d,0x3e,0x3f,0x3e,0x38,0x30,0x2c,
0x2e,0x39,0x4a,0x5e,0x6f,0x7a,0x7b,0x76,0x6b,0x61,0x5a,0x55,0x4f,0x46,0x3e,0x38,
0x33,0x31,0x33,0x36,0x3c,0x47,0x52,0x60,0x6e,0x78,0x7b,0x75,0x6b,0x60,0x5a,0x5c,
0x63,0x6e,0x78,0x7a,0x73,0x68,0x5e,0x59,0x5b,0x61,0x6c,0x75,0x79,0x76,0x6f,0x67,
0x61,0x5f,0x63,0x6c,0x77,0x7f,0x7f,0x77,0x6a,0x5f,0x5a,0x5c,0x60,0x61,0x59,0x47,
0x36,0x2d,0x32,0x44,0x5d,0x75,0x82,0x83,0x7a,0x6a,0x5e,0x57,0x52,0x4d,0x46,0x3d,
0x38,0x3c,0x4a,0x5f,0x75,0x86,0x89,0x80,0x6f,0x5f,0x57,0x5a,0x61,0x67,0x6b,0x6e,
0x72,0x7c,0x88,0x97,0xa5,0xae,0xad,0xa6,0x9e,0x99,0x98,0x9d,0x9d,0x99,0x92,0x87,
0x77,0x6c,0x61,0x56,0x4d,0x43,0x3b,0x34,0x38,0x40,0x51,0x67,0x7a,0x84,0x82,0x75,
0x67,0x5c,0x55,0x50,0x4a,0x42,0x38,0x33,0x33,0x3d,0x51,0x6b,0x82,0x91,0x97,0x98,
0x96,0x98,0x9f,0xa6,0xab,0xa4,0x96,0x85,0x73,0x65,0x5c,0x57,0x4f,0x43,0x3a,0x33,
0x32,0x3b,0x4e,0x63,0x76,0x80,0x7e,0x78,0x6c,0x60,0x57,0x50,0x49,0x44,0x3c,0x34,
0x2d,0x30,0x33,0x3a,0x43,0x49,0x49,0x46,0x3e,0x39,0x38,0x37,0x36,0x37,0x38,0x3f,
0x4a,0x57,0x65,0x73,0x80,0x89,0x8f,0x94,0x93,0x8d,0x82,0x72,0x61,0x53,0x48,0x42,
0x40,0x40,0x40,0x40,0x3c,0x3a,0x3b,0x40,0x46,0x4e,0x59,0x66,0x73,0x83,0x8e,0x97,
0x9b,0x98,0x8e,0x80,0x6f,0x5e,0x51,0x44,0x3c,0x36,0x36,0x36,0x36,0x38,0x3c,0x3f,
0x40,0x40,0x3f,0x40,0x3e,0x39,0x35,0x33,0x34,0x38,0x3a,0x39,0x36,0x32,0x30,0x32,
0x3a,0x49,0x5c,0x70,0x7b,0x7c,0x77,0x6c,0x5f,0x5a,0x5c,0x64,0x70,0x78,0x79,0x74,
0x69,0x5e,0x5a,0x5e,0x68,0x72,0x79,0x79,0x72,0x6c,0x66,0x61,0x5d,0x5b,0x58,0x54,
0x4a,0x3e,0x34,0x2e,0x2d,0x30,0x37,0x3f,0x44,0x44,0x40,0x39,0x36,0x34,0x36,0x39,
0x3a,0x3d,0x3f,0x3e,0x3d,0x3a,0x38,0x36,0x34,0x33,0x35,0x37,0x39,0x38,0x38,0x38,
0x36,0x36,0x36,0x36,0x37,0x3a,0x3b,0x3b,0x39,0x3a,0x3a,0x3b,0x39,0x38,0x39,0x3b,
// Line 12
0x3a,0x39,0x37,0x37,0x37,0x38,0x39,0x38,0x36,0x37,0x38,0x39,0x37,0x36,0x35,0x36,
0x36,0x37,0x36,0x36,0x36,0x35,0x35,0x34,0x36,0x38,0x39,0x37,0x37,0x37,0x38,0x39,
0x39,0x38,0x39,0x39,0x39,0x39,0x3b,0x3a,0x38,0x34,0x31,0x31,0x32,0x34,0x35,0x35,
0x33,0x31,0x30,0x38,0x45,0x5a,0x6d,0x79,0x7a,0x73,0x66,0x5a,0x54,0x56,0x5f,0x6d,
0x76,0x76,0x70,0x68,0x61,0x5c,0x5b,0x60,0x6b,0x73,0x78,0x76,0x71,0x69,0x63,0x60,
0x61,0x66,0x6c,0x72,0x74,0x72,0x6b,0x63,0x5c,0x5a,0x5e,0x67,0x71,0x77,0x79,0x76,
0x6f,0x65,0x5f,0x5a,0x5c,0x63,0x6a,0x6f,0x72,0x6f,0x69,0x63,0x5e,0x5c,0x60,0x68,
0x70,0x77,0x79,0x76,0x6f,0x65,0x5c,0x58,0x5c,0x63,0x6c,0x75,0x7a,0x77,0x70,0x68,
0x61,0x61,0x66,0x6c,0x70,0x71,0x70,0x70,0x73,0x79,0x84,0x91,0x9e,0xa5,0xa8,0xa3,
0x9a,0x8b,0x7b,0x6c,0x63,0x5c,0x56,0x50,0x4a,0x42,0x3b,0x38,0x3a,0x44,0x56,0x69,
0x7a,0x87,0x8f,0x95,0x98,0x9a,0x9c,0x9d,0x9d,0x9b,0x9a,0x9a,0x9a,0x9a,0x97,0x8f,
0x83,0x76,0x68,0x5c,0x54,0x4d,0x44,0x39,0x32,0x34,0x3e,0x52,0x67,0x76,0x7f,0x7b,
0x71,0x64,0x5a,0x54,0x53,0x4b,0x3f,0x36,0x32,0x37,0x45,0x5e,0x73,0x81,0x84,0x7d,
0x6f,0x5e,0x52,0x4d,0x4b,0x48,0x42,0x3b,0x34,0x2e,0x2d,0x30,0x39,0x46,0x55,0x63,
0x6e,0x74,0x75,0x71,0x6b,0x64,0x5f,0x5a,0x52,0x45,0x3e,0x36,0x37,0x41,0x53,0x68,
0x7b,0x8a,0x91,0x95,0x98,0x97,0x8f,0x84,0x70,0x5d,0x55,0x55,0x5e,0x6c,0x77,0x79,
0x73,0x69,0x61,0x5e,0x5d,0x59,0x4f,0x3f,0x2f,0x26,0x2f,0x47,0x65,0x7f,0x8b,0x87,
0x7a,0x69,0x5e,0x59,0x56,0x4f,0x43,0x36,0x2c,0x31,0x44,0x5f,0x76,0x83,0x82,0x76,
0x66,0x57,0x4f,0x4d,0x4c,0x47,0x3e,0x33,0x2c,0x2c,0x32,0x3b,0x41,0x43,0x3f,0x38,
0x31,0x30,0x36,0x45,0x56,0x67,0x78,0x84,0x8a,0x92,0x97,0x9e,0xa2,0xa7,0xa4,0x9e,
0x93,0x86,0x73,0x67,0x5b,0x53,0x4e,0x48,0x41,0x3c,0x37,0x34,0x32,0x33,0x34,0x37,
0x38,0x37,0x37,0x36,0x34,0x33,0x34,0x37,0x3a,0x3d,0x3d,0x3b,0x36,0x32,0x32,0x3d,
0x4c,0x60,0x73,0x7d,0x7b,0x73,0x69,0x61,0x5e,0x60,0x66,0x6c,0x74,0x79,0x7c,0x87,
0x91,0x98,0x99,0x91,0x81,0x6c,0x57,0x46,0x3c,0x37,0x38,0x38,0x37,0x38,0x3b,0x41,
0x44,0x44,0x42,0x3d,0x37,0x33,0x34,0x3d,0x4a,0x59,0x65,0x72,0x7e,0x89,0x91,0x94,
0x92,0x8b,0x81,0x71,0x60,0x53,0x49,0x42,0x3f,0x3c,0x3b,0x3a,0x37,0x34,0x37,0x3c,
0x43,0x4e,0x5a,0x67,0x73,0x81,0x8f,0x97,0x9d,0x9d,0x93,0x85,0x74,0x65,0x5c,0x5a,
0x5b,0x62,0x6c,0x7a,0x81,0x8e,0x94,0x99,0x97,0x8e,0x7e,0x6b,0x59,0x4c,0x46,0x43,
0x3f,0x3d,0x3b,0x38,0x36,0x36,0x3b,0x3e,0x3e,0x3a,0x33,0x2f,0x32,0x3d,0x4f,0x65,
0x78,0x82,0x81,0x79,0x6c,0x60,0x5a,0x5c,0x60,0x67,0x6b,0x73,0x78,0x80,0x8c,0x96,
0x9a,0x97,0x88,0x74,0x60,0x4c,0x3e,0x39,0x39,0x38,0x37,0x37,0x38,0x38,0x39,0x3a,
0x3c,0x3e,0x3d,0x3b,0x3a,0x39,0x39,0x3d,0x3f,0x40,0x41,0x3e,0x3c,0x3b,0x3d,0x42,
0x4c,0x5a,0x6b,0x7b,0x89,0x93,0x97,0x98,0x93,0x8d,0x84,0x74,0x62,0x53,0x46,0x3e,
0x38,0x36,0x37,0x37,0x37,0x36,0x37,0x3d,0x3f,0x3e,0x3c,0x37,0x34,0x35,0x38,0x3c,
0x3f,0x40,0x3d,0x38,0x35,0x34,0x35,0x40,0x49,0x55,0x65,0x75,0x84,0x91,0x9a,0x9c,
0x9a,0x90,0x83,0x73,0x64,0x54,0x47,0x3f,0x39,0x34,0x31,0x30,0x32,0x36,0x38,0x39,
0x39,0x39,0x39,0x39,0x37,0x37,0x3a,0x3e,0x3e,0x3d,0x3c,0x39,0x35,0x31,0x32,0x3b,
0x49,0x58,0x65,0x72,0x80,0x8c,0x97,0x9a,0x99,0x92,0x86,0x76,0x64,0x53,0x46,0x3f,
0x3b,0x37,0x32,0x31,0x30,0x31,0x34,0x35,0x35,0x37,0x37,0x36,0x33,0x32,0x32,0x37,
0x3d,0x3f,0x3e,0x39,0x34,0x31,0x34,0x3c,0x47,0x54,0x64,0x75,0x84,0x8e,0x95,0x98,
0x99,0x91,0x83,0x73,0x64,0x55,0x47,0x3c,0x32,0x30,0x31,0x34,0x35,0x33,0x32,0x35,
0x36,0x37,0x39,0x39,0x39,0x39,0x3a,0x3b,0x3d,0x3d,0x3d,0x3a,0x37,0x34,0x34,0x39,
0x44,0x53,0x64,0x73,0x80,0x8e,0x97,0x9a,0x97,0x8e,0x81,0x71,0x5f,0x4d,0x40,0x3a,
0x38,0x35,0x34,0x31,0x31,0x35,0x38,0x3a,0x38,0x39,0x36,0x34,0x31,0x30,0x32,0x39,
0x3c,0x3b,0x3b,0x38,0x34,0x34,0x35,0x3c,0x49,0x59,0x66,0x75,0x83,0x8f,0x97,0x98,
0x93,0x8b,0x7e,0x6d,0x5d,0x4f,0x44,0x3b,0x37,0x32,0x30,0x32,0x34,0x35,0x36,0x36,
0x36,0x36,0x34,0x34,0x33,0x32,0x32,0x33,0x36,0x38,0x36,0x34,0x30,0x2e,0x32,0x39,
0x44,0x54,0x65,0x76,0x84,0x8e,0x95,0x98,0x97,0x8e,0x80,0x6f,0x5f,0x50,0x44,0x3a,
0x34,0x32,0x33,0x32,0x32,0x33,0x34,0x36,0x36,0x37,0x37,0x36,0x34,0x34,0x35,0x38,
0x39,0x39,0x37,0x35,0x34,0x32,0x33,0x39,0x44,0x53,0x65,0x76,0x84,0x8f,0x98,0x9a,
0x94,0x8b,0x80,0x71,0x60,0x4d,0x3f,0x38,0x33,0x30,0x2e,0x2d,0x2f,0x34,0x37,0x39,
0x39,0x38,0x37,0x34,0x31,0x31,0x32,0x39,0x38,0x37,0x36,0x34,0x31,0x2f,0x32,0x39,
0x44,0x53,0x63,0x70,0x81,0x8c,0x94,0x97,0x94,0x8b,0x82,0x71,0x5e,0x50,0x44,0x3c,
0x35,0x30,0x2d,0x2f,0x30,0x31,0x33,0x35,0x36,0x35,0x34,0x33,0x32,0x33,0x35,0x37,
0x3b,0x3d,0x3b,0x36,0x32,0x31,0x36,0x3e,0x48,0x56,0x65,0x74,0x81,0x8d,0x95,0x9a,
0x9b,0x93,0x81,0x6f,0x5e,0x4e,0x41,0x39,0x34,0x34,0x33,0x33,0x31,0x34,0x36,0x36,
0x37,0x37,0x35,0x33,0x2e,0x2c,0x2f,0x35,0x3a,0x3c,0x3b,0x38,0x36,0x35,0x36,0x3d,
0x49,0x57,0x66,0x75,0x83,0x8e,0x98,0x9c,0x99,0x90,0x82,0x72,0x60,0x50,0x44,0x3d,
0x38,0x34,0x32,0x34,0x35,0x36,0x3a,0x3e,0x3e,0x3c,0x36,0x32,0x32,0x32,0x35,0x37,
0x39,0x37,0x37,0x35,0x34,0x33,0x3b,0x42,0x4a,0x56,0x65,0x75,0x87,0x93,0x99,0x9c,
0x99,0x91,0x83,0x71,0x5f,0x50,0x46,0x3e,0x39,0x37,0x35,0x36,0x37,0x37,0x37,0x3a,
0x3b,0x39,0x38,0x36,0x33,0x31,0x32,0x36,0x3b,0x3d,0x3b,0x37,0x33,0x32,0x35,0x3d,
0x49,0x58,0x68,0x76,0x82,0x8c,0x94,0x98,0x95,0x8b,0x7c,0x6c,0x5b,0x4b,0x3e,0x39,
0x36,0x34,0x34,0x35,0x36,0x39,0x3a,0x3b,0x3c,0x3d,0x3a,0x36,0x32,0x30,0x34,0x39,
0x3b,0x3a,0x39,0x36,0x35,0x35,0x38,0x40,0x4c,0x5a,0x66,0x74,0x82,0x8f,0x95,0x99,
0x95,0x8d,0x80,0x70,0x5e,0x4f,0x44,0x3b,0x35,0x32,0x32,0x35,0x34,0x35,0x38,0x3c,
0x3e,0x3e,0x3c,0x38,0x34,0x32,0x34,0x37,0x39,0x39,0x39,0x37,0x33,0x31,0x36,0x3e,
0x4a,0x58,0x68,0x76,0x80,0x8c,0x93,0x99,0x97,0x8f,0x7e,0x70,0x60,0x52,0x45,0x3c,
0x37,0x35,0x34,0x32,0x33,0x35,0x39,0x3a,0x39,0x35,0x34,0x33,0x31,0x2f,0x2f,0x32,
0x35,0x38,0x37,0x35,0x34,0x34,0x38,0x41,0x4b,0x59,0x68,0x76,0x82,0x8d,0x95,0x98,
0x94,0x8b,0x80,0x72,0x61,0x51,0x43,0x3c,0x36,0x34,0x36,0x39,0x3a,0x39,0x35,0x35,
0x3e,0x4d,0x5d,0x6b,0x72,0x72,0x6c,0x65,0x5d,0x56,0x54,0x4e,0x47,0x40,0x38,0x31,
0x2f,0x2f,0x32,0x3d,0x49,0x56,0x60,0x6d,0x73,0x71,0x6c,0x63,0x57,0x53,0x4e,0x46,
0x40,0x38,0x31,0x2b,0x27,0x27,0x2e,0x38,0x43,0x4d,0x56,0x5e,0x68,0x73,0x7e,0x8a,
0x93,0x9a,0xa0,0xa4,0xa3,0xa0,0x9c,0x99,0x95,0x96,0x97,0x9b,0x9e,0x9f,0x9c,0x97,
0x8f,0x82,0x72,0x64,0x56,0x4a,0x44,0x40,0x3e,0x3c,0x37,0x2f,0x2d,0x2f,0x37,0x3c,
0x3e,0x3c,0x36,0x30,0x2d,0x34,0x46,0x5d,0x71,0x7d,0x7e,0x75,0x68,0x5f,0x5b,0x60,
0x68,0x6f,0x72,0x76,0x78,0x7e,0x87,0x91,0x96,0x93,0x85,0x71,0x5b,0x48,0x3d,0x39,
0x37,0x39,0x3b,0x3b,0x3a,0x39,0x37,0x39,0x3e,0x46,0x50,0x5e,0x6c,0x79,0x84,0x8e,
0x94,0x9a,0x9f,0xa4,0xa5,0xa3,0x9b,0x8c,0x7a,0x68,0x5c,0x57,0x5c,0x65,0x6f,0x79,
0x79,0x72,0x69,0x5f,0x59,0x57,0x53,0x4c,0x43,0x37,0x2b,0x21,0x22,0x27,0x32,0x3f,
0x44,0x40,0x38,0x2f,0x2c,0x35,0x46,0x5d,0x71,0x7c,0x7b,0x73,0x67,0x5e,0x5a,0x5e,
0x65,0x6d,0x74,0x79,0x7e,0x86,0x8f,0x98,0x9c,0x95,0x88,0x76,0x60,0x4c,0x40,0x3a,
0x38,0x34,0x36,0x36,0x39,0x3b,0x3c,0x3a,0x39,0x37,0x34,0x33,0x32,0x36,0x3a,0x3c,
0x3b,0x38,0x35,0x36,0x37,0x39,0x3b,0x3b,0x39,0x32,0x2f,0x32,0x3d,0x4f,0x63,0x72,
0x7b,0x7a,0x72,0x67,0x5e,0x5a,0x57,0x50,0x45,0x39,0x31,0x34,0x41,0x56,0x6d,0x7d,
0x7e,0x76,0x65,0x57,0x52,0x54,0x5b,0x65,0x6e,0x76,0x7c,0x84,0x8f,0x98,0x9b,0x93,
0x81,0x6c,0x5a,0x4e,0x46,0x3f,0x39,0x37,0x38,0x3d,0x4c,0x62,0x77,0x82,0x82,0x75,
0x61,0x54,0x50,0x56,0x63,0x6f,0x76,0x74,0x6c,0x61,0x5c,0x5e,0x60,0x61,0x5a,0x4b,
0x37,0x30,0x32,0x42,0x5e,0x79,0x89,0x8b,0x7f,0x6c,0x5f,0x57,0x59,0x5f,0x68,0x6e,
0x73,0x7a,0x85,0x92,0x99,0x9a,0x92,0x86,0x73,0x5f,0x4f,0x44,0x3c,0x37,0x33,0x34,
0x3d,0x4b,0x5c,0x6d,0x7c,0x87,0x8c,0x94,0x95,0x94,0x91,0x84,0x70,0x5e,0x53,0x53,
0x5c,0x68,0x75,0x7c,0x79,0x6d,0x61,0x59,0x53,0x4f,0x47,0x3d,0x32,0x2b,0x27,0x2a,
0x31,0x38,0x3d,0x3e,0x3b,0x36,0x34,0x32,0x2f,0x2e,0x2e,0x31,0x36,0x39,0x3a,0x3c,
0x3d,0x3c,0x3a,0x38,0x38,0x39,0x3b,0x3a,0x36,0x34,0x33,0x33,0x35,0x36,0x38,0x3a,
0x3b,0x3b,0x3b,0x3b,0x3a,0x36,0x35,0x34,0x33,0x34,0x35,0x35,0x36,0x35,0x34,0x34,
// Line 13
0x3b,0x3b,0x3b,0x3b,0x39,0x37,0x36,0x37,0x3a,0x3c,0x3c,0x3a,0x39,0x39,0x3b,0x3b,
0x3c,0x3b,0x3b,0x3b,0x39,0x37,0x36,0x36,0x36,0x37,0x36,0x36,0x37,0x39,0x39,0x37,
0x36,0x35,0x35,0x35,0x33,0x34,0x38,0x39,0x3a,0x3a,0x39,0x38,0x37,0x37,0x39,0x39,
0x3e,0x3c,0x39,0x39,0x39,0x37,0x38,0x39,0x3b,0x3c,0x39,0x36,0x32,0x32,0x32,0x36,
0x38,0x39,0x39,0x38,0x35,0x32,0x34,0x37,0x39,0x38,0x36,0x35,0x36,0x37,0x37,0x38,
0x39,0x38,0x37,0x36,0x37,0x38,0x39,0x39,0x3a,0x3b,0x3b,0x3b,0x3b,0x3b,0x39,0x39,
0x39,0x39,0x38,0x37,0x35,0x35,0x37,0x39,0x37,0x39,0x37,0x36,0x36,0x35,0x35,0x36,
0x38,0x39,0x3b,0x3b,0x39,0x38,0x3b,0x3b,0x39,0x37,0x37,0x37,0x38,0x38,0x38,0x39,
0x3c,0x3c,0x3b,0x39,0x38,0x39,0x39,0x3a,0x36,0x37,0x36,0x36,0x38,0x39,0x37,0x38,
0x37,0x36,0x36,0x37,0x37,0x37,0x38,0x39,0x39,0x39,0x3a,0x3a,0x39,0x38,0x37,0x37,
0x36,0x36,0x37,0x37,0x36,0x36,0x36,0x38,0x39,0x36,0x36,0x38,0x39,0x39,0x38,0x39,
0x39,0x39,0x3a,0x3b,0x3c,0x3c,0x3c,0x3a,0x3b,0x3a,0x39,0x37,0x35,0x33,0x34,0x36,
0x37,0x36,0x38,0x38,0x37,0x37,0x38,0x39,0x39,0x38,0x36,0x37,0x37,0x37,0x37,0x37,
0x37,0x3a,0x3c,0x3c,0x3c,0x3c,0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,0x3b,0x38,0x36,0x35,
0x35,0x35,0x36,0x36,0x37,0x37,0x36,0x35,0x37,0x37,0x37,0x39,0x39,0x38,0x37,0x36,
0x36,0x38,0x38,0x38,0x39,0x36,0x34,0x36,0x38,0x3a,0x3b,0x3b,0x3b,0x3a,0x3a,0x3a,
0x3a,0x3b,0x3c,0x39,0x39,0x39,0x39,0x39,0x39,0x38,0x39,0x3a,0x39,0x36,0x38,0x39,
0x38,0x38,0x39,0x3b,0x3d,0x3e,0x3c,0x3c,0x3b,0x3c,0x3d,0x3b,0x39,0x38,0x3a,0x3a,
0x38,0x36,0x37,0x39,0x3b,0x3b,0x39,0x39,0x39,0x39,0x38,0x36,0x37,0x38,0x37,0x35,
0x36,0x36,0x37,0x38,0x39,0x38,0x39,0x3a,0x3a,0x3a,0x3b,0x39,0x38,0x38,0x38,0x39,
0x39,0x38,0x37,0x39,0x3a,0x3b,0x3b,0x3d,0x3c,0x3c,0x3c,0x3a,0x38,0x38,0x39,0x39,
0x39,0x38,0x38,0x39,0x39,0x38,0x39,0x3b,0x3b,0x3b,0x3b,0x3b,0x3c,0x3c,0x3b,0x3d,
0x3f,0x3f,0x3d,0x3b,0x3b,0x3b,0x3a,0x38,0x37,0x38,0x39,0x3b,0x3b,0x39,0x37,0x37,
0x39,0x39,0x39,0x3a,0x3b,0x3a,0x39,0x38,0x37,0x39,0x3a,0x3a,0x3c,0x3b,0x39,0x37,
0x37,0x37,0x39,0x3b,0x3c,0x3d,0x3e,0x3d,0x3a,0x39,0x39,0x3b,0x3b,0x3a,0x38,0x37,
0x37,0x37,0x38,0x38,0x39,0x3a,0x3b,0x3b,0x39,0x38,0x39,0x39,0x3b,0x3b,0x39,0x39,
0x39,0x38,0x38,0x39,0x3a,0x39,0x39,0x37,0x37,0x38,0x3a,0x3b,0x3b,0x39,0x38,0x39,
0x39,0x3a,0x3b,0x3a,0x39,0x39,0x39,0x3a,0x3a,0x39,0x39,0x39,0x3b,0x3a,0x39,0x3a,
0x3b,0x3b,0x3b,0x39,0x39,0x3a,0x3a,0x39,0x37,0x35,0x36,0x38,0x38,0x36,0x35,0x36,
0x37,0x36,0x39,0x38,0x39,0x3b,0x3b,0x39,0x39,0x39,0x38,0x3b,0x3b,0x3a,0x39,0x39,
0x39,0x38,0x37,0x36,0x37,0x39,0x39,0x38,0x39,0x3b,0x3b,0x39,0x38,0x36,0x36,0x37,
0x37,0x36,0x36,0x37,0x39,0x3a,0x3b,0x3a,0x3b,0x3b,0x3b,0x38,0x36,0x35,0x36,0x36,
0x34,0x36,0x39,0x3c,0x3d,0x39,0x36,0x36,0x37,0x38,0x36,0x37,0x36,0x34,0x35,0x36,
0x36,0x39,0x39,0x39,0x39,0x39,0x38,0x37,0x36,0x35,0x36,0x39,0x39,0x39,0x3a,0x3a,
0x39,0x39,0x37,0x38,0x39,0x3b,0x3b,0x3b,0x3b,0x3c,0x3b,0x39,0x36,0x35,0x36,0x38,
0x39,0x38,0x37,0x35,0x36,0x35,0x36,0x3a,0x3b,0x3a,0x39,0x37,0x36,0x36,0x37,0x38,
0x39,0x3a,0x3a,0x3a,0x3b,0x3a,0x3b,0x3c,0x3c,0x3a,0x39,0x37,0x34,0x34,0x34,0x36,
0x36,0x35,0x33,0x34,0x37,0x38,0x36,0x35,0x36,0x36,0x36,0x35,0x36,0x39,0x3b,0x3d,
0x3e,0x3c,0x3c,0x3c,0x3a,0x37,0x36,0x36,0x36,0x35,0x37,0x34,0x32,0x35,0x39,0x3b,
0x3b,0x39,0x38,0x38,0x39,0x39,0x38,0x39,0x39,0x38,0x39,0x39,0x38,0x37,0x37,0x37,
0x37,0x36,0x35,0x37,0x38,0x38,0x37,0x37,0x3a,0x3b,0x3b,0x39,0x38,0x39,0x3b,0x3a,
0x39,0x39,0x3a,0x3b,0x39,0x38,0x38,0x37,0x36,0x35,0x34,0x35,0x34,0x33,0x34,0x36,
0x38,0x38,0x38,0x39,0x39,0x38,0x39,0x39,0x39,0x39,0x3a,0x39,0x39,0x39,0x3a,0x3b,
0x3b,0x39,0x39,0x39,0x39,0x37,0x36,0x37,0x39,0x3b,0x3b,0x39,0x39,0x39,0x3a,0x3b,
0x3c,0x3d,0x3d,0x3c,0x39,0x38,0x39,0x3b,0x3b,0x3a,0x3a,0x39,0x3a,0x38,0x37,0x38,
0x39,0x39,0x39,0x3a,0x3b,0x39,0x39,0x37,0x35,0x37,0x39,0x39,0x39,0x37,0x36,0x37,
0x36,0x37,0x3a,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x39,0x3a,0x3b,0x3a,0x39,0x38,
0x38,0x39,0x3a,0x3a,0x3a,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x38,0x3a,0x38,0x35,0x36,
0x36,0x34,0x36,0x34,0x33,0x33,0x33,0x34,0x35,0x35,0x36,0x37,0x37,0x38,0x39,0x3a,
0x39,0x38,0x39,0x39,0x37,0x37,0x34,0x34,0x36,0x37,0x37,0x37,0x39,0x39,0x39,0x39,
0x3a,0x3b,0x39,0x37,0x35,0x36,0x36,0x36,0x36,0x35,0x35,0x37,0x38,0x37,0x35,0x36,
0x36,0x38,0x39,0x39,0x3b,0x3c,0x3a,0x38,0x37,0x37,0x38,0x38,0x37,0x35,0x36,0x36,
0x35,0x34,0x36,0x36,0x37,0x35,0x37,0x38,0x39,0x35,0x32,0x32,0x33,0x33,0x33,0x34,
0x34,0x36,0x34,0x32,0x32,0x33,0x35,0x39,0x3a,0x3b,0x39,0x3b,0x39,0x38,0x3b,0x3d,
0x3e,0x3e,0x3b,0x39,0x3b,0x3b,0x3a,0x3a,0x3c,0x3c,0x3b,0x39,0x39,0x39,0x39,0x39,
0x38,0x38,0x39,0x39,0x39,0x38,0x37,0x38,0x38,0x38,0x38,0x37,0x36,0x37,0x36,0x37,
0x39,0x3a,0x39,0x38,0x39,0x3a,0x39,0x39,0x39,0x38,0x37,0x37,0x37,0x36,0x36,0x36,
0x38,0x37,0x35,0x34,0x37,0x37,0x37,0x39,0x39,0x39,0x39,0x39,0x38,0x38,0x39,0x38,
0x37,0x36,0x36,0x36,0x34,0x35,0x36,0x38,0x37,0x36,0x37,0x38,0x36,0x36,0x34,0x33,
0x35,0x35,0x35,0x34,0x33,0x33,0x35,0x37,0x39,0x39,0x3b,0x3b,0x39,0x39,0x39,0x39,
0x37,0x36,0x36,0x39,0x3a,0x39,0x39,0x3a,0x39,0x3a,0x3a,0x3b,0x3b,0x39,0x38,0x36,
0x36,0x36,0x38,0x3a,0x3a,0x39,0x3b,0x3a,0x39,0x39,0x3a,0x39,0x38,0x36,0x34,0x31,
0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x36,0x34,0x36,0x38,0x38,0x38,0x37,0x37,0x39,
0x39,0x39,0x39,0x39,0x38,0x38,0x39,0x3a,0x39,0x37,0x36,0x35,0x36,0x37,0x37,0x38,
0x39,0x38,0x37,0x35,0x35,0x36,0x37,0x38,0x39,0x39,0x39,0x39,0x39,0x3c,0x3c,0x3d,
0x3c,0x39,0x39,0x37,0x36,0x38,0x39,0x38,0x36,0x38,0x37,0x36,0x37,0x39,0x3b,0x3b,
0x39,0x37,0x37,0x36,0x37,0x38,0x39,0x39,0x39,0x38,0x39,0x38,0x37,0x36,0x35,0x36,
0x37,0x36,0x36,0x35,0x34,0x36,0x37,0x38,0x39,0x39,0x3a,0x3b,0x39,0x35,0x30,0x33,
0x35,0x37,0x38,0x39,0x38,0x3b,0x39,0x39,0x3a,0x3d,0x3e,0x3f,0x3d,0x3b,0x3b,0x3b,
0x3a,0x39,0x39,0x39,0x39,0x39,0x37,0x36,0x35,0x34,0x36,0x39,0x3c,0x3d,0x3d,0x3a,
0x38,0x38,0x38,0x39,0x39,0x39,0x37,0x35,0x33,0x34,0x35,0x37,0x38,0x37,0x39,0x3b,
0x39,0x39,0x37,0x38,0x39,0x38,0x37,0x38,0x39,0x38,0x38,0x37,0x37,0x38,0x39,0x38,
0x38,0x39,0x39,0x39,0x3a,0x39,0x39,0x3b,0x3b,0x3b,0x3b,0x3a,0x39,0x37,0x35,0x35,
0x35,0x35,0x36,0x36,0x38,0x38,0x39,0x3a,0x38,0x39,0x3a,0x3b,0x3a,0x38,0x38,0x36,
0x36,0x35,0x36,0x38,0x39,0x39,0x36,0x37,0x37,0x37,0x38,0x38,0x39,0x3b,0x3b,0x39,
0x37,0x37,0x38,0x39,0x39,0x39,0x38,0x38,0x38,0x37,0x38,0x39,0x39,0x39,0x39,0x38,
0x3a,0x3a,0x39,0x35,0x36,0x35,0x37,0x39,0x3b,0x39,0x3b,0x38,0x35,0x32,0x33,0x36,
0x38,0x37,0x35,0x35,0x35,0x36,0x36,0x37,0x38,0x39,0x38,0x37,0x37,0x37,0x36,0x35,
0x37,0x38,0x39,0x39,0x39,0x36,0x37,0x37,0x36,0x35,0x36,0x37,0x37,0x36,0x36,0x34,
0x37,0x39,0x39,0x3b,0x3b,0x3a,0x39,0x39,0x38,0x38,0x39,0x38,0x36,0x37,0x37,0x37,
0x37,0x36,0x36,0x36,0x35,0x34,0x36,0x37,0x39,0x39,0x39,0x39,0x3b,0x3b,0x39,0x37,
0x36,0x36,0x36,0x35,0x35,0x36,0x36,0x36,0x36,0x37,0x37,0x37,0x38,0x36,0x33,0x34,
0x36,0x37,0x36,0x36,0x35,0x35,0x34,0x34,0x35,0x37,0x37,0x36,0x36,0x36,0x36,0x37,
0x37,0x37,0x38,0x39,0x38,0x35,0x34,0x34,0x35,0x36,0x38,0x39,0x39,0x39,0x36,0x36,
0x35,0x36,0x39,0x39,0x38,0x37,0x36,0x34,0x33,0x35,0x38,0x3a,0x3b,0x38,0x36,0x36,
0x36,0x36,0x39,0x3b,0x3a,0x39,0x37,0x36,0x37,0x37,0x37,0x36,0x37,0x36,0x36,0x36,
0x35,0x32,0x35,0x34,0x34,0x36,0x37,0x38,0x38,0x36,0x35,0x36,0x38,0x39,0x39,0x38,
0x37,0x37,0x37,0x38,0x39,0x39,0x38,0x37,0x37,0x37,0x37,0x37,0x36,0x33,0x34,0x34,
0x35,0x36,0x36,0x37,0x39,0x38,0x37,0x37,0x38,0x39,0x39,0x38,0x37,0x37,0x37,0x37,
0x34,0x36,0x37,0x38,0x39,0x39,0x38,0x39,0x3a,0x3a,0x39,0x3a,0x3b,0x3a,0x39,0x36,
0x34,0x35,0x36,0x36,0x38,0x39,0x38,0x37,0x36,0x36,0x39,0x39,0x39,0x39,0x38,0x37,
0x35,0x34,0x35,0x38,0x3a,0x35,0x32,0x35,0x37,0x39,0x39,0x39,0x39,0x39,0x39,0x38,
0x37,0x37,0x37,0x35,0x34,0x34,0x35,0x37,0x37,0x36,0x36,0x36,0x36,0x35,0x35,0x36,
0x38,0x39,0x39,0x38,0x37,0x37,0x37,0x38,0x37,0x38,0x3a,0x3b,0x39,0x39,0x39,0x3a,
0x3a,0x38,0x35,0x34,0x36,0x35,0x32,0x33,0x33,0x33,0x34,0x33,0x33,0x36,0x36,0x36,
0x35,0x34,0x33,0x35,0x34,0x35,0x37,0x38,0x38,0x37,0x37,0x37,0x37,0x38,0x38,0x38,
// Line 14
0x3b,0x3b,0x3b,0x3b,0x3b,0x3a,0x3a,0x3b,0x3a,0x38,0x37,0x39,0x3a,0x38,0x36,0x36,
0x36,0x37,0x35,0x33,0x34,0x35,0x38,0x39,0x39,0x39,0x39,0x39,0x38,0x36,0x36,0x35,
0x36,0x35,0x33,0x33,0x36,0x38,0x3a,0x3a,0x39,0x38,0x3a,0x3a,0x3a,0x3b,0x3b,0x3b,
0x3b,0x3e,0x43,0x48,0x51,0x5a,0x64,0x6d,0x75,0x7c,0x85,0x8b,0x91,0x95,0x96,0x96,
0x96,0x96,0x95,0x94,0x96,0x96,0x97,0x96,0x94,0x92,0x93,0x93,0x91,0x8b,0x84,0x7b,
0x74,0x6a,0x61,0x5a,0x53,0x4b,0x42,0x3d,0x3a,0x38,0x39,0x37,0x37,0x39,0x38,0x37,
0x38,0x37,0x37,0x39,0x39,0x39,0x3a,0x3b,0x3c,0x3f,0x44,0x4b,0x51,0x59,0x62,0x6b,
0x75,0x7e,0x85,0x8c,0x90,0x93,0x97,0x98,0x9b,0x9b,0x9a,0x98,0x97,0x95,0x95,0x95,
0x95,0x94,0x91,0x91,0x8e,0x89,0x85,0x7f,0x79,0x73,0x6a,0x61,0x57,0x50,0x4a,0x45,
0x41,0x41,0x3f,0x3d,0x3b,0x39,0x3c,0x3d,0x3c,0x3b,0x3b,0x3b,0x3b,0x38,0x38,0x3b,
0x3d,0x3d,0x3f,0x43,0x49,0x50,0x58,0x5f,0x69,0x74,0x7e,0x86,0x8c,0x8f,0x93,0x97,
0x98,0x97,0x96,0x98,0x96,0x95,0x96,0x98,0x97,0x9a,0x98,0x95,0x94,0x90,0x8b,0x85,
0x7d,0x74,0x6c,0x62,0x5a,0x53,0x4d,0x46,0x42,0x3f,0x3f,0x40,0x40,0x3f,0x3d,0x3c,
0x3b,0x38,0x37,0x37,0x38,0x3b,0x3a,0x3a,0x3b,0x3c,0x3d,0x40,0x45,0x4b,0x51,0x59,
0x60,0x6a,0x75,0x80,0x88,0x8d,0x92,0x96,0x9a,0x9b,0x9a,0x99,0x96,0x94,0x94,0x94,
0x95,0x96,0x98,0x96,0x93,0x90,0x8e,0x8a,0x86,0x7f,0x78,0x70,0x68,0x5e,0x57,0x4f,
0x48,0x42,0x40,0x3f,0x3d,0x3c,0x38,0x37,0x39,0x38,0x37,0x37,0x36,0x35,0x35,0x35,
0x36,0x38,0x3b,0x3c,0x40,0x44,0x4b,0x50,0x5d,0x65,0x6d,0x76,0x7f,0x85,0x8b,0x90,
0x93,0x97,0x97,0x96,0x95,0x95,0x96,0x98,0x99,0x98,0x97,0x98,0x97,0x95,0x94,0x90,
0x8b,0x85,0x7d,0x73,0x6b,0x63,0x5b,0x53,0x4c,0x46,0x42,0x40,0x40,0x3f,0x3f,0x3d,
0x3c,0x3c,0x3c,0x3b,0x3a,0x38,0x37,0x36,0x36,0x36,0x37,0x3a,0x3b,0x3f,0x45,0x4d,
0x52,0x5f,0x68,0x70,0x7a,0x83,0x89,0x93,0x94,0x96,0x98,0x99,0x97,0x96,0x96,0x98,
0x9a,0x99,0x99,0x9b,0x9c,0x9b,0x99,0x97,0x95,0x91,0x89,0x7f,0x74,0x6b,0x61,0x59,
0x53,0x4d,0x46,0x41,0x3d,0x3b,0x3b,0x3d,0x3d,0x3d,0x3e,0x3d,0x3a,0x3a,0x38,0x38,
0x3a,0x39,0x37,0x37,0x3a,0x3b,0x3f,0x46,0x4f,0x58,0x60,0x67,0x70,0x7c,0x87,0x8e,
0x91,0x94,0x97,0x9a,0x9c,0x9c,0x9b,0x99,0x96,0x96,0x98,0x98,0x99,0x9a,0x9a,0x98,
0x96,0x94,0x91,0x8c,0x84,0x77,0x6c,0x62,0x5a,0x52,0x4e,0x49,0x44,0x40,0x3d,0x3e,
0x40,0x40,0x3e,0x3f,0x40,0x3e,0x3d,0x3c,0x3b,0x3c,0x3b,0x38,0x37,0x37,0x39,0x3d,
0x3e,0x3d,0x3d,0x3f,0x40,0x3f,0x40,0x40,0x40,0x3f,0x3d,0x3a,0x39,0x38,0x3a,0x3b,
0x3a,0x38,0x39,0x3a,0x3a,0x39,0x39,0x39,0x3a,0x3c,0x3d,0x3c,0x3b,0x3b,0x3c,0x3e,
0x3e,0x3d,0x3c,0x3c,0x3b,0x3b,0x3b,0x3b,0x3c,0x3f,0x3d,0x3b,0x3c,0x3d,0x3e,0x41,
0x3f,0x3c,0x3b,0x39,0x37,0x37,0x39,0x3b,0x3c,0x3c,0x3c,0x3b,0x3b,0x3b,0x3b,0x3c,
0x3d,0x3d,0x3b,0x3a,0x3a,0x3b,0x3b,0x3a,0x39,0x37,0x37,0x3a,0x3b,0x3b,0x3a,0x39,
0x38,0x38,0x39,0x3b,0x3f,0x45,0x49,0x4d,0x55,0x5e,0x68,0x74,0x7e,0x85,0x8b,0x8e,
0x90,0x90,0x95,0x96,0x96,0x96,0x96,0x96,0x97,0x96,0x96,0x99,0x9b,0x9a,0x98,0x96,
0x93,0x94,0x95,0x95,0x95,0x95,0x95,0x96,0x96,0x96,0x98,0x98,0x98,0x97,0x96,0x93,
0x93,0x94,0x96,0x98,0x9a,0x9a,0x98,0x97,0x9a,0x9b,0x9b,0x9b,0x9a,0x99,0x98,0x96,
0x94,0x96,0x98,0x9a,0x98,0x95,0x93,0x95,0x97,0x98,0x98,0x9a,0x9b,0x9b,0x9a,0x97,
0x95,0x97,0x98,0x97,0x97,0x97,0x97,0x99,0x9a,0x98,0x98,0x98,0x9b,0x9c,0x9b,0x99,
0x98,0x97,0x96,0x98,0x98,0x97,0x97,0x98,0x98,0x96,0x95,0x95,0x95,0x98,0x98,0x96,
0x95,0x95,0x97,0x98,0x95,0x90,0x8a,0x84,0x7b,0x70,0x68,0x5f,0x57,0x4f,0x46,0x3c,
0x3b,0x3b,0x3b,0x3b,0x3c,0x3b,0x3b,0x3a,0x3a,0x3a,0x3c,0x3d,0x3b,0x3a,0x38,0x39,
0x3a,0x3a,0x3b,0x3d,0x3d,0x3b,0x3a,0x3b,0x3b,0x3b,0x3c,0x3d,0x3e,0x3e,0x3b,0x39,
0x39,0x3a,0x3b,0x3c,0x3b,0x3b,0x3b,0x3b,0x39,0x34,0x35,0x36,0x38,0x39,0x3a,0x38,
0x3b,0x3a,0x3a,0x3b,0x3c,0x3d,0x3d,0x3b,0x3a,0x39,0x39,0x38,0x35,0x37,0x37,0x37,
0x36,0x36,0x38,0x39,0x39,0x39,0x3a,0x3b,0x3b,0x3c,0x3c,0x3b,0x3c,0x3d,0x3d,0x3b,
0x37,0x36,0x38,0x3a,0x3a,0x38,0x3b,0x39,0x37,0x37,0x39,0x3c,0x3e,0x3e,0x3b,0x3b,
0x3a,0x3a,0x3a,0x3c,0x3d,0x3c,0x3a,0x36,0x34,0x34,0x33,0x32,0x35,0x37,0x39,0x3a,
0x38,0x37,0x38,0x3a,0x3c,0x3c,0x3b,0x39,0x38,0x36,0x33,0x31,0x32,0x34,0x36,0x39,
0x39,0x39,0x3b,0x3a,0x38,0x39,0x3a,0x3b,0x39,0x38,0x38,0x38,0x38,0x37,0x38,0x3b,
0x3d,0x3c,0x3d,0x3c,0x3d,0x3d,0x3c,0x3a,0x3a,0x3b,0x3b,0x3b,0x39,0x38,0x38,0x3b,
0x3a,0x38,0x36,0x35,0x36,0x38,0x39,0x3b,0x3b,0x3a,0x3b,0x3a,0x3b,0x3b,0x3b,0x3c,
0x3a,0x38,0x37,0x37,0x38,0x3a,0x3b,0x3c,0x3c,0x3c,0x3d,0x3d,0x3d,0x3b,0x3b,0x3b,
0x3b,0x38,0x38,0x38,0x38,0x39,0x39,0x39,0x39,0x39,0x38,0x3a,0x3a,0x3b,0x3c,0x3a,
0x38,0x37,0x38,0x3a,0x3c,0x3d,0x3d,0x3c,0x3b,0x38,0x37,0x39,0x3b,0x3a,0x3a,0x38,
0x37,0x37,0x36,0x37,0x38,0x3a,0x3b,0x3a,0x3b,0x39,0x39,0x3a,0x38,0x37,0x39,0x39,
0x3a,0x3a,0x3a,0x3a,0x39,0x39,0x39,0x3b,0x3b,0x3b,0x3a,0x3a,0x38,0x38,0x3a,0x3b,
0x3a,0x39,0x38,0x39,0x39,0x39,0x38,0x39,0x38,0x36,0x36,0x39,0x3d,0x3d,0x3c,0x3b,
0x3b,0x3b,0x39,0x39,0x3b,0x3c,0x3c,0x3b,0x3a,0x3b,0x3c,0x3c,0x3b,0x3b,0x3d,0x3f,
0x3b,0x3b,0x38,0x36,0x37,0x36,0x36,0x38,0x38,0x36,0x35,0x32,0x31,0x34,0x36,0x38,
0x3a,0x3b,0x3b,0x3b,0x38,0x36,0x39,0x3d,0x3d,0x3b,0x3a,0x38,0x38,0x37,0x37,0x37,
0x37,0x36,0x34,0x36,0x38,0x39,0x39,0x39,0x38,0x37,0x38,0x39,0x38,0x38,0x39,0x37,
0x38,0x36,0x37,0x38,0x3a,0x3a,0x3b,0x3a,0x3a,0x39,0x3a,0x38,0x38,0x3a,0x3b,0x3b,
0x3b,0x3a,0x39,0x39,0x37,0x36,0x37,0x38,0x37,0x36,0x37,0x39,0x3a,0x38,0x37,0x37,
0x39,0x3a,0x39,0x39,0x3a,0x3a,0x3a,0x37,0x36,0x36,0x38,0x37,0x38,0x38,0x39,0x38,
0x36,0x36,0x37,0x3a,0x3b,0x38,0x39,0x38,0x38,0x39,0x3a,0x38,0x39,0x38,0x36,0x36,
0x36,0x37,0x37,0x37,0x37,0x37,0x38,0x3a,0x3a,0x3a,0x39,0x38,0x37,0x35,0x35,0x37,
0x37,0x37,0x38,0x38,0x3b,0x3b,0x3b,0x3b,0x3a,0x3a,0x39,0x38,0x37,0x36,0x36,0x38,
0x37,0x36,0x38,0x38,0x38,0x39,0x3a,0x3b,0x3b,0x39,0x37,0x36,0x37,0x37,0x38,0x3a,
0x39,0x37,0x36,0x34,0x33,0x35,0x36,0x36,0x36,0x36,0x37,0x36,0x38,0x36,0x38,0x3b,
0x3b,0x39,0x38,0x37,0x38,0x39,0x38,0x39,0x3a,0x3a,0x39,0x38,0x39,0x3a,0x3b,0x3c,
0x3c,0x3a,0x3a,0x38,0x36,0x37,0x37,0x37,0x38,0x36,0x35,0x36,0x36,0x36,0x37,0x38,
0x38,0x37,0x36,0x35,0x37,0x3b,0x40,0x45,0x4a,0x51,0x5a,0x65,0x6f,0x78,0x81,0x88,
0x8e,0x90,0x93,0x96,0x98,0x98,0x97,0x97,0x97,0x96,0x95,0x92,0x92,0x93,0x95,0x96,
0x96,0x96,0x96,0x95,0x96,0x96,0x9a,0x9b,0x98,0x94,0x93,0x94,0x95,0x95,0x98,0x99,
0x98,0x98,0x96,0x96,0x96,0x96,0x96,0x96,0x94,0x93,0x93,0x93,0x91,0x90,0x8e,0x8a,
0x82,0x7a,0x71,0x69,0x60,0x57,0x4e,0x49,0x44,0x3d,0x3a,0x38,0x39,0x38,0x36,0x35,
0x36,0x37,0x38,0x33,0x35,0x34,0x34,0x35,0x36,0x37,0x3a,0x39,0x38,0x38,0x3a,0x3b,
0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3a,0x3a,0x3b,0x3d,0x3e,0x3d,0x3b,0x3b,0x3b,0x39,
0x38,0x38,0x38,0x37,0x36,0x35,0x36,0x37,0x3a,0x3a,0x3d,0x3b,0x3a,0x3a,0x3b,0x3a,
0x39,0x39,0x39,0x3b,0x3a,0x3b,0x3b,0x3b,0x3a,0x39,0x39,0x38,0x39,0x3a,0x3a,0x37,
0x38,0x39,0x3a,0x3a,0x39,0x38,0x38,0x39,0x39,0x3a,0x39,0x38,0x37,0x38,0x39,0x3a,
0x3b,0x3c,0x3c,0x3d,0x3c,0x3a,0x39,0x39,0x39,0x3a,0x39,0x38,0x36,0x36,0x35,0x36,
0x38,0x39,0x3a,0x3b,0x3a,0x39,0x3b,0x3d,0x3c,0x3c,0x3b,0x3b,0x3b,0x3a,0x3a,0x3b,
0x3b,0x3a,0x38,0x37,0x37,0x38,0x39,0x38,0x38,0x38,0x39,0x39,0x3a,0x3a,0x3b,0x3d,
0x3e,0x3f,0x40,0x40,0x3e,0x3c,0x3b,0x3c,0x3b,0x3c,0x3c,0x3b,0x3b,0x3a,0x39,0x3a,
0x3b,0x3a,0x3b,0x3a,0x38,0x37,0x37,0x36,0x36,0x37,0x37,0x36,0x38,0x34,0x34,0x38,
0x3a,0x3a,0x3a,0x39,0x38,0x38,0x38,0x3a,0x3b,0x3b,0x39,0x36,0x34,0x34,0x35,0x37,
0x38,0x39,0x3a,0x38,0x37,0x38,0x3a,0x3b,0x3c,0x3b,0x3b,0x38,0x39,0x3a,0x38,0x3a,
0x3b,0x3b,0x38,0x35,0x34,0x37,0x39,0x3a,0x3a,0x3a,0x39,0x3a,0x3a,0x38,0x38,0x38,
0x37,0x38,0x38,0x38,0x39,0x3a,0x3a,0x39,0x3a,0x3b,0x3b,0x3b,0x3b,0x3c,0x3c,0x3c,
0x3b,0x3a,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x38,0x33,0x32,0x34,0x35,0x36,0x36,0x35,
0x34,0x34,0x35,0x37,0x38,0x3c,0x3d,0x3b,0x3a,0x39,0x38,0x39,0x38,0x38,0x3b,0x3b,
0x39,0x38,0x37,0x38,0x3a,0x3b,0x39,0x38,0x37,0x37,0x35,0x34,0x35,0x35,0x36,0x33,
0x32,0x34,0x37,0x36,0x34,0x31,0x32,0x35,0x39,0x39,0x38,0x3a,0x39,0x38,0x39,0x3a,
0x3b,0x3b,0x3b,0x39,0x39,0x38,0x39,0x3b,0x3b,0x39,0x3a,0x3a,0x39,0x38,0x38,0x37,
// Line 15
0x36,0x37,0x38,0x37,0x36,0x37,0x38,0x38,0x3a,0x39,0x39,0x39,0x37,0x35,0x36,0x38,
0x3b,0x3a,0x37,0x36,0x38,0x39,0x39,0x39,0x39,0x39,0x38,0x38,0x37,0x37,0x3a,0x3b,
0x39,0x37,0x34,0x34,0x34,0x34,0x35,0x37,0x3a,0x3a,0x37,0x36,0x36,0x37,0x3a,0x3c,
0x3d,0x3b,0x36,0x33,0x36,0x40,0x51,0x64,0x75,0x7b,0x7a,0x71,0x65,0x5b,0x5c,0x63,
0x6e,0x79,0x7c,0x79,0x74,0x6a,0x61,0x5f,0x61,0x67,0x6e,0x72,0x73,0x72,0x6e,0x69,
0x64,0x61,0x65,0x6c,0x74,0x77,0x78,0x76,0x6e,0x64,0x60,0x5f,0x64,0x6d,0x73,0x78,
0x79,0x75,0x6e,0x64,0x62,0x61,0x67,0x6e,0x76,0x79,0x7b,0x76,0x6d,0x64,0x61,0x61,
0x65,0x6a,0x71,0x76,0x77,0x73,0x6c,0x64,0x61,0x61,0x67,0x6f,0x77,0x7d,0x7c,0x76,
0x6f,0x67,0x64,0x63,0x65,0x69,0x6e,0x70,0x71,0x74,0x7d,0x85,0x90,0x9c,0xa6,0xab,
0xa9,0xa0,0x92,0x84,0x75,0x69,0x61,0x5a,0x54,0x4f,0x4a,0x43,0x3b,0x3b,0x42,0x4f,
0x61,0x73,0x82,0x8f,0x94,0x94,0x95,0x98,0x9d,0xa1,0x9e,0x97,0x8d,0x7f,0x6f,0x62,
0x5c,0x5c,0x61,0x69,0x70,0x78,0x82,0x8c,0x92,0x9a,0xa0,0xa6,0xa9,0xa9,0xa3,0x9e,
0x9a,0x97,0x98,0x9a,0x9a,0x96,0x8b,0x7a,0x68,0x5b,0x55,0x59,0x65,0x72,0x7d,0x81,
0x7c,0x72,0x67,0x61,0x63,0x67,0x6e,0x76,0x7a,0x79,0x72,0x6c,0x68,0x64,0x65,0x6c,
0x73,0x79,0x79,0x78,0x6f,0x67,0x63,0x63,0x66,0x70,0x78,0x7c,0x79,0x70,0x67,0x63,
0x60,0x5f,0x5e,0x5a,0x51,0x46,0x3a,0x30,0x2e,0x32,0x39,0x3f,0x47,0x51,0x5c,0x6a,
0x76,0x7d,0x7e,0x74,0x67,0x5f,0x5e,0x67,0x74,0x7e,0x81,0x7c,0x73,0x67,0x5c,0x5e,
0x65,0x6f,0x78,0x7a,0x78,0x72,0x69,0x61,0x5e,0x5e,0x5e,0x5a,0x51,0x43,0x37,0x2e,
0x2b,0x2f,0x38,0x40,0x44,0x44,0x3d,0x37,0x34,0x34,0x33,0x33,0x32,0x34,0x3c,0x4a,
0x5b,0x6e,0x7b,0x7f,0x7a,0x6f,0x63,0x5c,0x59,0x54,0x4c,0x44,0x3a,0x34,0x3c,0x4b,
0x62,0x78,0x8a,0x93,0x98,0x99,0x9a,0x98,0x8e,0x80,0x6e,0x60,0x58,0x5a,0x64,0x73,
0x7e,0x83,0x7e,0x74,0x6a,0x64,0x65,0x6c,0x75,0x7a,0x7c,0x78,0x71,0x69,0x65,0x65,
0x6a,0x72,0x7a,0x7d,0x7c,0x74,0x6c,0x65,0x61,0x5d,0x5c,0x5a,0x54,0x44,0x3a,0x2f,
0x2b,0x2f,0x36,0x3f,0x47,0x48,0x42,0x3d,0x36,0x32,0x30,0x33,0x36,0x3a,0x3d,0x3d,
0x37,0x32,0x32,0x38,0x45,0x55,0x67,0x78,0x81,0x7e,0x78,0x6e,0x68,0x67,0x69,0x6d,
0x72,0x77,0x7c,0x81,0x86,0x8d,0x97,0xa3,0xaa,0xab,0xa6,0x9c,0x8e,0x7f,0x72,0x67,
0x5e,0x59,0x53,0x4c,0x42,0x39,0x34,0x3f,0x4f,0x65,0x7a,0x85,0x82,0x75,0x64,0x58,
0x56,0x60,0x6f,0x7d,0x81,0x79,0x6e,0x64,0x60,0x61,0x62,0x5e,0x53,0x43,0x32,0x2c,
0x36,0x4c,0x67,0x7f,0x8c,0x8b,0x7f,0x6f,0x63,0x61,0x65,0x6e,0x75,0x7c,0x7e,0x82,
0x8c,0x96,0x9f,0xa9,0xad,0xaa,0xa1,0x95,0x89,0x7c,0x6e,0x61,0x58,0x52,0x4d,0x48,
0x43,0x3e,0x3b,0x38,0x35,0x33,0x37,0x3f,0x48,0x52,0x5c,0x69,0x78,0x85,0x8f,0x97,
0x9a,0x97,0x8c,0x7c,0x6b,0x5d,0x53,0x4a,0x41,0x3d,0x3b,0x3f,0x4b,0x5d,0x71,0x81,
0x87,0x82,0x75,0x67,0x5d,0x59,0x60,0x68,0x6f,0x76,0x7a,0x80,0x8a,0x94,0x9c,0xa0,
0x98,0x88,0x73,0x61,0x57,0x58,0x61,0x6d,0x79,0x84,0x8c,0x93,0x9b,0xa1,0xa5,0xa6,
0xa4,0xa0,0x9e,0x9c,0x9c,0x9c,0x9d,0x9d,0x9e,0xa0,0xa1,0x9f,0x97,0x8b,0x7d,0x72,
0x66,0x5c,0x54,0x4d,0x44,0x3e,0x39,0x3d,0x46,0x54,0x66,0x76,0x83,0x8d,0x94,0x99,
0x99,0x94,0x8c,0x7d,0x6c,0x60,0x5a,0x5c,0x66,0x71,0x79,0x7c,0x79,0x6f,0x68,0x61,
0x5b,0x55,0x4d,0x44,0x3b,0x36,0x36,0x36,0x39,0x3d,0x44,0x4d,0x57,0x60,0x69,0x75,
0x7f,0x89,0x90,0x98,0x9e,0xa5,0xa6,0xa4,0xa1,0x9d,0x9a,0x9a,0x9a,0x9b,0x9e,0xa1,
0xa3,0x9e,0x97,0x8b,0x7e,0x72,0x66,0x58,0x51,0x47,0x3f,0x3b,0x36,0x36,0x40,0x54,
0x6a,0x7c,0x83,0x7e,0x73,0x65,0x5c,0x5a,0x60,0x69,0x72,0x79,0x7c,0x81,0x8b,0x97,
0x9f,0x9f,0x94,0x81,0x6d,0x59,0x4a,0x40,0x3c,0x3b,0x39,0x38,0x36,0x34,0x39,0x3b,
0x3d,0x44,0x4d,0x59,0x6a,0x79,0x83,0x8a,0x91,0x97,0x9e,0xa3,0xa5,0xa3,0x9c,0x90,
0x81,0x73,0x67,0x5d,0x58,0x52,0x4b,0x42,0x3b,0x39,0x41,0x4e,0x5e,0x6e,0x7d,0x89,
0x91,0x94,0x95,0x98,0x9c,0x9e,0x9e,0x9c,0x94,0x86,0x76,0x68,0x60,0x5f,0x63,0x6a,
0x73,0x7c,0x84,0x8b,0x94,0x9d,0xa3,0xa3,0x98,0x85,0x73,0x63,0x5b,0x59,0x5e,0x68,
0x75,0x7f,0x88,0x8e,0x94,0x9b,0xa0,0xa3,0xa3,0xa1,0x9d,0x98,0x94,0x97,0x9a,0x9c,
0x98,0x8d,0x7d,0x6e,0x61,0x5c,0x60,0x6b,0x77,0x81,0x81,0x7a,0x6e,0x66,0x5f,0x5e,
0x65,0x6d,0x72,0x76,0x77,0x7c,0x87,0x94,0xa0,0xa3,0x9b,0x88,0x70,0x5c,0x55,0x5c,
0x6b,0x79,0x81,0x82,0x7d,0x73,0x6b,0x66,0x63,0x5c,0x4f,0x3f,0x33,0x32,0x3c,0x51,
0x67,0x77,0x7f,0x7d,0x70,0x5f,0x56,0x53,0x52,0x4f,0x47,0x3e,0x38,0x35,0x34,0x35,
0x3a,0x42,0x4b,0x53,0x5c,0x67,0x78,0x85,0x8e,0x94,0x97,0x94,0x8d,0x80,0x71,0x64,
0x55,0x47,0x3d,0x39,0x3b,0x3f,0x47,0x54,0x63,0x72,0x7f,0x89,0x91,0x97,0x9a,0x98,
0x8d,0x7d,0x6e,0x61,0x5b,0x5c,0x65,0x72,0x7d,0x80,0x7b,0x6e,0x69,0x63,0x5f,0x64,
0x6b,0x70,0x73,0x76,0x7c,0x88,0x96,0xa3,0xac,0xaf,0xac,0xa4,0x9a,0x94,0x94,0x98,
0x9c,0x9d,0xa0,0xa2,0xa1,0x9f,0x9d,0x9d,0x9f,0x9f,0x9f,0x9f,0x9e,0x9d,0x9c,0x9b,
0x99,0x92,0x88,0x7b,0x6c,0x5e,0x51,0x46,0x41,0x3a,0x36,0x36,0x34,0x30,0x2d,0x31,
0x3a,0x4a,0x5b,0x69,0x72,0x77,0x73,0x68,0x5d,0x56,0x53,0x50,0x49,0x40,0x39,0x33,
0x30,0x32,0x38,0x42,0x46,0x44,0x3e,0x3a,0x37,0x35,0x34,0x33,0x33,0x34,0x39,0x41,
0x4f,0x61,0x72,0x7e,0x87,0x8e,0x95,0x9c,0x9e,0x97,0x88,0x74,0x61,0x54,0x54,0x60,
0x70,0x7e,0x81,0x7b,0x70,0x64,0x5e,0x60,0x67,0x70,0x77,0x77,0x72,0x68,0x63,0x60,
0x5d,0x5d,0x5a,0x50,0x49,0x3b,0x2f,0x2c,0x2f,0x33,0x39,0x42,0x4c,0x57,0x61,0x6c,
0x76,0x82,0x8c,0x95,0x9d,0xa3,0xa9,0xab,0xa9,0x9f,0x91,0x82,0x74,0x66,0x5b,0x51,
0x4b,0x45,0x3e,0x37,0x30,0x2d,0x2e,0x33,0x39,0x3e,0x43,0x3e,0x34,0x31,0x33,0x3f,
0x52,0x67,0x78,0x81,0x80,0x76,0x66,0x62,0x61,0x67,0x6f,0x75,0x78,0x7d,0x80,0x88,
0x94,0x9d,0xa0,0x98,0x87,0x72,0x63,0x5b,0x5b,0x61,0x6e,0x7a,0x84,0x8d,0x96,0x9b,
0x9c,0x94,0x88,0x78,0x67,0x58,0x4e,0x45,0x3d,0x37,0x35,0x3a,0x45,0x5a,0x6e,0x7d,
0x83,0x7d,0x70,0x67,0x5c,0x55,0x51,0x4b,0x41,0x36,0x31,0x36,0x46,0x5d,0x75,0x86,
0x90,0x93,0x94,0x94,0x92,0x8d,0x83,0x75,0x65,0x5d,0x5d,0x64,0x70,0x7b,0x82,0x89,
0x8f,0x95,0x9b,0xa1,0xa4,0xa3,0x9e,0x98,0x94,0x97,0x9a,0x9c,0x9d,0x99,0x8e,0x81,
0x72,0x65,0x60,0x61,0x67,0x6f,0x78,0x81,0x89,0x91,0x97,0x9d,0xa5,0xa9,0xa9,0xa5,
0x9e,0x99,0x97,0x97,0x9a,0x9c,0x99,0x8e,0x7c,0x68,0x5b,0x59,0x62,0x6f,0x7b,0x81,
0x7d,0x74,0x6c,0x66,0x63,0x61,0x5b,0x50,0x44,0x3a,0x37,0x3d,0x53,0x6c,0x81,0x89,
0x84,0x72,0x64,0x58,0x58,0x64,0x73,0x7f,0x83,0x7a,0x6e,0x66,0x63,0x62,0x60,0x59,
0x4b,0x3b,0x30,0x2f,0x3d,0x55,0x6e,0x81,0x89,0x85,0x7a,0x6d,0x61,0x58,0x51,0x4a,
0x41,0x39,0x37,0x3f,0x4e,0x63,0x76,0x87,0x91,0x95,0x94,0x92,0x8e,0x85,0x7b,0x6b,
0x5a,0x4d,0x44,0x40,0x3e,0x3d,0x3b,0x37,0x34,0x32,0x33,0x3e,0x47,0x51,0x5d,0x6c,
0x79,0x86,0x91,0x9a,0x9f,0x9e,0x97,0x89,0x76,0x66,0x5e,0x5d,0x61,0x69,0x76,0x81,
0x88,0x8e,0x93,0x99,0x9c,0x9f,0x9f,0x9e,0x9a,0x97,0x98,0x9a,0x9e,0xa1,0xa5,0xa7,
0xa5,0xa5,0x9f,0x95,0x89,0x78,0x68,0x5c,0x57,0x57,0x5e,0x69,0x76,0x7f,0x89,0x91,
0x99,0xa0,0xa7,0xa9,0xa8,0xa3,0x9b,0x91,0x82,0x72,0x66,0x5d,0x5c,0x63,0x6e,0x78,
0x7d,0x7b,0x74,0x6c,0x64,0x60,0x5a,0x58,0x4f,0x42,0x36,0x2d,0x2a,0x30,0x36,0x3d,
0x45,0x4d,0x57,0x65,0x71,0x78,0x79,0x74,0x69,0x60,0x5f,0x66,0x71,0x7c,0x81,0x7d,
0x72,0x63,0x5a,0x5c,0x64,0x70,0x78,0x7a,0x78,0x71,0x68,0x61,0x5e,0x61,0x62,0x5e,
0x54,0x43,0x34,0x31,0x38,0x4b,0x67,0x81,0x8d,0x88,0x77,0x63,0x57,0x56,0x60,0x6e,
0x7a,0x7d,0x77,0x6d,0x64,0x60,0x61,0x5f,0x58,0x4c,0x3f,0x34,0x2c,0x2a,0x2f,0x37,
0x3c,0x3e,0x3d,0x3e,0x3d,0x3b,0x39,0x36,0x33,0x33,0x36,0x3c,0x46,0x51,0x5e,0x69,
0x79,0x85,0x91,0x9b,0x9e,0x98,0x8f,0x81,0x70,0x60,0x51,0x45,0x3f,0x3b,0x38,0x37,
0x36,0x35,0x35,0x36,0x3a,0x45,0x56,0x65,0x70,0x77,0x78,0x72,0x69,0x60,0x59,0x55,
0x4e,0x46,0x3f,0x37,0x33,0x30,0x33,0x39,0x43,0x4e,0x59,0x63,0x6e,0x79,0x83,0x8f,
0x9a,0xa3,0xaa,0xab,0xaa,0xa5,0x9f,0x9b,0x96,0x97,0x97,0x98,0x97,0x8e,0x80,0x6f,
0x61,0x5a,0x5c,0x65,0x73,0x7f,0x84,0x7c,0x70,0x64,0x5e,0x60,0x66,0x6e,0x73,0x76,
0x71,0x67,0x61,0x60,0x63,0x69,0x6c,0x6e,0x6f,0x71,0x74,0x7d,0x88,0x92,0x98,0x99,
0x90,0x81,0x70,0x5f,0x4f,0x44,0x3f,0x3b,0x3c,0x3f,0x46,0x54,0x63,0x71,0x7c,0x87,
0x8f,0x95,0x98,0x9b,0xa1,0xa6,0xa9,0xa6,0xa3,0x9e,0x9d,0xa1,0xa5,0xa7,0xa8,0xa5,
0xa1,0x9e,0x9c,0x9f,0xa1,0x9f,0x99,0x8f,0x84,0x75,0x66,0x5a,0x52,0x4a,0x44,0x3d,
// Line 16
0x3a,0x37,0x36,0x37,0x39,0x3a,0x3b,0x3c,0x3c,0x3b,0x39,0x39,0x3b,0x3b,0x3a,0x39,
0x37,0x35,0x37,0x39,0x38,0x36,0x36,0x37,0x39,0x39,0x39,0x38,0x39,0x39,0x39,0x39,
0x39,0x39,0x39,0x36,0x35,0x36,0x38,0x39,0x3a,0x38,0x34,0x31,0x30,0x32,0x36,0x3c,
0x3d,0x3b,0x39,0x35,0x34,0x3b,0x46,0x58,0x6b,0x76,0x78,0x73,0x6a,0x5e,0x58,0x5a,
0x64,0x70,0x79,0x7b,0x76,0x6d,0x64,0x5f,0x61,0x67,0x6f,0x75,0x77,0x75,0x71,0x6a,
0x62,0x5f,0x62,0x67,0x6d,0x74,0x78,0x76,0x71,0x6a,0x62,0x5f,0x60,0x66,0x70,0x76,
0x77,0x74,0x6e,0x68,0x64,0x61,0x62,0x65,0x6d,0x71,0x74,0x73,0x71,0x6b,0x65,0x5f,
0x5f,0x66,0x6f,0x75,0x77,0x75,0x6f,0x68,0x60,0x5c,0x5e,0x66,0x6e,0x76,0x7a,0x7a,
0x76,0x6f,0x67,0x62,0x64,0x68,0x6d,0x6f,0x6f,0x6f,0x74,0x7a,0x84,0x91,0x9f,0xa9,
0xac,0xa8,0x9d,0x8f,0x84,0x74,0x67,0x5f,0x5a,0x54,0x4d,0x44,0x3c,0x38,0x39,0x42,
0x51,0x63,0x76,0x85,0x8e,0x94,0x98,0x9b,0x9d,0x9f,0xa2,0xa0,0x98,0x8b,0x7a,0x6b,
0x5e,0x56,0x56,0x5d,0x68,0x71,0x78,0x79,0x73,0x69,0x62,0x5c,0x5e,0x69,0x73,0x7a,
0x7a,0x74,0x6b,0x64,0x60,0x62,0x66,0x6b,0x6c,0x6c,0x6c,0x71,0x79,0x89,0x97,0xa2,
0xac,0xac,0xa7,0xa0,0x99,0x95,0x97,0x9a,0x9a,0x95,0x8a,0x7c,0x6b,0x5e,0x53,0x4c,
0x45,0x3d,0x36,0x37,0x40,0x4f,0x62,0x72,0x7b,0x7c,0x74,0x66,0x5c,0x55,0x52,0x4c,
0x46,0x3d,0x37,0x3a,0x47,0x5c,0x73,0x83,0x88,0x80,0x71,0x61,0x56,0x50,0x4d,0x49,
0x42,0x39,0x33,0x30,0x32,0x37,0x40,0x48,0x4e,0x58,0x63,0x6f,0x7a,0x84,0x8e,0x95,
0x97,0x91,0x86,0x78,0x67,0x56,0x49,0x40,0x3c,0x3c,0x3d,0x3b,0x3a,0x39,0x39,0x3d,
0x41,0x48,0x53,0x63,0x71,0x7c,0x84,0x8c,0x92,0x98,0x9d,0xa1,0xa6,0xa4,0x9a,0x8c,
0x7c,0x6d,0x62,0x5e,0x5e,0x63,0x6b,0x73,0x77,0x82,0x8e,0x97,0x9e,0x9c,0x95,0x8d,
0x7d,0x69,0x58,0x4c,0x41,0x38,0x34,0x35,0x3e,0x4c,0x5c,0x6a,0x76,0x82,0x8b,0x94,
0x9a,0x9a,0x97,0x8d,0x7f,0x6f,0x62,0x5d,0x60,0x67,0x72,0x7f,0x88,0x8e,0x92,0x99,
0xa0,0xa5,0xa6,0xa4,0xa0,0x9b,0x97,0x95,0x97,0x9b,0xa0,0xa2,0xa0,0x9d,0x9d,0x9d,
0x9d,0x9d,0x9b,0x98,0x92,0x89,0x7d,0x6f,0x60,0x53,0x48,0x41,0x3d,0x3b,0x3b,0x39,
0x36,0x35,0x36,0x3c,0x44,0x50,0x5f,0x6d,0x76,0x76,0x71,0x6a,0x61,0x5b,0x5e,0x67,
0x72,0x79,0x7b,0x76,0x6e,0x67,0x62,0x61,0x60,0x5c,0x53,0x46,0x36,0x2b,0x2a,0x2f,
0x36,0x3d,0x40,0x3f,0x3a,0x35,0x30,0x31,0x34,0x35,0x35,0x3a,0x3c,0x3c,0x3a,0x37,
0x36,0x3d,0x47,0x54,0x66,0x76,0x84,0x91,0x98,0x9b,0x9d,0x99,0x8f,0x7d,0x6c,0x5e,
0x58,0x5c,0x65,0x6f,0x79,0x84,0x8d,0x94,0x9b,0x9c,0x98,0x8b,0x76,0x62,0x52,0x48,
0x42,0x41,0x3e,0x3c,0x3b,0x39,0x39,0x3d,0x40,0x3f,0x3d,0x37,0x34,0x33,0x37,0x42,
0x52,0x62,0x71,0x7e,0x89,0x94,0x9d,0x9f,0x98,0x89,0x79,0x6b,0x60,0x5d,0x5f,0x67,
0x71,0x7a,0x84,0x90,0x9b,0xa3,0xa0,0x95,0x84,0x71,0x60,0x52,0x46,0x40,0x39,0x33,
0x33,0x39,0x48,0x5e,0x72,0x7c,0x7e,0x78,0x6c,0x5e,0x59,0x55,0x52,0x4d,0x43,0x3a,
0x3c,0x40,0x4f,0x65,0x79,0x8b,0x95,0x96,0x95,0x97,0x9e,0xa5,0xa8,0xa5,0xa2,0xa1,
0xa1,0x9f,0x9d,0x9d,0x9c,0x9a,0x99,0x97,0x91,0x89,0x7d,0x6c,0x5e,0x52,0x4a,0x46,
0x42,0x3e,0x3a,0x37,0x34,0x30,0x35,0x38,0x3e,0x4a,0x58,0x66,0x73,0x77,0x71,0x68,
0x5e,0x58,0x54,0x52,0x4e,0x49,0x40,0x36,0x2f,0x2e,0x35,0x3e,0x49,0x50,0x57,0x60,
0x6b,0x77,0x87,0x95,0x9d,0x9a,0x92,0x84,0x78,0x6b,0x5e,0x4f,0x46,0x3a,0x33,0x35,
0x3d,0x4b,0x5e,0x71,0x7a,0x7d,0x78,0x6f,0x66,0x5e,0x57,0x53,0x4c,0x46,0x40,0x3e,
0x40,0x4a,0x5e,0x74,0x88,0x91,0x92,0x90,0x91,0x97,0x9e,0xa2,0xa2,0x9b,0x8f,0x82,
0x73,0x63,0x5a,0x53,0x4c,0x44,0x3b,0x37,0x3c,0x46,0x51,0x61,0x71,0x82,0x8e,0x9a,
0x9b,0x96,0x8b,0x7d,0x6e,0x62,0x57,0x4c,0x42,0x37,0x2f,0x2f,0x37,0x48,0x5e,0x73,
0x7f,0x80,0x76,0x69,0x5e,0x56,0x51,0x4d,0x48,0x41,0x38,0x30,0x2e,0x33,0x3c,0x42,
0x44,0x40,0x39,0x33,0x31,0x36,0x42,0x52,0x64,0x74,0x81,0x8a,0x92,0x9a,0x9f,0xa1,
0xa0,0x9f,0x9b,0x94,0x8d,0x82,0x76,0x69,0x5e,0x5a,0x5e,0x67,0x71,0x7a,0x82,0x89,
0x8f,0x97,0x9e,0xa4,0xa9,0xa7,0xa0,0x9c,0x99,0x99,0x99,0x9e,0x9f,0x9f,0x9f,0xa0,
0x9d,0x9f,0x9e,0x9c,0x9a,0x97,0x98,0x9b,0x9e,0x9f,0x9c,0x95,0x8b,0x7c,0x6e,0x61,
0x57,0x4e,0x47,0x3f,0x38,0x35,0x3a,0x45,0x52,0x61,0x74,0x84,0x8f,0x96,0x97,0x97,
0x90,0x82,0x73,0x64,0x59,0x51,0x49,0x45,0x3e,0x3d,0x44,0x50,0x60,0x71,0x7f,0x84,
0x7d,0x6e,0x60,0x57,0x56,0x5d,0x68,0x73,0x79,0x7d,0x82,0x89,0x94,0xa2,0xac,0xaf,
0xac,0xa5,0x9d,0x97,0x96,0x9b,0x9e,0xa3,0xa3,0xa2,0xa3,0xa3,0xa0,0xa1,0x9d,0x9b,
0x9d,0x9d,0x9c,0x9b,0x9b,0x98,0x96,0x94,0x96,0x9a,0x9d,0x9a,0x91,0x84,0x76,0x69,
0x60,0x5d,0x63,0x6c,0x74,0x79,0x81,0x89,0x91,0x98,0x9d,0xa4,0xa6,0xa1,0x9a,0x93,
0x91,0x92,0x92,0x94,0x92,0x8b,0x81,0x71,0x62,0x55,0x4c,0x47,0x44,0x40,0x3d,0x39,
0x35,0x34,0x36,0x3d,0x44,0x4a,0x53,0x5e,0x6d,0x7e,0x8c,0x95,0x99,0x97,0x8e,0x81,
0x71,0x64,0x58,0x4d,0x42,0x38,0x34,0x37,0x40,0x50,0x62,0x72,0x7e,0x7f,0x79,0x6d,
0x62,0x56,0x4e,0x4a,0x46,0x3c,0x39,0x35,0x33,0x34,0x37,0x3d,0x46,0x52,0x60,0x6d,
0x77,0x7a,0x78,0x6f,0x66,0x60,0x5e,0x64,0x6b,0x71,0x76,0x7a,0x81,0x8a,0x92,0x97,
0x94,0x8a,0x7c,0x68,0x53,0x44,0x3e,0x3b,0x39,0x38,0x3c,0x45,0x54,0x64,0x73,0x82,
0x8c,0x90,0x94,0x97,0x9c,0xa3,0xa6,0xa5,0x9c,0x8f,0x82,0x72,0x64,0x5b,0x5a,0x61,
0x6b,0x74,0x7d,0x7d,0x75,0x68,0x5b,0x58,0x60,0x6b,0x77,0x7d,0x7a,0x72,0x67,0x5e,
0x5d,0x5e,0x5f,0x58,0x4b,0x3a,0x30,0x2e,0x3e,0x56,0x6f,0x84,0x8b,0x82,0x73,0x61,
0x58,0x5b,0x64,0x70,0x78,0x79,0x74,0x6c,0x67,0x63,0x60,0x5d,0x55,0x49,0x3b,0x30,
0x2c,0x35,0x49,0x61,0x78,0x88,0x91,0x95,0x95,0x8f,0x88,0x7f,0x74,0x66,0x55,0x46,
0x3b,0x38,0x38,0x39,0x3c,0x3d,0x39,0x38,0x38,0x3e,0x4a,0x5e,0x6c,0x76,0x79,0x75,
0x6b,0x62,0x5d,0x5e,0x63,0x69,0x6d,0x72,0x77,0x7f,0x8a,0x95,0x9c,0x9a,0x8e,0x7c,
0x67,0x56,0x4a,0x44,0x3e,0x3a,0x38,0x3d,0x47,0x58,0x6f,0x7e,0x84,0x7e,0x6f,0x61,
0x5a,0x5e,0x69,0x76,0x7e,0x7d,0x74,0x6c,0x61,0x59,0x5b,0x5c,0x58,0x50,0x44,0x36,
0x2e,0x28,0x2b,0x32,0x3e,0x44,0x44,0x3d,0x34,0x30,0x34,0x41,0x54,0x6b,0x7a,0x81,
0x79,0x6c,0x60,0x5d,0x5f,0x67,0x6f,0x75,0x78,0x7a,0x81,0x8c,0x99,0xa2,0x9f,0x8f,
0x79,0x62,0x53,0x51,0x5a,0x69,0x76,0x7c,0x79,0x70,0x6b,0x64,0x60,0x58,0x4f,0x42,
0x35,0x2b,0x2d,0x3e,0x55,0x6c,0x7c,0x80,0x7b,0x72,0x66,0x5c,0x55,0x4e,0x49,0x3f,
0x38,0x38,0x40,0x4f,0x61,0x73,0x86,0x92,0x97,0x95,0x90,0x89,0x80,0x75,0x67,0x5c,
0x52,0x49,0x42,0x3d,0x3c,0x41,0x4e,0x5f,0x71,0x7e,0x82,0x7a,0x6b,0x5b,0x53,0x57,
0x62,0x6f,0x79,0x7b,0x76,0x6a,0x60,0x5d,0x5d,0x5c,0x55,0x4a,0x3d,0x30,0x28,0x28,
0x2e,0x38,0x42,0x44,0x41,0x39,0x33,0x33,0x38,0x43,0x53,0x63,0x75,0x7f,0x88,0x91,
0x97,0x9a,0x95,0x88,0x76,0x66,0x59,0x55,0x59,0x69,0x74,0x7b,0x7b,0x76,0x6b,0x65,
0x5b,0x53,0x4d,0x46,0x3d,0x34,0x2c,0x28,0x2c,0x33,0x3b,0x46,0x53,0x5f,0x6a,0x71,
0x73,0x71,0x6b,0x62,0x58,0x53,0x51,0x4c,0x44,0x3a,0x34,0x30,0x30,0x32,0x39,0x45,
0x53,0x61,0x6c,0x76,0x79,0x76,0x6c,0x61,0x5a,0x54,0x51,0x4d,0x43,0x38,0x2d,0x28,
0x27,0x2c,0x38,0x44,0x50,0x59,0x60,0x67,0x75,0x81,0x8a,0x95,0x99,0x95,0x8a,0x7a,
0x6a,0x5e,0x58,0x5c,0x67,0x76,0x82,0x86,0x80,0x76,0x6a,0x63,0x60,0x62,0x68,0x6d,
0x73,0x77,0x7d,0x85,0x93,0xa1,0xac,0xaf,0xaa,0xa0,0x93,0x83,0x73,0x64,0x5c,0x57,
0x52,0x4d,0x44,0x3a,0x35,0x37,0x42,0x56,0x6c,0x7e,0x82,0x7a,0x6b,0x5c,0x53,0x55,
0x60,0x6e,0x78,0x7a,0x77,0x6f,0x68,0x65,0x61,0x63,0x68,0x6b,0x6d,0x6c,0x73,0x7e,
0x8b,0x98,0xa4,0xac,0xb5,0xb1,0xa7,0x9b,0x8c,0x7c,0x6f,0x62,0x5a,0x58,0x5e,0x64,
0x6b,0x73,0x7a,0x84,0x8d,0x95,0x9d,0xa4,0xa8,0xa6,0xa2,0x9a,0x8c,0x7e,0x6f,0x62,
0x5c,0x5a,0x5e,0x62,0x69,0x70,0x79,0x83,0x8c,0x95,0x9e,0xa6,0xa8,0xa8,0xa2,0x98,
0x8b,0x7a,0x6a,0x61,0x5e,0x5e,0x5d,0x63,0x6a,0x74,0x7e,0x88,0x92,0x9b,0x9e,0x99,
0x8c,0x7b,0x6b,0x5e,0x57,0x58,0x60,0x6d,0x7a,0x84,0x8c,0x93,0x9a,0xa0,0xa3,0xa4,
0xa2,0x9c,0x92,0x88,0x7b,0x6f,0x66,0x5e,0x5a,0x5d,0x65,0x6f,0x79,0x81,0x89,0x91,
0x96,0x9b,0xa0,0xa8,0xa7,0xa1,0x97,0x89,0x79,0x6f,0x64,0x5e,0x5d,0x5f,0x64,0x6b,
0x73,0x7e,0x88,0x91,0x98,0x9a,0xa2,0xa6,0xa3,0x9c,0x91,0x83,0x76,0x64,0x57,0x51,
0x4d,0x48,0x41,0x38,0x31,0x2f,0x2f,0x31,0x33,0x38,0x3b,0x3b,0x39,0x37,0x34,0x35,
0x34,0x35,0x36,0x37,0x37,0x35,0x32,0x30,0x30,0x34,0x37,0x38,0x38,0x39,0x39,0x39,
0x37,0x38,0x39,0x37,0x35,0x34,0x35,0x36,0x37,0x36,0x35,0x35,0x36,0x36,0x35,0x37,
// Line 17
0x38,0x39,0x3b,0x3b,0x38,0x34,0x33,0x33,0x34,0x35,0x38,0x39,0x38,0x37,0x36,0x36,
0x39,0x3b,0x3b,0x39,0x38,0x39,0x3d,0x3c,0x3a,0x38,0x38,0x39,0x3b,0x3b,0x3b,0x39,
0x38,0x36,0x34,0x34,0x35,0x37,0x3b,0x3c,0x3a,0x38,0x36,0x34,0x34,0x36,0x37,0x39,
0x3a,0x38,0x35,0x35,0x38,0x40,0x53,0x66,0x76,0x7e,0x7b,0x72,0x68,0x5f,0x5d,0x64,
0x6f,0x77,0x7c,0x7a,0x73,0x68,0x62,0x5e,0x63,0x6a,0x73,0x79,0x7a,0x75,0x6e,0x67,
0x60,0x5f,0x64,0x6c,0x75,0x7d,0x7d,0x78,0x70,0x68,0x65,0x64,0x68,0x70,0x76,0x7a,
0x78,0x72,0x6e,0x68,0x63,0x62,0x65,0x6a,0x6e,0x71,0x73,0x71,0x6b,0x63,0x5f,0x62,
0x68,0x6e,0x77,0x7b,0x7b,0x78,0x6e,0x64,0x5f,0x5e,0x63,0x6d,0x74,0x78,0x78,0x74,
0x6e,0x67,0x66,0x69,0x6e,0x71,0x73,0x73,0x74,0x78,0x7d,0x85,0x8d,0x98,0xa3,0xa9,
0xaa,0xa4,0x9a,0x8b,0x7b,0x6e,0x63,0x5c,0x57,0x50,0x4a,0x43,0x3d,0x3b,0x40,0x4f,
0x62,0x76,0x85,0x8e,0x94,0x95,0x96,0x98,0x9b,0x9f,0x9f,0x9a,0x8e,0x7f,0x71,0x64,
0x5b,0x5b,0x5f,0x68,0x72,0x79,0x7b,0x79,0x70,0x65,0x5d,0x60,0x68,0x71,0x7a,0x7d,
0x7b,0x76,0x6d,0x67,0x67,0x69,0x6d,0x70,0x70,0x6f,0x6e,0x76,0x81,0x90,0xa0,0xac,
0xaf,0xb1,0xa8,0xa1,0x9f,0x9f,0xa0,0xa0,0x9a,0x90,0x83,0x72,0x63,0x57,0x4e,0x45,
0x3b,0x33,0x32,0x3b,0x4a,0x5c,0x6e,0x7c,0x80,0x78,0x6c,0x60,0x59,0x56,0x52,0x4b,
0x42,0x39,0x37,0x3e,0x51,0x6a,0x7e,0x88,0x85,0x7a,0x6c,0x60,0x5c,0x60,0x69,0x71,
0x79,0x7d,0x82,0x8b,0x94,0x9b,0xa2,0xa7,0xa7,0xa1,0x96,0x89,0x7a,0x6c,0x61,0x58,
0x53,0x4d,0x48,0x44,0x3d,0x37,0x33,0x34,0x38,0x3d,0x43,0x49,0x53,0x5d,0x68,0x74,
0x82,0x8c,0x93,0x9a,0x9e,0x9e,0xa2,0xa2,0x9d,0x92,0x84,0x77,0x6c,0x65,0x63,0x67,
0x6e,0x73,0x7a,0x80,0x87,0x8e,0x98,0x9e,0xa3,0xa6,0xa5,0xa2,0x9e,0x9b,0x98,0x97,
0x99,0x9c,0x9d,0x9f,0x9e,0x9b,0x9a,0x9b,0x9d,0xa0,0x9e,0x9a,0x92,0x85,0x78,0x6a,
0x5d,0x51,0x48,0x40,0x3b,0x3a,0x3d,0x45,0x52,0x62,0x73,0x82,0x8d,0x93,0x95,0x96,
0x90,0x86,0x7a,0x6c,0x5d,0x4f,0x45,0x3e,0x3c,0x3b,0x3b,0x38,0x37,0x36,0x38,0x40,
0x4e,0x5e,0x6f,0x7b,0x7d,0x78,0x6d,0x61,0x58,0x53,0x50,0x4a,0x42,0x37,0x2e,0x2b,
0x2e,0x37,0x42,0x48,0x48,0x43,0x3b,0x34,0x32,0x36,0x3b,0x3c,0x3b,0x38,0x36,0x37,
0x38,0x3a,0x3c,0x3c,0x39,0x37,0x35,0x39,0x44,0x51,0x5f,0x6a,0x77,0x81,0x8b,0x94,
0x9c,0xa1,0xa4,0xa4,0xa3,0x9f,0x97,0x8a,0x7c,0x6a,0x5c,0x59,0x60,0x6a,0x75,0x7f,
0x81,0x7b,0x72,0x69,0x64,0x68,0x6c,0x6e,0x73,0x75,0x78,0x7c,0x83,0x8d,0x9d,0xa8,
0xac,0xaa,0xa4,0x98,0x8b,0x7c,0x6f,0x65,0x5d,0x56,0x4f,0x4a,0x44,0x3f,0x3a,0x38,
0x37,0x39,0x3d,0x43,0x4b,0x55,0x5f,0x6c,0x78,0x85,0x8d,0x97,0x9b,0x9f,0xa4,0xa8,
0xa7,0xa0,0x95,0x85,0x79,0x6d,0x65,0x63,0x6a,0x71,0x78,0x7d,0x82,0x86,0x8f,0x96,
0x9a,0x98,0x8f,0x82,0x6f,0x5e,0x54,0x56,0x62,0x6f,0x7b,0x7e,0x7a,0x6e,0x62,0x5c,
0x5f,0x69,0x74,0x7b,0x7c,0x77,0x70,0x6b,0x65,0x61,0x5f,0x59,0x4e,0x40,0x34,0x31,
0x39,0x49,0x5e,0x73,0x89,0x96,0x9b,0x9d,0x98,0x8f,0x83,0x75,0x68,0x5c,0x51,0x46,
0x3a,0x36,0x36,0x3c,0x4a,0x5d,0x6e,0x7f,0x84,0x80,0x75,0x67,0x5b,0x51,0x49,0x43,
0x3d,0x37,0x32,0x30,0x2f,0x31,0x39,0x44,0x50,0x5e,0x6b,0x76,0x7a,0x78,0x6f,0x65,
0x61,0x61,0x67,0x70,0x78,0x7c,0x7d,0x82,0x89,0x95,0xa0,0xa4,0x9c,0x8b,0x75,0x60,
0x55,0x54,0x5d,0x6c,0x76,0x7e,0x87,0x8f,0x97,0x9d,0xa2,0xa2,0xa2,0x9e,0x9a,0x92,
0x88,0x7b,0x6d,0x60,0x5c,0x60,0x6c,0x79,0x82,0x85,0x7e,0x73,0x68,0x62,0x62,0x69,
0x70,0x77,0x78,0x74,0x6c,0x62,0x60,0x62,0x65,0x6a,0x6d,0x71,0x74,0x76,0x7b,0x85,
0x92,0x9f,0xac,0xb1,0xae,0xa5,0x9c,0x97,0x98,0x99,0x9a,0x98,0x92,0x85,0x75,0x65,
0x59,0x50,0x4a,0x43,0x3b,0x36,0x39,0x46,0x56,0x6d,0x7c,0x83,0x81,0x76,0x68,0x5d,
0x5f,0x68,0x75,0x7e,0x80,0x79,0x6e,0x65,0x62,0x62,0x60,0x59,0x4f,0x3f,0x30,0x2d,
0x38,0x4f,0x6b,0x7c,0x82,0x7e,0x75,0x6a,0x60,0x58,0x53,0x4b,0x43,0x3b,0x39,0x42,
0x51,0x64,0x77,0x86,0x91,0x97,0x9a,0x9a,0x97,0x8c,0x7c,0x6a,0x5b,0x55,0x5c,0x69,
0x76,0x7d,0x7f,0x7b,0x71,0x68,0x62,0x5f,0x59,0x4d,0x3d,0x33,0x30,0x38,0x4a,0x5f,
0x74,0x87,0x92,0x96,0x96,0x97,0x9a,0x9f,0xa2,0xa2,0x9d,0x94,0x86,0x75,0x67,0x5e,
0x5f,0x65,0x70,0x79,0x80,0x7e,0x78,0x6e,0x66,0x62,0x5d,0x55,0x4a,0x3c,0x35,0x31,
0x38,0x4e,0x66,0x7b,0x83,0x7f,0x71,0x65,0x5b,0x54,0x4c,0x48,0x42,0x3b,0x35,0x30,
0x2d,0x31,0x36,0x3f,0x4c,0x5c,0x6a,0x75,0x77,0x73,0x6d,0x65,0x5b,0x52,0x4b,0x45,
0x3c,0x34,0x32,0x39,0x4a,0x5f,0x73,0x85,0x93,0x9a,0x9e,0x99,0x8f,0x86,0x7c,0x6f,
0x60,0x4f,0x46,0x3f,0x3b,0x38,0x38,0x40,0x4e,0x5e,0x71,0x80,0x8c,0x92,0x93,0x91,
0x8e,0x89,0x7d,0x6c,0x5b,0x4c,0x42,0x3e,0x3f,0x40,0x40,0x3b,0x34,0x2f,0x32,0x3c,
0x48,0x53,0x5f,0x6a,0x75,0x80,0x8c,0x95,0x9c,0x9d,0x94,0x82,0x6e,0x5e,0x57,0x58,
0x62,0x6e,0x7a,0x7f,0x7b,0x71,0x68,0x65,0x67,0x67,0x6e,0x72,0x76,0x7c,0x81,0x8a,
0x96,0x9f,0xa6,0xac,0xaa,0xa6,0x9f,0x91,0x80,0x71,0x66,0x60,0x5e,0x63,0x6a,0x71,
0x79,0x7f,0x87,0x90,0x9a,0x9e,0x9a,0x8c,0x79,0x64,0x51,0x44,0x3e,0x3d,0x3b,0x37,
0x33,0x31,0x33,0x3a,0x3f,0x41,0x40,0x3b,0x34,0x31,0x35,0x42,0x53,0x63,0x70,0x7b,
0x85,0x8f,0x97,0x9e,0xa1,0xa2,0xa2,0xa0,0x9e,0x9e,0x9d,0x9d,0x9d,0x9e,0xa0,0xa3,
0xa4,0xa0,0x9b,0x92,0x85,0x73,0x62,0x57,0x4e,0x48,0x42,0x3c,0x39,0x35,0x32,0x30,
0x2f,0x33,0x3b,0x47,0x53,0x5f,0x6e,0x7b,0x86,0x91,0x98,0x9a,0x97,0x8d,0x7f,0x73,
0x63,0x53,0x48,0x40,0x3c,0x39,0x40,0x46,0x52,0x61,0x70,0x7a,0x88,0x90,0x96,0x9a,
0x96,0x8c,0x7e,0x6f,0x62,0x5d,0x5e,0x65,0x6e,0x77,0x7e,0x87,0x8f,0x96,0x9d,0x9c,
0x94,0x84,0x73,0x62,0x59,0x5d,0x68,0x76,0x81,0x87,0x8c,0x8f,0x93,0x98,0x9d,0xa0,
0x9f,0x9a,0x98,0x94,0x96,0x9b,0xa0,0xa2,0xa3,0xa3,0xa2,0xa3,0x9f,0x96,0x88,0x77,
0x66,0x5c,0x5c,0x61,0x68,0x6f,0x75,0x7b,0x84,0x8d,0x95,0x9b,0x9b,0x91,0x80,0x6c,
0x5d,0x58,0x5a,0x62,0x6e,0x7a,0x85,0x8c,0x92,0x96,0x97,0x96,0x8c,0x7c,0x6c,0x59,
0x49,0x40,0x3d,0x3d,0x3c,0x3d,0x38,0x33,0x31,0x33,0x36,0x43,0x4e,0x5b,0x6b,0x78,
0x82,0x8b,0x94,0x98,0x98,0x8e,0x81,0x73,0x66,0x5d,0x5a,0x5f,0x6c,0x79,0x85,0x90,
0x97,0x9c,0x9e,0xa0,0xa0,0xa0,0x9e,0x98,0x8d,0x80,0x71,0x65,0x5c,0x5b,0x61,0x6e,
0x76,0x7b,0x78,0x72,0x6d,0x63,0x59,0x56,0x50,0x4a,0x43,0x3b,0x34,0x32,0x34,0x37,
0x3d,0x46,0x53,0x5e,0x69,0x71,0x76,0x75,0x6e,0x61,0x5b,0x5d,0x66,0x73,0x7a,0x7d,
0x79,0x6d,0x62,0x5b,0x5a,0x5c,0x5b,0x52,0x44,0x36,0x2e,0x2b,0x2d,0x35,0x3f,0x48,
0x4f,0x56,0x5f,0x6a,0x77,0x81,0x8a,0x93,0x9d,0xa2,0xa8,0xa7,0xa1,0x99,0x8d,0x7e,
0x73,0x67,0x5c,0x53,0x4a,0x43,0x41,0x3f,0x3c,0x39,0x36,0x36,0x36,0x3b,0x48,0x59,
0x6b,0x76,0x78,0x73,0x6b,0x64,0x5f,0x59,0x53,0x48,0x3e,0x35,0x32,0x38,0x48,0x5d,
0x73,0x85,0x94,0x9d,0x9e,0x98,0x93,0x87,0x79,0x6d,0x5f,0x53,0x49,0x3f,0x37,0x35,
0x3a,0x48,0x5a,0x6a,0x76,0x7d,0x7c,0x74,0x67,0x5e,0x57,0x52,0x4b,0x42,0x38,0x38,
0x43,0x53,0x69,0x7a,0x83,0x7f,0x73,0x64,0x57,0x51,0x4e,0x49,0x3f,0x34,0x2d,0x2e,
0x31,0x39,0x40,0x42,0x3d,0x37,0x32,0x34,0x36,0x3a,0x37,0x31,0x30,0x34,0x3f,0x55,
0x68,0x78,0x7f,0x79,0x6c,0x61,0x5c,0x5d,0x64,0x6a,0x70,0x74,0x7a,0x7d,0x85,0x92,
0x9e,0xa6,0xa9,0xa7,0xa0,0x98,0x8a,0x7c,0x70,0x67,0x60,0x58,0x51,0x4a,0x43,0x3c,
0x39,0x3d,0x4a,0x5f,0x71,0x7f,0x89,0x8f,0x95,0x98,0x9a,0x9f,0xa3,0xa2,0x9b,0x8e,
0x7f,0x70,0x64,0x59,0x51,0x4a,0x44,0x3d,0x3b,0x36,0x34,0x39,0x3b,0x3b,0x3b,0x38,
0x34,0x32,0x32,0x34,0x35,0x35,0x32,0x32,0x3b,0x49,0x5c,0x6c,0x77,0x7d,0x7d,0x75,
0x6a,0x64,0x62,0x66,0x6d,0x73,0x78,0x7e,0x85,0x8c,0x94,0x9e,0xa6,0xa9,0xaa,0xa4,
0x9a,0x8f,0x82,0x75,0x6a,0x64,0x61,0x64,0x6a,0x73,0x7c,0x85,0x8c,0x92,0x9a,0x9d,
0x9b,0x92,0x83,0x70,0x5e,0x4e,0x43,0x3b,0x3b,0x3c,0x41,0x49,0x55,0x65,0x73,0x80,
0x88,0x91,0x96,0x98,0x95,0x8b,0x7d,0x70,0x62,0x59,0x59,0x61,0x6d,0x7a,0x83,0x8b,
0x92,0x9a,0x9f,0xa0,0x9a,0x8a,0x73,0x62,0x54,0x56,0x63,0x74,0x80,0x82,0x7a,0x6d,
0x60,0x5a,0x5f,0x6a,0x74,0x7a,0x79,0x74,0x6d,0x67,0x64,0x63,0x61,0x5d,0x54,0x46,
0x38,0x33,0x3b,0x50,0x69,0x80,0x8d,0x8d,0x7f,0x6b,0x5c,0x58,0x60,0x6e,0x79,0x7d,
0x7d,0x75,0x6a,0x60,0x60,0x65,0x6e,0x76,0x79,0x77,0x74,0x6c,0x63,0x5f,0x5d,0x5d,
0x59,0x4f,0x42,0x36,0x2d,0x28,0x2a,0x33,0x3d,0x43,0x43,0x40,0x3b,0x35,0x33,0x32,
0x34,0x37,0x39,0x3a,0x37,0x34,0x36,0x38,0x36,0x33,0x32,0x33,0x37,0x38,0x36,0x34,
0x38,0x37,0x34,0x37,0x39,0x3c,0x3d,0x3c,0x3b,0x3b,0x3d,0x3c,0x39,0x36,0x34,0x33,
// Line 18
0x39,0x38,0x37,0x36,0x36,0x38,0x38,0x38,0x37,0x36,0x36,0x34,0x33,0x34,0x36,0x38,
0x3b,0x3b,0x39,0x39,0x38,0x38,0x39,0x3c,0x3f,0x40,0x3c,0x34,0x2c,0x2c,0x31,0x38,
0x40,0x42,0x3e,0x35,0x2d,0x2a,0x31,0x3c,0x46,0x47,0x41,0x33,0x27,0x24,0x2a,0x36,
0x44,0x48,0x3f,0x32,0x25,0x20,0x28,0x38,0x45,0x4a,0x45,0x38,0x2b,0x27,0x2f,0x3d,
0x4b,0x4b,0x42,0x32,0x26,0x23,0x2d,0x3c,0x48,0x4b,0x42,0x31,0x26,0x24,0x2f,0x3e,
0x47,0x49,0x40,0x32,0x25,0x21,0x29,0x39,0x43,0x46,0x3f,0x32,0x27,0x24,0x2c,0x3e,
0x4c,0x50,0x45,0x38,0x2a,0x25,0x2d,0x3b,0x47,0x4d,0x45,0x34,0x25,0x22,0x2a,0x39,
0x45,0x48,0x41,0x31,0x24,0x1f,0x2a,0x3b,0x49,0x4e,0x44,0x32,0x24,0x1f,0x28,0x39,
0x46,0x49,0x42,0x33,0x25,0x21,0x2a,0x3b,0x4a,0x4d,0x42,0x32,0x26,0x22,0x2c,0x3a,
0x4a,0x51,0x4e,0x42,0x37,0x36,0x3f,0x4e,0x5b,0x60,0x5b,0x4a,0x40,0x3b,0x43,0x51,
0x5d,0x62,0x5d,0x4f,0x40,0x3c,0x43,0x51,0x5e,0x62,0x5a,0x4b,0x3f,0x3b,0x43,0x53,
0x60,0x64,0x5d,0x4e,0x3f,0x3b,0x43,0x53,0x62,0x65,0x5d,0x4e,0x3f,0x39,0x42,0x52,
0x61,0x64,0x5a,0x48,0x39,0x36,0x3f,0x4f,0x5c,0x61,0x59,0x4a,0x3b,0x36,0x3f,0x52,
0x5f,0x63,0x5b,0x4b,0x3c,0x3c,0x42,0x51,0x62,0x66,0x5d,0x4d,0x40,0x3b,0x43,0x52,
0x60,0x63,0x5b,0x4b,0x3e,0x3c,0x47,0x59,0x6a,0x71,0x6d,0x60,0x54,0x50,0x58,0x68,
0x74,0x78,0x6f,0x60,0x53,0x4e,0x54,0x64,0x72,0x79,0x71,0x62,0x54,0x50,0x5a,0x69,
0x76,0x7a,0x72,0x63,0x56,0x51,0x58,0x68,0x75,0x79,0x72,0x63,0x55,0x51,0x5b,0x6b,
0x7a,0x7f,0x75,0x62,0x55,0x4f,0x57,0x66,0x73,0x78,0x72,0x63,0x53,0x4e,0x57,0x68,
0x75,0x7b,0x72,0x63,0x57,0x55,0x5d,0x6c,0x79,0x7c,0x75,0x66,0x56,0x50,0x55,0x62,
0x6e,0x73,0x6e,0x60,0x53,0x50,0x5a,0x6a,0x78,0x7d,0x78,0x6d,0x62,0x5f,0x65,0x75,
0x86,0x8b,0x85,0x77,0x6a,0x66,0x6b,0x7d,0x89,0x8e,0x89,0x7c,0x6c,0x69,0x6f,0x7d,
0x8b,0x8f,0x88,0x79,0x69,0x63,0x6b,0x79,0x89,0x8e,0x88,0x79,0x6b,0x67,0x6e,0x7d,
0x8b,0x90,0x8a,0x7c,0x6d,0x66,0x6d,0x7c,0x89,0x8d,0x86,0x79,0x6d,0x68,0x6d,0x7b,
0x8b,0x90,0x88,0x7c,0x6d,0x67,0x6f,0x7c,0x88,0x8d,0x85,0x78,0x6d,0x6a,0x70,0x7e,
0x89,0x8c,0x85,0x79,0x6d,0x69,0x71,0x80,0x8e,0x92,0x8b,0x7d,0x6f,0x69,0x6e,0x7c,
0x8b,0x91,0x8e,0x82,0x75,0x73,0x7e,0x8f,0x9d,0xa2,0x9c,0x8d,0x82,0x7f,0x87,0x98,
0xa3,0xa5,0x9f,0x8f,0x83,0x7d,0x88,0x94,0x9f,0xa1,0x9a,0x8c,0x81,0x7e,0x88,0x97,
0xa2,0xa4,0x9d,0x8d,0x80,0x7c,0x82,0x90,0x9e,0xa2,0x98,0x89,0x7d,0x7a,0x83,0x91,
0x9f,0xa4,0x9f,0x90,0x82,0x7e,0x89,0x97,0xa4,0xa7,0x9e,0x8c,0x80,0x7a,0x81,0x90,
0x9e,0xa1,0x9a,0x8c,0x81,0x7e,0x86,0x95,0xa3,0xa6,0x9d,0x8e,0x80,0x7c,0x83,0x91,
0x9d,0xa0,0x9b,0x8e,0x82,0x80,0x89,0x99,0xaa,0xaf,0xa9,0x9d,0x92,0x90,0x99,0xa8,
0xb3,0xb6,0xad,0x9d,0x8f,0x8c,0x95,0xa5,0xb5,0xb8,0xb1,0xa5,0x99,0x95,0x9e,0xab,
0xb7,0xba,0xb1,0xa3,0x97,0x93,0x9a,0xa8,0xb3,0xb7,0xb0,0xa4,0x98,0x95,0x9e,0xac,
0xb6,0xb7,0xb0,0xa3,0x99,0x95,0x9c,0xa9,0xb3,0xb5,0xae,0xa2,0x97,0x93,0x9d,0xa9,
0xb3,0xb6,0xad,0xa1,0x97,0x96,0x9c,0xaa,0xb3,0xb4,0xab,0x9f,0x93,0x90,0x97,0xa5,
0xae,0xaf,0xa5,0x9a,0x93,0x93,0x9b,0xa7,0xb1,0xb5,0xb0,0xa7,0x9e,0x9a,0x9e,0xa4,
0xab,0xad,0xaa,0xa4,0x9f,0x9e,0xa3,0xa9,0xac,0xab,0xaa,0xa6,0xa2,0xa2,0xa3,0xa4,
0xa7,0xa8,0xa8,0xa7,0xa7,0xa7,0xa6,0xa4,0xa2,0xa2,0xa4,0xa8,0xa9,0xa8,0xa5,0xa4,
0xa5,0xa6,0xa7,0xa7,0xa6,0xa4,0xa2,0x9f,0x9f,0xa0,0xa4,0xa5,0xa4,0xa3,0xa2,0xa1,
0xa3,0xa3,0xa4,0xa6,0xa5,0xa4,0xa4,0xa4,0xa0,0x9e,0xa0,0xa4,0xa4,0xa4,0xa3,0xa3,
0xa8,0xaa,0xa8,0xa9,0xa8,0xa8,0xa9,0xa6,0xa3,0xa1,0xa2,0xa1,0xa0,0xa0,0xa1,0xa0,
0x9d,0x93,0x88,0x7e,0x72,0x67,0x5c,0x52,0x47,0x40,0x39,0x36,0x35,0x34,0x34,0x35,
0x37,0x39,0x37,0x35,0x34,0x32,0x33,0x34,0x35,0x37,0x39,0x3b,0x3b,0x39,0x39,0x3c,
0x3f,0x3d,0x3b,0x39,0x38,0x35,0x35,0x34,0x34,0x36,0x38,0x36,0x36,0x35,0x36,0x3b,
0x3b,0x3b,0x3a,0x39,0x39,0x39,0x39,0x39,0x39,0x38,0x35,0x33,0x34,0x35,0x37,0x38,
0x37,0x37,0x38,0x36,0x35,0x36,0x38,0x38,0x36,0x34,0x34,0x35,0x36,0x36,0x37,0x3a,
0x3a,0x38,0x3a,0x37,0x36,0x38,0x38,0x38,0x38,0x39,0x39,0x3b,0x3c,0x3c,0x39,0x39,
0x36,0x34,0x35,0x34,0x35,0x33,0x31,0x30,0x36,0x39,0x3c,0x3d,0x3b,0x38,0x35,0x33,
0x33,0x37,0x3b,0x3b,0x37,0x34,0x33,0x39,0x47,0x5c,0x75,0x8d,0x9d,0xa0,0x9c,0x92,
0x85,0x78,0x6d,0x63,0x57,0x48,0x39,0x2d,0x29,0x2b,0x30,0x37,0x3b,0x3b,0x39,0x34,
0x30,0x31,0x34,0x36,0x37,0x37,0x38,0x39,0x3b,0x39,0x38,0x38,0x36,0x34,0x34,0x33,
0x34,0x39,0x3b,0x3b,0x3a,0x38,0x37,0x39,0x3b,0x3c,0x3b,0x40,0x3f,0x3b,0x37,0x33,
0x32,0x35,0x3b,0x40,0x43,0x3f,0x39,0x36,0x38,0x3f,0x4d,0x57,0x59,0x52,0x46,0x3b,
0x3b,0x4b,0x60,0x72,0x76,0x69,0x54,0x46,0x47,0x5a,0x76,0x8c,0x90,0x7e,0x63,0x4e,
0x4d,0x63,0x82,0x9a,0x9f,0x8c,0x69,0x51,0x4d,0x65,0x89,0xa2,0xa4,0x8f,0x6d,0x54,
0x53,0x69,0x88,0x9f,0x9e,0x85,0x64,0x4d,0x4d,0x5f,0x75,0x83,0x7f,0x6d,0x53,0x42,
0x40,0x4b,0x5b,0x63,0x5d,0x50,0x43,0x3d,0x3d,0x43,0x4b,0x4f,0x4b,0x41,0x36,0x31,
0x33,0x35,0x38,0x38,0x38,0x36,0x36,0x37,0x38,0x35,0x39,0x39,0x38,0x36,0x36,0x36,
0x38,0x34,0x32,0x34,0x34,0x33,0x34,0x36,0x37,0x38,0x38,0x38,0x39,0x3b,0x3b,0x3b,
0x3c,0x3d,0x3c,0x3b,0x38,0x34,0x35,0x36,0x36,0x35,0x33,0x32,0x33,0x32,0x31,0x32,
0x35,0x38,0x38,0x37,0x38,0x38,0x39,0x39,0x37,0x38,0x38,0x39,0x39,0x37,0x36,0x37,
0x37,0x36,0x34,0x36,0x36,0x34,0x34,0x34,0x32,0x34,0x34,0x34,0x37,0x38,0x36,0x35,
0x34,0x34,0x36,0x37,0x38,0x38,0x38,0x39,0x38,0x3a,0x40,0x47,0x50,0x5a,0x66,0x75,
0x85,0x95,0xa2,0xac,0xb4,0xba,0xbe,0xc0,0xc2,0xc4,0xc3,0xc1,0xc0,0xbf,0xc1,0xc3,
0xc4,0xc3,0xc2,0xbf,0xbe,0xbb,0xba,0xba,0xbb,0xbb,0xba,0xb9,0xb9,0xba,0xbb,0xbb,
0xbc,0xbe,0xc0,0xbd,0xbb,0xbb,0xbd,0xbe,0xbf,0xbf,0xbe,0xbf,0xbf,0xbe,0xbd,0xc0,
0xbf,0xbe,0xbd,0xbc,0xba,0xbb,0xb9,0xb8,0xbb,0xbb,0xbb,0xba,0xbb,0xb9,0xb9,0xba,
0xbb,0xb8,0xb7,0xb7,0xb7,0xb8,0xb8,0xba,0xbc,0xba,0xb8,0xb9,0xba,0xba,0xbb,0xba,
0xbb,0xbb,0xbb,0xbb,0xbb,0xbd,0xbd,0xbd,0xbd,0xbd,0xbb,0xbc,0xbc,0xbb,0xbc,0xbe,
0xbf,0xbe,0xbd,0xbd,0xbd,0xbc,0xbc,0xbb,0xbd,0xbe,0xbe,0xbf,0xbf,0xc0,0xc2,0xc0,
0xbd,0xbe,0xbe,0xbe,0xbc,0xba,0xb9,0xb9,0xba,0xb9,0xb9,0xba,0xbb,0xba,0xbb,0xbc,
0xbd,0xbf,0xbf,0xbf,0xc0,0xbf,0xbe,0xbc,0xbb,0xba,0xba,0xbb,0xbb,0xba,0xb9,0xba,
0xba,0xbb,0xbd,0xbf,0xbf,0xbf,0xbc,0xbd,0xc0,0xc1,0xbf,0xbd,0xbd,0xbd,0xbd,0xbd,
0xbd,0xbd,0xbe,0xbd,0xbc,0xba,0xba,0xbd,0xbd,0xbb,0xbb,0xbb,0xbd,0xbb,0xb9,0xb8,
0xb9,0xbb,0xbb,0xba,0xb9,0xb8,0xb8,0xbb,0xbb,0xbb,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,
0xbe,0xbe,0xbd,0xbe,0xbd,0xbc,0xba,0xba,0xba,0xba,0xbb,0xbd,0xbe,0xbf,0xbe,0xbb,
0xbb,0xbc,0xbe,0xbd,0xbc,0xba,0xb9,0xb7,0xb5,0xb3,0xb5,0xb7,0xb8,0xba,0xba,0xba,
0xbc,0xbb,0xba,0xbb,0xbc,0xbe,0xbf,0xbe,0xbb,0xba,0xba,0xba,0xb9,0xb9,0xba,0xb8,
0xb8,0xb7,0xb8,0xbb,0xbc,0xbc,0xbd,0xbc,0xbb,0xba,0xbb,0xbb,0xbb,0xba,0xb9,0xb9,
0xb8,0xb8,0xb9,0xba,0xbb,0xba,0xba,0xba,0xbb,0xbc,0xbd,0xc0,0xc1,0xc0,0xbe,0xbe,
0xbd,0xbe,0xbd,0xbe,0xbf,0xbf,0xbf,0xbf,0xbe,0xbf,0xbf,0xbe,0xbe,0xbd,0xbd,0xbc,
0xba,0xba,0xbd,0xbf,0xbf,0xbf,0xbe,0xbe,0xbd,0xbb,0xba,0xb9,0xbb,0xba,0xba,0xbb,
0xbd,0xbf,0xc0,0xc0,0xbe,0xbe,0xbd,0xbd,0xb9,0xbb,0xba,0xba,0xba,0xb9,0xb9,0xba,
0xba,0xba,0xbb,0xbd,0xbe,0xbe,0xbd,0xbb,0xbb,0xbc,0xbd,0xbb,0xbb,0xba,0xb9,0xb8,
0xb7,0xb7,0xba,0xbc,0xbd,0xbc,0xbc,0xbd,0xc0,0xc0,0xbf,0xbf,0xc0,0xbf,0xbd,0xba,
0xb9,0xb9,0xb9,0xb8,0xb8,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,0xc0,0xbe,0xbd,0xbc,
0xba,0xb6,0xb9,0xb9,0xba,0xba,0xb9,0xb8,0xb9,0xb9,0xba,0xba,0xbb,0xba,0xba,0xba,
0xb9,0xba,0xbc,0xbe,0xbe,0xbd,0xbc,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbb,0xba,0xba,
0xbb,0xbd,0xbe,0xbd,0xbd,0xbc,0xbd,0xbd,0xbd,0xbe,0xbd,0xbc,0xb8,0xb6,0xb5,0xb6,
0xb7,0xb8,0xb9,0xba,0xbb,0xbb,0xbb,0xbd,0xbf,0xc1,0xc1,0xc1,0xbe,0xbb,0xbb,0xbb,
0xba,0xba,0xba,0xba,0xbb,0xba,0xbb,0xbd,0xbe,0xbe,0xbf,0xbf,0xbf,0xbf,0xbd,0xbb,
0xbb,0xbb,0xbb,0xba,0xba,0xbb,0xbc,0xbb,0xbb,0xbd,0xc0,0xc0,0xbe,0xbd,0xbd,0xbd,
0xb8,0xba,0xba,0xba,0xbb,0xbb,0xb9,0xba,0xbb,0xbb,0xbb,0xbb,0xba,0xba,0xb9,0xb8,
0xb9,0xbb,0xbd,0xbd,0xbc,0xbd,0xbd,0xbf,0xbf,0xbe,0xbf,0xbf,0xbc,0xba,0xb8,0xba,
0xbb,0xbb,0xba,0xb9,0xb9,0xba,0xbb,0xba,0xb7,0xb6,0xb5,0xae,0xa5,0x9b,0x91,0x85,
0x77,0x68,0x5b,0x50,0x47,0x3e,0x37,0x35,0x36,0x37,0x38,0x38,0x39,0x39,0x39,0x37,
// Line 19
0x3b,0x3a,0x38,0x38,0x3b,0x3b,0x3a,0x3a,0x3a,0x3a,0x39,0x37,0x36,0x38,0x3a,0x39,
0x38,0x37,0x38,0x3a,0x3c,0x3e,0x40,0x44,0x47,0x49,0x4d,0x52,0x58,0x5c,0x5f,0x60,
0x60,0x60,0x5e,0x5e,0x5e,0x5d,0x5c,0x5b,0x59,0x5a,0x5f,0x62,0x62,0x61,0x60,0x60,
0x60,0x61,0x61,0x5e,0x60,0x5e,0x5c,0x5f,0x62,0x63,0x65,0x64,0x64,0x64,0x65,0x64,
0x66,0x65,0x64,0x62,0x60,0x60,0x60,0x60,0x60,0x5e,0x5e,0x5f,0x60,0x62,0x61,0x60,
0x60,0x61,0x60,0x60,0x5f,0x60,0x63,0x64,0x64,0x63,0x64,0x63,0x60,0x60,0x62,0x62,
0x63,0x60,0x5e,0x5e,0x5d,0x5c,0x60,0x62,0x63,0x62,0x60,0x5e,0x5d,0x5c,0x5b,0x59,
0x59,0x5b,0x5c,0x5c,0x5c,0x5b,0x5d,0x60,0x62,0x62,0x62,0x62,0x62,0x60,0x5d,0x5d,
0x5f,0x60,0x62,0x62,0x60,0x5f,0x60,0x61,0x60,0x64,0x63,0x60,0x5e,0x5c,0x5e,0x60,
0x61,0x61,0x60,0x5f,0x5f,0x5d,0x5e,0x60,0x62,0x60,0x5e,0x5d,0x5d,0x5d,0x5e,0x5d,
0x5c,0x5c,0x5e,0x60,0x5f,0x5e,0x5c,0x5b,0x59,0x58,0x58,0x58,0x58,0x56,0x53,0x53,
0x53,0x55,0x56,0x5a,0x59,0x59,0x56,0x55,0x53,0x53,0x52,0x50,0x50,0x4f,0x4e,0x50,
0x4f,0x4e,0x50,0x51,0x50,0x4f,0x4f,0x4f,0x4e,0x4b,0x48,0x45,0x45,0x45,0x45,0x44,
0x43,0x41,0x40,0x3f,0x3d,0x3f,0x3f,0x3d,0x3a,0x36,0x35,0x35,0x37,0x37,0x35,0x34,
0x33,0x31,0x31,0x31,0x30,0x2f,0x2d,0x2b,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x32,0x33,
0x33,0x33,0x37,0x39,0x3a,0x3a,0x3c,0x40,0x43,0x44,0x46,0x4b,0x50,0x53,0x56,0x58,
0x5c,0x60,0x64,0x68,0x6a,0x70,0x74,0x77,0x7a,0x7e,0x82,0x89,0x87,0x88,0x8d,0x91,
0x94,0x95,0x96,0x97,0x99,0x9a,0x99,0x97,0x95,0x92,0x8f,0x89,0x84,0x7f,0x7c,0x77,
0x71,0x6c,0x69,0x65,0x60,0x59,0x51,0x4e,0x4b,0x47,0x41,0x39,0x33,0x2e,0x2b,0x29,
0x29,0x28,0x28,0x26,0x29,0x2c,0x32,0x3a,0x3f,0x46,0x4f,0x57,0x5e,0x64,0x6d,0x75,
0x7c,0x81,0x86,0x8b,0x94,0x96,0x95,0x96,0x95,0x93,0x8f,0x89,0x82,0x7b,0x74,0x6c,
0x64,0x5b,0x53,0x4c,0x46,0x41,0x3c,0x38,0x33,0x2e,0x2f,0x30,0x31,0x32,0x33,0x37,
0x3d,0x44,0x4b,0x55,0x60,0x6a,0x74,0x7e,0x85,0x89,0x92,0x94,0x93,0x91,0x8d,0x87,
0x80,0x74,0x69,0x60,0x59,0x52,0x4a,0x41,0x3a,0x34,0x31,0x2f,0x2e,0x2f,0x33,0x39,
0x41,0x47,0x50,0x5c,0x67,0x73,0x80,0x8c,0x95,0x97,0x96,0x93,0x8d,0x85,0x7a,0x71,
0x67,0x5a,0x4c,0x41,0x39,0x34,0x34,0x32,0x31,0x35,0x3a,0x41,0x48,0x53,0x60,0x6d,
0x7b,0x85,0x8a,0x91,0x92,0x8d,0x87,0x7e,0x74,0x69,0x5c,0x4f,0x46,0x3f,0x3a,0x36,
0x34,0x37,0x3c,0x44,0x4e,0x59,0x68,0x75,0x7e,0x86,0x8b,0x8d,0x89,0x81,0x76,0x6c,
0x62,0x55,0x47,0x3d,0x35,0x33,0x33,0x36,0x3c,0x44,0x51,0x5e,0x6d,0x7a,0x85,0x8d,
0x8f,0x8b,0x84,0x78,0x6c,0x5f,0x53,0x47,0x3e,0x36,0x32,0x31,0x37,0x41,0x4e,0x5f,
0x6f,0x7c,0x87,0x89,0x86,0x83,0x7d,0x74,0x65,0x5a,0x4c,0x41,0x38,0x32,0x2f,0x39,
0x42,0x4f,0x5f,0x70,0x7e,0x88,0x8a,0x84,0x7a,0x6f,0x64,0x58,0x4c,0x41,0x37,0x33,
0x33,0x39,0x47,0x58,0x6c,0x7d,0x87,0x8c,0x8a,0x82,0x76,0x6b,0x5e,0x52,0x45,0x3b,
0x34,0x35,0x3e,0x4b,0x5c,0x6f,0x80,0x89,0x8b,0x84,0x79,0x6b,0x5b,0x4c,0x41,0x38,
0x33,0x31,0x38,0x47,0x5b,0x71,0x81,0x89,0x8d,0x85,0x77,0x69,0x5b,0x4f,0x44,0x3b,
0x37,0x3b,0x47,0x58,0x6b,0x79,0x82,0x83,0x7f,0x74,0x67,0x59,0x4b,0x40,0x39,0x38,
0x40,0x4e,0x60,0x71,0x80,0x87,0x85,0x7a,0x6c,0x5c,0x4f,0x43,0x3a,0x37,0x3e,0x48,
0x58,0x6d,0x7d,0x87,0x89,0x80,0x6f,0x5f,0x50,0x44,0x3d,0x3a,0x40,0x4b,0x5f,0x71,
0x7e,0x85,0x83,0x7a,0x6b,0x59,0x4b,0x41,0x3e,0x41,0x4b,0x58,0x68,0x76,0x7f,0x80,
0x78,0x69,0x58,0x4b,0x43,0x40,0x42,0x4c,0x5b,0x6b,0x76,0x7d,0x7b,0x74,0x69,0x5c,
0x4f,0x47,0x45,0x4d,0x59,0x64,0x6d,0x75,0x77,0x72,0x68,0x5b,0x50,0x4b,0x4b,0x51,
0x5a,0x65,0x71,0x77,0x76,0x6f,0x66,0x5c,0x53,0x4c,0x4c,0x53,0x5d,0x69,0x72,0x78,
0x76,0x6c,0x5f,0x54,0x4c,0x49,0x4a,0x56,0x60,0x68,0x6f,0x70,0x6b,0x65,0x5f,0x55,
0x4f,0x4e,0x54,0x5e,0x65,0x6a,0x6c,0x6b,0x65,0x5c,0x53,0x4c,0x4c,0x53,0x5a,0x60,
0x66,0x68,0x67,0x63,0x5d,0x59,0x58,0x5a,0x5d,0x64,0x69,0x6d,0x6c,0x65,0x5d,0x59,
0x58,0x59,0x5c,0x64,0x69,0x6b,0x69,0x65,0x60,0x5e,0x5c,0x5b,0x5d,0x62,0x66,0x68,
0x65,0x5d,0x56,0x53,0x54,0x59,0x62,0x69,0x6d,0x6f,0x68,0x60,0x58,0x53,0x53,0x58,
0x61,0x6a,0x6d,0x6b,0x63,0x5a,0x53,0x4f,0x52,0x5d,0x69,0x72,0x75,0x6d,0x61,0x55,
0x4b,0x48,0x50,0x5f,0x6e,0x76,0x71,0x65,0x56,0x4b,0x44,0x48,0x58,0x6b,0x79,0x7e,
0x74,0x63,0x51,0x45,0x44,0x51,0x65,0x76,0x7c,0x75,0x64,0x50,0x41,0x3e,0x47,0x5b,
0x6f,0x7c,0x7a,0x6a,0x54,0x44,0x41,0x49,0x5d,0x75,0x85,0x80,0x6f,0x53,0x3f,0x3b,
0x49,0x5f,0x77,0x82,0x7d,0x6c,0x53,0x3f,0x3c,0x4b,0x60,0x77,0x81,0x7b,0x64,0x4a,
0x37,0x38,0x4b,0x68,0x7d,0x86,0x7a,0x60,0x45,0x35,0x3f,0x5c,0x7a,0x89,0x86,0x6e,
0x51,0x3b,0x3a,0x4c,0x6b,0x84,0x8a,0x79,0x59,0x3d,0x32,0x41,0x5d,0x79,0x87,0x80,
0x66,0x48,0x37,0x3e,0x56,0x74,0x84,0x81,0x6c,0x4f,0x38,0x3c,0x53,0x71,0x88,0x87,
0x70,0x53,0x3e,0x3b,0x4f,0x6d,0x83,0x83,0x6d,0x4f,0x3a,0x3b,0x52,0x6f,0x83,0x80,
0x69,0x4e,0x3e,0x42,0x58,0x72,0x80,0x7b,0x63,0x47,0x3b,0x44,0x5d,0x78,0x84,0x7b,
0x63,0x4b,0x43,0x50,0x6b,0x7e,0x80,0x6e,0x54,0x40,0x41,0x54,0x6f,0x80,0x7d,0x65,
0x4b,0x41,0x4c,0x62,0x79,0x7b,0x6e,0x58,0x45,0x44,0x55,0x6d,0x7b,0x76,0x61,0x4e,
0x47,0x53,0x68,0x79,0x7b,0x6d,0x58,0x4b,0x4e,0x5f,0x74,0x7b,0x70,0x5c,0x4c,0x4b,
0x58,0x69,0x75,0x71,0x62,0x51,0x4d,0x58,0x6a,0x76,0x76,0x67,0x55,0x4d,0x53,0x60,
0x6d,0x71,0x66,0x58,0x4f,0x52,0x60,0x6d,0x6f,0x67,0x5b,0x53,0x53,0x5c,0x68,0x6d,
0x6a,0x5e,0x54,0x54,0x5d,0x69,0x6e,0x68,0x5e,0x55,0x59,0x60,0x6b,0x70,0x6d,0x62,
0x5a,0x58,0x5d,0x68,0x6d,0x6a,0x61,0x59,0x57,0x5c,0x64,0x6b,0x6a,0x64,0x5d,0x5a,
0x5e,0x65,0x6a,0x6a,0x63,0x5c,0x5c,0x5f,0x64,0x67,0x65,0x60,0x5c,0x5b,0x5f,0x64,
0x67,0x64,0x60,0x5e,0x5e,0x62,0x65,0x64,0x62,0x60,0x5e,0x5d,0x61,0x65,0x67,0x67,
0x63,0x5f,0x5d,0x63,0x65,0x65,0x63,0x60,0x5c,0x5e,0x5f,0x60,0x63,0x62,0x5f,0x5f,
0x60,0x61,0x64,0x64,0x64,0x62,0x62,0x60,0x60,0x62,0x64,0x65,0x63,0x60,0x5f,0x63,
0x65,0x63,0x61,0x60,0x60,0x62,0x62,0x63,0x63,0x64,0x64,0x64,0x64,0x66,0x66,0x69,
0x65,0x62,0x63,0x62,0x61,0x60,0x61,0x60,0x61,0x60,0x60,0x60,0x62,0x64,0x63,0x64,
0x64,0x64,0x64,0x61,0x60,0x63,0x64,0x64,0x63,0x62,0x61,0x62,0x62,0x60,0x61,0x61,
0x60,0x5f,0x5f,0x60,0x61,0x63,0x64,0x63,0x64,0x64,0x63,0x61,0x5f,0x5d,0x5d,0x5e,
0x5f,0x5f,0x60,0x60,0x60,0x60,0x62,0x64,0x64,0x62,0x61,0x64,0x63,0x60,0x60,0x60,
0x60,0x60,0x62,0x63,0x63,0x63,0x62,0x61,0x60,0x61,0x63,0x64,0x63,0x60,0x60,0x60,
0x5f,0x5e,0x5d,0x5e,0x5f,0x5e,0x5e,0x5f,0x60,0x60,0x60,0x62,0x63,0x65,0x67,0x65,
0x63,0x61,0x61,0x62,0x64,0x63,0x62,0x62,0x60,0x5e,0x5e,0x60,0x61,0x62,0x63,0x61,
0x5f,0x5f,0x5f,0x5f,0x63,0x64,0x63,0x62,0x60,0x60,0x61,0x62,0x61,0x5e,0x60,0x60,
0x60,0x62,0x64,0x65,0x68,0x63,0x62,0x64,0x66,0x67,0x65,0x64,0x63,0x62,0x60,0x60,
0x60,0x60,0x60,0x5e,0x5d,0x5c,0x5e,0x61,0x60,0x5f,0x60,0x62,0x64,0x63,0x61,0x62,
0x63,0x63,0x61,0x60,0x60,0x5e,0x5d,0x5d,0x5f,0x61,0x64,0x61,0x5f,0x5f,0x60,0x61,
0x63,0x65,0x65,0x64,0x61,0x5e,0x5d,0x5e,0x5e,0x5d,0x5d,0x5c,0x5c,0x5e,0x60,0x60,
0x63,0x65,0x65,0x65,0x63,0x62,0x64,0x64,0x63,0x63,0x63,0x62,0x60,0x60,0x60,0x61,
0x61,0x61,0x61,0x61,0x62,0x62,0x63,0x63,0x63,0x65,0x65,0x64,0x62,0x60,0x60,0x60,
0x5e,0x5e,0x5e,0x60,0x60,0x5e,0x5f,0x60,0x60,0x62,0x62,0x62,0x64,0x64,0x63,0x63,
0x63,0x62,0x60,0x60,0x60,0x5f,0x5e,0x5d,0x5c,0x5d,0x5e,0x5f,0x60,0x5f,0x5f,0x62,
0x64,0x64,0x62,0x60,0x60,0x5e,0x5d,0x5f,0x60,0x62,0x62,0x60,0x60,0x62,0x62,0x64,
0x63,0x63,0x64,0x64,0x62,0x5e,0x5f,0x60,0x60,0x5f,0x5e,0x5f,0x61,0x62,0x62,0x64,
0x65,0x65,0x64,0x63,0x62,0x63,0x65,0x65,0x63,0x60,0x60,0x60,0x60,0x61,0x62,0x63,
0x62,0x5f,0x5e,0x5c,0x5b,0x5c,0x5c,0x5d,0x60,0x60,0x60,0x5d,0x5e,0x5d,0x5e,0x5f,
0x5d,0x58,0x55,0x4e,0x45,0x40,0x3d,0x3c,0x3d,0x3b,0x38,0x37,0x38,0x38,0x36,0x35,
0x35,0x37,0x37,0x35,0x33,0x33,0x34,0x34,0x35,0x35,0x37,0x3a,0x39,0x37,0x36,0x36,
0x35,0x34,0x34,0x35,0x37,0x36,0x34,0x33,0x35,0x35,0x35,0x36,0x38,0x39,0x3a,0x38,
0x35,0x36,0x38,0x37,0x35,0x33,0x33,0x34,0x34,0x33,0x32,0x33,0x34,0x33,0x34,0x34,
0x35,0x37,0x36,0x36,0x38,0x3a,0x3b,0x3c,0x3c,0x3a,0x3b,0x3a,0x38,0x35,0x34,0x33,
0x33,0x34,0x34,0x36,0x39,0x38,0x37,0x37,0x38,0x38,0x37,0x37,0x36,0x36,0x38,0x38,
0x35,0x35,0x35,0x34,0x34,0x35,0x35,0x35,0x34,0x32,0x33,0x36,0x38,0x38,0x3a,0x3a,
// Line 20
0x38,0x36,0x36,0x37,0x38,0x39,0x3b,0x3e,0x3f,0x3c,0x3a,0x3b,0x3d,0x3b,0x36,0x33,
0x32,0x33,0x32,0x31,0x32,0x33,0x35,0x35,0x36,0x37,0x3b,0x42,0x47,0x4d,0x56,0x61,
0x6d,0x7d,0x8c,0x9b,0xa7,0xb0,0xb7,0xbd,0xc2,0xc4,0xc4,0xc3,0xc1,0xbf,0xbe,0xbc,
0xbc,0xbf,0xc0,0xbf,0xbf,0xbd,0xbe,0xbe,0xbe,0xbc,0xbd,0xbd,0xbc,0xb9,0xb9,0xb9,
0xba,0xbc,0xbb,0xba,0xba,0xba,0xba,0xbb,0xbd,0xbe,0xbf,0xbc,0xba,0xba,0xbc,0xbe,
0xbf,0xbe,0xbd,0xbc,0xbd,0xbc,0xbc,0xbf,0xc1,0xc1,0xbf,0xbc,0xbc,0xbb,0xbb,0xbc,
0xbd,0xbe,0xbd,0xba,0xb8,0xb7,0xb7,0xba,0xbc,0xbb,0xbc,0xbc,0xbb,0xbc,0xbc,0xbd,
0xbf,0xbf,0xbc,0xba,0xba,0xba,0xbb,0xba,0xbc,0xbc,0xbe,0xbe,0xbd,0xbe,0xbe,0xbd,
0xbe,0xbd,0xbd,0xbd,0xba,0xb8,0xb8,0xb9,0xb9,0xba,0xba,0xbb,0xbb,0xbc,0xbd,0xbe,
0xbe,0xbf,0xbf,0xbf,0xbd,0xbd,0xbb,0xbd,0xbb,0xba,0xba,0xbc,0xbc,0xbd,0xbd,0xbe,
0xc0,0xbf,0xbe,0xbd,0xbc,0xbb,0xbc,0xbd,0xbd,0xbd,0xbd,0xbc,0xbd,0xbd,0xbd,0xbd,
0xbd,0xbb,0xba,0xbc,0xbc,0xbb,0xba,0xbc,0xbf,0xc1,0xc1,0xc1,0xc2,0xbf,0xbc,0xba,
0xb9,0xba,0xba,0xb9,0xb7,0xb4,0xb2,0xae,0xa8,0xa2,0x9c,0x95,0x8e,0x85,0x7f,0x7b,
0x76,0x72,0x6e,0x6d,0x6e,0x6f,0x6e,0x6e,0x6f,0x72,0x74,0x72,0x71,0x72,0x73,0x74,
0x74,0x73,0x72,0x72,0x70,0x6d,0x6d,0x70,0x72,0x72,0x71,0x70,0x72,0x71,0x70,0x70,
0x71,0x73,0x73,0x72,0x70,0x6e,0x70,0x6e,0x6d,0x6c,0x6d,0x6c,0x6d,0x6d,0x6c,0x6d,
0x6e,0x6d,0x71,0x73,0x74,0x75,0x74,0x74,0x74,0x75,0x74,0x74,0x78,0x7c,0x80,0x84,
0x87,0x8a,0x8f,0x92,0x95,0x95,0x98,0x99,0x98,0x95,0x93,0x92,0x91,0x8c,0x88,0x84,
0x81,0x7d,0x78,0x72,0x6e,0x6b,0x68,0x64,0x60,0x5c,0x5b,0x5a,0x55,0x4e,0x4b,0x4a,
0x49,0x46,0x44,0x44,0x46,0x47,0x47,0x48,0x4d,0x50,0x53,0x56,0x5a,0x5d,0x62,0x66,
0x6b,0x70,0x75,0x7a,0x80,0x84,0x88,0x8b,0x8f,0x91,0x95,0x9a,0x9c,0x9d,0x9c,0x9a,
0x99,0x9a,0x99,0x96,0x94,0x90,0x8a,0x86,0x82,0x81,0x7d,0x7b,0x76,0x70,0x6c,0x68,
0x63,0x61,0x5d,0x5b,0x59,0x54,0x50,0x4e,0x4f,0x4c,0x49,0x48,0x49,0x45,0x48,0x47,
0x48,0x4b,0x4e,0x52,0x58,0x5b,0x5f,0x65,0x69,0x6c,0x70,0x74,0x78,0x7b,0x80,0x84,
0x89,0x8d,0x90,0x94,0x98,0x99,0x9a,0x9b,0x9a,0x99,0x9a,0x98,0x95,0x93,0x91,0x8f,
0x8b,0x88,0x87,0x83,0x7d,0x76,0x70,0x6d,0x67,0x61,0x60,0x5a,0x58,0x57,0x56,0x53,
0x51,0x4e,0x4b,0x4a,0x49,0x49,0x4a,0x4a,0x48,0x49,0x4c,0x50,0x53,0x57,0x5b,0x5f,
0x64,0x68,0x6c,0x70,0x75,0x7a,0x7e,0x83,0x89,0x8c,0x8f,0x91,0x90,0x91,0x94,0x97,
0x9a,0x99,0x9a,0x9c,0x9c,0x9a,0x99,0x96,0x92,0x8f,0x8a,0x86,0x81,0x7b,0x76,0x70,
0x6d,0x67,0x64,0x61,0x60,0x5d,0x5b,0x57,0x53,0x53,0x53,0x50,0x4e,0x4c,0x4b,0x49,
0x49,0x47,0x49,0x50,0x55,0x5a,0x5f,0x64,0x68,0x6e,0x70,0x71,0x72,0x72,0x72,0x72,
0x70,0x70,0x72,0x71,0x70,0x6f,0x70,0x70,0x70,0x70,0x70,0x70,0x72,0x72,0x70,0x71,
0x71,0x70,0x70,0x70,0x72,0x72,0x72,0x72,0x70,0x70,0x6f,0x6e,0x6d,0x6d,0x6d,0x6e,
0x6f,0x6f,0x70,0x70,0x72,0x74,0x74,0x74,0x72,0x72,0x71,0x72,0x73,0x74,0x74,0x77,
0x74,0x73,0x74,0x73,0x72,0x72,0x72,0x6f,0x6d,0x6b,0x6c,0x6d,0x70,0x71,0x70,0x72,
0x72,0x70,0x70,0x6b,0x66,0x64,0x60,0x5b,0x56,0x53,0x50,0x53,0x57,0x5d,0x64,0x6d,
0x77,0x81,0x8b,0x91,0x95,0x94,0x8f,0x89,0x81,0x77,0x6d,0x62,0x5a,0x53,0x4d,0x49,
0x46,0x49,0x52,0x57,0x5c,0x65,0x70,0x7d,0x87,0x8b,0x8f,0x91,0x92,0x90,0x89,0x80,
0x75,0x6d,0x66,0x5d,0x52,0x4d,0x4a,0x4a,0x4d,0x4e,0x52,0x5a,0x64,0x6e,0x79,0x81,
0x89,0x8c,0x90,0x8e,0x89,0x83,0x7d,0x76,0x6e,0x63,0x59,0x53,0x4e,0x4d,0x4d,0x4e,
0x50,0x56,0x5e,0x66,0x6d,0x76,0x82,0x8e,0x93,0x92,0x8c,0x8b,0x85,0x7d,0x74,0x6c,
0x62,0x5c,0x53,0x4b,0x4b,0x4d,0x50,0x53,0x57,0x5c,0x66,0x70,0x7b,0x84,0x8c,0x8f,
0x90,0x8f,0x8e,0x8b,0x84,0x79,0x6c,0x60,0x54,0x4e,0x4a,0x4a,0x4d,0x50,0x52,0x53,
0x58,0x64,0x72,0x7f,0x8a,0x91,0x94,0x93,0x8d,0x87,0x82,0x7d,0x76,0x6b,0x5f,0x56,
0x4f,0x4b,0x49,0x4a,0x4f,0x54,0x5a,0x61,0x68,0x72,0x7d,0x83,0x85,0x89,0x8a,0x87,
0x7f,0x79,0x73,0x70,0x6e,0x6b,0x67,0x6c,0x6d,0x6d,0x6e,0x70,0x71,0x72,0x71,0x6f,
0x6e,0x6f,0x70,0x6e,0x6d,0x6d,0x70,0x70,0x6f,0x6d,0x6d,0x6d,0x6b,0x6b,0x6b,0x6d,
0x6f,0x6f,0x6e,0x70,0x70,0x72,0x70,0x6f,0x6f,0x70,0x72,0x70,0x6e,0x6f,0x6d,0x6c,
0x6d,0x6e,0x6e,0x72,0x72,0x70,0x6e,0x6e,0x70,0x70,0x70,0x70,0x71,0x72,0x70,0x70,
0x72,0x72,0x70,0x70,0x70,0x6e,0x6b,0x66,0x64,0x65,0x6b,0x72,0x77,0x7d,0x83,0x86,
0x83,0x7b,0x72,0x6b,0x64,0x5c,0x56,0x53,0x55,0x5e,0x69,0x73,0x7e,0x87,0x8a,0x87,
0x7d,0x6e,0x63,0x59,0x53,0x4f,0x53,0x59,0x64,0x71,0x7f,0x89,0x8c,0x89,0x81,0x78,
0x6d,0x61,0x55,0x4d,0x4b,0x52,0x5e,0x6c,0x79,0x88,0x8e,0x8b,0x83,0x79,0x70,0x67,
0x5e,0x56,0x52,0x53,0x5b,0x65,0x75,0x81,0x8a,0x8c,0x87,0x7b,0x72,0x64,0x5b,0x54,
0x50,0x51,0x59,0x65,0x70,0x7e,0x88,0x8f,0x8b,0x83,0x77,0x6c,0x60,0x56,0x50,0x51,
0x55,0x5f,0x6d,0x7a,0x84,0x8b,0x8b,0x84,0x7a,0x6f,0x64,0x59,0x50,0x4b,0x50,0x5b,
0x69,0x75,0x85,0x8b,0x8b,0x87,0x7e,0x74,0x6f,0x67,0x61,0x5e,0x5c,0x5e,0x63,0x6a,
0x6f,0x75,0x79,0x79,0x76,0x72,0x6e,0x6d,0x6d,0x6b,0x6c,0x6e,0x70,0x6f,0x70,0x72,
0x74,0x73,0x70,0x6d,0x6d,0x6e,0x6e,0x6d,0x6f,0x6e,0x6e,0x70,0x6f,0x6f,0x72,0x71,
0x6e,0x6e,0x6f,0x70,0x70,0x70,0x6f,0x6e,0x6e,0x6e,0x6f,0x72,0x74,0x76,0x74,0x6e,
0x6b,0x69,0x6d,0x72,0x78,0x7a,0x77,0x6e,0x61,0x59,0x5b,0x65,0x72,0x7c,0x80,0x7c,
0x70,0x63,0x59,0x59,0x61,0x6d,0x77,0x7d,0x7b,0x72,0x66,0x60,0x5e,0x66,0x72,0x7f,
0x81,0x81,0x75,0x69,0x61,0x5c,0x5f,0x6a,0x76,0x7d,0x7d,0x75,0x6c,0x62,0x5c,0x5a,
0x61,0x70,0x7d,0x81,0x7f,0x78,0x6e,0x66,0x60,0x60,0x69,0x74,0x7b,0x7d,0x76,0x6d,
0x61,0x57,0x56,0x5f,0x6e,0x7b,0x81,0x7f,0x77,0x6b,0x60,0x58,0x5b,0x66,0x73,0x7b,
0x7d,0x78,0x72,0x69,0x61,0x5d,0x64,0x70,0x7c,0x81,0x7f,0x78,0x6e,0x62,0x5a,0x59,
0x65,0x74,0x7e,0x81,0x7d,0x72,0x66,0x5d,0x5d,0x66,0x72,0x7c,0x7a,0x75,0x6d,0x65,
0x66,0x6b,0x73,0x7b,0x7e,0x7a,0x72,0x6b,0x68,0x67,0x6b,0x6d,0x70,0x74,0x76,0x74,
0x74,0x72,0x70,0x6f,0x6c,0x6b,0x6e,0x6e,0x6f,0x70,0x70,0x72,0x72,0x70,0x6f,0x70,
0x74,0x76,0x75,0x73,0x72,0x6f,0x6f,0x6d,0x6c,0x6c,0x6d,0x6d,0x6d,0x6c,0x6e,0x72,
0x72,0x72,0x72,0x74,0x74,0x72,0x72,0x71,0x72,0x75,0x74,0x71,0x6f,0x6c,0x6b,0x6d,
0x70,0x76,0x78,0x76,0x6d,0x65,0x64,0x6a,0x74,0x7f,0x83,0x7f,0x74,0x65,0x5b,0x5e,
0x6d,0x7d,0x86,0x7f,0x6f,0x5e,0x53,0x57,0x6a,0x81,0x8e,0x87,0x72,0x5c,0x51,0x5c,
0x71,0x86,0x91,0x8c,0x77,0x5e,0x50,0x59,0x6e,0x83,0x8b,0x83,0x6e,0x5a,0x4e,0x59,
0x6c,0x81,0x8f,0x89,0x73,0x5f,0x52,0x59,0x6d,0x83,0x8e,0x87,0x73,0x5c,0x50,0x56,
0x6b,0x81,0x8d,0x87,0x73,0x5d,0x51,0x57,0x6c,0x81,0x8e,0x88,0x72,0x5b,0x50,0x57,
0x6a,0x80,0x8b,0x86,0x6e,0x5a,0x50,0x57,0x6d,0x81,0x8a,0x86,0x71,0x5d,0x53,0x5b,
0x6e,0x81,0x89,0x83,0x72,0x61,0x5b,0x61,0x6d,0x7b,0x83,0x81,0x77,0x6c,0x66,0x69,
0x70,0x77,0x78,0x74,0x70,0x6b,0x69,0x6b,0x6f,0x72,0x74,0x72,0x70,0x6f,0x71,0x72,
0x70,0x6f,0x6d,0x6d,0x6e,0x6e,0x6e,0x6d,0x6d,0x6b,0x6a,0x6d,0x70,0x71,0x73,0x70,
0x6e,0x6e,0x6f,0x6f,0x6e,0x6d,0x6d,0x6d,0x6d,0x6d,0x6e,0x70,0x6f,0x6f,0x71,0x73,
0x74,0x72,0x70,0x6f,0x6f,0x6f,0x71,0x73,0x74,0x72,0x6f,0x6c,0x6c,0x70,0x76,0x78,
0x74,0x6f,0x6b,0x67,0x6c,0x70,0x76,0x7a,0x76,0x6d,0x65,0x64,0x6a,0x74,0x79,0x77,
0x70,0x67,0x62,0x66,0x6e,0x79,0x7d,0x77,0x6d,0x64,0x66,0x6e,0x76,0x7a,0x76,0x6d,
0x66,0x65,0x6c,0x75,0x7b,0x78,0x71,0x69,0x67,0x6c,0x76,0x7a,0x78,0x72,0x6b,0x65,
0x6a,0x72,0x77,0x77,0x70,0x68,0x66,0x6c,0x73,0x78,0x77,0x72,0x69,0x66,0x69,0x71,
0x79,0x78,0x6e,0x64,0x60,0x64,0x70,0x77,0x76,0x6f,0x66,0x63,0x68,0x71,0x7b,0x7d,
0x74,0x68,0x63,0x69,0x74,0x7a,0x79,0x70,0x64,0x61,0x65,0x71,0x7d,0x7d,0x73,0x66,
0x5f,0x62,0x6f,0x7b,0x7e,0x76,0x69,0x5e,0x5e,0x67,0x74,0x7b,0x78,0x6d,0x62,0x60,
0x66,0x70,0x78,0x79,0x72,0x6c,0x68,0x6b,0x6f,0x74,0x75,0x72,0x6d,0x6a,0x6c,0x71,
0x74,0x73,0x6f,0x6c,0x6a,0x6d,0x70,0x73,0x72,0x6f,0x6d,0x6d,0x70,0x72,0x72,0x72,
0x6e,0x6c,0x6d,0x70,0x73,0x75,0x74,0x70,0x6f,0x6d,0x6f,0x70,0x70,0x6d,0x6a,0x6a,
0x6c,0x6e,0x70,0x70,0x6d,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0x6c,0x69,0x6a,0x6c,0x6e,
0x6d,0x6c,0x6c,0x6d,0x6d,0x6d,0x6d,0x70,0x73,0x72,0x70,0x70,0x72,0x74,0x74,0x72,
0x70,0x6d,0x6e,0x6e,0x6d,0x6e,0x6e,0x6d,0x6f,0x6d,0x6c,0x6f,0x70,0x6f,0x6a,0x63,
0x5c,0x56,0x50,0x4b,0x45,0x40,0x3b,0x37,0x34,0x33,0x35,0x36,0x38,0x39,0x3b,0x3a,
// Line 21
0x3a,0x3c,0x3d,0x3c,0x3b,0x3a,0x38,0x37,0x36,0x37,0x39,0x3a,0x39,0x38,0x3a,0x3c,
0x3a,0x38,0x38,0x38,0x39,0x38,0x34,0x31,0x32,0x33,0x35,0x34,0x35,0x35,0x36,0x39,
0x3a,0x3b,0x3c,0x3c,0x3a,0x39,0x39,0x3a,0x3b,0x3a,0x3a,0x3c,0x3d,0x3d,0x3c,0x43,
0x45,0x45,0x46,0x47,0x4a,0x50,0x51,0x4f,0x51,0x53,0x55,0x58,0x5a,0x5d,0x61,0x65,
0x66,0x66,0x66,0x67,0x69,0x6a,0x6a,0x68,0x66,0x64,0x61,0x61,0x60,0x5e,0x5e,0x5a,
0x58,0x55,0x51,0x4e,0x4a,0x48,0x47,0x46,0x45,0x43,0x40,0x3e,0x3b,0x38,0x39,0x3c,
0x3e,0x3f,0x3d,0x3b,0x3b,0x3d,0x42,0x45,0x48,0x49,0x4a,0x4c,0x4c,0x4e,0x51,0x54,
0x56,0x58,0x59,0x5c,0x5e,0x5e,0x5e,0x60,0x62,0x64,0x64,0x67,0x69,0x6a,0x6a,0x68,
0x67,0x6a,0x6b,0x68,0x67,0x64,0x61,0x60,0x5b,0x57,0x57,0x56,0x55,0x51,0x4e,0x4c,
0x4a,0x47,0x44,0x41,0x40,0x40,0x3f,0x3e,0x3d,0x3d,0x3e,0x3d,0x3d,0x3e,0x42,0x44,
0x45,0x45,0x46,0x49,0x4c,0x4e,0x51,0x55,0x58,0x59,0x5d,0x5e,0x60,0x61,0x61,0x60,
0x63,0x66,0x68,0x69,0x6a,0x69,0x6a,0x6a,0x69,0x67,0x6b,0x6a,0x64,0x5f,0x5d,0x5d,
0x5c,0x59,0x55,0x53,0x4f,0x4c,0x49,0x46,0x45,0x45,0x45,0x42,0x3f,0x3e,0x3e,0x3e,
0x3e,0x3d,0x3d,0x3c,0x39,0x38,0x39,0x3d,0x3f,0x41,0x43,0x46,0x4a,0x4c,0x4c,0x4e,
0x51,0x54,0x54,0x57,0x59,0x5d,0x60,0x61,0x61,0x64,0x67,0x6a,0x69,0x67,0x67,0x69,
0x69,0x67,0x66,0x67,0x67,0x64,0x64,0x61,0x5f,0x5e,0x5b,0x57,0x55,0x54,0x53,0x4e,
0x4a,0x46,0x45,0x45,0x41,0x3e,0x40,0x41,0x3d,0x3b,0x3a,0x3c,0x3e,0x41,0x40,0x40,
0x40,0x3f,0x40,0x41,0x44,0x47,0x4b,0x4c,0x4d,0x4e,0x50,0x53,0x57,0x5a,0x5d,0x63,
0x64,0x64,0x64,0x67,0x6a,0x6a,0x67,0x66,0x69,0x6b,0x68,0x64,0x61,0x62,0x63,0x61,
0x5e,0x5b,0x5b,0x5a,0x56,0x54,0x51,0x51,0x50,0x4e,0x49,0x44,0x43,0x41,0x40,0x40,
0x3e,0x3c,0x3c,0x3a,0x3a,0x3a,0x3a,0x3b,0x3e,0x40,0x40,0x40,0x3f,0x3f,0x42,0x48,
0x4c,0x4f,0x50,0x51,0x52,0x54,0x57,0x5d,0x63,0x64,0x63,0x64,0x64,0x64,0x66,0x69,
0x6a,0x6a,0x68,0x66,0x63,0x64,0x64,0x66,0x66,0x62,0x5e,0x5c,0x5a,0x58,0x57,0x55,
0x53,0x4e,0x48,0x43,0x40,0x40,0x42,0x43,0x42,0x3f,0x3c,0x3c,0x3b,0x3c,0x3f,0x40,
0x3d,0x3d,0x3f,0x41,0x41,0x43,0x46,0x4b,0x4f,0x4f,0x4e,0x52,0x54,0x55,0x5a,0x5c,
0x5e,0x61,0x61,0x61,0x64,0x66,0x69,0x68,0x6a,0x68,0x67,0x67,0x67,0x66,0x65,0x65,
0x64,0x61,0x5e,0x5b,0x5b,0x5a,0x58,0x55,0x52,0x51,0x4c,0x47,0x45,0x44,0x45,0x43,
0x40,0x3d,0x3b,0x3a,0x3b,0x3c,0x3d,0x3f,0x3e,0x3c,0x3a,0x3b,0x3c,0x39,0x3c,0x3a,
0x37,0x36,0x36,0x36,0x3a,0x3a,0x39,0x3c,0x3c,0x3b,0x3c,0x3d,0x3c,0x3d,0x3d,0x3e,
0x3d,0x3d,0x3c,0x3a,0x3a,0x3a,0x39,0x3a,0x3a,0x3a,0x3b,0x38,0x38,0x3a,0x3c,0x3c,
0x3d,0x3d,0x3d,0x3b,0x38,0x37,0x38,0x3b,0x3c,0x3a,0x39,0x38,0x38,0x39,0x3a,0x3b,
0x3d,0x3d,0x3c,0x3c,0x3d,0x3d,0x40,0x40,0x3f,0x3d,0x3c,0x3b,0x39,0x38,0x36,0x36,
0x38,0x37,0x35,0x34,0x34,0x35,0x38,0x3a,0x3d,0x3d,0x3e,0x3c,0x3c,0x3c,0x3e,0x3e,
0x3e,0x3d,0x3a,0x39,0x38,0x3a,0x41,0x47,0x4a,0x4e,0x53,0x58,0x5b,0x60,0x62,0x67,
0x6b,0x6c,0x69,0x69,0x68,0x69,0x6c,0x6d,0x6d,0x6d,0x6c,0x6a,0x6a,0x6a,0x6a,0x6c,
0x6b,0x6a,0x6a,0x6b,0x6a,0x67,0x69,0x6a,0x6d,0x6d,0x6a,0x69,0x69,0x6a,0x6a,0x6a,
0x69,0x6a,0x68,0x68,0x67,0x68,0x6c,0x6e,0x6d,0x6c,0x6a,0x6a,0x69,0x66,0x61,0x5f,
0x5b,0x55,0x4e,0x47,0x43,0x41,0x3f,0x3c,0x3a,0x38,0x38,0x38,0x38,0x39,0x38,0x3b,
0x3c,0x3a,0x37,0x35,0x35,0x37,0x38,0x38,0x38,0x36,0x36,0x39,0x3c,0x3c,0x3b,0x3d,
0x3e,0x3c,0x3a,0x37,0x36,0x38,0x38,0x38,0x36,0x35,0x36,0x37,0x36,0x34,0x36,0x3a,
0x3d,0x3b,0x3a,0x38,0x38,0x3c,0x3e,0x3e,0x40,0x44,0x49,0x4e,0x53,0x58,0x60,0x67,
0x69,0x6a,0x6a,0x6a,0x6a,0x6a,0x68,0x66,0x64,0x64,0x64,0x66,0x68,0x6a,0x6b,0x6c,
0x6d,0x6c,0x6a,0x68,0x69,0x6c,0x6e,0x6d,0x6c,0x6c,0x6d,0x6f,0x6f,0x6d,0x6e,0x6e,
0x6c,0x69,0x66,0x66,0x68,0x6c,0x6d,0x6b,0x6b,0x6c,0x6a,0x6a,0x6a,0x6a,0x6c,0x68,
0x61,0x5a,0x52,0x4e,0x49,0x43,0x40,0x3e,0x3c,0x3a,0x38,0x38,0x3a,0x39,0x3a,0x3b,
0x3d,0x3f,0x3d,0x3a,0x38,0x38,0x37,0x38,0x3a,0x3c,0x3c,0x3c,0x39,0x39,0x3c,0x3f,
0x40,0x41,0x3d,0x3b,0x3c,0x3a,0x38,0x3a,0x3b,0x3a,0x38,0x37,0x36,0x36,0x38,0x38,
0x37,0x37,0x37,0x37,0x36,0x35,0x36,0x39,0x3a,0x38,0x38,0x36,0x35,0x35,0x34,0x34,
0x34,0x35,0x34,0x34,0x34,0x36,0x38,0x39,0x38,0x38,0x39,0x38,0x38,0x38,0x39,0x3a,
0x3b,0x38,0x37,0x35,0x36,0x36,0x37,0x39,0x3b,0x3a,0x38,0x36,0x35,0x38,0x3a,0x3a,
0x39,0x39,0x3a,0x38,0x35,0x34,0x37,0x3a,0x3d,0x3d,0x3c,0x3a,0x38,0x38,0x36,0x37,
0x3b,0x3d,0x41,0x44,0x45,0x47,0x4f,0x55,0x5c,0x60,0x63,0x64,0x64,0x65,0x67,0x67,
0x69,0x68,0x67,0x6a,0x6a,0x6b,0x6b,0x6a,0x69,0x68,0x67,0x68,0x6a,0x6c,0x6c,0x6a,
0x69,0x68,0x6a,0x6c,0x6c,0x6a,0x6b,0x6b,0x6a,0x69,0x6a,0x6a,0x6b,0x6a,0x68,0x67,
0x66,0x66,0x64,0x65,0x64,0x65,0x67,0x67,0x65,0x66,0x64,0x60,0x5a,0x54,0x51,0x4e,
0x49,0x43,0x3f,0x3c,0x39,0x38,0x38,0x39,0x3a,0x3c,0x39,0x38,0x3a,0x3b,0x3c,0x3c,
0x3b,0x38,0x38,0x39,0x3a,0x3a,0x3c,0x3c,0x3a,0x38,0x38,0x38,0x3a,0x38,0x36,0x38,
0x38,0x38,0x38,0x38,0x38,0x39,0x3a,0x3a,0x39,0x3a,0x3b,0x39,0x38,0x38,0x39,0x3c,
0x3d,0x3a,0x3c,0x3e,0x41,0x44,0x49,0x50,0x58,0x5e,0x60,0x64,0x66,0x67,0x66,0x66,
0x67,0x67,0x66,0x64,0x64,0x66,0x69,0x6a,0x6b,0x6a,0x6b,0x6d,0x6e,0x6d,0x6b,0x6a,
0x6a,0x68,0x66,0x64,0x64,0x68,0x6a,0x68,0x68,0x68,0x68,0x6a,0x69,0x6b,0x6d,0x6d,
0x6c,0x6a,0x6a,0x68,0x68,0x69,0x69,0x69,0x68,0x64,0x61,0x61,0x61,0x5d,0x5b,0x56,
0x51,0x4e,0x49,0x43,0x40,0x3d,0x3b,0x38,0x36,0x34,0x34,0x35,0x35,0x35,0x38,0x3b,
0x3c,0x3a,0x38,0x38,0x3a,0x39,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x39,0x38,
0x38,0x38,0x38,0x39,0x38,0x37,0x38,0x3c,0x3d,0x3c,0x3a,0x39,0x39,0x3b,0x3b,0x3b,
0x3a,0x38,0x36,0x33,0x33,0x35,0x38,0x3a,0x38,0x36,0x38,0x37,0x36,0x38,0x3c,0x3c,
0x3a,0x38,0x36,0x33,0x36,0x36,0x36,0x37,0x35,0x32,0x33,0x32,0x32,0x36,0x3a,0x3b,
0x38,0x36,0x34,0x33,0x34,0x37,0x38,0x38,0x36,0x33,0x33,0x34,0x36,0x36,0x34,0x33,
0x34,0x36,0x37,0x38,0x36,0x37,0x39,0x38,0x38,0x39,0x3b,0x3b,0x38,0x37,0x38,0x39,
0x3b,0x3a,0x3a,0x3b,0x3a,0x38,0x36,0x38,0x38,0x38,0x38,0x36,0x34,0x35,0x34,0x35,
0x36,0x36,0x38,0x38,0x37,0x36,0x36,0x37,0x38,0x38,0x38,0x37,0x37,0x37,0x37,0x37,
0x36,0x35,0x34,0x35,0x35,0x35,0x37,0x36,0x36,0x38,0x38,0x36,0x33,0x33,0x36,0x38,
0x38,0x38,0x38,0x38,0x37,0x36,0x38,0x3a,0x3a,0x3a,0x36,0x33,0x34,0x33,0x33,0x34,
0x34,0x36,0x38,0x39,0x39,0x3a,0x3b,0x39,0x36,0x34,0x35,0x36,0x37,0x34,0x32,0x34,
0x35,0x35,0x35,0x36,0x37,0x38,0x38,0x36,0x36,0x35,0x35,0x33,0x34,0x33,0x33,0x36,
0x36,0x35,0x35,0x36,0x36,0x35,0x36,0x37,0x38,0x39,0x38,0x35,0x33,0x33,0x33,0x34,
0x35,0x36,0x37,0x36,0x34,0x35,0x36,0x38,0x37,0x36,0x34,0x35,0x36,0x34,0x34,0x36,
0x38,0x35,0x35,0x36,0x36,0x37,0x38,0x38,0x38,0x38,0x38,0x35,0x38,0x38,0x3a,0x3c,
0x3c,0x39,0x39,0x38,0x36,0x38,0x39,0x3a,0x3b,0x39,0x37,0x36,0x36,0x36,0x37,0x36,
0x36,0x39,0x3a,0x39,0x38,0x38,0x3a,0x3a,0x3a,0x38,0x36,0x37,0x36,0x32,0x32,0x32,
0x35,0x35,0x35,0x35,0x38,0x3a,0x39,0x38,0x38,0x36,0x35,0x35,0x36,0x38,0x39,0x38,
0x35,0x36,0x36,0x38,0x38,0x36,0x35,0x36,0x35,0x34,0x34,0x35,0x38,0x38,0x38,0x36,
0x38,0x3a,0x3a,0x38,0x36,0x36,0x38,0x38,0x37,0x35,0x37,0x38,0x38,0x36,0x37,0x38,
0x38,0x39,0x38,0x38,0x38,0x36,0x35,0x36,0x36,0x37,0x36,0x38,0x35,0x36,0x38,0x3a,
0x3a,0x3a,0x38,0x38,0x36,0x35,0x35,0x38,0x38,0x35,0x33,0x33,0x35,0x36,0x36,0x36,
0x38,0x38,0x38,0x37,0x36,0x38,0x3a,0x3c,0x3a,0x38,0x38,0x38,0x38,0x37,0x38,0x39,
0x39,0x38,0x35,0x35,0x34,0x34,0x33,0x35,0x35,0x33,0x34,0x35,0x36,0x38,0x38,0x37,
0x38,0x37,0x37,0x36,0x34,0x34,0x36,0x38,0x38,0x36,0x38,0x38,0x38,0x3a,0x3a,0x38,
0x38,0x35,0x32,0x32,0x32,0x34,0x36,0x36,0x34,0x35,0x37,0x38,0x39,0x39,0x3a,0x3a,
0x38,0x36,0x36,0x36,0x35,0x34,0x34,0x35,0x38,0x38,0x36,0x34,0x34,0x36,0x37,0x34,
0x36,0x36,0x38,0x3a,0x3c,0x3e,0x46,0x4d,0x51,0x56,0x5a,0x5d,0x5e,0x60,0x61,0x66,
0x69,0x69,0x67,0x64,0x63,0x63,0x64,0x65,0x66,0x67,0x67,0x65,0x65,0x65,0x66,0x68,
0x68,0x67,0x67,0x67,0x67,0x64,0x66,0x67,0x67,0x68,0x67,0x65,0x68,0x67,0x65,0x66,
0x67,0x69,0x6a,0x68,0x65,0x66,0x68,0x69,0x68,0x66,0x63,0x61,0x5e,0x5a,0x54,0x52,
0x50,0x4b,0x44,0x3d,0x39,0x38,0x36,0x34,0x34,0x36,0x38,0x38,0x36,0x38,0x39,0x3c,
0x3c,0x38,0x38,0x38,0x36,0x35,0x35,0x35,0x37,0x36,0x34,0x35,0x36,0x38,0x38,0x37,
//Field 5
// Line 10
0x35,0x35,0x35,0x36,0x35,0x35,0x35,0x36,0x36,0x36,0x35,0x37,0x39,0x39,0x37,0x37,
0x37,0x37,0x37,0x38,0x37,0x37,0x37,0x36,0x35,0x35,0x35,0x37,0x38,0x39,0x37,0x37,
0x37,0x37,0x37,0x36,0x36,0x38,0x36,0x34,0x31,0x31,0x31,0x34,0x35,0x36,0x34,0x37,
0x36,0x36,0x37,0x39,0x37,0x35,0x33,0x32,0x33,0x35,0x37,0x39,0x3a,0x39,0x39,0x3a,
0x3b,0x3d,0x3d,0x3d,0x3b,0x3a,0x39,0x37,0x37,0x37,0x36,0x37,0x37,0x36,0x36,0x34,
0x32,0x35,0x35,0x36,0x36,0x37,0x36,0x36,0x36,0x37,0x36,0x39,0x36,0x34,0x36,0x37,
0x38,0x39,0x3a,0x39,0x38,0x37,0x37,0x37,0x37,0x36,0x36,0x36,0x34,0x32,0x32,0x33,
0x33,0x36,0x36,0x35,0x34,0x32,0x32,0x34,0x36,0x39,0x3a,0x3a,0x38,0x37,0x37,0x38,
0x39,0x39,0x37,0x36,0x37,0x37,0x37,0x37,0x37,0x38,0x39,0x38,0x37,0x38,0x37,0x35,
0x32,0x33,0x35,0x36,0x38,0x39,0x38,0x38,0x37,0x38,0x3a,0x3b,0x3b,0x3b,0x38,0x37,
0x35,0x36,0x37,0x39,0x3a,0x3a,0x37,0x37,0x35,0x35,0x38,0x3a,0x3b,0x3d,0x3b,0x38,
0x38,0x39,0x3a,0x37,0x3a,0x37,0x35,0x33,0x32,0x32,0x35,0x36,0x36,0x37,0x38,0x39,
0x3b,0x3b,0x3a,0x3b,0x3a,0x3a,0x3a,0x3a,0x39,0x38,0x37,0x37,0x36,0x37,0x39,0x3a,
0x3c,0x3d,0x3c,0x3b,0x3a,0x3a,0x3a,0x3a,0x39,0x3b,0x3b,0x3a,0x39,0x39,0x3a,0x3c,
0x3c,0x3b,0x39,0x39,0x37,0x37,0x37,0x37,0x38,0x38,0x38,0x38,0x39,0x3b,0x3b,0x3a,
0x39,0x38,0x36,0x37,0x35,0x34,0x36,0x37,0x35,0x34,0x33,0x32,0x34,0x36,0x37,0x37,
0x36,0x35,0x36,0x39,0x3b,0x3b,0x3a,0x3a,0x38,0x39,0x37,0x36,0x35,0x35,0x34,0x34,
0x33,0x34,0x36,0x37,0x36,0x35,0x34,0x35,0x35,0x36,0x36,0x37,0x39,0x39,0x37,0x39,
0x36,0x36,0x37,0x37,0x37,0x36,0x36,0x35,0x34,0x36,0x37,0x37,0x37,0x38,0x37,0x38,
0x37,0x37,0x37,0x37,0x37,0x39,0x3a,0x39,0x39,0x38,0x38,0x39,0x37,0x39,0x39,0x37,
0x35,0x34,0x36,0x37,0x36,0x36,0x35,0x35,0x36,0x38,0x3a,0x3c,0x3c,0x3b,0x3a,0x3a,
0x39,0x3c,0x3d,0x3c,0x38,0x38,0x37,0x36,0x36,0x36,0x37,0x39,0x3b,0x3c,0x3c,0x3b,
0x3b,0x3c,0x3d,0x3d,0x3c,0x3b,0x38,0x36,0x36,0x38,0x3a,0x3c,0x3b,0x39,0x38,0x37,
0x36,0x35,0x38,0x3a,0x39,0x39,0x37,0x35,0x37,0x37,0x37,0x38,0x37,0x36,0x36,0x35,
0x33,0x36,0x38,0x3b,0x3b,0x3a,0x38,0x38,0x3a,0x39,0x3a,0x39,0x37,0x36,0x37,0x38,
0x38,0x39,0x38,0x38,0x37,0x36,0x35,0x35,0x36,0x36,0x37,0x39,0x39,0x37,0x3b,0x3a,
0x38,0x38,0x39,0x3b,0x3c,0x39,0x36,0x37,0x38,0x3b,0x3b,0x3c,0x3b,0x3c,0x3b,0x3a,
0x39,0x3a,0x3b,0x39,0x38,0x39,0x39,0x3a,0x38,0x37,0x39,0x39,0x38,0x37,0x37,0x37,
0x37,0x37,0x35,0x36,0x37,0x37,0x36,0x37,0x37,0x38,0x38,0x37,0x35,0x37,0x39,0x39,
0x37,0x36,0x36,0x37,0x39,0x3a,0x3a,0x3b,0x3b,0x39,0x37,0x37,0x37,0x37,0x37,0x35,
0x35,0x36,0x37,0x37,0x37,0x38,0x38,0x38,0x37,0x37,0x3a,0x3a,0x37,0x38,0x38,0x39,
0x39,0x39,0x39,0x3a,0x3a,0x3a,0x39,0x39,0x3a,0x3b,0x3e,0x3d,0x3b,0x3b,0x38,0x36,
0x36,0x36,0x39,0x3b,0x3a,0x39,0x39,0x3a,0x39,0x39,0x39,0x3a,0x39,0x38,0x36,0x35,
0x35,0x36,0x37,0x39,0x3a,0x3c,0x3d,0x3d,0x3a,0x39,0x3a,0x3a,0x39,0x39,0x38,0x37,
0x35,0x33,0x34,0x36,0x37,0x38,0x37,0x36,0x35,0x36,0x35,0x36,0x37,0x39,0x39,0x35,
0x35,0x35,0x36,0x37,0x38,0x37,0x38,0x36,0x33,0x35,0x36,0x37,0x37,0x37,0x36,0x35,
0x34,0x36,0x37,0x37,0x37,0x37,0x38,0x38,0x37,0x38,0x38,0x38,0x38,0x37,0x36,0x36,
0x34,0x33,0x33,0x36,0x37,0x38,0x39,0x39,0x39,0x3a,0x39,0x38,0x39,0x3a,0x37,0x36,
0x34,0x35,0x37,0x39,0x36,0x36,0x37,0x3b,0x3c,0x3a,0x37,0x37,0x3b,0x3c,0x39,0x37,
0x37,0x38,0x38,0x36,0x33,0x34,0x35,0x36,0x35,0x35,0x35,0x35,0x36,0x38,0x38,0x39,
0x37,0x38,0x39,0x37,0x34,0x35,0x36,0x38,0x39,0x3a,0x38,0x39,0x3b,0x3a,0x37,0x36,
0x36,0x39,0x3a,0x37,0x35,0x33,0x32,0x33,0x34,0x33,0x34,0x37,0x36,0x35,0x35,0x36,
0x38,0x39,0x3a,0x38,0x36,0x37,0x39,0x38,0x37,0x37,0x35,0x35,0x36,0x37,0x39,0x38,
0x37,0x36,0x36,0x35,0x35,0x37,0x38,0x3a,0x39,0x38,0x38,0x39,0x39,0x38,0x38,0x37,
0x37,0x37,0x36,0x35,0x36,0x37,0x37,0x34,0x36,0x35,0x36,0x38,0x39,0x37,0x39,0x37,
0x37,0x38,0x38,0x39,0x3a,0x38,0x36,0x36,0x36,0x37,0x36,0x36,0x36,0x36,0x37,0x37,
0x37,0x37,0x37,0x36,0x35,0x33,0x33,0x36,0x37,0x37,0x38,0x37,0x37,0x36,0x35,0x33,
0x34,0x35,0x36,0x32,0x33,0x34,0x34,0x37,0x38,0x39,0x3b,0x3c,0x3a,0x39,0x37,0x39,
0x38,0x38,0x37,0x37,0x39,0x38,0x35,0x33,0x33,0x35,0x38,0x38,0x36,0x36,0x35,0x35,
0x36,0x37,0x38,0x39,0x38,0x36,0x35,0x36,0x35,0x35,0x35,0x35,0x33,0x35,0x34,0x35,
0x37,0x36,0x32,0x32,0x33,0x34,0x35,0x35,0x33,0x35,0x37,0x37,0x36,0x39,0x3b,0x3b,
0x3a,0x37,0x36,0x38,0x37,0x38,0x39,0x3a,0x39,0x38,0x34,0x32,0x35,0x39,0x3b,0x3b,
0x38,0x36,0x34,0x36,0x36,0x36,0x37,0x37,0x34,0x32,0x32,0x34,0x35,0x35,0x34,0x36,
0x37,0x38,0x36,0x38,0x38,0x37,0x37,0x36,0x37,0x3b,0x3b,0x3a,0x39,0x3a,0x3a,0x3a,
0x3a,0x3a,0x3a,0x3b,0x3a,0x38,0x37,0x36,0x35,0x36,0x35,0x35,0x33,0x33,0x33,0x34,
0x33,0x36,0x35,0x37,0x37,0x37,0x37,0x39,0x36,0x39,0x38,0x37,0x39,0x39,0x37,0x36,
0x34,0x35,0x37,0x38,0x38,0x39,0x38,0x36,0x35,0x37,0x38,0x37,0x37,0x37,0x37,0x38,
0x39,0x38,0x3a,0x3a,0x37,0x37,0x37,0x39,0x39,0x37,0x35,0x35,0x36,0x37,0x37,0x39,
0x3a,0x38,0x38,0x37,0x37,0x39,0x38,0x38,0x37,0x38,0x38,0x38,0x37,0x37,0x37,0x39,
0x39,0x39,0x39,0x39,0x39,0x3a,0x3a,0x3a,0x3b,0x3b,0x3a,0x39,0x37,0x37,0x36,0x35,
0x32,0x33,0x34,0x36,0x36,0x36,0x37,0x39,0x3a,0x3a,0x39,0x39,0x38,0x38,0x38,0x38,
0x37,0x37,0x36,0x34,0x33,0x37,0x39,0x38,0x38,0x37,0x37,0x37,0x36,0x36,0x37,0x36,
0x35,0x36,0x35,0x36,0x35,0x36,0x35,0x36,0x38,0x3a,0x3b,0x3b,0x39,0x37,0x38,0x38,
0x38,0x37,0x38,0x38,0x39,0x3b,0x3c,0x3c,0x3b,0x3a,0x37,0x38,0x37,0x36,0x37,0x34,
0x32,0x34,0x33,0x34,0x36,0x39,0x3a,0x3b,0x39,0x39,0x37,0x36,0x35,0x36,0x38,0x3a,
0x38,0x38,0x38,0x38,0x39,0x3b,0x3c,0x3b,0x39,0x38,0x37,0x36,0x36,0x36,0x37,0x36,
0x34,0x35,0x35,0x34,0x33,0x35,0x35,0x37,0x36,0x35,0x34,0x36,0x34,0x36,0x36,0x37,
0x37,0x37,0x36,0x37,0x39,0x39,0x39,0x3a,0x38,0x36,0x36,0x36,0x36,0x36,0x35,0x35,
0x36,0x39,0x3a,0x3b,0x3a,0x39,0x38,0x37,0x36,0x37,0x39,0x3a,0x39,0x38,0x36,0x36,
0x37,0x38,0x38,0x39,0x38,0x37,0x36,0x35,0x35,0x37,0x38,0x39,0x38,0x39,0x39,0x37,
0x37,0x39,0x39,0x39,0x39,0x39,0x3a,0x38,0x36,0x35,0x35,0x36,0x37,0x39,0x39,0x38,
0x36,0x35,0x33,0x36,0x36,0x36,0x36,0x37,0x36,0x37,0x37,0x36,0x35,0x35,0x34,0x35,
0x35,0x37,0x36,0x35,0x32,0x31,0x32,0x37,0x39,0x3b,0x3b,0x3b,0x3a,0x38,0x39,0x3a,
0x39,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x34,0x37,0x38,0x38,0x39,0x39,0x3a,0x3a,
0x38,0x3a,0x39,0x3c,0x3a,0x3a,0x39,0x39,0x39,0x39,0x37,0x36,0x36,0x37,0x35,0x35,
0x35,0x36,0x36,0x35,0x35,0x33,0x37,0x38,0x37,0x37,0x37,0x37,0x37,0x38,0x39,0x3a,
0x39,0x38,0x39,0x37,0x35,0x36,0x36,0x35,0x35,0x36,0x35,0x35,0x36,0x39,0x39,0x38,
0x37,0x36,0x37,0x38,0x37,0x36,0x37,0x39,0x3a,0x3b,0x3c,0x3c,0x3a,0x38,0x39,0x3b,
0x3b,0x3a,0x39,0x37,0x33,0x34,0x36,0x37,0x39,0x3a,0x38,0x38,0x36,0x36,0x37,0x37,
0x37,0x37,0x36,0x36,0x35,0x34,0x33,0x34,0x36,0x37,0x38,0x3a,0x38,0x37,0x37,0x37,
0x38,0x39,0x3b,0x3b,0x3a,0x39,0x39,0x37,0x35,0x36,0x35,0x36,0x36,0x36,0x38,0x37,
0x38,0x39,0x3a,0x3b,0x3b,0x3b,0x38,0x37,0x37,0x38,0x39,0x38,0x37,0x38,0x39,0x3a,
0x3a,0x3a,0x3b,0x3a,0x39,0x38,0x37,0x39,0x39,0x3a,0x3b,0x39,0x38,0x36,0x34,0x33,
0x34,0x37,0x38,0x38,0x38,0x37,0x35,0x37,0x38,0x39,0x3a,0x39,0x36,0x35,0x34,0x34,
0x33,0x37,0x38,0x39,0x39,0x39,0x38,0x39,0x37,0x39,0x3c,0x3c,0x3a,0x3a,0x3a,0x38,
0x36,0x36,0x36,0x36,0x35,0x36,0x36,0x37,0x37,0x37,0x39,0x3a,0x39,0x3a,0x3a,0x39,
0x36,0x37,0x37,0x36,0x36,0x37,0x35,0x36,0x35,0x34,0x34,0x35,0x35,0x35,0x34,0x34,
0x36,0x37,0x37,0x36,0x35,0x35,0x36,0x36,0x37,0x37,0x37,0x37,0x36,0x38,0x38,0x39,
0x3a,0x39,0x38,0x38,0x37,0x37,0x37,0x37,0x37,0x38,0x39,0x39,0x39,0x3d,0x3b,0x3a,
0x3a,0x3a,0x3b,0x3b,0x39,0x37,0x39,0x3a,0x39,0x38,0x3a,0x39,0x38,0x38,0x37,0x35,
0x35,0x36,0x35,0x35,0x33,0x33,0x33,0x33,0x34,0x35,0x35,0x37,0x38,0x37,0x37,0x37,
0x37,0x38,0x38,0x37,0x36,0x35,0x35,0x35,0x32,0x33,0x33,0x33,0x35,0x35,0x37,0x36,
0x35,0x35,0x35,0x35,0x34,0x35,0x35,0x34,0x32,0x34,0x35,0x35,0x36,0x36,0x35,0x36,
0x34,0x34,0x35,0x36,0x36,0x36,0x37,0x36,0x34,0x37,0x36,0x35,0x37,0x39,0x39,0x38,
0x36,0x33,0x32,0x35,0x36,0x35,0x34,0x33,0x32,0x32,0x31,0x32,0x37,0x37,0x36,0x37,
0x37,0x38,0x37,0x36,0x35,0x36,0x35,0x34,0x32,0x32,0x32,0x34,0x36,0x37,0x38,0x39,
// Line 11
0x37,0x36,0x35,0x35,0x34,0x34,0x35,0x34,0x34,0x34,0x33,0x34,0x35,0x37,0x37,0x3a,
0x3b,0x3b,0x38,0x39,0x3a,0x3c,0x3d,0x3b,0x38,0x38,0x37,0x35,0x34,0x37,0x39,0x3b,
0x38,0x35,0x35,0x37,0x37,0x37,0x37,0x37,0x38,0x3a,0x38,0x35,0x32,0x32,0x33,0x36,
0x37,0x38,0x36,0x32,0x30,0x33,0x3d,0x4f,0x61,0x73,0x7a,0x79,0x6f,0x61,0x58,0x57,
0x5c,0x66,0x70,0x76,0x78,0x74,0x6b,0x61,0x5d,0x5f,0x66,0x6d,0x70,0x72,0x70,0x6c,
0x63,0x5b,0x57,0x5c,0x62,0x6b,0x71,0x73,0x6f,0x6a,0x62,0x5b,0x59,0x5c,0x63,0x6f,
0x75,0x76,0x74,0x6d,0x64,0x5d,0x59,0x5c,0x64,0x6d,0x72,0x72,0x6e,0x67,0x61,0x5d,
0x5c,0x60,0x68,0x6f,0x74,0x76,0x71,0x69,0x60,0x5a,0x57,0x5d,0x65,0x6f,0x76,0x78,
0x72,0x6c,0x66,0x61,0x5e,0x62,0x67,0x69,0x6b,0x6b,0x6d,0x74,0x7b,0x86,0x93,0x9f,
0xa7,0xaa,0xa5,0x98,0x87,0x77,0x68,0x5b,0x52,0x4e,0x4d,0x4a,0x43,0x3c,0x38,0x3c,
0x46,0x57,0x6a,0x7b,0x87,0x8e,0x91,0x94,0x96,0x9c,0x9e,0x9f,0x9c,0x9c,0x9e,0x9e,
0x9a,0x97,0x8e,0x80,0x73,0x68,0x5e,0x54,0x4d,0x43,0x38,0x33,0x35,0x42,0x55,0x69,
0x77,0x7e,0x79,0x6d,0x62,0x5b,0x56,0x51,0x49,0x40,0x34,0x30,0x37,0x49,0x60,0x75,
0x82,0x84,0x7a,0x6b,0x5d,0x54,0x4e,0x4a,0x44,0x3c,0x35,0x2f,0x2c,0x2e,0x35,0x3d,
0x4a,0x5b,0x69,0x71,0x77,0x75,0x6d,0x64,0x5c,0x55,0x4f,0x47,0x3e,0x38,0x33,0x36,
0x43,0x57,0x6c,0x80,0x8e,0x96,0x99,0x99,0x94,0x8b,0x80,0x70,0x5e,0x54,0x53,0x5f,
0x6e,0x78,0x79,0x75,0x6b,0x65,0x62,0x61,0x5b,0x4f,0x41,0x31,0x2a,0x33,0x47,0x61,
0x78,0x81,0x7c,0x70,0x61,0x58,0x54,0x51,0x49,0x3f,0x34,0x30,0x34,0x47,0x5f,0x76,
0x83,0x82,0x76,0x67,0x5a,0x57,0x5b,0x62,0x6a,0x70,0x74,0x79,0x80,0x8c,0x99,0xa7,
0xac,0xac,0xa6,0xa1,0x99,0x95,0x98,0x9a,0x9a,0x97,0x8d,0x7c,0x68,0x5a,0x53,0x56,
0x60,0x6e,0x73,0x79,0x74,0x6a,0x63,0x5d,0x58,0x54,0x4e,0x45,0x3b,0x31,0x2b,0x2b,
0x2e,0x34,0x3b,0x3f,0x3e,0x3b,0x37,0x34,0x32,0x34,0x38,0x3e,0x41,0x41,0x3d,0x39,
0x34,0x34,0x3d,0x4c,0x5d,0x6f,0x79,0x7c,0x75,0x6a,0x5e,0x59,0x5c,0x64,0x6b,0x74,
0x79,0x80,0x88,0x8e,0x95,0x9f,0xa6,0xa8,0xa2,0x98,0x8a,0x7c,0x6b,0x5d,0x54,0x51,
0x4d,0x4a,0x44,0x3d,0x34,0x32,0x32,0x37,0x3d,0x42,0x42,0x3e,0x38,0x34,0x34,0x3c,
0x47,0x57,0x69,0x79,0x86,0x91,0x98,0x9b,0x98,0x8f,0x81,0x74,0x65,0x59,0x4e,0x46,
0x3f,0x38,0x39,0x40,0x4c,0x5e,0x6e,0x7b,0x88,0x8d,0x90,0x94,0x98,0xa0,0xa6,0xa8,
0xa1,0x97,0x88,0x78,0x6a,0x61,0x5c,0x5f,0x65,0x6d,0x73,0x7b,0x84,0x8e,0x99,0x9f,
0x9d,0x95,0x84,0x6e,0x5a,0x50,0x53,0x5c,0x69,0x74,0x79,0x78,0x70,0x66,0x62,0x5b,
0x56,0x52,0x48,0x3c,0x32,0x2e,0x2f,0x37,0x41,0x46,0x43,0x40,0x37,0x32,0x35,0x3f,
0x4d,0x5d,0x6d,0x7b,0x87,0x90,0x98,0x9c,0x9a,0x91,0x84,0x74,0x65,0x5b,0x56,0x58,
0x60,0x6d,0x78,0x82,0x8b,0x91,0x97,0x9f,0xa5,0xa7,0xa2,0x9b,0x8e,0x7f,0x71,0x67,
0x5f,0x59,0x4f,0x44,0x3c,0x37,0x35,0x40,0x4a,0x5a,0x6b,0x79,0x84,0x8e,0x95,0x99,
0x98,0x90,0x80,0x6c,0x5d,0x56,0x58,0x65,0x74,0x7f,0x80,0x77,0x6b,0x65,0x63,0x62,
0x5e,0x54,0x46,0x38,0x30,0x34,0x46,0x61,0x78,0x85,0x83,0x76,0x65,0x5b,0x58,0x5c,
0x67,0x70,0x74,0x78,0x7d,0x85,0x8f,0x97,0x97,0x8f,0x81,0x70,0x5e,0x52,0x49,0x43,
0x3d,0x39,0x39,0x41,0x4d,0x5e,0x6e,0x7b,0x84,0x8c,0x91,0x95,0x99,0x9f,0xa2,0xa3,
0x9f,0x95,0x85,0x74,0x63,0x5a,0x59,0x5d,0x64,0x6c,0x74,0x7c,0x84,0x8c,0x93,0x9b,
0x9c,0x94,0x83,0x6f,0x5c,0x51,0x51,0x54,0x5d,0x6b,0x7a,0x86,0x8a,0x91,0x99,0xa3,
0xa9,0xab,0xa5,0x9c,0x8f,0x81,0x73,0x67,0x5c,0x53,0x4b,0x43,0x3b,0x36,0x36,0x3e,
0x4b,0x5b,0x6b,0x7e,0x8b,0x96,0x9b,0x99,0x91,0x87,0x7a,0x6b,0x5c,0x4c,0x3f,0x38,
0x35,0x32,0x2f,0x33,0x36,0x3d,0x41,0x43,0x41,0x41,0x3d,0x39,0x38,0x3a,0x3b,0x3d,
0x3b,0x38,0x38,0x37,0x38,0x39,0x39,0x39,0x38,0x38,0x36,0x37,0x38,0x3b,0x3c,0x3d,
0x3b,0x3b,0x3d,0x3d,0x3c,0x3d,0x3c,0x3c,0x39,0x38,0x39,0x3c,0x3c,0x3c,0x3b,0x3c,
0x3a,0x38,0x37,0x36,0x34,0x32,0x30,0x2f,0x31,0x34,0x36,0x35,0x36,0x37,0x37,0x39,
0x39,0x39,0x3a,0x3a,0x38,0x38,0x38,0x38,0x39,0x39,0x38,0x3a,0x39,0x38,0x36,0x35,
0x35,0x37,0x38,0x39,0x38,0x39,0x37,0x35,0x36,0x38,0x3a,0x3c,0x39,0x37,0x35,0x35,
0x35,0x37,0x37,0x37,0x37,0x3a,0x3c,0x3c,0x3c,0x3d,0x3a,0x3c,0x39,0x39,0x39,0x36,
0x34,0x35,0x35,0x37,0x38,0x3a,0x3c,0x3a,0x38,0x37,0x36,0x38,0x39,0x39,0x38,0x37,
0x37,0x38,0x3a,0x3c,0x3d,0x3c,0x3a,0x3a,0x3a,0x3a,0x3a,0x3b,0x3b,0x3a,0x3a,0x38,
0x37,0x38,0x38,0x38,0x37,0x35,0x34,0x35,0x37,0x38,0x36,0x35,0x34,0x37,0x38,0x38,
0x36,0x35,0x36,0x37,0x36,0x37,0x38,0x3c,0x3b,0x39,0x39,0x3c,0x3c,0x3c,0x3b,0x39,
0x38,0x39,0x38,0x37,0x37,0x37,0x36,0x35,0x35,0x36,0x3a,0x3b,0x38,0x38,0x38,0x38,
0x38,0x38,0x39,0x3a,0x39,0x37,0x35,0x38,0x39,0x38,0x39,0x38,0x37,0x36,0x36,0x37,
0x38,0x39,0x39,0x38,0x34,0x32,0x33,0x36,0x37,0x37,0x38,0x38,0x37,0x37,0x37,0x37,
0x38,0x38,0x35,0x35,0x36,0x38,0x36,0x34,0x33,0x34,0x36,0x36,0x34,0x36,0x37,0x36,
0x36,0x35,0x34,0x37,0x35,0x34,0x33,0x34,0x35,0x38,0x39,0x38,0x38,0x3a,0x3b,0x3a,
0x3a,0x3a,0x3b,0x3c,0x3b,0x3c,0x3c,0x39,0x38,0x3a,0x3c,0x3d,0x3d,0x3c,0x3a,0x3a,
0x39,0x38,0x37,0x37,0x37,0x37,0x38,0x39,0x38,0x39,0x37,0x35,0x35,0x37,0x37,0x37,
0x36,0x35,0x34,0x34,0x34,0x34,0x34,0x36,0x36,0x37,0x35,0x34,0x34,0x35,0x35,0x37,
0x38,0x3c,0x3c,0x3a,0x38,0x38,0x39,0x39,0x36,0x34,0x34,0x36,0x37,0x37,0x38,0x3a,
0x3b,0x39,0x39,0x3b,0x3b,0x3a,0x37,0x34,0x32,0x34,0x35,0x38,0x37,0x37,0x38,0x39,
0x38,0x38,0x3c,0x3d,0x3c,0x3c,0x3c,0x3c,0x3b,0x38,0x37,0x37,0x37,0x37,0x35,0x34,
0x35,0x36,0x38,0x39,0x3a,0x3c,0x3c,0x3b,0x39,0x39,0x39,0x3c,0x3a,0x38,0x37,0x37,
0x37,0x38,0x38,0x38,0x38,0x39,0x37,0x35,0x35,0x35,0x34,0x35,0x34,0x35,0x37,0x37,
0x35,0x37,0x39,0x3b,0x38,0x38,0x38,0x39,0x39,0x38,0x37,0x36,0x35,0x35,0x37,0x37,
0x36,0x37,0x35,0x34,0x35,0x37,0x39,0x39,0x38,0x37,0x36,0x36,0x35,0x37,0x38,0x38,
0x35,0x35,0x34,0x34,0x36,0x37,0x37,0x37,0x37,0x37,0x35,0x38,0x39,0x39,0x3b,0x3a,
0x38,0x38,0x37,0x37,0x36,0x37,0x37,0x37,0x35,0x34,0x34,0x36,0x37,0x36,0x35,0x36,
0x34,0x35,0x35,0x35,0x35,0x37,0x3a,0x3d,0x3c,0x3b,0x39,0x38,0x35,0x37,0x38,0x3b,
0x38,0x39,0x38,0x37,0x38,0x38,0x39,0x3a,0x39,0x39,0x38,0x37,0x36,0x37,0x37,0x35,
0x35,0x36,0x37,0x37,0x37,0x36,0x36,0x37,0x39,0x39,0x3a,0x3c,0x3d,0x3d,0x3a,0x38,
0x37,0x36,0x34,0x33,0x33,0x34,0x32,0x34,0x34,0x34,0x35,0x37,0x37,0x38,0x38,0x37,
0x38,0x38,0x38,0x38,0x35,0x34,0x35,0x37,0x37,0x38,0x38,0x37,0x37,0x38,0x37,0x37,
0x38,0x3a,0x3a,0x39,0x37,0x38,0x38,0x38,0x37,0x38,0x38,0x39,0x39,0x38,0x37,0x38,
0x3a,0x3b,0x3a,0x3c,0x3b,0x3a,0x3a,0x39,0x38,0x38,0x38,0x37,0x38,0x38,0x38,0x38,
0x37,0x37,0x38,0x3b,0x3b,0x3b,0x3a,0x39,0x37,0x37,0x35,0x35,0x35,0x35,0x34,0x35,
0x36,0x38,0x3b,0x3d,0x3c,0x3c,0x3c,0x3a,0x38,0x37,0x36,0x35,0x35,0x36,0x38,0x38,
0x37,0x36,0x37,0x38,0x38,0x37,0x38,0x38,0x38,0x38,0x36,0x35,0x35,0x36,0x38,0x3b,
0x3a,0x39,0x36,0x37,0x35,0x37,0x38,0x39,0x39,0x38,0x35,0x34,0x35,0x37,0x38,0x38,
0x38,0x37,0x37,0x37,0x38,0x3b,0x3a,0x39,0x37,0x36,0x37,0x36,0x38,0x38,0x37,0x37,
0x34,0x32,0x35,0x34,0x37,0x38,0x39,0x39,0x39,0x38,0x37,0x38,0x3a,0x3c,0x3a,0x38,
0x35,0x34,0x34,0x35,0x35,0x37,0x38,0x3a,0x3b,0x39,0x37,0x38,0x38,0x38,0x38,0x37,
0x37,0x36,0x36,0x35,0x34,0x37,0x38,0x39,0x39,0x39,0x38,0x39,0x39,0x39,0x3a,0x3b,
0x38,0x38,0x39,0x39,0x38,0x38,0x36,0x35,0x35,0x35,0x35,0x36,0x37,0x37,0x37,0x35,
0x35,0x37,0x38,0x39,0x39,0x39,0x39,0x39,0x38,0x37,0x38,0x38,0x37,0x35,0x35,0x36,
0x38,0x3c,0x3d,0x3d,0x3c,0x3c,0x3b,0x3a,0x39,0x3a,0x3a,0x3a,0x36,0x35,0x37,0x38,
0x39,0x39,0x38,0x36,0x35,0x33,0x32,0x33,0x33,0x33,0x34,0x35,0x35,0x36,0x37,0x37,
0x37,0x37,0x38,0x3a,0x3c,0x3a,0x37,0x37,0x33,0x32,0x35,0x3d,0x4a,0x59,0x68,0x77,
0x83,0x8d,0x92,0x96,0x97,0x91,0x83,0x73,0x5f,0x54,0x52,0x57,0x62,0x70,0x7c,0x87,
0x8e,0x95,0x9c,0x9f,0xa2,0xa1,0x9d,0x95,0x89,0x7c,0x6e,0x63,0x57,0x4e,0x45,0x3e,
0x3b,0x39,0x37,0x36,0x35,0x35,0x36,0x39,0x42,0x51,0x63,0x73,0x7b,0x79,0x6e,0x61,
0x59,0x58,0x5f,0x6c,0x76,0x7a,0x75,0x6a,0x60,0x5c,0x5c,0x5e,0x5c,0x54,0x44,0x33,
0x2a,0x31,0x44,0x60,0x76,0x83,0x82,0x77,0x66,0x59,0x50,0x4c,0x47,0x43,0x3b,0x32,
0x2e,0x30,0x34,0x3c,0x40,0x40,0x3e,0x3a,0x36,0x35,0x35,0x35,0x36,0x37,0x38,0x39,
0x3b,0x3a,0x38,0x38,0x38,0x36,0x34,0x32,0x32,0x35,0x34,0x34,0x34,0x33,0x34,0x37,
// Line 12
0x37,0x38,0x39,0x3a,0x39,0x37,0x37,0x39,0x39,0x39,0x3b,0x3a,0x38,0x37,0x36,0x37,
0x36,0x36,0x35,0x35,0x35,0x33,0x33,0x36,0x36,0x35,0x35,0x35,0x35,0x37,0x38,0x38,
0x37,0x38,0x37,0x37,0x36,0x36,0x37,0x39,0x39,0x38,0x36,0x34,0x33,0x36,0x37,0x38,
0x3b,0x3b,0x37,0x33,0x32,0x37,0x40,0x4e,0x5f,0x70,0x79,0x7a,0x72,0x66,0x5b,0x58,
0x5c,0x67,0x73,0x7a,0x79,0x72,0x6a,0x64,0x60,0x62,0x68,0x70,0x76,0x79,0x76,0x6f,
0x66,0x5f,0x5b,0x5d,0x61,0x68,0x70,0x74,0x70,0x6b,0x64,0x5e,0x5a,0x5f,0x65,0x6e,
0x73,0x73,0x70,0x6d,0x67,0x62,0x61,0x63,0x67,0x6f,0x73,0x74,0x72,0x6b,0x63,0x5c,
0x58,0x5b,0x62,0x6d,0x75,0x76,0x72,0x68,0x5e,0x59,0x58,0x5e,0x67,0x71,0x76,0x77,
0x72,0x6b,0x65,0x60,0x5c,0x5e,0x64,0x67,0x68,0x6c,0x70,0x75,0x7d,0x87,0x93,0xa1,
0xa9,0xab,0xa8,0x9c,0x8d,0x7b,0x6a,0x5f,0x5a,0x57,0x52,0x4a,0x3f,0x36,0x33,0x39,
0x44,0x57,0x6c,0x7d,0x87,0x8e,0x92,0x97,0x9b,0x9f,0x9f,0x9e,0x9e,0x9f,0x9f,0x9e,
0x9c,0x98,0x8f,0x83,0x73,0x65,0x5b,0x53,0x4c,0x44,0x3b,0x36,0x39,0x44,0x56,0x6c,
0x7b,0x7f,0x7a,0x6e,0x62,0x5b,0x56,0x51,0x4a,0x3f,0x34,0x30,0x35,0x48,0x60,0x75,
0x81,0x82,0x79,0x6a,0x5b,0x52,0x4c,0x49,0x44,0x3c,0x32,0x2c,0x28,0x29,0x31,0x3e,
0x4d,0x5e,0x69,0x70,0x71,0x6e,0x68,0x61,0x5b,0x57,0x54,0x4e,0x43,0x38,0x34,0x38,
0x47,0x5d,0x70,0x81,0x8c,0x91,0x92,0x93,0x92,0x8f,0x82,0x70,0x5e,0x55,0x58,0x65,
0x73,0x7b,0x7a,0x70,0x66,0x5e,0x5a,0x5b,0x55,0x4c,0x3d,0x2f,0x29,0x35,0x4d,0x69,
0x7e,0x87,0x82,0x75,0x65,0x5b,0x55,0x52,0x49,0x3f,0x34,0x2f,0x36,0x4b,0x64,0x79,
0x7f,0x7f,0x72,0x64,0x5a,0x52,0x4e,0x4a,0x43,0x3b,0x34,0x30,0x32,0x38,0x3e,0x3f,
0x3c,0x39,0x36,0x34,0x33,0x34,0x35,0x35,0x35,0x38,0x43,0x55,0x67,0x78,0x7e,0x7c,
0x72,0x64,0x5a,0x5a,0x60,0x69,0x6c,0x72,0x75,0x7b,0x84,0x8f,0x95,0x9a,0x92,0x81,
0x6b,0x57,0x47,0x3f,0x3b,0x3a,0x39,0x38,0x36,0x37,0x39,0x3e,0x41,0x42,0x3d,0x35,
0x30,0x32,0x3d,0x51,0x62,0x73,0x7c,0x7c,0x72,0x66,0x5f,0x60,0x64,0x6a,0x70,0x74,
0x7b,0x82,0x89,0x96,0x9b,0x9b,0x95,0x84,0x6e,0x5b,0x4b,0x40,0x3a,0x39,0x38,0x38,
0x38,0x38,0x3b,0x3f,0x40,0x3e,0x3b,0x38,0x35,0x36,0x36,0x37,0x39,0x3a,0x38,0x38,
0x37,0x37,0x35,0x35,0x36,0x39,0x3d,0x3f,0x3e,0x3d,0x3c,0x3a,0x3a,0x39,0x3b,0x3b,
0x3a,0x38,0x37,0x37,0x39,0x38,0x3b,0x3b,0x39,0x3a,0x3a,0x3b,0x3b,0x3b,0x39,0x39,
0x37,0x37,0x39,0x3a,0x3b,0x3b,0x3b,0x39,0x38,0x38,0x39,0x3b,0x3b,0x3b,0x3a,0x3a,
0x3a,0x3a,0x3b,0x3b,0x3b,0x3d,0x3c,0x3a,0x37,0x37,0x37,0x38,0x38,0x37,0x37,0x3a,
0x3a,0x38,0x38,0x37,0x37,0x3b,0x3b,0x3a,0x39,0x38,0x37,0x38,0x39,0x3a,0x3a,0x3b,
0x38,0x37,0x37,0x37,0x36,0x3a,0x38,0x38,0x38,0x39,0x38,0x38,0x39,0x38,0x37,0x36,
0x37,0x37,0x39,0x39,0x39,0x3b,0x3c,0x3c,0x3b,0x3b,0x3b,0x3d,0x3b,0x39,0x38,0x35,
0x32,0x32,0x34,0x37,0x39,0x3b,0x3a,0x39,0x3b,0x3c,0x3c,0x3d,0x3d,0x3e,0x3e,0x3a,
0x36,0x36,0x36,0x37,0x38,0x38,0x38,0x37,0x37,0x36,0x35,0x38,0x38,0x38,0x38,0x38,
0x37,0x39,0x38,0x37,0x37,0x39,0x39,0x39,0x37,0x38,0x38,0x39,0x37,0x38,0x3b,0x3b,
0x3a,0x3a,0x38,0x36,0x37,0x38,0x38,0x37,0x37,0x36,0x36,0x34,0x33,0x35,0x36,0x37,
0x36,0x37,0x37,0x38,0x37,0x36,0x37,0x39,0x38,0x38,0x38,0x38,0x37,0x37,0x38,0x38,
0x38,0x37,0x35,0x34,0x36,0x35,0x35,0x35,0x36,0x38,0x3a,0x3a,0x3a,0x3d,0x3d,0x3c,
0x3b,0x3b,0x3a,0x38,0x38,0x36,0x34,0x34,0x37,0x38,0x3b,0x39,0x38,0x3b,0x3b,0x3c,
0x3b,0x3b,0x3b,0x3b,0x39,0x37,0x33,0x34,0x37,0x38,0x37,0x34,0x32,0x34,0x35,0x37,
0x39,0x3b,0x3a,0x39,0x37,0x35,0x35,0x38,0x3b,0x3d,0x3b,0x37,0x35,0x36,0x38,0x38,
0x38,0x37,0x37,0x39,0x37,0x36,0x36,0x37,0x38,0x3a,0x39,0x38,0x37,0x35,0x33,0x33,
0x33,0x34,0x35,0x37,0x36,0x35,0x35,0x35,0x35,0x37,0x37,0x35,0x35,0x37,0x37,0x35,
0x35,0x36,0x37,0x38,0x38,0x36,0x38,0x36,0x34,0x37,0x38,0x38,0x39,0x3a,0x3b,0x3a,
0x37,0x35,0x37,0x38,0x38,0x37,0x37,0x36,0x35,0x34,0x34,0x35,0x37,0x38,0x35,0x35,
0x34,0x35,0x37,0x38,0x39,0x39,0x36,0x33,0x32,0x32,0x33,0x34,0x34,0x32,0x32,0x33,
0x35,0x35,0x37,0x37,0x38,0x38,0x37,0x36,0x34,0x36,0x36,0x35,0x33,0x35,0x34,0x33,
0x31,0x32,0x33,0x33,0x33,0x35,0x36,0x37,0x37,0x37,0x37,0x38,0x37,0x36,0x35,0x35,
0x34,0x35,0x35,0x34,0x33,0x34,0x33,0x30,0x33,0x34,0x35,0x37,0x38,0x39,0x3b,0x3c,
0x3a,0x3b,0x3b,0x3c,0x3b,0x3b,0x37,0x33,0x34,0x34,0x35,0x36,0x38,0x37,0x39,0x38,
0x36,0x35,0x34,0x33,0x33,0x33,0x35,0x34,0x31,0x2f,0x2e,0x32,0x33,0x30,0x30,0x32,
0x33,0x35,0x36,0x37,0x38,0x39,0x39,0x37,0x33,0x32,0x30,0x35,0x33,0x32,0x32,0x33,
0x32,0x33,0x34,0x36,0x37,0x38,0x38,0x37,0x35,0x34,0x33,0x34,0x36,0x37,0x38,0x37,
0x34,0x35,0x36,0x37,0x37,0x36,0x36,0x37,0x37,0x36,0x36,0x37,0x35,0x37,0x37,0x38,
0x36,0x35,0x34,0x33,0x33,0x33,0x33,0x34,0x33,0x33,0x34,0x35,0x34,0x36,0x38,0x39,
0x39,0x38,0x37,0x37,0x37,0x37,0x37,0x38,0x37,0x36,0x35,0x34,0x35,0x38,0x37,0x38,
0x38,0x37,0x35,0x35,0x37,0x39,0x39,0x3a,0x37,0x35,0x35,0x36,0x35,0x37,0x36,0x35,
0x37,0x39,0x39,0x38,0x38,0x38,0x37,0x38,0x37,0x36,0x39,0x36,0x32,0x31,0x31,0x32,
0x35,0x36,0x34,0x35,0x33,0x34,0x34,0x37,0x37,0x38,0x37,0x38,0x37,0x35,0x33,0x31,
0x32,0x33,0x34,0x34,0x32,0x31,0x33,0x33,0x33,0x34,0x37,0x38,0x38,0x37,0x36,0x35,
0x34,0x34,0x34,0x36,0x37,0x36,0x34,0x33,0x32,0x35,0x36,0x37,0x36,0x37,0x35,0x34,
0x33,0x34,0x34,0x39,0x38,0x38,0x38,0x38,0x38,0x38,0x37,0x37,0x38,0x3a,0x3a,0x39,
0x39,0x37,0x37,0x37,0x38,0x38,0x39,0x35,0x33,0x35,0x36,0x35,0x34,0x32,0x31,0x32,
0x33,0x34,0x36,0x37,0x36,0x35,0x37,0x37,0x38,0x3a,0x39,0x37,0x37,0x35,0x34,0x35,
0x34,0x33,0x34,0x34,0x32,0x32,0x32,0x32,0x33,0x36,0x37,0x38,0x3b,0x39,0x36,0x35,
0x34,0x35,0x35,0x35,0x34,0x35,0x34,0x32,0x32,0x32,0x34,0x36,0x37,0x37,0x35,0x33,
0x32,0x32,0x37,0x39,0x39,0x3b,0x37,0x35,0x33,0x33,0x34,0x37,0x36,0x36,0x35,0x36,
0x35,0x35,0x37,0x39,0x38,0x39,0x3a,0x3a,0x3a,0x38,0x37,0x38,0x37,0x37,0x36,0x38,
0x36,0x36,0x36,0x36,0x36,0x38,0x37,0x38,0x37,0x36,0x34,0x34,0x33,0x32,0x33,0x35,
0x35,0x34,0x33,0x32,0x33,0x35,0x36,0x37,0x38,0x38,0x37,0x36,0x35,0x37,0x39,0x39,
0x38,0x39,0x39,0x38,0x37,0x37,0x37,0x37,0x37,0x36,0x34,0x33,0x33,0x33,0x36,0x37,
0x38,0x39,0x37,0x36,0x35,0x36,0x37,0x37,0x39,0x39,0x38,0x37,0x36,0x35,0x37,0x38,
0x37,0x39,0x38,0x38,0x35,0x33,0x32,0x34,0x36,0x37,0x34,0x31,0x2f,0x30,0x32,0x33,
0x33,0x34,0x35,0x35,0x36,0x37,0x38,0x3a,0x3b,0x39,0x37,0x35,0x35,0x35,0x35,0x36,
0x36,0x38,0x38,0x38,0x39,0x38,0x37,0x39,0x38,0x36,0x36,0x35,0x32,0x34,0x34,0x36,
0x36,0x35,0x34,0x33,0x33,0x34,0x34,0x38,0x38,0x39,0x39,0x39,0x37,0x36,0x36,0x36,
0x37,0x37,0x35,0x33,0x32,0x33,0x36,0x38,0x39,0x3b,0x3b,0x38,0x34,0x35,0x35,0x36,
0x37,0x37,0x35,0x35,0x33,0x35,0x35,0x35,0x34,0x36,0x36,0x37,0x35,0x36,0x37,0x37,
0x37,0x37,0x36,0x37,0x35,0x36,0x39,0x3b,0x3b,0x3b,0x3a,0x39,0x38,0x38,0x37,0x38,
0x39,0x38,0x36,0x36,0x35,0x35,0x37,0x38,0x37,0x39,0x39,0x39,0x37,0x37,0x36,0x37,
0x39,0x3a,0x39,0x39,0x37,0x36,0x35,0x36,0x37,0x37,0x36,0x34,0x32,0x33,0x35,0x35,
0x33,0x32,0x32,0x33,0x33,0x35,0x37,0x38,0x38,0x39,0x36,0x35,0x36,0x38,0x38,0x38,
0x37,0x36,0x34,0x33,0x34,0x36,0x39,0x3a,0x38,0x39,0x39,0x37,0x37,0x37,0x37,0x38,
0x36,0x34,0x35,0x35,0x35,0x36,0x37,0x38,0x38,0x39,0x3a,0x3a,0x38,0x36,0x35,0x37,
0x36,0x36,0x37,0x35,0x34,0x34,0x34,0x35,0x36,0x37,0x37,0x35,0x33,0x32,0x32,0x33,
0x34,0x35,0x35,0x34,0x32,0x34,0x36,0x37,0x38,0x39,0x39,0x37,0x34,0x33,0x35,0x38,
0x38,0x37,0x37,0x35,0x34,0x35,0x35,0x37,0x38,0x38,0x37,0x37,0x37,0x38,0x37,0x38,
0x37,0x36,0x35,0x35,0x32,0x33,0x33,0x32,0x32,0x33,0x33,0x35,0x34,0x34,0x35,0x37,
0x37,0x36,0x35,0x34,0x34,0x35,0x34,0x33,0x34,0x34,0x33,0x33,0x33,0x33,0x35,0x35,
0x34,0x33,0x33,0x37,0x37,0x36,0x35,0x36,0x35,0x34,0x33,0x32,0x32,0x32,0x33,0x32,
0x31,0x34,0x34,0x35,0x37,0x39,0x3b,0x3b,0x3b,0x3a,0x38,0x3a,0x38,0x37,0x35,0x35,
0x34,0x35,0x35,0x35,0x35,0x35,0x34,0x35,0x35,0x37,0x37,0x37,0x37,0x37,0x37,0x36,
0x34,0x36,0x37,0x36,0x35,0x34,0x32,0x30,0x30,0x31,0x34,0x37,0x39,0x39,0x37,0x35,
0x34,0x35,0x36,0x35,0x37,0x37,0x35,0x34,0x34,0x34,0x35,0x34,0x33,0x34,0x33,0x33,
0x31,0x32,0x32,0x33,0x35,0x38,0x37,0x37,0x35,0x35,0x36,0x37,0x36,0x37,0x36,0x34,
0x33,0x33,0x34,0x34,0x33,0x34,0x35,0x38,0x38,0x38,0x38,0x38,0x38,0x39,0x37,0x35,
// Line 13
0x38,0x3a,0x39,0x38,0x38,0x3a,0x3c,0x3e,0x3b,0x39,0x36,0x35,0x34,0x34,0x33,0x33,
0x32,0x32,0x32,0x33,0x36,0x38,0x38,0x38,0x35,0x35,0x36,0x38,0x38,0x38,0x36,0x36,
0x36,0x38,0x39,0x3a,0x3b,0x3b,0x38,0x38,0x37,0x38,0x3b,0x3c,0x3a,0x37,0x33,0x31,
0x31,0x35,0x35,0x35,0x34,0x34,0x34,0x37,0x38,0x39,0x3a,0x3b,0x39,0x37,0x36,0x37,
0x38,0x3a,0x39,0x3a,0x3a,0x3b,0x3a,0x3a,0x38,0x38,0x3a,0x3a,0x38,0x36,0x35,0x35,
0x38,0x3a,0x3b,0x35,0x36,0x35,0x38,0x39,0x39,0x39,0x3b,0x38,0x35,0x35,0x35,0x38,
0x3a,0x3d,0x3a,0x39,0x36,0x34,0x32,0x33,0x34,0x36,0x36,0x36,0x36,0x38,0x38,0x37,
0x39,0x3a,0x3a,0x39,0x37,0x38,0x3a,0x3b,0x3a,0x38,0x38,0x38,0x36,0x36,0x36,0x36,
0x36,0x36,0x37,0x38,0x38,0x37,0x39,0x38,0x36,0x38,0x39,0x3a,0x39,0x38,0x36,0x36,
0x36,0x38,0x39,0x3b,0x3a,0x39,0x38,0x39,0x38,0x39,0x39,0x39,0x3a,0x3a,0x38,0x36,
0x35,0x36,0x38,0x38,0x38,0x39,0x39,0x38,0x37,0x39,0x3a,0x3a,0x38,0x39,0x38,0x38,
0x37,0x38,0x38,0x38,0x37,0x38,0x39,0x3a,0x38,0x39,0x38,0x38,0x37,0x37,0x36,0x36,
0x35,0x35,0x38,0x39,0x38,0x37,0x36,0x36,0x36,0x37,0x38,0x38,0x38,0x37,0x35,0x36,
0x35,0x37,0x38,0x39,0x38,0x39,0x38,0x37,0x37,0x37,0x36,0x37,0x37,0x37,0x34,0x37,
0x36,0x36,0x37,0x37,0x35,0x36,0x36,0x38,0x39,0x3b,0x3b,0x3b,0x39,0x39,0x39,0x3b,
0x3a,0x38,0x38,0x38,0x37,0x38,0x39,0x3a,0x3b,0x3a,0x38,0x3a,0x3b,0x3c,0x3c,0x3c,
0x3a,0x3b,0x39,0x3a,0x3a,0x3a,0x38,0x36,0x36,0x35,0x34,0x37,0x38,0x38,0x39,0x39,
0x38,0x3b,0x3b,0x3a,0x38,0x37,0x38,0x39,0x39,0x39,0x38,0x39,0x37,0x36,0x36,0x36,
0x36,0x3a,0x3b,0x3a,0x37,0x37,0x38,0x3b,0x3c,0x3b,0x38,0x39,0x37,0x35,0x35,0x36,
0x37,0x39,0x37,0x36,0x36,0x38,0x3a,0x3c,0x3b,0x3a,0x3a,0x3b,0x3a,0x39,0x39,0x3a,
0x39,0x39,0x38,0x39,0x38,0x37,0x36,0x39,0x3a,0x3b,0x3c,0x3c,0x3b,0x3e,0x3e,0x3e,
0x3e,0x3d,0x3d,0x3b,0x38,0x36,0x34,0x35,0x36,0x35,0x35,0x35,0x35,0x36,0x36,0x37,
0x39,0x3b,0x3a,0x37,0x37,0x35,0x33,0x35,0x36,0x38,0x39,0x39,0x38,0x3a,0x3b,0x3d,
0x3c,0x3b,0x39,0x3a,0x39,0x36,0x34,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3d,0x3c,0x3b,
0x3b,0x3a,0x39,0x39,0x38,0x38,0x38,0x39,0x3a,0x3a,0x3c,0x3c,0x39,0x3a,0x3a,0x38,
0x37,0x36,0x36,0x37,0x37,0x37,0x38,0x39,0x39,0x3b,0x3b,0x3b,0x39,0x38,0x37,0x39,
0x3a,0x3a,0x3a,0x3b,0x39,0x38,0x38,0x39,0x39,0x3a,0x39,0x38,0x36,0x38,0x39,0x3a,
0x3b,0x3b,0x3a,0x39,0x37,0x36,0x37,0x38,0x35,0x35,0x34,0x34,0x33,0x35,0x36,0x39,
0x3a,0x3a,0x38,0x38,0x37,0x39,0x3c,0x3d,0x3c,0x3b,0x38,0x36,0x36,0x38,0x3a,0x3b,
0x39,0x38,0x38,0x3a,0x3a,0x3a,0x3a,0x3b,0x3c,0x3d,0x3c,0x3b,0x3b,0x3b,0x39,0x38,
0x37,0x39,0x38,0x38,0x36,0x36,0x35,0x36,0x36,0x37,0x36,0x36,0x38,0x38,0x38,0x39,
0x38,0x36,0x36,0x36,0x36,0x37,0x37,0x36,0x36,0x38,0x36,0x36,0x38,0x3a,0x3b,0x3e,
0x3e,0x3e,0x3e,0x3b,0x38,0x38,0x38,0x3a,0x38,0x39,0x37,0x38,0x38,0x3a,0x3b,0x3a,
0x3b,0x3b,0x3d,0x3b,0x3a,0x3b,0x3b,0x3a,0x3a,0x3a,0x3a,0x3a,0x38,0x38,0x3a,0x3b,
0x38,0x36,0x35,0x35,0x35,0x36,0x38,0x39,0x39,0x38,0x37,0x38,0x39,0x3a,0x3a,0x3a,
0x38,0x38,0x38,0x38,0x33,0x34,0x35,0x36,0x36,0x38,0x38,0x39,0x38,0x37,0x38,0x38,
0x38,0x39,0x38,0x35,0x31,0x32,0x34,0x36,0x38,0x38,0x3a,0x3c,0x3c,0x3c,0x3e,0x3e,
0x3c,0x3b,0x39,0x3a,0x38,0x38,0x36,0x38,0x39,0x39,0x35,0x3a,0x39,0x3a,0x3a,0x3a,
0x38,0x3b,0x3a,0x39,0x38,0x38,0x3a,0x3b,0x3b,0x39,0x39,0x3b,0x3b,0x39,0x36,0x36,
0x37,0x3a,0x3a,0x38,0x36,0x35,0x36,0x38,0x38,0x39,0x38,0x38,0x36,0x36,0x35,0x35,
0x35,0x38,0x38,0x36,0x36,0x35,0x36,0x38,0x38,0x38,0x39,0x3a,0x3a,0x3a,0x39,0x36,
0x36,0x38,0x3a,0x3a,0x37,0x35,0x34,0x36,0x35,0x35,0x36,0x39,0x39,0x3a,0x37,0x36,
0x36,0x38,0x38,0x38,0x38,0x3a,0x39,0x3b,0x39,0x39,0x3a,0x3a,0x39,0x3b,0x3a,0x38,
0x37,0x37,0x37,0x36,0x35,0x35,0x38,0x39,0x39,0x37,0x36,0x35,0x36,0x39,0x3a,0x3b,
0x3c,0x3c,0x3a,0x39,0x37,0x38,0x39,0x38,0x36,0x35,0x33,0x34,0x33,0x34,0x36,0x38,
0x3a,0x3a,0x39,0x3b,0x3b,0x3c,0x3b,0x3a,0x39,0x38,0x36,0x34,0x34,0x35,0x36,0x35,
0x36,0x36,0x36,0x38,0x38,0x38,0x39,0x39,0x38,0x39,0x3a,0x3b,0x3b,0x3b,0x3a,0x3a,
0x39,0x3a,0x38,0x37,0x35,0x36,0x39,0x39,0x38,0x38,0x38,0x36,0x36,0x36,0x36,0x37,
0x35,0x33,0x34,0x36,0x36,0x36,0x37,0x37,0x36,0x35,0x35,0x34,0x36,0x38,0x3a,0x3b,
0x3a,0x39,0x39,0x38,0x37,0x38,0x38,0x38,0x36,0x35,0x35,0x36,0x36,0x38,0x39,0x3b,
0x39,0x38,0x37,0x37,0x37,0x37,0x36,0x33,0x34,0x35,0x35,0x35,0x33,0x34,0x34,0x35,
0x34,0x33,0x34,0x37,0x37,0x38,0x38,0x38,0x38,0x39,0x38,0x38,0x38,0x3a,0x39,0x38,
0x35,0x35,0x36,0x37,0x36,0x36,0x35,0x35,0x36,0x36,0x36,0x35,0x32,0x32,0x32,0x34,
0x35,0x36,0x37,0x38,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x35,0x34,0x35,0x37,0x38,
0x36,0x37,0x38,0x3a,0x38,0x38,0x37,0x35,0x34,0x32,0x31,0x33,0x35,0x36,0x38,0x37,
0x36,0x36,0x35,0x34,0x35,0x36,0x36,0x37,0x36,0x35,0x35,0x37,0x38,0x38,0x37,0x37,
0x36,0x38,0x37,0x37,0x37,0x36,0x35,0x36,0x36,0x37,0x39,0x39,0x38,0x36,0x37,0x38,
0x38,0x3a,0x3a,0x38,0x36,0x36,0x37,0x3a,0x3b,0x3b,0x3a,0x39,0x39,0x39,0x38,0x38,
0x37,0x39,0x39,0x37,0x36,0x36,0x36,0x38,0x37,0x37,0x38,0x37,0x36,0x37,0x36,0x37,
0x35,0x36,0x36,0x37,0x38,0x38,0x36,0x35,0x35,0x35,0x36,0x38,0x38,0x39,0x39,0x38,
0x37,0x36,0x36,0x34,0x36,0x35,0x35,0x36,0x37,0x36,0x36,0x35,0x36,0x39,0x39,0x39,
0x38,0x38,0x36,0x35,0x34,0x36,0x37,0x38,0x37,0x36,0x37,0x38,0x38,0x38,0x38,0x39,
0x39,0x38,0x36,0x36,0x34,0x35,0x36,0x38,0x37,0x38,0x38,0x37,0x36,0x38,0x39,0x3a,
0x3a,0x38,0x36,0x37,0x37,0x38,0x37,0x36,0x36,0x38,0x38,0x39,0x39,0x3a,0x39,0x38,
0x38,0x38,0x37,0x36,0x37,0x38,0x39,0x39,0x37,0x38,0x38,0x37,0x36,0x37,0x38,0x38,
0x36,0x36,0x35,0x35,0x34,0x34,0x34,0x34,0x32,0x34,0x34,0x34,0x35,0x37,0x38,0x3b,
0x3b,0x3c,0x3c,0x3a,0x36,0x35,0x36,0x37,0x34,0x33,0x33,0x34,0x34,0x34,0x34,0x37,
0x38,0x38,0x39,0x3a,0x3a,0x38,0x38,0x38,0x37,0x39,0x38,0x36,0x36,0x36,0x34,0x35,
0x35,0x36,0x39,0x3a,0x38,0x38,0x38,0x39,0x39,0x39,0x38,0x37,0x38,0x3a,0x3a,0x3a,
0x39,0x38,0x38,0x38,0x37,0x38,0x37,0x36,0x35,0x35,0x35,0x35,0x36,0x38,0x39,0x3a,
0x3a,0x39,0x39,0x38,0x36,0x38,0x37,0x37,0x36,0x36,0x34,0x35,0x34,0x36,0x36,0x38,
0x38,0x39,0x3a,0x3b,0x3a,0x3b,0x3b,0x39,0x3b,0x3a,0x38,0x37,0x35,0x34,0x34,0x36,
0x38,0x3a,0x39,0x38,0x36,0x37,0x38,0x39,0x3a,0x39,0x38,0x38,0x36,0x38,0x38,0x39,
0x38,0x3a,0x3b,0x3b,0x3a,0x3b,0x3a,0x38,0x37,0x37,0x37,0x39,0x38,0x36,0x36,0x35,
0x34,0x36,0x36,0x37,0x37,0x38,0x37,0x36,0x35,0x35,0x35,0x35,0x36,0x38,0x38,0x38,
0x36,0x37,0x36,0x35,0x35,0x34,0x35,0x37,0x36,0x35,0x34,0x34,0x34,0x36,0x38,0x3a,
0x3a,0x3a,0x39,0x36,0x38,0x38,0x38,0x3a,0x39,0x37,0x35,0x34,0x34,0x35,0x36,0x36,
0x35,0x35,0x34,0x36,0x37,0x38,0x38,0x38,0x37,0x35,0x34,0x34,0x36,0x39,0x38,0x37,
0x36,0x36,0x35,0x35,0x36,0x38,0x39,0x38,0x37,0x36,0x38,0x37,0x38,0x39,0x39,0x38,
0x37,0x37,0x36,0x36,0x36,0x36,0x36,0x38,0x38,0x38,0x37,0x36,0x34,0x36,0x36,0x36,
0x36,0x38,0x38,0x38,0x36,0x37,0x37,0x38,0x39,0x39,0x3a,0x39,0x38,0x37,0x36,0x37,
0x3a,0x3b,0x3a,0x38,0x34,0x34,0x35,0x35,0x34,0x34,0x35,0x33,0x32,0x35,0x37,0x39,
0x39,0x39,0x38,0x38,0x37,0x38,0x38,0x36,0x32,0x31,0x31,0x33,0x34,0x36,0x38,0x37,
0x35,0x34,0x33,0x36,0x35,0x36,0x38,0x38,0x37,0x37,0x35,0x34,0x34,0x33,0x33,0x31,
0x31,0x31,0x32,0x32,0x31,0x33,0x35,0x36,0x36,0x38,0x3a,0x3a,0x38,0x37,0x37,0x39,
0x39,0x3b,0x3a,0x39,0x36,0x34,0x34,0x34,0x33,0x34,0x34,0x34,0x35,0x36,0x35,0x36,
0x36,0x36,0x37,0x38,0x38,0x35,0x37,0x36,0x34,0x35,0x36,0x37,0x37,0x38,0x37,0x38,
0x36,0x34,0x33,0x34,0x33,0x34,0x35,0x37,0x36,0x37,0x35,0x35,0x36,0x38,0x38,0x39,
0x38,0x36,0x36,0x36,0x36,0x36,0x36,0x37,0x38,0x3a,0x39,0x37,0x36,0x37,0x35,0x35,
0x36,0x37,0x37,0x36,0x33,0x35,0x35,0x36,0x38,0x39,0x39,0x39,0x39,0x38,0x38,0x38,
0x38,0x38,0x39,0x3a,0x37,0x37,0x35,0x35,0x36,0x36,0x36,0x38,0x39,0x38,0x38,0x38,
0x38,0x3a,0x3a,0x3a,0x38,0x3a,0x38,0x37,0x37,0x37,0x35,0x35,0x35,0x35,0x35,0x36,
0x34,0x36,0x37,0x38,0x37,0x37,0x36,0x35,0x35,0x36,0x36,0x36,0x34,0x33,0x34,0x34,
0x35,0x35,0x35,0x35,0x35,0x36,0x34,0x35,0x35,0x35,0x34,0x34,0x33,0x34,0x38,0x37,
0x36,0x37,0x38,0x39,0x38,0x37,0x37,0x38,0x38,0x39,0x38,0x38,0x37,0x36,0x38,0x38,
0x37,0x39,0x39,0x37,0x36,0x36,0x36,0x37,0x35,0x35,0x35,0x35,0x34,0x32,0x32,0x34,
// Line 14
0x39,0x38,0x3a,0x3c,0x3e,0x40,0x3f,0x3d,0x3c,0x39,0x38,0x3a,0x39,0x37,0x38,0x39,
0x38,0x39,0x37,0x36,0x36,0x38,0x38,0x38,0x38,0x3a,0x38,0x38,0x36,0x36,0x37,0x37,
0x35,0x35,0x35,0x35,0x34,0x34,0x35,0x38,0x39,0x3b,0x3b,0x39,0x38,0x38,0x3a,0x3a,
0x39,0x3d,0x3e,0x3f,0x42,0x46,0x4c,0x54,0x5e,0x68,0x71,0x7a,0x82,0x87,0x8f,0x93,
0x96,0x98,0x9a,0x9a,0x98,0x96,0x95,0x96,0x96,0x98,0x98,0x97,0x96,0x95,0x95,0x91,
0x8a,0x84,0x7c,0x72,0x6a,0x62,0x5a,0x53,0x4b,0x46,0x42,0x3e,0x3c,0x3c,0x3a,0x38,
0x37,0x39,0x38,0x36,0x37,0x38,0x39,0x3b,0x3b,0x3b,0x3c,0x3b,0x3b,0x40,0x46,0x4d,
0x55,0x5e,0x66,0x70,0x79,0x83,0x8c,0x93,0x97,0x99,0x9a,0x99,0x98,0x9a,0x99,0x99,
0x9a,0x9a,0x98,0x97,0x95,0x93,0x92,0x90,0x8c,0x86,0x7f,0x77,0x6d,0x66,0x5e,0x58,
0x52,0x4c,0x44,0x40,0x3b,0x3a,0x36,0x37,0x35,0x34,0x35,0x36,0x34,0x36,0x35,0x36,
0x3a,0x3b,0x3b,0x3b,0x3b,0x3e,0x44,0x4a,0x52,0x5b,0x64,0x6d,0x76,0x7f,0x87,0x8e,
0x93,0x96,0x98,0x98,0x97,0x98,0x98,0x97,0x96,0x96,0x94,0x94,0x94,0x94,0x93,0x92,
0x90,0x8c,0x84,0x80,0x74,0x6a,0x63,0x5c,0x55,0x51,0x4a,0x41,0x3b,0x38,0x38,0x38,
0x37,0x37,0x38,0x38,0x36,0x36,0x37,0x39,0x3a,0x3b,0x3b,0x3c,0x3c,0x3e,0x41,0x46,
0x4c,0x54,0x5b,0x63,0x6b,0x75,0x7e,0x86,0x8b,0x90,0x95,0x98,0x9b,0x9c,0x9b,0x9b,
0x9a,0x98,0x96,0x95,0x96,0x98,0x98,0x97,0x96,0x95,0x90,0x88,0x7e,0x76,0x6d,0x67,
0x5d,0x55,0x4d,0x45,0x3e,0x3c,0x3c,0x3e,0x3c,0x3b,0x38,0x37,0x36,0x38,0x37,0x3b,
0x3b,0x3b,0x3b,0x3b,0x3b,0x3e,0x41,0x44,0x48,0x4d,0x53,0x5b,0x65,0x6f,0x79,0x82,
0x88,0x8a,0x8f,0x91,0x92,0x95,0x96,0x98,0x98,0x98,0x97,0x97,0x96,0x98,0x9a,0x9b,
0x99,0x96,0x92,0x8e,0x88,0x82,0x78,0x6f,0x67,0x5f,0x55,0x4e,0x47,0x43,0x3f,0x3c,
0x3a,0x3a,0x3a,0x39,0x39,0x39,0x38,0x36,0x38,0x39,0x3a,0x3c,0x3d,0x3d,0x3b,0x3d,
0x40,0x47,0x4e,0x56,0x5f,0x69,0x71,0x7a,0x83,0x8b,0x91,0x96,0x98,0x98,0x9b,0x9b,
0x9b,0x9b,0x9a,0x9a,0x9a,0x98,0x97,0x99,0x98,0x96,0x93,0x90,0x8b,0x84,0x7c,0x72,
0x69,0x63,0x5c,0x53,0x4a,0x43,0x3f,0x3f,0x3e,0x3e,0x3c,0x40,0x3e,0x3c,0x3b,0x3b,
0x3b,0x3d,0x3b,0x3b,0x39,0x3a,0x3a,0x3c,0x3f,0x45,0x4d,0x54,0x5a,0x63,0x6b,0x74,
0x7d,0x86,0x8e,0x92,0x94,0x96,0x97,0x9a,0x9a,0x9b,0x9b,0x99,0x97,0x96,0x96,0x98,
0x9a,0x9a,0x99,0x96,0x91,0x8c,0x84,0x7f,0x75,0x6c,0x65,0x5d,0x54,0x4c,0x44,0x3f,
0x3d,0x3d,0x3d,0x3c,0x3d,0x3c,0x3b,0x3c,0x3d,0x3b,0x3d,0x3e,0x3e,0x3e,0x3e,0x3c,
0x3b,0x3c,0x3c,0x3d,0x3c,0x3c,0x3c,0x3c,0x3b,0x3a,0x38,0x39,0x3b,0x3d,0x3d,0x3d,
0x3d,0x3c,0x3b,0x3d,0x3b,0x3b,0x3c,0x3e,0x3e,0x3d,0x3b,0x3b,0x3b,0x3c,0x3c,0x3c,
0x3c,0x3c,0x3b,0x3b,0x3a,0x39,0x3b,0x3b,0x38,0x3b,0x3b,0x3c,0x3c,0x3e,0x3d,0x3e,
0x3e,0x3f,0x3f,0x40,0x40,0x3e,0x3f,0x3e,0x3d,0x3d,0x3b,0x3a,0x3b,0x3c,0x3d,0x3c,
0x3b,0x3b,0x3b,0x3b,0x3a,0x3a,0x39,0x39,0x38,0x38,0x38,0x38,0x36,0x37,0x38,0x3b,
0x3b,0x3d,0x3d,0x3e,0x3b,0x3a,0x3d,0x42,0x47,0x4e,0x55,0x5b,0x64,0x6c,0x74,0x7f,
0x87,0x8c,0x90,0x92,0x92,0x94,0x97,0x99,0x9a,0x9a,0x99,0x99,0x97,0x97,0x96,0x97,
0x95,0x93,0x92,0x92,0x93,0x98,0x9a,0x9a,0x98,0x97,0x96,0x98,0x98,0x99,0x98,0x98,
0x96,0x95,0x95,0x97,0x98,0x9a,0x99,0x99,0x9a,0x9b,0x9b,0x9b,0x99,0x98,0x95,0x92,
0x8d,0x86,0x7c,0x70,0x63,0x5a,0x53,0x4f,0x4a,0x44,0x40,0x3e,0x3a,0x3a,0x3a,0x3c,
0x3d,0x3e,0x3c,0x3a,0x36,0x3a,0x37,0x36,0x37,0x3a,0x3c,0x3b,0x38,0x35,0x34,0x37,
0x3a,0x3a,0x3b,0x3b,0x3c,0x3d,0x3b,0x39,0x3b,0x3c,0x3f,0x41,0x3e,0x3b,0x3b,0x3a,
0x38,0x38,0x37,0x35,0x34,0x36,0x35,0x35,0x35,0x37,0x3a,0x3b,0x39,0x3a,0x3b,0x3d,
0x3b,0x3b,0x39,0x38,0x3a,0x3b,0x3a,0x37,0x34,0x34,0x35,0x36,0x36,0x35,0x34,0x34,
0x33,0x37,0x39,0x3c,0x3c,0x3c,0x39,0x38,0x38,0x3a,0x3c,0x3e,0x3c,0x39,0x38,0x38,
0x39,0x3d,0x3d,0x3c,0x3d,0x3f,0x3e,0x3b,0x39,0x39,0x3b,0x3b,0x39,0x38,0x37,0x38,
0x3a,0x39,0x38,0x39,0x38,0x38,0x37,0x38,0x38,0x39,0x39,0x3a,0x38,0x39,0x39,0x3a,
0x3a,0x3b,0x3a,0x39,0x38,0x38,0x37,0x38,0x38,0x39,0x3b,0x3c,0x3b,0x3c,0x3b,0x3b,
0x3a,0x39,0x38,0x38,0x37,0x35,0x32,0x33,0x33,0x35,0x37,0x3a,0x3a,0x3b,0x3b,0x3b,
0x3c,0x3b,0x38,0x3a,0x39,0x38,0x36,0x34,0x32,0x33,0x37,0x3e,0x45,0x50,0x58,0x5f,
0x68,0x71,0x7a,0x84,0x8a,0x8f,0x94,0x96,0x95,0x92,0x90,0x90,0x91,0x93,0x95,0x95,
0x96,0x96,0x96,0x97,0x97,0x98,0x99,0x9b,0x9a,0x99,0x98,0x98,0x9a,0x9a,0x98,0x98,
0x98,0x98,0x96,0x9a,0x98,0x98,0x98,0x98,0x97,0x98,0x98,0x98,0x99,0x9a,0x99,0x98,
0x95,0x94,0x94,0x91,0x8b,0x81,0x78,0x70,0x67,0x60,0x58,0x53,0x4d,0x48,0x42,0x3e,
0x3c,0x3c,0x3e,0x3d,0x3b,0x39,0x38,0x3a,0x3a,0x3b,0x3a,0x39,0x38,0x39,0x38,0x38,
0x38,0x38,0x3a,0x3b,0x3b,0x3b,0x3b,0x3b,0x3c,0x3c,0x3b,0x3a,0x3a,0x3b,0x3b,0x3b,
0x38,0x39,0x3b,0x3c,0x3b,0x3b,0x3a,0x38,0x37,0x37,0x37,0x39,0x39,0x39,0x38,0x38,
0x36,0x36,0x36,0x38,0x38,0x39,0x39,0x38,0x38,0x38,0x3a,0x3b,0x3a,0x37,0x37,0x36,
0x36,0x34,0x36,0x35,0x34,0x37,0x39,0x3b,0x3b,0x3c,0x3b,0x3d,0x3d,0x3e,0x3d,0x3b,
0x38,0x38,0x38,0x39,0x38,0x37,0x36,0x36,0x36,0x37,0x38,0x3b,0x3c,0x3b,0x3c,0x3c,
0x3c,0x3c,0x3c,0x3c,0x3e,0x43,0x47,0x4a,0x53,0x5a,0x61,0x6b,0x72,0x7b,0x84,0x8c,
0x8e,0x92,0x94,0x95,0x94,0x94,0x94,0x95,0x95,0x96,0x94,0x94,0x93,0x93,0x93,0x93,
0x94,0x96,0x96,0x95,0x96,0x98,0x9b,0x9a,0x98,0x98,0x99,0x98,0x98,0x96,0x94,0x94,
0x94,0x97,0x97,0x97,0x98,0x9a,0x98,0x96,0x95,0x97,0x98,0x98,0x94,0x90,0x89,0x82,
0x78,0x70,0x67,0x5e,0x57,0x4f,0x49,0x44,0x3f,0x3b,0x3a,0x38,0x38,0x38,0x38,0x38,
0x38,0x39,0x39,0x38,0x38,0x39,0x3a,0x3c,0x3a,0x39,0x3a,0x3a,0x38,0x3b,0x3b,0x3d,
0x3c,0x3c,0x3a,0x3a,0x39,0x39,0x36,0x3a,0x38,0x38,0x38,0x3a,0x3a,0x3d,0x3c,0x3b,
0x3b,0x3b,0x3b,0x3b,0x39,0x39,0x3d,0x43,0x47,0x4d,0x53,0x5b,0x62,0x6c,0x75,0x7e,
0x87,0x8c,0x91,0x95,0x98,0x9b,0x9b,0x9b,0x98,0x98,0x98,0x97,0x94,0x93,0x92,0x93,
0x93,0x94,0x94,0x94,0x94,0x94,0x94,0x95,0x95,0x97,0x98,0x98,0x98,0x98,0x99,0x98,
0x9b,0x9b,0x9a,0x9a,0x98,0x97,0x97,0x97,0x97,0x98,0x99,0x99,0x98,0x97,0x93,0x90,
0x8b,0x86,0x7c,0x73,0x69,0x60,0x57,0x4f,0x47,0x43,0x3f,0x3b,0x3a,0x3a,0x3b,0x3c,
0x3c,0x3c,0x3c,0x3c,0x3b,0x3a,0x3c,0x3b,0x3b,0x3d,0x3c,0x3b,0x3b,0x39,0x37,0x39,
0x39,0x3b,0x38,0x3b,0x3b,0x3b,0x3a,0x3a,0x3a,0x3c,0x3c,0x3c,0x3b,0x39,0x37,0x37,
0x36,0x37,0x38,0x38,0x38,0x39,0x39,0x37,0x36,0x39,0x3c,0x3c,0x3b,0x3d,0x3b,0x3b,
0x39,0x39,0x3a,0x3a,0x38,0x38,0x37,0x37,0x36,0x38,0x38,0x3a,0x3b,0x3b,0x39,0x3b,
0x3a,0x38,0x3a,0x3a,0x38,0x38,0x38,0x38,0x39,0x3a,0x3b,0x3b,0x3b,0x3a,0x38,0x3a,
0x3a,0x39,0x38,0x38,0x38,0x3a,0x39,0x3a,0x39,0x3a,0x3a,0x3c,0x3a,0x3a,0x3b,0x3d,
0x3e,0x40,0x44,0x4a,0x51,0x5a,0x62,0x6b,0x75,0x7d,0x83,0x88,0x8c,0x91,0x96,0x98,
0x99,0x99,0x97,0x94,0x94,0x98,0x9c,0x9e,0x9b,0x9b,0x98,0x98,0x98,0x98,0x9a,0x9b,
0x99,0x97,0x96,0x96,0x98,0x9a,0x9a,0x9b,0x9b,0x9b,0x99,0x98,0x98,0x9b,0x9b,0x9a,
0x97,0x99,0x99,0x98,0x98,0x97,0x97,0x95,0x94,0x94,0x96,0x98,0x9b,0x9b,0x9a,0x99,
0x98,0x99,0x9a,0x9a,0x98,0x98,0x96,0x96,0x96,0x98,0x9a,0x99,0x96,0x95,0x96,0x97,
0x97,0x97,0x96,0x97,0x97,0x98,0x97,0x98,0x99,0x99,0x9a,0x99,0x98,0x98,0x97,0x97,
0x96,0x96,0x96,0x96,0x98,0x98,0x97,0x98,0x96,0x96,0x97,0x97,0x96,0x98,0x98,0x98,
0x97,0x95,0x91,0x8d,0x87,0x81,0x78,0x6d,0x64,0x5d,0x57,0x51,0x4b,0x47,0x44,0x41,
0x3f,0x3d,0x3c,0x3b,0x38,0x37,0x36,0x37,0x38,0x3a,0x3c,0x3c,0x3b,0x3c,0x3b,0x3b,
0x3b,0x3b,0x3a,0x3b,0x3b,0x3b,0x3a,0x39,0x38,0x3b,0x3b,0x3c,0x3d,0x3e,0x3e,0x3e,
0x3d,0x3d,0x3c,0x3e,0x3d,0x3c,0x3b,0x3a,0x38,0x38,0x38,0x39,0x3b,0x3a,0x3a,0x3b,
0x3a,0x3a,0x38,0x3a,0x3a,0x3b,0x3b,0x3c,0x3a,0x3a,0x3a,0x39,0x38,0x38,0x38,0x3a,
0x38,0x38,0x37,0x38,0x38,0x3a,0x3b,0x3b,0x39,0x3c,0x38,0x38,0x3b,0x3c,0x3c,0x3b,
0x38,0x36,0x36,0x38,0x3b,0x3c,0x3e,0x3c,0x39,0x39,0x3a,0x3a,0x3c,0x3c,0x3b,0x3c,
0x3a,0x38,0x36,0x38,0x37,0x3a,0x3b,0x3a,0x38,0x38,0x37,0x37,0x36,0x37,0x37,0x38,
0x38,0x38,0x38,0x3a,0x3a,0x3b,0x3b,0x38,0x38,0x38,0x38,0x36,0x3a,0x3b,0x3b,0x3c,
0x3a,0x3a,0x3d,0x3c,0x3a,0x3a,0x3a,0x39,0x36,0x36,0x35,0x37,0x37,0x38,0x35,0x37,
0x37,0x38,0x3a,0x3a,0x38,0x36,0x34,0x35,0x38,0x39,0x38,0x38,0x36,0x35,0x36,0x38,
0x3a,0x3b,0x3a,0x39,0x37,0x3a,0x3b,0x3b,0x3c,0x3c,0x3b,0x3c,0x3b,0x3a,0x38,0x39,
0x38,0x37,0x35,0x36,0x36,0x38,0x38,0x38,0x3a,0x3c,0x3c,0x3c,0x3c,0x3c,0x3d,0x3e,
// Line 15
0x3a,0x3b,0x3b,0x3a,0x36,0x36,0x36,0x39,0x38,0x36,0x34,0x33,0x35,0x36,0x38,0x3a,
0x39,0x37,0x36,0x36,0x35,0x36,0x36,0x36,0x35,0x34,0x33,0x33,0x34,0x37,0x38,0x38,
0x36,0x36,0x36,0x35,0x34,0x35,0x34,0x35,0x36,0x36,0x35,0x35,0x36,0x38,0x36,0x3b,
0x38,0x3b,0x3d,0x3e,0x3b,0x3a,0x36,0x39,0x43,0x52,0x62,0x72,0x7a,0x7b,0x72,0x66,
0x5b,0x58,0x5d,0x66,0x71,0x79,0x7a,0x75,0x6d,0x66,0x62,0x65,0x6a,0x72,0x77,0x78,
0x71,0x6c,0x67,0x64,0x60,0x62,0x68,0x6f,0x75,0x78,0x78,0x76,0x6a,0x61,0x5f,0x62,
0x69,0x72,0x77,0x77,0x73,0x6e,0x67,0x60,0x5f,0x62,0x69,0x72,0x78,0x78,0x77,0x71,
0x6a,0x64,0x61,0x65,0x6b,0x74,0x78,0x7a,0x78,0x72,0x6a,0x64,0x62,0x67,0x6f,0x78,
0x7f,0x81,0x7c,0x72,0x68,0x62,0x61,0x64,0x6a,0x70,0x73,0x74,0x74,0x75,0x7e,0x89,
0x97,0xa5,0xac,0xac,0xa6,0x9c,0x8c,0x7f,0x72,0x69,0x61,0x59,0x4f,0x48,0x40,0x3b,
0x38,0x3d,0x4a,0x5b,0x6e,0x80,0x8e,0x98,0x9b,0x9d,0x9f,0xa1,0xa2,0xa2,0x9d,0x95,
0x8a,0x7c,0x6e,0x64,0x5f,0x62,0x69,0x72,0x7a,0x81,0x87,0x8c,0x90,0x99,0xa1,0xa6,
0xa7,0xa5,0xa0,0x9b,0x97,0x97,0x98,0x9a,0x96,0x8d,0x7d,0x6b,0x5c,0x58,0x58,0x62,
0x70,0x7e,0x83,0x81,0x78,0x6b,0x64,0x63,0x67,0x6e,0x78,0x7c,0x79,0x74,0x6a,0x64,
0x60,0x63,0x6a,0x74,0x7a,0x7e,0x7b,0x73,0x6a,0x66,0x65,0x6a,0x6f,0x75,0x78,0x77,
0x71,0x6a,0x64,0x60,0x5f,0x5d,0x59,0x52,0x48,0x3d,0x30,0x2c,0x2d,0x34,0x3b,0x41,
0x4d,0x5b,0x68,0x74,0x78,0x78,0x72,0x68,0x60,0x60,0x66,0x71,0x7b,0x7e,0x79,0x71,
0x66,0x5e,0x5d,0x62,0x6a,0x74,0x79,0x79,0x75,0x71,0x6b,0x65,0x62,0x61,0x5d,0x55,
0x48,0x3b,0x2e,0x28,0x26,0x2b,0x34,0x3d,0x4a,0x56,0x5e,0x67,0x72,0x81,0x8e,0x99,
0x9c,0x9b,0x94,0x86,0x74,0x64,0x54,0x48,0x3e,0x39,0x38,0x3b,0x42,0x4e,0x5b,0x6e,
0x79,0x87,0x91,0x99,0x9c,0x9f,0x9f,0xa0,0xa1,0x9f,0x99,0x8a,0x7d,0x6e,0x60,0x5c,
0x5d,0x64,0x73,0x7c,0x80,0x80,0x77,0x6b,0x62,0x60,0x65,0x6f,0x75,0x7a,0x79,0x72,
0x64,0x5b,0x59,0x61,0x6a,0x75,0x79,0x79,0x74,0x6b,0x62,0x5c,0x58,0x58,0x58,0x54,
0x4b,0x3f,0x36,0x2d,0x2c,0x35,0x3f,0x47,0x4b,0x46,0x3b,0x33,0x30,0x38,0x4b,0x62,
0x71,0x79,0x78,0x71,0x65,0x5a,0x50,0x4b,0x48,0x43,0x3b,0x34,0x2e,0x2f,0x35,0x3b,
0x3f,0x41,0x40,0x3b,0x37,0x35,0x33,0x33,0x33,0x33,0x34,0x3d,0x49,0x57,0x6b,0x79,
0x83,0x8c,0x92,0x98,0x9e,0xa5,0xa8,0xa6,0xa1,0x9c,0x98,0x97,0x9a,0x9e,0x9f,0x97,
0x86,0x72,0x61,0x59,0x5b,0x66,0x75,0x7d,0x7e,0x79,0x71,0x68,0x60,0x5b,0x58,0x51,
0x44,0x38,0x2d,0x27,0x27,0x2d,0x36,0x42,0x4d,0x57,0x60,0x6d,0x79,0x87,0x95,0x9f,
0xa2,0x9f,0x93,0x86,0x78,0x6a,0x5d,0x52,0x45,0x3b,0x37,0x3a,0x44,0x57,0x6b,0x7a,
0x81,0x7e,0x73,0x66,0x5e,0x58,0x54,0x50,0x47,0x3e,0x37,0x39,0x47,0x5e,0x76,0x87,
0x8a,0x81,0x71,0x64,0x5d,0x61,0x6a,0x73,0x77,0x7a,0x7f,0x87,0x92,0x9f,0xa6,0xa9,
0xa8,0xa4,0x9e,0x9b,0x9b,0x9d,0x9e,0x9e,0x9f,0xa2,0xa5,0xa6,0xa2,0x9b,0x8d,0x7c,
0x6d,0x64,0x60,0x60,0x63,0x6a,0x72,0x7f,0x87,0x92,0x9a,0x9d,0x99,0x8f,0x7e,0x6e,
0x60,0x53,0x45,0x3c,0x36,0x36,0x3b,0x47,0x58,0x6c,0x7a,0x81,0x7e,0x75,0x69,0x5b,
0x51,0x4b,0x47,0x44,0x3e,0x37,0x33,0x30,0x2e,0x35,0x3e,0x49,0x57,0x65,0x71,0x78,
0x79,0x77,0x6f,0x69,0x64,0x65,0x6d,0x75,0x7a,0x7c,0x7c,0x80,0x89,0x96,0xa4,0xae,
0xaf,0xa9,0xa0,0x98,0x95,0x97,0x9c,0xa0,0x9e,0x98,0x88,0x75,0x65,0x5c,0x5b,0x64,
0x6f,0x7b,0x82,0x7f,0x72,0x64,0x5b,0x5d,0x68,0x77,0x7f,0x7f,0x78,0x6e,0x65,0x61,
0x62,0x64,0x62,0x57,0x44,0x32,0x2a,0x32,0x48,0x64,0x79,0x84,0x80,0x76,0x69,0x5f,
0x56,0x50,0x4b,0x40,0x37,0x34,0x39,0x4b,0x64,0x7b,0x83,0x82,0x77,0x69,0x5a,0x50,
0x4b,0x48,0x44,0x3c,0x32,0x2c,0x2d,0x35,0x40,0x48,0x47,0x40,0x36,0x32,0x35,0x3f,
0x4e,0x5c,0x6b,0x77,0x81,0x8e,0x98,0x9d,0x9c,0x92,0x81,0x6f,0x62,0x5e,0x61,0x68,
0x6e,0x77,0x7f,0x88,0x8f,0x97,0x9c,0x9b,0x93,0x83,0x6f,0x5f,0x55,0x58,0x64,0x71,
0x7a,0x7f,0x7a,0x6f,0x64,0x5c,0x58,0x51,0x4c,0x42,0x36,0x30,0x33,0x40,0x58,0x6f,
0x84,0x92,0x95,0x97,0x96,0x99,0x9c,0xa0,0xa2,0x9e,0x94,0x85,0x75,0x69,0x61,0x60,
0x60,0x66,0x6d,0x75,0x7c,0x85,0x8c,0x95,0x9a,0x9a,0x93,0x86,0x73,0x61,0x51,0x47,
0x3f,0x3e,0x3b,0x3b,0x40,0x4a,0x57,0x6a,0x7b,0x89,0x94,0x97,0x97,0x9b,0x9f,0xa4,
0xa5,0xa2,0x99,0x8b,0x7b,0x6d,0x60,0x5d,0x60,0x68,0x74,0x7d,0x7f,0x7b,0x71,0x66,
0x61,0x60,0x65,0x6d,0x72,0x75,0x78,0x7c,0x82,0x8f,0x9c,0xa7,0xaa,0xa8,0xa1,0x9c,
0x99,0x99,0x9a,0x9d,0x9d,0x9e,0x9e,0x9f,0x9e,0x9e,0x98,0x8d,0x7c,0x6a,0x5e,0x58,
0x5e,0x67,0x6f,0x75,0x77,0x74,0x6d,0x65,0x5e,0x59,0x54,0x4c,0x42,0x3b,0x34,0x2d,
0x2a,0x2b,0x30,0x3c,0x49,0x5a,0x69,0x73,0x76,0x75,0x6d,0x65,0x5d,0x56,0x50,0x4a,
0x45,0x3f,0x35,0x30,0x2c,0x2d,0x36,0x42,0x4e,0x5f,0x6b,0x74,0x78,0x75,0x6f,0x68,
0x60,0x5c,0x58,0x54,0x49,0x3e,0x37,0x38,0x44,0x5b,0x75,0x87,0x8c,0x81,0x6e,0x5e,
0x56,0x5d,0x69,0x77,0x7f,0x7e,0x76,0x6a,0x5f,0x5d,0x5f,0x65,0x6d,0x74,0x78,0x78,
0x74,0x6c,0x66,0x64,0x66,0x6b,0x74,0x79,0x7b,0x76,0x6e,0x65,0x60,0x60,0x65,0x6e,
0x72,0x74,0x74,0x75,0x79,0x83,0x8f,0x9a,0x9d,0x95,0x85,0x71,0x5e,0x4f,0x44,0x40,
0x3e,0x3d,0x3e,0x3d,0x3c,0x3e,0x3f,0x3c,0x39,0x37,0x34,0x30,0x31,0x31,0x32,0x34,
0x36,0x36,0x35,0x35,0x34,0x37,0x38,0x3a,0x3b,0x3d,0x3b,0x3b,0x3b,0x3a,0x37,0x36,
0x37,0x3e,0x4b,0x5b,0x6d,0x7e,0x89,0x90,0x96,0x9d,0xa2,0xa6,0xa7,0xa4,0x9d,0x8f,
0x7f,0x70,0x64,0x59,0x50,0x4b,0x45,0x40,0x3e,0x3b,0x36,0x36,0x37,0x39,0x3c,0x3d,
0x3c,0x3a,0x35,0x31,0x30,0x34,0x38,0x3b,0x3b,0x39,0x35,0x31,0x30,0x35,0x3f,0x4d,
0x5b,0x6a,0x78,0x85,0x93,0x9f,0xa4,0xa2,0x97,0x87,0x75,0x66,0x5e,0x5d,0x62,0x6a,
0x72,0x7c,0x87,0x91,0x99,0x9b,0x96,0x8d,0x7f,0x6d,0x5a,0x4d,0x43,0x40,0x3c,0x3a,
0x37,0x38,0x39,0x3b,0x3f,0x42,0x42,0x3f,0x38,0x34,0x35,0x3c,0x48,0x5a,0x6a,0x78,
0x83,0x8b,0x91,0x97,0x9e,0xa3,0xa6,0xa7,0xa3,0x9c,0x90,0x81,0x70,0x68,0x64,0x64,
0x66,0x6e,0x75,0x7d,0x83,0x88,0x8b,0x98,0x9f,0xa5,0xa8,0xa6,0x9d,0x91,0x81,0x73,
0x68,0x5f,0x56,0x4e,0x45,0x3e,0x38,0x37,0x3c,0x48,0x5a,0x6d,0x7d,0x8b,0x93,0x97,
0x98,0x96,0x8f,0x85,0x75,0x65,0x59,0x57,0x5b,0x69,0x78,0x7e,0x7b,0x73,0x66,0x5d,
0x5e,0x66,0x71,0x7e,0x7f,0x79,0x72,0x6c,0x69,0x69,0x6a,0x6c,0x6f,0x72,0x71,0x74,
0x79,0x84,0x8f,0x9b,0xa3,0xa9,0xaa,0xa7,0xa0,0x9c,0x9a,0x9a,0x9b,0x9c,0x9e,0xa3,
0xa4,0xa4,0x9e,0x94,0x85,0x74,0x65,0x58,0x4f,0x4a,0x44,0x3f,0x3b,0x37,0x36,0x38,
0x39,0x3d,0x3f,0x3e,0x3d,0x39,0x36,0x36,0x35,0x34,0x30,0x30,0x36,0x41,0x53,0x66,
0x75,0x7c,0x78,0x6f,0x64,0x5d,0x57,0x55,0x51,0x4a,0x40,0x35,0x2e,0x2d,0x31,0x38,
0x3f,0x48,0x53,0x5d,0x68,0x72,0x7f,0x8a,0x93,0x98,0x98,0x92,0x87,0x76,0x62,0x53,
0x45,0x3e,0x3b,0x39,0x36,0x36,0x34,0x33,0x33,0x38,0x40,0x50,0x60,0x6f,0x75,0x78,
0x71,0x66,0x5d,0x58,0x5d,0x68,0x72,0x79,0x7a,0x76,0x6f,0x68,0x65,0x6a,0x70,0x75,
0x75,0x75,0x75,0x79,0x81,0x8e,0x9b,0xa6,0xac,0xac,0xa7,0xa1,0x9b,0x97,0x97,0x98,
0x97,0x95,0x8d,0x80,0x6f,0x61,0x57,0x56,0x60,0x6f,0x7c,0x81,0x79,0x6d,0x61,0x59,
0x54,0x51,0x4e,0x46,0x3a,0x2f,0x27,0x28,0x30,0x3c,0x40,0x40,0x38,0x2d,0x2a,0x2f,
0x3b,0x52,0x67,0x78,0x7c,0x7b,0x73,0x6b,0x62,0x5c,0x55,0x4d,0x40,0x38,0x37,0x40,
0x51,0x68,0x7a,0x83,0x81,0x77,0x68,0x5d,0x54,0x4d,0x46,0x3e,0x34,0x30,0x36,0x4b,
0x64,0x7b,0x84,0x80,0x75,0x66,0x5a,0x57,0x57,0x54,0x4b,0x3e,0x35,0x3b,0x4e,0x69,
0x7d,0x8d,0x8b,0x7c,0x68,0x5a,0x56,0x5e,0x66,0x6d,0x72,0x76,0x7c,0x87,0x92,0x9c,
0xa0,0x9a,0x89,0x74,0x62,0x57,0x56,0x5e,0x68,0x75,0x81,0x8c,0x95,0x9f,0xa4,0xa1,
0x94,0x86,0x73,0x62,0x58,0x56,0x5a,0x66,0x71,0x7c,0x87,0x93,0x9a,0x9e,0x9d,0x93,
0x85,0x74,0x64,0x56,0x4b,0x42,0x3c,0x3a,0x3b,0x42,0x4f,0x5f,0x6e,0x7f,0x88,0x8f,
0x93,0x95,0x94,0x8f,0x84,0x77,0x69,0x5e,0x59,0x5f,0x6a,0x76,0x7f,0x8a,0x92,0x97,
0x9c,0x9c,0x94,0x87,0x73,0x61,0x56,0x58,0x61,0x6b,0x78,0x80,0x89,0x92,0x98,0x9f,
0xa4,0xa7,0xa5,0xa1,0x9a,0x95,0x94,0x94,0x95,0x99,0x9c,0xa0,0xa2,0xa3,0xa0,0x9e,
0x9c,0x9d,0x9e,0x9d,0x96,0x8b,0x7b,0x6b,0x5e,0x5b,0x5d,0x66,0x71,0x7c,0x81,0x86,
0x8b,0x93,0x9b,0x9d,0x95,0x84,0x6e,0x5b,0x52,0x58,0x63,0x71,0x7c,0x7e,0x78,0x6d,
0x61,0x5b,0x54,0x52,0x4b,0x42,0x3b,0x34,0x30,0x35,0x39,0x3e,0x45,0x4d,0x56,0x62,
0x6c,0x75,0x7f,0x89,0x93,0x9a,0xa1,0xa5,0xa7,0xa8,0xa3,0x9d,0x9b,0x9c,0xa1,0xa6,
0xa7,0xa6,0xa4,0xa1,0x9c,0x9c,0x9c,0x9d,0x9a,0x94,0x89,0x7e,0x70,0x65,0x58,0x4e,
// Line 16
0x36,0x35,0x34,0x34,0x33,0x34,0x34,0x35,0x35,0x38,0x39,0x39,0x39,0x39,0x38,0x38,
0x38,0x3a,0x38,0x37,0x35,0x35,0x36,0x35,0x34,0x35,0x36,0x38,0x38,0x37,0x37,0x38,
0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x36,0x34,0x38,0x3a,0x3b,0x3b,0x39,0x36,0x36,
0x35,0x38,0x38,0x3b,0x39,0x36,0x34,0x36,0x3c,0x4d,0x5f,0x71,0x7b,0x7e,0x74,0x67,
0x5c,0x59,0x5f,0x69,0x72,0x79,0x7b,0x74,0x6a,0x62,0x60,0x62,0x69,0x71,0x76,0x79,
0x75,0x70,0x68,0x61,0x5e,0x62,0x69,0x71,0x76,0x79,0x77,0x73,0x6a,0x65,0x60,0x65,
0x6a,0x71,0x76,0x76,0x73,0x6e,0x65,0x5e,0x5d,0x61,0x68,0x6f,0x73,0x74,0x73,0x6e,
0x66,0x5f,0x5b,0x5d,0x61,0x69,0x6e,0x71,0x6f,0x69,0x61,0x5c,0x5b,0x61,0x6a,0x74,
0x79,0x7b,0x77,0x70,0x66,0x62,0x60,0x63,0x69,0x6b,0x6d,0x70,0x70,0x74,0x7b,0x86,
0x92,0x9d,0xa7,0xaa,0xa8,0x9e,0x8f,0x7d,0x70,0x63,0x59,0x55,0x51,0x4b,0x41,0x38,
0x32,0x38,0x43,0x54,0x66,0x79,0x87,0x91,0x93,0x94,0x97,0x9c,0x9d,0x9d,0x9b,0x94,
0x87,0x78,0x67,0x5a,0x55,0x58,0x60,0x6d,0x78,0x7d,0x7a,0x72,0x66,0x5c,0x5e,0x62,
0x6b,0x75,0x7a,0x78,0x71,0x66,0x5e,0x5f,0x63,0x69,0x6e,0x70,0x6f,0x70,0x74,0x7e,
0x8b,0x9b,0xa7,0xab,0xaa,0xa4,0x9b,0x95,0x94,0x96,0x9b,0x9b,0x94,0x89,0x79,0x69,
0x5c,0x53,0x4a,0x42,0x3a,0x33,0x33,0x40,0x52,0x66,0x78,0x7f,0x7a,0x70,0x63,0x5b,
0x55,0x52,0x4c,0x42,0x38,0x34,0x3a,0x4b,0x60,0x75,0x81,0x81,0x75,0x66,0x58,0x50,
0x4d,0x4c,0x47,0x41,0x38,0x33,0x31,0x35,0x3b,0x44,0x4a,0x51,0x59,0x65,0x71,0x7f,
0x8c,0x93,0x95,0x92,0x89,0x7e,0x70,0x60,0x50,0x46,0x40,0x3e,0x3b,0x3f,0x3d,0x3b,
0x3b,0x3d,0x3f,0x45,0x4d,0x5a,0x69,0x76,0x82,0x8d,0x94,0x96,0x92,0x87,0x7a,0x6b,
0x5c,0x50,0x47,0x41,0x3b,0x39,0x38,0x37,0x36,0x39,0x3b,0x3d,0x3d,0x3b,0x34,0x31,
0x34,0x3d,0x4b,0x62,0x73,0x7c,0x7b,0x72,0x62,0x5c,0x59,0x60,0x6f,0x7b,0x7e,0x7b,
0x72,0x68,0x63,0x63,0x61,0x5f,0x56,0x49,0x3b,0x34,0x35,0x41,0x56,0x6e,0x81,0x8e,
0x95,0x99,0x96,0x91,0x86,0x7b,0x6d,0x5f,0x50,0x46,0x40,0x3e,0x3e,0x3c,0x3a,0x38,
0x38,0x3c,0x44,0x4d,0x55,0x5e,0x68,0x74,0x82,0x91,0x9a,0x9b,0x9a,0x8f,0x7d,0x6c,
0x5c,0x53,0x4a,0x43,0x3b,0x38,0x39,0x42,0x52,0x65,0x75,0x80,0x80,0x78,0x6a,0x5e,
0x59,0x5f,0x68,0x70,0x76,0x7b,0x7f,0x84,0x8d,0x99,0xa3,0xaa,0xa9,0xa5,0xa0,0x9c,
0x9a,0x99,0xa0,0xa1,0xa2,0xa7,0xa9,0xa7,0xa3,0x94,0x83,0x73,0x66,0x5e,0x55,0x4d,
0x42,0x3a,0x33,0x34,0x3c,0x51,0x68,0x79,0x81,0x7e,0x72,0x66,0x5c,0x59,0x59,0x52,
0x46,0x3a,0x33,0x38,0x48,0x62,0x79,0x87,0x88,0x7f,0x6e,0x61,0x5b,0x60,0x69,0x70,
0x74,0x78,0x7b,0x83,0x8f,0x9b,0xa3,0xab,0xae,0xa9,0x9c,0x8d,0x7c,0x6d,0x63,0x5a,
0x53,0x4e,0x48,0x42,0x3e,0x3c,0x41,0x4d,0x5d,0x6f,0x7d,0x86,0x8b,0x8d,0x92,0x96,
0x9d,0xa3,0xa5,0xa5,0xa2,0xa0,0x9e,0xa0,0xa0,0x9c,0x8f,0x7d,0x69,0x5c,0x58,0x5a,
0x5f,0x68,0x72,0x79,0x82,0x8d,0x96,0x9f,0xa0,0x99,0x88,0x73,0x62,0x58,0x56,0x5e,
0x6a,0x75,0x79,0x74,0x6e,0x63,0x59,0x53,0x4f,0x4b,0x46,0x3e,0x35,0x30,0x30,0x35,
0x3d,0x46,0x4e,0x56,0x5e,0x66,0x70,0x7d,0x89,0x93,0x97,0x94,0x8c,0x82,0x72,0x63,
0x56,0x4b,0x43,0x3c,0x38,0x3a,0x41,0x4d,0x59,0x68,0x78,0x85,0x8f,0x96,0x99,0x97,
0x91,0x84,0x76,0x68,0x5e,0x5b,0x5f,0x67,0x70,0x7b,0x86,0x8f,0x92,0x9c,0xa0,0xa3,
0xa4,0xa2,0x9e,0x9a,0x96,0x97,0x9b,0x9e,0xa1,0xa2,0xa0,0x9e,0x9e,0x9d,0x9b,0x9a,
0x99,0x99,0x93,0x8b,0x7e,0x70,0x65,0x5d,0x59,0x5d,0x66,0x74,0x7f,0x85,0x89,0x8e,
0x95,0x9f,0xa4,0xa9,0xa3,0x9c,0x92,0x82,0x71,0x63,0x56,0x4f,0x49,0x43,0x3c,0x38,
0x35,0x34,0x36,0x3a,0x3d,0x43,0x43,0x42,0x3e,0x3c,0x3a,0x38,0x39,0x39,0x36,0x38,
0x3f,0x4a,0x56,0x65,0x71,0x7d,0x88,0x91,0x96,0x9d,0xa4,0xa8,0xa7,0xa2,0x9d,0x9d,
0x9b,0x9c,0x9a,0x94,0x88,0x78,0x6b,0x5e,0x54,0x4e,0x48,0x41,0x38,0x35,0x39,0x48,
0x59,0x6c,0x7b,0x82,0x86,0x8c,0x93,0x9b,0xa1,0xa4,0xa1,0xa0,0x9d,0x9c,0x9b,0x9c,
0x9b,0x96,0x8b,0x7b,0x68,0x5b,0x51,0x49,0x41,0x3b,0x36,0x34,0x35,0x36,0x38,0x3b,
0x3b,0x3b,0x3a,0x36,0x34,0x34,0x34,0x31,0x2f,0x30,0x35,0x3f,0x4c,0x5b,0x6a,0x79,
0x84,0x91,0x9a,0x9f,0x9b,0x91,0x81,0x71,0x62,0x55,0x48,0x42,0x3c,0x39,0x3a,0x41,
0x4d,0x5e,0x6f,0x7c,0x87,0x92,0x99,0x98,0x99,0x92,0x82,0x71,0x5f,0x55,0x59,0x60,
0x6b,0x76,0x7a,0x76,0x6c,0x65,0x5f,0x5e,0x5c,0x56,0x49,0x3b,0x2f,0x32,0x42,0x5c,
0x75,0x85,0x86,0x7b,0x69,0x59,0x53,0x5b,0x68,0x76,0x7e,0x7f,0x77,0x6b,0x61,0x5c,
0x5e,0x67,0x70,0x76,0x79,0x76,0x6d,0x65,0x5f,0x5e,0x5e,0x5d,0x56,0x4d,0x41,0x35,
0x2a,0x29,0x2d,0x36,0x41,0x4a,0x50,0x59,0x62,0x6e,0x7c,0x8a,0x94,0x9d,0x9c,0x94,
0x86,0x78,0x68,0x5c,0x56,0x58,0x60,0x6f,0x7c,0x86,0x8f,0x98,0x9d,0xa2,0xa4,0xa5,
0xa4,0x9e,0x93,0x85,0x76,0x68,0x5b,0x5a,0x5b,0x63,0x6d,0x75,0x77,0x78,0x6f,0x65,
0x5d,0x59,0x53,0x4d,0x46,0x3c,0x33,0x2e,0x2b,0x2f,0x36,0x40,0x4d,0x5b,0x68,0x71,
0x76,0x74,0x6d,0x66,0x5e,0x59,0x52,0x4b,0x40,0x38,0x31,0x35,0x41,0x55,0x6a,0x7f,
0x8d,0x96,0x99,0x9b,0x95,0x8d,0x81,0x72,0x61,0x59,0x58,0x5d,0x68,0x74,0x7e,0x85,
0x8b,0x93,0x9b,0x9e,0x98,0x87,0x72,0x5d,0x50,0x52,0x5d,0x6d,0x7a,0x7d,0x78,0x6d,
0x62,0x5b,0x58,0x55,0x4f,0x44,0x39,0x2f,0x29,0x2a,0x31,0x39,0x41,0x43,0x3e,0x36,
0x30,0x30,0x3a,0x4c,0x60,0x70,0x7b,0x7b,0x71,0x67,0x5c,0x54,0x50,0x4b,0x44,0x3d,
0x38,0x39,0x44,0x55,0x69,0x7f,0x8f,0x99,0x9b,0x97,0x8f,0x86,0x7b,0x6d,0x5c,0x50,
0x45,0x3c,0x38,0x35,0x33,0x34,0x35,0x36,0x38,0x3b,0x3a,0x36,0x35,0x32,0x30,0x34,
0x34,0x33,0x35,0x36,0x3d,0x4f,0x61,0x72,0x7c,0x7b,0x71,0x65,0x59,0x55,0x52,0x4f,
0x46,0x3c,0x34,0x30,0x2f,0x34,0x3a,0x43,0x4c,0x56,0x60,0x6d,0x75,0x77,0x70,0x65,
0x59,0x56,0x5c,0x66,0x72,0x7b,0x7b,0x71,0x66,0x60,0x60,0x68,0x6e,0x73,0x72,0x70,
0x6f,0x75,0x80,0x8f,0x9b,0x9f,0x99,0x8a,0x76,0x63,0x56,0x53,0x58,0x63,0x73,0x7e,
0x86,0x8e,0x94,0x9a,0x9e,0xa3,0xa5,0xa3,0x9c,0x98,0x96,0x99,0x9c,0x9f,0x9d,0x91,
0x7f,0x6f,0x61,0x5b,0x59,0x61,0x68,0x71,0x79,0x82,0x8b,0x92,0x99,0x9f,0xa3,0xa4,
0xa0,0x99,0x8b,0x7d,0x6d,0x5e,0x52,0x4b,0x46,0x42,0x3c,0x36,0x31,0x30,0x33,0x38,
0x3c,0x41,0x41,0x3d,0x37,0x32,0x32,0x3a,0x46,0x57,0x66,0x76,0x83,0x8e,0x94,0x9a,
0x9c,0xa1,0xa1,0xa0,0x9d,0x97,0x8b,0x7b,0x6a,0x5e,0x5b,0x5f,0x68,0x73,0x7b,0x7c,
0x75,0x6b,0x62,0x5e,0x5f,0x64,0x67,0x6b,0x6d,0x70,0x76,0x80,0x8d,0x9c,0xa1,0x9c,
0x8d,0x79,0x66,0x5b,0x59,0x61,0x6b,0x79,0x81,0x89,0x91,0x9a,0xa0,0xa7,0xa8,0xa4,
0xa0,0x9e,0x9a,0x99,0x9a,0x9b,0x9c,0x9e,0x9e,0xa0,0x9f,0x9c,0x94,0x89,0x78,0x67,
0x5b,0x58,0x59,0x62,0x6b,0x75,0x7f,0x89,0x92,0x9b,0x9f,0x9d,0x92,0x82,0x6c,0x57,
0x48,0x40,0x3b,0x3b,0x3a,0x3a,0x3b,0x3c,0x3c,0x3c,0x3b,0x3a,0x37,0x35,0x33,0x34,
0x34,0x35,0x36,0x38,0x38,0x38,0x3c,0x3d,0x3c,0x3d,0x3c,0x3b,0x38,0x38,0x3b,0x42,
0x4b,0x56,0x63,0x71,0x7e,0x88,0x8f,0x96,0x9b,0x9e,0xa0,0xa0,0x9f,0x9b,0x8e,0x7d,
0x6a,0x5e,0x5a,0x5d,0x67,0x73,0x7b,0x79,0x72,0x69,0x61,0x5c,0x5b,0x56,0x4d,0x43,
0x38,0x30,0x30,0x3c,0x4e,0x66,0x7b,0x8c,0x92,0x96,0x93,0x8d,0x84,0x7b,0x6f,0x63,
0x56,0x4c,0x42,0x38,0x33,0x36,0x42,0x55,0x6a,0x7c,0x83,0x7e,0x72,0x64,0x59,0x54,
0x4f,0x4a,0x40,0x35,0x2c,0x31,0x42,0x5a,0x72,0x81,0x83,0x7a,0x6b,0x5f,0x54,0x55,
0x52,0x4c,0x43,0x3a,0x30,0x30,0x30,0x35,0x3c,0x46,0x4e,0x59,0x63,0x72,0x81,0x8f,
0x98,0x9b,0x98,0x8e,0x80,0x71,0x62,0x53,0x47,0x3c,0x36,0x34,0x34,0x3b,0x4a,0x5d,
0x70,0x7f,0x83,0x7c,0x6d,0x5f,0x59,0x5c,0x65,0x73,0x7a,0x7d,0x70,0x60,0x59,0x59,
0x5e,0x66,0x6d,0x6f,0x70,0x71,0x75,0x80,0x8e,0x9b,0xa0,0x9c,0x8d,0x7b,0x66,0x57,
0x52,0x59,0x65,0x72,0x7e,0x86,0x8c,0x92,0x99,0xa1,0xa7,0xa9,0xa5,0x9c,0x95,0x92,
0x93,0x9a,0x9c,0x9a,0x91,0x80,0x6a,0x58,0x52,0x59,0x65,0x73,0x7a,0x79,0x77,0x6e,
0x63,0x5c,0x58,0x54,0x4d,0x43,0x38,0x30,0x2a,0x29,0x2d,0x35,0x3f,0x4c,0x55,0x5f,
0x67,0x72,0x7b,0x86,0x90,0x99,0x9f,0xa4,0xa3,0xa0,0x9e,0x9b,0x99,0x9b,0x9c,0x9c,
0x96,0x8d,0x7e,0x6d,0x5e,0x53,0x49,0x44,0x3d,0x38,0x36,0x34,0x33,0x37,0x3a,0x3b,
0x38,0x35,0x31,0x31,0x32,0x35,0x37,0x38,0x35,0x35,0x36,0x39,0x3a,0x3b,0x38,0x34,
0x31,0x34,0x38,0x3e,0x3e,0x3d,0x3a,0x37,0x36,0x3f,0x50,0x63,0x74,0x7f,0x7e,0x74,
0x65,0x5a,0x55,0x5d,0x68,0x74,0x78,0x78,0x70,0x67,0x5f,0x5b,0x59,0x5b,0x56,0x4b,
0x3e,0x31,0x28,0x2a,0x2f,0x38,0x40,0x44,0x40,0x39,0x31,0x2e,0x2f,0x32,0x34,0x36,
0x38,0x3a,0x39,0x3b,0x39,0x3a,0x3a,0x3a,0x38,0x39,0x3a,0x3c,0x3a,0x3a,0x38,0x38,
// Line 17
0x3a,0x3a,0x39,0x38,0x35,0x34,0x35,0x38,0x3a,0x3a,0x37,0x35,0x34,0x36,0x38,0x3a,
0x38,0x36,0x34,0x34,0x34,0x35,0x36,0x36,0x35,0x35,0x34,0x33,0x33,0x34,0x36,0x37,
0x37,0x36,0x37,0x3a,0x39,0x38,0x38,0x3a,0x3a,0x3a,0x39,0x38,0x34,0x35,0x34,0x33,
0x35,0x38,0x37,0x38,0x36,0x36,0x36,0x3c,0x47,0x59,0x6a,0x78,0x7c,0x79,0x70,0x65,
0x5e,0x5e,0x63,0x70,0x78,0x7c,0x79,0x71,0x68,0x63,0x61,0x64,0x6b,0x74,0x79,0x77,
0x72,0x6b,0x64,0x61,0x60,0x64,0x6b,0x72,0x76,0x78,0x74,0x6e,0x66,0x61,0x62,0x68,
0x70,0x79,0x7c,0x7c,0x76,0x6e,0x65,0x5f,0x5f,0x66,0x6e,0x73,0x77,0x78,0x73,0x6d,
0x65,0x60,0x62,0x68,0x6f,0x74,0x79,0x78,0x72,0x6b,0x64,0x5f,0x5f,0x67,0x70,0x78,
0x79,0x78,0x72,0x6b,0x63,0x62,0x65,0x6b,0x6f,0x71,0x70,0x71,0x76,0x7d,0x86,0x91,
0x9c,0xa6,0xab,0xaa,0xa3,0x99,0x8a,0x7a,0x6c,0x62,0x5d,0x57,0x53,0x4a,0x41,0x3b,
0x3a,0x41,0x50,0x63,0x76,0x86,0x8f,0x93,0x94,0x96,0x99,0x9c,0x9d,0x9c,0x97,0x8e,
0x7f,0x72,0x67,0x5e,0x5c,0x62,0x6b,0x77,0x7e,0x80,0x7a,0x71,0x64,0x5d,0x5f,0x67,
0x71,0x79,0x7a,0x73,0x69,0x63,0x60,0x61,0x68,0x6d,0x6e,0x70,0x70,0x73,0x7c,0x88,
0x94,0xa3,0xab,0xad,0xa7,0xa0,0x9c,0x9c,0x9e,0x9e,0x9e,0x99,0x8e,0x80,0x71,0x64,
0x58,0x4f,0x44,0x3a,0x33,0x34,0x3c,0x4d,0x61,0x73,0x7e,0x80,0x77,0x68,0x5e,0x57,
0x52,0x51,0x49,0x40,0x38,0x38,0x42,0x59,0x72,0x86,0x8d,0x87,0x76,0x67,0x5e,0x5e,
0x64,0x6d,0x72,0x76,0x7a,0x7f,0x87,0x93,0x9e,0xa7,0xaa,0xa6,0x9e,0x93,0x86,0x79,
0x6b,0x60,0x57,0x4f,0x4a,0x46,0x41,0x3d,0x37,0x34,0x35,0x37,0x3b,0x42,0x4c,0x59,
0x64,0x6f,0x78,0x84,0x91,0x9c,0x9d,0x97,0x8a,0x79,0x69,0x5b,0x54,0x59,0x66,0x74,
0x7f,0x83,0x7c,0x72,0x67,0x61,0x62,0x68,0x70,0x76,0x77,0x71,0x6b,0x67,0x64,0x66,
0x68,0x6b,0x6b,0x6e,0x70,0x76,0x7c,0x8b,0x97,0xa3,0xac,0xb0,0xab,0xa4,0x96,0x87,
0x78,0x6c,0x62,0x5b,0x52,0x49,0x3f,0x37,0x35,0x3b,0x44,0x52,0x64,0x77,0x87,0x91,
0x96,0x9a,0x97,0x91,0x84,0x74,0x63,0x54,0x46,0x3e,0x3a,0x3c,0x3c,0x3b,0x37,0x34,
0x36,0x3b,0x41,0x50,0x59,0x65,0x72,0x7e,0x89,0x94,0x9b,0x9d,0x9a,0x8e,0x7e,0x6d,
0x5e,0x58,0x58,0x60,0x6b,0x77,0x84,0x89,0x8f,0x97,0x9e,0xa3,0xa6,0xa4,0xa1,0x9d,
0x99,0x99,0x9b,0x9c,0x98,0x90,0x84,0x74,0x64,0x58,0x4d,0x46,0x41,0x3e,0x39,0x38,
0x37,0x38,0x3a,0x3b,0x3a,0x3a,0x3a,0x3a,0x39,0x38,0x35,0x33,0x32,0x33,0x3a,0x4c,
0x5e,0x6f,0x79,0x7c,0x77,0x71,0x69,0x64,0x5d,0x57,0x4c,0x41,0x3a,0x3a,0x42,0x52,
0x65,0x79,0x89,0x90,0x93,0x94,0x96,0x9a,0x9c,0x9d,0x9b,0x99,0x98,0x99,0x9a,0x9e,
0xa0,0xa2,0xa2,0x9f,0x9b,0x97,0x90,0x85,0x78,0x68,0x5a,0x51,0x49,0x43,0x3d,0x3a,
0x3b,0x42,0x4f,0x60,0x72,0x85,0x8d,0x90,0x93,0x99,0x9e,0xa4,0xa7,0xa4,0x9b,0x8e,
0x7c,0x6d,0x61,0x57,0x4e,0x4b,0x46,0x3f,0x3b,0x34,0x31,0x34,0x3a,0x3e,0x3e,0x3b,
0x33,0x2f,0x2f,0x38,0x43,0x5a,0x6b,0x74,0x77,0x74,0x69,0x64,0x5c,0x58,0x55,0x4d,
0x41,0x3b,0x3b,0x44,0x55,0x68,0x7b,0x8a,0x93,0x99,0x9b,0x9c,0x97,0x8f,0x82,0x71,
0x62,0x5b,0x5c,0x65,0x70,0x7c,0x85,0x8e,0x94,0x9c,0xa0,0xa4,0xa6,0xa7,0xa4,0x9b,
0x8e,0x80,0x70,0x63,0x5d,0x5e,0x62,0x6a,0x71,0x78,0x7e,0x85,0x8e,0x96,0x9a,0x99,
0x8f,0x80,0x6b,0x58,0x4d,0x47,0x42,0x42,0x40,0x3c,0x35,0x32,0x2f,0x34,0x3c,0x47,
0x4e,0x5e,0x6b,0x7a,0x89,0x96,0x9c,0x9b,0x91,0x85,0x78,0x6b,0x5e,0x52,0x47,0x3f,
0x3a,0x3a,0x3d,0x48,0x57,0x68,0x76,0x80,0x87,0x8f,0x94,0x98,0x9b,0x9e,0xa0,0xa1,
0x9f,0x9d,0x9a,0x9b,0x9a,0x99,0x8e,0x83,0x72,0x64,0x5b,0x52,0x48,0x43,0x3a,0x38,
0x3f,0x4e,0x61,0x76,0x84,0x86,0x7e,0x70,0x63,0x5b,0x54,0x4e,0x44,0x3a,0x31,0x31,
0x38,0x49,0x5e,0x74,0x85,0x91,0x94,0x94,0x93,0x91,0x8a,0x7d,0x6b,0x5c,0x50,0x48,
0x42,0x3e,0x3b,0x41,0x44,0x4e,0x5f,0x71,0x80,0x8d,0x92,0x94,0x96,0x99,0x9f,0xa3,
0xa6,0xa3,0x9f,0x9d,0x9b,0x9b,0x9d,0xa0,0xa1,0xa2,0xa0,0x9e,0x9c,0x9c,0x9d,0x9e,
0x9a,0x94,0x88,0x77,0x67,0x5f,0x5e,0x63,0x6b,0x76,0x7b,0x77,0x71,0x68,0x63,0x60,
0x5b,0x52,0x48,0x3c,0x34,0x33,0x41,0x54,0x69,0x7c,0x89,0x91,0x99,0x9a,0x97,0x94,
0x89,0x7a,0x6a,0x5e,0x5b,0x61,0x6b,0x78,0x81,0x87,0x8b,0x91,0x97,0x9a,0x97,0x8b,
0x78,0x65,0x58,0x55,0x5b,0x67,0x75,0x81,0x88,0x8e,0x91,0x97,0x9a,0x95,0x87,0x74,
0x5f,0x52,0x4f,0x59,0x67,0x77,0x7e,0x7e,0x76,0x6d,0x65,0x61,0x5c,0x55,0x48,0x3b,
0x31,0x33,0x3e,0x52,0x68,0x7c,0x8a,0x93,0x97,0x97,0x93,0x8f,0x85,0x76,0x64,0x55,
0x49,0x41,0x41,0x41,0x41,0x3f,0x3a,0x34,0x35,0x38,0x3e,0x4e,0x5f,0x6d,0x74,0x74,
0x70,0x6d,0x68,0x63,0x5e,0x56,0x4c,0x41,0x39,0x36,0x3c,0x4c,0x62,0x78,0x89,0x94,
0x99,0x9a,0x97,0x97,0x9b,0xa2,0xa5,0xa1,0x95,0x84,0x72,0x63,0x5a,0x5b,0x65,0x70,
0x77,0x7a,0x77,0x70,0x67,0x62,0x5e,0x5b,0x56,0x4d,0x3f,0x34,0x2f,0x38,0x4a,0x62,
0x77,0x88,0x8f,0x90,0x91,0x94,0x9a,0xa2,0xa4,0xa4,0xa3,0x9f,0x9b,0x99,0x9c,0x9f,
0xa2,0xa3,0xa2,0xa0,0x9e,0x9e,0x9e,0xa0,0x9e,0x9b,0x92,0x83,0x71,0x65,0x5d,0x5c,
0x61,0x6c,0x76,0x7c,0x7c,0x75,0x6b,0x61,0x58,0x51,0x4d,0x47,0x3e,0x36,0x2d,0x2a,
0x2b,0x32,0x3b,0x46,0x50,0x5b,0x65,0x71,0x7b,0x84,0x91,0x98,0x9a,0x98,0x8f,0x80,
0x6e,0x5c,0x52,0x56,0x63,0x75,0x80,0x86,0x7c,0x6f,0x62,0x5d,0x5e,0x6b,0x74,0x79,
0x7b,0x76,0x71,0x6f,0x68,0x68,0x6e,0x71,0x71,0x72,0x73,0x77,0x7c,0x85,0x8f,0x9b,
0xa4,0xaa,0xa8,0xa4,0x99,0x8c,0x7e,0x71,0x68,0x64,0x64,0x69,0x70,0x78,0x7c,0x7c,
0x79,0x71,0x67,0x62,0x63,0x69,0x73,0x79,0x79,0x77,0x6f,0x64,0x5e,0x5e,0x66,0x70,
0x78,0x7a,0x79,0x73,0x6a,0x61,0x5e,0x61,0x61,0x5e,0x51,0x41,0x32,0x2e,0x37,0x4e,
0x6b,0x83,0x8e,0x87,0x75,0x64,0x5b,0x5d,0x65,0x71,0x78,0x7b,0x7c,0x81,0x8b,0x99,
0xa1,0xa0,0x93,0x7c,0x64,0x55,0x52,0x5c,0x6d,0x7c,0x83,0x7d,0x77,0x6c,0x64,0x62,
0x5c,0x52,0x47,0x3a,0x2e,0x2f,0x3b,0x52,0x6a,0x7d,0x84,0x80,0x74,0x67,0x5d,0x5b,
0x5f,0x68,0x71,0x78,0x7b,0x83,0x89,0x93,0x9b,0xa3,0xaa,0xac,0xa5,0x99,0x8b,0x7d,
0x6f,0x64,0x5d,0x55,0x4d,0x47,0x3e,0x38,0x37,0x3f,0x4d,0x61,0x74,0x85,0x8e,0x93,
0x94,0x97,0x9d,0xa2,0xa0,0xa3,0xa2,0xa0,0x9e,0x9b,0x9b,0x9e,0x9f,0x9f,0x9f,0x9d,
0x97,0x8f,0x83,0x72,0x63,0x56,0x4d,0x48,0x43,0x3e,0x39,0x36,0x33,0x33,0x37,0x3c,
0x40,0x42,0x3d,0x37,0x34,0x3a,0x47,0x5b,0x6e,0x7a,0x7c,0x76,0x6a,0x5f,0x5e,0x60,
0x65,0x6f,0x77,0x7a,0x7e,0x85,0x90,0x9c,0x9f,0x9a,0x8e,0x7c,0x68,0x56,0x48,0x3f,
0x39,0x38,0x38,0x3c,0x47,0x57,0x68,0x78,0x83,0x8c,0x92,0x96,0x96,0x93,0x8c,0x7e,
0x6b,0x5d,0x58,0x5f,0x6d,0x7b,0x81,0x84,0x7a,0x6e,0x63,0x5c,0x58,0x52,0x46,0x38,
0x2d,0x2e,0x3d,0x55,0x6f,0x83,0x8a,0x84,0x74,0x64,0x5a,0x53,0x4f,0x4a,0x43,0x3a,
0x33,0x31,0x2f,0x34,0x3c,0x47,0x4f,0x57,0x60,0x6e,0x7c,0x88,0x8f,0x96,0x98,0x94,
0x8b,0x7d,0x6e,0x5e,0x4f,0x45,0x40,0x3c,0x3c,0x3f,0x45,0x52,0x63,0x75,0x83,0x8d,
0x92,0x96,0x98,0x9e,0xa2,0xa7,0xa7,0x9f,0x8e,0x7c,0x6e,0x64,0x5a,0x53,0x4a,0x41,
0x38,0x34,0x36,0x42,0x51,0x64,0x76,0x84,0x8e,0x94,0x97,0x97,0x93,0x89,0x7b,0x68,
0x5e,0x58,0x5a,0x65,0x71,0x7c,0x7f,0x7c,0x73,0x6b,0x64,0x66,0x6b,0x72,0x75,0x77,
0x7b,0x81,0x87,0x93,0x9d,0xa6,0xa9,0xa7,0x9e,0x99,0x93,0x8f,0x91,0x96,0x9c,0xa3,
0xa3,0xa4,0xa3,0x9f,0x9c,0x9a,0x9a,0x9c,0x99,0x95,0x88,0x78,0x67,0x5c,0x59,0x61,
0x6d,0x79,0x81,0x7f,0x74,0x68,0x5d,0x5a,0x5e,0x66,0x6e,0x74,0x76,0x72,0x6b,0x68,
0x60,0x5e,0x5c,0x58,0x4f,0x44,0x38,0x2e,0x2a,0x2c,0x30,0x39,0x44,0x52,0x60,0x6d,
0x74,0x76,0x71,0x6a,0x60,0x5b,0x55,0x4f,0x49,0x42,0x38,0x30,0x2b,0x2e,0x34,0x3d,
0x47,0x54,0x62,0x6e,0x76,0x79,0x76,0x6d,0x64,0x5f,0x63,0x6e,0x79,0x7e,0x7c,0x75,
0x69,0x60,0x5b,0x5b,0x5a,0x57,0x4b,0x3c,0x31,0x31,0x3b,0x50,0x67,0x7d,0x8e,0x96,
0x9a,0x9c,0x99,0x91,0x84,0x77,0x66,0x59,0x53,0x57,0x5e,0x6b,0x74,0x7e,0x89,0x95,
0x9e,0xa1,0x9f,0x93,0x82,0x70,0x61,0x56,0x59,0x5e,0x6a,0x78,0x82,0x8a,0x90,0x95,
0x9a,0xa1,0xa4,0xa5,0x9f,0x96,0x89,0x7a,0x6e,0x64,0x5c,0x54,0x4a,0x3f,0x38,0x36,
0x3b,0x4a,0x5e,0x72,0x80,0x85,0x80,0x76,0x68,0x5c,0x52,0x4c,0x45,0x3d,0x3a,0x36,
0x39,0x4a,0x5f,0x74,0x86,0x94,0x99,0x9b,0x94,0x8e,0x84,0x7a,0x6b,0x5c,0x4c,0x41,
0x38,0x35,0x35,0x3c,0x47,0x55,0x64,0x76,0x83,0x8f,0x99,0x9f,0x9e,0x96,0x89,0x79,
0x68,0x5c,0x58,0x5e,0x67,0x72,0x79,0x7b,0x74,0x69,0x64,0x5f,0x58,0x53,0x49,0x3f,
0x30,0x2c,0x29,0x2d,0x37,0x41,0x44,0x41,0x3a,0x35,0x33,0x33,0x31,0x30,0x30,0x31,
0x32,0x35,0x37,0x39,0x38,0x38,0x38,0x39,0x3b,0x3e,0x3f,0x3d,0x38,0x37,0x35,0x35,
// Line 18
0x39,0x38,0x37,0x35,0x36,0x36,0x35,0x36,0x34,0x35,0x36,0x37,0x36,0x37,0x37,0x37,
0x36,0x37,0x37,0x37,0x36,0x36,0x35,0x37,0x37,0x38,0x38,0x38,0x35,0x35,0x36,0x38,
0x38,0x3b,0x3c,0x40,0x45,0x4a,0x50,0x54,0x55,0x57,0x58,0x5a,0x5b,0x5c,0x5a,0x57,
0x57,0x57,0x57,0x57,0x58,0x5a,0x5a,0x5b,0x59,0x58,0x5a,0x5b,0x5b,0x5a,0x58,0x58,
0x58,0x58,0x58,0x5b,0x5c,0x5c,0x5a,0x5a,0x59,0x58,0x59,0x5a,0x5a,0x5b,0x59,0x57,
0x58,0x59,0x59,0x59,0x57,0x55,0x57,0x56,0x54,0x53,0x55,0x56,0x57,0x58,0x59,0x5a,
0x5b,0x5c,0x5c,0x5d,0x5d,0x5d,0x5c,0x5a,0x58,0x59,0x5a,0x5a,0x57,0x54,0x53,0x53,
0x54,0x55,0x55,0x57,0x55,0x55,0x57,0x58,0x5a,0x5d,0x5c,0x5b,0x59,0x59,0x59,0x5b,
0x5d,0x5d,0x5b,0x59,0x57,0x57,0x5a,0x5b,0x5b,0x5b,0x5a,0x58,0x57,0x56,0x56,0x57,
0x58,0x58,0x57,0x57,0x57,0x57,0x5a,0x5b,0x5b,0x5b,0x5a,0x5a,0x5a,0x5a,0x59,0x59,
0x57,0x55,0x57,0x59,0x5b,0x5b,0x5c,0x5c,0x5a,0x5a,0x58,0x58,0x58,0x57,0x55,0x55,
0x53,0x55,0x57,0x59,0x5a,0x5d,0x5e,0x5d,0x5c,0x5d,0x5d,0x5d,0x5d,0x5b,0x5a,0x5a,
0x58,0x57,0x57,0x58,0x58,0x59,0x58,0x58,0x58,0x59,0x58,0x58,0x57,0x57,0x57,0x57,
0x55,0x55,0x55,0x54,0x53,0x57,0x59,0x5b,0x58,0x57,0x55,0x57,0x58,0x5b,0x5a,0x5e,
0x5d,0x5e,0x5d,0x5b,0x5a,0x5c,0x5d,0x5d,0x5b,0x59,0x58,0x5a,0x57,0x55,0x58,0x5b,
0x5a,0x58,0x57,0x56,0x57,0x58,0x5a,0x5b,0x5b,0x5b,0x5a,0x58,0x57,0x57,0x58,0x57,
0x55,0x57,0x55,0x57,0x57,0x59,0x5b,0x5b,0x5a,0x59,0x59,0x5d,0x5c,0x5a,0x5a,0x5a,
0x5a,0x5b,0x5b,0x5c,0x5d,0x5d,0x5d,0x5b,0x5a,0x5a,0x5a,0x5a,0x59,0x58,0x5c,0x59,
0x57,0x58,0x59,0x59,0x5a,0x5b,0x5b,0x5e,0x5f,0x5d,0x57,0x57,0x57,0x5c,0x5e,0x5d,
0x5b,0x5a,0x54,0x53,0x57,0x5e,0x63,0x64,0x5d,0x54,0x4f,0x52,0x5f,0x71,0x80,0x88,
0x87,0x7e,0x6f,0x64,0x60,0x64,0x66,0x67,0x60,0x56,0x4e,0x4c,0x50,0x5b,0x65,0x6a,
0x66,0x60,0x58,0x55,0x55,0x59,0x5a,0x5e,0x5b,0x58,0x57,0x58,0x59,0x5c,0x5a,0x57,
0x57,0x58,0x59,0x58,0x59,0x5a,0x59,0x5a,0x5a,0x5a,0x5a,0x5a,0x59,0x5a,0x59,0x5a,
0x5a,0x5a,0x58,0x58,0x57,0x58,0x5a,0x5b,0x5b,0x5b,0x5a,0x58,0x57,0x58,0x5a,0x5b,
0x5d,0x5b,0x58,0x58,0x58,0x58,0x59,0x5a,0x5a,0x59,0x5a,0x59,0x58,0x5a,0x5a,0x5a,
0x5b,0x5b,0x5b,0x5c,0x5b,0x5a,0x5a,0x5a,0x5a,0x5d,0x5f,0x60,0x5d,0x5c,0x5a,0x5a,
0x5b,0x5e,0x5e,0x5d,0x5a,0x58,0x57,0x57,0x58,0x5b,0x5c,0x5c,0x5b,0x5b,0x5b,0x5d,
0x5b,0x5a,0x5a,0x5a,0x58,0x57,0x58,0x58,0x57,0x58,0x58,0x5b,0x5c,0x5b,0x58,0x58,
0x58,0x58,0x58,0x5a,0x5a,0x5c,0x5b,0x5a,0x58,0x5a,0x5a,0x5a,0x59,0x58,0x58,0x58,
0x58,0x58,0x5a,0x5b,0x5c,0x5b,0x58,0x55,0x55,0x57,0x57,0x58,0x59,0x59,0x58,0x59,
0x59,0x5a,0x5b,0x5b,0x5b,0x5d,0x5d,0x5b,0x5b,0x5c,0x5c,0x5d,0x5d,0x5d,0x5a,0x57,
0x55,0x55,0x57,0x57,0x56,0x57,0x55,0x54,0x54,0x57,0x5b,0x5d,0x5d,0x5c,0x5b,0x5b,
0x5b,0x5b,0x5c,0x5c,0x5a,0x5a,0x57,0x56,0x55,0x57,0x58,0x59,0x59,0x5a,0x5b,0x5a,
0x5b,0x5b,0x5b,0x5b,0x5a,0x59,0x58,0x59,0x5a,0x5a,0x58,0x5a,0x5a,0x5b,0x5b,0x5b,
0x5c,0x5c,0x5a,0x57,0x57,0x59,0x5a,0x59,0x57,0x57,0x57,0x58,0x58,0x57,0x57,0x58,
0x57,0x59,0x58,0x5a,0x5a,0x5b,0x59,0x57,0x57,0x57,0x57,0x57,0x57,0x58,0x58,0x58,
0x57,0x58,0x58,0x58,0x57,0x57,0x57,0x58,0x57,0x57,0x57,0x58,0x58,0x59,0x5a,0x59,
0x57,0x59,0x5a,0x5b,0x5a,0x5b,0x5b,0x5d,0x5c,0x5b,0x57,0x5a,0x57,0x57,0x57,0x55,
0x52,0x50,0x4e,0x4e,0x4e,0x4e,0x4c,0x4b,0x4a,0x49,0x47,0x44,0x45,0x48,0x48,0x45,
0x42,0x44,0x46,0x47,0x44,0x43,0x42,0x44,0x45,0x44,0x44,0x43,0x43,0x45,0x45,0x45,
0x43,0x44,0x44,0x44,0x45,0x45,0x43,0x46,0x48,0x49,0x4a,0x4b,0x4b,0x4a,0x4a,0x48,
0x46,0x47,0x47,0x46,0x44,0x41,0x40,0x42,0x44,0x47,0x48,0x48,0x48,0x4a,0x49,0x47,
0x45,0x47,0x46,0x47,0x45,0x44,0x43,0x44,0x43,0x44,0x45,0x48,0x47,0x49,0x47,0x47,
0x44,0x44,0x45,0x48,0x48,0x46,0x46,0x47,0x47,0x47,0x47,0x47,0x46,0x47,0x47,0x47,
0x46,0x47,0x47,0x48,0x48,0x47,0x46,0x47,0x46,0x46,0x46,0x47,0x47,0x47,0x45,0x44,
0x45,0x45,0x45,0x47,0x45,0x45,0x45,0x43,0x41,0x44,0x44,0x45,0x45,0x47,0x45,0x44,
0x43,0x44,0x46,0x49,0x4c,0x4c,0x4c,0x49,0x48,0x49,0x49,0x49,0x49,0x48,0x46,0x43,
0x42,0x43,0x44,0x46,0x45,0x44,0x45,0x45,0x45,0x46,0x46,0x46,0x46,0x46,0x45,0x48,
0x47,0x47,0x47,0x48,0x48,0x47,0x46,0x45,0x45,0x49,0x4d,0x50,0x58,0x60,0x6a,0x76,
0x81,0x8d,0x99,0xa3,0xa9,0xaf,0xb0,0xb2,0xb3,0xb2,0xb1,0xb0,0xaf,0xae,0xaf,0xb0,
0xb2,0xb4,0xb4,0xb3,0xb2,0xb2,0xb1,0xb0,0xb1,0xb2,0xb2,0xb1,0xae,0xac,0xac,0xaf,
0xb1,0xae,0xb0,0xae,0xad,0xb0,0xb2,0xb1,0xb2,0xb3,0xb2,0xb4,0xb3,0xb4,0xb3,0xb3,
0xb1,0xb2,0xb2,0xb2,0xb1,0xb0,0xb0,0xaf,0xae,0xad,0xad,0xaf,0xaf,0xb0,0xb0,0xb0,
0xb0,0xb2,0xb3,0xb2,0xb0,0xb0,0xb0,0xaf,0xaf,0xb0,0xaf,0xb1,0xb0,0xaf,0xae,0xae,
0xac,0xae,0xb1,0xb3,0xb3,0xb0,0xad,0xad,0xad,0xb0,0xb0,0xaf,0xae,0xb0,0xaf,0xad,
0xac,0xae,0xb0,0xb2,0xb1,0xb0,0xb0,0xb0,0xaf,0xaf,0xb0,0xb0,0xb1,0xb1,0xb0,0xb0,
0xae,0xb1,0xb1,0xb1,0xb1,0xb1,0xb0,0xb1,0xb1,0xb2,0xb1,0xb3,0xb1,0xb0,0xaf,0xb0,
0xaf,0xb1,0xb0,0xb0,0xb2,0xb2,0xb2,0xb1,0xb0,0xb1,0xb2,0xb4,0xb4,0xb3,0xb2,0xb0,
0xaf,0xb0,0xb1,0xb3,0xb3,0xb2,0xb1,0xb2,0xb0,0xb0,0xaf,0xaf,0xae,0xb0,0xb1,0xb2,
0xb1,0xb1,0xb0,0xb0,0xb0,0xaf,0xac,0xae,0xac,0xa9,0xa7,0xa5,0xa2,0xa1,0xa1,0xa0,
0x9e,0x9d,0x9e,0x9f,0x9d,0x9c,0x9c,0x9d,0x9f,0xa1,0xa2,0xa2,0xa1,0xa0,0x9f,0x9f,
0x9e,0x9e,0x9d,0x9f,0x9f,0x9f,0x9c,0x9c,0x9d,0x9e,0x9f,0x9f,0x9d,0x9d,0x9c,0x9c,
0x9d,0x9f,0x9f,0x9f,0x9d,0x9c,0x9b,0x9b,0x9d,0x9f,0xa0,0x9f,0x9c,0x9d,0x9d,0x9f,
0xa1,0xa1,0x9f,0x9f,0x9e,0x9d,0x9c,0x9c,0x9b,0x9d,0x9e,0x9f,0x9d,0x9e,0x9e,0x9e,
0x9e,0xa1,0xa1,0xa2,0x9f,0x9c,0x9c,0x9b,0x9c,0x9d,0x9f,0xa0,0xa1,0xa1,0xa1,0xa1,
0xa2,0xa3,0xa3,0xa4,0xa1,0xa0,0x9f,0x9e,0x9d,0x9f,0x9f,0x9f,0x9d,0x9d,0x9e,0xa1,
0xa1,0xa3,0xa4,0xa3,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0x9f,0x9e,0x9d,0x9e,0x9f,0x9d,
0x9f,0x9f,0x9f,0x9f,0x9e,0x9d,0x9f,0x9e,0x9d,0xa0,0xa1,0xa0,0x9f,0x9e,0x9f,0xa1,
0x9f,0xa0,0xa1,0x9f,0x9d,0x9e,0x9e,0x9f,0x9e,0x9f,0x9e,0x9f,0xa1,0xa1,0xa2,0xa3,
0xa3,0xa2,0xa1,0xa1,0xa1,0xa1,0x9f,0x9e,0x9e,0x9f,0x9e,0x9d,0x9f,0xa0,0x9f,0x9f,
0x9e,0x9f,0xa3,0xa1,0xa1,0xa1,0x9f,0xa0,0xa0,0x9f,0x9f,0xa1,0xa1,0xa0,0x9f,0x9d,
0x9d,0x9e,0x9f,0xa0,0x9f,0x9f,0x9e,0x9e,0x9f,0xa0,0xa1,0xa1,0x9f,0x9d,0x9c,0x9c,
0x9a,0x99,0x9a,0x9c,0x9c,0x9f,0x9f,0x9f,0xa0,0xa1,0xa0,0xa1,0xa1,0xa1,0x9f,0x9f,
0x9c,0x9c,0x9e,0xa1,0xa0,0x9f,0x9f,0xa1,0xa1,0x9f,0x9f,0xa0,0xa0,0x9f,0x9f,0xa1,
0xa1,0xa1,0xa0,0x9e,0x9e,0xa0,0xa1,0xa1,0xa1,0xa1,0xa1,0xa0,0x9e,0x9f,0x9f,0xa0,
0x9d,0x9e,0x9f,0xa0,0x9f,0x9d,0x9c,0x9d,0xa0,0xa1,0x9f,0x9f,0x9d,0x9b,0x9c,0x9e,
0xa0,0xa2,0xa1,0x9d,0x9c,0x9c,0x9e,0xa1,0xa2,0xa1,0x9f,0x9b,0x98,0x9a,0x9f,0xa1,
0xa3,0xa1,0x94,0x83,0x73,0x6d,0x6d,0x76,0x80,0x8a,0x8e,0x8e,0x8c,0x93,0x9b,0xa4,
0xab,0xad,0xa9,0xa0,0x98,0x95,0x95,0xa0,0xa2,0xa5,0xa6,0xa4,0xa1,0xa0,0x9f,0x9f,
0x9f,0x9f,0x9f,0x9d,0x9c,0x9c,0x9c,0x9d,0x9d,0x9e,0x9f,0xa1,0xa0,0xa1,0xa0,0xa1,
0xa0,0x9f,0x9c,0x9d,0x9e,0x9f,0x9d,0x9b,0x9a,0x9d,0xa0,0xa2,0xa2,0xa2,0xa1,0x9f,
0x9e,0x9e,0x9f,0xa2,0xa2,0xa1,0x9f,0x9f,0x9e,0x9c,0x9a,0x9c,0x9e,0xa1,0x9f,0x9f,
0xa0,0xa0,0x9f,0xa1,0xa1,0xa2,0xa2,0xa1,0x9f,0x9d,0x9b,0x9c,0x9c,0x9e,0x9e,0x9f,
0x9f,0x9f,0x9e,0x9f,0x9d,0x9d,0x9c,0x9c,0x9c,0x9e,0x9e,0x9d,0x9d,0x9f,0x9e,0x9c,
0x9c,0x9c,0x9b,0x9d,0x9e,0x9f,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa1,0x9f,0x9e,
0x9c,0x9c,0x9c,0x9c,0x9c,0x9e,0x9f,0x9e,0x9d,0x9e,0x9f,0xa1,0xa1,0xa0,0x9f,0x9e,
0x9d,0x9d,0x9f,0xa1,0xa2,0xa1,0x9f,0x9c,0x9b,0x9c,0x9d,0x9d,0xa0,0x9f,0x9d,0x9d,
0x9c,0x9d,0xa1,0xa2,0xa2,0xa3,0xa2,0xa1,0x9f,0x9f,0x9f,0xa0,0x9f,0x9f,0x9d,0x9c,
0x9b,0x9c,0x9e,0x9f,0x9f,0xa0,0x9f,0x9f,0x9e,0x9f,0xa1,0xa1,0x9f,0x9d,0x9d,0x9f,
0x9f,0x9f,0x9f,0xa1,0xa0,0xa1,0xa1,0x9f,0x9d,0x9a,0x98,0x98,0x99,0x9c,0x9d,0x9c,
0x9a,0x98,0x99,0x9b,0x9c,0xa1,0xa2,0xa0,0x9f,0x9e,0x9f,0xa1,0xa4,0xa3,0xa4,0xa3,
0xa1,0x9d,0x9c,0x9d,0x9e,0x9f,0x9f,0x9e,0x9f,0x9f,0xa0,0xa1,0xa1,0xa0,0xa1,0x9f,
0x9d,0x9e,0x9f,0xa0,0x9f,0x9d,0x9e,0x9d,0x9f,0x9f,0xa0,0xa1,0xa0,0x9f,0xa0,0xa1,
0xa1,0xa1,0xa0,0x9e,0x9d,0x9e,0xa0,0xa1,0x9f,0x9e,0x9f,0xa0,0x9f,0x9f,0xa1,0xa1,
0x9e,0x9f,0x9d,0x9e,0x9d,0x9e,0x9c,0x9e,0x9f,0xa2,0xa1,0x9f,0x9d,0x9d,0x9f,0x9f,
0x9b,0x98,0x91,0x89,0x7f,0x73,0x66,0x5d,0x54,0x4a,0x41,0x38,0x35,0x34,0x32,0x30,
// Line 19
0x39,0x3b,0x39,0x37,0x35,0x34,0x33,0x34,0x36,0x37,0x37,0x37,0x36,0x35,0x35,0x37,
0x37,0x37,0x35,0x35,0x34,0x36,0x38,0x3c,0x3f,0x42,0x44,0x4b,0x4f,0x53,0x58,0x5b,
0x5e,0x61,0x61,0x60,0x60,0x61,0x62,0x64,0x64,0x66,0x68,0x67,0x65,0x64,0x65,0x65,
0x64,0x63,0x60,0x5e,0x5f,0x60,0x60,0x5e,0x61,0x60,0x60,0x61,0x62,0x62,0x64,0x63,
0x61,0x62,0x62,0x62,0x63,0x64,0x64,0x63,0x60,0x61,0x62,0x62,0x61,0x62,0x63,0x64,
0x62,0x61,0x60,0x61,0x64,0x65,0x62,0x60,0x5d,0x5d,0x5e,0x5e,0x5e,0x60,0x64,0x64,
0x61,0x62,0x64,0x65,0x66,0x65,0x64,0x62,0x5f,0x5e,0x60,0x62,0x61,0x62,0x62,0x64,
0x62,0x61,0x60,0x60,0x61,0x62,0x61,0x60,0x5f,0x60,0x60,0x61,0x61,0x63,0x63,0x63,
0x64,0x62,0x61,0x61,0x60,0x61,0x62,0x63,0x63,0x64,0x64,0x64,0x63,0x66,0x68,0x69,
0x68,0x69,0x69,0x69,0x66,0x66,0x66,0x66,0x64,0x64,0x62,0x61,0x61,0x64,0x65,0x67,
0x6a,0x6c,0x6c,0x6c,0x69,0x69,0x6a,0x6b,0x69,0x66,0x66,0x65,0x65,0x68,0x6a,0x6c,
0x6f,0x6e,0x6c,0x6d,0x6e,0x70,0x71,0x70,0x6f,0x6f,0x6f,0x70,0x70,0x72,0x73,0x73,
0x73,0x73,0x73,0x73,0x72,0x73,0x73,0x75,0x75,0x77,0x79,0x7b,0x7d,0x7e,0x7f,0x81,
0x83,0x82,0x81,0x82,0x81,0x82,0x85,0x84,0x84,0x88,0x8a,0x8a,0x8a,0x8b,0x8d,0x90,
0x90,0x8e,0x8d,0x8e,0x8e,0x8e,0x8f,0x8f,0x8e,0x8f,0x8f,0x8e,0x8e,0x8f,0x90,0x90,
0x8d,0x8d,0x8c,0x8c,0x8b,0x8a,0x89,0x87,0x86,0x85,0x81,0x7d,0x7a,0x78,0x75,0x73,
0x6e,0x6c,0x69,0x65,0x5f,0x5d,0x5a,0x54,0x4e,0x4a,0x48,0x44,0x40,0x3d,0x3a,0x37,
0x33,0x31,0x30,0x2f,0x2b,0x2b,0x2a,0x29,0x28,0x28,0x29,0x2d,0x30,0x35,0x37,0x3b,
0x3f,0x43,0x48,0x4c,0x50,0x5a,0x63,0x69,0x6e,0x70,0x74,0x7a,0x81,0x87,0x8b,0x91,
0x93,0x93,0x92,0x93,0x94,0x9a,0x96,0x92,0x8e,0x89,0x83,0x7d,0x74,0x6c,0x65,0x5f,
0x58,0x51,0x49,0x44,0x3e,0x39,0x32,0x2e,0x2b,0x29,0x28,0x28,0x29,0x2b,0x30,0x35,
0x3a,0x44,0x4d,0x56,0x5e,0x65,0x6b,0x73,0x7a,0x84,0x8b,0x90,0x92,0x91,0x91,0x91,
0x8e,0x8b,0x85,0x7d,0x75,0x6d,0x64,0x5a,0x52,0x4b,0x44,0x3e,0x36,0x31,0x2f,0x2e,
0x2d,0x31,0x35,0x3c,0x45,0x4d,0x54,0x5e,0x69,0x74,0x7d,0x85,0x8b,0x91,0x93,0x91,
0x8c,0x89,0x81,0x78,0x6f,0x65,0x5a,0x4f,0x45,0x3d,0x39,0x38,0x36,0x36,0x37,0x39,
0x3d,0x44,0x4e,0x58,0x65,0x6e,0x76,0x81,0x88,0x8c,0x8d,0x8a,0x83,0x7c,0x75,0x6c,
0x60,0x54,0x4b,0x43,0x3a,0x36,0x33,0x34,0x35,0x37,0x3f,0x47,0x53,0x61,0x6f,0x7c,
0x87,0x8d,0x91,0x91,0x8a,0x81,0x77,0x6c,0x5e,0x52,0x49,0x3d,0x34,0x32,0x32,0x36,
0x3d,0x47,0x4f,0x5b,0x68,0x76,0x83,0x8e,0x93,0x94,0x8e,0x83,0x75,0x69,0x5c,0x4f,
0x43,0x39,0x31,0x2e,0x2d,0x33,0x3e,0x4e,0x5e,0x6e,0x7b,0x87,0x8f,0x91,0x8e,0x87,
0x7b,0x6d,0x5e,0x52,0x47,0x3c,0x35,0x2f,0x30,0x39,0x47,0x58,0x69,0x7b,0x88,0x90,
0x90,0x8b,0x82,0x7a,0x6c,0x5d,0x50,0x43,0x39,0x33,0x31,0x35,0x43,0x57,0x6b,0x7d,
0x89,0x8c,0x8c,0x87,0x7c,0x70,0x62,0x55,0x48,0x3d,0x33,0x2f,0x32,0x3c,0x4b,0x5f,
0x71,0x7f,0x87,0x89,0x81,0x78,0x6d,0x61,0x54,0x4c,0x42,0x39,0x37,0x3d,0x49,0x61,
0x73,0x81,0x8a,0x8b,0x84,0x7a,0x6a,0x5e,0x53,0x4a,0x3f,0x36,0x34,0x3d,0x4d,0x63,
0x75,0x82,0x86,0x80,0x75,0x69,0x5d,0x52,0x48,0x3f,0x39,0x3b,0x42,0x51,0x64,0x76,
0x82,0x86,0x81,0x77,0x68,0x5a,0x4c,0x41,0x3b,0x3a,0x41,0x4e,0x5d,0x6d,0x7b,0x85,
0x84,0x7b,0x6c,0x5e,0x4f,0x45,0x3c,0x3b,0x41,0x4c,0x5b,0x6d,0x7b,0x84,0x83,0x7a,
0x6d,0x60,0x52,0x46,0x40,0x44,0x4d,0x5a,0x68,0x74,0x7c,0x80,0x7b,0x6f,0x60,0x51,
0x48,0x44,0x44,0x48,0x53,0x66,0x76,0x80,0x7f,0x78,0x6a,0x5d,0x4f,0x44,0x43,0x46,
0x4e,0x5a,0x65,0x6f,0x73,0x76,0x70,0x66,0x5a,0x4e,0x44,0x48,0x4f,0x5a,0x67,0x71,
0x77,0x78,0x71,0x65,0x58,0x4f,0x4b,0x4c,0x50,0x5a,0x69,0x73,0x77,0x76,0x6e,0x63,
0x57,0x50,0x4d,0x4e,0x56,0x61,0x6b,0x71,0x71,0x70,0x68,0x5e,0x53,0x4d,0x4a,0x4f,
0x57,0x62,0x6a,0x6c,0x6c,0x69,0x61,0x5d,0x54,0x52,0x56,0x5e,0x64,0x67,0x6a,0x69,
0x64,0x5e,0x56,0x50,0x50,0x56,0x5d,0x65,0x6a,0x6c,0x69,0x61,0x5a,0x58,0x58,0x5b,
0x5e,0x63,0x65,0x66,0x65,0x61,0x5a,0x56,0x56,0x5a,0x5e,0x63,0x66,0x6a,0x66,0x60,
0x59,0x56,0x57,0x5b,0x5e,0x62,0x65,0x64,0x60,0x5b,0x56,0x52,0x53,0x5b,0x64,0x6a,
0x6d,0x6c,0x65,0x5d,0x56,0x53,0x56,0x5d,0x64,0x6c,0x6d,0x69,0x5d,0x58,0x51,0x50,
0x58,0x65,0x6f,0x78,0x73,0x69,0x59,0x4c,0x45,0x46,0x54,0x64,0x70,0x76,0x71,0x64,
0x54,0x4a,0x48,0x53,0x64,0x75,0x7e,0x7b,0x6e,0x5c,0x4a,0x43,0x48,0x5a,0x6d,0x7a,
0x7d,0x70,0x5b,0x48,0x3d,0x42,0x54,0x6c,0x7c,0x81,0x76,0x5e,0x48,0x3c,0x41,0x52,
0x6a,0x7a,0x7f,0x75,0x5e,0x45,0x3a,0x3e,0x52,0x6e,0x7f,0x82,0x73,0x5b,0x44,0x3b,
0x44,0x5e,0x78,0x89,0x84,0x6e,0x51,0x3b,0x36,0x48,0x63,0x7b,0x84,0x78,0x5e,0x43,
0x34,0x3d,0x58,0x77,0x88,0x86,0x6e,0x50,0x39,0x39,0x4e,0x6a,0x83,0x87,0x77,0x5a,
0x3f,0x37,0x47,0x65,0x7f,0x8b,0x81,0x67,0x4b,0x3b,0x40,0x5b,0x78,0x87,0x80,0x66,
0x48,0x38,0x40,0x5a,0x75,0x87,0x82,0x6a,0x4c,0x3b,0x41,0x5b,0x77,0x86,0x80,0x68,
0x4b,0x3b,0x40,0x5a,0x75,0x85,0x7c,0x63,0x48,0x3e,0x48,0x64,0x7e,0x89,0x7a,0x61,
0x44,0x3b,0x4b,0x68,0x7a,0x80,0x6e,0x53,0x40,0x42,0x56,0x72,0x81,0x7b,0x65,0x4c,
0x42,0x4d,0x64,0x7a,0x81,0x74,0x5b,0x48,0x46,0x58,0x6e,0x7e,0x78,0x65,0x4e,0x44,
0x4c,0x62,0x76,0x7b,0x6c,0x58,0x48,0x4b,0x5b,0x70,0x77,0x71,0x5e,0x4c,0x4b,0x58,
0x6c,0x7a,0x77,0x66,0x54,0x4e,0x58,0x6c,0x79,0x79,0x6c,0x5a,0x4f,0x53,0x60,0x6e,
0x73,0x6d,0x5c,0x4e,0x4c,0x59,0x67,0x70,0x6d,0x60,0x56,0x55,0x5d,0x69,0x6e,0x6c,
0x60,0x57,0x56,0x5d,0x69,0x71,0x6e,0x66,0x5a,0x56,0x5d,0x68,0x6f,0x6c,0x61,0x54,
0x4f,0x56,0x62,0x6c,0x6b,0x64,0x5b,0x58,0x5b,0x64,0x6d,0x6d,0x65,0x5d,0x58,0x5b,
0x62,0x68,0x69,0x65,0x5d,0x5a,0x5b,0x60,0x65,0x65,0x64,0x5e,0x59,0x5b,0x61,0x68,
0x6b,0x69,0x64,0x60,0x61,0x62,0x64,0x64,0x60,0x5e,0x5d,0x5e,0x5e,0x63,0x61,0x5d,
0x5a,0x5b,0x5e,0x64,0x65,0x65,0x62,0x5f,0x5e,0x62,0x66,0x68,0x66,0x62,0x5d,0x5a,
0x5b,0x60,0x62,0x62,0x5e,0x5d,0x5f,0x61,0x62,0x62,0x5f,0x5d,0x5d,0x5f,0x61,0x64,
0x63,0x63,0x60,0x60,0x60,0x63,0x67,0x66,0x62,0x5f,0x5d,0x5e,0x5f,0x66,0x66,0x65,
0x61,0x60,0x60,0x62,0x61,0x61,0x61,0x60,0x5d,0x5d,0x5e,0x60,0x63,0x63,0x61,0x5f,
0x5d,0x5d,0x5f,0x61,0x63,0x63,0x63,0x64,0x64,0x66,0x65,0x64,0x63,0x63,0x62,0x61,
0x60,0x60,0x61,0x64,0x64,0x65,0x66,0x66,0x64,0x64,0x61,0x60,0x62,0x62,0x60,0x5f,
0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5f,0x60,0x62,0x63,0x63,0x60,0x5e,0x5d,0x5e,
0x5f,0x5f,0x60,0x5e,0x5d,0x5e,0x60,0x62,0x63,0x64,0x64,0x64,0x62,0x63,0x64,0x65,
0x62,0x60,0x60,0x60,0x60,0x64,0x63,0x62,0x61,0x61,0x60,0x61,0x61,0x60,0x60,0x62,
0x62,0x63,0x64,0x64,0x62,0x64,0x64,0x64,0x63,0x64,0x64,0x64,0x60,0x5e,0x5d,0x5e,
0x60,0x63,0x64,0x63,0x62,0x62,0x60,0x60,0x62,0x64,0x64,0x65,0x60,0x5f,0x60,0x61,
0x62,0x62,0x64,0x64,0x62,0x64,0x64,0x63,0x64,0x61,0x5f,0x60,0x60,0x61,0x61,0x60,
0x5f,0x5e,0x5d,0x5d,0x5d,0x5e,0x5e,0x5f,0x5e,0x5f,0x60,0x61,0x61,0x62,0x65,0x66,
0x65,0x65,0x63,0x61,0x60,0x61,0x61,0x61,0x60,0x60,0x5e,0x5e,0x5f,0x61,0x64,0x64,
0x62,0x64,0x61,0x5f,0x61,0x60,0x5f,0x60,0x60,0x61,0x63,0x64,0x62,0x64,0x64,0x64,
0x62,0x61,0x61,0x61,0x62,0x64,0x64,0x64,0x62,0x62,0x63,0x61,0x5f,0x5e,0x5d,0x5b,
0x5b,0x5d,0x5e,0x61,0x63,0x63,0x61,0x62,0x61,0x60,0x61,0x60,0x5e,0x5f,0x5f,0x60,
0x61,0x62,0x62,0x63,0x64,0x66,0x66,0x66,0x64,0x61,0x61,0x62,0x61,0x64,0x5f,0x5f,
0x5f,0x5e,0x5e,0x5f,0x60,0x61,0x61,0x60,0x5f,0x5d,0x5e,0x5e,0x5e,0x5f,0x5e,0x60,
0x61,0x63,0x64,0x65,0x64,0x64,0x62,0x61,0x60,0x60,0x60,0x60,0x61,0x62,0x62,0x60,
0x60,0x61,0x60,0x5f,0x5d,0x5e,0x60,0x62,0x60,0x60,0x5e,0x5e,0x5e,0x61,0x64,0x64,
0x63,0x61,0x5e,0x5f,0x60,0x62,0x64,0x62,0x5e,0x60,0x5e,0x5d,0x5c,0x60,0x61,0x63,
0x62,0x63,0x62,0x61,0x60,0x61,0x61,0x61,0x60,0x64,0x64,0x63,0x61,0x61,0x62,0x62,
0x60,0x5f,0x5d,0x59,0x55,0x52,0x51,0x4e,0x48,0x45,0x40,0x3d,0x39,0x35,0x33,0x36,
0x37,0x37,0x35,0x32,0x33,0x35,0x37,0x38,0x36,0x37,0x37,0x36,0x36,0x37,0x36,0x3a,
0x37,0x36,0x37,0x37,0x37,0x37,0x38,0x39,0x3a,0x3b,0x39,0x39,0x39,0x37,0x35,0x34,
0x34,0x36,0x37,0x35,0x33,0x35,0x35,0x36,0x37,0x38,0x38,0x39,0x38,0x37,0x36,0x35,
0x34,0x35,0x37,0x37,0x36,0x39,0x39,0x39,0x39,0x3b,0x3c,0x3a,0x38,0x38,0x37,0x37,
0x36,0x36,0x36,0x35,0x31,0x31,0x33,0x34,0x37,0x36,0x34,0x35,0x36,0x37,0x38,0x37,
0x37,0x39,0x38,0x37,0x35,0x35,0x35,0x36,0x36,0x35,0x36,0x37,0x36,0x34,0x35,0x35,
// Line 20
0x39,0x38,0x37,0x37,0x35,0x35,0x38,0x3a,0x3b,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x39,
0x38,0x37,0x37,0x36,0x35,0x37,0x36,0x37,0x3a,0x3d,0x3d,0x3a,0x38,0x39,0x3d,0x45,
0x4c,0x57,0x63,0x71,0x7d,0x8c,0x9a,0xa9,0xb4,0xbb,0xbd,0xbf,0xc1,0xc4,0xc3,0xc5,
0xc2,0xc0,0xbf,0xbe,0xbd,0xbf,0xc0,0xc0,0xbf,0xbd,0xbb,0xbb,0xba,0xbb,0xbd,0xbc,
0xbb,0xb9,0xb9,0xba,0xbb,0xbd,0xbd,0xbd,0xbd,0xbe,0xbf,0xc1,0xbf,0xbd,0xbb,0xbb,
0xb9,0xbb,0xbd,0xc0,0xbf,0xbd,0xbb,0xba,0xbb,0xbb,0xbd,0xbf,0xbf,0xbf,0xc0,0xbf,
0xbe,0xbf,0xbf,0xbf,0xbf,0xbf,0xbe,0xbc,0xbb,0xbb,0xbd,0xbe,0xbd,0xbe,0xbd,0xbd,
0xb9,0xb9,0xba,0xbb,0xbb,0xbb,0xb6,0xb6,0xb7,0xbb,0xbd,0xbf,0xbf,0xc0,0xc0,0xbf,
0xbd,0xc1,0xc0,0xc0,0xbf,0xbf,0xbd,0xbd,0xbc,0xbc,0xbd,0xbf,0xbf,0xbf,0xbf,0xbf,
0xbf,0xbf,0xbd,0xbd,0xbc,0xbd,0xbd,0xbe,0xbd,0xbd,0xbd,0xbd,0xb9,0xba,0xbb,0xbd,
0xbd,0xbd,0xbb,0xbd,0xbd,0xbd,0xbd,0xc0,0xbd,0xbe,0xc0,0xbf,0xbd,0xbd,0xbd,0xbd,
0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xc0,0xbf,0xbf,0xbd,0xbd,0xbd,0xbe,0xbd,0xbd,
0xbd,0xbd,0xbb,0xbc,0xbb,0xbf,0xbf,0xbf,0xbd,0xbc,0xbb,0xb8,0xb8,0xb9,0xbb,0xbd,
0xbd,0xbc,0xb9,0xb9,0xb9,0xbc,0xc1,0xc2,0xbe,0xb3,0xa6,0x9b,0x9b,0xa2,0xaa,0xaf,
0xac,0xa0,0x90,0x85,0x81,0x8b,0x9b,0xaa,0xaa,0x9e,0x8b,0x7c,0x79,0x87,0x9c,0xad,
0xb2,0xa8,0x90,0x80,0x78,0x84,0x9b,0xaf,0xb3,0xa8,0x91,0x7c,0x74,0x81,0x99,0xae,
0xb3,0xa7,0x93,0x80,0x7a,0x87,0x9c,0xae,0xb2,0xa7,0x90,0x7d,0x78,0x85,0x9a,0xac,
0xb0,0xa6,0x90,0x7f,0x7a,0x87,0x9e,0xb0,0xb3,0xa8,0x91,0x7e,0x79,0x86,0x9b,0xae,
0xb2,0xa8,0x94,0x82,0x7c,0x88,0x9c,0xae,0xb2,0xa8,0x92,0x7d,0x76,0x84,0x9b,0xaf,
0xb3,0xa9,0x95,0x82,0x7a,0x87,0x9e,0xb2,0xb7,0xa9,0x91,0x7c,0x79,0x87,0x9d,0xaf,
0xb3,0xa9,0x95,0x81,0x7c,0x88,0x9e,0xaf,0xb2,0xa6,0x90,0x7d,0x78,0x84,0x9a,0xad,
0xb2,0xa7,0x92,0x7f,0x79,0x85,0x99,0xac,0xb0,0xa7,0x90,0x7d,0x78,0x86,0x9c,0xaf,
0xb3,0xa8,0x94,0x81,0x7b,0x88,0x9c,0xae,0xb6,0xaa,0x94,0x81,0x7a,0x85,0x9a,0xae,
0xb4,0xaa,0x96,0x81,0x7a,0x87,0x9d,0xb0,0xb5,0xaa,0x94,0x81,0x7c,0x87,0x9e,0xb1,
0xb4,0xa8,0x91,0x7f,0x7b,0x89,0x9d,0xac,0xad,0x9f,0x8d,0x82,0x82,0x90,0xa2,0xaa,
0xa7,0x9c,0x8d,0x87,0x8d,0x97,0x9d,0x95,0x86,0x75,0x6f,0x7a,0x8d,0x9d,0x9f,0x8f,
0x75,0x64,0x65,0x79,0x94,0xa7,0xa5,0x8c,0x6b,0x59,0x5f,0x7d,0x9d,0xaf,0xa9,0x8d,
0x69,0x52,0x57,0x77,0x9b,0xaf,0xaa,0x8d,0x6a,0x55,0x5c,0x7b,0x9e,0xb2,0xae,0x90,
0x6d,0x5b,0x62,0x7c,0x9e,0xb0,0xaa,0x90,0x6d,0x58,0x5c,0x78,0x97,0xad,0xa8,0x90,
0x70,0x5c,0x5f,0x79,0x9a,0xad,0xa8,0x8f,0x6d,0x58,0x5e,0x79,0x9b,0xaf,0xaa,0x90,
0x6f,0x5b,0x61,0x7c,0x9b,0xad,0xa8,0x8f,0x6d,0x59,0x60,0x7b,0x99,0xad,0xa8,0x8d,
0x6a,0x58,0x5e,0x79,0x9a,0xae,0xa8,0x94,0x71,0x5a,0x60,0x7a,0x9a,0xad,0xa6,0x8c,
0x6d,0x5b,0x60,0x7c,0x9b,0xaf,0xac,0x92,0x70,0x5a,0x60,0x7c,0x99,0xad,0xaa,0x91,
0x71,0x5c,0x61,0x7f,0x9f,0xb1,0xac,0x92,0x6f,0x5b,0x60,0x7c,0x9a,0xaf,0xa8,0x8d,
0x6d,0x58,0x59,0x76,0x95,0xa8,0xa8,0x91,0x71,0x5b,0x5e,0x78,0x99,0xb0,0xae,0x95,
0x74,0x5d,0x5e,0x7a,0x9a,0xb0,0xae,0x95,0x72,0x5b,0x5e,0x78,0x97,0xac,0xa9,0x92,
0x70,0x59,0x5b,0x74,0x95,0xab,0xab,0x95,0x75,0x5d,0x5a,0x6d,0x8e,0xa7,0xac,0x99,
0x77,0x5b,0x51,0x61,0x7e,0x97,0xa5,0x97,0x7a,0x5e,0x52,0x5c,0x78,0x95,0xa3,0x9d,
0x82,0x63,0x50,0x56,0x71,0x91,0xa3,0x9d,0x82,0x66,0x53,0x57,0x6f,0x8d,0xa0,0x9f,
0x86,0x64,0x52,0x59,0x73,0x91,0xa0,0x9b,0x81,0x63,0x51,0x53,0x6f,0x8d,0x9f,0x9c,
0x81,0x62,0x50,0x57,0x6f,0x8f,0x9f,0x9a,0x7f,0x63,0x51,0x57,0x70,0x90,0xa3,0x9e,
0x82,0x63,0x51,0x57,0x71,0x92,0xa2,0x9c,0x82,0x63,0x50,0x55,0x6d,0x8c,0x9f,0x9c,
0x82,0x62,0x4f,0x55,0x6f,0x8f,0xa0,0x9c,0x84,0x64,0x4f,0x54,0x6e,0x8d,0x9f,0x9c,
0x83,0x66,0x53,0x58,0x6f,0x90,0xa0,0x9b,0x83,0x65,0x52,0x58,0x71,0x8e,0xa0,0x9c,
0x83,0x65,0x53,0x59,0x74,0x92,0xa2,0x9b,0x82,0x64,0x52,0x59,0x73,0x92,0xa2,0x9b,
0x81,0x63,0x51,0x57,0x71,0x8f,0xa0,0x9b,0x7f,0x60,0x4e,0x55,0x6f,0x8f,0xa2,0x9d,
0x84,0x65,0x54,0x58,0x73,0x92,0xa2,0x9b,0x7f,0x60,0x50,0x58,0x73,0x90,0xa0,0x9c,
0x82,0x65,0x55,0x5b,0x78,0x90,0x9c,0x98,0x80,0x67,0x59,0x5f,0x72,0x89,0x97,0x93,
0x81,0x70,0x64,0x64,0x6e,0x7c,0x84,0x83,0x7e,0x78,0x75,0x70,0x69,0x63,0x5d,0x5e,
0x67,0x73,0x7a,0x77,0x6a,0x58,0x4c,0x51,0x65,0x7d,0x90,0x8a,0x70,0x53,0x3f,0x44,
0x5f,0x80,0x94,0x91,0x74,0x52,0x3d,0x42,0x5e,0x7f,0x94,0x8f,0x73,0x50,0x39,0x3f,
0x5d,0x7f,0x93,0x8c,0x70,0x51,0x40,0x48,0x61,0x7f,0x92,0x8d,0x73,0x53,0x3e,0x44,
0x60,0x7d,0x8d,0x8b,0x73,0x55,0x41,0x45,0x5a,0x7a,0x8f,0x8d,0x73,0x53,0x40,0x44,
0x5d,0x7e,0x93,0x92,0x79,0x57,0x42,0x46,0x61,0x81,0x92,0x8c,0x72,0x52,0x3d,0x41,
0x5b,0x7d,0x92,0x8d,0x72,0x52,0x40,0x47,0x60,0x7f,0x91,0x8d,0x72,0x50,0x3b,0x42,
0x5e,0x7e,0x8d,0x8c,0x72,0x53,0x3f,0x44,0x5d,0x81,0x8f,0x89,0x72,0x54,0x40,0x47,
0x60,0x7f,0x93,0x8f,0x74,0x54,0x40,0x47,0x60,0x7f,0x91,0x8c,0x73,0x54,0x41,0x48,
0x63,0x82,0x95,0x8d,0x71,0x50,0x3e,0x44,0x5d,0x7d,0x8f,0x8b,0x73,0x56,0x43,0x4b,
0x63,0x82,0x95,0x8f,0x75,0x58,0x44,0x49,0x63,0x82,0x94,0x8e,0x74,0x54,0x42,0x47,
0x5f,0x7e,0x8e,0x87,0x6c,0x4f,0x3f,0x48,0x63,0x7e,0x8c,0x85,0x6b,0x4f,0x42,0x4e,
0x69,0x82,0x8a,0x7a,0x5c,0x45,0x40,0x50,0x6d,0x85,0x87,0x70,0x4e,0x36,0x38,0x51,
0x71,0x84,0x83,0x69,0x47,0x32,0x37,0x51,0x73,0x88,0x83,0x69,0x46,0x32,0x3a,0x56,
0x76,0x8c,0x88,0x6e,0x4a,0x35,0x39,0x56,0x78,0x8b,0x87,0x6d,0x49,0x34,0x39,0x55,
0x76,0x8c,0x86,0x69,0x47,0x32,0x37,0x4e,0x71,0x87,0x85,0x6b,0x49,0x34,0x39,0x55,
0x75,0x8b,0x88,0x6f,0x4b,0x33,0x33,0x4f,0x73,0x8b,0x88,0x6e,0x4a,0x34,0x38,0x54,
0x77,0x8d,0x88,0x6b,0x47,0x2f,0x32,0x4f,0x72,0x89,0x89,0x70,0x4b,0x34,0x35,0x51,
0x74,0x8b,0x86,0x6b,0x49,0x32,0x34,0x4f,0x72,0x8a,0x89,0x6f,0x4c,0x36,0x39,0x55,
0x75,0x8b,0x87,0x6f,0x4d,0x37,0x38,0x52,0x71,0x87,0x85,0x6b,0x48,0x34,0x36,0x51,
0x74,0x8b,0x88,0x6d,0x49,0x31,0x36,0x52,0x73,0x88,0x85,0x6a,0x46,0x31,0x34,0x4f,
0x73,0x89,0x83,0x6a,0x4a,0x37,0x3b,0x57,0x77,0x8c,0x88,0x6d,0x4b,0x37,0x39,0x53,
0x73,0x87,0x84,0x6d,0x4b,0x36,0x3b,0x56,0x77,0x88,0x85,0x6b,0x4a,0x37,0x39,0x4f,
0x73,0x87,0x86,0x72,0x54,0x3e,0x3f,0x4d,0x64,0x78,0x7e,0x73,0x5c,0x47,0x3a,0x3c,
0x48,0x58,0x64,0x67,0x5e,0x4f,0x40,0x37,0x38,0x45,0x56,0x64,0x67,0x5d,0x4a,0x37,
0x30,0x3a,0x52,0x68,0x6f,0x66,0x51,0x38,0x29,0x31,0x48,0x60,0x6e,0x64,0x4a,0x33,
0x2b,0x37,0x4f,0x65,0x6d,0x65,0x4f,0x37,0x2c,0x37,0x4e,0x64,0x6c,0x62,0x4a,0x37,
0x2f,0x39,0x50,0x65,0x6d,0x64,0x4d,0x37,0x2e,0x39,0x4f,0x64,0x6c,0x63,0x4e,0x39,
0x2f,0x38,0x50,0x65,0x6c,0x63,0x4d,0x37,0x2c,0x35,0x4c,0x65,0x6d,0x64,0x4c,0x36,
0x2c,0x36,0x4e,0x63,0x6b,0x64,0x4c,0x34,0x2d,0x3a,0x52,0x67,0x6d,0x62,0x4b,0x35,
0x2b,0x35,0x4d,0x64,0x6b,0x62,0x4b,0x35,0x2f,0x39,0x4e,0x64,0x6c,0x63,0x4b,0x35,
0x2b,0x37,0x4f,0x66,0x6c,0x65,0x4c,0x35,0x2b,0x37,0x4d,0x64,0x6a,0x5f,0x4a,0x35,
0x2e,0x3b,0x51,0x67,0x6f,0x64,0x4d,0x36,0x2d,0x39,0x52,0x68,0x6d,0x60,0x49,0x32,
0x29,0x37,0x4e,0x65,0x6d,0x62,0x49,0x36,0x31,0x3e,0x54,0x68,0x6c,0x60,0x49,0x33,
0x2b,0x38,0x4e,0x60,0x67,0x5f,0x4b,0x39,0x32,0x3b,0x4f,0x64,0x6a,0x60,0x4d,0x3b,
0x34,0x3b,0x49,0x57,0x5c,0x58,0x4b,0x40,0x3a,0x40,0x49,0x51,0x51,0x4b,0x44,0x3f,
0x3c,0x3d,0x40,0x43,0x3d,0x42,0x42,0x48,0x47,0x46,0x43,0x41,0x3e,0x40,0x40,0x42,
0x43,0x44,0x42,0x41,0x40,0x40,0x42,0x45,0x42,0x40,0x40,0x41,0x41,0x42,0x42,0x43,
0x43,0x42,0x40,0x41,0x43,0x45,0x45,0x45,0x44,0x43,0x43,0x42,0x42,0x45,0x44,0x44,
0x44,0x45,0x44,0x43,0x42,0x41,0x41,0x42,0x42,0x42,0x44,0x42,0x40,0x41,0x40,0x40,
0x42,0x43,0x40,0x3f,0x3c,0x3e,0x40,0x41,0x40,0x41,0x42,0x43,0x42,0x42,0x43,0x45,
0x45,0x44,0x41,0x40,0x40,0x40,0x41,0x42,0x41,0x42,0x42,0x41,0x40,0x42,0x44,0x44,
0x43,0x42,0x41,0x44,0x43,0x43,0x44,0x43,0x42,0x44,0x45,0x45,0x44,0x43,0x42,0x42,
0x42,0x44,0x44,0x45,0x44,0x43,0x43,0x43,0x44,0x47,0x45,0x44,0x42,0x42,0x41,0x42,
0x44,0x45,0x46,0x47,0x46,0x45,0x44,0x43,0x43,0x45,0x45,0x43,0x42,0x42,0x41,0x41,
0x40,0x42,0x43,0x42,0x42,0x42,0x42,0x41,0x40,0x40,0x42,0x42,0x44,0x43,0x42,0x42,
0x3f,0x3f,0x40,0x41,0x41,0x41,0x41,0x3f,0x3f,0x42,0x44,0x45,0x44,0x45,0x45,0x46,
0x45,0x44,0x44,0x42,0x40,0x3f,0x3b,0x3a,0x39,0x3a,0x39,0x38,0x38,0x3a,0x39,0x3b,
// Line 21
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//Field 6
// Line 10
0x36,0x36,0x39,0x3a,0x3a,0x3a,0x39,0x38,0x37,0x35,0x35,0x36,0x38,0x36,0x34,0x35,
0x36,0x37,0x37,0x36,0x37,0x39,0x3a,0x38,0x35,0x34,0x34,0x35,0x36,0x38,0x38,0x39,
0x3b,0x39,0x39,0x39,0x3a,0x3a,0x39,0x38,0x37,0x36,0x35,0x37,0x38,0x38,0x39,0x3a,
0x39,0x38,0x38,0x35,0x33,0x33,0x34,0x34,0x38,0x38,0x38,0x3a,0x38,0x36,0x38,0x38,
0x39,0x3b,0x39,0x36,0x36,0x35,0x35,0x35,0x37,0x38,0x38,0x38,0x36,0x35,0x38,0x38,
0x38,0x38,0x36,0x35,0x36,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x36,0x38,
0x39,0x3a,0x3a,0x38,0x37,0x35,0x35,0x36,0x38,0x38,0x3a,0x39,0x37,0x35,0x35,0x38,
0x3a,0x3c,0x3c,0x39,0x39,0x38,0x36,0x38,0x38,0x38,0x3a,0x38,0x37,0x36,0x36,0x35,
0x37,0x37,0x38,0x37,0x36,0x34,0x35,0x36,0x38,0x38,0x38,0x36,0x36,0x39,0x39,0x3a,
0x3a,0x38,0x38,0x38,0x38,0x3a,0x3c,0x3e,0x3d,0x3a,0x38,0x37,0x38,0x39,0x38,0x38,
0x39,0x38,0x36,0x34,0x34,0x34,0x35,0x36,0x38,0x38,0x38,0x37,0x35,0x36,0x38,0x39,
0x3a,0x3a,0x3b,0x3b,0x3a,0x38,0x38,0x39,0x39,0x39,0x39,0x3a,0x39,0x38,0x36,0x38,
0x3a,0x3c,0x3c,0x3c,0x3c,0x3a,0x39,0x37,0x35,0x36,0x38,0x39,0x38,0x37,0x39,0x3b,
0x3b,0x3a,0x3a,0x3c,0x3c,0x3b,0x3a,0x39,0x3a,0x3c,0x3e,0x3d,0x3e,0x3b,0x3b,0x3b,
0x3a,0x39,0x38,0x38,0x35,0x33,0x34,0x36,0x36,0x38,0x38,0x35,0x36,0x36,0x35,0x34,
0x34,0x33,0x35,0x35,0x37,0x36,0x39,0x39,0x38,0x39,0x3a,0x3c,0x3c,0x3c,0x3a,0x39,
0x37,0x36,0x38,0x3a,0x38,0x38,0x36,0x36,0x38,0x37,0x36,0x36,0x38,0x38,0x38,0x35,
0x35,0x38,0x3c,0x3c,0x39,0x35,0x34,0x35,0x38,0x39,0x3a,0x38,0x3c,0x38,0x34,0x35,
0x37,0x3a,0x3c,0x3b,0x39,0x37,0x36,0x36,0x36,0x37,0x37,0x38,0x38,0x37,0x35,0x34,
0x34,0x34,0x36,0x37,0x37,0x38,0x38,0x36,0x37,0x36,0x36,0x37,0x37,0x38,0x38,0x37,
0x38,0x38,0x39,0x39,0x39,0x3c,0x3e,0x3e,0x3d,0x39,0x38,0x39,0x3a,0x39,0x38,0x38,
0x36,0x35,0x34,0x36,0x39,0x3b,0x3c,0x3c,0x3c,0x39,0x38,0x38,0x38,0x39,0x3a,0x39,
0x38,0x36,0x35,0x35,0x36,0x36,0x36,0x35,0x39,0x39,0x38,0x39,0x3a,0x3a,0x3b,0x3a,
0x38,0x38,0x39,0x38,0x36,0x35,0x36,0x38,0x39,0x3a,0x39,0x3b,0x3a,0x39,0x38,0x38,
0x37,0x38,0x38,0x38,0x3a,0x3b,0x39,0x38,0x38,0x38,0x39,0x39,0x39,0x39,0x39,0x38,
0x36,0x36,0x38,0x3b,0x3b,0x38,0x36,0x38,0x38,0x38,0x36,0x39,0x38,0x38,0x38,0x37,
0x35,0x35,0x35,0x35,0x37,0x38,0x39,0x3b,0x3b,0x39,0x3a,0x3b,0x3c,0x3d,0x3c,0x3a,
0x3a,0x39,0x37,0x38,0x38,0x3a,0x39,0x39,0x38,0x36,0x37,0x38,0x36,0x38,0x39,0x39,
0x38,0x36,0x35,0x35,0x36,0x36,0x33,0x35,0x36,0x36,0x37,0x36,0x36,0x38,0x38,0x38,
0x3b,0x3c,0x3d,0x3b,0x38,0x36,0x37,0x39,0x3a,0x3a,0x39,0x37,0x35,0x35,0x36,0x38,
0x3b,0x3a,0x38,0x38,0x39,0x38,0x38,0x37,0x38,0x38,0x38,0x36,0x37,0x36,0x36,0x36,
0x38,0x39,0x39,0x3e,0x3c,0x3b,0x3c,0x3c,0x3c,0x3b,0x39,0x39,0x39,0x38,0x38,0x36,
0x3c,0x3d,0x3c,0x3b,0x3b,0x3c,0x3d,0x3b,0x38,0x38,0x38,0x38,0x38,0x36,0x35,0x36,
0x38,0x37,0x37,0x38,0x39,0x39,0x39,0x38,0x36,0x35,0x36,0x38,0x3a,0x3b,0x3a,0x38,
0x36,0x35,0x36,0x39,0x3a,0x3b,0x3a,0x38,0x36,0x35,0x38,0x39,0x3b,0x3b,0x3a,0x3a,
0x3a,0x3a,0x3b,0x3a,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x38,0x38,0x38,0x38,0x3a,
0x39,0x37,0x38,0x38,0x36,0x35,0x35,0x36,0x39,0x39,0x38,0x38,0x3a,0x3a,0x39,0x3a,
0x3b,0x3c,0x3c,0x3a,0x36,0x34,0x34,0x37,0x38,0x36,0x35,0x37,0x39,0x39,0x38,0x38,
0x3a,0x3a,0x3b,0x3b,0x3a,0x39,0x38,0x38,0x38,0x36,0x36,0x38,0x3a,0x3b,0x3c,0x3a,
0x39,0x36,0x3a,0x3b,0x3a,0x39,0x38,0x38,0x38,0x36,0x32,0x33,0x35,0x36,0x36,0x34,
0x33,0x37,0x3a,0x3a,0x39,0x38,0x39,0x3c,0x3c,0x3a,0x39,0x3a,0x39,0x37,0x37,0x36,
0x36,0x37,0x38,0x38,0x39,0x38,0x3a,0x3a,0x39,0x36,0x38,0x3a,0x3c,0x3b,0x3a,0x38,
0x35,0x36,0x38,0x39,0x3a,0x38,0x35,0x35,0x35,0x36,0x37,0x39,0x3b,0x3a,0x3a,0x38,
0x38,0x38,0x37,0x36,0x35,0x33,0x34,0x35,0x35,0x35,0x37,0x39,0x3c,0x39,0x3b,0x3c,
0x3c,0x3a,0x39,0x38,0x3b,0x39,0x38,0x39,0x38,0x37,0x37,0x36,0x35,0x36,0x39,0x3a,
0x38,0x38,0x38,0x38,0x39,0x38,0x37,0x38,0x38,0x38,0x38,0x38,0x3a,0x3c,0x3a,0x39,
0x3a,0x3c,0x3e,0x3c,0x39,0x37,0x36,0x36,0x35,0x34,0x3a,0x38,0x36,0x35,0x36,0x38,
0x3a,0x3b,0x3b,0x3c,0x3c,0x3c,0x38,0x38,0x36,0x35,0x37,0x36,0x36,0x37,0x37,0x36,
0x36,0x37,0x38,0x38,0x38,0x35,0x34,0x36,0x36,0x37,0x38,0x38,0x38,0x39,0x38,0x38,
0x38,0x38,0x36,0x38,0x38,0x38,0x38,0x36,0x34,0x35,0x37,0x37,0x36,0x35,0x36,0x39,
0x3a,0x38,0x37,0x37,0x38,0x37,0x36,0x35,0x36,0x38,0x38,0x36,0x36,0x38,0x3b,0x3b,
0x3a,0x39,0x38,0x38,0x38,0x34,0x35,0x35,0x32,0x32,0x33,0x37,0x39,0x38,0x36,0x35,
0x36,0x36,0x35,0x36,0x38,0x38,0x38,0x35,0x33,0x35,0x38,0x39,0x3a,0x39,0x39,0x38,
0x34,0x31,0x32,0x34,0x36,0x35,0x36,0x36,0x38,0x38,0x36,0x35,0x36,0x38,0x39,0x39,
0x38,0x37,0x38,0x38,0x35,0x34,0x34,0x35,0x34,0x33,0x34,0x36,0x38,0x38,0x36,0x3a,
0x39,0x3b,0x3f,0x3e,0x3c,0x3b,0x39,0x35,0x33,0x33,0x36,0x37,0x37,0x35,0x35,0x37,
0x38,0x38,0x38,0x38,0x38,0x35,0x33,0x32,0x33,0x33,0x34,0x35,0x38,0x3a,0x3a,0x38,
0x38,0x3a,0x3d,0x3d,0x3b,0x39,0x3a,0x39,0x38,0x36,0x38,0x3a,0x3a,0x36,0x35,0x35,
0x38,0x39,0x39,0x38,0x38,0x39,0x38,0x36,0x36,0x37,0x39,0x39,0x37,0x36,0x38,0x38,
0x38,0x37,0x38,0x39,0x37,0x35,0x33,0x35,0x38,0x38,0x37,0x37,0x34,0x34,0x36,0x36,
0x36,0x38,0x3b,0x39,0x38,0x39,0x3a,0x39,0x3b,0x39,0x38,0x38,0x39,0x37,0x39,0x39,
0x39,0x3a,0x3a,0x3b,0x3b,0x3b,0x39,0x38,0x36,0x36,0x36,0x36,0x36,0x36,0x38,0x38,
0x38,0x37,0x38,0x3a,0x3c,0x3b,0x3a,0x39,0x38,0x38,0x39,0x3a,0x3c,0x3b,0x3a,0x38,
0x38,0x3a,0x3b,0x3a,0x3c,0x3b,0x3a,0x39,0x38,0x38,0x3b,0x3a,0x38,0x37,0x37,0x39,
0x3a,0x39,0x3a,0x39,0x38,0x36,0x35,0x36,0x36,0x37,0x39,0x39,0x36,0x33,0x32,0x33,
0x34,0x35,0x36,0x38,0x36,0x33,0x34,0x36,0x39,0x3a,0x3c,0x3c,0x39,0x36,0x33,0x32,
0x34,0x35,0x37,0x37,0x38,0x38,0x39,0x37,0x35,0x35,0x36,0x36,0x36,0x35,0x36,0x35,
0x38,0x37,0x38,0x39,0x39,0x38,0x38,0x37,0x37,0x36,0x36,0x35,0x34,0x35,0x35,0x36,
0x38,0x37,0x38,0x3a,0x3a,0x39,0x39,0x3a,0x39,0x39,0x39,0x39,0x37,0x34,0x33,0x32,
0x34,0x35,0x35,0x36,0x36,0x34,0x35,0x34,0x34,0x35,0x37,0x36,0x35,0x34,0x34,0x34,
0x36,0x37,0x38,0x3b,0x39,0x36,0x37,0x35,0x34,0x36,0x36,0x37,0x38,0x38,0x36,0x36,
0x35,0x37,0x37,0x36,0x34,0x33,0x34,0x34,0x34,0x33,0x33,0x34,0x38,0x36,0x35,0x37,
0x38,0x38,0x37,0x37,0x39,0x3a,0x38,0x36,0x35,0x36,0x35,0x34,0x35,0x35,0x35,0x36,
0x36,0x36,0x38,0x39,0x37,0x36,0x35,0x36,0x38,0x39,0x38,0x38,0x39,0x38,0x35,0x34,
0x36,0x36,0x38,0x36,0x34,0x35,0x36,0x36,0x37,0x37,0x38,0x38,0x36,0x35,0x34,0x36,
0x36,0x35,0x34,0x34,0x35,0x39,0x38,0x36,0x36,0x36,0x37,0x38,0x38,0x38,0x36,0x35,
0x34,0x33,0x36,0x39,0x3a,0x3b,0x38,0x36,0x38,0x38,0x39,0x38,0x38,0x35,0x34,0x33,
0x33,0x34,0x39,0x38,0x38,0x38,0x38,0x38,0x37,0x36,0x34,0x35,0x34,0x32,0x32,0x33,
0x35,0x39,0x3a,0x3c,0x3c,0x3a,0x39,0x39,0x3a,0x3a,0x3a,0x39,0x35,0x32,0x32,0x32,
0x33,0x35,0x38,0x39,0x3a,0x39,0x3a,0x38,0x3a,0x38,0x37,0x37,0x37,0x34,0x33,0x33,
0x33,0x35,0x34,0x34,0x36,0x36,0x38,0x38,0x37,0x37,0x36,0x36,0x36,0x36,0x38,0x39,
0x39,0x38,0x36,0x33,0x33,0x35,0x36,0x36,0x36,0x36,0x38,0x39,0x3a,0x39,0x38,0x35,
0x34,0x33,0x33,0x33,0x33,0x34,0x35,0x36,0x35,0x35,0x38,0x3b,0x3d,0x3c,0x39,0x38,
0x38,0x36,0x36,0x36,0x37,0x38,0x38,0x38,0x38,0x38,0x3a,0x3a,0x38,0x37,0x36,0x35,
0x35,0x35,0x37,0x36,0x36,0x34,0x33,0x36,0x39,0x3a,0x3d,0x3a,0x39,0x39,0x38,0x36,
0x36,0x37,0x39,0x39,0x39,0x38,0x35,0x37,0x37,0x38,0x39,0x3a,0x3a,0x3a,0x38,0x36,
0x38,0x38,0x3a,0x3c,0x3a,0x36,0x35,0x35,0x35,0x36,0x39,0x3a,0x39,0x38,0x38,0x38,
0x39,0x39,0x3a,0x3b,0x39,0x36,0x34,0x34,0x35,0x36,0x37,0x38,0x37,0x37,0x37,0x37,
0x38,0x38,0x36,0x36,0x35,0x34,0x36,0x38,0x38,0x37,0x36,0x34,0x36,0x36,0x39,0x3a,
0x3a,0x38,0x38,0x38,0x39,0x39,0x39,0x38,0x36,0x38,0x38,0x38,0x36,0x36,0x38,0x3a,
0x38,0x36,0x37,0x38,0x38,0x35,0x34,0x33,0x36,0x36,0x36,0x35,0x37,0x37,0x37,0x38,
0x38,0x38,0x3a,0x39,0x38,0x38,0x38,0x39,0x39,0x39,0x39,0x38,0x37,0x35,0x36,0x37,
0x38,0x38,0x38,0x37,0x36,0x37,0x38,0x37,0x38,0x38,0x38,0x36,0x36,0x36,0x37,0x38,
0x37,0x35,0x38,0x39,0x38,0x37,0x35,0x35,0x37,0x38,0x38,0x36,0x38,0x37,0x37,0x37,
0x37,0x38,0x39,0x37,0x35,0x35,0x36,0x38,0x38,0x36,0x35,0x36,0x35,0x33,0x34,0x37,
0x38,0x38,0x38,0x39,0x3b,0x3b,0x39,0x37,0x37,0x37,0x36,0x33,0x32,0x30,0x33,0x32,
// Line 11
0x35,0x32,0x31,0x33,0x37,0x38,0x3a,0x39,0x37,0x36,0x37,0x36,0x36,0x38,0x38,0x35,
0x35,0x35,0x36,0x37,0x37,0x35,0x36,0x37,0x39,0x39,0x37,0x36,0x34,0x35,0x34,0x33,
0x34,0x35,0x33,0x34,0x33,0x35,0x38,0x39,0x39,0x37,0x36,0x37,0x39,0x3a,0x3b,0x39,
0x35,0x32,0x33,0x3d,0x4f,0x60,0x6f,0x77,0x74,0x6b,0x5e,0x52,0x52,0x5a,0x67,0x71,
0x75,0x73,0x6f,0x68,0x60,0x5d,0x5f,0x65,0x6d,0x74,0x74,0x72,0x6e,0x66,0x5f,0x5b,
0x5e,0x64,0x6e,0x73,0x74,0x6e,0x67,0x60,0x5a,0x59,0x5f,0x67,0x70,0x76,0x75,0x71,
0x6a,0x64,0x60,0x60,0x64,0x68,0x6f,0x70,0x70,0x6e,0x68,0x62,0x5c,0x59,0x5c,0x63,
0x6a,0x70,0x74,0x70,0x67,0x5e,0x58,0x59,0x5e,0x65,0x6e,0x76,0x78,0x73,0x6c,0x65,
0x61,0x60,0x64,0x67,0x69,0x6a,0x6a,0x6b,0x70,0x78,0x85,0x90,0x9f,0xa8,0xa9,0xa4,
0x97,0x85,0x78,0x6b,0x62,0x5a,0x53,0x4d,0x47,0x3e,0x36,0x34,0x3a,0x4a,0x5d,0x6e,
0x7c,0x85,0x8d,0x91,0x94,0x97,0x9a,0x9c,0x9d,0x9b,0x99,0x99,0x9a,0x99,0x95,0x8d,
0x81,0x71,0x63,0x59,0x52,0x4c,0x43,0x3a,0x36,0x38,0x45,0x59,0x6f,0x7c,0x80,0x79,
0x6a,0x5e,0x57,0x53,0x4e,0x47,0x3c,0x32,0x2f,0x37,0x49,0x64,0x79,0x83,0x83,0x76,
0x67,0x59,0x50,0x4a,0x46,0x40,0x3d,0x38,0x31,0x2a,0x2b,0x33,0x3e,0x4c,0x5d,0x6b,
0x73,0x76,0x71,0x67,0x5f,0x5a,0x56,0x52,0x49,0x3e,0x35,0x2f,0x33,0x43,0x5b,0x72,
0x83,0x8d,0x95,0x96,0x98,0x94,0x8b,0x7d,0x6b,0x5d,0x56,0x59,0x64,0x70,0x76,0x74,
0x6c,0x64,0x5d,0x59,0x5d,0x56,0x48,0x38,0x2b,0x29,0x36,0x4c,0x64,0x75,0x7c,0x78,
0x6c,0x5f,0x56,0x52,0x4f,0x48,0x3d,0x32,0x2d,0x36,0x4b,0x62,0x74,0x7f,0x7d,0x72,
0x64,0x59,0x58,0x5e,0x66,0x6b,0x70,0x76,0x7d,0x82,0x8f,0x9a,0xa3,0xa8,0xa5,0x9d,
0x93,0x87,0x79,0x6b,0x5f,0x55,0x4d,0x47,0x42,0x3f,0x3d,0x3b,0x37,0x35,0x35,0x37,
0x3e,0x47,0x51,0x5f,0x6b,0x76,0x80,0x89,0x92,0x96,0x93,0x88,0x7a,0x67,0x56,0x48,
0x3e,0x39,0x39,0x3a,0x3a,0x38,0x3a,0x3c,0x3e,0x41,0x41,0x3d,0x37,0x32,0x32,0x3d,
0x51,0x67,0x75,0x7d,0x78,0x6b,0x62,0x5a,0x59,0x60,0x68,0x6e,0x72,0x76,0x80,0x8c,
0x97,0x9e,0x9e,0x95,0x84,0x6f,0x5c,0x4e,0x43,0x3d,0x39,0x37,0x38,0x38,0x3a,0x3c,
0x3c,0x3c,0x3a,0x38,0x35,0x35,0x36,0x38,0x37,0x37,0x38,0x3a,0x3d,0x3d,0x3d,0x3c,
0x3a,0x38,0x38,0x38,0x3a,0x3c,0x3c,0x3a,0x38,0x39,0x3b,0x3b,0x3a,0x39,0x3a,0x3b,
0x38,0x36,0x37,0x38,0x3a,0x3a,0x3a,0x39,0x39,0x38,0x37,0x36,0x38,0x3a,0x3a,0x3a,
0x39,0x38,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x38,0x37,0x38,0x39,0x3a,0x3a,0x3b,0x3c,
0x3c,0x3a,0x3a,0x38,0x37,0x38,0x37,0x36,0x36,0x35,0x36,0x37,0x38,0x38,0x38,0x38,
0x37,0x37,0x38,0x3a,0x38,0x37,0x36,0x35,0x36,0x36,0x37,0x39,0x3a,0x38,0x37,0x36,
0x37,0x37,0x3a,0x3a,0x38,0x38,0x38,0x38,0x3a,0x39,0x39,0x3c,0x3c,0x39,0x37,0x35,
0x35,0x37,0x3a,0x3c,0x3c,0x3a,0x38,0x39,0x39,0x39,0x3a,0x3a,0x3a,0x39,0x39,0x38,
0x38,0x39,0x39,0x38,0x39,0x38,0x38,0x37,0x38,0x36,0x35,0x36,0x38,0x36,0x3a,0x38,
0x38,0x3c,0x3d,0x3c,0x3d,0x3b,0x3b,0x3c,0x3b,0x39,0x39,0x37,0x36,0x35,0x36,0x37,
0x38,0x39,0x38,0x36,0x36,0x36,0x39,0x3b,0x3b,0x39,0x3a,0x39,0x3a,0x3a,0x3c,0x3c,
0x3a,0x3a,0x3a,0x39,0x3c,0x38,0x36,0x37,0x35,0x35,0x37,0x38,0x38,0x3a,0x38,0x37,
0x36,0x36,0x36,0x38,0x3a,0x38,0x36,0x33,0x32,0x32,0x35,0x37,0x38,0x37,0x36,0x36,
0x36,0x36,0x37,0x38,0x39,0x38,0x37,0x36,0x35,0x36,0x36,0x35,0x33,0x35,0x37,0x38,
0x38,0x36,0x36,0x39,0x3a,0x39,0x36,0x37,0x36,0x35,0x36,0x35,0x35,0x38,0x39,0x39,
0x3b,0x3a,0x39,0x38,0x38,0x39,0x3a,0x39,0x38,0x3a,0x3d,0x3b,0x39,0x38,0x3b,0x3d,
0x3a,0x36,0x34,0x35,0x36,0x35,0x34,0x33,0x35,0x37,0x37,0x37,0x37,0x38,0x39,0x39,
0x37,0x35,0x36,0x38,0x38,0x36,0x36,0x36,0x34,0x34,0x34,0x35,0x36,0x36,0x36,0x35,
0x35,0x33,0x34,0x36,0x37,0x36,0x37,0x35,0x36,0x38,0x3a,0x3a,0x38,0x36,0x38,0x39,
0x37,0x34,0x34,0x35,0x35,0x33,0x32,0x32,0x34,0x36,0x37,0x38,0x39,0x38,0x37,0x35,
0x33,0x34,0x37,0x37,0x38,0x38,0x36,0x34,0x33,0x33,0x36,0x36,0x3a,0x38,0x37,0x38,
0x39,0x38,0x3a,0x38,0x3a,0x3b,0x3a,0x38,0x37,0x37,0x37,0x36,0x35,0x33,0x34,0x36,
0x36,0x35,0x37,0x37,0x38,0x37,0x38,0x39,0x3c,0x3b,0x39,0x39,0x38,0x39,0x3a,0x39,
0x37,0x36,0x35,0x33,0x33,0x34,0x36,0x37,0x36,0x34,0x33,0x36,0x38,0x39,0x3a,0x38,
0x36,0x35,0x34,0x35,0x37,0x39,0x3a,0x38,0x37,0x36,0x35,0x34,0x33,0x33,0x35,0x36,
0x35,0x34,0x33,0x33,0x36,0x37,0x37,0x36,0x37,0x36,0x35,0x36,0x37,0x38,0x38,0x38,
0x39,0x3c,0x3d,0x3d,0x3d,0x3d,0x3c,0x39,0x36,0x34,0x32,0x36,0x36,0x34,0x34,0x35,
0x36,0x37,0x38,0x37,0x38,0x39,0x39,0x38,0x36,0x34,0x34,0x34,0x35,0x37,0x37,0x36,
0x36,0x37,0x36,0x34,0x32,0x32,0x35,0x37,0x37,0x35,0x34,0x34,0x34,0x36,0x38,0x38,
0x37,0x36,0x36,0x34,0x34,0x36,0x36,0x38,0x36,0x32,0x33,0x33,0x34,0x33,0x33,0x33,
0x35,0x35,0x35,0x35,0x36,0x35,0x33,0x33,0x35,0x36,0x38,0x37,0x36,0x37,0x38,0x37,
0x37,0x38,0x3a,0x3a,0x3a,0x39,0x3a,0x3a,0x3b,0x38,0x38,0x38,0x38,0x38,0x37,0x37,
0x39,0x38,0x37,0x37,0x37,0x38,0x39,0x3a,0x38,0x37,0x37,0x37,0x37,0x39,0x3b,0x3c,
0x3c,0x3b,0x3a,0x3a,0x39,0x37,0x36,0x36,0x37,0x37,0x38,0x38,0x38,0x38,0x38,0x39,
0x3a,0x3a,0x3a,0x3c,0x38,0x36,0x36,0x37,0x3a,0x39,0x3a,0x38,0x38,0x38,0x37,0x37,
0x37,0x38,0x38,0x38,0x37,0x35,0x36,0x35,0x33,0x33,0x35,0x35,0x34,0x33,0x33,0x35,
0x37,0x38,0x39,0x3a,0x3c,0x39,0x37,0x35,0x33,0x34,0x35,0x3b,0x46,0x55,0x65,0x75,
0x80,0x88,0x8e,0x95,0x9b,0x9d,0x9f,0x9f,0x9d,0x99,0x96,0x96,0x97,0x99,0x9c,0x9e,
0x9f,0x9e,0x9a,0x97,0x96,0x97,0x99,0x99,0x99,0x99,0x99,0x99,0x9a,0x9a,0x9c,0x9e,
0x9d,0x9b,0x9b,0x9b,0x9b,0x99,0x97,0x97,0x99,0x9a,0x9b,0x9a,0x9c,0x9a,0x98,0x9a,
0x9a,0x9a,0x9b,0x9a,0x97,0x97,0x9a,0x9a,0x99,0x99,0x99,0x99,0x99,0x98,0x97,0x99,
0x99,0x97,0x99,0x9a,0x9b,0x9b,0x9b,0x9a,0x9a,0x99,0x99,0x99,0x98,0x97,0x98,0x99,
0x99,0x97,0x98,0x99,0x9a,0x9b,0x9b,0x9b,0x9b,0x99,0x99,0x9b,0x9c,0x9b,0x99,0x99,
0x99,0x9a,0x9b,0x9d,0x9f,0x9e,0x9e,0x9d,0x9d,0x9b,0x9d,0x9e,0x9e,0x9b,0x9b,0x9a,
0x9b,0x9b,0x99,0x98,0x99,0x9b,0x9a,0x99,0x9a,0x9a,0x9a,0x9b,0x9b,0x99,0x9b,0x9b,
0x9a,0x9a,0x9a,0x9b,0x9a,0x9a,0x9a,0x9b,0x9c,0x9b,0x9b,0x9b,0x9c,0x9a,0x9b,0x9b,
0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9c,0x9d,0x9d,0x9b,0x9b,0x9c,0x9d,0x9a,0x9a,0x9a,
0x9b,0x9d,0x9c,0x9a,0x9b,0x9a,0x9a,0x9b,0x9c,0x9c,0x9b,0x9a,0x9a,0x9c,0x9d,0x9d,
0x9d,0x9e,0xa0,0x9e,0x9e,0x9c,0x9a,0x9a,0x99,0x97,0x99,0x9a,0x9c,0x9c,0x9a,0x99,
0x9a,0x9d,0x9e,0x9d,0x9e,0x9e,0x9e,0x9f,0xa0,0xa1,0xa3,0xa1,0x9d,0x9b,0x9a,0x9a,
0x9b,0x9a,0x99,0x99,0x9a,0x9d,0x9c,0x9d,0x9e,0x9e,0x9d,0x9b,0x9a,0x9a,0x9b,0x9b,
0x9b,0x9b,0x9c,0x9c,0x9d,0x9d,0x9e,0x9e,0x9d,0x9b,0x9a,0x9a,0x99,0x99,0x97,0x97,
0x98,0x98,0x97,0x98,0x9a,0x9b,0x9d,0x9d,0x9b,0x9c,0x9d,0x9e,0x9e,0x9d,0x9b,0x9a,
0x9b,0x99,0x99,0x9d,0x9b,0x9b,0x9a,0x9a,0x9b,0x9b,0x9d,0x9d,0x9e,0x9f,0x9e,0x9c,
0x9b,0x9b,0x9a,0x9a,0x9a,0x99,0x9b,0x9c,0x9d,0x9e,0x9e,0x9d,0x9e,0x9e,0xa0,0xa1,
0xa3,0xa3,0xa1,0x9f,0x9e,0x9e,0xa1,0xa1,0xa0,0x9c,0x99,0x96,0x95,0x97,0x9a,0x9d,
0x9d,0x9c,0x9d,0x9d,0x9f,0xa0,0xa1,0xa0,0x9f,0x9f,0x9f,0x9c,0x9b,0x9b,0x9b,0x9b,
0x9a,0x9a,0x9a,0x9c,0x9c,0x9c,0x9d,0x9c,0x9b,0x9a,0x99,0x99,0x9a,0x99,0x9a,0x9b,
0x9b,0x99,0x9a,0x9a,0x9c,0x9e,0x9e,0x9b,0x99,0x99,0x9a,0x9b,0x9b,0x9d,0xa1,0xa3,
0xa2,0x9f,0x9e,0x9f,0x9f,0x9f,0x9f,0x9f,0x9d,0x9a,0x98,0x99,0x9a,0x9d,0x9e,0x9e,
0x9d,0x9d,0x9c,0x9b,0x9a,0x9c,0x9e,0x9f,0x9e,0x9c,0x9b,0x9b,0x9b,0x9d,0xa0,0xa1,
0xa1,0x9f,0x9e,0x9c,0x9b,0x9c,0x9d,0x9d,0x9c,0x9a,0x99,0x9a,0x9b,0x9d,0x9e,0x9e,
0x9b,0x9b,0x9d,0x9e,0x9d,0x9d,0x9b,0x9a,0x9b,0x9d,0x9d,0xa1,0x9f,0x9e,0x9e,0x9d,
0x9b,0x9d,0x9e,0x9d,0x9d,0x9d,0x9d,0x9c,0x9b,0x9c,0x9c,0x9d,0x9e,0x9d,0x9b,0x9a,
0x9a,0x99,0x99,0x9b,0x9d,0x9b,0x94,0x87,0x7b,0x70,0x65,0x5b,0x51,0x48,0x42,0x3b,
0x36,0x3a,0x44,0x54,0x65,0x76,0x83,0x8b,0x8f,0x92,0x96,0x97,0x90,0x81,0x6e,0x5e,
0x54,0x57,0x61,0x70,0x7f,0x82,0x7b,0x6f,0x60,0x59,0x5d,0x67,0x72,0x78,0x7a,0x76,
0x6d,0x64,0x60,0x60,0x60,0x5b,0x4f,0x40,0x32,0x2c,0x32,0x41,0x59,0x73,0x89,0x95,
0x99,0x9a,0x9a,0x9a,0x9b,0x9e,0xa1,0xa1,0x97,0x87,0x74,0x63,0x58,0x55,0x5b,0x65,
0x72,0x7a,0x79,0x72,0x69,0x62,0x5d,0x59,0x52,0x4b,0x43,0x38,0x2f,0x2d,0x32,0x39,
0x40,0x41,0x40,0x3b,0x37,0x32,0x32,0x34,0x35,0x35,0x35,0x36,0x37,0x3a,0x3d,0x3d,
0x3d,0x39,0x36,0x38,0x3a,0x3d,0x3e,0x40,0x3f,0x3c,0x39,0x3a,0x3b,0x3c,0x3a,0x38,
// Line 12
0x38,0x38,0x38,0x37,0x35,0x33,0x34,0x37,0x38,0x36,0x35,0x33,0x32,0x33,0x34,0x35,
0x36,0x35,0x36,0x37,0x38,0x39,0x3a,0x3c,0x3c,0x38,0x37,0x37,0x36,0x36,0x35,0x33,
0x33,0x31,0x31,0x32,0x34,0x35,0x37,0x38,0x36,0x33,0x32,0x32,0x34,0x37,0x37,0x35,
0x32,0x31,0x35,0x3f,0x4e,0x61,0x71,0x7a,0x78,0x6d,0x60,0x59,0x56,0x5c,0x65,0x6e,
0x76,0x78,0x71,0x68,0x5e,0x5a,0x5e,0x65,0x6d,0x71,0x74,0x70,0x69,0x60,0x59,0x57,
0x5b,0x61,0x68,0x6e,0x6e,0x6c,0x67,0x61,0x5c,0x5c,0x5e,0x65,0x6b,0x71,0x71,0x6d,
0x68,0x62,0x5c,0x5c,0x5e,0x65,0x6e,0x73,0x75,0x71,0x6a,0x60,0x5a,0x59,0x5d,0x64,
0x6d,0x72,0x73,0x70,0x68,0x60,0x5b,0x5b,0x60,0x6a,0x74,0x7b,0x7b,0x75,0x6e,0x68,
0x62,0x60,0x61,0x65,0x68,0x6a,0x6a,0x6d,0x73,0x7c,0x87,0x92,0x9f,0xa7,0xa9,0xa3,
0x96,0x84,0x74,0x67,0x5d,0x56,0x53,0x4d,0x46,0x3d,0x34,0x33,0x3c,0x4a,0x5c,0x70,
0x7f,0x89,0x8f,0x92,0x96,0x9a,0x9e,0x9f,0x9d,0x99,0x98,0x98,0x99,0x99,0x97,0x8e,
0x7f,0x6f,0x64,0x5b,0x53,0x4b,0x42,0x39,0x34,0x37,0x44,0x59,0x6e,0x7c,0x7f,0x79,
0x6d,0x61,0x5a,0x54,0x4f,0x48,0x3d,0x33,0x2f,0x37,0x49,0x63,0x79,0x82,0x80,0x75,
0x65,0x56,0x4f,0x4b,0x47,0x43,0x3c,0x34,0x2d,0x2c,0x2e,0x33,0x3e,0x4a,0x5c,0x6a,
0x73,0x75,0x73,0x6b,0x64,0x5f,0x5b,0x55,0x50,0x42,0x36,0x32,0x37,0x47,0x5e,0x74,
0x84,0x8d,0x90,0x92,0x90,0x91,0x89,0x7b,0x6a,0x5a,0x52,0x58,0x65,0x73,0x7d,0x7d,
0x73,0x68,0x60,0x5d,0x5e,0x5b,0x50,0x3e,0x30,0x2c,0x37,0x4e,0x69,0x7d,0x84,0x7d,
0x6e,0x61,0x5a,0x55,0x50,0x46,0x3b,0x35,0x34,0x3d,0x4e,0x66,0x78,0x81,0x7f,0x75,
0x67,0x5a,0x52,0x4c,0x48,0x42,0x3c,0x38,0x33,0x30,0x33,0x3b,0x43,0x4d,0x55,0x60,
0x6b,0x75,0x7f,0x88,0x8f,0x92,0x91,0x8a,0x7f,0x6e,0x5d,0x4d,0x41,0x3b,0x3c,0x3d,
0x3d,0x3a,0x36,0x34,0x34,0x39,0x46,0x57,0x68,0x72,0x77,0x74,0x6c,0x62,0x58,0x51,
0x4d,0x49,0x41,0x38,0x2f,0x2a,0x2c,0x34,0x3d,0x40,0x46,0x3e,0x35,0x2f,0x31,0x3e,
0x53,0x68,0x78,0x81,0x80,0x76,0x67,0x5f,0x5b,0x5d,0x63,0x6a,0x6e,0x76,0x7c,0x83,
0x8e,0x99,0xa2,0xa9,0xa8,0xa0,0x9a,0x96,0x94,0x96,0x99,0x9d,0xa0,0xa2,0xa2,0xa1,
0xa0,0x9f,0x9c,0x9c,0x9b,0x9c,0x9d,0x9c,0x9c,0x9d,0x9d,0x9c,0x9a,0x98,0x9a,0x9c,
0x9e,0x9d,0x9d,0x9f,0x9f,0x9c,0x9b,0x9b,0x9c,0x9d,0x9d,0x9c,0x9e,0x9e,0x9e,0x9d,
0x9d,0x9c,0x9d,0x9d,0x9d,0x9c,0x9c,0x9c,0x9c,0x9e,0xa0,0xa2,0xa3,0xa2,0xa1,0xa2,
0xa2,0xa3,0xa2,0xa0,0x9c,0x9a,0x9b,0x9b,0x9b,0x9c,0x9c,0x9d,0x9d,0x9c,0x9c,0x9e,
0x9e,0x9c,0x9d,0x9c,0x9e,0x9d,0x9d,0x9c,0x9d,0x9d,0x9c,0x99,0x9b,0x9b,0x9a,0x9a,
0x99,0x99,0x9c,0x9d,0x9d,0x9f,0x9f,0x9f,0x9c,0x9a,0x9a,0x9a,0x9c,0x9c,0x9b,0x9d,
0x9c,0x9b,0x9c,0x9d,0x9e,0x9d,0x9e,0x9d,0x9d,0x9d,0x9e,0x9d,0x9c,0x9c,0x9c,0x9d,
0x9c,0x9c,0x9c,0x9c,0x9c,0x9e,0x9f,0x9f,0x9f,0x9d,0x9c,0x9c,0x9d,0x9e,0x9c,0x9e,
0x9c,0x9c,0x9a,0x99,0x99,0x9a,0x9c,0x9c,0x9c,0x9b,0x9b,0x9c,0x9d,0x9d,0x9d,0x9f,
0xa0,0x9e,0x9c,0x9a,0x9b,0x9d,0x9e,0x9f,0x9f,0x9d,0x9c,0x9b,0x9a,0x99,0x9c,0x9d,
0x9e,0x9e,0x9f,0x9e,0x9d,0x9c,0x9b,0x9c,0x9d,0x9d,0x9d,0x9d,0x9d,0x9e,0xa0,0xa1,
0xa2,0xa1,0xa0,0x9e,0x9d,0x9d,0x9e,0x9f,0x9e,0x9b,0x9a,0x9c,0x9d,0x9d,0x9d,0x9c,
0x9b,0x9a,0x9a,0x9b,0x9d,0x9d,0x9d,0x9f,0x9f,0x9d,0x9a,0x99,0x99,0x99,0x9b,0x9c,
0x9b,0x9c,0x9d,0x9b,0x9c,0x9c,0x9c,0x9e,0x9f,0x9e,0x9c,0x9b,0x9b,0x99,0x9b,0x9a,
0x9a,0x9c,0x9c,0x9c,0x9a,0x98,0x98,0x9c,0x9e,0x9f,0x9e,0x9d,0x9d,0x9d,0x9e,0x9d,
0x9e,0x9e,0x9f,0x9f,0x9f,0x9e,0x9d,0x9f,0xa0,0xa0,0x9e,0x9c,0x9d,0x9d,0x9c,0x9a,
0x9a,0x9d,0xa0,0x9d,0x9e,0x9b,0x9b,0x9f,0xa0,0x9f,0xa0,0xa0,0x9e,0x9d,0x9b,0x9a,
0x9c,0x9b,0x9c,0x9e,0x9d,0x9c,0x9b,0x9b,0x9b,0x9a,0x9b,0x9a,0x9c,0x9c,0x9c,0x9c,
0x9d,0x9d,0xa0,0xa1,0xa0,0x9d,0x9d,0x9d,0x9d,0x9b,0x9a,0x99,0x99,0x9b,0x9b,0x9a,
0x9b,0x9c,0x9f,0x9f,0x9d,0x9a,0x9b,0x9a,0x99,0x97,0x99,0x9c,0x9c,0x9d,0x9a,0x99,
0x9c,0x9c,0x9c,0x9e,0x9e,0x9c,0x9c,0x9b,0x9a,0x9a,0x9a,0x9b,0x9d,0x9f,0x9f,0x9f,
0x9e,0x9b,0x9a,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9b,0x99,0x98,0x9a,0x9c,0x9c,0x9c,
0x9b,0x9c,0x9d,0x9d,0x9c,0x9a,0x9c,0x9c,0x9d,0x9d,0x9d,0x9c,0x9c,0x9a,0x98,0x99,
0x9c,0x9d,0x9d,0x9c,0x9b,0x9c,0x9a,0x99,0x98,0x9a,0x9a,0x97,0x94,0x94,0x96,0x99,
0x99,0x9a,0x9c,0x9d,0x9d,0x9d,0x9f,0xa0,0xa1,0x9f,0x9c,0x9a,0x9b,0x9c,0x9c,0x9c,
0x9a,0x99,0x9a,0x99,0x98,0x98,0x99,0x9a,0x99,0x98,0x99,0x9c,0x9c,0x9a,0x99,0x9b,
0x9d,0x9c,0x9b,0x9b,0x9c,0x9e,0x9e,0x9c,0x9c,0x9d,0x9c,0x9c,0x9a,0x9b,0x9c,0x9c,
0x9a,0x97,0x97,0x98,0x99,0x99,0x99,0x99,0x9a,0x9a,0x9c,0x9d,0xa0,0xa0,0x9f,0x9c,
0x9a,0x9a,0x99,0x98,0x97,0x97,0x98,0x98,0x9a,0x9a,0x9c,0x9f,0xa0,0x9e,0x9c,0x9c,
0x9d,0x9e,0x9d,0x9d,0x9d,0x9f,0x9f,0x9e,0x9f,0x9e,0x9b,0x99,0x99,0x99,0x9c,0x9e,
0x9e,0x9c,0x9d,0x9c,0x9c,0x9d,0x9f,0xa0,0x9f,0x9d,0x9b,0x9c,0x9c,0x9d,0x9d,0x9b,
0x9a,0x9c,0x9c,0x9c,0x9c,0x9c,0x9b,0x9b,0x9c,0x9d,0xa0,0xa0,0x9e,0x9c,0x9c,0x9c,
0x9b,0x9c,0x9d,0x9e,0xa0,0x9e,0x9c,0x9c,0x9c,0x9c,0x9e,0x9f,0xa0,0x9f,0x9f,0x9e,
0x9c,0x9b,0x9c,0x9e,0x9f,0x9f,0x9f,0xa0,0xa0,0x9d,0x9c,0x9c,0x9e,0x9e,0x9c,0x9c,
0x9b,0x9a,0x99,0x9a,0x9d,0x9e,0xa0,0xa2,0xa0,0xa0,0xa1,0xa0,0x9e,0x9c,0x9c,0x9d,
0x9f,0x9e,0x9f,0xa0,0xa0,0x9d,0x9c,0x9d,0xa0,0x9f,0x9c,0x99,0x98,0x98,0x99,0x9a,
0x9c,0x9d,0x9d,0xa0,0x9f,0x9d,0x9c,0xa1,0xa2,0xa1,0xa1,0xa0,0x9f,0x9d,0x9c,0x9b,
0x9d,0x9d,0x9f,0x9d,0x9e,0x9c,0x9d,0x9d,0x9f,0x9f,0xa2,0xa0,0x9e,0x9d,0x9e,0x9e,
0xa0,0x9d,0x9a,0x9b,0x9b,0x9a,0x9d,0x9c,0x9c,0x9d,0x9d,0x9c,0x9c,0x9b,0x9c,0x9e,
0xa0,0xa0,0x9f,0x9e,0x9c,0x9c,0x9d,0x9f,0x9f,0x9f,0x9f,0x9d,0x9c,0x99,0x9a,0x9c,
0x9f,0x9f,0xa0,0xa0,0xa0,0x9f,0x9e,0x9d,0x9c,0x9f,0xa1,0xa0,0x9d,0x9b,0x9b,0x9c,
0x9c,0x9c,0x9c,0x9c,0x9b,0x9a,0x9a,0x9c,0x9c,0x9d,0x9b,0x98,0x99,0x9b,0x9d,0x9e,
0x9d,0x9c,0x9c,0x9c,0x9c,0x9d,0xa0,0x9f,0x9d,0x9b,0x9a,0x9a,0x9b,0x9c,0x9d,0xa0,
0xa0,0x9f,0x9f,0x9e,0x9d,0x9e,0x9e,0x9e,0x9d,0x9d,0x9c,0x9b,0x9b,0x9b,0x9d,0xa0,
0xa0,0x9e,0x9d,0x9d,0x9c,0x9b,0x9b,0x9d,0xa0,0x9e,0x9c,0x9c,0x9c,0x9d,0x9f,0xa0,
0xa0,0x9e,0x9d,0x9c,0x9b,0x9d,0x9d,0x9c,0x9b,0x9a,0x99,0x9a,0x9a,0x9b,0x9c,0x9d,
0x9d,0x9c,0x9d,0x9d,0x9e,0x9e,0x9c,0x9b,0x9c,0x9d,0x9d,0x9b,0x9b,0x99,0x9b,0x9d,
0x9d,0x9c,0x9d,0x9c,0x9b,0x9b,0x9c,0x9d,0xa2,0xa2,0x9f,0x9f,0x9c,0x9a,0x9a,0x98,
0x98,0x99,0x9a,0x9a,0x9a,0x99,0x98,0x99,0x9a,0x9c,0x9d,0x9f,0x9e,0x9c,0x9c,0x9d,
0x9d,0x9d,0x9d,0x9d,0x9f,0x9e,0x9c,0x99,0x99,0x9a,0x9c,0x9c,0x9c,0x9c,0x9e,0x9d,
0x9d,0x9d,0x9f,0xa0,0xa0,0x9e,0x9d,0x9e,0x9f,0x9e,0x9d,0x9d,0x9d,0x9b,0x9a,0x9b,
0x9d,0x9f,0xa0,0x9f,0xa1,0xa1,0xa0,0x9d,0x9b,0x9b,0x9c,0x9c,0x9c,0x9a,0x99,0x98,
0x9a,0x9c,0x9d,0x9f,0xa0,0x9c,0x9a,0x9a,0x9c,0x9d,0x9e,0x9f,0x9e,0xa0,0xa0,0xa1,
0xa0,0xa0,0x9f,0x9e,0x9d,0x9b,0x9b,0x9f,0x9f,0x9d,0x9c,0x9d,0x9d,0x9e,0x9d,0x9d,
0x9f,0x9e,0x9d,0x9c,0x9b,0x9c,0x9d,0x9f,0x9f,0x9e,0xa0,0x9f,0x9d,0x9e,0x9f,0xa0,
0xa0,0x9e,0x9e,0x9d,0x9e,0x9f,0x9f,0x9e,0x97,0x98,0x99,0x9d,0xa0,0xa0,0x9d,0x9b,
0x99,0x98,0x99,0x99,0x9c,0x9b,0x9e,0x9d,0x9c,0x9a,0x9b,0x9a,0x9a,0x9b,0x9b,0x9d,
0x9d,0x9d,0x9c,0x9e,0x9e,0x9d,0x9d,0x9d,0x9d,0x9d,0x9c,0x9d,0x9d,0x9c,0x9c,0x9c,
0x9d,0x9d,0x9c,0x9e,0xa0,0x9e,0x9d,0x9c,0x9d,0x9d,0x9c,0x99,0x9a,0x9a,0x9b,0x99,
0x99,0x99,0x9a,0x9b,0x9a,0x9a,0x9a,0x9a,0x99,0x9b,0x9d,0x9e,0xa0,0x9f,0xa0,0xa1,
0xa0,0x9e,0x9c,0x99,0x99,0x9a,0x9b,0x9b,0x9a,0x9b,0x9a,0x98,0x99,0x9a,0x9e,0xa1,
0xa2,0x9f,0x9e,0x9e,0x9e,0x9e,0xa0,0x9e,0x9e,0x9c,0x9b,0x99,0x9a,0x9a,0x9a,0x9c,
0x9c,0x9c,0x9f,0x9f,0xa0,0xa1,0xa2,0xa1,0x9e,0x9e,0x9f,0x9e,0x9e,0x9d,0x9c,0x9b,
0x99,0x97,0x98,0x9a,0x9b,0x9c,0x9b,0x9a,0x9b,0x9d,0x9f,0x9d,0x9b,0x9b,0x9c,0x9c,
0x9c,0x99,0x92,0x86,0x75,0x65,0x59,0x56,0x5b,0x64,0x6f,0x78,0x7b,0x76,0x6c,0x64,
0x5e,0x60,0x64,0x68,0x6c,0x71,0x78,0x7e,0x89,0x95,0x9e,0xa2,0x97,0x81,0x6c,0x58,
0x52,0x54,0x60,0x6e,0x7a,0x7d,0x78,0x6f,0x69,0x64,0x5f,0x57,0x4b,0x3d,0x32,0x2e,
0x38,0x4c,0x63,0x76,0x7f,0x7a,0x6e,0x61,0x58,0x52,0x4d,0x48,0x43,0x3d,0x38,0x33,
0x33,0x36,0x3b,0x41,0x4d,0x5a,0x69,0x75,0x79,0x75,0x6e,0x63,0x5a,0x58,0x60,0x6c,
0x75,0x78,0x73,0x6e,0x66,0x60,0x5d,0x5e,0x5d,0x56,0x4a,0x3d,0x32,0x2d,0x32,0x38,
0x3a,0x41,0x43,0x40,0x3a,0x34,0x30,0x32,0x32,0x32,0x35,0x38,0x3b,0x3b,0x3d,0x3b,
0x3a,0x37,0x38,0x38,0x3b,0x3b,0x3a,0x39,0x37,0x36,0x37,0x38,0x38,0x39,0x3b,0x3b,
// Line 13
0x38,0x35,0x35,0x34,0x34,0x35,0x35,0x36,0x35,0x34,0x35,0x38,0x38,0x36,0x37,0x37,
0x37,0x36,0x36,0x37,0x38,0x38,0x36,0x35,0x35,0x36,0x37,0x36,0x35,0x34,0x37,0x37,
0x37,0x37,0x37,0x36,0x37,0x39,0x39,0x39,0x38,0x38,0x38,0x36,0x34,0x33,0x36,0x37,
0x36,0x36,0x34,0x33,0x33,0x32,0x33,0x35,0x37,0x37,0x38,0x39,0x37,0x36,0x37,0x39,
0x3a,0x38,0x35,0x34,0x35,0x37,0x38,0x39,0x38,0x37,0x37,0x36,0x36,0x37,0x38,0x37,
0x36,0x35,0x34,0x33,0x33,0x34,0x35,0x37,0x37,0x36,0x36,0x36,0x37,0x38,0x3a,0x3b,
0x39,0x39,0x38,0x36,0x35,0x35,0x36,0x37,0x35,0x34,0x36,0x36,0x35,0x35,0x36,0x37,
0x38,0x38,0x39,0x39,0x3b,0x39,0x3a,0x3a,0x3a,0x39,0x38,0x37,0x36,0x38,0x38,0x38,
0x38,0x37,0x36,0x36,0x37,0x36,0x37,0x37,0x35,0x35,0x36,0x37,0x35,0x34,0x34,0x35,
0x36,0x34,0x32,0x31,0x31,0x31,0x34,0x34,0x34,0x33,0x33,0x32,0x34,0x35,0x39,0x3a,
0x3c,0x3b,0x3a,0x3a,0x3a,0x39,0x39,0x39,0x38,0x36,0x35,0x33,0x33,0x34,0x36,0x38,
0x39,0x38,0x38,0x37,0x36,0x34,0x36,0x37,0x37,0x37,0x35,0x34,0x36,0x36,0x37,0x38,
0x39,0x39,0x3a,0x39,0x39,0x39,0x39,0x37,0x35,0x36,0x36,0x36,0x36,0x37,0x38,0x38,
0x37,0x36,0x36,0x36,0x34,0x34,0x34,0x35,0x35,0x35,0x36,0x37,0x3a,0x3c,0x3b,0x3e,
0x38,0x37,0x38,0x38,0x38,0x36,0x35,0x34,0x35,0x35,0x35,0x34,0x38,0x35,0x34,0x35,
0x36,0x35,0x39,0x38,0x36,0x34,0x33,0x34,0x36,0x37,0x37,0x38,0x39,0x3a,0x37,0x38,
0x37,0x37,0x38,0x37,0x35,0x34,0x33,0x34,0x35,0x34,0x35,0x35,0x36,0x34,0x34,0x35,
0x38,0x3a,0x3a,0x38,0x36,0x36,0x35,0x34,0x35,0x35,0x37,0x39,0x39,0x37,0x34,0x37,
0x37,0x37,0x37,0x38,0x36,0x37,0x36,0x34,0x35,0x38,0x39,0x39,0x39,0x39,0x3b,0x3a,
0x39,0x38,0x36,0x36,0x37,0x39,0x3a,0x39,0x39,0x38,0x37,0x37,0x36,0x36,0x38,0x38,
0x39,0x3a,0x3b,0x3c,0x3c,0x3b,0x3a,0x38,0x38,0x38,0x38,0x3a,0x39,0x37,0x38,0x38,
0x38,0x39,0x39,0x38,0x39,0x39,0x3a,0x39,0x37,0x35,0x35,0x36,0x38,0x39,0x39,0x38,
0x36,0x36,0x37,0x36,0x37,0x37,0x38,0x38,0x37,0x34,0x34,0x35,0x38,0x3a,0x3b,0x3c,
0x3b,0x3c,0x3c,0x39,0x3a,0x3a,0x3a,0x3b,0x37,0x34,0x35,0x36,0x37,0x37,0x39,0x39,
0x3a,0x3b,0x3a,0x38,0x3a,0x39,0x38,0x39,0x39,0x38,0x38,0x37,0x35,0x35,0x35,0x34,
0x34,0x35,0x37,0x37,0x37,0x37,0x39,0x3a,0x3a,0x39,0x3b,0x3c,0x3d,0x3b,0x38,0x36,
0x36,0x38,0x3a,0x39,0x3a,0x38,0x37,0x34,0x32,0x31,0x35,0x36,0x37,0x3a,0x3b,0x3a,
0x39,0x38,0x39,0x3c,0x3d,0x3b,0x37,0x35,0x35,0x35,0x35,0x36,0x37,0x39,0x3a,0x39,
0x39,0x3a,0x3a,0x39,0x36,0x34,0x36,0x39,0x3a,0x39,0x38,0x37,0x37,0x36,0x36,0x37,
0x38,0x37,0x36,0x36,0x36,0x37,0x39,0x39,0x37,0x37,0x37,0x36,0x33,0x35,0x36,0x37,
0x38,0x38,0x38,0x38,0x37,0x35,0x36,0x36,0x37,0x38,0x37,0x35,0x36,0x36,0x38,0x39,
0x39,0x39,0x3a,0x39,0x38,0x36,0x38,0x38,0x38,0x38,0x39,0x39,0x39,0x38,0x37,0x38,
0x39,0x37,0x33,0x34,0x33,0x33,0x34,0x36,0x37,0x37,0x37,0x37,0x39,0x3a,0x3c,0x3d,
0x3c,0x3a,0x39,0x38,0x37,0x36,0x37,0x37,0x39,0x39,0x39,0x39,0x39,0x39,0x37,0x37,
0x38,0x39,0x39,0x38,0x35,0x35,0x37,0x37,0x35,0x34,0x33,0x34,0x35,0x34,0x31,0x34,
0x35,0x35,0x37,0x38,0x39,0x3a,0x39,0x38,0x38,0x39,0x39,0x3a,0x39,0x37,0x36,0x37,
0x39,0x39,0x3a,0x3a,0x39,0x37,0x36,0x38,0x38,0x37,0x36,0x38,0x39,0x37,0x36,0x36,
0x37,0x38,0x38,0x38,0x36,0x36,0x36,0x35,0x36,0x36,0x37,0x39,0x3a,0x39,0x38,0x38,
0x39,0x38,0x3b,0x39,0x39,0x38,0x38,0x34,0x34,0x33,0x35,0x37,0x38,0x36,0x36,0x35,
0x35,0x37,0x37,0x37,0x37,0x36,0x36,0x36,0x35,0x34,0x36,0x38,0x39,0x35,0x35,0x35,
0x37,0x38,0x35,0x32,0x34,0x36,0x38,0x37,0x35,0x36,0x38,0x39,0x3a,0x39,0x3a,0x3a,
0x3a,0x39,0x39,0x38,0x39,0x39,0x37,0x35,0x34,0x34,0x36,0x37,0x37,0x35,0x36,0x37,
0x37,0x37,0x37,0x37,0x38,0x37,0x37,0x38,0x36,0x34,0x34,0x35,0x37,0x36,0x36,0x38,
0x3a,0x39,0x39,0x38,0x38,0x38,0x37,0x37,0x36,0x35,0x37,0x37,0x36,0x37,0x37,0x37,
0x37,0x35,0x36,0x37,0x38,0x37,0x36,0x34,0x34,0x35,0x36,0x36,0x37,0x38,0x38,0x35,
0x36,0x37,0x39,0x38,0x35,0x33,0x35,0x38,0x39,0x38,0x39,0x39,0x39,0x38,0x37,0x37,
0x38,0x37,0x35,0x35,0x36,0x35,0x37,0x38,0x39,0x39,0x38,0x38,0x36,0x36,0x36,0x37,
0x38,0x37,0x37,0x39,0x39,0x37,0x38,0x38,0x39,0x37,0x35,0x32,0x32,0x33,0x34,0x34,
0x35,0x36,0x39,0x39,0x38,0x37,0x39,0x38,0x35,0x34,0x33,0x34,0x35,0x34,0x33,0x33,
0x35,0x35,0x34,0x36,0x38,0x39,0x38,0x35,0x34,0x36,0x36,0x37,0x38,0x39,0x3a,0x39,
0x37,0x34,0x36,0x39,0x3a,0x36,0x34,0x33,0x32,0x31,0x31,0x31,0x33,0x33,0x31,0x31,
0x32,0x34,0x38,0x39,0x39,0x39,0x39,0x39,0x38,0x36,0x36,0x36,0x39,0x37,0x35,0x34,
0x34,0x34,0x35,0x35,0x35,0x33,0x31,0x2f,0x30,0x32,0x33,0x32,0x35,0x34,0x34,0x34,
0x34,0x35,0x39,0x3b,0x39,0x38,0x38,0x39,0x39,0x37,0x34,0x34,0x35,0x34,0x31,0x31,
0x31,0x31,0x34,0x35,0x35,0x35,0x36,0x37,0x37,0x36,0x37,0x37,0x36,0x34,0x34,0x35,
0x36,0x33,0x36,0x35,0x35,0x34,0x32,0x32,0x34,0x35,0x34,0x34,0x35,0x35,0x35,0x34,
0x32,0x32,0x35,0x37,0x35,0x35,0x34,0x35,0x37,0x37,0x37,0x37,0x37,0x36,0x36,0x37,
0x38,0x39,0x39,0x39,0x39,0x38,0x39,0x38,0x36,0x35,0x34,0x35,0x34,0x33,0x35,0x36,
0x35,0x34,0x36,0x38,0x39,0x39,0x38,0x38,0x39,0x37,0x35,0x36,0x38,0x38,0x3a,0x37,
0x34,0x34,0x35,0x34,0x34,0x34,0x34,0x36,0x36,0x34,0x34,0x36,0x38,0x36,0x36,0x36,
0x36,0x36,0x36,0x34,0x34,0x34,0x36,0x36,0x36,0x38,0x38,0x38,0x36,0x34,0x36,0x37,
0x36,0x33,0x32,0x31,0x34,0x34,0x33,0x33,0x34,0x33,0x34,0x35,0x38,0x39,0x3b,0x39,
0x37,0x35,0x34,0x33,0x33,0x32,0x32,0x32,0x30,0x2f,0x31,0x33,0x35,0x35,0x34,0x35,
0x36,0x35,0x35,0x35,0x37,0x37,0x36,0x37,0x36,0x36,0x39,0x39,0x38,0x36,0x36,0x35,
0x36,0x36,0x39,0x39,0x38,0x34,0x34,0x34,0x34,0x33,0x33,0x35,0x34,0x33,0x32,0x32,
0x34,0x36,0x35,0x36,0x35,0x34,0x33,0x34,0x34,0x35,0x37,0x38,0x36,0x37,0x35,0x35,
0x37,0x37,0x36,0x35,0x34,0x32,0x33,0x33,0x34,0x35,0x35,0x34,0x35,0x37,0x39,0x38,
0x39,0x39,0x38,0x37,0x35,0x33,0x33,0x33,0x33,0x34,0x34,0x34,0x34,0x35,0x35,0x34,
0x36,0x37,0x38,0x37,0x35,0x33,0x33,0x32,0x32,0x34,0x35,0x35,0x36,0x34,0x34,0x34,
0x35,0x34,0x34,0x34,0x36,0x36,0x34,0x34,0x34,0x36,0x36,0x36,0x36,0x35,0x35,0x37,
0x37,0x35,0x34,0x34,0x32,0x31,0x34,0x36,0x38,0x38,0x36,0x34,0x34,0x34,0x34,0x36,
0x35,0x34,0x34,0x32,0x32,0x32,0x36,0x36,0x36,0x34,0x34,0x33,0x33,0x33,0x34,0x35,
0x35,0x34,0x34,0x33,0x32,0x34,0x35,0x35,0x35,0x34,0x34,0x35,0x36,0x38,0x39,0x38,
0x35,0x34,0x37,0x37,0x37,0x35,0x34,0x33,0x33,0x31,0x31,0x32,0x35,0x34,0x34,0x33,
0x35,0x37,0x39,0x37,0x34,0x35,0x36,0x35,0x35,0x34,0x34,0x35,0x35,0x35,0x37,0x38,
0x38,0x38,0x37,0x37,0x37,0x38,0x38,0x38,0x38,0x36,0x35,0x37,0x36,0x34,0x35,0x33,
0x32,0x32,0x33,0x32,0x31,0x30,0x32,0x33,0x34,0x32,0x32,0x36,0x39,0x37,0x38,0x37,
0x36,0x38,0x37,0x34,0x34,0x36,0x35,0x34,0x34,0x34,0x34,0x33,0x34,0x34,0x36,0x36,
0x35,0x35,0x34,0x33,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x36,0x37,0x35,0x33,
0x33,0x34,0x34,0x35,0x35,0x35,0x36,0x37,0x38,0x38,0x37,0x38,0x38,0x38,0x37,0x37,
0x35,0x35,0x33,0x32,0x34,0x34,0x35,0x36,0x33,0x33,0x34,0x33,0x31,0x31,0x32,0x33,
0x34,0x34,0x34,0x32,0x34,0x35,0x36,0x39,0x39,0x38,0x36,0x34,0x33,0x34,0x33,0x33,
0x34,0x33,0x33,0x33,0x33,0x33,0x34,0x37,0x36,0x36,0x37,0x37,0x38,0x38,0x36,0x33,
0x35,0x36,0x37,0x36,0x35,0x33,0x34,0x33,0x35,0x34,0x34,0x34,0x33,0x33,0x34,0x33,
0x34,0x35,0x35,0x37,0x36,0x33,0x32,0x33,0x34,0x33,0x33,0x34,0x34,0x34,0x31,0x31,
0x32,0x34,0x34,0x36,0x34,0x33,0x33,0x33,0x35,0x36,0x35,0x35,0x35,0x34,0x34,0x35,
0x36,0x34,0x33,0x34,0x33,0x32,0x33,0x34,0x35,0x36,0x36,0x35,0x34,0x34,0x34,0x35,
0x37,0x37,0x37,0x35,0x33,0x31,0x32,0x34,0x35,0x34,0x33,0x33,0x35,0x35,0x35,0x34,
0x35,0x35,0x35,0x34,0x34,0x32,0x34,0x33,0x31,0x32,0x34,0x36,0x37,0x34,0x34,0x35,
0x36,0x35,0x36,0x35,0x35,0x35,0x34,0x35,0x35,0x35,0x36,0x35,0x34,0x33,0x33,0x34,
0x33,0x32,0x34,0x36,0x35,0x35,0x37,0x38,0x38,0x37,0x37,0x34,0x39,0x38,0x37,0x38,
0x37,0x35,0x34,0x33,0x32,0x34,0x35,0x35,0x34,0x32,0x31,0x32,0x32,0x34,0x35,0x36,
0x35,0x34,0x33,0x33,0x33,0x34,0x35,0x35,0x37,0x38,0x37,0x36,0x35,0x35,0x38,0x37,
0x36,0x35,0x34,0x33,0x31,0x31,0x35,0x37,0x37,0x34,0x32,0x34,0x35,0x37,0x37,0x37,
0x36,0x35,0x34,0x32,0x31,0x32,0x32,0x32,0x31,0x30,0x30,0x32,0x33,0x34,0x35,0x35,
0x35,0x36,0x35,0x35,0x37,0x35,0x35,0x34,0x35,0x34,0x33,0x34,0x33,0x31,0x33,0x31,
// Line 14
0x3a,0x38,0x38,0x39,0x3b,0x3c,0x3b,0x3a,0x3a,0x3a,0x38,0x35,0x35,0x36,0x38,0x38,
0x36,0x36,0x38,0x39,0x39,0x3a,0x39,0x38,0x38,0x36,0x35,0x36,0x38,0x39,0x38,0x35,
0x33,0x36,0x39,0x39,0x38,0x35,0x34,0x32,0x32,0x32,0x33,0x37,0x36,0x36,0x38,0x3a,
0x3d,0x40,0x48,0x4f,0x57,0x60,0x68,0x70,0x7b,0x81,0x87,0x8b,0x8f,0x93,0x95,0x94,
0x93,0x94,0x96,0x98,0x98,0x97,0x97,0x98,0x98,0x98,0x95,0x93,0x8f,0x88,0x81,0x77,
0x6f,0x68,0x60,0x56,0x4d,0x45,0x40,0x3c,0x3a,0x39,0x3a,0x39,0x39,0x36,0x39,0x3a,
0x39,0x3a,0x39,0x39,0x3a,0x38,0x35,0x36,0x3a,0x3f,0x45,0x49,0x50,0x58,0x63,0x6b,
0x74,0x7c,0x84,0x8a,0x90,0x93,0x95,0x97,0x96,0x94,0x96,0x97,0x97,0x96,0x96,0x96,
0x96,0x95,0x95,0x94,0x93,0x8e,0x86,0x7f,0x76,0x6d,0x65,0x5d,0x54,0x4b,0x46,0x42,
0x3e,0x3b,0x3a,0x38,0x39,0x38,0x38,0x3c,0x3b,0x3b,0x3c,0x3b,0x39,0x38,0x37,0x37,
0x38,0x3b,0x3f,0x41,0x48,0x4e,0x57,0x65,0x70,0x79,0x85,0x8b,0x8e,0x91,0x93,0x96,
0x98,0x97,0x96,0x97,0x97,0x97,0x96,0x93,0x92,0x95,0x97,0x97,0x95,0x92,0x8e,0x85,
0x7d,0x73,0x6b,0x65,0x5d,0x54,0x4b,0x45,0x41,0x3e,0x3c,0x3c,0x3d,0x3d,0x3a,0x38,
0x3a,0x3b,0x3a,0x3b,0x3a,0x3a,0x3a,0x3a,0x3a,0x3c,0x3f,0x44,0x48,0x4b,0x52,0x5d,
0x68,0x70,0x78,0x81,0x8a,0x8f,0x94,0x96,0x98,0x99,0x97,0x95,0x95,0x95,0x95,0x95,
0x94,0x92,0x93,0x95,0x97,0x97,0x95,0x8f,0x86,0x7d,0x74,0x6b,0x65,0x5d,0x54,0x4d,
0x44,0x3c,0x36,0x36,0x38,0x39,0x39,0x36,0x34,0x34,0x35,0x37,0x3b,0x3c,0x3d,0x3c,
0x3a,0x38,0x39,0x3e,0x43,0x49,0x4f,0x55,0x5e,0x68,0x72,0x7b,0x83,0x8a,0x90,0x95,
0x97,0x97,0x98,0x98,0x96,0x94,0x93,0x94,0x96,0x96,0x96,0x96,0x97,0x96,0x93,0x93,
0x8f,0x8a,0x82,0x78,0x6b,0x62,0x57,0x4f,0x4a,0x46,0x44,0x41,0x3e,0x3a,0x3a,0x3b,
0x3c,0x3c,0x3c,0x3c,0x3c,0x3b,0x3a,0x39,0x3a,0x3c,0x3c,0x3f,0x41,0x44,0x4a,0x51,
0x59,0x61,0x6b,0x76,0x7f,0x86,0x8b,0x90,0x96,0x97,0x97,0x97,0x98,0x97,0x98,0x98,
0x98,0x97,0x95,0x94,0x96,0x99,0x9a,0x95,0x92,0x8b,0x84,0x7d,0x76,0x6c,0x66,0x5d,
0x52,0x4a,0x44,0x40,0x3e,0x3d,0x3c,0x3a,0x39,0x37,0x36,0x37,0x39,0x38,0x39,0x38,
0x3a,0x3a,0x3b,0x3a,0x3d,0x40,0x45,0x4b,0x50,0x57,0x61,0x6b,0x76,0x7f,0x85,0x8a,
0x8e,0x92,0x95,0x95,0x95,0x96,0x98,0x98,0x97,0x98,0x99,0x9b,0x9a,0x99,0x9a,0x99,
0x96,0x90,0x8b,0x86,0x80,0x76,0x6d,0x65,0x5c,0x53,0x4e,0x48,0x44,0x40,0x3e,0x3b,
0x3a,0x3c,0x3d,0x3e,0x3c,0x3b,0x39,0x3a,0x3a,0x39,0x3a,0x3d,0x3d,0x3d,0x3c,0x3c,
0x3c,0x3d,0x3d,0x3b,0x3b,0x3c,0x3d,0x40,0x3e,0x3b,0x3c,0x3d,0x3e,0x3e,0x3e,0x3d,
0x3c,0x39,0x39,0x39,0x39,0x39,0x3b,0x3c,0x3d,0x3c,0x3a,0x39,0x3a,0x3c,0x3b,0x3a,
0x3a,0x3a,0x39,0x38,0x36,0x36,0x3a,0x3c,0x3c,0x3a,0x3b,0x3b,0x39,0x38,0x3a,0x3c,
0x3f,0x3e,0x3c,0x3b,0x39,0x39,0x3a,0x3b,0x3a,0x39,0x38,0x36,0x34,0x36,0x3a,0x3a,
0x3d,0x3a,0x39,0x3a,0x38,0x36,0x37,0x38,0x38,0x39,0x3a,0x3b,0x3c,0x3b,0x3b,0x3c,
0x3e,0x3e,0x3c,0x3d,0x3e,0x40,0x46,0x4e,0x59,0x66,0x6f,0x76,0x7f,0x85,0x8c,0x93,
0x98,0x99,0x9a,0x9a,0x9a,0x97,0x97,0x99,0x9b,0x9d,0x9c,0x99,0x97,0x96,0x97,0x98,
0x97,0x96,0x97,0x97,0x96,0x95,0x95,0x96,0x96,0x96,0x95,0x95,0x96,0x95,0x94,0x95,
0x94,0x94,0x96,0x97,0x97,0x97,0x96,0x95,0x96,0x97,0x99,0x99,0x98,0x97,0x98,0x9a,
0x9a,0x97,0x95,0x95,0x96,0x97,0x98,0x99,0x9b,0x9b,0x99,0x98,0x97,0x97,0x98,0x99,
0x97,0x96,0x96,0x98,0x9a,0x9b,0x9b,0x9a,0x9b,0x9a,0x99,0x98,0x96,0x96,0x98,0x99,
0x99,0x99,0x98,0x97,0x97,0x98,0x9a,0x99,0x99,0x9a,0x9a,0x99,0x96,0x95,0x97,0x99,
0x98,0x97,0x96,0x95,0x92,0x8c,0x86,0x80,0x7b,0x73,0x67,0x5c,0x52,0x4a,0x46,0x42,
0x3e,0x3d,0x3c,0x3a,0x39,0x38,0x38,0x36,0x37,0x39,0x3a,0x3a,0x3a,0x39,0x39,0x39,
0x3b,0x3c,0x3e,0x3d,0x3e,0x3a,0x39,0x39,0x3a,0x3e,0x40,0x42,0x3f,0x3d,0x3d,0x3c,
0x39,0x38,0x38,0x38,0x39,0x38,0x36,0x38,0x39,0x38,0x39,0x39,0x3a,0x3b,0x3b,0x39,
0x38,0x39,0x3c,0x3c,0x3d,0x3c,0x3b,0x3a,0x3a,0x38,0x39,0x3a,0x39,0x37,0x36,0x36,
0x37,0x38,0x38,0x3a,0x3c,0x3a,0x38,0x38,0x37,0x36,0x39,0x39,0x38,0x38,0x38,0x36,
0x36,0x35,0x36,0x36,0x38,0x38,0x38,0x38,0x38,0x36,0x36,0x36,0x38,0x39,0x39,0x39,
0x3a,0x3b,0x3c,0x3c,0x3e,0x3e,0x3e,0x3a,0x36,0x32,0x34,0x35,0x35,0x34,0x35,0x36,
0x3a,0x39,0x3a,0x3a,0x3a,0x39,0x38,0x38,0x38,0x36,0x3a,0x39,0x37,0x38,0x39,0x3c,
0x3d,0x3d,0x3c,0x3a,0x39,0x35,0x36,0x37,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
0x3a,0x3c,0x3c,0x3c,0x3a,0x39,0x3a,0x39,0x39,0x36,0x37,0x39,0x3a,0x3a,0x3a,0x3a,
0x3d,0x3c,0x3b,0x3c,0x3d,0x3c,0x3b,0x39,0x38,0x37,0x36,0x36,0x38,0x39,0x38,0x39,
0x39,0x39,0x3a,0x3c,0x3c,0x3a,0x3b,0x3a,0x39,0x37,0x35,0x35,0x36,0x37,0x37,0x36,
0x35,0x33,0x34,0x36,0x37,0x38,0x3b,0x3a,0x38,0x39,0x3a,0x39,0x38,0x38,0x39,0x3a,
0x3b,0x39,0x39,0x3a,0x3a,0x39,0x3a,0x3a,0x3a,0x3b,0x3a,0x39,0x3a,0x3a,0x3b,0x3b,
0x3a,0x38,0x38,0x39,0x39,0x38,0x37,0x37,0x38,0x36,0x36,0x37,0x3a,0x3b,0x3a,0x3a,
0x3a,0x3a,0x39,0x38,0x36,0x38,0x39,0x39,0x39,0x3b,0x3b,0x3a,0x3a,0x3a,0x3b,0x3c,
0x3a,0x39,0x3b,0x3b,0x3a,0x38,0x36,0x38,0x3b,0x3b,0x3a,0x39,0x38,0x37,0x38,0x37,
0x38,0x39,0x3a,0x3b,0x3a,0x39,0x39,0x39,0x39,0x36,0x34,0x36,0x38,0x37,0x37,0x36,
0x36,0x34,0x34,0x35,0x37,0x38,0x38,0x35,0x35,0x35,0x36,0x38,0x36,0x36,0x38,0x3a,
0x3a,0x37,0x36,0x35,0x36,0x37,0x38,0x38,0x3a,0x39,0x39,0x38,0x36,0x36,0x39,0x3a,
0x3a,0x3b,0x39,0x37,0x36,0x36,0x36,0x38,0x39,0x38,0x39,0x38,0x38,0x36,0x36,0x38,
0x39,0x3b,0x38,0x35,0x35,0x36,0x38,0x39,0x39,0x38,0x3a,0x3b,0x3a,0x3a,0x3b,0x3b,
0x3a,0x3a,0x3a,0x39,0x3a,0x39,0x39,0x3a,0x3a,0x39,0x38,0x37,0x36,0x36,0x36,0x38,
0x37,0x36,0x35,0x36,0x37,0x39,0x3a,0x3c,0x3a,0x38,0x39,0x38,0x38,0x38,0x38,0x36,
0x36,0x36,0x39,0x3d,0x42,0x46,0x4b,0x51,0x58,0x61,0x6b,0x73,0x7c,0x85,0x8c,0x8f,
0x92,0x94,0x95,0x97,0x97,0x95,0x95,0x96,0x97,0x97,0x98,0x98,0x99,0x99,0x98,0x98,
0x99,0x98,0x97,0x96,0x95,0x93,0x94,0x94,0x95,0x94,0x96,0x96,0x95,0x94,0x96,0x98,
0x99,0x98,0x98,0x99,0x99,0x99,0x97,0x95,0x94,0x95,0x97,0x98,0x97,0x96,0x96,0x96,
0x97,0x98,0x9a,0x9b,0x9a,0x99,0x99,0x97,0x96,0x96,0x96,0x97,0x97,0x97,0x96,0x93,
0x95,0x94,0x95,0x98,0x98,0x98,0x9a,0x98,0x95,0x93,0x95,0x98,0x9a,0x98,0x96,0x97,
0x97,0x97,0x97,0x98,0x9b,0x9b,0x99,0x96,0x97,0x97,0x97,0x97,0x98,0x98,0x97,0x96,
0x94,0x93,0x96,0x97,0x97,0x95,0x94,0x94,0x94,0x95,0x94,0x95,0x95,0x94,0x93,0x95,
0x96,0x95,0x94,0x94,0x94,0x96,0x99,0x9b,0x9a,0x9c,0x9c,0x9b,0x9b,0x9b,0x9b,0x99,
0x97,0x96,0x97,0x98,0x99,0x99,0x97,0x96,0x97,0x97,0x97,0x97,0x99,0x98,0x97,0x97,
0x96,0x97,0x9a,0x9a,0x98,0x96,0x97,0x97,0x97,0x96,0x97,0x9a,0x9c,0x9d,0x9b,0x9b,
0x9b,0x99,0x9a,0x99,0x98,0x98,0x97,0x97,0x96,0x95,0x96,0x96,0x97,0x96,0x96,0x96,
0x96,0x93,0x96,0x97,0x98,0x99,0x99,0x98,0x99,0x97,0x97,0x97,0x98,0x98,0x97,0x95,
0x93,0x94,0x97,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x98,0x95,0x95,0x95,
0x97,0x99,0x99,0x99,0x99,0x98,0x9a,0x9b,0x9c,0x9b,0x9b,0x9c,0x9a,0x99,0x9b,0x9a,
0x96,0x94,0x94,0x94,0x94,0x92,0x91,0x92,0x94,0x96,0x97,0x98,0x9a,0x9b,0x9c,0x9b,
0x98,0x98,0x97,0x96,0x97,0x98,0x9a,0x9a,0x98,0x97,0x97,0x98,0x99,0x98,0x9a,0x9a,
0x99,0x96,0x95,0x97,0x98,0x99,0x9b,0x9b,0x9b,0x9b,0x9c,0x9b,0x98,0x95,0x94,0x92,
0x8a,0x81,0x7a,0x71,0x6a,0x60,0x57,0x51,0x4e,0x47,0x44,0x3f,0x3c,0x39,0x3a,0x3a,
0x3c,0x3e,0x3f,0x3d,0x3c,0x3b,0x3b,0x3d,0x3d,0x3c,0x3e,0x3c,0x3a,0x39,0x3a,0x3d,
0x3e,0x3c,0x3a,0x39,0x39,0x39,0x3a,0x3a,0x3c,0x3d,0x40,0x41,0x40,0x40,0x40,0x3d,
0x3b,0x39,0x3a,0x39,0x3a,0x38,0x38,0x39,0x3a,0x39,0x3c,0x3b,0x3c,0x3c,0x3c,0x3a,
0x3a,0x39,0x3a,0x3b,0x3a,0x3b,0x3d,0x3d,0x3c,0x3a,0x3b,0x3c,0x3c,0x3b,0x3b,0x3c,
0x3e,0x3c,0x38,0x36,0x36,0x36,0x37,0x38,0x39,0x3c,0x3a,0x39,0x38,0x38,0x3a,0x39,
0x39,0x38,0x38,0x39,0x38,0x38,0x3b,0x3d,0x3b,0x3b,0x3a,0x3c,0x3c,0x3a,0x39,0x39,
0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3c,0x3b,0x39,0x38,0x39,0x38,0x39,0x36,0x36,0x38,
0x38,0x37,0x39,0x3b,0x3d,0x3e,0x3d,0x3c,0x3c,0x3c,0x3c,0x39,0x39,0x38,0x38,0x38,
0x38,0x36,0x36,0x35,0x33,0x34,0x36,0x38,0x39,0x36,0x35,0x35,0x36,0x38,0x38,0x39,
0x3a,0x38,0x36,0x34,0x33,0x36,0x38,0x36,0x36,0x36,0x38,0x38,0x36,0x34,0x36,0x39,
0x3a,0x3a,0x3c,0x3d,0x3d,0x3c,0x3b,0x3a,0x3b,0x3a,0x3a,0x39,0x38,0x38,0x37,0x39,
0x39,0x38,0x3c,0x3e,0x3d,0x3c,0x3b,0x39,0x3a,0x36,0x36,0x37,0x37,0x36,0x36,0x36,
// Line 15
0x35,0x34,0x35,0x37,0x39,0x39,0x3a,0x39,0x35,0x33,0x32,0x35,0x38,0x3a,0x3a,0x39,
0x37,0x36,0x36,0x37,0x36,0x35,0x35,0x34,0x33,0x33,0x34,0x36,0x37,0x36,0x36,0x38,
0x3a,0x39,0x37,0x35,0x35,0x37,0x3c,0x3c,0x3a,0x37,0x35,0x34,0x34,0x32,0x34,0x39,
0x35,0x31,0x30,0x31,0x37,0x44,0x58,0x6b,0x79,0x7e,0x7a,0x70,0x68,0x60,0x5f,0x65,
0x6f,0x79,0x7e,0x7a,0x70,0x67,0x61,0x62,0x66,0x6d,0x74,0x7b,0x7c,0x77,0x6c,0x63,
0x5e,0x5d,0x62,0x6b,0x72,0x75,0x73,0x6e,0x69,0x63,0x60,0x62,0x69,0x70,0x77,0x7a,
0x79,0x72,0x6e,0x66,0x62,0x62,0x64,0x6b,0x72,0x75,0x73,0x6f,0x67,0x5f,0x5e,0x60,
0x67,0x70,0x78,0x7b,0x7a,0x74,0x6a,0x60,0x5d,0x5e,0x65,0x6d,0x73,0x76,0x77,0x73,
0x6b,0x64,0x62,0x66,0x6b,0x6f,0x72,0x70,0x74,0x76,0x7c,0x87,0x95,0xa1,0xac,0xad,
0xa8,0x9f,0x91,0x82,0x73,0x67,0x5d,0x56,0x51,0x4c,0x45,0x3e,0x39,0x37,0x40,0x4f,
0x63,0x77,0x86,0x8f,0x95,0x97,0x96,0x98,0x9c,0x9f,0xa0,0x98,0x8d,0x7f,0x70,0x63,
0x5c,0x5c,0x62,0x6a,0x74,0x7b,0x81,0x88,0x90,0x96,0x9c,0xa2,0xa4,0xa3,0x9e,0x9a,
0x95,0x95,0x98,0x9b,0x9c,0x96,0x88,0x76,0x64,0x56,0x55,0x5d,0x6a,0x76,0x7e,0x7e,
0x79,0x6f,0x66,0x62,0x64,0x6b,0x72,0x78,0x78,0x74,0x6e,0x66,0x60,0x60,0x65,0x6d,
0x73,0x75,0x75,0x72,0x6b,0x64,0x60,0x64,0x6a,0x6f,0x77,0x79,0x77,0x74,0x6c,0x64,
0x60,0x5f,0x5e,0x59,0x4d,0x3f,0x34,0x2d,0x2c,0x2b,0x32,0x3b,0x48,0x55,0x62,0x6e,
0x78,0x79,0x75,0x6d,0x65,0x61,0x63,0x6d,0x79,0x81,0x81,0x79,0x6e,0x64,0x62,0x64,
0x6c,0x74,0x79,0x7c,0x76,0x6e,0x68,0x64,0x63,0x61,0x5c,0x54,0x4a,0x3f,0x33,0x2b,
0x29,0x2c,0x33,0x3a,0x3e,0x3f,0x3d,0x37,0x32,0x32,0x34,0x39,0x3d,0x3d,0x3d,0x3d,
0x3d,0x3b,0x3a,0x3e,0x46,0x51,0x62,0x72,0x7f,0x89,0x8f,0x94,0x98,0x9d,0xa3,0xa5,
0xa3,0x9a,0x8d,0x7d,0x6e,0x62,0x5a,0x55,0x4d,0x44,0x3c,0x37,0x3c,0x45,0x57,0x6c,
0x7d,0x85,0x7f,0x72,0x63,0x58,0x58,0x60,0x6b,0x76,0x7c,0x78,0x6f,0x64,0x5e,0x60,
0x68,0x71,0x7b,0x7f,0x7c,0x73,0x69,0x63,0x62,0x62,0x63,0x5d,0x51,0x41,0x33,0x2c,
0x2b,0x31,0x3d,0x43,0x43,0x3e,0x37,0x34,0x32,0x33,0x35,0x34,0x32,0x33,0x3a,0x49,
0x5c,0x6d,0x7b,0x7f,0x77,0x6c,0x62,0x5f,0x62,0x69,0x70,0x74,0x7a,0x7d,0x85,0x90,
0x9a,0x9d,0x98,0x8b,0x79,0x67,0x56,0x4b,0x42,0x3a,0x35,0x35,0x3c,0x4c,0x60,0x74,
0x7f,0x7f,0x77,0x6a,0x5c,0x57,0x55,0x50,0x4a,0x3e,0x35,0x37,0x42,0x55,0x6d,0x81,
0x87,0x7f,0x70,0x62,0x57,0x53,0x51,0x4b,0x43,0x3b,0x3a,0x44,0x54,0x69,0x7d,0x8b,
0x91,0x93,0x93,0x97,0x9e,0xa2,0xa3,0xa3,0xa0,0x9f,0xa1,0xa3,0xa3,0x9f,0x96,0x86,
0x75,0x66,0x5f,0x5d,0x62,0x6a,0x71,0x78,0x82,0x8b,0x96,0x9f,0xa1,0x9a,0x8d,0x7c,
0x6b,0x5e,0x58,0x5c,0x68,0x73,0x7c,0x86,0x8d,0x94,0x97,0x9b,0x9f,0xa2,0xa4,0xa0,
0x95,0x86,0x77,0x6a,0x62,0x5a,0x54,0x4e,0x45,0x3b,0x36,0x3a,0x49,0x5c,0x71,0x80,
0x84,0x7e,0x72,0x65,0x5e,0x60,0x69,0x73,0x79,0x7a,0x7d,0x82,0x8b,0x97,0x9f,0x9f,
0x93,0x7f,0x67,0x58,0x55,0x5e,0x6a,0x7a,0x81,0x7f,0x79,0x70,0x68,0x65,0x66,0x69,
0x6b,0x6d,0x71,0x77,0x7e,0x86,0x90,0x9c,0xa3,0xa4,0x9f,0x98,0x8e,0x83,0x75,0x6a,
0x64,0x5e,0x54,0x4b,0x40,0x39,0x38,0x3c,0x45,0x53,0x66,0x79,0x86,0x8f,0x95,0x94,
0x94,0x8d,0x83,0x75,0x64,0x53,0x47,0x3d,0x3a,0x37,0x3c,0x3c,0x3b,0x3b,0x3b,0x3c,
0x44,0x51,0x62,0x71,0x78,0x77,0x73,0x6b,0x63,0x5f,0x60,0x66,0x6f,0x74,0x75,0x78,
0x7e,0x88,0x96,0xa2,0xaa,0xab,0xaa,0xa5,0x9f,0x9a,0x98,0x98,0x9c,0x9f,0xa1,0xa1,
0xa0,0x9e,0x9d,0x9c,0x9b,0x99,0x9d,0x9c,0x94,0x86,0x73,0x61,0x5a,0x5a,0x62,0x6d,
0x79,0x7f,0x7c,0x72,0x66,0x5d,0x5a,0x59,0x51,0x45,0x36,0x2c,0x30,0x40,0x57,0x70,
0x81,0x85,0x7f,0x6c,0x5b,0x51,0x4c,0x49,0x47,0x40,0x37,0x2c,0x2c,0x32,0x3a,0x42,
0x42,0x3e,0x3a,0x33,0x30,0x38,0x48,0x5c,0x70,0x79,0x7a,0x76,0x6f,0x69,0x62,0x59,
0x51,0x47,0x40,0x39,0x37,0x3f,0x50,0x65,0x79,0x87,0x90,0x95,0x98,0x97,0x93,0x8a,
0x7a,0x68,0x5a,0x56,0x5d,0x6b,0x79,0x7d,0x7c,0x73,0x65,0x5d,0x5a,0x5a,0x57,0x4c,
0x3a,0x2d,0x2e,0x3e,0x56,0x70,0x82,0x87,0x82,0x74,0x65,0x5d,0x5e,0x64,0x6c,0x71,
0x74,0x77,0x7e,0x88,0x95,0x9f,0xa8,0xa8,0xa3,0x9e,0x9a,0x98,0x98,0x98,0x9b,0x98,
0x91,0x87,0x79,0x6a,0x5e,0x53,0x47,0x3d,0x39,0x37,0x39,0x42,0x50,0x62,0x76,0x86,
0x90,0x97,0x99,0x96,0x91,0x84,0x75,0x67,0x5a,0x4d,0x43,0x3d,0x39,0x3a,0x42,0x4f,
0x62,0x75,0x82,0x85,0x7d,0x70,0x63,0x5a,0x54,0x4f,0x49,0x40,0x36,0x32,0x37,0x49,
0x5f,0x75,0x84,0x8b,0x90,0x93,0x96,0x9b,0xa1,0xa3,0xa5,0xa2,0x9d,0x9d,0xa0,0xa3,
0xa4,0xa1,0x9e,0x9b,0x9b,0x99,0x9b,0x9d,0x9c,0x98,0x95,0x94,0x97,0x9b,0x9c,0x98,
0x8f,0x81,0x72,0x66,0x5f,0x5f,0x62,0x67,0x6d,0x75,0x7f,0x89,0x90,0x97,0x9f,0xa3,
0xa7,0xa6,0xa2,0x9a,0x8c,0x79,0x6b,0x5d,0x53,0x4c,0x49,0x41,0x39,0x34,0x32,0x32,
0x35,0x39,0x3d,0x3d,0x39,0x34,0x31,0x31,0x32,0x34,0x35,0x36,0x38,0x3d,0x48,0x5a,
0x6f,0x7d,0x82,0x7c,0x6e,0x60,0x5b,0x5f,0x6a,0x77,0x7f,0x7f,0x77,0x6b,0x63,0x60,
0x63,0x69,0x6e,0x72,0x72,0x72,0x7b,0x84,0x8f,0x9b,0xa1,0x9c,0x90,0x7d,0x67,0x51,
0x42,0x39,0x35,0x34,0x35,0x37,0x38,0x37,0x35,0x35,0x3e,0x4c,0x5f,0x6e,0x78,0x79,
0x72,0x67,0x5d,0x56,0x51,0x4d,0x47,0x3c,0x33,0x2c,0x2a,0x2c,0x38,0x40,0x43,0x42,
0x39,0x30,0x2f,0x34,0x40,0x50,0x62,0x73,0x81,0x8a,0x90,0x96,0x9d,0xa3,0xa6,0xa4,
0x9f,0x97,0x8f,0x81,0x72,0x63,0x5a,0x58,0x60,0x6a,0x76,0x7e,0x7f,0x77,0x6b,0x62,
0x60,0x64,0x6e,0x77,0x7b,0x79,0x70,0x66,0x5f,0x5e,0x5e,0x5c,0x54,0x47,0x3b,0x32,
0x30,0x3a,0x50,0x69,0x7c,0x8f,0x97,0x9a,0x9d,0x9c,0x96,0x8c,0x7c,0x6a,0x5d,0x57,
0x5d,0x69,0x75,0x7b,0x7a,0x73,0x69,0x5f,0x57,0x53,0x51,0x4c,0x40,0x31,0x28,0x27,
0x2f,0x3b,0x43,0x48,0x46,0x3e,0x35,0x32,0x36,0x42,0x50,0x64,0x6f,0x77,0x83,0x8e,
0x97,0x9e,0xa3,0xa4,0xa2,0x9f,0x9e,0x9f,0xa0,0x9f,0x9d,0x98,0x8e,0x80,0x70,0x64,
0x5b,0x53,0x49,0x3c,0x33,0x30,0x39,0x4a,0x5f,0x73,0x7f,0x82,0x7b,0x6f,0x64,0x5d,
0x57,0x52,0x49,0x3f,0x38,0x37,0x3f,0x51,0x65,0x79,0x8a,0x92,0x98,0x96,0x97,0x90,
0x86,0x79,0x6c,0x5f,0x54,0x4b,0x45,0x42,0x3c,0x3b,0x40,0x4d,0x5f,0x72,0x81,0x8c,
0x90,0x92,0x94,0x9b,0xa3,0xa9,0xa8,0xa0,0x90,0x7f,0x70,0x64,0x5d,0x5c,0x5f,0x65,
0x6d,0x74,0x7f,0x88,0x92,0x9b,0xa0,0xa5,0xa8,0xa5,0xa4,0x9f,0x99,0x9a,0x9c,0xa0,
0xa3,0xa4,0xa3,0xa3,0xa0,0x9f,0xa0,0xa2,0xa1,0x9e,0x9d,0x9c,0x9c,0x9c,0x9c,0x99,
0x94,0x88,0x78,0x6a,0x60,0x5e,0x65,0x6e,0x78,0x7f,0x80,0x78,0x6b,0x5f,0x5a,0x5d,
0x69,0x74,0x78,0x78,0x72,0x67,0x61,0x5d,0x5c,0x5d,0x59,0x4d,0x3e,0x30,0x29,0x2b,
0x32,0x3b,0x41,0x42,0x3d,0x37,0x36,0x35,0x35,0x34,0x31,0x2f,0x35,0x3e,0x4f,0x62,
0x73,0x7c,0x7c,0x72,0x67,0x5d,0x57,0x53,0x4f,0x4b,0x43,0x38,0x2f,0x29,0x2c,0x35,
0x3d,0x40,0x3e,0x37,0x30,0x2e,0x35,0x45,0x5b,0x6f,0x7a,0x7c,0x78,0x6f,0x63,0x59,
0x50,0x49,0x46,0x3f,0x39,0x32,0x33,0x32,0x34,0x39,0x44,0x51,0x66,0x73,0x7c,0x7d,
0x77,0x6b,0x60,0x5a,0x5d,0x67,0x73,0x7a,0x79,0x72,0x67,0x5e,0x5d,0x5f,0x60,0x5b,
0x4d,0x3b,0x30,0x2c,0x37,0x4f,0x6b,0x81,0x8c,0x87,0x77,0x64,0x5b,0x5b,0x63,0x70,
0x79,0x7d,0x7c,0x70,0x63,0x5e,0x60,0x68,0x70,0x75,0x76,0x74,0x6f,0x67,0x61,0x5f,
0x5d,0x5a,0x56,0x4e,0x40,0x33,0x29,0x27,0x2c,0x34,0x3e,0x49,0x51,0x59,0x63,0x6e,
0x7a,0x87,0x92,0x99,0x98,0x90,0x85,0x76,0x64,0x54,0x48,0x3f,0x3a,0x36,0x36,0x36,
0x36,0x3a,0x3c,0x3c,0x35,0x34,0x30,0x2f,0x30,0x31,0x32,0x31,0x30,0x30,0x39,0x46,
0x59,0x6d,0x7a,0x7d,0x7a,0x6f,0x66,0x5f,0x60,0x66,0x6e,0x75,0x79,0x7c,0x84,0x8d,
0x98,0xa5,0xae,0xb0,0xac,0xa3,0x9b,0x98,0x95,0x95,0x94,0x92,0x8b,0x80,0x73,0x64,
0x56,0x4b,0x42,0x3b,0x3b,0x3a,0x3a,0x37,0x33,0x31,0x35,0x40,0x50,0x61,0x70,0x78,
0x77,0x70,0x68,0x61,0x5d,0x56,0x4f,0x45,0x3b,0x34,0x39,0x47,0x5b,0x72,0x83,0x88,
0x80,0x71,0x66,0x5c,0x55,0x4e,0x45,0x41,0x37,0x35,0x3f,0x52,0x68,0x7c,0x89,0x8f,
0x93,0x96,0x99,0x97,0x90,0x80,0x6e,0x61,0x5c,0x60,0x6d,0x7b,0x82,0x81,0x76,0x6a,
0x61,0x5e,0x60,0x66,0x6b,0x6e,0x6f,0x74,0x80,0x8d,0x9b,0xa2,0xa0,0x93,0x80,0x6c,
0x5f,0x58,0x5a,0x64,0x6f,0x7a,0x86,0x8f,0x97,0x98,0x9f,0xa2,0xa3,0xa2,0x9f,0x9b,
0x98,0x97,0x97,0x98,0x95,0x8e,0x80,0x6b,0x58,0x4b,0x45,0x42,0x40,0x3b,0x36,0x32,
0x30,0x32,0x39,0x3f,0x42,0x3d,0x38,0x32,0x31,0x37,0x43,0x52,0x63,0x72,0x7f,0x86,
0x8d,0x93,0x9a,0xa0,0xa3,0xa4,0xa4,0xa3,0xa1,0xa0,0x9e,0x9f,0xa1,0xa2,0xa1,0xa0,
0x9f,0x9e,0x9c,0x9c,0x9b,0x9a,0x95,0x8b,0x7e,0x6e,0x62,0x54,0x4b,0x44,0x3f,0x3b,
// Line 16
0x3c,0x3c,0x3b,0x3a,0x39,0x38,0x38,0x38,0x37,0x36,0x38,0x38,0x37,0x37,0x37,0x38,
0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x37,0x34,0x33,0x32,0x33,0x34,0x36,0x36,
0x38,0x37,0x37,0x39,0x39,0x39,0x3a,0x39,0x36,0x35,0x35,0x36,0x35,0x36,0x37,0x38,
0x39,0x36,0x33,0x35,0x39,0x44,0x56,0x68,0x75,0x7c,0x7a,0x6e,0x62,0x5a,0x5c,0x63,
0x6e,0x76,0x7a,0x78,0x71,0x67,0x61,0x5f,0x64,0x6e,0x75,0x78,0x76,0x70,0x68,0x62,
0x5d,0x5e,0x65,0x6d,0x71,0x74,0x75,0x72,0x6b,0x63,0x60,0x5f,0x65,0x6a,0x70,0x75,
0x75,0x70,0x6a,0x62,0x5e,0x5d,0x65,0x6c,0x74,0x78,0x76,0x6f,0x68,0x60,0x5d,0x60,
0x65,0x6c,0x74,0x77,0x75,0x6f,0x68,0x63,0x60,0x60,0x65,0x6d,0x77,0x7c,0x79,0x72,
0x69,0x62,0x62,0x63,0x66,0x6a,0x6d,0x6d,0x6e,0x71,0x78,0x82,0x91,0x9d,0xa6,0xa9,
0xa7,0x9e,0x93,0x83,0x74,0x67,0x5d,0x56,0x50,0x4a,0x43,0x3b,0x37,0x3a,0x43,0x52,
0x63,0x76,0x88,0x93,0x99,0x9b,0x9d,0x9f,0xa2,0xa1,0xa0,0x9a,0x92,0x83,0x72,0x62,
0x59,0x58,0x5f,0x68,0x72,0x7c,0x7d,0x75,0x6a,0x60,0x5b,0x60,0x69,0x74,0x7a,0x7a,
0x75,0x6c,0x64,0x61,0x62,0x65,0x6a,0x6d,0x6f,0x70,0x72,0x7a,0x86,0x93,0xa2,0xab,
0xac,0xa8,0xa1,0x9a,0x98,0x99,0x9c,0x9d,0x9a,0x8f,0x81,0x72,0x65,0x5a,0x51,0x45,
0x3a,0x33,0x32,0x39,0x49,0x5d,0x6e,0x79,0x79,0x73,0x69,0x61,0x5a,0x54,0x4f,0x46,
0x3a,0x32,0x32,0x3d,0x54,0x6b,0x7b,0x82,0x7e,0x71,0x64,0x5a,0x54,0x50,0x4b,0x45,
0x3c,0x35,0x31,0x32,0x36,0x3b,0x42,0x4b,0x54,0x5d,0x6b,0x7a,0x86,0x8e,0x92,0x93,
0x8f,0x87,0x78,0x66,0x55,0x46,0x3b,0x38,0x37,0x38,0x3c,0x3d,0x39,0x35,0x34,0x39,
0x47,0x58,0x68,0x70,0x73,0x6e,0x66,0x5f,0x5d,0x62,0x69,0x70,0x74,0x76,0x79,0x80,
0x8b,0x97,0x9f,0xa1,0x97,0x83,0x6c,0x5d,0x55,0x58,0x65,0x74,0x7e,0x88,0x8c,0x91,
0x98,0x9a,0x95,0x88,0x74,0x5e,0x50,0x4b,0x55,0x65,0x74,0x7b,0x79,0x74,0x6e,0x68,
0x65,0x5f,0x55,0x4b,0x3f,0x36,0x36,0x3e,0x4f,0x64,0x77,0x87,0x91,0x95,0x94,0x8e,
0x87,0x7e,0x73,0x65,0x56,0x49,0x41,0x3b,0x39,0x39,0x3b,0x3e,0x40,0x3f,0x41,0x45,
0x4e,0x5d,0x70,0x7d,0x81,0x7c,0x72,0x65,0x5d,0x5e,0x67,0x73,0x7c,0x7d,0x78,0x6f,
0x65,0x5f,0x62,0x6b,0x72,0x76,0x77,0x76,0x70,0x68,0x60,0x5b,0x5c,0x5a,0x56,0x4d,
0x42,0x35,0x30,0x2e,0x31,0x37,0x3e,0x46,0x4f,0x57,0x60,0x6b,0x79,0x85,0x8f,0x99,
0xa0,0xa3,0xa7,0xa9,0xa6,0x9e,0x91,0x81,0x6e,0x63,0x5e,0x60,0x68,0x74,0x7b,0x80,
0x79,0x6e,0x66,0x5d,0x58,0x56,0x52,0x4a,0x3f,0x34,0x2c,0x28,0x2b,0x32,0x3d,0x44,
0x43,0x3d,0x36,0x33,0x38,0x48,0x5d,0x70,0x7f,0x84,0x82,0x7a,0x70,0x68,0x65,0x68,
0x6b,0x70,0x77,0x7d,0x84,0x8b,0x92,0x9a,0xa3,0xa9,0xa9,0xa3,0x9b,0x8f,0x84,0x76,
0x6b,0x63,0x63,0x65,0x6a,0x70,0x78,0x80,0x88,0x8f,0x95,0x9e,0xa5,0xa8,0xa9,0xa5,
0x9e,0x9b,0x99,0x9a,0x9c,0x9f,0xa1,0xa2,0xa2,0xa1,0x9e,0xa0,0x9c,0x9a,0x9c,0x9e,
0xa1,0xa2,0xa3,0xa2,0xa1,0xa1,0xa0,0x9d,0x9f,0x9d,0x9c,0x9a,0x98,0x95,0x9b,0x9e,
0xa1,0xa2,0xa1,0xa0,0x9d,0x9d,0x9d,0x9e,0x9b,0x91,0x82,0x70,0x63,0x5b,0x5a,0x5d,
0x65,0x70,0x79,0x80,0x89,0x92,0x9c,0xa2,0xa6,0xa6,0xa6,0xa3,0x9a,0x8d,0x7d,0x6d,
0x60,0x58,0x5a,0x60,0x6e,0x79,0x7a,0x77,0x6f,0x67,0x63,0x5d,0x54,0x4e,0x46,0x3c,
0x34,0x2e,0x2e,0x30,0x37,0x3f,0x48,0x52,0x5e,0x6a,0x74,0x78,0x75,0x6c,0x61,0x5d,
0x60,0x66,0x6e,0x75,0x7a,0x7d,0x83,0x8b,0x93,0x9d,0xa9,0xb0,0xac,0xa2,0x93,0x83,
0x76,0x66,0x5b,0x54,0x51,0x4d,0x45,0x3c,0x35,0x35,0x40,0x55,0x6d,0x7e,0x85,0x80,
0x74,0x63,0x58,0x57,0x5f,0x6c,0x78,0x7b,0x76,0x6b,0x61,0x5c,0x5d,0x62,0x68,0x6f,
0x76,0x77,0x71,0x6c,0x67,0x63,0x67,0x69,0x6b,0x70,0x74,0x76,0x7a,0x80,0x8b,0x98,
0xa0,0xa0,0x94,0x83,0x6f,0x5b,0x4d,0x43,0x3c,0x39,0x39,0x3d,0x47,0x56,0x67,0x76,
0x82,0x8b,0x92,0x95,0x97,0x94,0x8c,0x7c,0x6a,0x5d,0x56,0x59,0x63,0x6d,0x77,0x82,
0x8b,0x92,0x99,0x9e,0xa3,0xa5,0xa3,0x9d,0x9a,0x9a,0x9d,0xa0,0xa1,0x9f,0x9e,0x9e,
0x9e,0x9c,0x99,0x90,0x80,0x6e,0x5e,0x56,0x58,0x61,0x6c,0x76,0x7a,0x77,0x70,0x69,
0x62,0x5c,0x55,0x4b,0x41,0x39,0x33,0x2d,0x2a,0x2b,0x2e,0x37,0x42,0x50,0x5e,0x6b,
0x73,0x73,0x70,0x68,0x60,0x5e,0x59,0x50,0x49,0x42,0x3a,0x33,0x2e,0x2e,0x34,0x3c,
0x45,0x4f,0x5d,0x6b,0x76,0x79,0x76,0x6c,0x62,0x5c,0x5d,0x6a,0x76,0x7d,0x7b,0x72,
0x66,0x5d,0x5c,0x5d,0x5d,0x56,0x49,0x37,0x2b,0x2a,0x3a,0x54,0x6e,0x7e,0x85,0x81,
0x76,0x66,0x5b,0x53,0x4e,0x48,0x42,0x3b,0x36,0x33,0x31,0x32,0x39,0x43,0x51,0x60,
0x6c,0x75,0x79,0x76,0x6d,0x62,0x5b,0x59,0x56,0x4b,0x3d,0x34,0x35,0x40,0x54,0x6a,
0x7b,0x83,0x7f,0x70,0x5e,0x52,0x4e,0x4c,0x48,0x3f,0x39,0x39,0x41,0x51,0x68,0x7b,
0x89,0x91,0x93,0x92,0x90,0x8b,0x82,0x76,0x65,0x54,0x49,0x41,0x3f,0x40,0x40,0x3c,
0x36,0x35,0x3a,0x40,0x45,0x41,0x38,0x2f,0x2b,0x31,0x41,0x59,0x70,0x7a,0x7a,0x70,
0x65,0x5e,0x5b,0x57,0x54,0x4a,0x3d,0x33,0x2f,0x38,0x50,0x68,0x7b,0x84,0x81,0x74,
0x63,0x58,0x56,0x60,0x6e,0x78,0x7a,0x78,0x6d,0x61,0x5c,0x5d,0x64,0x6e,0x72,0x72,
0x71,0x72,0x7b,0x86,0x92,0x9b,0x9c,0x91,0x7a,0x61,0x51,0x4e,0x57,0x67,0x74,0x7b,
0x7b,0x75,0x6c,0x64,0x62,0x5f,0x57,0x49,0x39,0x30,0x32,0x3f,0x54,0x6d,0x7c,0x80,
0x7b,0x6c,0x5d,0x55,0x50,0x4d,0x49,0x42,0x39,0x31,0x2d,0x2e,0x35,0x3d,0x46,0x4d,
0x55,0x5f,0x6c,0x7d,0x89,0x94,0x9a,0x9a,0x91,0x85,0x77,0x69,0x5a,0x4b,0x3f,0x37,
0x35,0x36,0x3c,0x47,0x56,0x66,0x77,0x86,0x91,0x99,0x9c,0x9a,0x93,0x87,0x79,0x69,
0x5d,0x54,0x56,0x5d,0x68,0x74,0x81,0x8d,0x97,0x9e,0xa0,0x9a,0x8d,0x7b,0x67,0x58,
0x53,0x58,0x63,0x70,0x79,0x82,0x8b,0x93,0x98,0x9e,0x9a,0x8e,0x7e,0x69,0x58,0x50,
0x55,0x5d,0x6b,0x78,0x83,0x8b,0x93,0x97,0x9c,0xa2,0xa6,0xa3,0xa1,0x9a,0x90,0x84,
0x75,0x67,0x61,0x5e,0x60,0x65,0x6c,0x76,0x7d,0x81,0x87,0x90,0x9a,0xa3,0xa6,0xa5,
0x9d,0x91,0x83,0x74,0x65,0x5a,0x52,0x4b,0x45,0x3d,0x36,0x32,0x2e,0x2c,0x2d,0x32,
0x38,0x3b,0x3d,0x3b,0x37,0x34,0x33,0x34,0x38,0x3a,0x3a,0x38,0x32,0x2c,0x2a,0x2c,
0x33,0x3f,0x50,0x5e,0x6c,0x7a,0x88,0x94,0x9d,0xa1,0x9c,0x92,0x81,0x6e,0x62,0x5c,
0x5d,0x62,0x6c,0x77,0x82,0x8c,0x94,0x98,0x96,0x8e,0x83,0x74,0x63,0x53,0x4a,0x43,
0x3d,0x3a,0x38,0x36,0x37,0x37,0x36,0x37,0x36,0x34,0x31,0x30,0x30,0x32,0x37,0x39,
0x39,0x39,0x38,0x38,0x39,0x39,0x3b,0x38,0x38,0x32,0x2e,0x32,0x3a,0x43,0x54,0x62,
0x70,0x7e,0x89,0x91,0x98,0x9a,0x97,0x8c,0x7b,0x68,0x5b,0x55,0x5a,0x66,0x74,0x7e,
0x7f,0x78,0x6e,0x62,0x5a,0x54,0x4d,0x45,0x3a,0x31,0x2c,0x2a,0x2f,0x37,0x3d,0x3f,
0x3c,0x38,0x36,0x35,0x36,0x36,0x36,0x35,0x36,0x3c,0x4d,0x60,0x70,0x78,0x76,0x6f,
0x63,0x5c,0x56,0x53,0x51,0x4a,0x3d,0x30,0x2b,0x35,0x4d,0x69,0x7f,0x88,0x83,0x72,
0x62,0x56,0x54,0x5d,0x66,0x6b,0x70,0x75,0x7b,0x84,0x90,0x9a,0x9d,0x94,0x83,0x6c,
0x5a,0x53,0x59,0x67,0x73,0x7d,0x7e,0x78,0x6c,0x62,0x5e,0x62,0x66,0x68,0x69,0x6e,
0x76,0x7e,0x88,0x97,0xa0,0x9e,0x94,0x7f,0x69,0x5a,0x56,0x5b,0x68,0x76,0x82,0x83,
0x7b,0x6e,0x64,0x61,0x63,0x67,0x6b,0x6e,0x70,0x75,0x7d,0x89,0x97,0x9e,0x9b,0x8f,
0x7d,0x6b,0x5e,0x58,0x5c,0x65,0x71,0x7c,0x84,0x8d,0x97,0x9d,0xa1,0x9b,0x8e,0x7b,
0x68,0x5a,0x56,0x5c,0x65,0x6c,0x77,0x80,0x86,0x8d,0x96,0x9a,0x9a,0x8e,0x7a,0x69,
0x5a,0x55,0x5b,0x68,0x76,0x7e,0x80,0x7b,0x72,0x69,0x63,0x62,0x65,0x68,0x6b,0x6e,
0x76,0x81,0x8f,0x97,0x99,0x94,0x89,0x77,0x67,0x58,0x4f,0x46,0x3d,0x36,0x33,0x3b,
0x49,0x5d,0x71,0x7f,0x81,0x7a,0x6d,0x60,0x58,0x5a,0x61,0x6a,0x70,0x74,0x77,0x81,
0x89,0x92,0x9c,0x9c,0x8f,0x7d,0x65,0x50,0x45,0x3d,0x3b,0x3b,0x3a,0x38,0x38,0x39,
0x3d,0x3f,0x3d,0x39,0x34,0x31,0x32,0x34,0x36,0x36,0x36,0x36,0x34,0x32,0x34,0x36,
0x37,0x36,0x33,0x30,0x2c,0x32,0x39,0x45,0x54,0x63,0x70,0x7e,0x8a,0x94,0x9d,0x9e,
0x98,0x8b,0x79,0x68,0x5b,0x54,0x55,0x5d,0x67,0x72,0x7e,0x8a,0x94,0x9b,0x9d,0x97,
0x89,0x79,0x68,0x58,0x4b,0x42,0x3d,0x3b,0x3a,0x3c,0x42,0x50,0x61,0x72,0x81,0x8b,
0x91,0x94,0x98,0x9c,0xa5,0xa9,0xa9,0xa5,0x9e,0x9a,0x99,0x9a,0x9b,0x92,0x8b,0x7a,
0x6a,0x5d,0x57,0x5a,0x62,0x6b,0x74,0x7d,0x85,0x8a,0x91,0x98,0x9f,0xa3,0xa3,0x9e,
0x96,0x88,0x78,0x69,0x5f,0x58,0x51,0x4a,0x41,0x39,0x35,0x35,0x3e,0x4f,0x62,0x74,
0x83,0x8d,0x95,0x98,0x96,0x8e,0x83,0x76,0x67,0x59,0x4d,0x44,0x3c,0x38,0x37,0x3a,
0x45,0x59,0x6d,0x7b,0x7f,0x7a,0x6c,0x62,0x57,0x50,0x4e,0x4b,0x43,0x39,0x2e,0x2a,
0x2e,0x35,0x3c,0x3f,0x3d,0x37,0x32,0x2f,0x2f,0x32,0x34,0x34,0x33,0x35,0x36,0x38,
0x39,0x37,0x36,0x35,0x34,0x35,0x36,0x38,0x36,0x35,0x33,0x34,0x34,0x38,0x39,0x39,
// Line 17
0x39,0x37,0x38,0x37,0x37,0x35,0x34,0x34,0x35,0x36,0x37,0x36,0x37,0x39,0x3b,0x3b,
0x3a,0x39,0x38,0x36,0x35,0x33,0x35,0x36,0x35,0x33,0x34,0x35,0x35,0x35,0x35,0x36,
0x36,0x36,0x36,0x36,0x38,0x39,0x39,0x3b,0x3c,0x3b,0x39,0x37,0x35,0x37,0x39,0x3b,
0x39,0x34,0x30,0x32,0x3b,0x49,0x59,0x6d,0x7b,0x7f,0x7b,0x70,0x64,0x5e,0x5e,0x66,
0x71,0x78,0x7b,0x77,0x6f,0x65,0x61,0x63,0x68,0x70,0x77,0x7b,0x7b,0x77,0x70,0x67,
0x61,0x60,0x64,0x6b,0x71,0x73,0x74,0x71,0x68,0x61,0x5e,0x61,0x66,0x6e,0x74,0x77,
0x76,0x70,0x68,0x65,0x60,0x60,0x67,0x70,0x77,0x79,0x77,0x71,0x6a,0x64,0x61,0x60,
0x66,0x6d,0x74,0x78,0x77,0x70,0x69,0x61,0x5d,0x5f,0x67,0x70,0x79,0x7a,0x77,0x70,
0x6b,0x67,0x65,0x67,0x6d,0x71,0x74,0x74,0x73,0x77,0x7e,0x87,0x94,0x9e,0xa8,0xab,
0xa8,0x9d,0x90,0x80,0x72,0x64,0x5b,0x55,0x51,0x4c,0x46,0x3f,0x3d,0x3e,0x45,0x55,
0x67,0x7b,0x8b,0x92,0x96,0x99,0x9d,0xa0,0xa3,0xa4,0xa2,0x9b,0x90,0x7e,0x6c,0x5f,
0x59,0x59,0x61,0x6d,0x77,0x7a,0x7a,0x74,0x69,0x61,0x5f,0x5e,0x69,0x73,0x78,0x7a,
0x76,0x6e,0x69,0x65,0x66,0x69,0x6e,0x73,0x74,0x74,0x76,0x7e,0x8b,0x9a,0xa7,0xad,
0xad,0xa7,0x9f,0x99,0x98,0x9b,0x9f,0xa0,0x9b,0x90,0x83,0x74,0x65,0x57,0x4f,0x48,
0x3f,0x36,0x32,0x39,0x4a,0x60,0x71,0x7b,0x7c,0x74,0x67,0x5e,0x58,0x55,0x53,0x4c,
0x40,0x36,0x36,0x44,0x5a,0x73,0x85,0x8b,0x88,0x78,0x68,0x62,0x61,0x66,0x6f,0x76,
0x7b,0x7f,0x83,0x8b,0x96,0xa1,0xa8,0xa6,0xa4,0x9b,0x8f,0x83,0x75,0x67,0x61,0x58,
0x50,0x4b,0x47,0x43,0x3f,0x39,0x34,0x35,0x39,0x41,0x47,0x4e,0x55,0x60,0x6e,0x7c,
0x88,0x90,0x96,0x9b,0x9f,0xa0,0xa2,0xa2,0x9f,0x93,0x84,0x73,0x67,0x61,0x64,0x6a,
0x75,0x80,0x83,0x7d,0x74,0x68,0x61,0x5f,0x64,0x6c,0x76,0x79,0x75,0x6c,0x64,0x5e,
0x59,0x59,0x57,0x50,0x44,0x36,0x2b,0x26,0x29,0x33,0x3e,0x46,0x49,0x48,0x43,0x3e,
0x3b,0x3a,0x3a,0x38,0x37,0x38,0x3f,0x4a,0x57,0x64,0x72,0x7f,0x89,0x91,0x95,0x96,
0x93,0x87,0x78,0x68,0x59,0x4e,0x45,0x3e,0x3b,0x39,0x3b,0x3a,0x38,0x36,0x38,0x41,
0x50,0x5d,0x6c,0x77,0x78,0x73,0x68,0x5d,0x56,0x52,0x50,0x4a,0x3f,0x35,0x2d,0x29,
0x31,0x38,0x40,0x45,0x43,0x3b,0x32,0x2e,0x35,0x47,0x60,0x75,0x7d,0x7f,0x77,0x6e,
0x67,0x60,0x57,0x53,0x48,0x3c,0x35,0x34,0x3d,0x4e,0x65,0x7c,0x8e,0x96,0x99,0x98,
0x92,0x8a,0x80,0x75,0x66,0x57,0x49,0x3f,0x39,0x38,0x3b,0x3c,0x3d,0x39,0x36,0x39,
0x41,0x52,0x63,0x72,0x79,0x7a,0x74,0x6b,0x61,0x5d,0x57,0x52,0x4e,0x43,0x39,0x37,
0x3d,0x4b,0x63,0x7b,0x8e,0x96,0x98,0x95,0x96,0x99,0xa0,0xa6,0xa4,0x9a,0x8b,0x7a,
0x6c,0x61,0x5a,0x54,0x4a,0x40,0x38,0x38,0x3c,0x44,0x52,0x64,0x76,0x83,0x8d,0x94,
0x98,0x97,0x91,0x85,0x77,0x69,0x5e,0x51,0x46,0x3e,0x3b,0x3b,0x41,0x4b,0x5b,0x6c,
0x7b,0x88,0x92,0x97,0x99,0x98,0x92,0x87,0x78,0x67,0x57,0x4a,0x40,0x3b,0x38,0x39,
0x3e,0x48,0x58,0x68,0x76,0x86,0x91,0x98,0x9e,0x9b,0x95,0x8b,0x7d,0x6d,0x62,0x5e,
0x63,0x6c,0x77,0x7f,0x86,0x8f,0x96,0x9b,0xa2,0xa6,0xa6,0xa2,0x9c,0x97,0x96,0x9a,
0x9e,0x9d,0x98,0x8c,0x7b,0x6d,0x5e,0x54,0x4e,0x47,0x3f,0x37,0x34,0x39,0x4c,0x61,
0x74,0x80,0x82,0x78,0x6b,0x5c,0x55,0x52,0x4f,0x47,0x3e,0x34,0x2e,0x2d,0x32,0x3c,
0x45,0x48,0x44,0x3d,0x36,0x34,0x38,0x44,0x53,0x64,0x74,0x80,0x89,0x93,0x9c,0x9d,
0x98,0x8d,0x7b,0x6c,0x61,0x5b,0x5c,0x64,0x6f,0x7a,0x84,0x8b,0x92,0x99,0xa1,0xa4,
0xa5,0xa4,0xa1,0x9d,0x9a,0x97,0x98,0x99,0x99,0x93,0x87,0x74,0x62,0x57,0x57,0x5e,
0x6a,0x76,0x7c,0x7e,0x7a,0x70,0x64,0x60,0x65,0x6d,0x79,0x7f,0x7d,0x77,0x6d,0x64,
0x5f,0x60,0x67,0x71,0x76,0x75,0x72,0x73,0x79,0x86,0x96,0x9f,0x9e,0x91,0x7b,0x64,
0x54,0x52,0x5b,0x6c,0x7b,0x82,0x7c,0x75,0x6a,0x61,0x5d,0x58,0x50,0x46,0x39,0x31,
0x34,0x40,0x52,0x69,0x7d,0x89,0x92,0x96,0x99,0x97,0x8f,0x81,0x70,0x61,0x54,0x4a,
0x44,0x40,0x3e,0x3c,0x39,0x39,0x3d,0x42,0x44,0x42,0x3d,0x36,0x32,0x34,0x3d,0x49,
0x59,0x67,0x75,0x80,0x89,0x90,0x96,0x94,0x8c,0x7d,0x6c,0x5e,0x55,0x55,0x5e,0x6c,
0x78,0x7f,0x7f,0x79,0x71,0x69,0x61,0x59,0x4e,0x45,0x3d,0x34,0x2f,0x2d,0x30,0x38,
0x3f,0x47,0x52,0x5e,0x6a,0x72,0x77,0x75,0x6b,0x61,0x5d,0x61,0x6f,0x7b,0x84,0x84,
0x7d,0x70,0x65,0x5f,0x61,0x66,0x6b,0x6c,0x6b,0x6e,0x75,0x80,0x90,0x99,0x9c,0x9b,
0x91,0x7f,0x6a,0x57,0x47,0x3c,0x38,0x39,0x3a,0x3f,0x3d,0x38,0x34,0x34,0x3a,0x4b,
0x5d,0x6c,0x77,0x7a,0x74,0x6a,0x62,0x5a,0x55,0x4e,0x47,0x3e,0x35,0x2e,0x2d,0x33,
0x39,0x3f,0x3e,0x38,0x35,0x35,0x37,0x35,0x32,0x2f,0x2e,0x33,0x3d,0x4c,0x5c,0x6f,
0x78,0x79,0x73,0x67,0x5c,0x59,0x54,0x4e,0x47,0x3d,0x35,0x2e,0x2b,0x2c,0x34,0x3b,
0x44,0x50,0x5d,0x69,0x73,0x79,0x78,0x70,0x64,0x5b,0x5c,0x66,0x74,0x7c,0x7d,0x74,
0x67,0x5e,0x5b,0x5f,0x67,0x6f,0x74,0x74,0x73,0x76,0x80,0x8f,0x9c,0xa2,0xa2,0x94,
0x80,0x6b,0x5c,0x58,0x5d,0x66,0x72,0x7c,0x86,0x8d,0x93,0x99,0xa0,0xa3,0xa3,0x9e,
0x98,0x94,0x94,0x95,0x98,0x97,0x93,0x8b,0x7c,0x6c,0x5c,0x55,0x4d,0x44,0x3d,0x38,
0x37,0x3c,0x45,0x54,0x66,0x77,0x82,0x89,0x8c,0x8f,0x98,0x9f,0xa3,0xa0,0xa1,0x9e,
0x99,0x99,0x9a,0x99,0x9c,0x91,0x82,0x71,0x62,0x59,0x59,0x60,0x6c,0x79,0x80,0x80,
0x77,0x6b,0x62,0x60,0x63,0x6b,0x74,0x7b,0x79,0x71,0x6a,0x64,0x62,0x64,0x67,0x6c,
0x70,0x72,0x74,0x78,0x82,0x8e,0x99,0x9c,0x97,0x89,0x7b,0x65,0x50,0x44,0x3d,0x39,
0x36,0x36,0x3d,0x4d,0x60,0x71,0x7d,0x80,0x7a,0x6f,0x64,0x5f,0x5e,0x64,0x6b,0x70,
0x75,0x79,0x81,0x8b,0x96,0xa2,0xac,0xae,0xa9,0x9f,0x93,0x85,0x77,0x6a,0x61,0x5a,
0x52,0x49,0x3f,0x3a,0x39,0x40,0x50,0x62,0x73,0x7f,0x81,0x78,0x69,0x5c,0x54,0x50,
0x4c,0x44,0x3b,0x36,0x36,0x40,0x55,0x6f,0x86,0x8e,0x85,0x74,0x63,0x5a,0x5b,0x65,
0x73,0x7b,0x7d,0x78,0x6d,0x63,0x60,0x62,0x67,0x70,0x77,0x7a,0x77,0x72,0x69,0x63,
0x5e,0x5b,0x57,0x55,0x4b,0x3e,0x31,0x28,0x25,0x29,0x31,0x3b,0x47,0x53,0x5e,0x68,
0x6f,0x71,0x72,0x6c,0x64,0x59,0x50,0x4a,0x45,0x3f,0x38,0x31,0x2e,0x2d,0x2f,0x38,
0x47,0x57,0x67,0x71,0x77,0x78,0x74,0x6c,0x62,0x5d,0x61,0x69,0x74,0x79,0x7b,0x80,
0x85,0x8c,0x97,0xa1,0xa2,0x97,0x80,0x65,0x52,0x4c,0x55,0x64,0x78,0x81,0x81,0x79,
0x6d,0x62,0x5c,0x57,0x4f,0x47,0x3d,0x36,0x31,0x2d,0x2d,0x32,0x3b,0x47,0x54,0x65,
0x70,0x74,0x73,0x69,0x60,0x5b,0x5c,0x5d,0x59,0x50,0x42,0x37,0x35,0x41,0x59,0x74,
0x89,0x8f,0x85,0x73,0x62,0x5a,0x5b,0x65,0x73,0x7f,0x80,0x7a,0x70,0x65,0x61,0x60,
0x65,0x6f,0x77,0x7b,0x77,0x70,0x68,0x62,0x5e,0x5a,0x59,0x57,0x4f,0x40,0x34,0x2b,
0x28,0x2d,0x36,0x3f,0x4a,0x54,0x5e,0x64,0x6f,0x7a,0x86,0x91,0x96,0x94,0x8e,0x83,
0x74,0x64,0x54,0x48,0x41,0x3b,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x38,0x38,0x34,
0x30,0x30,0x33,0x35,0x37,0x37,0x39,0x38,0x35,0x33,0x35,0x38,0x39,0x34,0x30,0x2c,
0x2d,0x37,0x49,0x5e,0x73,0x7d,0x7d,0x79,0x70,0x66,0x61,0x59,0x50,0x45,0x39,0x31,
0x30,0x38,0x4a,0x61,0x79,0x89,0x92,0x96,0x97,0x96,0x98,0x9c,0xa0,0xa1,0x9e,0x99,
0x99,0x99,0x9a,0x9a,0x9c,0x9e,0x9f,0x9c,0x96,0x8a,0x7f,0x71,0x61,0x55,0x4c,0x46,
0x41,0x3b,0x33,0x2e,0x30,0x34,0x39,0x3c,0x3c,0x38,0x35,0x31,0x32,0x39,0x47,0x58,
0x68,0x76,0x82,0x8e,0x96,0x9a,0x9d,0x99,0x90,0x7d,0x68,0x5a,0x57,0x5d,0x68,0x74,
0x7c,0x7c,0x74,0x69,0x5e,0x5a,0x60,0x6a,0x71,0x76,0x77,0x73,0x6d,0x67,0x62,0x61,
0x5e,0x58,0x4b,0x44,0x38,0x2f,0x2c,0x2d,0x33,0x3d,0x47,0x50,0x5a,0x64,0x6f,0x79,
0x81,0x89,0x92,0x97,0x94,0x89,0x7a,0x67,0x54,0x44,0x3b,0x38,0x3b,0x3d,0x3c,0x39,
0x34,0x32,0x35,0x3f,0x50,0x64,0x74,0x7b,0x79,0x70,0x68,0x61,0x5e,0x59,0x52,0x48,
0x3c,0x32,0x33,0x40,0x57,0x6d,0x7c,0x80,0x79,0x6c,0x5c,0x4e,0x4b,0x4a,0x46,0x40,
0x37,0x2f,0x33,0x36,0x3c,0x43,0x45,0x42,0x3a,0x33,0x30,0x38,0x44,0x52,0x5f,0x6d,
0x79,0x83,0x8f,0x98,0x9f,0xa4,0xa6,0xa6,0xa4,0xa4,0xa4,0xa4,0xa0,0x9e,0x9e,0xa1,
0xa1,0x9f,0x9e,0x9e,0x9e,0x9e,0x9e,0x9d,0x9e,0x9c,0x9b,0x9b,0x9a,0x97,0x8f,0x80,
0x6e,0x5e,0x56,0x55,0x59,0x67,0x74,0x7b,0x7b,0x74,0x69,0x64,0x64,0x67,0x71,0x7b,
0x80,0x7e,0x76,0x6d,0x68,0x65,0x66,0x67,0x67,0x68,0x6a,0x6d,0x70,0x78,0x86,0x93,
0x9e,0xa6,0xa8,0xa6,0x9e,0x92,0x83,0x76,0x6c,0x63,0x59,0x50,0x4a,0x45,0x3f,0x39,
0x39,0x46,0x54,0x65,0x77,0x85,0x90,0x94,0x95,0x95,0x99,0x9f,0xa2,0x9f,0x9a,0x8b,
0x7a,0x6b,0x5e,0x54,0x4d,0x47,0x41,0x3c,0x36,0x32,0x33,0x36,0x39,0x3c,0x3d,0x3d,
0x39,0x34,0x31,0x32,0x34,0x34,0x33,0x34,0x34,0x33,0x31,0x30,0x31,0x33,0x33,0x32,
0x32,0x34,0x37,0x36,0x3b,0x39,0x39,0x3b,0x3b,0x39,0x3b,0x3b,0x3b,0x39,0x38,0x39,
// Line 18
0x3a,0x3a,0x3b,0x38,0x36,0x36,0x38,0x39,0x38,0x36,0x34,0x37,0x38,0x37,0x37,0x37,
0x37,0x37,0x38,0x38,0x39,0x39,0x38,0x36,0x33,0x32,0x36,0x3c,0x40,0x3c,0x38,0x32,
0x2f,0x30,0x36,0x3f,0x47,0x45,0x3d,0x30,0x29,0x28,0x32,0x3f,0x49,0x48,0x40,0x2f,
0x23,0x25,0x31,0x40,0x4c,0x4b,0x3e,0x2d,0x22,0x22,0x2e,0x3f,0x49,0x49,0x3e,0x2d,
0x21,0x23,0x2e,0x3f,0x4c,0x4c,0x41,0x30,0x25,0x24,0x31,0x41,0x4b,0x4b,0x40,0x31,
0x27,0x27,0x32,0x40,0x4b,0x4a,0x3e,0x2e,0x22,0x23,0x30,0x3e,0x48,0x4b,0x43,0x34,
0x28,0x28,0x32,0x41,0x4c,0x4c,0x40,0x31,0x23,0x22,0x2e,0x3f,0x4a,0x4c,0x41,0x30,
0x26,0x26,0x32,0x41,0x4c,0x4b,0x3f,0x2e,0x22,0x21,0x2d,0x3d,0x48,0x48,0x3d,0x2e,
0x24,0x26,0x32,0x45,0x4f,0x4e,0x41,0x30,0x24,0x23,0x2e,0x3f,0x48,0x4a,0x3f,0x30,
0x28,0x2d,0x3d,0x53,0x61,0x61,0x56,0x47,0x3d,0x3a,0x4a,0x5a,0x65,0x63,0x55,0x42,
0x36,0x36,0x43,0x55,0x61,0x60,0x54,0x43,0x38,0x3a,0x45,0x55,0x62,0x61,0x53,0x43,
0x39,0x3a,0x47,0x57,0x63,0x61,0x55,0x46,0x3b,0x3c,0x48,0x59,0x66,0x65,0x57,0x43,
0x39,0x39,0x45,0x56,0x63,0x61,0x57,0x45,0x3a,0x3e,0x4c,0x5b,0x65,0x61,0x54,0x45,
0x3a,0x3c,0x48,0x58,0x61,0x5f,0x54,0x46,0x3d,0x3e,0x48,0x55,0x5e,0x5b,0x51,0x43,
0x3a,0x3b,0x48,0x58,0x63,0x65,0x5c,0x50,0x4a,0x4f,0x5b,0x6b,0x75,0x76,0x6c,0x5e,
0x54,0x55,0x64,0x71,0x7a,0x7b,0x70,0x62,0x54,0x56,0x60,0x70,0x7a,0x78,0x6b,0x5e,
0x50,0x4d,0x5a,0x6b,0x75,0x75,0x6a,0x5c,0x52,0x52,0x5e,0x6e,0x79,0x78,0x6c,0x5b,
0x51,0x53,0x5f,0x6e,0x77,0x77,0x6c,0x5e,0x53,0x52,0x5f,0x6f,0x7a,0x79,0x6d,0x5e,
0x53,0x55,0x60,0x70,0x79,0x7a,0x6e,0x5c,0x50,0x4f,0x5a,0x6e,0x77,0x75,0x6a,0x5a,
0x4f,0x4f,0x5a,0x6a,0x77,0x77,0x6d,0x5d,0x52,0x53,0x5f,0x71,0x81,0x84,0x7c,0x6d,
0x62,0x63,0x70,0x81,0x8d,0x8d,0x81,0x70,0x65,0x65,0x70,0x80,0x8c,0x8e,0x84,0x74,
0x68,0x69,0x75,0x84,0x8e,0x8d,0x81,0x70,0x65,0x66,0x74,0x85,0x90,0x90,0x85,0x74,
0x67,0x65,0x70,0x80,0x8d,0x8a,0x7d,0x6d,0x65,0x67,0x73,0x83,0x8d,0x8e,0x83,0x72,
0x65,0x6a,0x75,0x83,0x8f,0x90,0x85,0x78,0x6b,0x69,0x74,0x83,0x8e,0x8e,0x82,0x74,
0x6b,0x6b,0x75,0x84,0x8f,0x8f,0x84,0x74,0x68,0x68,0x75,0x85,0x8f,0x90,0x88,0x7a,
0x6f,0x6e,0x7c,0x8e,0x9b,0x9c,0x94,0x86,0x7d,0x7d,0x8b,0x9a,0xa4,0xa5,0x98,0x86,
0x7b,0x7c,0x89,0x96,0xa0,0x9f,0x95,0x89,0x7f,0x81,0x8c,0x9b,0xa5,0xa4,0x98,0x8a,
0x81,0x82,0x8c,0x9a,0xa3,0xa3,0x98,0x89,0x7d,0x80,0x8d,0x9d,0xa6,0xa4,0x98,0x88,
0x7e,0x7d,0x89,0x99,0xa4,0xa2,0x97,0x87,0x7f,0x81,0x8e,0x9b,0xa5,0xa4,0x98,0x86,
0x7d,0x7e,0x89,0x99,0xa5,0xa3,0x98,0x88,0x7c,0x7e,0x8a,0x99,0xa4,0xa2,0x97,0x89,
0x7e,0x7e,0x8a,0x9a,0xa6,0xa6,0x9d,0x8f,0x87,0x8a,0x96,0xa8,0xb5,0xb6,0xad,0x9d,
0x90,0x90,0x9d,0xad,0xb9,0xb7,0xae,0x9f,0x96,0x96,0xa1,0xaf,0xbc,0xba,0xac,0x9c,
0x92,0x93,0x9f,0xad,0xb4,0xb5,0xac,0x9e,0x93,0x93,0x9f,0xad,0xb7,0xb6,0xab,0x9d,
0x92,0x91,0x9e,0xae,0xb8,0xb7,0xad,0x9e,0x95,0x97,0xa3,0xb0,0xb9,0xb7,0xab,0x99,
0x8f,0x91,0x9e,0xad,0xb6,0xb6,0xab,0x9f,0x97,0x98,0xa1,0xaf,0xb8,0xb5,0xa5,0x98,
0x8f,0x93,0x9d,0xa9,0xb1,0xb1,0xaa,0x9e,0x97,0x97,0x9e,0xa8,0xae,0xad,0xaa,0xa3,
0xa0,0xa1,0xa6,0xaa,0xad,0xad,0xaa,0xa5,0xa1,0x9f,0x9f,0xa3,0xa4,0xa5,0xa6,0xa5,
0xa3,0xa3,0xa5,0xa8,0xa7,0xa5,0xa5,0xa5,0xa6,0xa5,0xa3,0xa5,0xa5,0xa5,0xa5,0xa3,
0xa2,0xa3,0xa5,0xa5,0xa4,0xa4,0xa6,0xa6,0xa8,0xa8,0xa7,0xa8,0xa8,0xa6,0xa5,0xa3,
0xa1,0xa1,0xa2,0xa1,0x9f,0x9c,0x9d,0xa1,0xa3,0xa4,0xa3,0xa5,0xa7,0xaa,0xaa,0xa8,
0xa7,0xa8,0xa9,0xa7,0xa6,0xa5,0xa6,0xa6,0xa6,0xa4,0xa3,0xa3,0xa4,0xa3,0xa0,0x9c,
0x98,0x90,0x87,0x7a,0x6f,0x63,0x57,0x4e,0x46,0x3f,0x3c,0x38,0x36,0x36,0x36,0x38,
0x3a,0x3a,0x3c,0x3a,0x39,0x35,0x34,0x34,0x34,0x35,0x36,0x36,0x37,0x36,0x35,0x34,
0x37,0x3a,0x3f,0x3e,0x3b,0x38,0x38,0x3a,0x3a,0x3a,0x3d,0x3d,0x3a,0x38,0x37,0x37,
0x3a,0x3a,0x39,0x38,0x37,0x37,0x35,0x38,0x37,0x37,0x39,0x37,0x36,0x36,0x37,0x37,
0x37,0x36,0x37,0x3a,0x3c,0x39,0x39,0x39,0x3a,0x36,0x36,0x36,0x37,0x38,0x38,0x37,
0x39,0x38,0x37,0x37,0x37,0x38,0x3a,0x37,0x35,0x35,0x36,0x37,0x37,0x36,0x36,0x37,
0x38,0x38,0x37,0x37,0x37,0x37,0x38,0x38,0x38,0x3a,0x3a,0x38,0x38,0x38,0x3a,0x38,
0x39,0x38,0x38,0x38,0x35,0x31,0x33,0x3a,0x4a,0x5f,0x78,0x8f,0x9f,0xa3,0x9d,0x92,
0x83,0x75,0x65,0x5b,0x4e,0x40,0x35,0x2a,0x26,0x2c,0x34,0x3a,0x40,0x3e,0x3a,0x36,
0x32,0x30,0x33,0x37,0x3c,0x3c,0x3a,0x37,0x37,0x39,0x3a,0x37,0x35,0x35,0x36,0x38,
0x38,0x38,0x3a,0x3a,0x39,0x39,0x3a,0x3a,0x3b,0x39,0x36,0x34,0x35,0x37,0x39,0x3d,
0x3d,0x39,0x35,0x34,0x37,0x40,0x48,0x4c,0x4b,0x45,0x3e,0x37,0x3d,0x4a,0x5c,0x6a,
0x68,0x57,0x47,0x3f,0x45,0x5a,0x72,0x82,0x83,0x70,0x56,0x47,0x4e,0x6a,0x8b,0x9d,
0x98,0x7d,0x5f,0x4c,0x53,0x71,0x94,0xa6,0xa0,0x82,0x5e,0x49,0x50,0x6e,0x91,0xa3,
0x9b,0x7e,0x5c,0x48,0x4f,0x6a,0x86,0x93,0x8a,0x6e,0x53,0x43,0x49,0x5b,0x70,0x76,
0x6e,0x5b,0x48,0x3e,0x41,0x4c,0x54,0x56,0x52,0x47,0x3b,0x38,0x38,0x3c,0x3f,0x40,
0x3f,0x3e,0x3d,0x3b,0x3a,0x39,0x39,0x38,0x37,0x34,0x36,0x38,0x39,0x37,0x36,0x37,
0x38,0x38,0x38,0x38,0x3a,0x38,0x36,0x35,0x36,0x38,0x3a,0x3a,0x3a,0x3a,0x3d,0x3d,
0x3a,0x36,0x35,0x36,0x37,0x35,0x36,0x38,0x38,0x38,0x38,0x37,0x38,0x38,0x39,0x36,
0x34,0x35,0x36,0x36,0x39,0x39,0x3a,0x3a,0x3a,0x38,0x3a,0x3a,0x3a,0x38,0x37,0x36,
0x35,0x35,0x35,0x38,0x3a,0x3a,0x38,0x36,0x34,0x35,0x36,0x36,0x37,0x38,0x37,0x35,
0x34,0x35,0x37,0x39,0x39,0x38,0x38,0x38,0x3a,0x3c,0x42,0x4a,0x55,0x64,0x74,0x81,
0x8f,0x9c,0xa6,0xaf,0xb6,0xbb,0xbf,0xc3,0xc2,0xc0,0xbd,0xbb,0xb9,0xb8,0xb9,0xb9,
0xbc,0xbd,0xbc,0xbc,0xbc,0xbd,0xbe,0xbf,0xbe,0xbd,0xbd,0xbb,0xbb,0xbb,0xbc,0xbb,
0xb9,0xb8,0xb8,0xba,0xbb,0xba,0xbc,0xba,0xba,0xbb,0xbb,0xbc,0xbc,0xbc,0xbc,0xbd,
0xbd,0xbd,0xbc,0xbd,0xb9,0xb6,0xb8,0xb8,0xb9,0xbb,0xbc,0xbc,0xbd,0xbd,0xbd,0xbe,
0xbf,0xbd,0xbd,0xbd,0xbe,0xbb,0xba,0xbb,0xbc,0xbd,0xbd,0xbc,0xbb,0xbb,0xbc,0xbd,
0xbc,0xba,0xba,0xb9,0xb9,0xb9,0xbd,0xbf,0xc0,0xbe,0xbc,0xba,0xbc,0xbd,0xbd,0xbc,
0xbc,0xba,0xb9,0xb9,0xba,0xbc,0xbd,0xbd,0xbe,0xbd,0xbd,0xbc,0xbc,0xbc,0xbd,0xbe,
0xbe,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbd,0xbe,0xbe,0xbc,0xba,0xba,0xbb,0xbc,0xbd,
0xbc,0xbb,0xbc,0xbd,0xbb,0xba,0xbc,0xbd,0xbe,0xbd,0xbd,0xbd,0xbe,0xbc,0xbc,0xbc,
0xbc,0xbb,0xbc,0xba,0xba,0xbc,0xbc,0xbc,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbc,0xbc,
0xbb,0xba,0xbc,0xbd,0xc0,0xbf,0xbe,0xbd,0xbd,0xbd,0xbc,0xbb,0xba,0xba,0xbc,0xbd,
0xbd,0xbb,0xba,0xba,0xbb,0xbc,0xbd,0xbe,0xbd,0xba,0xb7,0xb9,0xba,0xbb,0xbe,0xbf,
0xbf,0xbe,0xbd,0xbe,0xc1,0xc1,0xc0,0xbe,0xbd,0xbe,0xbe,0xbe,0xbd,0xbc,0xbd,0xbc,
0xba,0xb8,0xb9,0xba,0xba,0xb8,0xb8,0xb8,0xb9,0xb9,0xb9,0xbb,0xbd,0xbd,0xbe,0xbd,
0xbc,0xbe,0xbe,0xbd,0xbc,0xbd,0xbf,0xc0,0xbf,0xbd,0xbc,0xbd,0xbc,0xbc,0xbd,0xbd,
0xbd,0xbc,0xb9,0xb8,0xba,0xbb,0xbc,0xba,0xb9,0xb8,0xb9,0xba,0xbc,0xbc,0xbe,0xbc,
0xba,0xb9,0xb9,0xbb,0xbc,0xbc,0xba,0xbc,0xbc,0xbc,0xbb,0xbd,0xbd,0xbe,0xbe,0xbd,
0xbc,0xbc,0xba,0xb8,0xb8,0xbb,0xbc,0xbe,0xbd,0xbc,0xbd,0xbd,0xbd,0xbe,0xbe,0xbe,
0xbf,0xbe,0xbf,0xbe,0xbe,0xbe,0xbf,0xbf,0xbe,0xbd,0xbd,0xbc,0xb9,0xb9,0xb9,0xb9,
0xba,0xb9,0xbb,0xbc,0xbc,0xbb,0xba,0xbb,0xbc,0xbb,0xba,0xbc,0xbd,0xbd,0xbc,0xbd,
0xbf,0xc0,0xc0,0xbf,0xbe,0xbe,0xbf,0xbf,0xbf,0xbf,0xc0,0xc0,0xbf,0xbe,0xbd,0xbe,
0xbe,0xbc,0xba,0xbb,0xbc,0xbc,0xbc,0xbb,0xbc,0xbe,0xbf,0xc0,0xbf,0xbe,0xbe,0xbe,
0xbd,0xbc,0xbd,0xbe,0xbd,0xbc,0xbe,0xbe,0xbd,0xbe,0xbe,0xbe,0xc0,0xbe,0xbe,0xbd,
0xbd,0xbc,0xba,0xba,0xbb,0xba,0xbc,0xba,0xb9,0xbc,0xbe,0xc0,0xc0,0xbe,0xbf,0xc0,
0xbf,0xbd,0xbd,0xbe,0xbe,0xbe,0xbd,0xbe,0xbe,0xbd,0xbc,0xba,0xbc,0xbc,0xbc,0xbb,
0xba,0xba,0xba,0xba,0xbb,0xbc,0xbc,0xbd,0xbd,0xb9,0xb8,0xba,0xbc,0xbc,0xbc,0xbd,
0xbe,0xbd,0xba,0xb8,0xb8,0xbc,0xbd,0xbd,0xbd,0xbd,0xbd,0xbe,0xbe,0xbf,0xc1,0xc0,
0xbe,0xbc,0xbe,0xbe,0xbd,0xbe,0xbd,0xbd,0xbe,0xbd,0xbc,0xbd,0xbc,0xba,0xbb,0xbb,
0xbc,0xbb,0xbc,0xbc,0xb9,0xba,0xbc,0xbd,0xbd,0xbc,0xbd,0xbe,0xbe,0xbd,0xbd,0xbe,
0xbd,0xbb,0xb9,0xb9,0xbb,0xbb,0xba,0xbb,0xbd,0xbd,0xbb,0xba,0xb9,0xb8,0xbc,0xbd,
0xbe,0xbe,0xbe,0xbe,0xbd,0xbc,0xbb,0xbc,0xbe,0xbd,0xbc,0xbc,0xbd,0xbe,0xc0,0xbe,
0xbb,0xbd,0xbe,0xbe,0xbe,0xbc,0xba,0xb8,0xb6,0xb4,0xb1,0xae,0xa6,0x9b,0x8e,0x7f,
0x71,0x65,0x5a,0x50,0x4a,0x44,0x3f,0x39,0x35,0x33,0x35,0x37,0x37,0x38,0x3a,0x39,
// Line 19
0x36,0x34,0x35,0x36,0x38,0x38,0x38,0x36,0x35,0x36,0x38,0x3a,0x39,0x36,0x35,0x35,
0x34,0x33,0x35,0x38,0x3b,0x3d,0x3f,0x43,0x49,0x4e,0x51,0x54,0x58,0x5d,0x60,0x60,
0x61,0x62,0x64,0x64,0x63,0x63,0x64,0x64,0x63,0x60,0x60,0x60,0x60,0x5e,0x60,0x62,
0x64,0x62,0x62,0x61,0x60,0x62,0x60,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x60,0x64,0x65,
0x63,0x62,0x62,0x62,0x61,0x62,0x61,0x60,0x62,0x62,0x61,0x60,0x61,0x61,0x61,0x5f,
0x5e,0x5e,0x5f,0x5f,0x60,0x62,0x62,0x60,0x5f,0x60,0x60,0x62,0x62,0x60,0x61,0x61,
0x60,0x60,0x60,0x62,0x63,0x64,0x62,0x60,0x5f,0x61,0x61,0x62,0x61,0x60,0x61,0x61,
0x5e,0x5c,0x5d,0x5f,0x5f,0x5f,0x5e,0x5d,0x5c,0x5b,0x5b,0x5d,0x5f,0x61,0x62,0x60,
0x5d,0x5e,0x5f,0x60,0x62,0x62,0x62,0x62,0x5f,0x5d,0x5d,0x5f,0x5f,0x61,0x62,0x62,
0x5e,0x5e,0x5d,0x5c,0x5d,0x5d,0x5d,0x60,0x5d,0x5d,0x5e,0x5d,0x5d,0x5e,0x5e,0x5d,
0x5c,0x5b,0x5d,0x5e,0x5d,0x5c,0x5c,0x5d,0x5d,0x5c,0x5a,0x5a,0x5a,0x5a,0x59,0x58,
0x58,0x57,0x56,0x55,0x55,0x57,0x58,0x57,0x55,0x54,0x52,0x50,0x50,0x4f,0x4f,0x50,
0x52,0x52,0x50,0x50,0x4f,0x4f,0x50,0x4e,0x4d,0x4a,0x49,0x44,0x41,0x41,0x43,0x42,
0x40,0x3e,0x3c,0x3c,0x3b,0x3a,0x3b,0x3b,0x3b,0x3a,0x37,0x35,0x33,0x32,0x31,0x31,
0x31,0x32,0x33,0x31,0x30,0x31,0x34,0x32,0x30,0x2f,0x2f,0x2d,0x2d,0x2c,0x2f,0x2e,
0x31,0x31,0x32,0x36,0x39,0x3a,0x3e,0x41,0x43,0x46,0x49,0x4b,0x50,0x55,0x58,0x5c,
0x5e,0x60,0x63,0x66,0x69,0x6d,0x74,0x7d,0x82,0x83,0x86,0x8a,0x8f,0x91,0x92,0x94,
0x96,0x97,0x98,0x98,0x99,0x9a,0x9a,0x96,0x92,0x8f,0x8e,0x8b,0x88,0x82,0x7c,0x78,
0x71,0x69,0x64,0x60,0x5b,0x57,0x50,0x49,0x43,0x3e,0x3a,0x37,0x35,0x31,0x2f,0x2e,
0x2d,0x2c,0x2f,0x30,0x31,0x36,0x3b,0x3f,0x44,0x4a,0x52,0x5a,0x5e,0x62,0x6a,0x73,
0x7c,0x83,0x89,0x8e,0x92,0x95,0x97,0x98,0x98,0x95,0x8f,0x8b,0x84,0x7c,0x76,0x6f,
0x66,0x5d,0x54,0x4c,0x42,0x3d,0x38,0x35,0x34,0x30,0x2d,0x2e,0x2f,0x30,0x34,0x39,
0x41,0x47,0x51,0x58,0x60,0x6b,0x78,0x85,0x8e,0x93,0x95,0x97,0x97,0x93,0x8e,0x87,
0x7f,0x76,0x6b,0x5e,0x54,0x4c,0x45,0x3e,0x39,0x34,0x2f,0x2e,0x2f,0x32,0x37,0x3c,
0x43,0x4b,0x54,0x5e,0x6b,0x78,0x82,0x87,0x8d,0x8d,0x8b,0x89,0x86,0x7f,0x79,0x6b,
0x5e,0x54,0x4a,0x40,0x3b,0x37,0x35,0x35,0x34,0x36,0x3b,0x43,0x4d,0x59,0x66,0x74,
0x80,0x89,0x8d,0x8e,0x8d,0x8a,0x82,0x77,0x6a,0x5e,0x53,0x48,0x3f,0x39,0x36,0x33,
0x32,0x37,0x3e,0x47,0x51,0x5c,0x69,0x79,0x84,0x8b,0x90,0x90,0x8b,0x82,0x77,0x6b,
0x5d,0x50,0x44,0x3a,0x33,0x30,0x31,0x36,0x3e,0x48,0x56,0x64,0x73,0x81,0x89,0x8c,
0x8d,0x89,0x82,0x75,0x69,0x5a,0x4d,0x42,0x38,0x31,0x2e,0x30,0x36,0x43,0x51,0x5f,
0x6f,0x7b,0x84,0x8b,0x8b,0x85,0x79,0x72,0x66,0x57,0x4a,0x3e,0x34,0x30,0x2f,0x36,
0x44,0x56,0x69,0x7b,0x85,0x89,0x88,0x82,0x7a,0x70,0x64,0x54,0x46,0x3a,0x31,0x2e,
0x31,0x3b,0x4c,0x61,0x73,0x80,0x87,0x88,0x84,0x7f,0x74,0x67,0x5a,0x4e,0x42,0x39,
0x36,0x3b,0x46,0x57,0x68,0x77,0x84,0x8a,0x87,0x80,0x74,0x67,0x5a,0x4c,0x40,0x36,
0x31,0x32,0x3d,0x50,0x65,0x77,0x84,0x88,0x85,0x7c,0x71,0x64,0x57,0x49,0x3f,0x39,
0x38,0x3f,0x4d,0x62,0x74,0x83,0x88,0x85,0x7a,0x71,0x62,0x51,0x45,0x3d,0x3a,0x3c,
0x44,0x51,0x64,0x75,0x7f,0x84,0x7f,0x73,0x64,0x55,0x49,0x40,0x39,0x37,0x3f,0x4e,
0x60,0x71,0x81,0x88,0x87,0x7e,0x70,0x5e,0x4d,0x42,0x3f,0x41,0x48,0x53,0x62,0x71,
0x7c,0x7e,0x7c,0x70,0x61,0x52,0x46,0x3e,0x3f,0x44,0x50,0x62,0x71,0x7a,0x7e,0x7c,
0x76,0x68,0x59,0x48,0x3d,0x3f,0x46,0x50,0x5d,0x6b,0x77,0x7d,0x79,0x6c,0x5d,0x51,
0x49,0x45,0x49,0x52,0x5d,0x6d,0x75,0x78,0x78,0x72,0x67,0x5a,0x4b,0x41,0x44,0x4b,
0x57,0x65,0x71,0x76,0x76,0x6f,0x66,0x5c,0x53,0x4d,0x4d,0x56,0x5e,0x67,0x6d,0x6f,
0x6b,0x64,0x5a,0x4e,0x47,0x48,0x4e,0x57,0x60,0x6a,0x71,0x74,0x6d,0x64,0x5d,0x58,
0x54,0x54,0x58,0x60,0x69,0x6d,0x6c,0x66,0x5c,0x54,0x50,0x4f,0x52,0x59,0x62,0x6a,
0x6d,0x6d,0x6a,0x65,0x5e,0x57,0x55,0x59,0x5e,0x62,0x66,0x67,0x65,0x61,0x5a,0x55,
0x54,0x5a,0x5e,0x61,0x65,0x67,0x66,0x62,0x5a,0x54,0x55,0x5a,0x5e,0x62,0x65,0x66,
0x62,0x5c,0x58,0x56,0x5a,0x5e,0x64,0x69,0x6a,0x69,0x63,0x5b,0x55,0x53,0x55,0x5b,
0x62,0x67,0x6b,0x6a,0x63,0x59,0x53,0x51,0x55,0x5c,0x67,0x6f,0x71,0x6b,0x5d,0x4d,
0x48,0x49,0x53,0x62,0x6e,0x74,0x71,0x64,0x52,0x46,0x44,0x4d,0x5d,0x6e,0x7a,0x79,
0x6d,0x58,0x46,0x3f,0x45,0x55,0x69,0x77,0x7b,0x72,0x60,0x4c,0x41,0x43,0x51,0x62,
0x73,0x7c,0x78,0x66,0x4d,0x3c,0x3c,0x4c,0x64,0x79,0x82,0x7a,0x66,0x4d,0x3b,0x38,
0x47,0x60,0x77,0x81,0x78,0x62,0x4b,0x3c,0x3c,0x4f,0x6b,0x80,0x86,0x79,0x5f,0x45,
0x37,0x3c,0x54,0x71,0x84,0x84,0x72,0x55,0x3f,0x3a,0x48,0x62,0x7b,0x86,0x7d,0x5f,
0x41,0x31,0x3a,0x55,0x71,0x83,0x86,0x71,0x53,0x3b,0x39,0x4d,0x6c,0x83,0x88,0x79,
0x5b,0x40,0x35,0x44,0x5e,0x79,0x84,0x78,0x59,0x41,0x34,0x3f,0x5c,0x79,0x88,0x7f,
0x65,0x45,0x37,0x41,0x5d,0x78,0x84,0x79,0x62,0x45,0x36,0x3f,0x5c,0x79,0x84,0x79,
0x5e,0x44,0x3c,0x48,0x61,0x79,0x82,0x73,0x57,0x3e,0x37,0x4a,0x66,0x7c,0x7c,0x6b,
0x4d,0x3a,0x3d,0x53,0x6f,0x84,0x7d,0x64,0x49,0x3c,0x48,0x5f,0x79,0x82,0x77,0x5c,
0x44,0x3f,0x50,0x6b,0x7c,0x7a,0x67,0x50,0x44,0x4b,0x60,0x76,0x7e,0x74,0x5e,0x4a,
0x48,0x5a,0x71,0x7d,0x76,0x63,0x4e,0x46,0x52,0x67,0x77,0x79,0x6a,0x54,0x48,0x4e,
0x62,0x73,0x79,0x6d,0x5a,0x4b,0x4b,0x58,0x6a,0x73,0x6e,0x60,0x50,0x4d,0x5a,0x6c,
0x76,0x73,0x66,0x57,0x51,0x56,0x64,0x6f,0x6e,0x64,0x57,0x4f,0x53,0x5f,0x6d,0x6e,
0x67,0x5a,0x53,0x54,0x5e,0x68,0x6b,0x66,0x5b,0x54,0x57,0x61,0x6a,0x6b,0x68,0x60,
0x5b,0x5d,0x64,0x6b,0x6d,0x69,0x60,0x5c,0x5d,0x64,0x6a,0x6a,0x65,0x5f,0x5d,0x5d,
0x62,0x68,0x68,0x62,0x5d,0x59,0x5b,0x61,0x65,0x64,0x62,0x5d,0x5a,0x5d,0x62,0x67,
0x6a,0x67,0x61,0x5d,0x5e,0x63,0x67,0x68,0x65,0x5f,0x5e,0x60,0x62,0x66,0x67,0x67,
0x62,0x5e,0x5c,0x5e,0x61,0x63,0x5d,0x5d,0x5b,0x5b,0x5e,0x62,0x62,0x65,0x62,0x5e,
0x5f,0x5f,0x61,0x62,0x62,0x60,0x61,0x62,0x64,0x64,0x62,0x63,0x62,0x62,0x61,0x60,
0x62,0x60,0x5d,0x5d,0x5e,0x5f,0x61,0x5f,0x5e,0x5e,0x5e,0x5e,0x5e,0x5f,0x5f,0x5e,
0x5d,0x5c,0x5c,0x5e,0x60,0x61,0x63,0x63,0x62,0x64,0x63,0x62,0x62,0x63,0x63,0x61,
0x60,0x60,0x61,0x61,0x60,0x60,0x63,0x64,0x62,0x61,0x5f,0x60,0x60,0x5f,0x5e,0x60,
0x62,0x62,0x61,0x5f,0x5e,0x5f,0x62,0x62,0x62,0x62,0x63,0x62,0x62,0x61,0x62,0x62,
0x61,0x60,0x60,0x60,0x5f,0x5e,0x5e,0x5f,0x60,0x62,0x61,0x5f,0x60,0x5f,0x5f,0x62,
0x63,0x65,0x67,0x64,0x60,0x60,0x63,0x65,0x64,0x62,0x60,0x60,0x5f,0x5e,0x5d,0x5d,
0x5e,0x5d,0x5c,0x5d,0x5e,0x5e,0x5e,0x5f,0x61,0x61,0x62,0x62,0x62,0x61,0x61,0x60,
0x5e,0x5c,0x5c,0x5c,0x5d,0x5e,0x5f,0x60,0x5f,0x5e,0x5d,0x5e,0x62,0x63,0x62,0x63,
0x61,0x5e,0x5e,0x5f,0x5e,0x5f,0x60,0x60,0x5f,0x5e,0x60,0x62,0x62,0x60,0x61,0x62,
0x63,0x62,0x61,0x61,0x61,0x60,0x60,0x5f,0x5f,0x60,0x62,0x62,0x62,0x60,0x5f,0x5f,
0x5e,0x5e,0x61,0x64,0x65,0x63,0x60,0x60,0x61,0x62,0x62,0x66,0x64,0x62,0x60,0x5e,
0x5e,0x5f,0x62,0x63,0x63,0x63,0x64,0x63,0x61,0x61,0x62,0x63,0x62,0x5e,0x5d,0x5c,
0x5b,0x5c,0x5b,0x5d,0x5e,0x5e,0x5e,0x5d,0x5e,0x60,0x60,0x60,0x5f,0x5f,0x5f,0x5d,
0x5d,0x5f,0x61,0x61,0x61,0x60,0x62,0x62,0x62,0x60,0x61,0x62,0x62,0x62,0x62,0x61,
0x60,0x62,0x62,0x60,0x60,0x60,0x60,0x60,0x5f,0x5f,0x60,0x60,0x5e,0x5d,0x5f,0x62,
0x62,0x60,0x5f,0x5e,0x5f,0x5f,0x5f,0x5f,0x5f,0x5e,0x5e,0x5c,0x5d,0x5f,0x61,0x62,
0x61,0x62,0x63,0x64,0x64,0x64,0x65,0x67,0x67,0x66,0x66,0x65,0x64,0x63,0x60,0x5f,
0x5d,0x60,0x61,0x60,0x5f,0x5d,0x5d,0x5e,0x5d,0x5d,0x5f,0x5e,0x5c,0x5d,0x5e,0x61,
0x63,0x64,0x65,0x65,0x62,0x5f,0x5f,0x60,0x62,0x61,0x5f,0x5c,0x5b,0x5c,0x5d,0x5d,
0x5f,0x60,0x60,0x5f,0x5f,0x62,0x63,0x65,0x64,0x64,0x64,0x63,0x62,0x60,0x62,0x62,
0x62,0x61,0x5e,0x60,0x5e,0x5f,0x5e,0x5e,0x5e,0x5f,0x5f,0x5e,0x5d,0x60,0x62,0x60,
0x5f,0x5a,0x54,0x4e,0x48,0x43,0x3f,0x3c,0x39,0x37,0x35,0x34,0x34,0x34,0x34,0x33,
0x33,0x34,0x36,0x36,0x35,0x34,0x37,0x37,0x36,0x36,0x37,0x38,0x37,0x35,0x35,0x34,
0x35,0x34,0x33,0x33,0x33,0x34,0x35,0x35,0x33,0x35,0x36,0x36,0x36,0x36,0x35,0x36,
0x36,0x36,0x35,0x34,0x33,0x32,0x33,0x34,0x34,0x33,0x34,0x32,0x34,0x34,0x34,0x34,
0x36,0x36,0x36,0x35,0x35,0x35,0x36,0x37,0x36,0x36,0x37,0x38,0x37,0x34,0x34,0x38,
0x39,0x37,0x37,0x35,0x34,0x35,0x36,0x36,0x36,0x36,0x37,0x37,0x37,0x37,0x35,0x35,
0x34,0x33,0x34,0x35,0x35,0x36,0x35,0x34,0x35,0x37,0x37,0x37,0x37,0x35,0x34,0x32,
// Line 20
0x39,0x39,0x3a,0x39,0x37,0x36,0x37,0x38,0x39,0x3a,0x3a,0x37,0x37,0x39,0x3a,0x39,
0x37,0x37,0x38,0x37,0x35,0x34,0x33,0x32,0x32,0x34,0x36,0x3d,0x45,0x4e,0x58,0x65,
0x72,0x83,0x94,0xa2,0xac,0xb3,0xb9,0xbd,0xbf,0xc1,0xc2,0xc2,0xc2,0xc1,0xc0,0xc1,
0xbd,0xbb,0xbc,0xbe,0xbe,0xbd,0xbc,0xbb,0xbb,0xbc,0xbc,0xb9,0xbf,0xbe,0xbf,0xc0,
0xc0,0xbe,0xbd,0xbc,0xbb,0xbb,0xbc,0xbd,0xbd,0xbd,0xbc,0xbd,0xbe,0xbf,0xc1,0xc2,
0xc3,0xc1,0xc0,0xbf,0xbf,0xc0,0xbf,0xbd,0xbf,0xbe,0xbd,0xbd,0xbb,0xbb,0xbc,0xbd,
0xbd,0xbb,0xbc,0xbd,0xbf,0xc0,0xc0,0xc0,0xc3,0xbf,0xbd,0xbd,0xbd,0xbd,0xbc,0xbb,
0xb9,0xba,0xbb,0xbc,0xbc,0xbd,0xbd,0xbe,0xbf,0xbd,0xbd,0xbd,0xbc,0xba,0xba,0xbb,
0xbb,0xbb,0xba,0xb9,0xbb,0xbb,0xbd,0xbd,0xbe,0xbe,0xbe,0xbe,0xbc,0xbb,0xbd,0xbe,
0xbe,0xc0,0xbf,0xbf,0xbe,0xc0,0xbf,0xc0,0xc0,0xbe,0xbc,0xbc,0xbb,0xbb,0xbb,0xbb,
0xbb,0xbb,0xbb,0xba,0xbb,0xbc,0xbe,0xbf,0xbd,0xbb,0xbd,0xbe,0xbe,0xbe,0xbf,0xbf,
0xbd,0xbc,0xbd,0xbf,0xc0,0xc0,0xbe,0xbc,0xbb,0xbb,0xbd,0xbd,0xbe,0xbf,0xbf,0xbd,
0xbb,0xb9,0xba,0xbb,0xba,0xb5,0xaf,0xac,0xa1,0x96,0x90,0x8a,0x84,0x7f,0x78,0x72,
0x71,0x70,0x6f,0x6c,0x6d,0x6d,0x6f,0x70,0x70,0x6f,0x71,0x70,0x6f,0x6f,0x71,0x73,
0x73,0x71,0x70,0x70,0x71,0x71,0x71,0x72,0x73,0x72,0x73,0x73,0x74,0x75,0x75,0x73,
0x72,0x71,0x71,0x72,0x70,0x6e,0x70,0x70,0x70,0x6f,0x6d,0x6d,0x6f,0x6f,0x6f,0x6e,
0x6e,0x6d,0x6d,0x6e,0x6f,0x6f,0x6f,0x6d,0x6d,0x6f,0x73,0x77,0x7a,0x7f,0x85,0x8b,
0x8f,0x93,0x95,0x98,0x98,0x96,0x97,0x98,0x98,0x97,0x92,0x8e,0x8b,0x89,0x87,0x83,
0x7f,0x7a,0x75,0x70,0x6a,0x65,0x63,0x61,0x5e,0x5a,0x56,0x53,0x4f,0x4c,0x4a,0x4a,
0x4a,0x49,0x49,0x48,0x46,0x45,0x48,0x4c,0x4e,0x51,0x54,0x56,0x5a,0x5f,0x65,0x6c,
0x71,0x75,0x79,0x7e,0x80,0x82,0x86,0x89,0x8e,0x91,0x95,0x97,0x99,0x9b,0x9d,0x9f,
0x9e,0x9b,0x9b,0x97,0x90,0x8d,0x89,0x88,0x84,0x82,0x7e,0x79,0x75,0x70,0x6c,0x68,
0x62,0x5a,0x57,0x54,0x51,0x4f,0x4e,0x4b,0x48,0x47,0x46,0x44,0x44,0x44,0x44,0x48,
0x49,0x4a,0x4d,0x52,0x56,0x5b,0x5f,0x63,0x67,0x6a,0x6d,0x73,0x78,0x7c,0x81,0x87,
0x8b,0x8f,0x91,0x91,0x93,0x96,0x99,0x9a,0x9b,0x9a,0x9b,0x9a,0x96,0x91,0x90,0x90,
0x8f,0x8a,0x86,0x7e,0x78,0x75,0x71,0x6b,0x67,0x63,0x5e,0x59,0x54,0x53,0x51,0x4f,
0x4c,0x4a,0x4a,0x49,0x46,0x48,0x46,0x46,0x48,0x48,0x49,0x4d,0x51,0x55,0x59,0x5e,
0x63,0x67,0x6d,0x70,0x76,0x7b,0x7f,0x82,0x86,0x89,0x8e,0x92,0x94,0x94,0x95,0x97,
0x98,0x9b,0x9b,0x9a,0x98,0x94,0x90,0x8e,0x8a,0x87,0x83,0x7e,0x7b,0x78,0x76,0x74,
0x71,0x6e,0x6a,0x65,0x60,0x5b,0x57,0x54,0x4f,0x49,0x46,0x47,0x48,0x47,0x45,0x44,
0x47,0x4c,0x4e,0x51,0x59,0x5f,0x64,0x68,0x69,0x6c,0x6f,0x71,0x71,0x71,0x71,0x71,
0x6e,0x6e,0x6f,0x6f,0x73,0x73,0x72,0x72,0x6f,0x6c,0x6d,0x6f,0x72,0x73,0x73,0x72,
0x6f,0x71,0x72,0x73,0x73,0x71,0x71,0x71,0x6f,0x6d,0x6f,0x70,0x71,0x71,0x70,0x6f,
0x6f,0x6f,0x6f,0x6f,0x6f,0x70,0x73,0x74,0x74,0x73,0x73,0x71,0x6f,0x6f,0x6e,0x6d,
0x6d,0x6e,0x6f,0x6e,0x6f,0x6e,0x6f,0x71,0x72,0x71,0x71,0x70,0x71,0x73,0x73,0x72,
0x72,0x71,0x6f,0x6d,0x67,0x62,0x5d,0x59,0x55,0x54,0x55,0x58,0x5c,0x61,0x67,0x6f,
0x7a,0x86,0x8e,0x91,0x91,0x8e,0x89,0x83,0x7c,0x75,0x6e,0x63,0x59,0x52,0x51,0x51,
0x51,0x53,0x57,0x5d,0x62,0x67,0x71,0x7b,0x83,0x8b,0x90,0x90,0x8d,0x89,0x83,0x7c,
0x72,0x68,0x5d,0x57,0x51,0x4c,0x4c,0x4b,0x4d,0x53,0x57,0x5c,0x65,0x6f,0x7b,0x86,
0x8a,0x8b,0x8d,0x8e,0x8e,0x88,0x7f,0x74,0x69,0x60,0x56,0x4c,0x46,0x45,0x48,0x4c,
0x50,0x55,0x5e,0x67,0x71,0x7b,0x86,0x8e,0x93,0x93,0x8d,0x87,0x80,0x79,0x71,0x68,
0x5f,0x56,0x4e,0x48,0x45,0x44,0x4b,0x51,0x57,0x5f,0x6b,0x74,0x80,0x86,0x8e,0x94,
0x93,0x8e,0x88,0x7f,0x77,0x6e,0x63,0x59,0x51,0x4c,0x46,0x44,0x46,0x4c,0x54,0x5c,
0x62,0x6b,0x77,0x81,0x89,0x8f,0x93,0x92,0x8f,0x88,0x80,0x76,0x6c,0x63,0x5b,0x53,
0x4d,0x48,0x4b,0x4c,0x4d,0x56,0x5e,0x65,0x6b,0x71,0x7b,0x86,0x8c,0x8a,0x86,0x83,
0x7e,0x79,0x75,0x72,0x70,0x6f,0x6c,0x69,0x69,0x6b,0x6b,0x6b,0x6c,0x6d,0x6f,0x71,
0x71,0x71,0x70,0x6f,0x6f,0x70,0x71,0x72,0x71,0x6e,0x6b,0x6c,0x6e,0x6f,0x73,0x71,
0x6f,0x6e,0x6d,0x6c,0x6d,0x70,0x73,0x73,0x72,0x72,0x72,0x72,0x72,0x74,0x75,0x77,
0x75,0x70,0x6d,0x6c,0x6e,0x6e,0x6e,0x6f,0x70,0x6f,0x6f,0x6f,0x72,0x75,0x77,0x75,
0x72,0x72,0x6f,0x6c,0x6b,0x69,0x68,0x68,0x65,0x64,0x67,0x6d,0x73,0x7a,0x80,0x83,
0x82,0x7b,0x72,0x67,0x60,0x5b,0x58,0x59,0x5b,0x5e,0x6a,0x76,0x7f,0x84,0x87,0x83,
0x7b,0x70,0x64,0x57,0x4f,0x4b,0x4f,0x5a,0x67,0x76,0x83,0x8b,0x8d,0x89,0x80,0x75,
0x6b,0x60,0x58,0x54,0x53,0x58,0x62,0x6f,0x7b,0x83,0x89,0x88,0x82,0x76,0x68,0x5c,
0x55,0x50,0x51,0x56,0x5e,0x6b,0x79,0x85,0x8b,0x89,0x87,0x7c,0x6f,0x64,0x5b,0x54,
0x52,0x54,0x5d,0x6b,0x78,0x84,0x8c,0x8d,0x87,0x7e,0x6f,0x61,0x56,0x50,0x4c,0x4d,
0x55,0x63,0x74,0x82,0x8b,0x8f,0x8f,0x88,0x7b,0x6e,0x63,0x59,0x53,0x4f,0x54,0x5e,
0x6b,0x78,0x83,0x8a,0x88,0x81,0x76,0x6b,0x64,0x5f,0x5c,0x5a,0x5a,0x5d,0x63,0x6c,
0x72,0x77,0x7b,0x7b,0x78,0x74,0x70,0x6f,0x6f,0x70,0x6f,0x6d,0x70,0x73,0x73,0x71,
0x6f,0x6e,0x6e,0x6e,0x6f,0x6f,0x73,0x73,0x72,0x71,0x72,0x71,0x74,0x71,0x6d,0x6e,
0x6d,0x6c,0x6d,0x6f,0x71,0x74,0x74,0x74,0x74,0x75,0x75,0x74,0x72,0x70,0x6d,0x6a,
0x67,0x68,0x6f,0x77,0x7c,0x7b,0x74,0x6b,0x64,0x61,0x64,0x6b,0x74,0x7a,0x7b,0x76,
0x6b,0x61,0x5d,0x60,0x68,0x74,0x7c,0x7d,0x77,0x6d,0x64,0x5f,0x60,0x67,0x71,0x7b,
0x7e,0x78,0x70,0x66,0x5f,0x5f,0x64,0x6c,0x78,0x7f,0x80,0x79,0x6e,0x63,0x5e,0x5f,
0x67,0x72,0x7c,0x81,0x7d,0x75,0x69,0x60,0x5d,0x63,0x6d,0x79,0x81,0x82,0x7a,0x6f,
0x62,0x5a,0x5b,0x64,0x6d,0x79,0x7c,0x77,0x6f,0x64,0x5b,0x5a,0x5d,0x68,0x75,0x7e,
0x7f,0x77,0x6b,0x5f,0x5b,0x5d,0x68,0x75,0x82,0x87,0x83,0x78,0x69,0x5e,0x5c,0x61,
0x6d,0x79,0x7f,0x80,0x79,0x6d,0x63,0x5d,0x61,0x6a,0x72,0x7b,0x78,0x6f,0x68,0x64,
0x65,0x6d,0x75,0x7a,0x7f,0x7b,0x73,0x69,0x65,0x66,0x6e,0x75,0x77,0x77,0x75,0x71,
0x6e,0x6c,0x6d,0x6f,0x6e,0x6c,0x6b,0x6d,0x70,0x72,0x74,0x73,0x73,0x72,0x71,0x71,
0x71,0x73,0x75,0x74,0x72,0x71,0x6f,0x6f,0x70,0x6f,0x70,0x70,0x6f,0x6d,0x6f,0x6f,
0x71,0x72,0x73,0x73,0x72,0x70,0x70,0x72,0x73,0x74,0x75,0x72,0x6d,0x6a,0x6c,0x72,
0x79,0x7b,0x7a,0x74,0x6c,0x63,0x61,0x69,0x77,0x82,0x83,0x7c,0x6e,0x63,0x5f,0x67,
0x78,0x88,0x8b,0x7e,0x6a,0x59,0x54,0x60,0x75,0x86,0x8a,0x7e,0x65,0x51,0x4b,0x59,
0x73,0x88,0x8c,0x7f,0x69,0x57,0x53,0x5f,0x77,0x8b,0x90,0x82,0x69,0x55,0x53,0x5f,
0x75,0x88,0x8c,0x7f,0x69,0x54,0x4f,0x5c,0x72,0x84,0x88,0x7c,0x67,0x57,0x53,0x5f,
0x74,0x87,0x8b,0x7e,0x68,0x57,0x56,0x63,0x78,0x8a,0x8f,0x81,0x69,0x56,0x51,0x5f,
0x75,0x87,0x8b,0x7e,0x68,0x55,0x52,0x5f,0x74,0x85,0x88,0x7b,0x67,0x54,0x51,0x5c,
0x70,0x80,0x88,0x81,0x71,0x5f,0x5c,0x62,0x6f,0x7a,0x7f,0x79,0x72,0x69,0x65,0x68,
0x6f,0x75,0x77,0x74,0x6e,0x6b,0x6b,0x6d,0x6f,0x6f,0x71,0x71,0x72,0x72,0x72,0x73,
0x70,0x6c,0x6b,0x6d,0x6f,0x72,0x72,0x6f,0x6e,0x6d,0x6c,0x6b,0x6c,0x6e,0x6f,0x6e,
0x6d,0x6b,0x6f,0x6e,0x6e,0x70,0x72,0x73,0x73,0x71,0x70,0x70,0x6f,0x6e,0x6f,0x71,
0x72,0x71,0x70,0x6d,0x6c,0x6e,0x71,0x71,0x70,0x6e,0x6b,0x6a,0x6a,0x6e,0x74,0x78,
0x77,0x6e,0x68,0x67,0x6c,0x72,0x77,0x77,0x73,0x6b,0x65,0x67,0x6f,0x78,0x7c,0x76,
0x6b,0x63,0x63,0x6a,0x72,0x79,0x79,0x73,0x6b,0x65,0x67,0x71,0x7a,0x7a,0x75,0x6c,
0x67,0x68,0x6e,0x77,0x7c,0x79,0x70,0x68,0x66,0x6c,0x76,0x7a,0x77,0x6d,0x67,0x65,
0x6b,0x75,0x7a,0x78,0x71,0x69,0x66,0x6b,0x73,0x79,0x77,0x6e,0x65,0x64,0x6b,0x74,
0x7a,0x78,0x6f,0x66,0x65,0x6a,0x75,0x7b,0x77,0x6d,0x67,0x67,0x70,0x78,0x7d,0x79,
0x6f,0x67,0x64,0x6a,0x77,0x7e,0x79,0x6e,0x64,0x62,0x6c,0x7a,0x83,0x80,0x73,0x65,
0x5f,0x64,0x72,0x7e,0x81,0x76,0x67,0x60,0x62,0x6c,0x79,0x7d,0x77,0x6c,0x62,0x5f,
0x67,0x72,0x7a,0x77,0x70,0x69,0x6b,0x73,0x79,0x78,0x78,0x6f,0x68,0x69,0x6b,0x70,
0x73,0x71,0x6b,0x68,0x6b,0x6f,0x74,0x74,0x6f,0x6b,0x6b,0x6b,0x6e,0x71,0x73,0x6f,
0x6c,0x6c,0x6f,0x72,0x73,0x71,0x6e,0x6c,0x6d,0x6f,0x71,0x72,0x71,0x6e,0x6b,0x68,
0x6d,0x71,0x72,0x72,0x70,0x6f,0x71,0x72,0x72,0x72,0x72,0x70,0x6e,0x6b,0x6c,0x6e,
0x6f,0x6d,0x6c,0x6d,0x6f,0x71,0x73,0x72,0x70,0x6f,0x6f,0x6e,0x6f,0x70,0x71,0x6f,
0x6c,0x6b,0x6d,0x70,0x71,0x71,0x70,0x6f,0x6f,0x6f,0x6f,0x6f,0x6e,0x6b,0x65,0x60,
0x5c,0x54,0x4c,0x47,0x41,0x3c,0x3a,0x38,0x35,0x35,0x34,0x33,0x35,0x37,0x3b,0x3c,
// Line 21
0x34,0x32,0x34,0x36,0x36,0x36,0x39,0x39,0x37,0x36,0x37,0x3c,0x3e,0x3c,0x3b,0x3a,
0x3c,0x3c,0x3b,0x3c,0x3b,0x39,0x38,0x36,0x38,0x38,0x38,0x37,0x38,0x37,0x37,0x36,
0x36,0x35,0x35,0x37,0x37,0x37,0x38,0x38,0x37,0x37,0x38,0x3b,0x40,0x41,0x40,0x3f,
0x40,0x43,0x45,0x48,0x4a,0x4e,0x53,0x54,0x55,0x57,0x5b,0x5e,0x61,0x63,0x63,0x67,
0x68,0x65,0x64,0x65,0x67,0x66,0x66,0x65,0x66,0x66,0x63,0x5f,0x61,0x5e,0x5a,0x58,
0x56,0x53,0x51,0x4e,0x4a,0x49,0x48,0x47,0x45,0x42,0x40,0x3e,0x3e,0x3d,0x3c,0x3c,
0x3a,0x39,0x3b,0x3c,0x3c,0x3e,0x40,0x41,0x42,0x45,0x4a,0x4e,0x50,0x50,0x51,0x54,
0x55,0x55,0x56,0x59,0x5c,0x5f,0x60,0x61,0x62,0x63,0x65,0x66,0x67,0x68,0x67,0x68,
0x67,0x65,0x65,0x63,0x61,0x61,0x5e,0x5b,0x59,0x56,0x54,0x54,0x52,0x4d,0x4a,0x49,
0x49,0x47,0x44,0x40,0x3f,0x3e,0x3e,0x3b,0x3b,0x3b,0x3c,0x3d,0x3d,0x3a,0x3c,0x3e,
0x40,0x43,0x46,0x49,0x4b,0x4c,0x4d,0x4f,0x53,0x56,0x59,0x5c,0x5d,0x5e,0x61,0x63,
0x63,0x66,0x6a,0x6a,0x69,0x67,0x67,0x68,0x68,0x66,0x66,0x67,0x65,0x61,0x5f,0x5d,
0x5c,0x5b,0x58,0x54,0x51,0x4e,0x4a,0x48,0x46,0x44,0x43,0x40,0x3c,0x38,0x38,0x39,
0x38,0x38,0x38,0x38,0x3b,0x3c,0x3d,0x3e,0x42,0x44,0x46,0x47,0x49,0x4a,0x4d,0x4d,
0x4d,0x51,0x55,0x57,0x59,0x5b,0x5f,0x63,0x65,0x67,0x6a,0x69,0x67,0x67,0x68,0x6a,
0x6a,0x6c,0x69,0x65,0x62,0x61,0x5f,0x60,0x5e,0x5b,0x5b,0x58,0x55,0x52,0x51,0x4e,
0x4c,0x4a,0x49,0x47,0x45,0x40,0x3e,0x3f,0x3e,0x3c,0x3c,0x3d,0x3e,0x3e,0x3e,0x3d,
0x3e,0x3f,0x40,0x42,0x44,0x47,0x4a,0x4e,0x4f,0x50,0x54,0x59,0x59,0x59,0x5a,0x5c,
0x5f,0x61,0x63,0x63,0x68,0x67,0x68,0x68,0x69,0x69,0x69,0x68,0x65,0x63,0x61,0x5f,
0x60,0x5e,0x5b,0x5b,0x59,0x55,0x4f,0x49,0x46,0x46,0x46,0x46,0x45,0x42,0x3f,0x3b,
0x3b,0x3b,0x3d,0x3f,0x3e,0x3c,0x3c,0x3b,0x3b,0x3e,0x41,0x45,0x48,0x49,0x49,0x4b,
0x4e,0x50,0x53,0x57,0x59,0x5a,0x5c,0x5e,0x5f,0x63,0x64,0x65,0x64,0x65,0x65,0x66,
0x67,0x68,0x69,0x69,0x68,0x65,0x64,0x63,0x61,0x5f,0x5c,0x57,0x54,0x51,0x50,0x4e,
0x4b,0x4a,0x49,0x48,0x46,0x44,0x43,0x41,0x40,0x40,0x3e,0x3c,0x3c,0x3a,0x3b,0x3e,
0x3e,0x3f,0x3f,0x42,0x43,0x45,0x46,0x48,0x48,0x4c,0x4c,0x4d,0x51,0x56,0x5a,0x5e,
0x5d,0x5d,0x60,0x63,0x65,0x66,0x67,0x68,0x68,0x66,0x65,0x66,0x68,0x68,0x65,0x61,
0x5d,0x5b,0x5a,0x59,0x57,0x58,0x56,0x53,0x50,0x4d,0x4a,0x49,0x47,0x46,0x44,0x43,
0x40,0x3b,0x3c,0x3e,0x3d,0x3e,0x3c,0x3c,0x3d,0x3b,0x3b,0x39,0x38,0x38,0x3b,0x3b,
0x3b,0x39,0x38,0x38,0x38,0x38,0x38,0x39,0x3a,0x39,0x39,0x39,0x39,0x3a,0x3b,0x3c,
0x3b,0x3b,0x3a,0x3a,0x3b,0x3c,0x3b,0x39,0x3a,0x3b,0x39,0x3b,0x39,0x39,0x3d,0x3e,
0x3c,0x39,0x39,0x38,0x38,0x39,0x3a,0x39,0x39,0x38,0x38,0x39,0x3b,0x3c,0x3d,0x3b,
0x39,0x38,0x39,0x3a,0x39,0x39,0x3a,0x3c,0x3a,0x39,0x3a,0x3c,0x3c,0x39,0x38,0x38,
0x38,0x37,0x34,0x34,0x36,0x37,0x38,0x37,0x38,0x38,0x3a,0x3b,0x3b,0x3b,0x3e,0x3f,
0x3e,0x3e,0x3e,0x3d,0x3e,0x40,0x42,0x48,0x4b,0x4f,0x54,0x58,0x5d,0x63,0x67,0x6b,
0x6c,0x6d,0x6d,0x6b,0x6b,0x6a,0x68,0x67,0x65,0x65,0x68,0x6b,0x6d,0x6c,0x6a,0x67,
0x67,0x67,0x68,0x67,0x6a,0x69,0x68,0x67,0x67,0x67,0x6d,0x6c,0x6a,0x6b,0x6a,0x68,
0x67,0x67,0x6a,0x6c,0x6c,0x6b,0x6b,0x6b,0x6b,0x6a,0x6c,0x6c,0x6c,0x69,0x63,0x5c,
0x56,0x52,0x4d,0x47,0x43,0x40,0x3e,0x3d,0x3b,0x39,0x38,0x39,0x39,0x3a,0x39,0x39,
0x3b,0x39,0x39,0x3c,0x3c,0x3c,0x3c,0x3c,0x3a,0x38,0x37,0x38,0x3a,0x3b,0x39,0x35,
0x33,0x34,0x38,0x3a,0x39,0x38,0x38,0x37,0x36,0x34,0x35,0x38,0x3b,0x3c,0x3b,0x37,
0x35,0x36,0x39,0x3b,0x3b,0x39,0x3b,0x39,0x36,0x36,0x37,0x3a,0x3c,0x3a,0x37,0x35,
0x36,0x37,0x38,0x3d,0x3c,0x39,0x38,0x38,0x38,0x39,0x39,0x38,0x39,0x3a,0x39,0x38,
0x38,0x38,0x3a,0x3b,0x3b,0x39,0x38,0x37,0x37,0x35,0x34,0x34,0x35,0x36,0x36,0x38,
0x37,0x37,0x38,0x39,0x38,0x37,0x38,0x39,0x36,0x36,0x37,0x38,0x39,0x39,0x3b,0x3c,
0x3d,0x3e,0x43,0x48,0x4d,0x53,0x59,0x5d,0x61,0x64,0x67,0x68,0x68,0x68,0x6a,0x6b,
0x69,0x68,0x69,0x68,0x67,0x67,0x68,0x69,0x69,0x68,0x68,0x6a,0x6a,0x6b,0x6a,0x6c,
0x6c,0x6c,0x6c,0x6a,0x69,0x6a,0x6a,0x6a,0x6b,0x6b,0x6c,0x6d,0x6c,0x69,0x6a,0x6a,
0x6c,0x6a,0x68,0x68,0x69,0x69,0x67,0x65,0x62,0x5e,0x59,0x53,0x4f,0x4b,0x48,0x42,
0x3d,0x3a,0x3a,0x39,0x34,0x37,0x38,0x37,0x38,0x36,0x36,0x3b,0x3b,0x39,0x38,0x36,
0x34,0x33,0x33,0x33,0x36,0x39,0x3b,0x39,0x37,0x37,0x39,0x3c,0x3b,0x3b,0x3b,0x3b,
0x38,0x37,0x37,0x3a,0x3b,0x39,0x36,0x35,0x34,0x36,0x34,0x34,0x34,0x35,0x38,0x3a,
0x3c,0x40,0x44,0x48,0x4d,0x50,0x55,0x5a,0x5e,0x61,0x65,0x66,0x67,0x66,0x66,0x66,
0x67,0x67,0x68,0x67,0x6b,0x69,0x68,0x69,0x6a,0x6b,0x6c,0x6a,0x67,0x66,0x67,0x67,
0x68,0x69,0x68,0x6a,0x6b,0x6a,0x6a,0x6a,0x6a,0x6a,0x6b,0x6d,0x6e,0x6f,0x6e,0x6d,
0x6c,0x6b,0x6b,0x6a,0x6a,0x69,0x69,0x68,0x66,0x63,0x63,0x5e,0x57,0x52,0x4d,0x48,
0x44,0x40,0x3d,0x3b,0x39,0x37,0x35,0x38,0x39,0x3c,0x40,0x3e,0x39,0x36,0x35,0x34,
0x35,0x34,0x37,0x39,0x38,0x35,0x36,0x38,0x3c,0x3d,0x3d,0x3c,0x3b,0x3a,0x38,0x37,
0x38,0x39,0x39,0x39,0x38,0x38,0x38,0x37,0x36,0x36,0x38,0x39,0x37,0x36,0x36,0x36,
0x36,0x34,0x34,0x39,0x39,0x37,0x37,0x37,0x38,0x3a,0x3b,0x3a,0x3a,0x38,0x38,0x36,
0x35,0x35,0x36,0x37,0x37,0x36,0x35,0x36,0x38,0x3b,0x3d,0x3b,0x39,0x36,0x34,0x35,
0x35,0x35,0x37,0x37,0x35,0x34,0x36,0x36,0x36,0x38,0x3a,0x37,0x38,0x37,0x36,0x38,
0x37,0x37,0x38,0x39,0x3b,0x3a,0x3b,0x3a,0x38,0x3a,0x3d,0x3e,0x40,0x42,0x46,0x4a,
0x4f,0x54,0x5c,0x61,0x65,0x67,0x69,0x69,0x69,0x68,0x68,0x69,0x69,0x67,0x66,0x67,
0x68,0x6a,0x6c,0x6d,0x6c,0x6b,0x69,0x68,0x69,0x6a,0x6d,0x69,0x6a,0x68,0x68,0x68,
0x69,0x68,0x6d,0x6d,0x6d,0x6d,0x6b,0x6a,0x6b,0x6a,0x6c,0x6c,0x6b,0x69,0x67,0x65,
0x64,0x66,0x6a,0x6a,0x66,0x61,0x5c,0x55,0x50,0x49,0x45,0x42,0x3e,0x39,0x38,0x36,
0x37,0x38,0x38,0x38,0x38,0x39,0x38,0x37,0x36,0x34,0x33,0x36,0x37,0x38,0x3a,0x38,
0x36,0x36,0x36,0x36,0x37,0x39,0x38,0x38,0x38,0x38,0x36,0x39,0x39,0x39,0x3a,0x39,
0x38,0x38,0x38,0x38,0x38,0x37,0x37,0x36,0x34,0x34,0x35,0x37,0x38,0x3b,0x3e,0x42,
0x46,0x4b,0x51,0x57,0x5d,0x61,0x63,0x64,0x65,0x66,0x68,0x67,0x65,0x65,0x66,0x66,
0x65,0x65,0x68,0x68,0x69,0x68,0x67,0x69,0x67,0x68,0x68,0x67,0x66,0x65,0x66,0x66,
0x67,0x69,0x6a,0x6a,0x68,0x66,0x65,0x67,0x68,0x69,0x6a,0x6a,0x69,0x67,0x67,0x68,
0x69,0x6a,0x6a,0x69,0x68,0x65,0x63,0x63,0x65,0x65,0x69,0x6a,0x69,0x68,0x68,0x68,
0x66,0x67,0x6a,0x69,0x6a,0x68,0x66,0x67,0x68,0x69,0x6a,0x69,0x68,0x69,0x69,0x69,
0x6a,0x6c,0x6d,0x6c,0x6b,0x6b,0x6a,0x6a,0x69,0x69,0x6b,0x6b,0x69,0x67,0x67,0x68,
0x6a,0x69,0x69,0x69,0x68,0x64,0x63,0x65,0x66,0x66,0x69,0x67,0x65,0x65,0x63,0x60,
0x5e,0x5a,0x55,0x53,0x4e,0x48,0x46,0x42,0x3e,0x3d,0x3e,0x3e,0x3c,0x3b,0x39,0x39,
0x3a,0x39,0x39,0x39,0x38,0x37,0x37,0x36,0x37,0x38,0x39,0x39,0x38,0x38,0x3a,0x3b,
0x3b,0x37,0x34,0x34,0x35,0x35,0x36,0x35,0x35,0x37,0x37,0x36,0x37,0x38,0x38,0x38,
0x36,0x36,0x37,0x38,0x38,0x36,0x38,0x3a,0x3d,0x41,0x47,0x4c,0x51,0x55,0x59,0x5d,
0x60,0x63,0x67,0x6a,0x6b,0x69,0x6b,0x69,0x67,0x68,0x69,0x69,0x69,0x68,0x67,0x68,
0x65,0x66,0x68,0x6c,0x6d,0x6c,0x6a,0x6b,0x6a,0x68,0x68,0x68,0x6a,0x6a,0x68,0x66,
0x65,0x68,0x6d,0x6e,0x6e,0x6d,0x6a,0x68,0x64,0x64,0x67,0x6a,0x6a,0x67,0x66,0x67,
0x68,0x68,0x69,0x6a,0x6b,0x69,0x67,0x65,0x66,0x66,0x68,0x69,0x69,0x68,0x68,0x69,
0x68,0x67,0x6a,0x6a,0x68,0x67,0x66,0x66,0x67,0x68,0x6a,0x6b,0x6c,0x6b,0x6a,0x69,
0x68,0x69,0x6c,0x6c,0x6c,0x6c,0x6d,0x6b,0x6a,0x6a,0x6a,0x6d,0x6e,0x6d,0x6b,0x69,
0x69,0x6a,0x6a,0x6c,0x6d,0x6e,0x6e,0x6c,0x6b,0x6b,0x6b,0x6a,0x6b,0x6d,0x6e,0x6d,
0x6b,0x6a,0x6b,0x6a,0x6b,0x6c,0x6b,0x69,0x67,0x66,0x65,0x66,0x68,0x69,0x69,0x67,
0x67,0x68,0x68,0x6a,0x6b,0x6c,0x6a,0x69,0x69,0x6a,0x6a,0x6c,0x6d,0x6e,0x6e,0x6c,
0x69,0x68,0x65,0x64,0x66,0x67,0x67,0x66,0x65,0x65,0x67,0x69,0x6c,0x6e,0x6f,0x6c,
0x6a,0x67,0x65,0x62,0x5f,0x59,0x52,0x4d,0x48,0x42,0x3f,0x3d,0x3c,0x3c,0x3a,0x39,
0x39,0x3a,0x3b,0x3c,0x3c,0x3b,0x39,0x3a,0x37,0x36,0x39,0x3b,0x39,0x38,0x37,0x36,
0x38,0x38,0x37,0x37,0x36,0x36,0x37,0x36,0x38,0x3b,0x3e,0x3d,0x3a,0x3c,0x3c,0x3b,
0x39,0x36,0x36,0x37,0x37,0x36,0x34,0x36,0x36,0x36,0x38,0x39,0x3a,0x39,0x36,0x33,
0x33,0x33,0x34,0x36,0x36,0x36,0x36,0x36,0x35,0x34,0x37,0x37,0x34,0x33,0x32,0x30,
0x30,0x32,0x34,0x36,0x36,0x34,0x34,0x34,0x34,0x33,0x33,0x33,0x34,0x32,0x32,0x30,
//Field 7
// Line 10
0x38,0x38,0x37,0x35,0x33,0x35,0x37,0x3a,0x3b,0x3d,0x3c,0x3a,0x38,0x37,0x36,0x35,
0x37,0x37,0x38,0x39,0x39,0x38,0x38,0x39,0x3b,0x3a,0x3a,0x3a,0x38,0x38,0x36,0x34,
0x35,0x37,0x38,0x3a,0x39,0x39,0x39,0x39,0x39,0x3c,0x3b,0x3a,0x38,0x38,0x37,0x34,
0x35,0x36,0x36,0x38,0x35,0x33,0x34,0x36,0x36,0x37,0x38,0x38,0x39,0x3a,0x3a,0x38,
0x37,0x38,0x39,0x3b,0x38,0x38,0x38,0x36,0x34,0x37,0x39,0x3b,0x39,0x37,0x35,0x35,
0x35,0x37,0x37,0x37,0x35,0x34,0x34,0x35,0x34,0x37,0x38,0x37,0x36,0x35,0x34,0x35,
0x36,0x36,0x35,0x37,0x37,0x38,0x38,0x3a,0x39,0x39,0x38,0x37,0x37,0x36,0x33,0x33,
0x34,0x35,0x36,0x35,0x33,0x35,0x35,0x35,0x35,0x37,0x37,0x36,0x36,0x36,0x36,0x37,
0x37,0x37,0x38,0x38,0x37,0x36,0x37,0x37,0x38,0x3a,0x39,0x37,0x38,0x38,0x36,0x37,
0x37,0x38,0x38,0x37,0x34,0x35,0x35,0x36,0x38,0x3a,0x38,0x39,0x38,0x38,0x37,0x38,
0x39,0x3b,0x3b,0x3a,0x38,0x37,0x36,0x33,0x32,0x33,0x37,0x38,0x36,0x34,0x37,0x38,
0x3a,0x3b,0x3a,0x3a,0x38,0x38,0x37,0x38,0x39,0x3a,0x3a,0x3b,0x39,0x38,0x37,0x36,
0x33,0x35,0x35,0x36,0x36,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x39,0x38,0x37,0x36,
0x36,0x39,0x38,0x37,0x37,0x37,0x38,0x38,0x38,0x38,0x38,0x39,0x38,0x37,0x37,0x35,
0x34,0x37,0x38,0x38,0x38,0x38,0x36,0x36,0x35,0x37,0x38,0x39,0x39,0x39,0x38,0x37,
0x35,0x37,0x38,0x3b,0x3b,0x3b,0x3a,0x38,0x35,0x34,0x36,0x38,0x3a,0x3a,0x39,0x37,
0x34,0x35,0x36,0x38,0x38,0x38,0x36,0x36,0x36,0x37,0x37,0x36,0x34,0x34,0x35,0x37,
0x34,0x38,0x38,0x3a,0x39,0x3a,0x3a,0x3a,0x3b,0x3b,0x3a,0x36,0x31,0x33,0x36,0x38,
0x39,0x39,0x38,0x37,0x34,0x33,0x34,0x37,0x38,0x37,0x35,0x33,0x32,0x35,0x37,0x38,
0x39,0x38,0x38,0x38,0x38,0x3a,0x38,0x3b,0x39,0x39,0x39,0x39,0x38,0x3b,0x3b,0x38,
0x37,0x35,0x34,0x37,0x36,0x36,0x36,0x37,0x38,0x39,0x38,0x38,0x39,0x3c,0x3c,0x3c,
0x3b,0x39,0x38,0x37,0x35,0x35,0x36,0x34,0x34,0x37,0x38,0x38,0x38,0x38,0x38,0x39,
0x3a,0x39,0x38,0x39,0x39,0x38,0x39,0x39,0x38,0x39,0x38,0x37,0x36,0x38,0x39,0x3a,
0x39,0x38,0x38,0x38,0x37,0x38,0x39,0x3a,0x38,0x38,0x38,0x38,0x38,0x37,0x37,0x37,
0x37,0x38,0x37,0x35,0x35,0x38,0x38,0x38,0x36,0x37,0x38,0x39,0x38,0x38,0x38,0x39,
0x38,0x37,0x38,0x3a,0x3c,0x3b,0x3a,0x38,0x39,0x3b,0x3c,0x3a,0x3b,0x3a,0x38,0x3a,
0x39,0x39,0x3a,0x39,0x38,0x38,0x38,0x3b,0x3c,0x3d,0x3b,0x3a,0x3a,0x3a,0x3a,0x3b,
0x3b,0x39,0x38,0x36,0x34,0x35,0x35,0x34,0x33,0x35,0x37,0x37,0x35,0x35,0x36,0x37,
0x35,0x35,0x37,0x38,0x3a,0x3d,0x3b,0x3a,0x3b,0x3b,0x3a,0x3b,0x3b,0x3c,0x39,0x39,
0x38,0x3a,0x3c,0x3d,0x3d,0x3f,0x3f,0x3d,0x3b,0x3a,0x39,0x3a,0x38,0x37,0x36,0x37,
0x35,0x34,0x33,0x33,0x35,0x38,0x38,0x37,0x37,0x38,0x38,0x3a,0x3a,0x3b,0x3a,0x38,
0x34,0x33,0x33,0x35,0x35,0x35,0x35,0x37,0x38,0x38,0x37,0x3a,0x3a,0x38,0x37,0x36,
0x34,0x36,0x36,0x36,0x36,0x37,0x38,0x38,0x39,0x39,0x39,0x39,0x38,0x37,0x35,0x36,
0x37,0x39,0x39,0x3b,0x3b,0x3b,0x39,0x38,0x36,0x37,0x36,0x35,0x33,0x33,0x34,0x34,
0x32,0x35,0x36,0x37,0x38,0x39,0x38,0x38,0x38,0x38,0x38,0x38,0x39,0x3b,0x39,0x38,
0x38,0x38,0x37,0x34,0x35,0x38,0x37,0x38,0x39,0x3b,0x3c,0x3b,0x3b,0x3b,0x3b,0x3b,
0x3a,0x38,0x37,0x36,0x36,0x36,0x36,0x35,0x37,0x38,0x39,0x38,0x38,0x3a,0x3a,0x39,
0x39,0x3a,0x3a,0x38,0x38,0x37,0x36,0x36,0x35,0x35,0x38,0x38,0x38,0x3a,0x3b,0x3a,
0x39,0x38,0x36,0x36,0x35,0x35,0x33,0x31,0x32,0x35,0x37,0x36,0x34,0x35,0x37,0x37,
0x36,0x36,0x36,0x37,0x37,0x36,0x34,0x35,0x36,0x38,0x37,0x34,0x32,0x34,0x37,0x39,
0x3c,0x39,0x37,0x38,0x39,0x39,0x38,0x38,0x38,0x38,0x36,0x35,0x35,0x39,0x39,0x39,
0x38,0x37,0x33,0x31,0x32,0x34,0x37,0x38,0x38,0x39,0x37,0x35,0x34,0x37,0x38,0x39,
0x37,0x35,0x34,0x33,0x32,0x31,0x34,0x34,0x33,0x36,0x38,0x38,0x37,0x38,0x38,0x39,
0x38,0x38,0x38,0x3b,0x3b,0x3a,0x38,0x37,0x37,0x39,0x39,0x39,0x3a,0x3b,0x39,0x37,
0x35,0x35,0x37,0x37,0x38,0x39,0x38,0x36,0x34,0x36,0x35,0x34,0x33,0x32,0x32,0x33,
0x33,0x33,0x35,0x37,0x37,0x3a,0x3b,0x3c,0x3b,0x3b,0x3b,0x3a,0x3a,0x3a,0x39,0x39,
0x36,0x33,0x34,0x35,0x35,0x37,0x36,0x35,0x34,0x35,0x37,0x38,0x37,0x36,0x34,0x35,
0x36,0x37,0x38,0x38,0x38,0x39,0x39,0x38,0x38,0x38,0x38,0x38,0x37,0x37,0x38,0x38,
0x37,0x36,0x34,0x34,0x34,0x36,0x37,0x36,0x38,0x38,0x35,0x34,0x32,0x33,0x33,0x34,
0x35,0x37,0x37,0x37,0x37,0x39,0x3a,0x39,0x37,0x37,0x35,0x34,0x34,0x34,0x36,0x37,
0x38,0x3b,0x3a,0x39,0x39,0x3a,0x3a,0x39,0x38,0x37,0x34,0x34,0x32,0x32,0x34,0x37,
0x38,0x38,0x36,0x35,0x37,0x39,0x3c,0x3f,0x3f,0x3f,0x3e,0x3e,0x3d,0x3b,0x3b,0x38,
0x38,0x39,0x37,0x33,0x31,0x32,0x32,0x33,0x35,0x38,0x3b,0x3b,0x38,0x35,0x34,0x34,
0x35,0x37,0x37,0x37,0x37,0x37,0x35,0x35,0x34,0x36,0x38,0x38,0x37,0x37,0x36,0x35,
0x36,0x37,0x39,0x39,0x39,0x3a,0x38,0x38,0x38,0x37,0x38,0x37,0x35,0x36,0x34,0x34,
0x34,0x36,0x36,0x36,0x36,0x37,0x38,0x3a,0x38,0x39,0x3a,0x3b,0x38,0x37,0x36,0x37,
0x38,0x39,0x38,0x37,0x37,0x37,0x37,0x37,0x37,0x38,0x37,0x36,0x35,0x36,0x37,0x37,
0x38,0x37,0x36,0x37,0x35,0x35,0x36,0x37,0x37,0x38,0x39,0x3b,0x3a,0x39,0x38,0x37,
0x38,0x39,0x37,0x38,0x36,0x35,0x36,0x37,0x37,0x37,0x38,0x38,0x37,0x38,0x38,0x39,
0x3a,0x39,0x38,0x38,0x38,0x38,0x38,0x37,0x36,0x38,0x38,0x38,0x37,0x37,0x37,0x39,
0x3a,0x3a,0x38,0x38,0x37,0x36,0x37,0x37,0x36,0x37,0x37,0x37,0x37,0x37,0x37,0x36,
0x35,0x36,0x36,0x38,0x39,0x3b,0x3c,0x39,0x37,0x39,0x3b,0x3b,0x3a,0x38,0x37,0x37,
0x36,0x35,0x35,0x37,0x36,0x37,0x36,0x36,0x35,0x35,0x35,0x35,0x37,0x37,0x35,0x34,
0x32,0x31,0x32,0x33,0x34,0x36,0x37,0x37,0x36,0x36,0x36,0x37,0x38,0x3a,0x3b,0x3b,
0x3a,0x39,0x38,0x36,0x35,0x37,0x37,0x35,0x33,0x33,0x33,0x32,0x32,0x33,0x34,0x36,
0x34,0x34,0x38,0x39,0x38,0x39,0x39,0x38,0x38,0x37,0x34,0x34,0x33,0x33,0x34,0x36,
0x37,0x38,0x38,0x37,0x36,0x37,0x37,0x37,0x35,0x33,0x31,0x31,0x31,0x33,0x35,0x36,
0x35,0x36,0x35,0x35,0x34,0x35,0x35,0x34,0x33,0x33,0x33,0x35,0x36,0x36,0x37,0x37,
0x36,0x33,0x33,0x33,0x34,0x37,0x38,0x39,0x39,0x39,0x39,0x3b,0x3b,0x3c,0x3b,0x3b,
0x3a,0x38,0x33,0x31,0x31,0x33,0x33,0x33,0x34,0x36,0x36,0x36,0x36,0x37,0x38,0x38,
0x37,0x38,0x37,0x37,0x37,0x37,0x38,0x37,0x37,0x36,0x35,0x36,0x35,0x37,0x38,0x37,
0x36,0x38,0x37,0x38,0x38,0x39,0x37,0x37,0x35,0x35,0x31,0x34,0x35,0x36,0x38,0x38,
0x37,0x37,0x36,0x36,0x38,0x3a,0x3b,0x39,0x37,0x37,0x37,0x37,0x36,0x36,0x37,0x37,
0x37,0x37,0x37,0x37,0x3a,0x3a,0x38,0x39,0x38,0x38,0x38,0x38,0x38,0x38,0x39,0x39,
0x38,0x38,0x37,0x38,0x37,0x38,0x38,0x38,0x37,0x36,0x36,0x37,0x39,0x3a,0x38,0x34,
0x35,0x36,0x35,0x34,0x34,0x36,0x36,0x35,0x34,0x34,0x38,0x37,0x38,0x3b,0x3b,0x3a,
0x39,0x39,0x38,0x38,0x37,0x38,0x38,0x37,0x34,0x34,0x35,0x35,0x33,0x33,0x34,0x34,
0x34,0x37,0x38,0x3a,0x38,0x38,0x39,0x3a,0x3a,0x39,0x38,0x37,0x36,0x36,0x35,0x34,
0x34,0x35,0x37,0x38,0x36,0x35,0x37,0x37,0x34,0x36,0x37,0x38,0x37,0x37,0x36,0x37,
0x36,0x36,0x34,0x37,0x36,0x34,0x33,0x34,0x36,0x37,0x36,0x36,0x37,0x38,0x37,0x38,
0x37,0x37,0x37,0x39,0x39,0x38,0x37,0x37,0x36,0x37,0x36,0x34,0x34,0x35,0x34,0x35,
0x35,0x37,0x37,0x38,0x38,0x38,0x3a,0x39,0x37,0x38,0x38,0x38,0x38,0x38,0x38,0x3a,
0x39,0x39,0x38,0x38,0x39,0x3b,0x3a,0x39,0x39,0x3b,0x3a,0x38,0x37,0x36,0x36,0x37,
0x38,0x38,0x38,0x37,0x35,0x35,0x36,0x38,0x38,0x37,0x35,0x34,0x34,0x34,0x33,0x37,
0x37,0x38,0x37,0x37,0x36,0x37,0x37,0x37,0x37,0x38,0x38,0x38,0x37,0x36,0x36,0x37,
0x36,0x35,0x35,0x35,0x33,0x34,0x33,0x34,0x34,0x33,0x33,0x35,0x35,0x36,0x36,0x36,
0x35,0x37,0x37,0x38,0x37,0x37,0x37,0x37,0x38,0x37,0x35,0x37,0x37,0x38,0x38,0x3a,
0x3a,0x39,0x37,0x34,0x34,0x37,0x39,0x3a,0x38,0x38,0x37,0x37,0x35,0x36,0x37,0x38,
0x38,0x38,0x37,0x35,0x34,0x34,0x35,0x38,0x38,0x3a,0x39,0x38,0x36,0x37,0x37,0x37,
0x37,0x38,0x37,0x34,0x32,0x32,0x32,0x35,0x36,0x37,0x38,0x39,0x39,0x37,0x39,0x39,
0x39,0x3b,0x3a,0x38,0x36,0x34,0x33,0x36,0x37,0x38,0x38,0x38,0x36,0x36,0x34,0x34,
0x33,0x33,0x33,0x32,0x32,0x33,0x33,0x34,0x33,0x34,0x35,0x37,0x37,0x37,0x35,0x35,
0x34,0x34,0x32,0x2e,0x32,0x33,0x34,0x37,0x34,0x32,0x33,0x33,0x33,0x36,0x37,0x37,
0x36,0x35,0x33,0x33,0x35,0x38,0x39,0x38,0x38,0x36,0x35,0x32,0x31,0x32,0x33,0x32,
0x33,0x34,0x34,0x35,0x33,0x33,0x34,0x36,0x38,0x38,0x36,0x34,0x32,0x33,0x33,0x33,
0x33,0x32,0x32,0x33,0x30,0x31,0x31,0x33,0x34,0x36,0x35,0x35,0x36,0x38,0x35,0x34,
// Line 11
0x36,0x38,0x39,0x3a,0x3a,0x38,0x35,0x34,0x32,0x33,0x34,0x35,0x33,0x32,0x33,0x35,
0x37,0x38,0x38,0x37,0x39,0x39,0x39,0x3a,0x3a,0x38,0x36,0x34,0x32,0x35,0x37,0x38,
0x39,0x3a,0x37,0x36,0x35,0x37,0x3a,0x3e,0x3d,0x3b,0x39,0x37,0x34,0x33,0x34,0x36,
0x38,0x38,0x34,0x31,0x30,0x35,0x3f,0x52,0x63,0x73,0x7b,0x7a,0x6d,0x60,0x54,0x52,
0x5a,0x67,0x73,0x78,0x75,0x6b,0x61,0x5c,0x5a,0x5f,0x66,0x6f,0x72,0x74,0x70,0x6a,
0x63,0x5e,0x5c,0x60,0x66,0x6f,0x76,0x79,0x73,0x6a,0x60,0x5a,0x58,0x5f,0x67,0x6f,
0x74,0x73,0x6b,0x65,0x5c,0x57,0x5a,0x60,0x67,0x6f,0x72,0x72,0x6f,0x6a,0x64,0x5e,
0x5c,0x60,0x67,0x6e,0x73,0x74,0x6f,0x67,0x5e,0x5a,0x5a,0x61,0x6b,0x73,0x78,0x78,
0x72,0x6a,0x60,0x5c,0x5c,0x60,0x67,0x6b,0x6d,0x71,0x75,0x79,0x83,0x90,0x9d,0xa9,
0xae,0xac,0xa5,0x97,0x86,0x74,0x69,0x60,0x58,0x54,0x4d,0x46,0x3d,0x36,0x35,0x3e,
0x4e,0x61,0x75,0x84,0x8c,0x92,0x95,0x98,0x9b,0x9d,0x9d,0x9a,0x97,0x96,0x94,0x97,
0x96,0x91,0x88,0x79,0x68,0x5c,0x54,0x4d,0x45,0x3d,0x35,0x2f,0x37,0x46,0x5a,0x6f,
0x7c,0x7e,0x7a,0x6c,0x60,0x5a,0x56,0x50,0x47,0x3b,0x32,0x34,0x3f,0x55,0x6b,0x7c,
0x83,0x7f,0x72,0x64,0x55,0x4d,0x47,0x43,0x3d,0x39,0x34,0x33,0x33,0x37,0x3d,0x49,
0x56,0x64,0x6e,0x72,0x70,0x6b,0x64,0x5b,0x57,0x53,0x4e,0x49,0x40,0x37,0x34,0x3c,
0x4c,0x63,0x77,0x86,0x8e,0x92,0x93,0x93,0x90,0x88,0x7a,0x68,0x5a,0x55,0x5d,0x6a,
0x76,0x7e,0x7b,0x71,0x66,0x5f,0x5d,0x5d,0x58,0x4c,0x3a,0x2d,0x2c,0x3a,0x54,0x6b,
0x7a,0x80,0x79,0x6c,0x5f,0x58,0x54,0x52,0x4a,0x3f,0x34,0x32,0x3c,0x53,0x6b,0x7c,
0x81,0x7b,0x6d,0x5f,0x57,0x56,0x5b,0x64,0x69,0x6f,0x77,0x80,0x8b,0x95,0x9b,0x99,
0x8d,0x7c,0x69,0x58,0x4e,0x4e,0x55,0x61,0x70,0x81,0x8f,0x9b,0x9f,0x9e,0x95,0x88,
0x78,0x69,0x5a,0x4e,0x45,0x3c,0x34,0x33,0x38,0x47,0x5c,0x6f,0x7b,0x7e,0x76,0x68,
0x5a,0x52,0x4f,0x50,0x4d,0x44,0x38,0x2e,0x29,0x2d,0x34,0x3d,0x43,0x43,0x3c,0x34,
0x30,0x37,0x44,0x59,0x6b,0x78,0x7c,0x7b,0x70,0x65,0x5e,0x5b,0x5d,0x66,0x6d,0x72,
0x78,0x7e,0x86,0x8f,0x99,0xa2,0xa8,0xa9,0xa5,0xa0,0x9a,0x97,0x96,0x9b,0x9f,0xa2,
0xa1,0x9e,0x9c,0x9b,0x98,0x97,0x98,0x9a,0x9b,0x9d,0x9e,0xa0,0xa0,0xa0,0xa0,0xa0,
0x9f,0x9f,0x9f,0x9f,0x9d,0x9c,0x9b,0x9c,0x9c,0x9b,0x9b,0x9a,0x99,0x9c,0x9e,0x9e,
0xa0,0x9f,0x9e,0x9f,0x9e,0x9d,0x9d,0x9c,0x9b,0x9c,0x9c,0x9d,0x9e,0x9e,0x9e,0xa0,
0xa1,0xa2,0xa1,0xa2,0xa1,0x9e,0x9c,0x9a,0x9a,0x9c,0x9d,0x9e,0x9e,0x9e,0x9d,0x9d,
0x9e,0x9e,0x9f,0x9f,0x9e,0x9c,0x9c,0x9d,0x9d,0x9f,0xa0,0xa1,0xa1,0xa0,0x9e,0x9e,
0x9c,0x9c,0x9c,0x9b,0x9b,0x9d,0x9e,0x9e,0x9d,0x9e,0x9e,0x9d,0x9e,0xa0,0xa1,0xa2,
0xa0,0x9e,0x9d,0x9d,0x9d,0x9e,0x9e,0x9e,0x9f,0xa0,0x9f,0x9d,0x9d,0x9e,0x9e,0xa0,
0x9f,0x9e,0x9f,0x9e,0x9a,0x9c,0x9d,0x9f,0x9e,0x9e,0x9c,0x9c,0x9a,0x9b,0x9b,0x9e,
0xa0,0x9f,0x9e,0x9e,0x9e,0x9f,0x9e,0x9e,0xa0,0xa1,0xa1,0xa0,0x9e,0x9e,0x9e,0x9e,
0x9d,0x9c,0x9b,0x9c,0x9b,0x9d,0x9e,0x9f,0xa2,0xa4,0xa4,0xa4,0xa1,0xa0,0x9f,0x9d,
0x9b,0x9c,0x9c,0x9c,0x99,0x9e,0x9d,0x9e,0xa1,0xa2,0xa0,0xa0,0x9f,0x9d,0x9f,0x9f,
0x9e,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0xa0,0xa0,0x9f,0xa0,0xa0,0xa1,0xa2,0xa0,
0x9c,0x9c,0x9c,0x9d,0x9c,0x9c,0x9d,0x9e,0x9e,0x9f,0x9c,0x9e,0x9e,0xa0,0xa0,0x9f,
0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0xa0,0xa0,0x9f,0x9f,0x9e,0x9f,0x9e,
0x9c,0x9e,0x9f,0xa0,0x9e,0x9d,0x9c,0x9f,0x9f,0x9e,0x9b,0x99,0x98,0x9a,0x9b,0x9b,
0x9b,0x9e,0xa0,0xa1,0xa0,0x9e,0x9f,0xa1,0xa1,0x9e,0x9c,0x9d,0x9e,0xa0,0x9e,0x9c,
0x9d,0x9f,0xa1,0x9e,0x9c,0x9a,0x9b,0x9e,0xa0,0xa1,0xa2,0xa2,0xa1,0xa1,0x9e,0x9d,
0x9d,0x9f,0x9f,0x9f,0x9c,0x9a,0x9a,0x9b,0x9b,0x9d,0x9e,0x9f,0x9e,0x9d,0x99,0x97,
0x98,0x9c,0x9f,0xa1,0x9f,0x9e,0x9d,0x9d,0x9c,0x9b,0x9c,0x9e,0x9e,0x9e,0x9c,0x9a,
0x9c,0x9e,0x9d,0x9f,0x9e,0xa1,0xa2,0xa0,0x9e,0x9f,0x9f,0x9f,0x9c,0x9b,0x9a,0x9a,
0x9b,0x9e,0x9f,0xa0,0xa0,0xa1,0xa2,0xa2,0xa2,0xa3,0xa1,0xa0,0x9e,0x9f,0x9e,0x9c,
0x9a,0x9b,0x9c,0x9e,0x9f,0xa0,0xa0,0xa0,0x9e,0xa0,0xa0,0xa1,0xa1,0xa1,0x9f,0x9e,
0x9c,0x9c,0x9c,0x9e,0x9d,0x9d,0x9e,0x9d,0x9b,0x9c,0x9b,0x9b,0x9b,0x9c,0x9e,0xa0,
0x9e,0x9c,0x9c,0x9c,0x9c,0x9b,0x9a,0x9b,0x9b,0x9b,0x99,0x99,0x9b,0x9d,0x9f,0xa1,
0xa1,0xa1,0xa1,0xa2,0xa0,0x9f,0x9f,0xa0,0x9e,0x9c,0x9a,0x9b,0x9a,0x9b,0x9b,0x9c,
0x9d,0x9e,0x9f,0x9f,0x9f,0xa1,0xa0,0x9e,0x9d,0x9e,0x9e,0x9e,0x9c,0x9c,0x9c,0x9c,
0x9c,0x9b,0x9e,0x9e,0x9e,0xa0,0x9e,0x9d,0x9d,0x9e,0x9e,0x9e,0x9c,0x9d,0x9d,0x9b,
0x99,0x99,0x9a,0x9c,0x9d,0x9e,0x9c,0x9c,0x9d,0x9f,0xa1,0xa2,0xa0,0x9f,0x9e,0x9e,
0x9e,0x9f,0x9e,0x9d,0x9c,0x9c,0x9a,0x97,0x9a,0x9c,0x9d,0x9e,0x9e,0xa0,0xa1,0xa1,
0xa1,0xa2,0xa2,0xa1,0x9e,0x9d,0x9c,0x9b,0x9c,0x9d,0x9d,0x9e,0x9d,0x9d,0x9c,0x9a,
0x9b,0x9d,0x9e,0x9d,0x9d,0x9e,0x9e,0x9e,0x9c,0x9d,0x9d,0x9e,0x9c,0x99,0x98,0x97,
0x96,0x99,0x99,0x9b,0x9c,0x9d,0x9c,0x9e,0x9e,0xa0,0x9f,0xa1,0x9f,0x9f,0xa0,0x9e,
0x9a,0x99,0x98,0x98,0x99,0x9b,0x9c,0x9e,0x9e,0x9e,0xa0,0xa2,0xa4,0xa4,0xa4,0xa1,
0x9f,0x9f,0x9f,0x9e,0x9e,0x9f,0x9e,0x9f,0x9d,0x9e,0x9e,0x9e,0x9d,0x9e,0x9f,0xa1,
0xa2,0xa3,0xa3,0xa2,0xa1,0x9f,0x9d,0x9e,0x9d,0x9f,0xa0,0xa0,0x9d,0x9d,0x9c,0x9d,
0x9f,0xa2,0xa3,0xa2,0xa0,0x9e,0x9c,0x9d,0x9e,0x9f,0x9f,0xa0,0xa1,0xa0,0x9e,0x9f,
0xa0,0xa2,0xa1,0xa1,0x9e,0x9e,0x9d,0x9e,0x9d,0x9d,0x9e,0x9f,0x9e,0xa0,0x9e,0x9b,
0x9d,0x9f,0x9f,0x9e,0x9e,0x9d,0x9f,0x9f,0xa0,0xa1,0xa1,0xa1,0xa2,0xa4,0xa3,0xa1,
0x9f,0x9e,0x9c,0x9e,0x9d,0x9e,0x9e,0x9d,0x9b,0x9a,0x9b,0x9e,0x9f,0x9f,0x9f,0x9e,
0x9e,0x9e,0x9e,0xa1,0xa0,0x9f,0xa0,0x9f,0x9d,0x9e,0x9d,0x9d,0x9d,0x9f,0xa1,0xa4,
0xa2,0xa2,0xa2,0xa4,0xa2,0xa2,0xa2,0xa1,0xa1,0xa1,0x9e,0x9c,0x9b,0x9b,0x9a,0x9a,
0x9a,0x9e,0x9f,0x9e,0x9c,0x9d,0x9f,0xa1,0x9f,0xa2,0xa2,0xa0,0xa1,0xa1,0xa0,0xa0,
0xa0,0xa0,0xa0,0xa0,0x9f,0x9f,0x9f,0xa0,0xa1,0xa2,0xa1,0x9f,0x9e,0x9d,0x9b,0x9b,
0x9b,0x9b,0x9b,0x9b,0x9a,0x9d,0x9f,0xa2,0xa1,0xa2,0xa1,0xa1,0xa1,0xa1,0xa1,0xa0,
0xa0,0xa0,0xa0,0x9f,0x9e,0xa0,0x9f,0x9f,0xa0,0xa1,0xa1,0xa0,0x9f,0x9e,0xa0,0xa2,
0xa1,0xa1,0xa0,0xa1,0xa0,0x9f,0x9e,0x9d,0x9e,0x9e,0x9d,0x9d,0x9e,0xa0,0xa1,0xa1,
0x9e,0x9e,0xa1,0xa2,0xa1,0xa0,0x9f,0x9e,0x9d,0x9d,0x9d,0x9e,0x9e,0x9d,0x9c,0x9b,
0x9b,0x9b,0x9d,0x9e,0x9e,0xa1,0xa1,0x9e,0xa0,0xa0,0xa0,0xa0,0x9d,0x9c,0x9d,0x9d,
0x9b,0x9c,0x9c,0x9f,0xa0,0x9f,0x9d,0x9d,0xa0,0xa2,0xa2,0xa3,0xa2,0xa2,0xa4,0xa2,
0xa1,0xa1,0xa0,0x9f,0x9e,0x9e,0x9d,0x9b,0x99,0x9b,0x9d,0x9f,0xa1,0xa2,0xa4,0xa2,
0xa1,0xa3,0xa4,0xa4,0xa3,0xa2,0x9e,0x9b,0x98,0x99,0x9b,0x9b,0x9b,0x9c,0x9c,0x9e,
0x9d,0x9e,0x9e,0x9f,0xa0,0xa0,0x9f,0x9e,0x9d,0x9c,0x9b,0x9a,0x9a,0x9d,0x9e,0x9f,
0x9f,0xa1,0xa0,0x9e,0x9c,0x9c,0x9c,0x9d,0x9b,0x9b,0x9b,0x9c,0x9b,0x9d,0x9e,0xa0,
0xa1,0xa1,0x9e,0x9f,0x9f,0xa1,0xa1,0xa0,0x9e,0x9f,0xa1,0xa1,0x9f,0x9e,0x9d,0x9b,
0x9a,0x9a,0x9b,0x9d,0x9d,0x9e,0x9f,0xa0,0xa1,0xa1,0xa2,0xa1,0xa1,0xa1,0x9e,0x9e,
0x9e,0x9f,0x9f,0xa0,0x9e,0x9e,0x9e,0x9f,0x9d,0x9c,0x9d,0x9f,0x9e,0xa0,0x9e,0x9d,
0x9e,0xa0,0xa1,0xa1,0x9e,0x9c,0x9c,0x9c,0x9c,0x9d,0x9e,0x9e,0x9c,0x9a,0x99,0x9b,
0x9b,0x98,0x90,0x83,0x70,0x60,0x56,0x56,0x5e,0x6d,0x79,0x7e,0x7d,0x74,0x6a,0x63,
0x60,0x5f,0x5a,0x51,0x42,0x35,0x32,0x3b,0x51,0x6e,0x84,0x8b,0x86,0x76,0x62,0x52,
0x53,0x5d,0x6d,0x78,0x7b,0x75,0x6e,0x67,0x62,0x63,0x61,0x5c,0x51,0x42,0x36,0x34,
0x3c,0x4e,0x65,0x7a,0x89,0x95,0x9b,0x9c,0x9a,0x96,0x8a,0x7b,0x69,0x5b,0x53,0x56,
0x61,0x71,0x7c,0x82,0x7c,0x6e,0x63,0x5c,0x60,0x6a,0x74,0x78,0x7b,0x74,0x6a,0x65,
0x62,0x64,0x63,0x5d,0x51,0x42,0x36,0x31,0x37,0x48,0x5c,0x74,0x88,0x98,0x9d,0x9c,
0x97,0x8e,0x84,0x78,0x6c,0x62,0x58,0x4d,0x42,0x3b,0x38,0x3c,0x45,0x54,0x65,0x75,
0x81,0x8a,0x90,0x95,0x96,0x95,0x8c,0x7e,0x6b,0x5d,0x55,0x5b,0x67,0x76,0x7f,0x80,
0x79,0x6f,0x65,0x60,0x5a,0x5a,0x50,0x42,0x36,0x31,0x36,0x48,0x5f,0x76,0x87,0x92,
0x95,0x95,0x96,0x9a,0x9d,0xa1,0xa2,0xa1,0x9f,0x9d,0x9d,0xa0,0xa1,0xa4,0xa6,0xa5,
0xa2,0x9e,0x95,0x88,0x79,0x6a,0x5e,0x59,0x59,0x5f,0x67,0x76,0x7e,0x86,0x90,0x96,
0x96,0x93,0x89,0x7a,0x6a,0x5a,0x4b,0x40,0x3a,0x39,0x3b,0x3d,0x3e,0x3d,0x3a,0x39,
0x3e,0x4c,0x5d,0x6e,0x7a,0x7c,0x75,0x6d,0x64,0x5e,0x59,0x55,0x4f,0x47,0x3b,0x31,
0x2c,0x31,0x38,0x40,0x43,0x44,0x40,0x3c,0x36,0x34,0x35,0x38,0x3a,0x3b,0x3a,0x39,
0x38,0x3a,0x3c,0x3d,0x3c,0x3a,0x3a,0x3b,0x3c,0x3d,0x3d,0x3b,0x3a,0x3a,0x39,0x3b,
// Line 12
0x39,0x39,0x37,0x37,0x36,0x38,0x38,0x38,0x37,0x37,0x36,0x36,0x34,0x35,0x36,0x37,
0x35,0x36,0x35,0x38,0x3a,0x3b,0x3a,0x3a,0x3a,0x3b,0x3b,0x3d,0x3d,0x3d,0x3c,0x3a,
0x38,0x37,0x34,0x33,0x34,0x35,0x34,0x33,0x33,0x34,0x35,0x35,0x34,0x36,0x3a,0x3c,
0x3b,0x3b,0x39,0x35,0x36,0x3a,0x43,0x53,0x63,0x72,0x78,0x75,0x6a,0x5f,0x58,0x58,
0x5e,0x6a,0x73,0x78,0x77,0x6e,0x65,0x5e,0x5b,0x61,0x6b,0x73,0x75,0x75,0x71,0x6b,
0x64,0x60,0x5f,0x64,0x6a,0x6f,0x74,0x75,0x72,0x6c,0x66,0x62,0x5f,0x62,0x68,0x72,
0x76,0x75,0x6e,0x68,0x62,0x5e,0x5b,0x5f,0x66,0x70,0x77,0x76,0x70,0x6a,0x5f,0x58,
0x57,0x5d,0x66,0x6e,0x72,0x72,0x6c,0x66,0x60,0x5b,0x5f,0x65,0x6d,0x76,0x79,0x77,
0x74,0x6c,0x63,0x61,0x61,0x64,0x67,0x6b,0x6c,0x6f,0x73,0x79,0x81,0x8c,0x97,0xa2,
0xa9,0xaa,0xa4,0x96,0x84,0x73,0x66,0x5c,0x58,0x54,0x4f,0x46,0x3d,0x37,0x34,0x3b,
0x49,0x5e,0x71,0x80,0x87,0x8c,0x92,0x97,0x99,0x9f,0x9f,0x9f,0x9b,0x9a,0x9a,0x9c,
0x9e,0x9b,0x8d,0x7e,0x6d,0x60,0x59,0x52,0x49,0x41,0x37,0x31,0x35,0x45,0x5a,0x6f,
0x7c,0x7e,0x75,0x68,0x5c,0x54,0x4f,0x4a,0x43,0x3b,0x30,0x2e,0x3a,0x51,0x6a,0x7e,
0x84,0x82,0x77,0x67,0x58,0x4f,0x4a,0x47,0x40,0x38,0x30,0x2c,0x2c,0x30,0x37,0x46,
0x50,0x5f,0x6c,0x75,0x76,0x72,0x68,0x5f,0x59,0x56,0x53,0x4a,0x40,0x37,0x33,0x3a,
0x4b,0x62,0x79,0x8b,0x93,0x98,0x99,0x98,0x95,0x8b,0x7b,0x6b,0x5e,0x59,0x5c,0x67,
0x74,0x7c,0x79,0x6f,0x64,0x5f,0x5c,0x5a,0x54,0x48,0x39,0x2d,0x2c,0x38,0x50,0x6c,
0x7e,0x84,0x7c,0x6c,0x5e,0x59,0x54,0x51,0x49,0x3e,0x35,0x35,0x3e,0x53,0x6b,0x7e,
0x84,0x7d,0x6d,0x5c,0x53,0x54,0x5c,0x68,0x73,0x77,0x74,0x6c,0x65,0x5f,0x5d,0x5d,
0x59,0x51,0x44,0x38,0x2d,0x2a,0x2e,0x34,0x41,0x48,0x49,0x45,0x3a,0x32,0x37,0x41,
0x53,0x68,0x78,0x80,0x7a,0x6e,0x5e,0x55,0x56,0x62,0x6c,0x78,0x79,0x73,0x6b,0x61,
0x5a,0x5b,0x5b,0x59,0x53,0x48,0x3a,0x30,0x2b,0x2e,0x38,0x43,0x49,0x47,0x3e,0x34,
0x2e,0x33,0x3e,0x4f,0x63,0x76,0x7e,0x7c,0x72,0x68,0x61,0x5f,0x5f,0x66,0x6e,0x74,
0x79,0x81,0x88,0x8f,0x99,0xa3,0xaa,0xaf,0xa8,0x9b,0x8a,0x7a,0x6d,0x61,0x56,0x4f,
0x4d,0x49,0x43,0x3b,0x34,0x34,0x37,0x3f,0x42,0x43,0x40,0x3d,0x38,0x36,0x37,0x40,
0x4f,0x60,0x70,0x7d,0x86,0x8d,0x94,0x9a,0x9f,0xa2,0xa4,0xa2,0x9b,0x8e,0x7d,0x6b,
0x5d,0x54,0x4f,0x4a,0x49,0x43,0x3c,0x36,0x33,0x34,0x37,0x3d,0x3f,0x40,0x3b,0x35,
0x32,0x36,0x41,0x53,0x62,0x72,0x7e,0x87,0x8c,0x93,0x9a,0x9f,0xa2,0xa5,0xa4,0xa0,
0x9c,0x9a,0x9b,0x9d,0x9f,0xa2,0xa2,0xa2,0xa0,0x9d,0x9d,0x9c,0x9c,0x9f,0xa0,0x9f,
0x9e,0x9e,0x9e,0xa2,0xa1,0xa0,0xa0,0xa0,0x9e,0x9d,0x9b,0x9a,0x99,0x9b,0x9b,0x9c,
0x9d,0x9c,0x99,0x91,0x81,0x71,0x63,0x57,0x4b,0x44,0x3e,0x39,0x35,0x35,0x34,0x36,
0x39,0x3d,0x3f,0x40,0x3e,0x3a,0x37,0x34,0x34,0x37,0x3a,0x39,0x39,0x39,0x37,0x37,
0x36,0x37,0x36,0x3b,0x3a,0x3b,0x3b,0x3c,0x3c,0x40,0x3f,0x3e,0x3d,0x3c,0x3a,0x39,
0x39,0x40,0x4d,0x5b,0x68,0x76,0x83,0x8d,0x93,0x9b,0xa0,0xa5,0xa6,0xa5,0xa2,0x9e,
0x9a,0x99,0x99,0x9a,0x9b,0x9f,0x9f,0x9e,0x9b,0x9b,0x99,0x97,0x98,0x9b,0x9b,0x9b,
0x98,0x97,0x99,0x9c,0x9e,0x9f,0x9b,0x94,0x89,0x7c,0x6e,0x63,0x59,0x50,0x49,0x43,
0x3d,0x3a,0x37,0x36,0x36,0x3b,0x3d,0x3b,0x35,0x30,0x2c,0x2d,0x2d,0x30,0x32,0x34,
0x34,0x34,0x34,0x35,0x37,0x3e,0x3d,0x38,0x34,0x32,0x32,0x3a,0x43,0x50,0x60,0x6f,
0x7c,0x85,0x8d,0x92,0x9a,0xa2,0xa5,0xa5,0xa0,0x9c,0x99,0x99,0x99,0x9c,0x9e,0xa0,
0xa1,0xa0,0x9b,0x97,0x96,0x99,0x9a,0x99,0x93,0x8b,0x7e,0x72,0x64,0x57,0x4f,0x48,
0x42,0x3e,0x37,0x31,0x32,0x36,0x3a,0x3a,0x3a,0x3a,0x38,0x37,0x35,0x37,0x39,0x39,
0x36,0x37,0x3a,0x41,0x4b,0x5a,0x6a,0x78,0x82,0x89,0x8f,0x96,0x9d,0xa3,0xa4,0xa3,
0x9f,0x9c,0x99,0x9a,0x9e,0xa0,0xa0,0x9e,0x9c,0x9b,0x9b,0x9c,0x9c,0x9c,0x9b,0x99,
0x9a,0x9d,0x9f,0x9e,0x97,0x8c,0x7c,0x6c,0x5f,0x56,0x4f,0x48,0x40,0x3b,0x36,0x34,
0x33,0x36,0x38,0x39,0x38,0x36,0x31,0x34,0x32,0x32,0x34,0x35,0x36,0x37,0x38,0x38,
0x3a,0x3a,0x39,0x36,0x34,0x35,0x37,0x3a,0x3a,0x37,0x37,0x34,0x33,0x3a,0x45,0x53,
0x62,0x6f,0x7a,0x84,0x8b,0x92,0x97,0x9b,0x9d,0x9f,0x9e,0x9b,0x98,0x97,0x97,0x97,
0x99,0x9c,0x9d,0x9e,0x9b,0x95,0x8c,0x7e,0x6e,0x5f,0x52,0x48,0x41,0x3d,0x39,0x33,
0x33,0x31,0x30,0x34,0x37,0x3e,0x46,0x4e,0x55,0x63,0x70,0x7d,0x86,0x8d,0x93,0x99,
0x9e,0xa2,0xa2,0xa0,0x9c,0x99,0x97,0x99,0x9c,0xa2,0xa4,0xa3,0xa2,0x9f,0x9c,0x9b,
0x9b,0x9b,0x9c,0x9b,0x98,0x97,0x96,0x97,0x97,0x97,0x97,0x97,0x99,0x9c,0x9b,0x9b,
0x99,0x9b,0x9b,0x9c,0x9b,0x9b,0x9a,0x9b,0x9a,0x9a,0x9a,0x9a,0x9b,0x9c,0x99,0x9b,
0x97,0x99,0x9c,0x9d,0x9c,0x9a,0x99,0x97,0x98,0x99,0x98,0x96,0x96,0x96,0x97,0x99,
0x9a,0x9d,0x9e,0x9d,0x9a,0x9b,0x9b,0x9b,0x99,0x92,0x87,0x79,0x68,0x5b,0x50,0x49,
0x42,0x3b,0x35,0x32,0x30,0x33,0x35,0x3a,0x3d,0x3f,0x3c,0x38,0x33,0x32,0x34,0x36,
0x36,0x34,0x37,0x36,0x34,0x37,0x3a,0x3c,0x3c,0x3a,0x37,0x3a,0x3a,0x3d,0x3d,0x3d,
0x3a,0x39,0x35,0x33,0x34,0x37,0x38,0x38,0x36,0x34,0x34,0x35,0x36,0x38,0x3a,0x3a,
0x39,0x36,0x35,0x36,0x38,0x3a,0x3a,0x36,0x37,0x37,0x36,0x38,0x38,0x39,0x39,0x37,
0x34,0x34,0x36,0x37,0x37,0x36,0x34,0x34,0x34,0x34,0x34,0x37,0x37,0x37,0x36,0x37,
0x38,0x3c,0x3d,0x3c,0x3a,0x3b,0x3a,0x39,0x37,0x36,0x34,0x30,0x2d,0x2d,0x32,0x3e,
0x51,0x65,0x72,0x77,0x74,0x6c,0x61,0x58,0x50,0x4c,0x46,0x41,0x39,0x31,0x2d,0x2d,
0x30,0x3a,0x41,0x46,0x4f,0x57,0x63,0x72,0x7d,0x86,0x91,0x9b,0xa0,0xa0,0x9f,0x9f,
0x9e,0x9b,0x96,0x93,0x93,0x96,0x99,0x9f,0xa1,0x9f,0x96,0x8a,0x7c,0x6f,0x62,0x57,
0x4d,0x48,0x3f,0x39,0x34,0x34,0x38,0x4a,0x5a,0x6b,0x7b,0x86,0x8c,0x92,0x93,0x97,
0x9b,0xa0,0xa0,0x9b,0x8e,0x80,0x73,0x67,0x5c,0x58,0x5a,0x5e,0x65,0x6f,0x79,0x83,
0x8b,0x8f,0x93,0x9c,0xa2,0xa7,0xa4,0x99,0x89,0x76,0x65,0x58,0x51,0x4e,0x49,0x42,
0x3b,0x36,0x31,0x32,0x37,0x3a,0x3d,0x3d,0x3c,0x39,0x3a,0x37,0x37,0x38,0x39,0x39,
0x3c,0x3e,0x3c,0x3c,0x38,0x35,0x33,0x32,0x32,0x36,0x39,0x3b,0x3a,0x3a,0x39,0x3b,
0x3d,0x3f,0x3e,0x3e,0x3a,0x3b,0x3a,0x38,0x37,0x38,0x37,0x35,0x34,0x35,0x37,0x34,
0x36,0x36,0x37,0x38,0x37,0x36,0x38,0x3a,0x38,0x39,0x37,0x37,0x37,0x35,0x33,0x34,
0x36,0x38,0x38,0x37,0x34,0x35,0x38,0x3b,0x3a,0x3a,0x35,0x33,0x33,0x37,0x3d,0x4b,
0x58,0x68,0x77,0x84,0x8d,0x94,0x94,0x8f,0x83,0x75,0x67,0x5b,0x50,0x48,0x3e,0x39,
0x35,0x39,0x44,0x51,0x60,0x72,0x7e,0x86,0x89,0x8e,0x91,0x96,0x9b,0xa0,0x9e,0x9e,
0x99,0x96,0x95,0x95,0x96,0x9a,0x9d,0x9e,0x9b,0x95,0x88,0x7b,0x6b,0x5f,0x55,0x4f,
0x46,0x3c,0x34,0x30,0x34,0x42,0x55,0x67,0x76,0x7b,0x75,0x68,0x5a,0x50,0x4a,0x47,
0x41,0x3a,0x34,0x2e,0x2c,0x32,0x3b,0x41,0x44,0x42,0x3c,0x3a,0x36,0x34,0x34,0x33,
0x30,0x31,0x37,0x44,0x58,0x6d,0x7a,0x7d,0x74,0x67,0x5b,0x56,0x54,0x52,0x4c,0x41,
0x34,0x2c,0x29,0x2f,0x38,0x40,0x43,0x40,0x37,0x30,0x2e,0x34,0x41,0x50,0x60,0x70,
0x7c,0x8a,0x92,0x97,0x99,0x95,0x89,0x79,0x66,0x56,0x4f,0x4f,0x55,0x60,0x6e,0x79,
0x82,0x89,0x8f,0x96,0x9c,0xa0,0xa1,0x9e,0x93,0x86,0x78,0x6a,0x5f,0x59,0x54,0x4e,
0x44,0x3c,0x37,0x37,0x40,0x4f,0x5f,0x74,0x81,0x8f,0x97,0x99,0x95,0x8c,0x82,0x73,
0x65,0x5b,0x50,0x44,0x37,0x30,0x2e,0x36,0x45,0x58,0x6c,0x79,0x7d,0x7b,0x70,0x63,
0x57,0x4d,0x45,0x41,0x3d,0x3a,0x34,0x30,0x2e,0x30,0x38,0x42,0x4f,0x60,0x6e,0x76,
0x79,0x76,0x6d,0x63,0x5c,0x5a,0x5d,0x63,0x69,0x6e,0x74,0x79,0x7f,0x8b,0x97,0xa3,
0xa9,0xa8,0x9f,0x95,0x86,0x77,0x68,0x5b,0x50,0x4a,0x47,0x43,0x3e,0x3a,0x35,0x32,
0x30,0x32,0x36,0x3e,0x48,0x51,0x5c,0x67,0x74,0x81,0x8c,0x93,0x95,0x91,0x87,0x75,
0x68,0x59,0x4e,0x4f,0x55,0x60,0x70,0x7c,0x87,0x92,0x98,0x9c,0x9f,0xa2,0xa0,0x9d,
0x97,0x93,0x90,0x91,0x94,0x99,0x9e,0xa0,0x9f,0x9c,0x97,0x96,0x97,0x9a,0x9b,0x97,
0x8d,0x7f,0x6e,0x5f,0x57,0x57,0x5f,0x6b,0x75,0x7c,0x79,0x6f,0x66,0x62,0x5d,0x59,
0x51,0x46,0x37,0x30,0x2d,0x3a,0x50,0x6a,0x79,0x80,0x79,0x6c,0x60,0x59,0x51,0x4a,
0x41,0x38,0x31,0x30,0x3a,0x4d,0x61,0x72,0x80,0x8b,0x8f,0x92,0x94,0x92,0x88,0x79,
0x65,0x58,0x53,0x59,0x64,0x71,0x78,0x76,0x6e,0x67,0x5d,0x58,0x54,0x4f,0x43,0x3b,
0x30,0x2a,0x2c,0x32,0x39,0x40,0x40,0x40,0x3d,0x3b,0x38,0x37,0x32,0x2f,0x2b,0x2c,
0x34,0x42,0x54,0x64,0x6e,0x74,0x6f,0x67,0x5d,0x55,0x4f,0x4d,0x47,0x40,0x37,0x30,
0x2d,0x2f,0x35,0x3d,0x41,0x43,0x40,0x39,0x34,0x31,0x31,0x33,0x34,0x35,0x37,0x3a,
0x3a,0x38,0x37,0x33,0x31,0x33,0x34,0x34,0x37,0x38,0x37,0x37,0x34,0x32,0x34,0x34,
// Line 13
0x37,0x38,0x39,0x39,0x39,0x38,0x35,0x32,0x32,0x33,0x34,0x35,0x36,0x38,0x38,0x39,
0x38,0x39,0x3b,0x3d,0x3c,0x3d,0x3d,0x3d,0x3b,0x39,0x37,0x36,0x36,0x37,0x37,0x36,
0x34,0x34,0x35,0x34,0x33,0x34,0x35,0x36,0x37,0x37,0x35,0x33,0x31,0x32,0x34,0x37,
0x39,0x38,0x38,0x34,0x32,0x38,0x43,0x53,0x68,0x75,0x79,0x76,0x6c,0x62,0x5a,0x58,
0x5e,0x6b,0x76,0x7b,0x79,0x71,0x66,0x5e,0x5d,0x61,0x68,0x70,0x75,0x76,0x73,0x6c,
0x63,0x5d,0x5a,0x5e,0x67,0x70,0x76,0x78,0x76,0x6e,0x64,0x5e,0x5d,0x64,0x70,0x76,
0x76,0x76,0x71,0x69,0x5f,0x5c,0x5c,0x63,0x6a,0x72,0x76,0x77,0x70,0x68,0x60,0x5c,
0x5a,0x60,0x68,0x6e,0x73,0x73,0x6d,0x64,0x5c,0x58,0x5a,0x61,0x6b,0x73,0x77,0x76,
0x70,0x69,0x63,0x60,0x63,0x66,0x67,0x6a,0x6b,0x6e,0x71,0x76,0x7e,0x8c,0x9a,0xa6,
0xa9,0xab,0xa3,0x98,0x89,0x79,0x6b,0x62,0x5a,0x55,0x4f,0x48,0x3f,0x39,0x38,0x3e,
0x4d,0x60,0x73,0x82,0x8d,0x94,0x98,0x9b,0x9d,0x9f,0xa0,0x9f,0x9b,0x9b,0x9a,0x9a,
0x99,0x93,0x88,0x7c,0x6d,0x61,0x54,0x51,0x48,0x3f,0x39,0x37,0x3e,0x4f,0x63,0x75,
0x82,0x85,0x7d,0x70,0x64,0x5c,0x57,0x4e,0x43,0x39,0x33,0x33,0x3d,0x53,0x6a,0x7e,
0x84,0x80,0x72,0x65,0x5b,0x54,0x4f,0x49,0x41,0x3b,0x35,0x32,0x30,0x36,0x3e,0x48,
0x53,0x61,0x6d,0x79,0x7a,0x76,0x6d,0x64,0x5c,0x58,0x52,0x49,0x40,0x3a,0x37,0x3b,
0x4a,0x61,0x78,0x89,0x92,0x96,0x97,0x95,0x8f,0x86,0x78,0x68,0x5a,0x54,0x5b,0x6a,
0x76,0x7d,0x7a,0x71,0x66,0x5f,0x5d,0x5b,0x54,0x49,0x39,0x2b,0x2c,0x3b,0x56,0x71,
0x80,0x83,0x7b,0x6f,0x62,0x57,0x53,0x4d,0x43,0x3a,0x33,0x34,0x40,0x57,0x70,0x81,
0x85,0x80,0x74,0x67,0x5b,0x53,0x4c,0x44,0x3a,0x33,0x31,0x39,0x4a,0x60,0x76,0x89,
0x93,0x99,0x9c,0x9b,0x95,0x8b,0x7a,0x69,0x5d,0x5a,0x5d,0x64,0x6c,0x77,0x80,0x8b,
0x93,0x9a,0x9f,0x9d,0x8f,0x7c,0x66,0x56,0x4f,0x54,0x61,0x71,0x7a,0x7d,0x74,0x6b,
0x61,0x5a,0x56,0x52,0x4b,0x48,0x3d,0x31,0x2e,0x31,0x39,0x42,0x48,0x47,0x3f,0x36,
0x30,0x33,0x3e,0x51,0x67,0x78,0x7e,0x79,0x6d,0x62,0x5b,0x5d,0x64,0x6e,0x77,0x7b,
0x7e,0x86,0x8f,0x9b,0xa3,0xa3,0x96,0x81,0x6a,0x57,0x4c,0x51,0x57,0x63,0x72,0x7e,
0x88,0x93,0x98,0x9a,0x97,0x8d,0x7d,0x69,0x56,0x4a,0x44,0x41,0x3e,0x3c,0x3b,0x3b,
0x3c,0x3d,0x3e,0x41,0x48,0x51,0x5c,0x68,0x76,0x83,0x8e,0x95,0x99,0x9e,0xa3,0xa6,
0xa1,0x9a,0x8c,0x7c,0x6d,0x61,0x57,0x51,0x4a,0x44,0x41,0x3f,0x3d,0x3a,0x37,0x37,
0x3a,0x42,0x4d,0x5e,0x6e,0x79,0x7b,0x78,0x6d,0x63,0x5b,0x54,0x4f,0x4a,0x43,0x3b,
0x30,0x2e,0x2d,0x33,0x3d,0x48,0x55,0x67,0x71,0x78,0x7a,0x76,0x6f,0x69,0x61,0x5b,
0x55,0x4e,0x43,0x39,0x34,0x39,0x49,0x60,0x76,0x87,0x91,0x96,0x97,0x9a,0x9d,0xa1,
0xa4,0xa3,0x9f,0x9d,0x9e,0xa1,0xa1,0x9b,0x8f,0x7f,0x6f,0x61,0x56,0x51,0x4b,0x43,
0x3a,0x34,0x36,0x45,0x59,0x6f,0x80,0x87,0x80,0x72,0x63,0x5a,0x5a,0x63,0x6b,0x71,
0x76,0x7a,0x80,0x8a,0x93,0x9d,0xa0,0x96,0x82,0x6c,0x5b,0x53,0x55,0x60,0x6d,0x7a,
0x7e,0x78,0x6c,0x62,0x5c,0x5d,0x63,0x6b,0x71,0x75,0x74,0x6f,0x68,0x65,0x65,0x63,
0x67,0x6b,0x70,0x76,0x7b,0x80,0x89,0x90,0x9a,0xa6,0xac,0xac,0xa4,0x97,0x85,0x76,
0x6a,0x61,0x5b,0x57,0x4f,0x48,0x3f,0x39,0x38,0x42,0x53,0x65,0x78,0x87,0x93,0x9c,
0x9f,0x9b,0x94,0x8a,0x7c,0x6c,0x5d,0x55,0x55,0x5e,0x68,0x74,0x81,0x8b,0x90,0x93,
0x92,0x8f,0x85,0x78,0x64,0x54,0x47,0x3e,0x37,0x3b,0x3e,0x42,0x42,0x3f,0x3b,0x3a,
0x3e,0x48,0x59,0x6a,0x77,0x7d,0x78,0x6d,0x61,0x5d,0x5f,0x68,0x72,0x7a,0x7b,0x76,
0x6a,0x60,0x5b,0x5c,0x5b,0x59,0x4f,0x42,0x36,0x2e,0x29,0x2d,0x36,0x42,0x46,0x49,
0x41,0x38,0x35,0x3a,0x43,0x56,0x68,0x78,0x81,0x7f,0x73,0x66,0x5b,0x57,0x5b,0x64,
0x6c,0x74,0x78,0x7e,0x84,0x90,0x9d,0xa8,0xae,0xac,0xa5,0x9c,0x96,0x96,0x99,0x9e,
0x9e,0x9d,0x9c,0x9c,0x9d,0x9f,0x9e,0x9e,0x9f,0x9f,0x9d,0xa1,0xa0,0xa1,0xa1,0x9d,
0x91,0x83,0x74,0x64,0x57,0x53,0x56,0x61,0x6d,0x78,0x7a,0x77,0x6c,0x61,0x5b,0x5e,
0x68,0x76,0x7c,0x7b,0x72,0x69,0x60,0x5c,0x5b,0x5c,0x59,0x4f,0x3e,0x31,0x2c,0x35,
0x46,0x5e,0x75,0x86,0x92,0x96,0x97,0x99,0x9c,0x9f,0xa2,0xa4,0xa3,0x9e,0x9f,0x9d,
0x9d,0x9f,0x9f,0x9f,0x9d,0x9c,0x9b,0x9d,0x9c,0x9b,0x9a,0x99,0x98,0x9b,0x9c,0x9b,
0x95,0x8a,0x7c,0x6d,0x63,0x5a,0x53,0x4c,0x43,0x3b,0x38,0x3b,0x44,0x53,0x63,0x73,
0x7e,0x86,0x8b,0x8f,0x96,0x9c,0x9f,0x9f,0x9d,0x98,0x97,0x96,0x97,0x98,0x93,0x8a,
0x7c,0x6d,0x5e,0x54,0x4c,0x48,0x42,0x3d,0x39,0x3b,0x43,0x52,0x63,0x76,0x84,0x8f,
0x94,0x98,0x99,0x9c,0x9f,0xa3,0xa3,0x9c,0x8f,0x7e,0x6c,0x5d,0x54,0x56,0x5e,0x6a,
0x75,0x7a,0x79,0x76,0x6e,0x69,0x62,0x5a,0x51,0x49,0x3f,0x37,0x2d,0x2d,0x2b,0x2e,
0x34,0x3f,0x49,0x5d,0x69,0x74,0x79,0x74,0x68,0x5d,0x56,0x59,0x64,0x71,0x79,0x7a,
0x74,0x6b,0x64,0x63,0x64,0x66,0x60,0x52,0x3f,0x31,0x2d,0x34,0x47,0x5e,0x75,0x86,
0x90,0x97,0x97,0x93,0x8a,0x7f,0x70,0x62,0x52,0x4a,0x42,0x3c,0x3a,0x38,0x34,0x34,
0x37,0x3d,0x43,0x44,0x3f,0x37,0x30,0x2d,0x33,0x42,0x53,0x63,0x71,0x7d,0x86,0x90,
0x97,0x9a,0x96,0x89,0x76,0x63,0x54,0x51,0x54,0x5c,0x66,0x73,0x7f,0x8c,0x96,0x9f,
0xa2,0x9e,0x92,0x80,0x6a,0x59,0x50,0x52,0x5c,0x69,0x76,0x7f,0x89,0x8f,0x94,0x9a,
0xa1,0xa4,0xa4,0xa1,0x9b,0x9a,0x98,0x99,0x9a,0x96,0x8e,0x84,0x74,0x64,0x54,0x46,
0x3c,0x37,0x36,0x37,0x39,0x39,0x37,0x34,0x36,0x3e,0x49,0x5a,0x6b,0x78,0x7d,0x76,
0x68,0x5c,0x59,0x5d,0x66,0x73,0x7b,0x7a,0x78,0x6e,0x65,0x63,0x64,0x65,0x62,0x56,
0x46,0x3a,0x33,0x39,0x49,0x60,0x75,0x85,0x8f,0x92,0x92,0x93,0x96,0x9c,0xa2,0xa3,
0x9b,0x8e,0x7c,0x6d,0x62,0x5c,0x56,0x51,0x48,0x3e,0x36,0x38,0x41,0x53,0x6c,0x7a,
0x7e,0x7a,0x6c,0x5e,0x56,0x59,0x62,0x70,0x78,0x7a,0x75,0x6d,0x65,0x5f,0x5d,0x5a,
0x55,0x4d,0x43,0x39,0x34,0x32,0x32,0x36,0x3c,0x46,0x54,0x63,0x70,0x78,0x7a,0x76,
0x6c,0x63,0x5b,0x54,0x4e,0x47,0x3e,0x37,0x2f,0x2a,0x2a,0x2f,0x37,0x46,0x57,0x65,
0x6f,0x76,0x74,0x6e,0x66,0x60,0x5a,0x57,0x50,0x48,0x3d,0x34,0x31,0x3d,0x51,0x69,
0x7c,0x84,0x7f,0x71,0x5f,0x52,0x4b,0x48,0x45,0x3f,0x36,0x2c,0x29,0x2f,0x38,0x40,
0x43,0x3f,0x39,0x36,0x36,0x39,0x39,0x3c,0x38,0x37,0x3a,0x46,0x55,0x6c,0x7a,0x7e,
0x79,0x6c,0x5e,0x59,0x5b,0x65,0x71,0x7a,0x7a,0x74,0x6b,0x63,0x5d,0x5b,0x59,0x54,
0x4b,0x3e,0x2e,0x26,0x25,0x2b,0x34,0x3e,0x43,0x46,0x42,0x3b,0x34,0x33,0x33,0x36,
0x38,0x39,0x37,0x3b,0x36,0x36,0x39,0x3a,0x38,0x38,0x37,0x37,0x3a,0x43,0x50,0x5e,
0x6e,0x7c,0x88,0x91,0x97,0x9d,0xa4,0xa4,0xa4,0xa3,0x9a,0x8c,0x7b,0x6a,0x5c,0x53,
0x4b,0x47,0x44,0x41,0x3b,0x37,0x34,0x36,0x39,0x3e,0x3e,0x3d,0x3c,0x3b,0x38,0x39,
0x36,0x36,0x39,0x3c,0x3e,0x3c,0x38,0x33,0x31,0x36,0x40,0x52,0x65,0x74,0x78,0x77,
0x6c,0x5f,0x56,0x57,0x5e,0x6b,0x75,0x7a,0x78,0x72,0x6a,0x66,0x66,0x6a,0x6d,0x71,
0x71,0x71,0x74,0x79,0x81,0x8f,0x9a,0xa4,0xa9,0xa8,0xa1,0x9a,0x94,0x91,0x92,0x94,
0x94,0x90,0x84,0x73,0x61,0x53,0x48,0x43,0x40,0x3f,0x3a,0x38,0x35,0x35,0x35,0x3a,
0x3f,0x49,0x52,0x5e,0x68,0x78,0x84,0x8f,0x98,0x9b,0x96,0x8b,0x7a,0x69,0x5c,0x55,
0x55,0x5e,0x69,0x74,0x7e,0x89,0x92,0x99,0x9b,0x99,0x90,0x80,0x6c,0x5b,0x52,0x51,
0x59,0x67,0x75,0x81,0x8b,0x92,0x96,0x9c,0xa1,0xa4,0xa1,0x9f,0x94,0x89,0x7b,0x6e,
0x62,0x5c,0x59,0x5b,0x62,0x6b,0x74,0x7e,0x88,0x91,0x99,0x9d,0x9d,0x94,0x84,0x70,
0x5c,0x52,0x50,0x57,0x63,0x70,0x7b,0x85,0x8c,0x93,0x9a,0xa1,0xa6,0xa9,0xa4,0x99,
0x89,0x7a,0x6b,0x5f,0x57,0x50,0x48,0x41,0x37,0x31,0x34,0x40,0x53,0x6a,0x7a,0x80,
0x7b,0x71,0x62,0x55,0x4c,0x4a,0x48,0x44,0x3e,0x38,0x35,0x32,0x33,0x3c,0x47,0x54,
0x60,0x6e,0x74,0x76,0x72,0x6b,0x60,0x57,0x50,0x4d,0x48,0x40,0x34,0x2b,0x26,0x28,
0x30,0x39,0x41,0x42,0x3d,0x37,0x34,0x35,0x37,0x3a,0x3a,0x39,0x3b,0x42,0x4f,0x60,
0x71,0x7d,0x85,0x8c,0x91,0x96,0x9a,0x9e,0x9d,0x9d,0x98,0x8e,0x7d,0x71,0x63,0x58,
0x57,0x5e,0x69,0x76,0x7b,0x7a,0x72,0x67,0x5e,0x5c,0x5e,0x64,0x6a,0x6e,0x71,0x75,
0x7c,0x87,0x93,0xa1,0xa8,0xaa,0xa5,0x9c,0x90,0x84,0x77,0x6a,0x5c,0x51,0x49,0x45,
0x42,0x3f,0x3b,0x3a,0x36,0x32,0x33,0x39,0x42,0x53,0x61,0x6b,0x74,0x78,0x74,0x6e,
0x65,0x5f,0x5b,0x57,0x4d,0x43,0x39,0x35,0x38,0x47,0x5b,0x73,0x85,0x90,0x95,0x97,
0x98,0x9b,0x9e,0xa1,0x9f,0x9f,0x9d,0x9a,0x97,0x96,0x99,0x9c,0x9f,0x9f,0x9c,0x97,
0x8d,0x80,0x70,0x63,0x59,0x51,0x4b,0x42,0x3c,0x37,0x32,0x2f,0x32,0x36,0x39,0x3d,
0x3b,0x38,0x37,0x35,0x34,0x37,0x38,0x39,0x39,0x39,0x38,0x38,0x37,0x37,0x38,0x3a,
0x39,0x3a,0x3d,0x3d,0x3d,0x3d,0x3c,0x3b,0x3b,0x3c,0x3b,0x3a,0x39,0x37,0x35,0x35,
// Line 14
0x39,0x3b,0x3a,0x38,0x36,0x37,0x38,0x39,0x37,0x37,0x35,0x34,0x35,0x36,0x37,0x3a,
0x3b,0x3a,0x3a,0x3b,0x3c,0x3d,0x3c,0x39,0x37,0x37,0x36,0x37,0x37,0x37,0x35,0x36,
0x36,0x37,0x37,0x38,0x37,0x37,0x38,0x39,0x39,0x38,0x36,0x34,0x32,0x32,0x31,0x36,
0x34,0x36,0x37,0x39,0x3c,0x44,0x50,0x5a,0x64,0x6b,0x72,0x79,0x81,0x88,0x8f,0x95,
0x97,0x97,0x95,0x95,0x94,0x96,0x97,0x98,0x98,0x97,0x95,0x98,0x9a,0x9b,0x98,0x92,
0x89,0x82,0x79,0x6f,0x64,0x5c,0x53,0x4c,0x46,0x42,0x3d,0x3a,0x38,0x37,0x39,0x3a,
0x3b,0x3b,0x39,0x37,0x34,0x36,0x37,0x38,0x3a,0x3a,0x38,0x3a,0x3c,0x41,0x48,0x51,
0x5a,0x64,0x6d,0x77,0x80,0x87,0x8d,0x91,0x95,0x97,0x98,0x96,0x95,0x94,0x95,0x95,
0x93,0x94,0x94,0x95,0x95,0x96,0x95,0x92,0x8c,0x84,0x7c,0x76,0x6d,0x64,0x5e,0x52,
0x48,0x43,0x3e,0x3b,0x37,0x36,0x35,0x35,0x34,0x36,0x37,0x39,0x37,0x37,0x39,0x39,
0x37,0x37,0x38,0x3a,0x3d,0x3f,0x43,0x4a,0x52,0x5b,0x65,0x70,0x7a,0x83,0x8a,0x8e,
0x90,0x93,0x96,0x97,0x97,0x96,0x95,0x96,0x95,0x95,0x95,0x98,0x99,0x9a,0x98,0x96,
0x8f,0x8d,0x85,0x7c,0x74,0x6d,0x63,0x5a,0x50,0x48,0x43,0x3f,0x3c,0x3a,0x37,0x36,
0x36,0x37,0x37,0x37,0x38,0x3a,0x3a,0x3c,0x3d,0x3d,0x3d,0x3a,0x39,0x3d,0x41,0x46,
0x49,0x54,0x5c,0x67,0x6f,0x78,0x80,0x89,0x8f,0x93,0x96,0x98,0x9a,0x9b,0x9a,0x9a,
0x9b,0x9c,0x9b,0x9a,0x98,0x96,0x95,0x94,0x92,0x90,0x8c,0x85,0x7d,0x76,0x6d,0x62,
0x59,0x50,0x48,0x43,0x3e,0x3b,0x38,0x37,0x36,0x37,0x37,0x39,0x3a,0x3b,0x3a,0x37,
0x38,0x3a,0x3a,0x3c,0x3c,0x3c,0x3d,0x40,0x45,0x4a,0x55,0x5e,0x6a,0x74,0x7d,0x84,
0x8b,0x92,0x97,0x9a,0x99,0x99,0x98,0x98,0x95,0x96,0x96,0x96,0x96,0x97,0x96,0x95,
0x93,0x92,0x91,0x8c,0x84,0x7b,0x74,0x6d,0x63,0x5c,0x53,0x4d,0x47,0x44,0x3f,0x3c,
0x3a,0x39,0x39,0x3a,0x39,0x39,0x39,0x38,0x37,0x3b,0x3c,0x3d,0x3d,0x3d,0x3e,0x42,
0x46,0x4c,0x52,0x5a,0x62,0x6a,0x72,0x7b,0x84,0x8d,0x93,0x96,0x98,0x99,0x99,0x9a,
0x9a,0x9b,0x9c,0x9b,0x9a,0x98,0x98,0x96,0x95,0x97,0x96,0x92,0x8b,0x83,0x78,0x71,
0x69,0x60,0x5a,0x50,0x48,0x43,0x40,0x3e,0x3d,0x3c,0x3b,0x39,0x37,0x38,0x3b,0x3d,
0x3e,0x3d,0x3c,0x3a,0x39,0x39,0x3a,0x3d,0x43,0x48,0x4c,0x51,0x59,0x63,0x6f,0x7a,
0x81,0x87,0x8c,0x8f,0x92,0x96,0x98,0x98,0x9a,0x9a,0x98,0x98,0x98,0x98,0x97,0x97,
0x95,0x96,0x96,0x93,0x90,0x8b,0x82,0x78,0x6f,0x6a,0x62,0x5a,0x52,0x4a,0x45,0x42,
0x40,0x40,0x3e,0x3d,0x3d,0x3d,0x3b,0x3a,0x3a,0x3a,0x39,0x3a,0x3a,0x3c,0x3d,0x3b,
0x39,0x39,0x3a,0x39,0x3a,0x3c,0x3c,0x3d,0x3c,0x3c,0x3b,0x3c,0x3c,0x3d,0x3e,0x3e,
0x3d,0x3d,0x3a,0x3a,0x3c,0x3d,0x3d,0x3e,0x3e,0x3f,0x3f,0x3e,0x3e,0x3d,0x3e,0x3c,
0x3a,0x3a,0x39,0x39,0x3a,0x3b,0x3a,0x3b,0x3b,0x3d,0x3d,0x3c,0x3b,0x3c,0x3d,0x3d,
0x3b,0x3b,0x39,0x39,0x39,0x3a,0x3b,0x3b,0x3a,0x3a,0x3b,0x3d,0x3d,0x3d,0x3d,0x3c,
0x3b,0x3c,0x3b,0x39,0x3a,0x3b,0x39,0x37,0x35,0x36,0x37,0x39,0x38,0x3a,0x3a,0x3a,
0x39,0x39,0x39,0x3b,0x3a,0x3d,0x3d,0x3f,0x41,0x47,0x4f,0x59,0x63,0x6d,0x75,0x7c,
0x85,0x8d,0x92,0x95,0x97,0x98,0x9a,0x9a,0x98,0x97,0x96,0x95,0x94,0x94,0x93,0x94,
0x96,0x95,0x94,0x96,0x96,0x99,0x9b,0x9c,0x9b,0x9a,0x98,0x97,0x96,0x97,0x97,0x95,
0x94,0x94,0x95,0x96,0x95,0x96,0x97,0x97,0x97,0x97,0x97,0x97,0x98,0x98,0x93,0x8d,
0x85,0x7d,0x75,0x6d,0x63,0x5c,0x56,0x4d,0x44,0x40,0x3e,0x3e,0x3d,0x40,0x3d,0x3a,
0x38,0x3a,0x39,0x3a,0x39,0x37,0x38,0x39,0x37,0x37,0x35,0x36,0x39,0x3c,0x3b,0x39,
0x37,0x39,0x3c,0x3d,0x3d,0x3d,0x3d,0x3e,0x3b,0x38,0x36,0x39,0x3c,0x3c,0x3a,0x3a,
0x3a,0x3b,0x38,0x3b,0x3a,0x3d,0x3d,0x3d,0x39,0x39,0x37,0x37,0x39,0x39,0x37,0x36,
0x34,0x35,0x36,0x37,0x39,0x3b,0x3a,0x3a,0x3b,0x3c,0x3c,0x3a,0x39,0x39,0x38,0x38,
0x37,0x37,0x37,0x36,0x35,0x37,0x3a,0x3d,0x3d,0x3c,0x3a,0x3c,0x3d,0x3e,0x3a,0x3d,
0x3a,0x39,0x39,0x37,0x35,0x38,0x3a,0x39,0x38,0x39,0x3c,0x3d,0x3d,0x3b,0x3b,0x3b,
0x39,0x39,0x37,0x37,0x36,0x36,0x35,0x36,0x36,0x37,0x36,0x36,0x35,0x36,0x37,0x38,
0x39,0x3b,0x3d,0x3c,0x3a,0x3a,0x3b,0x3c,0x3d,0x3d,0x3b,0x3c,0x37,0x37,0x38,0x3a,
0x3c,0x3d,0x3c,0x3a,0x39,0x39,0x37,0x37,0x37,0x39,0x38,0x3a,0x37,0x36,0x36,0x35,
0x35,0x37,0x38,0x3a,0x37,0x35,0x33,0x33,0x34,0x37,0x37,0x38,0x37,0x37,0x35,0x35,
0x34,0x37,0x39,0x39,0x39,0x39,0x37,0x37,0x37,0x37,0x37,0x39,0x3a,0x3b,0x3a,0x3a,
0x39,0x3b,0x3a,0x3a,0x3b,0x3c,0x38,0x36,0x34,0x37,0x37,0x39,0x37,0x3a,0x3d,0x3d,
0x39,0x39,0x39,0x3a,0x3d,0x3d,0x3b,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3c,0x3b,0x38,
0x36,0x36,0x36,0x37,0x37,0x39,0x37,0x37,0x36,0x36,0x37,0x37,0x37,0x37,0x38,0x3a,
0x38,0x37,0x34,0x36,0x38,0x3a,0x36,0x38,0x35,0x34,0x35,0x37,0x37,0x3d,0x3b,0x39,
0x37,0x37,0x37,0x37,0x39,0x3a,0x3a,0x38,0x37,0x38,0x39,0x39,0x39,0x3b,0x39,0x37,
0x37,0x39,0x37,0x37,0x37,0x37,0x37,0x37,0x36,0x37,0x38,0x39,0x37,0x37,0x36,0x35,
0x36,0x37,0x36,0x39,0x36,0x36,0x37,0x37,0x37,0x37,0x36,0x34,0x32,0x32,0x33,0x33,
0x36,0x37,0x37,0x3a,0x3a,0x38,0x38,0x3a,0x3a,0x3a,0x37,0x36,0x34,0x34,0x33,0x34,
0x36,0x37,0x37,0x37,0x35,0x35,0x36,0x37,0x37,0x39,0x38,0x38,0x38,0x39,0x39,0x39,
0x37,0x36,0x35,0x34,0x34,0x33,0x37,0x37,0x37,0x3a,0x3a,0x39,0x3a,0x37,0x36,0x37,
0x36,0x36,0x36,0x36,0x32,0x32,0x32,0x35,0x36,0x37,0x37,0x37,0x39,0x37,0x36,0x37,
0x37,0x37,0x38,0x38,0x37,0x38,0x37,0x37,0x37,0x37,0x37,0x39,0x3a,0x3c,0x3c,0x3d,
0x3b,0x39,0x3a,0x38,0x37,0x37,0x37,0x37,0x37,0x36,0x33,0x33,0x34,0x37,0x37,0x37,
0x34,0x33,0x34,0x34,0x32,0x34,0x35,0x35,0x35,0x37,0x37,0x3a,0x39,0x39,0x37,0x37,
0x37,0x37,0x36,0x35,0x35,0x37,0x36,0x36,0x37,0x37,0x36,0x37,0x37,0x37,0x39,0x3a,
0x37,0x38,0x3a,0x3a,0x38,0x3a,0x3a,0x3a,0x3b,0x3a,0x39,0x37,0x36,0x36,0x37,0x38,
0x39,0x3a,0x38,0x36,0x35,0x35,0x37,0x37,0x37,0x37,0x36,0x35,0x34,0x34,0x36,0x37,
0x39,0x3c,0x3b,0x3b,0x3b,0x3b,0x3c,0x3c,0x3b,0x3a,0x39,0x37,0x37,0x37,0x37,0x37,
0x35,0x39,0x37,0x37,0x38,0x3a,0x3a,0x3a,0x37,0x36,0x36,0x37,0x37,0x38,0x39,0x37,
0x34,0x35,0x37,0x37,0x37,0x37,0x37,0x38,0x37,0x38,0x38,0x38,0x37,0x38,0x39,0x39,
0x37,0x39,0x36,0x35,0x37,0x39,0x3b,0x3b,0x39,0x39,0x3b,0x3a,0x3a,0x3b,0x3b,0x39,
0x37,0x35,0x34,0x33,0x32,0x32,0x32,0x34,0x35,0x35,0x36,0x37,0x37,0x3a,0x3a,0x3a,
0x3b,0x3c,0x3a,0x39,0x36,0x36,0x37,0x37,0x37,0x37,0x39,0x38,0x37,0x37,0x37,0x38,
0x39,0x3a,0x3a,0x3b,0x3b,0x39,0x38,0x39,0x39,0x36,0x35,0x34,0x32,0x34,0x34,0x32,
0x32,0x34,0x34,0x37,0x38,0x3a,0x3b,0x3c,0x3a,0x39,0x37,0x37,0x37,0x38,0x36,0x34,
0x34,0x34,0x33,0x34,0x34,0x35,0x37,0x39,0x39,0x39,0x3a,0x39,0x37,0x36,0x36,0x37,
0x37,0x36,0x37,0x38,0x37,0x37,0x39,0x38,0x37,0x3a,0x3a,0x38,0x37,0x37,0x36,0x37,
0x37,0x3a,0x39,0x39,0x39,0x39,0x3a,0x3a,0x38,0x38,0x37,0x37,0x36,0x35,0x34,0x36,
0x34,0x34,0x36,0x36,0x36,0x34,0x35,0x34,0x34,0x36,0x37,0x35,0x37,0x36,0x36,0x37,
0x37,0x37,0x37,0x38,0x39,0x3a,0x39,0x38,0x38,0x37,0x35,0x36,0x37,0x39,0x38,0x37,
0x36,0x35,0x35,0x36,0x36,0x37,0x37,0x35,0x36,0x38,0x3c,0x42,0x4a,0x52,0x59,0x61,
0x6a,0x74,0x7e,0x83,0x88,0x8e,0x91,0x92,0x94,0x94,0x93,0x95,0x95,0x96,0x95,0x95,
0x96,0x98,0x98,0x97,0x98,0x9b,0x98,0x96,0x97,0x96,0x95,0x95,0x94,0x95,0x96,0x95,
0x95,0x95,0x93,0x93,0x93,0x94,0x94,0x95,0x96,0x94,0x92,0x95,0x97,0x98,0x9b,0x99,
0x96,0x94,0x91,0x8c,0x84,0x7c,0x70,0x67,0x5e,0x56,0x4d,0x47,0x40,0x3d,0x3c,0x3a,
0x37,0x38,0x39,0x38,0x39,0x39,0x38,0x37,0x37,0x38,0x37,0x37,0x36,0x37,0x39,0x38,
0x36,0x37,0x38,0x39,0x3a,0x39,0x39,0x3a,0x3a,0x39,0x39,0x39,0x37,0x37,0x36,0x37,
0x35,0x39,0x39,0x38,0x38,0x39,0x38,0x39,0x39,0x39,0x3a,0x3a,0x39,0x39,0x39,0x39,
0x3a,0x3d,0x3c,0x38,0x39,0x37,0x37,0x38,0x38,0x36,0x37,0x36,0x35,0x37,0x38,0x38,
0x37,0x38,0x37,0x37,0x36,0x37,0x37,0x38,0x36,0x35,0x35,0x36,0x36,0x37,0x37,0x37,
0x39,0x39,0x37,0x37,0x37,0x3a,0x3a,0x3b,0x3a,0x38,0x36,0x34,0x35,0x39,0x3b,0x3a,
0x3a,0x38,0x35,0x35,0x35,0x36,0x37,0x37,0x35,0x34,0x32,0x33,0x32,0x36,0x36,0x36,
0x36,0x37,0x37,0x39,0x37,0x38,0x39,0x38,0x37,0x39,0x3a,0x38,0x37,0x36,0x34,0x34,
0x32,0x32,0x32,0x34,0x33,0x32,0x31,0x31,0x32,0x34,0x35,0x34,0x34,0x34,0x34,0x36,
0x37,0x37,0x36,0x3a,0x36,0x35,0x36,0x38,0x3a,0x3b,0x39,0x39,0x3a,0x3b,0x3a,0x38,
0x37,0x37,0x37,0x37,0x36,0x37,0x37,0x37,0x35,0x35,0x32,0x32,0x33,0x33,0x32,0x33,
0x32,0x34,0x35,0x35,0x35,0x37,0x3a,0x3c,0x3a,0x3a,0x3a,0x37,0x37,0x39,0x38,0x3a,
// Line 15
0x38,0x37,0x35,0x36,0x37,0x39,0x3a,0x3a,0x38,0x39,0x3a,0x3a,0x38,0x37,0x36,0x36,
0x36,0x36,0x35,0x35,0x35,0x35,0x37,0x39,0x39,0x3a,0x39,0x37,0x36,0x37,0x36,0x36,
0x35,0x35,0x35,0x36,0x36,0x37,0x36,0x35,0x34,0x35,0x36,0x35,0x34,0x32,0x31,0x31,
0x33,0x36,0x37,0x39,0x36,0x33,0x35,0x3c,0x4c,0x62,0x73,0x7d,0x7f,0x79,0x6c,0x61,
0x5b,0x5f,0x68,0x72,0x78,0x7a,0x74,0x6b,0x62,0x5f,0x61,0x68,0x70,0x77,0x7a,0x7a,
0x75,0x6f,0x67,0x62,0x62,0x68,0x70,0x75,0x77,0x75,0x71,0x67,0x61,0x5e,0x60,0x6a,
0x73,0x79,0x7c,0x7a,0x73,0x6c,0x68,0x65,0x67,0x6d,0x73,0x77,0x79,0x75,0x6f,0x69,
0x62,0x5f,0x61,0x68,0x71,0x79,0x7d,0x7c,0x74,0x6a,0x61,0x60,0x65,0x6f,0x76,0x7c,
0x7c,0x7a,0x73,0x6a,0x64,0x64,0x69,0x6e,0x71,0x73,0x73,0x77,0x7a,0x80,0x89,0x96,
0xa3,0xab,0xae,0xa6,0x9b,0x8f,0x81,0x73,0x69,0x61,0x58,0x54,0x4c,0x45,0x3e,0x3b,
0x3d,0x48,0x57,0x6a,0x7b,0x88,0x91,0x96,0x9a,0x9b,0x9d,0xa1,0xa3,0xa3,0x9a,0x8c,
0x7c,0x6e,0x62,0x5e,0x5f,0x65,0x6d,0x74,0x7b,0x82,0x88,0x91,0x99,0xa1,0xa7,0xa8,
0xa3,0x9e,0x99,0x98,0x96,0x9a,0x99,0x96,0x8e,0x80,0x6d,0x5d,0x54,0x56,0x61,0x6f,
0x7a,0x82,0x81,0x78,0x6e,0x66,0x63,0x66,0x6d,0x74,0x7a,0x7b,0x77,0x71,0x69,0x65,
0x67,0x6e,0x74,0x7a,0x7d,0x7c,0x75,0x6e,0x66,0x64,0x67,0x70,0x77,0x7c,0x7c,0x78,
0x70,0x6a,0x63,0x5f,0x5e,0x5b,0x52,0x4a,0x3c,0x32,0x2d,0x2d,0x31,0x38,0x40,0x4b,
0x57,0x66,0x72,0x7b,0x7c,0x77,0x6c,0x63,0x60,0x64,0x6f,0x79,0x7f,0x80,0x79,0x6f,
0x64,0x60,0x61,0x6a,0x73,0x7a,0x78,0x75,0x6b,0x63,0x5f,0x5e,0x5c,0x5c,0x55,0x4b,
0x41,0x36,0x2e,0x2c,0x2f,0x36,0x3f,0x4a,0x55,0x61,0x6a,0x72,0x79,0x84,0x8e,0x98,
0xa1,0xa7,0xa9,0xa9,0xa4,0x9f,0x99,0x98,0x9a,0x9e,0x9c,0x94,0x84,0x72,0x61,0x59,
0x5b,0x64,0x70,0x7c,0x7d,0x77,0x6c,0x63,0x5e,0x5b,0x5a,0x52,0x47,0x3d,0x37,0x3a,
0x49,0x61,0x78,0x88,0x8a,0x80,0x6f,0x5e,0x57,0x5b,0x67,0x74,0x7b,0x7d,0x76,0x6e,
0x67,0x63,0x65,0x6d,0x73,0x78,0x7b,0x79,0x71,0x6b,0x64,0x60,0x5e,0x5a,0x55,0x4a,
0x43,0x38,0x2f,0x2e,0x2f,0x38,0x46,0x52,0x5c,0x67,0x6e,0x75,0x7d,0x87,0x90,0x97,
0x99,0x94,0x87,0x75,0x62,0x58,0x59,0x65,0x73,0x80,0x85,0x83,0x7b,0x6f,0x65,0x5e,
0x56,0x4e,0x42,0x36,0x2e,0x32,0x40,0x56,0x6d,0x83,0x91,0x98,0x9a,0x9b,0x98,0x92,
0x88,0x7b,0x6d,0x61,0x59,0x5e,0x67,0x73,0x7e,0x86,0x8c,0x93,0x9a,0xa1,0xa6,0xa8,
0xa5,0x9e,0x95,0x88,0x79,0x6d,0x62,0x59,0x52,0x4c,0x45,0x3d,0x3a,0x3d,0x49,0x5a,
0x6d,0x80,0x8e,0x96,0x98,0x9b,0x9e,0xa3,0xaa,0xaa,0xa4,0x9d,0x97,0x95,0x95,0x96,
0x93,0x8e,0x81,0x71,0x62,0x5b,0x5e,0x67,0x77,0x81,0x83,0x7f,0x77,0x6e,0x67,0x65,
0x68,0x6b,0x71,0x74,0x77,0x7c,0x83,0x8f,0x9b,0xa5,0xab,0xad,0xa8,0xa0,0x99,0x97,
0x98,0x9c,0x9d,0x99,0x8e,0x7f,0x6e,0x60,0x55,0x4e,0x46,0x40,0x3a,0x3b,0x44,0x54,
0x65,0x78,0x83,0x84,0x7c,0x6f,0x60,0x52,0x4e,0x48,0x43,0x3e,0x39,0x32,0x2f,0x2b,
0x2f,0x3a,0x49,0x58,0x67,0x72,0x77,0x78,0x72,0x6c,0x65,0x60,0x5b,0x56,0x4d,0x42,
0x3a,0x39,0x3f,0x50,0x67,0x80,0x92,0x9b,0x9a,0x98,0x99,0x9d,0xa1,0xa6,0xa6,0x9e,
0x8f,0x7d,0x6c,0x5f,0x58,0x5a,0x62,0x6e,0x77,0x7d,0x7d,0x76,0x6d,0x68,0x66,0x6a,
0x73,0x7b,0x7e,0x7a,0x73,0x6c,0x67,0x69,0x6a,0x70,0x76,0x76,0x75,0x7a,0x7e,0x87,
0x92,0x9d,0xa5,0xa7,0xa9,0xa7,0xa2,0x99,0x8c,0x7d,0x6e,0x60,0x5b,0x61,0x6a,0x74,
0x7c,0x7e,0x77,0x6e,0x63,0x5e,0x59,0x55,0x4e,0x46,0x3b,0x33,0x2b,0x29,0x2e,0x39,
0x42,0x45,0x40,0x3a,0x36,0x36,0x37,0x36,0x36,0x38,0x3a,0x42,0x4e,0x61,0x73,0x7e,
0x81,0x77,0x65,0x5a,0x5a,0x63,0x73,0x7c,0x7f,0x7d,0x74,0x6b,0x65,0x65,0x67,0x64,
0x59,0x48,0x35,0x2a,0x2d,0x3f,0x57,0x6f,0x7e,0x84,0x7e,0x71,0x61,0x56,0x4e,0x4a,
0x45,0x3e,0x37,0x32,0x2f,0x2f,0x36,0x3c,0x46,0x55,0x63,0x70,0x77,0x78,0x72,0x6a,
0x60,0x58,0x52,0x50,0x4c,0x45,0x3b,0x31,0x29,0x2b,0x32,0x3f,0x4b,0x56,0x5f,0x66,
0x6f,0x7c,0x8a,0x95,0x9d,0x9f,0x98,0x8a,0x78,0x6a,0x5e,0x59,0x5d,0x67,0x73,0x7e,
0x81,0x7c,0x72,0x67,0x5e,0x62,0x6b,0x76,0x7d,0x7e,0x79,0x71,0x67,0x61,0x5f,0x67,
0x6f,0x75,0x79,0x77,0x72,0x6a,0x63,0x61,0x63,0x6a,0x70,0x73,0x75,0x77,0x79,0x81,
0x8e,0x9d,0xa9,0xb0,0xb0,0xab,0x9f,0x90,0x80,0x71,0x62,0x58,0x50,0x4b,0x44,0x3e,
0x38,0x33,0x31,0x31,0x35,0x3a,0x40,0x40,0x3d,0x3a,0x36,0x34,0x33,0x35,0x37,0x36,
0x35,0x33,0x34,0x36,0x39,0x3b,0x3b,0x39,0x35,0x33,0x35,0x40,0x52,0x65,0x74,0x7c,
0x7b,0x78,0x70,0x68,0x64,0x6a,0x6f,0x75,0x7c,0x80,0x81,0x89,0x91,0x98,0x9b,0x96,
0x88,0x77,0x61,0x4f,0x42,0x3c,0x3b,0x3c,0x3e,0x3f,0x3f,0x42,0x43,0x41,0x3d,0x38,
0x34,0x35,0x37,0x38,0x35,0x2f,0x2b,0x31,0x3d,0x50,0x63,0x75,0x7d,0x7d,0x73,0x66,
0x5d,0x5c,0x59,0x51,0x48,0x3d,0x35,0x35,0x3e,0x51,0x6a,0x7e,0x8c,0x94,0x96,0x96,
0x96,0x9d,0xa1,0xa4,0xa0,0x98,0x88,0x7a,0x6a,0x5e,0x54,0x49,0x40,0x3c,0x3a,0x3a,
0x37,0x35,0x32,0x35,0x3a,0x46,0x54,0x67,0x74,0x7c,0x7b,0x74,0x6a,0x62,0x5f,0x60,
0x67,0x6d,0x72,0x77,0x7b,0x83,0x8e,0x9b,0xa5,0xae,0xb2,0xad,0xa4,0x99,0x8a,0x7d,
0x71,0x68,0x64,0x66,0x69,0x71,0x77,0x7e,0x83,0x8b,0x94,0x9b,0x9a,0x96,0x87,0x72,
0x5f,0x54,0x56,0x62,0x70,0x7b,0x81,0x7e,0x74,0x67,0x62,0x60,0x5d,0x57,0x4a,0x3a,
0x35,0x39,0x48,0x61,0x78,0x88,0x8c,0x81,0x6e,0x5f,0x59,0x5f,0x69,0x75,0x7c,0x7e,
0x78,0x6e,0x64,0x62,0x64,0x6b,0x71,0x75,0x78,0x7c,0x80,0x87,0x92,0x9e,0xa3,0x9e,
0x90,0x7c,0x67,0x55,0x47,0x40,0x3e,0x3c,0x3a,0x41,0x4c,0x5c,0x6c,0x7c,0x86,0x92,
0x98,0x9b,0x96,0x90,0x83,0x75,0x62,0x54,0x49,0x45,0x41,0x3f,0x3c,0x3a,0x38,0x39,
0x3a,0x3c,0x3e,0x3a,0x34,0x2f,0x2f,0x37,0x47,0x5a,0x6b,0x7a,0x85,0x8c,0x93,0x9a,
0xa0,0xa5,0xa6,0xa4,0x9f,0x9d,0x9a,0x9b,0x9c,0x9f,0xa0,0xa3,0xa5,0xa7,0xa5,0xa7,
0xa3,0x9f,0x9c,0x99,0x99,0x9d,0x9e,0x9e,0x9a,0x92,0x85,0x76,0x68,0x5c,0x53,0x4c,
0x44,0x3d,0x37,0x37,0x3e,0x4d,0x5f,0x73,0x83,0x8f,0x95,0x99,0x9a,0x98,0x90,0x82,
0x70,0x61,0x51,0x44,0x3b,0x39,0x36,0x35,0x35,0x38,0x3a,0x40,0x40,0x3e,0x3b,0x38,
0x36,0x37,0x35,0x33,0x33,0x35,0x36,0x3b,0x46,0x56,0x66,0x77,0x81,0x8a,0x91,0x98,
0x9f,0xa7,0xac,0xac,0xa8,0xa3,0x9e,0x9d,0x9f,0xa3,0xa3,0xa3,0xa1,0xa0,0x9f,0x9d,
0x9d,0x9d,0x9c,0x97,0x91,0x89,0x7e,0x71,0x61,0x53,0x49,0x43,0x40,0x3b,0x3e,0x39,
0x32,0x32,0x33,0x3b,0x47,0x53,0x5f,0x6b,0x77,0x83,0x8f,0x96,0x9a,0x9a,0x92,0x82,
0x6f,0x5f,0x52,0x4a,0x44,0x3f,0x3a,0x39,0x37,0x38,0x3a,0x3e,0x40,0x3e,0x36,0x2f,
0x2b,0x2f,0x3a,0x45,0x59,0x6b,0x77,0x84,0x8d,0x96,0xa1,0xa2,0x9a,0x8e,0x7d,0x6c,
0x60,0x5b,0x5f,0x69,0x75,0x80,0x87,0x8d,0x92,0x98,0xa0,0xa5,0xa6,0xa3,0x9f,0x9a,
0x98,0x99,0x9b,0x9b,0x95,0x8b,0x7e,0x6f,0x5f,0x53,0x4a,0x46,0x40,0x3e,0x3d,0x44,
0x50,0x5f,0x6f,0x80,0x8e,0x98,0x9b,0x9b,0x9a,0x9d,0xa1,0xa3,0x9f,0x97,0x8a,0x78,
0x67,0x5b,0x58,0x5f,0x6a,0x75,0x7c,0x7d,0x7a,0x73,0x6a,0x64,0x61,0x5f,0x57,0x4a,
0x3f,0x39,0x3a,0x46,0x57,0x6e,0x82,0x8f,0x94,0x95,0x97,0x9b,0x9d,0xa4,0xa5,0xa3,
0x9f,0x9d,0x9b,0x9e,0x9f,0x9b,0x91,0x80,0x6b,0x5e,0x57,0x5c,0x67,0x74,0x7e,0x80,
0x7c,0x75,0x6d,0x68,0x63,0x5c,0x55,0x49,0x3d,0x37,0x37,0x40,0x54,0x6b,0x80,0x90,
0x98,0x9b,0x9c,0x9d,0x9f,0xa6,0xa9,0xa7,0x9b,0x8b,0x79,0x6b,0x61,0x59,0x50,0x4a,
0x40,0x38,0x39,0x41,0x52,0x64,0x74,0x7c,0x7c,0x75,0x69,0x5b,0x56,0x52,0x4b,0x45,
0x3c,0x38,0x3b,0x42,0x51,0x65,0x7b,0x8d,0x95,0x99,0x96,0x98,0x9b,0xa0,0xa3,0xa1,
0x99,0x8b,0x7d,0x70,0x65,0x61,0x61,0x65,0x6c,0x75,0x7f,0x88,0x8e,0x93,0x9a,0xa0,
0xa3,0xa5,0xa4,0x9f,0x95,0x89,0x7b,0x6e,0x66,0x63,0x64,0x69,0x6d,0x75,0x7d,0x87,
0x8e,0x96,0x9c,0xa0,0xa3,0xa3,0xa0,0x9b,0x93,0x87,0x77,0x69,0x5e,0x5b,0x60,0x68,
0x73,0x7e,0x83,0x80,0x77,0x6d,0x65,0x61,0x65,0x6b,0x71,0x77,0x77,0x72,0x6b,0x63,
0x5f,0x63,0x69,0x71,0x75,0x7a,0x77,0x72,0x6c,0x69,0x66,0x67,0x6a,0x72,0x7a,0x7d,
0x7a,0x75,0x6c,0x65,0x60,0x64,0x6f,0x7c,0x81,0x81,0x7b,0x71,0x66,0x5f,0x5a,0x59,
0x58,0x55,0x4a,0x3b,0x2f,0x29,0x29,0x2f,0x37,0x3f,0x43,0x45,0x3e,0x36,0x32,0x31,
0x32,0x36,0x39,0x3b,0x3b,0x3b,0x3a,0x3b,0x38,0x35,0x36,0x38,0x38,0x3b,0x3d,0x3d,
0x3b,0x3a,0x38,0x36,0x35,0x37,0x39,0x3a,0x39,0x35,0x32,0x31,0x35,0x42,0x52,0x63,
0x72,0x7c,0x7a,0x73,0x6a,0x63,0x5b,0x58,0x50,0x48,0x42,0x3c,0x3c,0x48,0x57,0x6c,
0x80,0x8e,0x93,0x94,0x94,0x98,0x9d,0xa1,0xa4,0xa4,0xa2,0x9e,0x9d,0xa1,0xa3,0xa6,
0xa6,0xa5,0xa0,0x9e,0x9d,0xa0,0xa3,0xa3,0x9d,0x97,0x8b,0x7e,0x6f,0x60,0x53,0x4a,
// Line 16
0x39,0x3b,0x39,0x39,0x37,0x36,0x36,0x38,0x39,0x3a,0x39,0x39,0x38,0x38,0x37,0x35,
0x32,0x32,0x32,0x34,0x36,0x38,0x39,0x39,0x38,0x39,0x3c,0x3f,0x40,0x3e,0x3a,0x36,
0x32,0x34,0x36,0x38,0x38,0x37,0x36,0x36,0x38,0x39,0x3a,0x38,0x35,0x35,0x34,0x34,
0x35,0x38,0x39,0x38,0x36,0x34,0x35,0x3f,0x4b,0x5b,0x6d,0x77,0x7a,0x75,0x68,0x5c,
0x57,0x5a,0x63,0x6f,0x76,0x78,0x73,0x6b,0x62,0x5f,0x60,0x65,0x6c,0x73,0x74,0x71,
0x6d,0x67,0x61,0x5f,0x60,0x66,0x6e,0x76,0x7b,0x7b,0x74,0x6b,0x62,0x5f,0x5e,0x62,
0x6a,0x72,0x75,0x72,0x6b,0x63,0x5f,0x5f,0x62,0x67,0x6d,0x72,0x74,0x73,0x6e,0x68,
0x60,0x5c,0x5d,0x65,0x6d,0x76,0x7c,0x7b,0x73,0x6a,0x61,0x5e,0x61,0x69,0x72,0x79,
0x79,0x76,0x70,0x69,0x62,0x60,0x63,0x69,0x6d,0x70,0x70,0x70,0x73,0x7b,0x87,0x96,
0xa3,0xac,0xae,0xa9,0x9e,0x90,0x7f,0x70,0x66,0x60,0x59,0x52,0x49,0x41,0x3a,0x37,
0x3b,0x46,0x56,0x67,0x76,0x86,0x90,0x95,0x98,0x9a,0x9c,0x9e,0x9f,0x9d,0x96,0x8a,
0x7a,0x69,0x5c,0x55,0x57,0x60,0x6c,0x75,0x7a,0x7a,0x73,0x68,0x61,0x60,0x62,0x6a,
0x71,0x76,0x77,0x71,0x67,0x62,0x5f,0x62,0x69,0x6e,0x70,0x72,0x74,0x79,0x7e,0x89,
0x96,0xa4,0xac,0xac,0xa4,0x9c,0x97,0x97,0x9b,0x9f,0x9f,0x97,0x8a,0x7b,0x6c,0x61,
0x59,0x51,0x48,0x3f,0x35,0x34,0x3b,0x4c,0x63,0x77,0x7f,0x7e,0x75,0x68,0x5d,0x58,
0x51,0x4e,0x46,0x3c,0x31,0x35,0x41,0x57,0x70,0x81,0x84,0x7d,0x6d,0x5d,0x52,0x4e,
0x4d,0x4a,0x42,0x39,0x31,0x30,0x32,0x39,0x41,0x48,0x4e,0x56,0x5e,0x6a,0x79,0x87,
0x90,0x96,0x94,0x8e,0x83,0x74,0x63,0x55,0x49,0x42,0x3b,0x3e,0x3b,0x39,0x36,0x33,
0x31,0x37,0x3f,0x49,0x55,0x62,0x6d,0x7a,0x84,0x90,0x9a,0x9e,0x99,0x8d,0x7d,0x6c,
0x5e,0x5a,0x5c,0x64,0x71,0x7c,0x83,0x8a,0x92,0x9b,0xa4,0xaa,0xab,0xac,0xa9,0xa5,
0x9f,0x9c,0x9d,0xa1,0xa4,0xa5,0xa2,0x9e,0x99,0x96,0x98,0x9a,0x9b,0x99,0x90,0x85,
0x77,0x6d,0x62,0x5a,0x52,0x4c,0x44,0x3e,0x3b,0x41,0x4c,0x5c,0x6b,0x7b,0x89,0x92,
0x95,0x94,0x90,0x8d,0x84,0x78,0x67,0x57,0x4a,0x40,0x3e,0x3d,0x3e,0x3f,0x3b,0x37,
0x35,0x3a,0x44,0x54,0x67,0x73,0x78,0x76,0x6f,0x66,0x60,0x5b,0x56,0x50,0x46,0x3c,
0x36,0x35,0x40,0x56,0x6c,0x7e,0x84,0x7c,0x6c,0x5e,0x56,0x5a,0x65,0x75,0x80,0x82,
0x7c,0x72,0x67,0x61,0x60,0x63,0x67,0x69,0x6b,0x70,0x76,0x7f,0x8b,0x99,0xa5,0xad,
0xb1,0xae,0xa6,0x9a,0x8a,0x7a,0x6d,0x63,0x5f,0x60,0x61,0x67,0x6b,0x74,0x7b,0x87,
0x92,0x9b,0x9b,0x95,0x88,0x76,0x64,0x54,0x47,0x3e,0x39,0x37,0x37,0x38,0x38,0x38,
0x36,0x37,0x3d,0x4b,0x5c,0x6d,0x79,0x7b,0x73,0x69,0x5f,0x5b,0x61,0x6b,0x75,0x7a,
0x79,0x72,0x65,0x5c,0x57,0x59,0x5c,0x59,0x4c,0x41,0x32,0x2b,0x2c,0x33,0x3f,0x49,
0x49,0x42,0x39,0x31,0x30,0x38,0x47,0x58,0x69,0x77,0x84,0x8e,0x95,0x99,0x97,0x93,
0x87,0x76,0x65,0x5a,0x59,0x61,0x6d,0x77,0x7c,0x7b,0x72,0x68,0x5e,0x56,0x4f,0x4c,
0x44,0x3b,0x32,0x2c,0x29,0x31,0x37,0x3f,0x45,0x4d,0x54,0x5f,0x69,0x75,0x83,0x90,
0x99,0xa0,0xa3,0xa5,0xa5,0xa5,0xa2,0x9f,0x9c,0x9a,0x9a,0x9e,0xa1,0xa4,0xa3,0x9f,
0x95,0x89,0x7b,0x6c,0x5f,0x56,0x50,0x4b,0x46,0x3e,0x37,0x3c,0x48,0x5b,0x71,0x81,
0x84,0x7b,0x6b,0x5a,0x53,0x5b,0x6a,0x79,0x7f,0x7d,0x72,0x66,0x5b,0x58,0x59,0x5a,
0x54,0x49,0x3c,0x32,0x2c,0x2e,0x33,0x3c,0x42,0x44,0x3f,0x37,0x30,0x30,0x38,0x45,
0x54,0x66,0x76,0x82,0x8c,0x94,0x99,0x99,0x93,0x87,0x75,0x65,0x5a,0x57,0x60,0x6d,
0x75,0x7b,0x78,0x70,0x65,0x5c,0x55,0x53,0x4f,0x48,0x3b,0x2f,0x27,0x29,0x30,0x38,
0x3d,0x3f,0x3b,0x35,0x30,0x2f,0x30,0x36,0x3b,0x3c,0x39,0x35,0x33,0x37,0x39,0x38,
0x36,0x36,0x35,0x33,0x34,0x3b,0x49,0x5c,0x6e,0x7b,0x81,0x7b,0x6f,0x66,0x60,0x60,
0x64,0x6b,0x72,0x77,0x79,0x7d,0x83,0x8e,0x9a,0xa6,0xab,0xa7,0x9c,0x90,0x83,0x76,
0x6b,0x5f,0x54,0x4f,0x49,0x43,0x3e,0x3a,0x38,0x35,0x31,0x30,0x33,0x3f,0x4e,0x5c,
0x6b,0x76,0x78,0x74,0x69,0x62,0x60,0x66,0x70,0x7c,0x82,0x81,0x77,0x6b,0x61,0x5c,
0x5d,0x5e,0x58,0x4b,0x39,0x2c,0x2d,0x3d,0x55,0x72,0x85,0x8a,0x81,0x71,0x63,0x5b,
0x5b,0x60,0x67,0x6e,0x73,0x78,0x7f,0x8a,0x94,0xa1,0xa7,0xa8,0xa4,0x9f,0x9b,0x99,
0x98,0x9a,0x9b,0xa2,0xa2,0xa4,0xa3,0xa1,0x9d,0xa0,0x9e,0x9e,0xa0,0xa1,0xa0,0xa0,
0x9f,0x9f,0x9f,0x9f,0x9f,0x9e,0x9b,0x99,0x98,0x9a,0x9b,0x97,0x8e,0x83,0x76,0x6a,
0x5d,0x51,0x48,0x41,0x3c,0x3a,0x38,0x39,0x37,0x36,0x33,0x36,0x3e,0x4d,0x5d,0x6d,
0x79,0x7d,0x79,0x6d,0x61,0x5f,0x63,0x6d,0x78,0x7e,0x7d,0x74,0x6b,0x62,0x5d,0x63,
0x6c,0x73,0x75,0x72,0x71,0x79,0x84,0x92,0x9c,0xa2,0x9d,0x8f,0x7a,0x66,0x56,0x52,
0x56,0x61,0x6f,0x7b,0x84,0x8e,0x96,0x9c,0xa1,0xa4,0xa3,0xa1,0x9b,0x9a,0x9a,0x9a,
0x9c,0x9f,0xa0,0x9f,0x9e,0xa0,0x9f,0x9a,0x90,0x82,0x72,0x65,0x5d,0x5b,0x5e,0x67,
0x70,0x7a,0x83,0x8c,0x95,0x9e,0xa2,0xa5,0xa4,0x9f,0x98,0x90,0x84,0x75,0x69,0x5e,
0x57,0x59,0x60,0x6c,0x79,0x80,0x7e,0x74,0x67,0x5e,0x5b,0x62,0x6c,0x76,0x7a,0x77,
0x6d,0x65,0x5f,0x60,0x63,0x62,0x59,0x4c,0x3d,0x34,0x36,0x45,0x5c,0x74,0x83,0x84,
0x79,0x6b,0x5b,0x4f,0x4b,0x48,0x41,0x38,0x33,0x36,0x45,0x5c,0x75,0x86,0x8a,0x80,
0x6d,0x60,0x5a,0x5c,0x66,0x70,0x75,0x79,0x7b,0x83,0x8c,0x98,0x9f,0x9e,0x8f,0x79,
0x64,0x56,0x51,0x58,0x68,0x79,0x81,0x7f,0x75,0x69,0x60,0x5c,0x60,0x69,0x72,0x77,
0x79,0x74,0x6d,0x66,0x62,0x63,0x66,0x69,0x6a,0x6b,0x6d,0x72,0x79,0x84,0x91,0x9e,
0xa7,0xaa,0xa7,0x9f,0x90,0x83,0x72,0x69,0x60,0x5b,0x56,0x4f,0x44,0x3b,0x33,0x34,
0x44,0x59,0x6e,0x7c,0x81,0x79,0x6c,0x61,0x5c,0x5e,0x6b,0x73,0x77,0x7b,0x7f,0x84,
0x8c,0x95,0x99,0x97,0x89,0x76,0x62,0x54,0x4d,0x52,0x5d,0x6b,0x77,0x82,0x8a,0x93,
0x9b,0xa2,0xa5,0xa5,0xa2,0x9f,0x97,0x8a,0x7b,0x6c,0x5f,0x58,0x59,0x5f,0x68,0x6e,
0x79,0x81,0x87,0x90,0x99,0xa1,0xa8,0xa8,0xa2,0x9f,0x9a,0x97,0x97,0x98,0x9b,0x9f,
0xa0,0xa2,0xa2,0x9f,0x95,0x87,0x77,0x6a,0x5e,0x56,0x4d,0x44,0x3c,0x36,0x33,0x3a,
0x49,0x60,0x74,0x7f,0x81,0x76,0x69,0x5d,0x55,0x53,0x4f,0x48,0x3f,0x35,0x34,0x42,
0x58,0x71,0x81,0x85,0x7a,0x69,0x58,0x4f,0x54,0x63,0x71,0x79,0x79,0x72,0x68,0x61,
0x5c,0x5c,0x5a,0x54,0x48,0x3c,0x30,0x29,0x28,0x2e,0x36,0x40,0x49,0x53,0x5d,0x69,
0x74,0x81,0x8a,0x92,0x96,0x98,0x92,0x85,0x73,0x60,0x50,0x46,0x41,0x3f,0x3e,0x3f,
0x3c,0x39,0x38,0x3c,0x42,0x45,0x40,0x38,0x33,0x32,0x39,0x48,0x5b,0x70,0x7c,0x7b,
0x70,0x62,0x58,0x54,0x5a,0x66,0x72,0x79,0x79,0x73,0x6c,0x68,0x66,0x66,0x64,0x5c,
0x4d,0x3f,0x35,0x33,0x3b,0x50,0x65,0x79,0x87,0x91,0x95,0x97,0x93,0x8e,0x84,0x76,
0x65,0x59,0x53,0x58,0x64,0x71,0x79,0x79,0x74,0x69,0x5f,0x5d,0x62,0x6d,0x76,0x7a,
0x77,0x72,0x6a,0x63,0x5f,0x5d,0x59,0x52,0x48,0x3c,0x30,0x2c,0x29,0x2d,0x33,0x3c,
0x47,0x57,0x63,0x6d,0x76,0x7a,0x75,0x6c,0x60,0x5a,0x5e,0x69,0x74,0x7b,0x7a,0x73,
0x68,0x60,0x5c,0x63,0x6d,0x74,0x75,0x73,0x70,0x72,0x7b,0x89,0x97,0xa1,0x9f,0x90,
0x7a,0x64,0x57,0x56,0x5e,0x6b,0x77,0x7f,0x7c,0x72,0x69,0x60,0x5a,0x57,0x4d,0x40,
0x34,0x30,0x32,0x3c,0x54,0x6c,0x7d,0x83,0x7c,0x6e,0x61,0x5a,0x5b,0x65,0x6d,0x73,
0x77,0x7c,0x82,0x8c,0x98,0xa2,0xa8,0xa8,0xa4,0x9f,0x9a,0x99,0x99,0x9c,0x9c,0x98,
0x90,0x83,0x74,0x67,0x5c,0x58,0x5c,0x65,0x6f,0x77,0x7f,0x86,0x8c,0x94,0x97,0x94,
0x8b,0x7c,0x68,0x5b,0x54,0x58,0x65,0x71,0x7b,0x86,0x8c,0x92,0x96,0x9c,0xa1,0xa4,
0xa2,0x9d,0x95,0x8a,0x7b,0x70,0x67,0x5f,0x5b,0x5e,0x65,0x6d,0x77,0x81,0x89,0x8f,
0x95,0x9c,0xa2,0xa7,0xa7,0xa2,0x9a,0x8c,0x7c,0x71,0x66,0x60,0x60,0x62,0x68,0x70,
0x76,0x7d,0x82,0x8a,0x90,0x99,0xa0,0xa3,0xa1,0x9f,0x99,0x94,0x96,0x9a,0x9b,0x99,
0x8c,0x7d,0x6d,0x60,0x54,0x48,0x47,0x43,0x3c,0x38,0x34,0x34,0x36,0x37,0x37,0x36,
0x34,0x33,0x33,0x31,0x2e,0x30,0x31,0x32,0x31,0x32,0x33,0x36,0x38,0x38,0x36,0x36,
0x36,0x36,0x39,0x3f,0x48,0x55,0x62,0x6e,0x7b,0x88,0x90,0x95,0x9a,0x9f,0xa2,0xa4,
0x9e,0x94,0x86,0x75,0x64,0x58,0x4e,0x49,0x48,0x43,0x3b,0x35,0x32,0x33,0x36,0x3b,
0x3f,0x41,0x3f,0x3a,0x33,0x31,0x33,0x3f,0x51,0x63,0x72,0x7f,0x88,0x90,0x97,0x9d,
0xa5,0xa7,0xa8,0xa5,0x9c,0x90,0x80,0x6f,0x63,0x58,0x4f,0x49,0x44,0x41,0x3d,0x36,
0x2f,0x2f,0x32,0x37,0x3f,0x4a,0x55,0x61,0x6b,0x77,0x83,0x90,0x97,0x99,0x93,0x87,
0x76,0x66,0x5b,0x59,0x5e,0x68,0x72,0x7c,0x85,0x8d,0x96,0x9e,0xa0,0x99,0x8b,0x76,
0x5e,0x51,0x50,0x5a,0x6a,0x78,0x7e,0x7d,0x73,0x68,0x5f,0x5a,0x55,0x50,0x46,0x38,
0x2c,0x27,0x29,0x30,0x38,0x3f,0x41,0x3f,0x3a,0x36,0x34,0x34,0x34,0x34,0x33,0x33,
0x34,0x37,0x37,0x36,0x34,0x33,0x31,0x32,0x34,0x36,0x38,0x39,0x37,0x38,0x38,0x39,
// Line 17
0x39,0x39,0x39,0x3a,0x38,0x3a,0x3a,0x3a,0x38,0x37,0x37,0x3a,0x39,0x38,0x38,0x3a,
0x3b,0x3c,0x39,0x39,0x39,0x39,0x38,0x37,0x38,0x3a,0x38,0x38,0x37,0x36,0x37,0x37,
0x38,0x38,0x37,0x37,0x38,0x38,0x38,0x38,0x38,0x39,0x3a,0x3c,0x3b,0x39,0x38,0x36,
0x36,0x39,0x39,0x37,0x36,0x34,0x34,0x3a,0x48,0x5c,0x6f,0x7b,0x7d,0x78,0x6c,0x63,
0x5e,0x63,0x6c,0x75,0x7c,0x7d,0x76,0x6c,0x62,0x5e,0x62,0x6a,0x71,0x77,0x79,0x76,
0x70,0x6b,0x66,0x62,0x62,0x67,0x6f,0x77,0x79,0x79,0x76,0x6e,0x65,0x62,0x63,0x6a,
0x72,0x79,0x79,0x76,0x6f,0x68,0x61,0x60,0x62,0x6b,0x74,0x7b,0x7c,0x7b,0x73,0x6b,
0x64,0x61,0x64,0x6b,0x70,0x76,0x77,0x75,0x6f,0x67,0x60,0x5e,0x63,0x6e,0x77,0x7e,
0x7e,0x79,0x71,0x6b,0x66,0x65,0x68,0x6e,0x71,0x73,0x73,0x74,0x76,0x7f,0x8a,0x96,
0xa1,0xac,0xad,0xa9,0x9e,0x8f,0x80,0x71,0x66,0x5e,0x57,0x4f,0x48,0x40,0x3b,0x38,
0x3a,0x45,0x56,0x6d,0x7f,0x8e,0x96,0x9b,0x9c,0x9f,0xa0,0xa3,0xa4,0xa3,0x9a,0x8c,
0x7b,0x6a,0x5a,0x57,0x57,0x60,0x6b,0x76,0x7d,0x7d,0x76,0x6a,0x64,0x64,0x6a,0x73,
0x79,0x7d,0x7c,0x75,0x6c,0x65,0x63,0x66,0x6b,0x6f,0x72,0x72,0x73,0x77,0x7f,0x8c,
0x99,0xa5,0xac,0xab,0xa4,0x9e,0x99,0x97,0x97,0x9b,0x9b,0x95,0x8b,0x7e,0x6e,0x60,
0x52,0x48,0x42,0x3c,0x36,0x38,0x41,0x53,0x67,0x77,0x7f,0x7d,0x73,0x68,0x5e,0x59,
0x56,0x53,0x4b,0x40,0x39,0x3c,0x49,0x60,0x77,0x88,0x8a,0x7f,0x6e,0x60,0x57,0x5c,
0x64,0x6e,0x75,0x79,0x7a,0x85,0x8e,0x99,0xa4,0xab,0xa9,0xa3,0x96,0x89,0x7c,0x6f,
0x62,0x57,0x4f,0x49,0x46,0x46,0x44,0x42,0x3c,0x38,0x37,0x3d,0x44,0x4c,0x55,0x60,
0x69,0x74,0x7e,0x89,0x92,0x99,0x9a,0x93,0x83,0x6f,0x5e,0x55,0x57,0x61,0x6f,0x7c,
0x82,0x80,0x78,0x6b,0x60,0x5a,0x57,0x4f,0x48,0x3d,0x31,0x2d,0x2f,0x37,0x3f,0x44,
0x44,0x42,0x3b,0x35,0x32,0x32,0x33,0x36,0x36,0x38,0x39,0x3b,0x3d,0x3f,0x40,0x3f,
0x3c,0x3c,0x3b,0x3c,0x3b,0x38,0x34,0x32,0x34,0x3c,0x49,0x5a,0x6a,0x78,0x87,0x8f,
0x95,0x99,0x97,0x8f,0x83,0x73,0x61,0x53,0x48,0x42,0x3d,0x3d,0x3b,0x38,0x36,0x37,
0x39,0x3f,0x44,0x4e,0x5b,0x69,0x76,0x82,0x8b,0x91,0x95,0x93,0x8c,0x82,0x75,0x65,
0x55,0x4a,0x42,0x40,0x3e,0x3f,0x3f,0x3f,0x3e,0x3d,0x3e,0x44,0x4f,0x62,0x73,0x7c,
0x7b,0x72,0x67,0x5e,0x5c,0x63,0x6f,0x7b,0x7e,0x7b,0x72,0x67,0x60,0x63,0x63,0x60,
0x56,0x46,0x37,0x2f,0x35,0x49,0x64,0x7d,0x89,0x89,0x7e,0x6f,0x61,0x5b,0x55,0x4f,
0x44,0x39,0x32,0x36,0x48,0x61,0x77,0x84,0x86,0x7e,0x6f,0x61,0x58,0x54,0x4f,0x48,
0x3f,0x39,0x3a,0x44,0x56,0x6b,0x80,0x8d,0x93,0x95,0x96,0x9b,0xa0,0xa6,0xa9,0xa6,
0xa2,0xa0,0x9e,0xa2,0xa3,0x9f,0x95,0x84,0x6f,0x60,0x5a,0x5d,0x65,0x70,0x79,0x7d,
0x78,0x6f,0x67,0x62,0x5c,0x55,0x4f,0x46,0x3c,0x33,0x2d,0x2d,0x34,0x3e,0x45,0x46,
0x40,0x3a,0x34,0x36,0x3d,0x4b,0x5b,0x6b,0x78,0x86,0x90,0x9a,0xa0,0xa0,0x9a,0x8f,
0x7f,0x6f,0x62,0x5e,0x61,0x69,0x72,0x7c,0x85,0x8e,0x96,0x9b,0xa0,0xa5,0xa8,0xa6,
0xa1,0x99,0x8d,0x7e,0x6e,0x60,0x5c,0x60,0x6a,0x75,0x7e,0x81,0x82,0x77,0x6c,0x67,
0x67,0x6b,0x6f,0x70,0x71,0x76,0x7c,0x84,0x8e,0x9b,0xa6,0xaf,0xb0,0xab,0xa3,0x9e,
0x9a,0x99,0x9b,0x9e,0xa0,0xa1,0x9f,0x9c,0x9a,0x9a,0x9b,0x9c,0x9c,0x9d,0x9e,0x9f,
0xa1,0xa4,0xa7,0xa0,0x93,0x85,0x76,0x67,0x60,0x5e,0x61,0x6b,0x76,0x7f,0x84,0x8a,
0x91,0x9b,0xa4,0xa9,0xa9,0xa6,0x9d,0x90,0x82,0x73,0x67,0x5e,0x55,0x4e,0x45,0x3e,
0x39,0x37,0x36,0x38,0x3b,0x3f,0x42,0x44,0x42,0x3f,0x3a,0x3b,0x3b,0x3c,0x3a,0x38,
0x37,0x3a,0x3b,0x3b,0x3a,0x3a,0x3a,0x39,0x35,0x32,0x34,0x40,0x52,0x67,0x78,0x7f,
0x7e,0x79,0x6d,0x61,0x59,0x55,0x51,0x4a,0x3f,0x32,0x29,0x29,0x2f,0x35,0x40,0x48,
0x4e,0x59,0x65,0x71,0x7f,0x89,0x92,0x9b,0x9f,0xa3,0xa4,0xa6,0xa3,0x9a,0x8b,0x7b,
0x6b,0x62,0x5f,0x5f,0x63,0x6a,0x71,0x7a,0x80,0x86,0x8f,0x99,0xa0,0xa4,0xa3,0xa3,
0xa0,0x98,0x8c,0x7c,0x6d,0x63,0x60,0x61,0x66,0x6c,0x74,0x7b,0x80,0x88,0x91,0x9c,
0xa4,0xa9,0xa8,0xa5,0xa1,0x9e,0x9a,0x9e,0x9e,0x9b,0x95,0x89,0x7a,0x6c,0x5d,0x4f,
0x44,0x3e,0x3a,0x38,0x36,0x35,0x35,0x36,0x37,0x3c,0x44,0x52,0x61,0x72,0x7c,0x7d,
0x78,0x6e,0x64,0x61,0x63,0x68,0x6f,0x74,0x77,0x7c,0x83,0x8d,0x96,0xa5,0xac,0xaf,
0xac,0xa1,0x93,0x87,0x76,0x6a,0x61,0x59,0x51,0x49,0x3f,0x35,0x33,0x3a,0x4a,0x5e,
0x71,0x7e,0x81,0x7a,0x6c,0x60,0x56,0x50,0x4b,0x48,0x42,0x3a,0x32,0x2d,0x2c,0x32,
0x3c,0x4a,0x59,0x66,0x70,0x77,0x78,0x72,0x6b,0x67,0x60,0x5a,0x54,0x4c,0x42,0x36,
0x2e,0x2b,0x2f,0x39,0x43,0x45,0x41,0x39,0x32,0x31,0x33,0x37,0x3c,0x3f,0x3d,0x3b,
0x36,0x36,0x3a,0x3e,0x3d,0x3a,0x34,0x32,0x33,0x3e,0x4d,0x61,0x73,0x7e,0x7e,0x76,
0x6b,0x62,0x60,0x64,0x6a,0x72,0x78,0x7b,0x80,0x89,0x93,0x9a,0xa0,0x9c,0x8f,0x7c,
0x67,0x5a,0x57,0x5d,0x67,0x74,0x7f,0x8a,0x93,0x9b,0x9b,0x99,0x8e,0x7f,0x6c,0x5b,
0x4f,0x47,0x40,0x3b,0x37,0x37,0x40,0x51,0x66,0x79,0x83,0x82,0x76,0x67,0x5d,0x59,
0x56,0x53,0x4c,0x40,0x36,0x38,0x43,0x57,0x6f,0x84,0x90,0x95,0x93,0x93,0x96,0x9b,
0x9f,0xa1,0x9c,0x93,0x84,0x78,0x6b,0x60,0x54,0x4b,0x43,0x40,0x3f,0x3c,0x39,0x37,
0x35,0x38,0x3b,0x44,0x4f,0x5f,0x6d,0x78,0x80,0x88,0x8f,0x97,0x9e,0xa3,0xa9,0xa6,
0xa1,0x96,0x86,0x77,0x68,0x61,0x5a,0x54,0x4e,0x45,0x3c,0x3a,0x3f,0x4f,0x65,0x79,
0x83,0x83,0x78,0x68,0x5a,0x53,0x50,0x4f,0x48,0x3e,0x33,0x2d,0x2c,0x32,0x3a,0x42,
0x44,0x40,0x37,0x30,0x31,0x3a,0x4b,0x61,0x74,0x7f,0x81,0x79,0x6d,0x65,0x62,0x67,
0x6e,0x75,0x7b,0x7c,0x7f,0x85,0x8e,0x9c,0xa3,0xa0,0x92,0x7c,0x66,0x58,0x57,0x61,
0x71,0x81,0x86,0x80,0x74,0x67,0x5d,0x59,0x54,0x4c,0x42,0x35,0x2a,0x26,0x27,0x2f,
0x38,0x40,0x42,0x42,0x3e,0x3c,0x37,0x35,0x32,0x34,0x37,0x3a,0x39,0x38,0x33,0x2f,
0x31,0x3c,0x4f,0x63,0x76,0x7e,0x7c,0x73,0x68,0x60,0x5b,0x59,0x54,0x4a,0x3c,0x32,
0x35,0x43,0x57,0x6f,0x80,0x83,0x79,0x66,0x57,0x54,0x5b,0x69,0x74,0x7b,0x7a,0x74,
0x6e,0x69,0x63,0x5f,0x58,0x50,0x45,0x3c,0x34,0x2f,0x2f,0x2d,0x31,0x3a,0x4a,0x59,
0x68,0x73,0x76,0x75,0x6b,0x61,0x5e,0x5a,0x55,0x50,0x46,0x3a,0x31,0x36,0x44,0x5b,
0x73,0x86,0x88,0x7f,0x6e,0x5d,0x53,0x4e,0x4a,0x44,0x3d,0x36,0x30,0x2d,0x31,0x3a,
0x40,0x42,0x3d,0x39,0x36,0x34,0x34,0x36,0x36,0x39,0x38,0x37,0x36,0x37,0x37,0x36,
0x36,0x38,0x37,0x39,0x37,0x36,0x36,0x38,0x37,0x3b,0x3d,0x3d,0x3c,0x37,0x36,0x3b,
0x48,0x5d,0x6f,0x7b,0x7b,0x75,0x68,0x5e,0x5b,0x64,0x71,0x7e,0x82,0x7e,0x73,0x6a,
0x61,0x60,0x60,0x5e,0x55,0x47,0x37,0x2d,0x2d,0x42,0x5b,0x74,0x86,0x89,0x7e,0x70,
0x62,0x5d,0x62,0x68,0x6e,0x73,0x76,0x7b,0x84,0x90,0x9a,0x9f,0x9a,0x8a,0x76,0x63,
0x57,0x56,0x5d,0x6b,0x77,0x81,0x81,0x79,0x6e,0x66,0x61,0x62,0x67,0x71,0x76,0x76,
0x70,0x6b,0x65,0x65,0x67,0x6c,0x70,0x73,0x76,0x79,0x7d,0x88,0x90,0x9a,0xa5,0xab,
0xac,0xab,0xa3,0x95,0x84,0x74,0x66,0x5c,0x57,0x5c,0x66,0x73,0x79,0x7a,0x75,0x6d,
0x63,0x5e,0x5b,0x57,0x51,0x48,0x3f,0x35,0x2d,0x2b,0x2f,0x38,0x41,0x4c,0x56,0x60,
0x68,0x72,0x7e,0x89,0x94,0x9c,0xa3,0xa8,0xa8,0xa5,0xa0,0x9c,0x9b,0x9d,0x9d,0x9b,
0x96,0x8d,0x7e,0x6b,0x5d,0x51,0x46,0x42,0x3c,0x36,0x31,0x30,0x32,0x36,0x3a,0x3c,
0x37,0x36,0x30,0x2f,0x32,0x36,0x37,0x35,0x32,0x34,0x3d,0x4a,0x5a,0x6c,0x7a,0x82,
0x89,0x90,0x97,0x9f,0xa3,0xa4,0xa4,0xa3,0xa0,0x9f,0xa0,0xa0,0x9d,0x9b,0x91,0x83,
0x73,0x63,0x54,0x48,0x3d,0x39,0x36,0x38,0x36,0x33,0x2f,0x30,0x35,0x44,0x54,0x65,
0x74,0x7a,0x77,0x6f,0x65,0x5e,0x5b,0x5a,0x54,0x4a,0x3c,0x34,0x35,0x45,0x5d,0x76,
0x87,0x8b,0x7f,0x6d,0x5c,0x56,0x5e,0x6c,0x78,0x7f,0x7b,0x73,0x68,0x60,0x5a,0x57,
0x54,0x4f,0x44,0x3b,0x2d,0x28,0x29,0x30,0x3a,0x42,0x46,0x42,0x3b,0x34,0x31,0x38,
0x47,0x5b,0x6f,0x7d,0x80,0x79,0x6b,0x5f,0x5a,0x5e,0x67,0x72,0x79,0x7b,0x74,0x6b,
0x62,0x61,0x65,0x6b,0x72,0x79,0x7d,0x7a,0x75,0x70,0x6b,0x67,0x6a,0x6e,0x6f,0x70,
0x73,0x77,0x7c,0x84,0x8e,0x99,0xa4,0xa9,0xa7,0xa3,0x9b,0x91,0x84,0x76,0x67,0x5e,
0x58,0x5d,0x65,0x71,0x7a,0x7e,0x79,0x71,0x67,0x63,0x63,0x67,0x6e,0x71,0x73,0x75,
0x79,0x82,0x8f,0x9d,0xa6,0xac,0xab,0xa5,0x9e,0x99,0x96,0x96,0x99,0x9b,0x9d,0xa1,
0xa3,0xa1,0x9e,0x94,0x86,0x79,0x6b,0x5e,0x52,0x49,0x42,0x3e,0x3c,0x3c,0x39,0x36,
0x34,0x33,0x38,0x41,0x4c,0x5a,0x67,0x74,0x80,0x8a,0x91,0x9a,0xa3,0xa9,0xac,0xa9,
0xa3,0x9f,0x9d,0x9c,0x9b,0x9b,0x95,0x8b,0x7d,0x6e,0x5d,0x53,0x4c,0x48,0x3f,0x3c,
0x36,0x34,0x34,0x36,0x37,0x39,0x3a,0x38,0x34,0x32,0x31,0x33,0x35,0x37,0x39,0x3a,
0x37,0x36,0x35,0x34,0x36,0x38,0x3a,0x3a,0x39,0x3a,0x39,0x3c,0x3d,0x3e,0x3e,0x3d,
// Line 18
0x3b,0x39,0x38,0x35,0x34,0x36,0x36,0x36,0x35,0x35,0x35,0x33,0x33,0x34,0x36,0x37,
0x36,0x36,0x36,0x37,0x37,0x3a,0x3a,0x39,0x38,0x37,0x37,0x3a,0x3b,0x3d,0x3c,0x3c,
0x3b,0x3e,0x41,0x45,0x49,0x4c,0x4c,0x4d,0x4f,0x52,0x54,0x55,0x56,0x57,0x57,0x57,
0x58,0x57,0x5b,0x5c,0x5d,0x5f,0x5c,0x59,0x5a,0x5b,0x5b,0x5b,0x5b,0x5c,0x5e,0x5c,
0x59,0x58,0x58,0x5a,0x5b,0x5c,0x59,0x58,0x55,0x55,0x57,0x59,0x5b,0x5b,0x5a,0x5a,
0x58,0x58,0x56,0x59,0x5b,0x5c,0x5b,0x59,0x57,0x57,0x57,0x59,0x59,0x59,0x5c,0x5a,
0x57,0x58,0x59,0x5b,0x5c,0x5c,0x59,0x57,0x57,0x58,0x59,0x59,0x59,0x5a,0x5b,0x5c,
0x5b,0x5b,0x5a,0x5a,0x5a,0x58,0x57,0x58,0x56,0x56,0x57,0x59,0x59,0x5a,0x5a,0x5a,
0x5b,0x5e,0x5e,0x5d,0x5b,0x5a,0x58,0x5a,0x5a,0x5b,0x5b,0x5c,0x59,0x58,0x56,0x56,
0x55,0x56,0x55,0x55,0x55,0x56,0x56,0x5a,0x5a,0x59,0x5a,0x58,0x57,0x57,0x57,0x56,
0x57,0x58,0x5a,0x5a,0x58,0x57,0x5a,0x5c,0x5c,0x5b,0x5a,0x5a,0x59,0x59,0x59,0x5a,
0x5b,0x5c,0x5b,0x5b,0x5b,0x5d,0x5e,0x5c,0x5a,0x5b,0x5c,0x5d,0x5c,0x5d,0x5d,0x5b,
0x5a,0x58,0x58,0x5b,0x5b,0x5b,0x5a,0x5a,0x59,0x59,0x59,0x5a,0x5b,0x5c,0x5b,0x58,
0x5a,0x59,0x59,0x5b,0x5a,0x5a,0x5c,0x5b,0x59,0x5a,0x5b,0x5c,0x5a,0x5a,0x59,0x5b,
0x5c,0x5d,0x5b,0x5c,0x5b,0x5a,0x5a,0x5a,0x5a,0x5a,0x59,0x57,0x58,0x5a,0x5d,0x5c,
0x5b,0x59,0x5a,0x5a,0x59,0x57,0x57,0x57,0x56,0x58,0x58,0x59,0x5a,0x5b,0x5a,0x5a,
0x59,0x5a,0x5a,0x5a,0x59,0x58,0x59,0x59,0x59,0x5b,0x5d,0x5a,0x5b,0x5b,0x5a,0x5b,
0x5b,0x5b,0x5a,0x5a,0x5b,0x59,0x5a,0x5a,0x5c,0x5f,0x5e,0x5c,0x5a,0x59,0x5a,0x5f,
0x5d,0x5b,0x5b,0x5a,0x59,0x59,0x58,0x58,0x58,0x58,0x57,0x57,0x58,0x5d,0x60,0x60,
0x5d,0x5a,0x58,0x58,0x5b,0x61,0x61,0x5c,0x54,0x4e,0x4d,0x52,0x60,0x72,0x82,0x8a,
0x85,0x78,0x6c,0x65,0x64,0x69,0x6a,0x67,0x5e,0x54,0x4c,0x4c,0x54,0x5f,0x67,0x67,
0x60,0x58,0x53,0x52,0x55,0x59,0x5a,0x59,0x57,0x56,0x57,0x5c,0x5f,0x5e,0x5b,0x58,
0x57,0x58,0x5a,0x5c,0x5d,0x5e,0x5c,0x58,0x5a,0x5c,0x5d,0x5f,0x5f,0x5e,0x5e,0x5c,
0x5b,0x5b,0x5a,0x59,0x58,0x58,0x58,0x5b,0x5b,0x5b,0x59,0x58,0x58,0x5a,0x5b,0x5c,
0x5c,0x5c,0x5b,0x5a,0x5a,0x5c,0x5e,0x5f,0x5d,0x58,0x57,0x58,0x59,0x5b,0x5b,0x59,
0x58,0x59,0x58,0x57,0x59,0x5b,0x5b,0x5d,0x5d,0x5e,0x5e,0x5d,0x5a,0x58,0x58,0x57,
0x55,0x59,0x59,0x59,0x5a,0x59,0x59,0x5b,0x5e,0x5f,0x5e,0x5d,0x5d,0x5c,0x5a,0x58,
0x58,0x5a,0x5a,0x5a,0x58,0x57,0x57,0x59,0x59,0x5a,0x5c,0x5e,0x5d,0x5c,0x5a,0x5a,
0x59,0x59,0x59,0x58,0x57,0x57,0x55,0x57,0x58,0x5a,0x5d,0x5f,0x5f,0x60,0x5e,0x5b,
0x5b,0x5b,0x5b,0x5b,0x5a,0x59,0x59,0x59,0x59,0x59,0x58,0x57,0x57,0x5a,0x5a,0x59,
0x5a,0x5b,0x5a,0x59,0x57,0x59,0x5c,0x5d,0x5b,0x5a,0x58,0x58,0x57,0x59,0x5a,0x59,
0x5a,0x5a,0x57,0x56,0x57,0x58,0x59,0x5c,0x5f,0x5f,0x5e,0x5d,0x5c,0x5e,0x5f,0x5c,
0x5c,0x5b,0x59,0x59,0x58,0x57,0x58,0x59,0x58,0x59,0x5a,0x5b,0x5a,0x5a,0x5a,0x58,
0x57,0x58,0x59,0x59,0x58,0x57,0x57,0x57,0x58,0x5a,0x5c,0x5d,0x5d,0x5e,0x5f,0x60,
0x5f,0x5d,0x5c,0x5e,0x5e,0x5c,0x5b,0x5a,0x5a,0x5b,0x5a,0x59,0x58,0x59,0x59,0x59,
0x58,0x59,0x59,0x5a,0x59,0x59,0x59,0x5a,0x5c,0x5f,0x5d,0x5b,0x5b,0x5a,0x5a,0x5a,
0x5b,0x5b,0x5b,0x5b,0x5a,0x5b,0x5a,0x59,0x59,0x5b,0x5a,0x57,0x55,0x54,0x53,0x55,
0x56,0x56,0x55,0x54,0x54,0x55,0x56,0x58,0x59,0x5b,0x5c,0x5b,0x5b,0x5b,0x59,0x59,
0x57,0x54,0x50,0x4a,0x47,0x47,0x46,0x43,0x42,0x44,0x47,0x4a,0x49,0x48,0x47,0x49,
0x49,0x46,0x42,0x3f,0x3f,0x42,0x42,0x3f,0x3d,0x40,0x42,0x44,0x44,0x44,0x45,0x47,
0x45,0x43,0x43,0x47,0x4a,0x4e,0x4c,0x49,0x49,0x4a,0x49,0x49,0x47,0x45,0x44,0x44,
0x43,0x40,0x43,0x44,0x45,0x48,0x49,0x4a,0x4a,0x4b,0x4b,0x4c,0x4a,0x49,0x47,0x46,
0x44,0x43,0x43,0x44,0x44,0x47,0x48,0x49,0x4a,0x4b,0x4b,0x4c,0x4a,0x49,0x4a,0x4b,
0x49,0x47,0x45,0x45,0x45,0x47,0x47,0x45,0x47,0x47,0x45,0x45,0x45,0x45,0x47,0x45,
0x45,0x45,0x43,0x43,0x44,0x43,0x43,0x44,0x46,0x48,0x47,0x46,0x44,0x43,0x44,0x44,
0x45,0x47,0x46,0x44,0x44,0x44,0x44,0x44,0x43,0x44,0x45,0x45,0x43,0x41,0x43,0x44,
0x43,0x45,0x47,0x47,0x49,0x47,0x46,0x47,0x48,0x4a,0x4a,0x48,0x47,0x47,0x45,0x44,
0x44,0x45,0x45,0x45,0x45,0x47,0x47,0x47,0x45,0x46,0x47,0x48,0x48,0x48,0x47,0x47,
0x45,0x44,0x42,0x42,0x41,0x43,0x43,0x43,0x43,0x46,0x4d,0x51,0x59,0x65,0x72,0x7e,
0x89,0x94,0x9c,0xa4,0xaa,0xaf,0xb1,0xb2,0xb1,0xb0,0xae,0xac,0xac,0xae,0xaf,0xaf,
0xb1,0xb3,0xb4,0xb3,0xb0,0xae,0xaf,0xb0,0xaf,0xae,0xac,0xab,0xad,0xaf,0xaf,0xb1,
0xb4,0xb6,0xb3,0xb3,0xb1,0xb2,0xb2,0xb4,0xb1,0xb1,0xae,0xad,0xab,0xaf,0xae,0xad,
0xad,0xaf,0xb1,0xb1,0xaf,0xb0,0xb4,0xb5,0xb4,0xb4,0xb2,0xb1,0xb1,0xb1,0xb1,0xb1,
0xb1,0xb1,0xb2,0xb1,0xb0,0xb0,0xb1,0xb1,0xb0,0xb1,0xb0,0xae,0xad,0xad,0xae,0xb0,
0xb0,0xb0,0xad,0xaf,0xaf,0xae,0xb0,0xb0,0xaf,0xb1,0xb1,0xb0,0xb1,0xb3,0xb4,0xb4,
0xb3,0xb1,0xb1,0xb3,0xb2,0xb1,0xb1,0xb1,0xae,0xae,0xae,0xae,0xaf,0xb0,0xaf,0xb0,
0xb0,0xb1,0xb1,0xb1,0xb2,0xb4,0xb3,0xb1,0xb1,0xb1,0xb0,0xb0,0xb0,0xb0,0xae,0xb3,
0xae,0xae,0xb0,0xb1,0xb1,0xb2,0xb1,0xb0,0xb0,0xb1,0xb1,0xb3,0xb1,0xb1,0xb1,0xb2,
0xb1,0xb1,0xb4,0xb5,0xb4,0xb5,0xb5,0xb4,0xb4,0xb4,0xb3,0xb4,0xb3,0xb4,0xb3,0xb1,
0xb0,0xb1,0xb1,0xb1,0xb0,0xb0,0xae,0xad,0xab,0xaa,0xa8,0xa8,0xa5,0xa3,0xa2,0xa2,
0xa1,0x9f,0x9d,0x9c,0x9c,0x9f,0xa0,0xa0,0x9e,0x9d,0x9d,0x9f,0xa0,0xa1,0xa2,0xa1,
0x9f,0x9f,0x9f,0x9f,0xa0,0xa0,0x9e,0x9d,0x9b,0x9b,0x9d,0x9f,0x9f,0x9f,0xa0,0x9f,
0xa0,0xa2,0xa2,0xa2,0xa1,0xa0,0xa0,0x9f,0x9f,0x9f,0x9f,0xa1,0xa1,0xa3,0xa2,0xa2,
0x9f,0x9f,0x9f,0x9e,0x9d,0x9d,0x9e,0xa0,0xa0,0xa0,0x9f,0xa0,0x9f,0xa0,0xa1,0xa0,
0x9d,0xa0,0x9e,0x9c,0x9b,0x9b,0x9e,0x9f,0x9d,0x9d,0x9d,0x9f,0xa1,0xa0,0xa0,0xa0,
0xa2,0xa4,0xa4,0xa3,0xa0,0xa0,0x9f,0x9f,0x9f,0x9f,0x9f,0x9e,0x9c,0x9c,0x9d,0x9f,
0xa2,0xa4,0xa5,0xa5,0xa4,0xa4,0xa2,0xa1,0xa1,0xa0,0xa1,0xa0,0xa1,0xa2,0x9f,0x9e,
0x9f,0xa1,0xa3,0xa4,0xa5,0xa5,0xa4,0xa2,0xa0,0xa0,0xa3,0xa4,0xa3,0xa3,0xa1,0xa0,
0xa0,0xa0,0x9f,0xa1,0xa3,0xa4,0xa4,0xa3,0xa3,0xa4,0xa4,0xa3,0xa0,0x9f,0x9e,0x9d,
0x9e,0x9f,0xa0,0xa0,0x9f,0x9f,0xa0,0xa1,0xa3,0xa5,0xa5,0xa5,0xa3,0xa2,0xa0,0x9f,
0x9f,0xa1,0xa0,0xa0,0x9f,0x9f,0x9f,0x9f,0x9f,0xa3,0xa4,0xa5,0xa2,0xa3,0xa2,0xa4,
0xa4,0xa4,0xa1,0xa3,0xa0,0x9d,0x9c,0x9c,0x9d,0x9f,0x9d,0x9d,0x9e,0x9f,0xa0,0x9f,
0x9f,0xa0,0xa0,0xa0,0x9f,0x9e,0x9f,0xa0,0x9e,0x9d,0x9e,0xa0,0xa1,0xa1,0xa0,0xa2,
0xa2,0xa2,0xa0,0x9f,0x9f,0xa1,0xa2,0xa2,0xa0,0x9e,0x9e,0x9d,0x9f,0xa0,0xa1,0xa0,
0x9e,0x9c,0x9d,0x9e,0x9f,0x9f,0xa0,0x9f,0x9f,0x9f,0x9e,0x9e,0x9e,0x9e,0x9d,0x9d,
0x9c,0x9c,0x9e,0x9f,0x9f,0x9f,0x9f,0xa2,0xa3,0xa1,0x9f,0xa1,0xa1,0xa2,0xa2,0xa3,
0xa2,0x9f,0x9e,0x9b,0x98,0x99,0x9c,0x9f,0xa1,0xa0,0x9d,0x9a,0x99,0x9d,0xa3,0xaa,
0xaa,0xa3,0x93,0x7f,0x6f,0x6b,0x6f,0x7a,0x86,0x8d,0x8e,0x8e,0x90,0x97,0x9f,0xa7,
0xaa,0xaa,0xa5,0x9e,0x97,0x97,0x9b,0x9e,0xa2,0xa4,0xa3,0xa4,0xa2,0xa0,0xa0,0xa0,
0xa0,0x9f,0x9e,0x9f,0xa1,0xa4,0xa3,0x9e,0x9e,0x9d,0x9c,0x9e,0x9f,0xa0,0xa1,0xa0,
0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9c,0x9f,0xa1,0xa3,0xa3,0xa2,0xa0,0x9e,0x9e,0x9e,
0x9d,0x9e,0x9d,0x9b,0x9a,0x9b,0x9e,0xa1,0xa2,0xa2,0xa0,0x9f,0x9e,0x9f,0x9e,0x9f,
0xa0,0xa2,0xa0,0x9f,0xa0,0x9f,0x9e,0x9f,0x9f,0xa1,0xa1,0xa0,0xa0,0xa1,0xa1,0xa2,
0xa2,0xa3,0xa3,0xa2,0xa2,0xa0,0x9f,0xa2,0xa1,0x9e,0x9d,0x9c,0x9c,0x9e,0x9f,0xa0,
0xa3,0xa4,0xa3,0xa0,0xa0,0xa2,0xa2,0xa4,0xa4,0xa3,0xa3,0xa1,0x9f,0xa0,0xa1,0xa2,
0xa0,0xa0,0x9d,0x9e,0x9f,0xa0,0xa0,0xa0,0xa1,0xa2,0xa3,0xa2,0xa2,0xa4,0xa3,0xa1,
0x9e,0x9d,0x9c,0x9d,0x9c,0x9d,0x9e,0x9f,0x9f,0x9f,0x9f,0xa0,0xa1,0xa4,0xa4,0xa3,
0xa1,0x9f,0x9e,0x9f,0x9f,0xa0,0xa0,0xa0,0x9e,0x9f,0xa0,0xa2,0xa2,0xa2,0xa3,0xa4,
0xa4,0xa4,0xa4,0xa4,0xa2,0xa0,0x9f,0x9f,0x9e,0x9f,0x9e,0x9d,0x9a,0x9b,0x9c,0x9e,
0x9f,0xa2,0xa3,0xa4,0xa4,0xa4,0xa3,0xa0,0x9f,0xa2,0xa2,0xa1,0x9e,0x9e,0x9c,0x9d,
0x9d,0x9f,0xa0,0xa2,0xa1,0xa2,0xa3,0xa2,0xa1,0xa3,0xa3,0xa2,0xa1,0x9f,0x9e,0x9d,
0x9d,0x9d,0x9d,0x9e,0x9e,0x9e,0x9f,0xa1,0xa3,0xa5,0xa4,0xa2,0xa3,0xa0,0x9f,0x9e,
0x9d,0x9e,0x9d,0x9b,0x98,0x9a,0x9d,0x9e,0x9d,0x9e,0x9d,0x9c,0x9d,0x9e,0x9f,0xa1,
0x9f,0x9f,0x9f,0x9f,0xa1,0xa2,0xa4,0xa1,0x9f,0xa1,0xa1,0xa2,0xa2,0xa1,0xa1,0xa2,
0xa0,0xa0,0xa1,0x9f,0x9e,0x9d,0x9c,0x9d,0x9e,0x9f,0x9d,0x9d,0x9b,0x9b,0x9a,0x99,
0x96,0x93,0x8d,0x85,0x7b,0x70,0x65,0x5a,0x50,0x48,0x43,0x3b,0x39,0x35,0x33,0x34,
// Line 19
0x37,0x39,0x38,0x38,0x37,0x37,0x37,0x38,0x38,0x39,0x39,0x38,0x38,0x37,0x37,0x38,
0x37,0x36,0x36,0x37,0x37,0x39,0x3c,0x3e,0x41,0x46,0x4a,0x4e,0x50,0x54,0x57,0x5a,
0x5b,0x5d,0x5f,0x61,0x64,0x64,0x64,0x64,0x61,0x61,0x61,0x61,0x63,0x64,0x62,0x63,
0x60,0x60,0x61,0x61,0x5f,0x60,0x60,0x60,0x62,0x64,0x65,0x66,0x65,0x65,0x64,0x65,
0x66,0x66,0x66,0x65,0x63,0x62,0x62,0x62,0x64,0x64,0x63,0x61,0x60,0x60,0x62,0x64,
0x64,0x64,0x64,0x65,0x64,0x63,0x61,0x61,0x62,0x61,0x60,0x60,0x61,0x64,0x65,0x65,
0x64,0x64,0x65,0x64,0x63,0x64,0x65,0x64,0x64,0x62,0x60,0x63,0x62,0x62,0x62,0x60,
0x60,0x61,0x60,0x61,0x64,0x67,0x67,0x67,0x67,0x66,0x64,0x64,0x62,0x61,0x61,0x61,
0x5f,0x5f,0x60,0x61,0x64,0x65,0x66,0x65,0x65,0x65,0x65,0x66,0x65,0x64,0x64,0x64,
0x63,0x65,0x64,0x63,0x62,0x62,0x60,0x62,0x63,0x66,0x67,0x69,0x66,0x66,0x67,0x69,
0x6a,0x6b,0x69,0x67,0x67,0x69,0x68,0x68,0x68,0x69,0x69,0x67,0x67,0x69,0x6b,0x6b,
0x69,0x6a,0x6b,0x6d,0x6e,0x6f,0x70,0x70,0x6e,0x6d,0x6b,0x6d,0x6d,0x6e,0x6f,0x70,
0x70,0x72,0x73,0x73,0x77,0x78,0x78,0x78,0x77,0x76,0x78,0x78,0x78,0x7a,0x7c,0x7c,
0x7e,0x81,0x83,0x84,0x85,0x85,0x86,0x88,0x8a,0x8a,0x88,0x88,0x89,0x8b,0x8c,0x8c,
0x8c,0x8c,0x8d,0x8e,0x8f,0x92,0x92,0x96,0x95,0x93,0x94,0x94,0x95,0x98,0x96,0x91,
0x8e,0x8d,0x8c,0x8c,0x88,0x88,0x88,0x86,0x84,0x81,0x7f,0x7c,0x78,0x77,0x76,0x75,
0x73,0x6e,0x67,0x64,0x5f,0x5b,0x57,0x52,0x4e,0x49,0x43,0x3d,0x39,0x3a,0x39,0x37,
0x35,0x33,0x2f,0x2d,0x2a,0x29,0x28,0x28,0x28,0x29,0x2a,0x2b,0x2f,0x34,0x38,0x3a,
0x3c,0x41,0x48,0x4e,0x54,0x5a,0x5f,0x65,0x6a,0x71,0x78,0x80,0x85,0x88,0x88,0x8c,
0x8e,0x92,0x93,0x96,0x94,0x91,0x8f,0x8c,0x88,0x87,0x80,0x78,0x72,0x6c,0x64,0x5d,
0x54,0x4e,0x49,0x41,0x3a,0x35,0x32,0x31,0x2f,0x31,0x31,0x32,0x33,0x35,0x39,0x3f,
0x45,0x4c,0x52,0x57,0x5c,0x64,0x6d,0x77,0x81,0x8b,0x90,0x92,0x92,0x93,0x91,0x91,
0x8b,0x85,0x7e,0x76,0x6d,0x63,0x5a,0x51,0x4b,0x45,0x3d,0x37,0x31,0x2e,0x2d,0x2f,
0x30,0x33,0x37,0x3d,0x44,0x4e,0x58,0x61,0x6c,0x75,0x7e,0x86,0x8d,0x91,0x91,0x90,
0x8c,0x85,0x7d,0x74,0x69,0x5f,0x53,0x49,0x42,0x3e,0x3b,0x37,0x33,0x32,0x33,0x39,
0x3e,0x45,0x50,0x5b,0x65,0x72,0x7d,0x87,0x91,0x94,0x93,0x91,0x88,0x7d,0x71,0x65,
0x56,0x4d,0x43,0x3b,0x36,0x34,0x33,0x35,0x38,0x3e,0x46,0x52,0x5c,0x68,0x74,0x7e,
0x88,0x8e,0x8f,0x8b,0x86,0x7d,0x71,0x63,0x57,0x4c,0x41,0x39,0x33,0x31,0x36,0x38,
0x3d,0x49,0x55,0x62,0x6f,0x7c,0x84,0x8c,0x8f,0x8e,0x88,0x7e,0x71,0x65,0x56,0x48,
0x3d,0x36,0x2e,0x2b,0x2f,0x38,0x42,0x50,0x5f,0x70,0x80,0x8c,0x90,0x8d,0x87,0x7f,
0x75,0x6a,0x5d,0x50,0x42,0x38,0x30,0x2f,0x34,0x41,0x52,0x64,0x71,0x7f,0x89,0x8e,
0x8d,0x88,0x7e,0x73,0x64,0x55,0x48,0x3d,0x33,0x2e,0x33,0x3d,0x4b,0x5e,0x6e,0x7d,
0x88,0x8e,0x8d,0x86,0x7a,0x6e,0x61,0x55,0x48,0x3d,0x37,0x34,0x38,0x44,0x55,0x6a,
0x7d,0x88,0x8a,0x86,0x7d,0x71,0x63,0x57,0x4b,0x42,0x39,0x33,0x33,0x3d,0x4d,0x61,
0x75,0x84,0x8a,0x88,0x7e,0x71,0x65,0x5a,0x4e,0x43,0x38,0x33,0x36,0x43,0x54,0x68,
0x7c,0x86,0x85,0x80,0x76,0x6b,0x5e,0x51,0x45,0x3e,0x39,0x3d,0x46,0x58,0x6a,0x79,
0x81,0x84,0x7e,0x73,0x64,0x54,0x47,0x3d,0x39,0x3c,0x44,0x52,0x65,0x76,0x83,0x86,
0x81,0x78,0x6a,0x5c,0x4b,0x3e,0x37,0x38,0x40,0x50,0x63,0x76,0x82,0x84,0x7c,0x6f,
0x5f,0x52,0x45,0x40,0x3d,0x40,0x4b,0x58,0x66,0x79,0x80,0x7f,0x75,0x67,0x58,0x4b,
0x3e,0x39,0x3f,0x4f,0x5f,0x6d,0x77,0x7f,0x81,0x7b,0x6c,0x5b,0x4e,0x45,0x42,0x48,
0x4f,0x5b,0x69,0x72,0x74,0x71,0x69,0x5e,0x52,0x49,0x44,0x48,0x50,0x5e,0x6a,0x76,
0x79,0x78,0x71,0x65,0x58,0x4e,0x49,0x49,0x51,0x5f,0x6b,0x73,0x74,0x71,0x6a,0x60,
0x55,0x4d,0x4b,0x4e,0x54,0x5f,0x69,0x70,0x71,0x6d,0x64,0x5a,0x51,0x4e,0x50,0x56,
0x5c,0x65,0x6d,0x6e,0x6a,0x64,0x5c,0x54,0x51,0x51,0x58,0x5f,0x68,0x6d,0x6c,0x68,
0x60,0x57,0x54,0x51,0x54,0x5a,0x61,0x67,0x6a,0x6b,0x67,0x60,0x59,0x54,0x54,0x57,
0x5b,0x62,0x67,0x69,0x65,0x60,0x5a,0x58,0x5a,0x5d,0x61,0x65,0x66,0x66,0x63,0x5d,
0x58,0x57,0x58,0x5b,0x5f,0x65,0x69,0x66,0x62,0x5c,0x54,0x53,0x58,0x5f,0x69,0x6d,
0x6e,0x6c,0x62,0x58,0x50,0x4f,0x54,0x5f,0x69,0x70,0x71,0x6b,0x5e,0x53,0x50,0x52,
0x5b,0x67,0x70,0x73,0x6e,0x60,0x51,0x46,0x44,0x4d,0x5b,0x6c,0x77,0x79,0x70,0x5f,
0x50,0x48,0x4a,0x57,0x67,0x76,0x7c,0x76,0x64,0x4f,0x3f,0x3d,0x47,0x5b,0x6f,0x7c,
0x77,0x69,0x50,0x3e,0x3d,0x4b,0x5f,0x74,0x7e,0x7c,0x6b,0x54,0x40,0x3a,0x45,0x5b,
0x71,0x80,0x7f,0x6f,0x58,0x44,0x3e,0x49,0x5f,0x75,0x81,0x7c,0x66,0x4c,0x37,0x34,
0x45,0x60,0x79,0x83,0x7a,0x65,0x48,0x39,0x39,0x4f,0x6d,0x83,0x84,0x75,0x59,0x3f,
0x37,0x46,0x62,0x7e,0x8c,0x83,0x67,0x47,0x34,0x3a,0x53,0x70,0x85,0x86,0x70,0x50,
0x36,0x34,0x48,0x68,0x7e,0x83,0x72,0x54,0x3a,0x34,0x44,0x64,0x80,0x89,0x7b,0x5f,
0x44,0x39,0x46,0x63,0x7e,0x88,0x7c,0x61,0x43,0x37,0x41,0x5d,0x78,0x84,0x78,0x5c,
0x40,0x36,0x44,0x63,0x7c,0x86,0x78,0x5a,0x3f,0x3a,0x4b,0x67,0x7f,0x84,0x72,0x56,
0x41,0x44,0x57,0x74,0x84,0x7f,0x69,0x4f,0x3e,0x4a,0x5f,0x76,0x80,0x76,0x5c,0x46,
0x41,0x51,0x69,0x79,0x7a,0x69,0x51,0x43,0x48,0x5f,0x75,0x7d,0x72,0x5c,0x49,0x46,
0x54,0x6a,0x7a,0x78,0x67,0x52,0x47,0x50,0x64,0x76,0x78,0x6a,0x56,0x49,0x4b,0x5c,
0x6e,0x76,0x6e,0x5b,0x4b,0x49,0x56,0x69,0x76,0x73,0x62,0x50,0x4a,0x54,0x67,0x76,
0x76,0x66,0x58,0x4e,0x53,0x64,0x72,0x76,0x6d,0x5c,0x4e,0x50,0x5c,0x6a,0x6d,0x68,
0x5a,0x51,0x53,0x5d,0x67,0x6d,0x69,0x5f,0x58,0x58,0x5f,0x68,0x6b,0x66,0x5f,0x5a,
0x5c,0x63,0x6b,0x6e,0x69,0x5f,0x58,0x57,0x5c,0x64,0x67,0x65,0x5f,0x58,0x58,0x5d,
0x64,0x69,0x67,0x60,0x58,0x5a,0x5e,0x62,0x66,0x66,0x60,0x5c,0x5b,0x5f,0x65,0x67,
0x65,0x60,0x5d,0x5c,0x60,0x64,0x66,0x65,0x60,0x5c,0x5a,0x5f,0x64,0x65,0x62,0x5d,
0x5b,0x5e,0x60,0x64,0x68,0x67,0x64,0x60,0x5e,0x61,0x60,0x64,0x61,0x5e,0x5d,0x60,
0x63,0x66,0x66,0x64,0x64,0x63,0x62,0x64,0x66,0x65,0x63,0x5f,0x5a,0x59,0x5a,0x5b,
0x5c,0x5f,0x60,0x60,0x60,0x61,0x62,0x64,0x62,0x62,0x61,0x60,0x5f,0x5d,0x5b,0x5c,
0x5d,0x5f,0x60,0x61,0x64,0x66,0x64,0x64,0x5f,0x5f,0x61,0x60,0x5e,0x5f,0x5f,0x5f,
0x5f,0x5f,0x5f,0x60,0x60,0x60,0x60,0x62,0x62,0x64,0x63,0x60,0x5f,0x61,0x62,0x64,
0x64,0x62,0x5f,0x5e,0x5d,0x5f,0x60,0x60,0x5f,0x5f,0x5f,0x5f,0x5f,0x60,0x5f,0x5f,
0x60,0x63,0x64,0x63,0x63,0x63,0x63,0x61,0x5f,0x5f,0x61,0x61,0x5f,0x60,0x60,0x60,
0x62,0x66,0x66,0x66,0x64,0x64,0x64,0x63,0x62,0x63,0x62,0x61,0x60,0x61,0x60,0x5f,
0x60,0x61,0x60,0x5f,0x5d,0x5f,0x60,0x60,0x5f,0x60,0x62,0x64,0x64,0x65,0x65,0x65,
0x62,0x60,0x5e,0x5f,0x5f,0x5f,0x5e,0x5d,0x5c,0x5f,0x61,0x61,0x61,0x62,0x64,0x66,
0x66,0x67,0x66,0x67,0x65,0x61,0x5f,0x5f,0x5f,0x62,0x62,0x60,0x60,0x5f,0x60,0x60,
0x64,0x65,0x66,0x66,0x65,0x64,0x62,0x62,0x61,0x62,0x63,0x61,0x5f,0x5d,0x5c,0x5f,
0x60,0x62,0x61,0x60,0x60,0x60,0x60,0x61,0x62,0x64,0x63,0x62,0x61,0x61,0x62,0x62,
0x60,0x60,0x62,0x63,0x63,0x64,0x63,0x61,0x62,0x63,0x63,0x62,0x62,0x64,0x63,0x62,
0x61,0x60,0x61,0x61,0x60,0x62,0x63,0x64,0x63,0x62,0x60,0x5f,0x5f,0x5f,0x5f,0x60,
0x60,0x5f,0x5f,0x5f,0x5d,0x5d,0x5c,0x5d,0x5e,0x60,0x60,0x61,0x61,0x60,0x61,0x62,
0x64,0x65,0x67,0x66,0x62,0x62,0x60,0x60,0x5f,0x5f,0x60,0x62,0x63,0x63,0x61,0x60,
0x5f,0x60,0x61,0x63,0x60,0x62,0x5f,0x5d,0x5d,0x5e,0x61,0x64,0x64,0x64,0x65,0x64,
0x62,0x60,0x60,0x61,0x61,0x61,0x60,0x5f,0x5f,0x5f,0x5d,0x5f,0x60,0x60,0x5f,0x5c,
0x5a,0x5b,0x5c,0x5d,0x5d,0x60,0x60,0x60,0x61,0x62,0x61,0x65,0x65,0x64,0x65,0x64,
0x63,0x64,0x62,0x60,0x5f,0x60,0x60,0x5e,0x5d,0x5c,0x5c,0x5d,0x5f,0x60,0x62,0x63,
0x62,0x63,0x62,0x62,0x62,0x62,0x60,0x60,0x5e,0x5d,0x5d,0x5d,0x5d,0x5f,0x60,0x5f,
0x5f,0x62,0x62,0x62,0x63,0x63,0x61,0x62,0x5f,0x5d,0x5d,0x5e,0x5f,0x60,0x5f,0x5c,
0x5b,0x5b,0x5b,0x58,0x55,0x51,0x4e,0x49,0x43,0x3e,0x3c,0x39,0x39,0x39,0x37,0x34,
0x32,0x31,0x31,0x32,0x33,0x36,0x37,0x37,0x37,0x37,0x38,0x3a,0x39,0x3c,0x3a,0x38,
0x36,0x34,0x33,0x34,0x33,0x33,0x36,0x38,0x39,0x39,0x39,0x39,0x38,0x39,0x38,0x39,
0x38,0x37,0x36,0x36,0x37,0x39,0x3b,0x3a,0x38,0x39,0x37,0x36,0x33,0x33,0x36,0x37,
0x37,0x36,0x33,0x35,0x37,0x39,0x3a,0x3a,0x39,0x38,0x34,0x32,0x33,0x37,0x38,0x36,
0x36,0x35,0x34,0x35,0x34,0x34,0x34,0x35,0x33,0x33,0x32,0x31,0x31,0x32,0x33,0x35,
0x35,0x36,0x36,0x36,0x34,0x34,0x36,0x37,0x38,0x38,0x37,0x36,0x34,0x34,0x34,0x34,
// Line 20
0x3b,0x3d,0x3b,0x3a,0x38,0x3b,0x3d,0x3d,0x3b,0x3b,0x3a,0x3a,0x37,0x38,0x37,0x38,
0x37,0x39,0x39,0x3a,0x39,0x3a,0x39,0x3a,0x3a,0x3b,0x3b,0x3a,0x39,0x3b,0x3e,0x43,
0x4c,0x57,0x64,0x72,0x81,0x91,0xa1,0xb0,0xb9,0xc1,0xc4,0xc4,0xc2,0xc2,0xc3,0xc3,
0xc3,0xc3,0xbf,0xbf,0xbc,0xbc,0xc0,0xc1,0xbf,0xbf,0xbb,0xb8,0xb8,0xba,0xbc,0xbe,
0xbd,0xbd,0xbc,0xbd,0xbd,0xbc,0xbb,0xba,0xba,0xbb,0xba,0xbc,0xbf,0xbf,0xbe,0xbe,
0xbf,0xc1,0xc2,0xc0,0xbf,0xbe,0xbe,0xbf,0xbe,0xbd,0xbd,0xbc,0xbd,0xbf,0xbf,0xbf,
0xbd,0xbb,0xbb,0xbb,0xbd,0xbb,0xbd,0xbc,0xbb,0xbc,0xbd,0xbc,0xbc,0xbe,0xbd,0xbc,
0xba,0xb9,0xba,0xbb,0xbc,0xbc,0xbc,0xbc,0xbd,0xbe,0xbd,0xbf,0xc1,0xc2,0xc0,0xbe,
0xbc,0xbb,0xbe,0xbf,0xbf,0xc0,0xbf,0xbd,0xbe,0xbf,0xbf,0xbd,0xbe,0xbd,0xbc,0xbc,
0xbc,0xbb,0xbf,0xbd,0xbe,0xbf,0xbd,0xbc,0xbd,0xbe,0xbe,0xbf,0xbc,0xbb,0xbb,0xba,
0xba,0xbb,0xbe,0xbf,0xbe,0xbe,0xbd,0xbd,0xbf,0xbf,0xc0,0xc0,0xbf,0xbd,0xbc,0xbc,
0xbc,0xbc,0xbb,0xbb,0xbb,0xbe,0xbf,0xbc,0xbb,0xba,0xbb,0xbe,0xbf,0xbe,0xbf,0xbd,
0xbb,0xbd,0xbf,0xc3,0xc5,0xc7,0xc4,0xc2,0xc0,0xc1,0xc3,0xc5,0xc2,0xbf,0xbc,0xb9,
0xb8,0xbb,0xbf,0xc1,0xbf,0xb8,0xb1,0xae,0xae,0xb3,0xb6,0xb6,0xb0,0xa2,0x93,0x87,
0x87,0x95,0xa3,0xaa,0xa8,0x9b,0x89,0x81,0x86,0x97,0xaa,0xb5,0xb1,0x9f,0x88,0x78,
0x79,0x8b,0xa4,0xb3,0xb2,0xa0,0x87,0x76,0x76,0x8a,0xa3,0xb3,0xb1,0x9f,0x86,0x74,
0x75,0x89,0xa3,0xb4,0xb4,0xa3,0x8a,0x7a,0x7a,0x8c,0xa2,0xb2,0xb0,0x9f,0x88,0x79,
0x7b,0x8e,0xa4,0xb4,0xb4,0xa5,0x8c,0x7e,0x7e,0x8d,0xa5,0xb4,0xb2,0xa1,0x89,0x79,
0x79,0x89,0x9f,0xb0,0xb0,0xa1,0x8b,0x7a,0x7b,0x8e,0xa6,0xb4,0xb3,0xa3,0x8b,0x7b,
0x7c,0x8c,0xa2,0xb2,0xb2,0xa4,0x8c,0x7a,0x79,0x8c,0xa5,0xb4,0xb2,0xa2,0x8b,0x7b,
0x7d,0x8f,0xa5,0xb5,0xb4,0xa4,0x8b,0x79,0x79,0x8a,0xa2,0xb2,0xb2,0xa3,0x8c,0x7b,
0x7e,0x8e,0xa3,0xb4,0xb4,0xa4,0x8c,0x7a,0x79,0x8a,0xa1,0xb2,0xb3,0xa3,0x8a,0x77,
0x77,0x8a,0xa2,0xb4,0xb4,0xa5,0x90,0x7f,0x7c,0x8c,0xa2,0xb2,0xb3,0xa4,0x8d,0x7c,
0x7a,0x8c,0xa2,0xb4,0xb4,0xa5,0x90,0x7f,0x7c,0x8c,0xa2,0xb2,0xb2,0xa2,0x8c,0x7d,
0x7e,0x90,0xa6,0xb2,0xac,0x9c,0x89,0x7d,0x81,0x91,0xa3,0xab,0xa9,0x9c,0x8e,0x89,
0x8f,0x9b,0xa3,0x9f,0x92,0x84,0x7e,0x84,0x93,0x9f,0x9e,0x8d,0x77,0x69,0x6b,0x7f,
0x96,0xa5,0x9f,0x86,0x6a,0x5f,0x6b,0x89,0xa6,0xb3,0xa6,0x87,0x66,0x59,0x68,0x87,
0xa5,0xb0,0xa3,0x82,0x60,0x54,0x62,0x83,0xa3,0xaf,0xa2,0x80,0x63,0x55,0x62,0x83,
0xa2,0xae,0xa2,0x83,0x65,0x5b,0x69,0x89,0xa8,0xb4,0xa7,0x89,0x67,0x58,0x64,0x85,
0xa3,0xb1,0xa6,0x87,0x66,0x58,0x65,0x85,0xa6,0xb4,0xa8,0x89,0x67,0x57,0x64,0x83,
0xa2,0xb0,0xa3,0x83,0x61,0x54,0x61,0x80,0xa2,0xb0,0xa5,0x88,0x68,0x59,0x68,0x86,
0xa3,0xb1,0xa4,0x83,0x61,0x53,0x60,0x81,0xa1,0xb0,0xa3,0x85,0x64,0x56,0x66,0x87,
0xa4,0xb0,0xa2,0x83,0x64,0x57,0x64,0x85,0xa2,0xaf,0xa2,0x84,0x64,0x58,0x65,0x82,
0x9f,0xae,0xa4,0x87,0x69,0x5b,0x68,0x88,0xa6,0xb2,0xa5,0x86,0x64,0x55,0x60,0x81,
0xa0,0xae,0xa1,0x83,0x65,0x58,0x65,0x86,0xa4,0xb0,0xa4,0x84,0x63,0x55,0x64,0x84,
0xa2,0xaf,0xa2,0x82,0x66,0x58,0x63,0x83,0xa2,0xaf,0xa6,0x86,0x65,0x59,0x64,0x82,
0x9e,0xac,0xa2,0x87,0x67,0x58,0x62,0x7f,0x9c,0xac,0xa8,0x8f,0x6f,0x5b,0x5c,0x74,
0x91,0xa5,0xa3,0x8d,0x6d,0x55,0x52,0x66,0x83,0x9b,0x9e,0x8c,0x6f,0x58,0x52,0x61,
0x7f,0x9b,0xa4,0x97,0x78,0x5c,0x52,0x60,0x7c,0x98,0xa2,0x98,0x7a,0x63,0x54,0x5c,
0x7c,0x9c,0xa7,0x99,0x78,0x5a,0x50,0x5e,0x7b,0x97,0xa2,0x96,0x79,0x5c,0x50,0x5d,
0x7c,0x97,0xa1,0x94,0x76,0x5c,0x52,0x60,0x7b,0x96,0xa0,0x94,0x77,0x5c,0x51,0x60,
0x7c,0x97,0x9f,0x95,0x79,0x5e,0x54,0x63,0x7e,0x9a,0xa2,0x96,0x7a,0x5d,0x50,0x5e,
0x79,0x95,0xa0,0x94,0x79,0x5e,0x54,0x5f,0x7c,0x98,0xa4,0x97,0x7a,0x5b,0x4c,0x5a,
0x79,0x98,0xa4,0x97,0x7a,0x5e,0x52,0x60,0x7e,0x9c,0xa7,0x9a,0x7c,0x5c,0x4f,0x5d,
0x7c,0x9a,0xa5,0x96,0x76,0x57,0x4c,0x5a,0x7b,0x9a,0xa5,0x97,0x78,0x5a,0x4f,0x5e,
0x7c,0x9a,0xa5,0x97,0x77,0x58,0x4e,0x5f,0x7f,0x9b,0xa5,0x96,0x78,0x5c,0x50,0x5f,
0x7c,0x97,0xa1,0x90,0x72,0x58,0x4f,0x5e,0x7b,0x96,0xa1,0x95,0x79,0x5f,0x57,0x65,
0x7f,0x96,0x9f,0x93,0x79,0x60,0x57,0x63,0x7b,0x91,0x99,0x91,0x7c,0x68,0x5f,0x68,
0x79,0x8a,0x93,0x91,0x86,0x7b,0x70,0x6b,0x6c,0x6d,0x6e,0x71,0x74,0x78,0x7a,0x74,
0x69,0x59,0x54,0x5c,0x6b,0x7e,0x86,0x7c,0x69,0x50,0x42,0x4d,0x69,0x87,0x96,0x8c,
0x6c,0x4c,0x3c,0x4b,0x6c,0x8c,0x98,0x8b,0x6b,0x49,0x3a,0x4a,0x69,0x88,0x94,0x85,
0x63,0x45,0x3a,0x4c,0x6d,0x8b,0x94,0x85,0x66,0x4b,0x42,0x51,0x6e,0x8a,0x94,0x85,
0x64,0x47,0x3c,0x4c,0x6d,0x8a,0x94,0x88,0x6a,0x4c,0x3f,0x4d,0x69,0x88,0x95,0x87,
0x65,0x4a,0x3e,0x4c,0x6d,0x8b,0x96,0x87,0x67,0x49,0x3f,0x4f,0x70,0x8c,0x93,0x84,
0x64,0x47,0x3d,0x4b,0x6b,0x89,0x93,0x85,0x65,0x48,0x3e,0x4c,0x69,0x88,0x93,0x85,
0x66,0x48,0x3b,0x4a,0x68,0x87,0x93,0x8a,0x6b,0x4d,0x41,0x4d,0x69,0x87,0x91,0x83,
0x68,0x4c,0x40,0x4d,0x6a,0x86,0x91,0x86,0x68,0x4b,0x41,0x4f,0x6b,0x87,0x90,0x85,
0x6a,0x4c,0x41,0x4f,0x6e,0x8a,0x94,0x87,0x69,0x4e,0x44,0x52,0x6d,0x89,0x92,0x82,
0x64,0x47,0x3c,0x4e,0x6b,0x87,0x93,0x87,0x6b,0x4d,0x41,0x4f,0x6d,0x88,0x91,0x82,
0x67,0x4d,0x43,0x53,0x70,0x8b,0x94,0x86,0x67,0x4d,0x46,0x56,0x74,0x8c,0x8f,0x7d,
0x62,0x4b,0x48,0x5b,0x74,0x87,0x84,0x6b,0x4b,0x38,0x3d,0x57,0x75,0x87,0x81,0x65,
0x46,0x37,0x43,0x61,0x7f,0x8c,0x83,0x60,0x3e,0x32,0x40,0x62,0x83,0x8d,0x7d,0x5c,
0x3c,0x31,0x3e,0x60,0x7d,0x89,0x7c,0x5c,0x3e,0x34,0x44,0x65,0x85,0x8f,0x81,0x61,
0x3f,0x30,0x3d,0x5c,0x7b,0x89,0x7c,0x5c,0x3d,0x30,0x3c,0x5c,0x7c,0x8c,0x7e,0x5e,
0x3d,0x30,0x41,0x5f,0x7c,0x8c,0x80,0x5f,0x3c,0x2e,0x3a,0x5c,0x7c,0x8c,0x7e,0x60,
0x3f,0x32,0x40,0x60,0x80,0x8f,0x81,0x60,0x3f,0x32,0x3f,0x60,0x7f,0x8d,0x80,0x62,
0x41,0x33,0x3e,0x5d,0x7d,0x8c,0x7e,0x5e,0x3e,0x30,0x3a,0x5c,0x7c,0x8d,0x82,0x61,
0x3e,0x30,0x3e,0x5e,0x7e,0x8c,0x81,0x62,0x41,0x32,0x3e,0x5f,0x80,0x8f,0x82,0x61,
0x40,0x32,0x3f,0x5f,0x80,0x8f,0x83,0x62,0x3f,0x30,0x3c,0x5e,0x7e,0x8c,0x81,0x61,
0x3f,0x33,0x40,0x60,0x80,0x8c,0x7e,0x5e,0x3d,0x30,0x3e,0x5d,0x7c,0x8b,0x7f,0x60,
0x40,0x36,0x43,0x63,0x82,0x8f,0x82,0x65,0x46,0x37,0x42,0x5e,0x7a,0x84,0x7b,0x61,
0x45,0x3a,0x42,0x5a,0x79,0x89,0x82,0x6e,0x54,0x43,0x3e,0x4a,0x59,0x69,0x6d,0x67,
0x55,0x45,0x3a,0x3a,0x46,0x54,0x60,0x65,0x5f,0x50,0x3e,0x32,0x34,0x44,0x56,0x63,
0x64,0x56,0x42,0x30,0x2d,0x3f,0x59,0x6f,0x72,0x62,0x47,0x31,0x2b,0x3c,0x55,0x6a,
0x6d,0x5d,0x42,0x30,0x30,0x42,0x58,0x6b,0x6a,0x59,0x41,0x2e,0x2c,0x3f,0x58,0x6a,
0x6b,0x5b,0x44,0x35,0x35,0x43,0x58,0x69,0x6a,0x5b,0x44,0x32,0x30,0x40,0x57,0x68,
0x69,0x5a,0x43,0x34,0x32,0x42,0x5a,0x6c,0x6c,0x5c,0x43,0x30,0x2e,0x3f,0x56,0x69,
0x6a,0x5a,0x43,0x30,0x2f,0x41,0x5c,0x6e,0x70,0x61,0x48,0x35,0x34,0x44,0x5b,0x6b,
0x6b,0x5a,0x41,0x30,0x2e,0x3f,0x5a,0x6a,0x6a,0x5a,0x41,0x2f,0x2f,0x3f,0x55,0x67,
0x69,0x5a,0x40,0x31,0x2f,0x40,0x59,0x6b,0x6b,0x5f,0x45,0x31,0x31,0x44,0x5c,0x70,
0x6e,0x5d,0x44,0x32,0x30,0x3e,0x55,0x67,0x68,0x57,0x3e,0x2c,0x2e,0x41,0x59,0x6b,
0x6d,0x5f,0x48,0x36,0x32,0x43,0x5a,0x6b,0x6d,0x5c,0x42,0x30,0x2e,0x3e,0x54,0x68,
0x66,0x58,0x43,0x32,0x30,0x3f,0x57,0x67,0x67,0x59,0x45,0x35,0x32,0x3f,0x53,0x64,
0x65,0x5b,0x4a,0x3c,0x3a,0x43,0x50,0x59,0x5a,0x53,0x47,0x3e,0x3b,0x3f,0x46,0x48,
0x45,0x40,0x3b,0x38,0x38,0x3c,0x40,0x42,0x43,0x42,0x42,0x44,0x45,0x45,0x44,0x42,
0x40,0x40,0x41,0x43,0x44,0x47,0x46,0x45,0x46,0x44,0x43,0x46,0x46,0x46,0x45,0x44,
0x41,0x41,0x41,0x42,0x3f,0x42,0x42,0x43,0x43,0x41,0x3f,0x3f,0x3f,0x42,0x43,0x43,
0x44,0x46,0x44,0x43,0x44,0x45,0x46,0x46,0x43,0x41,0x3f,0x40,0x40,0x41,0x43,0x43,
0x43,0x45,0x46,0x45,0x44,0x43,0x43,0x43,0x43,0x44,0x41,0x41,0x3e,0x3c,0x3c,0x3e,
0x3e,0x41,0x42,0x41,0x43,0x43,0x43,0x44,0x46,0x47,0x48,0x47,0x47,0x46,0x45,0x43,
0x42,0x43,0x43,0x43,0x42,0x42,0x42,0x42,0x42,0x41,0x41,0x40,0x40,0x41,0x41,0x42,
0x42,0x42,0x40,0x40,0x42,0x44,0x45,0x46,0x46,0x43,0x43,0x42,0x41,0x43,0x44,0x44,
0x43,0x43,0x42,0x40,0x3e,0x3e,0x3e,0x41,0x42,0x42,0x41,0x40,0x3f,0x43,0x44,0x46,
0x46,0x44,0x43,0x43,0x42,0x44,0x44,0x42,0x40,0x3f,0x41,0x41,0x40,0x3f,0x3f,0x3e,
0x3f,0x3f,0x3f,0x43,0x43,0x42,0x41,0x41,0x43,0x45,0x44,0x43,0x44,0x44,0x44,0x41,
0x43,0x42,0x3f,0x3e,0x3c,0x3a,0x3a,0x39,0x38,0x39,0x3a,0x3b,0x3a,0x3a,0x37,0x38,
// Line 21
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//Field 8
// Line 10
0x39,0x37,0x36,0x36,0x36,0x36,0x37,0x37,0x36,0x35,0x36,0x36,0x37,0x38,0x39,0x38,
0x37,0x36,0x35,0x35,0x36,0x38,0x3a,0x3a,0x37,0x37,0x38,0x38,0x38,0x37,0x36,0x38,
0x3a,0x39,0x3a,0x39,0x39,0x3a,0x3a,0x39,0x37,0x35,0x34,0x33,0x33,0x33,0x35,0x37,
0x37,0x34,0x34,0x35,0x36,0x37,0x3a,0x3a,0x38,0x37,0x37,0x37,0x39,0x3a,0x3b,0x3b,
0x3a,0x38,0x37,0x37,0x37,0x39,0x39,0x37,0x37,0x37,0x36,0x37,0x36,0x36,0x38,0x39,
0x38,0x35,0x36,0x36,0x36,0x37,0x36,0x35,0x38,0x39,0x38,0x35,0x36,0x35,0x36,0x37,
0x37,0x34,0x34,0x34,0x35,0x38,0x39,0x3a,0x3a,0x39,0x38,0x38,0x36,0x36,0x37,0x36,
0x35,0x34,0x34,0x36,0x39,0x3b,0x3b,0x39,0x3a,0x3b,0x3c,0x3b,0x3b,0x3a,0x3b,0x3a,
0x38,0x38,0x37,0x37,0x38,0x39,0x39,0x38,0x38,0x37,0x37,0x39,0x3a,0x3a,0x3b,0x3a,
0x37,0x37,0x39,0x39,0x38,0x39,0x39,0x39,0x37,0x35,0x35,0x36,0x36,0x36,0x38,0x38,
0x39,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3c,0x3a,0x36,0x35,0x36,0x36,0x35,0x36,0x36,
0x35,0x36,0x36,0x36,0x36,0x36,0x35,0x37,0x39,0x39,0x37,0x38,0x38,0x3a,0x3a,0x3a,
0x38,0x3a,0x38,0x36,0x37,0x39,0x3a,0x3b,0x3a,0x3a,0x3b,0x3c,0x3a,0x39,0x38,0x38,
0x38,0x39,0x39,0x3a,0x3b,0x3a,0x37,0x38,0x36,0x37,0x3a,0x3a,0x38,0x37,0x37,0x39,
0x38,0x38,0x38,0x39,0x3a,0x39,0x37,0x37,0x36,0x37,0x39,0x39,0x3a,0x3a,0x39,0x38,
0x3a,0x3c,0x3d,0x3b,0x38,0x37,0x38,0x3a,0x38,0x36,0x37,0x37,0x35,0x35,0x34,0x36,
0x38,0x3a,0x3a,0x3b,0x3a,0x3b,0x3b,0x3a,0x39,0x38,0x38,0x38,0x36,0x3a,0x38,0x36,
0x36,0x37,0x37,0x38,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x35,0x35,0x36,0x36,0x36,
0x35,0x35,0x36,0x36,0x35,0x35,0x38,0x3a,0x3a,0x3a,0x3b,0x3c,0x3c,0x3b,0x3a,0x3b,
0x3a,0x39,0x36,0x36,0x36,0x36,0x38,0x39,0x39,0x39,0x39,0x37,0x38,0x3a,0x3a,0x36,
0x37,0x37,0x37,0x39,0x39,0x39,0x3b,0x3b,0x3b,0x3a,0x38,0x37,0x36,0x35,0x36,0x37,
0x39,0x3a,0x3a,0x39,0x37,0x37,0x3a,0x3a,0x3a,0x3a,0x3b,0x3b,0x3a,0x3a,0x3a,0x3a,
0x37,0x35,0x35,0x36,0x38,0x37,0x3a,0x38,0x38,0x3a,0x3a,0x3a,0x3d,0x3c,0x3b,0x3a,
0x36,0x35,0x36,0x37,0x39,0x3a,0x3d,0x3d,0x3a,0x39,0x38,0x39,0x3a,0x3a,0x3b,0x3c,
0x3b,0x3b,0x3c,0x3b,0x3b,0x3b,0x3b,0x39,0x39,0x39,0x39,0x38,0x36,0x36,0x37,0x3b,
0x3b,0x3a,0x3b,0x3a,0x38,0x37,0x37,0x38,0x39,0x3a,0x39,0x36,0x35,0x36,0x36,0x3a,
0x39,0x39,0x3a,0x38,0x37,0x38,0x3a,0x3a,0x39,0x37,0x38,0x38,0x36,0x36,0x38,0x39,
0x38,0x36,0x37,0x3a,0x3d,0x3f,0x3e,0x3c,0x3a,0x39,0x39,0x3a,0x3b,0x3a,0x3a,0x38,
0x36,0x36,0x37,0x3b,0x3e,0x3e,0x3b,0x39,0x39,0x3a,0x3a,0x3a,0x3b,0x3a,0x39,0x38,
0x37,0x36,0x37,0x36,0x37,0x37,0x37,0x35,0x36,0x36,0x37,0x3b,0x3c,0x3c,0x3c,0x3a,
0x3a,0x3b,0x3c,0x3c,0x3b,0x3b,0x38,0x35,0x35,0x38,0x3a,0x3b,0x3a,0x37,0x38,0x38,
0x36,0x37,0x38,0x39,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x39,0x39,0x36,
0x35,0x35,0x33,0x34,0x36,0x37,0x38,0x39,0x38,0x39,0x3b,0x3b,0x3b,0x3b,0x3b,0x3a,
0x37,0x38,0x36,0x35,0x35,0x34,0x33,0x33,0x33,0x36,0x3a,0x3b,0x3a,0x39,0x38,0x39,
0x3a,0x3a,0x3b,0x3a,0x37,0x35,0x35,0x39,0x3b,0x3c,0x3d,0x3c,0x39,0x37,0x33,0x34,
0x36,0x37,0x36,0x35,0x33,0x33,0x35,0x36,0x36,0x36,0x37,0x3a,0x39,0x3a,0x3b,0x3a,
0x3a,0x3b,0x3c,0x3e,0x3c,0x3a,0x3a,0x37,0x36,0x36,0x36,0x37,0x37,0x39,0x38,0x35,
0x33,0x33,0x36,0x39,0x39,0x37,0x36,0x36,0x36,0x38,0x3a,0x3b,0x3c,0x3b,0x36,0x31,
0x32,0x35,0x36,0x38,0x36,0x34,0x37,0x38,0x37,0x36,0x36,0x37,0x39,0x39,0x37,0x37,
0x38,0x38,0x37,0x35,0x34,0x35,0x36,0x38,0x36,0x36,0x36,0x36,0x36,0x35,0x34,0x35,
0x36,0x3a,0x3a,0x39,0x36,0x35,0x36,0x38,0x38,0x37,0x37,0x38,0x3a,0x38,0x36,0x37,
0x3a,0x3b,0x3d,0x3c,0x3a,0x38,0x36,0x35,0x35,0x35,0x37,0x38,0x38,0x36,0x35,0x37,
0x38,0x39,0x3a,0x39,0x38,0x39,0x39,0x3a,0x3a,0x3a,0x39,0x39,0x3a,0x38,0x36,0x34,
0x35,0x34,0x36,0x36,0x34,0x35,0x36,0x36,0x36,0x37,0x3a,0x3a,0x3a,0x37,0x36,0x37,
0x38,0x38,0x39,0x37,0x36,0x38,0x37,0x37,0x39,0x3b,0x3b,0x3b,0x39,0x38,0x38,0x38,
0x36,0x37,0x39,0x39,0x37,0x37,0x37,0x37,0x37,0x38,0x38,0x38,0x36,0x37,0x38,0x39,
0x3c,0x3e,0x3e,0x3b,0x39,0x3a,0x3a,0x39,0x3b,0x3c,0x3c,0x3c,0x3b,0x3a,0x3c,0x3e,
0x3d,0x3e,0x3d,0x3c,0x39,0x38,0x37,0x36,0x38,0x3a,0x39,0x38,0x36,0x36,0x39,0x3a,
0x3a,0x3a,0x3b,0x3a,0x38,0x35,0x35,0x35,0x35,0x36,0x39,0x39,0x38,0x37,0x37,0x36,
0x36,0x3a,0x3c,0x3b,0x3b,0x3a,0x38,0x38,0x39,0x3b,0x3d,0x3c,0x3a,0x37,0x37,0x39,
0x3a,0x38,0x37,0x37,0x39,0x38,0x36,0x36,0x37,0x38,0x3a,0x38,0x36,0x37,0x3a,0x3b,
0x3a,0x3a,0x3a,0x38,0x39,0x36,0x35,0x35,0x36,0x36,0x37,0x36,0x35,0x35,0x36,0x38,
0x39,0x3a,0x39,0x37,0x36,0x36,0x35,0x36,0x36,0x37,0x39,0x38,0x36,0x37,0x39,0x3b,
0x3d,0x3d,0x3c,0x39,0x38,0x35,0x34,0x35,0x35,0x34,0x34,0x33,0x33,0x35,0x36,0x38,
0x3a,0x39,0x38,0x38,0x38,0x38,0x38,0x39,0x3a,0x3a,0x38,0x37,0x37,0x39,0x3a,0x3a,
0x3b,0x3b,0x39,0x36,0x35,0x34,0x38,0x3b,0x3a,0x3a,0x38,0x37,0x36,0x36,0x38,0x3a,
0x3b,0x3a,0x37,0x37,0x36,0x36,0x37,0x38,0x3a,0x3b,0x3b,0x3a,0x39,0x39,0x38,0x39,
0x3a,0x3a,0x3a,0x39,0x36,0x32,0x33,0x35,0x36,0x37,0x39,0x38,0x38,0x36,0x35,0x36,
0x37,0x38,0x38,0x38,0x38,0x37,0x37,0x36,0x36,0x3a,0x38,0x37,0x37,0x36,0x36,0x37,
0x38,0x39,0x3a,0x3a,0x38,0x37,0x36,0x36,0x35,0x36,0x36,0x35,0x36,0x37,0x37,0x37,
0x35,0x35,0x37,0x38,0x36,0x35,0x37,0x37,0x37,0x38,0x3a,0x3b,0x3e,0x3b,0x39,0x39,
0x38,0x37,0x37,0x35,0x35,0x35,0x36,0x35,0x33,0x35,0x36,0x38,0x39,0x3a,0x3a,0x3a,
0x36,0x35,0x36,0x35,0x34,0x33,0x34,0x34,0x33,0x33,0x36,0x37,0x36,0x35,0x36,0x36,
0x38,0x3a,0x39,0x38,0x36,0x36,0x37,0x36,0x36,0x36,0x35,0x35,0x33,0x31,0x33,0x34,
0x36,0x37,0x39,0x3a,0x3b,0x3b,0x3a,0x37,0x37,0x38,0x37,0x37,0x33,0x32,0x33,0x33,
0x33,0x33,0x33,0x34,0x36,0x35,0x35,0x36,0x36,0x35,0x35,0x38,0x39,0x39,0x39,0x36,
0x33,0x35,0x35,0x36,0x37,0x37,0x37,0x36,0x36,0x36,0x36,0x39,0x39,0x38,0x3a,0x39,
0x38,0x38,0x36,0x35,0x37,0x38,0x38,0x38,0x37,0x36,0x35,0x34,0x35,0x37,0x3a,0x3b,
0x3b,0x3b,0x3a,0x39,0x39,0x38,0x38,0x3a,0x3b,0x3b,0x3a,0x38,0x36,0x37,0x38,0x38,
0x38,0x3a,0x3a,0x39,0x39,0x37,0x37,0x36,0x35,0x35,0x36,0x37,0x37,0x36,0x35,0x33,
0x33,0x34,0x35,0x36,0x36,0x36,0x36,0x37,0x39,0x38,0x3a,0x39,0x38,0x3a,0x3a,0x3a,
0x37,0x36,0x35,0x35,0x33,0x33,0x33,0x35,0x37,0x38,0x39,0x38,0x38,0x3a,0x3a,0x39,
0x39,0x3a,0x3a,0x3a,0x36,0x35,0x37,0x37,0x38,0x39,0x3a,0x3a,0x37,0x37,0x37,0x37,
0x39,0x39,0x38,0x3a,0x3a,0x39,0x37,0x35,0x35,0x37,0x37,0x36,0x34,0x35,0x36,0x37,
0x38,0x39,0x3a,0x3a,0x37,0x36,0x35,0x35,0x35,0x34,0x35,0x35,0x37,0x37,0x38,0x37,
0x39,0x37,0x36,0x37,0x36,0x36,0x3a,0x38,0x36,0x37,0x39,0x3a,0x3a,0x39,0x37,0x37,
0x37,0x36,0x35,0x35,0x33,0x33,0x36,0x36,0x37,0x37,0x37,0x37,0x38,0x38,0x38,0x36,
0x36,0x36,0x37,0x36,0x35,0x34,0x36,0x36,0x36,0x36,0x37,0x37,0x37,0x36,0x33,0x34,
0x35,0x35,0x33,0x33,0x33,0x33,0x33,0x35,0x35,0x38,0x39,0x37,0x37,0x36,0x34,0x34,
0x35,0x35,0x38,0x3a,0x3a,0x38,0x36,0x35,0x35,0x36,0x36,0x38,0x38,0x35,0x33,0x33,
0x35,0x36,0x38,0x39,0x39,0x3a,0x38,0x39,0x38,0x3a,0x39,0x39,0x39,0x37,0x35,0x35,
0x34,0x34,0x35,0x33,0x33,0x33,0x33,0x35,0x36,0x37,0x38,0x36,0x35,0x34,0x34,0x36,
0x38,0x39,0x39,0x38,0x38,0x3a,0x3a,0x3b,0x3b,0x3a,0x38,0x39,0x39,0x3a,0x38,0x37,
0x36,0x36,0x36,0x37,0x38,0x3a,0x3a,0x38,0x39,0x3a,0x3b,0x3e,0x3d,0x3b,0x3a,0x39,
0x37,0x35,0x35,0x35,0x33,0x35,0x33,0x33,0x35,0x37,0x3b,0x3e,0x3d,0x3d,0x3c,0x3a,
0x37,0x38,0x39,0x3a,0x3b,0x39,0x37,0x35,0x35,0x37,0x3a,0x3a,0x38,0x36,0x36,0x35,
0x33,0x32,0x33,0x35,0x37,0x39,0x39,0x34,0x37,0x37,0x37,0x3a,0x3a,0x39,0x39,0x38,
0x36,0x35,0x35,0x35,0x37,0x38,0x37,0x37,0x37,0x3a,0x3c,0x3c,0x3b,0x3a,0x38,0x37,
0x35,0x35,0x35,0x35,0x35,0x35,0x36,0x39,0x39,0x3a,0x3b,0x3c,0x3c,0x3a,0x38,0x37,
0x36,0x38,0x38,0x38,0x38,0x38,0x37,0x36,0x34,0x35,0x36,0x35,0x35,0x35,0x35,0x35,
0x35,0x36,0x36,0x38,0x3a,0x3a,0x38,0x36,0x34,0x35,0x37,0x36,0x36,0x37,0x38,0x39,
0x38,0x39,0x3a,0x37,0x3a,0x39,0x37,0x3a,0x39,0x37,0x36,0x37,0x36,0x37,0x38,0x38,
0x38,0x36,0x33,0x33,0x36,0x38,0x39,0x3b,0x3a,0x3a,0x3a,0x3a,0x3a,0x3b,0x3a,0x38,
0x35,0x33,0x34,0x36,0x36,0x35,0x35,0x37,0x37,0x36,0x35,0x35,0x36,0x37,0x36,0x34,
0x33,0x33,0x33,0x34,0x33,0x33,0x36,0x38,0x37,0x37,0x36,0x38,0x3a,0x3a,0x39,0x39,
0x3a,0x39,0x35,0x33,0x33,0x35,0x39,0x3a,0x39,0x39,0x39,0x39,0x39,0x39,0x3a,0x3a,
// Line 11
0x36,0x37,0x37,0x36,0x35,0x35,0x34,0x34,0x35,0x35,0x35,0x34,0x34,0x34,0x37,0x37,
0x38,0x38,0x38,0x38,0x39,0x38,0x38,0x38,0x37,0x35,0x34,0x35,0x36,0x37,0x37,0x37,
0x35,0x36,0x37,0x37,0x38,0x39,0x39,0x39,0x37,0x34,0x33,0x33,0x34,0x36,0x36,0x34,
0x2f,0x2f,0x33,0x3e,0x50,0x64,0x71,0x78,0x74,0x67,0x5b,0x54,0x56,0x5f,0x6b,0x75,
0x78,0x74,0x6c,0x64,0x5d,0x5b,0x61,0x6a,0x71,0x72,0x72,0x6c,0x64,0x5e,0x58,0x58,
0x5c,0x63,0x6a,0x6f,0x70,0x6c,0x63,0x5b,0x54,0x56,0x5f,0x69,0x71,0x77,0x77,0x70,
0x6a,0x64,0x5f,0x5d,0x61,0x67,0x6c,0x70,0x6f,0x6c,0x67,0x61,0x5d,0x5f,0x65,0x6d,
0x73,0x77,0x77,0x73,0x6a,0x60,0x5a,0x5b,0x61,0x69,0x72,0x78,0x77,0x71,0x68,0x60,
0x5c,0x5d,0x63,0x68,0x69,0x69,0x6a,0x6c,0x72,0x7b,0x8b,0x9a,0xa5,0xa9,0xa7,0x9c,
0x8e,0x7c,0x6d,0x64,0x5d,0x58,0x53,0x4c,0x43,0x3c,0x37,0x38,0x42,0x52,0x64,0x75,
0x81,0x89,0x8f,0x94,0x98,0x9a,0x9c,0x9b,0x97,0x96,0x94,0x96,0x99,0x99,0x94,0x89,
0x7a,0x6c,0x61,0x57,0x4e,0x45,0x3c,0x34,0x30,0x38,0x4a,0x60,0x74,0x7e,0x7d,0x76,
0x6b,0x62,0x5b,0x56,0x4e,0x45,0x3b,0x34,0x33,0x43,0x57,0x6e,0x7e,0x81,0x7b,0x72,
0x61,0x54,0x4d,0x49,0x44,0x3e,0x37,0x31,0x2b,0x2a,0x2e,0x38,0x43,0x50,0x5e,0x6a,
0x72,0x74,0x70,0x68,0x60,0x5b,0x58,0x51,0x47,0x3d,0x35,0x34,0x3b,0x4c,0x61,0x77,
0x87,0x90,0x94,0x95,0x94,0x8f,0x84,0x74,0x64,0x56,0x53,0x59,0x66,0x72,0x79,0x78,
0x72,0x69,0x62,0x5f,0x5b,0x56,0x49,0x38,0x30,0x2f,0x3e,0x59,0x73,0x84,0x88,0x7f,
0x6d,0x5f,0x56,0x53,0x4f,0x45,0x38,0x2d,0x2d,0x39,0x4d,0x67,0x7a,0x84,0x7f,0x6f,
0x5e,0x55,0x57,0x61,0x6f,0x77,0x79,0x76,0x6f,0x67,0x61,0x60,0x62,0x66,0x6a,0x6b,
0x69,0x6e,0x77,0x82,0x8e,0x9a,0xa3,0xa9,0xa8,0xa2,0x9c,0x97,0x96,0x97,0x9b,0x9f,
0xa0,0x9f,0x9e,0x9c,0x9a,0x9a,0x9a,0x99,0x98,0x99,0x9c,0x9e,0x9f,0x9c,0x94,0x88,
0x78,0x67,0x5b,0x50,0x49,0x42,0x3c,0x38,0x34,0x31,0x2e,0x31,0x35,0x3b,0x3f,0x3f,
0x39,0x33,0x31,0x36,0x44,0x57,0x6a,0x78,0x7b,0x75,0x6a,0x5e,0x58,0x59,0x61,0x6b,
0x73,0x78,0x7d,0x84,0x8f,0x98,0x9d,0x9c,0x91,0x81,0x6c,0x59,0x48,0x3f,0x3b,0x3b,
0x3b,0x3f,0x48,0x58,0x67,0x77,0x84,0x8e,0x93,0x93,0x93,0x90,0x86,0x78,0x66,0x56,
0x49,0x40,0x3c,0x3b,0x3b,0x3b,0x3c,0x3c,0x3b,0x3e,0x43,0x4c,0x56,0x60,0x6d,0x7a,
0x85,0x8f,0x94,0x9a,0xa0,0xa3,0xa3,0xa0,0x98,0x8e,0x80,0x71,0x63,0x5e,0x5d,0x62,
0x6e,0x78,0x7c,0x7d,0x74,0x68,0x60,0x5e,0x60,0x64,0x6a,0x6e,0x73,0x78,0x80,0x89,
0x97,0x9f,0x9c,0x90,0x7c,0x68,0x59,0x52,0x54,0x5f,0x6c,0x79,0x84,0x8c,0x94,0x9c,
0xa3,0xa5,0xa4,0xa2,0x9d,0x9a,0x9a,0x9a,0x9a,0x9b,0x9b,0x9c,0x9d,0x9e,0x9d,0x98,
0x8e,0x7f,0x70,0x64,0x5d,0x5a,0x5f,0x65,0x6d,0x78,0x81,0x89,0x93,0x99,0x9e,0xa2,
0xa2,0x9f,0x9a,0x96,0x93,0x96,0x9a,0x9d,0x9c,0x96,0x8a,0x7a,0x6a,0x5f,0x5b,0x5f,
0x64,0x6d,0x76,0x7e,0x87,0x91,0x9c,0xa4,0xa8,0xa7,0xa2,0x9a,0x97,0x94,0x95,0x99,
0x99,0x96,0x8f,0x82,0x71,0x63,0x57,0x4f,0x46,0x3e,0x38,0x38,0x3e,0x49,0x56,0x67,
0x78,0x86,0x90,0x94,0x97,0x9a,0x9f,0xa0,0xa2,0x9f,0x9d,0x9a,0x95,0x93,0x94,0x93,
0x8e,0x83,0x76,0x68,0x5d,0x5b,0x60,0x6b,0x78,0x7f,0x7c,0x76,0x6a,0x61,0x5b,0x60,
0x66,0x6f,0x77,0x79,0x73,0x6c,0x66,0x63,0x64,0x67,0x69,0x6c,0x6d,0x6f,0x75,0x7e,
0x8a,0x96,0xa0,0xa7,0xaa,0xa8,0xa3,0x9d,0x98,0x97,0x97,0x99,0x9b,0x9f,0xa3,0xa5,
0xa0,0x9c,0x98,0x98,0x97,0x9a,0x9a,0x9c,0x9e,0x9d,0x99,0x97,0x96,0x98,0x9d,0x9f,
0x9b,0x92,0x84,0x74,0x66,0x5d,0x5a,0x5c,0x61,0x69,0x73,0x7b,0x81,0x8a,0x94,0x9d,
0xa2,0xa3,0xa0,0x9b,0x93,0x85,0x76,0x69,0x5e,0x55,0x4d,0x46,0x3f,0x3d,0x3b,0x39,
0x39,0x3b,0x3d,0x3e,0x40,0x3f,0x3c,0x3b,0x38,0x38,0x37,0x36,0x35,0x38,0x3e,0x45,
0x50,0x5f,0x6e,0x7a,0x86,0x8b,0x93,0x9c,0xa3,0xa7,0xaa,0xa5,0x9a,0x8c,0x7d,0x6e,
0x61,0x56,0x4d,0x46,0x3f,0x3b,0x38,0x3b,0x43,0x50,0x63,0x74,0x82,0x8d,0x91,0x93,
0x95,0x97,0x98,0x9b,0x9b,0x9c,0x9b,0x9a,0x9a,0x98,0x99,0x9c,0xa0,0xa2,0xa0,0x98,
0x90,0x81,0x6f,0x61,0x59,0x58,0x5c,0x62,0x68,0x71,0x7c,0x88,0x90,0x96,0x94,0x8d,
0x80,0x70,0x61,0x54,0x4a,0x42,0x3c,0x37,0x38,0x40,0x50,0x63,0x75,0x81,0x83,0x7a,
0x6b,0x5d,0x54,0x52,0x4e,0x49,0x44,0x3b,0x32,0x2f,0x32,0x39,0x42,0x46,0x43,0x3d,
0x36,0x33,0x32,0x32,0x33,0x35,0x38,0x39,0x39,0x3b,0x3b,0x3c,0x3b,0x3a,0x3b,0x3e,
0x3f,0x3e,0x3d,0x3b,0x38,0x36,0x37,0x3a,0x3c,0x3c,0x39,0x34,0x33,0x34,0x37,0x3d,
0x3f,0x3c,0x37,0x2f,0x2d,0x36,0x49,0x5f,0x6e,0x79,0x79,0x73,0x69,0x5e,0x57,0x54,
0x4f,0x47,0x3c,0x33,0x33,0x3f,0x53,0x68,0x7b,0x83,0x80,0x71,0x60,0x4f,0x46,0x44,
0x42,0x3d,0x37,0x2f,0x2c,0x2f,0x36,0x3e,0x45,0x4c,0x54,0x5e,0x69,0x78,0x86,0x93,
0x96,0x93,0x8d,0x81,0x73,0x67,0x5e,0x4e,0x42,0x37,0x32,0x35,0x3d,0x4c,0x61,0x75,
0x81,0x83,0x7b,0x6e,0x62,0x5b,0x54,0x4d,0x45,0x3c,0x33,0x33,0x3c,0x51,0x69,0x7c,
0x83,0x7d,0x6e,0x5e,0x50,0x4c,0x4b,0x49,0x44,0x3a,0x2f,0x2b,0x2f,0x3b,0x46,0x4a,
0x45,0x39,0x2f,0x2d,0x34,0x46,0x5b,0x6c,0x76,0x76,0x71,0x6c,0x65,0x5e,0x59,0x52,
0x46,0x3b,0x35,0x37,0x42,0x55,0x69,0x7a,0x83,0x81,0x76,0x65,0x56,0x4d,0x49,0x46,
0x40,0x39,0x32,0x2c,0x2b,0x30,0x39,0x43,0x4c,0x56,0x5f,0x6c,0x7b,0x88,0x93,0x98,
0x99,0x96,0x8a,0x7b,0x6b,0x5e,0x53,0x50,0x54,0x61,0x73,0x81,0x8c,0x93,0x97,0x9e,
0xa3,0xa8,0xa8,0xa4,0x9c,0x8a,0x76,0x64,0x59,0x53,0x4f,0x48,0x40,0x39,0x35,0x37,
0x43,0x57,0x6e,0x7e,0x83,0x7b,0x6e,0x61,0x58,0x57,0x62,0x6f,0x78,0x7d,0x7a,0x73,
0x68,0x61,0x5f,0x61,0x66,0x6b,0x6f,0x71,0x74,0x7b,0x87,0x94,0x9e,0xa6,0xa8,0xa5,
0x9f,0x91,0x81,0x71,0x63,0x59,0x52,0x4e,0x4a,0x46,0x40,0x39,0x32,0x31,0x34,0x3b,
0x43,0x44,0x40,0x3a,0x34,0x32,0x37,0x41,0x4f,0x5f,0x70,0x7e,0x86,0x91,0x94,0x98,
0x9f,0xa3,0xa4,0xa3,0x9a,0x8d,0x80,0x72,0x66,0x5b,0x5c,0x60,0x67,0x6f,0x78,0x82,
0x8a,0x91,0x96,0x9b,0xa0,0xa2,0xa2,0x9d,0x94,0x87,0x76,0x67,0x5c,0x58,0x57,0x5c,
0x63,0x6a,0x71,0x7a,0x85,0x91,0x9c,0xa0,0x9c,0x8f,0x7c,0x68,0x59,0x53,0x56,0x5c,
0x67,0x72,0x7d,0x88,0x93,0x9b,0x9e,0x98,0x8a,0x78,0x64,0x56,0x51,0x57,0x64,0x73,
0x79,0x78,0x73,0x69,0x60,0x5a,0x54,0x4f,0x46,0x40,0x37,0x30,0x2f,0x32,0x37,0x3e,
0x46,0x50,0x5b,0x66,0x71,0x7b,0x84,0x8d,0x93,0x96,0x91,0x84,0x73,0x61,0x53,0x52,
0x59,0x68,0x78,0x81,0x80,0x78,0x6d,0x64,0x5e,0x59,0x52,0x47,0x38,0x2e,0x2b,0x3b,
0x51,0x69,0x7f,0x86,0x7f,0x71,0x5e,0x52,0x51,0x5b,0x69,0x72,0x78,0x75,0x6c,0x63,
0x5c,0x5a,0x61,0x69,0x71,0x78,0x78,0x71,0x68,0x60,0x5c,0x60,0x66,0x6b,0x6e,0x6f,
0x70,0x73,0x7b,0x87,0x95,0x9d,0x9b,0x90,0x7f,0x6c,0x5c,0x54,0x54,0x5b,0x6a,0x79,
0x87,0x93,0x9a,0x9d,0x9e,0x9f,0xa0,0xa0,0x9f,0x9a,0x8e,0x7e,0x6c,0x5b,0x54,0x57,
0x5f,0x6e,0x76,0x79,0x76,0x6e,0x67,0x61,0x5c,0x59,0x53,0x4a,0x3e,0x34,0x2f,0x2f,
0x31,0x36,0x3e,0x47,0x54,0x61,0x6e,0x72,0x75,0x6f,0x66,0x5e,0x59,0x54,0x52,0x4a,
0x3f,0x37,0x34,0x3b,0x4c,0x64,0x7a,0x8a,0x92,0x94,0x93,0x93,0x94,0x9a,0x9e,0x9f,
0x9c,0x9b,0x9a,0x9b,0x9c,0x99,0x90,0x82,0x72,0x60,0x53,0x49,0x40,0x3b,0x39,0x39,
0x39,0x39,0x3a,0x3b,0x3c,0x40,0x49,0x5a,0x69,0x74,0x78,0x72,0x64,0x5b,0x57,0x5d,
0x68,0x72,0x78,0x78,0x71,0x66,0x5e,0x5b,0x5b,0x5a,0x57,0x4d,0x3f,0x33,0x2c,0x2c,
0x33,0x3c,0x43,0x45,0x42,0x3b,0x36,0x31,0x30,0x32,0x35,0x36,0x36,0x3c,0x45,0x51,
0x63,0x72,0x80,0x8c,0x93,0x98,0x9d,0xa0,0xa2,0xa4,0xa0,0x97,0x87,0x78,0x68,0x5c,
0x56,0x51,0x49,0x43,0x37,0x32,0x36,0x43,0x57,0x6c,0x7a,0x7c,0x75,0x69,0x60,0x5b,
0x56,0x4f,0x45,0x3a,0x33,0x34,0x44,0x5d,0x73,0x84,0x87,0x80,0x73,0x67,0x60,0x5b,
0x56,0x4a,0x3c,0x30,0x2f,0x3b,0x54,0x6e,0x7d,0x81,0x7a,0x6a,0x5f,0x56,0x52,0x4d,
0x45,0x3b,0x33,0x2d,0x2c,0x32,0x3a,0x3f,0x3f,0x3d,0x3a,0x39,0x3a,0x39,0x36,0x34,
0x32,0x33,0x39,0x44,0x52,0x63,0x71,0x7c,0x84,0x8d,0x94,0x9a,0x9c,0xa0,0xa1,0xa0,
0x9a,0x90,0x84,0x76,0x66,0x5c,0x5a,0x61,0x6e,0x78,0x7d,0x7b,0x70,0x64,0x5d,0x5c,
0x5f,0x64,0x68,0x6c,0x70,0x78,0x81,0x8d,0x96,0x97,0x93,0x89,0x7a,0x68,0x54,0x48,
0x3c,0x34,0x32,0x34,0x3b,0x4f,0x63,0x73,0x7e,0x81,0x7b,0x70,0x64,0x5b,0x5b,0x63,
0x69,0x6e,0x72,0x77,0x7d,0x87,0x93,0xa0,0xa8,0xaa,0xa7,0xa2,0x9a,0x96,0x96,0x98,
0x9a,0x98,0x91,0x86,0x76,0x67,0x59,0x4d,0x44,0x3f,0x3b,0x36,0x33,0x32,0x35,0x37,
0x38,0x38,0x3a,0x3a,0x3a,0x38,0x36,0x32,0x36,0x37,0x38,0x38,0x37,0x36,0x36,0x34,
0x34,0x37,0x3b,0x3d,0x3e,0x3c,0x38,0x38,0x39,0x39,0x3b,0x3b,0x3b,0x3b,0x39,0x37,
// Line 12
0x38,0x38,0x39,0x39,0x38,0x39,0x39,0x38,0x37,0x35,0x33,0x35,0x37,0x38,0x37,0x37,
0x37,0x39,0x39,0x39,0x37,0x38,0x37,0x38,0x38,0x37,0x38,0x39,0x38,0x36,0x35,0x34,
0x34,0x33,0x32,0x33,0x36,0x3a,0x3d,0x3c,0x39,0x36,0x35,0x36,0x39,0x3b,0x3c,0x37,
0x2f,0x2d,0x33,0x40,0x53,0x66,0x76,0x7b,0x78,0x6b,0x5e,0x59,0x5a,0x60,0x6a,0x73,
0x76,0x74,0x6a,0x60,0x59,0x57,0x5e,0x67,0x6d,0x70,0x73,0x71,0x6a,0x60,0x5a,0x59,
0x5e,0x67,0x6f,0x74,0x73,0x6d,0x63,0x5b,0x55,0x57,0x5d,0x66,0x6c,0x71,0x71,0x6c,
0x63,0x5e,0x5a,0x59,0x60,0x6a,0x72,0x76,0x74,0x6d,0x65,0x5c,0x57,0x59,0x5f,0x67,
0x6d,0x6f,0x6e,0x67,0x61,0x5b,0x59,0x5d,0x63,0x6c,0x74,0x76,0x73,0x6e,0x67,0x63,
0x5f,0x5e,0x61,0x66,0x6a,0x6c,0x6d,0x6f,0x76,0x81,0x8f,0x9a,0xa3,0xa8,0xa8,0x9f,
0x91,0x7e,0x6f,0x62,0x59,0x53,0x4e,0x4a,0x42,0x39,0x34,0x34,0x3d,0x4f,0x65,0x77,
0x84,0x8b,0x8e,0x92,0x96,0x9b,0x9e,0x9e,0x9a,0x97,0x95,0x95,0x94,0x95,0x8f,0x85,
0x79,0x6b,0x5f,0x55,0x4d,0x42,0x38,0x30,0x2f,0x36,0x47,0x5c,0x6f,0x7b,0x7b,0x73,
0x68,0x5e,0x57,0x53,0x4d,0x44,0x3a,0x33,0x32,0x3f,0x55,0x6e,0x7d,0x85,0x7e,0x70,
0x61,0x53,0x4b,0x47,0x44,0x40,0x3b,0x34,0x2f,0x30,0x34,0x3c,0x48,0x56,0x64,0x6e,
0x72,0x72,0x6d,0x67,0x60,0x59,0x54,0x4e,0x44,0x3a,0x33,0x31,0x3a,0x4b,0x60,0x76,
0x86,0x91,0x95,0x97,0x95,0x91,0x87,0x78,0x65,0x56,0x53,0x5b,0x6a,0x78,0x7d,0x7b,
0x70,0x67,0x61,0x5e,0x5c,0x55,0x48,0x37,0x2b,0x2b,0x3b,0x55,0x70,0x81,0x85,0x7c,
0x6d,0x61,0x5b,0x55,0x4e,0x44,0x39,0x34,0x37,0x44,0x58,0x6f,0x81,0x85,0x78,0x6d,
0x5e,0x57,0x54,0x4e,0x44,0x3b,0x33,0x31,0x3c,0x53,0x6b,0x7e,0x87,0x7e,0x6c,0x5a,
0x4f,0x51,0x5c,0x68,0x71,0x77,0x76,0x70,0x69,0x65,0x65,0x68,0x6a,0x6e,0x70,0x72,
0x75,0x7b,0x87,0x94,0x9f,0xa7,0xab,0xa9,0xa3,0x9c,0x95,0x92,0x92,0x94,0x93,0x8d,
0x80,0x6f,0x5d,0x4f,0x46,0x42,0x40,0x3c,0x39,0x34,0x30,0x30,0x35,0x3c,0x43,0x40,
0x39,0x35,0x35,0x3b,0x48,0x5a,0x6d,0x7a,0x7d,0x78,0x6d,0x62,0x5c,0x5c,0x63,0x6a,
0x6f,0x74,0x7a,0x81,0x8d,0x97,0x9f,0xa6,0xaa,0xa7,0xa0,0x96,0x8b,0x7f,0x70,0x61,
0x54,0x54,0x5b,0x67,0x74,0x79,0x78,0x74,0x6c,0x63,0x5e,0x60,0x65,0x6a,0x6d,0x72,
0x76,0x7c,0x85,0x91,0x9e,0xa7,0xab,0xa9,0xa2,0x97,0x8a,0x79,0x6a,0x60,0x5b,0x5c,
0x5f,0x66,0x6f,0x74,0x7d,0x84,0x8e,0x99,0x9d,0x9b,0x91,0x7e,0x69,0x5b,0x53,0x54,
0x5d,0x6a,0x77,0x83,0x8a,0x91,0x94,0x9d,0xa0,0xa3,0xa4,0xa0,0x95,0x89,0x79,0x6b,
0x63,0x5c,0x54,0x4f,0x48,0x3e,0x38,0x39,0x44,0x55,0x67,0x76,0x81,0x8a,0x91,0x94,
0x97,0x9a,0x9f,0xa1,0x9f,0x9c,0x9b,0x9b,0x9d,0x9d,0x99,0x8d,0x7c,0x6c,0x5e,0x54,
0x4d,0x45,0x3d,0x37,0x34,0x37,0x45,0x5a,0x71,0x80,0x83,0x7b,0x6d,0x5f,0x57,0x57,
0x5b,0x60,0x67,0x70,0x76,0x7e,0x86,0x90,0x9a,0xa4,0xaa,0xa8,0xa1,0x94,0x84,0x75,
0x67,0x5e,0x59,0x55,0x4e,0x44,0x3a,0x33,0x33,0x40,0x53,0x68,0x78,0x7d,0x78,0x69,
0x5b,0x54,0x57,0x5f,0x6a,0x72,0x7b,0x80,0x84,0x8e,0x98,0x9d,0x9a,0x8e,0x7b,0x67,
0x56,0x4f,0x4f,0x5b,0x67,0x74,0x83,0x91,0x99,0xa0,0x9d,0x94,0x87,0x76,0x65,0x57,
0x49,0x3f,0x38,0x34,0x33,0x39,0x46,0x57,0x68,0x7a,0x85,0x8d,0x92,0x95,0x9a,0xa1,
0xa3,0xa2,0x9f,0x9b,0x98,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9c,0x9a,0x94,0x87,0x7b,
0x67,0x59,0x53,0x4e,0x48,0x41,0x39,0x35,0x39,0x46,0x5b,0x71,0x81,0x84,0x79,0x67,
0x59,0x55,0x59,0x60,0x67,0x6d,0x71,0x77,0x80,0x8b,0x95,0x9c,0x9a,0x8d,0x79,0x65,
0x56,0x4d,0x48,0x42,0x3e,0x3d,0x3f,0x47,0x55,0x65,0x73,0x80,0x87,0x8a,0x8e,0x94,
0x9b,0xa0,0xa2,0xa2,0x9f,0x9c,0x9a,0x9a,0x99,0x94,0x8b,0x7f,0x6f,0x60,0x52,0x46,
0x3f,0x3e,0x3d,0x3b,0x38,0x37,0x37,0x38,0x38,0x3d,0x44,0x57,0x63,0x6d,0x7b,0x87,
0x92,0x9a,0x9a,0x93,0x89,0x7a,0x69,0x57,0x4f,0x4f,0x57,0x65,0x74,0x82,0x8e,0x95,
0x98,0x9e,0xa2,0xa3,0xa4,0x9f,0x96,0x8a,0x79,0x6b,0x5f,0x57,0x56,0x5b,0x61,0x67,
0x6e,0x77,0x80,0x89,0x92,0x9a,0x9f,0xa1,0xa0,0x9b,0x99,0x97,0x97,0x97,0x98,0x99,
0x9a,0x9b,0x9d,0x9e,0x9a,0x8f,0x7e,0x6d,0x5b,0x53,0x55,0x5e,0x67,0x72,0x77,0x74,
0x6b,0x64,0x5d,0x5a,0x56,0x4f,0x44,0x3b,0x32,0x2a,0x27,0x29,0x2e,0x38,0x42,0x4f,
0x5e,0x6a,0x71,0x71,0x6e,0x68,0x63,0x5f,0x5a,0x51,0x47,0x3b,0x32,0x31,0x3b,0x4d,
0x63,0x7a,0x8c,0x96,0x9a,0x9a,0x95,0x8b,0x7f,0x70,0x60,0x51,0x44,0x3c,0x38,0x36,
0x36,0x35,0x35,0x39,0x3c,0x3d,0x3c,0x39,0x35,0x32,0x33,0x35,0x35,0x33,0x33,0x33,
0x39,0x45,0x57,0x6c,0x7b,0x7e,0x76,0x68,0x5b,0x58,0x5a,0x60,0x64,0x6b,0x70,0x75,
0x7d,0x89,0x94,0x9e,0x9b,0x8f,0x7d,0x67,0x54,0x44,0x3b,0x35,0x34,0x34,0x35,0x35,
0x31,0x2f,0x30,0x37,0x42,0x51,0x63,0x6f,0x73,0x70,0x67,0x5d,0x59,0x57,0x5c,0x64,
0x6c,0x71,0x76,0x7b,0x85,0x92,0x9d,0xa6,0xa8,0xa7,0xa1,0x9a,0x96,0x94,0x97,0x9c,
0xa0,0xa1,0xa6,0xa7,0xa5,0xa1,0x9c,0x9a,0x9a,0x9a,0x99,0x91,0x83,0x6f,0x5e,0x54,
0x52,0x5b,0x6a,0x76,0x7d,0x7b,0x72,0x67,0x5e,0x59,0x55,0x4f,0x44,0x38,0x2d,0x2b,
0x34,0x47,0x5e,0x74,0x84,0x8d,0x90,0x91,0x95,0x9a,0x9f,0xa1,0xa1,0xa0,0x9f,0x9e,
0x9d,0x9d,0x9c,0x9b,0x9a,0x99,0x96,0x8f,0x85,0x77,0x67,0x59,0x4e,0x46,0x42,0x3e,
0x3b,0x38,0x37,0x36,0x32,0x38,0x39,0x3d,0x43,0x4c,0x58,0x69,0x76,0x81,0x8c,0x93,
0x99,0x9c,0x9f,0x9e,0xa0,0x9e,0x9b,0x98,0x97,0x95,0x97,0x9a,0x9e,0xa1,0xa2,0x9c,
0x90,0x83,0x76,0x68,0x5e,0x5a,0x5a,0x61,0x6a,0x73,0x7a,0x81,0x8a,0x92,0x99,0x9d,
0xa1,0xa4,0xa1,0x98,0x8b,0x7b,0x6d,0x60,0x58,0x57,0x5b,0x63,0x6a,0x6f,0x78,0x80,
0x88,0x92,0x9a,0xa1,0xa8,0xa4,0x9e,0x94,0x87,0x79,0x6b,0x5e,0x54,0x4f,0x4b,0x45,
0x3c,0x34,0x30,0x2f,0x30,0x34,0x39,0x3e,0x3e,0x3a,0x37,0x34,0x35,0x37,0x39,0x39,
0x3b,0x3b,0x39,0x38,0x37,0x36,0x37,0x39,0x39,0x3a,0x3c,0x3b,0x38,0x36,0x34,0x35,
0x39,0x43,0x4f,0x5f,0x71,0x80,0x8c,0x95,0x99,0x98,0x92,0x87,0x78,0x65,0x53,0x46,
0x3f,0x3c,0x3b,0x38,0x39,0x38,0x35,0x34,0x36,0x3a,0x4a,0x57,0x63,0x6c,0x70,0x6d,
0x67,0x5c,0x54,0x50,0x4b,0x47,0x41,0x38,0x2f,0x2c,0x2d,0x33,0x3a,0x46,0x51,0x5a,
0x62,0x6b,0x77,0x85,0x90,0x96,0x97,0x91,0x85,0x74,0x63,0x55,0x53,0x59,0x65,0x70,
0x7a,0x7c,0x76,0x6c,0x61,0x57,0x54,0x4f,0x47,0x3d,0x34,0x2d,0x29,0x2f,0x38,0x42,
0x46,0x44,0x3a,0x31,0x2b,0x2f,0x3f,0x55,0x68,0x78,0x7d,0x77,0x6c,0x5f,0x5a,0x5d,
0x67,0x74,0x7d,0x7f,0x79,0x6d,0x61,0x5b,0x5d,0x5d,0x57,0x4a,0x3b,0x2d,0x2c,0x38,
0x50,0x6a,0x7e,0x83,0x7a,0x6a,0x5c,0x53,0x4b,0x49,0x44,0x3d,0x37,0x31,0x2e,0x30,
0x35,0x3a,0x3f,0x46,0x4e,0x5b,0x68,0x76,0x81,0x89,0x8f,0x96,0x9c,0xa2,0xa4,0xa2,
0x98,0x89,0x78,0x68,0x5b,0x54,0x4e,0x48,0x3f,0x37,0x32,0x34,0x3f,0x4f,0x63,0x76,
0x84,0x8d,0x95,0x98,0x9a,0x9f,0xa2,0xa1,0xa0,0x9d,0x99,0x95,0x92,0x92,0x95,0x98,
0x9b,0x9a,0x9a,0x93,0x87,0x7b,0x6a,0x5b,0x51,0x4b,0x47,0x42,0x3d,0x38,0x34,0x31,
0x31,0x36,0x3d,0x40,0x3b,0x34,0x2d,0x2b,0x33,0x40,0x54,0x69,0x77,0x7b,0x73,0x66,
0x5b,0x56,0x5b,0x67,0x71,0x7a,0x7b,0x74,0x6d,0x64,0x5f,0x5e,0x5d,0x54,0x49,0x39,
0x2b,0x27,0x30,0x45,0x60,0x79,0x8a,0x95,0x99,0x97,0x92,0x89,0x7e,0x71,0x64,0x54,
0x47,0x3d,0x37,0x35,0x35,0x36,0x37,0x36,0x34,0x35,0x3b,0x46,0x55,0x65,0x72,0x78,
0x74,0x6a,0x5e,0x56,0x59,0x62,0x6d,0x74,0x74,0x6a,0x60,0x57,0x55,0x59,0x5d,0x5b,
0x4c,0x3f,0x31,0x2f,0x3e,0x57,0x6f,0x80,0x82,0x78,0x66,0x55,0x4d,0x4a,0x46,0x3d,
0x33,0x2b,0x2d,0x39,0x51,0x6b,0x7f,0x87,0x80,0x70,0x61,0x59,0x59,0x60,0x68,0x6d,
0x70,0x75,0x7c,0x87,0x92,0x97,0x95,0x87,0x74,0x61,0x51,0x42,0x39,0x35,0x33,0x32,
0x33,0x37,0x3d,0x3f,0x3d,0x39,0x36,0x37,0x38,0x38,0x37,0x34,0x2f,0x2d,0x2d,0x35,
0x46,0x59,0x6a,0x75,0x76,0x70,0x68,0x5f,0x59,0x54,0x50,0x47,0x3b,0x31,0x30,0x3c,
0x51,0x67,0x7a,0x81,0x7e,0x71,0x61,0x56,0x53,0x58,0x62,0x68,0x6f,0x77,0x81,0x89,
0x95,0x9f,0xa5,0xa7,0xa4,0x9e,0x9a,0x97,0x94,0x95,0x97,0x97,0x99,0x9d,0x9d,0x9c,
0x96,0x8d,0x7e,0x6c,0x5b,0x52,0x53,0x5c,0x68,0x72,0x76,0x74,0x6e,0x66,0x5e,0x5a,
0x53,0x4b,0x44,0x3b,0x34,0x2f,0x2d,0x2d,0x32,0x3c,0x46,0x51,0x5e,0x6b,0x73,0x76,
0x71,0x66,0x5c,0x56,0x57,0x5c,0x63,0x69,0x70,0x77,0x7e,0x89,0x92,0x97,0x97,0x8e,
0x7d,0x67,0x56,0x47,0x3d,0x37,0x34,0x35,0x3b,0x45,0x54,0x65,0x74,0x7e,0x87,0x8d,
0x92,0x92,0x8d,0x85,0x78,0x67,0x56,0x48,0x40,0x3a,0x37,0x35,0x35,0x36,0x34,0x37,
0x38,0x37,0x38,0x36,0x32,0x33,0x32,0x33,0x36,0x37,0x36,0x35,0x35,0x34,0x34,0x35,
0x37,0x38,0x39,0x39,0x38,0x3a,0x3c,0x3c,0x3a,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3b,
// Line 13
0x36,0x37,0x38,0x39,0x3a,0x39,0x39,0x38,0x38,0x37,0x36,0x36,0x36,0x34,0x34,0x36,
0x36,0x35,0x34,0x34,0x34,0x36,0x36,0x37,0x37,0x38,0x38,0x37,0x36,0x37,0x37,0x37,
0x37,0x36,0x38,0x38,0x38,0x3a,0x38,0x37,0x37,0x38,0x37,0x37,0x38,0x38,0x38,0x36,
0x33,0x33,0x3d,0x45,0x57,0x69,0x77,0x7c,0x78,0x6d,0x61,0x5a,0x58,0x5e,0x68,0x74,
0x78,0x73,0x6c,0x62,0x5c,0x5a,0x5e,0x65,0x6f,0x73,0x72,0x6d,0x65,0x5d,0x59,0x5a,
0x60,0x69,0x72,0x76,0x75,0x70,0x68,0x5f,0x59,0x5a,0x5f,0x68,0x6e,0x71,0x71,0x6e,
0x66,0x61,0x5f,0x62,0x65,0x69,0x70,0x75,0x75,0x6f,0x65,0x5e,0x59,0x59,0x61,0x6a,
0x72,0x76,0x73,0x6a,0x62,0x5d,0x5b,0x5c,0x63,0x6d,0x76,0x79,0x76,0x73,0x6f,0x68,
0x62,0x61,0x63,0x68,0x6b,0x6c,0x6d,0x6f,0x75,0x7e,0x88,0x98,0xa2,0xa8,0xa8,0xa1,
0x90,0x81,0x70,0x62,0x5c,0x57,0x54,0x4d,0x44,0x3a,0x35,0x35,0x3e,0x4e,0x62,0x74,
0x80,0x89,0x8e,0x93,0x99,0x9c,0x9f,0x9f,0x9d,0x9b,0x9b,0x9c,0x9a,0x99,0x94,0x89,
0x79,0x68,0x5c,0x55,0x4f,0x47,0x3d,0x38,0x35,0x3d,0x4e,0x63,0x77,0x80,0x7f,0x73,
0x65,0x5a,0x54,0x50,0x4b,0x42,0x38,0x30,0x31,0x3f,0x56,0x6f,0x80,0x87,0x81,0x73,
0x61,0x54,0x4d,0x4a,0x46,0x40,0x3a,0x32,0x2d,0x2b,0x2f,0x38,0x46,0x57,0x64,0x6f,
0x76,0x76,0x71,0x67,0x5d,0x57,0x54,0x50,0x46,0x3b,0x34,0x34,0x3d,0x4e,0x64,0x7a,
0x8b,0x94,0x96,0x96,0x93,0x8e,0x84,0x73,0x61,0x56,0x55,0x5e,0x6b,0x77,0x7b,0x78,
0x70,0x67,0x61,0x61,0x5f,0x55,0x47,0x36,0x2a,0x2b,0x3c,0x55,0x6e,0x7d,0x80,0x73,
0x67,0x59,0x51,0x50,0x4e,0x47,0x3d,0x33,0x31,0x3d,0x54,0x6c,0x7d,0x83,0x7c,0x6d,
0x5e,0x54,0x53,0x5c,0x69,0x74,0x79,0x75,0x6c,0x64,0x5f,0x5e,0x61,0x68,0x71,0x76,
0x76,0x70,0x69,0x60,0x5b,0x5c,0x62,0x6b,0x73,0x77,0x75,0x6c,0x66,0x5e,0x5c,0x5f,
0x5f,0x5a,0x50,0x3e,0x2e,0x27,0x28,0x2f,0x38,0x3f,0x43,0x42,0x3c,0x35,0x31,0x31,
0x35,0x38,0x3a,0x39,0x38,0x38,0x37,0x37,0x3a,0x3a,0x38,0x35,0x32,0x33,0x3a,0x4a,
0x5c,0x6f,0x7c,0x80,0x7a,0x70,0x64,0x5d,0x5c,0x5f,0x65,0x6d,0x74,0x79,0x7b,0x85,
0x8e,0x9b,0xa8,0xae,0xaa,0xa3,0x94,0x84,0x77,0x6c,0x62,0x5b,0x52,0x49,0x40,0x38,
0x35,0x38,0x43,0x52,0x64,0x74,0x82,0x8e,0x97,0x9a,0x99,0x93,0x86,0x77,0x68,0x5b,
0x55,0x58,0x60,0x6b,0x75,0x7f,0x88,0x92,0x99,0x9a,0x94,0x88,0x77,0x64,0x54,0x47,
0x41,0x40,0x40,0x3e,0x3d,0x3a,0x3a,0x39,0x3b,0x3d,0x44,0x50,0x5e,0x6c,0x7b,0x87,
0x8f,0x97,0x9b,0x9e,0xa2,0xa4,0xa1,0x9b,0x8d,0x7b,0x6b,0x60,0x5a,0x5d,0x62,0x68,
0x6d,0x74,0x7b,0x82,0x8e,0x98,0x9c,0x98,0x8a,0x77,0x63,0x56,0x54,0x58,0x63,0x6d,
0x74,0x75,0x6f,0x62,0x5a,0x56,0x53,0x4f,0x47,0x3f,0x36,0x30,0x2d,0x33,0x3c,0x44,
0x48,0x46,0x3d,0x35,0x32,0x36,0x40,0x50,0x5e,0x6d,0x7a,0x86,0x8e,0x96,0x9c,0xa2,
0xa6,0xa7,0xa6,0x9c,0x8c,0x79,0x69,0x5f,0x57,0x51,0x4f,0x48,0x3e,0x39,0x3b,0x47,
0x5a,0x70,0x7e,0x80,0x76,0x67,0x59,0x54,0x59,0x65,0x74,0x7a,0x78,0x70,0x67,0x61,
0x5e,0x5c,0x59,0x52,0x47,0x3b,0x35,0x36,0x40,0x51,0x68,0x7b,0x8a,0x94,0x9a,0x9b,
0x99,0x8f,0x82,0x75,0x68,0x5f,0x5a,0x5d,0x61,0x6a,0x75,0x7e,0x86,0x8f,0x96,0x9c,
0xa3,0xa4,0xa1,0x9c,0x96,0x92,0x94,0x96,0x9a,0x99,0x94,0x85,0x73,0x61,0x55,0x52,
0x58,0x63,0x6d,0x73,0x73,0x6d,0x64,0x5d,0x5c,0x60,0x65,0x6c,0x71,0x75,0x7a,0x84,
0x90,0x9d,0xa2,0xa1,0x94,0x82,0x6f,0x5d,0x53,0x54,0x5f,0x6c,0x78,0x80,0x89,0x91,
0x97,0x9b,0x9d,0x9d,0x9d,0x9b,0x95,0x88,0x7a,0x6e,0x63,0x5a,0x57,0x5c,0x65,0x73,
0x7a,0x79,0x72,0x67,0x5f,0x5e,0x62,0x67,0x6c,0x70,0x75,0x79,0x7f,0x87,0x94,0xa0,
0xa8,0xa7,0xa0,0x99,0x96,0x95,0x97,0x99,0x9a,0x99,0x92,0x84,0x78,0x66,0x57,0x4d,
0x43,0x38,0x32,0x30,0x37,0x47,0x5a,0x6b,0x76,0x7a,0x73,0x67,0x5a,0x52,0x4e,0x4d,
0x49,0x43,0x3b,0x33,0x2e,0x31,0x38,0x3f,0x48,0x4f,0x57,0x60,0x6c,0x7a,0x8c,0x98,
0x9e,0x9c,0x91,0x84,0x76,0x6a,0x5d,0x50,0x43,0x36,0x2f,0x2f,0x39,0x4a,0x5f,0x71,
0x7a,0x7b,0x73,0x68,0x5d,0x57,0x52,0x4c,0x45,0x3d,0x34,0x36,0x3d,0x4e,0x68,0x7b,
0x83,0x7f,0x70,0x60,0x54,0x52,0x59,0x63,0x6c,0x71,0x79,0x84,0x8e,0x98,0xa1,0xa7,
0xa8,0xa6,0x9f,0x96,0x8a,0x7a,0x69,0x5b,0x54,0x57,0x61,0x6f,0x79,0x7c,0x77,0x6d,
0x61,0x59,0x56,0x54,0x52,0x4a,0x3d,0x33,0x2b,0x28,0x2f,0x3a,0x44,0x48,0x44,0x3b,
0x32,0x2f,0x34,0x42,0x54,0x68,0x77,0x7e,0x78,0x6c,0x5f,0x56,0x56,0x60,0x6d,0x77,
0x7a,0x76,0x6b,0x61,0x5c,0x5e,0x64,0x69,0x6b,0x6b,0x6c,0x6f,0x77,0x86,0x95,0xa0,
0xa6,0xa6,0xa3,0x9d,0x99,0x94,0x93,0x96,0x98,0x9b,0x9f,0xa3,0xa5,0xa4,0x9c,0x8d,
0x7c,0x6f,0x63,0x5d,0x5a,0x5c,0x60,0x68,0x6f,0x7a,0x88,0x95,0x9c,0x9b,0x91,0x81,
0x71,0x61,0x54,0x4c,0x43,0x3b,0x33,0x31,0x38,0x48,0x5d,0x72,0x81,0x86,0x7c,0x69,
0x5c,0x57,0x5a,0x68,0x74,0x7a,0x7b,0x72,0x65,0x5c,0x57,0x57,0x56,0x52,0x4a,0x40,
0x38,0x32,0x2f,0x31,0x37,0x3e,0x49,0x54,0x5e,0x68,0x6f,0x78,0x80,0x89,0x92,0x98,
0x97,0x8d,0x7a,0x65,0x54,0x4e,0x54,0x64,0x75,0x83,0x86,0x7e,0x71,0x65,0x60,0x5f,
0x61,0x65,0x68,0x6d,0x72,0x79,0x86,0x94,0x9f,0xa6,0xa7,0xa4,0xa0,0x97,0x8b,0x7b,
0x69,0x5b,0x57,0x59,0x62,0x6d,0x77,0x7a,0x77,0x6f,0x68,0x64,0x61,0x5c,0x52,0x47,
0x3a,0x31,0x32,0x3d,0x4e,0x65,0x79,0x87,0x8e,0x92,0x93,0x92,0x8d,0x82,0x72,0x62,
0x56,0x52,0x5a,0x68,0x75,0x7d,0x7e,0x77,0x6c,0x64,0x61,0x61,0x66,0x68,0x69,0x6d,
0x70,0x77,0x83,0x90,0x9b,0xa4,0xa8,0xa6,0x9d,0x90,0x82,0x74,0x68,0x5f,0x59,0x55,
0x4f,0x47,0x42,0x3d,0x3f,0x47,0x56,0x66,0x77,0x86,0x90,0x94,0x94,0x91,0x8c,0x82,
0x73,0x63,0x57,0x47,0x3d,0x3a,0x38,0x38,0x37,0x35,0x33,0x37,0x3c,0x43,0x4d,0x57,
0x60,0x6c,0x77,0x82,0x8b,0x93,0x9b,0x9f,0xa0,0x9d,0x9c,0x9b,0x96,0x92,0x93,0x95,
0x99,0x9b,0x9e,0x9e,0x9b,0x94,0x8a,0x7d,0x71,0x65,0x59,0x4f,0x46,0x3e,0x3a,0x35,
0x36,0x3e,0x4e,0x62,0x74,0x84,0x90,0x96,0x97,0x93,0x89,0x80,0x6f,0x5d,0x50,0x46,
0x3e,0x3b,0x38,0x37,0x3a,0x3c,0x3d,0x3e,0x40,0x3f,0x3d,0x3a,0x36,0x34,0x35,0x38,
0x3c,0x3e,0x3c,0x38,0x35,0x33,0x35,0x38,0x3a,0x3a,0x36,0x32,0x31,0x38,0x48,0x5c,
0x6e,0x7a,0x79,0x6f,0x63,0x5a,0x57,0x57,0x54,0x4d,0x43,0x3a,0x32,0x2d,0x30,0x38,
0x41,0x46,0x42,0x3a,0x31,0x2e,0x32,0x3f,0x4e,0x5e,0x6f,0x7f,0x8b,0x94,0x9b,0x9b,
0x93,0x84,0x74,0x66,0x59,0x50,0x47,0x40,0x38,0x32,0x35,0x42,0x57,0x6d,0x7c,0x7e,
0x77,0x66,0x57,0x50,0x54,0x5f,0x6d,0x78,0x7a,0x72,0x6c,0x64,0x5d,0x5c,0x58,0x53,
0x4a,0x3d,0x31,0x2b,0x2b,0x2f,0x34,0x3a,0x44,0x51,0x61,0x70,0x79,0x7c,0x77,0x6d,
0x61,0x58,0x58,0x61,0x6c,0x74,0x77,0x72,0x69,0x60,0x5a,0x5d,0x64,0x70,0x79,0x7b,
0x79,0x71,0x68,0x62,0x5e,0x5d,0x5b,0x54,0x48,0x3b,0x32,0x2c,0x2a,0x2b,0x30,0x3a,
0x46,0x55,0x63,0x6f,0x77,0x78,0x74,0x68,0x5d,0x59,0x5d,0x64,0x6b,0x70,0x74,0x77,
0x7d,0x87,0x95,0x9f,0x9f,0x95,0x84,0x6a,0x54,0x4d,0x50,0x5d,0x6c,0x77,0x7f,0x86,
0x8d,0x95,0x9b,0xa0,0x9f,0x9c,0x98,0x94,0x91,0x93,0x97,0x99,0x96,0x8b,0x7b,0x6c,
0x5d,0x50,0x48,0x45,0x41,0x3c,0x35,0x30,0x30,0x34,0x3b,0x40,0x42,0x40,0x39,0x33,
0x30,0x36,0x46,0x5a,0x6d,0x7a,0x7e,0x77,0x6a,0x61,0x5d,0x60,0x64,0x6a,0x6f,0x75,
0x7b,0x82,0x8e,0x97,0x9a,0x94,0x86,0x73,0x60,0x50,0x45,0x3c,0x33,0x2d,0x2f,0x37,
0x47,0x5c,0x6f,0x79,0x7b,0x76,0x6b,0x5e,0x56,0x50,0x4e,0x4b,0x44,0x3a,0x30,0x2d,
0x2d,0x32,0x3d,0x47,0x4e,0x5b,0x63,0x6f,0x7b,0x86,0x8e,0x96,0x95,0x8e,0x84,0x76,
0x65,0x55,0x46,0x3a,0x36,0x37,0x3a,0x3b,0x38,0x35,0x33,0x36,0x3f,0x4d,0x5f,0x6e,
0x75,0x75,0x71,0x69,0x60,0x59,0x53,0x4d,0x44,0x3b,0x34,0x33,0x3b,0x4b,0x61,0x76,
0x85,0x92,0x95,0x94,0x95,0x99,0x9c,0x9d,0x9b,0x9a,0x99,0x98,0x98,0x98,0x99,0x99,
0x9a,0x9c,0x9b,0x98,0x90,0x83,0x73,0x63,0x57,0x51,0x54,0x5e,0x69,0x74,0x7e,0x87,
0x8e,0x96,0x9c,0xa0,0xa2,0xa0,0x9d,0x9b,0x98,0x96,0x97,0x98,0x9b,0x9f,0xa4,0xa5,
0xa2,0x98,0x89,0x75,0x65,0x5c,0x57,0x53,0x4c,0x40,0x3a,0x34,0x37,0x46,0x5b,0x71,
0x7f,0x7f,0x75,0x65,0x59,0x56,0x58,0x5e,0x63,0x69,0x71,0x79,0x82,0x8d,0x97,0x9c,
0x9a,0x8f,0x7c,0x68,0x54,0x44,0x3c,0x37,0x36,0x35,0x35,0x35,0x33,0x32,0x33,0x39,
0x4a,0x5a,0x69,0x74,0x76,0x73,0x6b,0x61,0x58,0x54,0x4e,0x47,0x3d,0x36,0x35,0x3d,
0x4f,0x65,0x7a,0x8b,0x93,0x96,0x99,0x9b,0x9e,0xa1,0xa2,0x9e,0x9b,0x98,0x98,0x98,
0x97,0x91,0x86,0x77,0x67,0x58,0x4f,0x49,0x43,0x3e,0x38,0x34,0x33,0x33,0x34,0x38,
0x3c,0x3c,0x38,0x37,0x35,0x35,0x35,0x33,0x33,0x33,0x34,0x36,0x38,0x37,0x36,0x36,
0x34,0x34,0x36,0x3a,0x3c,0x3b,0x39,0x37,0x36,0x37,0x39,0x3a,0x39,0x3a,0x3a,0x3a,
// Line 14
0x36,0x34,0x33,0x34,0x35,0x37,0x38,0x38,0x37,0x36,0x37,0x37,0x3a,0x3b,0x3b,0x3b,
0x39,0x37,0x36,0x37,0x37,0x37,0x38,0x38,0x38,0x39,0x38,0x37,0x37,0x37,0x37,0x37,
0x35,0x34,0x34,0x33,0x32,0x33,0x36,0x37,0x36,0x35,0x33,0x32,0x34,0x37,0x3a,0x39,
0x3c,0x40,0x45,0x4d,0x55,0x5c,0x69,0x71,0x7a,0x81,0x87,0x8b,0x90,0x92,0x92,0x93,
0x95,0x95,0x96,0x97,0x96,0x96,0x98,0x9b,0x9c,0x9b,0x98,0x93,0x8e,0x86,0x7d,0x73,
0x6a,0x60,0x58,0x52,0x4d,0x45,0x40,0x3b,0x38,0x37,0x36,0x32,0x33,0x32,0x30,0x31,
0x32,0x32,0x33,0x34,0x34,0x35,0x36,0x38,0x3b,0x41,0x45,0x4b,0x52,0x5c,0x64,0x6f,
0x78,0x80,0x87,0x8a,0x8d,0x91,0x92,0x91,0x92,0x93,0x95,0x95,0x94,0x93,0x96,0x97,
0x98,0x97,0x96,0x94,0x8f,0x8a,0x82,0x79,0x6f,0x64,0x5a,0x54,0x4d,0x46,0x3e,0x3a,
0x37,0x35,0x36,0x37,0x37,0x3b,0x3b,0x38,0x37,0x38,0x37,0x37,0x35,0x35,0x37,0x38,
0x39,0x39,0x3d,0x41,0x49,0x53,0x5e,0x69,0x75,0x7e,0x84,0x8a,0x8f,0x94,0x98,0x9a,
0x98,0x97,0x94,0x92,0x91,0x93,0x94,0x96,0x96,0x96,0x94,0x96,0x91,0x8d,0x8a,0x83,
0x79,0x70,0x67,0x5f,0x56,0x4e,0x48,0x43,0x3e,0x3b,0x39,0x3b,0x3b,0x3b,0x39,0x37,
0x37,0x3b,0x3c,0x3c,0x3b,0x3a,0x39,0x39,0x38,0x3b,0x40,0x44,0x47,0x4d,0x55,0x5f,
0x68,0x73,0x7d,0x85,0x8d,0x92,0x94,0x98,0x98,0x98,0x98,0x96,0x96,0x94,0x93,0x93,
0x93,0x93,0x93,0x94,0x96,0x94,0x91,0x8c,0x85,0x7b,0x72,0x67,0x5c,0x55,0x4f,0x48,
0x41,0x3b,0x37,0x35,0x37,0x3a,0x3b,0x3d,0x3c,0x38,0x38,0x38,0x37,0x39,0x38,0x37,
0x36,0x36,0x36,0x39,0x3e,0x43,0x4c,0x56,0x5f,0x6a,0x74,0x7c,0x83,0x8c,0x90,0x92,
0x94,0x95,0x96,0x98,0x98,0x97,0x96,0x94,0x93,0x93,0x96,0x98,0x98,0x9a,0x96,0x91,
0x8c,0x85,0x7f,0x78,0x6e,0x62,0x59,0x51,0x4a,0x41,0x3d,0x39,0x37,0x38,0x39,0x38,
0x37,0x36,0x36,0x37,0x37,0x37,0x37,0x37,0x36,0x37,0x37,0x3b,0x3e,0x42,0x49,0x51,
0x5a,0x63,0x6f,0x79,0x82,0x89,0x90,0x95,0x98,0x9b,0x9c,0x9a,0x98,0x96,0x94,0x92,
0x93,0x92,0x94,0x95,0x95,0x92,0x96,0x95,0x91,0x8c,0x86,0x7c,0x71,0x65,0x5b,0x55,
0x4f,0x4a,0x42,0x3c,0x38,0x37,0x39,0x3c,0x3e,0x3e,0x3c,0x39,0x39,0x3a,0x3c,0x40,
0x3e,0x3b,0x39,0x39,0x3b,0x3e,0x42,0x46,0x4e,0x56,0x5e,0x66,0x73,0x7e,0x86,0x8e,
0x93,0x96,0x98,0x97,0x98,0x9b,0x9b,0x9a,0x97,0x95,0x93,0x94,0x94,0x95,0x96,0x97,
0x94,0x8e,0x88,0x81,0x7b,0x73,0x6a,0x60,0x58,0x51,0x4b,0x46,0x41,0x3b,0x39,0x39,
0x3a,0x39,0x3b,0x38,0x37,0x38,0x38,0x38,0x3b,0x3c,0x3c,0x3f,0x40,0x3f,0x3e,0x3b,
0x39,0x3a,0x3b,0x3b,0x3a,0x3b,0x3b,0x3b,0x3a,0x3a,0x3b,0x3b,0x3b,0x3a,0x3a,0x3b,
0x39,0x39,0x38,0x37,0x37,0x38,0x39,0x38,0x37,0x37,0x38,0x39,0x39,0x3b,0x3d,0x3d,
0x3b,0x39,0x39,0x39,0x38,0x37,0x36,0x37,0x38,0x39,0x39,0x3a,0x38,0x37,0x38,0x39,
0x39,0x3b,0x3b,0x3a,0x3a,0x3a,0x3a,0x3b,0x3b,0x3c,0x3d,0x3c,0x38,0x36,0x37,0x38,
0x38,0x39,0x3a,0x3b,0x3d,0x3c,0x3b,0x3c,0x3e,0x3f,0x3d,0x3b,0x39,0x39,0x3a,0x39,
0x37,0x37,0x39,0x3b,0x3e,0x42,0x4a,0x54,0x5e,0x68,0x72,0x7b,0x83,0x8b,0x91,0x93,
0x96,0x97,0x98,0x98,0x96,0x93,0x92,0x92,0x93,0x94,0x95,0x96,0x95,0x96,0x97,0x98,
0x97,0x95,0x95,0x96,0x96,0x96,0x93,0x94,0x92,0x91,0x92,0x93,0x92,0x94,0x94,0x94,
0x93,0x94,0x96,0x97,0x98,0x98,0x99,0x9a,0x98,0x98,0x97,0x98,0x97,0x97,0x99,0x9a,
0x9a,0x98,0x99,0x99,0x9a,0x9a,0x98,0x96,0x94,0x95,0x95,0x95,0x91,0x94,0x96,0x95,
0x93,0x91,0x8f,0x93,0x94,0x93,0x93,0x95,0x98,0x99,0x9a,0x98,0x98,0x9a,0x9c,0x9b,
0x98,0x96,0x96,0x9a,0x99,0x98,0x97,0x96,0x96,0x98,0x98,0x99,0x98,0x97,0x95,0x93,
0x92,0x93,0x93,0x94,0x8f,0x8a,0x82,0x7b,0x72,0x6a,0x61,0x59,0x53,0x4c,0x46,0x40,
0x3c,0x3a,0x39,0x3b,0x3e,0x3c,0x3b,0x3a,0x39,0x39,0x38,0x37,0x3b,0x3b,0x3a,0x39,
0x37,0x36,0x37,0x39,0x39,0x3a,0x3a,0x3a,0x3a,0x3b,0x3a,0x3b,0x3c,0x3b,0x38,0x35,
0x33,0x34,0x36,0x37,0x38,0x39,0x39,0x37,0x37,0x38,0x39,0x38,0x37,0x36,0x35,0x34,
0x33,0x33,0x37,0x37,0x36,0x37,0x37,0x37,0x36,0x34,0x34,0x36,0x38,0x39,0x39,0x3a,
0x3a,0x38,0x38,0x38,0x38,0x39,0x38,0x36,0x34,0x34,0x34,0x35,0x35,0x36,0x38,0x3a,
0x39,0x38,0x37,0x37,0x37,0x37,0x37,0x36,0x36,0x35,0x35,0x36,0x36,0x37,0x3a,0x39,
0x38,0x39,0x38,0x38,0x38,0x3a,0x3b,0x3d,0x41,0x47,0x4e,0x57,0x5f,0x67,0x70,0x77,
0x7d,0x83,0x88,0x8c,0x90,0x93,0x96,0x96,0x95,0x96,0x97,0x98,0x98,0x97,0x96,0x95,
0x93,0x93,0x93,0x94,0x97,0x97,0x97,0x98,0x99,0x9b,0x98,0x9a,0x99,0x98,0x97,0x96,
0x95,0x98,0x96,0x92,0x92,0x93,0x96,0x98,0x98,0x99,0x9a,0x9b,0x99,0x96,0x96,0x97,
0x98,0x98,0x96,0x93,0x93,0x95,0x94,0x93,0x93,0x94,0x95,0x93,0x91,0x91,0x92,0x95,
0x95,0x94,0x95,0x98,0x9a,0x99,0x98,0x96,0x95,0x93,0x93,0x93,0x93,0x95,0x93,0x90,
0x91,0x93,0x96,0x97,0x98,0x98,0x98,0x98,0x96,0x94,0x95,0x96,0x96,0x97,0x95,0x94,
0x93,0x92,0x92,0x95,0x99,0x9b,0x9b,0x9a,0x98,0x97,0x98,0x98,0x98,0x9a,0x9a,0x97,
0x95,0x94,0x94,0x95,0x95,0x96,0x97,0x97,0x98,0x95,0x95,0x94,0x94,0x96,0x98,0x99,
0x99,0x98,0x98,0x97,0x94,0x93,0x94,0x96,0x95,0x95,0x95,0x95,0x94,0x94,0x95,0x96,
0x98,0x99,0x98,0x98,0x97,0x95,0x95,0x94,0x94,0x95,0x94,0x93,0x94,0x93,0x93,0x92,
0x90,0x8b,0x87,0x82,0x7b,0x70,0x67,0x5e,0x54,0x4d,0x46,0x40,0x3b,0x38,0x36,0x37,
0x39,0x3b,0x3b,0x3b,0x3b,0x3c,0x3d,0x3d,0x3d,0x3d,0x3b,0x38,0x38,0x38,0x38,0x38,
0x38,0x37,0x36,0x37,0x39,0x3b,0x3b,0x3a,0x3a,0x3b,0x3c,0x3b,0x3b,0x3a,0x3b,0x3b,
0x3a,0x38,0x37,0x37,0x36,0x37,0x37,0x38,0x37,0x38,0x36,0x34,0x36,0x38,0x38,0x39,
0x37,0x36,0x37,0x36,0x36,0x38,0x39,0x38,0x37,0x36,0x37,0x37,0x38,0x38,0x38,0x38,
0x38,0x37,0x37,0x39,0x38,0x39,0x38,0x38,0x37,0x37,0x36,0x37,0x37,0x37,0x34,0x34,
0x34,0x34,0x36,0x37,0x36,0x39,0x38,0x37,0x38,0x37,0x37,0x37,0x38,0x37,0x37,0x37,
0x37,0x37,0x3b,0x3c,0x40,0x48,0x50,0x58,0x60,0x67,0x70,0x7a,0x83,0x8b,0x91,0x92,
0x92,0x92,0x94,0x95,0x95,0x96,0x97,0x96,0x96,0x95,0x95,0x98,0x96,0x97,0x97,0x96,
0x94,0x94,0x97,0x97,0x98,0x99,0x9c,0x9b,0x9c,0x99,0x98,0x99,0x99,0x99,0x99,0x9a,
0x98,0x99,0x98,0x9a,0x9c,0x9e,0x9d,0x9b,0x99,0x97,0x96,0x96,0x96,0x98,0x9a,0x99,
0x98,0x98,0x98,0x9a,0x9c,0x9c,0x9b,0x98,0x96,0x94,0x94,0x96,0x94,0x93,0x93,0x93,
0x92,0x95,0x98,0x98,0x9b,0x9a,0x98,0x98,0x98,0x9a,0x9b,0x9b,0x99,0x98,0x96,0x96,
0x98,0x98,0x9a,0x9a,0x9a,0x98,0x95,0x93,0x92,0x94,0x98,0x9a,0x9a,0x9a,0x99,0x98,
0x97,0x97,0x98,0x97,0x93,0x8d,0x84,0x7c,0x72,0x67,0x61,0x5a,0x53,0x4d,0x47,0x41,
0x3d,0x3b,0x38,0x38,0x39,0x38,0x38,0x37,0x36,0x36,0x38,0x3a,0x3a,0x3b,0x3b,0x3b,
0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x39,0x3b,0x3b,0x39,0x39,0x37,0x37,
0x35,0x34,0x35,0x37,0x37,0x37,0x38,0x38,0x37,0x37,0x38,0x39,0x39,0x39,0x38,0x37,
0x37,0x36,0x36,0x34,0x35,0x36,0x39,0x39,0x38,0x38,0x38,0x38,0x39,0x3a,0x3a,0x3b,
0x3a,0x37,0x36,0x37,0x38,0x3a,0x3b,0x3a,0x38,0x38,0x37,0x37,0x38,0x38,0x38,0x38,
0x36,0x34,0x34,0x35,0x35,0x35,0x36,0x36,0x33,0x34,0x34,0x34,0x37,0x3a,0x3a,0x3a,
0x37,0x37,0x37,0x37,0x38,0x38,0x39,0x3b,0x40,0x45,0x4e,0x58,0x61,0x69,0x72,0x7a,
0x80,0x85,0x8a,0x8f,0x91,0x93,0x94,0x94,0x95,0x95,0x95,0x96,0x98,0x99,0x98,0x98,
0x93,0x92,0x93,0x94,0x94,0x96,0x97,0x95,0x94,0x93,0x94,0x97,0x98,0x97,0x96,0x95,
0x94,0x93,0x93,0x93,0x94,0x95,0x95,0x94,0x93,0x94,0x97,0x98,0x98,0x99,0x9a,0x98,
0x97,0x96,0x96,0x96,0x96,0x95,0x93,0x92,0x93,0x95,0x96,0x98,0x98,0x97,0x98,0x97,
0x96,0x95,0x96,0x95,0x94,0x93,0x94,0x94,0x96,0x95,0x95,0x96,0x93,0x92,0x93,0x93,
0x94,0x94,0x94,0x96,0x97,0x96,0x97,0x98,0x9a,0x99,0x98,0x97,0x96,0x96,0x97,0x97,
0x96,0x96,0x96,0x98,0x98,0x98,0x98,0x94,0x8f,0x88,0x80,0x79,0x70,0x67,0x5f,0x55,
0x4c,0x46,0x42,0x40,0x3c,0x3b,0x39,0x39,0x3b,0x3b,0x3d,0x3d,0x3b,0x3a,0x38,0x38,
0x38,0x39,0x39,0x37,0x38,0x37,0x35,0x35,0x36,0x37,0x3b,0x3b,0x39,0x38,0x38,0x38,
0x37,0x38,0x39,0x38,0x37,0x37,0x35,0x37,0x38,0x3a,0x3b,0x3b,0x38,0x38,0x39,0x39,
0x35,0x38,0x38,0x37,0x37,0x37,0x37,0x39,0x38,0x36,0x37,0x36,0x35,0x37,0x37,0x38,
0x39,0x39,0x3a,0x3a,0x3b,0x3b,0x3b,0x3b,0x39,0x37,0x37,0x37,0x37,0x39,0x3a,0x39,
0x37,0x34,0x34,0x36,0x37,0x39,0x39,0x37,0x36,0x35,0x37,0x38,0x3a,0x3b,0x3a,0x35,
0x34,0x33,0x32,0x33,0x34,0x34,0x34,0x33,0x33,0x32,0x35,0x35,0x34,0x36,0x37,0x37,
0x37,0x35,0x36,0x37,0x36,0x34,0x34,0x33,0x33,0x36,0x38,0x39,0x38,0x37,0x38,0x3a,
0x3b,0x3b,0x3a,0x38,0x35,0x31,0x30,0x31,0x33,0x34,0x34,0x32,0x32,0x33,0x34,0x34,
// Line 15
0x36,0x37,0x37,0x37,0x36,0x37,0x38,0x3a,0x3b,0x3b,0x3b,0x3b,0x39,0x39,0x38,0x36,
0x37,0x37,0x37,0x36,0x35,0x34,0x35,0x33,0x33,0x33,0x35,0x36,0x37,0x38,0x38,0x39,
0x3c,0x3c,0x3b,0x39,0x3a,0x3a,0x3a,0x38,0x36,0x37,0x38,0x38,0x37,0x38,0x3b,0x3a,
0x3a,0x36,0x33,0x34,0x37,0x42,0x55,0x68,0x75,0x79,0x76,0x6b,0x62,0x5c,0x5d,0x65,
0x70,0x78,0x7b,0x79,0x71,0x6a,0x65,0x65,0x68,0x6d,0x75,0x7b,0x7a,0x76,0x6e,0x66,
0x61,0x61,0x64,0x6d,0x75,0x78,0x78,0x73,0x6b,0x66,0x61,0x62,0x67,0x71,0x79,0x7b,
0x79,0x72,0x6b,0x66,0x63,0x62,0x68,0x6f,0x75,0x78,0x78,0x72,0x6b,0x63,0x5d,0x5e,
0x63,0x6d,0x75,0x78,0x76,0x70,0x68,0x61,0x5d,0x62,0x6a,0x73,0x7a,0x7c,0x7a,0x74,
0x6d,0x68,0x67,0x69,0x6c,0x6f,0x70,0x6f,0x70,0x75,0x7c,0x85,0x94,0x9c,0xa5,0xab,
0xa8,0xa1,0x95,0x86,0x75,0x6a,0x62,0x5d,0x57,0x50,0x47,0x3e,0x39,0x3b,0x42,0x52,
0x64,0x75,0x83,0x8c,0x91,0x95,0x98,0x9c,0xa1,0xa3,0xa1,0x9b,0x8f,0x80,0x72,0x68,
0x61,0x5f,0x62,0x68,0x70,0x79,0x81,0x89,0x91,0x99,0x9d,0xa2,0xa6,0xa5,0x9f,0x9a,
0x95,0x94,0x98,0x99,0x97,0x92,0x86,0x73,0x61,0x52,0x4f,0x57,0x64,0x71,0x7a,0x7b,
0x78,0x6f,0x66,0x62,0x63,0x6b,0x73,0x78,0x79,0x75,0x6d,0x64,0x5e,0x5d,0x61,0x6a,
0x72,0x78,0x79,0x76,0x6d,0x66,0x62,0x64,0x6d,0x76,0x7a,0x7c,0x76,0x6d,0x67,0x61,
0x5e,0x5d,0x5b,0x53,0x48,0x3b,0x31,0x2c,0x2b,0x2d,0x35,0x40,0x4b,0x55,0x5f,0x6a,
0x73,0x78,0x75,0x6d,0x64,0x5f,0x60,0x69,0x75,0x7f,0x80,0x7a,0x6e,0x64,0x60,0x61,
0x67,0x76,0x7d,0x7b,0x78,0x70,0x69,0x64,0x61,0x60,0x5c,0x56,0x4e,0x42,0x36,0x2d,
0x2a,0x2e,0x36,0x3d,0x40,0x3f,0x39,0x35,0x31,0x2f,0x31,0x36,0x3a,0x3c,0x3b,0x3a,
0x3a,0x3b,0x3b,0x3b,0x39,0x38,0x35,0x39,0x3e,0x4d,0x60,0x71,0x7a,0x7f,0x79,0x70,
0x67,0x62,0x62,0x65,0x6c,0x72,0x78,0x7e,0x85,0x8e,0x99,0xa1,0xa6,0xa8,0xa5,0x9f,
0x96,0x8b,0x7f,0x73,0x66,0x61,0x61,0x6a,0x73,0x7c,0x82,0x81,0x78,0x6b,0x62,0x61,
0x67,0x70,0x76,0x79,0x78,0x6e,0x64,0x5b,0x58,0x57,0x59,0x52,0x49,0x3e,0x35,0x2d,
0x2e,0x32,0x39,0x42,0x46,0x43,0x3e,0x39,0x33,0x30,0x2f,0x31,0x34,0x36,0x37,0x36,
0x35,0x34,0x34,0x35,0x33,0x32,0x32,0x33,0x35,0x36,0x38,0x38,0x39,0x35,0x33,0x32,
0x34,0x35,0x39,0x3b,0x3a,0x35,0x37,0x3b,0x47,0x5c,0x70,0x7d,0x83,0x7f,0x72,0x64,
0x5b,0x5f,0x6b,0x77,0x7c,0x7d,0x78,0x6f,0x66,0x63,0x60,0x5e,0x5b,0x50,0x43,0x36,
0x2c,0x29,0x2d,0x34,0x3a,0x3d,0x3d,0x39,0x34,0x32,0x30,0x30,0x32,0x35,0x39,0x3c,
0x3a,0x35,0x31,0x31,0x37,0x47,0x5b,0x70,0x7c,0x82,0x7d,0x73,0x67,0x5e,0x57,0x53,
0x4d,0x44,0x3c,0x34,0x2f,0x2e,0x31,0x38,0x45,0x53,0x61,0x6b,0x71,0x72,0x6f,0x69,
0x61,0x59,0x56,0x51,0x49,0x40,0x35,0x2a,0x28,0x2c,0x34,0x3d,0x42,0x43,0x3d,0x36,
0x31,0x33,0x42,0x59,0x6d,0x7c,0x81,0x7c,0x73,0x69,0x62,0x63,0x67,0x71,0x7b,0x7f,
0x7a,0x70,0x68,0x62,0x62,0x68,0x71,0x79,0x7d,0x7c,0x76,0x6d,0x64,0x5e,0x60,0x66,
0x6e,0x77,0x7a,0x79,0x74,0x6c,0x65,0x63,0x64,0x63,0x5e,0x51,0x3e,0x31,0x30,0x3d,
0x54,0x6d,0x81,0x88,0x82,0x72,0x60,0x52,0x49,0x45,0x42,0x3e,0x36,0x2f,0x2c,0x2e,
0x34,0x3c,0x40,0x3e,0x38,0x33,0x30,0x31,0x34,0x36,0x35,0x36,0x34,0x33,0x35,0x39,
0x3b,0x39,0x35,0x31,0x31,0x35,0x40,0x4c,0x58,0x63,0x71,0x7d,0x8a,0x93,0x9e,0xa0,
0x9b,0x90,0x7e,0x6b,0x62,0x5d,0x61,0x6c,0x78,0x7f,0x7c,0x75,0x6c,0x64,0x5c,0x56,
0x4e,0x47,0x3d,0x31,0x28,0x25,0x2b,0x35,0x3b,0x3d,0x3c,0x3b,0x3a,0x39,0x37,0x36,
0x37,0x37,0x38,0x39,0x41,0x4f,0x60,0x70,0x7b,0x83,0x8a,0x91,0x98,0xa0,0xa6,0xa8,
0xa3,0x98,0x89,0x79,0x6b,0x62,0x5c,0x57,0x50,0x44,0x3c,0x37,0x3b,0x48,0x59,0x6b,
0x7b,0x80,0x7b,0x6d,0x5d,0x50,0x4c,0x4a,0x46,0x3e,0x36,0x2e,0x28,0x28,0x2c,0x35,
0x42,0x4c,0x55,0x60,0x69,0x77,0x87,0x95,0x9c,0x9e,0x99,0x90,0x81,0x70,0x62,0x59,
0x59,0x5f,0x68,0x74,0x7e,0x88,0x92,0x9a,0x9e,0xa4,0xa6,0xa4,0xa1,0x9b,0x91,0x81,
0x75,0x68,0x60,0x5e,0x63,0x6b,0x78,0x7d,0x7b,0x76,0x6b,0x63,0x61,0x61,0x65,0x6b,
0x6e,0x72,0x76,0x7e,0x89,0x96,0xa2,0xa9,0xaa,0xa6,0x9d,0x95,0x8c,0x81,0x73,0x65,
0x5a,0x59,0x61,0x6d,0x78,0x7d,0x7b,0x72,0x65,0x5d,0x5b,0x61,0x6f,0x78,0x7a,0x79,
0x73,0x6b,0x64,0x61,0x5e,0x59,0x50,0x47,0x3a,0x33,0x2e,0x2d,0x31,0x37,0x3e,0x49,
0x56,0x63,0x72,0x7b,0x7c,0x76,0x6a,0x60,0x5b,0x61,0x6c,0x78,0x7d,0x7c,0x76,0x6b,
0x61,0x5a,0x5a,0x5a,0x58,0x50,0x42,0x33,0x28,0x26,0x2a,0x35,0x3f,0x46,0x44,0x3e,
0x33,0x2d,0x32,0x42,0x56,0x6d,0x7b,0x7d,0x79,0x6e,0x63,0x5e,0x5e,0x67,0x75,0x7d,
0x7d,0x76,0x6f,0x68,0x63,0x5f,0x5b,0x54,0x4c,0x41,0x36,0x2e,0x28,0x28,0x2f,0x38,
0x44,0x54,0x63,0x6f,0x74,0x73,0x6c,0x66,0x61,0x5e,0x5a,0x51,0x43,0x36,0x2e,0x2f,
0x3c,0x56,0x70,0x80,0x87,0x81,0x75,0x64,0x5a,0x52,0x4e,0x4a,0x42,0x39,0x37,0x33,
0x32,0x35,0x3a,0x41,0x4b,0x58,0x66,0x73,0x7a,0x79,0x70,0x64,0x5c,0x5f,0x6b,0x78,
0x7f,0x7e,0x76,0x6b,0x61,0x5e,0x63,0x6c,0x72,0x73,0x73,0x73,0x77,0x7f,0x8c,0x99,
0xa3,0xa4,0x99,0x83,0x6c,0x5a,0x4f,0x54,0x62,0x72,0x7c,0x7d,0x76,0x69,0x5d,0x5a,
0x5d,0x69,0x73,0x7a,0x79,0x72,0x69,0x64,0x61,0x60,0x5f,0x58,0x4c,0x3e,0x32,0x2b,
0x2b,0x31,0x39,0x41,0x42,0x3e,0x38,0x34,0x32,0x36,0x42,0x51,0x62,0x73,0x81,0x8c,
0x94,0x96,0x94,0x8e,0x84,0x76,0x63,0x58,0x4c,0x45,0x43,0x41,0x3b,0x3b,0x38,0x36,
0x39,0x3c,0x3c,0x38,0x32,0x2d,0x2d,0x35,0x46,0x59,0x6d,0x78,0x7b,0x75,0x6b,0x63,
0x5e,0x57,0x51,0x49,0x40,0x39,0x39,0x42,0x52,0x67,0x7b,0x8c,0x93,0x94,0x95,0x99,
0x9d,0x9f,0x9e,0x9f,0x9c,0x99,0x9b,0x9e,0x9f,0x9b,0x8e,0x7b,0x6a,0x5d,0x56,0x4f,
0x49,0x41,0x39,0x36,0x39,0x46,0x5e,0x76,0x86,0x89,0x81,0x73,0x65,0x5e,0x5c,0x61,
0x68,0x70,0x73,0x76,0x7a,0x85,0x92,0x9e,0xa7,0xab,0xa9,0xa3,0x98,0x8c,0x80,0x73,
0x69,0x61,0x5a,0x53,0x4b,0x3f,0x3b,0x3b,0x42,0x4f,0x61,0x72,0x81,0x8a,0x8e,0x91,
0x95,0x9a,0xa1,0xa5,0xa1,0x98,0x89,0x78,0x69,0x5f,0x56,0x4f,0x49,0x44,0x3d,0x3c,
0x3d,0x4b,0x60,0x73,0x80,0x83,0x7d,0x72,0x64,0x5c,0x5c,0x5e,0x67,0x6f,0x75,0x7c,
0x81,0x87,0x96,0x9f,0xa6,0xa9,0xa5,0xa0,0x9b,0x98,0x98,0x9b,0x9d,0x9c,0x95,0x89,
0x78,0x69,0x61,0x5d,0x5d,0x62,0x6b,0x75,0x7f,0x88,0x8f,0x96,0x9b,0xa0,0xa3,0xa2,
0x9d,0x91,0x82,0x72,0x65,0x5e,0x59,0x52,0x4d,0x44,0x3b,0x38,0x3e,0x4e,0x64,0x77,
0x81,0x82,0x79,0x6d,0x62,0x59,0x54,0x51,0x4b,0x41,0x39,0x39,0x42,0x56,0x6e,0x81,
0x88,0x83,0x74,0x63,0x58,0x59,0x63,0x70,0x78,0x79,0x75,0x6e,0x67,0x63,0x65,0x68,
0x69,0x6d,0x6f,0x72,0x7a,0x82,0x8c,0x97,0xa1,0xa9,0xac,0xaa,0xa4,0x9a,0x8d,0x7c,
0x6d,0x64,0x60,0x61,0x64,0x6b,0x72,0x7b,0x81,0x89,0x91,0x97,0x9a,0x96,0x89,0x76,
0x62,0x50,0x44,0x3c,0x39,0x38,0x37,0x36,0x34,0x34,0x37,0x3b,0x3c,0x3d,0x39,0x34,
0x2e,0x36,0x42,0x58,0x6d,0x7d,0x82,0x7c,0x70,0x63,0x5e,0x61,0x6a,0x76,0x7d,0x7f,
0x7b,0x72,0x6b,0x67,0x66,0x69,0x6d,0x71,0x73,0x75,0x78,0x7c,0x84,0x8f,0x9b,0xa6,
0xac,0xac,0xa4,0x96,0x87,0x78,0x69,0x61,0x5b,0x58,0x51,0x47,0x3b,0x36,0x3a,0x46,
0x5a,0x70,0x7f,0x84,0x7b,0x6b,0x5e,0x54,0x4e,0x4c,0x49,0x42,0x37,0x2f,0x2b,0x2c,
0x34,0x3d,0x43,0x42,0x38,0x30,0x2f,0x36,0x47,0x5b,0x70,0x7f,0x82,0x7c,0x73,0x68,
0x61,0x5e,0x5e,0x66,0x6c,0x73,0x7b,0x83,0x8b,0x95,0x9e,0xa6,0xac,0xad,0xa8,0x9e,
0x8f,0x7c,0x6b,0x5f,0x5b,0x5f,0x6a,0x73,0x7a,0x7c,0x77,0x6c,0x63,0x5d,0x5b,0x59,
0x52,0x47,0x39,0x2f,0x2e,0x3d,0x58,0x73,0x85,0x89,0x7f,0x6f,0x5f,0x56,0x53,0x54,
0x4d,0x42,0x38,0x37,0x42,0x56,0x71,0x83,0x88,0x80,0x6d,0x5b,0x53,0x57,0x62,0x70,
0x78,0x78,0x73,0x6b,0x64,0x61,0x5f,0x5d,0x54,0x48,0x3b,0x33,0x34,0x3e,0x4e,0x64,
0x78,0x89,0x95,0x9b,0x9d,0x9b,0x94,0x89,0x7b,0x6c,0x61,0x5a,0x5e,0x65,0x6d,0x78,
0x82,0x87,0x8f,0x94,0x96,0x94,0x8b,0x7b,0x68,0x54,0x47,0x40,0x40,0x42,0x42,0x3e,
0x38,0x35,0x35,0x38,0x3d,0x46,0x50,0x5c,0x69,0x75,0x81,0x8c,0x95,0x9c,0xa1,0xa3,
0xa4,0xa2,0x9f,0x9c,0x9b,0x9b,0x9d,0x9c,0x96,0x8a,0x7a,0x6d,0x61,0x5b,0x5d,0x65,
0x6d,0x78,0x81,0x89,0x8d,0x97,0x9d,0xa3,0xa6,0xa6,0xa1,0x98,0x8b,0x7c,0x6f,0x64,
0x5e,0x5e,0x61,0x67,0x6f,0x78,0x81,0x8b,0x93,0x99,0x9b,0x95,0x87,0x76,0x64,0x56,
0x49,0x42,0x3d,0x3b,0x39,0x3c,0x46,0x58,0x6e,0x7f,0x81,0x7c,0x6f,0x60,0x59,0x5c,
0x68,0x78,0x80,0x80,0x78,0x6d,0x64,0x61,0x63,0x6a,0x70,0x73,0x73,0x75,0x7a,0x81,
0x8a,0x97,0xa3,0xab,0xad,0xaa,0xa3,0x9e,0x98,0x96,0x97,0x99,0x9d,0xa1,0xa0,0x9c,
0x98,0x96,0x94,0x95,0x98,0x98,0x94,0x8b,0x7c,0x6d,0x60,0x54,0x4b,0x43,0x3e,0x3b,
// Line 16
0x37,0x37,0x38,0x38,0x38,0x36,0x35,0x35,0x35,0x36,0x37,0x37,0x35,0x34,0x36,0x38,
0x38,0x39,0x3b,0x3a,0x3a,0x38,0x36,0x36,0x37,0x37,0x37,0x34,0x32,0x32,0x34,0x34,
0x33,0x34,0x32,0x32,0x35,0x36,0x37,0x39,0x38,0x36,0x34,0x34,0x34,0x38,0x3d,0x3d,
0x39,0x35,0x30,0x32,0x3c,0x4c,0x5f,0x71,0x7a,0x7a,0x74,0x68,0x5d,0x57,0x5d,0x67,
0x70,0x78,0x78,0x73,0x6a,0x60,0x5a,0x5e,0x66,0x70,0x78,0x7a,0x78,0x72,0x69,0x62,
0x60,0x63,0x68,0x70,0x75,0x76,0x71,0x6a,0x62,0x5c,0x5d,0x60,0x67,0x71,0x78,0x7a,
0x75,0x70,0x6a,0x63,0x61,0x61,0x66,0x6e,0x72,0x71,0x70,0x6c,0x65,0x63,0x60,0x63,
0x6a,0x70,0x75,0x77,0x74,0x6d,0x65,0x5f,0x5c,0x60,0x68,0x71,0x77,0x7a,0x75,0x6d,
0x65,0x5f,0x5d,0x60,0x65,0x6a,0x6f,0x72,0x73,0x76,0x7c,0x87,0x94,0xa2,0xab,0xab,
0xa6,0x9a,0x8a,0x7c,0x6f,0x65,0x60,0x59,0x51,0x49,0x41,0x3b,0x39,0x3f,0x4a,0x5a,
0x6b,0x7b,0x88,0x91,0x96,0x98,0x9b,0x9f,0xa1,0xa2,0x9e,0x96,0x8c,0x7e,0x6f,0x62,
0x59,0x59,0x61,0x6d,0x77,0x7b,0x7a,0x73,0x67,0x5f,0x5d,0x63,0x6e,0x78,0x7d,0x7d,
0x76,0x6e,0x69,0x66,0x67,0x6d,0x71,0x71,0x6f,0x71,0x76,0x7e,0x8b,0x99,0xa4,0xab,
0xaa,0xa4,0x9f,0x9b,0x9a,0x99,0x9b,0x9a,0x94,0x89,0x7b,0x6c,0x5e,0x53,0x49,0x42,
0x3a,0x34,0x35,0x3f,0x4f,0x65,0x77,0x80,0x7b,0x73,0x66,0x5c,0x55,0x52,0x4b,0x46,
0x3a,0x31,0x35,0x43,0x5b,0x75,0x84,0x86,0x7c,0x6c,0x5e,0x54,0x4f,0x4e,0x4c,0x46,
0x3b,0x31,0x2e,0x32,0x38,0x42,0x49,0x50,0x57,0x63,0x71,0x80,0x8c,0x95,0x98,0x95,
0x8c,0x81,0x73,0x62,0x52,0x46,0x3c,0x36,0x37,0x39,0x3c,0x3c,0x38,0x35,0x38,0x42,
0x50,0x60,0x70,0x7a,0x7d,0x78,0x6c,0x61,0x59,0x5c,0x64,0x70,0x78,0x7a,0x75,0x69,
0x5e,0x5b,0x5f,0x6b,0x78,0x7f,0x7e,0x78,0x70,0x69,0x64,0x67,0x67,0x68,0x6a,0x6b,
0x6b,0x6f,0x73,0x7a,0x87,0x94,0x9f,0xa8,0xac,0xaa,0xa2,0x94,0x82,0x73,0x69,0x63,
0x5e,0x57,0x4c,0x41,0x38,0x37,0x3c,0x49,0x59,0x6b,0x7d,0x88,0x8e,0x92,0x93,0x90,
0x8a,0x7e,0x6f,0x5e,0x51,0x47,0x42,0x42,0x3e,0x3c,0x3b,0x3a,0x38,0x38,0x3c,0x43,
0x4e,0x5b,0x68,0x71,0x80,0x8b,0x96,0x9a,0x96,0x8c,0x80,0x72,0x63,0x56,0x4a,0x40,
0x3b,0x38,0x3b,0x43,0x52,0x64,0x74,0x80,0x89,0x8f,0x94,0x99,0x9e,0xa1,0xa2,0xa0,
0x9f,0x9c,0x9b,0x9a,0x9a,0x9b,0x9d,0x9f,0xa1,0x9d,0x9a,0x90,0x82,0x75,0x67,0x5c,
0x57,0x51,0x4a,0x42,0x3b,0x39,0x40,0x50,0x62,0x73,0x7f,0x7f,0x75,0x66,0x5c,0x59,
0x60,0x69,0x72,0x78,0x7a,0x7d,0x85,0x92,0x9d,0xa3,0x9e,0x8b,0x73,0x60,0x57,0x5a,
0x67,0x75,0x7f,0x81,0x7b,0x73,0x6d,0x67,0x61,0x5a,0x4e,0x3e,0x31,0x2e,0x34,0x46,
0x5d,0x73,0x7d,0x80,0x76,0x69,0x61,0x5c,0x56,0x4f,0x47,0x3f,0x3a,0x39,0x41,0x54,
0x68,0x7a,0x88,0x8f,0x93,0x97,0x9a,0x9d,0x9f,0xa2,0x9f,0x9c,0x99,0x97,0x98,0x9c,
0x9e,0x9e,0x9e,0x9d,0x9a,0x9a,0x9c,0x9f,0x9f,0x9a,0x93,0x87,0x7b,0x6e,0x62,0x59,
0x4e,0x45,0x40,0x3a,0x37,0x3c,0x47,0x56,0x67,0x77,0x84,0x8d,0x92,0x94,0x99,0x9f,
0xa4,0xa4,0x9f,0x92,0x81,0x72,0x65,0x5c,0x56,0x4f,0x45,0x3d,0x36,0x36,0x3e,0x51,
0x65,0x76,0x7e,0x7b,0x71,0x69,0x5e,0x57,0x53,0x4c,0x42,0x38,0x32,0x34,0x43,0x59,
0x71,0x82,0x86,0x7b,0x6a,0x5e,0x59,0x5d,0x66,0x71,0x7a,0x7f,0x81,0x87,0x91,0x9c,
0xa0,0x9c,0x8e,0x79,0x62,0x51,0x4e,0x57,0x68,0x78,0x7e,0x81,0x78,0x6d,0x65,0x62,
0x63,0x6b,0x73,0x76,0x77,0x72,0x6b,0x62,0x5c,0x5d,0x65,0x71,0x79,0x7b,0x78,0x70,
0x69,0x65,0x63,0x65,0x6a,0x6f,0x70,0x70,0x70,0x76,0x82,0x8f,0x99,0xa2,0xaa,0xac,
0xa7,0x9b,0x8c,0x7d,0x72,0x67,0x5e,0x56,0x4e,0x47,0x41,0x3a,0x36,0x38,0x45,0x57,
0x6a,0x7c,0x87,0x8f,0x94,0x97,0x99,0x9d,0x9e,0x9f,0x9e,0x9b,0x97,0x97,0x9a,0x9e,
0xa1,0xa1,0x9f,0xa0,0xa3,0xa4,0xa4,0xa2,0x9f,0x9d,0x9e,0x9e,0x9f,0x9f,0x9b,0x93,
0x85,0x73,0x66,0x5b,0x52,0x47,0x3f,0x38,0x32,0x33,0x3e,0x4e,0x60,0x73,0x81,0x8a,
0x8f,0x94,0x97,0x99,0x94,0x88,0x75,0x62,0x55,0x55,0x5f,0x6f,0x7b,0x81,0x7d,0x73,
0x69,0x61,0x60,0x67,0x6b,0x6e,0x6f,0x70,0x75,0x7e,0x8c,0x98,0x9d,0x98,0x87,0x71,
0x5e,0x54,0x54,0x60,0x6e,0x7a,0x7e,0x7b,0x71,0x67,0x61,0x5c,0x53,0x4b,0x40,0x35,
0x2e,0x2c,0x2e,0x37,0x3c,0x3d,0x3f,0x3b,0x38,0x36,0x36,0x35,0x35,0x33,0x32,0x35,
0x3d,0x4c,0x5e,0x6d,0x75,0x76,0x70,0x67,0x5e,0x58,0x53,0x4f,0x4b,0x43,0x3b,0x33,
0x2e,0x31,0x36,0x3f,0x47,0x50,0x5a,0x64,0x70,0x7e,0x8b,0x95,0x9a,0x98,0x8e,0x82,
0x72,0x64,0x58,0x4b,0x40,0x35,0x31,0x34,0x3f,0x53,0x68,0x78,0x7f,0x7e,0x72,0x66,
0x5d,0x59,0x58,0x54,0x48,0x3d,0x34,0x36,0x42,0x59,0x71,0x81,0x84,0x7a,0x68,0x5a,
0x54,0x5c,0x6b,0x78,0x7c,0x7a,0x73,0x6b,0x64,0x5f,0x5c,0x54,0x4c,0x3f,0x35,0x2e,
0x2c,0x2b,0x2f,0x33,0x39,0x46,0x55,0x66,0x73,0x7a,0x79,0x72,0x68,0x61,0x60,0x64,
0x68,0x6c,0x70,0x73,0x76,0x7d,0x87,0x93,0xa0,0xa8,0xab,0xa8,0x9f,0x92,0x82,0x74,
0x69,0x62,0x5c,0x55,0x4c,0x43,0x3c,0x34,0x36,0x3e,0x50,0x66,0x77,0x82,0x89,0x8d,
0x8f,0x94,0x9a,0xa0,0xa3,0x9e,0x92,0x83,0x75,0x68,0x5e,0x58,0x51,0x48,0x41,0x3b,
0x3b,0x3f,0x4a,0x59,0x6a,0x79,0x84,0x8c,0x8f,0x92,0x97,0x9a,0x9c,0x9b,0x9c,0x9c,
0x9a,0x9b,0x9d,0x9e,0xa0,0xa1,0xa0,0xa2,0xa1,0xa1,0xa1,0xa0,0x9d,0x9c,0x9c,0x9d,
0x9e,0x9f,0x9f,0x9e,0x9e,0x9d,0x9b,0x9b,0x9b,0x9c,0x9f,0x9d,0x98,0x8e,0x81,0x70,
0x61,0x56,0x4f,0x4a,0x45,0x3f,0x39,0x36,0x35,0x36,0x3c,0x41,0x42,0x41,0x3b,0x37,
0x35,0x3a,0x3f,0x4a,0x57,0x66,0x73,0x7f,0x89,0x92,0x96,0x94,0x8c,0x7f,0x72,0x66,
0x5c,0x51,0x48,0x42,0x3c,0x3b,0x40,0x4c,0x5c,0x6c,0x7b,0x85,0x8b,0x90,0x95,0x99,
0x9d,0xa1,0xa2,0xa2,0x9f,0x9b,0x9a,0x9d,0x9f,0xa1,0xa3,0xa4,0xa2,0x9e,0x9a,0x97,
0x98,0x9a,0x9c,0x99,0x91,0x83,0x73,0x65,0x5d,0x5f,0x68,0x73,0x7b,0x7f,0x7b,0x71,
0x67,0x5f,0x5e,0x62,0x67,0x6b,0x6e,0x71,0x77,0x82,0x90,0x9b,0xa0,0x9e,0x90,0x7b,
0x65,0x59,0x55,0x60,0x6b,0x78,0x7f,0x7d,0x73,0x6a,0x61,0x5f,0x63,0x68,0x6e,0x73,
0x77,0x7c,0x87,0x93,0x9d,0xa0,0x99,0x88,0x71,0x5f,0x55,0x54,0x59,0x63,0x70,0x7e,
0x87,0x8f,0x97,0x9e,0x9e,0x97,0x88,0x76,0x63,0x5a,0x57,0x5c,0x67,0x72,0x7c,0x84,
0x88,0x8e,0x98,0x9e,0xa3,0xa4,0xa3,0x9d,0x99,0x98,0x9a,0x9e,0xa1,0xa2,0xa1,0xa0,
0x9f,0x9e,0x9f,0x9e,0x9d,0x9e,0x9e,0x9e,0x9f,0xa2,0xa3,0xa1,0x98,0x8c,0x7d,0x6f,
0x63,0x5c,0x5c,0x60,0x65,0x6d,0x73,0x7c,0x88,0x92,0x97,0x95,0x8c,0x7f,0x6e,0x5d,
0x51,0x47,0x40,0x39,0x35,0x39,0x43,0x51,0x63,0x72,0x7e,0x81,0x7a,0x6c,0x60,0x5c,
0x5e,0x66,0x6e,0x73,0x76,0x7d,0x82,0x8c,0x98,0xa3,0xaa,0xa9,0xa2,0x9b,0x98,0x9a,
0x9f,0xa1,0x9f,0x98,0x8d,0x7f,0x70,0x61,0x58,0x4a,0x3d,0x35,0x31,0x33,0x3c,0x47,
0x54,0x66,0x77,0x85,0x8c,0x94,0x95,0x90,0x87,0x7b,0x6c,0x61,0x55,0x4b,0x44,0x3f,
0x3d,0x3d,0x3b,0x3b,0x3c,0x3d,0x3e,0x42,0x4a,0x55,0x63,0x72,0x7e,0x89,0x91,0x95,
0x98,0x9c,0x9e,0x9c,0x97,0x8e,0x7f,0x71,0x63,0x59,0x53,0x50,0x4e,0x49,0x42,0x3b,
0x35,0x33,0x36,0x3c,0x40,0x3f,0x3a,0x32,0x2b,0x2b,0x36,0x48,0x5c,0x6b,0x75,0x75,
0x6e,0x64,0x5c,0x55,0x52,0x4d,0x47,0x40,0x38,0x32,0x32,0x36,0x3e,0x46,0x49,0x43,
0x3b,0x34,0x32,0x38,0x43,0x53,0x63,0x74,0x7f,0x88,0x93,0x9a,0x9b,0x95,0x86,0x73,
0x63,0x5a,0x58,0x5c,0x64,0x70,0x7a,0x85,0x8d,0x95,0x9e,0x9d,0x96,0x8a,0x78,0x62,
0x51,0x43,0x39,0x36,0x36,0x39,0x39,0x37,0x31,0x2f,0x32,0x3d,0x4c,0x62,0x73,0x7b,
0x7a,0x70,0x66,0x5f,0x5c,0x60,0x68,0x70,0x73,0x75,0x79,0x82,0x90,0x9e,0xa6,0xa2,
0x94,0x7f,0x68,0x57,0x50,0x54,0x61,0x6e,0x78,0x82,0x8b,0x94,0x9a,0x9e,0xa2,0xa4,
0xa2,0x9d,0x95,0x8c,0x7f,0x70,0x66,0x60,0x5f,0x66,0x70,0x78,0x7f,0x85,0x8a,0x8f,
0x97,0x9f,0xa6,0xa8,0xa6,0xa2,0x9e,0x9a,0x99,0x9d,0xa1,0xa2,0xa3,0xa2,0x9f,0x9e,
0x9e,0x9d,0x99,0x97,0x97,0x98,0x9c,0x9f,0x9e,0x9a,0x91,0x85,0x77,0x6b,0x61,0x5a,
0x51,0x47,0x40,0x3b,0x3a,0x3e,0x48,0x57,0x67,0x76,0x80,0x88,0x8d,0x91,0x95,0x9a,
0x9d,0x9f,0xa1,0x9f,0x9c,0x9c,0x9b,0x99,0x90,0x87,0x78,0x6b,0x5f,0x57,0x4e,0x4a,
0x43,0x3c,0x3b,0x40,0x4e,0x65,0x7a,0x82,0x83,0x7a,0x6d,0x60,0x59,0x59,0x60,0x68,
0x6e,0x73,0x78,0x7f,0x87,0x95,0xa2,0xaa,0xad,0xa9,0xa0,0x94,0x82,0x72,0x65,0x5b,
0x54,0x50,0x4a,0x43,0x39,0x36,0x3a,0x44,0x56,0x6a,0x7d,0x8b,0x8f,0x91,0x94,0x9a,
0xa2,0xa6,0xa6,0xa2,0x9e,0x9b,0x9a,0x98,0x9b,0x99,0x8f,0x81,0x6e,0x5e,0x59,0x5b,
0x64,0x70,0x79,0x7d,0x7a,0x70,0x66,0x5d,0x56,0x51,0x4b,0x42,0x37,0x2c,0x26,0x26,
0x2b,0x33,0x3a,0x3f,0x3f,0x3c,0x36,0x31,0x2f,0x32,0x37,0x3b,0x3d,0x3c,0x3b,0x37,
0x35,0x35,0x37,0x39,0x3b,0x3b,0x38,0x38,0x37,0x38,0x3a,0x38,0x36,0x37,0x36,0x34,
// Line 17
0x36,0x37,0x37,0x38,0x39,0x38,0x37,0x36,0x34,0x37,0x3a,0x39,0x38,0x38,0x3a,0x3b,
0x39,0x39,0x37,0x36,0x36,0x34,0x32,0x32,0x32,0x32,0x34,0x34,0x34,0x33,0x34,0x35,
0x34,0x34,0x34,0x35,0x39,0x39,0x39,0x39,0x3a,0x3a,0x3d,0x3d,0x3a,0x37,0x34,0x35,
0x3c,0x49,0x5a,0x6c,0x7a,0x80,0x7a,0x6f,0x63,0x5c,0x5f,0x68,0x72,0x7b,0x7c,0x77,
0x6f,0x65,0x60,0x60,0x64,0x6b,0x72,0x76,0x76,0x71,0x6c,0x65,0x60,0x62,0x66,0x6c,
0x72,0x76,0x76,0x71,0x69,0x63,0x61,0x63,0x68,0x71,0x78,0x7b,0x78,0x72,0x68,0x5f,
0x5e,0x63,0x68,0x71,0x76,0x76,0x76,0x6f,0x68,0x61,0x61,0x61,0x68,0x70,0x78,0x7a,
0x7b,0x76,0x6d,0x67,0x63,0x64,0x6c,0x73,0x79,0x7b,0x78,0x70,0x68,0x61,0x60,0x63,
0x69,0x6f,0x72,0x72,0x71,0x73,0x7b,0x86,0x93,0xa0,0xaa,0xac,0xa7,0x9d,0x8e,0x7d,
0x6f,0x65,0x5d,0x57,0x50,0x48,0x41,0x3c,0x3b,0x40,0x4a,0x5b,0x6f,0x7e,0x88,0x90,
0x94,0x97,0x99,0x9b,0x9c,0x9c,0x9a,0x94,0x8a,0x7c,0x6e,0x62,0x5d,0x5d,0x61,0x6e,
0x78,0x7b,0x7b,0x76,0x6b,0x63,0x60,0x62,0x6b,0x76,0x7d,0x7d,0x77,0x6e,0x66,0x63,
0x64,0x68,0x6c,0x6e,0x6e,0x6f,0x71,0x79,0x86,0x96,0xa3,0xab,0xac,0xa8,0xa2,0x9b,
0x98,0x98,0x9b,0x9c,0x96,0x8b,0x7d,0x6d,0x60,0x54,0x4b,0x43,0x3a,0x33,0x33,0x3c,
0x4e,0x60,0x73,0x7b,0x79,0x71,0x64,0x59,0x54,0x52,0x4e,0x46,0x3c,0x35,0x38,0x46,
0x5c,0x74,0x85,0x89,0x81,0x72,0x63,0x5a,0x5c,0x63,0x6d,0x75,0x77,0x7a,0x82,0x8d,
0x98,0xa3,0xa7,0xa7,0xa2,0x98,0x8d,0x7f,0x73,0x68,0x5d,0x55,0x4f,0x49,0x47,0x43,
0x3e,0x3a,0x3a,0x39,0x3a,0x3d,0x43,0x4b,0x57,0x64,0x71,0x7c,0x84,0x89,0x91,0x99,
0x9f,0xa3,0xa3,0x9e,0x92,0x84,0x74,0x68,0x61,0x5d,0x58,0x51,0x47,0x3e,0x3c,0x42,
0x52,0x66,0x79,0x83,0x82,0x77,0x6a,0x61,0x5a,0x56,0x4d,0x46,0x39,0x33,0x35,0x44,
0x5a,0x71,0x80,0x83,0x7a,0x6c,0x5f,0x58,0x52,0x4d,0x4b,0x47,0x3e,0x33,0x32,0x34,
0x39,0x41,0x49,0x52,0x5a,0x65,0x71,0x7f,0x8a,0x91,0x96,0x96,0x91,0x88,0x7b,0x69,
0x59,0x49,0x3e,0x38,0x3a,0x3e,0x41,0x3f,0x38,0x35,0x39,0x43,0x54,0x66,0x73,0x7b,
0x7d,0x78,0x6e,0x62,0x60,0x61,0x67,0x6b,0x6f,0x71,0x7a,0x83,0x8c,0x98,0xa4,0xac,
0xad,0xa9,0xa2,0x9b,0x97,0x98,0x9b,0x9f,0xa1,0xa2,0xa1,0xa0,0x9c,0x94,0x89,0x7b,
0x6e,0x61,0x55,0x4b,0x43,0x3d,0x3b,0x39,0x36,0x31,0x30,0x31,0x37,0x44,0x53,0x61,
0x71,0x79,0x79,0x76,0x6c,0x63,0x5e,0x58,0x4e,0x46,0x3c,0x35,0x34,0x3e,0x52,0x6c,
0x83,0x93,0x9c,0x9f,0x9d,0x96,0x8e,0x84,0x77,0x69,0x5a,0x4c,0x42,0x3b,0x38,0x3a,
0x43,0x51,0x64,0x76,0x81,0x82,0x7b,0x6f,0x63,0x5c,0x56,0x51,0x4a,0x3f,0x36,0x37,
0x45,0x5c,0x71,0x81,0x82,0x79,0x6a,0x5a,0x50,0x4d,0x4b,0x45,0x3b,0x31,0x2b,0x2c,
0x32,0x39,0x41,0x42,0x3e,0x37,0x36,0x35,0x36,0x3a,0x3b,0x3b,0x39,0x38,0x39,0x3c,
0x3b,0x39,0x36,0x32,0x32,0x34,0x38,0x3b,0x3a,0x38,0x33,0x33,0x34,0x37,0x39,0x3b,
0x3a,0x39,0x37,0x34,0x33,0x37,0x3e,0x48,0x57,0x65,0x73,0x7c,0x87,0x8f,0x98,0xa1,
0xa7,0xa8,0xa9,0xa5,0x9e,0x99,0x98,0x9a,0x9c,0x96,0x8d,0x80,0x6f,0x5f,0x53,0x4a,
0x44,0x40,0x3b,0x38,0x34,0x34,0x35,0x36,0x38,0x39,0x38,0x37,0x34,0x35,0x36,0x36,
0x36,0x36,0x38,0x3e,0x48,0x56,0x65,0x73,0x7f,0x89,0x90,0x98,0x9c,0xa2,0xa7,0xa8,
0xa2,0x98,0x8b,0x7c,0x6e,0x62,0x5d,0x5e,0x62,0x69,0x70,0x7a,0x81,0x89,0x94,0x9d,
0x9f,0x9c,0x8f,0x7a,0x68,0x5c,0x58,0x5a,0x64,0x71,0x7e,0x87,0x8c,0x90,0x96,0x9f,
0xa5,0xa7,0xa4,0xa0,0x9d,0x99,0x98,0x9b,0x9e,0x9d,0x96,0x86,0x6f,0x5e,0x57,0x5a,
0x64,0x6f,0x78,0x7c,0x7b,0x72,0x67,0x61,0x59,0x54,0x50,0x46,0x3b,0x2e,0x27,0x25,
0x2b,0x34,0x3d,0x42,0x40,0x39,0x2f,0x2d,0x34,0x46,0x5c,0x6e,0x79,0x7c,0x78,0x6f,
0x66,0x60,0x60,0x66,0x6c,0x75,0x7b,0x81,0x86,0x8e,0x99,0xa3,0xaa,0xae,0xac,0xa6,
0x9a,0x8a,0x7a,0x6c,0x61,0x5b,0x5c,0x60,0x68,0x6f,0x77,0x7e,0x84,0x8d,0x96,0x9d,
0xa3,0xa4,0xa3,0xa0,0x9b,0x97,0x96,0x97,0x9b,0x9f,0xa2,0xa3,0xa1,0x9f,0x9c,0x99,
0x98,0x99,0x9b,0xa2,0xa2,0xa1,0xa0,0x9f,0x9d,0x9c,0x9f,0x9f,0x9b,0x92,0x84,0x73,
0x68,0x5d,0x54,0x4e,0x47,0x3e,0x3a,0x38,0x3e,0x50,0x66,0x78,0x82,0x7e,0x72,0x66,
0x5c,0x56,0x51,0x4b,0x43,0x39,0x34,0x3a,0x49,0x61,0x77,0x84,0x85,0x7b,0x6c,0x5e,
0x55,0x4e,0x48,0x40,0x37,0x31,0x36,0x46,0x5d,0x77,0x86,0x89,0x82,0x72,0x61,0x55,
0x4f,0x4a,0x46,0x3e,0x35,0x2e,0x2c,0x2d,0x32,0x3c,0x47,0x54,0x61,0x6c,0x71,0x72,
0x6c,0x62,0x5a,0x55,0x51,0x4e,0x48,0x3e,0x34,0x2d,0x2d,0x32,0x3a,0x41,0x43,0x40,
0x39,0x34,0x32,0x33,0x35,0x38,0x38,0x39,0x3c,0x44,0x50,0x62,0x73,0x7e,0x85,0x8a,
0x8f,0x94,0x9e,0xa4,0xa5,0xa2,0x9a,0x8e,0x7f,0x71,0x67,0x63,0x62,0x64,0x69,0x71,
0x79,0x82,0x8a,0x91,0x97,0x9b,0x96,0x8a,0x77,0x63,0x50,0x44,0x3e,0x3d,0x3b,0x3c,
0x38,0x36,0x36,0x39,0x3b,0x40,0x41,0x3d,0x38,0x34,0x33,0x38,0x3b,0x3d,0x3e,0x3c,
0x39,0x35,0x33,0x34,0x3d,0x4b,0x5d,0x6c,0x78,0x7c,0x77,0x6f,0x65,0x5e,0x5e,0x61,
0x68,0x6f,0x73,0x78,0x7d,0x86,0x92,0xa0,0xaa,0xae,0xa9,0xa1,0x99,0x96,0x99,0x9c,
0x9e,0x9c,0x93,0x85,0x73,0x64,0x5d,0x5b,0x61,0x66,0x6e,0x78,0x80,0x87,0x8f,0x95,
0x98,0x96,0x8a,0x79,0x66,0x59,0x53,0x5a,0x68,0x79,0x83,0x83,0x78,0x6a,0x5f,0x5c,
0x5f,0x68,0x71,0x76,0x76,0x72,0x6c,0x67,0x65,0x66,0x6b,0x6e,0x71,0x71,0x75,0x79,
0x81,0x8d,0x96,0x9b,0x96,0x8a,0x76,0x64,0x51,0x44,0x3d,0x39,0x38,0x3c,0x46,0x55,
0x66,0x73,0x7c,0x7d,0x75,0x68,0x5d,0x56,0x51,0x4d,0x46,0x3a,0x32,0x32,0x3e,0x55,
0x6e,0x80,0x86,0x7d,0x6c,0x5b,0x55,0x5c,0x69,0x75,0x7b,0x78,0x71,0x6a,0x65,0x64,
0x64,0x5f,0x55,0x48,0x39,0x32,0x34,0x3f,0x50,0x64,0x79,0x89,0x92,0x97,0x98,0x96,
0x98,0x9b,0x9c,0x9e,0x9a,0x91,0x83,0x73,0x65,0x5a,0x5f,0x68,0x72,0x7d,0x82,0x7d,
0x76,0x69,0x62,0x61,0x64,0x68,0x6f,0x72,0x74,0x7b,0x84,0x90,0x99,0x9c,0x94,0x86,
0x72,0x5f,0x4f,0x44,0x3c,0x37,0x35,0x36,0x3e,0x50,0x65,0x77,0x81,0x81,0x79,0x6a,
0x5e,0x56,0x53,0x51,0x4b,0x41,0x39,0x2d,0x28,0x2d,0x34,0x3a,0x3d,0x3c,0x37,0x33,
0x32,0x32,0x34,0x38,0x3b,0x3d,0x3d,0x3c,0x3a,0x39,0x37,0x34,0x35,0x35,0x36,0x36,
0x36,0x36,0x39,0x3b,0x3c,0x3c,0x39,0x35,0x33,0x36,0x3d,0x47,0x54,0x62,0x6f,0x7c,
0x85,0x8c,0x93,0x9b,0xa0,0xa5,0xa4,0xa1,0x9b,0x9c,0x9d,0x9e,0xa0,0xa1,0xa3,0xa4,
0xa0,0x9c,0x9c,0x9b,0x99,0x99,0x98,0x91,0x87,0x79,0x6a,0x5d,0x51,0x49,0x44,0x41,
0x3d,0x39,0x35,0x33,0x34,0x39,0x3e,0x3d,0x39,0x31,0x2c,0x30,0x3c,0x4c,0x61,0x75,
0x80,0x81,0x7b,0x71,0x66,0x5f,0x57,0x4f,0x48,0x41,0x38,0x35,0x30,0x30,0x35,0x3e,
0x49,0x57,0x65,0x71,0x76,0x76,0x72,0x69,0x5d,0x55,0x51,0x4d,0x46,0x3c,0x32,0x28,
0x24,0x2b,0x34,0x3e,0x43,0x41,0x3b,0x34,0x31,0x38,0x47,0x5a,0x6a,0x76,0x81,0x8b,
0x91,0x96,0x9b,0x9e,0xa1,0xa0,0x9e,0x9c,0x9b,0x9c,0x9d,0x9e,0x9c,0x96,0x8a,0x7b,
0x6c,0x61,0x5c,0x60,0x69,0x74,0x7c,0x7d,0x76,0x6a,0x60,0x5d,0x60,0x68,0x73,0x7a,
0x78,0x73,0x68,0x60,0x5f,0x63,0x69,0x71,0x73,0x73,0x76,0x7a,0x82,0x8e,0x9b,0xa1,
0x9e,0x92,0x7f,0x6b,0x5d,0x57,0x5a,0x65,0x72,0x7e,0x86,0x8a,0x8f,0x97,0x9e,0xa2,
0xa2,0x9f,0x9b,0x97,0x96,0x99,0x9c,0x9b,0x94,0x89,0x7c,0x6d,0x5d,0x52,0x4a,0x43,
0x3f,0x3b,0x38,0x35,0x36,0x34,0x34,0x39,0x42,0x4f,0x61,0x70,0x79,0x7a,0x72,0x66,
0x5b,0x54,0x50,0x4e,0x48,0x3f,0x34,0x2b,0x29,0x2f,0x39,0x43,0x47,0x43,0x39,0x2e,
0x2e,0x3b,0x4f,0x64,0x74,0x7b,0x79,0x71,0x64,0x5d,0x57,0x51,0x48,0x3e,0x34,0x2c,
0x33,0x42,0x57,0x6f,0x7f,0x83,0x7e,0x70,0x63,0x5c,0x5d,0x61,0x68,0x6f,0x75,0x7a,
0x81,0x89,0x95,0x9f,0xa5,0xa6,0xa4,0x9d,0x94,0x86,0x77,0x66,0x59,0x51,0x4a,0x46,
0x40,0x3d,0x39,0x35,0x31,0x31,0x37,0x3a,0x3b,0x3c,0x3a,0x36,0x35,0x34,0x36,0x39,
0x3b,0x3b,0x39,0x37,0x36,0x37,0x38,0x39,0x36,0x31,0x2f,0x32,0x3f,0x51,0x65,0x75,
0x7b,0x78,0x72,0x6a,0x63,0x5e,0x5a,0x52,0x46,0x3a,0x32,0x34,0x44,0x5b,0x72,0x81,
0x82,0x77,0x6a,0x5a,0x51,0x4d,0x4b,0x44,0x37,0x32,0x33,0x40,0x56,0x6e,0x80,0x86,
0x7d,0x6c,0x5e,0x59,0x5d,0x67,0x6f,0x76,0x7a,0x7e,0x84,0x8c,0x98,0xa3,0xa9,0xa7,
0xa1,0x9a,0x96,0x94,0x96,0x99,0x98,0x94,0x8a,0x7c,0x6c,0x5e,0x53,0x4a,0x3f,0x38,
0x31,0x2d,0x2c,0x2c,0x2d,0x33,0x36,0x35,0x36,0x34,0x34,0x36,0x36,0x36,0x37,0x38,
0x39,0x3c,0x44,0x51,0x61,0x72,0x80,0x8a,0x93,0x98,0x98,0x92,0x86,0x77,0x67,0x57,
0x4a,0x42,0x40,0x3f,0x3e,0x3b,0x38,0x39,0x3a,0x3c,0x3a,0x3c,0x36,0x30,0x2f,0x2f,
0x2f,0x31,0x30,0x31,0x33,0x37,0x38,0x36,0x37,0x38,0x39,0x3a,0x39,0x38,0x3b,0x3a,
0x37,0x35,0x34,0x36,0x37,0x38,0x37,0x38,0x38,0x39,0x39,0x39,0x38,0x37,0x35,0x34,
// Line 18
0x3c,0x3c,0x3b,0x39,0x36,0x35,0x34,0x36,0x37,0x38,0x38,0x39,0x39,0x38,0x37,0x35,
0x33,0x34,0x39,0x3b,0x3b,0x37,0x34,0x2e,0x2e,0x30,0x36,0x3e,0x41,0x3d,0x35,0x2d,
0x2a,0x2e,0x37,0x41,0x46,0x42,0x3a,0x2f,0x29,0x2a,0x36,0x45,0x4c,0x47,0x3c,0x2d,
0x23,0x26,0x32,0x41,0x4a,0x46,0x39,0x2c,0x24,0x29,0x35,0x44,0x4a,0x45,0x3a,0x2d,
0x24,0x29,0x36,0x43,0x4a,0x46,0x3a,0x2d,0x24,0x27,0x34,0x42,0x49,0x46,0x39,0x2a,
0x23,0x29,0x36,0x44,0x4e,0x49,0x3a,0x2d,0x25,0x27,0x34,0x43,0x48,0x42,0x37,0x2a,
0x1f,0x27,0x36,0x44,0x4e,0x4a,0x3c,0x2e,0x24,0x29,0x36,0x44,0x4b,0x47,0x37,0x27,
0x20,0x27,0x37,0x46,0x4e,0x48,0x39,0x2b,0x22,0x26,0x37,0x47,0x4c,0x47,0x36,0x26,
0x1e,0x23,0x31,0x40,0x49,0x44,0x37,0x27,0x21,0x2a,0x3d,0x4f,0x58,0x57,0x4c,0x3f,
0x3b,0x41,0x50,0x60,0x64,0x5b,0x4e,0x40,0x39,0x3e,0x4d,0x5b,0x60,0x5b,0x4e,0x40,
0x3c,0x42,0x51,0x60,0x64,0x5d,0x4e,0x40,0x37,0x3d,0x4c,0x5d,0x61,0x5d,0x4c,0x3c,
0x38,0x40,0x50,0x61,0x67,0x5f,0x51,0x41,0x39,0x3f,0x4e,0x5d,0x64,0x5e,0x4e,0x3e,
0x37,0x3b,0x4a,0x5a,0x62,0x5e,0x53,0x43,0x3b,0x3f,0x4c,0x5c,0x64,0x5e,0x4f,0x40,
0x39,0x3e,0x4b,0x59,0x60,0x5c,0x4f,0x3f,0x36,0x3b,0x49,0x57,0x61,0x5d,0x51,0x45,
0x40,0x44,0x55,0x67,0x71,0x6c,0x64,0x55,0x4e,0x56,0x65,0x74,0x7b,0x76,0x69,0x5b,
0x53,0x56,0x64,0x73,0x78,0x74,0x67,0x58,0x50,0x55,0x62,0x71,0x78,0x74,0x65,0x56,
0x4e,0x53,0x62,0x71,0x78,0x74,0x65,0x57,0x50,0x56,0x65,0x74,0x7a,0x73,0x64,0x55,
0x4e,0x54,0x62,0x71,0x78,0x74,0x66,0x56,0x50,0x55,0x62,0x71,0x78,0x73,0x64,0x53,
0x4a,0x50,0x61,0x71,0x77,0x75,0x69,0x5a,0x54,0x56,0x63,0x74,0x7d,0x77,0x68,0x58,
0x4f,0x52,0x60,0x6d,0x75,0x73,0x69,0x5a,0x56,0x5c,0x6c,0x80,0x8a,0x87,0x7d,0x70,
0x67,0x6a,0x78,0x88,0x8e,0x87,0x78,0x6a,0x64,0x6a,0x78,0x88,0x8f,0x8b,0x7f,0x70,
0x68,0x6e,0x7d,0x8a,0x8f,0x89,0x7b,0x6c,0x64,0x68,0x76,0x86,0x8e,0x89,0x7b,0x6d,
0x67,0x6c,0x78,0x86,0x8d,0x86,0x77,0x69,0x61,0x67,0x77,0x86,0x8a,0x85,0x7b,0x6d,
0x64,0x6b,0x7a,0x86,0x8d,0x88,0x7c,0x6f,0x69,0x6d,0x7c,0x89,0x90,0x8b,0x7e,0x6e,
0x67,0x6c,0x7a,0x88,0x93,0x8b,0x7e,0x71,0x6a,0x6f,0x7d,0x8c,0x92,0x90,0x86,0x7c,
0x77,0x7d,0x8c,0x9c,0xa5,0xa1,0x94,0x85,0x7e,0x82,0x91,0x9f,0xa4,0x9f,0x92,0x83,
0x7d,0x82,0x8f,0x9c,0xa5,0x9f,0x8e,0x7f,0x78,0x7e,0x8f,0x9d,0xa3,0x9f,0x91,0x82,
0x7b,0x7f,0x8e,0x9e,0xa5,0xa1,0x92,0x83,0x79,0x7d,0x8c,0x9c,0xa3,0x9f,0x91,0x83,
0x7c,0x7f,0x8b,0x9b,0xa3,0x9f,0x91,0x80,0x78,0x7e,0x8c,0x9b,0xa1,0x9d,0x92,0x85,
0x7e,0x82,0x8f,0x9f,0xa6,0xa4,0x97,0x88,0x7f,0x85,0x93,0xa1,0xa7,0xa2,0x95,0x88,
0x82,0x85,0x91,0xa0,0xa8,0xa7,0x9d,0x92,0x8c,0x92,0xa0,0xaf,0xb7,0xb5,0xaa,0x99,
0x94,0x97,0xa3,0xb0,0xb7,0xb3,0xa9,0x97,0x8e,0x94,0xa4,0xb3,0xb9,0xb5,0xa9,0x9b,
0x94,0x9a,0xa7,0xb7,0xbb,0xb3,0xa6,0x98,0x91,0x96,0xa4,0xb1,0xb7,0xb0,0xa3,0x96,
0x92,0x98,0xa5,0xb3,0xba,0xb5,0xa7,0x99,0x94,0x99,0xa6,0xb2,0xb6,0xaf,0xa3,0x97,
0x92,0x97,0xa3,0xb0,0xb3,0xae,0xa4,0x99,0x94,0x9a,0xa8,0xb3,0xb7,0xb1,0xa4,0x9b,
0x95,0x98,0xa5,0xb0,0xb3,0xb0,0xa7,0x9d,0x99,0x9b,0xa3,0xa9,0xac,0xaa,0xa4,0x9f,
0x9c,0x9f,0xa5,0xa8,0xa9,0xa7,0xa5,0xa3,0xa0,0xa0,0xa1,0xa5,0xa6,0xa7,0xa8,0xa8,
0xa7,0xa7,0xa9,0xaa,0xaa,0xa8,0xa5,0xa4,0xa6,0xa4,0xa4,0xa3,0xa3,0xa5,0xa7,0xa7,
0xa5,0xa6,0xa7,0xa7,0xa6,0xa8,0xa8,0xa7,0xa7,0xa5,0xa3,0xa2,0xa3,0xa4,0xa5,0xa3,
0xa0,0xa1,0xa5,0xa9,0xa9,0xab,0xaa,0xa9,0xaa,0xa9,0xa7,0xa8,0xa6,0xa5,0xa4,0xa2,
0xa0,0xa0,0xa3,0xa4,0xa5,0xa5,0xa5,0xa4,0xa3,0xa0,0x9c,0x98,0x92,0x8a,0x80,0x74,
0x68,0x5e,0x54,0x4b,0x42,0x3c,0x38,0x38,0x38,0x39,0x39,0x39,0x38,0x39,0x3b,0x3a,
0x39,0x39,0x39,0x37,0x35,0x36,0x37,0x38,0x38,0x37,0x37,0x37,0x37,0x37,0x39,0x38,
0x37,0x37,0x39,0x3a,0x39,0x37,0x37,0x3a,0x39,0x37,0x36,0x36,0x35,0x36,0x36,0x36,
0x36,0x36,0x35,0x34,0x36,0x36,0x37,0x37,0x37,0x37,0x37,0x36,0x36,0x36,0x36,0x35,
0x36,0x36,0x35,0x36,0x38,0x39,0x3a,0x3b,0x3a,0x39,0x39,0x37,0x37,0x37,0x37,0x37,
0x36,0x36,0x34,0x35,0x36,0x37,0x37,0x36,0x36,0x34,0x35,0x35,0x36,0x37,0x37,0x37,
0x39,0x37,0x37,0x37,0x39,0x39,0x3a,0x39,0x38,0x37,0x38,0x39,0x39,0x3c,0x3d,0x3a,
0x37,0x32,0x34,0x3e,0x50,0x67,0x7f,0x91,0x9b,0x9c,0x94,0x87,0x79,0x6d,0x64,0x58,
0x4c,0x40,0x36,0x31,0x2f,0x35,0x3d,0x41,0x40,0x3d,0x37,0x31,0x2d,0x2c,0x2e,0x32,
0x36,0x38,0x37,0x39,0x3a,0x39,0x37,0x35,0x34,0x36,0x36,0x36,0x36,0x36,0x37,0x39,
0x39,0x37,0x34,0x37,0x37,0x39,0x3b,0x3c,0x3a,0x3b,0x37,0x32,0x35,0x39,0x3e,0x41,
0x3f,0x3a,0x36,0x36,0x3c,0x49,0x55,0x5a,0x56,0x4a,0x3f,0x3e,0x48,0x5b,0x6c,0x73,
0x6b,0x58,0x47,0x41,0x4e,0x6a,0x83,0x8e,0x83,0x68,0x4f,0x4a,0x5d,0x7e,0x9b,0xa7,
0x99,0x79,0x5b,0x51,0x61,0x81,0x9d,0xa5,0x96,0x76,0x58,0x4a,0x5b,0x7b,0x97,0x9d,
0x8c,0x6c,0x53,0x4b,0x56,0x6d,0x80,0x85,0x76,0x5d,0x47,0x41,0x49,0x57,0x61,0x61,
0x54,0x44,0x37,0x36,0x3c,0x46,0x4c,0x4b,0x46,0x3e,0x37,0x34,0x36,0x37,0x3a,0x3a,
0x39,0x36,0x33,0x31,0x33,0x33,0x33,0x31,0x38,0x37,0x37,0x37,0x38,0x38,0x3b,0x3b,
0x3a,0x3c,0x3d,0x3d,0x3b,0x39,0x37,0x37,0x37,0x37,0x37,0x37,0x36,0x35,0x36,0x36,
0x36,0x36,0x36,0x37,0x37,0x36,0x35,0x34,0x33,0x34,0x34,0x34,0x34,0x35,0x36,0x36,
0x35,0x37,0x37,0x39,0x3c,0x3b,0x39,0x38,0x38,0x37,0x35,0x35,0x34,0x35,0x35,0x34,
0x34,0x36,0x37,0x37,0x37,0x37,0x38,0x39,0x38,0x36,0x37,0x38,0x37,0x36,0x34,0x33,
0x33,0x33,0x34,0x35,0x38,0x3d,0x44,0x4c,0x56,0x64,0x75,0x85,0x92,0x9f,0xac,0xb5,
0xba,0xbc,0xbe,0xc0,0xc1,0xc0,0xbe,0xbf,0xbe,0xbd,0xc0,0xc2,0xc3,0xc4,0xc3,0xc1,
0xc0,0xc0,0xc0,0xbf,0xbe,0xbc,0xbb,0xba,0xbb,0xbc,0xbd,0xbe,0xbc,0xbc,0xba,0xb9,
0xba,0xbb,0xbc,0xbd,0xbd,0xbd,0xbc,0xbb,0xbb,0xbc,0xbe,0xbe,0xbd,0xbf,0xbe,0xbd,
0xbe,0xbd,0xbe,0xbf,0xbe,0xbc,0xbd,0xbe,0xbd,0xbc,0xbc,0xbc,0xbe,0xc0,0xbf,0xbd,
0xbc,0xbc,0xbc,0xbc,0xbd,0xbc,0xbb,0xba,0xb7,0xb8,0xba,0xbc,0xbd,0xbe,0xbd,0xbc,
0xbc,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xbc,0xbd,0xbc,0xbd,0xbd,0xbe,0xbd,
0xbb,0xba,0xba,0xbc,0xbd,0xbd,0xbe,0xbe,0xbe,0xbd,0xbc,0xbb,0xbb,0xbc,0xbb,0xba,
0xb9,0xbb,0xbc,0xbc,0xbb,0xbc,0xbf,0xbe,0xba,0xba,0xba,0xba,0xbb,0xba,0xbb,0xbb,
0xba,0xba,0xba,0xbb,0xbc,0xbb,0xbc,0xbb,0xbc,0xbf,0xbf,0xbf,0xbe,0xbd,0xbc,0xbc,
0xbb,0xbc,0xbe,0xbf,0xbe,0xbd,0xbc,0xbd,0xbe,0xbe,0xbe,0xbe,0xbf,0xbd,0xbb,0xb8,
0xb7,0xb8,0xbb,0xbc,0xbd,0xbd,0xbc,0xb9,0xb8,0xba,0xbd,0xbf,0xbe,0xbd,0xbc,0xbb,
0xba,0xba,0xbc,0xbc,0xbc,0xbc,0xba,0xb9,0xb9,0xba,0xba,0xbc,0xbc,0xbc,0xba,0xba,
0xb4,0xb7,0xba,0xbf,0xc1,0xc2,0xbd,0xbc,0xb9,0xb8,0xb7,0xb7,0xb9,0xb8,0xb9,0xb9,
0xb9,0xba,0xba,0xb9,0xb8,0xb9,0xbb,0xbc,0xbc,0xba,0xb9,0xb9,0xb7,0xb6,0xb6,0xb7,
0xb9,0xbb,0xbb,0xbb,0xbc,0xbb,0xbc,0xbc,0xbd,0xbd,0xbc,0xbc,0xba,0xba,0xbc,0xbd,
0xbc,0xbc,0xbb,0xbb,0xbc,0xbc,0xbd,0xbd,0xbc,0xba,0xba,0xbd,0xbe,0xbe,0xbd,0xbd,
0xbc,0xbc,0xbb,0xbc,0xbf,0xbe,0xbc,0xbc,0xbc,0xbe,0xbf,0xbf,0xbe,0xbe,0xc0,0xbf,
0xbe,0xbe,0xbe,0xbe,0xbe,0xbd,0xbc,0xbb,0xba,0xbb,0xbc,0xbc,0xbc,0xbc,0xbc,0xba,
0xb9,0xbb,0xba,0xbb,0xbc,0xbd,0xbc,0xbc,0xb9,0xba,0xbc,0xbe,0xbd,0xbd,0xbd,0xbc,
0xbc,0xbc,0xbc,0xbc,0xbd,0xbe,0xbd,0xbc,0xbc,0xbd,0xc0,0xc0,0xbe,0xbd,0xbc,0xbc,
0xbc,0xbb,0xbc,0xb9,0xbc,0xb9,0xb9,0xba,0xba,0xb9,0xbb,0xbb,0xbc,0xbd,0xbe,0xbf,
0xc1,0xc1,0xc0,0xc0,0xbe,0xbe,0xbf,0xc0,0xbf,0xbf,0xc0,0xc0,0xbf,0xbe,0xbe,0xbe,
0xbf,0xbf,0xbe,0xbe,0xbd,0xbc,0xbc,0xbc,0xbd,0xbe,0xbd,0xbc,0xbc,0xbc,0xbd,0xbe,
0xbe,0xbe,0xbe,0xbe,0xbd,0xbe,0xbf,0xbe,0xbd,0xbc,0xba,0xb9,0xb8,0xb8,0xba,0xbd,
0xbd,0xbd,0xbc,0xbc,0xbb,0xbb,0xbf,0xc0,0xbe,0xbd,0xbb,0xb9,0xb9,0xba,0xbd,0xbe,
0xbf,0xbd,0xbd,0xbd,0xbd,0xbc,0xc0,0xbe,0xbd,0xbd,0xbd,0xbc,0xbd,0xbc,0xbc,0xbe,
0xbe,0xbe,0xbc,0xbe,0xbd,0xbd,0xbd,0xbf,0xbe,0xbf,0xbe,0xbd,0xbd,0xbd,0xbd,0xbc,
0xb9,0xb9,0xba,0xba,0xb9,0xb8,0xb9,0xb9,0xbb,0xbc,0xbd,0xbd,0xbd,0xbc,0xbc,0xbe,
0xbf,0xbe,0xbd,0xbc,0xbb,0xbc,0xba,0xb9,0xba,0xbb,0xba,0xba,0xba,0xbd,0xbe,0xc1,
0xc1,0xbf,0xbe,0xbd,0xba,0xb9,0xb8,0xb8,0xba,0xba,0xb9,0xba,0xba,0xba,0xbc,0xbe,
0xc0,0xc1,0xbf,0xbc,0xbb,0xbd,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbf,0xbe,0xbd,
0xbc,0xbc,0xbc,0xbd,0xba,0xb7,0xb0,0xa8,0xa0,0x97,0x8b,0x7e,0x70,0x62,0x56,0x4c,
0x44,0x3d,0x38,0x35,0x32,0x32,0x33,0x36,0x37,0x36,0x36,0x37,0x36,0x35,0x35,0x37,
// Line 19
0x35,0x32,0x35,0x35,0x35,0x36,0x37,0x38,0x36,0x35,0x36,0x36,0x36,0x36,0x37,0x3a,
0x3c,0x3e,0x43,0x47,0x4a,0x50,0x54,0x58,0x5a,0x5e,0x61,0x63,0x63,0x63,0x62,0x63,
0x62,0x61,0x61,0x60,0x60,0x61,0x60,0x60,0x62,0x62,0x62,0x63,0x62,0x61,0x62,0x62,
0x64,0x63,0x63,0x61,0x60,0x61,0x62,0x62,0x62,0x61,0x61,0x61,0x61,0x61,0x63,0x64,
0x63,0x64,0x63,0x62,0x5f,0x61,0x5f,0x5e,0x5d,0x5e,0x5e,0x62,0x61,0x5e,0x60,0x61,
0x62,0x64,0x66,0x66,0x66,0x65,0x64,0x63,0x63,0x63,0x63,0x64,0x62,0x61,0x61,0x5e,
0x5c,0x5f,0x62,0x63,0x64,0x63,0x62,0x63,0x62,0x63,0x64,0x64,0x62,0x62,0x62,0x61,
0x60,0x60,0x5f,0x5f,0x5f,0x5f,0x5f,0x5e,0x5c,0x5e,0x60,0x62,0x61,0x62,0x62,0x60,
0x5e,0x5d,0x5e,0x61,0x62,0x61,0x61,0x64,0x64,0x64,0x65,0x66,0x66,0x68,0x69,0x68,
0x64,0x64,0x62,0x62,0x64,0x66,0x66,0x68,0x66,0x64,0x66,0x67,0x69,0x6b,0x6b,0x6a,
0x69,0x69,0x69,0x69,0x69,0x66,0x65,0x65,0x66,0x68,0x6b,0x6d,0x6d,0x6d,0x6d,0x6d,
0x6d,0x6f,0x71,0x71,0x71,0x71,0x71,0x72,0x73,0x74,0x76,0x76,0x76,0x77,0x77,0x74,
0x75,0x76,0x75,0x74,0x73,0x75,0x78,0x7a,0x7a,0x79,0x7a,0x7c,0x7d,0x7f,0x81,0x82,
0x84,0x84,0x84,0x87,0x89,0x8a,0x8a,0x8a,0x89,0x8c,0x8d,0x8e,0x8e,0x8f,0x90,0x90,
0x8f,0x8e,0x90,0x91,0x90,0x8d,0x8e,0x8f,0x90,0x90,0x8f,0x8e,0x8d,0x8d,0x8d,0x8c,
0x89,0x86,0x82,0x7f,0x7c,0x78,0x76,0x73,0x6f,0x6c,0x68,0x64,0x60,0x5b,0x57,0x55,
0x52,0x4f,0x4a,0x46,0x41,0x3c,0x3a,0x37,0x33,0x31,0x2d,0x2a,0x26,0x26,0x27,0x26,
0x26,0x26,0x27,0x2a,0x2c,0x2f,0x36,0x39,0x3c,0x41,0x47,0x4c,0x53,0x57,0x5b,0x62,
0x69,0x6e,0x73,0x78,0x7e,0x85,0x8b,0x8d,0x8f,0x93,0x96,0x97,0x96,0x94,0x93,0x92,
0x8e,0x88,0x82,0x7c,0x78,0x71,0x69,0x5f,0x57,0x52,0x4d,0x46,0x3e,0x39,0x35,0x32,
0x2f,0x2c,0x2e,0x2f,0x2f,0x30,0x33,0x36,0x3a,0x3e,0x43,0x4b,0x54,0x5d,0x64,0x6f,
0x76,0x7d,0x87,0x8e,0x94,0x98,0x97,0x94,0x90,0x8a,0x86,0x7f,0x76,0x6d,0x62,0x58,
0x4d,0x46,0x42,0x3d,0x37,0x33,0x31,0x30,0x32,0x32,0x34,0x38,0x3d,0x44,0x4c,0x56,
0x5f,0x6a,0x76,0x7f,0x84,0x8d,0x90,0x92,0x91,0x8c,0x84,0x7c,0x72,0x68,0x5e,0x55,
0x4d,0x44,0x3c,0x36,0x31,0x30,0x30,0x30,0x36,0x39,0x3f,0x4c,0x58,0x65,0x72,0x7e,
0x86,0x8c,0x90,0x91,0x90,0x88,0x7d,0x73,0x67,0x5b,0x4d,0x45,0x3e,0x37,0x33,0x30,
0x31,0x36,0x3a,0x41,0x4c,0x5a,0x69,0x75,0x7e,0x84,0x89,0x8a,0x88,0x83,0x7c,0x72,
0x64,0x56,0x4a,0x40,0x3b,0x37,0x35,0x36,0x37,0x3d,0x46,0x51,0x5e,0x6f,0x7d,0x88,
0x8e,0x8e,0x8b,0x86,0x7d,0x71,0x62,0x55,0x48,0x3c,0x32,0x2c,0x2b,0x2f,0x38,0x43,
0x51,0x62,0x74,0x82,0x8b,0x8f,0x8e,0x89,0x7e,0x72,0x65,0x56,0x48,0x3e,0x36,0x33,
0x34,0x39,0x41,0x51,0x62,0x74,0x80,0x87,0x8b,0x8a,0x86,0x7b,0x6e,0x62,0x56,0x48,
0x3a,0x32,0x2f,0x30,0x38,0x45,0x57,0x6c,0x7d,0x84,0x8b,0x87,0x7d,0x72,0x64,0x57,
0x4b,0x41,0x38,0x33,0x32,0x3a,0x49,0x5b,0x6d,0x7f,0x8a,0x8c,0x85,0x7b,0x6f,0x62,
0x56,0x4a,0x3f,0x37,0x33,0x36,0x42,0x54,0x69,0x7d,0x89,0x8d,0x88,0x7d,0x70,0x60,
0x54,0x48,0x3c,0x37,0x35,0x39,0x48,0x5a,0x6d,0x7e,0x88,0x8a,0x82,0x73,0x63,0x56,
0x4a,0x40,0x39,0x36,0x3b,0x48,0x5c,0x6f,0x7d,0x85,0x85,0x7d,0x70,0x60,0x52,0x46,
0x3e,0x39,0x3a,0x45,0x55,0x69,0x7a,0x83,0x83,0x7c,0x6f,0x61,0x56,0x48,0x3e,0x39,
0x3a,0x44,0x54,0x68,0x78,0x84,0x88,0x81,0x71,0x5e,0x50,0x44,0x3e,0x3d,0x41,0x4c,
0x5b,0x6b,0x78,0x7e,0x7c,0x75,0x68,0x57,0x46,0x3c,0x3b,0x42,0x4b,0x58,0x67,0x76,
0x7e,0x7e,0x74,0x64,0x54,0x4c,0x46,0x45,0x4a,0x54,0x62,0x6e,0x76,0x79,0x75,0x6c,
0x60,0x51,0x46,0x42,0x45,0x50,0x5e,0x6a,0x72,0x74,0x72,0x6e,0x62,0x53,0x4a,0x48,
0x4c,0x51,0x5e,0x68,0x6e,0x72,0x6e,0x64,0x5d,0x51,0x4a,0x4b,0x50,0x5a,0x64,0x6f,
0x72,0x71,0x6c,0x61,0x55,0x4d,0x49,0x4b,0x52,0x5b,0x64,0x6b,0x6d,0x68,0x62,0x58,
0x50,0x4e,0x53,0x59,0x62,0x69,0x6f,0x6f,0x69,0x62,0x5c,0x58,0x55,0x56,0x5b,0x61,
0x65,0x69,0x69,0x66,0x61,0x5b,0x56,0x56,0x58,0x5d,0x61,0x65,0x64,0x62,0x60,0x5a,
0x56,0x55,0x57,0x5c,0x62,0x66,0x66,0x63,0x5c,0x55,0x51,0x53,0x5a,0x62,0x68,0x69,
0x63,0x5e,0x57,0x51,0x52,0x58,0x61,0x69,0x6e,0x6d,0x69,0x60,0x56,0x51,0x50,0x57,
0x61,0x69,0x6d,0x6c,0x66,0x5b,0x51,0x4c,0x4f,0x59,0x67,0x71,0x74,0x6f,0x64,0x57,
0x4d,0x4c,0x55,0x62,0x71,0x76,0x72,0x68,0x57,0x46,0x3f,0x46,0x57,0x6c,0x79,0x7d,
0x74,0x62,0x4f,0x43,0x44,0x53,0x67,0x79,0x81,0x7b,0x69,0x54,0x43,0x40,0x4d,0x60,
0x74,0x7d,0x78,0x67,0x4e,0x3b,0x37,0x46,0x60,0x77,0x83,0x7a,0x68,0x51,0x3f,0x3c,
0x4b,0x64,0x7b,0x86,0x7d,0x65,0x4a,0x39,0x39,0x4d,0x69,0x7e,0x84,0x78,0x5f,0x44,
0x37,0x41,0x5a,0x74,0x83,0x7f,0x6b,0x50,0x3a,0x37,0x48,0x65,0x7e,0x86,0x7a,0x60,
0x43,0x35,0x3f,0x5a,0x76,0x87,0x83,0x6b,0x4c,0x39,0x3a,0x50,0x6d,0x82,0x83,0x6f,
0x51,0x3b,0x39,0x4e,0x6d,0x83,0x89,0x78,0x58,0x3f,0x36,0x45,0x63,0x7c,0x81,0x70,
0x53,0x39,0x32,0x44,0x63,0x7d,0x84,0x73,0x56,0x3e,0x3b,0x4e,0x6c,0x82,0x85,0x73,
0x54,0x3d,0x3c,0x50,0x6b,0x7f,0x7f,0x6b,0x4d,0x3b,0x40,0x58,0x74,0x83,0x7b,0x64,
0x46,0x3c,0x4a,0x65,0x7d,0x82,0x75,0x5b,0x45,0x43,0x57,0x71,0x7f,0x7a,0x63,0x4b,
0x40,0x4a,0x63,0x78,0x7d,0x70,0x56,0x43,0x42,0x52,0x69,0x78,0x73,0x61,0x4c,0x45,
0x4e,0x64,0x78,0x7b,0x6d,0x58,0x4c,0x50,0x62,0x73,0x79,0x72,0x5f,0x4f,0x4e,0x5b,
0x6c,0x76,0x71,0x61,0x52,0x50,0x5a,0x69,0x75,0x74,0x67,0x59,0x52,0x57,0x63,0x6d,
0x6c,0x60,0x52,0x4d,0x50,0x5f,0x6b,0x6c,0x66,0x5c,0x55,0x5c,0x65,0x6d,0x71,0x6b,
0x5e,0x55,0x54,0x5e,0x69,0x6d,0x67,0x5e,0x57,0x59,0x60,0x69,0x6d,0x68,0x60,0x58,
0x57,0x5e,0x64,0x68,0x64,0x5d,0x57,0x57,0x5c,0x62,0x66,0x64,0x5e,0x58,0x5a,0x60,
0x66,0x6b,0x65,0x5e,0x5b,0x5c,0x60,0x65,0x67,0x64,0x5e,0x5a,0x5a,0x5e,0x65,0x68,
0x64,0x61,0x5e,0x5f,0x63,0x66,0x67,0x64,0x5f,0x5b,0x5b,0x5e,0x63,0x64,0x62,0x5e,
0x5c,0x5c,0x62,0x66,0x69,0x66,0x61,0x5c,0x5b,0x5e,0x62,0x64,0x63,0x61,0x5f,0x5e,
0x60,0x62,0x64,0x62,0x62,0x60,0x5f,0x61,0x61,0x62,0x62,0x5f,0x5c,0x5e,0x61,0x62,
0x61,0x60,0x5f,0x61,0x60,0x61,0x62,0x62,0x60,0x5c,0x5c,0x5f,0x62,0x62,0x62,0x60,
0x61,0x60,0x61,0x63,0x64,0x64,0x63,0x61,0x5e,0x5a,0x5f,0x61,0x62,0x62,0x62,0x5f,
0x62,0x5f,0x5c,0x5f,0x62,0x63,0x63,0x61,0x60,0x60,0x5e,0x5c,0x5c,0x5e,0x61,0x62,
0x62,0x62,0x61,0x5f,0x5f,0x60,0x62,0x65,0x66,0x67,0x64,0x62,0x61,0x60,0x61,0x62,
0x61,0x60,0x5f,0x5e,0x5c,0x5b,0x5f,0x5f,0x5e,0x60,0x60,0x60,0x5e,0x5e,0x5e,0x61,
0x62,0x62,0x60,0x5f,0x5f,0x60,0x62,0x64,0x64,0x66,0x64,0x63,0x63,0x64,0x65,0x68,
0x65,0x62,0x62,0x61,0x61,0x62,0x63,0x63,0x63,0x64,0x64,0x64,0x63,0x63,0x62,0x62,
0x61,0x61,0x61,0x62,0x62,0x62,0x62,0x62,0x61,0x62,0x62,0x61,0x62,0x61,0x60,0x61,
0x60,0x5f,0x60,0x61,0x61,0x60,0x60,0x60,0x62,0x62,0x63,0x62,0x61,0x5e,0x5c,0x5e,
0x5e,0x5f,0x60,0x5f,0x5d,0x5e,0x5f,0x60,0x62,0x61,0x62,0x62,0x62,0x62,0x60,0x64,
0x62,0x62,0x61,0x61,0x61,0x62,0x62,0x61,0x61,0x61,0x61,0x62,0x61,0x62,0x64,0x66,
0x64,0x5f,0x5e,0x5d,0x5d,0x5f,0x5f,0x61,0x61,0x5f,0x5e,0x5e,0x5e,0x60,0x62,0x62,
0x5f,0x5e,0x60,0x60,0x5f,0x61,0x62,0x62,0x62,0x60,0x60,0x61,0x61,0x5f,0x60,0x60,
0x5f,0x5f,0x5e,0x5e,0x60,0x61,0x61,0x5d,0x61,0x62,0x61,0x62,0x62,0x61,0x61,0x5f,
0x5e,0x5f,0x60,0x5f,0x5d,0x5c,0x5e,0x60,0x60,0x5f,0x5e,0x5e,0x5d,0x5c,0x5d,0x5e,
0x5e,0x5f,0x60,0x60,0x60,0x62,0x63,0x64,0x61,0x5c,0x5c,0x5f,0x62,0x5f,0x62,0x61,
0x5f,0x62,0x62,0x62,0x63,0x62,0x5f,0x5d,0x5c,0x5e,0x5f,0x61,0x61,0x61,0x60,0x5e,
0x5c,0x5d,0x5e,0x61,0x62,0x60,0x5d,0x5c,0x5c,0x5c,0x5e,0x60,0x61,0x5f,0x5c,0x5c,
0x5c,0x5e,0x61,0x62,0x65,0x63,0x63,0x64,0x64,0x62,0x63,0x61,0x5e,0x5c,0x5c,0x5c,
0x5a,0x5b,0x5a,0x5c,0x60,0x62,0x62,0x64,0x66,0x67,0x68,0x66,0x64,0x63,0x61,0x5f,
0x5e,0x5c,0x5e,0x5f,0x5f,0x5e,0x5e,0x5f,0x60,0x60,0x5f,0x5d,0x5a,0x55,0x4e,0x48,
0x44,0x3f,0x39,0x35,0x35,0x35,0x2f,0x2f,0x2f,0x31,0x34,0x37,0x37,0x3b,0x3b,0x39,
0x38,0x37,0x36,0x38,0x39,0x39,0x37,0x33,0x30,0x30,0x30,0x32,0x35,0x37,0x38,0x37,
0x36,0x35,0x35,0x37,0x36,0x35,0x35,0x33,0x31,0x30,0x31,0x32,0x33,0x34,0x33,0x35,
0x36,0x36,0x35,0x37,0x36,0x35,0x37,0x38,0x38,0x39,0x39,0x37,0x36,0x35,0x35,0x35,
0x34,0x34,0x34,0x35,0x33,0x33,0x33,0x35,0x37,0x39,0x3a,0x3b,0x3d,0x3b,0x37,0x35,
0x34,0x35,0x35,0x32,0x2f,0x30,0x32,0x34,0x34,0x35,0x37,0x36,0x37,0x36,0x36,0x37,
0x36,0x34,0x33,0x31,0x2f,0x2e,0x2f,0x2f,0x30,0x30,0x30,0x2f,0x2f,0x30,0x32,0x36,
// Line 20
0x37,0x37,0x38,0x38,0x38,0x36,0x36,0x35,0x34,0x36,0x36,0x35,0x36,0x38,0x39,0x37,
0x35,0x35,0x36,0x38,0x39,0x39,0x39,0x3b,0x40,0x4a,0x58,0x67,0x78,0x88,0x97,0xa5,
0xaf,0xb9,0xc0,0xc5,0xc6,0xc3,0xc0,0xbe,0xbb,0xbb,0xba,0xbc,0xbe,0xc0,0xc1,0xc2,
0xc0,0xc0,0xbe,0xbd,0xbd,0xbe,0xbe,0xbc,0xbb,0xbc,0xbb,0xba,0xbb,0xbb,0xbc,0xbe,
0xc0,0xc0,0xc0,0xbe,0xbc,0xbd,0xbd,0xbd,0xbc,0xbd,0xbc,0xbc,0xbc,0xbb,0xbb,0xbd,
0xbc,0xbd,0xbe,0xbe,0xbc,0xbb,0xbb,0xbc,0xbd,0xbd,0xbd,0xbb,0xbc,0xba,0xba,0xbc,
0xbc,0xba,0xbe,0xbc,0xbb,0xbd,0xbe,0xbe,0xbe,0xbe,0xbd,0xbe,0xbf,0xc0,0xc0,0xc0,
0xbe,0xbd,0xbe,0xbe,0xbe,0xbd,0xbc,0xbb,0xbc,0xbc,0xbd,0xbe,0xbd,0xbd,0xbd,0xbd,
0xbe,0xc0,0xc2,0xc3,0xc2,0xc0,0xbe,0xbd,0xbc,0xbd,0xbe,0xc0,0xc0,0xbc,0xbb,0xbc,
0xbc,0xbf,0xc0,0xc2,0xbe,0xc0,0xbd,0xba,0xba,0xbb,0xb9,0xbd,0xba,0xb7,0xb9,0xba,
0xb9,0xba,0xbc,0xbd,0xbd,0xbd,0xbe,0xbf,0xbe,0xbe,0xbe,0xbe,0xbe,0xbc,0xba,0xb8,
0xb8,0xbb,0xbd,0xbc,0xbd,0xbe,0xbe,0xbf,0xbf,0xc0,0xc2,0xc2,0xc0,0xc0,0xbd,0xba,
0xb6,0xb3,0xac,0xa6,0xa0,0x99,0x90,0x89,0x83,0x7b,0x76,0x72,0x70,0x70,0x6f,0x6e,
0x6d,0x6f,0x71,0x71,0x71,0x70,0x70,0x71,0x71,0x71,0x71,0x70,0x71,0x73,0x73,0x71,
0x71,0x73,0x75,0x75,0x73,0x73,0x73,0x73,0x72,0x72,0x73,0x74,0x73,0x72,0x71,0x70,
0x70,0x71,0x71,0x70,0x6f,0x6c,0x6b,0x6d,0x6e,0x6d,0x71,0x6e,0x6c,0x6d,0x6d,0x6d,
0x6f,0x70,0x70,0x70,0x70,0x70,0x72,0x7a,0x7e,0x82,0x84,0x89,0x8e,0x91,0x95,0x97,
0x97,0x98,0x96,0x97,0x95,0x93,0x91,0x8f,0x8b,0x89,0x85,0x80,0x7c,0x7a,0x76,0x72,
0x6b,0x65,0x5f,0x5d,0x5a,0x58,0x57,0x54,0x51,0x4f,0x4b,0x4a,0x46,0x49,0x4a,0x48,
0x48,0x4a,0x4b,0x4e,0x4e,0x4f,0x54,0x58,0x5c,0x61,0x65,0x6a,0x6f,0x74,0x77,0x7b,
0x80,0x85,0x8a,0x8e,0x91,0x94,0x95,0x96,0x95,0x97,0x99,0x99,0x98,0x96,0x95,0x94,
0x90,0x8b,0x85,0x84,0x82,0x7f,0x7c,0x79,0x74,0x71,0x68,0x61,0x5e,0x5d,0x5a,0x57,
0x51,0x4c,0x48,0x46,0x45,0x45,0x45,0x46,0x45,0x45,0x46,0x4a,0x4e,0x50,0x51,0x55,
0x59,0x5c,0x5f,0x61,0x65,0x6c,0x73,0x76,0x78,0x7c,0x82,0x88,0x8c,0x8f,0x93,0x95,
0x96,0x97,0x9a,0x9a,0x9a,0x98,0x96,0x95,0x93,0x8f,0x8d,0x88,0x88,0x82,0x7d,0x7b,
0x78,0x74,0x71,0x6d,0x66,0x62,0x60,0x5c,0x58,0x54,0x4f,0x4e,0x4c,0x4b,0x48,0x47,
0x45,0x44,0x44,0x46,0x48,0x4c,0x4e,0x51,0x57,0x5b,0x5e,0x61,0x62,0x66,0x6d,0x73,
0x76,0x78,0x7c,0x80,0x84,0x87,0x8b,0x90,0x96,0x98,0x98,0x99,0x9a,0x9b,0x9c,0x9b,
0x99,0x97,0x94,0x8f,0x85,0x84,0x83,0x80,0x7c,0x78,0x74,0x71,0x6b,0x66,0x64,0x61,
0x5f,0x5c,0x54,0x4e,0x4b,0x4a,0x4c,0x4b,0x4a,0x49,0x49,0x4b,0x4a,0x4b,0x51,0x57,
0x5d,0x64,0x66,0x6b,0x6d,0x6f,0x70,0x72,0x71,0x71,0x6f,0x6f,0x6d,0x6d,0x6c,0x6c,
0x6d,0x6f,0x71,0x72,0x73,0x73,0x73,0x73,0x71,0x6f,0x70,0x72,0x73,0x72,0x72,0x70,
0x6e,0x6f,0x70,0x72,0x75,0x73,0x71,0x71,0x71,0x71,0x73,0x73,0x73,0x73,0x75,0x75,
0x71,0x72,0x72,0x72,0x72,0x70,0x6f,0x73,0x72,0x71,0x72,0x72,0x72,0x72,0x71,0x70,
0x70,0x72,0x72,0x71,0x70,0x6f,0x6f,0x6f,0x6f,0x70,0x71,0x70,0x70,0x6f,0x6d,0x6b,
0x69,0x64,0x5f,0x5b,0x58,0x56,0x54,0x55,0x5a,0x60,0x6a,0x73,0x7c,0x86,0x8f,0x94,
0x96,0x94,0x90,0x88,0x7d,0x71,0x68,0x5e,0x55,0x4f,0x49,0x46,0x44,0x48,0x4f,0x58,
0x63,0x6c,0x74,0x7f,0x88,0x90,0x96,0x98,0x94,0x8f,0x88,0x7f,0x71,0x65,0x5d,0x58,
0x53,0x4c,0x48,0x49,0x4c,0x51,0x58,0x60,0x6a,0x76,0x81,0x88,0x8d,0x91,0x94,0x91,
0x8b,0x83,0x79,0x6f,0x64,0x5a,0x51,0x4b,0x46,0x47,0x49,0x4e,0x53,0x5c,0x65,0x71,
0x7b,0x84,0x8b,0x92,0x94,0x94,0x8f,0x88,0x7f,0x7a,0x6f,0x63,0x58,0x50,0x4b,0x49,
0x47,0x48,0x4b,0x51,0x59,0x60,0x69,0x73,0x80,0x8b,0x91,0x91,0x90,0x8b,0x85,0x7d,
0x73,0x6a,0x61,0x59,0x51,0x4e,0x4c,0x4c,0x4d,0x51,0x57,0x5d,0x64,0x6e,0x76,0x83,
0x88,0x8d,0x91,0x91,0x8d,0x87,0x7f,0x73,0x6a,0x61,0x59,0x50,0x49,0x45,0x45,0x48,
0x4b,0x51,0x5d,0x68,0x6f,0x77,0x80,0x86,0x8a,0x89,0x88,0x86,0x83,0x7e,0x79,0x74,
0x70,0x6f,0x6f,0x6e,0x6e,0x6f,0x6f,0x6f,0x6f,0x6f,0x70,0x70,0x70,0x70,0x70,0x70,
0x70,0x6f,0x6d,0x6e,0x6e,0x6d,0x6b,0x6a,0x6a,0x6a,0x6a,0x6c,0x6c,0x6e,0x6f,0x70,
0x6e,0x6f,0x70,0x72,0x70,0x73,0x72,0x73,0x74,0x73,0x71,0x6f,0x6d,0x6e,0x6e,0x6f,
0x6f,0x70,0x6f,0x6d,0x6c,0x6d,0x70,0x71,0x71,0x71,0x71,0x72,0x70,0x6e,0x6e,0x6d,
0x6b,0x69,0x66,0x64,0x64,0x66,0x6b,0x73,0x7b,0x82,0x85,0x84,0x80,0x7a,0x70,0x66,
0x5d,0x58,0x55,0x55,0x5a,0x63,0x71,0x80,0x88,0x8a,0x88,0x84,0x7b,0x6e,0x60,0x58,
0x54,0x53,0x56,0x5c,0x68,0x77,0x83,0x8b,0x8b,0x86,0x7e,0x71,0x63,0x59,0x53,0x52,
0x54,0x5d,0x6a,0x78,0x84,0x89,0x87,0x88,0x7e,0x71,0x65,0x5b,0x53,0x51,0x51,0x55,
0x61,0x70,0x81,0x8c,0x8f,0x8a,0x83,0x7a,0x6e,0x60,0x57,0x51,0x4f,0x54,0x5d,0x6b,
0x7b,0x85,0x8b,0x8a,0x84,0x7b,0x70,0x66,0x5b,0x55,0x52,0x54,0x5a,0x69,0x78,0x83,
0x89,0x8a,0x84,0x7b,0x70,0x65,0x5c,0x54,0x51,0x52,0x58,0x64,0x73,0x83,0x8d,0x90,
0x8b,0x82,0x76,0x6b,0x63,0x5e,0x5b,0x59,0x59,0x5d,0x64,0x6c,0x72,0x77,0x79,0x78,
0x75,0x72,0x6f,0x6e,0x6c,0x6d,0x71,0x72,0x72,0x76,0x78,0x76,0x72,0x70,0x70,0x70,
0x6e,0x6d,0x6f,0x72,0x73,0x73,0x72,0x73,0x73,0x73,0x70,0x70,0x70,0x70,0x6e,0x6f,
0x6f,0x6f,0x70,0x6d,0x6d,0x6f,0x73,0x75,0x71,0x71,0x6e,0x6b,0x6b,0x6f,0x74,0x7b,
0x7c,0x7a,0x71,0x66,0x5e,0x5c,0x65,0x6f,0x79,0x80,0x7f,0x74,0x68,0x5f,0x5c,0x64,
0x6f,0x79,0x80,0x7c,0x71,0x66,0x5e,0x5c,0x61,0x6b,0x75,0x7c,0x7e,0x7a,0x70,0x66,
0x5f,0x60,0x69,0x73,0x7b,0x7f,0x7c,0x73,0x67,0x5c,0x58,0x5d,0x69,0x75,0x7e,0x80,
0x7a,0x6c,0x62,0x5c,0x5c,0x68,0x75,0x80,0x84,0x7f,0x73,0x68,0x5e,0x5c,0x5f,0x6b,
0x75,0x7b,0x7e,0x7b,0x73,0x68,0x61,0x60,0x68,0x73,0x7d,0x82,0x81,0x77,0x6b,0x5f,
0x5a,0x5d,0x67,0x75,0x7f,0x83,0x7e,0x72,0x64,0x5a,0x5a,0x63,0x6e,0x79,0x80,0x7d,
0x72,0x67,0x60,0x5f,0x64,0x6e,0x77,0x7b,0x78,0x71,0x6a,0x65,0x64,0x6b,0x75,0x7a,
0x7a,0x76,0x6f,0x6a,0x68,0x68,0x6c,0x72,0x75,0x75,0x73,0x70,0x6d,0x69,0x6a,0x6a,
0x6a,0x6f,0x72,0x73,0x72,0x70,0x6f,0x6e,0x6d,0x6e,0x70,0x71,0x70,0x6f,0x6f,0x6f,
0x6f,0x70,0x70,0x71,0x70,0x6e,0x6c,0x6f,0x71,0x71,0x73,0x73,0x73,0x71,0x71,0x6f,
0x6c,0x6d,0x6f,0x6d,0x70,0x6f,0x6f,0x6f,0x6b,0x69,0x6c,0x71,0x77,0x7b,0x77,0x70,
0x66,0x60,0x60,0x6b,0x7a,0x83,0x83,0x77,0x65,0x5a,0x5d,0x6a,0x7b,0x86,0x86,0x78,
0x64,0x54,0x57,0x69,0x7e,0x8b,0x8a,0x7b,0x64,0x51,0x51,0x61,0x7a,0x8a,0x88,0x75,
0x5f,0x50,0x52,0x66,0x7f,0x8f,0x8e,0x7d,0x64,0x51,0x53,0x66,0x7e,0x8d,0x8a,0x78,
0x62,0x54,0x54,0x6a,0x80,0x8e,0x8b,0x77,0x5f,0x51,0x53,0x64,0x7a,0x88,0x88,0x76,
0x5d,0x4e,0x51,0x66,0x7c,0x89,0x89,0x79,0x62,0x53,0x56,0x69,0x7f,0x8c,0x88,0x76,
0x5f,0x51,0x54,0x65,0x7b,0x88,0x89,0x7a,0x64,0x58,0x59,0x68,0x7b,0x86,0x85,0x79,
0x68,0x5a,0x59,0x64,0x73,0x7c,0x7c,0x73,0x68,0x62,0x61,0x68,0x70,0x76,0x76,0x72,
0x6d,0x6b,0x6c,0x6e,0x70,0x71,0x73,0x73,0x72,0x70,0x6f,0x6f,0x70,0x6f,0x6f,0x70,
0x71,0x71,0x71,0x6f,0x6c,0x6c,0x6e,0x6f,0x6f,0x70,0x71,0x71,0x70,0x70,0x71,0x74,
0x74,0x72,0x72,0x6f,0x6e,0x70,0x70,0x6f,0x70,0x70,0x6f,0x6f,0x6d,0x6c,0x6d,0x6e,
0x6f,0x70,0x73,0x72,0x70,0x6e,0x6b,0x6c,0x70,0x73,0x75,0x73,0x6e,0x68,0x65,0x68,
0x6e,0x75,0x78,0x73,0x6b,0x68,0x68,0x6c,0x75,0x7a,0x7b,0x75,0x6c,0x67,0x66,0x6d,
0x73,0x76,0x73,0x6b,0x62,0x60,0x66,0x6f,0x77,0x79,0x73,0x6b,0x67,0x6a,0x73,0x7b,
0x7b,0x75,0x6c,0x68,0x69,0x70,0x77,0x7a,0x73,0x6b,0x65,0x69,0x70,0x77,0x7a,0x75,
0x6c,0x66,0x68,0x70,0x7a,0x7c,0x76,0x6e,0x67,0x68,0x70,0x78,0x7a,0x75,0x6d,0x67,
0x67,0x6e,0x76,0x7a,0x75,0x6d,0x67,0x6a,0x71,0x7a,0x7c,0x77,0x6c,0x62,0x65,0x6f,
0x77,0x7c,0x76,0x69,0x62,0x62,0x6b,0x79,0x7f,0x78,0x6a,0x5f,0x5c,0x66,0x75,0x7f,
0x7d,0x71,0x62,0x5c,0x63,0x71,0x7a,0x7b,0x6f,0x63,0x5f,0x63,0x6d,0x76,0x7a,0x74,
0x6b,0x66,0x6a,0x73,0x79,0x7a,0x72,0x6b,0x66,0x68,0x6f,0x73,0x72,0x6f,0x6b,0x6a,
0x6b,0x71,0x76,0x78,0x73,0x6e,0x6a,0x6c,0x6f,0x71,0x70,0x6c,0x69,0x69,0x6a,0x6e,
0x71,0x72,0x70,0x6d,0x6c,0x6f,0x72,0x73,0x72,0x6f,0x6e,0x6b,0x6b,0x6f,0x70,0x70,
0x6e,0x6c,0x6d,0x70,0x71,0x72,0x73,0x71,0x6e,0x6f,0x71,0x74,0x75,0x74,0x71,0x70,
0x72,0x73,0x73,0x73,0x70,0x6d,0x6e,0x6f,0x70,0x70,0x70,0x6e,0x6d,0x6c,0x6c,0x6c,
0x70,0x6f,0x6c,0x6c,0x6c,0x6c,0x6c,0x6b,0x69,0x66,0x62,0x5d,0x57,0x50,0x4a,0x45,
0x40,0x3c,0x3b,0x3a,0x37,0x35,0x34,0x35,0x36,0x38,0x38,0x37,0x39,0x39,0x38,0x38,
// Line 21
0x3c,0x3b,0x39,0x38,0x38,0x37,0x35,0x35,0x36,0x35,0x34,0x36,0x36,0x38,0x3a,0x3c,
0x3c,0x3d,0x3c,0x3a,0x39,0x3a,0x39,0x37,0x34,0x33,0x36,0x36,0x36,0x35,0x36,0x36,
0x37,0x38,0x39,0x3a,0x3c,0x3a,0x39,0x38,0x38,0x3a,0x3c,0x3e,0x3d,0x3c,0x3e,0x3f,
0x3f,0x42,0x44,0x47,0x4b,0x4e,0x50,0x55,0x57,0x59,0x5c,0x5f,0x61,0x63,0x63,0x64,
0x65,0x65,0x66,0x65,0x65,0x66,0x66,0x66,0x63,0x61,0x60,0x5e,0x5b,0x59,0x57,0x57,
0x54,0x50,0x4c,0x49,0x47,0x47,0x46,0x45,0x43,0x40,0x3e,0x3d,0x3c,0x3d,0x3d,0x3d,
0x3e,0x3e,0x3d,0x3c,0x3b,0x3b,0x3e,0x43,0x46,0x47,0x49,0x49,0x48,0x49,0x4b,0x50,
0x58,0x5a,0x5b,0x5c,0x5d,0x60,0x62,0x65,0x64,0x66,0x68,0x69,0x67,0x67,0x68,0x68,
0x67,0x67,0x66,0x65,0x61,0x5f,0x5e,0x5c,0x57,0x55,0x53,0x50,0x4e,0x4c,0x4b,0x49,
0x46,0x43,0x3f,0x3f,0x3c,0x3b,0x3b,0x3c,0x3b,0x3b,0x3b,0x3c,0x3d,0x3e,0x40,0x43,
0x46,0x47,0x47,0x49,0x4a,0x4d,0x51,0x55,0x55,0x57,0x59,0x5a,0x5d,0x61,0x64,0x67,
0x67,0x66,0x67,0x68,0x6a,0x6a,0x69,0x67,0x66,0x65,0x63,0x61,0x60,0x5e,0x5b,0x59,
0x57,0x55,0x53,0x50,0x4d,0x4c,0x4c,0x4d,0x49,0x49,0x46,0x44,0x43,0x3f,0x3b,0x3e,
0x3d,0x3d,0x3c,0x3c,0x3e,0x40,0x42,0x41,0x42,0x45,0x47,0x47,0x49,0x47,0x49,0x4c,
0x4f,0x52,0x56,0x59,0x5a,0x5c,0x5d,0x60,0x62,0x65,0x66,0x68,0x67,0x68,0x68,0x68,
0x68,0x69,0x69,0x65,0x60,0x5d,0x5c,0x5d,0x5d,0x5a,0x59,0x57,0x53,0x4f,0x4d,0x4c,
0x4b,0x46,0x44,0x40,0x3b,0x3a,0x3a,0x38,0x3c,0x3c,0x3b,0x3b,0x3c,0x3d,0x3e,0x3f,
0x3f,0x41,0x43,0x46,0x46,0x47,0x49,0x4c,0x4e,0x50,0x53,0x57,0x59,0x5b,0x5d,0x5e,
0x61,0x64,0x65,0x66,0x68,0x69,0x6b,0x6c,0x6b,0x69,0x68,0x68,0x65,0x61,0x5e,0x5c,
0x5a,0x59,0x57,0x57,0x57,0x54,0x52,0x50,0x4f,0x4f,0x4c,0x49,0x46,0x45,0x44,0x42,
0x3f,0x3d,0x3d,0x3b,0x39,0x36,0x36,0x38,0x3b,0x3d,0x3f,0x41,0x45,0x48,0x4c,0x50,
0x54,0x59,0x5a,0x57,0x59,0x57,0x59,0x5d,0x5f,0x61,0x62,0x63,0x63,0x64,0x66,0x6c,
0x6d,0x6d,0x6b,0x69,0x68,0x65,0x62,0x60,0x5f,0x5d,0x5c,0x57,0x53,0x53,0x53,0x51,
0x4e,0x4c,0x4a,0x47,0x44,0x41,0x3f,0x40,0x40,0x3d,0x3b,0x3a,0x3a,0x3b,0x3b,0x3b,
0x3b,0x3c,0x3c,0x3d,0x3f,0x43,0x46,0x4c,0x4d,0x4f,0x51,0x53,0x55,0x57,0x5a,0x5c,
0x5e,0x5e,0x60,0x61,0x62,0x63,0x66,0x68,0x6a,0x69,0x68,0x66,0x64,0x65,0x65,0x63,
0x61,0x5e,0x5c,0x5a,0x57,0x54,0x51,0x4f,0x4c,0x4a,0x49,0x49,0x47,0x47,0x46,0x43,
0x42,0x3f,0x3d,0x3b,0x3a,0x39,0x3a,0x3a,0x3b,0x3c,0x3c,0x3b,0x39,0x39,0x3c,0x3d,
0x3d,0x3c,0x3c,0x3f,0x3e,0x3c,0x3e,0x3d,0x3d,0x3c,0x3a,0x37,0x36,0x38,0x39,0x38,
0x37,0x36,0x35,0x38,0x36,0x36,0x38,0x3a,0x39,0x3a,0x38,0x36,0x38,0x3a,0x3a,0x3a,
0x38,0x37,0x37,0x38,0x3a,0x3b,0x3d,0x3e,0x3c,0x3c,0x3b,0x3a,0x3a,0x3a,0x3a,0x3a,
0x38,0x36,0x36,0x36,0x35,0x36,0x36,0x36,0x37,0x38,0x39,0x3a,0x3c,0x3d,0x3d,0x3b,
0x3a,0x39,0x39,0x38,0x36,0x36,0x38,0x36,0x37,0x37,0x37,0x37,0x36,0x36,0x34,0x35,
0x37,0x38,0x3a,0x39,0x38,0x3e,0x44,0x49,0x50,0x55,0x59,0x5d,0x5f,0x62,0x66,0x6a,
0x6c,0x6b,0x69,0x67,0x66,0x67,0x67,0x68,0x67,0x66,0x65,0x65,0x65,0x66,0x68,0x6a,
0x6b,0x6a,0x69,0x68,0x68,0x6c,0x6d,0x6c,0x6b,0x68,0x67,0x69,0x68,0x69,0x6c,0x6c,
0x6b,0x69,0x66,0x65,0x65,0x67,0x67,0x66,0x68,0x69,0x68,0x68,0x66,0x63,0x61,0x5f,
0x5a,0x54,0x4d,0x46,0x3f,0x3b,0x39,0x38,0x38,0x36,0x36,0x38,0x3a,0x3c,0x3d,0x3d,
0x3e,0x3e,0x3b,0x37,0x35,0x34,0x36,0x3a,0x3a,0x38,0x36,0x39,0x3a,0x39,0x39,0x39,
0x39,0x3c,0x36,0x33,0x32,0x34,0x38,0x3a,0x3b,0x3a,0x3a,0x3c,0x3c,0x3b,0x3a,0x3a,
0x39,0x3a,0x38,0x36,0x36,0x35,0x37,0x38,0x38,0x36,0x37,0x37,0x37,0x38,0x3a,0x39,
0x36,0x36,0x34,0x32,0x32,0x34,0x36,0x39,0x36,0x33,0x36,0x38,0x3a,0x3a,0x3a,0x3a,
0x39,0x38,0x38,0x3a,0x3a,0x38,0x38,0x37,0x36,0x34,0x35,0x36,0x37,0x38,0x36,0x36,
0x36,0x36,0x37,0x38,0x37,0x36,0x36,0x37,0x36,0x36,0x37,0x38,0x38,0x38,0x39,0x3a,
0x3f,0x43,0x47,0x4c,0x52,0x57,0x5f,0x64,0x68,0x68,0x6a,0x69,0x69,0x69,0x69,0x67,
0x65,0x62,0x62,0x66,0x68,0x69,0x6b,0x6b,0x69,0x6a,0x69,0x68,0x68,0x68,0x68,0x67,
0x66,0x67,0x67,0x67,0x68,0x68,0x6b,0x6b,0x6b,0x6c,0x6c,0x6a,0x68,0x68,0x67,0x64,
0x65,0x63,0x63,0x63,0x64,0x62,0x62,0x61,0x5d,0x5c,0x5a,0x55,0x51,0x4c,0x47,0x45,
0x40,0x3c,0x3a,0x38,0x36,0x35,0x36,0x37,0x38,0x37,0x37,0x36,0x36,0x36,0x36,0x38,
0x39,0x3a,0x3b,0x3a,0x38,0x37,0x38,0x38,0x37,0x38,0x36,0x33,0x35,0x35,0x36,0x3a,
0x3b,0x3a,0x3a,0x3a,0x39,0x38,0x38,0x38,0x38,0x37,0x34,0x32,0x30,0x33,0x36,0x38,
0x3a,0x3b,0x40,0x45,0x49,0x4f,0x55,0x5b,0x60,0x63,0x65,0x66,0x66,0x66,0x66,0x66,
0x65,0x66,0x68,0x66,0x62,0x63,0x66,0x68,0x67,0x66,0x65,0x66,0x65,0x64,0x64,0x66,
0x67,0x66,0x66,0x66,0x66,0x66,0x66,0x67,0x69,0x6a,0x68,0x67,0x66,0x67,0x69,0x6b,
0x6b,0x6c,0x6c,0x6b,0x68,0x68,0x68,0x6a,0x69,0x65,0x5e,0x5b,0x57,0x53,0x4e,0x49,
0x45,0x43,0x3e,0x3a,0x37,0x38,0x38,0x37,0x36,0x37,0x38,0x3b,0x3a,0x39,0x3a,0x3a,
0x37,0x36,0x34,0x35,0x36,0x38,0x38,0x36,0x35,0x34,0x36,0x36,0x36,0x37,0x38,0x39,
0x36,0x38,0x3a,0x3b,0x3c,0x3b,0x3a,0x38,0x36,0x35,0x31,0x33,0x33,0x34,0x36,0x37,
0x36,0x37,0x35,0x33,0x35,0x36,0x36,0x36,0x34,0x31,0x30,0x30,0x32,0x34,0x38,0x39,
0x38,0x38,0x36,0x35,0x36,0x36,0x35,0x36,0x36,0x36,0x35,0x34,0x34,0x36,0x37,0x39,
0x3a,0x3c,0x3e,0x3c,0x3a,0x38,0x38,0x39,0x37,0x34,0x34,0x34,0x34,0x34,0x34,0x35,
0x38,0x3b,0x3d,0x3c,0x3d,0x3f,0x3f,0x3e,0x3a,0x38,0x37,0x37,0x39,0x3e,0x43,0x47,
0x4b,0x50,0x56,0x5c,0x61,0x65,0x65,0x68,0x67,0x67,0x69,0x69,0x68,0x68,0x69,0x66,
0x67,0x68,0x6b,0x6a,0x67,0x64,0x64,0x68,0x69,0x6a,0x6a,0x68,0x66,0x66,0x66,0x67,
0x6b,0x6c,0x69,0x68,0x67,0x67,0x6a,0x6c,0x6b,0x6b,0x6b,0x69,0x67,0x65,0x66,0x67,
0x69,0x68,0x66,0x64,0x60,0x5c,0x59,0x55,0x51,0x4c,0x45,0x40,0x3d,0x3c,0x3b,0x37,
0x38,0x36,0x36,0x36,0x36,0x36,0x39,0x39,0x37,0x36,0x36,0x38,0x38,0x38,0x38,0x3a,
0x3c,0x3c,0x3a,0x39,0x37,0x37,0x39,0x3a,0x3a,0x3b,0x3a,0x37,0x35,0x36,0x37,0x39,
0x3a,0x3a,0x3b,0x3b,0x3c,0x3a,0x3b,0x3c,0x3c,0x3e,0x3d,0x3a,0x3b,0x3d,0x3d,0x3e,
0x42,0x49,0x50,0x55,0x56,0x5a,0x5f,0x63,0x63,0x65,0x66,0x69,0x69,0x68,0x67,0x68,
0x68,0x66,0x67,0x67,0x67,0x68,0x68,0x68,0x69,0x6b,0x6c,0x6c,0x6c,0x6b,0x6c,0x6c,
0x6b,0x69,0x6c,0x6a,0x67,0x67,0x69,0x6c,0x6b,0x6a,0x68,0x68,0x66,0x65,0x65,0x66,
0x66,0x68,0x69,0x68,0x66,0x67,0x68,0x67,0x66,0x67,0x6a,0x6a,0x68,0x66,0x68,0x69,
0x68,0x67,0x66,0x66,0x65,0x65,0x66,0x66,0x66,0x65,0x65,0x68,0x68,0x69,0x6a,0x69,
0x68,0x67,0x68,0x69,0x68,0x68,0x69,0x69,0x69,0x69,0x6a,0x6c,0x6c,0x6c,0x6c,0x6b,
0x68,0x69,0x67,0x66,0x65,0x65,0x66,0x66,0x65,0x65,0x65,0x66,0x66,0x66,0x66,0x63,
0x5e,0x59,0x53,0x4e,0x4a,0x46,0x41,0x3d,0x3a,0x37,0x36,0x35,0x36,0x39,0x3d,0x3f,
0x3e,0x3c,0x3c,0x3c,0x3c,0x3a,0x39,0x37,0x35,0x33,0x34,0x34,0x34,0x35,0x37,0x38,
0x38,0x38,0x37,0x34,0x36,0x37,0x38,0x38,0x38,0x37,0x38,0x38,0x36,0x36,0x3a,0x3c,
0x38,0x36,0x34,0x35,0x37,0x3a,0x3b,0x3e,0x40,0x43,0x47,0x4b,0x4f,0x55,0x59,0x5a,
0x5c,0x5f,0x62,0x64,0x65,0x65,0x66,0x67,0x66,0x66,0x68,0x6a,0x6b,0x6b,0x68,0x68,
0x68,0x69,0x68,0x68,0x67,0x66,0x64,0x62,0x61,0x62,0x65,0x67,0x66,0x68,0x68,0x6a,
0x6c,0x6c,0x6d,0x6e,0x6c,0x69,0x68,0x65,0x63,0x63,0x62,0x62,0x62,0x65,0x67,0x67,
0x67,0x68,0x69,0x6a,0x69,0x68,0x68,0x66,0x64,0x64,0x66,0x68,0x68,0x67,0x66,0x66,
0x68,0x69,0x69,0x69,0x68,0x67,0x66,0x65,0x66,0x68,0x69,0x68,0x67,0x66,0x65,0x65,
0x66,0x65,0x66,0x68,0x69,0x6a,0x6b,0x6a,0x69,0x6a,0x6b,0x6b,0x6b,0x6a,0x68,0x67,
0x67,0x67,0x68,0x68,0x68,0x68,0x69,0x68,0x66,0x64,0x64,0x65,0x66,0x69,0x6b,0x6c,
0x6d,0x6c,0x6c,0x6c,0x6d,0x6c,0x6c,0x6b,0x68,0x68,0x67,0x67,0x67,0x67,0x67,0x69,
0x68,0x69,0x6a,0x6a,0x68,0x68,0x69,0x6a,0x6a,0x69,0x69,0x68,0x69,0x69,0x67,0x6a,
0x6b,0x6a,0x6c,0x6b,0x69,0x69,0x6a,0x6a,0x6c,0x6c,0x6c,0x6a,0x68,0x66,0x65,0x66,
0x65,0x62,0x5f,0x5d,0x58,0x54,0x4e,0x4a,0x47,0x46,0x42,0x3f,0x3c,0x3a,0x3a,0x3a,
0x38,0x37,0x3b,0x3c,0x3b,0x3a,0x38,0x38,0x3a,0x3b,0x3a,0x3a,0x39,0x37,0x36,0x35,
0x36,0x37,0x3a,0x3a,0x38,0x39,0x3a,0x38,0x3a,0x39,0x3a,0x3b,0x39,0x38,0x38,0x3a,
0x39,0x37,0x37,0x38,0x38,0x37,0x36,0x37,0x38,0x38,0x36,0x35,0x35,0x35,0x35,0x33,
0x31,0x30,0x32,0x32,0x32,0x33,0x36,0x38,0x38,0x37,0x35,0x35,0x34,0x33,0x34,0x34,
0x35,0x37,0x36,0x33,0x33,0x34,0x34,0x34,0x36,0x38,0x38,0x36,0x35,0x34,0x36,0x37,
//Field 9
// Line 10
0x34,0x34,0x35,0x37,0x35,0x36,0x37,0x39,0x3b,0x3c,0x3a,0x3b,0x3a,0x3b,0x3c,0x39,
0x37,0x38,0x37,0x35,0x35,0x36,0x37,0x38,0x37,0x36,0x37,0x39,0x3a,0x3b,0x3b,0x3a,
0x38,0x38,0x38,0x38,0x38,0x38,0x37,0x37,0x34,0x33,0x31,0x32,0x32,0x34,0x36,0x36,
0x36,0x38,0x38,0x36,0x37,0x37,0x37,0x39,0x39,0x38,0x36,0x35,0x35,0x36,0x37,0x38,
0x39,0x3b,0x3b,0x38,0x36,0x36,0x36,0x38,0x37,0x37,0x37,0x37,0x35,0x36,0x38,0x39,
0x38,0x37,0x36,0x36,0x37,0x39,0x39,0x3a,0x39,0x39,0x3b,0x3b,0x3b,0x3c,0x3c,0x3b,
0x39,0x38,0x37,0x35,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x35,0x37,0x3a,0x3a,0x38,
0x38,0x39,0x39,0x39,0x39,0x38,0x37,0x36,0x35,0x35,0x38,0x39,0x3a,0x3a,0x38,0x38,
0x3a,0x3c,0x3c,0x3e,0x3c,0x3b,0x38,0x36,0x35,0x36,0x38,0x37,0x37,0x39,0x37,0x36,
0x35,0x35,0x35,0x37,0x37,0x36,0x36,0x35,0x34,0x35,0x35,0x36,0x37,0x37,0x37,0x37,
0x38,0x38,0x37,0x37,0x37,0x38,0x3a,0x3a,0x3a,0x3b,0x3b,0x3b,0x3a,0x3a,0x38,0x36,
0x35,0x35,0x35,0x36,0x36,0x35,0x34,0x34,0x32,0x35,0x37,0x38,0x3a,0x3b,0x39,0x37,
0x37,0x39,0x3c,0x3b,0x39,0x39,0x38,0x37,0x36,0x37,0x37,0x38,0x39,0x38,0x37,0x39,
0x39,0x3a,0x3b,0x39,0x39,0x39,0x38,0x38,0x36,0x36,0x37,0x38,0x38,0x37,0x37,0x3a,
0x3a,0x39,0x3a,0x39,0x37,0x37,0x35,0x35,0x35,0x35,0x36,0x36,0x38,0x38,0x36,0x37,
0x36,0x38,0x3a,0x3a,0x3a,0x3b,0x39,0x37,0x36,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
0x38,0x39,0x37,0x35,0x35,0x37,0x37,0x36,0x36,0x37,0x37,0x37,0x38,0x3c,0x3d,0x3e,
0x3a,0x3a,0x3a,0x38,0x36,0x38,0x37,0x35,0x35,0x34,0x34,0x36,0x37,0x38,0x39,0x39,
0x38,0x39,0x38,0x37,0x37,0x38,0x3a,0x3b,0x3a,0x38,0x36,0x37,0x37,0x38,0x39,0x3a,
0x38,0x3a,0x39,0x38,0x38,0x3b,0x3c,0x3c,0x3b,0x3b,0x39,0x39,0x36,0x35,0x37,0x37,
0x37,0x36,0x38,0x37,0x38,0x37,0x37,0x38,0x38,0x38,0x38,0x38,0x39,0x39,0x39,0x38,
0x38,0x39,0x38,0x38,0x3a,0x3c,0x3c,0x3d,0x3c,0x3b,0x3a,0x39,0x37,0x38,0x3a,0x3c,
0x3b,0x3a,0x38,0x36,0x36,0x37,0x37,0x3a,0x38,0x37,0x35,0x33,0x34,0x36,0x38,0x38,
0x39,0x39,0x39,0x37,0x37,0x38,0x38,0x39,0x37,0x37,0x35,0x34,0x33,0x36,0x38,0x39,
0x3a,0x39,0x36,0x35,0x37,0x3b,0x3b,0x3c,0x3a,0x38,0x37,0x36,0x36,0x37,0x37,0x38,
0x38,0x37,0x36,0x36,0x39,0x3b,0x3b,0x3a,0x3a,0x3a,0x39,0x38,0x37,0x39,0x3a,0x3a,
0x39,0x39,0x38,0x38,0x38,0x3a,0x3a,0x3b,0x38,0x37,0x37,0x37,0x38,0x38,0x38,0x38,
0x3b,0x3c,0x3b,0x39,0x3a,0x3b,0x3c,0x3a,0x38,0x36,0x38,0x37,0x36,0x37,0x39,0x3b,
0x3c,0x3c,0x3c,0x3d,0x3c,0x3b,0x39,0x36,0x34,0x34,0x33,0x33,0x33,0x33,0x33,0x36,
0x39,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3c,0x3b,0x3a,0x37,0x35,0x34,0x35,0x36,0x38,
0x39,0x39,0x37,0x36,0x37,0x39,0x3c,0x3b,0x39,0x3b,0x3a,0x38,0x38,0x37,0x38,0x3b,
0x3a,0x39,0x37,0x39,0x39,0x3a,0x3a,0x3b,0x3b,0x3b,0x3a,0x39,0x39,0x39,0x39,0x37,
0x36,0x36,0x37,0x36,0x34,0x34,0x36,0x37,0x38,0x3a,0x3c,0x3e,0x3e,0x3d,0x3c,0x3c,
0x3d,0x3c,0x3b,0x38,0x36,0x37,0x37,0x37,0x36,0x36,0x35,0x34,0x36,0x38,0x38,0x3a,
0x3a,0x3b,0x3c,0x3b,0x3a,0x3b,0x39,0x39,0x38,0x38,0x37,0x37,0x36,0x37,0x37,0x37,
0x38,0x39,0x39,0x39,0x38,0x39,0x3a,0x3b,0x3c,0x3b,0x39,0x39,0x3a,0x3a,0x3a,0x3a,
0x38,0x37,0x37,0x36,0x35,0x37,0x38,0x38,0x39,0x3a,0x39,0x3a,0x38,0x3a,0x3b,0x3a,
0x37,0x36,0x35,0x35,0x35,0x35,0x35,0x34,0x34,0x34,0x33,0x35,0x37,0x39,0x3b,0x3a,
0x37,0x38,0x38,0x39,0x3a,0x39,0x37,0x36,0x34,0x35,0x34,0x38,0x38,0x3b,0x3c,0x3b,
0x39,0x38,0x38,0x38,0x39,0x38,0x37,0x35,0x36,0x37,0x38,0x38,0x3a,0x3a,0x3c,0x39,
0x36,0x37,0x39,0x3a,0x3a,0x37,0x34,0x34,0x35,0x36,0x35,0x35,0x36,0x39,0x3a,0x38,
0x37,0x39,0x3b,0x3c,0x3c,0x3b,0x3a,0x3b,0x3a,0x39,0x38,0x37,0x36,0x34,0x37,0x35,
0x35,0x36,0x37,0x36,0x37,0x35,0x33,0x34,0x36,0x38,0x38,0x36,0x36,0x37,0x37,0x37,
0x36,0x38,0x39,0x38,0x36,0x35,0x34,0x34,0x34,0x35,0x36,0x35,0x37,0x38,0x37,0x36,
0x38,0x38,0x37,0x35,0x34,0x36,0x37,0x37,0x36,0x38,0x3c,0x3a,0x38,0x3b,0x3d,0x3e,
0x3f,0x3d,0x38,0x38,0x38,0x38,0x36,0x35,0x33,0x33,0x33,0x33,0x33,0x36,0x37,0x38,
0x3a,0x3b,0x3b,0x3b,0x39,0x39,0x3b,0x3c,0x3b,0x38,0x37,0x36,0x37,0x37,0x37,0x37,
0x38,0x39,0x36,0x35,0x34,0x36,0x38,0x37,0x35,0x36,0x37,0x38,0x36,0x37,0x37,0x37,
0x36,0x35,0x34,0x37,0x37,0x37,0x37,0x36,0x37,0x38,0x39,0x39,0x3c,0x3d,0x3c,0x3a,
0x39,0x38,0x38,0x38,0x37,0x37,0x36,0x35,0x34,0x36,0x38,0x39,0x3b,0x3b,0x39,0x39,
0x38,0x38,0x37,0x39,0x39,0x3c,0x3c,0x3b,0x38,0x39,0x3a,0x38,0x37,0x37,0x37,0x38,
0x35,0x33,0x34,0x36,0x37,0x38,0x37,0x35,0x34,0x36,0x37,0x38,0x39,0x3b,0x39,0x39,
0x38,0x39,0x3a,0x3a,0x39,0x3a,0x39,0x3a,0x3b,0x3b,0x3a,0x39,0x38,0x36,0x34,0x35,
0x35,0x34,0x35,0x34,0x34,0x36,0x36,0x37,0x3a,0x3c,0x3d,0x3b,0x38,0x35,0x35,0x35,
0x36,0x38,0x3a,0x39,0x36,0x35,0x35,0x38,0x3b,0x3b,0x38,0x39,0x39,0x3b,0x3a,0x3a,
0x39,0x3a,0x39,0x38,0x37,0x38,0x3a,0x38,0x37,0x36,0x35,0x37,0x37,0x37,0x38,0x39,
0x39,0x38,0x37,0x37,0x38,0x3a,0x38,0x36,0x36,0x35,0x34,0x34,0x34,0x34,0x35,0x35,
0x34,0x35,0x36,0x37,0x37,0x37,0x37,0x37,0x37,0x38,0x38,0x38,0x37,0x37,0x37,0x37,
0x37,0x38,0x38,0x36,0x34,0x35,0x37,0x38,0x39,0x39,0x3a,0x3a,0x39,0x38,0x37,0x38,
0x3a,0x3c,0x3b,0x3a,0x39,0x37,0x34,0x33,0x34,0x36,0x35,0x32,0x30,0x31,0x33,0x35,
0x35,0x37,0x39,0x39,0x38,0x38,0x37,0x37,0x38,0x37,0x38,0x38,0x38,0x37,0x36,0x37,
0x38,0x3a,0x3b,0x3a,0x3b,0x39,0x37,0x37,0x36,0x37,0x38,0x38,0x35,0x36,0x36,0x36,
0x36,0x35,0x36,0x36,0x36,0x36,0x35,0x35,0x34,0x35,0x35,0x36,0x37,0x38,0x3a,0x39,
0x3a,0x3b,0x39,0x39,0x37,0x37,0x37,0x39,0x39,0x38,0x38,0x36,0x35,0x36,0x35,0x35,
0x36,0x37,0x37,0x38,0x38,0x39,0x3a,0x39,0x38,0x3a,0x3c,0x3c,0x37,0x37,0x36,0x37,
0x38,0x38,0x37,0x37,0x35,0x33,0x32,0x33,0x34,0x37,0x36,0x35,0x34,0x35,0x37,0x39,
0x3b,0x3c,0x3c,0x3b,0x39,0x36,0x35,0x35,0x35,0x37,0x37,0x37,0x36,0x35,0x34,0x34,
0x35,0x37,0x37,0x39,0x39,0x3a,0x3b,0x39,0x38,0x3a,0x39,0x37,0x38,0x38,0x38,0x37,
0x35,0x34,0x34,0x35,0x38,0x39,0x39,0x38,0x39,0x3b,0x3b,0x3a,0x39,0x3a,0x39,0x38,
0x36,0x35,0x35,0x35,0x35,0x37,0x37,0x39,0x38,0x36,0x34,0x34,0x35,0x36,0x35,0x34,
0x34,0x31,0x33,0x34,0x36,0x38,0x39,0x37,0x36,0x36,0x36,0x36,0x37,0x38,0x39,0x38,
0x36,0x36,0x37,0x38,0x38,0x38,0x37,0x38,0x39,0x38,0x36,0x36,0x38,0x39,0x38,0x37,
0x36,0x37,0x37,0x35,0x34,0x34,0x34,0x36,0x38,0x38,0x38,0x3b,0x39,0x38,0x38,0x39,
0x3b,0x39,0x39,0x37,0x36,0x37,0x38,0x37,0x3a,0x38,0x38,0x38,0x36,0x36,0x36,0x36,
0x35,0x35,0x35,0x38,0x37,0x36,0x36,0x37,0x38,0x38,0x37,0x37,0x37,0x37,0x37,0x36,
0x38,0x3a,0x39,0x38,0x38,0x38,0x39,0x38,0x37,0x37,0x38,0x38,0x36,0x34,0x37,0x3a,
0x3b,0x3b,0x37,0x36,0x36,0x34,0x30,0x32,0x34,0x37,0x37,0x36,0x35,0x37,0x39,0x3b,
0x3b,0x3b,0x38,0x36,0x37,0x36,0x34,0x35,0x37,0x38,0x38,0x37,0x37,0x39,0x39,0x37,
0x36,0x37,0x38,0x38,0x38,0x38,0x39,0x3c,0x3b,0x3b,0x3b,0x3a,0x37,0x37,0x37,0x37,
0x33,0x35,0x34,0x33,0x33,0x34,0x34,0x38,0x38,0x39,0x3a,0x39,0x38,0x38,0x36,0x35,
0x36,0x37,0x37,0x36,0x34,0x33,0x34,0x37,0x38,0x38,0x39,0x39,0x38,0x3a,0x39,0x3a,
0x3b,0x3b,0x3a,0x3a,0x3a,0x3a,0x3a,0x38,0x34,0x33,0x34,0x33,0x34,0x36,0x36,0x36,
0x37,0x38,0x37,0x38,0x39,0x39,0x38,0x36,0x35,0x35,0x35,0x35,0x37,0x3a,0x3b,0x3b,
0x39,0x39,0x39,0x3a,0x3b,0x3b,0x3a,0x39,0x37,0x38,0x38,0x38,0x36,0x34,0x34,0x35,
0x37,0x37,0x37,0x37,0x36,0x37,0x38,0x38,0x39,0x3a,0x38,0x37,0x35,0x36,0x37,0x37,
0x39,0x3a,0x39,0x39,0x39,0x39,0x39,0x39,0x38,0x39,0x39,0x39,0x39,0x38,0x37,0x36,
0x36,0x38,0x38,0x39,0x38,0x38,0x38,0x38,0x37,0x38,0x38,0x39,0x3a,0x3a,0x39,0x3a,
0x39,0x38,0x38,0x38,0x3a,0x3b,0x3b,0x39,0x36,0x37,0x36,0x36,0x37,0x38,0x38,0x38,
0x38,0x37,0x38,0x38,0x39,0x39,0x3a,0x39,0x38,0x36,0x35,0x34,0x35,0x36,0x36,0x37,
0x36,0x36,0x38,0x38,0x39,0x3b,0x3b,0x3a,0x37,0x36,0x36,0x34,0x36,0x35,0x36,0x37,
0x37,0x37,0x37,0x37,0x38,0x3b,0x3a,0x38,0x36,0x35,0x32,0x32,0x34,0x37,0x38,0x38,
0x35,0x34,0x36,0x37,0x37,0x36,0x35,0x34,0x34,0x33,0x33,0x34,0x37,0x38,0x38,0x38,
0x38,0x35,0x36,0x34,0x34,0x35,0x35,0x34,0x35,0x34,0x34,0x36,0x36,0x37,0x38,0x39,
0x39,0x3a,0x38,0x38,0x37,0x36,0x34,0x33,0x35,0x37,0x37,0x36,0x34,0x34,0x35,0x36,
0x36,0x36,0x35,0x35,0x36,0x35,0x35,0x35,0x36,0x37,0x37,0x38,0x37,0x39,0x38,0x36,
0x34,0x35,0x35,0x35,0x35,0x37,0x37,0x38,0x37,0x36,0x34,0x34,0x33,0x34,0x34,0x32,
// Line 11
0x3c,0x3d,0x3c,0x37,0x34,0x36,0x3a,0x3a,0x39,0x37,0x35,0x35,0x35,0x35,0x35,0x36,
0x36,0x35,0x35,0x34,0x35,0x38,0x3a,0x39,0x39,0x39,0x3a,0x39,0x37,0x36,0x35,0x35,
0x35,0x35,0x35,0x35,0x35,0x38,0x39,0x3a,0x3b,0x3b,0x3a,0x38,0x36,0x36,0x36,0x39,
0x38,0x36,0x32,0x2f,0x2e,0x38,0x48,0x5b,0x6d,0x79,0x7a,0x75,0x68,0x5c,0x55,0x58,
0x62,0x6d,0x71,0x72,0x6e,0x69,0x61,0x5b,0x5c,0x61,0x6b,0x73,0x76,0x75,0x71,0x6a,
0x62,0x5e,0x5d,0x61,0x68,0x6f,0x72,0x72,0x6d,0x66,0x5c,0x5c,0x5c,0x63,0x6e,0x76,
0x78,0x76,0x6f,0x66,0x61,0x5e,0x61,0x66,0x6c,0x71,0x73,0x70,0x6b,0x64,0x5e,0x5a,
0x5c,0x63,0x6c,0x73,0x74,0x70,0x6b,0x65,0x60,0x5f,0x60,0x65,0x6c,0x74,0x78,0x77,
0x71,0x6b,0x63,0x5e,0x5d,0x61,0x65,0x6c,0x6d,0x6d,0x70,0x76,0x80,0x8f,0x9c,0xa4,
0xa9,0xa7,0x9d,0x8c,0x7b,0x6c,0x61,0x59,0x54,0x51,0x4d,0x44,0x3a,0x35,0x3a,0x46,
0x56,0x68,0x76,0x82,0x88,0x8e,0x91,0x94,0x98,0x9c,0x9c,0x99,0x95,0x96,0x98,0x9a,
0x9a,0x94,0x87,0x78,0x67,0x5c,0x55,0x4f,0x46,0x3b,0x33,0x31,0x39,0x4d,0x65,0x77,
0x81,0x7f,0x75,0x68,0x5e,0x59,0x54,0x4a,0x3d,0x33,0x2c,0x2f,0x3e,0x56,0x6e,0x80,
0x83,0x7c,0x6f,0x63,0x56,0x4e,0x49,0x46,0x3f,0x39,0x33,0x2f,0x2e,0x33,0x3b,0x44,
0x55,0x64,0x6e,0x75,0x73,0x6b,0x66,0x5f,0x59,0x56,0x50,0x48,0x3d,0x38,0x36,0x42,
0x54,0x6a,0x7c,0x89,0x8f,0x93,0x94,0x92,0x8b,0x80,0x6f,0x5e,0x54,0x56,0x60,0x6f,
0x7a,0x7d,0x77,0x6e,0x65,0x61,0x60,0x5d,0x52,0x42,0x30,0x25,0x2d,0x42,0x5b,0x72,
0x7e,0x7d,0x75,0x66,0x5b,0x58,0x57,0x51,0x42,0x35,0x2d,0x32,0x44,0x5d,0x72,0x7f,
0x80,0x75,0x67,0x5b,0x56,0x55,0x50,0x44,0x38,0x32,0x35,0x43,0x58,0x70,0x80,0x83,
0x77,0x66,0x58,0x4f,0x4c,0x4c,0x49,0x40,0x38,0x30,0x2d,0x33,0x3c,0x46,0x46,0x44,
0x3d,0x39,0x37,0x38,0x3a,0x3d,0x3d,0x3a,0x38,0x37,0x38,0x3b,0x3a,0x39,0x38,0x37,
0x38,0x38,0x39,0x3b,0x3d,0x3d,0x3b,0x38,0x38,0x38,0x39,0x3a,0x3a,0x3a,0x38,0x33,
0x32,0x39,0x48,0x5a,0x6b,0x77,0x7a,0x75,0x6a,0x60,0x5a,0x5b,0x63,0x6b,0x74,0x78,
0x7b,0x82,0x8c,0x98,0xa5,0xaf,0xb0,0xab,0xa1,0x99,0x93,0x94,0x98,0x9c,0x9f,0xa1,
0xa1,0xa1,0x9e,0x9e,0x9e,0x9e,0x9b,0x98,0x93,0x8a,0x79,0x6c,0x5e,0x52,0x4a,0x43,
0x3e,0x3b,0x38,0x33,0x33,0x36,0x3b,0x40,0x40,0x3e,0x3c,0x3a,0x39,0x36,0x3a,0x3a,
0x3a,0x3b,0x3a,0x39,0x3c,0x3b,0x3d,0x3f,0x3c,0x3a,0x3b,0x3c,0x3f,0x47,0x55,0x66,
0x75,0x83,0x8c,0x92,0x98,0x9c,0xa0,0xa4,0xa6,0xa2,0x97,0x85,0x73,0x67,0x5e,0x58,
0x53,0x4e,0x46,0x3d,0x37,0x3b,0x4a,0x5f,0x73,0x80,0x84,0x79,0x6c,0x62,0x5d,0x5f,
0x65,0x6c,0x6f,0x72,0x76,0x7f,0x88,0x94,0x9e,0xa6,0xa9,0xa5,0x9e,0x99,0x98,0x97,
0x98,0x97,0x92,0x89,0x7a,0x6a,0x5b,0x4e,0x48,0x43,0x3e,0x39,0x36,0x36,0x37,0x38,
0x3a,0x3c,0x3d,0x3c,0x38,0x36,0x35,0x37,0x39,0x3d,0x3e,0x3d,0x39,0x36,0x35,0x37,
0x3b,0x3d,0x3a,0x38,0x34,0x33,0x3c,0x4b,0x5e,0x75,0x80,0x7f,0x76,0x6a,0x63,0x5e,
0x62,0x69,0x6f,0x75,0x77,0x7d,0x84,0x8e,0x98,0xa0,0x9d,0x8f,0x79,0x63,0x52,0x4f,
0x56,0x66,0x74,0x7f,0x80,0x7b,0x71,0x66,0x5e,0x5e,0x63,0x6b,0x72,0x73,0x6f,0x67,
0x5e,0x59,0x5d,0x65,0x6f,0x79,0x7d,0x77,0x6f,0x69,0x63,0x61,0x60,0x5e,0x56,0x4b,
0x3d,0x32,0x2b,0x29,0x2b,0x32,0x3b,0x44,0x4c,0x57,0x60,0x6d,0x7c,0x89,0x91,0x96,
0x96,0x90,0x84,0x72,0x5c,0x4e,0x43,0x3c,0x38,0x36,0x36,0x35,0x39,0x3c,0x40,0x44,
0x45,0x40,0x38,0x30,0x2f,0x39,0x4a,0x5e,0x6d,0x75,0x74,0x6f,0x68,0x61,0x59,0x52,
0x4b,0x46,0x40,0x39,0x33,0x32,0x33,0x36,0x3d,0x48,0x57,0x68,0x76,0x7b,0x78,0x6f,
0x65,0x5c,0x57,0x51,0x4d,0x49,0x41,0x35,0x2f,0x2a,0x2d,0x38,0x41,0x48,0x4f,0x57,
0x61,0x6f,0x7c,0x89,0x93,0x9a,0x9a,0x95,0x89,0x7a,0x6a,0x5b,0x4e,0x44,0x3e,0x3a,
0x3a,0x3f,0x47,0x52,0x62,0x74,0x83,0x8e,0x91,0x91,0x94,0x9a,0xa0,0xa2,0x9e,0x96,
0x86,0x75,0x62,0x52,0x4d,0x47,0x44,0x41,0x3c,0x39,0x35,0x36,0x35,0x37,0x3d,0x48,
0x51,0x5d,0x65,0x6f,0x7b,0x86,0x8d,0x93,0x94,0x90,0x84,0x70,0x5e,0x54,0x52,0x5b,
0x68,0x77,0x7f,0x7e,0x77,0x6d,0x65,0x61,0x5c,0x55,0x4c,0x41,0x35,0x2e,0x2a,0x2c,
0x33,0x3c,0x44,0x4c,0x57,0x63,0x6d,0x79,0x83,0x8e,0x98,0x9b,0x95,0x8a,0x78,0x67,
0x5a,0x55,0x5c,0x69,0x76,0x7d,0x7d,0x76,0x6c,0x62,0x5c,0x5c,0x5f,0x67,0x6d,0x72,
0x78,0x82,0x8c,0x99,0xa3,0xaa,0xac,0xa9,0x9e,0x90,0x7d,0x6c,0x5f,0x58,0x52,0x4d,
0x49,0x40,0x36,0x31,0x36,0x48,0x5e,0x73,0x82,0x83,0x78,0x67,0x57,0x4f,0x4d,0x4c,
0x48,0x3f,0x35,0x2f,0x2f,0x32,0x39,0x42,0x47,0x47,0x41,0x3c,0x37,0x3a,0x3b,0x3c,
0x3d,0x3f,0x3f,0x40,0x3d,0x37,0x39,0x3f,0x48,0x55,0x63,0x72,0x80,0x8b,0x90,0x8f,
0x8f,0x88,0x7e,0x72,0x64,0x56,0x4d,0x44,0x3c,0x3a,0x3a,0x40,0x4c,0x5b,0x69,0x78,
0x82,0x89,0x8c,0x90,0x94,0x9a,0x9e,0xa0,0xa0,0x9e,0x9b,0x9a,0x9c,0xa1,0xa4,0xa3,
0x9f,0x9e,0x9e,0x9d,0x9e,0x9f,0x9e,0x9b,0x99,0x9c,0x9f,0xa1,0xa0,0x97,0x86,0x76,
0x66,0x5d,0x57,0x52,0x4a,0x3f,0x35,0x31,0x36,0x4b,0x63,0x76,0x7f,0x7d,0x71,0x65,
0x5c,0x59,0x58,0x52,0x46,0x3a,0x31,0x33,0x43,0x5b,0x73,0x82,0x85,0x7b,0x6c,0x5d,
0x53,0x4f,0x4c,0x46,0x3e,0x37,0x32,0x2f,0x2f,0x34,0x3c,0x48,0x53,0x61,0x6d,0x79,
0x7b,0x77,0x6f,0x65,0x5e,0x60,0x65,0x6a,0x71,0x77,0x7a,0x7e,0x84,0x8f,0x9e,0xa9,
0xac,0xa8,0x9e,0x8f,0x80,0x71,0x66,0x60,0x5c,0x56,0x4c,0x43,0x3b,0x38,0x3d,0x4a,
0x5c,0x70,0x7e,0x82,0x7a,0x6c,0x5e,0x56,0x58,0x5e,0x66,0x71,0x75,0x79,0x7f,0x88,
0x94,0xa1,0xa8,0xaa,0xa6,0x9e,0x91,0x80,0x74,0x68,0x5d,0x55,0x4d,0x48,0x41,0x3a,
0x35,0x38,0x40,0x50,0x65,0x77,0x85,0x90,0x95,0x98,0x99,0x9b,0x9e,0xa0,0x9f,0x98,
0x8b,0x7b,0x69,0x5c,0x55,0x57,0x60,0x6c,0x77,0x7e,0x7e,0x75,0x67,0x5c,0x5c,0x61,
0x69,0x73,0x78,0x75,0x6f,0x66,0x5e,0x5f,0x5f,0x5d,0x54,0x46,0x38,0x2f,0x31,0x3d,
0x50,0x67,0x7d,0x8d,0x97,0x9a,0x98,0x92,0x87,0x7a,0x6d,0x62,0x58,0x4f,0x43,0x3a,
0x33,0x33,0x3a,0x49,0x5d,0x71,0x7e,0x80,0x78,0x69,0x5e,0x52,0x4a,0x48,0x43,0x3c,
0x34,0x2d,0x2b,0x2f,0x37,0x3f,0x43,0x43,0x40,0x3a,0x34,0x30,0x31,0x35,0x39,0x3c,
0x3f,0x40,0x3d,0x3a,0x37,0x3c,0x49,0x5d,0x70,0x7c,0x7e,0x78,0x6e,0x63,0x5d,0x5c,
0x62,0x69,0x6f,0x74,0x78,0x7f,0x8b,0x96,0xa1,0xab,0xad,0xa9,0xa2,0x9b,0x98,0x96,
0x98,0x9b,0x9c,0x9f,0x9f,0x9e,0x9c,0x94,0x89,0x7c,0x6c,0x5e,0x56,0x57,0x5f,0x6b,
0x77,0x7e,0x7d,0x76,0x6a,0x61,0x5f,0x62,0x68,0x6f,0x73,0x71,0x6c,0x63,0x5b,0x5b,
0x5c,0x5c,0x54,0x4b,0x3e,0x34,0x2d,0x2c,0x31,0x3c,0x43,0x45,0x46,0x41,0x3b,0x38,
0x35,0x36,0x3a,0x3e,0x3e,0x3a,0x39,0x37,0x35,0x37,0x3d,0x45,0x55,0x65,0x71,0x80,
0x8c,0x98,0x9d,0x9b,0x92,0x85,0x74,0x65,0x5a,0x58,0x5c,0x63,0x6c,0x77,0x82,0x8c,
0x94,0x9a,0x9c,0x97,0x89,0x75,0x61,0x55,0x52,0x57,0x60,0x6d,0x79,0x84,0x8e,0x96,
0x9a,0x99,0x93,0x86,0x75,0x64,0x56,0x4d,0x4a,0x43,0x3c,0x39,0x3b,0x46,0x57,0x69,
0x79,0x85,0x8c,0x8f,0x91,0x96,0x9e,0xa5,0xa9,0xa4,0x95,0x83,0x70,0x63,0x5c,0x56,
0x52,0x4b,0x40,0x38,0x35,0x3c,0x4a,0x5e,0x71,0x7f,0x81,0x7a,0x6d,0x60,0x58,0x57,
0x5d,0x67,0x71,0x78,0x7c,0x81,0x89,0x94,0x9f,0xa9,0xad,0xa9,0x9e,0x91,0x82,0x74,
0x69,0x62,0x59,0x50,0x48,0x41,0x3d,0x37,0x3c,0x46,0x55,0x69,0x7b,0x89,0x95,0x9a,
0x98,0x94,0x8a,0x80,0x76,0x67,0x55,0x4a,0x40,0x3a,0x34,0x38,0x3e,0x4a,0x57,0x68,
0x78,0x88,0x93,0x98,0x98,0x93,0x8a,0x81,0x73,0x64,0x55,0x48,0x3d,0x36,0x34,0x37,
0x40,0x4d,0x5a,0x67,0x75,0x82,0x8e,0x98,0x9a,0x99,0x92,0x85,0x75,0x67,0x5d,0x58,
0x59,0x5e,0x69,0x76,0x83,0x8e,0x93,0x9e,0xa0,0xa1,0xa3,0xa2,0x9c,0x93,0x85,0x74,
0x65,0x5a,0x55,0x58,0x60,0x6b,0x74,0x7a,0x77,0x71,0x69,0x63,0x5e,0x5b,0x53,0x49,
0x3e,0x34,0x30,0x39,0x4d,0x67,0x7f,0x8e,0x94,0x98,0x99,0x98,0x92,0x89,0x7a,0x69,
0x5b,0x55,0x59,0x67,0x76,0x7e,0x7d,0x75,0x69,0x5e,0x5e,0x61,0x6a,0x74,0x79,0x76,
0x75,0x6d,0x65,0x63,0x63,0x66,0x6b,0x6f,0x6f,0x73,0x78,0x81,0x8c,0x96,0x9b,0x9a,
0x8f,0x7e,0x68,0x54,0x47,0x40,0x3c,0x3a,0x3c,0x43,0x4b,0x57,0x65,0x76,0x83,0x8e,
0x92,0x94,0x93,0x8e,0x83,0x74,0x67,0x57,0x49,0x40,0x3a,0x36,0x39,0x3d,0x44,0x52,
0x64,0x75,0x83,0x8c,0x90,0x93,0x97,0x9c,0xa0,0xa4,0xa3,0x9c,0x8f,0x80,0x70,0x64,
0x5d,0x5d,0x65,0x6f,0x7a,0x7f,0x7c,0x71,0x65,0x5c,0x5a,0x5e,0x6a,0x73,0x77,0x76,
0x6d,0x64,0x60,0x5e,0x5d,0x5e,0x58,0x4d,0x40,0x32,0x2b,0x2b,0x33,0x3d,0x43,0x46,
0x45,0x42,0x3e,0x38,0x34,0x36,0x3a,0x3c,0x3d,0x3c,0x3c,0x3b,0x38,0x35,0x36,0x39,
0x3d,0x3f,0x3f,0x3e,0x3c,0x3b,0x3a,0x38,0x38,0x3a,0x39,0x39,0x39,0x38,0x36,0x38,
// Line 12
0x36,0x35,0x35,0x38,0x3a,0x3a,0x38,0x34,0x33,0x37,0x39,0x39,0x38,0x37,0x37,0x38,
0x39,0x3a,0x39,0x39,0x39,0x3a,0x39,0x38,0x38,0x3a,0x39,0x38,0x38,0x3a,0x3a,0x3a,
0x38,0x37,0x37,0x37,0x38,0x39,0x3a,0x3a,0x3a,0x39,0x39,0x37,0x35,0x33,0x34,0x36,
0x37,0x36,0x34,0x32,0x33,0x3a,0x48,0x59,0x6a,0x79,0x7c,0x77,0x6b,0x5e,0x57,0x5b,
0x62,0x6b,0x75,0x79,0x74,0x6c,0x61,0x5a,0x5c,0x62,0x6b,0x71,0x75,0x74,0x6f,0x67,
0x5f,0x5c,0x5c,0x62,0x6b,0x74,0x79,0x76,0x6e,0x66,0x5e,0x5c,0x5d,0x65,0x6e,0x73,
0x75,0x73,0x6e,0x69,0x62,0x5e,0x5e,0x61,0x6a,0x72,0x75,0x75,0x6c,0x62,0x5d,0x5a,
0x5d,0x64,0x6e,0x75,0x77,0x74,0x6c,0x65,0x5e,0x5b,0x5d,0x66,0x6f,0x76,0x79,0x78,
0x72,0x6c,0x65,0x61,0x62,0x66,0x69,0x6b,0x6d,0x6e,0x71,0x77,0x81,0x8d,0x9b,0xa8,
0xad,0xa9,0xa0,0x8f,0x7e,0x6f,0x63,0x5b,0x58,0x54,0x4e,0x45,0x3c,0x32,0x38,0x44,
0x56,0x6c,0x7e,0x89,0x8e,0x91,0x94,0x99,0x9d,0xa0,0x9e,0x9b,0x97,0x97,0x98,0x9b,
0x9a,0x94,0x86,0x75,0x67,0x5e,0x57,0x4e,0x44,0x3a,0x34,0x32,0x3a,0x4d,0x63,0x76,
0x7f,0x7c,0x70,0x62,0x5b,0x54,0x4e,0x4a,0x42,0x37,0x30,0x30,0x3f,0x58,0x70,0x80,
0x82,0x7b,0x6b,0x5c,0x4f,0x49,0x46,0x44,0x3e,0x37,0x31,0x2e,0x2e,0x32,0x3a,0x47,
0x57,0x65,0x6f,0x74,0x72,0x6c,0x65,0x5e,0x59,0x54,0x4e,0x44,0x3b,0x36,0x35,0x3f,
0x54,0x6b,0x7e,0x8c,0x94,0x98,0x98,0x96,0x8e,0x83,0x72,0x63,0x59,0x59,0x62,0x70,
0x7a,0x7e,0x79,0x6e,0x64,0x5f,0x60,0x5d,0x53,0x43,0x31,0x28,0x2e,0x42,0x5d,0x74,
0x81,0x7f,0x72,0x64,0x5a,0x57,0x55,0x4e,0x42,0x39,0x30,0x30,0x3c,0x56,0x71,0x83,
0x85,0x78,0x61,0x54,0x50,0x58,0x67,0x74,0x7b,0x7b,0x72,0x66,0x61,0x65,0x67,0x64,
0x58,0x46,0x34,0x2a,0x2e,0x3f,0x59,0x70,0x7c,0x7f,0x78,0x6c,0x62,0x5a,0x55,0x50,
0x49,0x3f,0x38,0x3c,0x4b,0x62,0x76,0x81,0x81,0x79,0x6b,0x5d,0x54,0x50,0x4b,0x44,
0x39,0x2e,0x2b,0x2d,0x32,0x3b,0x40,0x3f,0x3c,0x3a,0x38,0x38,0x3d,0x3c,0x3a,0x35,
0x36,0x3f,0x4f,0x62,0x74,0x81,0x81,0x78,0x69,0x5c,0x58,0x5c,0x63,0x6a,0x6d,0x74,
0x79,0x81,0x8d,0x98,0x9d,0x9b,0x8c,0x76,0x5d,0x4a,0x3f,0x3a,0x3a,0x3a,0x3a,0x3a,
0x39,0x3a,0x3c,0x3f,0x40,0x3f,0x39,0x33,0x32,0x3a,0x49,0x5f,0x73,0x7f,0x81,0x79,
0x6c,0x61,0x5b,0x5d,0x66,0x71,0x76,0x75,0x70,0x69,0x63,0x61,0x5e,0x5c,0x57,0x4f,
0x46,0x3c,0x33,0x2d,0x2c,0x32,0x3a,0x45,0x55,0x65,0x6f,0x76,0x74,0x6d,0x66,0x5d,
0x5a,0x5a,0x56,0x4b,0x3e,0x33,0x32,0x3f,0x55,0x6f,0x82,0x88,0x80,0x6f,0x5d,0x55,
0x58,0x63,0x6c,0x73,0x79,0x7e,0x85,0x8f,0x98,0xa2,0xa7,0xa5,0xa1,0x9b,0x98,0x97,
0x97,0x9a,0x9b,0x9e,0xa2,0xa5,0xa7,0xa4,0x9c,0x8e,0x7b,0x6a,0x5d,0x55,0x4f,0x4a,
0x41,0x3b,0x32,0x2e,0x2d,0x31,0x36,0x3a,0x38,0x36,0x35,0x35,0x35,0x38,0x3a,0x3f,
0x43,0x44,0x41,0x3d,0x3e,0x3a,0x3a,0x3f,0x49,0x56,0x65,0x74,0x81,0x8d,0x96,0x9a,
0x96,0x8f,0x81,0x73,0x63,0x56,0x4b,0x43,0x3e,0x3a,0x39,0x39,0x3a,0x41,0x42,0x42,
0x3f,0x3c,0x38,0x34,0x33,0x3b,0x49,0x5a,0x68,0x73,0x7e,0x8a,0x95,0x9b,0x9c,0x96,
0x8a,0x76,0x61,0x55,0x53,0x5d,0x6b,0x77,0x7b,0x7a,0x74,0x6a,0x60,0x5b,0x55,0x4c,
0x43,0x36,0x2a,0x27,0x26,0x2c,0x38,0x3f,0x41,0x3c,0x37,0x33,0x34,0x38,0x3a,0x3a,
0x37,0x36,0x3c,0x4a,0x5c,0x6e,0x7a,0x7a,0x72,0x67,0x5d,0x58,0x5a,0x61,0x68,0x70,
0x75,0x7a,0x81,0x8c,0x97,0x9b,0x98,0x8c,0x7a,0x66,0x53,0x45,0x3e,0x3a,0x3a,0x39,
0x36,0x33,0x33,0x36,0x3a,0x3f,0x47,0x51,0x5d,0x6d,0x7c,0x88,0x93,0x99,0x97,0x93,
0x85,0x76,0x65,0x5a,0x55,0x5b,0x63,0x6e,0x76,0x84,0x8d,0x94,0x9a,0x9e,0xa1,0xa3,
0xa1,0x9a,0x95,0x93,0x96,0x99,0x9a,0x99,0x9c,0xa0,0xa0,0x9a,0x8f,0x84,0x76,0x69,
0x5c,0x51,0x4a,0x45,0x3f,0x3a,0x38,0x3a,0x44,0x54,0x66,0x79,0x85,0x8c,0x8e,0x91,
0x96,0x9d,0xa2,0xa4,0xa0,0x95,0x83,0x70,0x62,0x5b,0x56,0x50,0x46,0x3a,0x32,0x31,
0x39,0x49,0x5f,0x74,0x81,0x85,0x7b,0x6b,0x61,0x5c,0x5c,0x63,0x69,0x6f,0x73,0x76,
0x79,0x83,0x92,0xa0,0xa9,0xa8,0xa2,0x9d,0x98,0x96,0x97,0x9b,0x9d,0x96,0x8a,0x79,
0x6b,0x61,0x56,0x4c,0x44,0x3e,0x38,0x33,0x39,0x49,0x5f,0x73,0x7c,0x7b,0x71,0x62,
0x55,0x51,0x53,0x5b,0x65,0x6e,0x70,0x76,0x7e,0x8a,0x95,0x9e,0x9d,0x8f,0x79,0x60,
0x4e,0x4c,0x54,0x64,0x74,0x7c,0x7d,0x74,0x66,0x5d,0x5a,0x5e,0x65,0x6a,0x6d,0x6d,
0x73,0x7e,0x8b,0x98,0xa0,0x9d,0x8e,0x77,0x5e,0x4f,0x4c,0x56,0x64,0x73,0x7b,0x7c,
0x74,0x6a,0x61,0x59,0x54,0x4d,0x43,0x3c,0x33,0x2b,0x2b,0x2e,0x34,0x3c,0x41,0x4a,
0x59,0x6b,0x77,0x78,0x71,0x67,0x5e,0x5b,0x5e,0x67,0x73,0x79,0x77,0x6e,0x61,0x5a,
0x57,0x59,0x59,0x53,0x47,0x39,0x2f,0x2b,0x2c,0x34,0x3e,0x44,0x45,0x44,0x3e,0x39,
0x35,0x34,0x31,0x2c,0x28,0x2a,0x36,0x4b,0x60,0x6f,0x79,0x77,0x6f,0x67,0x5f,0x59,
0x56,0x51,0x48,0x3c,0x30,0x2f,0x3c,0x52,0x6a,0x7e,0x85,0x7f,0x6f,0x5d,0x52,0x51,
0x5b,0x67,0x71,0x76,0x75,0x6f,0x66,0x5f,0x5f,0x67,0x6c,0x70,0x75,0x79,0x75,0x6b,
0x62,0x5c,0x5d,0x65,0x70,0x79,0x7c,0x78,0x6d,0x64,0x5c,0x5b,0x5e,0x65,0x67,0x67,
0x66,0x6a,0x71,0x7c,0x8b,0x97,0x9c,0x98,0x89,0x77,0x64,0x54,0x49,0x41,0x3c,0x3c,
0x3c,0x40,0x49,0x58,0x68,0x77,0x81,0x89,0x8f,0x95,0x99,0x9b,0x9d,0xa0,0xa0,0x9b,
0x8e,0x7c,0x6a,0x5d,0x54,0x54,0x5c,0x69,0x75,0x7d,0x7a,0x6f,0x65,0x5d,0x5b,0x62,
0x6c,0x75,0x78,0x72,0x6a,0x62,0x5d,0x59,0x59,0x59,0x54,0x49,0x39,0x2e,0x2d,0x3a,
0x4e,0x65,0x7a,0x8c,0x98,0x9f,0x9a,0x91,0x85,0x7a,0x6f,0x65,0x58,0x4e,0x3f,0x36,
0x2e,0x2c,0x37,0x4a,0x5f,0x75,0x7e,0x7a,0x73,0x68,0x5e,0x59,0x55,0x50,0x48,0x3c,
0x33,0x32,0x39,0x49,0x5f,0x79,0x8a,0x92,0x93,0x92,0x95,0x9b,0xa1,0xa3,0xa2,0x99,
0x8b,0x7c,0x6d,0x62,0x5b,0x5c,0x5d,0x64,0x6d,0x78,0x7f,0x8b,0x92,0x97,0x97,0x91,
0x86,0x79,0x69,0x58,0x49,0x40,0x3b,0x3a,0x3b,0x3f,0x49,0x56,0x65,0x74,0x82,0x8b,
0x90,0x96,0x99,0x9b,0xa0,0xa0,0x9a,0x91,0x84,0x76,0x66,0x59,0x4e,0x47,0x42,0x3c,
0x39,0x38,0x35,0x34,0x34,0x36,0x3a,0x42,0x4c,0x57,0x65,0x71,0x7b,0x83,0x89,0x8f,
0x97,0xa0,0xa2,0x9e,0x9c,0x98,0x96,0x99,0x9a,0x98,0x92,0x87,0x79,0x6b,0x5d,0x54,
0x4e,0x47,0x3e,0x36,0x34,0x39,0x44,0x55,0x67,0x77,0x83,0x88,0x8b,0x8f,0x96,0x9d,
0xa2,0xa4,0xa2,0x9c,0x95,0x92,0x93,0x96,0x96,0x8f,0x80,0x6a,0x5a,0x55,0x59,0x64,
0x73,0x7e,0x7f,0x78,0x6c,0x65,0x61,0x5f,0x59,0x4d,0x3d,0x2f,0x28,0x2e,0x40,0x5a,
0x73,0x81,0x83,0x7c,0x6f,0x62,0x59,0x54,0x4f,0x48,0x3e,0x34,0x2f,0x31,0x36,0x3c,
0x3f,0x3e,0x3a,0x37,0x33,0x34,0x37,0x36,0x32,0x2f,0x30,0x3a,0x4b,0x61,0x73,0x7d,
0x7d,0x75,0x67,0x5e,0x58,0x53,0x50,0x47,0x3b,0x33,0x31,0x3a,0x4c,0x64,0x7b,0x8e,
0x95,0x96,0x95,0x94,0x96,0x99,0x9a,0x98,0x96,0x97,0x96,0x95,0x95,0x98,0x9b,0x9f,
0xa0,0x9d,0x95,0x89,0x78,0x69,0x5c,0x54,0x4f,0x49,0x3f,0x36,0x32,0x38,0x47,0x5d,
0x70,0x7b,0x7d,0x75,0x68,0x5b,0x59,0x5a,0x60,0x69,0x6f,0x74,0x79,0x81,0x8b,0x95,
0x98,0x92,0x83,0x6f,0x5c,0x4e,0x42,0x3a,0x37,0x38,0x37,0x37,0x3a,0x3e,0x41,0x41,
0x3c,0x36,0x33,0x31,0x32,0x35,0x36,0x35,0x34,0x33,0x3a,0x45,0x5a,0x6d,0x79,0x7e,
0x77,0x69,0x5d,0x56,0x5b,0x69,0x76,0x7c,0x7c,0x78,0x6f,0x66,0x60,0x5e,0x5b,0x55,
0x49,0x38,0x2b,0x22,0x22,0x2a,0x32,0x3a,0x40,0x41,0x3f,0x38,0x32,0x2e,0x30,0x32,
0x36,0x3a,0x3c,0x3b,0x38,0x36,0x36,0x3b,0x46,0x55,0x62,0x73,0x7d,0x85,0x8a,0x90,
0x98,0xa0,0xa4,0xa4,0x9f,0x9d,0x9b,0x9d,0x9e,0x9d,0x97,0x8b,0x79,0x68,0x5a,0x51,
0x4b,0x46,0x3d,0x35,0x32,0x36,0x45,0x5b,0x72,0x82,0x85,0x7d,0x6c,0x5d,0x56,0x58,
0x60,0x6d,0x76,0x78,0x71,0x68,0x5f,0x5a,0x5c,0x62,0x69,0x74,0x79,0x79,0x73,0x6b,
0x64,0x61,0x61,0x65,0x6e,0x74,0x76,0x73,0x6b,0x62,0x5d,0x5c,0x5b,0x5a,0x57,0x4e,
0x40,0x33,0x2a,0x25,0x28,0x30,0x39,0x42,0x4c,0x56,0x60,0x6b,0x77,0x86,0x92,0x98,
0x99,0x93,0x88,0x78,0x69,0x5b,0x4e,0x44,0x3c,0x35,0x37,0x3f,0x4e,0x5e,0x70,0x79,
0x7a,0x74,0x68,0x5b,0x51,0x4c,0x47,0x41,0x3a,0x33,0x2e,0x2c,0x2d,0x34,0x3c,0x40,
0x40,0x3c,0x36,0x36,0x36,0x35,0x33,0x34,0x38,0x3f,0x4b,0x5a,0x69,0x78,0x82,0x88,
0x90,0x97,0x98,0x91,0x83,0x70,0x60,0x54,0x4f,0x50,0x5c,0x69,0x76,0x83,0x8d,0x97,
0x9e,0xa0,0x95,0x85,0x70,0x5e,0x51,0x47,0x40,0x3b,0x36,0x34,0x39,0x49,0x5c,0x70,
0x7e,0x81,0x7a,0x6d,0x5e,0x57,0x59,0x60,0x67,0x6e,0x73,0x79,0x81,0x8c,0x95,0x9b,
0xa4,0xa7,0xa4,0x9d,0x91,0x83,0x77,0x66,0x57,0x50,0x4c,0x4b,0x47,0x3f,0x36,0x30,
0x2d,0x30,0x35,0x3a,0x3c,0x3a,0x36,0x30,0x2e,0x31,0x33,0x33,0x35,0x36,0x36,0x36,
0x35,0x36,0x38,0x3a,0x39,0x37,0x36,0x38,0x38,0x3a,0x39,0x38,0x38,0x35,0x33,0x33,
// Line 13
0x38,0x38,0x39,0x3a,0x38,0x36,0x37,0x39,0x3a,0x39,0x36,0x35,0x35,0x37,0x37,0x37,
0x37,0x35,0x32,0x31,0x32,0x35,0x39,0x39,0x37,0x36,0x35,0x36,0x37,0x38,0x38,0x37,
0x38,0x37,0x34,0x33,0x33,0x33,0x35,0x35,0x35,0x36,0x35,0x34,0x33,0x34,0x37,0x37,
0x3b,0x3a,0x37,0x34,0x33,0x37,0x45,0x56,0x67,0x73,0x77,0x72,0x69,0x5f,0x59,0x5b,
0x65,0x71,0x78,0x79,0x74,0x6b,0x64,0x5f,0x5e,0x64,0x6b,0x71,0x76,0x75,0x70,0x69,
0x62,0x5e,0x5e,0x64,0x6c,0x73,0x75,0x72,0x6d,0x67,0x5f,0x59,0x5a,0x60,0x68,0x71,
0x75,0x75,0x71,0x69,0x5f,0x5b,0x5b,0x61,0x6a,0x73,0x75,0x73,0x6d,0x64,0x5b,0x5a,
0x5d,0x64,0x6d,0x72,0x74,0x71,0x69,0x60,0x5a,0x59,0x5d,0x65,0x6d,0x72,0x75,0x74,
0x6e,0x66,0x60,0x5e,0x5f,0x64,0x67,0x69,0x6b,0x6f,0x71,0x78,0x83,0x91,0x9b,0xa6,
0xa8,0xa8,0xa0,0x91,0x7f,0x6f,0x61,0x59,0x55,0x52,0x4c,0x44,0x3c,0x35,0x37,0x42,
0x55,0x6a,0x7c,0x87,0x8c,0x90,0x93,0x96,0x9b,0x9f,0xa0,0x9d,0x9a,0x97,0x97,0x98,
0x98,0x93,0x8a,0x7c,0x6e,0x60,0x55,0x4e,0x48,0x3f,0x36,0x37,0x3d,0x4b,0x63,0x75,
0x7f,0x7e,0x74,0x66,0x5c,0x56,0x53,0x4d,0x44,0x37,0x30,0x35,0x44,0x59,0x6f,0x7f,
0x84,0x7d,0x6f,0x60,0x56,0x50,0x4b,0x46,0x40,0x39,0x33,0x2e,0x2b,0x2f,0x38,0x45,
0x54,0x63,0x6f,0x76,0x77,0x71,0x68,0x61,0x5c,0x58,0x52,0x49,0x3f,0x35,0x37,0x40,
0x52,0x6a,0x7f,0x8e,0x95,0x96,0x94,0x92,0x8c,0x82,0x72,0x61,0x56,0x58,0x62,0x70,
0x7b,0x7e,0x78,0x6d,0x64,0x61,0x5f,0x5c,0x53,0x44,0x35,0x2b,0x2f,0x44,0x5e,0x75,
0x81,0x80,0x75,0x67,0x5e,0x57,0x52,0x4e,0x45,0x3a,0x35,0x37,0x46,0x5f,0x74,0x81,
0x83,0x7a,0x6d,0x60,0x57,0x50,0x49,0x41,0x38,0x33,0x34,0x3f,0x51,0x69,0x7d,0x8b,
0x91,0x95,0x98,0x9c,0xa0,0xa3,0xa3,0xa0,0x9c,0x98,0x98,0x98,0x9a,0x9a,0x92,0x81,
0x6d,0x5d,0x56,0x5a,0x63,0x6d,0x75,0x77,0x72,0x6c,0x64,0x5d,0x59,0x54,0x4a,0x3f,
0x34,0x2f,0x2b,0x2e,0x34,0x3a,0x41,0x44,0x40,0x40,0x3e,0x3b,0x3b,0x39,0x38,0x36,
0x39,0x3f,0x4d,0x60,0x73,0x7e,0x7e,0x75,0x68,0x5f,0x5c,0x5e,0x66,0x6e,0x73,0x77,
0x7b,0x83,0x8e,0x9a,0x9f,0x9b,0x8e,0x7a,0x64,0x54,0x4e,0x51,0x5e,0x6c,0x78,0x85,
0x8d,0x95,0x9c,0xa0,0xa2,0xa1,0xa1,0x9d,0x9a,0x9b,0x9c,0x9d,0x9e,0xa0,0xa1,0xa2,
0x9f,0x9a,0x90,0x83,0x74,0x67,0x5b,0x51,0x4a,0x44,0x3e,0x39,0x36,0x35,0x36,0x38,
0x3a,0x3b,0x3c,0x3b,0x38,0x37,0x37,0x38,0x3a,0x3c,0x3e,0x3a,0x39,0x38,0x37,0x3a,
0x3c,0x3b,0x3b,0x35,0x31,0x34,0x3d,0x4d,0x60,0x70,0x79,0x7a,0x73,0x6a,0x61,0x5d,
0x59,0x52,0x49,0x3d,0x33,0x34,0x3f,0x56,0x70,0x83,0x8a,0x82,0x6f,0x5e,0x59,0x5c,
0x64,0x6c,0x71,0x75,0x7a,0x82,0x8c,0x94,0x9c,0x97,0x87,0x75,0x60,0x50,0x45,0x41,
0x3b,0x38,0x35,0x36,0x39,0x3e,0x3f,0x3e,0x3b,0x37,0x34,0x33,0x35,0x3a,0x3e,0x3c,
0x39,0x38,0x3e,0x4b,0x5e,0x71,0x7d,0x80,0x77,0x68,0x5b,0x57,0x5c,0x69,0x76,0x7c,
0x7b,0x75,0x6d,0x64,0x5f,0x5d,0x5b,0x55,0x4b,0x3e,0x2f,0x2a,0x29,0x2c,0x35,0x3c,
0x41,0x41,0x3d,0x36,0x34,0x31,0x31,0x35,0x39,0x3e,0x3f,0x3e,0x3a,0x37,0x38,0x3b,
0x44,0x55,0x66,0x75,0x80,0x87,0x8c,0x93,0x99,0x9f,0xa1,0xa1,0x9e,0x9c,0x98,0x98,
0x98,0x99,0x96,0x8b,0x7c,0x6b,0x5a,0x50,0x46,0x41,0x42,0x3e,0x3a,0x37,0x35,0x35,
0x39,0x3d,0x3e,0x3b,0x34,0x2f,0x2f,0x36,0x42,0x51,0x61,0x71,0x80,0x8e,0x97,0x9b,
0x9a,0x91,0x84,0x74,0x63,0x58,0x4e,0x47,0x3e,0x37,0x35,0x3b,0x49,0x61,0x74,0x80,
0x81,0x77,0x66,0x59,0x51,0x55,0x63,0x72,0x7a,0x79,0x6f,0x62,0x5b,0x5c,0x5f,0x5e,
0x57,0x44,0x33,0x2c,0x30,0x40,0x5a,0x73,0x83,0x85,0x7b,0x6d,0x61,0x5a,0x55,0x4d,
0x43,0x38,0x32,0x38,0x47,0x5c,0x71,0x80,0x82,0x78,0x67,0x59,0x52,0x4f,0x4b,0x43,
0x39,0x33,0x34,0x3f,0x51,0x65,0x7c,0x8b,0x91,0x96,0x97,0x98,0x9c,0x9e,0x9e,0x9d,
0x9b,0x9a,0x9a,0x9a,0x99,0x9a,0x9b,0x9c,0x9c,0x9a,0x90,0x83,0x75,0x67,0x5a,0x50,
0x47,0x45,0x43,0x3d,0x36,0x32,0x31,0x35,0x3a,0x3d,0x3b,0x37,0x33,0x30,0x30,0x34,
0x39,0x3d,0x3d,0x3a,0x38,0x3a,0x3d,0x40,0x43,0x42,0x3e,0x37,0x31,0x32,0x3a,0x49,
0x5d,0x6c,0x75,0x75,0x6e,0x66,0x5b,0x52,0x50,0x4f,0x48,0x3e,0x32,0x2a,0x2b,0x32,
0x3c,0x43,0x49,0x43,0x37,0x2f,0x2d,0x34,0x42,0x51,0x61,0x71,0x7c,0x85,0x8d,0x93,
0x9c,0xa1,0xa1,0x9d,0x9a,0x98,0x98,0x98,0x98,0x98,0x92,0x88,0x78,0x6a,0x5f,0x56,
0x4d,0x43,0x39,0x33,0x33,0x3a,0x48,0x59,0x6d,0x77,0x76,0x6e,0x63,0x59,0x52,0x4d,
0x46,0x42,0x3b,0x33,0x2e,0x2f,0x33,0x3a,0x3f,0x41,0x3e,0x3c,0x3a,0x39,0x3a,0x39,
0x34,0x31,0x31,0x37,0x48,0x5d,0x6e,0x78,0x76,0x70,0x68,0x5f,0x59,0x55,0x51,0x4b,
0x3f,0x35,0x2e,0x2d,0x33,0x39,0x3d,0x41,0x40,0x3f,0x3b,0x36,0x32,0x31,0x33,0x36,
0x3a,0x3d,0x3c,0x38,0x34,0x35,0x3d,0x49,0x59,0x69,0x77,0x79,0x71,0x64,0x59,0x52,
0x50,0x4f,0x4b,0x43,0x3e,0x37,0x31,0x34,0x39,0x3e,0x47,0x4a,0x4f,0x5a,0x68,0x75,
0x80,0x88,0x8f,0x96,0x9e,0xa4,0xa5,0xa0,0x93,0x81,0x6d,0x5c,0x54,0x53,0x51,0x4a,
0x41,0x36,0x31,0x36,0x43,0x59,0x70,0x7e,0x80,0x74,0x64,0x56,0x50,0x56,0x5f,0x6c,
0x73,0x73,0x6c,0x63,0x5c,0x5a,0x56,0x55,0x4f,0x45,0x3a,0x30,0x2b,0x30,0x37,0x3e,
0x45,0x47,0x45,0x41,0x39,0x36,0x36,0x36,0x34,0x32,0x32,0x39,0x48,0x5e,0x70,0x7b,
0x7d,0x78,0x6b,0x5e,0x56,0x5b,0x66,0x72,0x78,0x79,0x73,0x69,0x61,0x5f,0x61,0x67,
0x6c,0x6d,0x6d,0x70,0x75,0x7d,0x8a,0x94,0x98,0x95,0x87,0x73,0x5f,0x50,0x44,0x3b,
0x34,0x30,0x32,0x3c,0x4a,0x5b,0x70,0x7c,0x7f,0x79,0x69,0x5a,0x53,0x55,0x5e,0x6c,
0x77,0x7b,0x76,0x6b,0x5f,0x59,0x5a,0x62,0x6c,0x75,0x76,0x72,0x6b,0x64,0x5e,0x5d,
0x5c,0x5b,0x56,0x4d,0x42,0x36,0x2c,0x27,0x28,0x2f,0x38,0x41,0x51,0x60,0x6b,0x72,
0x74,0x6f,0x68,0x5e,0x59,0x5d,0x66,0x71,0x77,0x76,0x70,0x68,0x62,0x61,0x64,0x6b,
0x71,0x73,0x72,0x70,0x72,0x7b,0x88,0x96,0xa3,0xab,0xad,0xa8,0x9f,0x96,0x93,0x93,
0x95,0x96,0x92,0x88,0x79,0x6b,0x5b,0x4e,0x47,0x43,0x3f,0x3b,0x37,0x34,0x32,0x34,
0x38,0x3f,0x41,0x3c,0x32,0x2c,0x2d,0x36,0x47,0x5b,0x6c,0x78,0x79,0x71,0x67,0x60,
0x5d,0x5e,0x61,0x66,0x6b,0x72,0x79,0x80,0x8a,0x93,0x9c,0xa5,0xa8,0xa6,0xa2,0x97,
0x8a,0x7b,0x6c,0x5f,0x55,0x56,0x5c,0x66,0x72,0x78,0x74,0x6c,0x5e,0x55,0x57,0x5f,
0x6b,0x76,0x7a,0x76,0x6e,0x66,0x62,0x64,0x64,0x60,0x58,0x49,0x38,0x2d,0x2e,0x39,
0x4d,0x66,0x7b,0x8a,0x95,0x9a,0x97,0x93,0x89,0x7f,0x70,0x5f,0x50,0x48,0x42,0x3f,
0x3b,0x3b,0x39,0x39,0x3b,0x3e,0x41,0x44,0x42,0x3c,0x36,0x34,0x39,0x44,0x52,0x62,
0x71,0x7e,0x88,0x8f,0x94,0x9b,0x9f,0xa3,0xa2,0x9f,0x9b,0x9b,0x9b,0x9e,0x9c,0x97,
0x8d,0x7d,0x6d,0x5f,0x55,0x4d,0x43,0x3a,0x32,0x31,0x3a,0x4a,0x5f,0x76,0x81,0x7e,
0x75,0x67,0x5d,0x56,0x50,0x48,0x3f,0x37,0x33,0x31,0x3e,0x4e,0x64,0x7b,0x8b,0x93,
0x97,0x97,0x92,0x8a,0x7f,0x71,0x63,0x54,0x49,0x42,0x3d,0x39,0x36,0x35,0x35,0x37,
0x3c,0x3d,0x3b,0x39,0x36,0x36,0x37,0x37,0x38,0x38,0x35,0x33,0x3a,0x4b,0x5f,0x70,
0x79,0x79,0x71,0x65,0x5a,0x57,0x5b,0x63,0x6a,0x6f,0x72,0x79,0x82,0x8c,0x94,0x9b,
0x97,0x8a,0x74,0x5d,0x47,0x3b,0x35,0x32,0x31,0x34,0x36,0x35,0x34,0x35,0x37,0x3e,
0x4d,0x5c,0x6c,0x75,0x79,0x73,0x6c,0x62,0x5c,0x5d,0x60,0x64,0x6d,0x71,0x78,0x80,
0x88,0x93,0x9f,0xa4,0xa5,0xa3,0x9e,0x96,0x8a,0x7b,0x6b,0x5e,0x58,0x59,0x60,0x6a,
0x73,0x78,0x75,0x6d,0x63,0x5e,0x5f,0x63,0x69,0x6d,0x71,0x74,0x78,0x80,0x8b,0x98,
0x9d,0x98,0x8c,0x78,0x64,0x59,0x52,0x54,0x5c,0x6b,0x79,0x85,0x8e,0x97,0x9a,0x96,
0x8d,0x7e,0x70,0x60,0x50,0x45,0x3d,0x3b,0x3b,0x3a,0x39,0x3a,0x39,0x36,0x38,0x40,
0x4d,0x59,0x66,0x71,0x7d,0x8a,0x91,0x98,0x9c,0x96,0x87,0x75,0x65,0x5b,0x58,0x5d,
0x64,0x6f,0x7b,0x84,0x8b,0x96,0x9a,0x9a,0x93,0x84,0x6e,0x5a,0x4d,0x4c,0x55,0x62,
0x6e,0x75,0x75,0x6e,0x66,0x5f,0x5b,0x56,0x50,0x47,0x3c,0x34,0x2f,0x2f,0x32,0x39,
0x3e,0x46,0x4f,0x5b,0x66,0x71,0x7c,0x87,0x8e,0x94,0x93,0x8f,0x83,0x73,0x64,0x52,
0x44,0x3f,0x3d,0x3b,0x3b,0x39,0x38,0x38,0x3b,0x3e,0x3f,0x3e,0x3b,0x37,0x36,0x39,
0x44,0x54,0x66,0x73,0x80,0x87,0x8d,0x94,0x98,0x9f,0xa3,0xa3,0x9f,0x98,0x8e,0x7f,
0x6d,0x61,0x59,0x58,0x63,0x70,0x79,0x7c,0x77,0x6d,0x62,0x5b,0x59,0x5c,0x61,0x65,
0x67,0x6b,0x74,0x81,0x8f,0x9a,0x9c,0x96,0x89,0x76,0x64,0x51,0x46,0x3e,0x37,0x34,
0x37,0x3f,0x4c,0x5b,0x6c,0x7b,0x87,0x8e,0x93,0x94,0x92,0x8a,0x7c,0x6e,0x5d,0x4e,
0x44,0x3c,0x37,0x34,0x34,0x36,0x37,0x3a,0x3e,0x3e,0x3e,0x3b,0x37,0x37,0x37,0x39,
0x3a,0x3b,0x39,0x39,0x37,0x39,0x39,0x39,0x39,0x38,0x36,0x34,0x35,0x36,0x37,0x37,
0x38,0x38,0x37,0x37,0x37,0x3a,0x3d,0x3d,0x3a,0x37,0x35,0x34,0x35,0x37,0x36,0x38,
// Line 14
0x37,0x37,0x37,0x37,0x38,0x39,0x39,0x38,0x38,0x38,0x3a,0x3c,0x3c,0x3c,0x3a,0x39,
0x3a,0x3a,0x39,0x38,0x39,0x39,0x39,0x39,0x38,0x3a,0x3b,0x3a,0x36,0x37,0x38,0x38,
0x37,0x35,0x35,0x36,0x38,0x39,0x37,0x36,0x35,0x35,0x35,0x35,0x37,0x38,0x37,0x33,
0x35,0x36,0x39,0x3d,0x42,0x49,0x51,0x59,0x5f,0x68,0x73,0x7e,0x88,0x8e,0x91,0x95,
0x99,0x9a,0x9a,0x9b,0x9b,0x9b,0x99,0x97,0x96,0x98,0x9b,0x9c,0x9a,0x97,0x91,0x8a,
0x83,0x7d,0x76,0x6d,0x63,0x58,0x50,0x4a,0x46,0x43,0x3e,0x3a,0x3a,0x39,0x39,0x34,
0x37,0x37,0x35,0x35,0x35,0x35,0x38,0x38,0x38,0x3a,0x3c,0x3f,0x43,0x49,0x50,0x59,
0x61,0x69,0x70,0x78,0x80,0x88,0x8e,0x91,0x93,0x93,0x93,0x93,0x93,0x94,0x97,0x97,
0x94,0x93,0x93,0x95,0x97,0x98,0x98,0x93,0x8c,0x85,0x7c,0x72,0x6b,0x62,0x57,0x4d,
0x46,0x41,0x3e,0x3a,0x37,0x3a,0x3c,0x3d,0x3c,0x3b,0x3a,0x38,0x38,0x36,0x34,0x35,
0x36,0x35,0x36,0x38,0x3c,0x43,0x48,0x50,0x5b,0x66,0x6f,0x77,0x7e,0x85,0x8b,0x90,
0x92,0x92,0x94,0x94,0x93,0x94,0x95,0x96,0x97,0x97,0x96,0x97,0x98,0x97,0x93,0x93,
0x8e,0x86,0x7e,0x75,0x6d,0x66,0x5d,0x52,0x4c,0x47,0x44,0x40,0x3b,0x39,0x39,0x3a,
0x3c,0x3b,0x3a,0x38,0x37,0x36,0x36,0x37,0x39,0x3c,0x3b,0x3b,0x3c,0x3f,0x44,0x4a,
0x51,0x5a,0x65,0x6d,0x73,0x7e,0x86,0x8d,0x92,0x94,0x94,0x99,0x9a,0x9a,0x9b,0x9b,
0x9b,0x9b,0x98,0x96,0x97,0x9a,0x9c,0x9b,0x96,0x90,0x88,0x82,0x7a,0x72,0x6a,0x5f,
0x54,0x4c,0x44,0x3f,0x3d,0x3d,0x3d,0x3e,0x3e,0x3e,0x3b,0x3a,0x39,0x3a,0x3b,0x3a,
0x38,0x39,0x38,0x35,0x36,0x38,0x3c,0x41,0x49,0x4e,0x58,0x62,0x6e,0x78,0x82,0x89,
0x90,0x95,0x97,0x98,0x9a,0x97,0x94,0x94,0x94,0x96,0x97,0x97,0x95,0x95,0x96,0x97,
0x97,0x96,0x91,0x89,0x80,0x78,0x6e,0x65,0x5c,0x53,0x4d,0x48,0x43,0x41,0x3e,0x3b,
0x3b,0x3c,0x3c,0x39,0x39,0x39,0x3a,0x3d,0x3d,0x3c,0x3b,0x3b,0x3b,0x3c,0x3d,0x3d,
0x41,0x47,0x4f,0x5a,0x65,0x70,0x7a,0x82,0x88,0x8e,0x93,0x97,0x97,0x98,0x98,0x97,
0x97,0x97,0x97,0x97,0x97,0x96,0x97,0x97,0x98,0x97,0x93,0x8c,0x86,0x7e,0x76,0x6d,
0x66,0x5c,0x51,0x49,0x42,0x3f,0x3d,0x3d,0x3c,0x3d,0x3b,0x3a,0x3a,0x39,0x39,0x3d,
0x3f,0x3f,0x3e,0x3d,0x3d,0x3d,0x3e,0x3f,0x41,0x47,0x4c,0x52,0x5a,0x65,0x6f,0x79,
0x81,0x8a,0x92,0x98,0x9b,0x9a,0x9a,0x98,0x97,0x98,0x98,0x97,0x97,0x97,0x96,0x97,
0x97,0x99,0x98,0x94,0x8d,0x87,0x81,0x7a,0x73,0x6b,0x61,0x56,0x4d,0x47,0x44,0x42,
0x40,0x3b,0x3a,0x3b,0x3d,0x3e,0x3e,0x3e,0x3f,0x40,0x3f,0x3e,0x3d,0x3d,0x3b,0x39,
0x36,0x35,0x39,0x3b,0x3c,0x3d,0x3c,0x3a,0x3a,0x3a,0x3c,0x3d,0x3e,0x3e,0x3e,0x3c,
0x3a,0x3a,0x3c,0x3d,0x3d,0x3e,0x3c,0x39,0x3a,0x3b,0x3d,0x3a,0x3a,0x3a,0x3a,0x3c,
0x3c,0x3c,0x3e,0x3e,0x3c,0x3d,0x3b,0x3a,0x3a,0x3b,0x3c,0x3c,0x3b,0x3d,0x3e,0x3d,
0x3b,0x3c,0x3e,0x3e,0x3c,0x3a,0x39,0x37,0x36,0x35,0x37,0x3a,0x3b,0x3c,0x3c,0x3b,
0x3b,0x3b,0x3a,0x3a,0x3a,0x3d,0x3e,0x3d,0x3c,0x3a,0x38,0x39,0x39,0x38,0x3a,0x3a,
0x38,0x37,0x36,0x37,0x3a,0x3e,0x41,0x45,0x4a,0x50,0x56,0x5e,0x66,0x6f,0x78,0x7f,
0x86,0x8d,0x91,0x94,0x96,0x97,0x98,0x99,0x97,0x97,0x97,0x97,0x97,0x97,0x98,0x98,
0x98,0x9b,0x9b,0x99,0x99,0x99,0x98,0x9a,0x9a,0x9a,0x98,0x98,0x97,0x97,0x98,0x9a,
0x9a,0x9a,0x97,0x94,0x95,0x97,0x98,0x99,0x9a,0x99,0x97,0x97,0x98,0x9a,0x9a,0x98,
0x97,0x99,0x9a,0x98,0x98,0x97,0x98,0x99,0x99,0x99,0x99,0x9b,0x99,0x98,0x96,0x94,
0x94,0x96,0x95,0x93,0x93,0x93,0x93,0x94,0x96,0x97,0x9a,0x9c,0x9b,0x9a,0x97,0x95,
0x95,0x97,0x98,0x96,0x94,0x93,0x93,0x95,0x97,0x98,0x9a,0x9b,0x9a,0x9a,0x95,0x94,
0x97,0x98,0x99,0x98,0x97,0x96,0x93,0x91,0x8a,0x82,0x7b,0x75,0x6b,0x61,0x57,0x4e,
0x4b,0x46,0x41,0x3f,0x3f,0x3e,0x3d,0x3b,0x3a,0x3a,0x39,0x38,0x39,0x3a,0x3a,0x3a,
0x3b,0x3c,0x3d,0x41,0x41,0x40,0x3d,0x39,0x37,0x37,0x39,0x3c,0x3d,0x3b,0x38,0x38,
0x39,0x3b,0x3d,0x40,0x3d,0x3a,0x3a,0x3a,0x38,0x37,0x3a,0x3c,0x3b,0x3a,0x38,0x38,
0x3a,0x3d,0x40,0x46,0x4e,0x58,0x61,0x68,0x71,0x7d,0x86,0x8d,0x92,0x95,0x97,0x96,
0x95,0x96,0x97,0x96,0x94,0x93,0x95,0x95,0x95,0x97,0x97,0x97,0x98,0x9a,0x99,0x9a,
0x9b,0x9b,0x9b,0x99,0x97,0x97,0x97,0x97,0x95,0x95,0x95,0x95,0x95,0x96,0x97,0x9a,
0x9b,0x9b,0x98,0x97,0x97,0x98,0x97,0x95,0x93,0x8e,0x86,0x7e,0x78,0x70,0x67,0x5f,
0x57,0x4e,0x49,0x43,0x3f,0x3b,0x3b,0x3a,0x3a,0x3a,0x3a,0x38,0x3a,0x39,0x36,0x37,
0x39,0x3a,0x3c,0x39,0x39,0x3a,0x3a,0x3a,0x39,0x3c,0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,
0x3b,0x3a,0x3c,0x3d,0x3e,0x3d,0x3a,0x37,0x39,0x3a,0x3b,0x3b,0x3c,0x3d,0x3d,0x3c,
0x39,0x39,0x3d,0x41,0x46,0x4c,0x52,0x5c,0x67,0x70,0x78,0x82,0x8a,0x90,0x92,0x93,
0x94,0x97,0x98,0x98,0x97,0x98,0x98,0x95,0x96,0x98,0x99,0x9a,0x98,0x98,0x99,0x99,
0x98,0x98,0x98,0x98,0x9a,0x98,0x97,0x97,0x97,0x96,0x95,0x97,0x97,0x98,0x9c,0x9b,
0x9a,0x9b,0x9b,0x9a,0x98,0x98,0x9a,0x9c,0x9b,0x9b,0x9b,0x9b,0x99,0x9a,0x9b,0x9e,
0x9e,0x9e,0x9b,0x98,0x9a,0x9a,0x99,0x98,0x98,0x9a,0x9b,0x99,0x97,0x96,0x97,0x97,
0x95,0x97,0x97,0x97,0x97,0x96,0x94,0x95,0x97,0x99,0x9b,0x9b,0x9c,0x9d,0x9c,0x9c,
0x9b,0x9c,0x9e,0x9d,0x9d,0x9c,0x9c,0x9b,0x98,0x97,0x98,0x99,0x98,0x96,0x94,0x94,
0x95,0x94,0x92,0x8e,0x8e,0x86,0x7b,0x72,0x6b,0x64,0x5c,0x53,0x4c,0x47,0x42,0x3e,
0x3d,0x3d,0x3d,0x3c,0x39,0x38,0x37,0x39,0x36,0x35,0x36,0x37,0x37,0x37,0x35,0x36,
0x39,0x3a,0x39,0x39,0x38,0x37,0x39,0x39,0x3a,0x39,0x3d,0x3d,0x3e,0x3e,0x3e,0x3e,
0x40,0x3c,0x3b,0x3c,0x3c,0x3e,0x3e,0x3b,0x39,0x39,0x39,0x39,0x38,0x38,0x37,0x36,
0x37,0x37,0x38,0x39,0x38,0x36,0x37,0x38,0x39,0x38,0x37,0x35,0x37,0x39,0x3a,0x3a,
0x3c,0x3c,0x3c,0x3b,0x3b,0x3a,0x3c,0x3b,0x3a,0x3b,0x3a,0x3a,0x3a,0x3a,0x38,0x39,
0x3a,0x3b,0x3b,0x3c,0x3c,0x3b,0x39,0x39,0x3a,0x3e,0x3a,0x39,0x3a,0x3b,0x3a,0x39,
0x39,0x3a,0x3c,0x3d,0x3c,0x3b,0x3c,0x3d,0x41,0x48,0x51,0x5b,0x68,0x73,0x7a,0x82,
0x8a,0x91,0x94,0x97,0x98,0x99,0x98,0x96,0x94,0x94,0x94,0x93,0x96,0x97,0x96,0x97,
0x97,0x97,0x98,0x97,0x98,0x9a,0x99,0x9a,0x9b,0x9c,0x9c,0x9a,0x99,0x9a,0x9a,0x9a,
0x9a,0x99,0x97,0x94,0x93,0x93,0x93,0x94,0x96,0x96,0x95,0x95,0x95,0x96,0x92,0x91,
0x8a,0x81,0x79,0x6e,0x64,0x5d,0x55,0x50,0x4b,0x48,0x44,0x40,0x3d,0x3b,0x3c,0x3c,
0x3b,0x39,0x3d,0x3a,0x38,0x37,0x38,0x3a,0x3c,0x3c,0x3c,0x3d,0x3c,0x3b,0x39,0x37,
0x37,0x39,0x3a,0x39,0x37,0x37,0x37,0x37,0x39,0x3b,0x3b,0x3b,0x3b,0x3b,0x3a,0x39,
0x39,0x3b,0x3b,0x3b,0x3c,0x3c,0x3c,0x3b,0x3c,0x3d,0x3d,0x3c,0x3b,0x3b,0x3b,0x3b,
0x3a,0x3a,0x3b,0x3b,0x3a,0x3b,0x3a,0x39,0x3a,0x3a,0x38,0x3a,0x39,0x39,0x3a,0x37,
0x35,0x35,0x34,0x35,0x37,0x39,0x3b,0x3a,0x3a,0x38,0x38,0x39,0x39,0x39,0x39,0x38,
0x37,0x37,0x37,0x35,0x36,0x38,0x39,0x3a,0x3a,0x3a,0x3b,0x39,0x38,0x3a,0x3b,0x3a,
0x38,0x37,0x38,0x37,0x38,0x38,0x38,0x39,0x37,0x37,0x38,0x3a,0x3c,0x3c,0x3a,0x39,
0x38,0x3a,0x3b,0x3b,0x3b,0x3d,0x3d,0x3d,0x3b,0x3a,0x3d,0x3e,0x3d,0x3d,0x3d,0x3d,
0x3b,0x38,0x35,0x34,0x35,0x35,0x34,0x32,0x33,0x33,0x35,0x36,0x3a,0x3d,0x3e,0x3d,
0x3c,0x3c,0x3d,0x3d,0x3e,0x3b,0x3a,0x3a,0x3a,0x39,0x3e,0x44,0x4b,0x55,0x5d,0x64,
0x6d,0x77,0x7e,0x86,0x8b,0x8f,0x93,0x93,0x91,0x90,0x91,0x93,0x94,0x96,0x95,0x96,
0x98,0x99,0x97,0x97,0x96,0x96,0x97,0x97,0x97,0x98,0x97,0x95,0x97,0x98,0x98,0x93,
0x93,0x92,0x92,0x92,0x92,0x93,0x95,0x96,0x94,0x95,0x94,0x95,0x97,0x98,0x97,0x96,
0x96,0x97,0x97,0x97,0x97,0x9a,0x9c,0x9b,0x9a,0x98,0x97,0x98,0x9a,0x9b,0x9c,0x9c,
0x9b,0x9a,0x99,0x98,0x99,0x9b,0x9a,0x98,0x95,0x94,0x95,0x95,0x99,0x9a,0x9a,0x99,
0x96,0x94,0x94,0x97,0x98,0x9a,0x9b,0x9b,0x9a,0x99,0x98,0x98,0x99,0x9a,0x9b,0x99,
0x97,0x94,0x94,0x93,0x92,0x92,0x93,0x93,0x93,0x93,0x91,0x8c,0x86,0x7e,0x78,0x70,
0x68,0x5e,0x54,0x4d,0x46,0x41,0x3b,0x38,0x38,0x39,0x38,0x38,0x38,0x3a,0x38,0x38,
0x37,0x39,0x3b,0x3a,0x38,0x38,0x38,0x36,0x35,0x35,0x35,0x37,0x38,0x39,0x3a,0x39,
0x3a,0x3a,0x3b,0x3a,0x3a,0x3c,0x3c,0x3a,0x39,0x38,0x37,0x37,0x37,0x37,0x38,0x37,
0x34,0x33,0x34,0x35,0x35,0x35,0x36,0x37,0x3a,0x3a,0x3a,0x3a,0x3c,0x3c,0x3b,0x3a,
0x39,0x3a,0x3a,0x38,0x37,0x37,0x37,0x37,0x36,0x36,0x38,0x3a,0x3b,0x3a,0x3a,0x39,
0x38,0x39,0x38,0x39,0x3b,0x3a,0x35,0x35,0x34,0x35,0x34,0x36,0x38,0x3b,0x3c,0x39,
0x35,0x37,0x38,0x38,0x3a,0x3a,0x3a,0x3b,0x38,0x36,0x35,0x38,0x3b,0x3c,0x3a,0x36,
0x35,0x38,0x3a,0x3a,0x3b,0x3c,0x3b,0x3a,0x37,0x34,0x35,0x36,0x35,0x35,0x35,0x36,
0x37,0x37,0x37,0x37,0x3a,0x3d,0x3b,0x3c,0x37,0x35,0x37,0x37,0x37,0x39,0x3a,0x3a,
// Line 15
0x39,0x39,0x36,0x34,0x34,0x34,0x35,0x37,0x39,0x39,0x39,0x3b,0x39,0x3a,0x3c,0x3c,
0x3b,0x3a,0x39,0x3a,0x3c,0x3b,0x39,0x38,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
0x35,0x37,0x38,0x38,0x37,0x36,0x36,0x38,0x3a,0x3c,0x3c,0x39,0x34,0x33,0x34,0x38,
0x3a,0x3d,0x3c,0x37,0x34,0x32,0x36,0x41,0x52,0x65,0x76,0x7d,0x7c,0x74,0x6a,0x5f,
0x5b,0x60,0x6b,0x74,0x79,0x78,0x73,0x6b,0x64,0x61,0x64,0x6a,0x71,0x77,0x78,0x74,
0x6f,0x68,0x62,0x60,0x63,0x6b,0x74,0x7a,0x7b,0x77,0x72,0x69,0x62,0x64,0x69,0x70,
0x79,0x7d,0x7d,0x7a,0x73,0x6b,0x66,0x66,0x6a,0x71,0x76,0x78,0x78,0x76,0x71,0x6b,
0x64,0x63,0x67,0x6f,0x76,0x7b,0x7d,0x7a,0x71,0x68,0x60,0x60,0x65,0x6f,0x77,0x7b,
0x7c,0x77,0x6e,0x67,0x63,0x65,0x6c,0x70,0x73,0x75,0x76,0x76,0x7a,0x84,0x90,0x9d,
0xa9,0xaf,0xae,0xa8,0x9b,0x8c,0x7d,0x6e,0x62,0x5c,0x56,0x4f,0x47,0x3f,0x37,0x34,
0x3a,0x48,0x5c,0x70,0x80,0x8c,0x94,0x97,0x99,0x9c,0xa0,0xa3,0xa5,0xa2,0x95,0x85,
0x75,0x66,0x5c,0x58,0x5b,0x61,0x6b,0x72,0x79,0x82,0x8c,0x95,0xa0,0xa6,0xa8,0xa8,
0xa3,0x9f,0x9a,0x96,0x95,0x97,0x97,0x94,0x8a,0x7b,0x6a,0x5b,0x56,0x5a,0x65,0x73,
0x7c,0x7e,0x7d,0x76,0x6c,0x65,0x64,0x67,0x6e,0x75,0x78,0x76,0x70,0x6a,0x63,0x60,
0x62,0x6a,0x74,0x7b,0x7b,0x78,0x71,0x69,0x64,0x64,0x6a,0x73,0x7a,0x7f,0x7b,0x76,
0x6c,0x63,0x60,0x5d,0x5c,0x59,0x50,0x43,0x38,0x31,0x2e,0x2e,0x32,0x39,0x44,0x50,
0x5c,0x68,0x73,0x79,0x78,0x71,0x67,0x5e,0x5c,0x62,0x6d,0x78,0x7d,0x7b,0x73,0x68,
0x60,0x60,0x68,0x71,0x78,0x7e,0x7b,0x73,0x6c,0x67,0x63,0x62,0x60,0x5d,0x57,0x4d,
0x40,0x35,0x2f,0x2e,0x34,0x3b,0x43,0x4c,0x55,0x5d,0x68,0x75,0x82,0x8d,0x96,0x9d,
0xa2,0xa8,0xa9,0xa5,0x9c,0x90,0x7f,0x70,0x61,0x59,0x51,0x4e,0x48,0x41,0x3c,0x38,
0x36,0x37,0x39,0x3c,0x45,0x4e,0x57,0x61,0x6e,0x7a,0x85,0x8f,0x95,0x9a,0x9f,0xa2,
0xa2,0xa2,0x9d,0x94,0x87,0x77,0x69,0x62,0x60,0x66,0x71,0x7c,0x84,0x86,0x80,0x75,
0x6a,0x64,0x63,0x68,0x70,0x77,0x79,0x76,0x6c,0x61,0x5c,0x5c,0x5c,0x5b,0x55,0x49,
0x3c,0x30,0x2a,0x29,0x36,0x40,0x46,0x46,0x3f,0x36,0x30,0x31,0x3b,0x4f,0x63,0x73,
0x7b,0x7b,0x73,0x6a,0x62,0x62,0x66,0x6c,0x71,0x77,0x7d,0x83,0x89,0x93,0x9d,0xa6,
0xac,0xad,0xa9,0xa1,0x9b,0x99,0x9b,0x9c,0x9a,0x92,0x88,0x77,0x65,0x55,0x4a,0x44,
0x41,0x3d,0x39,0x36,0x36,0x36,0x39,0x3a,0x3c,0x3f,0x3d,0x3b,0x36,0x34,0x33,0x33,
0x36,0x38,0x38,0x36,0x33,0x2f,0x31,0x39,0x46,0x58,0x6a,0x78,0x80,0x7f,0x78,0x6e,
0x64,0x5c,0x54,0x4b,0x43,0x3b,0x39,0x3d,0x47,0x59,0x6e,0x81,0x92,0x99,0x9b,0x9b,
0x96,0x8c,0x7b,0x6c,0x5c,0x51,0x4a,0x44,0x3f,0x3a,0x36,0x2f,0x2c,0x2e,0x34,0x3c,
0x40,0x3f,0x38,0x32,0x33,0x40,0x54,0x6b,0x7c,0x84,0x81,0x77,0x6b,0x60,0x5d,0x64,
0x6e,0x76,0x7b,0x7b,0x7f,0x8a,0x94,0x9e,0xa7,0xad,0xae,0xa9,0xa2,0x9c,0x97,0x99,
0x98,0x9a,0xa0,0xa4,0xa6,0xa4,0x9c,0x90,0x83,0x74,0x68,0x5f,0x58,0x51,0x47,0x3e,
0x39,0x3d,0x49,0x5b,0x6e,0x7e,0x84,0x80,0x75,0x66,0x5c,0x58,0x55,0x4d,0x43,0x3a,
0x38,0x3e,0x4e,0x63,0x77,0x81,0x7f,0x72,0x65,0x59,0x53,0x51,0x4e,0x48,0x41,0x39,
0x34,0x32,0x36,0x3b,0x43,0x4a,0x52,0x5c,0x6a,0x78,0x84,0x8e,0x95,0x9a,0x9f,0xa3,
0xa6,0xa8,0xa3,0x97,0x85,0x74,0x68,0x63,0x64,0x69,0x6e,0x73,0x79,0x7e,0x87,0x91,
0x99,0xa1,0xa1,0x97,0x87,0x73,0x62,0x53,0x56,0x62,0x71,0x7e,0x82,0x7d,0x75,0x68,
0x5e,0x5e,0x64,0x6c,0x71,0x73,0x73,0x77,0x84,0x93,0x9e,0xa3,0x9b,0x89,0x74,0x60,
0x56,0x5b,0x65,0x73,0x7e,0x82,0x7d,0x72,0x66,0x60,0x60,0x62,0x64,0x69,0x70,0x78,
0x7f,0x88,0x92,0x9b,0xa0,0x9a,0x89,0x73,0x5d,0x4e,0x44,0x3c,0x39,0x3c,0x3f,0x3d,
0x3b,0x37,0x36,0x3c,0x45,0x50,0x5d,0x6c,0x7b,0x84,0x8f,0x96,0x97,0x93,0x8a,0x7d,
0x6e,0x5e,0x50,0x45,0x3e,0x3c,0x3c,0x3b,0x39,0x3b,0x3d,0x3f,0x44,0x4a,0x52,0x5e,
0x6a,0x76,0x7f,0x8b,0x96,0x9d,0x9f,0x9f,0x9f,0x9e,0x9c,0x94,0x87,0x79,0x6c,0x62,
0x5e,0x60,0x69,0x73,0x79,0x80,0x87,0x8d,0x94,0x9b,0xa1,0xa4,0xa4,0xa1,0x9c,0x99,
0x98,0x9a,0x9b,0x9b,0x96,0x8c,0x7d,0x6e,0x60,0x5b,0x5c,0x64,0x6e,0x78,0x80,0x89,
0x94,0x9b,0x9e,0x9f,0x98,0x88,0x74,0x5f,0x54,0x54,0x5d,0x6c,0x79,0x80,0x7d,0x70,
0x66,0x5f,0x61,0x6d,0x78,0x7e,0x7f,0x79,0x70,0x68,0x63,0x63,0x63,0x5d,0x50,0x41,
0x36,0x31,0x36,0x4c,0x64,0x79,0x85,0x82,0x76,0x6c,0x61,0x5d,0x61,0x69,0x72,0x79,
0x7f,0x83,0x8a,0x94,0x9c,0x98,0x90,0x7e,0x6a,0x58,0x49,0x40,0x3f,0x3f,0x3c,0x39,
0x36,0x37,0x3a,0x3b,0x3a,0x39,0x36,0x33,0x31,0x33,0x3d,0x4c,0x5c,0x6b,0x78,0x85,
0x90,0x98,0x9c,0x9a,0x90,0x82,0x73,0x64,0x57,0x4e,0x47,0x3d,0x3d,0x3d,0x43,0x51,
0x60,0x6f,0x7d,0x88,0x8e,0x93,0x96,0x9b,0xa1,0xa3,0xa0,0x99,0x8e,0x82,0x73,0x66,
0x5b,0x54,0x4f,0x49,0x41,0x3d,0x3d,0x44,0x50,0x5f,0x71,0x81,0x8c,0x93,0x98,0x9b,
0x9f,0xa1,0xa2,0xa1,0xa0,0x9d,0x9a,0x98,0x99,0x9d,0xa1,0xa3,0xa1,0x9f,0x9c,0x9c,
0x9b,0x9d,0x9e,0x9e,0x97,0x8c,0x7d,0x6e,0x67,0x63,0x62,0x68,0x71,0x7a,0x82,0x87,
0x8e,0x96,0x9d,0xa0,0xa2,0xa2,0x9f,0x99,0x94,0x93,0x95,0x99,0x98,0x93,0x88,0x79,
0x6a,0x5d,0x52,0x4a,0x46,0x41,0x3b,0x36,0x32,0x33,0x36,0x3c,0x40,0x40,0x3d,0x36,
0x2f,0x34,0x3f,0x50,0x65,0x76,0x7e,0x7b,0x6f,0x61,0x59,0x5c,0x68,0x76,0x7e,0x7f,
0x79,0x72,0x6a,0x64,0x63,0x62,0x5e,0x55,0x47,0x39,0x36,0x3c,0x4a,0x5e,0x73,0x85,
0x93,0x9a,0x9a,0x95,0x90,0x85,0x76,0x6b,0x5d,0x54,0x4c,0x44,0x3c,0x3b,0x3e,0x48,
0x59,0x6e,0x7e,0x84,0x81,0x73,0x64,0x58,0x52,0x4d,0x49,0x44,0x3c,0x36,0x30,0x2f,
0x35,0x3d,0x46,0x4d,0x55,0x5f,0x6b,0x76,0x81,0x8b,0x95,0x9b,0xa1,0xa4,0xa6,0xa7,
0xa5,0xa1,0x9d,0x9a,0x9a,0x9e,0xa2,0xa5,0xa7,0xa4,0xa0,0x9a,0x98,0x9b,0x9e,0x9d,
0x97,0x8b,0x7d,0x6d,0x5e,0x59,0x5d,0x68,0x75,0x7e,0x80,0x7b,0x6e,0x67,0x61,0x64,
0x6b,0x73,0x75,0x78,0x78,0x7b,0x84,0x8f,0x99,0x9e,0x95,0x7f,0x67,0x52,0x46,0x3f,
0x3f,0x3f,0x3d,0x3b,0x38,0x37,0x3a,0x3f,0x41,0x42,0x3c,0x36,0x32,0x36,0x43,0x55,
0x69,0x78,0x7d,0x79,0x6f,0x65,0x5e,0x58,0x55,0x4e,0x46,0x3d,0x36,0x31,0x30,0x34,
0x3a,0x42,0x49,0x50,0x5b,0x68,0x78,0x82,0x88,0x92,0x99,0xa0,0xa6,0xa9,0xa8,0xa2,
0x91,0x7b,0x6a,0x5f,0x59,0x58,0x54,0x4e,0x44,0x3c,0x39,0x42,0x55,0x6c,0x7c,0x84,
0x7f,0x72,0x64,0x58,0x55,0x5c,0x69,0x75,0x7b,0x79,0x72,0x6a,0x65,0x63,0x67,0x6e,
0x75,0x77,0x76,0x76,0x7d,0x8b,0x98,0xa1,0xa4,0xa0,0x90,0x7b,0x68,0x5b,0x59,0x61,
0x6c,0x77,0x83,0x8b,0x92,0x97,0x9b,0xa0,0xa6,0xa8,0xa2,0x9b,0x8e,0x7e,0x6e,0x60,
0x57,0x4e,0x4c,0x46,0x3f,0x3b,0x37,0x33,0x36,0x38,0x3c,0x41,0x3f,0x39,0x33,0x31,
0x36,0x42,0x51,0x62,0x73,0x7f,0x86,0x8b,0x92,0x99,0x9a,0x93,0x83,0x70,0x63,0x5c,
0x5d,0x68,0x74,0x7d,0x80,0x7b,0x71,0x68,0x62,0x62,0x66,0x6c,0x70,0x74,0x7a,0x7e,
0x88,0x95,0x9c,0x9a,0x91,0x81,0x6d,0x5a,0x49,0x40,0x3a,0x39,0x3a,0x3d,0x47,0x54,
0x63,0x74,0x82,0x8c,0x93,0x96,0x98,0x9b,0x9e,0xa0,0x9f,0x99,0x8d,0x7f,0x6f,0x5f,
0x55,0x51,0x4d,0x49,0x44,0x3f,0x3b,0x39,0x36,0x38,0x39,0x41,0x49,0x53,0x5e,0x69,
0x75,0x81,0x8c,0x93,0x9a,0xa0,0xa3,0xa3,0xa0,0x9c,0x9c,0x9e,0x9e,0xa0,0xa1,0xa1,
0xa3,0xa5,0xa5,0xa2,0x9a,0x8b,0x79,0x6a,0x61,0x5d,0x60,0x66,0x6f,0x78,0x7f,0x86,
0x8f,0x99,0xa1,0xa1,0x95,0x82,0x6e,0x60,0x57,0x58,0x60,0x6d,0x77,0x84,0x8b,0x92,
0x9a,0x9d,0x9b,0x93,0x82,0x6d,0x59,0x49,0x40,0x3b,0x3a,0x3a,0x3b,0x3c,0x3b,0x39,
0x39,0x3f,0x49,0x5a,0x6a,0x77,0x7c,0x79,0x71,0x68,0x61,0x5f,0x66,0x6f,0x75,0x78,
0x7b,0x7f,0x88,0x95,0x9d,0x9f,0x9b,0x8b,0x76,0x63,0x57,0x55,0x5e,0x6a,0x76,0x81,
0x8a,0x92,0x97,0x9d,0xa2,0xa7,0xa8,0xa3,0x9c,0x95,0x88,0x77,0x66,0x5c,0x5b,0x63,
0x6d,0x77,0x7d,0x7c,0x73,0x69,0x62,0x60,0x5f,0x59,0x4e,0x3d,0x33,0x30,0x37,0x4a,
0x61,0x78,0x88,0x90,0x92,0x92,0x97,0x95,0x8f,0x82,0x71,0x61,0x58,0x5a,0x65,0x75,
0x82,0x84,0x7d,0x6e,0x62,0x5e,0x61,0x6a,0x73,0x7a,0x7b,0x75,0x6d,0x66,0x64,0x65,
0x67,0x60,0x55,0x48,0x3b,0x35,0x39,0x48,0x5e,0x76,0x88,0x90,0x96,0x98,0x9a,0x9e,
0xa3,0xa6,0xa8,0xa3,0x9e,0x9c,0x9b,0x9b,0x99,0x8f,0x7f,0x6f,0x5f,0x53,0x4b,0x46,
0x42,0x3d,0x36,0x30,0x2f,0x34,0x38,0x3d,0x41,0x43,0x3e,0x39,0x36,0x39,0x44,0x51,
0x60,0x6f,0x7d,0x89,0x92,0x96,0x9b,0x9e,0xa3,0xa4,0xa1,0x9c,0x92,0x82,0x73,0x62,
0x57,0x50,0x4b,0x46,0x41,0x3c,0x37,0x32,0x32,0x34,0x38,0x3f,0x45,0x4e,0x5b,0x6a,
0x79,0x85,0x8e,0x96,0x9e,0xa4,0xa9,0xa6,0xa9,0xa6,0xa0,0x9c,0x9a,0x9b,0xa1,0xa3,
0xa6,0xa7,0xa6,0xa3,0xa1,0xa1,0xa0,0xa1,0x9e,0x95,0x88,0x76,0x64,0x56,0x4e,0x48,
// Line 16
0x3b,0x3a,0x3b,0x3c,0x3c,0x3b,0x39,0x38,0x37,0x35,0x34,0x35,0x38,0x3a,0x3a,0x39,
0x38,0x39,0x3b,0x3a,0x3a,0x3b,0x3b,0x3b,0x3b,0x39,0x37,0x36,0x36,0x35,0x35,0x37,
0x38,0x39,0x38,0x36,0x34,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x34,0x34,0x34,0x36,
0x36,0x38,0x3a,0x39,0x35,0x33,0x35,0x3d,0x4e,0x5f,0x6f,0x79,0x7b,0x74,0x68,0x5d,
0x59,0x5e,0x68,0x70,0x77,0x77,0x72,0x6a,0x62,0x5e,0x60,0x68,0x71,0x78,0x7a,0x77,
0x72,0x6a,0x64,0x61,0x65,0x6b,0x70,0x75,0x76,0x72,0x69,0x61,0x5b,0x5a,0x60,0x69,
0x73,0x7c,0x7c,0x77,0x70,0x68,0x61,0x60,0x62,0x68,0x6e,0x74,0x76,0x71,0x69,0x61,
0x5d,0x5e,0x63,0x6a,0x73,0x78,0x79,0x76,0x6d,0x64,0x5f,0x5d,0x60,0x68,0x72,0x79,
0x7c,0x77,0x6e,0x67,0x65,0x66,0x69,0x6e,0x72,0x74,0x74,0x72,0x76,0x81,0x8f,0x9b,
0xa5,0xaa,0xac,0xa6,0x99,0x88,0x79,0x6d,0x64,0x5d,0x56,0x51,0x4a,0x46,0x3f,0x3b,
0x3f,0x49,0x59,0x6c,0x7e,0x8d,0x95,0x97,0x98,0x99,0x9c,0xa1,0xa1,0xa0,0x96,0x86,
0x74,0x61,0x55,0x54,0x58,0x5f,0x6b,0x75,0x79,0x77,0x6d,0x64,0x5f,0x60,0x66,0x6e,
0x76,0x79,0x77,0x70,0x69,0x65,0x65,0x69,0x6e,0x72,0x72,0x72,0x72,0x76,0x7e,0x8c,
0x9c,0xa7,0xaa,0xa9,0xa3,0x9d,0x9b,0x9b,0x9c,0x9f,0x9c,0x93,0x85,0x77,0x69,0x5b,
0x53,0x48,0x3f,0x38,0x36,0x38,0x45,0x57,0x6b,0x7c,0x81,0x7c,0x72,0x67,0x5d,0x56,
0x50,0x49,0x3c,0x37,0x32,0x39,0x4b,0x62,0x77,0x84,0x81,0x77,0x69,0x5c,0x53,0x4e,
0x4b,0x46,0x3f,0x37,0x31,0x2f,0x33,0x38,0x3d,0x47,0x52,0x59,0x66,0x71,0x7d,0x8b,
0x92,0x95,0x94,0x8c,0x7f,0x6e,0x5d,0x4e,0x45,0x41,0x3f,0x3e,0x3d,0x3b,0x38,0x35,
0x36,0x3b,0x46,0x53,0x5e,0x69,0x75,0x81,0x8d,0x96,0x9b,0x9b,0x93,0x83,0x70,0x61,
0x58,0x59,0x61,0x6d,0x79,0x81,0x7f,0x75,0x68,0x5e,0x5c,0x63,0x6d,0x75,0x78,0x74,
0x6c,0x64,0x5f,0x5f,0x5e,0x5c,0x53,0x46,0x3a,0x30,0x2d,0x30,0x37,0x3c,0x3f,0x3f,
0x3f,0x3d,0x3b,0x37,0x34,0x34,0x34,0x36,0x3b,0x43,0x4e,0x5d,0x6a,0x77,0x83,0x8d,
0x94,0x98,0x96,0x8e,0x81,0x72,0x5f,0x4f,0x44,0x3f,0x3d,0x3e,0x3d,0x3d,0x3e,0x3e,
0x3e,0x40,0x45,0x4f,0x5c,0x69,0x74,0x7f,0x88,0x8f,0x96,0x9c,0xa1,0xa3,0xa5,0xa0,
0x9b,0x99,0x99,0x9b,0x9a,0x98,0x90,0x81,0x71,0x65,0x5e,0x60,0x66,0x6e,0x78,0x81,
0x88,0x8f,0x95,0x99,0x9b,0x95,0x86,0x73,0x63,0x5a,0x59,0x5f,0x6a,0x77,0x80,0x86,
0x8d,0x96,0x9d,0xa2,0xa5,0xa5,0xa3,0xa1,0x9e,0x9c,0x9c,0x9f,0xa0,0xa2,0xa4,0xa6,
0xa6,0xa6,0xa3,0x9f,0x9c,0x9b,0x9c,0xa0,0xa0,0xa0,0xa1,0xa0,0x9d,0x9b,0x9c,0x9f,
0x9d,0x98,0x8e,0x80,0x70,0x63,0x5c,0x5e,0x67,0x73,0x7c,0x7f,0x78,0x6f,0x64,0x5b,
0x5c,0x64,0x6d,0x74,0x77,0x75,0x6e,0x66,0x61,0x5e,0x5f,0x5d,0x56,0x4e,0x3e,0x33,
0x2e,0x30,0x36,0x3c,0x45,0x4d,0x55,0x5e,0x69,0x77,0x86,0x91,0x98,0x9c,0x99,0x8f,
0x83,0x73,0x64,0x54,0x47,0x3e,0x38,0x36,0x3b,0x46,0x53,0x62,0x71,0x7f,0x8a,0x92,
0x98,0x9b,0x98,0x91,0x80,0x6d,0x60,0x59,0x5a,0x61,0x6c,0x76,0x7f,0x88,0x90,0x96,
0xa1,0xa0,0x96,0x85,0x70,0x5e,0x53,0x56,0x63,0x75,0x7e,0x7e,0x77,0x6c,0x62,0x5c,
0x57,0x52,0x4a,0x40,0x34,0x2b,0x2a,0x2f,0x37,0x3e,0x40,0x3e,0x3b,0x39,0x38,0x37,
0x34,0x32,0x32,0x32,0x38,0x41,0x51,0x5f,0x6d,0x7c,0x86,0x8e,0x98,0x9d,0x9a,0x94,
0x85,0x74,0x65,0x5c,0x5a,0x61,0x69,0x76,0x82,0x8c,0x94,0x99,0x9b,0x97,0x8b,0x7a,
0x66,0x53,0x47,0x3e,0x3a,0x39,0x36,0x32,0x30,0x31,0x34,0x39,0x3c,0x3c,0x38,0x32,
0x2f,0x33,0x42,0x54,0x66,0x74,0x78,0x75,0x6e,0x68,0x5e,0x59,0x52,0x4b,0x43,0x3b,
0x36,0x39,0x48,0x5d,0x71,0x81,0x8c,0x94,0x99,0x98,0x91,0x86,0x7b,0x6d,0x62,0x5a,
0x59,0x60,0x69,0x73,0x7c,0x86,0x8f,0x97,0x9c,0x9a,0x8d,0x7d,0x6a,0x5a,0x51,0x53,
0x60,0x71,0x7c,0x7f,0x79,0x6f,0x66,0x61,0x5e,0x5a,0x52,0x44,0x35,0x2c,0x32,0x45,
0x60,0x7c,0x89,0x87,0x7c,0x69,0x5c,0x57,0x61,0x6d,0x77,0x7c,0x78,0x6e,0x67,0x60,
0x5d,0x5e,0x5b,0x50,0x43,0x36,0x30,0x36,0x45,0x5c,0x6f,0x80,0x83,0x7a,0x6c,0x5e,
0x53,0x4d,0x48,0x43,0x3f,0x39,0x35,0x32,0x34,0x39,0x40,0x4a,0x54,0x5e,0x69,0x75,
0x80,0x89,0x90,0x96,0x9b,0x9e,0x9f,0x9f,0x9d,0x9b,0x99,0x98,0x97,0x98,0x94,0x88,
0x77,0x68,0x5d,0x54,0x4b,0x44,0x3d,0x3a,0x3a,0x40,0x52,0x68,0x7c,0x86,0x82,0x73,
0x64,0x5a,0x57,0x5b,0x64,0x6c,0x72,0x77,0x7c,0x85,0x93,0x98,0x9b,0x97,0x89,0x76,
0x61,0x4f,0x44,0x42,0x41,0x42,0x3e,0x3d,0x3b,0x39,0x38,0x3a,0x41,0x4d,0x5a,0x64,
0x72,0x81,0x8d,0x97,0x99,0x96,0x8d,0x80,0x6f,0x5f,0x52,0x48,0x41,0x3b,0x38,0x3a,
0x40,0x4a,0x59,0x69,0x79,0x86,0x8f,0x93,0x95,0x9b,0xa1,0xa5,0xa4,0xa1,0x9d,0x9c,
0x9b,0x99,0x99,0x9f,0xa1,0xa1,0xa1,0x9f,0xa0,0xa3,0xa1,0x9f,0xa0,0xa1,0xa0,0x9e,
0x9d,0x9e,0x9f,0x9e,0x9b,0x9b,0x98,0x90,0x81,0x71,0x62,0x56,0x4f,0x49,0x42,0x3d,
0x38,0x38,0x3c,0x4d,0x62,0x77,0x83,0x81,0x74,0x65,0x59,0x57,0x60,0x6d,0x79,0x7f,
0x7c,0x72,0x6a,0x65,0x64,0x63,0x68,0x6c,0x6d,0x6f,0x71,0x77,0x7f,0x8b,0x97,0xa3,
0xaa,0xac,0xaa,0x9f,0x8f,0x7f,0x70,0x65,0x5d,0x56,0x4e,0x46,0x3c,0x34,0x32,0x3b,
0x49,0x5c,0x70,0x80,0x8c,0x95,0x96,0x93,0x90,0x8c,0x81,0x6f,0x5f,0x4f,0x44,0x3d,
0x39,0x35,0x3a,0x38,0x36,0x34,0x35,0x3a,0x46,0x57,0x67,0x74,0x7a,0x7a,0x72,0x66,
0x5c,0x56,0x52,0x4d,0x45,0x3d,0x35,0x2b,0x28,0x2b,0x35,0x43,0x4d,0x56,0x61,0x6c,
0x78,0x86,0x94,0x9c,0x9f,0x9b,0x8d,0x7b,0x6d,0x60,0x51,0x46,0x3c,0x35,0x32,0x35,
0x40,0x53,0x69,0x7c,0x83,0x7f,0x74,0x69,0x63,0x60,0x62,0x69,0x70,0x75,0x7a,0x7f,
0x88,0x94,0x9d,0x9f,0x98,0x89,0x74,0x60,0x54,0x52,0x5b,0x66,0x72,0x7a,0x87,0x90,
0x97,0x9d,0x9c,0x96,0x86,0x71,0x5d,0x52,0x53,0x5d,0x6b,0x74,0x77,0x76,0x6f,0x68,
0x61,0x61,0x65,0x6b,0x6f,0x73,0x77,0x7e,0x87,0x92,0x9c,0xa5,0xaa,0xaa,0xa4,0x9c,
0x98,0x96,0x96,0x94,0x9b,0x9c,0x9f,0xa1,0xa0,0x9e,0x99,0x90,0x80,0x72,0x64,0x5c,
0x5b,0x63,0x6d,0x77,0x7c,0x79,0x6e,0x65,0x5d,0x5d,0x63,0x6c,0x75,0x78,0x76,0x6d,
0x65,0x62,0x64,0x6c,0x71,0x75,0x77,0x78,0x78,0x7c,0x85,0x92,0x9c,0x9f,0x97,0x86,
0x72,0x5f,0x54,0x54,0x5d,0x6b,0x78,0x83,0x8c,0x96,0x9c,0x9e,0x97,0x8c,0x7b,0x68,
0x56,0x4a,0x42,0x3f,0x3a,0x35,0x34,0x3b,0x4c,0x63,0x77,0x81,0x81,0x77,0x68,0x5b,
0x59,0x63,0x71,0x7e,0x81,0x7c,0x73,0x69,0x64,0x65,0x65,0x60,0x56,0x45,0x34,0x2c,
0x31,0x41,0x54,0x6e,0x82,0x90,0x99,0x9c,0x9b,0x9a,0x90,0x80,0x6e,0x5e,0x56,0x57,
0x5e,0x69,0x74,0x7b,0x7b,0x73,0x69,0x63,0x61,0x64,0x68,0x6c,0x72,0x77,0x7d,0x86,
0x91,0x9d,0xa8,0xae,0xac,0xa6,0x9c,0x8d,0x7c,0x6d,0x64,0x5d,0x59,0x51,0x47,0x42,
0x39,0x38,0x41,0x52,0x66,0x78,0x81,0x7d,0x74,0x6b,0x62,0x59,0x52,0x4b,0x46,0x3e,
0x37,0x39,0x46,0x5a,0x6e,0x7e,0x89,0x91,0x94,0x96,0x98,0x9e,0xa2,0xa4,0xa1,0x9d,
0x9d,0x9c,0x9c,0x9b,0x99,0x99,0x9b,0x9a,0x98,0x93,0x8a,0x7c,0x6d,0x60,0x5b,0x5e,
0x68,0x6e,0x7a,0x80,0x86,0x8d,0x95,0x9c,0xa6,0xaa,0xa8,0xa2,0x9b,0x97,0x95,0x96,
0x98,0x9b,0x98,0x8f,0x7e,0x6b,0x5c,0x58,0x5d,0x68,0x72,0x7c,0x7e,0x78,0x6d,0x61,
0x59,0x56,0x53,0x4d,0x44,0x3a,0x2e,0x25,0x27,0x2e,0x3b,0x47,0x49,0x42,0x3b,0x32,
0x32,0x3b,0x4f,0x68,0x7c,0x86,0x84,0x78,0x6d,0x64,0x61,0x63,0x6b,0x73,0x79,0x7c,
0x7d,0x83,0x89,0x93,0xa0,0xa9,0xac,0xa8,0x9f,0x96,0x92,0x94,0x99,0x9c,0x99,0x8f,
0x81,0x70,0x60,0x58,0x5b,0x66,0x71,0x7b,0x7c,0x78,0x6d,0x64,0x5c,0x5b,0x61,0x6a,
0x71,0x75,0x71,0x6a,0x63,0x5c,0x57,0x57,0x57,0x53,0x48,0x3a,0x2e,0x2a,0x2d,0x33,
0x3d,0x46,0x49,0x42,0x37,0x30,0x32,0x3c,0x4b,0x5c,0x6d,0x7c,0x85,0x8e,0x96,0x9b,
0x9a,0x92,0x81,0x6e,0x5e,0x57,0x56,0x63,0x6f,0x79,0x7d,0x78,0x6e,0x66,0x60,0x5a,
0x57,0x50,0x46,0x3a,0x2f,0x28,0x28,0x2e,0x3a,0x41,0x41,0x3a,0x32,0x30,0x32,0x3d,
0x50,0x65,0x77,0x7e,0x79,0x70,0x68,0x5f,0x58,0x52,0x4d,0x44,0x3b,0x38,0x3b,0x4b,
0x63,0x77,0x83,0x84,0x7a,0x69,0x59,0x4d,0x47,0x45,0x40,0x38,0x2f,0x2b,0x2a,0x2d,
0x34,0x3d,0x46,0x53,0x5f,0x6b,0x73,0x74,0x6f,0x68,0x61,0x5d,0x61,0x68,0x6f,0x75,
0x7a,0x7f,0x86,0x92,0x9e,0xa8,0xaf,0xae,0xa7,0x9f,0x99,0x98,0x99,0x9b,0x9c,0x9c,
0x9f,0x9d,0x9b,0x98,0x90,0x83,0x75,0x64,0x58,0x51,0x4a,0x45,0x41,0x3c,0x38,0x34,
0x32,0x31,0x34,0x3a,0x41,0x4a,0x55,0x63,0x71,0x80,0x8a,0x94,0x9d,0xa3,0xa6,0xa8,
0xa6,0xa5,0xa3,0xa3,0xa0,0x9f,0x9e,0x9f,0xa0,0xa1,0xa1,0x9c,0x92,0x83,0x73,0x67,
0x5b,0x52,0x4b,0x45,0x40,0x3a,0x34,0x30,0x30,0x33,0x36,0x36,0x35,0x34,0x33,0x31,
0x2f,0x32,0x35,0x36,0x36,0x36,0x36,0x36,0x3a,0x3b,0x3a,0x3a,0x3a,0x38,0x38,0x3a,
0x3d,0x3d,0x3e,0x38,0x33,0x33,0x35,0x36,0x38,0x39,0x38,0x39,0x39,0x38,0x38,0x38,
// Line 17
0x39,0x3c,0x3e,0x3e,0x3e,0x3e,0x3d,0x3b,0x39,0x3a,0x3a,0x39,0x38,0x36,0x34,0x37,
0x38,0x3a,0x3a,0x38,0x39,0x3a,0x3b,0x3a,0x3b,0x3d,0x3d,0x3c,0x3a,0x38,0x38,0x37,
0x38,0x39,0x3a,0x39,0x38,0x37,0x36,0x36,0x39,0x3d,0x3e,0x3c,0x38,0x34,0x31,0x32,
0x36,0x3a,0x3d,0x3a,0x35,0x34,0x38,0x42,0x52,0x67,0x76,0x7e,0x7c,0x71,0x63,0x5b,
0x5a,0x5f,0x6a,0x75,0x7b,0x7a,0x71,0x67,0x62,0x62,0x66,0x6d,0x74,0x77,0x79,0x76,
0x70,0x67,0x63,0x62,0x64,0x6b,0x73,0x7a,0x7c,0x78,0x6f,0x67,0x5f,0x5f,0x66,0x6e,
0x75,0x7b,0x7c,0x77,0x6e,0x69,0x64,0x62,0x67,0x6d,0x74,0x78,0x76,0x73,0x6d,0x67,
0x61,0x60,0x65,0x6d,0x75,0x79,0x77,0x71,0x6a,0x63,0x5e,0x60,0x67,0x72,0x7a,0x7c,
0x79,0x74,0x6d,0x67,0x63,0x63,0x65,0x6a,0x6e,0x70,0x6e,0x73,0x78,0x82,0x8e,0x9a,
0xa5,0xaf,0xaf,0xa6,0x98,0x88,0x79,0x6b,0x61,0x59,0x55,0x53,0x4e,0x46,0x3e,0x3b,
0x40,0x4d,0x5f,0x74,0x85,0x8f,0x93,0x94,0x96,0x9a,0x9f,0xa2,0xa4,0xa2,0x98,0x88,
0x75,0x67,0x5e,0x5b,0x5e,0x67,0x71,0x78,0x79,0x76,0x70,0x67,0x61,0x64,0x6a,0x73,
0x7b,0x7d,0x7a,0x71,0x69,0x63,0x64,0x6a,0x70,0x73,0x74,0x72,0x71,0x76,0x81,0x90,
0x9d,0xa5,0xa8,0xa7,0xa2,0x9c,0x98,0x9a,0x9f,0xa1,0x9f,0x96,0x86,0x79,0x69,0x59,
0x50,0x47,0x3e,0x37,0x32,0x35,0x42,0x57,0x6e,0x7c,0x80,0x79,0x6e,0x64,0x5d,0x58,
0x55,0x4e,0x44,0x38,0x35,0x3d,0x51,0x69,0x7c,0x88,0x85,0x78,0x68,0x5e,0x5e,0x64,
0x6d,0x72,0x75,0x79,0x7f,0x87,0x92,0x9d,0xa7,0xaa,0xa6,0x9e,0x95,0x8b,0x80,0x70,
0x65,0x59,0x4e,0x47,0x43,0x40,0x42,0x3d,0x36,0x32,0x32,0x38,0x40,0x4a,0x54,0x61,
0x6d,0x79,0x82,0x8b,0x94,0x9b,0x9c,0x94,0x84,0x75,0x67,0x5e,0x5d,0x63,0x6e,0x7c,
0x86,0x8b,0x90,0x95,0x9c,0xa2,0xa5,0xa4,0xa1,0x9c,0x97,0x94,0x96,0x9b,0x9d,0x98,
0x8b,0x79,0x67,0x59,0x54,0x5b,0x67,0x74,0x7b,0x7a,0x73,0x6b,0x64,0x5e,0x5b,0x59,
0x54,0x4b,0x40,0x36,0x30,0x30,0x34,0x3a,0x44,0x4f,0x59,0x5d,0x6a,0x74,0x80,0x8b,
0x93,0x96,0x97,0x8e,0x7f,0x6e,0x5d,0x4e,0x44,0x3f,0x3c,0x3e,0x40,0x40,0x3e,0x3a,
0x38,0x3e,0x4a,0x5a,0x69,0x75,0x7c,0x79,0x71,0x66,0x5d,0x5b,0x61,0x69,0x71,0x76,
0x75,0x70,0x68,0x61,0x61,0x65,0x6d,0x74,0x7a,0x7b,0x74,0x6c,0x65,0x62,0x64,0x69,
0x6d,0x70,0x73,0x76,0x79,0x80,0x8a,0x95,0xa0,0xa3,0x9b,0x8c,0x77,0x63,0x56,0x53,
0x5a,0x69,0x77,0x83,0x8c,0x93,0x98,0x9c,0x9f,0xa3,0xa4,0xa1,0x97,0x8a,0x7d,0x71,
0x66,0x5b,0x51,0x4a,0x44,0x41,0x3c,0x39,0x39,0x39,0x36,0x38,0x3a,0x44,0x53,0x63,
0x70,0x7a,0x7c,0x75,0x6b,0x63,0x65,0x6d,0x76,0x7d,0x81,0x7d,0x74,0x6a,0x62,0x5e,
0x5b,0x5a,0x53,0x48,0x3d,0x34,0x2e,0x30,0x35,0x3d,0x48,0x53,0x5e,0x6a,0x74,0x79,
0x77,0x70,0x65,0x60,0x63,0x6b,0x71,0x77,0x7a,0x7b,0x7e,0x84,0x90,0x9f,0xa5,0x9d,
0x8b,0x74,0x63,0x5a,0x5a,0x64,0x71,0x7d,0x80,0x7b,0x74,0x6d,0x68,0x67,0x69,0x6e,
0x73,0x77,0x7b,0x82,0x8d,0x99,0xa1,0xa9,0xa8,0xa6,0xa1,0x9a,0x94,0x95,0x98,0x9a,
0x9b,0x95,0x8a,0x7c,0x70,0x61,0x55,0x49,0x43,0x3f,0x3c,0x38,0x37,0x37,0x36,0x36,
0x3a,0x44,0x53,0x66,0x75,0x7e,0x7e,0x73,0x5e,0x5d,0x63,0x76,0x81,0x89,0x86,0x7d,
0x70,0x64,0x5d,0x5e,0x61,0x5d,0x51,0x40,0x31,0x2d,0x38,0x4e,0x69,0x80,0x8a,0x84,
0x76,0x64,0x58,0x53,0x4f,0x49,0x46,0x3d,0x3a,0x40,0x50,0x69,0x7f,0x8b,0x87,0x79,
0x69,0x5d,0x5b,0x62,0x6d,0x79,0x81,0x7d,0x73,0x69,0x62,0x61,0x66,0x6e,0x75,0x79,
0x79,0x75,0x6e,0x67,0x61,0x5d,0x5d,0x5a,0x53,0x49,0x3d,0x32,0x31,0x2f,0x31,0x39,
0x44,0x4e,0x54,0x5b,0x64,0x73,0x82,0x8f,0x97,0x9a,0x9b,0xa0,0xa5,0xa6,0xa0,0x94,
0x85,0x74,0x64,0x59,0x5a,0x67,0x74,0x7c,0x7e,0x7b,0x75,0x6e,0x67,0x63,0x5f,0x5a,
0x51,0x43,0x37,0x2f,0x33,0x44,0x5b,0x71,0x84,0x8e,0x91,0x93,0x93,0x97,0x9a,0x9e,
0x9d,0x98,0x8f,0x80,0x70,0x66,0x5b,0x51,0x49,0x42,0x3e,0x3c,0x3b,0x38,0x37,0x36,
0x39,0x40,0x47,0x4f,0x5d,0x6e,0x7b,0x84,0x8a,0x91,0x97,0x9f,0xa2,0xa2,0xa0,0x99,
0x8e,0x7e,0x6e,0x61,0x57,0x51,0x4b,0x46,0x42,0x3c,0x36,0x36,0x34,0x38,0x3e,0x3f,
0x3d,0x3b,0x37,0x34,0x36,0x3e,0x4c,0x5a,0x6d,0x7a,0x85,0x8f,0x95,0x9a,0x9c,0x9f,
0xa2,0xa4,0xa1,0x97,0x89,0x79,0x6a,0x61,0x5e,0x64,0x6d,0x76,0x7c,0x81,0x88,0x90,
0x97,0x9d,0x9b,0x91,0x80,0x69,0x55,0x4c,0x51,0x60,0x70,0x7b,0x80,0x7d,0x75,0x6c,
0x67,0x67,0x69,0x6a,0x6f,0x72,0x77,0x81,0x8c,0x97,0xa3,0xa9,0xab,0xaa,0xa6,0x9e,
0x92,0x83,0x71,0x63,0x5b,0x5d,0x64,0x6e,0x76,0x7b,0x79,0x6f,0x66,0x5f,0x5c,0x58,
0x53,0x4a,0x40,0x35,0x2c,0x28,0x2b,0x34,0x3d,0x3f,0x3f,0x39,0x32,0x33,0x39,0x43,
0x53,0x64,0x72,0x7e,0x88,0x91,0x98,0x9c,0x9a,0x90,0x80,0x6d,0x60,0x5d,0x61,0x6a,
0x76,0x80,0x82,0x7c,0x72,0x67,0x5f,0x5a,0x54,0x4d,0x44,0x3b,0x34,0x30,0x31,0x36,
0x3b,0x41,0x4b,0x59,0x64,0x6d,0x71,0x73,0x6a,0x60,0x56,0x56,0x5a,0x69,0x74,0x7c,
0x7d,0x78,0x70,0x67,0x64,0x69,0x73,0x7b,0x7d,0x7c,0x74,0x6b,0x64,0x61,0x62,0x67,
0x6e,0x72,0x73,0x73,0x74,0x78,0x80,0x8c,0x9a,0xa9,0xaf,0xac,0xa3,0x9a,0x93,0x92,
0x95,0x9b,0x9d,0x99,0x8d,0x7c,0x6c,0x61,0x5d,0x60,0x64,0x6a,0x74,0x7d,0x86,0x8f,
0x97,0x9d,0x9c,0x92,0x82,0x6d,0x62,0x5a,0x5a,0x64,0x71,0x7c,0x88,0x90,0x97,0x9f,
0xa1,0x9f,0x94,0x84,0x70,0x61,0x59,0x5a,0x64,0x70,0x7a,0x82,0x8c,0x94,0x9b,0x9d,
0x97,0x8c,0x7c,0x67,0x53,0x47,0x41,0x3d,0x3b,0x38,0x35,0x35,0x37,0x3b,0x3d,0x3c,
0x38,0x35,0x34,0x36,0x38,0x3c,0x3c,0x38,0x34,0x37,0x41,0x54,0x6a,0x79,0x7e,0x79,
0x6c,0x5f,0x5a,0x5e,0x67,0x71,0x74,0x76,0x7b,0x82,0x8d,0x98,0x9f,0x9f,0x94,0x81,
0x6b,0x58,0x49,0x3f,0x39,0x39,0x3b,0x3f,0x47,0x53,0x5f,0x70,0x7e,0x8a,0x92,0x96,
0x94,0x8f,0x85,0x77,0x6a,0x5e,0x52,0x48,0x41,0x3d,0x39,0x38,0x37,0x38,0x3e,0x44,
0x47,0x44,0x40,0x3a,0x37,0x39,0x40,0x4e,0x5e,0x6d,0x78,0x80,0x85,0x8d,0x95,0x9c,
0xa1,0xa5,0xa4,0x9f,0x93,0x85,0x78,0x6d,0x62,0x58,0x4e,0x46,0x40,0x3d,0x3d,0x42,
0x4e,0x5e,0x70,0x7f,0x8c,0x93,0x97,0x98,0x9a,0x9d,0xa0,0x9f,0x9c,0x93,0x89,0x7a,
0x6c,0x62,0x5d,0x5e,0x67,0x71,0x7b,0x7f,0x7c,0x74,0x69,0x60,0x5f,0x69,0x75,0x7d,
0x7c,0x76,0x6c,0x61,0x5d,0x5e,0x60,0x5d,0x51,0x41,0x34,0x2f,0x38,0x4e,0x68,0x7e,
0x89,0x86,0x79,0x65,0x5d,0x59,0x5d,0x67,0x6e,0x73,0x7e,0x85,0x8c,0x95,0x9b,0x9b,
0x93,0x83,0x6c,0x59,0x4b,0x42,0x3d,0x3c,0x3d,0x3c,0x3a,0x38,0x38,0x3b,0x40,0x47,
0x52,0x5f,0x6d,0x7b,0x88,0x93,0x9b,0x9c,0x98,0x8f,0x82,0x71,0x63,0x55,0x48,0x3d,
0x3b,0x39,0x3b,0x44,0x51,0x5f,0x70,0x7e,0x89,0x94,0x9a,0x98,0x91,0x87,0x79,0x6c,
0x5e,0x53,0x48,0x40,0x38,0x32,0x37,0x44,0x58,0x6d,0x7b,0x84,0x84,0x7b,0x6c,0x60,
0x5c,0x61,0x6a,0x71,0x75,0x78,0x7c,0x82,0x8b,0x98,0xa4,0xa9,0xa9,0xa2,0x9a,0x96,
0x97,0x9b,0x9e,0xa4,0xa5,0xa4,0xa2,0xa0,0x9e,0x9f,0x9c,0x9a,0x99,0x9a,0x9a,0x9b,
0x9c,0x9c,0x9b,0x93,0x88,0x7a,0x6c,0x60,0x59,0x5d,0x67,0x73,0x7b,0x7a,0x73,0x6b,
0x62,0x60,0x63,0x69,0x6e,0x73,0x76,0x78,0x7b,0x89,0x95,0x9f,0xa0,0x95,0x81,0x6f,
0x5d,0x53,0x57,0x64,0x73,0x7d,0x80,0x7c,0x75,0x6c,0x63,0x5a,0x54,0x4f,0x47,0x3e,
0x33,0x2e,0x2f,0x34,0x3b,0x44,0x4d,0x57,0x62,0x6c,0x75,0x82,0x8e,0x97,0x9a,0x98,
0x8f,0x82,0x70,0x5d,0x4c,0x42,0x3b,0x36,0x38,0x39,0x38,0x35,0x31,0x31,0x3a,0x49,
0x5a,0x6a,0x76,0x7b,0x79,0x71,0x67,0x61,0x61,0x65,0x69,0x6e,0x73,0x78,0x7e,0x85,
0x8f,0x9e,0xab,0xb0,0xaf,0xa8,0xa0,0x99,0x98,0x9b,0x9e,0xa0,0x9e,0x90,0x7f,0x6d,
0x61,0x5c,0x5e,0x64,0x70,0x79,0x7d,0x78,0x70,0x66,0x60,0x61,0x66,0x70,0x79,0x7c,
0x79,0x70,0x65,0x5e,0x5f,0x67,0x70,0x79,0x7e,0x7e,0x77,0x6e,0x69,0x68,0x69,0x67,
0x5e,0x51,0x42,0x33,0x2e,0x37,0x4c,0x67,0x7b,0x85,0x83,0x76,0x65,0x54,0x4d,0x4a,
0x49,0x45,0x3c,0x32,0x2e,0x30,0x37,0x41,0x47,0x47,0x40,0x35,0x30,0x36,0x44,0x57,
0x69,0x76,0x7a,0x77,0x6f,0x65,0x5b,0x57,0x53,0x4e,0x48,0x3e,0x36,0x30,0x2d,0x2f,
0x37,0x40,0x44,0x3c,0x38,0x31,0x34,0x40,0x51,0x66,0x79,0x7e,0x79,0x6f,0x61,0x58,
0x59,0x61,0x6b,0x74,0x79,0x79,0x74,0x6c,0x66,0x62,0x60,0x5d,0x55,0x4a,0x3b,0x2f,
0x29,0x2b,0x32,0x3a,0x3f,0x40,0x3c,0x35,0x30,0x2d,0x2e,0x30,0x34,0x38,0x39,0x36,
0x38,0x3b,0x3c,0x3a,0x36,0x32,0x32,0x33,0x37,0x40,0x4e,0x5e,0x6c,0x78,0x82,0x8e,
0x98,0x9f,0x9d,0x96,0x88,0x77,0x67,0x5d,0x5c,0x67,0x73,0x7c,0x81,0x7c,0x72,0x66,
0x5e,0x5e,0x67,0x71,0x77,0x76,0x71,0x68,0x5f,0x5b,0x5a,0x5a,0x59,0x50,0x42,0x35,
0x2b,0x2a,0x2b,0x35,0x3c,0x41,0x42,0x3e,0x37,0x33,0x31,0x31,0x36,0x38,0x39,0x3a,
0x38,0x36,0x36,0x36,0x37,0x37,0x35,0x33,0x34,0x37,0x3a,0x3a,0x3b,0x39,0x38,0x36,
// Line 18
0x38,0x38,0x37,0x38,0x38,0x38,0x38,0x38,0x38,0x3a,0x3b,0x3a,0x39,0x38,0x38,0x38,
0x38,0x38,0x38,0x37,0x35,0x34,0x34,0x35,0x38,0x39,0x38,0x36,0x36,0x36,0x34,0x35,
0x38,0x3d,0x40,0x43,0x46,0x4a,0x50,0x53,0x55,0x58,0x59,0x59,0x5a,0x5b,0x5c,0x5a,
0x5c,0x5b,0x5b,0x5b,0x5c,0x5b,0x5c,0x59,0x56,0x57,0x56,0x53,0x54,0x56,0x57,0x59,
0x58,0x57,0x57,0x59,0x59,0x58,0x59,0x5b,0x5c,0x5b,0x5a,0x59,0x5a,0x5a,0x59,0x58,
0x58,0x57,0x57,0x57,0x59,0x5a,0x5b,0x5b,0x5c,0x5d,0x5e,0x5c,0x5c,0x5a,0x57,0x57,
0x57,0x55,0x57,0x56,0x57,0x57,0x56,0x57,0x59,0x5a,0x5b,0x5b,0x5b,0x5c,0x5b,0x59,
0x57,0x57,0x56,0x56,0x55,0x55,0x55,0x57,0x59,0x5a,0x5b,0x5c,0x5d,0x5d,0x5d,0x5c,
0x5b,0x5a,0x5b,0x59,0x58,0x59,0x59,0x57,0x57,0x57,0x59,0x5a,0x5a,0x5a,0x59,0x5b,
0x5a,0x5a,0x5b,0x5c,0x5c,0x5a,0x57,0x56,0x57,0x57,0x57,0x56,0x57,0x56,0x56,0x56,
0x56,0x58,0x5a,0x5a,0x59,0x59,0x5b,0x5b,0x5a,0x5b,0x5c,0x5d,0x5d,0x5b,0x59,0x56,
0x55,0x56,0x55,0x54,0x54,0x57,0x57,0x59,0x59,0x5c,0x5e,0x5d,0x5b,0x58,0x58,0x59,
0x58,0x57,0x54,0x54,0x54,0x53,0x54,0x57,0x5b,0x5e,0x5d,0x5c,0x5b,0x5b,0x5a,0x59,
0x59,0x5b,0x5b,0x5a,0x5a,0x59,0x5a,0x5c,0x5b,0x59,0x59,0x5a,0x5b,0x5b,0x59,0x59,
0x58,0x58,0x57,0x57,0x59,0x5d,0x5e,0x5e,0x59,0x57,0x59,0x59,0x5b,0x5b,0x5c,0x5b,
0x5b,0x59,0x5a,0x5b,0x5d,0x5d,0x5b,0x59,0x59,0x59,0x59,0x59,0x59,0x5b,0x5a,0x58,
0x57,0x57,0x59,0x5a,0x5b,0x5b,0x5a,0x59,0x57,0x57,0x59,0x59,0x5b,0x5c,0x59,0x57,
0x58,0x57,0x56,0x57,0x59,0x5b,0x5b,0x5a,0x59,0x5a,0x5b,0x5a,0x59,0x5b,0x5d,0x5c,
0x59,0x55,0x53,0x56,0x57,0x57,0x57,0x56,0x55,0x54,0x55,0x56,0x59,0x5d,0x5e,0x5c,
0x59,0x57,0x56,0x59,0x5f,0x61,0x61,0x5c,0x56,0x4e,0x4e,0x57,0x67,0x7a,0x87,0x88,
0x82,0x73,0x67,0x62,0x64,0x67,0x68,0x60,0x56,0x4e,0x4b,0x4e,0x57,0x61,0x69,0x67,
0x60,0x59,0x56,0x55,0x57,0x5a,0x5e,0x5d,0x5b,0x5b,0x5a,0x5b,0x5d,0x5c,0x5a,0x58,
0x59,0x59,0x5a,0x5b,0x5a,0x59,0x5c,0x5a,0x58,0x59,0x5d,0x5d,0x5c,0x5b,0x5a,0x5b,
0x5c,0x5b,0x59,0x57,0x57,0x59,0x59,0x59,0x59,0x5b,0x5c,0x5c,0x5d,0x5f,0x5f,0x5d,
0x5b,0x59,0x59,0x58,0x59,0x5b,0x5a,0x59,0x59,0x5a,0x5b,0x5a,0x5d,0x5c,0x59,0x57,
0x58,0x59,0x59,0x57,0x57,0x58,0x57,0x57,0x56,0x58,0x59,0x59,0x59,0x57,0x57,0x59,
0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5d,0x5c,0x5c,0x5b,0x5b,0x59,0x59,0x59,0x59,0x58,
0x57,0x58,0x59,0x5a,0x5a,0x5d,0x5d,0x5c,0x5c,0x5b,0x59,0x5a,0x5c,0x5c,0x5a,0x58,
0x57,0x57,0x59,0x59,0x59,0x5b,0x5c,0x5b,0x5b,0x59,0x59,0x5a,0x5b,0x5a,0x5b,0x5c,
0x5c,0x5d,0x5b,0x59,0x59,0x5b,0x5b,0x5a,0x5a,0x59,0x59,0x5a,0x5b,0x5c,0x5d,0x5c,
0x5b,0x5c,0x5b,0x59,0x56,0x55,0x56,0x57,0x58,0x58,0x57,0x59,0x5b,0x59,0x5a,0x5a,
0x5b,0x5c,0x5c,0x59,0x5a,0x5c,0x5c,0x5b,0x5b,0x5b,0x5a,0x59,0x59,0x59,0x5b,0x59,
0x59,0x59,0x58,0x57,0x58,0x59,0x59,0x5a,0x5b,0x5b,0x57,0x57,0x58,0x59,0x5b,0x5a,
0x59,0x59,0x58,0x55,0x57,0x59,0x5b,0x5e,0x5d,0x5d,0x5c,0x5b,0x5c,0x5c,0x5d,0x5a,
0x59,0x57,0x56,0x54,0x54,0x56,0x59,0x5a,0x5b,0x5c,0x5d,0x5c,0x5b,0x5c,0x5d,0x5e,
0x5c,0x5a,0x57,0x57,0x56,0x56,0x55,0x54,0x55,0x54,0x56,0x57,0x57,0x58,0x59,0x5a,
0x5c,0x5c,0x5f,0x5f,0x5f,0x5d,0x59,0x59,0x58,0x57,0x57,0x55,0x55,0x57,0x57,0x57,
0x57,0x57,0x57,0x59,0x5c,0x5d,0x5d,0x5d,0x5b,0x5b,0x59,0x58,0x57,0x57,0x59,0x58,
0x56,0x51,0x4d,0x4c,0x4b,0x49,0x47,0x46,0x48,0x48,0x47,0x43,0x42,0x44,0x46,0x44,
0x44,0x42,0x40,0x40,0x40,0x40,0x42,0x41,0x40,0x42,0x44,0x44,0x44,0x45,0x47,0x47,
0x46,0x46,0x46,0x47,0x49,0x4b,0x49,0x44,0x44,0x47,0x49,0x47,0x47,0x48,0x49,0x47,
0x45,0x44,0x48,0x4b,0x4b,0x47,0x45,0x43,0x41,0x42,0x44,0x44,0x45,0x46,0x44,0x45,
0x46,0x47,0x46,0x49,0x47,0x47,0x46,0x44,0x42,0x43,0x43,0x42,0x42,0x42,0x42,0x44,
0x43,0x42,0x43,0x46,0x49,0x4b,0x4a,0x49,0x49,0x4b,0x49,0x47,0x47,0x47,0x45,0x45,
0x44,0x44,0x44,0x45,0x44,0x46,0x46,0x47,0x48,0x47,0x45,0x45,0x45,0x46,0x44,0x42,
0x42,0x42,0x41,0x40,0x40,0x43,0x45,0x44,0x44,0x46,0x49,0x49,0x48,0x47,0x49,0x49,
0x47,0x44,0x45,0x44,0x45,0x47,0x46,0x44,0x46,0x45,0x44,0x43,0x45,0x49,0x49,0x46,
0x45,0x47,0x49,0x48,0x45,0x45,0x45,0x45,0x45,0x43,0x43,0x44,0x42,0x41,0x42,0x44,
0x48,0x49,0x46,0x43,0x42,0x43,0x44,0x44,0x46,0x49,0x4e,0x54,0x5a,0x64,0x71,0x7f,
0x8c,0x98,0xa0,0xa7,0xae,0xb1,0xb2,0xb5,0xb6,0xb6,0xb3,0xb3,0xb3,0xb3,0xb3,0xb2,
0xb1,0xb1,0xb2,0xb1,0xb0,0xb0,0xb1,0xb2,0xb1,0xb0,0xb0,0xb3,0xb6,0xb6,0xb5,0xb1,
0xb0,0xb1,0xb1,0xaf,0xaf,0xaf,0xb0,0xae,0xac,0xac,0xae,0xae,0xaf,0xb1,0xb1,0xb2,
0xb3,0xb3,0xb4,0xb3,0xb5,0xb4,0xb3,0xb5,0xb3,0xb0,0xaf,0xaf,0xb0,0xb1,0xb0,0xad,
0xae,0xaf,0xb1,0xb1,0xb2,0xb2,0xb2,0xb2,0xb1,0xb0,0xb0,0xb1,0xb0,0xb1,0xaf,0xaf,
0xb0,0xb0,0xb0,0xb0,0xb2,0xb3,0xb2,0xb0,0xae,0xaf,0xb1,0xb0,0xaf,0xaf,0xb0,0xad,
0xad,0xac,0xaf,0xaf,0xb1,0xae,0xaf,0xb0,0xb2,0xb2,0xb2,0xb0,0xaf,0xb0,0xb0,0xb0,
0xb2,0xb1,0xb0,0xaf,0xae,0xaf,0xb1,0xb0,0xaf,0xb0,0xb0,0xb1,0xaf,0xb0,0xb1,0xb2,
0xb3,0xb2,0xb0,0xb0,0xaf,0xaf,0xaf,0xae,0xaf,0xb0,0xaf,0xae,0xaf,0xb2,0xb3,0xb2,
0xb2,0xb1,0xb1,0xb2,0xb0,0xaf,0xaf,0xaf,0xae,0xae,0xae,0xb0,0xb1,0xb1,0xb0,0xaf,
0xaf,0xb0,0xb1,0xb2,0xb2,0xb0,0xaf,0xac,0xa9,0xa7,0xa6,0xa6,0xa4,0xa0,0x9d,0x9d,
0x9d,0x9d,0x9e,0xa1,0xa3,0xa4,0xa3,0xa1,0x9f,0xa1,0xa1,0xa0,0x9f,0x9d,0x9d,0x9c,
0x9c,0x9c,0x9c,0x9d,0x9d,0x9f,0xa0,0xa1,0xa0,0xa2,0xa1,0xa0,0xa1,0xa2,0xa1,0xa1,
0xa0,0x9f,0x9e,0x9d,0x9e,0x9f,0x9e,0x9e,0xa0,0xa1,0xa2,0xa1,0xa0,0x9d,0x9c,0x9d,
0x9e,0x9f,0xa0,0x9f,0x9d,0x9d,0x9c,0x9d,0x9f,0xa1,0xa1,0xa0,0x9e,0x9d,0x9c,0x9c,
0x9d,0xa0,0xa2,0xa2,0xa0,0x9e,0x9d,0x9e,0x9f,0x9f,0x9f,0xa1,0xa0,0x9f,0x9d,0x9f,
0xa1,0xa4,0xa4,0xa2,0xa1,0xa1,0xa1,0xa0,0x9f,0x9f,0x9e,0x9f,0x9f,0x9e,0x9c,0x9e,
0x9d,0x9d,0x9c,0x9c,0x9a,0x9d,0x9d,0x9e,0xa1,0xa2,0xa2,0xa2,0xa2,0xa4,0xa5,0xa5,
0xa4,0xa4,0xa2,0x9f,0x9f,0xa0,0xa0,0xa1,0xa1,0xa1,0xa1,0xa3,0xa4,0xa3,0xa1,0xa0,
0x9f,0xa0,0x9f,0x9d,0x9e,0x9f,0x9e,0x9d,0x9e,0xa0,0xa0,0xa2,0xa0,0x9e,0x9f,0xa0,
0x9e,0x9e,0x9d,0x9e,0x9f,0x9f,0xa0,0xa1,0xa1,0xa1,0xa0,0x9e,0x9e,0x9f,0xa0,0x9f,
0x9e,0x9f,0x9f,0x9f,0xa0,0xa1,0xa0,0xa2,0xa1,0xa0,0xa1,0xa1,0xa0,0x9f,0x9f,0xa0,
0xa0,0xa0,0x9d,0x9e,0xa0,0xa0,0x9e,0x9c,0x9a,0x9d,0xa0,0xa1,0xa1,0xa1,0xa1,0x9e,
0x9d,0x9e,0x9e,0x9f,0xa0,0xa0,0x9f,0xa0,0xa0,0xa0,0x9f,0x9f,0x9f,0xa1,0xa1,0xa1,
0xa1,0xa1,0xa0,0x9e,0x9f,0xa2,0xa0,0xa2,0x9e,0x9b,0x9c,0x9d,0x9d,0xa1,0xa1,0x9f,
0xa1,0xa1,0xa1,0xa1,0xa4,0xa1,0x9f,0x9d,0x9d,0x9d,0xa1,0xa0,0x9f,0xa0,0x9f,0x9e,
0xa0,0xa1,0xa2,0xa4,0xa2,0xa1,0xa1,0xa1,0xa1,0xa1,0xa0,0xa1,0xa1,0xa0,0x9e,0x9e,
0x9f,0xa0,0x9f,0x9d,0x9c,0x9e,0xa2,0xa4,0xa1,0x9f,0x9d,0x9a,0x9b,0x9d,0xa1,0xa5,
0xa2,0x98,0x87,0x77,0x6c,0x68,0x71,0x79,0x85,0x90,0x94,0x94,0x97,0x9c,0xa3,0xaa,
0xad,0xac,0xa4,0x9d,0x96,0x93,0x98,0x9e,0xa2,0xa3,0xa1,0xa0,0xa0,0x9f,0x9e,0xa0,
0xa2,0xa2,0xa1,0xa0,0xa1,0xa4,0xa2,0x9e,0x9d,0x9d,0x9c,0x9d,0x9e,0x9f,0xa0,0xa0,
0x9e,0x9f,0xa0,0xa0,0x9f,0x9f,0x9f,0xa0,0x9f,0xa1,0xa1,0x9f,0x9e,0x9e,0x9c,0x9d,
0x9d,0x9d,0x9f,0xa0,0xa0,0xa1,0xa1,0xa2,0xa4,0xa2,0xa1,0xa1,0xa0,0xa0,0x9e,0x9e,
0x9d,0x9c,0x9d,0x9d,0x9d,0xa0,0xa2,0xa1,0x9f,0x9e,0xa0,0xa2,0xa2,0xa2,0xa0,0xa1,
0xa0,0x9e,0xa0,0xa1,0xa3,0xa4,0x9e,0x9c,0x9c,0x9d,0x9e,0x9d,0xa0,0xa0,0xa0,0xa0,
0xa0,0xa1,0xa2,0xa0,0x9e,0x9d,0x9c,0x9c,0x9c,0x9b,0x9c,0x9e,0xa1,0xa1,0x9f,0x9d,
0x9d,0x9f,0x9f,0x9e,0x9e,0x9d,0x9c,0x9a,0x9b,0x9d,0x9e,0x9f,0x9e,0x9d,0x9e,0xa0,
0xa2,0xa2,0xa2,0xa2,0xa2,0xa1,0x9f,0x9d,0xa1,0xa1,0x9f,0x9e,0x9e,0x9f,0x9f,0x9e,
0x9c,0x9e,0x9e,0x9d,0x9c,0x9b,0x9b,0x9c,0x9c,0x9d,0xa0,0xa1,0xa1,0x9f,0x9f,0x9e,
0x9f,0x9f,0x9e,0x9d,0x9e,0x9e,0x9f,0xa0,0xa0,0xa1,0xa1,0xa0,0xa0,0x9e,0xa2,0xa1,
0xa1,0xa3,0xa3,0xa1,0xa0,0x9f,0x9d,0x9e,0x9d,0x9d,0x9b,0x9a,0x99,0x9b,0x9d,0x9d,
0x9e,0x9f,0x9e,0x9c,0x9d,0x9e,0xa0,0xa1,0xa0,0x9d,0x9d,0x9d,0x9d,0x9e,0x9f,0xa0,
0x9f,0x9d,0x9c,0x9c,0x9d,0x9f,0x9f,0xa0,0x9f,0xa0,0x9f,0x9e,0x9d,0x9f,0xa0,0xa0,
0xa0,0x9f,0x9f,0xa0,0xa1,0xa1,0x9f,0x9e,0x9d,0x9c,0x9c,0x9c,0x9c,0x9d,0x9c,0x9c,
0x9d,0x9d,0x9e,0x9d,0x9c,0x9d,0x9f,0xa1,0xa2,0xa3,0xa7,0xa6,0xa4,0xa2,0xa2,0xa3,
0xa6,0xa4,0xa0,0x9e,0x9d,0x9e,0x9c,0x9c,0x9e,0xa2,0xa3,0xa1,0x9e,0x9d,0x9c,0x9b,
0x99,0x91,0x88,0x7e,0x72,0x66,0x5c,0x54,0x4c,0x44,0x3c,0x36,0x36,0x38,0x3a,0x3b,
// Line 19
0x35,0x36,0x37,0x36,0x35,0x33,0x33,0x33,0x34,0x37,0x39,0x39,0x38,0x38,0x39,0x3c,
0x3a,0x38,0x38,0x39,0x38,0x36,0x35,0x36,0x38,0x3b,0x3c,0x3e,0x44,0x4b,0x50,0x54,
0x57,0x5a,0x5f,0x61,0x60,0x60,0x62,0x63,0x62,0x60,0x60,0x60,0x5f,0x5e,0x5d,0x61,
0x61,0x61,0x62,0x63,0x63,0x62,0x60,0x5e,0x61,0x64,0x67,0x66,0x64,0x61,0x61,0x60,
0x5f,0x5f,0x61,0x63,0x61,0x60,0x5f,0x61,0x63,0x63,0x62,0x63,0x65,0x65,0x63,0x64,
0x62,0x61,0x61,0x62,0x62,0x63,0x62,0x61,0x61,0x60,0x61,0x63,0x63,0x62,0x62,0x62,
0x63,0x62,0x61,0x61,0x61,0x62,0x61,0x60,0x60,0x5f,0x5f,0x60,0x61,0x61,0x62,0x62,
0x61,0x60,0x60,0x62,0x62,0x60,0x5e,0x5e,0x5f,0x5e,0x5d,0x60,0x60,0x60,0x60,0x5e,
0x60,0x61,0x61,0x60,0x61,0x62,0x65,0x63,0x62,0x60,0x5e,0x5f,0x5f,0x5f,0x60,0x60,
0x5f,0x5e,0x5d,0x5d,0x60,0x60,0x5e,0x5d,0x5d,0x5e,0x5d,0x5b,0x5c,0x5d,0x5e,0x5d,
0x5d,0x5d,0x5f,0x5f,0x5e,0x5c,0x5a,0x5b,0x5c,0x5b,0x5c,0x5d,0x5d,0x5b,0x58,0x57,
0x58,0x5b,0x5b,0x59,0x59,0x56,0x54,0x53,0x53,0x54,0x56,0x55,0x52,0x51,0x51,0x54,
0x53,0x51,0x50,0x50,0x50,0x4f,0x4d,0x4b,0x4b,0x4b,0x4b,0x49,0x49,0x4a,0x49,0x47,
0x47,0x46,0x45,0x44,0x43,0x40,0x3d,0x3e,0x3d,0x3b,0x39,0x3a,0x3a,0x38,0x36,0x36,
0x38,0x38,0x36,0x34,0x32,0x31,0x31,0x30,0x2f,0x2e,0x2f,0x30,0x2e,0x2f,0x2f,0x2f,
0x32,0x33,0x33,0x35,0x35,0x35,0x37,0x3a,0x3c,0x3c,0x3c,0x3d,0x40,0x44,0x47,0x4b,
0x4c,0x4f,0x51,0x54,0x56,0x59,0x61,0x68,0x6b,0x6e,0x72,0x78,0x7d,0x81,0x84,0x8a,
0x91,0x91,0x8f,0x91,0x91,0x94,0x95,0x96,0x96,0x97,0x95,0x92,0x91,0x91,0x8f,0x8e,
0x8a,0x85,0x80,0x7c,0x79,0x73,0x6a,0x62,0x5b,0x55,0x4e,0x47,0x44,0x40,0x3b,0x36,
0x31,0x30,0x2f,0x2d,0x2b,0x29,0x2b,0x2e,0x2f,0x31,0x35,0x39,0x40,0x44,0x4b,0x53,
0x58,0x5e,0x65,0x6d,0x76,0x7b,0x85,0x8d,0x92,0x97,0x9a,0x9b,0x99,0x96,0x93,0x8f,
0x87,0x7f,0x78,0x6e,0x65,0x5e,0x57,0x50,0x4a,0x44,0x3d,0x38,0x34,0x31,0x2e,0x2d,
0x2d,0x2f,0x33,0x34,0x36,0x3d,0x45,0x4f,0x5b,0x67,0x73,0x7c,0x86,0x8b,0x90,0x95,
0x97,0x94,0x91,0x89,0x80,0x79,0x70,0x66,0x5d,0x53,0x49,0x40,0x38,0x34,0x31,0x2f,
0x2e,0x2e,0x32,0x38,0x3d,0x45,0x4c,0x57,0x64,0x70,0x7a,0x85,0x8b,0x8d,0x8f,0x8d,
0x89,0x84,0x7b,0x70,0x64,0x59,0x50,0x45,0x41,0x3a,0x37,0x35,0x34,0x34,0x37,0x3d,
0x45,0x50,0x5c,0x69,0x76,0x82,0x89,0x8d,0x8f,0x8d,0x86,0x7d,0x72,0x66,0x5b,0x4d,
0x41,0x3a,0x36,0x35,0x36,0x37,0x3c,0x43,0x4b,0x54,0x61,0x70,0x7d,0x86,0x8d,0x8d,
0x89,0x85,0x7d,0x72,0x64,0x57,0x49,0x3f,0x36,0x32,0x31,0x33,0x37,0x3f,0x4c,0x5d,
0x6d,0x7b,0x86,0x8b,0x8d,0x89,0x83,0x79,0x6d,0x5e,0x4f,0x42,0x38,0x31,0x2d,0x2d,
0x33,0x3e,0x4c,0x5c,0x6c,0x79,0x84,0x8c,0x8b,0x84,0x7b,0x73,0x68,0x5b,0x4d,0x41,
0x36,0x30,0x2e,0x31,0x3d,0x4e,0x61,0x73,0x7f,0x87,0x8a,0x88,0x81,0x77,0x6c,0x5f,
0x50,0x40,0x36,0x30,0x2f,0x34,0x41,0x55,0x6a,0x7c,0x89,0x8c,0x8b,0x87,0x7d,0x70,
0x63,0x56,0x4a,0x3d,0x36,0x33,0x37,0x49,0x59,0x6c,0x7c,0x87,0x8a,0x84,0x78,0x6c,
0x62,0x54,0x47,0x3c,0x34,0x30,0x35,0x44,0x57,0x68,0x7e,0x87,0x89,0x83,0x79,0x6d,
0x60,0x51,0x46,0x3f,0x3b,0x3c,0x45,0x56,0x68,0x79,0x83,0x86,0x82,0x77,0x6a,0x5b,
0x4f,0x43,0x3a,0x38,0x3c,0x47,0x59,0x6d,0x7e,0x85,0x84,0x7a,0x6d,0x5f,0x53,0x46,
0x3f,0x39,0x3a,0x44,0x53,0x66,0x77,0x83,0x86,0x83,0x76,0x64,0x53,0x47,0x41,0x41,
0x45,0x4e,0x5b,0x6c,0x78,0x81,0x81,0x78,0x6c,0x5d,0x4f,0x43,0x3f,0x43,0x4d,0x5c,
0x6b,0x77,0x7f,0x81,0x79,0x6c,0x5a,0x4a,0x3d,0x3c,0x40,0x4a,0x5a,0x67,0x71,0x7c,
0x7f,0x77,0x6a,0x59,0x4c,0x44,0x43,0x48,0x53,0x62,0x6d,0x74,0x76,0x72,0x6a,0x5e,
0x51,0x46,0x43,0x48,0x52,0x60,0x6a,0x72,0x77,0x74,0x6b,0x5f,0x54,0x4d,0x4c,0x51,
0x59,0x63,0x6e,0x73,0x70,0x6b,0x61,0x57,0x4e,0x4a,0x4b,0x52,0x5d,0x67,0x70,0x73,
0x70,0x66,0x5d,0x55,0x50,0x4f,0x53,0x59,0x64,0x6a,0x6c,0x68,0x61,0x59,0x56,0x53,
0x54,0x59,0x60,0x68,0x6c,0x6c,0x69,0x62,0x5c,0x57,0x54,0x55,0x59,0x5e,0x65,0x66,
0x67,0x65,0x61,0x5d,0x58,0x58,0x59,0x5c,0x61,0x66,0x68,0x65,0x5d,0x55,0x54,0x57,
0x5a,0x61,0x65,0x66,0x65,0x5f,0x58,0x54,0x54,0x59,0x60,0x64,0x67,0x66,0x62,0x5a,
0x52,0x4f,0x50,0x55,0x5d,0x65,0x6c,0x6e,0x68,0x5d,0x52,0x50,0x51,0x59,0x64,0x6d,
0x6e,0x6d,0x60,0x53,0x4c,0x4c,0x55,0x63,0x70,0x76,0x77,0x6c,0x5a,0x49,0x40,0x44,
0x51,0x63,0x73,0x79,0x74,0x64,0x50,0x43,0x42,0x4c,0x5f,0x71,0x7b,0x79,0x6b,0x57,
0x47,0x43,0x4b,0x5e,0x71,0x7c,0x7b,0x70,0x57,0x3f,0x37,0x40,0x56,0x70,0x7f,0x80,
0x73,0x5d,0x45,0x39,0x41,0x59,0x73,0x84,0x82,0x70,0x57,0x40,0x38,0x45,0x5e,0x77,
0x84,0x7f,0x6c,0x52,0x3d,0x3a,0x4b,0x65,0x7a,0x83,0x7a,0x61,0x44,0x33,0x39,0x4f,
0x6c,0x80,0x83,0x72,0x54,0x38,0x34,0x48,0x66,0x7f,0x8a,0x7f,0x63,0x47,0x38,0x41,
0x5e,0x7c,0x8a,0x83,0x69,0x4b,0x38,0x3a,0x51,0x72,0x87,0x85,0x6e,0x4f,0x3a,0x3a,
0x50,0x6e,0x84,0x86,0x70,0x51,0x3c,0x3a,0x4e,0x6c,0x81,0x82,0x70,0x54,0x40,0x3b,
0x51,0x6f,0x84,0x84,0x6d,0x50,0x3d,0x40,0x54,0x6e,0x7f,0x7d,0x68,0x4b,0x3b,0x43,
0x5c,0x78,0x81,0x7c,0x62,0x49,0x40,0x4e,0x67,0x81,0x83,0x70,0x55,0x41,0x41,0x55,
0x6f,0x81,0x81,0x6d,0x53,0x43,0x4a,0x62,0x79,0x81,0x72,0x5a,0x47,0x44,0x53,0x6d,
0x7c,0x7b,0x68,0x51,0x46,0x50,0x66,0x79,0x7f,0x72,0x5d,0x4b,0x4c,0x5c,0x6f,0x78,
0x6e,0x5a,0x4b,0x48,0x55,0x67,0x73,0x71,0x62,0x52,0x4b,0x51,0x66,0x74,0x75,0x69,
0x57,0x4d,0x52,0x61,0x6e,0x72,0x69,0x59,0x50,0x52,0x5d,0x6c,0x73,0x6d,0x5f,0x53,
0x52,0x5d,0x6c,0x73,0x70,0x65,0x5b,0x57,0x5d,0x68,0x6e,0x6c,0x60,0x54,0x51,0x58,
0x63,0x6a,0x6a,0x64,0x5d,0x5b,0x5f,0x65,0x6d,0x6c,0x63,0x5b,0x57,0x5a,0x62,0x68,
0x65,0x5e,0x58,0x56,0x59,0x61,0x65,0x67,0x63,0x5c,0x59,0x5c,0x63,0x67,0x69,0x65,
0x61,0x5f,0x5f,0x62,0x67,0x68,0x65,0x60,0x5d,0x5e,0x62,0x66,0x66,0x63,0x63,0x61,
0x61,0x63,0x64,0x66,0x65,0x63,0x5e,0x60,0x62,0x65,0x63,0x61,0x60,0x60,0x63,0x64,
0x63,0x63,0x62,0x61,0x60,0x5f,0x61,0x62,0x60,0x5b,0x59,0x5c,0x5f,0x61,0x61,0x60,
0x5f,0x5f,0x5f,0x60,0x63,0x66,0x66,0x65,0x62,0x61,0x62,0x63,0x62,0x63,0x63,0x63,
0x61,0x5e,0x5c,0x5b,0x5d,0x5e,0x5f,0x61,0x62,0x62,0x60,0x5e,0x60,0x63,0x64,0x64,
0x63,0x62,0x61,0x5f,0x5e,0x5f,0x62,0x65,0x65,0x63,0x63,0x63,0x65,0x65,0x64,0x63,
0x62,0x5f,0x5c,0x5d,0x60,0x62,0x5f,0x60,0x5e,0x5f,0x61,0x63,0x63,0x65,0x65,0x61,
0x60,0x5e,0x5e,0x60,0x60,0x5e,0x5f,0x60,0x61,0x60,0x5f,0x5e,0x5f,0x60,0x5f,0x5f,
0x61,0x62,0x62,0x64,0x62,0x61,0x61,0x62,0x63,0x63,0x63,0x63,0x62,0x5f,0x5d,0x5f,
0x61,0x63,0x62,0x63,0x61,0x5e,0x5f,0x5f,0x60,0x63,0x63,0x60,0x5f,0x5f,0x61,0x61,
0x61,0x5e,0x5b,0x5b,0x5b,0x5b,0x5c,0x5d,0x60,0x62,0x62,0x61,0x62,0x63,0x63,0x65,
0x65,0x62,0x60,0x5d,0x5b,0x5d,0x60,0x61,0x61,0x61,0x61,0x60,0x61,0x62,0x64,0x66,
0x66,0x64,0x63,0x61,0x61,0x60,0x5e,0x5d,0x5d,0x5d,0x5e,0x5f,0x60,0x5f,0x5f,0x61,
0x60,0x60,0x60,0x61,0x60,0x5f,0x5d,0x5e,0x5e,0x5d,0x5c,0x5e,0x5f,0x5f,0x5e,0x5e,
0x5f,0x5f,0x61,0x60,0x60,0x63,0x63,0x62,0x61,0x60,0x61,0x62,0x62,0x61,0x60,0x60,
0x5e,0x5c,0x5c,0x5d,0x5f,0x61,0x60,0x5f,0x60,0x62,0x63,0x65,0x66,0x65,0x64,0x62,
0x60,0x60,0x60,0x61,0x5f,0x5e,0x5d,0x5e,0x60,0x61,0x61,0x62,0x61,0x60,0x5f,0x61,
0x63,0x64,0x62,0x5f,0x5d,0x5f,0x60,0x60,0x61,0x62,0x62,0x62,0x5f,0x5e,0x60,0x62,
0x62,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x62,0x62,0x60,0x61,0x60,0x5f,0x5e,0x5d,
0x5d,0x5f,0x61,0x62,0x63,0x63,0x63,0x61,0x63,0x63,0x64,0x65,0x65,0x63,0x61,0x5f,
0x5d,0x5f,0x5e,0x5d,0x5c,0x5d,0x5e,0x5f,0x5f,0x61,0x63,0x63,0x61,0x61,0x63,0x64,
0x63,0x61,0x60,0x60,0x62,0x63,0x62,0x63,0x65,0x64,0x64,0x63,0x63,0x62,0x61,0x60,
0x5e,0x5e,0x5e,0x5d,0x60,0x5e,0x5e,0x61,0x62,0x62,0x63,0x64,0x64,0x63,0x61,0x61,
0x63,0x62,0x60,0x5f,0x5f,0x5f,0x5e,0x5e,0x5e,0x60,0x61,0x60,0x60,0x60,0x62,0x62,
0x62,0x62,0x62,0x61,0x5d,0x56,0x51,0x4d,0x4a,0x44,0x3e,0x3a,0x38,0x39,0x38,0x37,
0x37,0x38,0x38,0x3a,0x3b,0x39,0x38,0x38,0x36,0x34,0x34,0x36,0x35,0x34,0x33,0x32,
0x34,0x35,0x35,0x36,0x37,0x37,0x38,0x38,0x39,0x3a,0x3a,0x38,0x35,0x33,0x34,0x35,
0x35,0x35,0x36,0x38,0x37,0x35,0x36,0x37,0x35,0x35,0x34,0x35,0x35,0x35,0x35,0x33,
0x35,0x38,0x38,0x38,0x35,0x34,0x35,0x34,0x32,0x33,0x35,0x36,0x37,0x36,0x37,0x39,
0x39,0x38,0x37,0x38,0x39,0x37,0x34,0x32,0x33,0x34,0x35,0x34,0x33,0x33,0x34,0x37,
0x37,0x37,0x38,0x39,0x38,0x35,0x35,0x35,0x34,0x36,0x35,0x33,0x34,0x35,0x35,0x36,
// Line 20
0x38,0x36,0x38,0x38,0x39,0x39,0x37,0x34,0x32,0x33,0x35,0x36,0x38,0x37,0x37,0x37,
0x39,0x3b,0x3b,0x3a,0x3b,0x39,0x38,0x36,0x34,0x35,0x36,0x38,0x39,0x3d,0x42,0x49,
0x53,0x60,0x6e,0x7e,0x8d,0x9b,0xa6,0xb1,0xb8,0xbd,0xc0,0xc3,0xc2,0xc1,0xc0,0xbc,
0xb9,0xba,0xb9,0xba,0xbd,0xbf,0xc0,0xc2,0xc1,0xbe,0xbd,0xbd,0xbd,0xbc,0xbc,0xbb,
0xbc,0xbc,0xbb,0xbb,0xbc,0xbe,0xbd,0xbd,0xbc,0xbd,0xbd,0xbc,0xbc,0xbd,0xbe,0xbf,
0xbf,0xc0,0xc0,0xbf,0xbf,0xbf,0xbe,0xbc,0xbc,0xbb,0xbc,0xbc,0xbd,0xbe,0xbd,0xbd,
0xbe,0xbd,0xbb,0xb9,0xb9,0xbb,0xbb,0xba,0xba,0xb8,0xbc,0xbb,0xba,0xbc,0xbd,0xbe,
0xbf,0xbc,0xba,0xba,0xba,0xbb,0xbb,0xba,0xba,0xb8,0xb8,0xb9,0xbb,0xbc,0xbd,0xbb,
0xbc,0xbc,0xbd,0xbd,0xbc,0xbc,0xbe,0xbf,0xbe,0xbd,0xbd,0xbd,0xbe,0xbd,0xbc,0xbc,
0xbd,0xbd,0xbd,0xbe,0xc0,0xc2,0xc4,0xc5,0xc2,0xc2,0xc1,0xc1,0xbf,0xbe,0xbc,0xbc,
0xbc,0xbc,0xbb,0xba,0xbb,0xbb,0xbc,0xbc,0xbd,0xbe,0xbd,0xbc,0xbc,0xbe,0xbf,0xc0,
0xc1,0xbf,0xbf,0xbd,0xbc,0xbc,0xbf,0xc1,0xbf,0xbe,0xbc,0xbc,0xbc,0xbb,0xbb,0xbe,
0xbf,0xbf,0xbc,0xb8,0xb8,0xbb,0xbd,0xbe,0xbc,0xbc,0xbb,0xb9,0xba,0xbc,0xbf,0xc4,
0xc2,0xbc,0xb8,0xb8,0xbc,0xc2,0xc3,0xc0,0xb9,0xac,0xa0,0x98,0x9a,0xa3,0xaa,0xaa,
0xa0,0x92,0x86,0x7f,0x84,0x95,0xa6,0xac,0xa5,0x92,0x7f,0x79,0x82,0x96,0xaa,0xb3,
0xab,0x97,0x81,0x76,0x7e,0x95,0xa9,0xb1,0xaa,0x96,0x7f,0x73,0x7b,0x91,0xa9,0xb4,
0xac,0x97,0x81,0x76,0x7d,0x93,0xa8,0xb1,0xaa,0x94,0x7c,0x72,0x7c,0x93,0xa9,0xb3,
0xaa,0x98,0x82,0x77,0x80,0x95,0xa9,0xb2,0xab,0x96,0x80,0x75,0x7c,0x8f,0xa7,0xb2,
0xac,0x98,0x81,0x75,0x7e,0x94,0xa9,0xaf,0xab,0x98,0x82,0x77,0x7e,0x94,0xac,0xb6,
0xad,0x97,0x81,0x78,0x82,0x97,0xaa,0xb6,0xaf,0x9c,0x84,0x79,0x82,0x98,0xae,0xb6,
0xae,0x98,0x81,0x77,0x80,0x94,0xab,0xb4,0xab,0x97,0x83,0x7b,0x83,0x97,0xaf,0xb8,
0xaf,0x9b,0x84,0x79,0x80,0x94,0xa6,0xaf,0xa7,0x93,0x7f,0x76,0x7e,0x93,0xa9,0xb3,
0xab,0x98,0x83,0x78,0x81,0x94,0xa9,0xb3,0xab,0x97,0x81,0x77,0x80,0x96,0xab,0xb3,
0xad,0x9b,0x86,0x7a,0x81,0x96,0xaa,0xb4,0xad,0x98,0x82,0x76,0x7c,0x91,0xa5,0xae,
0xa8,0x96,0x83,0x7b,0x84,0x97,0xa9,0xb1,0xa9,0x98,0x87,0x81,0x88,0x98,0xa4,0xa3,
0x99,0x8e,0x8a,0x8d,0x94,0x9b,0x99,0x8f,0x7e,0x72,0x7b,0x8a,0x9b,0xa2,0x97,0x80,
0x6b,0x64,0x71,0x8b,0xa1,0xa6,0x94,0x76,0x5b,0x58,0x70,0x92,0xa9,0xae,0x99,0x75,
0x58,0x52,0x68,0x8d,0xa8,0xac,0x98,0x75,0x5b,0x57,0x6d,0x8f,0xab,0xb3,0xa0,0x7e,
0x61,0x5b,0x71,0x92,0xaa,0xae,0x9a,0x79,0x5b,0x54,0x67,0x88,0xa4,0xa9,0x95,0x75,
0x5b,0x58,0x69,0x8f,0xaa,0xaf,0x9d,0x7c,0x60,0x5c,0x70,0x8f,0xa9,0xae,0x9a,0x78,
0x5a,0x54,0x6b,0x8f,0xa9,0xad,0x99,0x77,0x5c,0x59,0x6d,0x8e,0xa8,0xab,0x96,0x73,
0x58,0x56,0x6d,0x90,0xa9,0xae,0x9b,0x7a,0x5f,0x5b,0x71,0x92,0xae,0xb2,0x9e,0x7b,
0x5e,0x58,0x6d,0x8d,0xa7,0xac,0x98,0x76,0x59,0x56,0x6d,0x8e,0xa9,0xaf,0x9d,0x7d,
0x5f,0x58,0x6c,0x8d,0xa6,0xab,0x99,0x79,0x5b,0x56,0x6b,0x8b,0xa7,0xac,0x97,0x78,
0x5a,0x54,0x6b,0x8d,0xa7,0xae,0x9a,0x77,0x5b,0x56,0x6d,0x8c,0xa8,0xad,0x98,0x79,
0x60,0x59,0x71,0x90,0xa8,0xaf,0x9c,0x79,0x5e,0x5a,0x6d,0x8d,0xa5,0xaa,0x99,0x79,
0x5c,0x54,0x67,0x89,0xa6,0xaf,0xa0,0x81,0x66,0x5d,0x6b,0x88,0xa3,0xae,0xa1,0x82,
0x61,0x50,0x56,0x6e,0x8a,0x9d,0x99,0x7f,0x63,0x51,0x54,0x70,0x8e,0xa1,0xa1,0x8b,
0x6b,0x54,0x52,0x66,0x82,0x9d,0x9f,0x8b,0x6b,0x53,0x53,0x69,0x89,0xa0,0xa4,0x91,
0x72,0x59,0x54,0x67,0x85,0x9d,0xa0,0x8b,0x6b,0x52,0x51,0x69,0x89,0x9f,0xa0,0x8a,
0x6b,0x54,0x51,0x63,0x83,0x9b,0x9e,0x8b,0x6b,0x54,0x50,0x68,0x84,0x9a,0x9d,0x8b,
0x6d,0x56,0x51,0x64,0x84,0x9d,0xa0,0x8f,0x6e,0x56,0x53,0x69,0x89,0xa0,0xa0,0x88,
0x69,0x51,0x50,0x65,0x83,0x9b,0x9d,0x8a,0x6b,0x52,0x53,0x6b,0x8c,0xa2,0xa0,0x8b,
0x6d,0x57,0x55,0x6b,0x8a,0xa1,0xa0,0x8c,0x6a,0x51,0x51,0x67,0x85,0x9e,0x9f,0x8d,
0x6f,0x56,0x53,0x66,0x86,0x9c,0x9f,0x8c,0x6e,0x54,0x51,0x63,0x83,0x9c,0xa0,0x8d,
0x6d,0x56,0x53,0x69,0x86,0x9b,0xa0,0x8d,0x6d,0x54,0x53,0x6b,0x89,0x9d,0x9d,0x88,
0x6b,0x55,0x53,0x68,0x86,0x9d,0x9f,0x8a,0x6b,0x54,0x56,0x69,0x86,0x9a,0x9c,0x85,
0x6b,0x53,0x53,0x6a,0x87,0x9b,0x9d,0x8b,0x71,0x5f,0x5e,0x6d,0x86,0x96,0x96,0x86,
0x73,0x66,0x63,0x6b,0x76,0x80,0x85,0x82,0x7b,0x75,0x70,0x6b,0x65,0x5f,0x5e,0x65,
0x72,0x7c,0x7c,0x71,0x5e,0x4e,0x4c,0x59,0x72,0x89,0x8c,0x76,0x59,0x40,0x3d,0x56,
0x77,0x91,0x95,0x80,0x5a,0x3b,0x36,0x50,0x76,0x91,0x92,0x79,0x58,0x40,0x3e,0x56,
0x76,0x8e,0x92,0x7e,0x5f,0x47,0x44,0x5b,0x79,0x8e,0x8f,0x79,0x59,0x40,0x3e,0x53,
0x71,0x88,0x8b,0x79,0x5b,0x45,0x40,0x53,0x72,0x8b,0x8f,0x7c,0x5c,0x44,0x41,0x53,
0x70,0x8a,0x90,0x7e,0x5d,0x43,0x3e,0x51,0x72,0x8c,0x90,0x7d,0x5d,0x43,0x40,0x56,
0x75,0x8e,0x92,0x7e,0x5d,0x44,0x41,0x56,0x74,0x8c,0x90,0x7c,0x5c,0x43,0x42,0x56,
0x75,0x8f,0x92,0x7e,0x5e,0x45,0x40,0x55,0x77,0x8f,0x90,0x7a,0x5a,0x40,0x3e,0x52,
0x71,0x8d,0x93,0x7e,0x5d,0x44,0x43,0x57,0x79,0x90,0x92,0x7e,0x5c,0x40,0x40,0x52,
0x71,0x8b,0x8f,0x7b,0x5c,0x44,0x42,0x57,0x76,0x8f,0x93,0x80,0x5f,0x45,0x42,0x56,
0x74,0x8c,0x8e,0x7a,0x5c,0x43,0x3f,0x53,0x73,0x8d,0x8f,0x7a,0x5b,0x44,0x46,0x59,
0x76,0x8e,0x90,0x7b,0x5f,0x48,0x47,0x5f,0x7c,0x8f,0x8a,0x73,0x56,0x46,0x4b,0x63,
0x80,0x8e,0x83,0x66,0x49,0x3e,0x49,0x65,0x7d,0x85,0x78,0x58,0x3b,0x32,0x44,0x65,
0x7f,0x85,0x73,0x53,0x39,0x34,0x48,0x6b,0x85,0x88,0x72,0x4f,0x33,0x31,0x47,0x68,
0x81,0x84,0x6f,0x4d,0x32,0x32,0x4a,0x6e,0x88,0x8d,0x78,0x56,0x39,0x34,0x48,0x69,
0x84,0x89,0x75,0x53,0x36,0x31,0x47,0x6a,0x85,0x8a,0x79,0x55,0x36,0x31,0x47,0x68,
0x85,0x89,0x73,0x52,0x35,0x30,0x44,0x6a,0x85,0x8b,0x77,0x56,0x38,0x38,0x4b,0x6b,
0x83,0x86,0x70,0x4e,0x30,0x2d,0x46,0x68,0x83,0x86,0x71,0x51,0x38,0x33,0x48,0x6a,
0x85,0x8a,0x76,0x55,0x3b,0x35,0x49,0x69,0x83,0x8b,0x77,0x55,0x38,0x32,0x46,0x6a,
0x86,0x8c,0x78,0x57,0x39,0x31,0x46,0x69,0x86,0x8f,0x77,0x51,0x35,0x30,0x46,0x69,
0x84,0x8b,0x77,0x53,0x36,0x32,0x4a,0x6d,0x86,0x8b,0x77,0x54,0x36,0x30,0x45,0x68,
0x83,0x8a,0x75,0x53,0x38,0x34,0x49,0x6a,0x83,0x88,0x73,0x50,0x34,0x30,0x47,0x6b,
0x83,0x88,0x76,0x56,0x3b,0x35,0x49,0x69,0x83,0x88,0x74,0x53,0x3a,0x34,0x46,0x66,
0x81,0x8a,0x7b,0x5d,0x41,0x38,0x44,0x5b,0x71,0x7c,0x76,0x63,0x4d,0x3d,0x3b,0x45,
0x54,0x60,0x65,0x5f,0x52,0x44,0x38,0x36,0x42,0x55,0x64,0x66,0x5e,0x4c,0x38,0x2c,
0x30,0x40,0x5b,0x6a,0x66,0x54,0x3e,0x30,0x37,0x47,0x5c,0x6b,0x68,0x53,0x3a,0x2a,
0x2f,0x45,0x5e,0x6b,0x67,0x54,0x3e,0x30,0x36,0x4a,0x61,0x6d,0x65,0x4f,0x39,0x2d,
0x34,0x48,0x5e,0x69,0x64,0x50,0x39,0x2c,0x34,0x47,0x5c,0x69,0x66,0x54,0x3e,0x2f,
0x32,0x49,0x61,0x6d,0x67,0x53,0x3b,0x2f,0x33,0x48,0x5d,0x6d,0x68,0x51,0x38,0x2a,
0x30,0x49,0x5f,0x6a,0x66,0x53,0x3b,0x2b,0x30,0x46,0x5f,0x6d,0x66,0x51,0x38,0x2b,
0x31,0x47,0x5e,0x6b,0x67,0x52,0x39,0x2d,0x33,0x49,0x60,0x6d,0x65,0x51,0x38,0x2a,
0x2f,0x45,0x5d,0x69,0x63,0x4e,0x35,0x2b,0x2f,0x43,0x5e,0x6b,0x66,0x51,0x38,0x2a,
0x2f,0x44,0x5d,0x68,0x64,0x4f,0x36,0x2b,0x32,0x48,0x62,0x6f,0x6b,0x58,0x41,0x32,
0x37,0x4a,0x61,0x6d,0x65,0x4f,0x36,0x2c,0x31,0x47,0x5e,0x69,0x64,0x52,0x3a,0x2d,
0x32,0x48,0x5f,0x6a,0x61,0x4c,0x38,0x2f,0x35,0x49,0x5e,0x69,0x64,0x54,0x42,0x36,
0x3d,0x4d,0x5b,0x64,0x61,0x55,0x46,0x3b,0x3b,0x45,0x4d,0x4e,0x4a,0x42,0x3b,0x38,
0x3a,0x40,0x47,0x4a,0x47,0x42,0x3f,0x3e,0x40,0x43,0x42,0x3f,0x3e,0x3e,0x40,0x42,
0x43,0x44,0x44,0x42,0x3f,0x3f,0x41,0x43,0x43,0x44,0x43,0x41,0x41,0x41,0x41,0x43,
0x44,0x44,0x42,0x41,0x40,0x3f,0x3f,0x3f,0x3e,0x42,0x40,0x3f,0x41,0x43,0x43,0x44,
0x43,0x43,0x43,0x44,0x44,0x43,0x42,0x41,0x41,0x42,0x41,0x40,0x42,0x42,0x42,0x43,
0x43,0x43,0x43,0x43,0x42,0x42,0x43,0x44,0x43,0x42,0x41,0x42,0x41,0x40,0x40,0x45,
0x44,0x43,0x42,0x40,0x40,0x40,0x41,0x40,0x41,0x42,0x41,0x3b,0x3b,0x3b,0x3e,0x40,
0x43,0x46,0x48,0x47,0x45,0x44,0x44,0x44,0x45,0x44,0x42,0x42,0x43,0x42,0x41,0x41,
0x42,0x43,0x44,0x43,0x43,0x42,0x40,0x3e,0x3b,0x3b,0x3e,0x42,0x43,0x42,0x42,0x40,
0x40,0x3f,0x40,0x41,0x44,0x45,0x44,0x41,0x42,0x43,0x42,0x44,0x42,0x44,0x46,0x44,
0x41,0x41,0x42,0x44,0x41,0x40,0x3f,0x40,0x40,0x40,0x3f,0x40,0x43,0x46,0x46,0x45,
0x45,0x46,0x44,0x41,0x40,0x42,0x43,0x41,0x3f,0x3c,0x3b,0x3e,0x40,0x42,0x45,0x43,
0x42,0x43,0x43,0x42,0x42,0x41,0x3e,0x3b,0x38,0x37,0x36,0x37,0x38,0x39,0x3a,0x39,
// Line 21
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
unsigned int VBIfieldSize = sizeof (VBIsamples[0]);
unsigned int VBIfieldCount = sizeof (VBIsamples) / sizeof (VBIsamples[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mcamdrv.c ===
/*++

Copyright (c) 1997 1998 PHILIPS  I&C

Module Name:  mcamdrv.c.c

Abstract:     driver for the philips camera.

Author:       Paul Oosterhof

Environment:  Kernel mode only

Revision History:

Date        Reason

Sept.22, 98 Optimized for NT5
Nov.30 , Frozen video frame for corrupted usb frames
Nov.30 , properties added to deliver VID/PID actual used camera to app
--*/	   

#include "mwarn.h"
#include "wdm.h"
#include "mcamdrv.h"
#include "strmini.h"
#include "mprpobj.h"
#include "mprpobjx.h"
#include "mprpftn.h"
#include "mcodec.h"
#include "mstreams.h"
#include "mssidef.h"


/*
 * Local function definitions
 */
static USHORT 
MapFrPeriodFrRate(LONGLONG llFramePeriod);

static NTSTATUS
PHILIPSCAM_SetFrRate_AltInterface(IN PVOID DeviceContext);
/*
   Here the mapping is defined to alternate interfaces dependent from
   picture format and framerate
*/
UCHAR InterfaceMap[9][10] = {
                // Size
//Framerate	// CIF, QCIF, SQCIF, QQCIF, VGA, SIF, SSIF, QSIF, SQSIF, SCIF  
/*  VGA  */	{   0 ,   0 ,    0 ,   0,    1,   0 ,   0 ,   0 ,   0  ,   0 },
/*  3.75 */	{   4 ,   0 ,    0 ,   0,    0,   4 ,   4 ,   0 ,   0  ,   4 },
/* 	5 */ 	{   7 ,   8 ,    8 ,   8,    0,   7 ,   7 ,   8 ,   8  ,   7 },
/*  7.5 */  {   6 ,   7 ,    7 ,   7,    0,   6 ,   6 ,   7 ,   7  ,   6 },
/* 10 */    {   4 ,   6 ,    7 ,   7,    0,   4 ,   4 ,   6 ,   7  ,   4 },
/* 12 */    {   3 ,   5 ,    6 ,   6,    0,   3 ,   3 ,   5 ,   6  ,   3 },
/* 15 */    {   2 ,   4 ,    5 ,   5,    0,   2 ,   2 ,   4 ,   5  ,   2 },
/* 20 */    {   0 ,   1 ,    3 ,   3,    0,   0 ,   0 ,   1 ,   3  ,   0 },
/* 24 */    {   0 ,   1 ,    3 ,   3,    0,   0 ,   0 ,   1 ,   3  ,   0 },
};

//QCIF20 alt.intfc. 2 is sufficient, however 20Fr/sec is asked as default by PM;
//to enable the user to select as well 24Fr/sec, also alt.intfc. 1 is selected
//SQCIF20 alt.intfc. 4 is sufficient, however 20Fr/sec is asked as default by PM;
//to enable the user to select as well 24Fr/sec, also alt.intfc. 3 is selected

ULONG PHILIPSCAM_DebugTraceLevel
#ifdef MAX_DEBUG
    = MAX_TRACE;
#else
    = MIN_TRACE;
#endif

#ifndef mmioFOURCC   
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

KSPIN_MEDIUM StandardMedium =
{
	STATIC_KSMEDIUMSETID_Standard,
	0, 0
};


// ------------------------------------------------------------------------
// Property sets for all video capture streams 
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(VideoStreamDroppedFramesProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DROPPEDFRAMES_CURRENT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinProperty
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};


// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(VideoStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_DROPPEDFRAMES,                // Set
        SIZEOF_ARRAY(VideoStreamDroppedFramesProperties),  // PropertiesCount
        VideoStreamDroppedFramesProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};
#define NUMBER_VIDEO_STREAM_PROPERTIES (SIZEOF_ARRAY(VideoStreamProperties))

KS_DATARANGE_VIDEO PHILIPSCAM_StreamFormat_QCIF_I420   = STREAMFORMAT_QCIF_I420 ;
KS_DATARANGE_VIDEO PHILIPSCAM_StreamFormat_CIF_I420  = STREAMFORMAT_CIF_I420;
KS_DATARANGE_VIDEO PHILIPSCAM_StreamFormat_SQCIF_I420 = STREAMFORMAT_SQCIF_I420;
KS_DATARANGE_VIDEO PHILIPSCAM_StreamFormat_QQCIF_I420 = STREAMFORMAT_QQCIF_I420;
KS_DATARANGE_VIDEO PHILIPSCAM_StreamFormat_SIF_I420   = STREAMFORMAT_SIF_I420 ;
KS_DATARANGE_VIDEO PHILIPSCAM_StreamFormat_SSIF_I420  = STREAMFORMAT_SSIF_I420 ;
KS_DATARANGE_VIDEO PHILIPSCAM_StreamFormat_QSIF_I420  = STREAMFORMAT_QSIF_I420 ;
KS_DATARANGE_VIDEO PHILIPSCAM_StreamFormat_SQSIF_I420 = STREAMFORMAT_SQSIF_I420 ;
KS_DATARANGE_VIDEO PHILIPSCAM_StreamFormat_SCIF_I420  = STREAMFORMAT_SCIF_I420 ;

static PKSDATAFORMAT PHILIPSCAM_MovingStreamFormats[]={
					 (PKSDATAFORMAT) &PHILIPSCAM_StreamFormat_QCIF_I420,
					 (PKSDATAFORMAT) &PHILIPSCAM_StreamFormat_CIF_I420,
					 (PKSDATAFORMAT) &PHILIPSCAM_StreamFormat_SQCIF_I420,
					 (PKSDATAFORMAT) &PHILIPSCAM_StreamFormat_QQCIF_I420,
					 (PKSDATAFORMAT) &PHILIPSCAM_StreamFormat_SIF_I420,
					 (PKSDATAFORMAT) &PHILIPSCAM_StreamFormat_SSIF_I420,
					 (PKSDATAFORMAT) &PHILIPSCAM_StreamFormat_QSIF_I420,
					 (PKSDATAFORMAT) &PHILIPSCAM_StreamFormat_SQSIF_I420,
                     (PKSDATAFORMAT) &PHILIPSCAM_StreamFormat_SCIF_I420
  };

#define NUM_PHILIPSCAM_STREAM_FORMATS (SIZEOF_ARRAY(PHILIPSCAM_MovingStreamFormats))

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

HW_STREAM_INFORMATION Streams [] = {
    // -----------------------------------------------------------------
    // PHILIPSCAM_Moving_Stream
    // -----------------------------------------------------------------

    // HW_STREAM_INFORMATION -------------------------------------------
    1,                                      // NumberOfPossibleInstances
    KSPIN_DATAFLOW_OUT,                     // DataFlow
    TRUE,                                   // DataAccessible
    NUM_PHILIPSCAM_STREAM_FORMATS,          // NumberOfFormatArrayEntries
    PHILIPSCAM_MovingStreamFormats,         // StreamFormatsArray
    NULL,                                   // ClassReserved[0]
    NULL,                                   // ClassReserved[1]
    NULL,                                   // ClassReserved[2]
    NULL,                                   // ClassReserved[3]
    NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
    (PKSPROPERTY_SET) VideoStreamProperties,// StreamPropertiesArray
    0,                                      // NumStreamEventArrayEntries;
    0,                                      // StreamEventsArray;
    (GUID *)&PINNAME_VIDEO_CAPTURE,         // Category;
    (GUID *)&PINNAME_VIDEO_CAPTURE,         // Name;
	0,										// MediumsCount
	&StandardMedium,						// Mediums
    FALSE,									// BridgeStream 
    0,                                      // Reserved[0]
    0                                       // Reserved[1]
};


/*****************************************************************************/
/*****************************************************************************/
/************       Start  of   Function  Blocks        **********************/
/*****************************************************************************/
/*****************************************************************************/

/*
// This function searches the maximal framerate for a given picture format
// dependent from the USB bus load and selects the belonging alternate interface.
//
*/
NTSTATUS
PHILIPSCAM_SetFrRate_AltInterface(IN PVOID DeviceContext){

  PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
  NTSTATUS ntStatus  = STATUS_SUCCESS;
  USHORT PhFormat    = deviceContext->CamStatus.PictureFormat;
  USHORT PhFrameRate = deviceContext->CamStatus.PictureFrameRate;
  USHORT j; 

  // reset permitted framerates
  for (j = FRRATEVGA; j <= FRRATE24; j++){
    deviceContext->FrrSupported[j] = FALSE;
  }
  // set permitted framerates dependent on selected format and sensortype
  switch (PhFormat) {
    case FORMATCIF:
	  for ( j = FRRATE375 ; j <= PhFrameRate; j++){
	    deviceContext->FrrSupported[j] = TRUE;
	  }
    break;
    case FORMATQCIF:
	  for ( j = FRRATE5 ; j <= PhFrameRate; j++){
	    deviceContext->FrrSupported[j] = TRUE;
	  }
    break;
    case FORMATSQCIF:
	  for ( j = FRRATE5 ; j <= PhFrameRate; j++){
	    deviceContext->FrrSupported[j] = TRUE;
	  }
    break;
    case FORMATQQCIF:
	  for ( j = FRRATE5 ; j <= PhFrameRate; j++){
	    deviceContext->FrrSupported[j] = TRUE;
	  }
    break;
    case FORMATSIF:
	  for ( j = FRRATE375 ; j <= PhFrameRate; j++){
	    deviceContext->FrrSupported[j] = TRUE;
	  }
    break;
    case FORMATSSIF:
	  for ( j = FRRATE375 ; j <= PhFrameRate; j++){
	    deviceContext->FrrSupported[j] = TRUE;
	  }
    break;
    case FORMATQSIF:
	  for ( j = FRRATE5 ; j <= PhFrameRate; j++){
	    deviceContext->FrrSupported[j] = TRUE;
	  }
    break;
    case FORMATSQSIF:
	  for ( j = FRRATE5 ; j <= PhFrameRate; j++){
	    deviceContext->FrrSupported[j] = TRUE;
	  }
    break;
    case FORMATSCIF:
	  for ( j = FRRATE375 ; j <= PhFrameRate; j++){
	    deviceContext->FrrSupported[j] = TRUE;
	  }
 
    default:
	  ; // no permitted framerates;
  }
  // select framerate dependent on available USB bandwidth
  ntStatus = STATUS_NOT_FOUND;
  for ( PhFrameRate ;
	    (!NT_SUCCESS(ntStatus) && (PhFrameRate != FRRATEVGA));
		 PhFrameRate --) {
	if (deviceContext->FrrSupported[PhFrameRate]){
	  if ( InterfaceMap[PhFrameRate][PhFormat] != 0 ){
        deviceContext->Interface->AlternateSetting =
				InterfaceMap[PhFrameRate][PhFormat];
        ntStatus = USBCAMD_SelectAlternateInterface(
    		               deviceContext,
			               deviceContext->Interface);
	  }
	  if (!NT_SUCCESS(ntStatus)){
	    deviceContext->FrrSupported[PhFrameRate]= FALSE;
	  }else{
	     PHILIPSCAM_KdPrint (MIN_TRACE, ("Alt Setting # %d, Max.allowed FPS %s\n", 
  						InterfaceMap[PhFrameRate][PhFormat] , FRString(PhFrameRate)));
 		 deviceContext->CamStatus.PictureFrameRate = PhFrameRate ;
	  }
	}
  }
  return ntStatus;
}


   
/*
** AdapterCompareGUIDsAndFormatSize()
**
**   Checks for a match on the three GUIDs and FormatSize
**
** Arguments:
**
**         IN DataRange1
**         IN DataRange2
**
** Returns:
**
**   TRUE if all elements match
**   FALSE if any are different
**
** Side Effects:  none
*/

BOOLEAN
AdapterCompareGUIDsAndFormatSize(
    IN PKSDATARANGE DataRange1,
    IN PKSDATARANGE DataRange2)
{
  return (
    IsEqualGUID (
	    &DataRange1->MajorFormat,
	    &DataRange2->MajorFormat) &&
	IsEqualGUID (
	    &DataRange1->SubFormat,
	    &DataRange2->SubFormat) &&
	IsEqualGUID (
	    &DataRange1->Specifier,
	    &DataRange2->Specifier) &&
	(DataRange1->FormatSize == DataRange2->FormatSize));
}

/*
** AdapterFormatFromRange()
**
**   Returns a DATAFORMAT from a DATARANGE
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb
**
** Returns:
**
**  STATUS_SUCCESS if format is supported
**
** Side Effects:  none
*/

NTSTATUS
AdapterFormatFromRange(
	IN PHW_STREAM_REQUEST_BLOCK Srb)
{
  PSTREAM_DATA_INTERSECT_INFO intersectInfo;
  PKSDATARANGE  dataRange;
  BOOL onlyWantsSize;
  ULONG formatSize = 0;
  ULONG streamNumber;
  ULONG j;
  ULONG numberOfFormatArrayEntries;
  PKSDATAFORMAT *availableFormats;
  NTSTATUS ntStatus = STATUS_NOT_FOUND;
   
  intersectInfo = Srb->CommandData.IntersectInfo;
  streamNumber = intersectInfo->StreamNumber;
  dataRange = intersectInfo->DataRange;

    //
    // Check that the stream number is valid
    //

//  ASSERT(streamNumber == 0);
   
  numberOfFormatArrayEntries = Streams[0].NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //

  availableFormats = Streams[0].StreamFormatsArray;

    //
    // Is the caller trying to get the format, or the size of the format?
    //

  onlyWantsSize =
	    (intersectInfo->SizeOfDataFormatBuffer == sizeof(ULONG));

    //
    // Walk the formats supported by the stream searching for a match
    // of the three GUIDs which together define a DATARANGE
    //

  for (j = 0; j < numberOfFormatArrayEntries; j++, availableFormats++) {

	if (!AdapterCompareGUIDsAndFormatSize(dataRange,
						      *availableFormats)) {
	    // not the format we want                                           
     
	    continue;
	}

	//
	// Now that the three GUIDs match, switch on the Specifier
	// to do a further type specific check
	//

	// -------------------------------------------------------------------
	// Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
	// -------------------------------------------------------------------

	if (IsEqualGUID (&dataRange->Specifier, 
                     &KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {

	  PKS_DATARANGE_VIDEO dataRangeVideoToVerify =
		    (PKS_DATARANGE_VIDEO) dataRange;
	  PKS_DATARANGE_VIDEO dataRangeVideo =
		    (PKS_DATARANGE_VIDEO) *availableFormats;
      PKS_DATAFORMAT_VIDEOINFOHEADER DataFormatVideoInfoHeaderOut;
      ULONG videoHeaderSize;
      ULONG rangeSize;

	    //
	    // Check that the other fields match
	    //
	  if ((dataRangeVideoToVerify->bFixedSizeSamples !=
					 dataRangeVideo->bFixedSizeSamples) ||
	      (dataRangeVideoToVerify->bTemporalCompression !=
					     dataRangeVideo->bTemporalCompression) ||
		  (dataRangeVideoToVerify->StreamDescriptionFlags !=
					     dataRangeVideo->StreamDescriptionFlags) ||
		  (dataRangeVideoToVerify->MemoryAllocationFlags !=
					     dataRangeVideo->MemoryAllocationFlags) ||
		  (RtlCompareMemory (&dataRangeVideoToVerify->ConfigCaps,
			&dataRangeVideo->ConfigCaps,
			sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) !=
			sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))) {
		// not the format want                       
		continue;
	  }

      if ((dataRangeVideoToVerify->VideoInfoHeader.bmiHeader.biWidth != 
           dataRangeVideo->VideoInfoHeader.bmiHeader.biWidth ) ||
          (dataRangeVideoToVerify->VideoInfoHeader.bmiHeader.biHeight != 
           dataRangeVideo->VideoInfoHeader.bmiHeader.biHeight )) {
         continue;
      }

      // Validate each step of the size calculations for arithmetic overflow,
      // and verify that the specified sizes correlate
      // (with unsigned math, a+b < b iff an arithmetic overflow occured)
      videoHeaderSize = dataRangeVideoToVerify->VideoInfoHeader.bmiHeader.biSize +
          FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader);
      rangeSize = videoHeaderSize +
          FIELD_OFFSET(KS_DATARANGE_VIDEO,VideoInfoHeader);

      if (videoHeaderSize < FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader) ||
          rangeSize < FIELD_OFFSET(KS_DATARANGE_VIDEO,VideoInfoHeader) ||
          rangeSize > dataRangeVideoToVerify->DataRange.FormatSize) {

          Srb->Status = ntStatus = STATUS_INVALID_PARAMETER;
          break;
      }

	  formatSize = sizeof(KSDATAFORMAT) + videoHeaderSize;

	  if (onlyWantsSize) {
		break;
	  }

      // Is the return buffer size = 0 ?
      if(intersectInfo->SizeOfDataFormatBuffer == 0) {

          ntStatus = Srb->Status = STATUS_BUFFER_OVERFLOW;
          // the proxy wants to know the actual buffer size to allocate.
          Srb->ActualBytesTransferred = formatSize;
          break;
      }
	   
	    // Caller wants the full data format, make sure we have room
	  if (intersectInfo->SizeOfDataFormatBuffer < formatSize) {
		Srb->Status = ntStatus = STATUS_BUFFER_TOO_SMALL;
		break;
	  }

      DataFormatVideoInfoHeaderOut = 
          (PKS_DATAFORMAT_VIDEOINFOHEADER) intersectInfo->DataFormatBuffer;

	    // Copy over the KSDATAFORMAT, followed by the
	    // actual VideoInfoHeader
	
	  RtlCopyMemory(
		&DataFormatVideoInfoHeaderOut->DataFormat,
		&dataRangeVideoToVerify->DataRange,
		sizeof (KSDATARANGE));

	  DataFormatVideoInfoHeaderOut->DataFormat.FormatSize = formatSize;

	  RtlCopyMemory(
		&DataFormatVideoInfoHeaderOut->VideoInfoHeader,
		&dataRangeVideoToVerify->VideoInfoHeader,
		videoHeaderSize);

      // Calculate biSizeImage for this request, and put the result in both
      // the biSizeImage field of the bmiHeader AND in the SampleSize field
      // of the DataFormat.
      //
      // Note that for compressed sizes, this calculation will probably not
      // be just width * height * bitdepth

      DataFormatVideoInfoHeaderOut->VideoInfoHeader.bmiHeader.biSizeImage =
        DataFormatVideoInfoHeaderOut->DataFormat.SampleSize = 
        KS_DIBSIZE(DataFormatVideoInfoHeaderOut->VideoInfoHeader.bmiHeader);

      //
      // Perform other validation such as cropping and scaling checks
      // 

      // we will not allow setting FPS below our minimum FPS.
	  if ((DataFormatVideoInfoHeaderOut->VideoInfoHeader.AvgTimePerFrame >
			 dataRangeVideo->ConfigCaps.MaxFrameInterval) ) {
            DataFormatVideoInfoHeaderOut->VideoInfoHeader.AvgTimePerFrame =
            	dataRangeVideo->ConfigCaps.MaxFrameInterval;
            DataFormatVideoInfoHeaderOut->VideoInfoHeader.dwBitRate = 
                dataRangeVideo->ConfigCaps.MinBitsPerSecond;
	  }

      // we will not allow setting FPS above our maximum FPS.
	  if ((DataFormatVideoInfoHeaderOut->VideoInfoHeader.AvgTimePerFrame <
			 dataRangeVideo->ConfigCaps.MinFrameInterval) ) {
            DataFormatVideoInfoHeaderOut->VideoInfoHeader.AvgTimePerFrame =
            	dataRangeVideo->ConfigCaps.MinFrameInterval;
            DataFormatVideoInfoHeaderOut->VideoInfoHeader.dwBitRate = 
                dataRangeVideo->ConfigCaps.MaxBitsPerSecond;
	  }

	  Srb->Status = ntStatus = STATUS_SUCCESS;
	  break;
	}

  } // End of loop on all formats for this stream

  if (NT_SUCCESS(ntStatus)) {
	if (onlyWantsSize) {
	  *(PULONG) intersectInfo->DataFormatBuffer = formatSize;
	  Srb->ActualBytesTransferred = sizeof(ULONG);
	}else {      
	  Srb->ActualBytesTransferred = formatSize;
	}
  }   
   
  return ntStatus;
}

/*
** AdapterVerifyFormat()
**
**   Checks the validity of a format request by walking through the
**       array of supported KSDATA_RANGEs for a given stream.
**
** Arguments:
**
**   pKSDataFormat - pointer of a KS_DATAFORMAT_VIDEOINFOHEADER structure.
**   StreamNumber - index of the stream being queried / opened.
**
** Returns:
**
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL
AdapterVerifyFormat(
    PKS_DATAFORMAT_VIDEOINFOHEADER pKSDataFormatToVerify,
    int StreamNumber
    )
{
  PKSDATAFORMAT               *pAvailableFormats;
  int                         NumberOfFormatArrayEntries;
  int                         j;
    
    // Make sure a format has been specified
  if (!pKSDataFormatToVerify)
  {
    return FALSE;
  }

    //
    // Make sure the stream index is valid
    //
  if (StreamNumber >= 2 || StreamNumber < 0) {
	return FALSE;
  }

    //
    // How many formats does this stream support?
    //
  NumberOfFormatArrayEntries =
		Streams[StreamNumber].NumberOfFormatArrayEntries;

  PHILIPSCAM_KdPrint (MAX_TRACE, ("AdapterVerifyFormat: Stream=%d\n",
	    StreamNumber));

  PHILIPSCAM_KdPrint (MAX_TRACE, ("AdapterVerifyFormat: FormatSize=%d\n",
	    pKSDataFormatToVerify->DataFormat.FormatSize));

  PHILIPSCAM_KdPrint (MAX_TRACE, ("AdapterVerifyFormat: MajorFormat=%x\n",
	    pKSDataFormatToVerify->DataFormat.MajorFormat));

    //
    // Get the pointer to the array of available formats
    //
  pAvailableFormats  = Streams[StreamNumber].StreamFormatsArray;

    //
    // Walk the array, searching for a match
    //
  for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++)	{

    PKS_DATARANGE_VIDEO         pKSDataRange = (PKS_DATARANGE_VIDEO) *pAvailableFormats;
    PKS_VIDEOINFOHEADER         pVideoInfoHdr = &pKSDataRange->VideoInfoHeader;
    KS_VIDEO_STREAM_CONFIG_CAPS *pConfigCaps = &pKSDataRange->ConfigCaps;
	//
	// Check for matching size, Major Type, Sub Type, and Specifier
	//

	if (!IsEqualGUID (&pKSDataRange->DataRange.MajorFormat,
	          &pKSDataFormatToVerify->DataFormat.MajorFormat)) {
	  continue;
	}
	if (!IsEqualGUID (&pKSDataRange->DataRange.SubFormat,
	        &pKSDataFormatToVerify->DataFormat.SubFormat)) {
	  continue;
	}

	if (!IsEqualGUID (&pKSDataRange->DataRange.Specifier,
	          &pKSDataFormatToVerify->DataFormat.Specifier)) {
	  continue;
	}

    // -------------------------------------------------------------------
    // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
    // -------------------------------------------------------------------

    if (IsEqualGUID(&pKSDataRange->DataRange.Specifier, &KSDATAFORMAT_SPECIFIER_VIDEOINFO))
    {
      PKS_VIDEOINFOHEADER pVideoInfoHdrToVerify;

      if (pKSDataFormatToVerify->DataFormat.FormatSize < sizeof(KS_DATAFORMAT_VIDEOINFOHEADER))
      {
        break; // considered a fatal error for this format
      }

	  pVideoInfoHdrToVerify = &pKSDataFormatToVerify->VideoInfoHeader;

      PHILIPSCAM_KdPrint (MAX_TRACE, ("AdapterVerifyFormat: pVideoInfoHdrToVerify=%x\n",
		    pVideoInfoHdrToVerify));

      PHILIPSCAM_KdPrint (MAX_TRACE, ("AdapterVerifyFormat: Width=%d Height=%d  biBitCount=%d\n",
		    pVideoInfoHdrToVerify->bmiHeader.biWidth,
		    pVideoInfoHdrToVerify->bmiHeader.biHeight,
		    pVideoInfoHdrToVerify->bmiHeader.biBitCount));

      PHILIPSCAM_KdPrint (MAX_TRACE, ("AdapterVerifyFormat: biSizeImage =%d\n",
		    pVideoInfoHdrToVerify->bmiHeader.biSizeImage));

      // Calculate the actual format buffer size (includes bmiHeader.biSize).
      // Validate each step of the size calculations for arithmetic overflow,
      // and verify that the specified sizes correlate
      // (with unsigned math, a+b < b iff an arithmetic overflow occured).
      {
        ULONG VideoHeaderSize = pVideoInfoHdrToVerify->bmiHeader.biSize +
          FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader);
        ULONG FormatSize = VideoHeaderSize +
          FIELD_OFFSET(KS_DATAFORMAT_VIDEOINFOHEADER,VideoInfoHeader);

        if (VideoHeaderSize < FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader) ||
          FormatSize < FIELD_OFFSET(KS_DATAFORMAT_VIDEOINFOHEADER,VideoInfoHeader) ||
          FormatSize > pKSDataFormatToVerify->DataFormat.FormatSize) {

          break; // considered a fatal error for this format
        }
      }

      if ((pVideoInfoHdrToVerify->bmiHeader.biWidth != 
                        pVideoInfoHdr->bmiHeader.biWidth ) ||
          (pVideoInfoHdrToVerify->bmiHeader.biHeight != 
                        pVideoInfoHdr->bmiHeader.biHeight )) {
        continue;
      }

      if ( pVideoInfoHdrToVerify->bmiHeader.biSizeImage != 
                        pVideoInfoHdr->bmiHeader.biSizeImage ||
          pVideoInfoHdrToVerify->bmiHeader.biSizeImage >
                        pKSDataFormatToVerify->DataFormat.SampleSize) {

        PHILIPSCAM_KdPrint (MIN_TRACE, ("***Error**:Format mismatch Width=%d Height=%d  image size=%d\n", 
          pVideoInfoHdrToVerify->bmiHeader.biWidth, 
          pVideoInfoHdrToVerify->bmiHeader.biHeight,
          pVideoInfoHdrToVerify->bmiHeader.biSizeImage));
        continue;
      }  

	  //
	  // HOORAY, the format passed all of the tests, so we support it
	  //
	  return TRUE;
    }
  }
    //
    // The format requested didn't match any of our listed ranges,
    // so refuse the connection.
    //
  return FALSE;

}

//
// hooks for stream SRBs
//

VOID STREAMAPI
PHILIPSCAM_ReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PVOID DeviceContext,
    IN PBOOLEAN Completed
    )
{
//     PHILIPSCAM_KdPrint (MAX_TRACE, ("P*_ReceiveDataPacket\n"));
}


VOID STREAMAPI
PHILIPSCAM_ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PVOID DeviceContext,
    IN PBOOLEAN Completed
    )
{
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
  PHILIPSCAM_KdPrint (ULTRA_TRACE, ("'PHILIPSCAM: Receive Ctrl SRB  %x\n", Srb->Command));
	
  *Completed = TRUE; 
  Srb->Status = STATUS_SUCCESS;

  switch (Srb->Command)	{

	case SRB_PROPOSE_DATA_FORMAT:
	  PHILIPSCAM_KdPrint(MIN_TRACE, ("'Receiving SRB_PROPOSE_DATA_FORMAT  SRB  \n"));
	  if ( !(AdapterVerifyFormat (
				(PKS_DATAFORMAT_VIDEOINFOHEADER)Srb->CommandData.OpenFormat, 
				Srb->StreamObject->StreamNumber))) {
		Srb->Status = STATUS_NO_MATCH;
		PHILIPSCAM_KdPrint(MIN_TRACE,("SRB_PROPOSE_DATA_FORMAT FAILED\n"));
	  }
	  break;

	case SRB_SET_DATA_FORMAT:  
      {
        PKS_DATAFORMAT_VIDEOINFOHEADER pKSDataFormat = 
                (PKS_DATAFORMAT_VIDEOINFOHEADER) Srb->CommandData.OpenFormat;
        PKS_VIDEOINFOHEADER  pVideoInfoHdrRequested = 
                                             &pKSDataFormat->VideoInfoHeader;

	    PHILIPSCAM_KdPrint(MIN_TRACE, ("'SRB_SET_DATA_FORMAT\n"));

	    if ((AdapterVerifyFormat(pKSDataFormat,Srb->StreamObject->StreamNumber))) {
          
//        if (deviceContext->UsbcamdInterface.USBCAMD_SetVideoFormat(DeviceContext,Srb)) {
//          deviceContext->CurrentProperty.Format.lWidth = 
//                                pVideoInfoHdrRequested->bmiHeader.biWidth;
//          deviceContext->CurrentProperty.Format.lHeight =
//                               pVideoInfoHdrRequested->bmiHeader.biHeight;
//        }
        }else {
		  Srb->Status = STATUS_NO_MATCH;
	  	  PHILIPSCAM_KdPrint(MIN_TRACE,(" SRB_SET_DATA_FORMAT FAILED\n"));
        }
      }
      break;
     
	case SRB_GET_DATA_FORMAT:
	  PHILIPSCAM_KdPrint(MIN_TRACE, ("' SRB_GET_DATA_FORMAT\n"));
	  Srb->Status = STATUS_NOT_IMPLEMENTED;
	  break;


	case SRB_SET_STREAM_STATE:

	case SRB_GET_STREAM_STATE:

	case SRB_GET_STREAM_PROPERTY:

	case SRB_SET_STREAM_PROPERTY:

	case SRB_INDICATE_MASTER_CLOCK:

	default:

 	  *Completed = FALSE; // let USBCAMD handle these control SRBs
  }
  if (*Completed == TRUE) {
    StreamClassStreamNotification(StreamRequestComplete,Srb->StreamObject,Srb);
  }

  PHILIPSCAM_KdPrint (ULTRA_TRACE, ("P*_ReceiveCtrlPacket\n"));
}



// **
// Describe the camera
//

USBCAMD_DEVICE_DATA PHILIPSCAM_DeviceData  = {
  0,
  PHILIPSCAM_Initialize,
  PHILIPSCAM_UnInitialize,
  PHILIPSCAM_ProcessUSBPacket,
  PHILIPSCAM_NewFrame,
  PHILIPSCAM_ProcessRawVideoFrame,
  PHILIPSCAM_StartVideoCapture,
  PHILIPSCAM_StopVideoCapture,
  PHILIPSCAM_Configure,
  PHILIPSCAM_SaveState,
  PHILIPSCAM_RestoreState,
  PHILIPSCAM_AllocateBandwidth,
  PHILIPSCAM_FreeBandwidth
};
/*		  Function                      Caller
    PHILIPSCAM_Initialize,              USBCAMD.c : USBCAMD_ConfigureDevice()
    PHILIPSCAM_UnInitialize,            USBCAMD.c : USBCAMD_RemoveDevice
    PHILIPSCAM_ProcessUSBPacket,        iso.c :     USBCAMD_TransferComplete()
    PHILIPSCAM_NewFrame,                iso.c :     USBCAMD_TransferComplete()
    PHILIPSCAM_ProcessRawVideoFrame,    iso.c :     USBCAMD_ProcessWorkItem()
    PHILIPSCAM_StartVideoCapture,       USBCAMD.c : USBCAMD_PrepareChannel()       
                                        reset.c		USBCAMD_ResetPipes()
    PHILIPSCAM_StopVideoCapture,        USBCAMD.c : USBCAMD_UnPrepareChannel()      
                                        reset.c:    USBCAMD_ResetPipes()
    PHILIPSCAM_Configure,               USBCAMD.c : USBCAMD_SelectConfiguration()
    PHILIPSCAM_SaveState,
    PHILIPSCAM_RestoreState,
    PHILIPSCAM_AllocateBandwidth,       		<--+
	   USBCAMD.c : USBCAMD_PrepareChannel()		  -+		<--+
	      STREAM.c : AdapterOpenStream() 					  -+		<--+
		      USBCAMD_AdapterReceivePacket(SRB = SRB_OPEN_STREAM)		  -+
    PHILIPSCAM_FreeBandwidth            USBCAMD.c : USBCAMD_UnPrepareChannel()

*/

VOID
PHILIPSCAM_AdapterReceivePacket( IN PHW_STREAM_REQUEST_BLOCK Srb ) {
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext;
  PHW_STREAM_INFORMATION streamInformation =
                      &(Srb->CommandData.StreamBuffer->StreamInfo);
  PHW_STREAM_HEADER streamHeader =
                      &(Srb->CommandData.StreamBuffer->StreamHeader);       
  PDEVICE_OBJECT deviceObject;       
    
  switch (Srb->Command) {
    case SRB_GET_STREAM_INFO:
	//
	// this is a request for the driver to enumerate requested streams
	//
	  PHILIPSCAM_KdPrint (ULTRA_TRACE, ("P*_AdapterReceivePacket: SRB_GET_STREAM_INFO\n"));

       // get our device ext. from USBCAMD.
 	  deviceContext     =
		USBCAMD_AdapterReceivePacket(Srb, NULL, NULL, FALSE);  
    //
	// we support one stream
	//
	  streamHeader->NumberOfStreams = 1;

	  streamInformation->StreamFormatsArray  = 
	           &PHILIPSCAM_MovingStreamFormats[0];
	  streamInformation->NumberOfFormatArrayEntries =
               Streams[0].NumberOfFormatArrayEntries;
	//
	// set the property information for the video stream
	//
	  streamHeader->DevicePropertiesArray =
         PHILIPSCAM_GetAdapterPropertyTable(&streamHeader->
                                                    NumDevPropArrayEntries) ;

        // pass to usbcamd to finish the job
 	  deviceContext     =
		USBCAMD_AdapterReceivePacket(Srb, &PHILIPSCAM_DeviceData, NULL, TRUE);  
	   
	  ASSERT_DEVICE_CONTEXT(deviceContext);
	break;

    case SRB_GET_DEVICE_PROPERTY:
	//
	// we handle all the property stuff
	//
	  PHILIPSCAM_KdPrint (ULTRA_TRACE, ("P*_AdapterReceivePacket: SRB_GET_DEVICE_PROPERTY\n"));

	  deviceContext     =
		USBCAMD_AdapterReceivePacket(Srb, &PHILIPSCAM_DeviceData, 
		                                          &deviceObject, FALSE);  
	  ASSERT_DEVICE_CONTEXT(deviceContext); 

	  PHILIPSCAM_KdPrint (ULTRA_TRACE, ("SRB_GET_STREAM_INFO\n"));
	  PHILIPSCAM_PropertyRequest( FALSE, deviceObject, deviceContext, Srb);

	  StreamClassDeviceNotification(DeviceRequestComplete,
				                    Srb->HwDeviceExtension,
				                    Srb);
	break;           
	   
    case SRB_SET_DEVICE_PROPERTY:
	//
	// we handle all the property stuff
	//
	  PHILIPSCAM_KdPrint (ULTRA_TRACE, ("P*_AdapterReceivePacket: SRB_SET_DEVICE_PROPERTY\n"));

	  deviceContext =    
	    USBCAMD_AdapterReceivePacket(Srb, &PHILIPSCAM_DeviceData, 
	                                      &deviceObject, FALSE);  
	  ASSERT_DEVICE_CONTEXT(deviceContext); 

	  PHILIPSCAM_KdPrint (ULTRA_TRACE, ("SRB_GET_STREAM_INFO\n"));
	  PHILIPSCAM_PropertyRequest( TRUE, deviceObject, deviceContext, Srb);

	  StreamClassDeviceNotification(DeviceRequestComplete,
				                    Srb->HwDeviceExtension,
				                    Srb);
	break;

    case SRB_OPEN_STREAM:  {
      PKS_DATAFORMAT_VIDEOINFOHEADER  pKSDataFormat =
	    	(PKS_DATAFORMAT_VIDEOINFOHEADER) Srb->CommandData.OpenFormat;
	  PKS_VIDEOINFOHEADER  pVideoInfoHdrRequested =
		                           &pKSDataFormat->VideoInfoHeader;
      PHILIPSCAM_KdPrint (ULTRA_TRACE, ("P*_AdapterReceivePacket: SRB_OPEN_STREAM\n"));
	// pass to usbcamd to finish the job
      Srb->StreamObject->ReceiveDataPacket = 
                            (PVOID) PHILIPSCAM_ReceiveDataPacket;
	  Srb->StreamObject->ReceiveControlPacket = 
	                        (PVOID) PHILIPSCAM_ReceiveCtrlPacket;

      if (AdapterVerifyFormat(pKSDataFormat,
		                      Srb->StreamObject->StreamNumber)) {
	    deviceContext =
		   USBCAMD_AdapterReceivePacket(Srb, &PHILIPSCAM_DeviceData, 
		                                NULL, TRUE);
//		deviceContext->StreamOpen = TRUE;     
	  }else{
	    Srb->Status = STATUS_INVALID_PARAMETER;
	    StreamClassDeviceNotification(DeviceRequestComplete,
				      Srb->HwDeviceExtension,
				      Srb);
	  }
	}
	break;                   


    case SRB_GET_DATA_INTERSECTION:
		//
		// Return a format, given a range
		//
	//deviceContext =    
	//    USBCAMD_AdapterReceivePacket(Srb,
		//                                   &PHILIPSCAM_DeviceData,
		//                                   &deviceObject,
		//                                                               FALSE);  
      PHILIPSCAM_KdPrint (MAX_TRACE, ("P*_AdapterReceivePacket: SRB_GET_DATA_INTERSECTION\n"));
 										
	  Srb->Status = AdapterFormatFromRange(Srb);
	  StreamClassDeviceNotification(DeviceRequestComplete,
				                    Srb->HwDeviceExtension,
				                    Srb);   
    break;   

    case SRB_CLOSE_STREAM:         // close the specified stream

    case SRB_CHANGE_POWER_STATE:   // change power state

    case SRB_SET_STREAM_RATE:	   // set the rate at which the stream should run

    default:
	//
	// let usbcamd handle it
	//
      PHILIPSCAM_KdPrint (ULTRA_TRACE, ("P*_AdapterReceivePacket: SRB_HANDLED BY USBCAMD\n"));
  
  	  deviceContext =    
	    USBCAMD_AdapterReceivePacket(Srb, 
	                                 &PHILIPSCAM_DeviceData, NULL, TRUE);           
	  ASSERT_DEVICE_CONTEXT(deviceContext); 
  }
}


/*
** DriverEntry()
**
** This routine is called when the mini driver is first loaded.  The driver
** should then call the StreamClassRegisterAdapter function to register with
** the stream class driver
**
** Arguments:
**
**  Context1:  The context arguments are private plug and play structures
**             used by the stream class driver to find the resources for this
**             adapter
**  Context2:
**
** Returns:
**
** This routine returns an NT_STATUS value indicating the result of the
** registration attempt. If a value other than STATUS_SUCCESS is returned, the
** minidriver will be unloaded.
**
** Side Effects:  none
*/

ULONG
DriverEntry(
  PVOID Context1,
  PVOID Context2 ){
    PHILIPSCAM_KdPrint (MAX_TRACE, ("'Driver Entry\n"));
    return USBCAMD_DriverEntry(Context1,
			                   Context2,
			                   sizeof(PHILIPSCAM_DEVICE_CONTEXT),
			                   sizeof(PHILIPSCAM_FRAME_CONTEXT),
			                   PHILIPSCAM_AdapterReceivePacket);
}


/*
** PHILIPSCAM_Initialize()
**
** On entry the device has been configured and the initial alt
** interface selected -- this is where we may send additional
** vendor commands to enable the device.
**
** Philips actions:
** 1.	 Find out what type of camera is available, VGA or medium-Res
**       This has consequences for the available streamformats.
**
** Arguments:
**
** BusDeviceObject - pdo associated with this device
**
** DeviceContext - driver specific context
**
** Returns:
**
** NTSTATUS code
**
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_Initialize( PDEVICE_OBJECT BusDeviceObject,
                       PVOID DeviceContext	) {
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext=DeviceContext;
  NTSTATUS ntStatus = STATUS_SUCCESS;
  ASSERT_DEVICE_CONTEXT(deviceContext);
    //
    // perform any hardware specific
    // initialization
    //
  ntStatus = PHILIPSCAM_GetSensorType(deviceContext);
  if  (NT_SUCCESS(ntStatus)) {
    ntStatus = PHILIPSCAM_GetReleaseNumber(deviceContext);
  }
  deviceContext->EmptyPacketCounter = 0; // (Initialize this counter)
  if  (NT_SUCCESS(ntStatus)) {
    ntStatus = PHILIPSCAM_InitPrpObj(deviceContext);
  }
  PHILIPSCAM_KdPrint (MIN_TRACE, ("'X P*_Initialize 0x%x\n", ntStatus));
  ILOGENTRY("inHW", 0, 0, ntStatus);
   
  return ntStatus;
}


/*
** PHILIPSCAM_UnInitialize()
**
** Assume the device hardware is gone -- all that needs to be done is to 
** free any allocated resources (like memory).
**
** Arguments:
**
** BusDeviceObject - pdo associated with this device
**
** DeviceContext - driver specific context
**
** Returns:
**
** NTSTATUS code
**
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_UnInitialize( PDEVICE_OBJECT BusDeviceObject,
                         PVOID DeviceContext ) {
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext;
  NTSTATUS ntStatus = STATUS_SUCCESS;

  deviceContext = DeviceContext;
  ASSERT_DEVICE_CONTEXT(deviceContext);
  if ( deviceContext->Interface) { 
   	ExFreePool(deviceContext->Interface);
   	deviceContext->Interface = NULL;
  }
  PHILIPSCAM_KdPrint (MAX_TRACE, ("'P*_UnInitialize 0x%x\n", ntStatus));
  return ntStatus;
}


/*
** PHILIPSCAM_Configure()
**
** Configure the iso streaming Interface:
**
** Called just before the device is configured, this is where we tell
** usbcamd which interface and alternate setting to use for the idle state.
**
** NOTE: The assumption here is that the device will have a single interface
**  with multiple alt settings and each alt setting has the same number of
**  pipes.
**
** Arguments:
**
**  BusDeviceObject - device object created by the hub whe can submit
**                  urbs to our device through this deviceObject
**
**  DeviceContext - minidriver device  context
**
**  Interface - USBD interface structure initialized with the proper values
**              for select_configuration. This Interface structure corresponds
**              a single iso interafce on the device.  This is the drivers
**              chance to pick a particular alternate setting and pipe
**              parameters.
**
**
**  ConfigurationDescriptor - USB configuration Descriptor for
**      this device.
**
** Returns:
**
**  NTSTATUS code
**
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_Configure(IN PDEVICE_OBJECT BusDeviceObject,
                     IN PVOID DeviceContext,
                     IN OUT PUSBD_INTERFACE_INFORMATION Interface,
                     IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
                     IN OUT PLONG DataPipeIndex,
                     IN OUT PLONG SyncPipeIndex	) {
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext;
  NTSTATUS ntStatus = STATUS_SUCCESS;

  deviceContext = DeviceContext;
  deviceContext->Sig = PHILIPSCAM_DEVICE_SIG;
    //
    // initilialize any other context stuff
    //
  PHILIPSCAM_KdPrint (MAX_TRACE, ("'E P*_Configure \n"));

  if ( Interface == NULL) {
    	//
    	// this is a signal from usbcamd that I need to free my previousely 
    	// allocated space for interface descriptor due to error conditions
    	// during IRP_MN_START_DEVICE processing and driver will be unloaded soon.
    	//
    	if (deviceContext->Interface) {
    		ExFreePool(deviceContext->Interface);
    		deviceContext->Interface = NULL;
    	}
    	return ntStatus;
  }

  deviceContext->Interface = ExAllocatePool(NonPagedPool,
     					                    Interface->Length);

  *DataPipeIndex = 1;
  *SyncPipeIndex = -1;  //  no sync pipe 

  if (deviceContext->Interface) {
	Interface->AlternateSetting = ALT_INTERFACE_0 ;
	  // This interface has two pipes,
	  // initialize input parameters to USBD for both pipes.
	  // The MaximumTransferSize is the size of the largest
	  // buffer we want to submit for a single iso urb
	  // request.
	  //
    Interface->Pipes[PHILIPSCAM_SYNC_PIPE].MaximumTransferSize =
           USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;        //  = PAGE SIZE ??
	Interface->Pipes[PHILIPSCAM_DATA_PIPE].MaximumTransferSize =
//	    1024*32;       // 32k transfer per urb       ??
                                      1024*198;       // CIF: 352x288x16/8 
    RtlCopyMemory(deviceContext->Interface,
	     	      Interface,
		          Interface->Length);                
	PHILIPSCAM_KdPrint (MAX_TRACE, ("'size of interface request  = %d\n", 
	                                  Interface->Length));
  }else{
	ntStatus = STATUS_INSUFFICIENT_RESOURCES;
  }
  //
  // return interface number and alternate setting
  //
  PHILIPSCAM_KdPrint (MIN_TRACE, ("'X P*_Configure 0x%x\n", ntStatus));

  return ntStatus;
}


/*
** PHILIPSCAM_StartVideoCapture()
**
** Arguments:
**
**  BusDeviceObject - device object created by the hub we can submit
**                  urbs to our device through this deviceObject
**
**  DeviceContext - minidriver device  context
**
** Returns:
**
** NTSTATUS code
**
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_StartVideoCapture( IN PDEVICE_OBJECT BusDeviceObject,
                              IN PVOID DeviceContext ) {
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
  NTSTATUS ntStatus= STATUS_SUCCESS;
   
  ASSERT_DEVICE_CONTEXT(deviceContext);
    //
    // This is where we select the interface we need and send
    // commands to start capturing
    //
  PHILIPSCAM_KdPrint (MAX_TRACE, ("'E P*_StartVideoCapture \n"));
  PHILIPSCAM_KdPrint (MAX_TRACE, ("'X P*_StartVideocapture 0x%x\n", ntStatus));

  return ntStatus;       
}

/*
** PHILIPSCAM_AllocateBandwidth()
**
** Called just before the iso video capture stream is
** started, here is where we select the appropriate
** alternate interface and set up the device to stream.
**
**  Called in connection with the stream class RUN command
**
** Arguments:
**
**  BusDeviceObject - device object created by the hub we can submit
**                  urbs to our device through this deviceObject
**
**  DeviceContext - minidriver device  context
**
**  RawFrameLength - pointer to be filled in with size of buffer needed to
**                  receive the raw frame data from the packet stream.
**
**  Format - pointer to PKS_DATAFORMAT_VIDEOINFOHEADER associated with this
**          stream.         
**
** Returns:
**
** NTSTATUS code
**
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_AllocateBandwidth( IN PDEVICE_OBJECT BusDeviceObject,
                              IN PVOID DeviceContext,
                              OUT PULONG RawFrameLength,
                              IN PVOID Format             ){ 
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
  NTSTATUS ntStatus = STATUS_SUCCESS;
  PKS_DATAFORMAT_VIDEOINFOHEADER pdataFormatHeader;
  PKS_BITMAPINFOHEADER bmInfoHeader;
  LONGLONG llDefaultFramePeriod ;
  USHORT usReqFrRate;
  ASSERT_DEVICE_CONTEXT(deviceContext);
  PHILIPSCAM_KdPrint (MAX_TRACE, ("'E P*_AllocateBandwidth \n"));
    //
    // This is where we select the interface we need and send
    // commands to start capturing
    //
  *RawFrameLength = 0;
  pdataFormatHeader = Format;
  bmInfoHeader = &pdataFormatHeader->VideoInfoHeader.bmiHeader;
//  deviceContext->pSelectedStreamFormat = &pdataFormatHeader->DataFormat; // removed RMR

  RtlCopyMemory (&deviceContext->CamStatus.PictureSubFormat,    // added RMR
                 &pdataFormatHeader->DataFormat.SubFormat,
				 sizeof (GUID));

  PHILIPSCAM_KdPrint (MIN_TRACE, 
	                    ("'req.format %d x %d\n", bmInfoHeader->biWidth,
			               bmInfoHeader->biHeight));

  switch (bmInfoHeader->biWidth) {
	case QQCIF_X:
      deviceContext->CamStatus.PictureFormat = FORMATQQCIF;
      *RawFrameLength = (SQCIF_X * SQCIF_Y * 12)/8;
    break;
	case SQCIF_X:
      deviceContext->CamStatus.PictureFormat = FORMATSQCIF;
      *RawFrameLength = (SQCIF_X * SQCIF_Y * 12)/8;
    break;
	case QCIF_X:
      deviceContext->CamStatus.PictureFormat = FORMATQCIF;
      *RawFrameLength = (QCIF_X * QCIF_Y * 12)/8;
    break;
    case CIF_X:
      deviceContext->CamStatus.PictureFormat = FORMATCIF;
      *RawFrameLength = (CIF_X * CIF_Y * 12)/8;
    break;
    case SQSIF_X:
      deviceContext->CamStatus.PictureFormat = FORMATSQSIF;
      *RawFrameLength = (SQCIF_X * SQCIF_Y * 12)/8;
    break;
    case QSIF_X:
      deviceContext->CamStatus.PictureFormat = FORMATQSIF;
      *RawFrameLength = (QCIF_X * QCIF_Y * 12)/8;
    break;
    case SSIF_X:
	  if (bmInfoHeader->biHeight == SSIF_Y){
        deviceContext->CamStatus.PictureFormat = FORMATSSIF;
      }else{
        deviceContext->CamStatus.PictureFormat = FORMATSCIF;
      }
      *RawFrameLength = (CIF_X * CIF_Y * 12)/8;
    break;
    case SIF_X:
      deviceContext->CamStatus.PictureFormat = FORMATSIF;
      *RawFrameLength = (CIF_X * CIF_Y * 12)/8;
    break;
    default:
      deviceContext->CamStatus.PictureFormat = FORMATQCIF;
      *RawFrameLength = (QCIF_X * QCIF_Y * 12)/8;
  }

  llDefaultFramePeriod = pdataFormatHeader->VideoInfoHeader.AvgTimePerFrame; // [100nS]
  usReqFrRate = MapFrPeriodFrRate(llDefaultFramePeriod);
  deviceContext->CamStatus.PictureFrameRate = usReqFrRate;

  PHILIPSCAM_KdPrint (MIN_TRACE,("Req.frperiod: %d us \n", 
	                             llDefaultFramePeriod / 10));
  PHILIPSCAM_KdPrint (MIN_TRACE,("Req.frperiod index: %d = %s fps\n",
	                            usReqFrRate, FRString(usReqFrRate)));


  // Define framerate based on available USB=bandwidth
  // if not suff.BW, frame rate is decreased.
  ntStatus = PHILIPSCAM_SetFrRate_AltInterface(deviceContext);

 
  // Send from here the format/framerate to the camera hardware:
  if (NT_SUCCESS(ntStatus)) {
    ntStatus = PHILIPSCAM_SetFormatFramerate( deviceContext );
  }
  if (NT_SUCCESS(ntStatus)) {
    ntStatus = PHILIPSCAM_StartCodec( deviceContext );
  }

  if (NT_SUCCESS(ntStatus)) {
	deviceContext->FrameLength = *RawFrameLength;
  }
  PHILIPSCAM_KdPrint (MAX_TRACE, ("'X P*_AllocateBandwidth  0x%x\n", ntStatus));

  return ntStatus;       
}

/*
** PHILIPSCAM_FreeBandwidth()
**
** Called after the iso video stream is stopped, this is where we
** select an alternate interface that uses no bandwidth.
**
** Arguments:
**
**  BusDeviceObject - device object created by the hub we can submit
**                  urbs to our device through this deviceObject
**
**  DeviceContext - minidriver device  context
**
** Returns:
**
**  NTSTATUS code
**
** Side Effects:  none
*/
NTSTATUS
PHILIPSCAM_FreeBandwidth(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext	 ){
  NTSTATUS ntStatus;
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
    // turn off streaming on the device
  ASSERT_DEVICE_CONTEXT(deviceContext);
  ntStatus = PHILIPSCAM_StopCodec(deviceContext);
  deviceContext->Interface->AlternateSetting = ALT_INTERFACE_0 ;
  ntStatus = USBCAMD_SelectAlternateInterface(
		   deviceContext,
		   deviceContext->Interface);

  PHILIPSCAM_KdPrint (MAX_TRACE, ("'X P*_FreeBandWidth 0x%x\n", ntStatus));
  return ntStatus;
}


/*
** PHILIPSCAM_StopVideoCapture()
**
** Called after the iso video stream is stopped, this is where we
** select an alternate interface that uses no bandwidth.
**
** Arguments:
**
**  BusDeviceObject - device object created by the hub we can submit
**                  urbs to our device through this deviceObject
**
**  DeviceContext - minidriver device  context
**
** Returns:
**
**  NTSTATUS code
**
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_StopVideoCapture( PDEVICE_OBJECT BusDeviceObject,
                             PVOID DeviceContext ) {
  NTSTATUS ntStatus = STATUS_SUCCESS;
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
    // turn off streaming on the device
  ASSERT_DEVICE_CONTEXT(deviceContext);
  PHILIPSCAM_KdPrint (MAX_TRACE, ("'X P*_StopVideoCapture 0x%x\n", ntStatus));
  return ntStatus;
}


/*
** PHILIPSCAM_NewFrame()
**
**  called at DPC level to allow driver to initialize a new video frame
**  context structure
**
** Arguments:
**
**  DeviceContext - minidriver device  context
**
**  FrameContext - frame context to be initialized
**
** Returns:
**
**  NTSTATUS code
** 
** Side Effects:  none
*/

VOID
PHILIPSCAM_NewFrame( PVOID DeviceContext,
                     PVOID FrameContext	 ){
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
  PPHILIPSCAM_FRAME_CONTEXT pFrameContext = FrameContext;

  pFrameContext->USBByteCounter = 0;

//  PHILIPSCAM_KdPrint (MAX_TRACE, ("'P*_NewFrame\n"));
  ASSERT_DEVICE_CONTEXT(deviceContext);
}


/*
** PHILIPSCAM_ProcessUSBPacket()
**
**  called at DPC level to allow driver to determine if this packet is part
**  of the current video frame or a new video frame.
**
**  This function should complete as quickly as possible, any image processing
**  should be deferred to the ProcessRawFrame routine.
**
** Arguments:
**
**  BusDeviceObject - device object created by the hub we can submit
**                  urbs to our device through this deviceObject
**
**  DeviceContext - minidriver device  context
**
**  CurrentFrameContext - some context for this particular frame
**
**  SyncPacket - iso packet descriptor from sync pipe, not used if the interface
**              has only one pipe.
**
**  SyncBuffer - pointer to data for the sync packet
**
**  DataPacket - iso packet descriptor from data pipe
**
**  DataBuffer - pointer to data for the data packet
**
**  FrameComplete - indicates to usbcamd that this is the first data packet
**          for a new video frame
**
** Returns:
** 
** number of bytes that should be copied in to the rawFrameBuffer of FrameBuffer.
**
** Side Effects:  none


*/
ULONG
PHILIPSCAM_ProcessUSBPacket(
              PDEVICE_OBJECT BusDeviceObject,
              PVOID DeviceContext,
              PVOID CurrentFrameContext,
              PUSBD_ISO_PACKET_DESCRIPTOR SyncPacket,
              PVOID SyncBuffer,
              PUSBD_ISO_PACKET_DESCRIPTOR DataPacket,
              PVOID DataBuffer,
              PBOOLEAN FrameComplete,
              PBOOLEAN NextFrameIsStill	) {
  static BOOLEAN  EndOfFrameFound = FALSE;
  static BOOLEAN  StartOfFrameFound = FALSE;
  static ULONG previous_packetSize= 0;
  static ULONG ActualBytesReceived = 0 ;

#if DBG
#if DBGHARD

  typedef struct {
    ULONG PSize;
    ULONG DeltaT;
  } PACKETINFO;
#define  MAXI 2048
  static ULONG ulRcvdFrameSize[MAXI];
  static ULONG ulPHistory[MAXI][2];
  static ULONG ulPcktCntr  = 0;
  static ULONG ulFrSCntr = 0;
  static LARGE_INTEGER liCurTicks, liPrevTicks;
  static ULONG ElapsedTicks;
  static ULONG TickPeriod ; 

#endif
#endif
  
  PUSBD_ISO_PACKET_DESCRIPTOR dataPacket = DataPacket;
  PPHILIPSCAM_FRAME_CONTEXT pFrameContext = CurrentFrameContext;

  ULONG  packetSize;

  PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
  *NextFrameIsStill = FALSE;
//    PHILIPSCAM_KdPrint (MAX_TRACE, ("'E P*_ProcessPacket\n"));
  ASSERT_DEVICE_CONTEXT(deviceContext);

  packetSize = dataPacket->Length ;


//            Synchronization:
//            ----------------
  if (packetSize != previous_packetSize){
	                              //end or start of frame
	if (packetSize < previous_packetSize) {
	  EndOfFrameFound = TRUE;
	}else{
	  StartOfFrameFound = TRUE;
	}
  }

  if ( StartOfFrameFound == TRUE ){
	*FrameComplete = TRUE;
	EndOfFrameFound = FALSE;
	StartOfFrameFound = FALSE;

#if DBG
#if DBGHARD
    ulRcvdFrameSize[ulFrSCntr] = ActualBytesReceived;
	if (ulFrSCntr==MAXI)	ulFrSCntr = 0;
#endif
#endif

	if (pFrameContext)	
		pFrameContext->USBByteCounter = ActualBytesReceived;
    ActualBytesReceived = 0;
  }

  ActualBytesReceived += packetSize;

#if DBG
#if DBGHARD

//  KeQueryTickCount(&liCurTicks);
  ElapsedTicks = (ULONG)( liCurTicks.QuadPart - liPrevTicks.QuadPart);
  ulPHistory[ulPcktCntr][0]  = packetSize;
  ulPHistory[ulPcktCntr][1]  = ElapsedTicks  ;
  liPrevTicks.QuadPart = liCurTicks.QuadPart;
  ulPcktCntr++;
  if (ulPcktCntr==MAXI) ulPcktCntr = 0;
#endif
#endif
	 
                           // Added to improve robustness
  if ( ActualBytesReceived > deviceContext->FrameLength){
	*FrameComplete = TRUE;
	ActualBytesReceived = 0;
  } 
  previous_packetSize = packetSize;
  return packetSize;
}

/*
** PHILIPSCAM_ProcessRawVideoFrame()
**
**  Called at PASSIVE level to allow driver to perform any decoding of the
**  raw video frame.
**
**    This routine will convert the packetized data in to the fromat
**    the CODEC expects, ie y,u,v
**
**    data is always of the form 256y 64u 64v (384 byte chunks) regardless of USB
**    packet size.
**
**
** Arguments:
**
**  DeviceContext - driver context
**
**  FrameContext - driver context for this frame
**
**  FrameBuffer - pointer to the buffer that should receive the final
**              processed video frame.
**
**  FrameLength - length of the Frame buffer (from the original read
**                  request)
**
**  RawFrameBuffer - pointer to buffer containing the received USB packets
**
**  RawFrameLength - length of the raw frame.
**
**  NumberOfPackets - number of USB packets received in to the RawFrameBuffer
**
**  BytesReturned - pointer to value to return for number of bytes read.
**             
** Returns:
**
**  NT status completion code for the read irp
** 
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_ProcessRawVideoFrame( PDEVICE_OBJECT BusDeviceObject,
                                 PVOID DeviceContext,
                                 PVOID FrameContext,
                                 PVOID FrameBuffer,
                                 ULONG FrameLength,
                                 PVOID RawFrameBuffer,
                                 ULONG RawFrameLength,
                                 ULONG NumberOfPackets,
                                 PULONG BytesReturned  ) {
NTSTATUS ntStatus = STATUS_SUCCESS;
PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
PPHILIPSCAM_FRAME_CONTEXT frameContext = FrameContext;
ULONG  rawDataLength, processedDataLength;
PUCHAR frameBuffer    = FrameBuffer;
PUCHAR rawFrameBuffer = RawFrameBuffer;
ULONG  rawFrameLength = RawFrameLength;
ULONG  frameLength    = FrameLength;
ULONG  ExpectedNumberOfBytes;

    //TEST_TRAP();
  ASSERT_DEVICE_CONTEXT(deviceContext);

  switch (deviceContext->CamStatus.PictureFormat){
    case FORMATCIF:
	  if ( deviceContext->CamStatus.PictureCompressing == COMPRESSION0 ){
		ExpectedNumberOfBytes = CIF_X * CIF_Y * 3/2 ;
	  }else{
		ExpectedNumberOfBytes = CIF_X * CIF_Y / 2 ;
	  }  
	break;
    case FORMATQCIF:
	  ExpectedNumberOfBytes = QCIF_X * QCIF_Y * 3/2 ;
	break;
    case FORMATSQCIF:
	  ExpectedNumberOfBytes = SQCIF_X * SQCIF_Y * 3/2 ;
	break;
    case FORMATQQCIF:
	  ExpectedNumberOfBytes = SQCIF_X * SQCIF_Y * 3/2 ;
	break;
    case FORMATVGA:
	  ExpectedNumberOfBytes = VGA_X * VGA_Y * 3/2 ;
	break;
    case FORMATSIF:
	  if ( deviceContext->CamStatus.PictureCompressing == COMPRESSION0 ){
		ExpectedNumberOfBytes = CIF_X * CIF_Y * 3/2 ;
	  }else{
		ExpectedNumberOfBytes = CIF_X * CIF_Y / 2 ;
	  }  
	break;
    case FORMATSSIF:
	  if ( deviceContext->CamStatus.PictureCompressing == COMPRESSION0 ){
		ExpectedNumberOfBytes = CIF_X * CIF_Y * 3/2 ;
	  }else{
		ExpectedNumberOfBytes = CIF_X * CIF_Y / 2 ;
	  }  
	break;
    case FORMATSCIF:
	  if ( deviceContext->CamStatus.PictureCompressing == COMPRESSION0 ){
		ExpectedNumberOfBytes = CIF_X * CIF_Y * 3/2 ;
	  }else{
		ExpectedNumberOfBytes = CIF_X * CIF_Y / 2 ;
	  }  
	break;
    case FORMATQSIF:
	  ExpectedNumberOfBytes = QCIF_X * QCIF_Y * 3/2 ;
	break;
    case FORMATSQSIF:
	  ExpectedNumberOfBytes = SQCIF_X * SQCIF_Y * 3/2 ;
	break;
    default:
      ExpectedNumberOfBytes = 0;
  }

  if (ExpectedNumberOfBytes == frameContext->USBByteCounter ) {
    ntStatus =  PHILIPSCAM_DecodeUsbData(deviceContext, 
                                       frameBuffer,
	  		  			               frameLength,
						               rawFrameBuffer,
						               rawFrameLength);
    *BytesReturned = frameLength ;
  }else{
    PHILIPSCAM_KdPrint (MIN_TRACE, ("Actual (%d) < Expected (%d) \n",
    	frameContext->USBByteCounter,ExpectedNumberOfBytes));

//	Green screen complaints bug fix : At the moment USBCAMD delivers a frame for
//	processing, we check whether the size of that frame is correct.
//	If not we return to USBCAMD a framelength to be copied of zero and we won't
//	process the frame.
//	The workaround is to let USBCAMD copy the buffer with the actual buffer length
//	and not to process the frame. Apparantly, returning a bufferlength zero has as
//	consequence that USB packets gets lost.
//	This causes subsequent frames to be incorrect, returning again bufferlength
//	zero. And so on. Not processing buffers has as consequence that the renderer
//	sees empty buffers resulting in a green screen.
//	Sometimes, if this happens  during streaming, old buffers are being rerendered.

    *BytesReturned = 0 ;  
    
	// 2001/01/29: This workaround was causing the first few frames
	// captured to remain uninitialized due to insufficient framelength.
	// Returning 0 to indicate a dropped frame is the correct behavior.
    //*BytesReturned = frameLength ;
  }

  return ntStatus;
}

/*
** PHILIPSCAM_PropertyRequest()
**
** Arguments:
**
**  DeviceContext - driver context
**
** Returns:
**
**  NT status completion code for the read irp
** 
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_PropertyRequest( BOOLEAN SetProperty,
                            PDEVICE_OBJECT BusDeviceObject,
                            PVOID DeviceContext,
                            PVOID PropertyContext ) {
  NTSTATUS ntStatus = STATUS_SUCCESS;
  PHW_STREAM_REQUEST_BLOCK srb = (PHW_STREAM_REQUEST_BLOCK)PropertyContext;
  PSTREAM_PROPERTY_DESCRIPTOR propertyDescriptor;

  propertyDescriptor = srb->CommandData.PropertyInfo;
    //
    // identify the property to set
    //
  PHILIPSCAM_KdPrint (MAX_TRACE, ("'E P*_PropertyRequest\n"));

    if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOPROCAMP, &propertyDescriptor->Property->Set)) 
		if (SetProperty) 
			ntStatus = PHILIPSCAM_SetCameraProperty(DeviceContext, srb);
		else 
			ntStatus = PHILIPSCAM_GetCameraProperty(DeviceContext, srb);
	else if (IsEqualGUID(&PROPSETID_PHILIPS_CUSTOM_PROP, &propertyDescriptor->Property->Set)) 
		if (SetProperty) 
			ntStatus = PHILIPSCAM_SetCustomProperty(DeviceContext, srb);
		else 
			ntStatus = PHILIPSCAM_GetCustomProperty(DeviceContext, srb);
	else if  (IsEqualGUID(&PROPSETID_PHILIPS_FACTORY_PROP, &propertyDescriptor->Property->Set)) 
		if (SetProperty) 
			ntStatus = PHILIPSCAM_SetFactoryProperty(DeviceContext, srb);
		else 
			ntStatus = PHILIPSCAM_GetFactoryProperty(DeviceContext, srb);
	else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOCONTROL, &propertyDescriptor->Property->Set))	
	{
		if (SetProperty) 
			ntStatus = PHILIPSCAM_SetVideoControlProperty(DeviceContext, srb);
		else
			ntStatus = PHILIPSCAM_GetVideoControlProperty(DeviceContext, srb);
	}
	else 
		ntStatus = STATUS_NOT_SUPPORTED;

  PHILIPSCAM_KdPrint (MAX_TRACE, ("'X P*_PropertyRequest 0x%x\n",ntStatus));

  return ntStatus;
}

/*
** PHILIPSCAM_SaveState()
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_SaveState( PDEVICE_OBJECT BusDeviceObject,
                      PVOID DeviceContext ) {
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
  PHILIPSCAM_KdPrint (MAX_TRACE, ("'P*_SaveState\n"));
  return STATUS_SUCCESS;
}   


/*
** PHILIPSCAM_RestoreState()
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_RestoreState( PDEVICE_OBJECT BusDeviceObject,
                         PVOID DeviceContext ) {
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
  PHILIPSCAM_KdPrint (MAX_TRACE, ("'RestoreState\n"));
  return STATUS_SUCCESS;
}   


/*
** PHILIPSCAM_ReadRegistry()
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_ReadRegistry( PDEVICE_OBJECT BusDeviceObject,
                         PVOID DeviceContext  ) {
  PPHILIPSCAM_DEVICE_CONTEXT deviceContext = DeviceContext;
  NTSTATUS ntStatus=STATUS_SUCCESS;
  HANDLE handle;

  return ntStatus;
}   


USHORT 
MapFrPeriodFrRate(LONGLONG llFramePeriod)
{
	USHORT FrameRate;
		
    if       (llFramePeriod <= 420000 ){        // 41.6 rounded to 42 ms
	  FrameRate = FRRATE24;
	}else if (llFramePeriod <= 510000 ){		// 50.0 rounded to 51 ma
	  FrameRate = FRRATE20;
	}else if (llFramePeriod <= 670000 ){		// 66.6 rounded to 67 ms
	  FrameRate = FRRATE15;
	}else if (llFramePeriod <= 840000 ){		// 83.3 rounded to 84 ms
	  FrameRate = FRRATE12;
	}else if (llFramePeriod <= 1010000 ){	    // 100.0 rounded to 101 ms
	  FrameRate = FRRATE10;
													// HR: changed from 134 to 143ms.				
	}else if (llFramePeriod <= 1430000 ){		// 133.3 rounded to 134 ms
	  FrameRate = FRRATE75;
	}else if (llFramePeriod <= 2010000 ){		// 200 rounded to 201 ms
	  FrameRate = FRRATE5;
	}else {
	  FrameRate = FRRATE375;
	}
  // rounding was necessary as the OS returns e.g. #667.111 for 15 fps

    return FrameRate;
}

#if DBG

PCHAR
FRString (
    USHORT index
)
{
	switch (index) 
	{
	    case FRRATEVGA: return "VGA";
   	    case FRRATE375: return "3.75";
   	    case FRRATE5: return "5";
   		case FRRATE75: return "7.5";
   		case FRRATE10: return "10";
   		case FRRATE12: return "12";
   		case FRRATE15: return "15";
   		case FRRATE20: return "20";
   		case FRRATE24:return "24";
   		default:
   			return "";break;
   	}

}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mcodec.c ===
/*++

Copyright (c) 1998  Philips B.V. CE - I&C

Module Name:

   mcodec.c

Abstract:

   this module converts the raw USB data to video data.

Original Author:

    Ronald v.d.Meer

Environment:

   Kernel mode only


Revision History:

Date        Reason
14-04-1998  Initial version
--*/       

#include "wdm.h"
#include "mcamdrv.h"
#include "mstreams.h"
#include "mdecoder.h"
#include "mcodec.h"

/*******************************************************************************
 *
 * START DEFINES
 *
 ******************************************************************************/

#define NO_BANDS_CIF       (CIF_Y / 4)  /* Number of YUV bands per frame */
#define NO_BANDS_SIF       (SIF_Y / 4)  /* Number of YUV bands per frame */
#define NO_BANDS_SSIF     (SSIF_Y / 4)  /* Number of YUV bands per frame */
#define NO_BANDS_SCIF     (SCIF_Y / 4)  /* Number of YUV bands per frame */

#define NO_LINES_IN_BAND  4

/*
 * one line contains "Width * 3/2" bytes (12 bits per pixel)
 * one YYYYCC block is 6 bytes
 * NO_YYYYCC_PER_LINE = (Width * 3/2 / 6) = (Width / 4)
 */
#define NO_YYYYCC_PER_LINE(width) (width >> 2)

#define QQCIF_DY                  ((SQCIF_Y - QQCIF_Y) / 2)
#define QQCIF_DX                  ((SQCIF_X - QQCIF_X) / 2)

#define SQSIF_DY                  ((SQCIF_Y - SQSIF_Y) / 2)
#define SQSIF_DX                  ((SQCIF_X - SQSIF_X) / 2)

#define  QSIF_DY                  (( QCIF_Y -  QSIF_Y) / 2)
#define  QSIF_DX                  (( QCIF_X -  QSIF_X) / 2)

#define  SSIF_DY                  ((  CIF_Y -  SSIF_Y) / 2)
#define  SSIF_DX                  ((  CIF_X -  SSIF_X) / 2)

#define   SIF_DY                  ((  CIF_Y -   SIF_Y) / 2)
#define   SIF_DX                  ((  CIF_X -   SIF_X) / 2)

#define  SCIF_DY                  ((  CIF_Y -  SCIF_Y) / 2)
#define  SCIF_DX                  ((  CIF_X -  SCIF_X) / 2)



/*******************************************************************************
 *
 * START STATIC VARIABLES
 *
 ******************************************************************************/

static WORD    FixGreenbarArray[CIF_Y][4];

/*******************************************************************************
 *
 * START STATIC METHODS DECLARATIONS
 *
 ******************************************************************************/


static void TranslateP420ToI420 (PBYTE pInput, PBYTE pOutput, int w, int h,
                                 DWORD camVersion);

extern void TranslatePCFxToI420 (PBYTE pInput, PBYTE pOutput, int width,
                                 int height, DWORD camVersion);

#ifdef PIX12_FIX
static void FixPix12InI420 (PBYTE p, BOOLEAN Compress, int w, int h,
                            DWORD camVersion);
#endif

static void Fix16PixGreenbarInI420 (PBYTE pStart, int w);

/*******************************************************************************
 *
 * START EXPORTED METHODS DEFINITIONS
 *
 ******************************************************************************/

/*
 * This routine is called at selection of a new stream
 */

extern NTSTATUS 
PHILIPSCAM_DecodeUsbData (PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
                          PUCHAR FrameBuffer,
                          ULONG  FrameLength,
                          PUCHAR RawFrameBuffer,
                          ULONG  RawFrameLength)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    int      width;
    int      height;

    switch (DeviceContext->CamStatus.PictureFormat)
    {
        case FORMATCIF :
            width  = CIF_X; 
            height = CIF_Y;
            break;
        case FORMATQCIF :
            width  = QCIF_X;
            height = QCIF_Y;
            break;
        case FORMATSQCIF :
            width  = SQCIF_X;
            height = SQCIF_Y;
            break;
        case FORMATSIF :
            width  = SIF_X;
            height = SIF_Y;
            break;
        case FORMATQSIF :
            width  = QSIF_X;
            height = QSIF_Y;
            break;
        case FORMATSQSIF :
            width  = SQSIF_X;
            height = SQSIF_Y;
            break;
        case FORMATQQCIF :
            width  = QQCIF_X;
            height = QQCIF_Y;
            break;
        case FORMATSSIF :
            width  = SSIF_X;
            height = SSIF_Y;
            break;
        case FORMATSCIF :
            width  = SCIF_X;
            height = SCIF_Y;
            break;
        default        :    // VGA
            width  = VGA_X;
            height = VGA_Y;
            break;
    }


    if (DeviceContext->CamStatus.PictureCompressing == COMPRESSION0)
    {
        // convert Philips P420 format to Intel I420 format
        TranslateP420ToI420 ((PBYTE) RawFrameBuffer, (PBYTE) FrameBuffer,
                             width, height,
                             DeviceContext->CamStatus.ReleaseNumber);
    }
    else
    {
        // convert Philips PCFx format to Intel I420 format
        TranslatePCFxToI420 ((PBYTE) RawFrameBuffer, (PBYTE) FrameBuffer,
                             width, height,
                             DeviceContext->CamStatus.ReleaseNumber);
    }

    return (ntStatus);
}


//------------------------------------------------------------------------------

/*
 * This routine is called at selection of a new stream
 */

extern NTSTATUS
PHILIPSCAM_StartCodec (PPHILIPSCAM_DEVICE_CONTEXT DeviceContext)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    InitDecoder ();

    if (DeviceContext->CamStatus.ReleaseNumber < SSI_8117_N3)
    {
        int line, pix;

        for (line = 0; line < CIF_Y; line++)
        {
            for (pix = 0; pix < 4; pix++)
            {
                FixGreenbarArray[line][pix] = (WORD) 0x8080;
            }
        }
    }

    return (ntStatus);
}


//------------------------------------------------------------------------------
  
/*
 * This routine is called after stopping a stream.
 * Used resources have to be made free.
 */
   
extern NTSTATUS
PHILIPSCAM_StopCodec(PPHILIPSCAM_DEVICE_CONTEXT DeviceContext)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    return (ntStatus);
}

//------------------------------------------------------------------------------

/*
 * This routine is called by mprpobj.c to announce a framerate selection
 * in CIF mode, eventually resulting in change from compressed <-> uncompressed.
 */

extern NTSTATUS
PHILIPSCAM_FrameRateChanged (PPHILIPSCAM_DEVICE_CONTEXT DeviceContext)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    return (ntStatus);
}

/*******************************************************************************
 *
 * START STATIC METHODS DEFINITIONS
 *
 ******************************************************************************/

#ifdef PIX12_FIX


static void
FixPix12InI420 (PBYTE p, BOOLEAN Compress, int width, int height,
                DWORD camVersion)
{
    int   line;
    PBYTE pStart;

    if (width == SQCIF_X)
    {
        return;
    }

    // only QCIF and CIF have to be fixed

    pStart = p;

    if (Compress)
    {
        for (line = height; line > 0; line--)
        {
            *(p + 0) = *(p + 1);
            *(p + 2) = *(p + 3);

            p += width;
        }
    }
    else
    {
        for (line = height; line > 0; line--)
        {
            *(p + 0) = *(p + 1);
            *(p + 1) = *(p + 2);

            p += width;
        }

        p = pStart + I420_NO_Y (width, height);

        width >>= 1;

        if (camVersion >= SSI_PIX12_FIX)
        {
            for (line = height; line > 0; line--)
            {
                // First all U's then all V's

                *(p + 0) = *(p + 1);

                p += width;
            }
        }
        else
        {
            for (line = height; line > 0; line--)
            {
                // First all U's then all V's

                *(p + 0) = *(p + 2);
                *(p + 1) = *(p + 2);

                p += width;
            }
        }
    }
}
#endif    // PIX12_FIX

//------------------------------------------------------------------------------

    // In the 8117 silicum versions N2 and before, the CIF decompressed
    // picture contains little green bars at the end of the picture.
    // These greenbars are 16 pixels width and 4 pixels height.
    // This bug is fixed in the 3rd silicium version of the 8117 (N3)
    // UV components of last 16 pixels in line : YYYYUU YYYYUU YYYYUU YYYYUU
    //                                           YYYYVV YYYYVV YYYYVV YYYYVV
    // This are 2 blocks
    // Greenbar bug : all V's do have the same value.
    // This value is less then 'VREF_VALUE'
    // pU points to 1st UUUU block, pU + 1 points to 1st VVVV block



static void
Fix16PixGreenbarInI420 (PBYTE pStart, int width)
{
    int     line;
    int     band;
    PWORD   pU;
    PWORD   pV;

#define VREF_VALUE        0x40
#define C_INC    (I420_NO_C_PER_LINE_CIF / sizeof (WORD))

    /* point to start of last 8 V's of first band V line */

    pU = (PWORD) ((PBYTE) pStart + I420_NO_Y_CIF + I420_NO_C_PER_LINE_CIF - 8);
    pV = (PWORD) ((PBYTE) pStart + I420_NO_Y_CIF + I420_NO_U_CIF + I420_NO_C_PER_LINE_CIF - 8);


    for (band = 0; band < NO_BANDS_CIF; band++)
    {
        line = band * 4;

        /*
         * band : UUUU UUUU ...
         *        UUUU UUUU ...
         *        VVVV VVVV ... --> check the last 8 V's for error condition
         *        VVVV VVVV ...
         *
         * V1V2 V3V4 V5V6 V7V8 (last V's in first BLOCK_BAND V line)
         * all V's have to be the same value. This value is < VREF_VALUE
         * If so, a green bar will be visible --> correct with last correct
         * pixel information
         */

        if ( (*(pV + 0) == *(pV + 1)) &&
             (*(pV + 0) == *(pV + 2)) &&
             (*(pV + 0) == *(pV + 3)) &&
            ((*(pV + 0) & 0x00FF) == (((*pV + 0) & 0xFF00) >> 8)) &&
            ((*(pV + 0) & 0x00FF) <  VREF_VALUE))
        {
            *(pU + (C_INC * 0) + 0) = FixGreenbarArray[line + 0][0];
            *(pU + (C_INC * 0) + 1) = FixGreenbarArray[line + 0][1];
            *(pU + (C_INC * 0) + 2) = FixGreenbarArray[line + 0][2];
            *(pU + (C_INC * 0) + 3) = FixGreenbarArray[line + 0][3];

            *(pV + (C_INC * 0) + 0) = FixGreenbarArray[line + 1][0];
            *(pV + (C_INC * 0) + 1) = FixGreenbarArray[line + 1][1];
            *(pV + (C_INC * 0) + 2) = FixGreenbarArray[line + 1][2];
            *(pV + (C_INC * 0) + 3) = FixGreenbarArray[line + 1][3];

            *(pU + (C_INC * 1) + 0) = FixGreenbarArray[line + 2][0];
            *(pU + (C_INC * 1) + 1) = FixGreenbarArray[line + 2][1];
            *(pU + (C_INC * 1) + 2) = FixGreenbarArray[line + 2][2];
            *(pU + (C_INC * 1) + 3) = FixGreenbarArray[line + 2][3];

            *(pV + (C_INC * 1) + 0) = FixGreenbarArray[line + 3][0];
            *(pV + (C_INC * 1) + 1) = FixGreenbarArray[line + 3][1];
            *(pV + (C_INC * 1) + 2) = FixGreenbarArray[line + 3][2];
            *(pV + (C_INC * 1) + 3) = FixGreenbarArray[line + 3][3];
        }
        else
        {
            FixGreenbarArray[line + 0][0] = *(pU + (C_INC * 0) + 0);
            FixGreenbarArray[line + 0][1] = *(pU + (C_INC * 0) + 1);
            FixGreenbarArray[line + 0][2] = *(pU + (C_INC * 0) + 2);
            FixGreenbarArray[line + 0][3] = *(pU + (C_INC * 0) + 3);

            FixGreenbarArray[line + 1][0] = *(pV + (C_INC * 0) + 0);
            FixGreenbarArray[line + 1][1] = *(pV + (C_INC * 0) + 1);
            FixGreenbarArray[line + 1][2] = *(pV + (C_INC * 0) + 2);
            FixGreenbarArray[line + 1][3] = *(pV + (C_INC * 0) + 3);

            FixGreenbarArray[line + 2][0] = *(pU + (C_INC * 1) + 0);
            FixGreenbarArray[line + 2][1] = *(pU + (C_INC * 1) + 1);
            FixGreenbarArray[line + 2][2] = *(pU + (C_INC * 1) + 2);
            FixGreenbarArray[line + 2][3] = *(pU + (C_INC * 1) + 3);

            FixGreenbarArray[line + 3][0] = *(pV + (C_INC * 1) + 0);
            FixGreenbarArray[line + 3][1] = *(pV + (C_INC * 1) + 1);
            FixGreenbarArray[line + 3][2] = *(pV + (C_INC * 1) + 2);
            FixGreenbarArray[line + 3][3] = *(pV + (C_INC * 1) + 3);
        }

        pU += (2 * C_INC);
        pV += (2 * C_INC);
    }
}
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------

/*
 *
 */

static void
TranslateP420ToI420 (PBYTE pInput, PBYTE pOutput, int width, int height,
                     DWORD camVersion)
{
    int    line;
    int    byte;
    int    dxSrc;

    PDWORD pdwSrc;
    PDWORD pdwY;
    PWORD  pwU;
    PWORD  pwV;

    PBYTE  pbSrc;
    PBYTE  pbY;


    if (camVersion == SSI_YGAIN_MUL2)
    {
        // SSI version 4 --> Ygain has to be doubled

        pbSrc = (PBYTE) pInput;
        pbY   = (PBYTE) pOutput;
        pwU   = (PWORD) ((PBYTE) pbY +  (width * height));
        pwV   = (PWORD) ((PBYTE) pwU  + ((width * height) >> 2));

        switch (width)
        {
        case SQSIF_X :
            pbSrc += ((((SQSIF_DY * SQCIF_X) + SQSIF_DX) * 3) / 2);
            dxSrc = ((2 * SQSIF_DX) * 3) / 2;
            break;
        case QSIF_X  :
            pbSrc += ((((QSIF_DY * QCIF_X) + QSIF_DX) * 3) / 2);
            dxSrc = ((2 * QSIF_DX) * 3) / 2;
            break;
        case SIF_X   :
            pbSrc += ((((SIF_DY * CIF_X) + SIF_DX) * 3) / 2);
            dxSrc = ((2 * SIF_DX) * 3) / 2;
            break;
        case QQCIF_X   :
            pbSrc += ((((QQCIF_DY * SQCIF_X) + QQCIF_DX) * 3) / 2);
            dxSrc = ((2 * QQCIF_DX) * 3) / 2;
            break;
        case SSIF_X :       // SSIF || SCIF
			if (height == SSIF_Y) {
              pbSrc += ((((SSIF_DY * CIF_X) + SSIF_DX) * 3) / 2);
              dxSrc = ((2 * SSIF_DX) * 3) / 2;
			}else{
              pbSrc += ((((SCIF_DY * CIF_X) + SCIF_DX) * 3) / 2);
              dxSrc = ((2 * SCIF_DX) * 3) / 2;
            }
            break;
        default    :    // xxCIF
            dxSrc = 0;
            break;
        }

        for (line = height >> 1; line > 0; line--)
        {
            for (byte = NO_YYYYCC_PER_LINE(width); byte > 0; byte--)
            {
                *pbY++ = (*pbSrc < 0x7F) ? (*pbSrc << 1) : 0xFF;
                pbSrc++;
                *pbY++ = (*pbSrc < 0x7F) ? (*pbSrc << 1) : 0xFF;
                pbSrc++;
                *pbY++ = (*pbSrc < 0x7F) ? (*pbSrc << 1) : 0xFF;
                pbSrc++;
                *pbY++ = (*pbSrc < 0x7F) ? (*pbSrc << 1) : 0xFF;
                pbSrc++;

                *pwU++ = (WORD) (* (PWORD) pbSrc);
                pbSrc += 2;
            }

            pbSrc += dxSrc;

            for (byte = NO_YYYYCC_PER_LINE(width); byte > 0; byte--)
            {
                *pbY++ = (*pbSrc < 0x7F) ? (*pbSrc << 1) : 0xFF;
                pbSrc++;
                *pbY++ = (*pbSrc < 0x7F) ? (*pbSrc << 1) : 0xFF;
                pbSrc++;
                *pbY++ = (*pbSrc < 0x7F) ? (*pbSrc << 1) : 0xFF;
                pbSrc++;
                *pbY++ = (*pbSrc < 0x7F) ? (*pbSrc << 1) : 0xFF;
                pbSrc++;

                *pwV++ = (WORD) (* (PWORD) pbSrc);
                pbSrc += 2;
            }

            pbSrc += dxSrc;
        }
    }
    else    // NO_YGAIN_MULTIPLY
    {
        pdwY  = (PDWORD) pOutput;
        pwU   = (PWORD) ((PBYTE) pdwY +  (width * height));
        pwV   = (PWORD) ((PBYTE) pwU  + ((width * height) >> 2));

        if (width == QQCIF_X)
        {
            pbSrc = (PBYTE) (pInput + ((((QQCIF_DY * SQCIF_X) + QQCIF_DX) * 3) / 2));
            dxSrc = ((2 * QQCIF_DX) * 3) / 2;

            for (line = height >> 1; line > 0; line--)
            {
                for (byte = NO_YYYYCC_PER_LINE(width); byte > 0; byte--)
                {
                    *pdwY++ = *((PDWORD) pbSrc)++;
                    *pwU++ = (WORD) (* (PWORD) pbSrc);
                    pbSrc += 2;
                }

                pbSrc += dxSrc;

                for (byte = NO_YYYYCC_PER_LINE(width); byte > 0; byte--)
                {
                    *pdwY++ = *((PDWORD) pbSrc)++;
                    *pwV++ = (WORD) (* (PWORD) pbSrc);
                    pbSrc += 2;
                }

                pbSrc += dxSrc;
            }
        }
        else
        {
            pdwSrc = (PDWORD) pInput;

            switch (width)
            {
            case SQSIF_X :
                pdwSrc += (((((SQSIF_DY * SQCIF_X) + SQSIF_DX) * 3) / 2) / sizeof (DWORD));
                dxSrc = (((2 * SQSIF_DX) * 3) / 2) / sizeof (DWORD);
                break;
            case QSIF_X  :
                pdwSrc += (((((QSIF_DY * QCIF_X) + QSIF_DX) * 3) / 2) / sizeof (DWORD));
                dxSrc = (((2 * QSIF_DX) * 3) / 2) / sizeof (DWORD);
                break;
            case SIF_X   :
                pdwSrc += (((((SIF_DY * CIF_X) + SIF_DX) * 3) / 2) / sizeof (DWORD));
                dxSrc = (((2 * SIF_DX) * 3) / 2) / sizeof (DWORD);
                break;
            case SSIF_X :    // SSIF || SCIF
			    if (height == SSIF_Y) {
                  pdwSrc += (((((SSIF_DY * CIF_X) + SSIF_DX) * 3) / 2) / sizeof (DWORD));
                  dxSrc = (((2 * SSIF_DX) * 3) / 2) / sizeof (DWORD);
				}else{
                  pdwSrc += (((((SCIF_DY * CIF_X) + SCIF_DX) * 3) / 2) / sizeof (DWORD));
                  dxSrc = (((2 * SCIF_DX) * 3) / 2) / sizeof (DWORD);
				}
                break;
             default    :    // xxCIF
                dxSrc = 0;
                break;
            }

            for (line = height >> 1; line > 0; line--)
            {
                for (byte = NO_YYYYCC_PER_LINE(width); byte > 0; byte--)
                {
                    *pdwY++ = *pdwSrc++;
                    *pwU++ = (WORD) (* (PWORD) pdwSrc);
                    pdwSrc = (PDWORD) ((PBYTE) pdwSrc + 2);
                }

                pdwSrc += dxSrc;

                for (byte = NO_YYYYCC_PER_LINE(width); byte > 0; byte--)
                {
                    *pdwY++ = *pdwSrc++;
                    *pwV++ = (WORD) (* (PWORD) pdwSrc);
                    pdwSrc = (PDWORD) ((PBYTE) pdwSrc + 2);
                }

                pdwSrc += dxSrc;
            }
        }
    }

#ifdef PIX12_FIX
    if (width == CIF_X || width == QCIF_X || width == SQCIF_X)
    {
        FixPix12InI420 (pOutput, FALSE, width, height, camVersion);
    }
#endif
}



/*
 ===========================================================================
 */

static void
TranslatePCFxToI420 (PBYTE pInput, PBYTE pOutput, int width, int height,
                     DWORD camVersion)
{
    int     band;
    int     line;
    int     byte;
    PBYTE   pSrc;
    PDWORD  pYDst;
    PDWORD  pCDst;

    PDWORD  pSIF_Y;
    PDWORD  pSIF_C;
    /*
     * For formats != 352x288, cropping has to be done.
     * The formats 320x240 and 240x180 can be derived from the 352x288 format.
     * The compressed data consists of 72 bands. A band contains the data for
     * 4 uncompressed lines. For the not 352x240 formats, the first 6 bands or
     * first 13 bands (320x240 or 240x180) of compressed data can be skipped. 
     * This will be the cropping in the Y-direction.
     * One band is 528 bytes big for 4x compressed mode and 704 bytes big for
     * 3x compressed mode. It's dependent of the camera version which
     * compression mode will be selected.
     * For the not 352x288 formats, the uncompressed data is temporary stored
     * in the first not used bands.
     * One uncompressed band consists of 4x352=1408 bytes of Y followed by
     * 2x176=352 bytes of U and followed by 2x176 bytes of V.
     * This is a total of 2112 uncompressed bytes. So there's enough place
     * for this temporary storage (6x528-2112=1056 bytes left worst case)
     * This temporary uncompressed data is then cropped in the X direction.
     * The result is written to the buffer pointed by 'pOutput'
     */

    if (width == CIF_X)
    {
        pSrc  = pInput;
        pYDst = (PDWORD) pOutput;
        pCDst = (PDWORD) pOutput + (I420_NO_Y_CIF / sizeof (DWORD));
        band = NO_BANDS_CIF;
    }
    else
    {
        pSrc   = pInput;
        pYDst  = (PDWORD) pInput;
        pCDst  = (PDWORD) pInput + (I420_NO_Y_PER_BAND_CIF / sizeof (DWORD));
        pSIF_Y = (PDWORD) pOutput;

        if (width == SIF_X)
        {
            pSIF_C = (PDWORD) pOutput + (I420_NO_Y_SIF / sizeof (DWORD));

            if (camVersion >= SSI_CIF3)
            {
                pSrc += ((SIF_DY / NO_LINES_IN_BAND) * BytesPerBandCIF3);
            }
            else
            {
                pSrc += ((SIF_DY / NO_LINES_IN_BAND) * BytesPerBandCIF4);
            }

            band = NO_BANDS_SIF;
        }
        else    // width == SSIF_X || width == SCIF
        {
			if (height == SSIF_Y) {
              pSIF_C = (PDWORD) pOutput + (I420_NO_Y_SSIF / sizeof (DWORD));

            // 13,5 bands to skip in start en 13,5 bands to skip at end
            // To make it easier : 13 bands to skip in start and 14 bytes at end

              if (camVersion >= SSI_CIF3)
			  {
                pSrc += (((SSIF_DY - 2) / NO_LINES_IN_BAND) * BytesPerBandCIF3);
			  }
              else
			  {
                pSrc += (((SSIF_DY - 2) / NO_LINES_IN_BAND) * BytesPerBandCIF4);
			  }

              band = NO_BANDS_SSIF;
            }else{
              pSIF_C = (PDWORD) pOutput + (I420_NO_Y_SCIF / sizeof (DWORD));

              if (camVersion >= SSI_CIF3)
			  {
                pSrc += (((SCIF_DY - 2) / NO_LINES_IN_BAND) * BytesPerBandCIF3);
			  }
              else
			  {
                pSrc += (((SCIF_DY - 2) / NO_LINES_IN_BAND) * BytesPerBandCIF4);
			  }

              band = NO_BANDS_SCIF;
            }
        }
    }

    for (; band > 0; band--)
    {
        DcDecompressBandToI420 (pSrc, (PBYTE) pYDst, camVersion,
                                Y_BLOCK_BAND, (BOOLEAN) (width != CIF_X));
        
        if (width == CIF_X)
        {
            pYDst += (I420_NO_Y_PER_BAND_CIF / sizeof (DWORD));
        }
        else
        {
            if (width == SIF_X)
            {
                pYDst += (SIF_DX / sizeof (DWORD));

                for (line = NO_LINES_IN_BAND; line > 0; line--)
                {
                    for (byte = (SIF_X / sizeof (DWORD)); byte > 0; byte--)
                    {
                        *pSIF_Y++ = *pYDst++;
                    }

                    pYDst += (( 2 * SIF_DX) / sizeof (DWORD));
                }

                pYDst = (PDWORD) pInput;
            }
            else    // width == SSIF_X || width == SCIF_X
            {
			  if ( height == SSIF_Y ){
                pYDst += (SSIF_DX / sizeof (DWORD));

                for (line = NO_LINES_IN_BAND ; line > 0; line--)
                {
                    for (byte = (SSIF_X / sizeof (DWORD)); byte > 0; byte--)
                    {
                        *pSIF_Y++ = *pYDst++;
                    }

                    pYDst += (( 2 * SSIF_DX) / sizeof (DWORD));
                }

                pYDst = (PDWORD) pInput;
              }else{
                pYDst += (SCIF_DX / sizeof (DWORD));

                for (line = NO_LINES_IN_BAND ; line > 0; line--)
                {
                    for (byte = (SCIF_X / sizeof (DWORD)); byte > 0; byte--)
                    {
                        *pSIF_Y++ = *pYDst++;
                    }

                    pYDst += (( 2 * SCIF_DX) / sizeof (DWORD));
                }

                pYDst = (PDWORD) pInput;
              } 
            }
        }

        DcDecompressBandToI420 (pSrc, (PBYTE) pCDst, camVersion,
                                UV_BLOCK_BAND, (BOOLEAN) (width != CIF_X));

        if (width == CIF_X)
        {
            pCDst += (I420_NO_U_PER_BAND_CIF / sizeof (DWORD));
        }
        else
        {
            if (width == SIF_X)
            {
                pCDst += ((SIF_DX / 2) / sizeof (DWORD));

                for (line = (NO_LINES_IN_BAND / 2); line > 0; line--)
                {
                    for (byte = ((SIF_X / 2) / sizeof (DWORD)); byte > 0; byte--)
                    {
                        *pSIF_C++ = *pCDst++;
                    }

                    pCDst += ((2 * (SIF_DX / 2)) / sizeof (DWORD));
                }

                pSIF_C += ((I420_NO_U_SIF - I420_NO_U_PER_BAND_SIF) / sizeof (DWORD));

                for (line = (NO_LINES_IN_BAND / 2); line > 0; line--)
                {
                    for (byte = ((SIF_X / 2) / sizeof (DWORD)); byte > 0; byte--)
                    {
                        *pSIF_C++ = *pCDst++;
                    }

                    pCDst += ((2 * (SIF_DX / 2)) / sizeof (DWORD));
                }

                pCDst   = (PDWORD) pInput + (I420_NO_Y_PER_BAND_CIF / sizeof (DWORD));
                pSIF_C -= (I420_NO_U_SIF / sizeof (DWORD));
            }
            else    // width == SSIF_X || width == SCIF_X
            {
			  if  (height == SSIF_Y){
                pCDst += ((SSIF_DX / 2) / sizeof (DWORD));

                for (line = (NO_LINES_IN_BAND / 2); line > 0; line--)
                {
                    for (byte = ((SSIF_X / 2) / sizeof (DWORD)); byte > 0; byte--)
                    {
                        *pSIF_C++ = *pCDst++;
                    }

                    pCDst += ((2 * (SSIF_DX / 2)) / sizeof (DWORD));
                }

                pSIF_C += ((I420_NO_U_SSIF - I420_NO_U_PER_BAND_SSIF) / sizeof (DWORD));

                for (line = (NO_LINES_IN_BAND / 2); line > 0; line--)
                {
                    for (byte = ((SSIF_X / 2) / sizeof (DWORD)); byte > 0; byte--)
                    {
                        *pSIF_C++ = *pCDst++;
                    }

                    pCDst += ((2 * (SSIF_DX / 2)) / sizeof (DWORD));
                }

                pCDst   = (PDWORD) pInput + (I420_NO_Y_PER_BAND_CIF / sizeof (DWORD));
                pSIF_C -= (I420_NO_U_SSIF / sizeof (DWORD));
              }else{
                pCDst += ((SCIF_DX / 2) / sizeof (DWORD));

                for (line = (NO_LINES_IN_BAND / 2); line > 0; line--)
                {
                    for (byte = ((SCIF_X / 2) / sizeof (DWORD)); byte > 0; byte--)
                    {
                        *pSIF_C++ = *pCDst++;
                    }

                    pCDst += ((2 * (SCIF_DX / 2)) / sizeof (DWORD));
                }

                pSIF_C += ((I420_NO_U_SCIF - I420_NO_U_PER_BAND_SCIF) / sizeof (DWORD));

                for (line = (NO_LINES_IN_BAND / 2); line > 0; line--)
                {
                    for (byte = ((SCIF_X / 2) / sizeof (DWORD)); byte > 0; byte--)
                    {
                        *pSIF_C++ = *pCDst++;
                    }

                    pCDst += ((2 * (SCIF_DX / 2)) / sizeof (DWORD));
                }

                pCDst   = (PDWORD) pInput + (I420_NO_Y_PER_BAND_CIF / sizeof (DWORD));
                pSIF_C -= (I420_NO_U_SCIF / sizeof (DWORD));

			  }	  
            }
        }

        pSrc += (camVersion >= SSI_CIF3) ? BytesPerBandCIF3 : BytesPerBandCIF4;
    }

    if (width == CIF_X)
    {
        if (camVersion < SSI_8117_N3)
        {
            Fix16PixGreenbarInI420 (pOutput, width);
        }
#ifdef PIX12_FIX
        FixPix12InI420 (pOutput, TRUE, width, height, camVersion);
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mcamdrv.h ===
#ifndef __MCAMDRV_H__
#define __MCAMDRV_H__

/*++

Copyright (c) 1997 1998,  Philips I&C

Module Name:

   mcamdrv.h

Abstract:

   driver for the philips camera.

Author:

	Paul Oosterhof

Environment:

   Kernel mode only


Revision History:

Date        Change
sept.22 98  Optimized for NT5

--*/

#include <strmini.h>
#include <ksmedia.h>

#include "usbdi.h"
#include "usbcamdi.h"

#include "mprpobj.h"
#include "mprpobjx.h"

//--- Compiler switches:------------------------------

                    // DEFINES FOR CODEC
// Copy for each line pixel 3 to pixel 2, pixel 2 to pixel 1.
#define PIX12_FIX

//--- end Compiler switches:------------------------------

#define DRIVERVERSION 001

                    // SSI numbers + added functionality

#define SSI_INITIAL         1
#define SSI_AUDIO_8KHZ      2    // 8kHz audio i.s.o. 11kHz
#define SSI_STRINGS         3    // strings added
#define SSI_YGAIN_MUL2      4    // Ygain divided by two in camera. Only this version !!
#define SSI_CIF3            5    // PCF4 substituted by PCF3
#define SSI_PIX12_FIX       5    // vertical black line pixel 1/2 change
#define SSI_8117_N3         8    // new N3 silicium for 8117


typedef struct _PHILIPSCAM_CAMSTATUS {
	DWORD  ReleaseNumber;
    USHORT SensorType;
    USHORT PictureFormat;
	USHORT PictureFrameRate;
	USHORT PictureCompressing;
	GUID   PictureSubFormat;					// added RMR
    } PHILIPSCAM_CAMSTATUS, *PPHILIPSCAM_CAMSTATUS;

typedef struct _PHILIPSCAM_DEVICE_CONTEXT {
    ULONG Sig;
	ULONG EmptyPacketCounter;
	PHILIPSCAM_CAMSTATUS CamStatus;
	PHILIPSCAM_CAMSTATUS PreviousCamStatus;
	BOOLEAN FrrSupported[9];
    // internal counters
    ULONG FrameLength;
    PUSBD_INTERFACE_INFORMATION Interface;
    } PHILIPSCAM_DEVICE_CONTEXT, *PPHILIPSCAM_DEVICE_CONTEXT;

typedef struct _PHILIPSCAM_FRAME_CONTEXT {
    ULONG Sig;
    ULONG USBByteCounter;    
} PHILIPSCAM_FRAME_CONTEXT, *PPHILIPSCAM_FRAME_CONTEXT;

#define PHILIPSCAM_DEVICE_SIG 0x45544e49     //"INTE"

#if DBG
#define ASSERT_DEVICE_CONTEXT(d) ASSERT((d)->Sig == PHILIPSCAM_DEVICE_SIG)
#else
#define ASSERT_DEVICE_CONTEXT(d) 
#endif

#define PHILIPSCAM_DEFAULT_FRAME_RATE     15
#define PHILIPSCAM_MAX_FRAME_RATE 24
#define PHILIPSCAM_SYNC_PIPE    0
#define PHILIPSCAM_DATA_PIPE    1

#define ULTRA_TRACE 3
#define MAX_TRACE 2
#define MIN_TRACE 1

#define CIF_X   352
#define CIF_Y   288
#define QCIF_X  176
#define QCIF_Y  144
#define SQCIF_X 128
#define SQCIF_Y  96
#define QQCIF_X  88
#define QQCIF_Y	 72
#define VGA_X   640
#define VGA_Y   480
#define SIF_X   320
#define SIF_Y   240
#define SSIF_X  240
#define SSIF_Y  180
#define QSIF_X  160
#define QSIF_Y  120
#define SQSIF_X  80
#define SQSIF_Y	 60
#define SCIF_X  240
#define SCIF_Y  176

#define ALT_INTERFACE_0    0

typedef enum {
   FORMATCIF,
   FORMATQCIF,
   FORMATSQCIF,
   FORMATQQCIF,
   FORMATVGA,
   FORMATSIF,
   FORMATSSIF,
   FORMATQSIF,
   FORMATSQSIF,
   FORMATSCIF
} PHFORMAT;

typedef enum {
   FRRATEVGA,
   FRRATE375,
   FRRATE5,
   FRRATE75,
   FRRATE10,
   FRRATE12,
   FRRATE15,
   FRRATE20,
   FRRATE24
} PHFRAMERATE;

typedef enum{
   COMPRESSION0,
   COMPRESSION3,
   COMPRESSION4
} PHCOMPRESSION;

typedef enum{
   SUBTYPEP420,
   SUBTYPEI420,
   SUBTYPEIYUV
} PHSUBTYPE;

#if DBG
extern ULONG PHILIPSCAM_DebugTraceLevel;

#define PHILIPSCAM_KdPrint(_t_, _x_) \
    if (PHILIPSCAM_DebugTraceLevel >= _t_) { \
	DbgPrint("PHILCAM1.SYS: "); \
	DbgPrint _x_ ;\
    }
    
PCHAR
FRString (
    USHORT index
);

#ifdef NTKERN
#define TRAP()  _asm {int 3}
#define TEST_TRAP() _asm {int 3}
#define TRAP_ERROR(e) if (!NT_SUCCESS(e)) { _asm {int 3} }
#else
#define TRAP()  DbgBreakPoint()
#define TEST_TRAP() DbgBreakPoint()
#define TRAP_ERROR(e) if (!NT_SUCCESS(e)) { DbgBreakPoint(); }
#endif
#else
#define PHILIPSCAM_KdPrint(_t_, _x_)
#define TEST_TRAP()
#define TRAP()
#endif /* DBG */

NTSTATUS
PHILIPSCAM_Initialize(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );

NTSTATUS
PHILIPSCAM_UnInitialize(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );    

NTSTATUS
PHILIPSCAM_StartVideoCapture(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );

NTSTATUS
PHILIPSCAM_StopVideoCapture(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );    

ULONG
PHILIPSCAM_ProcessUSBPacket(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PVOID CurrentFrameContext,
    PUSBD_ISO_PACKET_DESCRIPTOR SyncPacket,
    PVOID SyncBuffer,
    PUSBD_ISO_PACKET_DESCRIPTOR DataPacket,
    PVOID DataBuffer,
    PBOOLEAN FrameComplete,
    PBOOLEAN NextFrameIsStill
    );

VOID
PHILIPSCAM_NewFrame(
    PVOID DeviceContext,
    PVOID FrameContext
    );

NTSTATUS
PHILIPSCAM_ProcessRawVideoFrame(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PVOID FrameContext,
    PVOID FrameBuffer,
    ULONG FrameLength,
    PVOID RawFrameBuffer,
    ULONG RawFrameLength,
    ULONG NumberOfPackets,
    PULONG BytesReturned
    );

NTSTATUS
PHILIPSCAM_Configure(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PUSBD_INTERFACE_INFORMATION Interface,
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    PLONG DataPipeIndex,
    PLONG SyncPipeIndex
    );    

NTSTATUS
PHILIPSCAM_SaveState(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );

NTSTATUS
PHILIPSCAM_RestoreState(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );    

NTSTATUS
PHILIPSCAM_ReadRegistry(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );    

NTSTATUS
PHILIPSCAM_AllocateBandwidth(
    IN PDEVICE_OBJECT BusDeviceObject,
    IN PVOID DeviceContext,
    OUT PULONG RawFrameLength,
    IN PVOID Format           
    );    

NTSTATUS
PHILIPSCAM_FreeBandwidth(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );      


NTSTATUS
PHILIPSCAM_CameraToDriverDefaults(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );


NTSTATUS
PHILIPSCAM_SaveControlsToRegistry(
PDEVICE_OBJECT BusDeviceObject,
    PVOID pDeviceContext
    );


NTSTATUS
PHILIPSCAM_PropertyRequest(
    BOOLEAN SetProperty,
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PVOID PropertyContext
    );


VOID STREAMAPI
PHILIPSCAM_ReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PVOID DeviceContext,
    IN PBOOLEAN Completed
    );

VOID STREAMAPI
PHILIPSCAM_ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PVOID DeviceContext,
    IN PBOOLEAN Completed
    );

BOOL 
AdapterVerifyFormat(
    PKS_DATAFORMAT_VIDEOINFOHEADER pKSDataFormatToVerify, 
    int StreamNumber
    );    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mdecoder.h ===
/*++                            
Copyright (c) 1996, 1997  Philips B.V. CE-VCM

Module Name:

   mdecoder.h

Abstract:

   This module converts the compressed video data to uncompressed video data.

Original Author:

   Ronald v.d.Meer


Environment:

   Kernel mode only


Revision History:

Date       Change
14-04-1998 Initial version 

--*/

#ifndef __MDECODER_H__
#define __MDECODER_H__

#include <stdio.h>
#include "mcamdrv.h"
#include "resource.h"


/*******************************************************************************
 *
 * START DEFINES
 *
 ******************************************************************************/

#define BytesPerBandCIF3  704
#define BytesPerBandCIF4  528

#define BLOCK_BAND_WIDTH  ((CIF_X * 3) / 2)

#define Y_BLOCK_BAND      TRUE
#define UV_BLOCK_BAND     FALSE

/* defines for I420 space */

#define I420_NO_Y_PER_LINE_CIF    (CIF_X)
#define I420_NO_C_PER_LINE_CIF    (CIF_X >> 1)

#define I420_NO_Y_PER_LINE_SIF    (SIF_X)
#define I420_NO_C_PER_LINE_SIF    (SIF_X >> 1)

#define I420_NO_Y_PER_LINE_SSIF   (SSIF_X)
#define I420_NO_C_PER_LINE_SSIF   (SSIF_X >> 1)

#define I420_NO_Y_PER_LINE_SCIF   (SCIF_X)
#define I420_NO_C_PER_LINE_SCIF   (SCIF_X >> 1)

#define I420_NO_Y_PER_BAND_CIF    (4 * CIF_X)
#define I420_NO_U_PER_BAND_CIF    (2 * (CIF_X >> 1))
#define I420_NO_V_PER_BAND_CIF    (2 * (CIF_X >> 1))
#define I420_NO_C_PER_BAND_CIF    (CIF_X >> 1)

#define I420_NO_Y_PER_BAND_SIF    (4 * SIF_X)
#define I420_NO_U_PER_BAND_SIF    (2 * (SIF_X >> 1))
#define I420_NO_V_PER_BAND_SIF    (2 * (SIF_X >> 1))
#define I420_NO_C_PER_BAND_SIF    (SIF_X >> 1)

#define I420_NO_Y_PER_BAND_SSIF   (4 * SSIF_X)
#define I420_NO_U_PER_BAND_SSIF   (2 * (SSIF_X >> 1))
#define I420_NO_V_PER_BAND_SSIF   (2 * (SSIF_X >> 1))
#define I420_NO_C_PER_BAND_SSIF   (SSIF_X >> 1)

#define I420_NO_Y_PER_BAND_SCIF   (4 * SCIF_X)
#define I420_NO_U_PER_BAND_SCIF   (2 * (SCIF_X >> 1))
#define I420_NO_V_PER_BAND_SCIF   (2 * (SCIF_X >> 1))
#define I420_NO_C_PER_BAND_SCIF   (SCIF_X >> 1)

/*******************************************************************************
 *
 * START FUNCTION DECLARATIONS
 *
 ******************************************************************************/

extern void InitDecoder ();


extern void DcDecompressBandToI420 (PBYTE pSrc, PBYTE pDst, DWORD camVersion,
                                    BOOLEAN YBlockBand, BOOLEAN Cropping);

#endif  // __MDECODER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mprpdef.c ===
/*

Copyright (c) 1997 1998 PHILIPS  I&C

Module Name:  mprpdef.c.c

Abstract:     property set definition

Author:       Michael verberne

Revision History:

Date        Reason

Sept.22, 98 Optimized for NT5 
Nov. 30, 98 VID and PID added as custom properties


 * This file defines the following property sets:
 *
 * PROPSETID_VIDCAP_VIDEOPROCAMP
 * PROPSETID_VIDCAP_CAMERACONTROL
 * PROPSETID_PHILIPS_CUSTOM_PROP
 *
*/
#include "mwarn.h"
#include "wdm.h"
#include <strmini.h>
#include <ks.h>
#include <ksmedia.h>
#include "mprpobj.h"
#include "mprpobjx.h"
#include "mprpdef.h"


/*--------------------------------------------------------------------------  
 * PROPSETID_VIDCAP_VIDEOPROCAMP 
 *
 * Supported:
 *
 * Brightness, 
 * Contrast, 
 * Gamma
 * Color Enable 
 * BackLightCompensation, 
 *
 *--------------------------------------------------------------------------*/  

/*
 * Brightness
 */
KSPROPERTY_STEPPING_LONG Brightness_RangeAndStep [] = 
{
    {
        BRIGHTNESS_DELTA,				// SteppingDelta (range / steps)
        0,								// Reserved
        BRIGHTNESS_MIN,					// Minimum in (IRE * 100) units
        BRIGHTNESS_MAX					// Maximum in (IRE * 100) units
    }
};

LONG Brightness_Default = 15;

KSPROPERTY_MEMBERSLIST Brightness_MembersList [] = 
{
    {
		{
		    KSPROPERTY_MEMBER_RANGES,
			sizeof (Brightness_RangeAndStep),
			SIZEOF_ARRAY (Brightness_RangeAndStep),
			0
		},
		(PVOID) Brightness_RangeAndStep
	},
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (Brightness_Default),
            sizeof (Brightness_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &Brightness_Default,
    }    
};

KSPROPERTY_VALUES Brightness_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (Brightness_MembersList),
    Brightness_MembersList
};

/*
 * Contrast
 */
KSPROPERTY_STEPPING_LONG Contrast_RangeAndStep [] = 
{
    {
		CONTRAST_DELTA,					// SteppingDelta
		0,								// Reserved
		CONTRAST_MIN,					// Minimum 
		CONTRAST_MAX					// Maximum 
    }
};

LONG Contrast_Default = 15;

KSPROPERTY_MEMBERSLIST Contrast_MembersList [] = 
{
    {
		{
			KSPROPERTY_MEMBER_RANGES,
			sizeof (Contrast_RangeAndStep),
			SIZEOF_ARRAY (Contrast_RangeAndStep),
			0
		},
		(PVOID) Contrast_RangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (Contrast_Default),
            sizeof (Contrast_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &Contrast_Default,
    }    
};

KSPROPERTY_VALUES Contrast_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (Contrast_MembersList),
    Contrast_MembersList
};

/* 
 * Gamma
 */
KSPROPERTY_STEPPING_LONG Gamma_RangeAndStep [] = 
{
    {
		GAMMA_DELTA,					// SteppingDelta
		0,								// Reserved
		GAMMA_MIN,						// Minimum 
		GAMMA_MAX						// Maximum 
    }
};

LONG Gamma_Default = 15;

KSPROPERTY_MEMBERSLIST Gamma_MembersList [] = 
{
    {
	{
	    KSPROPERTY_MEMBER_RANGES,
	    sizeof (Gamma_RangeAndStep),
	    SIZEOF_ARRAY (Gamma_RangeAndStep),
	    0
	},
	(PVOID) Gamma_RangeAndStep
    },    
    {
	    {
		    KSPROPERTY_MEMBER_VALUES,
            sizeof (Gamma_Default),
            sizeof (Gamma_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &Gamma_Default,
    }    
};

KSPROPERTY_VALUES Gamma_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (Gamma_MembersList),
    Gamma_MembersList
};

/*
 * ColorEnable
 */
KSPROPERTY_STEPPING_LONG ColorEnable_RangeAndStep [] = 
{
    {
		COLORENABLE_DELTA,				// SteppingDelta
		0,								// Reserved
		COLORENABLE_MIN,				// Minimum 
		COLORENABLE_MAX					// Maximum 
    }
};

LONG ColorEnable_Default = 1;

KSPROPERTY_MEMBERSLIST ColorEnable_MembersList [] = 
{
    {
	{
	    KSPROPERTY_MEMBER_RANGES,
	    sizeof (ColorEnable_RangeAndStep),
	    SIZEOF_ARRAY (ColorEnable_RangeAndStep),
	    0
	},
	(PVOID) ColorEnable_RangeAndStep
    },    
    {
	    {
		    KSPROPERTY_MEMBER_VALUES,
            sizeof (ColorEnable_Default),
            sizeof (ColorEnable_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &ColorEnable_Default,
    }    
};

KSPROPERTY_VALUES ColorEnable_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (ColorEnable_MembersList),
    ColorEnable_MembersList
};

/*
 * BackLight Compensation
 */
KSPROPERTY_STEPPING_LONG BackLight_Compensation_RangeAndStep [] = 
{
    {
		BACKLIGHT_COMPENSATION_DELTA,	// SteppingDelta
		0,								// Reserved
		BACKLIGHT_COMPENSATION_MIN,		// Minimum 
		BACKLIGHT_COMPENSATION_MAX		// Maximum 
    }
};

LONG BackLight_Compensation_Default = 1;

KSPROPERTY_MEMBERSLIST BackLight_Compensation_MembersList [] = 
{
    {
	{
	    KSPROPERTY_MEMBER_RANGES,
	    sizeof (BackLight_Compensation_RangeAndStep),
	    SIZEOF_ARRAY (BackLight_Compensation_RangeAndStep),
	    0
	},
	(PVOID) BackLight_Compensation_RangeAndStep
    },    
    {
	    {
		    KSPROPERTY_MEMBER_VALUES,
            sizeof (BackLight_Compensation_Default),
            sizeof (BackLight_Compensation_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &BackLight_Compensation_Default,
    }    
};

KSPROPERTY_VALUES BackLight_Compensation_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (BackLight_Compensation_MembersList),
    BackLight_Compensation_MembersList
};

/*
 * Proc Amp propertyset
 */
DEFINE_KSPROPERTY_TABLE(VideoProcAmpProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
		TRUE,                                   // GetSupported or Handler
		sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
		sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
		TRUE,                                   // SetSupported or Handler
		&Brightness_Values,                     // Values
		0,                                      // RelationsCount
		NULL,                                   // Relations
		NULL,                                   // SupportHandler
		sizeof(ULONG)                           // SerializedSize
    ),	

    DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_VIDEOPROCAMP_CONTRAST,
		TRUE,                                   // GetSupported or Handler
		sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
		sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
		TRUE,                                   // SetSupported or Handler
		&Contrast_Values,                       // Values
		0,                                      // RelationsCount
		NULL,                                   // Relations
		NULL,                                   // SupportHandler
		sizeof(ULONG)                           // SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_VIDEOPROCAMP_GAMMA,
		TRUE,                                   // GetSupported or Handler
		sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
		sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
		TRUE,                                   // SetSupported or Handler
		&Gamma_Values,                          // Values
		0,                                      // RelationsCount
		NULL,                                   // Relations
		NULL,                                   // SupportHandler
		sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_VIDEOPROCAMP_COLORENABLE,
		TRUE,                                   // GetSupported or Handler
		sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
		sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
		TRUE,                                   // SetSupported or Handler
		&ColorEnable_Values,					// Values
		0,                                      // RelationsCount
		NULL,                                   // Relations
		NULL,                                   // SupportHandler
		sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,
		TRUE,                                   // GetSupported or Handler
		sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
		sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
		TRUE,                                   // SetSupported or Handler
		&BackLight_Compensation_Values,			// Values
		0,                                      // RelationsCount
		NULL,                                   // Relations
		NULL,                                   // SupportHandler
		sizeof(ULONG)                           // SerializedSize
    )
};


/*--------------------------------------------------------------------------  
 * PROPSETID_PHILIPS_CUSTOM_PROP
 *
 * Supported:
 *
 * WhiteBalance Mode, 
 * WhiteBalance Speed,
 * WhiteBalance Delay, 
 * WhiteBalance Red Gain, 
 * WhiteBalance Blue Gain, 
 * AutoExposure ControlSpeed
 * AutoExposure Flickerless
 * AutoExposure Shutter Mode
 * AutoExposure Shutter Speed
 * AutoExposure Shutter Status
 * AutoExposure AGC Mode
 * AutoExposure AGC Speed
 * DriverVersion
 * Framerate, 
 * Video Format
 * SensorType
 * VideoCompression,
 * Defaults
 * Release Number
 * VendorId
 * ProductId
 *
 *--------------------------------------------------------------------------*/  

/*
 * White balance Mode
 */
LONG WB_Mode_Default = KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_AUTO;

KSPROPERTY_MEMBERSLIST WB_Mode_MembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (WB_Mode_Default),
            sizeof (WB_Mode_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &WB_Mode_Default,
    }    
};

KSPROPERTY_VALUES WB_Mode_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (WB_Mode_MembersList),
    WB_Mode_MembersList
};


/*
 * White balance Speed
 */
KSPROPERTY_STEPPING_LONG WB_Speed_RangeAndStep [] = 
{
    {
		WB_SPEED_DELTA,		// SteppingDelta
		0,					// Reserved
		WB_SPEED_MIN,		// Minimum 
		WB_SPEED_MAX		// Maximum 
    }
};

LONG WB_Speed_Default = 15;

KSPROPERTY_MEMBERSLIST WB_Speed_MembersList [] = 
{
    {
		{
			KSPROPERTY_MEMBER_RANGES,
			sizeof (WB_Speed_RangeAndStep),
			SIZEOF_ARRAY (WB_Speed_RangeAndStep),
			0
		},
		(PVOID) WB_Speed_RangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (WB_Speed_Default),
            sizeof (WB_Speed_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &WB_Speed_Default,
    }    
};

KSPROPERTY_VALUES WB_Speed_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (WB_Speed_MembersList),
    WB_Speed_MembersList
};


/*
 * White balance Delay
 */
KSPROPERTY_STEPPING_LONG WB_Delay_RangeAndStep [] = 
{
    {
		WB_DELAY_DELTA,		// SteppingDelta
		0,					// Reserved
		WB_DELAY_MIN,		// Minimum 
		WB_DELAY_MAX		// Maximum 
    }
};

LONG WB_Delay_Default = 32;

KSPROPERTY_MEMBERSLIST WB_Delay_MembersList [] = 
{
    {
		{
			KSPROPERTY_MEMBER_RANGES,
			sizeof (WB_Delay_RangeAndStep),
			SIZEOF_ARRAY (WB_Delay_RangeAndStep),
			0
		},
		(PVOID) WB_Delay_RangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (WB_Delay_Default),
            sizeof (WB_Delay_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &WB_Delay_Default,
    }    
};

KSPROPERTY_VALUES WB_Delay_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (WB_Delay_MembersList),
    WB_Delay_MembersList
};

/*
 * White balance Red Gain
 */
KSPROPERTY_STEPPING_LONG WB_Red_Gain_RangeAndStep [] = 
{
    {
		WB_RED_GAIN_DELTA,	// SteppingDelta
		0,					// Reserved
		WB_RED_GAIN_MIN,	// Minimum 
		WB_RED_GAIN_MAX		// Maximum 
    }
};

LONG WB_Red_Gain_Default = 127;

KSPROPERTY_MEMBERSLIST WB_Red_Gain_MembersList [] = 
{
    {
		{
			KSPROPERTY_MEMBER_RANGES,
			sizeof (WB_Red_Gain_RangeAndStep),
			SIZEOF_ARRAY (WB_Red_Gain_RangeAndStep),
			0
		},
		(PVOID) WB_Red_Gain_RangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (WB_Red_Gain_Default),
            sizeof (WB_Red_Gain_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &WB_Red_Gain_Default,
    }    
};

KSPROPERTY_VALUES WB_Red_Gain_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (WB_Red_Gain_MembersList),
    WB_Red_Gain_MembersList
};

/*
 * White balance Blue Gain
 */
KSPROPERTY_STEPPING_LONG WB_Blue_Gain_RangeAndStep [] = 
{
    {
		WB_BLUE_GAIN_DELTA,	// SteppingDelta
		0,					// Reserved
		WB_BLUE_GAIN_MIN,	// Minimum 
		WB_BLUE_GAIN_MAX	// Maximum 
    }
};

LONG WB_Blue_Gain_Default = 127;

KSPROPERTY_MEMBERSLIST WB_Blue_Gain_MembersList [] = 
{
    {
		{
			KSPROPERTY_MEMBER_RANGES,
			sizeof (WB_Blue_Gain_RangeAndStep),
			SIZEOF_ARRAY (WB_Blue_Gain_RangeAndStep),
			0
		},
		(PVOID) WB_Blue_Gain_RangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (WB_Blue_Gain_Default),
            sizeof (WB_Blue_Gain_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &WB_Blue_Gain_Default,
    }    
};

KSPROPERTY_VALUES WB_Blue_Gain_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (WB_Blue_Gain_MembersList),
    WB_Blue_Gain_MembersList
};

/*
 * Auto Exposure Control Speed
 */
KSPROPERTY_STEPPING_LONG AE_Control_Speed_RangeAndStep [] = 
{
    {
		AE_CONTROL_SPEED_DELTA,		// SteppingDelta
		0,							// Reserved
		AE_CONTROL_SPEED_MIN,		// Minimum 
		AE_CONTROL_SPEED_MAX		// Maximum 
    }
};

LONG AE_Control_Speed_Default = 127;

KSPROPERTY_MEMBERSLIST AE_Control_Speed_MembersList [] = 
{
    {
		{
			KSPROPERTY_MEMBER_RANGES,
			sizeof (AE_Control_Speed_RangeAndStep),
			SIZEOF_ARRAY (AE_Control_Speed_RangeAndStep),
			0
		},
		(PVOID) AE_Control_Speed_RangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (AE_Control_Speed_Default),
            sizeof (AE_Control_Speed_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &AE_Control_Speed_Default,
    }    
};

KSPROPERTY_VALUES AE_Control_Speed_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (AE_Control_Speed_MembersList),
	AE_Control_Speed_MembersList
};

/*
 * Auto Exposure Flickerless
 */
LONG AE_Flickerless_Default = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS_ON;

KSPROPERTY_MEMBERSLIST AE_Flickerless_MembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (AE_Flickerless_Default),
            sizeof (AE_Flickerless_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &AE_Flickerless_Default,
    }    
};

KSPROPERTY_VALUES AE_Flickerless_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (AE_Flickerless_MembersList),
    AE_Flickerless_MembersList
};

/*
 * Auto Exposure Shutter Mode
 */
LONG AE_Shutter_Mode_Default = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_AUTO;

KSPROPERTY_MEMBERSLIST AE_Shutter_Mode_MembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (AE_Shutter_Mode_Default),
            sizeof (AE_Shutter_Mode_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &AE_Shutter_Mode_Default,
    }    
};

KSPROPERTY_VALUES AE_Shutter_Mode_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (AE_Shutter_Mode_MembersList),
    AE_Shutter_Mode_MembersList
};

/*
 * Auto Exposure Shutter Speed
 */
KSPROPERTY_STEPPING_LONG AE_Shutter_Speed_RangeAndStep [] = 
{
    {
		AE_SHUTTER_SPEED_DELTA,	// SteppingDelta
		0,						// Reserved
		AE_SHUTTER_SPEED_MIN,	// Minimum 
		AE_SHUTTER_SPEED_MAX	// Maximum 
    }
};

LONG AE_Shutter_Speed_Default = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_250;

KSPROPERTY_MEMBERSLIST AE_Shutter_Speed_MembersList [] = 
{
    {
		{
			KSPROPERTY_MEMBER_RANGES,
			sizeof (AE_Shutter_Speed_RangeAndStep),
			SIZEOF_ARRAY (AE_Shutter_Speed_RangeAndStep),
			0
		},
		(PVOID) AE_Shutter_Speed_RangeAndStep
    },

    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (AE_Shutter_Speed_Default),
            sizeof (AE_Shutter_Speed_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &AE_Shutter_Speed_Default,
    }    
};

KSPROPERTY_VALUES AE_Shutter_Speed_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (AE_Shutter_Speed_MembersList),
    AE_Shutter_Speed_MembersList
};

/*
 * Auto Exposure Shutter Status
 */
KSPROPERTY_VALUES AE_Shutter_Status_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    0,
	NULL
};

/*
 * Auto exposure AGC Mode
 */
LONG AE_AGC_Mode_Default = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_AUTO;

KSPROPERTY_MEMBERSLIST AE_AGC_Mode_MembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (AE_AGC_Mode_Default),
            sizeof (AE_AGC_Mode_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &AE_AGC_Mode_Default,
    }    
};

KSPROPERTY_VALUES AE_AGC_Mode_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (AE_AGC_Mode_MembersList),
    AE_AGC_Mode_MembersList
};

/*
 * Auto exposure AGC speed
 */
KSPROPERTY_STEPPING_LONG AE_AGC_RangeAndStep [] = 
{
    {
		AE_AGC_DELTA,			// SteppingDelta
		0,						// Reserved
		AE_AGC_MIN,				// Minimum 
		AE_AGC_MAX				// Maximum 
    }
};

LONG AE_AGC_Default = 10;

KSPROPERTY_MEMBERSLIST AE_AGC_MembersList [] = 
{
    {
		{
			KSPROPERTY_MEMBER_RANGES,
			sizeof (AE_AGC_RangeAndStep),
			SIZEOF_ARRAY (AE_AGC_RangeAndStep),
			0
		},
		(PVOID) AE_AGC_RangeAndStep
    },

    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (AE_AGC_Default),
            sizeof (AE_AGC_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &AE_AGC_Default,
    }    
};

KSPROPERTY_VALUES AE_AGC_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (AE_AGC_MembersList),
    AE_AGC_MembersList
};

/*
 * Driver Version
 */
KSPROPERTY_VALUES DriverVersion_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    0,
    NULL
};

/*
 * Framerate
 */
LONG Framerate_Default = KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_75;

KSPROPERTY_MEMBERSLIST Framerate_MembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (Framerate_Default),
            sizeof (Framerate_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &Framerate_Default,
    }    
};

KSPROPERTY_VALUES Framerate_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (Framerate_MembersList),
    Framerate_MembersList
};

/*
 * Framerates Supported
 */

KSPROPERTY_VALUES Framerates_Supported_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    0,
    NULL
};


/*
 * Videoformat
 */
LONG VideoFormat_Default = KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOFORMAT_QCIF;

KSPROPERTY_MEMBERSLIST VideoFormat_MembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (VideoFormat_Default),
            sizeof (VideoFormat_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &VideoFormat_Default,
    }    
};

KSPROPERTY_VALUES VideoFormat_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (VideoFormat_MembersList),
    VideoFormat_MembersList
};

/*
 * Sensor Type
 */
KSPROPERTY_VALUES SensorType_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    0,
    NULL
};

/*
 * VideoCompression
 */
LONG VideoCompression_Default = KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOCOMPRESSION_UNCOMPRESSED;

KSPROPERTY_MEMBERSLIST VideoCompression_MembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (VideoCompression_Default),
            sizeof (VideoCompression_Default),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &VideoCompression_Default,
    }    
};

KSPROPERTY_VALUES VideoCompression_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    SIZEOF_ARRAY (VideoCompression_MembersList),
    VideoCompression_MembersList
};

/*
 * Defaults
 */
KSPROPERTY_VALUES Default_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    0,
    NULL
};

/*
 * Release Number
 */
KSPROPERTY_VALUES Release_Number_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    0,
    NULL
};

/*
 * VendorId
 */
KSPROPERTY_VALUES Vendor_Id_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    0,
    NULL
};

/*
 * ProductId
 */
KSPROPERTY_VALUES Product_Id_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    0,
    NULL
};


/*--------------------------------------------------------------------------  
 * PROPSETID_PHILIPS_FACTORY_PROP
 *
 * Supported:
 *
 * Register
 * Factory Mode
 * Register Address
 * Register Data
 *--------------------------------------------------------------------------*/  

/*
 * Register Address
 */
KSPROPERTY_VALUES RegisterAddress_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    0,
	NULL
};

/*
 * Register Data
 */
KSPROPERTY_VALUES RegisterData_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    0,
	NULL
};

/*
 * Factory Mode
 */
KSPROPERTY_VALUES Factory_Mode_Values =
{
    {
		STATICGUIDOF (KSPROPTYPESETID_General),
		VT_I4,
		0
    },
    0,
    NULL
};


/*--------------------------------------------------------------------------  
 * PROPSETID_PHILIPS_CUSTOM_PROP
 *
 * Supported:
 *
 * WhiteBalance Mode			get		set				default
 * WhiteBalance Speed,			get		set		range	default
 * WhiteBalance Delay,			get		set		range	default
 * WhiteBalance Red Gain,		get		set		range	default
 * WhiteBalance Blue Gain,		get		set		range	default
 * AutoExposure ControlSpeed	get		set		range	default
 * AutoExposure Flickerless		get		set		ranges	default	
 * AutoExposure Shutter Mode	get		set				default
 * AutoExposure Shutter Speed	get		set		range	default
 * AutoExposure Shutter Status	get				
 * AutoExposure AGC Mode		get		set				default
 * AutoExposure AGC Speed		get		set		range	default
 * DriverVersion				get				
 * Framerate,					get		set				default
 * Framerates Supported			get		
 * Video Format					get						default
 * SensorType					get
 * VideoCompression,			get						default
 * Defaults								set
 * Release Number				get
 * VendorId						get
 * ProductId					get
 *
 *--------------------------------------------------------------------------*/  


DEFINE_KSPROPERTY_TABLE(CustomProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE,				// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&WB_Mode_Values,									// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_SPEED,			// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&WB_Speed_Values,									// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_DELAY,			// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&WB_Delay_Values,									// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_RED_GAIN,			// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&WB_Red_Gain_Values,								// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_BLUE_GAIN,		// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&WB_Blue_Gain_Values,								// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_CONTROL_SPEED,	// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&AE_Control_Speed_Values,							// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS,		// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&AE_Flickerless_Values,								// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE,		// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&AE_Shutter_Mode_Values,							// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED,	// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&AE_Shutter_Speed_Values,							// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_STATUS,	// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&AE_Shutter_Status_Values,							// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE,			// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&AE_AGC_Mode_Values,								// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC,				// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&AE_AGC_Values,										// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_DRIVERVERSION,		// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		FALSE,			                                    // SetSupported or Handler
		&DriverVersion_Values,								// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE,			// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&Framerate_Values,									// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATES_SUPPORTED,// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&Framerates_Supported_Values,						// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOFORMAT,			// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		FALSE,	// !! TBD	                                // SetSupported or Handler
		&VideoFormat_Values,								// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_SENSORTYPE,		    // PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		FALSE,	// !! TBD	                                // SetSupported or Handler
		&SensorType_Values,		    						// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOCOMPRESSION,	// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		FALSE,	// !! TBD	                                // SetSupported or Handler
		&VideoCompression_Values,							// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS,		    // PropertyId
		FALSE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,				                                // SetSupported or Handler
		&Default_Values,		    						// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_RELEASE_NUMBER,	    // PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,				                                // SetSupported or Handler
		&Release_Number_Values,	    						// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_VENDOR_ID,		    // PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,				                                // SetSupported or Handler
		&Vendor_Id_Values,		    						// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_CUSTOM_PROP_PRODUCT_ID,		    // PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S),			// MinData
		TRUE,				                                // SetSupported or Handler
		&Product_Id_Values,		    						// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

};

/*--------------------------------------------------------------------------  
 * PROPSETID_PHILIPS_FACTORY_PROP
 *
 * Supported:
 *
 * Register			set		get
 * Factory_Mode		set
 *
 *--------------------------------------------------------------------------*/  

DEFINE_KSPROPERTY_TABLE(FactoryProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_FACTORY_PROP_REGISTER_ADDRESS,  	// PropertyId
		FALSE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_FACTORY_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_FACTORY_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&RegisterAddress_Values,							// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_FACTORY_PROP_REGISTER_DATA,  	// PropertyId
		TRUE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_FACTORY_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_FACTORY_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&RegisterData_Values,								// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_PHILIPS_FACTORY_PROP_FACTORY_MODE,	   	// PropertyId
		FALSE,												// GetSupported or Handler
		sizeof(KSPROPERTY_PHILIPS_FACTORY_PROP_S),			// MinProperty
		sizeof(KSPROPERTY_PHILIPS_FACTORY_PROP_S),			// MinData
		TRUE,			                                    // SetSupported or Handler
		&Factory_Mode_Values,								// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		sizeof(ULONG)										// SerializedSize
    ),
};

/*--------------------------------------------------------------------------  
 | VideoControlProperties Table
 |
 | Supported:
 |
 | Videocontrol Capabilities
 | Videocontrol Mode						set
 |
 --------------------------------------------------------------------------*/  


DEFINE_KSPROPERTY_TABLE(FrameRateProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_CAPS_S), // MinProperty
        sizeof(KSPROPERTY_VIDEOCONTROL_CAPS_S), // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S),      // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
	
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_FRAME_RATES,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_FRAME_RATES_S),    // MinProperty
        0 ,                                     // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_MODE_S), // MinProperty
        sizeof(KSPROPERTY_VIDEOCONTROL_MODE_S), // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),

};
    

/*--------------------------------------------------------------------------  
 * Definition of property set table
 *--------------------------------------------------------------------------*/  
DEFINE_KSPROPERTY_SET_TABLE(AdapterPropertyTable)
{
    DEFINE_KSPROPERTY_SET
    ( 
		&PROPSETID_VIDCAP_VIDEOPROCAMP,					// Set
		SIZEOF_ARRAY(VideoProcAmpProperties),           // PropertiesCount
		VideoProcAmpProperties,                         // PropertyItem
		0,                                              // FastIoCount
		NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    ( 
		&PROPSETID_PHILIPS_CUSTOM_PROP,					// Set
		SIZEOF_ARRAY(CustomProperties),                 // PropertiesCount
		CustomProperties,                               // PropertyItem
		0,                                              // FastIoCount
		NULL                                            // FastIoTable
    ),

	DEFINE_KSPROPERTY_SET
    ( 
		&PROPSETID_PHILIPS_FACTORY_PROP,				// Set
		SIZEOF_ARRAY(FactoryProperties),                // PropertiesCount
		FactoryProperties,                              // PropertyItem
		0,                                              // FastIoCount
		NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_VIDEOCONTROL,           // Set
        SIZEOF_ARRAY(FrameRateProperties),        // PropertiesCount
        FrameRateProperties,                      // PropertyItem
        0,                                        // FastIoCount
        NULL                                      // FastIoTable
    )
};

const NUMBER_OF_ADAPTER_PROPERTY_SETS = (SIZEOF_ARRAY (AdapterPropertyTable));



/*--------------------------------------------------------------------------  
 | VideoControlProperties Table
 |
 | Supported:
 |
 | Videocontrol Capabilities
 | Videocontrol Mode						set
 |
 --------------------------------------------------------------------------*/  


DEFINE_KSPROPERTY_TABLE(VideoControlProperties)
{
	DEFINE_KSPROPERTY_ITEM
	(
		KSPROPERTY_VIDEOCONTROL_CAPS,					  	// PropertyId
		FALSE,												// GetSupported or Handler
		sizeof(KSPROPERTY_VIDEOCONTROL_CAPS_S),				// MinProperty
		sizeof(KSPROPERTY_VIDEOCONTROL_CAPS_S),				// MinData
		FALSE,												// SetSupported or Handler
		NULL,												// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		0													// SerializedSize
	),

   DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S),      // MinData
        TRUE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_FRAME_RATES,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_FRAME_RATES_S),    // MinProperty
        0 ,                                     // MinData
        FALSE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),

	DEFINE_KSPROPERTY_ITEM
	(
		KSPROPERTY_VIDEOCONTROL_MODE,					  	// PropertyId
		FALSE,												// GetSupported or Handler
		sizeof(KSPROPERTY_VIDEOCONTROL_MODE_S),				// MinProperty
		sizeof(KSPROPERTY_VIDEOCONTROL_MODE_S),				// MinData
		TRUE,												// SetSupported or Handler
		NULL,												// Values
		0,													// RelationsCount
		NULL,												// Relations
		NULL,												// SupportHandler
		0													// SerializedSize
	)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mdecoder.c ===
/*++

Copyright (c) 1998  Philips  CE - I&C

Module Name:

   mdecoder.c

Abstract:

   this module converts the raw USB data to video data.

Original Author:

    Ronald v.d.Meer

Environment:

   Kernel mode only


Revision History:

Date        Reason
14-04-1998  Initial version
--*/       

#include "wdm.h"
#include "mcamdrv.h"
#include "mstreams.h"
#include "mcodec.h"
#include "mdecoder.h"


/*******************************************************************************
 *
 * START LOCAL DEFINES
 *
 ******************************************************************************/

#define CLIP(x)           (((unsigned) (x) > 255) ? (((x) < 0) ? 0 : 255) : (x))

/*
 * The following code clips x between 0 and 255, it is crafted to let the
 * compiler generate good code:
 */
#define CLIP2(i1, i2)    \
{\
    long x = b[i2] >> 15;\
    *(pDst + i1) = (BYTE) ((DWORD) x > 255) ? ((x < 0) ? 0 : 255) : (BYTE) x;\
}

/*
 * The following code clips x between 0 and 255, it is crafted to let the
 * compiler generate good code:
 * YGain is doubled (used for camera's with SII version 4)
 */
#define CLIP2YGAIN(i1, i2)    \
{\
    long x = (b[i2] << 1) >> 15;\
    *(pDst + i1) = (BYTE) ((DWORD) x > 255) ? ((x < 0) ? 0 : 255) : (BYTE) x;\
}

/* these values are used in table[]: */
#define SHORT_SYMBOL    0
#define LONG_SYMBOL     1
#define END_OF_BLOCK    2
#define UNUSED          0

/*******************************************************************************
 *
 * START TYPEDEFS
 *
 ******************************************************************************/

typedef struct
{
    BYTE   bitc;
    BYTE   qsteplog;
} QB;

typedef struct
{
    BYTE   level;
    BYTE   length;
    BYTE   run;
    BYTE   index;
} TABLE_ELEMENT;

/*******************************************************************************
 *
 * START STATIC VARIABLES
 *
 ******************************************************************************/

/*
 * Order of arrays emperically optimized for cache behaviour:
 */
#define STRAT    8
#define DRAC     4
#define DC       512

static short   rs[STRAT][DRAC][8][16];    /* if long, then table[].index wouldn't fit in a byte */
static QB      qb[STRAT][DRAC][16];       /* qsteplog/bitc table */
static long    multiply[DC][6];
static long    table_val[9][DC];
static DWORD   valuesDC[DC];
static DWORD   value0coef[DC];

/*
 * This table is used by the variable length decoder part of the decompressor.
 * The first 6 bits of the next symbol(s) are used as index into this table.
 *
 * table[].level  : classifies the kind of symbol encountered.
 *
 * The following entries are only used in case of a short (<= 6 bits) symbol.
 *
 * table[].length : the number of bits of the symbol.
 * table[].run    : the number of 0 coeficients until the next non-zeo
 *                  coeficient, + 1.
 * table[].index  : used to index the rs[] table, it is optimized for the
 *                  assembly version, not the C version.
 */

static TABLE_ELEMENT table[64] = {
    /*       level:        length: run:    index: */
    /*  0 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /*  1 */ SHORT_SYMBOL, 3,      1,      0 * 16 * 2,
    /*  2 */ SHORT_SYMBOL, 4,      1,      1 * 16 * 2,
    /*  3 */ SHORT_SYMBOL, 6,      1,      3 * 16 * 2,
    /*  4 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /*  5 */ SHORT_SYMBOL, 3,      1,      4 * 16 * 2,
    /*  6 */ SHORT_SYMBOL, 5,      1,      2 * 16 * 2,
    /*  7 */ LONG_SYMBOL,  UNUSED, UNUSED, UNUSED,
    /*  8 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /*  9 */ SHORT_SYMBOL, 3,      1,      0 * 16 * 2,
    /* 10 */ SHORT_SYMBOL, 4,      1,      5 * 16 * 2,
    /* 11 */ SHORT_SYMBOL, 5,      2,      0 * 16 * 2,
    /* 12 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 13 */ SHORT_SYMBOL, 3,      1,      4 * 16 * 2,
    /* 14 */ SHORT_SYMBOL, 5,      3,      0 * 16 * 2,
    /* 15 */ LONG_SYMBOL,  UNUSED, UNUSED, UNUSED,
    /* 16 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 17 */ SHORT_SYMBOL, 3,      1,      0 * 16 * 2,
    /* 18 */ SHORT_SYMBOL, 4,      1,      1 * 16 * 2,
    /* 19 */ SHORT_SYMBOL, 6,      2,      1 * 16 * 2,
    /* 20 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 21 */ SHORT_SYMBOL, 3,      1,      4 * 16 * 2,
    /* 22 */ SHORT_SYMBOL, 5,      1,      6 * 16 * 2,
    /* 23 */ LONG_SYMBOL,  UNUSED, UNUSED, UNUSED,
    /* 24 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 25 */ SHORT_SYMBOL, 3,      1,      0 * 16 * 2,
    /* 26 */ SHORT_SYMBOL, 4,      1,      5 * 16 * 2,
    /* 27 */ SHORT_SYMBOL, 5,      2,      4 * 16 * 2,
    /* 28 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 29 */ SHORT_SYMBOL, 3,      1,      4 * 16 * 2,
    /* 30 */ SHORT_SYMBOL, 5,      3,      4 * 16 * 2,
    /* 31 */ LONG_SYMBOL,  UNUSED, UNUSED, UNUSED,
    /* 32 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 33 */ SHORT_SYMBOL, 3,      1,      0 * 16 * 2,
    /* 34 */ SHORT_SYMBOL, 4,      1,      1 * 16 * 2,
    /* 35 */ SHORT_SYMBOL, 6,      1,      7 * 16 * 2,
    /* 36 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 37 */ SHORT_SYMBOL, 3,      1,      4 * 16 * 2,
    /* 38 */ SHORT_SYMBOL, 5,      1,      2 * 16 * 2,
    /* 39 */ LONG_SYMBOL,  UNUSED, UNUSED, UNUSED,
    /* 40 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 41 */ SHORT_SYMBOL, 3,      1,      0 * 16 * 2,
    /* 42 */ SHORT_SYMBOL, 4,      1,      5 * 16 * 2,
    /* 43 */ SHORT_SYMBOL, 5,      2,      0 * 16 * 2,
    /* 44 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 45 */ SHORT_SYMBOL, 3,      1,      4 * 16 * 2,
    /* 46 */ SHORT_SYMBOL, 5,      3,      0 * 16 * 2,
    /* 47 */ LONG_SYMBOL,  UNUSED, UNUSED, UNUSED,
    /* 48 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 49 */ SHORT_SYMBOL, 3,      1,      0 * 16 * 2,
    /* 50 */ SHORT_SYMBOL, 4,      1,      1 * 16 * 2,
    /* 51 */ SHORT_SYMBOL, 6,      2,      5 * 16 * 2,
    /* 52 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 53 */ SHORT_SYMBOL, 3,      1,      4 * 16 * 2,
    /* 54 */ SHORT_SYMBOL, 5,      1,      6 * 16 * 2,
    /* 55 */ LONG_SYMBOL,  UNUSED, UNUSED, UNUSED,
    /* 56 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 57 */ SHORT_SYMBOL, 2 + 1,  1,      0 * 16 * 2,
    /* 58 */ SHORT_SYMBOL, 3 + 1,  1,      5 * 16 * 2,
    /* 59 */ SHORT_SYMBOL, 4 + 1,  2,      4 * 16 * 2,
    /* 60 */ END_OF_BLOCK, UNUSED, UNUSED, UNUSED,
    /* 61 */ SHORT_SYMBOL, 2 + 1,  1,      4 * 16 * 2,
    /* 62 */ SHORT_SYMBOL, 4 + 1,  3,      4 * 16 * 2,
    /* 63 */ LONG_SYMBOL,  UNUSED, UNUSED, UNUSED
};

/*******************************************************************************
 *
 * START STATIC VARIABLES
 *
 ******************************************************************************/

/* init the bit cost array for the different strategies and dynamic ranges */

static int bitzz[512] =
{
 // strategy 0
 9,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  
 9,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  
 9,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  
 9,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  
 
 // strategy 1
 9,  2,  2,  2,  2,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  
 9,  4,  4,  3,  3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  
 9,  6,  6,  6,  6,  6,  5,  5,  5,  5,  5,  5,  5,  4,  4,  4,  
 9,  8,  8,  8,  8,  8,  7,  7,  7,  7,  7,  7,  7,  6,  6,  6,  
 
 // strategy 2
 9,  2,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  
 9,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  
 9,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  4,  4,  4,  
 9,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  6,  6,  6,  
 
 // strategy 3
 9,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  
 9,  2,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  
 9,  5,  5,  5,  5,  5,  4,  4,  4,  4,  4,  4,  4,  3,  3,  3,  
 9,  7,  7,  7,  7,  7,  6,  6,  6,  6,  6,  6,  6,  5,  5,  5,  
 
 // strategy 4
 9,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
 9,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  
 9,  5,  5,  4,  4,  4,  4,  4,  4,  4,  3,  3,  3,  3,  3,  3,  
 9,  7,  7,  6,  6,  6,  6,  6,  6,  6,  5,  5,  5,  5,  5,  5,  
 
 // strategy 5
 9,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
 9,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
 9,  4,  4,  4,  4,  4,  3,  3,  3,  3,  3,  3,  3,  2,  2,  2,  
 9,  6,  6,  6,  6,  6,  5,  5,  5,  5,  5,  5,  5,  4,  4,  4,  
 
 // strategy 6
 9,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
 9,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
 9,  4,  4,  3,  3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  
 9,  6,  6,  5,  5,  5,  5,  5,  5,  5,  4,  4,  4,  4,  4,  4,  
 
 // strategy 7
 9,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
 9,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
 9,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  2,  1,  1,  1,  
 9,  5,  5,  5,  5,  5,  4,  4,  4,  4,  4,  4,  4,  3,  3,  3
};

/*
 * quantizatioon array for the different strategies and dynamic ranges
 */

static int qzz[512] =
{
 // strategy 0
 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  

 // strategy 1
 1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  4,  
 1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  4,  4,  4,  4,  4,  4,  
 1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  4,  4,  4,  
 1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  4,  4,  4,  

 // strategy 2
 1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  4,  
 1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  4,  4,  4,  4,  4,  4,  
 1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  4,  4,  4,  
 1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  4,  4,  4,  

 // strategy 3
 1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  4,  4,  4,  4,  4,  4,  
 1,  4,  4,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8, 16, 16, 16,  
 1,  2,  2,  2,  2,  2,  4,  4,  4,  4,  4,  4,  4,  8,  8,  8,  
 1,  2,  2,  2,  2,  2,  4,  4,  4,  4,  4,  4,  4,  8,  8,  8,  

 // strategy 4
 1,  2,  2,  2,  2,  2,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  
 1,  8,  8,  8,  8,  8,  8,  8,  8,  8, 16, 16, 16, 16, 16, 16, 
 1,  2,  2,  4,  4,  4,  4,  4,  4,  4,  8,  8,  8,  8,  8,  8,  
 1,  2,  2,  4,  4,  4,  4,  4,  4,  4,  8,  8,  8,  8,  8,  8,  

 // strategy 5
 1,  2,  2,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  
 1,  8,  8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
 1,  4,  4,  4,  4,  4,  8,  8,  8,  8,  8,  8,  8, 16, 16, 16, 
 1,  4,  4,  4,  4,  4,  8,  8,  8,  8,  8,  8,  8, 16, 16, 16, 

 // strategy 6
 1,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 4, 
 1,  8,  8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
 1,  4,  4,  8,  8,  8,  8,  8,  8,  8, 16, 16, 16, 16, 16, 16, 
 1,  4,  4,  8,  8,  8,  8,  8,  8,  8, 16, 16, 16, 16, 16, 16, 

 // strategy 7
 1,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 1,  8,  8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
 1,  8,  8,  8,  8,  8, 16, 16, 16, 16, 16, 16, 16, 32, 32, 32, 
 1,  8,  8,  8,  8,  8, 16, 16, 16, 16, 16, 16, 16, 32, 32, 32 
};


/*******************************************************************************
 *
 * START EXPORTED METHODS DEFINITIONS
 *
 ******************************************************************************/

/*
 *
 */

extern void
InitDecoder ()
{
    int          i;
    int          j;
	int          dc;
    int          strat;
	int          drac;
    DWORD        x;
    int          val;
    int          *p_zz;


    for (dc = 0; dc < 512; dc++)
    {
        x = CLIP ((dc * 31684L + 32768L / 2L) >> 15);
        x |= x << 8;
        x |= x << 16;
        value0coef[dc] = x;

        i = dc - 256;
        valuesDC[dc]    = dc * 31684L;
        multiply[dc][0] = i * 31684L;
        multiply[dc][1] = i * 42186L;
        multiply[dc][2] = i * 17444L;
        multiply[dc][3] = i * 56169L;
        multiply[dc][4] = i * 23226L;
        multiply[dc][5] = i * 9604L;
    }

    /* Warning: it is assumed that the qstep values are of the form 2^n, n e [0,7] */

    p_zz = &qzz[0];

    for (strat = 0; strat < 8; strat++)
    {
        for (drac = 0; drac <= 3; drac++)
        {
            for (i = 0; i <= 15; i++)
            {
                val = *p_zz++;
                
                for (j = 0; j < 8; j++)
                {
                    if (val & (1 << j))
                    {
                        qb[strat][drac][i].qsteplog = (BYTE) j;
                        break;
                    }
                }
                
                rs[strat][drac][0][i] = (short) ( val * 1 + 256) * 3;
                rs[strat][drac][1][i] = (short) ( val * 2 + 256) * 3;
                rs[strat][drac][2][i] = (short) ( val * 3 + 256) * 3;
                rs[strat][drac][3][i] = (short) ( val * 4 + 256) * 3;
                rs[strat][drac][4][i] = (short) (-val * 1 + 256) * 3;
                rs[strat][drac][5][i] = (short) (-val * 2 + 256) * 3;
                rs[strat][drac][6][i] = (short) (-val * 3 + 256) * 3;
                rs[strat][drac][7][i] = (short) (-val * 4 + 256) * 3;
            }
        }
    }

    p_zz = &bitzz[0];

    for (strat = 0; strat < 8; strat++)
    {
        for (drac = 0; drac <= 3; drac++)
        {
            for (i = 0; i <= 15; i++)
            {
                qb[strat][drac][i].bitc = (BYTE) *p_zz++;
            }
        }
    }
  
    for (dc = 0; dc < 512; dc++)
    {
        table_val[0][dc] = 0;
    }
    
    for (i = 1; i <= 8; i++)
    {
        j = 0;
        
        while ((j * (1 << i)) < 512)
        {
            for (dc = j * (1 << i); dc < 512; dc++)
            {
                if ((j % 2) == 0)
                {
                    table_val[i][dc] =   dc & ((1 << i) - 1);
                }
                else
                {
                    table_val[i][dc] = -(dc & ((1 << i) - 1));
                }
            }
            j++;
        }
    }
}


/*
 *
 */



//------------------------------------------------------------------------------

/*
 *
 */

extern void
DcDecompressBandToI420 (PBYTE pSrc, PBYTE pDst, DWORD camVersion,
                        BOOLEAN YBlockBand, BOOLEAN Cropping)
{
    long            b[16];
    long            k;
    long            level;
    DWORD           code_word;
    DWORD           strat;
    QB              *p_qb;
    long            result;
    BOOLEAN         Uval;
    PBYTE           pDstEnd;
    long            cm1, cm2, cm3;
    int             ix;
    unsigned short  *p_rs;
    PBYTE           pInputLimit;
    long            *pMultiply = (long *) multiply;     /* Help compiler avoid a divide. */

    static BYTE     bitIndex;
    static PBYTE    bytePtr;

//    BYTE            DummyRead; /* Force data cache line loads before repeated writes. */

    /*
     * The way input bits are read via *bit_pt is dependant on the endianess
     * of the machine.
     */

    if (YBlockBand)
    {
        bytePtr  = pSrc + 1;   // 1st bit and band_nr (7 bits) are not used
        bitIndex = 3;
        strat    = (* (PDWORD) (bytePtr)) & 0x7;
        pDstEnd  = pDst + CIF_X;
    }
    else    // UV BlockBand
    {
        // derive the strategy used for the UV data
        // from the strategy used for the Y data

        strat = (* (PDWORD) ((PBYTE) pSrc + 1)) & 0x7;

        if (strat != 0)
        {
            if (strat >= 6)
            {
                strat = 7;
            }
            else if (strat == 5)
            {
                strat = 6;
            }
            else
            {
                strat += 2;
            }
        }

        pDstEnd = pDst + (CIF_X / 2);
    }

    Uval = TRUE;

    pInputLimit = pSrc + ((camVersion >= SSI_CIF3) ? BytesPerBandCIF3
                                                   : BytesPerBandCIF4);

    do
    {
        if (bytePtr >= pInputLimit)
        {
            return;
        }

        bytePtr += (bitIndex / 8);
        bitIndex = (bitIndex % 8);

        code_word = (* (PDWORD) bytePtr) >> bitIndex;
        bitIndex += 11;

        result = (code_word >> 2) & 0x1FF;   // dc value

        if ((code_word & 0x00001800) == 0x00)  // the same as statement below
//        if (((code_word >> 11) & 0x3) == 0x0)
        {
            /*
             * EOB detected, 4x4 block contains only DC
             * Executed 0.27 times per IDCT block.
             */
             
            DWORD yuvVal = value0coef[result];
//          DummyRead += pDst[0];
//          DummyRead += pDst[BLOCK_BAND_WIDTH];

            if (YBlockBand)
            {
                if (camVersion == SSI_YGAIN_MUL2)
                {
                    yuvVal <<= 1;
                }

                * (PDWORD) (pDst + (0 * CIF_X) + 0) = yuvVal;
                * (PDWORD) (pDst + (1 * CIF_X) + 0) = yuvVal;
//                DummyRead += pDst[2 * CIF_X];
                * (PDWORD) (pDst + (2 * CIF_X) + 0) = yuvVal;
//                DummyRead += pDst[3 * CIF_X];
                * (PDWORD) (pDst + (3 * CIF_X) + 0) = yuvVal;
                pDst += 4;
            }
            else    // UV_BLOCK_BAND
            {
                if (Cropping)
                {
                    if (Uval)
                    {
                        * (PDWORD) (pDst + 0              + (0 * I420_NO_C_PER_LINE_CIF) + 0) = yuvVal;
                        * (PDWORD) (pDst + 0              + (0 * I420_NO_C_PER_LINE_CIF) + 4) = yuvVal;
                        * (PDWORD) (pDst + 0              + (1 * I420_NO_C_PER_LINE_CIF) + 0) = yuvVal;
                        * (PDWORD) (pDst + 0              + (1 * I420_NO_C_PER_LINE_CIF) + 4) = yuvVal;
                        Uval = FALSE;
                    }
                    else  // Vval
                    {
                        * (PDWORD) (pDst + I420_NO_U_PER_BAND_CIF + (0 * I420_NO_C_PER_LINE_CIF) + 0) = yuvVal;
                        * (PDWORD) (pDst + I420_NO_U_PER_BAND_CIF + (0 * I420_NO_C_PER_LINE_CIF) + 4) = yuvVal;
                        * (PDWORD) (pDst + I420_NO_U_PER_BAND_CIF + (1 * I420_NO_C_PER_LINE_CIF) + 0) = yuvVal;
                        * (PDWORD) (pDst + I420_NO_U_PER_BAND_CIF + (1 * I420_NO_C_PER_LINE_CIF) + 4) = yuvVal;
                        Uval = TRUE;
                        pDst += 8;
                    }
                }
                else    // CIF OUT
                {
                    if (Uval)
                    {
                        * (PDWORD) (pDst + 0              + (0 * I420_NO_C_PER_LINE_CIF) + 0) = yuvVal;
                        * (PDWORD) (pDst + 0              + (0 * I420_NO_C_PER_LINE_CIF) + 4) = yuvVal;
                        * (PDWORD) (pDst + 0              + (1 * I420_NO_C_PER_LINE_CIF) + 0) = yuvVal;
                        * (PDWORD) (pDst + 0              + (1 * I420_NO_C_PER_LINE_CIF) + 4) = yuvVal;
                        Uval = FALSE;
                    }
                    else  // Vval
                    {
                        * (PDWORD) (pDst + I420_NO_U_CIF + (0 * I420_NO_C_PER_LINE_CIF) + 0) = yuvVal;
                        * (PDWORD) (pDst + I420_NO_U_CIF + (0 * I420_NO_C_PER_LINE_CIF) + 4) = yuvVal;
                        * (PDWORD) (pDst + I420_NO_U_CIF + (1 * I420_NO_C_PER_LINE_CIF) + 0) = yuvVal;
                        * (PDWORD) (pDst + I420_NO_U_CIF + (1 * I420_NO_C_PER_LINE_CIF) + 4) = yuvVal;
                        Uval = TRUE;
                        pDst += 8;
                    }
                }
            }
            bitIndex += 2;
            continue;
        }

        k = 0;

        if (camVersion < SSI_8117_N3)
        {
            // for old 8117 versions (N2 and before) sometimes a decompressed
            // line contains coloured artifacts.  This occurs when the DC
            // value equals 256. The code below fixes this.

            if (result == 256)
            {
                k = 0 - 1;
            }
        }
        
        p_qb = qb[strat][code_word & 0x3];
        p_rs = (unsigned short *) &rs[strat][code_word & 0x3];
        result = valuesDC[result];

        b[ 0] = result; b[ 1] = result; b[ 2] = result; b[ 3] = result;
        b[ 4] = result; b[ 5] = result; b[ 6] = result; b[ 7] = result;
        b[ 8] = result; b[ 9] = result; b[10] = result; b[11] = result;
        b[12] = result; b[13] = result; b[14] = result; b[15] = result;

        while (1)
        {
            /*
             * On average 4.32 iterations per IDCT block.
             */
             
            if (bytePtr >= pInputLimit)
            {
                return;
            }

            bytePtr += (bitIndex / 8);
            bitIndex = (bitIndex % 8);

            code_word = (* (PDWORD) bytePtr) >> bitIndex;
            ix = code_word & 0x3F;
            level = table[ix].level;
            
            if (level >= LONG_SYMBOL) /* level == LONG_SYMBOL or END_OF_BLOCK */
            {
                if (level > LONG_SYMBOL) /* level == END_OF_BLOCK */
                {
                    /*
                     * Executed 0.73 times per IDCT block.
                     */
                    bitIndex += 2;
                    break;
                }
                
                /*
                 * Executed 0.81 times per IDCT block.
                 */
                k += ((code_word >> 3) & 15) + 1;
                k &= 0xF;
                level = p_qb[k].bitc;
                bitIndex += ((BYTE) level + 8);
                level = table_val[level][(code_word >> 7) & 511];
                result = level << p_qb[k].qsteplog;
                result += 256;
                result *= (3 * 2);
            }
            else /* level == SHORT_SYMBOL */
            {
                /*
                 * Executed 2.79 times per IDCT block.
                 */

                k += table[ix].run;
                k &= 0xF;
                bitIndex += table[ix].length;            // max 6
                result = (p_rs[table[ix].index / 2 + k]) * 2;
            }

            switch (k)
            {
            case 0:
                b[15] += 1; /* Fill slot 0 of jump table */
                break;
            case 1:
                cm1 = pMultiply[result + 1];
                cm2 = pMultiply[result + 2];

                b[ 0] += cm1;
                b[ 1] += cm2;
                b[ 2] -= cm2;
                b[ 3] -= cm1;
                b[ 4] += cm1;
                b[ 5] += cm2;
                b[ 6] -= cm2;
                b[ 7] -= cm1;
                b[ 8] += cm1;
                b[ 9] += cm2;
                b[10] -= cm2;
                b[11] -= cm1;
                b[12] += cm1;
                b[13] += cm2;
                b[14] -= cm2;
                b[15] -= cm1;
                break;
            case 5:
                cm1 = pMultiply[result + 0];

                b[ 0] += cm1;
                b[ 1] -= cm1;
                b[ 2] -= cm1;
                b[ 3] += cm1;
                b[ 4] += cm1;
                b[ 5] -= cm1;
                b[ 6] -= cm1;
                b[ 7] += cm1;
                b[ 8] += cm1;
                b[ 9] -= cm1;
                b[10] -= cm1;
                b[11] += cm1;
                b[12] += cm1;
                b[13] -= cm1;
                b[14] -= cm1;
                b[15] += cm1;
                break;
            case 6:
                cm1 = pMultiply[result + 1];
                cm2 = pMultiply[result + 2];

                b[ 0] += cm2;
                b[ 1] -= cm1;
                b[ 2] += cm1;
                b[ 3] -= cm2;
                b[ 4] += cm2;
                b[ 5] -= cm1;
                b[ 6] += cm1;
                b[ 7] -= cm2;
                b[ 8] += cm2;
                b[ 9] -= cm1;
                b[10] += cm1;
                b[11] -= cm2;
                b[12] += cm2;
                b[13] -= cm1;
                b[14] += cm1;
                b[15] -= cm2;
                break;
            case 2:
                cm1 = pMultiply[result + 1];
                cm2 = pMultiply[result + 2];

                b[ 0] += cm1;
                b[ 1] += cm1;
                b[ 2] += cm1;
                b[ 3] += cm1;
                b[ 4] += cm2;
                b[ 5] += cm2;
                b[ 6] += cm2;
                b[ 7] += cm2;
                b[ 8] -= cm2;
                b[ 9] -= cm2;
                b[10] -= cm2;
                b[11] -= cm2;
                b[12] -= cm1;
                b[13] -= cm1;
                b[14] -= cm1;
                b[15] -= cm1;
                break;
            case 4:
                cm1 = pMultiply[result + 3];
                cm2 = pMultiply[result + 4];
                cm3 = pMultiply[result + 5];

                b[ 0] += cm1;
                b[ 1] += cm2;
                b[ 2] -= cm2;
                b[ 3] -= cm1;
                b[ 4] += cm2;
                b[ 5] += cm3;
                b[ 6] -= cm3;
                b[ 7] -= cm2;
                b[ 8] -= cm2;
                b[ 9] -= cm3;
                b[10] += cm3;
                b[11] += cm2;
                b[12] -= cm1;
                b[13] -= cm2;
                b[14] += cm2;
                b[15] += cm1;
                break;
            case 7:
                cm1 = pMultiply[result + 1];
                cm2 = pMultiply[result + 2];

                b[ 0] += cm1;
                b[ 1] -= cm1;
                b[ 2] -= cm1;
                b[ 3] += cm1;
                b[ 4] += cm2;
                b[ 5] -= cm2;
                b[ 6] -= cm2;
                b[ 7] += cm2;
                b[ 8] -= cm2;
                b[ 9] += cm2;
                b[10] += cm2;
                b[11] -= cm2;
                b[12] -= cm1;
                b[13] += cm1;
                b[14] += cm1;
                b[15] -= cm1;
                break;
            case 12:
                cm1 = pMultiply[result + 3];
                cm2 = pMultiply[result + 4];
                cm3 = pMultiply[result + 5];

                b[ 0] += cm2;
                b[ 1] -= cm1;
                b[ 2] += cm1;
                b[ 3] -= cm2;
                b[ 4] += cm3;
                b[ 5] -= cm2;
                b[ 6] += cm2;
                b[ 7] -= cm3;
                b[ 8] -= cm3;
                b[ 9] += cm2;
                b[10] -= cm2;
                b[11] += cm3;
                b[12] -= cm2;
                b[13] += cm1;
                b[14] -= cm1;
                b[15] += cm2;
                break;
            case 3:
                cm1 = pMultiply[result + 0];

                b[ 0] += cm1;
                b[ 1] += cm1;
                b[ 2] += cm1;
                b[ 3] += cm1;
                b[ 4] -= cm1;
                b[ 5] -= cm1;
                b[ 6] -= cm1;
                b[ 7] -= cm1;
                b[ 8] -= cm1;
                b[ 9] -= cm1;
                b[10] -= cm1;
                b[11] -= cm1;
                b[12] += cm1;
                b[13] += cm1;
                b[14] += cm1;
                b[15] += cm1;
                break;
            case 8:
                cm1 = pMultiply[result + 1];
                cm2 = pMultiply[result + 2];

                b[ 0] += cm1;
                b[ 1] += cm2;
                b[ 2] -= cm2;
                b[ 3] -= cm1;
                b[ 4] -= cm1;
                b[ 5] -= cm2;
                b[ 6] += cm2;
                b[ 7] += cm1;
                b[ 8] -= cm1;
                b[ 9] -= cm2;
                b[10] += cm2;
                b[11] += cm1;
                b[12] += cm1;
                b[13] += cm2;
                b[14] -= cm2;
                b[15] -= cm1;
                break;
            case 11:
                cm1 = pMultiply[result + 0];

                b[ 0] += cm1;
                b[ 1] -= cm1;
                b[ 2] -= cm1;
                b[ 3] += cm1;
                b[ 4] -= cm1;
                b[ 5] += cm1;
                b[ 6] += cm1;
                b[ 7] -= cm1;
                b[ 8] -= cm1;
                b[ 9] += cm1;
                b[10] += cm1;
                b[11] -= cm1;
                b[12] += cm1;
                b[13] -= cm1;
                b[14] -= cm1;
                b[15] += cm1;
                break;
            case 13:
                cm1 = pMultiply[result + 1];
                cm2 = pMultiply[result + 2];

                b[ 0] += cm2;
                b[ 1] -= cm1;
                b[ 2] += cm1;
                b[ 3] -= cm2;
                b[ 4] -= cm2;
                b[ 5] += cm1;
                b[ 6] -= cm1;
                b[ 7] += cm2;
                b[ 8] -= cm2;
                b[ 9] += cm1;
                b[10] -= cm1;
                b[11] += cm2;
                b[12] += cm2;
                b[13] -= cm1;
                b[14] += cm1;
                b[15] -= cm2;
                break;
            case 9:
                cm1 = pMultiply[result + 1];
                cm2 = pMultiply[result + 2];

                b[ 0] += cm2;
                b[ 1] += cm2;
                b[ 2] += cm2;
                b[ 3] += cm2;
                b[ 4] -= cm1;
                b[ 5] -= cm1;
                b[ 6] -= cm1;
                b[ 7] -= cm1;
                b[ 8] += cm1;
                b[ 9] += cm1;
                b[10] += cm1;
                b[11] += cm1;
                b[12] -= cm2;
                b[13] -= cm2;
                b[14] -= cm2;
                b[15] -= cm2;
                break;
            case 10:
                cm1 = pMultiply[result + 3];
                cm2 = pMultiply[result + 4];
                cm3 = pMultiply[result + 5];

                b[ 0] += cm2;
                b[ 1] += cm3;
                b[ 2] -= cm3;
                b[ 3] -= cm2;
                b[ 4] -= cm1;
                b[ 5] -= cm2;
                b[ 6] += cm2;
                b[ 7] += cm1;
                b[ 8] += cm1;
                b[ 9] += cm2;
                b[10] -= cm2;
                b[11] -= cm1;
                b[12] -= cm2;
                b[13] -= cm3;
                b[14] += cm3;
                b[15] += cm2;
                break;
            case 14:
                cm1 = pMultiply[result + 1];
                cm2 = pMultiply[result + 2];

                b[ 0] += cm2;
                b[ 1] -= cm2;
                b[ 2] -= cm2;
                b[ 3] += cm2;
                b[ 4] -= cm1;
                b[ 5] += cm1;
                b[ 6] += cm1;
                b[ 7] -= cm1;
                b[ 8] += cm1;
                b[ 9] -= cm1;
                b[10] -= cm1;
                b[11] += cm1;
                b[12] -= cm2;
                b[13] += cm2;
                b[14] += cm2;
                b[15] -= cm2;
                break;
            case 15:
                cm1 = pMultiply[result + 3];
                cm2 = pMultiply[result + 4];
                cm3 = pMultiply[result + 5];

                b[ 0] += cm3;
                b[ 1] -= cm2;
                b[ 2] += cm2;
                b[ 3] -= cm3;
                b[ 4] -= cm2;
                b[ 5] += cm1;
                b[ 6] -= cm1;
                b[ 7] += cm2;
                b[ 8] += cm2;
                b[ 9] -= cm1;
                b[10] += cm1;
                b[11] -= cm2;
                b[12] -= cm3;
                b[13] += cm2;
                b[14] -= cm2;
                b[15] += cm3;
                break;
            }
        }

//      DummyRead += pDst[     0];
//      DummyRead += pDst[BLOCK_BAND_WIDTH];

        if (YBlockBand)
        {
            if (camVersion == SSI_YGAIN_MUL2)
            {
                CLIP2YGAIN (0 * CIF_X + 0,  0);       // Y1, line 1
                CLIP2YGAIN (0 * CIF_X + 1,  1);       // Y2, line 1
                CLIP2YGAIN (0 * CIF_X + 2,  2);       // Y3, line 1
                CLIP2YGAIN (0 * CIF_X + 3,  3);       // Y4, line 1
                CLIP2YGAIN (1 * CIF_X + 0,  4);       // Y1, line 2
                CLIP2YGAIN (1 * CIF_X + 1,  5);       // Y2, line 2
                CLIP2YGAIN (1 * CIF_X + 2,  6);       // Y3, line 2
                CLIP2YGAIN (1 * CIF_X + 3,  7);       // Y4, line 2
//              DummyRead += pDst[2 * CIF_X];
                CLIP2YGAIN (2 * CIF_X + 0,  8);       // Y1, line 3
                CLIP2YGAIN (2 * CIF_X + 1,  9);       // Y2, line 3
                CLIP2YGAIN (2 * CIF_X + 2, 10);       // Y3, line 3
                CLIP2YGAIN (2 * CIF_X + 3, 11);       // Y4, line 3
//              DummyRead += pDst[3 * CIF_X];
                CLIP2YGAIN (3 * CIF_X + 0, 12);       // Y1, line 4
                CLIP2YGAIN (3 * CIF_X + 1, 13);       // Y2, line 4
                CLIP2YGAIN (3 * CIF_X + 2, 14);       // Y3, line 4
                CLIP2YGAIN (3 * CIF_X + 3, 15);       // Y4, line 4
            }
            else
            {
                CLIP2 (0 * CIF_X + 0,  0);            // Y1, line 1
                CLIP2 (0 * CIF_X + 1,  1);            // Y2, line 1
                CLIP2 (0 * CIF_X + 2,  2);            // Y3, line 1
                CLIP2 (0 * CIF_X + 3,  3);            // Y4, line 1
                CLIP2 (1 * CIF_X + 0,  4);            // Y1, line 2
                CLIP2 (1 * CIF_X + 1,  5);            // Y2, line 2
                CLIP2 (1 * CIF_X + 2,  6);            // Y3, line 2
                CLIP2 (1 * CIF_X + 3,  7);            // Y4, line 2
//              DummyRead += pDst[2 * CIF_X];
                CLIP2 (2 * CIF_X + 0,  8);            // Y1, line 3
                CLIP2 (2 * CIF_X + 1,  9);            // Y2, line 3
                CLIP2 (2 * CIF_X + 2, 10);            // Y3, line 3
                CLIP2 (2 * CIF_X + 3, 11);            // Y4, line 3
//              DummyRead += pDst[3 * CIF_X];
                CLIP2 (3 * CIF_X + 0, 12);            // Y1, line 4
                CLIP2 (3 * CIF_X + 1, 13);            // Y2, line 4
                CLIP2 (3 * CIF_X + 2, 14);            // Y3, line 4
                CLIP2 (3 * CIF_X + 3, 15);            // Y4, line 4
            }
            pDst += 4;
        }
        else    // UV_BLOCK_BAND
        {
            if (Cropping)
            {
                if (Uval)
                {
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 0,  0);       // U1, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 1,  1);       // U2, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 2,  2);       // U3, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 3,  3);       // U4, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 4,  4);       // U5, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 5,  5);       // U6, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 6,  6);       // U7, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 7,  7);       // U8, line 1
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 0,  8);       // U1, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 1,  9);       // U2, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 2, 10);       // U3, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 3, 11);       // U4, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 4, 12);       // U5, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 5, 13);       // U6, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 6, 14);       // U7, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 7, 15);       // U8, line 3
                    Uval = FALSE;
                }
                else    // Vval
                {
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 0 * I420_NO_C_PER_LINE_CIF + 0,  0);       // V1, line 2
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 0 * I420_NO_C_PER_LINE_CIF + 1,  1);       // V2, line 2
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 0 * I420_NO_C_PER_LINE_CIF + 2,  2);       // V3, line 2
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 0 * I420_NO_C_PER_LINE_CIF + 3,  3);       // V4, line 2
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 0 * I420_NO_C_PER_LINE_CIF + 4,  4);       // V5, line 2
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 0 * I420_NO_C_PER_LINE_CIF + 5,  5);       // V6, line 2
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 0 * I420_NO_C_PER_LINE_CIF + 6,  6);       // V7, line 2
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 0 * I420_NO_C_PER_LINE_CIF + 7,  7);       // V8, line 2
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 1 * I420_NO_C_PER_LINE_CIF + 0,  8);       // V1, line 4
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 1 * I420_NO_C_PER_LINE_CIF + 1,  9);       // V2, line 4
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 1 * I420_NO_C_PER_LINE_CIF + 2, 10);       // V3, line 4
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 1 * I420_NO_C_PER_LINE_CIF + 3, 11);       // V4, line 4
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 1 * I420_NO_C_PER_LINE_CIF + 4, 12);       // V5, line 4
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 1 * I420_NO_C_PER_LINE_CIF + 5, 13);       // V6, line 4
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 1 * I420_NO_C_PER_LINE_CIF + 6, 14);       // V7, line 4
                    CLIP2 (I420_NO_U_PER_BAND_CIF + 1 * I420_NO_C_PER_LINE_CIF + 7, 15);       // V8, line 4
                    Uval = TRUE;
                    pDst += 8;
                }
            }
            else    // CIF OUT
            {
                if (Uval)
                {
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 0,  0);       // U1, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 1,  1);       // U2, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 2,  2);       // U3, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 3,  3);       // U4, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 4,  4);       // U5, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 5,  5);       // U6, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 6,  6);       // U7, line 1
                    CLIP2 (0              + 0 * I420_NO_C_PER_LINE_CIF + 7,  7);       // U8, line 1
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 0,  8);       // U1, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 1,  9);       // U2, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 2, 10);       // U3, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 3, 11);       // U4, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 4, 12);       // U5, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 5, 13);       // U6, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 6, 14);       // U7, line 3
                    CLIP2 (0              + 1 * I420_NO_C_PER_LINE_CIF + 7, 15);       // U8, line 3
                    Uval = FALSE;
                }
                else    // Vval
                {
                    CLIP2 (I420_NO_U_CIF + 0 * I420_NO_C_PER_LINE_CIF + 0,  0);       // V1, line 2
                    CLIP2 (I420_NO_U_CIF + 0 * I420_NO_C_PER_LINE_CIF + 1,  1);       // V2, line 2
                    CLIP2 (I420_NO_U_CIF + 0 * I420_NO_C_PER_LINE_CIF + 2,  2);       // V3, line 2
                    CLIP2 (I420_NO_U_CIF + 0 * I420_NO_C_PER_LINE_CIF + 3,  3);       // V4, line 2
                    CLIP2 (I420_NO_U_CIF + 0 * I420_NO_C_PER_LINE_CIF + 4,  4);       // V5, line 2
                    CLIP2 (I420_NO_U_CIF + 0 * I420_NO_C_PER_LINE_CIF + 5,  5);       // V6, line 2
                    CLIP2 (I420_NO_U_CIF + 0 * I420_NO_C_PER_LINE_CIF + 6,  6);       // V7, line 2
                    CLIP2 (I420_NO_U_CIF + 0 * I420_NO_C_PER_LINE_CIF + 7,  7);       // V8, line 2
                    CLIP2 (I420_NO_U_CIF + 1 * I420_NO_C_PER_LINE_CIF + 0,  8);       // V1, line 4
                    CLIP2 (I420_NO_U_CIF + 1 * I420_NO_C_PER_LINE_CIF + 1,  9);       // V2, line 4
                    CLIP2 (I420_NO_U_CIF + 1 * I420_NO_C_PER_LINE_CIF + 2, 10);       // V3, line 4
                    CLIP2 (I420_NO_U_CIF + 1 * I420_NO_C_PER_LINE_CIF + 3, 11);       // V4, line 4
                    CLIP2 (I420_NO_U_CIF + 1 * I420_NO_C_PER_LINE_CIF + 4, 12);       // V5, line 4
                    CLIP2 (I420_NO_U_CIF + 1 * I420_NO_C_PER_LINE_CIF + 5, 13);       // V6, line 4
                    CLIP2 (I420_NO_U_CIF + 1 * I420_NO_C_PER_LINE_CIF + 6, 14);       // V7, line 4
                    CLIP2 (I420_NO_U_CIF + 1 * I420_NO_C_PER_LINE_CIF + 7, 15);       // V8, line 4
                    Uval = TRUE;
                    pDst += 8;
                }
            }
        }
    }
    while (pDst < pDstEnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mcodec.h ===
/*++                            
Copyright (c) 1996, 1997, 1998  Philips CE-I&C

Module Name:

   mcodec.h

Abstract:

   This module converts the raw USB data to standard video data.

Original Author:

   Ronald v.d.Meer


Environment:

   Kernel mode only


Revision History:

Date       Change
14-04-1998 Initial version 

--*/

#ifndef __MCODEC_H__
#define __MCODEC_H__

#include <stdio.h>
#include "mcamdrv.h"
#include "resource.h"


/*******************************************************************************
 *
 * START DEFINES
 *
 ******************************************************************************/

/* defines for I420 space */

#define I420_NO_Y(w, h)           ((w) * (h))

#define I420_NO_Y_CIF              (CIF_X * CIF_Y)
#define I420_NO_U_CIF             ((CIF_X * CIF_Y) / 4)
#define I420_NO_V_CIF             ((CIF_X * CIF_Y) / 4)

#define I420_NO_Y_SIF              (SIF_X * SIF_Y)
#define I420_NO_U_SIF             ((SIF_X * SIF_Y) / 4)
#define I420_NO_V_SIF             ((SIF_X * SIF_Y) / 4)

#define I420_NO_Y_SSIF             (SSIF_X * SSIF_Y)
#define I420_NO_U_SSIF            ((SSIF_X * SSIF_Y) / 4)
#define I420_NO_V_SSIF            ((SSIF_X * SSIF_Y) / 4)

#define I420_NO_Y_SCIF             (SCIF_X * SCIF_Y)
#define I420_NO_U_SCIF            ((SCIF_X * SCIF_Y) / 4)
#define I420_NO_V_SCIF            ((SCIF_X * SCIF_Y) / 4)

/*******************************************************************************
 *
 * START FUNCTION DECLARATIONS
 *
 ******************************************************************************/

extern NTSTATUS
PHILIPSCAM_DecodeUsbData(PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
                         PUCHAR frameBuffer,
                         ULONG  frameLength,
                         PUCHAR rawFrameBuffer,
                         ULONG  rawFrameLength);

extern NTSTATUS
PHILIPSCAM_StartCodec(PPHILIPSCAM_DEVICE_CONTEXT DeviceContext);

extern NTSTATUS
PHILIPSCAM_StopCodec(PPHILIPSCAM_DEVICE_CONTEXT DeviceContext);

extern NTSTATUS
PHILIPSCAM_FrameRateChanged(PPHILIPSCAM_DEVICE_CONTEXT DeviceContext);

#endif  // __MCODEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mprpftn.h ===
#ifndef __PRPFTN_H__
#define __PRPFTN_H__

/*++

Copyright (c) 1997 1998 PHILIPS  I&C

Module Name:  mprpftn.h

Abstract:     

Author:       Michael Verberne

Revision History:

Date        Reason

Sept.22, 98 Optimized for NT5

--*/	
NTSTATUS
PHILIPSCAM_InitPrpObj(
	PPHILIPSCAM_DEVICE_CONTEXT DeviceContext
	);

NTSTATUS
PHILIPSCAM_PassCurrentStreamFormat(
	PPHILIPSCAM_DEVICE_CONTEXT DeviceContext
	);

PVOID 
PHILIPSCAM_GetAdapterPropertyTable(
    PULONG NumberOfPropertySets
    );    

NTSTATUS
PHILIPSCAM_GetCameraProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
PHILIPSCAM_SetCameraProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
PHILIPSCAM_GetCameraControlProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK Srb
    );

NTSTATUS
PHILIPSCAM_SetCameraControlProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK Srb
    );

NTSTATUS
PHILIPSCAM_GetCustomProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


NTSTATUS
PHILIPSCAM_SetCustomProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
PHILIPSCAM_SetFormatFramerate(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext
	);

NTSTATUS
PHILIPSCAM_GetSensorType(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext
	);

NTSTATUS
PHILIPSCAM_GetReleaseNumber(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext
	);

NTSTATUS
PHILIPSCAM_GetFactoryProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


NTSTATUS
PHILIPSCAM_SetFactoryProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
PHILIPSCAM_GetVideoControlProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );
NTSTATUS
PHILIPSCAM_SetVideoControlProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );

#endif  /* __PRPFTN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mprpobj.c ===
/*++

Copyright (c) 1997 1998 PHILIPS  I&C

Module Name:  mprpobj.c

Abstract:     Property handling module

Author:       Michael Verberne

Revision History:

Date        Reason

Sept.22, 98 Optimized for NT5
Nov. 30, 98 PID and VID properties added

--*/	
#include "mwarn.h"
#include "wdm.h"
#include <strmini.h>
#include <ksmedia.h>
#include "usbdi.h"
#include "usbcamdi.h"
#include "mcamdrv.h"
#include "mssidef.h"
#include "mprpobj.h"
#include "mprpobjx.h"
#include "mprpdef.h"
#include "mprpftn.h"

/*
 * defines 
 */
#define WAIT_FOR_COMPLETION 2000		// timeout value for USB in msec

#define NUM_100NANOSEC_UNITS_PERFRAME(x) ((x > 0) ? ((LONGLONG)10000000 / x) :0 )

/*
 * exported data
 */
const GUID PROPSETID_PHILIPS_CUSTOM_PROP  = { 
	STATIC_PROPSETID_PHILIPS_CUSTOM_PROP };
const GUID PROPSETID_PHILIPS_FACTORY_PROP = { 
	STATIC_PROPSETID_PHILIPS_FACTORY_PROP };

/*
 * Local data
 */
//static PHW_STREAM_REQUEST_BLOCK CurrentpSrb;
LONG Address = 0;

/*
 * Local function definitions
 */
static NTSTATUS 
Get_Brightness(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pBrightness);
static NTSTATUS 
Set_Brightness(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG Brightness);
static NTSTATUS 
Get_Contrast(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pContrast);
static NTSTATUS 
Set_Contrast(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG Contrast);
static NTSTATUS 
Get_Gamma(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pGamma);
static NTSTATUS 
Set_Gamma(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG Gamma);
static NTSTATUS 
Get_ColorEnable(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pColorEnable);
static NTSTATUS 
Set_ColorEnable(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG ColorEnable);
static NTSTATUS 
Get_BackLight_Compensation(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pBackLight_Compensation);
static NTSTATUS 
Set_BackLight_Compensation(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG BackLight_Compensation);
static NTSTATUS 
Get_WB_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pWB_Mode);
static NTSTATUS 
Set_WB_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG WB_Mode);
static NTSTATUS 
Get_WB_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pWB_Speed);
static NTSTATUS 
Set_WB_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG WB_Speed);
static NTSTATUS 
Get_WB_Delay(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pWB_Delay);
static NTSTATUS 
Set_WB_Delay(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG WB_Delay);
static NTSTATUS 
Get_WB_Red_Gain(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pWB_Red_Gain);
static NTSTATUS 
Set_WB_Red_Gain(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG WB_Red_Gain);
static NTSTATUS 
Get_WB_Blue_Gain(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pWB_Blue_Gain);
static NTSTATUS 
Set_WB_Blue_Gain(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG WB_Blue_Gain);
static NTSTATUS 
Get_AE_Control_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_Control_Speed);
static NTSTATUS 
Set_AE_Control_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_Control_Speed);
static NTSTATUS 
Get_AE_Flickerless(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_Flickerless);
static NTSTATUS 
Set_AE_Flickerless(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_Flickerless);
static NTSTATUS 
Get_AE_Shutter_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_Shutter_Mode);
static NTSTATUS 
Set_AE_Shutter_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_Shutter_Mode);
static NTSTATUS 
Get_AE_Shutter_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_Shutter_Speed);
static NTSTATUS 
Set_AE_Shutter_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_Shutter_Speed);
static NTSTATUS 
Get_AE_Shutter_Status(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_Shutter_Status);
static NTSTATUS 
Get_AE_AGC_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_AGC_Mode);
static NTSTATUS 
Set_AE_AGC_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_AGC_Mode);
static NTSTATUS 
Get_AE_AGC(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_AGC);
static NTSTATUS 
Set_AE_AGC(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_AGC);
static NTSTATUS 
Get_DriverVersion(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pDriverVersion);
static NTSTATUS 
Get_Framerate(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pFramerate);
static NTSTATUS 
Set_Framerate(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG Framerate);
static NTSTATUS
Get_Framerates_Supported(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pFramerates_Supported);
static NTSTATUS 
Get_VideoFormat(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pVideoFormat);
static NTSTATUS 
Get_SensorType(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pSensorType);
static NTSTATUS 
Get_VideoCompression(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pVideoCompression);
static NTSTATUS 
Set_Defaults(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG Command);
static NTSTATUS 
Get_Release_Number(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pRelease_Number);
static NTSTATUS 
Get_Vendor_Id(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pVendor_Id);
static NTSTATUS 
Get_Product_Id(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pProduct_Id);

static NTSTATUS 
PHILIPSCAM_Defaults_Restore_User(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext);
static NTSTATUS 
PHILIPSCAM_Defaults_Save_User(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext);
static NTSTATUS 
PHILIPSCAM_Defaults_Restore_Factory(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext);

static NTSTATUS 
Get_RegisterData(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext, 
		PLONG pValue);
static NTSTATUS 
Set_RegisterAddress(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext, 
		LONG AddressToSet);
static NTSTATUS 
Set_RegisterData(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext, 
		LONG Value);
static NTSTATUS 
Set_Factory_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext, 
		LONG Factory_Mode);

static NTSTATUS 
PHILIPSCAM_RestoreDriverDefaults(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext);


static NTSTATUS
PHILPCAM_ControlVendorCommand(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext,
		UCHAR Request,
		USHORT Value,
		USHORT Index,
		PVOID Buffer,
		PULONG BufferLength,
		BOOLEAN GetData,
		PCOMMAND_COMPLETE_FUNCTION CommandComplete,
		PVOID CommandContext);

static NTSTATUS Map_Framerate_Drv_to_KS(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext,
		PLONG pFramerate);
static NTSTATUS Map_Framerate_KS_to_Drv(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext,
		LONG Framerate);
static NTSTATUS Map_VideoFormat_Drv_to_KS(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext,
		PLONG pVideoFormat);
static NTSTATUS Map_VideoCompression_Drv_to_KS(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext,
		PLONG pVideoCompression);


//static VOID
//PHILIPSCAM_TimeoutDPC(
//    PKDPC Dpc,
//    PVOID DeferredContext,
//    PVOID SystemArgument1,
//    PVOID SystemArgument2
//    );


/*
** PHILIPSCAM_InitPrpObj()
**
** Arguments:
**
**  DeviceContext - driver context
**
** Returns:
**  
** Side Effects:  none
*/
NTSTATUS
PHILIPSCAM_InitPrpObj(
	PPHILIPSCAM_DEVICE_CONTEXT DeviceContext
	)
{
	NTSTATUS status = STATUS_SUCCESS;

	// Read defaults from camera, could also be done
	// using PHILIPSCAM_RestoreDriverDefaults() but this
	// is more save
	status = PHILIPSCAM_Defaults_Restore_User(DeviceContext);

	return status;
}


/*
** PHILIPSCAM_GetAdapterPropertyTable()
**
** Arguments:
**
** NumberOfPropertySets
**
** Returns:
**
** Addres of property table
**  
** Side Effects:  none
*/
PVOID 
PHILIPSCAM_GetAdapterPropertyTable(
    PULONG NumberOfPropertySets
    )
{
    *NumberOfPropertySets = NUMBER_OF_ADAPTER_PROPERTY_SETS;
    return (PVOID) AdapterPropertyTable;
}


/*
** PHILIPSCAM_GetCameraProperty()
**
** Arguments:
**
**  DeviceContext - driver context
**
** Returns:
**
**  NT status completion code 
**  
** Side Effects:  none
*/
NTSTATUS
PHILIPSCAM_GetCameraProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR streamPropertyDescr = 
		    pSrb->CommandData.PropertyInfo;
    PKSPROPERTY_VIDEOPROCAMP_S propertyData = 
			streamPropertyDescr->PropertyInfo;
    ULONG flags = propertyData->Flags;
    ULONG propertyID = streamPropertyDescr->Property->Id;	
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT(streamPropertyDescr->PropertyOutputSize 
			>= sizeof(KSPROPERTY_VIDEOPROCAMP_S));

    switch(propertyID) {
	    case  KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
			status = Get_Brightness(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
			status = Get_Contrast(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_VIDEOPROCAMP_GAMMA:
			status = Get_Gamma(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_VIDEOPROCAMP_COLORENABLE:
			status = Get_ColorEnable(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION:
			status = Get_BackLight_Compensation(DeviceContext, &propertyData->Value);
			break;
		default:
			status = STATUS_NOT_SUPPORTED;
    }

	if (NT_SUCCESS(status)) 
	{
		pSrb->ActualBytesTransferred = sizeof(KSPROPERTY_VIDEOPROCAMP_S);
		propertyData->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
		propertyData->Flags = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
	}	
	
	pSrb->Status = status;    

    return status;
}


/*
** PHILIPSCAM_SetCameraProperty()
**
** Arguments:
**
**  DeviceContext - driver context
**
** Returns:
**
**  NT status completion code 
**  
** Side Effects:  none
*/
NTSTATUS
PHILIPSCAM_SetCameraProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
	PSTREAM_PROPERTY_DESCRIPTOR streamPropertyDescr = 
		    pSrb->CommandData.PropertyInfo;
    PKSPROPERTY_VIDEOPROCAMP_S propertyData = 
			streamPropertyDescr->PropertyInfo;
    ULONG flags = propertyData->Flags;            
    ULONG propertyID = streamPropertyDescr->Property->Id;     
    NTSTATUS status = STATUS_SUCCESS;

    switch (propertyID) {
	    case  KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
			status = Set_Brightness(DeviceContext, propertyData->Value);
			break;
	    case  KSPROPERTY_VIDEOPROCAMP_CONTRAST:
			status = Set_Contrast(DeviceContext, propertyData->Value);
			break;
		case  KSPROPERTY_VIDEOPROCAMP_GAMMA:
			status = Set_Gamma(DeviceContext, propertyData->Value);
			break;
	    case  KSPROPERTY_VIDEOPROCAMP_COLORENABLE:
			status = Set_ColorEnable(DeviceContext, propertyData->Value);
			break;
		case  KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION:
			status = Set_BackLight_Compensation(DeviceContext, propertyData->Value);
			break;
	    default:
			status = STATUS_NOT_SUPPORTED;
	}

    pSrb->Status = status;

    return status;
}


/*
** PHILIPSCAM_GetCameraControlProperty()
**
** Arguments:
**
**  DeviceContext - driver context
**
** Returns:
**
**  NT status completion code 
**  
** Side Effects:  none
*/
NTSTATUS
PHILIPSCAM_GetCameraControlProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR streamPropertyDescr = 
		    pSrb->CommandData.PropertyInfo;
    PKSPROPERTY_CAMERACONTROL_S propertyData = 
			streamPropertyDescr->PropertyInfo;
    ULONG flags = propertyData->Flags;            
    ULONG propertyID = streamPropertyDescr->Property->Id;     
    NTSTATUS status = STATUS_SUCCESS;
    
    ASSERT(streamPropertyDescr->PropertyOutputSize 
			>= sizeof(KSPROPERTY_CAMERACONTROL_S));

    switch(propertyID) 
	{
		default:
			status = STATUS_NOT_SUPPORTED;
    }

    pSrb->Status = status;    

    return status;
}


/*
** PHILIPSCAM_SetCameraControlProperty()
**
** Arguments:
**
**  DeviceContext - driver context
**
** Returns:
**
**  NT status completion code 
**  
** Side Effects:  none
*/
NTSTATUS
PHILIPSCAM_SetCameraControlProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
	PSTREAM_PROPERTY_DESCRIPTOR streamPropertyDescr = 
		    pSrb->CommandData.PropertyInfo;
    PKSPROPERTY_CAMERACONTROL_S propertyData = 
			streamPropertyDescr->PropertyInfo;
    ULONG flags = propertyData->Flags;            
    ULONG propertyID = streamPropertyDescr->Property->Id;     
    NTSTATUS status = STATUS_SUCCESS;

    switch (propertyID) 
	{
	    default:
			status = STATUS_NOT_SUPPORTED;
    }

    pSrb->Status = status;

    return status;
}


/*
** PHILIPSCAM_GetCustomProperty()
**
** Arguments:
**
**  DeviceContext - driver context
**
** Returns:
**
**  NT status completion code 
**  
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_GetCustomProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR streamPropertyDescr = 
		    pSrb->CommandData.PropertyInfo;
    PKSPROPERTY_PHILIPS_CUSTOM_PROP_S propertyData = 
			streamPropertyDescr->PropertyInfo;
    ULONG flags = propertyData->Flags;            
    ULONG propertyID = streamPropertyDescr->Property->Id;	
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT(streamPropertyDescr->PropertyOutputSize 
			>= sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S));

    switch(propertyID) 
	{
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE:
			status = Get_WB_Mode(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_SPEED:
			status = Get_WB_Speed(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_DELAY:
			status = Get_WB_Delay(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_RED_GAIN:
			status = Get_WB_Red_Gain(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_BLUE_GAIN:
			status = Get_WB_Blue_Gain(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_CONTROL_SPEED:
			status = Get_AE_Control_Speed(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS:
			status = Get_AE_Flickerless(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE:
			status = Get_AE_Shutter_Mode(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED:
			status = Get_AE_Shutter_Speed(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_STATUS:
			status = Get_AE_Shutter_Status(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE:
			status = Get_AE_AGC_Mode(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC:
			status = Get_AE_AGC(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_DRIVERVERSION:
			status = Get_DriverVersion(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE:
			status = Get_Framerate(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATES_SUPPORTED:
			status = Get_Framerates_Supported(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOFORMAT:
			status = Get_VideoFormat(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_SENSORTYPE:
			status = Get_SensorType(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOCOMPRESSION:
			status = Get_VideoCompression(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_RELEASE_NUMBER:
			status = Get_Release_Number(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_VENDOR_ID:
			status = Get_Vendor_Id(DeviceContext, &propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_PRODUCT_ID:
			status = Get_Product_Id(DeviceContext, &propertyData->Value);
			break;

        default:
			status = STATUS_NOT_SUPPORTED;
    }

	if (NT_SUCCESS(status)) 
	{
		pSrb->ActualBytesTransferred = sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S);
		propertyData->Capabilities = 0;
	}

    pSrb->Status = status;    

    return status;
}



/*
** PHILIPSCAM_SetCustomProperty()
**
** Arguments:
**
**  DeviceContext - driver context
**
** Returns:
**
**  NT status completion code 
**  
** Side Effects:  none
*/

NTSTATUS
PHILIPSCAM_SetCustomProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
	PSTREAM_PROPERTY_DESCRIPTOR streamPropertyDescr = 
	    pSrb->CommandData.PropertyInfo;
	PKSPROPERTY_PHILIPS_CUSTOM_PROP_S propertyData = 
		streamPropertyDescr->PropertyInfo;
    ULONG propertyID = streamPropertyDescr->Property->Id;     
	ULONG length, slength;
	PVOID pValue  = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    switch(propertyID) 
	{
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE:
			status = Set_WB_Mode(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_SPEED:
			status = Set_WB_Speed(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_DELAY:
			status = Set_WB_Delay(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_RED_GAIN:
			status = Set_WB_Red_Gain(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_BLUE_GAIN:
			status = Set_WB_Blue_Gain(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_CONTROL_SPEED:
			status = Set_AE_Control_Speed(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS:
			status = Set_AE_Flickerless(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE:
			status = Set_AE_Shutter_Mode(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED:
			status = Set_AE_Shutter_Speed(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE:
			status = Set_AE_AGC_Mode(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC:
			status = Set_AE_AGC(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE:
			status = Set_Framerate(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS:
			status = Set_Defaults(DeviceContext, propertyData->Value);
			break;
		default:
			status = STATUS_NOT_SUPPORTED;
    }

    pSrb->Status = status;

    return status;
}

/*
** PHILIPSCAM_GetFactoryProperty()
**
** Arguments:
**
**  DeviceContext - driver context
**
** Returns:
**
**  NT status completion code 
**  
** Side Effects:  none
*/
NTSTATUS
PHILIPSCAM_GetFactoryProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR streamPropertyDescr = 
		    pSrb->CommandData.PropertyInfo;
    PKSPROPERTY_PHILIPS_FACTORY_PROP_S propertyData = 
			streamPropertyDescr->PropertyInfo;
    ULONG flags = propertyData->Flags;            
    ULONG propertyID = streamPropertyDescr->Property->Id;	
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT(streamPropertyDescr->PropertyOutputSize 
			>= sizeof(KSPROPERTY_PHILIPS_FACTORY_PROP_S));

	RtlCopyMemory( propertyData, streamPropertyDescr->Property,
          sizeof( KSPROPERTY_PHILIPS_FACTORY_PROP_S ) );

    switch(propertyID) 
	{
		case KSPROPERTY_PHILIPS_FACTORY_PROP_REGISTER_DATA:
			status = Get_RegisterData(DeviceContext, &propertyData->Value);
			break;
		default:
			status = STATUS_NOT_SUPPORTED;
    }

	if (NT_SUCCESS(status)) 
	{
		pSrb->ActualBytesTransferred = sizeof(KSPROPERTY_PHILIPS_FACTORY_PROP_S);
		propertyData->Capabilities = 0;
	}

    pSrb->Status = status;    

    return status;
}

/*
** PHILIPSCAM_SetFactoryProperty()
**
** Arguments:
**
**  DeviceContext - driver context
**
** Returns:
**
**  NT status completion code 
**  
** Side Effects:  none
*/
NTSTATUS
PHILIPSCAM_SetFactoryProperty(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext,
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
	PSTREAM_PROPERTY_DESCRIPTOR streamPropertyDescr = 
	    pSrb->CommandData.PropertyInfo;
	PKSPROPERTY_PHILIPS_FACTORY_PROP_S propertyData = 
		streamPropertyDescr->PropertyInfo;
    ULONG propertyID = streamPropertyDescr->Property->Id;     
	ULONG length, slength;
	PVOID pValue  = NULL;
    NTSTATUS status = STATUS_SUCCESS;

//	RtlCopyMemory( propertyData, streamPropertyDescr->Property,
//            sizeof( KSPROPERTY_PHILIPS_FACTORY_PROP_S ) );

    switch(propertyID) 
	{
		case KSPROPERTY_PHILIPS_FACTORY_PROP_REGISTER_ADDRESS:
			status = Set_RegisterAddress(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_FACTORY_PROP_REGISTER_DATA:
			status = Set_RegisterData(DeviceContext, propertyData->Value);
			break;
		case KSPROPERTY_PHILIPS_FACTORY_PROP_FACTORY_MODE:
			status = Set_Factory_Mode(DeviceContext, propertyData->Value);
			break;

		default:
			status = STATUS_NOT_SUPPORTED;
    }

    pSrb->Status = status;

    return status;
}

/*==============================================================================
 *
 * Function:	PHILIPSCAM_GetVideoControlProperty
 *
 * Abstract:	
 *
 * Arguments:	
 *
 * Returns:		NTSTATUS
 *
 * SideEffects:	None
 * 
 *============================================================================*/

NTSTATUS
PHILIPSCAM_GetVideoControlProperty(
		PPHILIPSCAM_DEVICE_CONTEXT pDc, 
		PHW_STREAM_REQUEST_BLOCK pSrb)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;
	PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo; 
	DWORD dwPropertyID = pSPD->Property->Id;	 // index of the property
	DWORD dwSize  = pSPD->PropertyOutputSize;		// size of data supplied
	LONGLONG FramePeriod[] = {
			NUM_100NANOSEC_UNITS_PERFRAME(1),
			0x28B0AA						,		// 3.75 fps
            NUM_100NANOSEC_UNITS_PERFRAME(5),
			0x145855                        ,		// 7.5 fps
			NUM_100NANOSEC_UNITS_PERFRAME(10),
			NUM_100NANOSEC_UNITS_PERFRAME(12),
			NUM_100NANOSEC_UNITS_PERFRAME(15),
			NUM_100NANOSEC_UNITS_PERFRAME(20),
			NUM_100NANOSEC_UNITS_PERFRAME(24)
	};
    USHORT	CIFFrameRatesList[] = 
	{
		   FRRATE375,
           FRRATE5,
           FRRATE75,
           FRRATE10,
           FRRATE12,
           FRRATE15
	};
	USHORT QCIFFrameRatesList[] =
	{
		   FRRATE5,
           FRRATE75,
           FRRATE10,
           FRRATE12,
           FRRATE15,
           FRRATE20,
           FRRATE24
	};

	ULONG i;


	PHILIPSCAM_KdPrint(MAX_TRACE, ("enter GetVideoControlProperty\n"));

	switch(dwPropertyID)
	{
	case KSPROPERTY_VIDEOCONTROL_CAPS:
		ntStatus = pSrb->Status = STATUS_NOT_SUPPORTED;
		break;
  	case KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE:
	{
		PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S pInputData = 
			(PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S) pSPD->Property;
		PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S pOutputData = 
			(PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S) pSPD->PropertyInfo;

    	if (pInputData->StreamIndex != 0) {
            ntStatus = pSrb->Status = STATUS_NOT_SUPPORTED;
            return ntStatus;
		}

		if (dwSize == 0)
		{
			pSrb->ActualBytesTransferred =
					sizeof(KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S);
			ntStatus = pSrb->Status = STATUS_BUFFER_OVERFLOW;
		}
		else if (dwSize >=
					sizeof(KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S))
		{
			pSrb->ActualBytesTransferred =
					sizeof(KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S);
			
			pOutputData->CurrentActualFrameRate = 
				FramePeriod[pDc->CamStatus.PictureFrameRate];

			for (i = FRRATE24; (i > FRRATEVGA)&&(pDc->FrrSupported[i] == FALSE); i--);

			pOutputData->CurrentMaxAvailableFrameRate = FramePeriod[i];
            ntStatus = pSrb->Status = STATUS_SUCCESS;
		}
	}
		break;
	case KSPROPERTY_VIDEOCONTROL_FRAME_RATES:
	{
        PKSPROPERTY_VIDEOCONTROL_FRAME_RATES_S pFrRInfo =
        	(PKSPROPERTY_VIDEOCONTROL_FRAME_RATES_S) pSPD->Property;
        ULONG BytesNeeded;

        // First value of Framerate table (FRRATEVGA) disabled as selectable value.
        PKSMULTIPLE_ITEM pOutputBuf = (PKSMULTIPLE_ITEM) pSPD->PropertyInfo;
        LONGLONG * pDataPtr = (LONGLONG*) (pOutputBuf + 1);

        if (pFrRInfo->Dimensions.cx > QCIF_X)
        {
            BytesNeeded = sizeof(KSMULTIPLE_ITEM) + 					
        	    	SIZEOF_ARRAY(CIFFrameRatesList) * sizeof(LONGLONG);		
        }
        else		
        {
            BytesNeeded = sizeof(KSMULTIPLE_ITEM) + 					
        	    	SIZEOF_ARRAY(QCIFFrameRatesList) * sizeof(LONGLONG);
        }

        if (dwSize == 0)
        {
        	pSrb->ActualBytesTransferred = BytesNeeded;
        	ntStatus = pSrb->Status = STATUS_BUFFER_OVERFLOW;
        }
        else
        {
        	if (dwSize >= BytesNeeded)
        	{
            //framerate list depends on requested pict.size
        		if (pFrRInfo->Dimensions.cx > QCIF_X)
        		{
        			//Use CIF Frame rate list
        		    pOutputBuf->Size = (SIZEOF_ARRAY(CIFFrameRatesList) * sizeof(LONGLONG));
        		    pOutputBuf->Count = SIZEOF_ARRAY(CIFFrameRatesList);
        		    for ( i=0 ; i < SIZEOF_ARRAY(CIFFrameRatesList) ; i++)
        			{
        			    pDataPtr[i] = FramePeriod[CIFFrameRatesList[i]];
        			}

        		    pSrb->ActualBytesTransferred = sizeof(KSMULTIPLE_ITEM) + 					
        			    	SIZEOF_ARRAY(CIFFrameRatesList) * sizeof(LONGLONG);
        		}
        		else
        		{
        			// Use QCIF Frame rate list
        		    pOutputBuf->Size = (SIZEOF_ARRAY(QCIFFrameRatesList) * sizeof(LONGLONG));
        		    pOutputBuf->Count = SIZEOF_ARRAY(QCIFFrameRatesList);
        		    for ( i=0 ; i < SIZEOF_ARRAY(QCIFFrameRatesList) ; i++)
        			{
        			    pDataPtr[i] = FramePeriod[QCIFFrameRatesList[i]];
        			}

        		    pSrb->ActualBytesTransferred = sizeof(KSMULTIPLE_ITEM) + 					
        			    	SIZEOF_ARRAY(QCIFFrameRatesList) * sizeof(LONGLONG);
        		}
        		ntStatus = pSrb->Status = STATUS_SUCCESS;
        	}

#if NOTACTIVE
			{
				pOutputBuf->Size = ((SIZEOF_ARRAY(FramePeriod)-1) * sizeof(LONGLONG));
				pOutputBuf->Count = SIZEOF_ARRAY(FramePeriod)-1;

				for ( i=1 ; i < SIZEOF_ARRAY(FramePeriod) ; i++)
				{
					pDataPtr[i-1] = FramePeriod[i];
				}

				pSrb->ActualBytesTransferred = sizeof(KSMULTIPLE_ITEM) + 
									(SIZEOF_ARRAY(FramePeriod) - 1) * sizeof(LONGLONG);

				ntStatus = pSrb->Status = STATUS_SUCCESS;
			}
#endif
			else
			{
				ntStatus = pSrb->Status = STATUS_NOT_SUPPORTED;
			}
		}
	}
		break;
	case KSPROPERTY_VIDEOCONTROL_MODE:
	{
		ntStatus = pSrb->Status = STATUS_NOT_SUPPORTED;
	}
		break;  

	default:
		ntStatus = pSrb->Status = STATUS_NOT_SUPPORTED;
	}
	
	return ntStatus;
}

/*==============================================================================
 *
 * Function:	PHILIPSCAM_SetVideoControlProperty
 *
 * Abstract:	
 *
 * Arguments:	
 *
 * Returns:		NTSTATUS
 *
 * SideEffects:	None
 * 
 *============================================================================*/

NTSTATUS
PHILIPSCAM_SetVideoControlProperty(
		PPHILIPSCAM_DEVICE_CONTEXT  pDc, 
		PHW_STREAM_REQUEST_BLOCK pSrb)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;
	PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo; 
	DWORD dwPropertyID = pSPD->Property->Id;	 // index of the property


	PHILIPSCAM_KdPrint(MAX_TRACE, ("enter SetVideoControlProperty\n"));

	ASSERT (pSPD->PropertyInputSize >= sizeof (KSPROPERTY_VIDEOCONTROL_MODE_S));

	switch(dwPropertyID)
	case KSPROPERTY_VIDEOCONTROL_CAPS:
  	case KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE:
	case KSPROPERTY_VIDEOCONTROL_FRAME_RATES:
	case KSPROPERTY_VIDEOCONTROL_MODE:
	default:
		ntStatus = pSrb->Status = STATUS_NOT_SUPPORTED;

	return ntStatus;
}


/*===========================================================================*/
NTSTATUS
PHILIPSCAM_SetFormatFramerate(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext
	)
/*===========================================================================*/
{
	UCHAR Buffer[3]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;
	LONG hVideoFormat, hFramerate, hCompression;

    if ( (DeviceContext->CamStatus.PictureFormat == FORMATCIF) ||
         (DeviceContext->CamStatus.PictureFormat == FORMATSIF) ||
         (DeviceContext->CamStatus.PictureFormat == FORMATSSIF)||
		 (DeviceContext->CamStatus.PictureFormat == FORMATSCIF)  ){
	  if (DeviceContext->CamStatus.PictureFrameRate == 	FRRATE375){
	    DeviceContext->CamStatus.PictureCompressing = COMPRESSION0;
	  }else{
	    if (DeviceContext->CamStatus.ReleaseNumber >= SSI_CIF3){
	      DeviceContext->CamStatus.PictureCompressing = COMPRESSION3;
	    }else{
	      DeviceContext->CamStatus.PictureCompressing = COMPRESSION4;
	    }
	  }
	}else{
	  DeviceContext->CamStatus.PictureCompressing = COMPRESSION0;
	}
	status = Map_Framerate_Drv_to_KS(DeviceContext, &hFramerate);
	if (!NT_SUCCESS(status)) 
		return status;
	status = Map_VideoFormat_Drv_to_KS(DeviceContext, &hVideoFormat);
	if (!NT_SUCCESS(status)) 
		return status;
	status = Map_VideoCompression_Drv_to_KS(DeviceContext, &hCompression);
	if (!NT_SUCCESS(status)) 
		return status;

	Buffer[bFRAMERATE] = (BYTE)hFramerate;
	Buffer[bVIDEOOUTPUTTYPE] = (BYTE)hVideoFormat;
	Buffer[bCOMPRESSIONFACT] = (BYTE)hCompression;
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
			SET_EP_STREAM_CTL, VIDEO_OUTPUT_CONTROL_FORMATTER, VIDEO_ENDPOINT,
	           Buffer, &BufferLength, SEND, NULL, NULL);
	   

    return status;

}

/*===========================================================================*/
NTSTATUS
PHILIPSCAM_GetSensorType(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext
	)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
			GET_STATUS_CTL, SENSOR_TYPE, VC_INTERFACE,
	           Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
			DeviceContext->CamStatus.SensorType = Buffer[0];

	return status;
}

/*===========================================================================*/
NTSTATUS
PHILIPSCAM_GetReleaseNumber(
    PPHILIPSCAM_DEVICE_CONTEXT DeviceContext
	)
/*===========================================================================*/
{
	UCHAR Buffer[2]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
			GET_STATUS_CTL, RELEASE_NUMBER, VC_INTERFACE,
		    Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) // ?? need to map to camera value ranges ??
	{
		DeviceContext->CamStatus.ReleaseNumber = 
				(((LONG)Buffer[1] << 8) | (LONG)Buffer[0]);
	}

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_Brightness(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pBrightness)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_LUM_CTL, BRIGHTNESS, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
			(*pBrightness) = Buffer[0] * BRIGHTNESS_DELTA;

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_Brightness(
	   PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
	   LONG Brightness)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	Buffer[0] = (UCHAR)(Brightness / BRIGHTNESS_DELTA);
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_LUM_CTL, BRIGHTNESS, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);
	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_Contrast(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pContrast)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_LUM_CTL, CONTRAST, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
			(*pContrast) = Buffer[0] * CONTRAST_DELTA;
	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_Contrast(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG Contrast)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	Buffer[0] = (UCHAR)(Contrast / CONTRAST_DELTA);
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_LUM_CTL, CONTRAST, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_Gamma(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pGamma)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_LUM_CTL, GAMMA, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
			(*pGamma) = Buffer[0] * GAMMA_DELTA;
	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_Gamma(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG Gamma)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	Buffer[0] = (UCHAR)(Gamma / GAMMA_DELTA);
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_LUM_CTL, GAMMA, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_ColorEnable(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pColorEnable)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_CHROM_CTL, COLOR_MODE, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
	{
		if (Buffer[0] ==(UCHAR)0)
			(*pColorEnable) = COLORENABLE_MIN;
		else
			(*pColorEnable) = COLORENABLE_MAX;
	}

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_ColorEnable(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG ColorEnable)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	if (ColorEnable == COLORENABLE_MIN)
		Buffer[0] = (UCHAR)0;
	else
		Buffer[0] = (UCHAR)0xff;
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_CHROM_CTL, COLOR_MODE, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);
	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_BackLight_Compensation(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pBackLight_Compensation)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_LUM_CTL, BACK_LIGHT_COMPENSATION, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
	{
		if (Buffer[0] ==(UCHAR)0)
			(*pBackLight_Compensation) = BACKLIGHT_COMPENSATION_MIN;
		else
			(*pBackLight_Compensation) = BACKLIGHT_COMPENSATION_MAX;
	}
	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_BackLight_Compensation(
	  PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
	  LONG BackLight_Compensation)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	if (BackLight_Compensation == BACKLIGHT_COMPENSATION_MIN)
		Buffer[0] = (UCHAR)0;
	else
		Buffer[0] = (UCHAR)0xff;
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_LUM_CTL, BACK_LIGHT_COMPENSATION, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_WB_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pWB_Mode)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;
	
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
					GET_CHROM_CTL, WB_MODE, VC_INTERFACE,
					Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
			(*pWB_Mode) = Buffer[0];
	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_WB_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG WB_Mode)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;
		
	/*
	 * switch to new mode
	 */
	Buffer[0] = (UCHAR)WB_Mode;
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
					SET_CHROM_CTL, WB_MODE, VC_INTERFACE,
					Buffer, &BufferLength, SEND, NULL, NULL);
	if (!NT_SUCCESS(status)) 
		return status;

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_WB_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pWB_Speed)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_CHROM_CTL, AWB_CONTROL_SPEED, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
			(*pWB_Speed) = Buffer[0] * WB_SPEED_DELTA;
	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_WB_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG WB_Speed)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	Buffer[0] = (UCHAR)(WB_Speed / WB_SPEED_DELTA);
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_CHROM_CTL, AWB_CONTROL_SPEED, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_WB_Delay(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pWB_Delay)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_CHROM_CTL, AWB_CONTROL_DELAY, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
			(*pWB_Delay) = Buffer[0] * WB_DELAY_DELTA;

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_WB_Delay(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG WB_Delay)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	Buffer[0] = (UCHAR)(WB_Delay / WB_DELAY_DELTA);
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_CHROM_CTL, AWB_CONTROL_DELAY, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);
	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_WB_Red_Gain(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pWB_Red_Gain)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_CHROM_CTL, RED_GAIN, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
			(*pWB_Red_Gain) = Buffer[0] * WB_RED_GAIN_DELTA;

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_WB_Red_Gain(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG WB_Red_Gain)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	Buffer[0] = (UCHAR)(WB_Red_Gain / WB_RED_GAIN_DELTA);
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_CHROM_CTL, RED_GAIN, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);
	
	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_WB_Blue_Gain(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pWB_Blue_Gain)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
			GET_CHROM_CTL, BLUE_GAIN, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
		(*pWB_Blue_Gain) = Buffer[0] * WB_BLUE_GAIN_DELTA;

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_WB_Blue_Gain(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG WB_Blue_Gain)
/*===========================================================================*/
{
	UCHAR Buffer[1] = {0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	Buffer[0] = (UCHAR)(WB_Blue_Gain / WB_BLUE_GAIN_DELTA);
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_CHROM_CTL, BLUE_GAIN, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_AE_Control_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_Control_Speed)
/*===========================================================================*/
{
	UCHAR Buffer[1] = {0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_LUM_CTL, AE_CONTROL_SPEED, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
			(*pAE_Control_Speed) = Buffer[0] * AE_CONTROL_SPEED_DELTA;

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_AE_Control_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_Control_Speed)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	Buffer[0] = (UCHAR)(AE_Control_Speed / AE_CONTROL_SPEED_DELTA);
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_LUM_CTL, AE_CONTROL_SPEED, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);
	
	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_AE_Flickerless(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_Flickerless)
/*===========================================================================*/
{
	UCHAR Buffer[1] = {0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_LUM_CTL, FLICKERLESS, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
	{
		if (Buffer[0] == (UCHAR)0)
			(*pAE_Flickerless) = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS_OFF;
		else
			(*pAE_Flickerless) = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS_ON;
	}

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_AE_Flickerless(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_Flickerless)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

   	if (AE_Flickerless == KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS_OFF)
		Buffer[0] = (UCHAR)0;
	else
		Buffer[0] = (UCHAR)0xff;
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_LUM_CTL, FLICKERLESS, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_AE_Shutter_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_Shutter_Mode)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_LUM_CTL, SHUTTER_MODE, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
	{
		if (Buffer[0] == (UCHAR)0)
			(*pAE_Shutter_Mode) = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_AUTO;
		else
			(*pAE_Shutter_Mode) = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_FIXED;
	}

	return status;
}


/*===========================================================================*/
static NTSTATUS 
Set_AE_Shutter_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_Shutter_Mode)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	if (AE_Shutter_Mode == KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_AUTO)
		Buffer[0] = (UCHAR)0;
	else
		Buffer[0] = (UCHAR)0xff;
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
			SET_LUM_CTL, SHUTTER_MODE, VC_INTERFACE,
	           Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_AE_Shutter_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_Shutter_Speed)
/*===========================================================================*/
{
	UCHAR Buffer[2]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_LUM_CTL, PRESET_SHUTTER, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) // ?? need to map to camera value ranges ??
	{
		(*pAE_Shutter_Speed) = (LONG)Buffer[0];
	}

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_AE_Shutter_Speed(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_Shutter_Speed)
/*===========================================================================*/
{
	UCHAR Buffer[2]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

		// ?? need to map to camera value ranges ??
   	Buffer[0] = (UCHAR)(AE_Shutter_Speed);

		// status field always equal in set command
	Buffer[1] = (UCHAR)KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_STATUS_EQUAL;		

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_LUM_CTL, PRESET_SHUTTER, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_AE_Shutter_Status(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_Shutter_Status)
/*===========================================================================*/
{
	UCHAR Buffer[2]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_LUM_CTL, PRESET_SHUTTER, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) // ?? need to map to camera value ranges ??
	{
		(*pAE_Shutter_Status) = (LONG)Buffer[1];
	}

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_AE_AGC_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_AGC_Mode)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_LUM_CTL, AGC_MODE, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
	{
		if (Buffer[0] == (UCHAR)0)
			(*pAE_AGC_Mode) = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_AUTO;
		else
			(*pAE_AGC_Mode) = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_FIXED;
	}

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_AE_AGC_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_AGC_Mode)
/*===========================================================================*/
{
	UCHAR Buffer[1] = {0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	if (AE_AGC_Mode == KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_AUTO)
		Buffer[0] = (UCHAR)0;
	else
		Buffer[0] = (UCHAR)0xff;
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
			SET_LUM_CTL, AGC_MODE, VC_INTERFACE,
	           Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_AE_AGC(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pAE_AGC)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				GET_LUM_CTL, PRESET_AGC, VC_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
			(*pAE_AGC) = Buffer[0] * AE_AGC_DELTA;

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_AE_AGC(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG AE_AGC)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	Buffer[0] = (UCHAR)(AE_AGC / AE_AGC_DELTA);
	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_LUM_CTL, PRESET_AGC, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_DriverVersion(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pDriverVersion)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;

	(*pDriverVersion) = DRIVERVERSION; //DeviceContext->DriverVersion;

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_Framerate(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pFramerate)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;
	
	status = Map_Framerate_Drv_to_KS(DeviceContext, pFramerate);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_Framerate(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		LONG Framerate)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;
	
	status = Map_Framerate_KS_to_Drv(DeviceContext, Framerate);
	if (!NT_SUCCESS(status)) 
			return status;

	status = PHILIPSCAM_SetFormatFramerate(DeviceContext);

	return status;
}

/*===========================================================================*/
static NTSTATUS
Get_Framerates_Supported(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pFramerates_Supported)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;
	int i;

	(*pFramerates_Supported) = 0x0;
	for (i = 0; i < 9; i++)
	{
		if (DeviceContext->FrrSupported[i])
			(*pFramerates_Supported) |= (0x1 << i);
	}

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_VideoFormat(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pVideoFormat)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;

	status = Map_VideoFormat_Drv_to_KS(DeviceContext, pVideoFormat);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_SensorType(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pSensorType)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;

	(*pSensorType) = DeviceContext->CamStatus.SensorType;

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_VideoCompression(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pVideoCompression)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;

	status = Map_VideoCompression_Drv_to_KS(DeviceContext, pVideoCompression);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_Defaults(
	PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
	LONG Command)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;

	switch(Command)
	{
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS_RESTORE_USER:
			status = PHILIPSCAM_Defaults_Restore_User(DeviceContext);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS_SAVE_USER:
			status = PHILIPSCAM_Defaults_Save_User(DeviceContext);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS_RESTORE_FACTORY:
			status = PHILIPSCAM_Defaults_Restore_Factory(DeviceContext);
			break;
		default:
			status = STATUS_NOT_SUPPORTED;
	}

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_Release_Number(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pRelease_Number)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;

	(*pRelease_Number) = DeviceContext->CamStatus.ReleaseNumber;

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_Vendor_Id(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pVendor_Id)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;
	LONG lVendor_Id_Hsb, lVendor_Id_Lsb;

	// set to factorymode
	status = Set_Factory_Mode(DeviceContext, 0x6d);
	if (status != STATUS_SUCCESS)
		return status;

	// set LSB address
	status = Set_RegisterAddress(DeviceContext, 0x1A5);
	if (status != STATUS_SUCCESS)
		goto Get_Vendor_Id_Err;

	// get LSB of vendor id
	status = Get_RegisterData(DeviceContext, &lVendor_Id_Lsb);
	if (status != STATUS_SUCCESS)
		goto Get_Vendor_Id_Err;

	// set HSB address
	status = Set_RegisterAddress(DeviceContext, 0x1A6);
	if (status != STATUS_SUCCESS)
		goto Get_Vendor_Id_Err;

	// get HSB of vendor id
	status = Get_RegisterData(DeviceContext, &lVendor_Id_Hsb);
	if (status != STATUS_SUCCESS)
		goto Get_Vendor_Id_Err;

	// revert to normal operation
	Set_Factory_Mode(DeviceContext, 0x0);
	
	// compose vendor id from lsb and hsb
	(*pVendor_Id) = ((lVendor_Id_Hsb & 0xff) << 8) | (lVendor_Id_Lsb & 0xff);

	return status;

Get_Vendor_Id_Err:
	// revert to normal operation
	Set_Factory_Mode(DeviceContext, 0x0);
	return status;
}

/*===========================================================================*/
static NTSTATUS 
Get_Product_Id(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext, 
		PLONG pProduct_Id)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;
	LONG lProduct_Id_Hsb, lProduct_Id_Lsb;

	// set to factorymode
	status = Set_Factory_Mode(DeviceContext, 0x6d);
	if (status != STATUS_SUCCESS)
		return status;

	// set LSB address
	status = Set_RegisterAddress(DeviceContext, 0x1A7);
	if (status != STATUS_SUCCESS)
		goto Get_Product_Id_Err;

	// get LSB of Product id
	status = Get_RegisterData(DeviceContext, &lProduct_Id_Lsb);
	if (status != STATUS_SUCCESS)
		goto Get_Product_Id_Err;

	// set HSB address
	status = Set_RegisterAddress(DeviceContext, 0x1A8);
	if (status != STATUS_SUCCESS)
		goto Get_Product_Id_Err;

	// get HSB of Product id
	status = Get_RegisterData(DeviceContext, &lProduct_Id_Hsb);
	if (status != STATUS_SUCCESS)
		goto Get_Product_Id_Err;

	// revert to normal operation
	Set_Factory_Mode(DeviceContext, 0x0);
	
	// compose Product id from lsb and hsb
	(*pProduct_Id) = ((lProduct_Id_Hsb & 0xff) << 8) | (lProduct_Id_Lsb & 0xff);

	return status;

Get_Product_Id_Err:
	// revert to normal operation
	Set_Factory_Mode(DeviceContext, 0x0);
	return status;
}


/*===========================================================================*/
static NTSTATUS 
Get_RegisterData(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext, 
		PLONG pValue)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(pDeviceContext,
				GET_FACTORY_CTL, (USHORT)Address, FACTORY_INTERFACE,
	            Buffer, &BufferLength, GET, NULL, NULL);
	if (NT_SUCCESS(status)) 
			(*pValue) = Buffer[0];

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_RegisterAddress(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext, 
		LONG AddressToSet)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;

	// swap high/low byte of address
	Address = HIBYTE(AddressToSet) | (LOBYTE(AddressToSet) << 8);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_RegisterData(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext, 
		LONG Value)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	Buffer[0] = (BYTE)Value;
	status = PHILPCAM_ControlVendorCommand(pDeviceContext,
				SET_FACTORY_CTL, (USHORT)Address, FACTORY_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
Set_Factory_Mode(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext, 
		LONG Factory_Mode)
/*===========================================================================*/
{
	UCHAR Buffer[1]={0};
	ULONG BufferLength = sizeof(Buffer);
	NTSTATUS status = STATUS_SUCCESS;

	Buffer[0] = (UCHAR)Factory_Mode;

	status = PHILPCAM_ControlVendorCommand(pDeviceContext,
				SET_STATUS_CTL, FACTORY_MODE, VC_INTERFACE,
	            Buffer, &BufferLength, SEND, NULL, NULL);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
PHILIPSCAM_Defaults_Restore_User(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_STATUS_CTL, RESTORE_USER_DEFAULTS, VC_INTERFACE,
			    NULL, 0, SEND, NULL, NULL);
	
	// restore all driver defaults
	if (NT_SUCCESS(status)) 
		status = PHILIPSCAM_RestoreDriverDefaults(DeviceContext);

	return status;
}

/*===========================================================================*/
static NTSTATUS 
PHILIPSCAM_Defaults_Save_User(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;

   	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_STATUS_CTL, SAVE_USER_DEFAULTS, VC_INTERFACE,
			    NULL, 0, SEND, NULL, NULL);

	return status;
}


/*===========================================================================*/
static NTSTATUS 
PHILIPSCAM_Defaults_Restore_Factory(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;

	status = PHILPCAM_ControlVendorCommand(DeviceContext,
				SET_STATUS_CTL, RESTORE_FACTORY_DEFAULTS, VC_INTERFACE,
			    NULL, 0, SEND, NULL, NULL);

	// restore all driver defaults
	if (NT_SUCCESS(status)) 
		status = PHILIPSCAM_RestoreDriverDefaults(DeviceContext);

	return status;

}

/*===========================================================================*/
static NTSTATUS 
PHILIPSCAM_RestoreDriverDefaults(
		PPHILIPSCAM_DEVICE_CONTEXT DeviceContext)
/*===========================================================================*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;

    ntStatus = Get_Brightness(DeviceContext, &Brightness_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_Contrast(DeviceContext, &Contrast_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_Gamma(DeviceContext, &Gamma_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_ColorEnable(DeviceContext, &ColorEnable_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_BackLight_Compensation(DeviceContext, &BackLight_Compensation_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;

    ntStatus = Get_WB_Mode(DeviceContext, &WB_Mode_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_WB_Speed(DeviceContext, &WB_Speed_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_WB_Delay(DeviceContext, &WB_Delay_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_WB_Red_Gain(DeviceContext, &WB_Red_Gain_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_WB_Blue_Gain(DeviceContext, &WB_Blue_Gain_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;

    ntStatus = Get_AE_Control_Speed(DeviceContext, &AE_Control_Speed_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_AE_Flickerless(DeviceContext, &AE_Flickerless_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_AE_Shutter_Mode(DeviceContext, &AE_Shutter_Mode_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_AE_Shutter_Speed(DeviceContext, &AE_Shutter_Speed_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_AE_AGC_Mode(DeviceContext, &AE_AGC_Mode_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_AE_AGC(DeviceContext, &AE_AGC_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;

    ntStatus = Get_Framerate(DeviceContext, &Framerate_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_VideoFormat(DeviceContext, &VideoFormat_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;
    ntStatus = Get_VideoCompression(DeviceContext, &VideoCompression_Default);
    if (STATUS_DEVICE_NOT_CONNECTED == ntStatus)
        return STATUS_DEVICE_NOT_CONNECTED;
    else
        status |= ntStatus;

	// hack; not all defaults are accesible yet, thus 
	// status will be FAIL
	// this must be removed when all supported
	status = STATUS_SUCCESS; 

	return status;
}

/*===========================================================================*/
static NTSTATUS Map_Framerate_Drv_to_KS(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext,
		PLONG pFramerate)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;
	static BYTE Map_PHFRAMERATE_To_SSI[] = 
		{	
			FRAMERATE_VGA,
			FRAMERATE_375,
			FRAMERATE_5,
			FRAMERATE_75,
			FRAMERATE_10,
			FRAMERATE_12,
			FRAMERATE_15,
			FRAMERATE_20,
			FRAMERATE_24,
		};
	if (pDeviceContext->CamStatus.PictureFrameRate < 0 || 
			pDeviceContext->CamStatus.PictureFrameRate >= 9)
		return STATUS_INVALID_PARAMETER;

	(*pFramerate) = 
			Map_PHFRAMERATE_To_SSI[pDeviceContext->CamStatus.PictureFrameRate];

	return status;
}

/*===========================================================================*/
static NTSTATUS Map_Framerate_KS_to_Drv(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext,
		LONG Framerate)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;

	switch(Framerate)
	{
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_VGA: 
			pDeviceContext->CamStatus.PictureFrameRate = FRRATEVGA;
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_375:
			pDeviceContext->CamStatus.PictureFrameRate = FRRATE375;
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_5:
			pDeviceContext->CamStatus.PictureFrameRate = FRRATE5;
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_75:
			pDeviceContext->CamStatus.PictureFrameRate = FRRATE75;
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_10:
			pDeviceContext->CamStatus.PictureFrameRate = FRRATE10;
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_12:
			pDeviceContext->CamStatus.PictureFrameRate = FRRATE12;
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_15:
			pDeviceContext->CamStatus.PictureFrameRate = FRRATE15;
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_20:
			pDeviceContext->CamStatus.PictureFrameRate = FRRATE20;
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_24:
			pDeviceContext->CamStatus.PictureFrameRate = FRRATE24;
			break;
		default:
			status = STATUS_INVALID_PARAMETER;
	}
	PHILIPSCAM_KdPrint (MIN_TRACE, ("Picture Frame Rate = %d\n",
						pDeviceContext->CamStatus.PictureFrameRate));
	return status;
}

/*===========================================================================*/
static NTSTATUS Map_VideoFormat_Drv_to_KS(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext,
		PLONG pVideoFormat)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;
	static BYTE Map_PHFORMAT_To_SSI[] = 
		{// SSI	(camera)	 STREAM (UserInterface)
			CIF_FORMAT,      //  FORMATCIF
			QCIF_FORMAT,	 //  FORMATQCIF
			SQCIF_FORMAT,	 //  FORMATSQCIF
			SQCIF_FORMAT,	 //  FORMATQQCIF
			VGA_FORMAT,		 //  FORMATVGA
			CIF_FORMAT,		 //  FORMATSIF
			CIF_FORMAT,		 //  FORMATSSIF
			QCIF_FORMAT,	 //  FORMATQSIF
			SQCIF_FORMAT,	 //  FORMATSQSIF 
			CIF_FORMAT,      //  FORMATSCIF
		};	

	if (pDeviceContext->CamStatus.PictureFormat < FORMATCIF || 
			pDeviceContext->CamStatus.PictureFormat > FORMATSCIF)
		return STATUS_INVALID_PARAMETER;

	(*pVideoFormat) = 
			Map_PHFORMAT_To_SSI[pDeviceContext->CamStatus.PictureFormat];

	return status;
}

/*===========================================================================*/
static NTSTATUS Map_VideoCompression_Drv_to_KS(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext,
		PLONG pVideoCompression)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;
	static BYTE Map_PHCOMPRESSION_To_SSI[] = 
		{
			UNCOMPRESSED,
			COMPRESSED_3,
			COMPRESSED_4
		};

	if (pDeviceContext->CamStatus.PictureCompressing < 0 ||
			pDeviceContext->CamStatus.PictureCompressing > 2)
		return STATUS_INVALID_PARAMETER;
	(*pVideoCompression) = 
			Map_PHCOMPRESSION_To_SSI[pDeviceContext->CamStatus.PictureCompressing];
	
	return status;
}

/*===========================================================================*/
//static VOID
//PHILIPSCAM_TimeoutDPC(
//    PKDPC Dpc,
//    PVOID DeferredContext,
//    PVOID SystemArgument1,
//    PVOID SystemArgument2
//    )
/*===========================================================================*/
//{
//	bTimerExpired = TRUE;    
//}

/*===========================================================================*/
static NTSTATUS
PHILPCAM_ControlVendorCommand(
		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext,
		UCHAR Request,
		USHORT Value,
		USHORT Index,
		PVOID Buffer,
		PULONG BufferLength,
		BOOLEAN GetData,
		PCOMMAND_COMPLETE_FUNCTION CommandComplete,
		PVOID CommandContext)
/*===========================================================================*/
{
	NTSTATUS status = STATUS_SUCCESS;
	LARGE_INTEGER SystemTimeCurrent = {0};
	LARGE_INTEGER SystemTimeStart = {0};

	KeQuerySystemTime(&SystemTimeStart);

	while(1)
	{
		status = USBCAMD_ControlVendorCommand(
				pDeviceContext,
				Request,
				Value,
				Index,
				Buffer,
				BufferLength,
				GetData,
				CommandComplete,
				CommandContext);
		if (NT_SUCCESS(status) || STATUS_DEVICE_NOT_CONNECTED == status) 
			break;

		KeQuerySystemTime(&SystemTimeCurrent);
		if ((SystemTimeCurrent.QuadPart - SystemTimeStart.QuadPart) > (10000 * WAIT_FOR_COMPLETION))
			break;
	}

	return status;	
}

/*===========================================================================*/
//static NTSTATUS
//PHILPCAM_ControlVendorCommand(
//		PPHILIPSCAM_DEVICE_CONTEXT pDeviceContext,
//		UCHAR Request,
//		USHORT Value,
//		USHORT Index,
//		PVOID Buffer,
//		PULONG BufferLength,
//		BOOLEAN GetData,
//		PCOMMAND_COMPLETE_FUNCTION CommandComplete,
//		PVOID CommandContext)
/*===========================================================================*/
//{
//	NTSTATUS status = STATUS_SUCCESS;
//	int i;
//  KTIMER TimeoutTimer;
//    KDPC TimeoutDpc;
//	LARGE_INTEGER dueTime;

//	bTimerExpired = FALSE;


	// start timer
//	KeInitializeTimer(&TimeoutTimer);
//  KeInitializeDpc(&TimeoutDpc,
//                PHILIPSCAM_TimeoutDPC,
//                CurrentpSrb->Irp);
		
//    dueTime.QuadPart = -10000 * WAIT_FOR_COMPLETION;

//    KeSetTimer(&TimeoutTimer,
//				dueTime,
//                &TimeoutDpc);        

//	while(!bTimerExpired)
//	{
//		status = USBCAMD_ControlVendorCommand(
//				pDeviceContext,
//				Request,
//				Value,
//				Index,
//				Buffer,
//				BufferLength,
//				GetData,
//				CommandComplete,
//				CommandContext);
/*		if (NT_SUCCESS(status)) 
			break;*/
//	}

//    KeCancelTimer(&TimeoutTimer);

//	return status;	
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mprpobj.h ===
#ifndef __MPRPOBJ_H__
#define __MPRPOBJ_H__

/*++

Copyright (c) 1997 1998 PHILIPS  I&C

Module Name:  mprpobj.c

Abstract:     Property handling module

Author:       Michael Verberne

Revision History:

Date        Reason

Sept.22, 98 Optimized for NT5
Nov. 30, 98 PID, VID and pushbutton flag added as custom properties

--*/	

/*
 * This file defines custom properties for the 
 * camera. These properties are additional to the 
 * property sets VideoProcAmp and CameraControl as 
 * defined in ksmedia.h
 *
 * The set of properties that is currently supported 
 * by the minidriver is a subset of the properties 
 * defined in the CRS (VGAUSB13.DOC) 
 *
 * Note 1: Most of the ranges in the table(s) above
 * follow from the SSI Lionsoft Philips Desktop Video 
 * Camera
 * 
 * Note 2: The Pan and Tilt properties (in SQ-CIF) are 
 * part of PROPSETID_VIDCAP_CAMERACONTROL. These 
 * properties must be added at a later stage.
 *
 * Note 3: Color Saturation is part of 
 * PROPSETID_VIDCAP_VIDEOPROCAMP. This must be added 
 * at a later stage.
 *
 *-------------------------------------------------------
 * Properties defined in PROPSETID_VIDCAP_VIDEOPROCAMP
 *
 * PROPERTY					RANGE			ACTIVE STATE
 *
 * Contrast					-32..31			Always
 *
 * Brightness				?? 0..31		Always
 *
 * Back_Light_Compensation	0 = Off			Always
 *							1 = On
 *
 * Color Enable				0 = Off			Always
 *							1 = On
 *
 * Gamma					0..100			Always
 *
 *-------------------------------------------------------
 * Properties defined in PROPSETID_PHILIPS_CUSTOM_PROP
 *
 * PROPERTY					RANGE			ACTIVE STATE
 *
 * White Balance			0 = Indoor |	Always
 *							1 = Outdoor |
 *							2 = FL |
 *							3 = Auto |
 *							4 = Manual
 *
 * White Balance Speed		1..32			In WB_Auto
 *
 * White Balance Delay		1..63			In WB_Auto
 *
 * White Balance Red Gain	0..255			In WB_Manual
 *
 * White Balance Blue_Gain	0..255			In WB_Manual
 *
 * Auto exposure			8..255
 * speed control			
 *
 * Shutterspeed				0 = 1/25,		In Shutter Fixed
 *							1 = 1/33, 
 *							2 = 1/50, 
 *							3 = 1/100, 
 *							4 = 1/250,
 *							5 = 1/500,
 *							6 = 1/1000
 *							7 = 1/1500
 *							8 = 1/2500
 *							9 = 1/5000
 *							a = 1/10000
 *
 * Shutter Mode 			0				Auto Mode
 *							0xff			Fixed Mode
 *
 * Shutter Status			0				Smaller
 *							1				Equal
 *							2				Greater
 *
 * AGC Mode					0				Auto Mode
 *							0xff			Fixed Mode
 *
 * AGC Speed				0..0x9f			In AGC Mode Auto
 *
 * Framerate				ff = VGA,		still image for VGA
 *							1 = 3.75		CIF
 *							2 = 5,			Always
 *							3 = 7,5			Always
 *							4 = 10,			Always
 *							5 = 12,			Not for VGA
 *							6 = 15,			Always
 *							7 = 20,			Q-CIF/SQ-CIF
 *							8 = 24			Q-CIF/SQ-CIF
 *
 * Framerate supported		returns a long representing 
 *							the currently available 
 *							framerates
 *							b0			VGA
 *							b1			3_75
 *							b2			5
 *							b3			7.5
 *							b4			10
 *							b5			12
 *							b6			15
 *							b7			20
 *							b8			24
 *							b9...b31	not used
 *
 * Video format				3 = SQ-CIF		Always			
 *							2 = Q-CIF
 *							1 = CIF
 *							4 = VGA
 *
 * Exposure Control			0 = Auto		Always			
 *							ff= Shutter Fixed
 *
 *
 */

#include "windef.h"
#include "mmsystem.h"
#include "ks.h"

// Whitebalance mode values 
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_INDOOR			0
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_OUTDOOR			1
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_TL				2
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_MANUAL			3
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_AUTO				4

// Auto Exposure shutter mode values 
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_AUTO		0
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_FIXED	0xff

// Auto Exposure agc mode values
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_AUTO			0
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_FIXED		0xff

// Auto Exposure flickerless values 
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS_ON		0xff
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS_OFF		0x0

// Auto Exposure shutterspeed values (1/xx s) 
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_25		0x0
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_33		0x1
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_50		0x2
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_100		0x3
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_250		0x4
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_500		0x5
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_1000	0x6
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_1500	0x7
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_2500	0x8
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_5000	0x9
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED_10000	0xa

// Auto Exposure shutterspeed status values
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_STATUS_SMALLER	0x0
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_STATUS_EQUAL		0x1
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_STATUS_GREATER	0x2

// Framerate values
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_VGA			0xff
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_375			0x4
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_5  			0x5
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_75				0x8
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_10				0xa
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_12				0xc
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_15				0xf
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_20				0x14
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_24				0x18

// Video format values
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOFORMAT_CIF			0x1
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOFORMAT_QCIF			0x2
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOFORMAT_SQCIF		0x3
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOFORMAT_VGA			0x4

// Video compression values
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOCOMPRESSION_UNCOMPRESSED 0x1
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOCOMPRESSION_COMPRESSED3X 0x3
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOCOMPRESSION_COMPRESSED4X 0x4

// Sensortype values
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_SENSORTYPE_PAL_MR		0x1
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_SENSORTYPE_VGA			0x0

// Commands for camera default
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS_RESTORE_USER	0x0
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS_SAVE_USER		0x1
#define KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS_RESTORE_FACTORY	0x2

// define the GUID of the custom propertyset
#define STATIC_PROPSETID_PHILIPS_CUSTOM_PROP \
	0xb5ca8702, 0xc487, 0x11d1, 0xb3, 0xd, 0x0, 0x60, 0x97, 0xd1, 0xcd, 0x79
DEFINE_GUIDEX(PROPSETID_PHILIPS_CUSTOM_PROP);

// define property id's for the custom property set
typedef enum {
	KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE,		
	KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_SPEED,	
	KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_DELAY,		
	KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_RED_GAIN,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_BLUE_GAIN,

	KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_CONTROL_SPEED,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_STATUS,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC,

	KSPROPERTY_PHILIPS_CUSTOM_PROP_DRIVERVERSION,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATES_SUPPORTED,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOFORMAT,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_SENSORTYPE,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOCOMPRESSION,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_RELEASE_NUMBER,
    KSPROPERTY_PHILIPS_CUSTOM_PROP_PUSHBUTTON_FLAG,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_VENDOR_ID,
	KSPROPERTY_PHILIPS_CUSTOM_PROP_PRODUCT_ID
} KSPROPERTY_PHILIPS_CUSTOM_PROP;


// define a generic structure which will be used to pass
// the properties Currently, this is the same as for 
// KSPROPERTY_PROCAMP_S.
//
// Note: There are currently no 
// KSPROPERTY_PHILIPS_CUSTOM_PROP_FLAGS defined
typedef struct {
    KSPROPERTY Property;
    ULONG  Instance;                    
    LONG   Value;			// Value to set or get
    ULONG  Flags;			// KSPROPERTY_PHILIPS_CUSTOM_PROP_FLAGS_
    ULONG  Capabilities;	// KSPROPERTY_PHILIPS_CUSTOM_PROP_FLAGS_
} KSPROPERTY_PHILIPS_CUSTOM_PROP_S, *PKSPROPERTY_PHILIPS_CUSTOM_PROP_S;


#endif	/* __MPRPOBJ_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mprpdef.h ===
#ifndef __PRPDEF_H__
#define __PRPDEF_H__

/*

Copyright (c) 1997 1998 PHILIPS  I&C

Module Name:  mprpdef.h

Abstract:     Property sets definition

Author:       Michael Verberne

Revision History:

Date        Reason

Sept.22, 98 Optimized for NT5

 * This file defines the following property sets:
 *
 * PROPSETID_VIDCAP_VIDEOPROCAMP
 * PROPSETID_VIDCAP_CAMERACONTROL
 * PROPSETID_PHILIPS_CUSTOM_PROP
 *
*/

/*
 * Following values are the ranges and stepping delta's
 */
#define BRIGHTNESS_MIN                                  0x0
#define BRIGHTNESS_MAX                                  0x7f    
#define BRIGHTNESS_DELTA                                0x1

#define CONTRAST_MIN                                    0x0
#define CONTRAST_MAX                                    0x3f
#define CONTRAST_DELTA                                  0x1

#define GAMMA_MIN                                       0x0
#define GAMMA_MAX                                       0x1f
#define GAMMA_DELTA                                     0x1

#define COLORENABLE_MIN                                 0x0
#define COLORENABLE_MAX                                 0x1
#define COLORENABLE_DELTA                               0x1

#define BACKLIGHT_COMPENSATION_MIN                      0x0
#define BACKLIGHT_COMPENSATION_MAX                      0x1
#define BACKLIGHT_COMPENSATION_DELTA                    0x1     

#define WB_SPEED_MIN                                    0x1
#define WB_SPEED_MAX                                    0x20
#define WB_SPEED_DELTA                                  0x1

#define WB_DELAY_MIN                                    0x1
#define WB_DELAY_MAX                                    0x3f
#define WB_DELAY_DELTA                                  0x1

#define WB_RED_GAIN_MIN                                 0x0
#define WB_RED_GAIN_MAX                                 0xff
#define WB_RED_GAIN_DELTA                               0x1

#define WB_BLUE_GAIN_MIN                                0x0
#define WB_BLUE_GAIN_MAX                                0xff
#define WB_BLUE_GAIN_DELTA                              0x1

#define AE_CONTROL_SPEED_MIN                            0x8
#define AE_CONTROL_SPEED_MAX                            0xff
#define AE_CONTROL_SPEED_DELTA                          0x1

#define AE_SHUTTER_SPEED_MIN                            0x0
#define AE_SHUTTER_SPEED_MAX                            0xa
#define AE_SHUTTER_SPEED_DELTA                          0x1

#define AE_AGC_MIN                                      0x0
#define AE_AGC_MAX                                      0x3f 
#define AE_AGC_DELTA                                    0x1

/*
 * Following are default values
 * These values may change during runtime !
 */
extern LONG Brightness_Default;
extern LONG Contrast_Default;
extern LONG Gamma_Default;
extern LONG ColorEnable_Default;
extern LONG BackLight_Compensation_Default;

extern LONG WB_Mode_Default;
extern LONG WB_Speed_Default;
extern LONG WB_Delay_Default;
extern LONG WB_Red_Gain_Default;
extern LONG WB_Blue_Gain_Default;

extern LONG AE_Control_Speed_Default;
extern LONG AE_Flickerless_Default;
extern LONG AE_Shutter_Mode_Default;
extern LONG AE_Shutter_Speed_Default;
extern LONG AE_AGC_Mode_Default;
extern LONG AE_AGC_Default;

extern LONG Framerate_Default;
extern LONG VideoFormat_Default;
extern LONG VideoCompression_Default;
extern LONG SensorType_Default;

/*
 * Complete property table for ProcAmp and Philips
 * Custom properties
 */
extern const KSPROPERTY_SET AdapterPropertyTable[];

/*
 * Number of propertysets in the table
 */
extern const NUMBER_OF_ADAPTER_PROPERTY_SETS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mprpobjx.h ===
#ifndef __MPRPOBJEX_H__
#define __MPRPOBJEX_H__
/*++

Copyright (c) 1997 1998 PHILIPS  I&C

Module Name:  mprpobj.c

Abstract:     factory property definitions

Author:       Michael Verberne

Revision History:

Date        Reason

Sept.22, 98 Optimized for NT5

--*/	

#include "windef.h"
#include "mmsystem.h"
#include "ks.h"


// define the GUID of the factory propertyset
#define STATIC_PROPSETID_PHILIPS_FACTORY_PROP \
	0xfcf75730, 0x5b4c, 0x11d1, 0xbd, 0x77, 0x0, 0x60, 0x97, 0xd1, 0xcd, 0x79
DEFINE_GUIDEX(PROPSETID_PHILIPS_FACTORY_PROP);

// define property id's for the custom property set
typedef enum {
	KSPROPERTY_PHILIPS_FACTORY_PROP_REGISTER_ADDRESS,
	KSPROPERTY_PHILIPS_FACTORY_PROP_REGISTER_DATA,
	KSPROPERTY_PHILIPS_FACTORY_PROP_FACTORY_MODE
} KSPROPERTY_PHILIPS_FACTORY_PROP;

// define a generic structure which will be used to pass
// register values
// Note: There are currently no 
// KSPROPERTY_PHILIPS_FACTORY_PROP_FLAGS defined
typedef struct {
    KSPROPERTY Property;
    ULONG  Instance;                    
    LONG   Value;			// Value to set or get
    ULONG  Flags;			// KSPROPERTY_PHILIPS_FACTORY_PROP_FLAGS_
    ULONG  Capabilities;	// KSPROPERTY_PHILIPS_FACTORY_PROP_FLAGS_
} KSPROPERTY_PHILIPS_FACTORY_PROP_S, *PKSPROPERTY_PHILIPS_FACTORY_PROP_S;

#endif	/* __MPRPOBJ_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mssidef.h ===
#ifndef __MSSIDEF_H__
#define __MSSIDEF_H__

/**
Copyright (c) 1997 Philips  CE - I&C

Module Name 	: vendorcm.h

Creation Date	: 12 September 1997

First Author	: Paul Oosterhof

Product			: nala camera

Description		: This include file contains the definition of the
                  vendor specific command values.
                  The values are derived from the SSI: AR18-97-D051. 
				  It has been placed in a separate file to increase 
				  the readability of philpcam.c, which includes this file.

History			:

------------+---------------+---------------------------------------------------
Date	    | Author		| reason
------------+---------------+---------------------------------------------------
sept.22, 98 | Paul          | optimized for NT5
------------+---------------+---------------------------------------------------
            |               |
------------+---------------+---------------------------------------------------
            |               |
------------+---------------+---------------------------------------------------
**/



/*
The vendor specific control commands are defined by the USB spec as follows:

+---------------+----------+--------+--------+---------++------------+
| bmRequestType | bRequest | wValue | wIndex | wLength || Data-field | 
+---------------+----------+--------+--------+---------++------------+

bmRequestType: D7 defines transfer direction: 0 = Host to device; 1 = Device to host.
        	   D6..5:  2 equals vendor specific 
			   D4..0:  Recipient ; 2 = endpoint
bRequest	 : Specifies requests, see define table
wValue		 : Content of this field depends on the request, see define table
wIndex		 : Content of this field depends on the request, see define table
wLength		 : Length of the datafield transferred in the second phase 
               of the control transfer
data-field	 : Depends on the request.




    


NTSTATUS
USBCAMD_ControlVendorCommand(
    IN PVOID DeviceContext,
    IN UCHAR Request,
    IN USHORT Value,
    IN USHORT Index,
    IN PVOID Buffer,
    IN OUT PULONG BufferLength,
    IN BOOLEAN GetData,
    IN PCOMMAND_COMPLETE_FUNCTION CommandComplete,
    IN PVOID CommandContext
    );    


Returns:
    Returns NTSTATUS code from command of STATUS_PENDING if command is deferred.


DeviceContext: Minidriver device context
Request      : value for the bRequest field in the USB vendor command
               This field contains the Vendor-Specific Video Request codes.
Value        : value for the wValue field in the vendor command
               This field contains the formatter information belonging to
			   the previous defined request code.
Index        : value for the wIndex field in the vendor command
               This field contains the endpoint or interface number to which
			   the command or request is addressed.
Buffer       : data buffer if the command has data, may be NULL
BufferLength : Pointer to bufferlength of buffer in bytes, may be NULL if
               Buffer is NULL.
               Will be filled with number of bytes returned if getData == TRUE.
GetData      : Indicates that the data is to be transferred from device to host
CommandComplete: function called when command is completed.
CommandContext:  context passed to CommandComplete function

*/


#define SEND                 FALSE
#define GET	                 TRUE

#define SELECT_INTERFACE	 1
#define SELECT_ENDPOINT		 2

#define AC_INTERFACE         0
#define AS_INTERFACE         1
#define VC_INTERFACE         2
#define VS_INTERFACE         3
#define HID_INTERFACE        4
#define FACTORY_INTERFACE 0xFF

#define AUDIO_ENDPOINT 5
#define VIDEO_ENDPOINT 4
#define INTERRUPT_ENDPOINT 2

// The following defines will be used to fill the bRequest field of the vendor 
// specific commands.

#define REQUEST_UNDEFINED        0X00
#define SET_LUM_CTL			     0x01
#define GET_LUM_CTL			     0x02
#define SET_CHROM_CTL		     0x03
#define GET_CHROM_CTL		     0x04
#define SET_STATUS_CTL		     0x05
#define GET_STATUS_CTL		     0x06
#define SET_EP_STREAM_CTL	     0x07
#define GET_EP_STREAM_CTL	     0x08
#define SET_FACTORY_CTL		     0x09
#define GET_FACTORY_CTL	         0x0A


// The following defines will be used to fill the  Value field of the vendor 
// specific commands.


// Luminance formatters

#define LUM_UNDEFINED			 0x0000
#define AGC_MODE				 0x2000
#define	PRESET_AGC				 0x2100
#define	SHUTTER_MODE			 0x2200
#define	PRESET_SHUTTER			 0x2300
#define	PRESET_CONTOUR			 0x2400
#define	AUTO_CONTOUR			 0x2500
#define	BACK_LIGHT_COMPENSATION	 0x2600
#define	CONTRAST				 0x2700
#define	DYNAMIC_NOISE_CONTROL	 0x2800
#define	FLICKERLESS				 0x2900
#define BRIGHTNESS				 0x2B00
#define	GAMMA					 0x2C00
#define AE_CONTROL_SPEED		 0x2A00

// Chrominance Formatters

#define CHROM_UNDEFINED			 0x0000
#define	WB_MODE					 0x1000
#define	AWB_CONTROL_SPEED		 0x1100
#define	AWB_CONTROL_DELAY		 0x1200
#define	RED_GAIN				 0x1300
#define	BLUE_GAIN				 0x1400
#define	COLOR_MODE				 0x1500
#define	SATURATION			     0x1700 //  ????? No number 0x16


// Status Formatters

#define	STATUS_UNDEFINED		 0x0000
#define	SAVE_USER_DEFAULTS		 0x0200
#define	RESTORE_USER_DEFAULTS	 0x0300
#define	RESTORE_FACTORY_DEFAULTS 0x0400
#define	EEPROM_READ_PTR			 0x0500
#define	VCMDSP_READ_PTR			 0x0600 // ????? No number 0x07
#define	SNAPSHOT_MODE			 0x0800
#define	AE_WB_VARIABLES			 0x0900
#define	PAN						 0x0A00
#define	TILT					 0x0B00
#define	SENSOR_TYPE				 0x0C00
#define FACTORY_MODE			 0x3000
#define RELEASE_NUMBER			 0x0D00

#define PAL_MR_SENSOR        1
#define VGA_SENSOR           0


// Endpoint Stream Control Formatters

#define VIDEO_OUTPUT_CONTROL_FORMATTER 0x0100

// endpoint stream data definitions
#define bFRAMERATE               0X00
#define bCOMPRESSIONFACT         0X01
#define bVIDEOOUTPUTTYPE         0X02

#define FRAMERATE_375            0x04
#define	FRAMERATE_5	             0x05
#define	FRAMERATE_75             0x08
#define	FRAMERATE_10             0x0A
#define	FRAMERATE_12             0x0C
#define	FRAMERATE_15             0x0F
#define	FRAMERATE_20             0x14
#define	FRAMERATE_24             0x18
#define	FRAMERATE_VGA            0xFF

#define	UNCOMPRESSED             0x01
#define	COMPRESSED_3             0x03
#define	COMPRESSED_4             0x04

#define CIF_FORMAT	             0x01
#define	QCIF_FORMAT	             0x02
#define	SQCIF_FORMAT             0x03
#define	VGA_FORMAT			     0x04


// Factory Control Formatters 



// The following defines will be used to fill the wIndex field of the vendor 
// specific commands.

#define INDEX_UNDEFINED          0X00#

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mstreams.h ===
#ifndef __MSTREAMS_H__
#define __MSTREAMS_H__
/**
Copyright (c) 1997 1998 Philips  CE  I&C

Module Name 	: phvcm_streamformats

Creation Date	: 13 August 1997

First Author	: Paul Oosterhof

Product			: nala camera

Description		: This include file contains the definition of the
                  streamformats. 
				  It has been placed in a separate file to increase 
				  the readability of philpcam.c, which includes this file.

History			:

--------+---------------+---------------------------------------------------
Date	| Author		| reason
--------+---------------+---------------------------------------------------
29-09-97|P.J.O.         |equal streams with diferent framerates can be combined
--------+---------------+---------------------------------------------------
11-03-98|P.J.O.         |PCF3 & prototype stream deleted
--------+---------------+---------------------------------------------------
14-04-98|P.J.O.         |PCFx Deleted and I420/IYUV added
--------+---------------+---------------------------------------------------
01-07-98|P.J.O.         |QQCIF/SIF/QSIF/SQSIF/SSIF added 
--------+---------------+---------------------------------------------------
22-09-98|P.J.O.         |Optimized for NT5
--------+---------------+---------------------------------------------------
30-12-98|P.J.O.         |SCIF (240x176) added
--------+---------------+---------------------------------------------------

	Here defined formats:
												       \
#define STREAMFORMAT_CIF_I420 													   \
#define STREAMFORMAT_QCIF_I420													       \
#define STREAMFORMAT_SQCIF_I420												       \
#define STREAMFORMAT_VGA_I420												           \
#define STREAMFORMAT_QQCIF_I420	( 88x 72)  CROPPED FROM QCIF  (176X144)
#define STREAMFORMAT_SIF_I420   (320x240)  CROPPED FROM CIF   (352X288)
#define STREAMFORMAT_QSIF_I420  (160X120)  CROPPED FROM QCIF  (176X144)
#define STREAMFORMAT_SQSIF_I420	( 80X 60)  CROPPED FROM SQCIF (128X 96)
#define STREAMFORMAT_SSIF_I420  (240x180)  CROPPED FROM CIF   (352X288)
#define STREAMFORMAT_SCIF_I420  (240x176)  CROPPED FROM CIF   (352X288)

**/

#define FCC_FORMAT_I420 mmioFOURCC('I','4','2','0')

#define	BIBITCOUNT_PRODUCT 12             	
#define	BPPXL 12    // bits per pixel            	

#define FORMAT_MEDIASUBTYPE_I420 {0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}

#define FRAMERATE24_INTV    416667  // 100 NS UNITS
#define FRAMERATE20_INTV    500000  // 100 NS UNITS
#define FRAMERATE15_INTV    666667  // 100 NS UNITS
#define FRAMERATE12_INTV    833333
#define FRAMERATE125_INTV   800000
#define FRAMERATE10_INTV   1000000
#define FRAMERATE75_INTV   1333333
#define FRAMERATE5_INTV    2000000
#define FRAMERATE375_INTV  2666667
#define FRAMERATE05_INTV  20000000		// 2 SEC 



/****************************************************************************** 
--------+---------+---------+---------+---------------+
Format  |Framerate|Compressd|Bitstream|Application	  |
--------+---------+---------+---------+---------------+
QCIF    |24       |    0    | 7.2     |PAL + VGA      |  
--------+---------+---------+---------+---------------+
QCIF    |20       |    0    | 6.2     |PAL + VGA      |  
--------+---------+---------+---------+---------------+
QCIF    |15       |    0    | 5.0     |PAL + VGA      |  
--------+---------+---------+---------+---------------+
QCIF    |12       |    0    | 4.0     |PAL            |  
--------+---------+---------+---------+---------------+
QCIF    |10       |    0    | 3.3     |PAL + VGA      |  
--------+---------+---------+---------+---------------+
QCIF    |7.5      |    0    | 2.5     |PAL + VGA      |  
--------+---------+---------+---------+---------------+
QCIF    | 5       |    0    | 1.25    |PAL + VGA      |  
*/

																		   
#define STREAMFORMAT_QCIF_I420													       \
{																				   \
  /* KSDATARANGE	 */															   \
  {     																		   \
	sizeof (KS_DATARANGE_VIDEO),												   \
	0,																			   \
    (QCIF_X * QCIF_Y * BIBITCOUNT_PRODUCT)/8, /* SampleSize, 12 bits per pixel */  \
    0,                                    /* Reserved	  */      	    		   \
	STATIC_KSDATAFORMAT_TYPE_VIDEO,       /*MEDIATYPE_Video (MajorFormat) */	   \
	FORMAT_MEDIASUBTYPE_I420,			  /* MEDIASUBTYPE_I420 (SubFormat) */      \
	STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO	 /*FORMAT_VideoInfo	 (Specifier) */	   \
  },																			   \
                                                                                   \
  TRUE,               /* BOOL,  bFixedSizeSamples (all samples same size?)*/	   \
  TRUE,               /* BOOL,  bTemporalCompression (all I frames?)	*/		   \
  KS_VIDEOSTREAM_CAPTURE,   /* StreamDescriptionFlags		   */				   \
  0,                  /* MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)*/			   \
                                                                                   \
  /* _KS_VIDEO_STREAM_CONFIG_CAPS  									   */	       \
  { 																	     	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,                                       \
    KS_AnalogVideo_None,    /* VideoStandard */                                    \
	QCIF_X,QCIF_Y,  /* InputSize, (the inherent size of the incoming signal	*/	   \
			        /*             with every digitized pixel unique)	*/		   \
	QCIF_X,QCIF_Y,  /* MinCroppingSize, smallest rcSrc cropping rect allowed*/	   \
	QCIF_X,QCIF_Y,  /* MaxCroppingSize, largest  rcSrc cropping rect allowed*/	   \
	1,              /* CropGranularityX, granularity of cropping size */		   \
	1,              /* CropGranularityY	   */									   \
	1,              /* CropAlignX, alignment of cropping rect  */				   \
	1,              /* CropAlignY 							*/					   \
	QCIF_X,QCIF_Y,  /* MinOutputSize, smallest bitmap stream can produce */		   \
	QCIF_X,QCIF_Y,  /* MaxOutputSize, largest  bitmap stream can produce */		   \
	1,              /* OutputGranularityX, granularity of output bitmap size */	   \
	1,              /* OutputGranularityY 								   */	   \
    0,              /* StretchTapsX */                                             \
    0,              /* StretchTapsY */                                             \
    0,              /* ShrinkTapsX  */                                             \
    0,              /* ShrinkTapsY  */                                             \
	FRAMERATE24_INTV,         /* MinFrameInterval, 100 nS units  (24 Hz)   */	   \
	FRAMERATE5_INTV,          /* MaxFrameInterval, 100 nS units			  */	   \
	BPPXL * 5 * QCIF_X * QCIF_Y,  /* MinBitsPerSecond   3 ??? JOHN			  */	   \
	BPPXL * 24 * QCIF_X * QCIF_Y  /* MaxBitsPerSecond 						 */		   \
  }, 																			   \
                                                                                   \
  /* KS_VIDEOINFOHEADER (default format)					   */				   \
  { 																			   \
	0,0,0,0,                            /* RECT  rcSource    */	          		   \
	0,0,0,0,                            /* RECT  rcTarget   */	         		   \
	QCIF_X * QCIF_Y * BPPXL * 24,           /* DWORD dwBitRate 	*/         			   \
	0L,                                 /* DWORD dwBitErrorRate   */			   \
	FRAMERATE24_INTV,                   /* REFERENCE_TIME  AvgTimePerFrame  */     \
	sizeof (KS_BITMAPINFOHEADER),       /* DWORD      biSize    */		    	   \
	QCIF_X,                             /* LONG       biWidth   */     	           \
	QCIF_Y,                             /* LONG       biHeight  */     		       \
	1,                                  /* WORD       biPlanes  */		       	   \
	BIBITCOUNT_PRODUCT, 				/* WORD       biBitCount */		       	   \
	FCC_FORMAT_I420,                    /* DWORD      biCompression */	       	   \
	(QCIF_X * QCIF_Y * BPPXL ) /8,      /* DWORD      biSizeImage   */	       	   \
	0,                                  /* LONG       biXPelsPerMeter */		   \
	0,                                  /* LONG       biYPelsPerMeter */		   \
	0,                                  /* DWORD      biClrUsed 		 */		   \
	0                                   /* DWORD      biClrImportant  */		   \
  }																				   \
} 																			   

/****************************************************************************** 
--------+---------+---------+---------+---------------+
Format  |Framerate|Compressd|Bitstream|Application	  |
--------+---------+---------+---------+---------------+
CIF     |15       |    0    |     Mb/s|VGA+Pal        | 
--------+---------+---------+---------+---------------+
CIF     |12       |    0    |         |PAL            |  
--------+---------+---------+---------+---------------+
CIF     |10       |    0    |         |PAL + VGA      |  
--------+---------+---------+---------+---------------+
CIF     |7.5      |    0    |         |PAL + VGA      |  
--------+---------+---------+---------+---------------+
CIF     |5        |    0    |         |PAL + VGA      |  
--------+---------+---------+---------+---------------+
CIF     |3.75     |    0    |         |PAL + VGA      |  
*/


																			   

#define STREAMFORMAT_CIF_I420 													   \
{																				   \
  /* KSDATARANGE	 */															   \
  {     																		   \
	sizeof (KS_DATARANGE_VIDEO),             /* ULONG   FormatSize*/			   \
	0,										 /* ULONG   Flags  */				   \
    (CIF_X * CIF_Y * BPPXL )/8,              /* SampleSize, 12 bits per pixel */   \
    0,                                       /* Reserved	  */			       \
	STATIC_KSDATAFORMAT_TYPE_VIDEO,          /*MEDIATYPE_Video (MajorFormat) */	   \
	FORMAT_MEDIASUBTYPE_I420,				 /*MEDIASUBTYPE_I420 (SubFormat) */	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO	                                	   \
  },																			   \
                                                                                   \
  TRUE,               /* BOOL,  bFixedSizeSamples (all samples same size?)*/	   \
  TRUE,               /* BOOL,  bTemporalCompression (all I frames?)	*/		   \
  KS_VIDEOSTREAM_CAPTURE,   /* StreamDescriptionFlags		   */				   \
  0,                  /* MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)*/			   \
                                                                                   \
  /* _KS_VIDEO_STREAM_CONFIG_CAPS  									   */	       \
  { 																	     	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,                                       \
    KS_AnalogVideo_None,    /* VideoStandard   */                                  \
	CIF_X,CIF_Y,    /* InputSize, (the inherent size of the incoming signal	*/	   \
			        /*             with every digitized pixel unique)	*/		   \
	CIF_X,CIF_Y,    /* MinCroppingSize, smallest rcSrc cropping rect allowed*/	   \
	CIF_X,CIF_Y,    /* MaxCroppingSize, largest  rcSrc cropping rect allowed*/	   \
	1,              /* CropGranularityX, granularity of cropping size */		   \
	1,              /* CropGranularityY	   */									   \
	1,              /* CropAlignX, alignment of cropping rect  */				   \
	1,              /* CropAlignY 							*/					   \
	CIF_X,CIF_Y,    /* MinOutputSize, smallest bitmap stream can produce */		   \
	CIF_X,CIF_Y,    /* MaxOutputSize, largest  bitmap stream can produce */		   \
	1,              /* OutputGranularityX, granularity of output bitmap size */	   \
	1,              /* OutputGranularityY 								   */	   \
    0,                      /* StretchTapsX */                                     \
    0,                      /* StretchTapsY */                                     \
    0,                      /* ShrinkTapsX  */                                     \
    0,                      /* ShrinkTapsY  */                                     \
	FRAMERATE15_INTV,       /* MinFrameInterval, 100 nS units  (15 Hz)   */	   \
	FRAMERATE375_INTV,         /* MaxFrameInterval, 100 nS units			  */	   \
	BPPXL *  3 * CIF_X * CIF_Y,  /* MinBitsPerSecond     			  */	   \
	BPPXL * 15 * CIF_X * CIF_Y   /* MaxBitsPerSecond 						 */		   \
  }, 																			   \
                                                                                   \
  /* KS_VIDEOINFOHEADER (default format)					   */				   \
  { 																			   \
	0,0,0,0,                            /* RECT  rcSource  	  */    			   \
	0,0,0,0,                            /* RECT  rcTarget  	 */		    		   \
	CIF_X * CIF_Y * BPPXL * 15,             /* DWORD dwBitRate 	 */			    	   \
	0L,                                 /* DWORD dwBitErrorRate   */			   \
	FRAMERATE15_INTV,                   /* REFERENCE_TIME  AvgTimePerFrame  */     \
	sizeof (KS_BITMAPINFOHEADER),       /* DWORD      biSize    */			       \
	CIF_X,                              /* LONG       biWidth   */		           \
	CIF_Y,                              /* LONG       biHeight  */			       \
	1,                                  /* WORD       biPlanes  */			       \
	BIBITCOUNT_PRODUCT,					/* WORD       biBitCount */			       \
	FCC_FORMAT_I420,                    /* DWORD      biCompression */		       \
	(CIF_X * CIF_Y * BPPXL )/8,         /* DWORD      biSizeImage   */		   \
	0,                                  /* LONG       biXPelsPerMeter */		   \
	0,                                  /* LONG       biYPelsPerMeter */		   \
	0,                                  /* DWORD      biClrUsed 		 */		   \
	0                                   /* DWORD      biClrImportant  */		   \
  }																				   \
} 																			   



/****************************************************************************** 
--------+---------+---------+---------+---------------+
Format  |Framerate|Compressd|Bitstream|Application	  |
--------+---------+---------+---------+---------------+
SQCIF   |24       |    0    | 7.2     |PAL + VGA      |  
--------+---------+---------+---------+---------------+
SQCIF   |20       |    0    | 6.0     |PAL + VGA      |  
--------+---------+---------+---------+---------------+
SQCIF   |15       |    0    | 5.0     |PAL + VGA      |  
--------+---------+---------+---------+---------------+
SQCIF   |12       |    0    | 4.0     |PAL            |  
--------+---------+---------+---------+---------------+
SQCIF   |10       |    0    | 3.3     |PAL + VGA      |  
--------+---------+---------+---------+---------------+
SQCIF   |7.5      |    0    | 2.5     |PAL + VGA      |  
--------+---------+---------+---------+---------------+
SQCIF   |5        |    0    | 1.25    |PAL + VGA      |  
*/


																		   
																			   
#define STREAMFORMAT_SQCIF_I420												       \
{																				   \
  /* KSDATARANGE	 */															   \
  {     																		   \
	sizeof (KS_DATARANGE_VIDEO),												   \
	0,																			   \
    (SQCIF_X * SQCIF_Y * BIBITCOUNT_PRODUCT)/8, /* SampleSize, 12 bits per pixel */	   \
    0,                                    /* Reserved	  */        			   \
	STATIC_KSDATAFORMAT_TYPE_VIDEO,       /*MEDIATYPE_Video (MajorFormat) */	   \
	FORMAT_MEDIASUBTYPE_I420,			  /* MEDIASUBTYPE_I420 (SubFormat) */      \
	STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO	 /*FORMAT_VideoInfo	 (Specifier) */	   \
  },																			   \
                                                                                   \
  TRUE,               /* BOOL,  bFixedSizeSamples (all samples same size?)*/	   \
  TRUE,               /* BOOL,  bTemporalCompression (all I frames?)	*/		   \
  KS_VIDEOSTREAM_CAPTURE,   /* StreamDescriptionFlags		   */				   \
  0,                  /* MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)*/			   \
                                                                                   \
  /* _KS_VIDEO_STREAM_CONFIG_CAPS  									   */	       \
  { 																	     	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,                                       \
    KS_AnalogVideo_None,    /*VideoStandard   */                                   \
	SQCIF_X,SQCIF_Y,/* InputSize, (the inherent size of the incoming signal	*/	   \
			        /*             with every digitized pixel unique)	*/		   \
	SQCIF_X,SQCIF_Y,/* MinCroppingSize, smallest rcSrc cropping rect allowed*/	   \
	SQCIF_X,SQCIF_Y,/* MaxCroppingSize, largest  rcSrc cropping rect allowed*/	   \
	1,              /* CropGranularityX, granularity of cropping size */		   \
	1,              /* CropGranularityY	   */									   \
	1,              /* CropAlignX, alignment of cropping rect  */				   \
	1,              /* CropAlignY 							*/					   \
	SQCIF_X,SQCIF_Y,/* MinOutputSize, smallest bitmap stream can produce */		   \
	SQCIF_X,SQCIF_Y,/* MaxOutputSize, largest  bitmap stream can produce */		   \
	1,              /* OutputGranularityX, granularity of output bitmap size */	   \
	1,              /* OutputGranularityY 								   */	   \
    0,              /* StretchTapsX */                                             \
    0,              /* StretchTapsY */                                             \
    0,              /* ShrinkTapsX  */                                             \
    0,              /* ShrinkTapsY  */                                             \
	FRAMERATE24_INTV,            /* MinFrameInterval, 100 nS units	     */    	   \
	FRAMERATE5_INTV ,            /* MaxFrameInterval, 100 nS units 	 */      	   \
	BPPXL *  5 * SQCIF_X * SQCIF_Y,  /* MinBitsPerSecond   3 ??? JOHN		  */	   \
	BPPXL * 24 * SQCIF_X * SQCIF_Y   /* MaxBitsPerSecond 					 */		   \
  }, 																			   \
                                                                                   \
  /* KS_VIDEOINFOHEADER (default format)					   */				   \
  { 																			   \
	0,0,0,0,                            /* RECT  rcSource    */	        		   \
	0,0,0,0,                            /* RECT  rcTarget  	 */	        		   \
	SQCIF_X * SQCIF_Y * BPPXL * 24,        /* DWORD dwBitRate 	 */	          		   \
	0L,                                 /* DWORD dwBitErrorRate   */			   \
	FRAMERATE24_INTV,                   /* REFERENCE_TIME  AvgTimePerFrame  */     \
	sizeof (KS_BITMAPINFOHEADER),       /* DWORD      biSize    */     			   \
	SQCIF_X,                            /* LONG       biWidth   */	    	       \
	SQCIF_Y,                            /* LONG       biHeight  */	     		   \
	1,                                  /* WORD       biPlanes  */     			   \
	BIBITCOUNT_PRODUCT,					/* WORD       biBitCount */	      		   \
	FCC_FORMAT_I420,                    /* DWORD      biCompression */     		   \
	(SQCIF_X * SQCIF_Y * BPPXL )/8,     /* DWORD      biSizeImage   */	    	   \
	0,                                  /* LONG       biXPelsPerMeter */		   \
	0,                                  /* LONG       biYPelsPerMeter */		   \
	0,                                  /* DWORD      biClrUsed 		 */		   \
	0                                   /* DWORD      biClrImportant  */		   \
  }																				   \
} 																			   

#define STREAMFORMAT_QQCIF_I420												       \
{																				   \
  /* KSDATARANGE	 */															   \
  {     																		   \
	sizeof (KS_DATARANGE_VIDEO),												   \
	0,																			   \
    (QQCIF_X * QQCIF_Y * BIBITCOUNT_PRODUCT)/8, /* SampleSize, 12 bits per pixel */	   \
    0,                                    /* Reserved	  */        			   \
	STATIC_KSDATAFORMAT_TYPE_VIDEO,       /*MEDIATYPE_Video (MajorFormat) */	   \
	FORMAT_MEDIASUBTYPE_I420,			  /* MEDIASUBTYPE_I420 (SubFormat) */      \
	STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO	 /*FORMAT_VideoInfo	 (Specifier) */	   \
  },																			   \
                                                                                   \
  TRUE,               /* BOOL,  bFixedSizeSamples (all samples same size?)*/	   \
  TRUE,               /* BOOL,  bTemporalCompression (all I frames?)	*/		   \
  KS_VIDEOSTREAM_CAPTURE,   /* StreamDescriptionFlags		   */				   \
  0,                  /* MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)*/			   \
                                                                                   \
  /* _KS_VIDEO_STREAM_CONFIG_CAPS  									   */	       \
  { 																	     	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,                                       \
    KS_AnalogVideo_None,    /*VideoStandard   */                                   \
	QQCIF_X,QQCIF_Y,/* InputSize, (the inherent size of the incoming signal	*/	   \
			        /*             with every digitized pixel unique)	*/		   \
	QQCIF_X,QQCIF_Y,/* MinCroppingSize, smallest rcSrc cropping rect allowed*/	   \
	QQCIF_X,QQCIF_Y,/* MaxCroppingSize, largest  rcSrc cropping rect allowed*/	   \
	1,              /* CropGranularityX, granularity of cropping size */		   \
	1,              /* CropGranularityY	   */									   \
	1,              /* CropAlignX, alignment of cropping rect  */				   \
	1,              /* CropAlignY 							*/					   \
	QQCIF_X,QQCIF_Y,/* MinOutputSize, smallest bitmap stream can produce */		   \
	QQCIF_X,QQCIF_Y,/* MaxOutputSize, largest  bitmap stream can produce */		   \
	1,              /* OutputGranularityX, granularity of output bitmap size */	   \
	1,              /* OutputGranularityY 								   */	   \
    0,              /* StretchTapsX */                                             \
    0,              /* StretchTapsY */                                             \
    0,              /* ShrinkTapsX  */                                             \
    0,              /* ShrinkTapsY  */                                             \
	FRAMERATE24_INTV,            /* MinFrameInterval, 100 nS units	     */    	   \
	FRAMERATE5_INTV ,            /* MaxFrameInterval, 100 nS units 	 */      	   \
	BPPXL *  5 * QQCIF_X * QQCIF_Y,  /* MinBitsPerSecond   3 ??? JOHN		  */	   \
	BPPXL * 24 * QQCIF_X * QQCIF_Y   /* MaxBitsPerSecond 					 */		   \
  }, 																			   \
                                                                                   \
  /* KS_VIDEOINFOHEADER (default format)					   */				   \
  { 																			   \
	0,0,0,0,                            /* RECT  rcSource    */	        		   \
	0,0,0,0,                            /* RECT  rcTarget  	 */	        		   \
	QQCIF_X * QQCIF_Y * BPPXL * 24,        /* DWORD dwBitRate 	 */	          		   \
	0L,                                 /* DWORD dwBitErrorRate   */			   \
	FRAMERATE24_INTV,                   /* REFERENCE_TIME  AvgTimePerFrame  */     \
	sizeof (KS_BITMAPINFOHEADER),       /* DWORD      biSize    */     			   \
	QQCIF_X,                            /* LONG       biWidth   */	    	       \
	QQCIF_Y,                            /* LONG       biHeight  */	     		   \
	1,                                  /* WORD       biPlanes  */     			   \
	BIBITCOUNT_PRODUCT,					/* WORD       biBitCount */	      		   \
	FCC_FORMAT_I420,                    /* DWORD      biCompression */     		   \
	(QQCIF_X * QQCIF_Y * BPPXL )/8,     /* DWORD      biSizeImage   */	    	   \
	0,                                  /* LONG       biXPelsPerMeter */		   \
	0,                                  /* LONG       biYPelsPerMeter */		   \
	0,                                  /* DWORD      biClrUsed 		 */		   \
	0                                   /* DWORD      biClrImportant  */		   \
  }																				   \
} 																			   

																			   
																		   

/****************************************************************************** 
--------+---------+---------+---------+---------------+
Format  |Framerate|Compressd|Bitstream|Application	  |
--------+---------+---------+---------+---------------+
VGA     |1        |    0    | 4.0     |VGA            |  
*/




#define STREAMFORMAT_VGA_I420												           \
{																				   \
  /* KSDATARANGE	 */															   \
  {     																		   \
	sizeof (KS_DATARANGE_VIDEO),												   \
	0,																			   \
    (VGA_X * VGA_Y * BIBITCOUNT_PRODUCT)/8,  /* SampleSize, 12 bits per pixel */   \
    0,                                       /* Reserved	  */     			   \
	STATIC_KSDATAFORMAT_TYPE_VIDEO,          /*MEDIATYPE_Video (MajorFormat) */	   \
	FORMAT_MEDIASUBTYPE_I420,				 /* MEDIASUBTYPE_I420 (SubFormat) */   \
	STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO	 /*FORMAT_VideoInfo	 (Specifier) */	   \
  },																			   \
                                                                                   \
  TRUE,                 /* BOOL,  bFixedSizeSamples (all samples same size?)*/	   \
  TRUE,                 /* BOOL,  bTemporalCompression (all I frames?)	*/		   \
  KS_VIDEOSTREAM_STILL, /* StreamDescriptionFlags		   */				       \
  0,                    /* MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)*/			   \
                                                                                   \
  /* _KS_VIDEO_STREAM_CONFIG_CAPS  									   */	       \
  { 																	     	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,                                       \
    KS_AnalogVideo_None,    /*VideoStandard   */                                   \
	VGA_X,VGA_Y,    /* InputSize, (the inherent size of the incoming signal	*/	   \
			        /*             with every digitized pixel unique)	*/		   \
	VGA_X,VGA_Y,/* MinCroppingSize, smallest rcSrc cropping rect allowed*/	       \
	VGA_X,VGA_Y,/* MaxCroppingSize, largest  rcSrc cropping rect allowed*/	       \
	1,          /* CropGranularityX, granularity of cropping size */               \
	1,          /* CropGranularityY	   */									       \
	1,          /* CropAlignX, alignment of cropping rect  */	       			   \
	1,          /* CropAlignY 							*/	     				   \
	VGA_X,VGA_Y,/* MinOutputSize, smallest bitmap stream can produce */		       \
	VGA_X,VGA_Y,/* MaxOutputSize, largest  bitmap stream can produce */		       \
	1,          /* OutputGranularityX, granularity of output bitmap size */	       \
	1,          /* OutputGranularityY 								   */    	   \
    0,          /* StretchTapsX */                                                 \
    0,          /* StretchTapsY */                                                 \
    0,          /* ShrinkTapsX  */                                                 \
    0,          /* ShrinkTapsY  */                                                 \
	FRAMERATE05_INTV,         /* MinFrameInterval, 100 nS units			   */	   \
	FRAMERATE05_INTV,         /* MaxFrameInterval, 100 nS units			  */	   \
    BPPXL * 1 * VGA_X * VGA_Y,    /* MinBitsPerSecond   3 ??? JOHN			  */	   \
	BPPXL * 1 * VGA_X * VGA_Y     /* MaxBitsPerSecond 						 */		   \
  }, 																			   \
                                                                                   \
  /* KS_VIDEOINFOHEADER (default format)					   */				   \
  { 																			   \
	0,0,0,0,                            /* RECT  rcSource  	  */       			   \
	0,0,0,0,                            /* RECT  rcTarget  	 */	     			   \
	VGA_X * VGA_Y * BPPXL * 1,              /* DWORD dwBitRate 	 */	     			   \
	0L,                                 /* DWORD dwBitErrorRate   */			   \
	FRAMERATE05_INTV,                   /* REFERENCE_TIME  AvgTimePerFrame  */     \
	sizeof (KS_BITMAPINFOHEADER),       /* DWORD      biSize    */	    		   \
	VGA_X,                              /* LONG       biWidth   */	     	       \
	VGA_Y,                              /* LONG       biHeight  */     			   \
	1,                                  /* WORD       biPlanes  */	     		   \
	BIBITCOUNT_PRODUCT,					/* WORD       biBitCount */	     		   \
	FCC_FORMAT_I420,                    /* DWORD      biCompression */	     	   \
	(VGA_X * VGA_Y * BIBITCOUNT_PRODUCT)/8, /* DWORD      biSizeImage   */     		   \
	0,                                  /* LONG       biXPelsPerMeter */   		   \
	0,                                  /* LONG       biYPelsPerMeter */		   \
	0,                                  /* DWORD      biClrUsed 		 */		   \
	0                                   /* DWORD      biClrImportant  */		   \
  }																				   \
}



#define STREAMFORMAT_SIF_I420 													   \
{																				   \
  /* KSDATARANGE	 */															   \
  {     																		   \
	sizeof (KS_DATARANGE_VIDEO),             /* ULONG   FormatSize*/			   \
	0,										 /* ULONG   Flags  */				   \
    (SIF_X * SIF_Y * BPPXL )/8,              /* SampleSize, 12 bits per pixel */   \
    0,                                       /* Reserved	  */			       \
	STATIC_KSDATAFORMAT_TYPE_VIDEO,          /*MEDIATYPE_Video (MajorFormat) */	   \
	FORMAT_MEDIASUBTYPE_I420,				 /*MEDIASUBTYPE_I420 (SubFormat) */	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO	                                	   \
  },																			   \
                                                                                   \
  TRUE,               /* BOOL,  bFixedSizeSamples (all samples same size?)*/	   \
  TRUE,               /* BOOL,  bTemporalCompression (all I frames?)	*/		   \
  KS_VIDEOSTREAM_CAPTURE,   /* StreamDescriptionFlags		   */				   \
  0,                  /* MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)*/			   \
                                                                                   \
  /* _KS_VIDEO_STREAM_CONFIG_CAPS  									   */	       \
  { 																	     	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,                                       \
    KS_AnalogVideo_None,    /* VideoStandard   */                                  \
	SIF_X,SIF_Y,    /* InputSize, (the inherent size of the incoming signal	*/	   \
			        /*             with every digitized pixel unique)	*/		   \
	SIF_X,SIF_Y,    /* MinCroppingSize, smallest rcSrc cropping rect allowed*/	   \
	SIF_X,SIF_Y,    /* MaxCroppingSize, largest  rcSrc cropping rect allowed*/	   \
	1,              /* CropGranularityX, granularity of cropping size */		   \
	1,              /* CropGranularityY	   */									   \
	1,              /* CropAlignX, alignment of cropping rect  */				   \
	1,              /* CropAlignY 							*/					   \
	SIF_X,SIF_Y,    /* MinOutputSize, smallest bitmap stream can produce */		   \
	SIF_X,SIF_Y,    /* MaxOutputSize, largest  bitmap stream can produce */		   \
	1,              /* OutputGranularityX, granularity of output bitmap size */	   \
	1,              /* OutputGranularityY 								   */	   \
    0,                      /* StretchTapsX */                                     \
    0,                      /* StretchTapsY */                                     \
    0,                      /* ShrinkTapsX  */                                     \
    0,                      /* ShrinkTapsY  */                                     \
	FRAMERATE15_INTV,       /* MinFrameInterval, 100 nS units  (15 Hz)   */	   \
	FRAMERATE375_INTV,         /* MaxFrameInterval, 100 nS units			  */	   \
	BPPXL *  3 * SIF_X * SIF_Y,  /* MinBitsPerSecond     			  */	   \
	BPPXL * 15 * SIF_X * SIF_Y   /* MaxBitsPerSecond 						 */		   \
  }, 																			   \
                                                                                   \
  /* KS_VIDEOINFOHEADER (default format)					   */				   \
  { 																			   \
	0,0,0,0,                            /* RECT  rcSource  	  */    			   \
	0,0,0,0,                            /* RECT  rcTarget  	 */		    		   \
	SIF_X * SIF_Y * BPPXL * 15,             /* DWORD dwBitRate 	 */			    	   \
	0L,                                 /* DWORD dwBitErrorRate   */			   \
	FRAMERATE15_INTV,                   /* REFERENCE_TIME  AvgTimePerFrame  */     \
	sizeof (KS_BITMAPINFOHEADER),       /* DWORD      biSize    */			       \
	SIF_X,                              /* LONG       biWidth   */		           \
	SIF_Y,                              /* LONG       biHeight  */			       \
	1,                                  /* WORD       biPlanes  */			       \
	BIBITCOUNT_PRODUCT,					/* WORD       biBitCount */			       \
	FCC_FORMAT_I420,                    /* DWORD      biCompression */		       \
	(SIF_X * SIF_Y * BPPXL )/8,         /* DWORD      biSizeImage   */		   \
	0,                                  /* LONG       biXPelsPerMeter */		   \
	0,                                  /* LONG       biYPelsPerMeter */		   \
	0,                                  /* DWORD      biClrUsed 		 */		   \
	0                                   /* DWORD      biClrImportant  */		   \
  }																				   \
}

#define STREAMFORMAT_SSIF_I420 													   \
{																				   \
  /* KSDATARANGE	 */															   \
  {     																		   \
	sizeof (KS_DATARANGE_VIDEO),             /* ULONG   FormatSize*/			   \
	0,										 /* ULONG   Flags  */				   \
    (SSIF_X * SSIF_Y * BPPXL )/8,              /* SampleSize, 12 bits per pixel */   \
    0,                                       /* Reserved	  */			       \
	STATIC_KSDATAFORMAT_TYPE_VIDEO,          /*MEDIATYPE_Video (MajorFormat) */	   \
	FORMAT_MEDIASUBTYPE_I420,				 /*MEDIASUBTYPE_I420 (SubFormat) */	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO	                                	   \
  },																			   \
                                                                                   \
  TRUE,               /* BOOL,  bFixedSizeSamples (all samples same size?)*/	   \
  TRUE,               /* BOOL,  bTemporalCompression (all I frames?)	*/		   \
  KS_VIDEOSTREAM_CAPTURE,   /* StreamDescriptionFlags		   */				   \
  0,                  /* MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)*/			   \
                                                                                   \
  /* _KS_VIDEO_STREAM_CONFIG_CAPS  									   */	       \
  { 																	     	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,                                       \
    KS_AnalogVideo_None,    /* VideoStandard   */                                  \
	SSIF_X,SSIF_Y,    /* InputSize, (the inherent size of the incoming signal	*/	   \
			        /*             with every digitized pixel unique)	*/		   \
	SSIF_X,SSIF_Y,    /* MinCroppingSize, smallest rcSrc cropping rect allowed*/	   \
	SSIF_X,SSIF_Y,    /* MaxCroppingSize, largest  rcSrc cropping rect allowed*/	   \
	1,              /* CropGranularityX, granularity of cropping size */		   \
	1,              /* CropGranularityY	   */									   \
	1,              /* CropAlignX, alignment of cropping rect  */				   \
	1,              /* CropAlignY 							*/					   \
	SSIF_X,SSIF_Y,    /* MinOutputSize, smallest bitmap stream can produce */		   \
	SSIF_X,SSIF_Y,    /* MaxOutputSize, largest  bitmap stream can produce */		   \
	1,              /* OutputGranularityX, granularity of output bitmap size */	   \
	1,              /* OutputGranularityY 								   */	   \
    0,                      /* StretchTapsX */                                     \
    0,                      /* StretchTapsY */                                     \
    0,                      /* ShrinkTapsX  */                                     \
    0,                      /* ShrinkTapsY  */                                     \
	FRAMERATE15_INTV,       /* MinFrameInterval, 100 nS units  (15 Hz)   */	   \
	FRAMERATE375_INTV,         /* MaxFrameInterval, 100 nS units			  */	   \
	BPPXL *  3 * SSIF_X * SSIF_Y,  /* MinBitsPerSecond     			  */	   \
	BPPXL * 15 * SSIF_X * SSIF_Y   /* MaxBitsPerSecond 						 */		   \
  }, 																			   \
                                                                                   \
  /* KS_VIDEOINFOHEADER (default format)					   */				   \
  { 																			   \
	0,0,0,0,                            /* RECT  rcSource  	  */    			   \
	0,0,0,0,                            /* RECT  rcTarget  	 */		    		   \
	SSIF_X * SSIF_Y * BPPXL * 15,             /* DWORD dwBitRate 	 */			    	   \
	0L,                                 /* DWORD dwBitErrorRate   */			   \
	FRAMERATE15_INTV,                   /* REFERENCE_TIME  AvgTimePerFrame  */     \
	sizeof (KS_BITMAPINFOHEADER),       /* DWORD      biSize    */			       \
	SSIF_X,                              /* LONG       biWidth   */		           \
	SSIF_Y,                              /* LONG       biHeight  */			       \
	1,                                  /* WORD       biPlanes  */			       \
	BIBITCOUNT_PRODUCT,					/* WORD       biBitCount */			       \
	FCC_FORMAT_I420,                    /* DWORD      biCompression */		       \
	(SSIF_X * SSIF_Y * BPPXL )/8,         /* DWORD      biSizeImage   */		   \
	0,                                  /* LONG       biXPelsPerMeter */		   \
	0,                                  /* LONG       biYPelsPerMeter */		   \
	0,                                  /* DWORD      biClrUsed 		 */		   \
	0                                   /* DWORD      biClrImportant  */		   \
  }																				   \
}
#define STREAMFORMAT_SCIF_I420 													   \
{																				   \
  /* KSDATARANGE	 */															   \
  {     																		   \
	sizeof (KS_DATARANGE_VIDEO),             /* ULONG   FormatSize*/			   \
	0,										 /* ULONG   Flags  */				   \
    (SCIF_X * SCIF_Y * BPPXL )/8,              /* SampleSize, 12 bits per pixel */   \
    0,                                       /* Reserved	  */			       \
	STATIC_KSDATAFORMAT_TYPE_VIDEO,          /*MEDIATYPE_Video (MajorFormat) */	   \
	FORMAT_MEDIASUBTYPE_I420,				 /*MEDIASUBTYPE_I420 (SubFormat) */	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO	                                	   \
  },																			   \
                                                                                   \
  TRUE,               /* BOOL,  bFixedSizeSamples (all samples same size?)*/	   \
  TRUE,               /* BOOL,  bTemporalCompression (all I frames?)	*/		   \
  KS_VIDEOSTREAM_CAPTURE,   /* StreamDescriptionFlags		   */				   \
  0,                  /* MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)*/			   \
                                                                                   \
  /* _KS_VIDEO_STREAM_CONFIG_CAPS  									   */	       \
  { 																	     	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,                                       \
    KS_AnalogVideo_None,    /* VideoStandard   */                                  \
	SCIF_X,SCIF_Y,    /* InputSize, (the inherent size of the incoming signal	*/	   \
			        /*             with every digitized pixel unique)	*/		   \
	SCIF_X,SCIF_Y,    /* MinCroppingSize, smallest rcSrc cropping rect allowed*/	   \
	SCIF_X,SCIF_Y,    /* MaxCroppingSize, largest  rcSrc cropping rect allowed*/	   \
	1,              /* CropGranularityX, granularity of cropping size */		   \
	1,              /* CropGranularityY	   */									   \
	1,              /* CropAlignX, alignment of cropping rect  */				   \
	1,              /* CropAlignY 							*/					   \
	SCIF_X,SCIF_Y,    /* MinOutputSize, smallest bitmap stream can produce */		   \
	SCIF_X,SCIF_Y,    /* MaxOutputSize, largest  bitmap stream can produce */		   \
	1,              /* OutputGranularityX, granularity of output bitmap size */	   \
	1,              /* OutputGranularityY 								   */	   \
    0,                      /* StretchTapsX */                                     \
    0,                      /* StretchTapsY */                                     \
    0,                      /* ShrinkTapsX  */                                     \
    0,                      /* ShrinkTapsY  */                                     \
	FRAMERATE15_INTV,       /* MinFrameInterval, 100 nS units  (15 Hz)   */	   \
	FRAMERATE375_INTV,         /* MaxFrameInterval, 100 nS units			  */	   \
	BPPXL *  3 * SCIF_X * SCIF_Y,  /* MinBitsPerSecond     			  */	   \
	BPPXL * 15 * SCIF_X * SCIF_Y   /* MaxBitsPerSecond 						 */		   \
  }, 																			   \
                                                                                   \
  /* KS_VIDEOINFOHEADER (default format)					   */				   \
  { 																			   \
	0,0,0,0,                            /* RECT  rcSource  	  */    			   \
	0,0,0,0,                            /* RECT  rcTarget  	 */		    		   \
	SCIF_X * SCIF_Y * BPPXL * 15,             /* DWORD dwBitRate 	 */			    	   \
	0L,                                 /* DWORD dwBitErrorRate   */			   \
	FRAMERATE15_INTV,                   /* REFERENCE_TIME  AvgTimePerFrame  */     \
	sizeof (KS_BITMAPINFOHEADER),       /* DWORD      biSize    */			       \
	SCIF_X,                              /* LONG       biWidth   */		           \
	SCIF_Y,                              /* LONG       biHeight  */			       \
	1,                                  /* WORD       biPlanes  */			       \
	BIBITCOUNT_PRODUCT,					/* WORD       biBitCount */			       \
	FCC_FORMAT_I420,                    /* DWORD      biCompression */		       \
	(SCIF_X * SCIF_Y * BPPXL )/8,         /* DWORD      biSizeImage   */		   \
	0,                                  /* LONG       biXPelsPerMeter */		   \
	0,                                  /* LONG       biYPelsPerMeter */		   \
	0,                                  /* DWORD      biClrUsed 		 */		   \
	0                                   /* DWORD      biClrImportant  */		   \
  }																				   \
}


#define STREAMFORMAT_QSIF_I420													       \
{																				   \
  /* KSDATARANGE	 */															   \
  {     																		   \
	sizeof (KS_DATARANGE_VIDEO),												   \
	0,																			   \
    (QSIF_X * QSIF_Y * BIBITCOUNT_PRODUCT)/8, /* SampleSize, 12 bits per pixel */  \
    0,                                    /* Reserved	  */      	    		   \
	STATIC_KSDATAFORMAT_TYPE_VIDEO,       /*MEDIATYPE_Video (MajorFormat) */	   \
	FORMAT_MEDIASUBTYPE_I420,			  /* MEDIASUBTYPE_I420 (SubFormat) */      \
	STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO	 /*FORMAT_VideoInfo	 (Specifier) */	   \
  },																			   \
                                                                                   \
  TRUE,               /* BOOL,  bFixedSizeSamples (all samples same size?)*/	   \
  TRUE,               /* BOOL,  bTemporalCompression (all I frames?)	*/		   \
  KS_VIDEOSTREAM_CAPTURE,   /* StreamDescriptionFlags		   */				   \
  0,                  /* MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)*/			   \
                                                                                   \
  /* _KS_VIDEO_STREAM_CONFIG_CAPS  									   */	       \
  { 																	     	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,                                       \
    KS_AnalogVideo_None,    /* VideoStandard */                                    \
	QSIF_X,QSIF_Y,  /* InputSize, (the inherent size of the incoming signal	*/	   \
			        /*             with every digitized pixel unique)	*/		   \
	QSIF_X,QSIF_Y,  /* MinCroppingSize, smallest rcSrc cropping rect allowed*/	   \
	QSIF_X,QSIF_Y,  /* MaxCroppingSize, largest  rcSrc cropping rect allowed*/	   \
	1,              /* CropGranularityX, granularity of cropping size */		   \
	1,              /* CropGranularityY	   */									   \
	1,              /* CropAlignX, alignment of cropping rect  */				   \
	1,              /* CropAlignY 							*/					   \
	QSIF_X,QSIF_Y,  /* MinOutputSize, smallest bitmap stream can produce */		   \
	QSIF_X,QSIF_Y,  /* MaxOutputSize, largest  bitmap stream can produce */		   \
	1,              /* OutputGranularityX, granularity of output bitmap size */	   \
	1,              /* OutputGranularityY 								   */	   \
    0,              /* StretchTapsX */                                             \
    0,              /* StretchTapsY */                                             \
    0,              /* ShrinkTapsX  */                                             \
    0,              /* ShrinkTapsY  */                                             \
	FRAMERATE24_INTV,         /* MinFrameInterval, 100 nS units  (24 Hz)   */	   \
	FRAMERATE5_INTV,          /* MaxFrameInterval, 100 nS units			  */	   \
	BPPXL * 5 * QSIF_X * QSIF_Y,  /* MinBitsPerSecond   3 ??? JOHN			  */	   \
	BPPXL * 24 * QSIF_X * QSIF_Y  /* MaxBitsPerSecond 						 */		   \
  }, 																			   \
                                                                                   \
  /* KS_VIDEOINFOHEADER (default format)					   */				   \
  { 																			   \
	0,0,0,0,                            /* RECT  rcSource    */	          		   \
	0,0,0,0,                            /* RECT  rcTarget   */	         		   \
	QSIF_X * QSIF_Y * BPPXL * 24,           /* DWORD dwBitRate 	*/         			   \
	0L,                                 /* DWORD dwBitErrorRate   */			   \
	FRAMERATE24_INTV,                   /* REFERENCE_TIME  AvgTimePerFrame  */     \
	sizeof (KS_BITMAPINFOHEADER),       /* DWORD      biSize    */		    	   \
	QSIF_X,                             /* LONG       biWidth   */     	           \
	QSIF_Y,                             /* LONG       biHeight  */     		       \
	1,                                  /* WORD       biPlanes  */		       	   \
	BIBITCOUNT_PRODUCT, 				/* WORD       biBitCount */		       	   \
	FCC_FORMAT_I420,                    /* DWORD      biCompression */	       	   \
	(QSIF_X * QSIF_Y * BPPXL ) /8,      /* DWORD      biSizeImage   */	       	   \
	0,                                  /* LONG       biXPelsPerMeter */		   \
	0,                                  /* LONG       biYPelsPerMeter */		   \
	0,                                  /* DWORD      biClrUsed 		 */		   \
	0                                   /* DWORD      biClrImportant  */		   \
  }																				   \
} 																			   

#define STREAMFORMAT_SQSIF_I420												       \
{																				   \
  /* KSDATARANGE	 */															   \
  {     																		   \
	sizeof (KS_DATARANGE_VIDEO),												   \
	0,																			   \
    (SQSIF_X * SQSIF_Y * BIBITCOUNT_PRODUCT)/8, /* SampleSize, 12 bits per pixel */	   \
    0,                                    /* Reserved	  */        			   \
	STATIC_KSDATAFORMAT_TYPE_VIDEO,       /*MEDIATYPE_Video (MajorFormat) */	   \
	FORMAT_MEDIASUBTYPE_I420,			  /* MEDIASUBTYPE_I420 (SubFormat) */      \
	STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO	 /*FORMAT_VideoInfo	 (Specifier) */	   \
  },																			   \
                                                                                   \
  TRUE,               /* BOOL,  bFixedSizeSamples (all samples same size?)*/	   \
  TRUE,               /* BOOL,  bTemporalCompression (all I frames?)	*/		   \
  KS_VIDEOSTREAM_CAPTURE,   /* StreamDescriptionFlags		   */				   \
  0,                  /* MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)*/			   \
                                                                                   \
  /* _KS_VIDEO_STREAM_CONFIG_CAPS  									   */	       \
  { 																	     	   \
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,                                       \
    KS_AnalogVideo_None,    /*VideoStandard   */                                   \
	SQSIF_X,SQSIF_Y,/* InputSize, (the inherent size of the incoming signal	*/	   \
			        /*             with every digitized pixel unique)	*/		   \
	SQSIF_X,SQSIF_Y,/* MinCroppingSize, smallest rcSrc cropping rect allowed*/	   \
	SQSIF_X,SQSIF_Y,/* MaxCroppingSize, largest  rcSrc cropping rect allowed*/	   \
	1,              /* CropGranularityX, granularity of cropping size */		   \
	1,              /* CropGranularityY	   */									   \
	1,              /* CropAlignX, alignment of cropping rect  */				   \
	1,              /* CropAlignY 							*/					   \
	SQSIF_X,SQSIF_Y,/* MinOutputSize, smallest bitmap stream can produce */		   \
	SQSIF_X,SQSIF_Y,/* MaxOutputSize, largest  bitmap stream can produce */		   \
	1,              /* OutputGranularityX, granularity of output bitmap size */	   \
	1,              /* OutputGranularityY 								   */	   \
    0,              /* StretchTapsX */                                             \
    0,              /* StretchTapsY */                                             \
    0,              /* ShrinkTapsX  */                                             \
    0,              /* ShrinkTapsY  */                                             \
	FRAMERATE24_INTV,            /* MinFrameInterval, 100 nS units	     */    	   \
	FRAMERATE5_INTV ,            /* MaxFrameInterval, 100 nS units 	 */      	   \
	BPPXL *  5 * SQSIF_X * SQSIF_Y,  /* MinBitsPerSecond   3 ??? JOHN		  */	   \
	BPPXL * 24 * SQSIF_X * SQSIF_Y   /* MaxBitsPerSecond 					 */		   \
  }, 																			   \
                                                                                   \
  /* KS_VIDEOINFOHEADER (default format)					   */				   \
  { 																			   \
	0,0,0,0,                            /* RECT  rcSource    */	        		   \
	0,0,0,0,                            /* RECT  rcTarget  	 */	        		   \
	SQSIF_X * SQSIF_Y * BPPXL * 24,        /* DWORD dwBitRate 	 */	          		   \
	0L,                                 /* DWORD dwBitErrorRate   */			   \
	FRAMERATE24_INTV,                   /* REFERENCE_TIME  AvgTimePerFrame  */     \
	sizeof (KS_BITMAPINFOHEADER),       /* DWORD      biSize    */     			   \
	SQSIF_X,                            /* LONG       biWidth   */	    	       \
	SQSIF_Y,                            /* LONG       biHeight  */	     		   \
	1,                                  /* WORD       biPlanes  */     			   \
	BIBITCOUNT_PRODUCT,					/* WORD       biBitCount */	      		   \
	FCC_FORMAT_I420,                    /* DWORD      biCompression */     		   \
	(SQSIF_X * SQSIF_Y * BPPXL )/8,     /* DWORD      biSizeImage   */	    	   \
	0,                                  /* LONG       biXPelsPerMeter */		   \
	0,                                  /* LONG       biYPelsPerMeter */		   \
	0,                                  /* DWORD      biClrUsed 		 */		   \
	0                                   /* DWORD      biClrImportant  */		   \
  }																				   \
} 																			   
																			   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\mwarn.h ===
/*
4214
4201 nonstandard extension using nameless struct/union
4115
4200
4514 unreferenced inline function
**4100 unreferenced formal parameter
4057
*/

#pragma warning(disable:4214 4201 4115 4200 4100 4514 4057)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\pca645vc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by musbvcm.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\debug.h ===
/*
 * Copyright (c) 1996 1997, 1998 Philips CE I&C
 *
 * FILE			DEBUG.H
 * DATE			7-1-97
 * VERSION		1.00
 * AUTHOR		M.J. Verberne
 * DESCRIPTION	Defines printf which is used for 
 *              debugging output to the console
 * HISTORY		
 */

#ifndef _DEBUG_
#define _DEBUG_

#include <stdio.h>

#ifndef _DEBUG

#define printf

#else

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\phvcmext.cpp ===
/*
 * Copyright (c) 1996 1997, 1998 Philips CE I&C
 *
 * FILE			PHVCMEXT.CPP
 * DATE			7-1-97
 * VERSION		1.00
 * AUTHOR		M.J. Verberne
 * DESCRIPTION	Main of extension DLL
 * HISTORY		
 */
#include <windows.h>
#include <winioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <commctrl.h>

#include "resource.h"
#include "prpcom.h"
#include "prppage1.h"
#include "prppage2.h"

#ifdef _SERVICE
#include "prppage3.h"
#endif

#ifdef _DEBUG
#include "enre.h"
#endif

#include "debug.h"
#include "phvcmext.h"

/*======================== LOCAL DATA =====================================*/
HINSTANCE hInst = NULL;  


/*======================== EXPORTED FUNCTIONS =============================*/

/*-------------------------------------------------------------------------*/
int WINAPI
DllMain (HINSTANCE hInstance, DWORD fdwReason, PVOID pvReserved)
/*-------------------------------------------------------------------------*/
{
	switch (fdwReason)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
			hInst = hInstance;
#ifdef _DEBUG
			ENRE_init();
#endif
			break;
		case DLL_PROCESS_DETACH:
		case DLL_THREAD_DETACH:
#ifdef _DEBUG
			ENRE_exit();
#endif
			break;
	}
	return TRUE;
}
  

/*-------------------------------------------------------------------------*/
DWORD CALLBACK VFWWDMExtension(
	LPVOID					pfnDeviceIoControl, 
	LPFNADDPROPSHEETPAGE	pfnAddPropertyPage, 
	LPARAM					lParam)
/*-------------------------------------------------------------------------*/
{
	DWORD dwFlags = 0;
	HPROPSHEETPAGE hPage;
	
	// load comctl32.dll
	InitCommonControls () ;

	hPage = PRPPAGE1_CreatePage((LPFNEXTDEVIO) pfnDeviceIoControl, lParam, hInst);
	if (hPage) 
	{
		if (pfnAddPropertyPage(hPage,lParam))
			dwFlags |= VFW_OEM_ADD_PAGE;
	}
	hPage = PRPPAGE2_CreatePage((LPFNEXTDEVIO) pfnDeviceIoControl, lParam, hInst);
	if (hPage) 
	{
		if (pfnAddPropertyPage(hPage,lParam))
			dwFlags |= VFW_OEM_ADD_PAGE;
	}

#ifdef _SERVICE
	hPage = PRPPAGE3_CreatePage((LPFNEXTDEVIO) pfnDeviceIoControl, lParam, hInst);
	if (hPage) 
	{
		if (pfnAddPropertyPage(hPage,lParam))
			dwFlags |= VFW_OEM_ADD_PAGE;
	}
#endif

	dwFlags |= (VFW_HIDE_CAMERACONTROL_PAGE  | VFW_HIDE_SETTINGS_PAGE);
	
	return dwFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\prpcom.h ===
/*
 * Copyright (c) 1996 1997, 1998 Philips CE I&C

 * FILE			PRPCOM.H
 * DATE			7-1-97
 * VERSION		1.00
 * AUTHOR		M.J. Verberne
 * DESCRIPTION	Transfer of custom properties
 * HISTORY		
 */

#ifndef _PRPCOM_
#define _PRPCOM_

#include "phvcmext.h"

#ifdef MRES
#include "mprpobj.h"
#else 
#ifdef HRES
#include "hprpobj.h"
#endif
#endif

/*======================== EXPORTED FUNCTIONS =============================*/
BOOL PRPCOM_HasDeviceChanged(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam);


BOOL PRPCOM_Get_Value(
	GUID PropertySet,
	ULONG ulPropertyId,
	LPFNEXTDEVIO pfnDeviceIoControl, 
	LPARAM lParam, 
	PLONG plValue);

BOOL PRPCOM_Set_Value(
	GUID PropertySet,
	ULONG ulPropertyId,
	LPFNEXTDEVIO pfnDeviceIoControl, 
	LPARAM lParam, 
	LONG lValue);

BOOL PRPCOM_Get_Range(
	GUID PropertySet,
	ULONG ulPropertyId,
	LPFNEXTDEVIO pfnDeviceIoControl, 
	LPARAM lParam, 
	PLONG plMin, PLONG plMax);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\enre.h ===
/*MPD::
 * Copyright (c) 1996, 1997, 1998 Philips CE I&C
 * Project		: Real-i
 * module prefix: ENRE
 * creation date: Nov, 1996
 * author		: M.J. Verberne
 * description	: 
 *MPE::*/

#ifndef _ENRE_DEFINED
#define _ENRE_DEFINED

/* ----- CONSTANTS----------------------------------------------------------- */
/* ----- TYPES -------------------------------------------------------------- */
/* ----- EXTERNAL FUNCTIONS ------------------------------------------------- */

extern void ENRE_init(void);
extern void ENRE_exit(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\prpcom.cpp ===
/*
 * Copyright (c) 1996 1997, 1998 Philips CE I&C

 * FILE			PRPCOM.CPP
 * DATE			7-1-97
 * VERSION		1.00
 * AUTHOR		M.J. Verberne
 * DESCRIPTION	Property transfer
 * HISTORY		
 */
#include <windows.h>
#include <winioctl.h>
#include <olectl.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksguid.h>

#include "enre.h"
#include "debug.h"
#include "prpcom.h"
#include "phvcmext.h"

/*======================== DEFINES =======================================*/
#define FILE_DEVICE_KS                  0x0000002f	// needed by ks header,
													// bug of Microsoft

/*======================== DATA TYPES ====================================*/
typedef struct {
	KSPROPERTY_DESCRIPTION	    PropertyDescription;
	KSPROPERTY_MEMBERSHEADER    MembersHeader;
    ULONG                       DefaultValue;
} VIDEOPROCAMP_DEFAULTLIST;


typedef struct {
	KSPROPERTY_DESCRIPTION	    PropertyDescription;
	KSPROPERTY_MEMBERSHEADER    MembersHeader;
	KSPROPERTY_STEPPING_LONG    SteppingLong;
} VIDEOPROCAMP_MEMBERSLIST;

/*======================== LOCAL FUNCTION DEFINITIONS ====================*/
static BOOL PRPCOM_GetVideoProcAmpPropertyValue(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG  ulPropertyId,     
	PLONG  plValue);
static BOOL PRPCOM_SetVideoProcAmpPropertyValue(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG ulPropertyId,     
	LONG  lValue);
static BOOL PRPCOM_GetVideoProcAmpPropertyRange(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG  ulPropertyId,     
	PLONG  plMin,
	PLONG  plMax);
static BOOL PRPCOM_GetCustomPropertyValue(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG  ulPropertyId,     
	PLONG  plValue);
static BOOL PRPCOM_SetCustomPropertyValue(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG ulPropertyId,     
	LONG  lValue);
static BOOL PRPCOM_GetCustomPropertyRange(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG  ulPropertyId,     
	PLONG  plMin,
	PLONG  plMax);
static BOOL PRPCOM_ExtDeviceIoControl(
	LPFNEXTDEVIO	pfnDeviceIoControl,
	LPARAM lParam, 
	DWORD dwVfWFlags, 
	DWORD dwIoControlCode,	
	LPVOID lpInBuffer,	
	DWORD cbInBufferSize,
	LPVOID lpOutBuffer, 
	DWORD cbOutBufferSize, 
	LPDWORD pcbReturned);

#ifdef _DEBUG

static void PRPCOM_Debug_PRPCOM_GetVideoProcAmpPropertyValue(
	ULONG ulPropertyId, 
	PLONG plValue, 
	BOOL bRet);

static void PRPCOM_Debug_PRPCOM_SetVideoProcAmpPropertyValue(
	ULONG ulPropertyId, 
	LONG lValue, 
	BOOL bRet);

static void PRPCOM_Debug_PRPCOM_GetVideoProcAmpPropertyRange(
	ULONG ulPropertyId, 
	PLONG plMin, 
	PLONG plMax, 
	BOOL bRet);

static void PRPCOM_Debug_GetVideoProcAmpPropertyIdStr(
	ULONG ulPropertyId, 
	char *PropertyIdStr, 
	UINT MaxLen);

static void PRPCOM_Debug_PRPCOM_GetCustomPropertyValue(
	ULONG ulPropertyId, 
	PLONG plValue, 
	BOOL bRet);

static void PRPCOM_Debug_PRPCOM_SetCustomPropertyValue(
	ULONG ulPropertyId, 
	LONG lValue, 
	BOOL bRet);

static void PRPCOM_Debug_PRPCOM_GetCustomPropertyRange(
	ULONG ulPropertyId, 
	PLONG plMin, 
	PLONG plMax, 
	BOOL bRet);

static void PRPCOM_Debug_PRPCOM_GetCustomPropertyIdStr(
	ULONG ulPropertyId, 
	char *PropertyIdStr, 
	UINT MaxLen);

#endif


/*======================== EXPORTED FUNCTIONS =============================*/

/*-------------------------------------------------------------------------*/
BOOL PRPCOM_HasDeviceChanged(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam)
/*-------------------------------------------------------------------------*/
{
	BOOL bRet = TRUE;

	bRet = pfnDeviceIoControl (
				lParam, 
				VFW_QUERY_DEV_CHANGED,
				0,0,0,0,0,0, 0);
	return bRet;
}

/*-------------------------------------------------------------------------*/
BOOL PRPCOM_Get_Value(
	GUID PropertySet,
	ULONG ulPropertyId,
	LPFNEXTDEVIO pfnDeviceIoControl, 
	LPARAM lParam, 
	PLONG plValue)
/*-------------------------------------------------------------------------*/
{
	BOOL bResult;

	if (IsEqualGUID(PropertySet, PROPSETID_VIDCAP_VIDEOPROCAMP))
	{
		// get VIDEOPROCAMP value
		bResult = PRPCOM_GetVideoProcAmpPropertyValue(
				pfnDeviceIoControl,
				lParam,
				ulPropertyId,     
				plValue);
	}
	else if (IsEqualGUID(PropertySet, PROPSETID_PHILIPS_CUSTOM_PROP))
	{
		// get custom value
		bResult = PRPCOM_GetCustomPropertyValue(
				pfnDeviceIoControl,
				lParam,
				ulPropertyId,     
				plValue);
	}
	else
		return FALSE;

	return bResult;
}

/*-------------------------------------------------------------------------*/
BOOL PRPCOM_Set_Value(
	GUID PropertySet,
	ULONG ulPropertyId,
	LPFNEXTDEVIO pfnDeviceIoControl, 
	LPARAM lParam, 
	LONG lValue)
/*-------------------------------------------------------------------------*/
{
	BOOL bResult;

	if (IsEqualGUID(PropertySet, PROPSETID_VIDCAP_VIDEOPROCAMP))	
	{
		// set VIDEOPROCAMP value
		bResult = PRPCOM_SetVideoProcAmpPropertyValue(
				pfnDeviceIoControl,
				lParam,
				ulPropertyId,     
				lValue);
	}
	else if (IsEqualGUID(PropertySet, PROPSETID_PHILIPS_CUSTOM_PROP))
	{
		// set custom value
		bResult = PRPCOM_SetCustomPropertyValue(
				pfnDeviceIoControl,
				lParam,
				ulPropertyId,     
				lValue);
	}
	else
		return FALSE;

	return bResult;
}

/*-------------------------------------------------------------------------*/
BOOL PRPCOM_Get_Range(
	GUID PropertySet,
	ULONG ulPropertyId,
	LPFNEXTDEVIO pfnDeviceIoControl, 
	LPARAM lParam, 
	PLONG plMin, PLONG plMax)
/*-------------------------------------------------------------------------*/
{
	BOOL bResult;
	
	if (IsEqualGUID(PropertySet, PROPSETID_VIDCAP_VIDEOPROCAMP))
	{
		// get VIDEOPROCAMP range
		bResult = PRPCOM_GetVideoProcAmpPropertyRange(
				pfnDeviceIoControl,
				lParam,
				ulPropertyId,     
				plMin,
				plMax);
	}
	else if (IsEqualGUID(PropertySet, PROPSETID_PHILIPS_CUSTOM_PROP))
	{
		// get custom range
		bResult = PRPCOM_GetCustomPropertyRange(
				pfnDeviceIoControl,
				lParam,
				ulPropertyId,     
				plMin,
				plMax);
	}
	else
		return FALSE;

	return bResult;
}


/*======================== LOCAL FUNCTIONS ================================*/

/*-------------------------------------------------------------------------*/
static BOOL PRPCOM_GetVideoProcAmpPropertyValue(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG  ulPropertyId,     
	PLONG  plValue)
/*-------------------------------------------------------------------------*/
{
	BOOL	bRet;
	DWORD	cbRet;    	
	KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;

	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S) );
	VideoProperty.Property.Set   = PROPSETID_VIDCAP_VIDEOPROCAMP;
	VideoProperty.Property.Id    = ulPropertyId;         
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_GET;
	VideoProperty.Flags          = 0;
	VideoProperty.Capabilities   = 0;

	if ((bRet = PRPCOM_ExtDeviceIoControl(
					pfnDeviceIoControl,
					lParam,
					VFW_USE_DEVICE_HANDLE,	
					IOCTL_KS_PROPERTY,
					&VideoProperty,	
					sizeof(VideoProperty), 
					&VideoProperty, 
					sizeof(VideoProperty), 
					&cbRet))) 
	{
		if (plValue != NULL)
			*plValue         = VideoProperty.Value;
/*		if (pulFlags != NULL)
			*pulFlags        = VideoProperty.Flags;
		if (pulCapabilities != NULL)
			*pulCapabilities = VideoProperty.Capabilities;*/
	} 	

#ifdef _DEBUG
	PRPCOM_Debug_PRPCOM_GetVideoProcAmpPropertyValue(ulPropertyId, plValue, bRet);
#endif

	return bRet;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPCOM_SetVideoProcAmpPropertyValue(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG ulPropertyId,     
	LONG  lValue)
/*-------------------------------------------------------------------------*/
{
	BOOL	bRet;
	DWORD	cbRet;    	
	KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;

	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S) );
	VideoProperty.Property.Set   = PROPSETID_VIDCAP_VIDEOPROCAMP;      
	VideoProperty.Property.Id    = ulPropertyId;         
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_SET;
	VideoProperty.Value			 = lValue;        
	VideoProperty.Flags			 = 0;
	VideoProperty.Capabilities   = 0;
	
	
	bRet = PRPCOM_ExtDeviceIoControl(
					pfnDeviceIoControl,
					lParam,
					VFW_USE_DEVICE_HANDLE,
					IOCTL_KS_PROPERTY,
					&VideoProperty,	
					sizeof(VideoProperty), 
					&VideoProperty, 
					sizeof(VideoProperty), 
					&cbRet); 

#ifdef _DEBUG
	PRPCOM_Debug_PRPCOM_SetVideoProcAmpPropertyValue(ulPropertyId, lValue, bRet);
#endif

	return bRet;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPCOM_GetVideoProcAmpPropertyRange(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG  ulPropertyId,     
	PLONG  plMin,
	PLONG  plMax)
/*-------------------------------------------------------------------------*/
{
	BOOL	bRet;
	DWORD	cbRet;    	
	KSPROPERTY_VIDEOPROCAMP_S VideoProperty;
	VIDEOPROCAMP_MEMBERSLIST PropertyList;

	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S) );
	VideoProperty.Property.Set   = PROPSETID_VIDCAP_VIDEOPROCAMP;      
	VideoProperty.Property.Id    = ulPropertyId;
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
	VideoProperty.Flags		     = 0;
	VideoProperty.Capabilities   = 0;

	bRet = PRPCOM_ExtDeviceIoControl(
					pfnDeviceIoControl,
					lParam,
					VFW_USE_DEVICE_HANDLE,
					IOCTL_KS_PROPERTY,
					&VideoProperty,	
					sizeof(VideoProperty), 
					&PropertyList,
					sizeof(PropertyList),
					&cbRet); 
	if (plMin != NULL)
		*plMin  = PropertyList.SteppingLong.Bounds.SignedMinimum;
	if (plMax != NULL)
		*plMax  = PropertyList.SteppingLong.Bounds.SignedMaximum;

#ifdef _DEBUG
	PRPCOM_Debug_PRPCOM_GetVideoProcAmpPropertyRange(ulPropertyId, plMin, plMax, bRet);
#endif

	return bRet;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPCOM_GetCustomPropertyValue(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG  ulPropertyId,     
	PLONG  plValue)
/*-------------------------------------------------------------------------*/
{
	BOOL	bRet;
	DWORD	cbRet;    	
	KSPROPERTY_PHILIPS_CUSTOM_PROP_S  VideoProperty;

	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S) );
	VideoProperty.Property.Set   = PROPSETID_PHILIPS_CUSTOM_PROP;      
	VideoProperty.Property.Id    = ulPropertyId;         
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_GET;
	VideoProperty.Flags          = 0;
	VideoProperty.Capabilities   = 0;

	if ((bRet = PRPCOM_ExtDeviceIoControl(
					pfnDeviceIoControl,
					lParam,
					VFW_USE_DEVICE_HANDLE,	
					IOCTL_KS_PROPERTY,
					&VideoProperty,	
					sizeof(VideoProperty), 
					&VideoProperty, 
					sizeof(VideoProperty), 
					&cbRet))) 
	{
		if (plValue != NULL)
			*plValue         = VideoProperty.Value;
/*		if (pulFlags != NULL)
			*pulFlags        = VideoProperty.Flags;
		if (pulCapabilities != NULL)
			*pulCapabilities = VideoProperty.Capabilities;*/
	} 	

#ifdef _DEBUG
	PRPCOM_Debug_PRPCOM_GetCustomPropertyValue(ulPropertyId, plValue, bRet);
#endif

	return bRet;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPCOM_SetCustomPropertyValue(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG ulPropertyId,     
	LONG  lValue)
/*-------------------------------------------------------------------------*/
{
	BOOL	bRet;
	DWORD	cbRet;    	
	KSPROPERTY_PHILIPS_CUSTOM_PROP_S VideoProperty;

	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S) );
	VideoProperty.Property.Set   = PROPSETID_PHILIPS_CUSTOM_PROP;      
	VideoProperty.Property.Id    = ulPropertyId;         
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_SET;
	VideoProperty.Value			 = lValue;        
	VideoProperty.Flags			 = 0;
	VideoProperty.Capabilities   = 0;
	
	bRet = PRPCOM_ExtDeviceIoControl(
					pfnDeviceIoControl,
					lParam,
					VFW_USE_DEVICE_HANDLE,
					IOCTL_KS_PROPERTY,
					&VideoProperty,	
					sizeof(VideoProperty), 
					&VideoProperty, 
					sizeof(VideoProperty), 
					&cbRet); 

#ifdef _DEBUG
	PRPCOM_Debug_PRPCOM_SetCustomPropertyValue(ulPropertyId, lValue, bRet);
#endif

	return bRet;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPCOM_GetCustomPropertyRange(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	ULONG  ulPropertyId,     
	PLONG  plMin,
	PLONG  plMax)
/*-------------------------------------------------------------------------*/
{
	BOOL	bRet;
	DWORD	cbRet;    	
	KSPROPERTY_PHILIPS_CUSTOM_PROP_S VideoProperty;
	VIDEOPROCAMP_MEMBERSLIST PropertyList;

	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_PHILIPS_CUSTOM_PROP_S) );
	VideoProperty.Property.Set   = PROPSETID_PHILIPS_CUSTOM_PROP;      
	VideoProperty.Property.Id    = ulPropertyId;         
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
	VideoProperty.Flags          = 0;
	VideoProperty.Capabilities   = 0;

	bRet = PRPCOM_ExtDeviceIoControl(
					pfnDeviceIoControl,
					lParam,
					VFW_USE_DEVICE_HANDLE,
					IOCTL_KS_PROPERTY,
					&VideoProperty,	
					sizeof(VideoProperty), 
					&PropertyList,
					sizeof(PropertyList),
					&cbRet); 
	if (plMin != NULL)
		*plMin  = PropertyList.SteppingLong.Bounds.SignedMinimum;
	if (plMax != NULL)
		*plMax  = PropertyList.SteppingLong.Bounds.SignedMaximum;

#ifdef _DEBUG
	PRPCOM_Debug_PRPCOM_GetCustomPropertyRange(ulPropertyId, plMin, plMax, bRet);
#endif

	return bRet;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPCOM_ExtDeviceIoControl(
	LPFNEXTDEVIO	pfnDeviceIoControl,
	LPARAM		lParam, 
	DWORD		dwVfWFlags, 
	DWORD		dwIoControlCode,	
	LPVOID		lpInBuffer,	
	DWORD		cbInBufferSize,
	LPVOID		lpOutBuffer, 
	DWORD		cbOutBufferSize, 
	LPDWORD		pcbReturned)
/*-------------------------------------------------------------------------*/
{
	OVERLAPPED	ov;
	BOOL bRet;

	ov.Offset		= 0;
	ov.OffsetHigh	= 0;
	ov.hEvent		= CreateEvent( NULL, FALSE, FALSE, NULL );

	if (ov.hEvent == (HANDLE) 0) 
		bRet= FALSE;
	else 
	{
		bRet = pfnDeviceIoControl (
				lParam,
			    dwVfWFlags,
				dwIoControlCode, 
				lpInBuffer, 
				cbInBufferSize, 
				lpOutBuffer, 
				cbOutBufferSize, 
				pcbReturned,
				&ov);
		if (!bRet && GetLastError() == ERROR_IO_PENDING) 
			bRet = WaitForSingleObject( ov.hEvent, 2000 ) == WAIT_OBJECT_0;
		CloseHandle(ov.hEvent);
	}
		
	return bRet;
}


/*======================== DEBUGGING CODE =================================*/

#ifdef _DEBUG

/*-------------------------------------------------------------------------*/
static void PRPCOM_Debug_PRPCOM_GetVideoProcAmpPropertyValue(
	ULONG ulPropertyId, 
	PLONG plValue, 
	BOOL bRet)
/*-------------------------------------------------------------------------*/
{
	char PropertyIdStr[132], RetStr[132];

	PRPCOM_Debug_GetVideoProcAmpPropertyIdStr(
		ulPropertyId, PropertyIdStr, 132);

	strcpy(RetStr, bRet ? "TRUE" : "FALSE");

	printf("\nPRPCOM_GetVideoProcAmpPropertyValue(%s) --> %s, Value: %li", 
			PropertyIdStr, RetStr, *plValue);
}

/*-------------------------------------------------------------------------*/
static void PRPCOM_Debug_PRPCOM_SetVideoProcAmpPropertyValue(
	ULONG ulPropertyId, 
	LONG lValue, 
	BOOL bRet)
/*-------------------------------------------------------------------------*/
{
	char PropertyIdStr[132], RetStr[132];

	PRPCOM_Debug_GetVideoProcAmpPropertyIdStr(
		ulPropertyId, PropertyIdStr, 132);

	strcpy(RetStr, bRet ? "TRUE" : "FALSE");

	printf("\nPRPCOM_SetVideoProcAmpPropertyValue(%s, %li) --> %s", 
			PropertyIdStr, lValue, RetStr);

}

/*-------------------------------------------------------------------------*/
static void PRPCOM_Debug_PRPCOM_GetVideoProcAmpPropertyRange(
	ULONG ulPropertyId, 
	PLONG plMin, 
	PLONG plMax, 
	BOOL bRet)
/*-------------------------------------------------------------------------*/
{
	char PropertyIdStr[132], RetStr[132];

	PRPCOM_Debug_GetVideoProcAmpPropertyIdStr(
		ulPropertyId, PropertyIdStr, 132);

	strcpy(RetStr, bRet ? "TRUE" : "FALSE");

	printf("\nPRPCOM_GetVideoProcAmpPropertyRange(%s) --> %s, Min: %li, Max : %li", 
			PropertyIdStr, RetStr, *plMin, *plMax, *plMax);
}

/*-------------------------------------------------------------------------*/
static void PRPCOM_Debug_GetVideoProcAmpPropertyIdStr(
	ULONG ulPropertyId, 
	char *PropertyIdStr, 
	UINT MaxLen)
/*-------------------------------------------------------------------------*/
{
	if (MaxLen == 0)
		return;

	switch(ulPropertyId)
	{
		case KSPROPERTY_VIDEOPROCAMP_COLORENABLE:
			strncpy(PropertyIdStr, "COLORENABLE", MaxLen - 1);
			break;
		case KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION:
			strncpy(PropertyIdStr, "BACKLIGHT_COMPENSATION", MaxLen - 1);
			break;
		case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
			strncpy(PropertyIdStr, "BRIGHTNESS", MaxLen - 1);
			break;
		case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
			strncpy(PropertyIdStr, "CONTRAST", MaxLen - 1);
			break;
		case KSPROPERTY_VIDEOPROCAMP_GAMMA:
			strncpy(PropertyIdStr, "GAMMA", MaxLen - 1);
			break;
		default:
			strncpy(PropertyIdStr, "??", MaxLen - 1);
	}
}

/*-------------------------------------------------------------------------*/
static void PRPCOM_Debug_PRPCOM_GetCustomPropertyValue(
	ULONG ulPropertyId, 
	PLONG plValue, 
	BOOL bRet)
/*-------------------------------------------------------------------------*/
{
	char PropertyIdStr[132], RetStr[132];

	PRPCOM_Debug_PRPCOM_GetCustomPropertyIdStr(
		ulPropertyId, PropertyIdStr, 132);

	strcpy(RetStr, bRet ? "TRUE" : "FALSE");

	printf("\nPRPCOM_GetCustomPropertyValue(%s) --> %s, Value: %li", 
			PropertyIdStr, RetStr, *plValue);
}

/*-------------------------------------------------------------------------*/
static void PRPCOM_Debug_PRPCOM_SetCustomPropertyValue(
	ULONG ulPropertyId, 
	LONG lValue, 
	BOOL bRet)
/*-------------------------------------------------------------------------*/
{
	char PropertyIdStr[132], RetStr[132];

	PRPCOM_Debug_PRPCOM_GetCustomPropertyIdStr(
		ulPropertyId, PropertyIdStr, 132);

	strcpy(RetStr, bRet ? "TRUE" : "FALSE");

	printf("\nPRPCOM_SetCustomPropertyValue(%s, %li) --> %s", 
			PropertyIdStr, lValue, RetStr);
}

/*-------------------------------------------------------------------------*/
static void PRPCOM_Debug_PRPCOM_GetCustomPropertyRange(
	ULONG ulPropertyId, 
	PLONG plMin, 
	PLONG plMax, 
	BOOL bRet)
/*-------------------------------------------------------------------------*/
{
	char PropertyIdStr[132], RetStr[132];

	PRPCOM_Debug_PRPCOM_GetCustomPropertyIdStr(
		ulPropertyId, PropertyIdStr, 132);

	strcpy(RetStr, bRet ? "TRUE" : "FALSE");

	printf("\nPRPCOM_GetCustomPropertyRange(%s) --> %s, Min: %li, Max : %li", 
			PropertyIdStr, RetStr, *plMin, *plMax, *plMax);
}

/*-------------------------------------------------------------------------*/
static void PRPCOM_Debug_PRPCOM_GetCustomPropertyIdStr(
	ULONG ulPropertyId, 
	char *PropertyIdStr, 
	UINT MaxLen)
/*-------------------------------------------------------------------------*/
{
	if (MaxLen == 0)
		return;

	switch(ulPropertyId)
	{
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE:		
			strncpy(PropertyIdStr, "WB_MODE", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_SPEED:	
			strncpy(PropertyIdStr, "WB_SPEED", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_DELAY:		
			strncpy(PropertyIdStr, "WB_DELAY", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_RED_GAIN:
			strncpy(PropertyIdStr, "RED_GAIN", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_BLUE_GAIN:
			strncpy(PropertyIdStr, "BLUE_GAIN", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_CONTROL_SPEED:  
			strncpy(PropertyIdStr, "EXPOSURE_SPEED", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS:
			strncpy(PropertyIdStr, "FLICKERLESS", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE:
			strncpy(PropertyIdStr, "EXPOSURE_SHUTTER_MODE", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED:
			strncpy(PropertyIdStr, "SHUTTERSPEED", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_STATUS:
			strncpy(PropertyIdStr, "SHUTTERSTATUS", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE:	    
			strncpy(PropertyIdStr, "EXPOSURE_AGC_MODE", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC:
			strncpy(PropertyIdStr, "EXPOSURE_AGC_SPEED", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_DRIVERVERSION:
			strncpy(PropertyIdStr, "DRIVERVERSION", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE:
			strncpy(PropertyIdStr, "FRAMERATE", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOFORMAT:
			strncpy(PropertyIdStr, "VIDEOFORMAT", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_SENSORTYPE:
			strncpy(PropertyIdStr, "SENSORTYPE", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_VIDEOCOMPRESSION:
			strncpy(PropertyIdStr, "VIDEOCOMPRESSION", MaxLen - 1);
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS:
			strncpy(PropertyIdStr, "DEFAULTS", MaxLen - 1);
			break;
		default:
			strncpy(PropertyIdStr, "??", MaxLen - 1);
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\enre.cpp ===
/*MPD::
 * Copyright (c) 1996 1997, 1998 Philips CE I&C
 *
 * Project		: Real-i
 * module prefix: IMTD
 * creation date: Nov, 1996
 * author		: M.J. Verberne
 * description	:
 *MPE::*/
#include <windows.h>
#include <io.h>
#include <stdio.h>
#include <fcntl.h>
#include "enre.h"

/* ----- CONSTANTS----------------------------------------------------------- */
/* ----- TYPES -------------------------------------------------------------- */
/* ----- GLOBAL VARIABLES --------------------------------------------------- */
/* ----- STATIC VARIABLES --------------------------------------------------- */
/* ----- STATIC FUNCTION DECLARATIONS --------------------------------------- */
/* ----- EXTERNAL FUNCTIONS ------------------------------------------------- */

/******************************************************************************/
void ENRE_init(void)
/******************************************************************************/
{
	int hCrt;
	FILE *hf;
	int i;
	COORD size;
	HWND hWnd;
	char title[256];
	int width, height;

	AllocConsole();
	SetConsoleTitle("Debugging Output");
	size = GetLargestConsoleWindowSize(GetStdHandle(STD_OUTPUT_HANDLE));
	size.Y = 65356 / size.X;
	SetConsoleScreenBufferSize(GetStdHandle(STD_OUTPUT_HANDLE), size);
	GetConsoleTitle(title, 256);
	hWnd=FindWindow(NULL, title);
//	width = GetSystemMetrics(SM_CXFULLSCREEN);
//	height =GetSystemMetrics(SM_CYFULLSCREEN)- 480;
	width = GetSystemMetrics(SM_CXFULLSCREEN) /2;
	height =GetSystemMetrics(SM_CYFULLSCREEN) / 2;
//	SetWindowPos(hWnd, HWND_TOP, 0, 480, width, height, 0);
	SetWindowPos(hWnd, HWND_TOP, 0, 0, width, height, SWP_NOMOVE | SWP_FRAMECHANGED);

	if ( hCrt = _open_osfhandle( 
		(LONG_PTR) GetStdHandle(STD_OUTPUT_HANDLE),
		_O_TEXT ) )
        {
	        if ( hf = _fdopen( hCrt, "w" ) )
		{
			*stdout = *hf;
		}
	}

	if ( hCrt = _open_osfhandle( 
		(LONG_PTR) GetStdHandle(STD_ERROR_HANDLE),
		_O_TEXT ) )
	{
		if ( hf = _fdopen( hCrt, "w" ) )
		{
			*stderr = *hf;
			i = setvbuf( stderr, NULL, _IONBF, 0 );
		}
	}

	if ( hCrt = _open_osfhandle(
		(LONG_PTR) GetStdHandle(STD_INPUT_HANDLE),
		_O_TEXT ) )
        {
		if ( hf = _fdopen( hCrt, "r" ) )
		{
			*stdin = *hf;
			i = setvbuf( stdin, NULL, _IONBF, 0 );
		}
	}
}

/******************************************************************************/
void ENRE_exit(void)
/******************************************************************************/
{
	FreeConsole();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\phvcmext.h ===
/*
 * Copyright (c) 1996 1997, 1998 Philips CE I&C
 *
 * FILE			PHVCMEXT.H
 * DATE			7-1-97
 * VERSION		1.00
 * AUTHOR		M.J. Verberne
 * DESCRIPTION	Main of extension DLL
 * HISTORY		This header file originates
 *              from Microsoft. 
 */
#ifndef _PHVCMEXT_
#define _PHVCMEXT_

#include <prsht.h>

/*======================== DEFINES =======================================*/
#define VFW_HIDE_SETTINGS_PAGE       0x00000001
#define VFW_HIDE_IMAGEFORMAT_PAGE    0x00000002
#define VFW_HIDE_CAMERACONTROL_PAGE  0x00000004
#define VFW_HIDE_ALL_PAGES           (VFW_HIDE_SETTINGS_PAGE | VFW_HIDE_IMAGEFORMAT_PAGE | VFW_HIDE_CAMERACONTROL_PAGE)
#define VFW_OEM_ADD_PAGE             0x80000000  // If OEM has added any page


#define VFW_USE_DEVICE_HANDLE        0x00000001
#define VFW_USE_STREAM_HANDLE        0x00000002
#define VFW_QUERY_DEV_CHANGED        0x00000100  // Selected_dev == streaming_dev


/*======================== DATA TYPES ====================================*/
//
// This is the function pointer that vfwwdm mapper calls to add an page
//
typedef 
DWORD (CALLBACK FAR * VFWWDMExtensionProc)(
	LPVOID					pfnDeviceIoControl, 
	LPFNADDPROPSHEETPAGE	pfnAddPropertyPage, 
	LPARAM					lParam);

//
// This is the function pointer that you can call to make DeviceIoControl() calls.
//
typedef 
BOOL (CALLBACK FAR * LPFNEXTDEVIO)(
					LPARAM lParam,	
					DWORD dwFlags,
					DWORD dwIoControlCode, 
					LPVOID lpInBuffer, 
					DWORD nInBufferSize, 
					LPVOID lpOutBuffer, 
					DWORD nOutBufferSize, 
					LPDWORD lpBytesReturned,
					LPOVERLAPPED lpOverlapped);

//
// This struture is used to record the device pointer
//
typedef 
struct _VFWEXT_INFO 
{
	LPFNEXTDEVIO pfnDeviceIoControl;
	LPARAM lParam;
} VFWEXT_INFO, * PVFWEXT_INFO;


/*======================== GLOBAL DATA ===================================*/

// instance handle of this module
extern HINSTANCE hInst; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\prpctrl.cpp ===
/*
 * Copyright (c) 1996 1997, 1998 Philips CE I&C
 *
 * FILE			PRPCTRL.CPP
 * DATE			7-1-97
 * VERSION		1.00
 * AUTHOR		M.J. Verberne
 * DESCRIPTION	Handle controls associated with
 *              properties
 * HISTORY		
 */
#include <windows.h>
#include <winioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <commctrl.h>
#include "prpcom.h"
#include "debug.h"
#include "phvcmext.h"
#include "prpctrl.h"

/*======================== LOCAL FUNCTION DEFINITIONS ====================*/
static void PRPCTRL_ScaleToPercent(LONG *plValue, LONG lMin, LONG lMax);

/*======================== EXPORTED FUNCTIONS =============================*/

/*-------------------------------------------------------------------------*/
BOOL PRPCTRL_Init(
		HWND hDlg,
		PRPCTRL_INFO *pCtrl,
		BOOL bEnable)
/*-------------------------------------------------------------------------*/
{
	BOOL bResult = TRUE;
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

	// check control
	if (!pCtrl->PrpCtrl)
		return FALSE;

	// get and set the ranges for slider controls
	if (pCtrl->PrpCtrlType == PRPCTRL_TYPE_SLIDER)
	{
		// preinit min and max for savety reasons
		pCtrl->lMin = 0;
		pCtrl->lMax = 0;

		// get property range
		bResult = PRPCOM_Get_Range(
			pCtrl->PropertySet,
			pCtrl->ulPropertyId,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			&pCtrl->lMin, &pCtrl->lMax);
		if (!bResult)
			return FALSE;

		// check ranges
		if (pCtrl->lMin > pCtrl->lMax)
			return FALSE;

		// set property range
		SendMessage(
			GetDlgItem(hDlg, pCtrl->PrpCtrl),
			TBM_SETRANGE, TRUE, MAKELONG(pCtrl->lMin, pCtrl->lMax));

		// set the thick marks
		SendMessage(
			GetDlgItem(hDlg, pCtrl->PrpCtrl),
			TBM_SETTICFREQ, (WPARAM) ((pCtrl->lMax - pCtrl->lMin) / 10), (LPARAM) 0);
	}
	else if (pCtrl->PrpCtrlType == PRPCTRL_TYPE_CHECKBOX)
	{
		// already filled in by user
	}
	else
		return FALSE;

	// update actual state
	bResult = PRPCTRL_Enable(hDlg, pCtrl, bEnable);
	
	return bResult;
}

/*-------------------------------------------------------------------------*/
BOOL PRPCTRL_Enable(
		HWND hDlg,
		PRPCTRL_INFO *pCtrl,
		BOOL bEnable)
/*-------------------------------------------------------------------------*/
{
	LONG lValue;
	BOOL bResult = TRUE;
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

	// check control
	if (!pCtrl->PrpCtrl)
		return FALSE;

	// get value if enable
	if (bEnable)
	{
		// get value of the control
		bResult = PRPCOM_Get_Value(
			pCtrl->PropertySet,
			pCtrl->ulPropertyId,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			&lValue);
		if (!bResult)
			return FALSE;

		// bring it into range of slider
		if (lValue < pCtrl->lMin)
			lValue = pCtrl->lMin;
		else if (lValue > pCtrl->lMax)
			lValue = pCtrl->lMax;

		// adjust if reverse
		if (pCtrl->bReverse)
		{
			lValue = pCtrl->lMin + pCtrl->lMax - lValue;
		}

		if (pCtrl->PrpCtrlType == PRPCTRL_TYPE_SLIDER)
		{	
			// update slider pos
			SendMessage(
				GetDlgItem(hDlg, pCtrl->PrpCtrl),
				TBM_SETPOS, TRUE,  (LPARAM)(LONG) lValue);
		}
		else if (pCtrl->PrpCtrlType == PRPCTRL_TYPE_CHECKBOX)
		{
			// update checkbox state
			SendMessage(GetDlgItem(hDlg, pCtrl->PrpCtrl), BM_SETCHECK, lValue, 0);
		}
		else
			return FALSE;

		// update buddy
		if (pCtrl->BuddyCtrl)
		{
			if (pCtrl->BuddyStrings != NULL)
			{
				SetDlgItemText(hDlg, pCtrl->BuddyCtrl, pCtrl->BuddyStrings[lValue]);
			}
			else
			{
				PRPCTRL_ScaleToPercent(&lValue, pCtrl->lMin, pCtrl->lMax);
				SetDlgItemInt(hDlg, pCtrl->BuddyCtrl, lValue, FALSE);
			}
		}
	}
	else
	{
		if (pCtrl->PrpCtrlType == PRPCTRL_TYPE_SLIDER)
		{
			// set the thumb to the middle of the slider
			lValue = pCtrl->lMin + (pCtrl->lMax - pCtrl->lMin) / 2;
			SendMessage(
				GetDlgItem(hDlg, pCtrl->PrpCtrl),
				TBM_SETPOS, TRUE,  (LPARAM)(LONG) lValue);
		}

		// clear the buddy
		if (pCtrl->BuddyCtrl)
			SetDlgItemText(hDlg, pCtrl->BuddyCtrl, "");
	}

	// enable / disable controls.
	EnableWindow(GetDlgItem(hDlg, pCtrl->PrpCtrl), bEnable);
	if (pCtrl->BuddyCtrl)
		EnableWindow(GetDlgItem(hDlg, pCtrl->BuddyCtrl), bEnable);
	if (pCtrl->TextCtrl)
		EnableWindow(GetDlgItem(hDlg, pCtrl->TextCtrl), bEnable);

	return bResult;

}

/*-------------------------------------------------------------------------*/
BOOL PRPCTRL_Handle_Msg(
		HWND hDlg,
		PRPCTRL_INFO *pCtrl)
/*-------------------------------------------------------------------------*/
{
	LONG lValue, lPos;
	BOOL bResult;
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

	if (pCtrl->PrpCtrlType == PRPCTRL_TYPE_SLIDER)
	{	
		// get position of slider
		lPos = (LONG)SendMessage(
			GetDlgItem(hDlg, pCtrl->PrpCtrl),
			TBM_GETPOS, (WPARAM) 0, (LPARAM) 0);

		// bring it into range of slider
		if (lPos < pCtrl->lMin)
			lPos = pCtrl->lMin;
		else if (lPos > pCtrl->lMax)
			lPos = pCtrl->lMax;
	}			
	else if (pCtrl->PrpCtrlType == PRPCTRL_TYPE_CHECKBOX)
	{
		// get state of checkbox
		if (SendMessage(GetDlgItem(hDlg, pCtrl->PrpCtrl),
				BM_GETCHECK, 0, 0) == BST_CHECKED)
			lPos = pCtrl->lMax;
		else
			lPos = pCtrl->lMin;
	}
	else
		return FALSE;

	// reverse if needed
	if (pCtrl->bReverse)
		lValue = pCtrl->lMin + pCtrl->lMax - lPos;
	else
		lValue = lPos;

	// Set value of property
	bResult = PRPCOM_Set_Value(
			pCtrl->PropertySet,
			pCtrl->ulPropertyId,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			lValue);
	if (!bResult)
		return FALSE;

	// update buddy
	if (pCtrl->BuddyCtrl)
	{
		if (pCtrl->BuddyStrings != NULL)
		{
			SetDlgItemText(hDlg, pCtrl->BuddyCtrl, pCtrl->BuddyStrings[lPos]);
		}
		else
		{
			PRPCTRL_ScaleToPercent(&lPos, pCtrl->lMin, pCtrl->lMax);
			SetDlgItemInt(hDlg, pCtrl->BuddyCtrl, lPos, FALSE);
		}
	}

	return TRUE;
}

/*-------------------------------------------------------------------------*/
static void PRPCTRL_ScaleToPercent(LONG *plValue, LONG lMin, LONG lMax)
/*-------------------------------------------------------------------------*/
{
	// validate
	if (lMin >= lMax)
	{
		(*plValue) = lMin;
		return;
	}

	// check borders
	if ((*plValue) < lMin)
	{
		(*plValue) = 0;
		return;
	}
	if ((*plValue) > lMax)
	{
		(*plValue) = 10000;
		return;
	}
	
	(*plValue) = (((*plValue) - lMin) * 100) / (lMax - lMin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\prpctrl.h ===
/*
 * Copyright (c) 1996 1997, 1998 Philips CE I&C
 *
 * FILE			PRPCTRL.H
 * DATE			7-1-97
 * VERSION		1.00
 * AUTHOR		M.J. Verberne
 * DESCRIPTION	Handle controls associated with 
 *              properties
 * HISTORY		
 */
#ifndef _PRPCTRL_
#define _PRPCTRL_

/*======================== DEFINES =======================================*/
#define PRPCTRL_TYPE_SLIDER		0
#define PRPCTRL_TYPE_CHECKBOX	1

/*======================== DATA TYPES ====================================*/
typedef struct PRPCTRL
{
	BOOL PrpCtrlType;
	WORD PrpCtrl;
	WORD BuddyCtrl;
	WORD TextCtrl;
	GUID PropertySet;
	ULONG ulPropertyId;
	BOOL bReverse;
	char **BuddyStrings;
	LONG lMin;
	LONG lMax;
} PRPCTRL_INFO;

/*======================== EXPORTED FUNCTIONS =============================*/
BOOL PRPCTRL_Init(
		HWND hDlg,
		PRPCTRL_INFO *pCtrl, 
		BOOL bEnable);

BOOL PRPCTRL_Enable(
		HWND hDlg,
		PRPCTRL_INFO *pCtrl, 
		BOOL bEnable);

BOOL PRPCTRL_Handle_Msg(
		HWND hDlg, 
		PRPCTRL_INFO *pCtrl);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\prppage2.h ===
/*
 * Copyright (c) 1996 1997, 1998 Philips CE I&C
 *
 * FILE			PRPPAGE2.H
 * DATE			7-1-97
 * VERSION		1.00
 * AUTHOR		M.J. Verberne
 * DESCRIPTION	Implements the first property page
 * HISTORY		
 */

#ifndef _PRPPAGE2_
#define _PRPPAGE2_

#include "phvcmext.h"

HPROPSHEETPAGE PRPPAGE2_CreatePage(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	HINSTANCE hInst);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\prppage1.cpp ===
/*
 * Copyright (c) 1996 1997, 1998 Philips CE I&C
 *
 * FILE			PRPPAGE1.CPP
 * DATE			7-1-97
 * VERSION		1.00
 * AUTHOR		M.J. Verberne
 * DESCRIPTION	Property page 1
 * HISTORY		
 */
#include <windows.h>
#include <winioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <commctrl.h>
#include "resource.h"
#include "prpcom.h"
#include "debug.h"
#include "phvcmext.h"
#include "prpctrl.h"
#include "prppage1.h"

/*======================== LOCAL DATA ====================================*/
static BOOL bInitialized = FALSE;
static BOOL bWB_Freeze = TRUE;
static BOOL bAE_Freeze = TRUE;

static VFWEXT_INFO VfWExtInfo;
static char *Shutter_Speed_Strings[11] =
	{
		"1/10000",	"1/5000",
		"1/2500",	"1/1500",
		"1/1000",	"1/500",	
		"1/250",	"1/100",
		"1/50",		"1/33",	
		"1/25",
	};

static PRPCTRL WB_Red_Gain_Ctrl =
	{
		PRPCTRL_TYPE_SLIDER,
		IDS_WB_RED_GAIN,
		IDE_WB_RED_GAIN,
		IDT_WB_RED_GAIN,
		STATIC_PROPSETID_PHILIPS_CUSTOM_PROP,
		KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_RED_GAIN,
		FALSE,
		NULL,
		0,
		0
	};
static PRPCTRL WB_Blue_Gain_Ctrl =
	{
		PRPCTRL_TYPE_SLIDER,
		IDS_WB_BLUE_GAIN,
		IDE_WB_BLUE_GAIN,
		IDT_WB_BLUE_GAIN,
		STATIC_PROPSETID_PHILIPS_CUSTOM_PROP,
		KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_BLUE_GAIN,
		FALSE,
		NULL,
		0,
		0
	};
static PRPCTRL WB_Speed_Ctrl =
	{
		PRPCTRL_TYPE_SLIDER,
		IDS_WB_SPEED,
		IDE_WB_SPEED,
		IDT_WB_SPEED,
		STATIC_PROPSETID_PHILIPS_CUSTOM_PROP,
		KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_SPEED,
		TRUE,
		NULL,
		0,
		0
	};
static PRPCTRL AE_AGC_Ctrl =
	{
		PRPCTRL_TYPE_SLIDER,
		IDS_AE_AGC,
		IDE_AE_AGC,
		IDT_AE_AGC,
		STATIC_PROPSETID_PHILIPS_CUSTOM_PROP,
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC,
		FALSE,
		NULL,
		0,
		0
	};
static PRPCTRL AE_Shutter_Speed_Ctrl =
	{
		PRPCTRL_TYPE_SLIDER,
		IDS_AE_SHUTTER_SPEED,
		IDE_AE_SHUTTER_SPEED,
		IDT_AE_SHUTTER_SPEED,
		STATIC_PROPSETID_PHILIPS_CUSTOM_PROP,
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED,
		TRUE,
		Shutter_Speed_Strings,
		0,
		0
	};
static PRPCTRL AE_Control_Speed_Ctrl =
	{
		PRPCTRL_TYPE_SLIDER,
		IDS_AE_CONTROL_SPEED,
		IDE_AE_CONTROL_SPEED,
		IDT_AE_CONTROL_SPEED,
		STATIC_PROPSETID_PHILIPS_CUSTOM_PROP,
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_CONTROL_SPEED,
		TRUE,
		NULL,
		0,
		0
	};
static PRPCTRL AE_FlickerlessCtrl =
	{
		PRPCTRL_TYPE_CHECKBOX,
		IDC_AE_FLICKERLESS,
		0,
		0,
		STATIC_PROPSETID_PHILIPS_CUSTOM_PROP,
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS,
		FALSE,
		NULL,
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS_OFF,
		KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_FLICKERLESS_ON
	};

/*======================== LOCAL FUNCTION DEFINITIONS ====================*/
static INT_PTR CALLBACK PRPPAGE1_PageDlgProc(
	HWND hDlg,
	UINT uMessage,
	WPARAM wParam,
	LPARAM lParam);
static UINT _stdcall PRPPAGE1_PageCallback(
	HWND hwnd,
	UINT uMsg,
	LPPROPSHEETPAGE ppsp);
static BOOL PRPPAGE1_ExtSetActive(
	HWND hDlg,
	WPARAM	wParam,
	LPARAM	lParam);
static BOOL PRPPAGE1_PageDlgProc_DoCommand(
	HWND hDlg,
    WPARAM wParam,
	LPARAM lParam);
static BOOL PRPPAGE1_Init_WB(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam);
static BOOL PRPPAGE1_Init_AE(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam);
static BOOL PRPPAGE1_Handle_WB_Mode(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam);
static BOOL PRPPAGE1_Handle_AE_Mode(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam);
static BOOL	PRPPAGE1_Handle_Slider(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam);
static BOOL PRPPAGE1_Handle_AE_Flickerless(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam);
static void PRPPAGE1_EnableControls(
	HWND hDlg,
	BOOL bEnable);
static void PRPPAGE1_Handle_Err_Comm(
	HWND hDlg);
static void PRPPAGE1_Handle_Err_Dev_Chg(
	HWND hDlg);

/*======================== EXPORTED FUNCTIONS =============================*/

/*-------------------------------------------------------------------------*/
HPROPSHEETPAGE PRPPAGE1_CreatePage(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	HINSTANCE hInst)
/*-------------------------------------------------------------------------*/
{
	PROPSHEETPAGE psPage;
	HPROPSHEETPAGE hPage;

	// save device info
	VfWExtInfo.pfnDeviceIoControl = pfnDeviceIoControl;
	VfWExtInfo.lParam = lParam;

	// create page
    psPage.dwSize		= sizeof(psPage);
    psPage.dwFlags		= PSP_USEREFPARENT | PSP_USECALLBACK;
    psPage.hInstance	= hInst;
    psPage.pszTemplate	= MAKEINTRESOURCE(IDD_VCM_NALA1);
	psPage.pszIcon      = NULL;
    psPage.pfnDlgProc	= PRPPAGE1_PageDlgProc;
    psPage.pcRefParent	= 0;
    psPage.pfnCallback	= (LPFNPSPCALLBACK) PRPPAGE1_PageCallback;	
    psPage.lParam		= (LPARAM) &VfWExtInfo;

	hPage = CreatePropertySheetPage(&psPage);

	return hPage;
}


/*======================== LOCAL FUNCTIONS ================================*/

/*-------------------------------------------------------------------------*/
static INT_PTR CALLBACK PRPPAGE1_PageDlgProc(
	HWND	hDlg,
	UINT	uMessage,
	WPARAM	wParam,
	LPARAM	lParam)
/*-------------------------------------------------------------------------*/
{
	switch (uMessage)
	{
		case WM_INITDIALOG:
			SetWindowLongPtr(hDlg,DWLP_USER, (LPARAM) &VfWExtInfo);
			return TRUE;
		case WM_COMMAND:
			return PRPPAGE1_PageDlgProc_DoCommand(hDlg, wParam, lParam);
		case WM_NOTIFY:
			if (((NMHDR FAR *)lParam)->code == PSN_SETACTIVE)
				return PRPPAGE1_ExtSetActive(hDlg, wParam, lParam);	
			break;
		case WM_HSCROLL:
			PRPPAGE1_Handle_Slider(hDlg, wParam, lParam);
			return TRUE;
	}
	return FALSE;	// default processing
}

/*-------------------------------------------------------------------------*/
static UINT _stdcall PRPPAGE1_PageCallback(
   HWND hwnd,
   UINT uMsg,
   LPPROPSHEETPAGE ppsp)
/*-------------------------------------------------------------------------*/
{
	switch(uMsg)
	{
		case PSPCB_CREATE:
			return 1;
		case PSPCB_RELEASE:
			return 0;
	}
	return 0;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE1_ExtSetActive(
	HWND hDlg,
	WPARAM	wParam,
	LPARAM	lParam)
/*-------------------------------------------------------------------------*/
{
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);
	BOOL bResult;

	// Open the device and initialize the controls
	if (PRPCOM_HasDeviceChanged(
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam))
	{
		// Oops, device is not the same anymore
		goto PRPPAGE1_ExtSetActive_Err_Dev_Chg;
	}

	// enable all controls
	PRPPAGE1_EnableControls(hDlg, TRUE);

	// initialize WB
	bResult = PRPPAGE1_Init_WB(hDlg, wParam, lParam);
	if (!bResult)
		goto PRPPAGE1_ExtSetActive_Err_Comm;

	// initialize AE
	bResult &= PRPPAGE1_Init_AE(hDlg, wParam, lParam);
	if (!bResult)
		goto PRPPAGE1_ExtSetActive_Err_Comm;

	// All ok
	bInitialized = TRUE;

	return TRUE;

PRPPAGE1_ExtSetActive_Err_Dev_Chg:

	PRPPAGE1_Handle_Err_Dev_Chg(hDlg);

	return FALSE;

PRPPAGE1_ExtSetActive_Err_Comm:

	PRPPAGE1_Handle_Err_Comm(hDlg);

	return FALSE;

}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE1_PageDlgProc_DoCommand(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam)
/*-------------------------------------------------------------------------*/
{
	BOOL bResult;

	switch(LOWORD(wParam))
	{
		case IDR_WB_MODE_AUTO:
		case IDR_WB_MODE_FIXED:
		case IDR_WB_MODE_MANUAL:
			bResult = PRPPAGE1_Handle_WB_Mode(hDlg, wParam, lParam);
			if (!bResult)
				goto PRPPAGE1_PageDlgProc_DoCommand_Err_Comm;
			break;
		case IDR_AE_MODE_AUTO:
		case IDR_AE_MODE_FIXED:
		case IDR_AE_MODE_MANUAL:
			bResult = PRPPAGE1_Handle_AE_Mode(hDlg, wParam, lParam);
			if (!bResult)
				goto PRPPAGE1_PageDlgProc_DoCommand_Err_Comm;
			break;
		case IDC_AE_FLICKERLESS:
			bResult = PRPPAGE1_Handle_AE_Flickerless(hDlg, wParam, lParam);
			if (!bResult)
				goto PRPPAGE1_PageDlgProc_DoCommand_Err_Comm;
			break;
		default:
			return FALSE; // default processing
	}

	return TRUE;	// message processed

PRPPAGE1_PageDlgProc_DoCommand_Err_Comm:

	PRPPAGE1_Handle_Err_Comm(hDlg);
	
	return TRUE;	// message processed
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE1_Init_WB(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam)
/*-------------------------------------------------------------------------*/
{
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);
	LONG lWB_Mode;
	BOOL bResult, bAuto, bFreeze, bManual;

	// Get white balance mode from camera
	bResult = PRPCOM_Get_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			&lWB_Mode);
	if (!bResult)
		return FALSE;

	// check whitebalance mode
	switch(lWB_Mode)
	{
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_INDOOR:
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_OUTDOOR:
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_TL:
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_AUTO:
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_MANUAL:
			break;
		default:
			return FALSE;
	}

	// switch to freeze mode if indoor, outdoor or tl
	// (these are not supported by the ui)
	if (lWB_Mode != KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_AUTO &&
			lWB_Mode != KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_MANUAL)
	{

		lWB_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_MANUAL;

		// Set new WhiteBalance mode
		bResult = PRPCOM_Set_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			lWB_Mode);
		if (!bResult)
			return FALSE;
	}

	// set radio buttons
	bAuto = lWB_Mode == KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_AUTO;
	if (bInitialized)
	{
		bFreeze = !bAuto && bWB_Freeze;
		bManual = !bAuto && !bWB_Freeze;
	}
	else
	{
		// if not initialized assume fixed mode when not auto
		bFreeze = !bAuto;
		bManual = FALSE;
	}
	bWB_Freeze = bFreeze;

	SendMessage(GetDlgItem(hDlg, IDR_WB_MODE_AUTO),
			BM_SETCHECK, bAuto, 0);
	SendMessage(GetDlgItem(hDlg, IDR_WB_MODE_FIXED),
			BM_SETCHECK, bFreeze, 0);
	SendMessage(GetDlgItem(hDlg, IDR_WB_MODE_MANUAL),
			BM_SETCHECK, bManual, 0);

	// update controls
	bResult = PRPCTRL_Init(hDlg, &WB_Red_Gain_Ctrl, bManual);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Init(hDlg, &WB_Blue_Gain_Ctrl, bManual);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Init(hDlg, &WB_Speed_Ctrl, bAuto);
	if (!bResult)
		return FALSE;

	return TRUE;	
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE1_Init_AE(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam)
/*-------------------------------------------------------------------------*/
{
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);
	LONG lAE_Shutter_Mode, lAE_AGC_Mode;
	BOOL bResult, bAuto, bFreeze, bManual;;

	// Get Shutter Mode from camera
	bResult = PRPCOM_Get_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE,			
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			&lAE_Shutter_Mode);
	if (!bResult)
		return FALSE;

	// check Shutter Mode
	switch(lAE_Shutter_Mode)
	{
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_AUTO:
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_FIXED:
			break;
		default:
			return FALSE;
	}

	// Get AGC Mode from camera
	bResult = PRPCOM_Get_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE,			
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			&lAE_AGC_Mode);
	if (!bResult)
		return FALSE;

	// check AGC Mode
	switch(lAE_AGC_Mode)
	{
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_AUTO:
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_FIXED:
			break;
		default:
			return FALSE;
	}

	// Situation where Shutter Mode = Auto and AGC Mode = Fixed or vice versa
	// not supported. In those cases, switch to fixed
	if (lAE_Shutter_Mode == KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_AUTO &&
			lAE_AGC_Mode == KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_FIXED)
	{
		// Set Shutter Mode to Fixed
		bResult = PRPCOM_Set_Value(
				PROPSETID_PHILIPS_CUSTOM_PROP,
				KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE,
				pVfWExtInfo->pfnDeviceIoControl,
				pVfWExtInfo->lParam,
				KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_FIXED);
		if (!bResult)
			return FALSE;
		lAE_Shutter_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_FIXED;
	}
	else if (lAE_Shutter_Mode == KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_FIXED &&
			lAE_AGC_Mode == KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_AUTO)
	{
		// Set AGC Mode to Fixed
		bResult = PRPCOM_Set_Value(
				PROPSETID_PHILIPS_CUSTOM_PROP,
				KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE,
				pVfWExtInfo->pfnDeviceIoControl,
				pVfWExtInfo->lParam,
				KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_FIXED);
		if (!bResult)
			return FALSE;
		lAE_AGC_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_FIXED;
	}

	// set radio buttons
	bAuto = lAE_Shutter_Mode == KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_AUTO;
	if (bInitialized)
	{
		bFreeze = !bAuto && bAE_Freeze;
		bManual = !bAuto && !bAE_Freeze;
	}
	else
	{
		// if not initialized assume fixed mode when not auto
		bFreeze = !bAuto;
		bManual = FALSE;
	}
	bAE_Freeze = bFreeze;

	SendMessage(GetDlgItem(hDlg, IDR_AE_MODE_AUTO),
			BM_SETCHECK, bAuto, 0);
	SendMessage(GetDlgItem(hDlg, IDR_AE_MODE_FIXED),
			BM_SETCHECK, bFreeze, 0);
	SendMessage(GetDlgItem(hDlg, IDR_AE_MODE_MANUAL),
			BM_SETCHECK, bManual, 0);

	// update controls
	bResult = PRPCTRL_Init(hDlg, &AE_AGC_Ctrl, bManual);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Init(hDlg, &AE_Shutter_Speed_Ctrl, bManual);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Init(hDlg, &AE_Control_Speed_Ctrl, bAuto);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Init(hDlg, &AE_FlickerlessCtrl, bAuto);
	if (!bResult)
		return FALSE;

	return TRUE;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE1_Handle_WB_Mode(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam)
/*-------------------------------------------------------------------------*/
{
	BOOL bResult = TRUE;
	LONG lWB_Mode;
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

	// Only process checked events for these radio buttons
	if (SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) != BST_CHECKED)
		return TRUE;
	
	// get new mode
	switch(LOWORD(wParam))
	{
		case IDR_WB_MODE_AUTO:
			lWB_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_AUTO;
			bWB_Freeze = FALSE;
			break;
		case IDR_WB_MODE_FIXED:
			lWB_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_MANUAL;
			bWB_Freeze = TRUE;
			break;
		case IDR_WB_MODE_MANUAL:
			lWB_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE_MANUAL;
			bWB_Freeze = FALSE;
			break;
		default:
			return FALSE;
	}

	// Set new WhiteBalance mode
	bResult = PRPCOM_Set_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_WB_MODE,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			lWB_Mode);
	if (!bResult)
		return FALSE;

	// update controls
	bResult = PRPCTRL_Enable(hDlg, &WB_Red_Gain_Ctrl,
			LOWORD(wParam) == IDR_WB_MODE_MANUAL);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Enable(hDlg, &WB_Blue_Gain_Ctrl,
			LOWORD(wParam) == IDR_WB_MODE_MANUAL);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Enable(hDlg, &WB_Speed_Ctrl,
			LOWORD(wParam) == IDR_WB_MODE_AUTO);
	if (!bResult)
		return FALSE;

	return TRUE;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE1_Handle_AE_Mode(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam)
/*-------------------------------------------------------------------------*/
{
	BOOL bResult = TRUE;
	LONG lAE_Shutter_Mode, lAE_AGC_Mode, lAE_Shutter_Speed;
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

	// Only process checked events for these radio buttons
	if (SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) != BST_CHECKED)
		return TRUE;
	
	// get new mode
	switch(LOWORD(wParam))
	{
		case IDR_AE_MODE_AUTO:
			lAE_Shutter_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_AUTO;
			lAE_AGC_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_AUTO;
			bAE_Freeze = FALSE;
			break;
		case IDR_AE_MODE_FIXED:
			lAE_Shutter_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_FIXED;
			lAE_AGC_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_FIXED;
			bAE_Freeze = TRUE;
			break;
		case IDR_AE_MODE_MANUAL:
			lAE_Shutter_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_FIXED;
			lAE_AGC_Mode = KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE_FIXED;
			bAE_Freeze = FALSE;
			break;
		default:
			return FALSE;
	}

	// Set new shutter mode
	bResult = PRPCOM_Set_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			lAE_Shutter_Mode);
	if (!bResult)
		return FALSE;

	// Set new AGC Mode
	bResult = PRPCOM_Set_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_AGC_MODE,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			lAE_AGC_Mode);
	if (!bResult)
		return FALSE;

	// pitfall for shutter speed: if switched to manual
	// we must set the value to one of the 11 discrete
	// values available
	if (LOWORD(wParam) == IDR_AE_MODE_MANUAL)
	{
		// Get shutterspeed
		bResult = PRPCOM_Get_Value(
				PROPSETID_PHILIPS_CUSTOM_PROP,
				KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED,
				pVfWExtInfo->pfnDeviceIoControl,
				pVfWExtInfo->lParam,
				&lAE_Shutter_Speed);
		if (!bResult)
			return FALSE;

		// Set shutterspeed
		bResult = PRPCOM_Set_Value(
				PROPSETID_PHILIPS_CUSTOM_PROP,
				KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED,
				pVfWExtInfo->pfnDeviceIoControl,
				pVfWExtInfo->lParam,
				lAE_Shutter_Speed);
		if (!bResult)
			return FALSE;
	}

	// update controls
	bResult = PRPCTRL_Enable(hDlg, &AE_AGC_Ctrl,
			LOWORD(wParam) == IDR_AE_MODE_MANUAL);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Enable(hDlg, &AE_Shutter_Speed_Ctrl,
			LOWORD(wParam) == IDR_AE_MODE_MANUAL);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Enable(hDlg, &AE_Control_Speed_Ctrl,
			LOWORD(wParam) == IDR_AE_MODE_AUTO);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Enable(hDlg, &AE_FlickerlessCtrl,
			LOWORD(wParam) == IDR_AE_MODE_AUTO);
	if (!bResult)
		return FALSE;

	return TRUE;
}

/*-------------------------------------------------------------------------*/
static BOOL	PRPPAGE1_Handle_Slider(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam)
/*-------------------------------------------------------------------------*/
{
	PRPCTRL_INFO *pCtrl;
	WORD Ctrl;
	BOOL bResult = TRUE;

	// only process when scrolling is done
	if (LOWORD(wParam) != SB_ENDSCROLL && LOWORD(wParam) != SB_THUMBTRACK)
		return TRUE;

	// get control id
	Ctrl = (WORD)GetWindowLong((HWND)lParam, GWL_ID);

	// get control object
	switch(Ctrl)
	{
		case IDS_WB_RED_GAIN:
			pCtrl = &WB_Red_Gain_Ctrl;
			break;
		case IDS_WB_BLUE_GAIN:
			pCtrl = &WB_Blue_Gain_Ctrl;
			break;
		case IDS_WB_SPEED:
			pCtrl = &WB_Speed_Ctrl;
			break;
		case IDS_AE_CONTROL_SPEED:
			pCtrl = &AE_Control_Speed_Ctrl;
			break;
		case IDS_AE_SHUTTER_SPEED:
			pCtrl = &AE_Shutter_Speed_Ctrl;
			break;
		case IDS_AE_AGC:
			pCtrl = &AE_AGC_Ctrl;
			break;
		default:
			return FALSE;
	}								

	// process the message
	bResult = PRPCTRL_Handle_Msg(hDlg, pCtrl);
	if (!bResult)
		goto PRPPAGE1_Handle_Slider_Err_Comm;

	return TRUE;

PRPPAGE1_Handle_Slider_Err_Comm:

	PRPPAGE1_Handle_Err_Comm(hDlg);
	
	return TRUE;	// message processed
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE1_Handle_AE_Flickerless(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam)
/*-------------------------------------------------------------------------*/
{
	PRPCTRL_INFO *pCtrl;
	BOOL bResult;

	// get control object
	pCtrl = &AE_FlickerlessCtrl;

	// process the message
	bResult = PRPCTRL_Handle_Msg(hDlg, pCtrl);
	if (!bResult)
		return FALSE;

	return TRUE;
}

/*-------------------------------------------------------------------------*/
static void PRPPAGE1_EnableControls(
	HWND hDlg,
	BOOL bEnable)
/*-------------------------------------------------------------------------*/
{
	static WORD Controls[] =
	{
		IDR_WB_MODE_AUTO,		IDR_WB_MODE_FIXED,	
		IDR_WB_MODE_MANUAL,		IDR_AE_MODE_AUTO,
		IDR_AE_MODE_FIXED,		IDR_AE_MODE_MANUAL,

		IDS_WB_SPEED,			IDS_WB_RED_GAIN,	
		IDS_WB_BLUE_GAIN,		IDS_AE_AGC,		
		IDS_AE_SHUTTER_SPEED,	IDS_AE_CONTROL_SPEED,

		IDE_WB_SPEED,			IDE_WB_RED_GAIN,	
		IDE_WB_BLUE_GAIN,		IDE_AE_AGC,		
		IDE_AE_SHUTTER_SPEED,	IDE_AE_CONTROL_SPEED,

		IDC_AE_FLICKERLESS,

		IDT_WB_MODE,			IDT_WB_SPEED,		
		IDT_WB_RED_GAIN,		IDT_WB_BLUE_GAIN,
		IDT_WB,					IDT_AE_MODE,		
		IDT_AE_AGC,		IDT_AE_SHUTTER_SPEED,
		IDT_AE,					IDT_AE_CONTROL_SPEED,

		0
	};
	int i = 0;

	while(Controls[i] != 0)
		EnableWindow(GetDlgItem(hDlg, Controls[i++]), bEnable);
}

/*-------------------------------------------------------------------------*/
static void PRPPAGE1_Handle_Err_Comm(
	HWND hDlg)
/*-------------------------------------------------------------------------*/
{
	char Msg_Err_Comm[132] = "";

	// disable everything
	PRPPAGE1_EnableControls(hDlg, FALSE);

	// load the message text from resource
	LoadString(hInst, IDS_MSG_ERR_COMM, Msg_Err_Comm, 132);

	// notify the user
	MessageBox(hDlg, Msg_Err_Comm,"Error", MB_OK | MB_ICONERROR);
}

/*-------------------------------------------------------------------------*/
static void PRPPAGE1_Handle_Err_Dev_Chg(
	HWND hDlg)
/*-------------------------------------------------------------------------*/
{
	char Msg_Err_Dev_Chg[132] = "";

	// disable everything
	PRPPAGE1_EnableControls(hDlg, FALSE);

	// load the message text from resource
	LoadString(hInst, IDS_MSG_ERR_DEV_CHG, Msg_Err_Dev_Chg, 132);

	// notify the user
	MessageBox(hDlg, Msg_Err_Dev_Chg,"Warning", MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by phvcmext.rc
//
#define IDS_MSG_ERR_DEV_CHG             1
#define IDS_MSG_ERR_COMM                2
#define IDD_VCM_NALA2                   107
#define IDD_VCM_NALA1                   109
#define IDD_VCM_NALA2_OLD               110
#define IDE_BRIGHTNESS                  1012
#define IDE_CONTRAST                    1013
#define IDE_GAMMA                       1014
#define IDE_WB_SPEED                    1015
#define IDS_WB_SPEED                    1016
#define IDE_WB_RED_GAIN                 1017
#define IDS_WB_RED_GAIN                 1018
#define IDE_WB_BLUE_GAIN                1019
#define IDS_WB_BLUE_GAIN                1020
#define IDS_BRIGHTNESS                  1021
#define IDC_COLORENABLE                 1022
#define IDC_BACKLIGHTCOMPENSATION       1023
#define IDS_CONTRAST                    1024
#define IDS_GAMMA                       1025
#define IDB_RESTORE_UD                  1058
#define IDB_RESTORE_FD                  1059
#define IDB_SAVE_UD                     1060
#define IDR_WB_MODE_AUTO                1063
#define IDR_WB_MODE_MANUAL              1065
#define IDT_WB_SPEED                    1069
#define IDT_WB_RED_GAIN                 1070
#define IDT_WB_BLUE_GAIN                1071
#define IDC_FRAMERATE                   1146
#define IDR_AE_MODE_AUTO                1158
#define IDR_AE_MODE_FIXED               1160
#define IDR_AE_MODE_MANUAL              1161
#define IDR_WB_MODE_FIXED               1162
#define IDT_WB_MODE                     1163
#define IDT_AE_CONTROL_SPEED            1164
#define IDT_AE_SHUTTER_SPEED            1165
#define IDS_AE_CONTROL_SPEED            1166
#define IDS_AE_SHUTTER_SPEED            1167
#define IDS_AE_AGC                      1168
#define IDC_AE_FLICKERLESS              1169
#define IDE_AE_CONTROL_SPEED            1170
#define IDE_AE_SHUTTER_SPEED            1171
#define IDT_WB                          1172
#define IDT_AE                          1173
#define IDT_AE_MODE                     1174
#define IDE_AE_AGC                      1175
#define IDT_AE_AGC                      1176
#define IDT_FRAMERATE                   1178
#define IDT_IMAGECONTROLS               1179
#define IDT_BRIGHTNESS                  1180
#define IDT_CONTRAST                    1181
#define IDT_GAMMA                       1182
#define IDT_DEFAULTS                    1183
#define IDT_UD                          1184
#define IDT_FD                          1185
#define IDC_BACKLIGHT_COMPENSATION      1186
#define IDR_FRAMERATE_B0                1188
#define IDR_FRAMERATE_B1                1189
#define IDR_FRAMERATE_B2                1190
#define IDR_FRAMERATE_B3                1191
#define IDR_FRAMERATE_B4                1192
#define IDR_FRAMERATE_B5                1193
#define IDR_FRAMERATE_B6                1194
#define IDR_FRAMERATE_B7                1195
#define IDR_FRAMERATE_MR_375            1196
#define IDR_FRAMERATE_MR_5              1197
#define IDR_FRAMERATE_MR_75             1198
#define IDR_FRAMERATE_MR_10             1199
#define IDR_FRAMERATE_MR_12             1200
#define IDR_FRAMERATE_MR_15             1201
#define IDR_FRAMERATE_MR_20             1202
#define IDR_FRAMERATE_MR_24             1203
#define IDR_FRAMERATE_VGA_375           1205
#define IDR_FRAMERATE_VGA_5             1206
#define IDR_FRAMERATE_VGA_75            1207
#define IDR_FRAMERATE_VGA_10            1208
#define IDR_FRAMERATE_VGA_15            1209
#define IDR_FRAMERATE_VGA_20            1210
#define IDR_FRAMERATE_VGA_24            1211

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        123
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1204
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\prppage1.h ===
/*
 * Copyright (c) 1996 1997, 1998 Philips CE I&C
 *
 * FILE			PRPPAGE1.H
 * DATE			7-1-97
 * VERSION		1.00
 * AUTHOR		M.J. Verberne
 * DESCRIPTION	Implements the first property page
 * HISTORY		
 */

#ifndef _PRPPAGE1_
#define _PRPPAGE1_

#include "phvcmext.h"

/*======================== EXPORTED FUNCTIONS =============================*/
HPROPSHEETPAGE PRPPAGE1_CreatePage(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	HINSTANCE hInst);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\usbcamd\intbulk.c ===
/*++


Module Name:

    IntBulk.c

Abstract:
        
    this module handle all interfaces to bulk & interrupt pipes 
    and performs read and write operations on these pipes.

Author:

    3/9/98 Husni Roukbi

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998  Microsoft Corporation

Revision History:

--*/

#include "usbcamd.h"


VOID
USBCAMD_RecycleIrp(
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN PIRP Irp,
    IN PURB Urb,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
    )
/*++

Routine Description:

    Get the current USB frame number.

Arguments:

    TransferExtension - context information for this transfer (pair of iso 
        urbs).

    Irp - Irp to recycle.

    Urb - Urb associated with this irp.

Return Value:

    None.

--*/    
{
    PIO_STACK_LOCATION nextStack;
    
    nextStack = IoGetNextIrpStackLocation(Irp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = Urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
        IOCTL_INTERNAL_USB_SUBMIT_URB;                    
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

#pragma warning(disable:4127)
    IoSetCompletionRoutine(Irp,
            CompletionRoutine,
            TransferExtension,
            TRUE,
            TRUE,
            TRUE);
#pragma warning(default:4127)            

}   


/*++

Routine Description:

    This routine performs a read or write operation on a specified 
    bulk pipe. 

Arguments:

    DeviceContext - 

    PipeIndex - 

    Buffer - 

    BufferLength - 

    CommandComplete -

    CommandContext -


Return Value:

    NT status code

--*/

NTSTATUS
USBCAMD_BulkReadWrite( 
    IN PVOID DeviceContext,
    IN USHORT PipeIndex,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PCOMMAND_COMPLETE_FUNCTION CommandComplete,
    IN PVOID CommandContext
    )
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
   
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    PUSBD_PIPE_INFORMATION pipeHandle ;
    PEVENTWAIT_WORKITEM workitem;
    PLIST_ENTRY listEntry =NULL;
    ULONG i;

    deviceExtension = USBCAMD_GET_DEVICE_EXTENSION(DeviceContext);


    USBCAMD_KdPrint ( MAX_TRACE, ("Enter USBCAMD_BulkReadWrite\n"));


    //
    // check if port is still connected.
    //
    if (deviceExtension ->CameraUnplugged ) {
        USBCAMD_KdPrint(MIN_TRACE,("Bulk Read/Write request after device removed!\n"));
        ntStatus = STATUS_FILE_CLOSED;        
        return ntStatus;        
    }
  
    //
    // do some parameter validation.
    //

    if (PipeIndex > deviceExtension->Interface->NumberOfPipes) {
        
        USBCAMD_KdPrint(MIN_TRACE,("BulkReadWrite invalid pipe index!\n"));
        ntStatus = STATUS_INVALID_PARAMETER;        
        return ntStatus;        
    }

    // check if we have a pending read or write already. 
    // we only accept one read and one write at atime.

    if (USBCAMD_OutstandingIrp(deviceExtension, PipeIndex) ) {
        USBCAMD_KdPrint(MIN_TRACE,("Bulk Read/Write Ovelapping request !\n"));
        ntStatus = STATUS_INVALID_PARAMETER;        
        return ntStatus;            
    }
    
    
    pipeHandle = &deviceExtension->Interface->Pipes[PipeIndex];

    if (pipeHandle->PipeType != UsbdPipeTypeBulk ) {
     
        USBCAMD_KdPrint(MIN_TRACE,("BulkReadWrite invalid pipe type!\n"));
        ntStatus = STATUS_INVALID_PARAMETER;        
        return ntStatus;        
    }

    if ( Buffer == NULL ) {
        USBCAMD_KdPrint(MIN_TRACE,("BulkReadWrite NULL buffer pointer!\n"));
        ntStatus = STATUS_INVALID_PARAMETER;        
        return ntStatus;        
    }

    
    //  
    // call the transfer function
    //

    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        //
        // we are at passive level, just do the command
        //
        ntStatus = USBCAMD_IntOrBulkTransfer(deviceExtension,
                                             NULL,
                                             Buffer,
                                             BufferLength,
                                             PipeIndex,
                                             CommandComplete,
                                             CommandContext,
                                             0,
                                             BULK_TRANSFER);        
        if (ntStatus != STATUS_SUCCESS) {
            USBCAMD_KdPrint(MIN_TRACE,("USBCAMD_BulkReadWrite: USBCAMD_IntOrBulkTransfer()=0x%x!\n", ntStatus));
        }

    } else {

//        TEST_TRAP();
        //
        // schedule a work item
        //
        ntStatus = STATUS_PENDING;

        workitem = USBCAMD_ExAllocatePool(NonPagedPool,
                                          sizeof(EVENTWAIT_WORKITEM));
        if (workitem) {
        
            ExInitializeWorkItem(&workitem->WorkItem,
                                 USBCAMD_EventWaitWorkItem,
                                 workitem);

            workitem->DeviceExtension = deviceExtension;
            workitem->ChannelExtension = NULL;
            workitem->PipeIndex = PipeIndex;
            workitem->Buffer = Buffer;
            workitem->BufferLength = BufferLength;
            workitem->EventComplete = CommandComplete;
            workitem->EventContext = CommandContext;
            workitem->LoopBack = 0;
            workitem->TransferType = BULK_TRANSFER;

            ExQueueWorkItem(&workitem->WorkItem,
                            DelayedWorkQueue);
   
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBCAMD_KdPrint(MIN_TRACE,("USBCAMD_BulkReadWrite: USBCAMD_ExAllocatePool(%d) failed!\n", sizeof(EVENTWAIT_WORKITEM)));
        }
    }
    
    return ntStatus;
}

/*++

Routine Description:

    This routine performs a read from an interrupt pipe. 

Arguments:

    DeviceContext - 

    PipeIndex - 

    Buffer - 

    BufferLength - 

    EventComplete -

    EventContext -


Return Value:

    NT status code

--*/

NTSTATUS
USBCAMD_WaitOnDeviceEvent( 
    IN PVOID DeviceContext,
    IN ULONG PipeIndex,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PCOMMAND_COMPLETE_FUNCTION   EventComplete,
    IN PVOID EventContext,
    IN BOOLEAN LoopBack
    )
{
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_PIPE_INFORMATION pipeHandle ;
    PEVENTWAIT_WORKITEM workitem;

    deviceExtension = USBCAMD_GET_DEVICE_EXTENSION(DeviceContext);


    USBCAMD_KdPrint ( MIN_TRACE, ("Enter USBCAMD_WaitOnDeviceEvent\n"));
   
    //
    // check if port is still connected.
    //

    if (deviceExtension->CameraUnplugged ) {
        USBCAMD_KdPrint(MIN_TRACE,("WaitOnDeviceEvent after device removed!\n"));
        ntStatus = STATUS_FILE_CLOSED;        
        return ntStatus;        
    }

    //
    // do some parameter validation.
    //

    if (PipeIndex > deviceExtension->Interface->NumberOfPipes) {
        
        USBCAMD_KdPrint(MIN_TRACE,("WaitOnDeviceEvent invalid pipe index!\n"));
        ntStatus = STATUS_INVALID_PARAMETER;        
        return ntStatus;        
    }
    
    // check if we have a pending interrupt request already. 
    // we only accept one interrupt request at atime.

    if (USBCAMD_OutstandingIrp(deviceExtension, PipeIndex) ) {
        USBCAMD_KdPrint(MIN_TRACE,("Ovelapping Interrupt request !\n"));
        ntStatus = STATUS_INVALID_PARAMETER;        
        return ntStatus;            
    }
   
    pipeHandle = &deviceExtension->Interface->Pipes[PipeIndex];

    if (pipeHandle->PipeType != UsbdPipeTypeInterrupt ) {
     
        USBCAMD_KdPrint(MIN_TRACE,("WaitOnDeviceEvent invalid pipe type!\n"));
        ntStatus = STATUS_INVALID_PARAMETER;        
        return ntStatus;        
    }

    if ( Buffer == NULL ) {
        USBCAMD_KdPrint(MIN_TRACE,("WaitOnDeviceEvent NULL buffer pointer!\n"));
        ntStatus = STATUS_INVALID_PARAMETER;        
        return ntStatus;        
    }

    if ( BufferLength < (ULONG) pipeHandle->MaximumPacketSize ) {
        USBCAMD_KdPrint(MIN_TRACE,("WaitOnDeviceEvent buffer is smaller than max. pkt size!\n"));
        ntStatus = STATUS_INVALID_PARAMETER;        
        return ntStatus;        
    }
   
    //  
    // call the transfer function
    //

    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        //
        // we are at passive level, just do the command
        //
        ntStatus = USBCAMD_IntOrBulkTransfer(deviceExtension,
                                             NULL,
                                             Buffer,
                                             BufferLength,
                                             PipeIndex,
                                             EventComplete,
                                             EventContext,
                                             LoopBack,
                                             INTERRUPT_TRANSFER);        
        if (ntStatus != STATUS_SUCCESS) {
            USBCAMD_KdPrint(MIN_TRACE,("USBCAMD_WaitOnDeviceEvent: USBCAMD_IntOrBulkTransfer()=0x%x!\n", ntStatus));
        }
    } else {

        //
        // schedule a work item
        //
        ntStatus = STATUS_PENDING;

        workitem = USBCAMD_ExAllocatePool(NonPagedPool,sizeof(EVENTWAIT_WORKITEM));
        if (workitem) {
        
            ExInitializeWorkItem(&workitem->WorkItem,
                                 USBCAMD_EventWaitWorkItem,
                                 workitem);

            workitem->DeviceExtension = deviceExtension;
            workitem->ChannelExtension = NULL;
            workitem->PipeIndex = PipeIndex;
            workitem->Buffer = Buffer;
            workitem->BufferLength = BufferLength;
            workitem->EventComplete = EventComplete;
            workitem->EventContext = EventContext; 
            workitem->LoopBack = LoopBack;
            workitem->TransferType = INTERRUPT_TRANSFER;

            ExQueueWorkItem(&workitem->WorkItem,DelayedWorkQueue);
   
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBCAMD_KdPrint(MIN_TRACE,("USBCAMD_WaitOnDeviceEvent: USBCAMD_ExAllocatePool(%d) failed!\n", sizeof(EVENTWAIT_WORKITEM)));
        }
    }

    return ntStatus;
}

/*++

Routine Description:


Arguments:

Return Value:

    None.

--*/
VOID
USBCAMD_EventWaitWorkItem(
    PVOID Context
    )
{
    NTSTATUS ntStatus;
    PEVENTWAIT_WORKITEM workItem = Context;
    ntStatus = USBCAMD_IntOrBulkTransfer(workItem->DeviceExtension,
                                         workItem->ChannelExtension,
                                         workItem->Buffer,
                                         workItem->BufferLength,
                                         workItem->PipeIndex,
                                         workItem->EventComplete,
                                         workItem->EventContext,
                                         workItem->LoopBack,
                                         workItem->TransferType);
    USBCAMD_ExFreePool(workItem);
}


/*++

Routine Description:

Arguments:

Return Value:
    NT Status - STATUS_SUCCESS

--*/

NTSTATUS
USBCAMD_IntOrBulkTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PVOID    pBuffer,        
    IN ULONG    TransferSize,
    IN ULONG    PipeIndex,
    IN PCOMMAND_COMPLETE_FUNCTION commandComplete,
    IN PVOID    commandContext,
    IN BOOLEAN  LoopBack,
    IN UCHAR    TransferType
)
{
    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PUSBCAMD_TRANSFER_EXTENSION pTransferContext;
    ULONG                       siz = 0;
    ULONG                       MaxPacketSize;
    ULONG                       MaxTransferSize;
    PUSBCAMD_PIPE_PIN_RELATIONS PipePinRelations;
    KIRQL                       Irql;

    USBCAMD_KdPrint(MAX_TRACE,("Bulk transfer called. size = %d, pBuffer = 0x%X\n",
                                TransferSize, pBuffer));

    PipePinRelations = &DeviceExtension->PipePinRelations[PipeIndex];

    MaxTransferSize = DeviceExtension->Interface->Pipes[PipeIndex].MaximumTransferSize;
    MaxPacketSize   = DeviceExtension->Interface->Pipes[PipeIndex].MaximumPacketSize;

    if ( TransferSize > MaxTransferSize) {
        USBCAMD_KdPrint(MIN_TRACE,("Bulk Transfer > Max transfer size.\n"));
    }

    //
    // Allocate and initialize Transfer Context
    //
    
    if ( ChannelExtension == NULL ) {

        pTransferContext = USBCAMD_ExAllocatePool(NonPagedPool, sizeof(USBCAMD_TRANSFER_EXTENSION));

        if (pTransferContext) {
            RtlZeroMemory(pTransferContext, sizeof(USBCAMD_TRANSFER_EXTENSION));  
            ntStatus = USBCAMD_InitializeBulkTransfer(DeviceExtension,
                                                  ChannelExtension,
                                                  DeviceExtension->Interface,
                                                  pTransferContext,
                                                  PipeIndex);
            if (ntStatus != STATUS_SUCCESS) {
                USBCAMD_ExFreePool(pTransferContext);
                USBCAMD_KdPrint(MIN_TRACE,("USBCAMD_IntOrBulkTransfer: USBCAMD_InitializeBulkTransfer()=0x%x\n",ntStatus));
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                return ntStatus;
            }     
        }
        else {
            USBCAMD_KdPrint(MIN_TRACE,("USBCAMD_IntOrBulkTransfer: USBCAMD_ExAllocatePool(%d) failed.  cannot allocate Transfer Context\n", sizeof(USBCAMD_TRANSFER_EXTENSION)));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            return ntStatus;
        }
        
    }
    else {
        pTransferContext = &ChannelExtension->TransferExtension[ChannelExtension->CurrentBulkTransferIndex];
    }
    
    ASSERT(pTransferContext);

    pTransferContext->BulkContext.fDestinedForReadBuffer = FALSE;
    pTransferContext->BulkContext.RemainingTransferLength = TransferSize;
    pTransferContext->BulkContext.ChunkSize = TransferSize;
    pTransferContext->BulkContext.PipeIndex = PipeIndex;
    pTransferContext->BulkContext.pTransferBuffer = pBuffer;
    pTransferContext->BulkContext.pOriginalTransferBuffer = pBuffer;
    pTransferContext->BulkContext.CommandCompleteCallback = commandComplete;
    pTransferContext->BulkContext.CommandCompleteContext = commandContext;
    pTransferContext->BulkContext.LoopBack = LoopBack;
    pTransferContext->BulkContext.TransferType = TransferType;
    pTransferContext->BulkContext.NBytesTransferred = 0;

   
    //
    // If chunksize is bigger than MaxTransferSize, then set it to MaxTransferSize.  The
    // transfer completion routine will issue additional transfers until the total size has
    // been transferred.
    // 

    if (pTransferContext->BulkContext.ChunkSize > MaxTransferSize) {
        pTransferContext->BulkContext.ChunkSize = MaxTransferSize;
    }

    if  (PipePinRelations->PipeDirection == INPUT_PIPE) {

        //
        // If this read is smaller than a USB packet, then issue a request for a 
        // whole usb packet and make sure it goes into the read buffer first.
        //

        if (pTransferContext->BulkContext.ChunkSize < MaxPacketSize) {
            USBCAMD_KdPrint(MAX_TRACE,("Request is < packet size - transferring whole packet into read buffer.\n"));
            pTransferContext->BulkContext.fDestinedForReadBuffer = TRUE;
            pTransferContext->BulkContext.pOriginalTransferBuffer = 
                pTransferContext->BulkContext.pTransferBuffer;  // save off original transfer ptr.
            pTransferContext->BulkContext.pTransferBuffer = pTransferContext->WorkBuffer =
                    USBCAMD_ExAllocatePool(NonPagedPool,MaxPacketSize); 
            if (pTransferContext->WorkBuffer == NULL ) {
                if (ChannelExtension == NULL) {
                    USBCAMD_FreeBulkTransfer(pTransferContext);
                    USBCAMD_ExFreePool(pTransferContext);
                }
                USBCAMD_KdPrint(MIN_TRACE,("USBCAMD_IntOrBulkTransfer: USBCAMD_ExAllocatePool(%d) failed\n", MaxPacketSize));
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                return ntStatus;
            }
            pTransferContext->BulkContext.ChunkSize = MaxPacketSize;
        }
        else {
            //
            // Truncate the size of the read to an integer number of packets.  If necessary, 
            // the completion routine will handle any fractional remaining packets (with the read buffer).
            //         
            pTransferContext->BulkContext.ChunkSize = (pTransferContext->BulkContext.ChunkSize 
                                                            / MaxPacketSize) * MaxPacketSize;
        }
    }

    ASSERT(pTransferContext->BulkContext.RemainingTransferLength);
    ASSERT(pTransferContext->BulkContext.pTransferBuffer);    
    ASSERT(pTransferContext->DataUrb);

    //
    // Initialize URB
    //

    UsbBuildInterruptOrBulkTransferRequest(pTransferContext->DataUrb,
                                           sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                                           DeviceExtension->Interface->Pipes[PipeIndex].PipeHandle,
                                           pTransferContext->BulkContext.pTransferBuffer,
                                           NULL,
                                           pTransferContext->BulkContext.ChunkSize,
                                           USBD_SHORT_TRANSFER_OK,
                                           NULL);

    KeAcquireSpinLock(&PipePinRelations->OutstandingIrpSpinlock, &Irql);

    //
    // Build the data request
    //
    ASSERT(pTransferContext->DataIrp == NULL);
    if (ChannelExtension) {
        ntStatus = USBCAMD_AcquireIdleLock(&ChannelExtension->IdleLock);
    }

    if (STATUS_SUCCESS == ntStatus) {

        pTransferContext->DataIrp = USBCAMD_BuildIoRequest(
            DeviceExtension,
            pTransferContext,
            pTransferContext->DataUrb,
            USBCAMD_BulkTransferComplete
            );
        if (pTransferContext->DataIrp == NULL) {

            USBCAMD_KdPrint(MIN_TRACE,("USBCAMD_IntOrBulkTransfer: USBCAMD_BuildIoRequest failed\n"));
            if (ChannelExtension == NULL) {
                USBCAMD_FreeBulkTransfer(pTransferContext);
                USBCAMD_ExFreePool(pTransferContext);
            }
            else {
                USBCAMD_ReleaseIdleLock(&ChannelExtension->IdleLock);
            }
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else {

            InsertTailList(&PipePinRelations->IrpPendingQueue, &pTransferContext->ListEntry);
        }
    }

    KeReleaseSpinLock(&PipePinRelations->OutstandingIrpSpinlock, Irql);

    if (pTransferContext->DataIrp) {

        ntStatus = IoCallDriver(DeviceExtension->StackDeviceObject, pTransferContext->DataIrp);

        //
        // Note the completion routine will handle cleanup
        //

        if (STATUS_PENDING == ntStatus) {
            ntStatus = STATUS_SUCCESS;
        }
    }

    USBCAMD_KdPrint(MAX_TRACE,("USBCAMD_IntOrBulkTransfer exit (0x%X).\n", ntStatus));
        
    return ntStatus;
}

/*++

Routine Description:

Arguments:
    DeviceExtension    - Pointer to Device Extension.
    PipeIndex       - Pipe index.

Return Value:
    NT Status - STATUS_SUCCESS
    
--*/

PUSBCAMD_TRANSFER_EXTENSION
USBCAMD_DequeueFirstIrp(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN ULONG    PipeIndex,
    IN PLIST_ENTRY pListHead)
{

    KIRQL Irql;
    PLIST_ENTRY pListEntry;
    PUSBCAMD_TRANSFER_EXTENSION pTransExt ;

    KeAcquireSpinLock(&DeviceExtension->PipePinRelations[PipeIndex].OutstandingIrpSpinlock, &Irql);

    if ( IsListEmpty(pListHead)) 
        pTransExt = NULL;
    else {
        pListEntry = RemoveHeadList(pListHead); 
        pTransExt = (PUSBCAMD_TRANSFER_EXTENSION) CONTAINING_RECORD(pListEntry, 
                                USBCAMD_TRANSFER_EXTENSION, ListEntry);   
        ASSERT_TRANSFER(pTransExt);
    }
   
    KeReleaseSpinLock(&DeviceExtension->PipePinRelations[PipeIndex].OutstandingIrpSpinlock, Irql);
    return pTransExt;
}    


/*++

Routine Description:

Arguments:
    DeviceExtension    - Pointer to Device Extension.
    PipeIndex       - Pipe index.

Return Value:
    NT Status - STATUS_SUCCESS
    
--*/

BOOLEAN
USBCAMD_OutstandingIrp(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN ULONG    PipeIndex)
{

    KIRQL Irql;
    BOOLEAN Pending = FALSE;
    PLIST_ENTRY pListHead; 

    KeAcquireSpinLock(&DeviceExtension->PipePinRelations[PipeIndex].OutstandingIrpSpinlock, &Irql);

    pListHead = &DeviceExtension->PipePinRelations[PipeIndex].IrpPendingQueue;
    Pending = IsListEmpty(pListHead);

    KeReleaseSpinLock(&DeviceExtension->PipePinRelations[PipeIndex].OutstandingIrpSpinlock, Irql);

    return (!Pending);
}    

NTSTATUS
USBCAMD_BulkTransferComplete(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
)
/*++

Routine Description:

Arguments:
    pDeviceObject    - Device object for a device.
    pIrp             - Read/write request packet
    pTransferContext - context info for transfer

Return Value:
    NT Status - STATUS_SUCCESS
    
--*/
{
    PURB                        pUrb;
    ULONG                       CompletedTransferLength;
    NTSTATUS                    CompletedTransferStatus;
    ULONG                       MaxPacketSize,PipeIndex;
    PUSBCAMD_TRANSFER_EXTENSION pTransferContext, pQueTransfer;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN                     fShortTransfer = FALSE;
    PLIST_ENTRY listEntry;
    PUSBCAMD_PIPE_PIN_RELATIONS PipePinRelations;
    KIRQL Irql;

    USBCAMD_KdPrint (ULTRA_TRACE, ("enter USBCAMD_BulkTransferComplete \n"));
   
    pTransferContext = Context;
    ASSERT_TRANSFER(pTransferContext);
    channelExtension = pTransferContext->ChannelExtension;
    deviceExtension = pTransferContext->DeviceExtension;
    PipeIndex = pTransferContext->BulkContext.PipeIndex;
    PipePinRelations = &deviceExtension->PipePinRelations[PipeIndex];

    KeAcquireSpinLock(&PipePinRelations->OutstandingIrpSpinlock, &Irql);

    ASSERT(pIrp == pTransferContext->DataIrp);
    pTransferContext->DataIrp = NULL;

    if (pIrp->Cancel) {

        // The IRP has been cancelled
        KeReleaseSpinLock(&PipePinRelations->OutstandingIrpSpinlock, Irql);

        IoFreeIrp(pIrp);

        // 
        // signal the cancel event
        //
        KeSetEvent(&pTransferContext->BulkContext.CancelEvent,1,FALSE);

        USBCAMD_KdPrint(MIN_TRACE,("**** Bulk transfer Irp Cancelled.\n"));

        // return w/o freeing transfercontext. We will use later when we resubmit
        // the transfer again to USBD.

        if (channelExtension) {
            USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
        }

        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    // The IRP hasn't been cancelled, so the context should be intact
    // Get this context out of the list, and mark it as such
    RemoveEntryList(&pTransferContext->ListEntry);
    InitializeListHead(&pTransferContext->ListEntry);

    if (channelExtension && (channelExtension->Flags & USBCAMD_STOP_STREAM)) {

        KeReleaseSpinLock(&PipePinRelations->OutstandingIrpSpinlock, Irql);

        IoFreeIrp(pIrp);

        USBCAMD_KdPrint(MIN_TRACE,("USBCAMD_BulkTransferComplete: Transfer completed after STOP.\n"));

        USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (!NT_SUCCESS(pIrp->IoStatus.Status)) {

        ntStatus = pIrp->IoStatus.Status;

        KeReleaseSpinLock(&PipePinRelations->OutstandingIrpSpinlock, Irql);

        IoFreeIrp(pIrp);

        USBCAMD_KdPrint(MIN_TRACE,("Int/Bulk transfer error. IO status = 0x%X\n", ntStatus));

        if ( channelExtension == NULL ) {
            USBCAMD_FreeBulkTransfer(pTransferContext);
            USBCAMD_ExFreePool(pTransferContext);
        }
        else {
            USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
            USBCAMD_ProcessResetRequest(deviceExtension,channelExtension); 
        }

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    pUrb = pTransferContext->DataUrb;
    CompletedTransferLength = pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;
    CompletedTransferStatus = pUrb->UrbBulkOrInterruptTransfer.Hdr.Status;

    if (STATUS_SUCCESS != CompletedTransferStatus) {

        KeReleaseSpinLock(&PipePinRelations->OutstandingIrpSpinlock, Irql);

        IoFreeIrp(pIrp);

        USBCAMD_KdPrint(MIN_TRACE,("Int/Bulk transfer error. USB status = 0x%X\n",CompletedTransferStatus));

        if ( channelExtension == NULL ) {
            USBCAMD_FreeBulkTransfer(pTransferContext);
            USBCAMD_ExFreePool(pTransferContext);
        }
        else {
            USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
            USBCAMD_ProcessResetRequest(deviceExtension,channelExtension); 
        }

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    MaxPacketSize =  deviceExtension->Interface->Pipes[PipeIndex].MaximumPacketSize;    

    if (CompletedTransferLength < pTransferContext->BulkContext.ChunkSize) {
        USBCAMD_KdPrint(MIN_TRACE,("Short bulk transfer received. Length = %d, ChunkSize = %d\n",
                                   CompletedTransferLength, pTransferContext->BulkContext.ChunkSize));
        fShortTransfer = TRUE;
    }
    
    //
    // If this transfer went into the read buffer, then this should be the final read 
    // of  a single very small read (< single usb packet).
    // In either case, we need to copy the appropriate amount of data into the user's irp, update the
    // read buffer variables, and complete the user's irp.
    //

    if (pTransferContext->BulkContext.fDestinedForReadBuffer) {
        USBCAMD_KdPrint(MAX_TRACE,("Read bulk buffer transfer completed. size = %d\n", CompletedTransferLength));
        ASSERT(CompletedTransferLength <= MaxPacketSize);
        ASSERT(pTransferContext->BulkContext.pOriginalTransferBuffer);
        ASSERT(pTransferContext->BulkContext.pTransferBuffer);
        ASSERT(pTransferContext->WorkBuffer == pTransferContext->BulkContext.pTransferBuffer);
        ASSERT(pTransferContext->BulkContext.RemainingTransferLength < MaxPacketSize);

        ASSERT(CompletedTransferLength < MaxPacketSize);            
        RtlCopyMemory(pTransferContext->BulkContext.pOriginalTransferBuffer,
                      pTransferContext->WorkBuffer,
                      CompletedTransferLength);
        pTransferContext->BulkContext.pTransferBuffer = 
            pTransferContext->BulkContext.pOriginalTransferBuffer;            
    }

    //
    // Update the number of bytes transferred, remaining bytes to transfer 
    // and advance the transfer buffer pointer appropriately.
    //

    pTransferContext->BulkContext.NBytesTransferred += CompletedTransferLength;
    pTransferContext->BulkContext.pTransferBuffer += CompletedTransferLength;
    pTransferContext->BulkContext.RemainingTransferLength -= CompletedTransferLength;

    //
    // If there is still data to transfer and the previous transfer was NOT a
    // short transfer, then issue another request to move the next chunk of data.
    //
    
    if (pTransferContext->BulkContext.RemainingTransferLength > 0) {
        if (!fShortTransfer) {

            USBCAMD_KdPrint(MAX_TRACE,("Queuing next chunk. RemainingSize = %d, pBuffer = 0x%x\n",
                                       pTransferContext->BulkContext.RemainingTransferLength,
                                       pTransferContext->BulkContext.pTransferBuffer));

            if (pTransferContext->BulkContext.RemainingTransferLength < pTransferContext->BulkContext.ChunkSize) {
                pTransferContext->BulkContext.ChunkSize = pTransferContext->BulkContext.RemainingTransferLength;
            }

            //
            // Reinitialize URB
            //
            // If the next transfer is < than 1 packet, change it's destination to be
            // the read buffer.  When this transfer completes, the appropriate amount of data will be
            // copied out of the read buffer and into the user's irp.  
            //

            if  (deviceExtension->PipePinRelations[PipeIndex].PipeDirection == INPUT_PIPE){
                if (pTransferContext->BulkContext.ChunkSize < MaxPacketSize) {
                    pTransferContext->BulkContext.fDestinedForReadBuffer = TRUE;
                    pTransferContext->BulkContext.pOriginalTransferBuffer = pTransferContext->BulkContext.pTransferBuffer;
                    if (pTransferContext->WorkBuffer)
                        pTransferContext->BulkContext.pTransferBuffer = pTransferContext->WorkBuffer;
                    else {
                        pTransferContext->BulkContext.pTransferBuffer = 
                        pTransferContext->WorkBuffer =
                                    USBCAMD_ExAllocatePool(NonPagedPool,MaxPacketSize); 
                        if (pTransferContext->WorkBuffer == NULL ){
                            USBCAMD_KdPrint (MIN_TRACE, ("Error allocating bulk transfer work buffer. \n"));
                            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }   
                    pTransferContext->BulkContext.ChunkSize = MaxPacketSize;
                }
                pTransferContext->BulkContext.ChunkSize = (pTransferContext->BulkContext.ChunkSize / MaxPacketSize) * MaxPacketSize;
            }

            ASSERT(pTransferContext->BulkContext.ChunkSize >= MaxPacketSize);
            ASSERT(0 == pTransferContext->BulkContext.ChunkSize % MaxPacketSize);     
            
            if (STATUS_SUCCESS == ntStatus) {

                // Restore the Irp to the transfer context
                pTransferContext->DataIrp = pIrp;

                // save outstanding IRP in device extension.
                InsertTailList(&PipePinRelations->IrpPendingQueue, &pTransferContext->ListEntry);

                KeReleaseSpinLock(&PipePinRelations->OutstandingIrpSpinlock, Irql);

                UsbBuildInterruptOrBulkTransferRequest(pUrb,
                    sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                    deviceExtension->Interface->Pipes[PipeIndex].PipeHandle,
                    pTransferContext->BulkContext.pTransferBuffer,
                    NULL,
                    pTransferContext->BulkContext.ChunkSize,
                    USBD_SHORT_TRANSFER_OK,
                    NULL);

                USBCAMD_RecycleIrp(pTransferContext, 
                                   pTransferContext->DataIrp,
                                   pTransferContext->DataUrb,
                                   USBCAMD_BulkTransferComplete);

                IoCallDriver(deviceExtension->StackDeviceObject, pTransferContext->DataIrp);
            }
            else {

                KeReleaseSpinLock(&PipePinRelations->OutstandingIrpSpinlock, Irql);

                IoFreeIrp(pIrp);

                if ( channelExtension == NULL ) {
                    USBCAMD_FreeBulkTransfer(pTransferContext);
                    USBCAMD_ExFreePool(pTransferContext);
                }
                else {
                    USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
                }
            }

            return STATUS_MORE_PROCESSING_REQUIRED;               
        }
    }

    KeReleaseSpinLock(&PipePinRelations->OutstandingIrpSpinlock, Irql);

    IoFreeIrp(pIrp);

    USBCAMD_KdPrint(MAX_TRACE,("Completing bulk transfer request. nbytes transferred = %d \n",
                               pTransferContext->BulkContext.NBytesTransferred));        

    //
    // we need to complete the read/write erequest.
    //
    
    if ( channelExtension == NULL ) {
        

        //
        // notify STI monitor if any and schedule a work item to resumbit
        // the interrupt transfer.
        //
        USBCAMD_ResubmitInterruptTransfer(deviceExtension,PipeIndex ,pTransferContext);
    }
    else {

        //
        // this is a stream class bulk read request on the video/still pin.
        //
        USBCAMD_CompleteBulkRead(channelExtension, CompletedTransferStatus);

        USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
USBCAMD_InitializeBulkTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN ULONG PipeIndex
    )
/*++

Routine Description:

    Initializes a bulk or interrupt transfer.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    ChannelExtension - extension specific to this video channel

    InterfaceInformation - pointer to USBD interface information structure 
        describing the currently active interface.

    TransferExtension - context information assocaited with this transfer set.        


Return Value:

    NT status code

--*/
{
    ULONG packetSize;
    NTSTATUS ntStatus = STATUS_SUCCESS;

#if DBG
    if ( ChannelExtension != NULL ) {
        ASSERT_CHANNEL(ChannelExtension);
    }
#endif
       
    USBCAMD_KdPrint (ULTRA_TRACE, ("enter USBCAMD_InitializeBulkTransfer\n"));

    TransferExtension->Sig = USBCAMD_TRANSFER_SIG;     
    TransferExtension->DeviceExtension = DeviceExtension;
    TransferExtension->ChannelExtension = ChannelExtension;
    TransferExtension->BulkContext.PipeIndex = PipeIndex;

    KeInitializeEvent(&TransferExtension->BulkContext.CancelEvent, SynchronizationEvent, FALSE);

    ASSERT(
        NULL == TransferExtension->DataUrb &&
        NULL == TransferExtension->SyncBuffer &&
        NULL == TransferExtension->WorkBuffer &&
        NULL == TransferExtension->SyncIrp
        );

    //
    // No pending transfers yet
    //
    packetSize = InterfaceInformation->Pipes[PipeIndex].MaximumPacketSize;

    //
    // Allocate and initialize URB
    //
    
    TransferExtension->DataUrb = USBCAMD_ExAllocatePool(NonPagedPool, 
                                                sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));
    if (NULL == TransferExtension->DataUrb) {
        USBCAMD_KdPrint(MIN_TRACE,(" cannot allocated bulk URB\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        return ntStatus;
    }

    RtlZeroMemory(TransferExtension->DataUrb, sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));

    USBCAMD_KdPrint (MAX_TRACE, ("exit USBCAMD_InitializeBulkTransfer 0x%x\n", ntStatus));

    return ntStatus;
}

NTSTATUS
USBCAMD_FreeBulkTransfer(
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension
    )
/*++

Routine Description:

    Opposite of USBCAMD_InitializeBulkTransfer, frees resources allocated for an 
    iso transfer.

Arguments:


    TransferExtension - context information for this transfer (pair of iso 
        urbs).

Return Value:

    NT status code

--*/
{
    ASSERT_TRANSFER(TransferExtension);
  
    USBCAMD_KdPrint (MAX_TRACE, ("Free Bulk Transfer\n"));
    
    ASSERT(TransferExtension->DataIrp == NULL);

    if (TransferExtension->WorkBuffer) {
        USBCAMD_ExFreePool(TransferExtension->WorkBuffer);
        TransferExtension->WorkBuffer = NULL;
    }
    
    if (TransferExtension->DataUrb) {
        USBCAMD_ExFreePool(TransferExtension->DataUrb);
        TransferExtension->DataUrb = NULL;
    }

    return STATUS_SUCCESS;
}



VOID
USBCAMD_ResubmitInterruptTransfer(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN ULONG PipeIndex,
        IN PUSBCAMD_TRANSFER_EXTENSION pTransferContext
    )
/*++

Routine Description:

    This routine completes the bnulk read/write request for the video/still pin

Arguments:

Return Value:

--*/    
{
    PINTERRUPT_WORK_ITEM pIntWorkItem;

    //
    // Queue a work item for this Irp
    //

    pIntWorkItem = USBCAMD_ExAllocatePool(NonPagedPool, sizeof(*pIntWorkItem));
    if (pIntWorkItem) {
        ExInitializeWorkItem(&pIntWorkItem->WorkItem,
                             USBCAMD_ProcessInterruptTransferWorkItem,
                             pIntWorkItem);

        pIntWorkItem->pDeviceExt = deviceExtension;       
        pIntWorkItem->pTransferExt = pTransferContext;
        pIntWorkItem->PipeIndex = PipeIndex;
        ExQueueWorkItem(&pIntWorkItem->WorkItem,DelayedWorkQueue);

    } 
    else
        TEST_TRAP();
}

//
// code to handle packet processing outside the DPC routine
//

VOID
USBCAMD_ProcessInterruptTransferWorkItem(
    PVOID Context
    )
/*++

Routine Description:

    Call the mini driver to convert a raw still frame to the proper format.

Arguments:

Return Value:

    None.

--*/
{
    PINTERRUPT_WORK_ITEM pIntWorkItem = Context;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    PUSBCAMD_TRANSFER_EXTENSION pTransferContext;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    
    pTransferContext = pIntWorkItem->pTransferExt;
    ASSERT_TRANSFER(pTransferContext);
    deviceExtension = pIntWorkItem->pDeviceExt;

    //
    // this is an external read/write request.
    //

    if (pTransferContext->BulkContext.CommandCompleteCallback) {
        // call the completion handler
        (*pTransferContext->BulkContext.CommandCompleteCallback)
                             (USBCAMD_GET_DEVICE_CONTEXT(deviceExtension), 
                              pTransferContext->BulkContext.CommandCompleteContext, 
                              ntStatus);
    }   

    // notify STI mon if this was an interrupt event.
    if ( pTransferContext->BulkContext.TransferType == INTERRUPT_TRANSFER) 
        if (deviceExtension->CamControlFlag & USBCAMD_CamControlFlag_EnableDeviceEvents) 
            USBCAMD_NotifyStiMonitor(deviceExtension);

    // check if we need to loop back.
    if ( pTransferContext->BulkContext.LoopBack ) 
        ntStatus = USBCAMD_RestoreOutstandingIrp(deviceExtension,pIntWorkItem->PipeIndex,pTransferContext);

   if (ntStatus != STATUS_SUCCESS) {
        // we have an error on the submission set the stream error flag
        // and exit.
        TEST_TRAP();
   }

    USBCAMD_ExFreePool(pIntWorkItem);
}   



VOID
USBCAMD_CompleteBulkRead(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN NTSTATUS ntStatus
    )
/*++

Routine Description:

    This routine completes the bnulk read/write request for the video/still pin

Arguments:

Return Value:

--*/    
{
    PUSBCAMD_WORK_ITEM usbWorkItem;

#if DBG
    // 
    // we increment capture frame counter in ch ext. regardles of read srb
    // availability
    ChannelExtension->FrameCaptured++;  
#endif

    //
    // Queue a work item for this Irp
    //

    usbWorkItem = USBCAMD_ExAllocatePool(NonPagedPool, sizeof(*usbWorkItem));
    if (usbWorkItem) {
        ExInitializeWorkItem(&usbWorkItem->WorkItem,
                             USBCAMD_ProcessStillReadWorkItem,
                             usbWorkItem);

        usbWorkItem->ChannelExtension = ChannelExtension;
        usbWorkItem->status = ntStatus;
        ExQueueWorkItem(&usbWorkItem->WorkItem,
                        DelayedWorkQueue);

    } 
    else
        TEST_TRAP();
}

//
// code to handle packet processing outside the DPC routine
//

VOID
USBCAMD_ProcessStillReadWorkItem(
    PVOID Context
    )
/*++

Routine Description:

    Call the mini driver to convert a raw still frame to the proper format.

Arguments:

Return Value:

    None.

--*/
{
    PUSBCAMD_WORK_ITEM usbWorkItem = Context;
    PVOID frameBuffer;
    ULONG maxLength,i;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension;    
    PUSBCAMD_READ_EXTENSION readExtension;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    ULONG bytesTransferred, index;
    NTSTATUS status;
    PHW_STREAM_REQUEST_BLOCK srb;
    PKSSTREAM_HEADER dataPacket;
    PUSBCAMD_TRANSFER_EXTENSION pTransferContext;
    PLIST_ENTRY listEntry = NULL;
    LARGE_INTEGER DelayTime = {(ULONG)(-5 * 1000 * 10), -1};

    status = usbWorkItem->status;
    channelExtension = usbWorkItem->ChannelExtension;
    ASSERT_CHANNEL(channelExtension);

    
    pTransferContext = &channelExtension->TransferExtension[channelExtension->CurrentBulkTransferIndex];  
    //
    // DSHOW buffer len returned will be equal raw frame len unless we 
    // process raw frame buffer in ring 0.
    //
    bytesTransferred = pTransferContext->BulkContext.NBytesTransferred;
    deviceExtension = channelExtension->DeviceExtension;

    //
    // get a pending read srb
    //

    for ( i=0; i < 2; i++) {
        listEntry =  ExInterlockedRemoveHeadList( &(channelExtension->PendingIoList),
                                             &channelExtension->PendingIoListSpin);
        if (listEntry )
            break;

        USBCAMD_KdPrint (MIN_TRACE, ("No Read Srbs available. Delay excution \n"));

        KeDelayExecutionThread(KernelMode,FALSE,&DelayTime);
    }   
    
    if ( listEntry ) { // chk if no more read SRBs in Q. 

        readExtension = (PUSBCAMD_READ_EXTENSION) CONTAINING_RECORD(listEntry, 
                                                     USBCAMD_READ_EXTENSION, 
                                                     ListEntry);       

        ASSERT_READ(readExtension);

        // Let client driver initiate the SRB extension.
        
        (*deviceExtension->DeviceDataEx.DeviceData2.CamNewVideoFrameEx)
                                       (USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                                        USBCAMD_GET_FRAME_CONTEXT(readExtension),
                                        channelExtension->StreamNumber,
                                        &readExtension->ActualRawFrameLen);
        

        srb = readExtension->Srb;
        dataPacket = srb->CommandData.DataBufferArray;
        dataPacket->OptionsFlags =0;    

        if ((status == STATUS_SUCCESS) && (!channelExtension->NoRawProcessingRequired)) {

            frameBuffer = USBCAMD_GetFrameBufferFromSrb(readExtension->Srb,&maxLength);

            // Ensure that the buffer size appears to be exactly what was requested
            ASSERT(maxLength >= channelExtension->VideoInfoHeader->bmiHeader.biSizeImage);
            maxLength = channelExtension->VideoInfoHeader->bmiHeader.biSizeImage;

            USBCAMD_DbgLog(TL_SRB_TRACE, '0ypC', srb, frameBuffer, 0);

            status = 
                (*deviceExtension->DeviceDataEx.DeviceData2.CamProcessRawVideoFrameEx)(
                    deviceExtension->StackDeviceObject,
                    USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                    USBCAMD_GET_FRAME_CONTEXT(readExtension),
                    frameBuffer,
                    maxLength,
                    pTransferContext->DataBuffer,
                    readExtension->RawFrameLength,
                    0,
                    &bytesTransferred,
                    pTransferContext->BulkContext.NBytesTransferred,
                    srb->StreamObject->StreamNumber);                   
        }

        USBCAMD_KdPrint (MAX_TRACE, ("CamProcessRawframeEx Completed, length = %d status = 0x%X \n",
                                        bytesTransferred,status));

        // The number of bytes transfer of the read is set above just before
        // USBCAMD_CompleteReadRequest is called.

        USBCAMD_CompleteRead(channelExtension,readExtension,status,bytesTransferred); 
    }
    else {
            USBCAMD_KdPrint (MIN_TRACE, ("Dropping Video Frame.\n"));
#if DBG
            pTransferContext->ChannelExtension->VideoFrameLostCount++;
#endif

            
            // and send a note to the camera driver about the cancellation.
            // send a CamProcessrawFrameEx with null buffer ptr.
            if ( !channelExtension->NoRawProcessingRequired) {

                status = 
                        (*deviceExtension->DeviceDataEx.DeviceData2.CamProcessRawVideoFrameEx)(
                             deviceExtension->StackDeviceObject,
                             USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                             NULL,
                             NULL,
                             0,
                             NULL,
                             0,
                             0,
                             NULL,
                             0,
                             0);
            }
            
    }

    channelExtension->CurrentBulkTransferIndex ^= 1; // toggle index.
    index = channelExtension->CurrentBulkTransferIndex;
    status = USBCAMD_IntOrBulkTransfer(deviceExtension,
                        channelExtension,
                        channelExtension->TransferExtension[index].DataBuffer,
                        channelExtension->TransferExtension[index].BufferLength,
                        channelExtension->DataPipe,
                        NULL,
                        NULL,
                        0,
                        BULK_TRANSFER);        

    USBCAMD_ExFreePool(usbWorkItem);
}   


/*++

Routine Description:


Arguments:

Return Value:

    None.

--*/

NTSTATUS
USBCAMD_CancelOutstandingBulkIntIrps(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN BOOLEAN bSaveIrp
        )
{

    NTSTATUS ntStatus= STATUS_SUCCESS;
    ULONG PipeIndex;


   for ( PipeIndex = 0; PipeIndex < deviceExtension->Interface->NumberOfPipes; PipeIndex++ ) {

        if ( USBCAMD_OutstandingIrp(deviceExtension, PipeIndex)) {

            // there is a pending IRP on this Pipe. Cancel it
            ntStatus = USBCAMD_CancelOutstandingIrp(deviceExtension,PipeIndex,bSaveIrp);
        }
    }

    return ntStatus;
}

/*++

Routine Description:


Arguments:

Return Value:

    None.

--*/

NTSTATUS
USBCAMD_CancelOutstandingIrp(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN ULONG PipeIndex,
        IN BOOLEAN bSaveIrp
        )
{
    PUSBCAMD_PIPE_PIN_RELATIONS PipePinRelations = &deviceExtension->PipePinRelations[PipeIndex];
    LIST_ENTRY LocalList;
    KIRQL Irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    InitializeListHead(&LocalList);

    // Cancel all the outstanding IRPs at once, saving them in a local queue for post-processing
    KeAcquireSpinLock(&PipePinRelations->OutstandingIrpSpinlock, &Irql);

    while (!IsListEmpty(&PipePinRelations->IrpPendingQueue)) {

        PLIST_ENTRY pListEntry;
        PUSBCAMD_TRANSFER_EXTENSION pTransferContext;

        pListEntry = RemoveHeadList(&PipePinRelations->IrpPendingQueue);
        pTransferContext = (PUSBCAMD_TRANSFER_EXTENSION)
            CONTAINING_RECORD(pListEntry, USBCAMD_TRANSFER_EXTENSION, ListEntry);

        ASSERT_TRANSFER(pTransferContext);
        ASSERT(pTransferContext->DataIrp != NULL);

        IoCancelIrp(pTransferContext->DataIrp);

        InsertTailList(&LocalList, &pTransferContext->ListEntry);
    }

    KeReleaseSpinLock(&PipePinRelations->OutstandingIrpSpinlock, Irql);

    while (!IsListEmpty(&LocalList)) {

        PLIST_ENTRY pListEntry;
        PUSBCAMD_TRANSFER_EXTENSION pTransferContext;

        pListEntry = RemoveHeadList(&LocalList);
        pTransferContext = (PUSBCAMD_TRANSFER_EXTENSION)
            CONTAINING_RECORD(pListEntry, USBCAMD_TRANSFER_EXTENSION, ListEntry);

        if (pTransferContext->ChannelExtension) {

            USBCAMD_ResetPipes(
                deviceExtension,
                pTransferContext->ChannelExtension,
                deviceExtension->Interface,
                TRUE
                );   
        }

        USBCAMD_KdPrint (MAX_TRACE, ("Wait for Bulk transfer Irp to complete with Cancel.\n"));

        ntStatus = KeWaitForSingleObject(
                   &pTransferContext->BulkContext.CancelEvent,
                   Executive,
                   KernelMode,
                   FALSE,
                   NULL);   

        if (!bSaveIrp) {

            // Inform Cam minidriver only if cancellation is permanent.
            if (pTransferContext->BulkContext.CommandCompleteCallback) {
                // call the completion handler
                (*pTransferContext->BulkContext.CommandCompleteCallback)
                                (USBCAMD_GET_DEVICE_CONTEXT(deviceExtension), 
                                 pTransferContext->BulkContext.CommandCompleteContext, 
                                 STATUS_CANCELLED);
            }
   
            // recycle allocate resources for the cancelled transfer.
            if ( pTransferContext->ChannelExtension == NULL ) {
                USBCAMD_FreeBulkTransfer(pTransferContext);  
                USBCAMD_ExFreePool(pTransferContext);
            }
        }
        else {

            // Save this in the restore queue (no need to protect with the spinlock)
            InsertTailList(&PipePinRelations->IrpRestoreQueue, &pTransferContext->ListEntry);
        }
    }

    return ntStatus;
}


/*++

Routine Description:


Arguments:

Return Value:

    None.

--*/

NTSTATUS
USBCAMD_RestoreOutstandingBulkIntIrps(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension
        )
{

    NTSTATUS ntStatus= STATUS_SUCCESS;
    ULONG PipeIndex;
    PUSBCAMD_TRANSFER_EXTENSION pTransExt;

    for ( PipeIndex = 0; PipeIndex < deviceExtension->Interface->NumberOfPipes; PipeIndex++ ) {

        // there are pending IRPs on this Pipe. restore them
        for ( ;;) {
            // Dequeue this irp from the restore Q.

            pTransExt = USBCAMD_DequeueFirstIrp(deviceExtension,
                PipeIndex,
                &deviceExtension->PipePinRelations[PipeIndex].IrpRestoreQueue);

            if ( pTransExt == NULL ) 
                break;

            ntStatus = USBCAMD_RestoreOutstandingIrp(deviceExtension,PipeIndex,pTransExt);
        }
    }
    return ntStatus;
}


/*++

Routine Description:


Arguments:

Return Value:

    None.

--*/

NTSTATUS
USBCAMD_RestoreOutstandingIrp(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN ULONG PipeIndex,
        IN PUSBCAMD_TRANSFER_EXTENSION pTransferContext
        )
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PVOID pBuffer,commandContext;
    ULONG TransferSize;
    PCOMMAND_COMPLETE_FUNCTION commandComplete;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension;
    BOOLEAN LoopBack;
    UCHAR TransferType;
            

    ASSERT_TRANSFER(pTransferContext);
    USBCAMD_KdPrint (MAX_TRACE, ("Restore Bulk/int transfer .\n"));

    // get all the relavent data from transfer context.
    pBuffer = pTransferContext->BulkContext.pOriginalTransferBuffer;
    TransferSize = pTransferContext->BulkContext.ChunkSize;
    commandComplete = pTransferContext->BulkContext.CommandCompleteCallback;
    commandContext = pTransferContext->BulkContext.CommandCompleteContext;
    LoopBack = pTransferContext->BulkContext.LoopBack;
    TransferType = pTransferContext->BulkContext.TransferType;
    channelExtension = pTransferContext->ChannelExtension;
   
    // recycle allocate resources for the cancelled transfer.

    if ( channelExtension == NULL ) {
       USBCAMD_FreeBulkTransfer(pTransferContext);  
       USBCAMD_ExFreePool(pTransferContext);
    }

    // request a new transfer with the resotred data.
    ntStatus = USBCAMD_IntOrBulkTransfer(deviceExtension,
                                         channelExtension,
                                         pBuffer,
                                         TransferSize,
                                         PipeIndex,
                                         commandComplete,
                                         commandContext,
                                         LoopBack,
                                         TransferType);        
    return ntStatus;
}

/*++

Routine Description:

    This routine will cancel any pending a read or write operation on a specified 
    bulk pipe. 

Arguments:

    DeviceContext - 

    PipeIndex - 



Return Value:

    NT status code

--*/

NTSTATUS
USBCAMD_CancelBulkReadWrite( 
    IN PVOID DeviceContext,
    IN ULONG PipeIndex
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
 
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    PUSBD_PIPE_INFORMATION pipeHandle ;

    deviceExtension = USBCAMD_GET_DEVICE_EXTENSION(DeviceContext);


    USBCAMD_KdPrint ( MAX_TRACE, ("Enter USBCAMD_CancelBulkReadWrite\n"));

    //
    // do some parameter validation.
    //

    if (PipeIndex > deviceExtension->Interface->NumberOfPipes) {
        
        USBCAMD_KdPrint(MIN_TRACE,("invalid pipe index!\n"));
        ntStatus = STATUS_INVALID_PARAMETER;        
        return ntStatus;        
    }

    // check if we have a pending read or write already. 

    if (!USBCAMD_OutstandingIrp(deviceExtension, PipeIndex) ) {
        // no pending IRP for this pipe ...
        ntStatus = STATUS_SUCCESS;        
        return ntStatus;            
    }
        
    pipeHandle = &deviceExtension->Interface->Pipes[PipeIndex];

    if (pipeHandle->PipeType < UsbdPipeTypeBulk ) {
     
        USBCAMD_KdPrint(MIN_TRACE,("invalid pipe type!\n"));
        ntStatus = STATUS_INVALID_PARAMETER;        
        return ntStatus;        
    }

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
        USBCAMD_KdPrint(MIN_TRACE,("BulkCancel is cancelable at Passive Level Only!\n"));
        ntStatus = STATUS_INVALID_PARAMETER;   
        TEST_TRAP();
        return ntStatus;       
    }
  
    // there is a pending IRP on this Pipe. Cancel it
    ntStatus = USBCAMD_CancelOutstandingIrp(deviceExtension,PipeIndex,FALSE);

    return ntStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\philips\vfwext\prppage2.cpp ===
/*
 * Copyright (c) 1996 1997, 1998 Philips CE I&C
 *
 * FILE			PRPPAGE2.CPP
 * DATE			7-1-97
 * VERSION		1.00
 * AUTHOR		M.J. Verberne
 * DESCRIPTION	Property page 1
 * HISTORY		
 *
*/
#include <windows.h>
#include <winioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include "resource.h"
#include "prpcom.h"
#include "prpctrl.h"
#include "debug.h"
#include "phvcmext.h"
#include "prppage2.h"

/*-- Data types ----------------------------------------------------------*/

/*-- Local data definitions ----------------------------------------------*/
static VFWEXT_INFO VfWExtInfo;
static PRPCTRL Brightness_Ctrl =
	{
		PRPCTRL_TYPE_SLIDER,
		IDS_BRIGHTNESS,
		IDE_BRIGHTNESS,
		IDT_BRIGHTNESS,
		STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP,
		KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
		FALSE,
		NULL,
		0,
		0
	};
static PRPCTRL Contrast_Ctrl =
	{
		PRPCTRL_TYPE_SLIDER,
		IDS_CONTRAST,
		IDE_CONTRAST,
		IDT_CONTRAST,
		STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP,
		KSPROPERTY_VIDEOPROCAMP_CONTRAST,
		FALSE,
		NULL,
		0,
		0
	};
static PRPCTRL Gamma_Ctrl =
	{
		PRPCTRL_TYPE_SLIDER,
		IDS_GAMMA,
		IDE_GAMMA,
		IDT_GAMMA,
		STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP,
		KSPROPERTY_VIDEOPROCAMP_GAMMA,
		FALSE,
		NULL,
		0,
		0
	};
static PRPCTRL ColorEnable_Ctrl =
	{
		PRPCTRL_TYPE_CHECKBOX,
		IDC_COLORENABLE,
		0,
		0,
		STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP,
		KSPROPERTY_VIDEOPROCAMP_COLORENABLE,
		FALSE,
		NULL,
		0,
		0xff
	};
static PRPCTRL BackLight_Compensation_Ctrl =
	{
		PRPCTRL_TYPE_CHECKBOX,
		IDC_BACKLIGHT_COMPENSATION,
		0,
		0,
		STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP,
		KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,
		FALSE,
		NULL,
		0,
		0xff
	};

/*-- Local function definitions ------------------------------------------*/
static INT_PTR CALLBACK PRPPAGE2_PageDlgProc(
	HWND hDlg,
	UINT uMessage,
	WPARAM wParam,
	LPARAM lParam);
static UINT _stdcall PRPPAGE2_PageCallback(
	HWND hwnd,
	UINT uMsg,
	LPPROPSHEETPAGE ppsp);
static BOOL PRPPAGE2_ExtSetActive(
	HWND hDlg,
	WPARAM	wParam,
	LPARAM	lParam);
static BOOL PRPPAGE2_PageDlgProc_DoCommand(
	HWND hDlg,
    WPARAM wParam,
	LPARAM lParam);
static BOOL PRPPAGE2_Init_Framerate(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam);
static BOOL PRPPAGE2_Init_ImageControls(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam);
static BOOL PRPPAGE2_Init_Defaults(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam);
static BOOL PRPPAGE2_Handle_Framerate(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam);
static BOOL	PRPPAGE2_Handle_Slider(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam);
static BOOL	PRPPAGE2_Handle_CheckBox(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam);
static BOOL PRPPAGE2_Handle_Defaults(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam);
static BOOL	PRPPAGE2_Get_Framerate_Ctrl(
	HWND hDlg,
	BOOL bVGA,
	LONG lFramerate,
	WORD *pCtrl_Id);
static BOOL	PRPPAGE2_Get_Framerate_Value(
	HWND hDlg,
	PLONG plFramerate,
	WORD Ctrl_Id);
static void PRPPAGE2_EnableControls(
	HWND hDlg,
	BOOL bEnable);
static void PRPPAGE2_Handle_Err_Comm(
	HWND hDlg);
static void PRPPAGE2_Handle_Err_Dev_Chg(
	HWND hDlg);


/*======================== EXPORTED FUNCTIONS =============================*/

/*-------------------------------------------------------------------------*/
HPROPSHEETPAGE PRPPAGE2_CreatePage(
	LPFNEXTDEVIO pfnDeviceIoControl,
	LPARAM lParam,
	HINSTANCE hInst)
/*-------------------------------------------------------------------------*/
{
	PROPSHEETPAGE psPage;
	HPROPSHEETPAGE hPage;

	// save device info
	VfWExtInfo.pfnDeviceIoControl = pfnDeviceIoControl;
	VfWExtInfo.lParam = lParam;

	// create page
    psPage.dwSize		= sizeof(psPage);
    psPage.dwFlags		= PSP_USEREFPARENT | PSP_USECALLBACK;
    psPage.hInstance	= hInst;
    psPage.pszTemplate	= MAKEINTRESOURCE(IDD_VCM_NALA2);
	psPage.pszIcon      = NULL;
    psPage.pfnDlgProc	= PRPPAGE2_PageDlgProc;
    psPage.pcRefParent	= 0;
    psPage.pfnCallback	= (LPFNPSPCALLBACK) PRPPAGE2_PageCallback;	
    psPage.lParam		= (LPARAM) &VfWExtInfo;

	hPage = CreatePropertySheetPage(&psPage);

	return hPage;
}

/*-- Local functions ------------------------------------------------------*/


/*-------------------------------------------------------------------------*/
static INT_PTR CALLBACK PRPPAGE2_PageDlgProc(
	HWND	hDlg,
	UINT	uMessage,
	WPARAM	wParam,
	LPARAM	lParam)
/*-------------------------------------------------------------------------*/
{
	switch (uMessage)
	{
		case WM_INITDIALOG:
			SetWindowLongPtr(hDlg,DWLP_USER, (LPARAM) &VfWExtInfo);
			return TRUE;
		case WM_COMMAND:
			return PRPPAGE2_PageDlgProc_DoCommand(hDlg, wParam, lParam);
		case WM_NOTIFY:
			if (((NMHDR FAR *)lParam)->code == PSN_SETACTIVE)
				return PRPPAGE2_ExtSetActive(hDlg, wParam, lParam);	
			break;
		case WM_HSCROLL:
			PRPPAGE2_Handle_Slider(hDlg, wParam, lParam);
			return TRUE;
	}
	return FALSE;	// default processing
}

/*-------------------------------------------------------------------------*/
static UINT _stdcall PRPPAGE2_PageCallback(
   HWND hwnd,
   UINT uMsg,
   LPPROPSHEETPAGE ppsp)
/*-------------------------------------------------------------------------*/
{
	switch(uMsg)
	{
		case PSPCB_CREATE:
			return 1;
		case PSPCB_RELEASE:
			return 0;
	}
	return 0;
}


/*-------------------------------------------------------------------------*/
static int PRPPAGE2_ExtSetActive(
	HWND hDlg,
	WPARAM	wParam,
	LPARAM	lParam)
/*-------------------------------------------------------------------------*/
{
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);
	BOOL bResult;

	// Open the device and initialize the controls
	if (PRPCOM_HasDeviceChanged(
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam))
	{
		// Oops, device is not the same anymore
		goto PRPPAGE2_ExtSetActive_Err_Dev_Chg;
	}

	// enable all controls
	PRPPAGE2_EnableControls(hDlg, TRUE);

	// initialize Framerate
	bResult = PRPPAGE2_Init_Framerate(hDlg, wParam, lParam);
	if (!bResult)
		goto PRPPAGE2_ExtSetActive_Err_Comm;

	// initialize Image controls
	bResult = PRPPAGE2_Init_ImageControls(hDlg, wParam, lParam);
	if (!bResult)
		goto PRPPAGE2_ExtSetActive_Err_Comm;

	// initialize Defaults
	bResult = PRPPAGE2_Init_Defaults(hDlg, wParam, lParam);
	if (!bResult)
		goto PRPPAGE2_ExtSetActive_Err_Comm;

	return TRUE;

PRPPAGE2_ExtSetActive_Err_Dev_Chg:

	PRPPAGE2_Handle_Err_Dev_Chg(hDlg);

	return FALSE;

PRPPAGE2_ExtSetActive_Err_Comm:

	PRPPAGE2_Handle_Err_Comm(hDlg);

	return FALSE;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE2_PageDlgProc_DoCommand(
	HWND hDlg,
    WPARAM wParam,
	LPARAM lParam)
/*-------------------------------------------------------------------------*/
{
	BOOL bResult;

	switch(LOWORD(wParam))
	{
		case IDR_FRAMERATE_VGA_375:	
		case IDR_FRAMERATE_MR_375:
		case IDR_FRAMERATE_VGA_5:	
		case IDR_FRAMERATE_MR_5:
		case IDR_FRAMERATE_VGA_75:	
		case IDR_FRAMERATE_MR_75:
		case IDR_FRAMERATE_VGA_10:	
		case IDR_FRAMERATE_MR_10:
		case IDR_FRAMERATE_MR_12:	
		case IDR_FRAMERATE_VGA_15:
		case IDR_FRAMERATE_MR_15:	
		case IDR_FRAMERATE_VGA_20:
		case IDR_FRAMERATE_MR_20:	
		case IDR_FRAMERATE_VGA_24:
		case IDR_FRAMERATE_MR_24:
			bResult = PRPPAGE2_Handle_Framerate(hDlg, wParam, lParam);
			if (!bResult)
				goto PRPPAGE2_PageDlgProc_DoCommand_Err_Comm;
			break;
		case IDC_COLORENABLE:
		case IDC_BACKLIGHT_COMPENSATION:
			bResult = PRPPAGE2_Handle_CheckBox(hDlg, wParam, lParam);
			if (!bResult)
				goto PRPPAGE2_PageDlgProc_DoCommand_Err_Comm;
			break;
		case IDB_RESTORE_UD:
		case IDB_RESTORE_FD:
		case IDB_SAVE_UD:
			bResult = PRPPAGE2_Handle_Defaults(hDlg, wParam, lParam);
			if (!bResult)
				goto PRPPAGE2_PageDlgProc_DoCommand_Err_Comm;
			break;
		default:
			return FALSE;	// default processing
	}

	return TRUE;	// message processed

PRPPAGE2_PageDlgProc_DoCommand_Err_Comm:

	PRPPAGE2_Handle_Err_Comm(hDlg);
	
	return TRUE;	// message processed
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE2_Init_Framerate(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam)
/*-------------------------------------------------------------------------*/
{
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);
	BOOL bResult = TRUE, bVGA;
	LONG lSensorType, lFramerate, lFramerates_Supported;
	WORD Ctrl_Id;
	WORD VGA_Button_Ids[7] = {	
		IDR_FRAMERATE_VGA_375,	IDR_FRAMERATE_VGA_5,	
		IDR_FRAMERATE_VGA_75,	IDR_FRAMERATE_VGA_10,	
		IDR_FRAMERATE_VGA_15,	IDR_FRAMERATE_VGA_20,	
		IDR_FRAMERATE_VGA_24 };
	WORD MR_Button_Ids[8] = {	
		IDR_FRAMERATE_MR_375,	IDR_FRAMERATE_MR_5,	
		IDR_FRAMERATE_MR_75,	IDR_FRAMERATE_MR_10,	
		IDR_FRAMERATE_MR_12,	IDR_FRAMERATE_MR_15,	
		IDR_FRAMERATE_MR_20,	IDR_FRAMERATE_MR_24 };
	int VGA_Bits[7] = { 1, 2, 3, 4, 6, 7, 8 };
	int MR_Bits[8] =  { 1, 2, 3, 4, 5, 6, 7, 8 };
	int i;

	// get sensortype from camera
	bResult = PRPCOM_Get_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_SENSORTYPE,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			&lSensorType);
	if (!bResult)
		return FALSE;

	// check sensortype
	switch(lSensorType)
	{
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_SENSORTYPE_PAL_MR:
			bVGA = FALSE;
			break;
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_SENSORTYPE_VGA:
			bVGA = TRUE;
			break;
		default:
			return FALSE;
	}

	// hide / show control set
	for (i = 0; i < 7; i++)
		ShowWindow(GetDlgItem(hDlg, VGA_Button_Ids[i]),	bVGA ? SW_SHOW: SW_HIDE);
	for (i = 0; i < 8; i++)
		ShowWindow(GetDlgItem(hDlg, MR_Button_Ids[i]), bVGA ? SW_HIDE : SW_SHOW);

	// reset framerate controls
	if (bVGA)
		for (i = 0; i < 7; i++)
			SendMessage(GetDlgItem(hDlg, VGA_Button_Ids[i]), BM_SETCHECK, 0, 0);
	else
		for (i = 0; i < 8; i++)
			SendMessage(GetDlgItem(hDlg, MR_Button_Ids[i]), BM_SETCHECK, 0, 0);

	// get framerate from camera
	bResult = PRPCOM_Get_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			&lFramerate);
	if (!bResult)
		return FALSE;

	// get control id associated with the framerate and sensortype
	bResult = PRPPAGE2_Get_Framerate_Ctrl(hDlg, bVGA, lFramerate, &Ctrl_Id);
	if (!bResult)
		return FALSE;
	if (Ctrl_Id)
		SendMessage(GetDlgItem(hDlg, Ctrl_Id), BM_SETCHECK, 1, 0);

	// get supported framerates
	bResult = PRPCOM_Get_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATES_SUPPORTED,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			&lFramerates_Supported);
	if (!bResult)
		return FALSE;

	// enable / disable controls
	if (bVGA)
		for (i = 0; i < 7; i++)
			EnableWindow(GetDlgItem(hDlg, VGA_Button_Ids[i]), lFramerates_Supported & (0x1 << VGA_Bits[i]));
	else
		for (i = 0; i < 8; i++)
			EnableWindow(GetDlgItem(hDlg, MR_Button_Ids[i]), lFramerates_Supported & (0x1 << MR_Bits[i]));

	// 10 hz not supported in 1st silicium
//	PRPPAGE2_Get_Framerate_Ctrl(
//			hDlg,
//			bVGA,
//			KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_10,
//			&Ctrl_Id);
//	EnableWindow(GetDlgItem(hDlg, Ctrl_Id), FALSE);

	return TRUE;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE2_Init_ImageControls(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam)
/*-------------------------------------------------------------------------*/
{
	BOOL bResult;
	LONG lEXP_ShutterMode;
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

	// Get Shutter Mode from camera
	bResult = PRPCOM_Get_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE,			
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			&lEXP_ShutterMode);
	if (!bResult)
		return FALSE;

	// check Shutter Mode
	switch(lEXP_ShutterMode)
	{
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_AUTO:
		case KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_FIXED:
			break;
		default:
			return FALSE;
	}

	// update controls
	bResult = PRPCTRL_Init(hDlg, &Brightness_Ctrl, TRUE);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Init(hDlg, &Contrast_Ctrl,
			lEXP_ShutterMode == KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_AUTO);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Init(hDlg, &Gamma_Ctrl, TRUE);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Init(hDlg, &ColorEnable_Ctrl, TRUE);
	if (!bResult)
		return FALSE;
	bResult = PRPCTRL_Init(hDlg, &BackLight_Compensation_Ctrl,
			lEXP_ShutterMode == KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_MODE_AUTO);
	if (!bResult)
		return FALSE;

	return TRUE;	
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE2_Init_Defaults(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam)
/*-------------------------------------------------------------------------*/
{
	// nothing to do

	return TRUE;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE2_Handle_Framerate(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam)
/*-------------------------------------------------------------------------*/
{
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);
	BOOL bResult;
	LONG lFramerate, lShutter_Speed;

	// get value corresponding to control id
	bResult = PRPPAGE2_Get_Framerate_Value(
			hDlg,
			&lFramerate,
			LOWORD(wParam));
	if (!bResult)
		return FALSE;

	// Save current Shutterspeed and shutter status
	bResult = PRPCOM_Get_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			&lShutter_Speed);
	if (!bResult)
		return FALSE;

	// Set new framerate
	bResult = PRPCOM_Set_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			lFramerate);
	if (!bResult)
		return FALSE;

	// Set shutterspeed back to old value
	bResult = PRPCOM_Set_Value(
			PROPSETID_PHILIPS_CUSTOM_PROP,
			KSPROPERTY_PHILIPS_CUSTOM_PROP_AE_SHUTTER_SPEED,
			pVfWExtInfo->pfnDeviceIoControl,
			pVfWExtInfo->lParam,
			lShutter_Speed);
	if (!bResult)
		return FALSE;

	return TRUE;
}

/*-------------------------------------------------------------------------*/
static BOOL	PRPPAGE2_Handle_Slider(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam)
/*-------------------------------------------------------------------------*/
{
	PRPCTRL_INFO *pCtrl;
	WORD Ctrl;
	BOOL bResult = TRUE;

	// only process when scrolling is done
	if (LOWORD(wParam) != SB_ENDSCROLL && LOWORD(wParam) != SB_THUMBTRACK)
		return TRUE;

	// get control id
	Ctrl = (WORD)GetWindowLong((HWND)lParam, GWL_ID);

	// get control object
	switch(Ctrl)
	{
		case IDS_BRIGHTNESS:
			pCtrl = &Brightness_Ctrl;
			break;
		case IDS_CONTRAST:
			pCtrl = &Contrast_Ctrl;
			break;
		case IDS_GAMMA:
			pCtrl = &Gamma_Ctrl;
			break;
		default:
			return FALSE;
	}								

	// process the message
	bResult = PRPCTRL_Handle_Msg(hDlg, pCtrl);
	if (!bResult)
		goto PRPPAGE2_Handle_Slider_Err_Comm;
		
	return TRUE;

PRPPAGE2_Handle_Slider_Err_Comm:

	PRPPAGE2_Handle_Err_Comm(hDlg);

	return FALSE;
}

/*-------------------------------------------------------------------------*/
static BOOL	PRPPAGE2_Handle_CheckBox(
	HWND	hDlg,
	WPARAM	wParam,
	LPARAM	lParam)
/*-------------------------------------------------------------------------*/
{
	PRPCTRL_INFO *pCtrl;
	BOOL bResult;
	WORD Ctrl;

	// get control id
	Ctrl = (WORD)GetWindowLong((HWND)lParam, GWL_ID);

	// get control object
	switch(Ctrl)
	{
		case IDC_COLORENABLE:
			pCtrl = &ColorEnable_Ctrl;
			break;
		case IDC_BACKLIGHT_COMPENSATION:
			pCtrl = &BackLight_Compensation_Ctrl;
			break;
		default:
			return FALSE;
	}								

	// process the message
	bResult = PRPCTRL_Handle_Msg(hDlg, pCtrl);
	if (!bResult)
		return FALSE;

	return TRUE;
}

/*-------------------------------------------------------------------------*/
static BOOL PRPPAGE2_Handle_Defaults(
	HWND hDlg,
	WPARAM wParam,
	LPARAM lParam)
/*-------------------------------------------------------------------------*/
{
	BOOL bResult;
	PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

	switch(LOWORD(wParam))
	{
		case IDB_RESTORE_UD:
			bResult = PRPCOM_Set_Value(
					PROPSETID_PHILIPS_CUSTOM_PROP,
					KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS,
					pVfWExtInfo->pfnDeviceIoControl,
					pVfWExtInfo->lParam,
					KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS_RESTORE_USER);
			if (!bResult)
				return FALSE;
			break;
		case IDB_RESTORE_FD:
			bResult = PRPCOM_Set_Value(
					PROPSETID_PHILIPS_CUSTOM_PROP,
					KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS,
					pVfWExtInfo->pfnDeviceIoControl,
					pVfWExtInfo->lParam,
					KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS_RESTORE_FACTORY);
			if (!bResult)
				return FALSE;
			break;
		case IDB_SAVE_UD:
			bResult = PRPCOM_Set_Value(
					PROPSETID_PHILIPS_CUSTOM_PROP,
					KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS,
					pVfWExtInfo->pfnDeviceIoControl,
					pVfWExtInfo->lParam,
					KSPROPERTY_PHILIPS_CUSTOM_PROP_DEFAULTS_SAVE_USER);
			if (!bResult)
				return FALSE;
			break;
		default:
			return FALSE;
	}

	// reinitialize the property page
	bResult = PRPPAGE2_ExtSetActive(hDlg, wParam, lParam);
	if (!bResult)
		return FALSE;
	
	return TRUE;
}

/*-------------------------------------------------------------------------*/
static BOOL	PRPPAGE2_Get_Framerate_Ctrl(
	HWND hDlg,
	BOOL bVGA,
	LONG lFramerate,
	WORD *pCtrl_Id)
/*-------------------------------------------------------------------------*/
{
	if (bVGA)
	{
		switch(lFramerate)
		{
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_VGA:
				(*pCtrl_Id) = 0;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_375:
				(*pCtrl_Id) = IDR_FRAMERATE_VGA_375;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_5:
				(*pCtrl_Id) = IDR_FRAMERATE_VGA_5;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_75:
				(*pCtrl_Id) = IDR_FRAMERATE_VGA_75;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_10:
				(*pCtrl_Id) = IDR_FRAMERATE_VGA_10;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_15:
				(*pCtrl_Id) = IDR_FRAMERATE_VGA_15;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_20:
				(*pCtrl_Id) = IDR_FRAMERATE_VGA_20;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_24:
				(*pCtrl_Id) = IDR_FRAMERATE_VGA_24;
				break;
			default:
				return FALSE;
		}
	}
	else
	{
		switch(lFramerate)
		{
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_375:
				(*pCtrl_Id) = IDR_FRAMERATE_MR_375;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_5:
				(*pCtrl_Id) = IDR_FRAMERATE_MR_5;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_75:
				(*pCtrl_Id) = IDR_FRAMERATE_MR_75;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_10:
				(*pCtrl_Id) = IDR_FRAMERATE_MR_10;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_12:
				(*pCtrl_Id) = IDR_FRAMERATE_MR_12;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_15:
				(*pCtrl_Id) = IDR_FRAMERATE_MR_15;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_20:
				(*pCtrl_Id) = IDR_FRAMERATE_MR_20;
				break;
			case KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_24:
				(*pCtrl_Id) = IDR_FRAMERATE_MR_24;
				break;
			default:
				return FALSE;
		}
	}

	return TRUE;
}


/*-------------------------------------------------------------------------*/
static BOOL	PRPPAGE2_Get_Framerate_Value(
	HWND hDlg,
	PLONG plFramerate,
	WORD Ctrl_Id)
/*-------------------------------------------------------------------------*/
{
	switch(Ctrl_Id)
	{
		case IDR_FRAMERATE_VGA_375:
		case IDR_FRAMERATE_MR_375:
			(*plFramerate) = KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_375;
			break;
		case IDR_FRAMERATE_VGA_5:
		case IDR_FRAMERATE_MR_5:
			(*plFramerate) = KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_5;
			break;
		case IDR_FRAMERATE_VGA_75:
		case IDR_FRAMERATE_MR_75:
			(*plFramerate) = KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_75;
			break;
		case IDR_FRAMERATE_VGA_10:
		case IDR_FRAMERATE_MR_10:
			(*plFramerate) = KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_10;
			break;
		case IDR_FRAMERATE_MR_12:
			(*plFramerate) = KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_12;
			break;
		case IDR_FRAMERATE_VGA_15:
		case IDR_FRAMERATE_MR_15:
			(*plFramerate) = KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_15;
			break;
		case IDR_FRAMERATE_VGA_20:
		case IDR_FRAMERATE_MR_20:
			(*plFramerate) = KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_20;
			break;
		case IDR_FRAMERATE_VGA_24:
		case IDR_FRAMERATE_MR_24:
			(*plFramerate) = KSPROPERTY_PHILIPS_CUSTOM_PROP_FRAMERATE_24;
			break;
	}

	return TRUE;
}

/*-------------------------------------------------------------------------*/
static void PRPPAGE2_EnableControls(
	HWND hDlg,
	BOOL bEnable)
/*-------------------------------------------------------------------------*/
{
	static WORD Controls[] =
	{
		IDR_FRAMERATE_VGA_375,	IDR_FRAMERATE_MR_375,
		IDR_FRAMERATE_VGA_5,	IDR_FRAMERATE_MR_5,
		IDR_FRAMERATE_VGA_75,	IDR_FRAMERATE_MR_75,
		IDR_FRAMERATE_VGA_10,	IDR_FRAMERATE_MR_10,
		IDR_FRAMERATE_MR_12,	IDR_FRAMERATE_VGA_15,
		IDR_FRAMERATE_MR_15,	IDR_FRAMERATE_VGA_20,
		IDR_FRAMERATE_MR_20,	IDR_FRAMERATE_VGA_24,
		IDR_FRAMERATE_MR_24,

		IDS_BRIGHTNESS,			IDS_CONTRAST,	
		IDS_GAMMA,

		IDE_BRIGHTNESS,			IDE_CONTRAST,	
		IDE_GAMMA,

		IDT_BRIGHTNESS,			IDT_CONTRAST,	
		IDT_GAMMA,				IDT_FRAMERATE,
		IDT_IMAGECONTROLS,		IDT_DEFAULTS,
		IDT_UD,					IDT_FD,

		IDC_COLORENABLE,		IDC_BACKLIGHT_COMPENSATION,

		IDB_RESTORE_UD,			IDB_SAVE_UD,
		IDB_RESTORE_FD,

		0
	};
	int i = 0;

	while(Controls[i] != 0)
		EnableWindow(GetDlgItem(hDlg, Controls[i++]), bEnable);
}

/*-------------------------------------------------------------------------*/
static void PRPPAGE2_Handle_Err_Comm(
	HWND hDlg)
/*-------------------------------------------------------------------------*/
{
	char Msg_Err_Comm[132] = "";

	// disable everything
	PRPPAGE2_EnableControls(hDlg, FALSE);

	// load the message text from resource
	LoadString(hInst, IDS_MSG_ERR_COMM, Msg_Err_Comm, 132);

	// notify the user
	MessageBox(hDlg, Msg_Err_Comm,"Error", MB_OK | MB_ICONERROR);
}

/*-------------------------------------------------------------------------*/
static void PRPPAGE2_Handle_Err_Dev_Chg(
	HWND hDlg)
/*-------------------------------------------------------------------------*/
{
	char Msg_Err_Dev_Chg[132] = "";

	// disable everything
	PRPPAGE2_EnableControls(hDlg, FALSE);

	// load the message text from resource
	LoadString(hInst, IDS_MSG_ERR_DEV_CHG, Msg_Err_Dev_Chg, 132);

	// notify the user
	MessageBox(hDlg, Msg_Err_Dev_Chg,"Warning", MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\usbcamd\stream.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   stream.c

Abstract:

    contains all the code that interfaces with the WDM stream class driver.


Environment:

   Kernel mode only


Revision History:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

    Original 3/96 John Dunn
    Updated  3/98 Husni Roukbi

--*/


#define INITGUID
#include "usbcamd.h"


VOID STREAMAPI
AdapterReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
AdapterTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
AdapterCancelPacket(
    PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
USBCAMD_ReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
USBCAMD_ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
AdapterCloseStream(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
AdapterOpenStream(
    PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
AdapterStreamInfo(
    PHW_STREAM_REQUEST_BLOCK Srb
    );


#if DBG
ULONG USBCAMD_HeapCount = 0;
#endif


//////////////////////
// EVENTS
//////////////////////

KSEVENT_ITEM VIDCAPTOSTIItem[] =
{
    {
        KSEVENT_VIDCAPTOSTI_EXT_TRIGGER,
        0,
        0,
        NULL,
        NULL,
        NULL
    }
};

GUID USBCAMD_KSEVENTSETID_VIDCAPTOSTI = {STATIC_KSEVENTSETID_VIDCAPTOSTI};

KSEVENT_SET VIDCAPTOSTIEventSet[] =
{
    {
        &USBCAMD_KSEVENTSETID_VIDCAPTOSTI,
        SIZEOF_ARRAY(VIDCAPTOSTIItem),
        VIDCAPTOSTIItem,
    }
};



//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static GUID Categories[] = {
    STATIC_KSCATEGORY_VIDEO,
    STATIC_PINNAME_VIDEO_STILL,
    STATIC_KSCATEGORY_CAPTURE
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,
    (GUID*) &Categories,
    0,
    NULL,
    0,
    NULL
};

// ------------------------------------------------------------------------
// Property sets for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(VideoStreamDroppedFramesProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DROPPEDFRAMES_CURRENT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinProperty
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};


// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(VideoStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_DROPPEDFRAMES,                // Set
        SIZEOF_ARRAY(VideoStreamDroppedFramesProperties),  // PropertiesCount
        VideoStreamDroppedFramesProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};

#define NUMBER_VIDEO_STREAM_PROPERTIES (SIZEOF_ARRAY(VideoStreamProperties))


NTSTATUS
DllUnload(
          void
)
{
    USBCAMD_KdPrint(MIN_TRACE, ("Unloading USBCAMD\n"));
    return (STATUS_SUCCESS);
}



ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    )
{
    // this function is not used
    return STATUS_SUCCESS;
}


/*
** DriverEntry()
**
** This routine is called when the mini driver is first loaded.  The driver
** should then call the StreamClassRegisterAdapter function to register with
** the stream class driver
**
** Arguments:
**
**  Context1:  The context arguments are private plug and play structures
**             used by the stream class driver to find the resources for this
**             adapter
**  Context2:
**
**      NOTICE if we take the config descriptor and the interface number
**              we can support multiple interafces
**
** Returns:
**
** This routine returns an NT_STATUS value indicating the result of the
** registration attempt. If a value other than STATUS_SUCCESS is returned, the
** minidriver will be unloaded.
**
** Side Effects:  none
*/

ULONG
USBCAMD_DriverEntry(
    PVOID Context1,
    PVOID Context2,
    ULONG DeviceContextSize,
    ULONG FrameContextSize,
    PADAPTER_RECEIVE_PACKET_ROUTINE AdapterReceivePacket
    )
{

    // Hardware Initialization data structure
    HW_INITIALIZATION_DATA hwInitData;

    // Note: all unused fields should be zero

    hwInitData.HwInitializationDataSize = sizeof(hwInitData);

    // Entry points for the mini Driver.

    hwInitData.HwInterrupt = NULL;  // IRQ handling routine

    //
    // data handling routines
    //

    hwInitData.HwReceivePacket = AdapterReceivePacket;
    hwInitData.HwCancelPacket = AdapterCancelPacket;
    hwInitData.HwRequestTimeoutHandler = AdapterTimeoutPacket;

    // Sizes for data structure extensions.  See mpinit.h for definitions

    hwInitData.DeviceExtensionSize = sizeof(USBCAMD_DEVICE_EXTENSION) +
        DeviceContextSize;
    hwInitData.PerRequestExtensionSize = sizeof(USBCAMD_READ_EXTENSION) +
        FrameContextSize;
    hwInitData.FilterInstanceExtensionSize = 0;
    hwInitData.PerStreamExtensionSize = sizeof(USBCAMD_CHANNEL_EXTENSION);

    // We do not use DMA in our driver,
    // since it does not use the hardware directly.

    hwInitData.BusMasterDMA = FALSE;
    hwInitData.Dma24BitAddresses = FALSE;
    hwInitData.DmaBufferSize = 0;
    hwInitData.BufferAlignment = 3;

    // Turn off synchronization - we support re-entrancy.

    hwInitData.TurnOffSynchronization = TRUE;

    //
    // attempt to register with the streaming class driver.  Note, this will
    // result in calls to the HwReceivePacket routine.
    //

    return (StreamClassRegisterAdapter(Context1,
                                       Context2,
                                       &hwInitData));

}


/*
** HwInitialize()
**
**   Initializes an adapter accessed through the information provided in the
**   ConfigInfo structure
**
** Arguments:
**
**   SRB - pointer to the request packet for the initialise command
**
**    ->ConfigInfo - provides the I/O port, memory windows, IRQ, and DMA levels
**                that should be used to access this instance of the device
**
** Returns:
**
**       STATUS_SUCCESS - if the card initializes correctly
**       STATUS_NO_SUCH_DEVICE - or other if the card is not found, or does
**                               not initialize correctly.
**
**
** Side Effects:  none
*/

NTSTATUS
HwInitialize(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PUSBCAMD_DEVICE_DATA DeviceData
    )
{
    int i;
    PPORT_CONFIGURATION_INFORMATION configInfo = Srb->CommandData.ConfigInfo;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension =
        (PUSBCAMD_DEVICE_EXTENSION) configInfo->HwDeviceExtension;
    PDEVICE_OBJECT physicalDeviceObject = configInfo->PhysicalDeviceObject;

#if DBG
    USBCAMD_InitDbg();

    USBCAMD_KdPrint(MIN_TRACE, ("Enter HwInitialize\n"));
#endif

    if (configInfo->NumberOfAccessRanges > 0) {
        TRAP();
        USBCAMD_KdPrint(MIN_TRACE, ("illegal config info"));

        return (STATUS_NO_SUCH_DEVICE);
    }
    // Initialize flags for the device object
    configInfo->ClassDeviceObject->Flags |= DO_DIRECT_IO;
    configInfo->ClassDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // remember the Physical device Object for apis to the
    // usb stack
    //
    deviceExtension->StackDeviceObject = physicalDeviceObject;
    // and our FDO.
    deviceExtension->SCDeviceObject = configInfo->ClassDeviceObject;
    // and our PNP PDO
    deviceExtension->RealPhysicalDeviceObject = configInfo->RealPhysicalDeviceObject;
  #if DBG
    deviceExtension->TimeIncrement = KeQueryTimeIncrement();
  #endif

    InitializeListHead( &deviceExtension->CompletedReadSrbList);
    KeInitializeSemaphore(&deviceExtension->CompletedSrbListSemaphore,0,0x7fffffff);
    
    // In case usbcamd is used with old stream.sys,
    // which has not implemented RealPhysicalDeviceObject.
    if(!deviceExtension->RealPhysicalDeviceObject)
        deviceExtension->RealPhysicalDeviceObject =
                    deviceExtension->StackDeviceObject;

    ASSERT(deviceExtension->StackDeviceObject != 0);
    deviceExtension->IsoThreadObject = NULL;
    deviceExtension->Sig = USBCAMD_EXTENSION_SIG;

    if ( deviceExtension->Usbcamd_version != USBCAMD_VERSION_200) {
        deviceExtension->DeviceDataEx.DeviceData =  *DeviceData;
    }

    // we initialize stream count to 1. USBCAMD_ConfigureDevice will set it to the right
    // number eventually on successfull return.

    deviceExtension->StreamCount = 1; // in this mode we support one stream only.

    for ( i=0; i < MAX_STREAM_COUNT; i++) {
        deviceExtension->ChannelExtension[i] = NULL;
    }

    deviceExtension->CurrentPowerState = PowerDeviceD0;
    deviceExtension->Initialized = DEVICE_INIT_STARTED;

    //
    // Configure the USB device
    //

    ntStatus = USBCAMD_StartDevice(deviceExtension);

    if ( NT_SUCCESS(ntStatus)) {

        //
        // initialize the size of stream descriptor information.
        // we have one stream descriptor, and we attempt to dword align the
        // structure.
        //

        configInfo->StreamDescriptorSize =
            deviceExtension->StreamCount * (sizeof (HW_STREAM_INFORMATION)) + // n stream descriptor
            sizeof (HW_STREAM_HEADER);             // and 1 stream header

        USBCAMD_KdPrint(MAX_TRACE, ("StreamDescriptorSize = %d\n", configInfo->StreamDescriptorSize));

        for ( i=0; i < MAX_STREAM_COUNT; i++ ) {
            InitializeListHead (&deviceExtension->StreamControlSRBList[i]);
            deviceExtension->ProcessingControlSRB[i] = FALSE;
        }

        KeInitializeSpinLock (&deviceExtension->ControlSRBSpinLock);
        KeInitializeSpinLock (&deviceExtension->DispatchSpinLock);
    //    KeInitializeEvent(&deviceExtension->BulkReadSyncEvent,SynchronizationEvent, TRUE);

        deviceExtension->CameraUnplugged = FALSE;
        deviceExtension->Initialized = DEVICE_INIT_COMPLETED;
#if DBG
        deviceExtension->InitCount++;
#endif
        deviceExtension->EventCount = 0;  // initialize event to disable state.

    }
#if DBG
    else {
        USBCAMD_ExitDbg();
    }
#endif

    return (ntStatus);
}

/*
** HwUnInitialize()
**
**   Release all resources and clean up the hardware
**
** Arguments:
**
**      DeviceExtension - pointer to the deviceextension structure for the
**                       the device to be free'd
**
** Returns:
**
** Side Effects:  none
*/

NTSTATUS
HwUnInitialize(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )
{
    ULONG i;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension =
        (PUSBCAMD_DEVICE_EXTENSION) Srb->HwDeviceExtension;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension;

    USBCAMD_KdPrint(MIN_TRACE, ("HwUnintialize\n"));

    //
    // delay the call to remove until every stream is closed
    //
    for ( i=0 ; i < deviceExtension->StreamCount; i++) {
        channelExtension = deviceExtension->ChannelExtension[i];
        if (channelExtension) 
            USBCAMD_CleanupChannel(deviceExtension, channelExtension, i);
    }
    deviceExtension->Initialized = DEVICE_UNINITIALIZED;

    USBCAMD_KdPrint(MIN_TRACE, ("HwUnintialize, remove device\n"));

    USBCAMD_RemoveDevice(deviceExtension);

#if DBG
    deviceExtension->InitCount--;
    ASSERT (deviceExtension->InitCount == 0);

    USBCAMD_ExitDbg();
#endif

    return STATUS_SUCCESS;
}


/*
** AdapterCancelPacket()
**
**   Request to cancel a packet that is currently in process in the minidriver
**
** Arguments:
**
**   Srb - pointer to request packet to cancel
**
** Returns:
**
** Side Effects:  none
*/

VOID
AdapterCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrbToCancel
    )
{
    USBCAMD_KdPrint(MIN_TRACE, ("Request to cancel SRB %x \n", pSrbToCancel));

    USBCAMD_DbgLog(TL_SRB_TRACE, 'lcnC',
        pSrbToCancel,
        0,
        0
        );

    // check  on SRB type : adapter, stream data or control?

    if (pSrbToCancel->Flags & (SRB_HW_FLAGS_DATA_TRANSFER | SRB_HW_FLAGS_STREAM_REQUEST)) {

        PLIST_ENTRY ListEntry;
        BOOL Found= FALSE;
        PUSBCAMD_READ_EXTENSION pSrbExt;
        PUSBCAMD_CHANNEL_EXTENSION channelExtension =
            (PUSBCAMD_CHANNEL_EXTENSION) pSrbToCancel->StreamObject->HwStreamExtension;
        PUSBCAMD_DEVICE_EXTENSION deviceExtension =
            (PUSBCAMD_DEVICE_EXTENSION) pSrbToCancel->HwDeviceExtension;

        //
        // check for data stream SRBs in here.
        //
        if (channelExtension->DataPipeType == UsbdPipeTypeIsochronous) {

            KeAcquireSpinLockAtDpcLevel(&channelExtension->CurrentRequestSpinLock);

            //
            // check and see if the SRB is being processed by the bus stack currently.
            //
            pSrbExt = channelExtension->CurrentRequest;

            if (pSrbExt && pSrbExt->Srb == pSrbToCancel) {

                channelExtension->CurrentRequest = NULL;
                Found = TRUE;
                USBCAMD_KdPrint(MIN_TRACE, ("Current Srb %x is Cancelled\n", pSrbToCancel));
            }
            else {

                //
                // Loop through the circular doubly linked list of pending read SRBs
                // from the beginning to end,trying to find the SRB to cancel
                //
                KeAcquireSpinLockAtDpcLevel(&channelExtension->PendingIoListSpin);

                ListEntry =  channelExtension->PendingIoList.Flink;
                while (ListEntry != &channelExtension->PendingIoList) {

                    pSrbExt = CONTAINING_RECORD(ListEntry, USBCAMD_READ_EXTENSION,ListEntry);
                    if (pSrbExt->Srb == pSrbToCancel) {

                        RemoveEntryList(ListEntry);
                        USBCAMD_KdPrint(MIN_TRACE, ("Queued Srb %x is Cancelled\n", pSrbToCancel));
                        Found = TRUE;

                        break;
                    }
                    ListEntry = ListEntry->Flink;
                }

                KeReleaseSpinLockFromDpcLevel(&channelExtension->PendingIoListSpin);
            }

            KeReleaseSpinLockFromDpcLevel(&channelExtension->CurrentRequestSpinLock);
        }
        else {

            // for Bulk. we need to cancel the pending bulk transfer.
            USBCAMD_CancelOutstandingIrp(deviceExtension,
                                         channelExtension->DataPipe,
                                         FALSE);

            //
            // Loop through the circular doubly linked list of pending read SRBs
            // from the beginning to end,trying to find the SRB to cancel
            //
            KeAcquireSpinLockAtDpcLevel(&channelExtension->PendingIoListSpin);

            ListEntry =  channelExtension->PendingIoList.Flink;
            while (ListEntry != &channelExtension->PendingIoList) {

                pSrbExt = CONTAINING_RECORD(ListEntry, USBCAMD_READ_EXTENSION,ListEntry);
                if (pSrbExt->Srb == pSrbToCancel) {

                    RemoveEntryList(ListEntry);
                    USBCAMD_KdPrint(MIN_TRACE, ("Queued Srb %x is Cancelled\n", pSrbToCancel));
                    Found = TRUE;

                    break;
                }
                ListEntry = ListEntry->Flink;
            }

            KeReleaseSpinLockFromDpcLevel(&channelExtension->PendingIoListSpin);

            // and send a note to the camera driver about the cancellation.
            // send a CamProcessrawFrameEx with null buffer ptr.
            if ( !channelExtension->NoRawProcessingRequired) {

                (*deviceExtension->DeviceDataEx.DeviceData2.CamProcessRawVideoFrameEx)(
                     deviceExtension->StackDeviceObject,
                     USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                     USBCAMD_GET_FRAME_CONTEXT(channelExtension->CurrentRequest),
                     NULL,
                     0,
                     NULL,
                     0,
                     0,
                     NULL,
                     0,
                     pSrbToCancel->StreamObject->StreamNumber);
            }
        }

        if (Found) {

            USBCAMD_CompleteRead(channelExtension, pSrbExt, STATUS_CANCELLED, 0);
        }
        else {

            USBCAMD_KdPrint(MIN_TRACE, ("Srb %x type (%d) for stream # %d was not found\n",
                pSrbToCancel,
                pSrbToCancel->Flags,
                pSrbToCancel->StreamObject->StreamNumber));
        }
    } // end of data stream SRB.
    else {

        USBCAMD_KdPrint(MIN_TRACE, ("Srb %x type (%d) for stream # %d not cancelled\n",
            pSrbToCancel,
            pSrbToCancel->Flags,
            pSrbToCancel->StreamObject->StreamNumber));
    }
}

#ifdef MAX_DEBUG
VOID
USBCAMD_DumpReadQueues(
    PUSBCAMD_DEVICE_EXTENSION deviceExtension
    )
{
    KIRQL oldIrql;
    PLIST_ENTRY ListEntry;
    PUSBCAMD_READ_EXTENSION pSrbExt;
    PHW_STREAM_REQUEST_BLOCK pSrb;
    ULONG i;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension;

//    TEST_TRAP();

    for ( i=0; i < MAX_STREAM_COUNT ; i++) {

        channelExtension = deviceExtension->ChannelExtension[i];

        if ( (!channelExtension ) || (!channelExtension->ImageCaptureStarted)) {
            continue;
        }

        KeAcquireSpinLock(&channelExtension->CurrentRequestSpinLock, &oldIrql);

        if (channelExtension->CurrentRequest != NULL) {
            USBCAMD_KdPrint(MAX_TRACE, ("Stream %d current Srb is %x \n",
                    channelExtension->StreamNumber,
                    channelExtension->CurrentRequest->Srb));
        }
    
        KeAcquireSpinLockAtDpcLevel(&channelExtension->PendingIoListSpin);
        ListEntry =  channelExtension->PendingIoList.Flink;

        while (ListEntry != &channelExtension->PendingIoList) {
            pSrbExt = CONTAINING_RECORD(ListEntry, USBCAMD_READ_EXTENSION,ListEntry);
            pSrb = pSrbExt->Srb;
            USBCAMD_KdPrint(MAX_TRACE, ("Stream %d Queued Srb %x \n",
                                         channelExtension->StreamNumber,
                                         pSrb));
            ListEntry = ListEntry->Flink;
        }
        KeReleaseSpinLockFromDpcLevel(&channelExtension->PendingIoListSpin);

        KeReleaseSpinLock(&channelExtension->CurrentRequestSpinLock, oldIrql);
    }
}

#endif

/*
** AdapterTimeoutPacket()
**
**   This routine is called when a packet has been in the minidriver for
**   too long.  The adapter must decide what to do with the packet.
**   Note: This function is called at DISPATCH_LEVEL
**
** Arguments:
**
**   Srb - pointer to the request packet that timed out
**
** Returns:
**
** Side Effects:  none
*/

VOID
AdapterTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK Srb
    )
{
#if DBG
    // is this a stream data srb?
    if ( !(Srb->Flags & (SRB_HW_FLAGS_DATA_TRANSFER | SRB_HW_FLAGS_STREAM_REQUEST)) ) {

        USBCAMD_KdPrint(MIN_TRACE, ("Timeout in Device Srb %x \n", Srb));
    }
#endif
    Srb->TimeoutCounter = Srb->TimeoutOriginal;
}


/*
** AdapterReceivePacket()
**
**   Main entry point for receiving adapter based request SRBs.  This routine
**   will always be called at High Priority.
**
**   Note: This is an asynchronous entry point.  The request does not complete
**         on return from this function, the request only completes when a
**         StreamClassDeviceNotification on this request block, of type
**         DeviceRequestComplete, is issued.
**
** Arguments:
**
**   Srb - Pointer to the STREAM_REQUEST_BLOCK
**        Srb->HwDeviceExtension - will be the hardware device extension for
**                                 as initialized in HwInitialize
**
** Returns:
**
** Side Effects:  none
*/

PVOID
USBCAMD_AdapterReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PUSBCAMD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT *deviceObject,
    IN BOOLEAN NeedsCompletion
    )
{
    ULONG i;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension =
        (PUSBCAMD_DEVICE_EXTENSION) Srb->HwDeviceExtension;

    //
    // determine the type of packet.
    //

    USBCAMD_KdPrint(MAX_TRACE, ("USBCAMD_ReceivePacket command = %x\n", Srb->Command));

    if (deviceObject) {
        *deviceObject = deviceExtension->StackDeviceObject;
    }

    if (!NeedsCompletion) {
        //
        // the cam driver will handled it, just return
        //
        return USBCAMD_GET_DEVICE_CONTEXT(deviceExtension);
    }

    switch (Srb->Command) {

    case SRB_OPEN_STREAM:

        //
        // this is a request to open a specified stream.
        //

        USBCAMD_KdPrint(MIN_TRACE, ("SRB_OPEN_STREAM\n"));
        AdapterOpenStream(Srb);
        break;

    case SRB_GET_STREAM_INFO:

        //
        // this is a request for the driver to enumerate requested streams
        //

        USBCAMD_KdPrint(MAX_TRACE, ("SRB_GET_STREAM_INFO\n"));
        AdapterStreamInfo(Srb);
        break;

    case SRB_INITIALIZE_DEVICE:

        USBCAMD_KdPrint(MIN_TRACE, ("SRB_INITIALIZE_DEVICE\n"));
        Srb->Status = HwInitialize(Srb, DeviceData);
        break;

    case SRB_INITIALIZATION_COMPLETE:

        // Get a copy of the physical device's capabilities into a
        // DEVICE_CAPABILITIES struct in our device extension;
        // We are most interested in learning which system power states
        // are to be mapped to which device power states for handling
        // IRP_MJ_SET_POWER Irps.

        USBCAMD_QueryCapabilities(deviceExtension);
        Srb->Status = STATUS_SUCCESS;
#if DBG
        //
        // display the device  caps
        //

        USBCAMD_KdPrint( MIN_TRACE,("USBCAMD: Device Power Caps Map:\n"));
        for (i=PowerSystemWorking; i< PowerSystemMaximum; i++)
            USBCAMD_KdPrint( MIN_TRACE,("%s -> %s\n",PnPSystemPowerStateString(i),
                            PnPDevicePowerStateString(deviceExtension->DeviceCapabilities.DeviceState[i] ) ));
#endif
        break;

    case SRB_UNINITIALIZE_DEVICE:

        USBCAMD_KdPrint(MIN_TRACE, ("SRB_UNINITIALIZE_DEVICE\n"));
        Srb->Status = HwUnInitialize(Srb);
        break;

    case SRB_CHANGE_POWER_STATE:
    {
        PIRP irp;
        PIO_STACK_LOCATION ioStackLocation;
        irp = Srb->Irp;
        ioStackLocation = IoGetCurrentIrpStackLocation(irp);

        USBCAMD_KdPrint(MIN_TRACE, ("(%s)\n", PnPPowerString(ioStackLocation->MinorFunction)));
        USBCAMD_KdPrint(MIN_TRACE, ("SRB_CHANGE_POWER_STATE\n"));

        Srb->Status = USBCAMD_SetDevicePowerState(deviceExtension,Srb);
        break;
    }
    case SRB_PAGING_OUT_DRIVER:
        USBCAMD_KdPrint(MAX_TRACE, ("SRB_PAGING_OUT_DRIVER\n"));
        Srb->Status = STATUS_SUCCESS;
        break;

    case SRB_CLOSE_STREAM:

        USBCAMD_KdPrint(MIN_TRACE, ("SRB_CLOSE_STREAM\n"));
        AdapterCloseStream(Srb);
        break;


    case SRB_SURPRISE_REMOVAL:
        //
        // this SRB is available on NT5 only to handle surprise removal.
        // because of that, we need to keep the old code path that handles
        // surprise removal in the timeout handler.
        // In a typical surpirse removal scenario, this SRB will be called before
        // the timeout handler or SRB_UNINITIALIZE_DEVICE. It corresponds to
        // IRP_MN_SURPRISE_REMOVAL PnP IRP.
        //

        // set the camera unplugged flag.
        deviceExtension->CameraUnplugged = TRUE;
        USBCAMD_KdPrint(MIN_TRACE, ("SRB_SURPRISE_REMOVAL\n"));

        for (i=0; i<MAX_STREAM_COUNT;i++) {
            if (deviceExtension->ChannelExtension[i]) {
                PUSBCAMD_CHANNEL_EXTENSION channelExtension;

                channelExtension = deviceExtension->ChannelExtension[i];
                if ( channelExtension->ImageCaptureStarted) {
                    //
                    // stop this channel and cancel all IRPs, SRBs.
                    //
                    USBCAMD_KdPrint(MIN_TRACE,("S#%d stopping.\n", i));
                    USBCAMD_StopChannel(deviceExtension,channelExtension);
                }

                if ( channelExtension->ChannelPrepared) {
                    //
                    // Free memory and bandwidth
                    //
                    USBCAMD_KdPrint(MIN_TRACE,("S#%d unpreparing.\n", i));
		            USBCAMD_UnPrepareChannel(deviceExtension,channelExtension);
                }
            }
        }
        Srb->Status = STATUS_SUCCESS;
        break;

    case SRB_UNKNOWN_DEVICE_COMMAND:

        {
            PIRP irp;
            PIO_STACK_LOCATION ioStackLocation;
            irp = Srb->Irp;
            ioStackLocation = IoGetCurrentIrpStackLocation(irp);
            //
            // we handle Pnp irps for
            // 1) Camera minidrivers sends QI PnP to USBCAMD.
            //
            if ( ioStackLocation->MajorFunction == IRP_MJ_PNP  ) {
               USBCAMD_KdPrint(MIN_TRACE, ("(%s)\n", PnPMinorFunctionString(ioStackLocation->MinorFunction)));
               USBCAMD_PnPHandler(Srb, irp, deviceExtension, ioStackLocation);
            }
            else {
                Srb->Status = STATUS_NOT_IMPLEMENTED;
                USBCAMD_KdPrint(MIN_TRACE, ("SRB_UNKNOWN_DEVICE_COMMAND %x\n", Srb->Command));
            }
        }
        break;

    default:

        USBCAMD_KdPrint(MAX_TRACE, ("Unknown SRB command %x\n", Srb->Command));

        //
        // this is a request that we do not understand.  Indicate invalid
        // command and complete the request
        //

        Srb->Status = STATUS_NOT_IMPLEMENTED;
    }

    //
    // all commands complete synchronously
    //

    StreamClassDeviceNotification(DeviceRequestComplete,
                                  Srb->HwDeviceExtension,
                                  Srb);

    return USBCAMD_GET_DEVICE_CONTEXT(deviceExtension);
}

/*++

Routine Description: handles certain Pnp Irps.

Arguments:
    Srb             - pointer to stream request block
    DeviceExtension    - Pointer to Device Extension.
    ioStacklocation   - ptr to io stack location for this Pnp Irp.

Return Value:
    none.
--*/

VOID
USBCAMD_PnPHandler(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PIRP pIrp,
    IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
    IN PIO_STACK_LOCATION ioStackLocation)
{

    switch (ioStackLocation->MinorFunction ) {
    case IRP_MN_QUERY_INTERFACE:

        if (IsEqualGUID(
                ioStackLocation->Parameters.QueryInterface.InterfaceType,
                &GUID_USBCAMD_INTERFACE) &&
            (ioStackLocation->Parameters.QueryInterface.Size ==
                sizeof( USBCAMD_INTERFACE )) &&
            (ioStackLocation->Parameters.QueryInterface.Version ==
                USBCAMD_VERSION_200 )) {

            PUSBCAMD_INTERFACE UsbcamdInterface;

            UsbcamdInterface =
                (PUSBCAMD_INTERFACE)ioStackLocation->Parameters.QueryInterface.Interface;
            UsbcamdInterface->Interface.Size = sizeof( USBCAMD_INTERFACE );
            UsbcamdInterface->Interface.Version = USBCAMD_VERSION_200;

            UsbcamdInterface->USBCAMD_SetVideoFormat = USBCAMD_SetVideoFormat;
            UsbcamdInterface->USBCAMD_WaitOnDeviceEvent = USBCAMD_WaitOnDeviceEvent;
            UsbcamdInterface->USBCAMD_BulkReadWrite = USBCAMD_BulkReadWrite;
            UsbcamdInterface->USBCAMD_CancelBulkReadWrite = USBCAMD_CancelBulkReadWrite;
            UsbcamdInterface->USBCAMD_SetIsoPipeState = USBCAMD_SetIsoPipeState;
            Srb->Status = pIrp->IoStatus.Status = STATUS_SUCCESS;
            USBCAMD_KdPrint(MIN_TRACE, ("USBCAMD2 QI \n"));

        } else {
            Srb->Status = STATUS_NOT_SUPPORTED; // STATUS_INVALID_PARAMETER_1;
        }
        break;

    default:
        Srb->Status = STATUS_NOT_IMPLEMENTED;
        USBCAMD_KdPrint(MAX_TRACE,("USBCAMD: Stream class did not translate IRP_MJ = 0x%x IRP_MN = 0x%x\n",
                    ioStackLocation->MajorFunction,
                    ioStackLocation->MinorFunction));
        break;
    }
}



/*++

Routine Description:

Arguments:

Note: in order to save one buffer copy. set CamProcessRawStill to NULL
    if still data is VGA or decompression occur in ring 3.

Return:
    Nothing.

--*/


ULONG
USBCAMD_InitializeNewInterface(
    IN PVOID DeviceContext,
    IN PVOID DeviceData,
    IN ULONG Version,
    IN ULONG CamControlFlag
    )
{
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;

    deviceExtension = USBCAMD_GET_DEVICE_EXTENSION(DeviceContext);
    if (Version == USBCAMD_VERSION_200 ) {
        deviceExtension->DeviceDataEx.DeviceData2 = *((PUSBCAMD_DEVICE_DATA2) DeviceData);
        deviceExtension->Usbcamd_version = USBCAMD_VERSION_200;
        deviceExtension->CamControlFlag = CamControlFlag;
    }
    return USBCAMD_VERSION_200;
}


NTSTATUS
USBCAMD_SetIsoPipeState(
    IN PVOID DeviceContext,
    IN ULONG PipeStateFlags
    )
{
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension;
    PEVENTWAIT_WORKITEM workitem;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // we only do this for ISO streams on the video pin.
    //

    USBCAMD_KdPrint ( MIN_TRACE, ("%s\n",PipeStateFlags ? "StopIsoStream":"StartIsoStream"));

    deviceExtension = USBCAMD_GET_DEVICE_EXTENSION(DeviceContext);
    channelExtension = deviceExtension->ChannelExtension[STREAM_Capture];

    if (channelExtension == NULL) {
        // Video open is not open for business yet.
        USBCAMD_KdPrint (MIN_TRACE, ("stop before open \n"));
        ntStatus = STATUS_SUCCESS;
        return ntStatus;
    }

    if ( !(channelExtension->IdleIsoStream ^ PipeStateFlags) ){
        USBCAMD_KdPrint ( MIN_TRACE, ("Requested iso stream state is same as previous.\n"));
        ntStatus = STATUS_INVALID_PARAMETER;
        return ntStatus;
    }

    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        //
        // we are at passive level, just do the command
        //
        USBCAMD_ProcessSetIsoPipeState(deviceExtension,
                                                  channelExtension,
                                                  PipeStateFlags);

    } else {

//        TEST_TRAP();
        USBCAMD_KdPrint(MIN_TRACE, ("Calling SetIsoPipeState from Dispatch level\n"));

        //
        // schedule a work item
        //
        ntStatus = STATUS_PENDING;

        workitem = USBCAMD_ExAllocatePool(NonPagedPool,
                                          sizeof(EVENTWAIT_WORKITEM));
        if (workitem) {

            ExInitializeWorkItem(&workitem->WorkItem,
                                 USBCAMD_SetIsoPipeWorkItem,
                                 workitem);

            workitem->DeviceExtension = deviceExtension;
            workitem->ChannelExtension = channelExtension;
            workitem->Flag = PipeStateFlags;

            ExQueueWorkItem(&workitem->WorkItem,
                            DelayedWorkQueue);

        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return ntStatus;
}

/*++

Routine Description:


Arguments:

Return Value:

    None.

--*/
VOID
USBCAMD_SetIsoPipeWorkItem(
    PVOID Context
    )
{
    PEVENTWAIT_WORKITEM workItem = Context;

    USBCAMD_ProcessSetIsoPipeState(workItem->DeviceExtension,
                                              workItem->ChannelExtension,
                                              workItem->Flag);
    USBCAMD_ExFreePool(workItem);
}

/*++

Routine Description:


Arguments:

Return Value:

    None.

--*/
VOID
USBCAMD_ProcessSetIsoPipeState(
    PUSBCAMD_DEVICE_EXTENSION deviceExtension,
    PUSBCAMD_CHANNEL_EXTENSION channelExtension,
    ULONG Flag
    )
{
    ULONG portStatus;
    ULONG ntStatus = STATUS_SUCCESS;

    if ( Flag == USBCAMD_STOP_STREAM ) {
        // time to idle the iso pipe.
        channelExtension->IdleIsoStream = TRUE;
        // save the max. pkt size of the current alt. interface.
        deviceExtension->currentMaxPkt =
            deviceExtension->Interface->Pipes[channelExtension->DataPipe].MaximumPacketSize;
        ntStatus = USBCAMD_StopChannel(deviceExtension,channelExtension);
    }
    else {

        USBCAMD_ClearIdleLock(&channelExtension->IdleLock);
        channelExtension->IdleIsoStream = FALSE;
       // channelExtension->ImageCaptureStarted = TRUE;
        //
        // Check the port state, if it is disabled we will need
        // to re-enable it
        //
        ntStatus = USBCAMD_GetPortStatus(deviceExtension,channelExtension, &portStatus);

        if (NT_SUCCESS(ntStatus) && !(portStatus & USBD_PORT_ENABLED)) {
        //
        // port is disabled, attempt reset
        //
            ntStatus = USBCAMD_EnablePort(deviceExtension);
            if (!NT_SUCCESS(ntStatus) ) {
                USBCAMD_KdPrint (MIN_TRACE, ("Failed to Enable usb port(0x%X)\n",ntStatus ));
                TEST_TRAP();
                return ;
            }
        }

        //
        // check if camera mini driver has requested a change for alt. interface
        // while iso pipe is stopped.
        //
        if (deviceExtension->currentMaxPkt !=
            deviceExtension->Interface->Pipes[channelExtension->DataPipe].MaximumPacketSize) {
            // CAMERA MINIDRIVER HAS CHANGED THE ALT. INTERFACE. we have to tear
            // down the ISO pipe and start over.
            TEST_TRAP();
        }


        ntStatus = USBCAMD_ResetPipes(deviceExtension,
                                      channelExtension,
                                      deviceExtension->Interface,
                                      FALSE);


        if (deviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {

            // send hardware stop and re-start
            if (NT_SUCCESS(ntStatus)) {
                ntStatus = (*deviceExtension->DeviceDataEx.DeviceData2.CamStopCaptureEx)(
                            deviceExtension->StackDeviceObject,
                            USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                            STREAM_Capture);
            }

            if (NT_SUCCESS(ntStatus)) {
                ntStatus = (*deviceExtension->DeviceDataEx.DeviceData2.CamStartCaptureEx)(
                            deviceExtension->StackDeviceObject,
                            USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                            STREAM_Capture);
            }
        }
        else {
            // send hardware stop and re-start
            if (NT_SUCCESS(ntStatus)) {
                ntStatus = (*deviceExtension->DeviceDataEx.DeviceData.CamStopCapture)(
                            deviceExtension->StackDeviceObject,
                            USBCAMD_GET_DEVICE_CONTEXT(deviceExtension));
            }

            if (NT_SUCCESS(ntStatus)) {
                ntStatus = (*deviceExtension->DeviceDataEx.DeviceData.CamStartCapture)(
                            deviceExtension->StackDeviceObject,
                            USBCAMD_GET_DEVICE_CONTEXT(deviceExtension));
            }

        }

        channelExtension->SyncPipe = deviceExtension->SyncPipe;
        channelExtension->DataPipe = deviceExtension->DataPipe;
        channelExtension->DataPipeType = UsbdPipeTypeIsochronous;

        ntStatus = USBCAMD_StartIsoStream(deviceExtension, channelExtension);
    }
#if DBG
    if (ntStatus != STATUS_SUCCESS)
        USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_ProcessSetIsoPipeState exit (0x%X)\n",ntStatus ));
#endif
//    TRAP_ERROR(ntStatus);
}



/*
** AdapterStreamInfo()
**
**   Returns the information of all streams that are supported by the
**   mini-driver
**
** Arguments:
**
**   Srb - Pointer to the STREAM_REQUEST_BLOCK
**        Srb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/

VOID
AdapterStreamInfo(
    PHW_STREAM_REQUEST_BLOCK Srb
    )
{
    ULONG i;
    //
    // pick up the pointer to the stream information data structures array.
    //

    PHW_STREAM_INFORMATION streamInformation =
       (PHW_STREAM_INFORMATION) &(Srb->CommandData.StreamBuffer->StreamInfo);

    PHW_STREAM_HEADER streamHeader =
        (PHW_STREAM_HEADER) &(Srb->CommandData.StreamBuffer->StreamHeader);

    PUSBCAMD_DEVICE_EXTENSION deviceExtension =
        (PUSBCAMD_DEVICE_EXTENSION) Srb->HwDeviceExtension;

    USBCAMD_KdPrint(MAX_TRACE, ("AdapterStreamInfo\n"));

    //
    // set number of streams
    //

    ASSERT (Srb->NumberOfBytesToTransfer >=
            sizeof (HW_STREAM_HEADER) +
            deviceExtension->StreamCount * sizeof (HW_STREAM_INFORMATION));

    //
    // initialize stream header
    //

    streamHeader->SizeOfHwStreamInformation = sizeof(HW_STREAM_INFORMATION);
    streamHeader->NumberOfStreams = deviceExtension->StreamCount;

    //
    // store a pointer to the topology for the device
    //

    streamHeader->Topology = &Topology;

//#if VIDCAP_TO_STI

    // expose device event table if Camera minidriver indicated so.
    // this event table will notify STI stack when a snapshot button is pressed on the camera.
    //
    if (deviceExtension->CamControlFlag & USBCAMD_CamControlFlag_EnableDeviceEvents) {
        streamHeader->NumDevEventArrayEntries = SIZEOF_ARRAY(VIDCAPTOSTIEventSet);
        streamHeader->DeviceEventsArray = VIDCAPTOSTIEventSet;
        streamHeader->DeviceEventRoutine = USBCAMD_DeviceEventProc;
    }

//#endif

    //
    // initialize the stream information array
    //
    // The NumberOfInstances field indicates the number of concurrent
    // streams of this type the device can support.
    //
    for ( i=0; i < deviceExtension->StreamCount; i++) {

        streamInformation[i].NumberOfPossibleInstances = 1;

        //
        // indicates the direction of data flow for this stream, relative to the
        // driver
        //

        streamInformation[i].DataFlow = KSPIN_DATAFLOW_OUT;

        //
        // dataAccessible - Indicates whether the data is "seen" by the host
        // processor.
        //

        streamInformation[i].DataAccessible = TRUE;

        //
        // indicate the pin name and category.
        //

        streamInformation[i].Name = (i == STREAM_Capture) ? (GUID *)&PINNAME_VIDEO_CAPTURE:
                                                            (GUID *)&PINNAME_VIDEO_STILL;
        streamInformation[i].Category = streamInformation[i].Name;

        streamInformation[i].StreamPropertiesArray =
                 (PKSPROPERTY_SET) VideoStreamProperties;
        streamInformation[i].NumStreamPropArrayEntries = NUMBER_VIDEO_STREAM_PROPERTIES;

    }


    //
    // indicate success
    //

    Srb->Status = STATUS_SUCCESS;
}

/*
** MultiplyCheckOverflow()
**
**   Perform a 32-bit unsigned multiplication with status indicating whether overflow occured.
**
** Arguments:
**
**   a - first operand
**   b - second operand
**   pab - result
**
** Returns:
**
**   TRUE - no overflow
**   FALSE - overflow occurred
**
*/

BOOL
MultiplyCheckOverflow(
    ULONG a,
    ULONG b,
    ULONG *pab
    )
{
    *pab = a * b;
    if ((a == 0) || (((*pab) / a) == b)) {
        return TRUE;
    }
    return FALSE;
}

/*
** CalculateImageSize()
**
**   Validate the image size and dimension parameters of a KS VideoInfoHeader
**   (the equivalent of using the KS_DIBSIZE macro)
**
** Arguments:
**
**   pVideoInfoHdr - pointer to a KS_VIDEOINFOHEADER
**   pImageSize - pointer to a ULONG to receive the calculated image size
**
** Returns:
**
**   STATUS_SUCCESS - Calculation succeeded
**   STATUS_INVALID_PARAMETER - the VIDEOINFOHEADER is in error
*/
NTSTATUS
CalculateImageSize(PKS_VIDEOINFOHEADER pVideoInfoHdr, PULONG pImageSize)
{
    if (!MultiplyCheckOverflow(
        (ULONG)pVideoInfoHdr->bmiHeader.biWidth,
        (ULONG)pVideoInfoHdr->bmiHeader.biBitCount,
        pImageSize
        )) {

        return STATUS_INVALID_PARAMETER;
    }

    // Convert bits to an even multiple of 4 bytes
    *pImageSize = ((*pImageSize / 8) + 3) & ~3;

    // Now calculate the full size
    if (!MultiplyCheckOverflow(
        *pImageSize,
        (ULONG)abs(pVideoInfoHdr->bmiHeader.biHeight),
        pImageSize
        )) {

        return STATUS_INVALID_PARAMETER;
    }

    // Finally, is the specified image size correct?
    if (pVideoInfoHdr->bmiHeader.biSizeImage != *pImageSize) {

        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

/*
** AdapterOpenStream()
**
**   This routine is called when an OpenStream SRB request is received
**
** Arguments:
**
**   Srb - pointer to stream request block for the Open command
**
** Returns:
**
** Side Effects:  none
*/

VOID
AdapterOpenStream(
    IN PHW_STREAM_REQUEST_BLOCK Srb)
{
    ULONG  StreamNumber = Srb->StreamObject->StreamNumber;

    //
    // the stream extension structure is allocated by the stream class driver
    //

    PUSBCAMD_CHANNEL_EXTENSION channelExtension =
        (PUSBCAMD_CHANNEL_EXTENSION) Srb->StreamObject->HwStreamExtension;


    PUSBCAMD_DEVICE_EXTENSION deviceExtension =
        (PUSBCAMD_DEVICE_EXTENSION) Srb->HwDeviceExtension;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG videoHeaderSize;
    ULONG formatSize;
    ULONG imageSize;
    PKS_DATAFORMAT_VIDEOINFOHEADER  pKSDataFormat =
                (PKS_DATAFORMAT_VIDEOINFOHEADER) Srb->CommandData.OpenFormat;
    PKS_VIDEOINFOHEADER  pVideoInfoHdrRequested;
    PKS_VIDEOINFOHEADER  VideoPinInfoHeader;

    USBCAMD_KdPrint(MAX_TRACE, ("Request to open stream %d \n",StreamNumber));

    USBCAMD_DbgLog(TL_CHN_TRACE|TL_PRF_TRACE, '+npo', StreamNumber, USBCAMD_StartClock(), status);

    ASSERT(channelExtension);

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //

    if (StreamNumber >= deviceExtension->StreamCount ) {
        Srb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    //
    // Check that we haven't exceeded the instance count for this stream
    //

    if (deviceExtension->ActualInstances[StreamNumber] >= MAX_STREAM_INSTANCES ){
        Srb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    //
    // Check that the format buffer is large enough to validate
    //

    if (pKSDataFormat->DataFormat.FormatSize < sizeof(KS_DATAFORMAT_VIDEOINFOHEADER))
    {
        Srb->Status = STATUS_INVALID_BUFFER_SIZE;
        return;
    }

    pVideoInfoHdrRequested = &pKSDataFormat->VideoInfoHeader;

    // Calculate the actual format buffer size (includes bmiHeader.biSize).
    // Validate each step of the size calculations for arithmetic overflow,
    // and verify that the specified sizes correlate
    // (with unsigned math, a+b < b iff an arithmetic overflow occured).
    videoHeaderSize = pVideoInfoHdrRequested->bmiHeader.biSize +
        FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader);
    formatSize = videoHeaderSize +
        FIELD_OFFSET(KS_DATAFORMAT_VIDEOINFOHEADER,VideoInfoHeader);

    if (videoHeaderSize < FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader) ||
        formatSize < FIELD_OFFSET(KS_DATAFORMAT_VIDEOINFOHEADER,VideoInfoHeader) ||
        formatSize > pKSDataFormat->DataFormat.FormatSize) {

        Srb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    // Validate the image size and dimension parameters
    // (the equivalent of using the KS_DIBSIZE macro)
    if (!NT_SUCCESS(CalculateImageSize(pVideoInfoHdrRequested, &imageSize)) ||
        pKSDataFormat->DataFormat.SampleSize < imageSize) {

        Srb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    //
    // check to see if the request is to open a still virtual pin.
    // VirtualStillPin Rules;
    // 1) you can't open virtual still pin till after you open the streaming pin.
    // 2) you can't start virtual still pin till after starting the streaming pin.
    // 3) you can stop virtual still pin w/o stopping the stream pin.
    // 4) you can close virtual still pin w/o closing the streaming pin.
    // 5) you can close capture pin w/o closing virtual still pin. however, you can only manipulate
    //    still pin properties then but can't change pin streaming state.
    //

    if ((StreamNumber == STREAM_Still) &&  (deviceExtension->VirtualStillPin)) {
        channelExtension->VirtualStillPin = TRUE;
        // video stream has to be open before we can succeed this still open.
        if (deviceExtension->ChannelExtension[STREAM_Capture] == NULL) {
            Srb->Status = STATUS_INVALID_PARAMETER;
            return;
        }
        if (deviceExtension->CamControlFlag & USBCAMD_CamControlFlag_AssociatedFormat) {
            ULONG nSize;
            //
            // if still pin is just an instance frame from the video pin, then still
            // pin has to open with the same format as video.
            //
            nSize = pVideoInfoHdrRequested->bmiHeader.biSize;
            VideoPinInfoHeader = deviceExtension->ChannelExtension[STREAM_Capture]->VideoInfoHeader;
            if (RtlCompareMemory (&pVideoInfoHdrRequested->bmiHeader,
                                  &VideoPinInfoHeader->bmiHeader,nSize) != nSize) {
                Srb->Status = STATUS_INVALID_PARAMETER;
                return;
            }
        }
    }
    else {
        channelExtension->VirtualStillPin = FALSE;
    }


    //
    // determine which stream number is being opened.  This number indicates
    // the offset into the array of streaminfo structures that was filled out
    // in the AdapterStreamInfo call.
    //

    channelExtension->StreamNumber = (UCHAR) StreamNumber;

    // save the channel extension for remove
    deviceExtension->ChannelExtension[StreamNumber] = channelExtension;

    channelExtension->NoRawProcessingRequired = (UCHAR) ((deviceExtension->CamControlFlag >> StreamNumber) & CAMCONTROL_FLAG_MASK );


    status = USBCAMD_OpenChannel(deviceExtension,
                                 channelExtension,
                                 Srb->CommandData.OpenFormat);

    if (NT_SUCCESS(status)) {

        //
        // this gets the bandwidth and memory we will need
        // for iso video streaming.
        //
        status = USBCAMD_PrepareChannel(deviceExtension,
                                        channelExtension);
    }

    // Check for valid framerate
    if (pVideoInfoHdrRequested->AvgTimePerFrame == 0) {
        USBCAMD_KdPrint(MAX_TRACE, ("WARNING: Zero AvgTimePerFrame \n"));
        Srb->Status = STATUS_INVALID_PARAMETER;
        return;
    }
    

    if (NT_SUCCESS(status)) {

        //
        // srb has been to the mini driver
        //
        // save their routines

        channelExtension->CamReceiveDataPacket = (PSTREAM_RECEIVE_PACKET)
            Srb->StreamObject->ReceiveDataPacket;
        channelExtension->CamReceiveCtrlPacket = (PSTREAM_RECEIVE_PACKET)
            Srb->StreamObject->ReceiveControlPacket;
        Srb->StreamObject->ReceiveDataPacket = (PVOID) USBCAMD_ReceiveDataPacket;
        Srb->StreamObject->ReceiveControlPacket = (PVOID) USBCAMD_ReceiveCtrlPacket;
        channelExtension->KSState = KSSTATE_STOP;

        Srb->StreamObject->HwClockObject.HwClockFunction = NULL;
        Srb->StreamObject->HwClockObject.ClockSupportFlags = 0;

        channelExtension->VideoInfoHeader =
            USBCAMD_ExAllocatePool(NonPagedPool, videoHeaderSize);

        if (channelExtension->VideoInfoHeader == NULL) {
            Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
            return;
        }

        deviceExtension->ActualInstances[StreamNumber]++;

        // Copy the VIDEOINFOHEADER requested to our storage
        RtlCopyMemory(
                channelExtension->VideoInfoHeader,
                pVideoInfoHdrRequested,
                videoHeaderSize);


        USBCAMD_KdPrint(MIN_TRACE, ("USBCAMD: VideoInfoHdrRequested for stream %d\n", StreamNumber));
        USBCAMD_KdPrint(MIN_TRACE, ("Width=%d  Height=%d  FrameTime (ms)= %d\n",
                                    pVideoInfoHdrRequested->bmiHeader.biWidth,
                                    pVideoInfoHdrRequested->bmiHeader.biHeight,
                                    pVideoInfoHdrRequested->AvgTimePerFrame/10000));

        // We don't use DMA.

        Srb->StreamObject->Dma = FALSE;
        Srb->StreamObject->StreamHeaderMediaSpecific = sizeof(KS_FRAME_INFO);

        //
        // The PIO flag must be set when the mini driver will be accessing the
        // data
        // buffers passed in using logical addressing
        //
#if 0
        Srb->StreamObject->Pio = FALSE;
#else
        Srb->StreamObject->Pio = TRUE;
#endif
    }
    else {
        USBCAMD_KdPrint(MIN_TRACE, ("AdapterOpenStream failed for stream %d\n", StreamNumber));
        // Reset channel extension in the device ext. for this stream.
        deviceExtension->ChannelExtension[StreamNumber] = NULL;
        status = STATUS_INVALID_PARAMETER;
    }

    Srb->Status = status;

    USBCAMD_DbgLog(TL_CHN_TRACE|TL_PRF_TRACE, '-npo', StreamNumber, USBCAMD_StopClock(), status);
}

/*
** AdapterCloseStream()
**
**   Close the requested data stream
**
** Arguments:
**
**   Srb the request block requesting to close the stream
**
** Returns:
**
** Side Effects:  none
*/

VOID
AdapterCloseStream(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )
{
    ULONG  StreamNumber = Srb->StreamObject->StreamNumber;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension =
        (PUSBCAMD_CHANNEL_EXTENSION) Srb->StreamObject->HwStreamExtension;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension =
        (PUSBCAMD_DEVICE_EXTENSION) Srb->HwDeviceExtension;

    USBCAMD_KdPrint(MIN_TRACE, ("AdapterCloseStream # %d\n", StreamNumber));

    Srb->Status = STATUS_SUCCESS;   // Not permitted to fail

    USBCAMD_DbgLog(TL_CHN_TRACE, '+slc', StreamNumber, 0, 0);

    if (StreamNumber >= deviceExtension->StreamCount ) {
        USBCAMD_DbgLog(TL_CHN_TRACE, '-slc', StreamNumber, 0, 0);
        return;
    }

    ASSERT_CHANNEL(channelExtension);

    USBCAMD_CleanupChannel(deviceExtension, channelExtension, StreamNumber);

    USBCAMD_DbgLog(TL_CHN_TRACE, '-slc', StreamNumber, 0, 0);
}


NTSTATUS 
USBCAMD_CleanupChannel(
    IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION channelExtension,
    IN ULONG StreamNumber
    )
{
    NTSTATUS status;

    if (!deviceExtension || !channelExtension) {
        ASSERT(0);
        return STATUS_INVALID_PARAMETER;
    }

    if (deviceExtension->ChannelExtension[StreamNumber]) {

        ASSERT(deviceExtension->ChannelExtension[StreamNumber] == channelExtension);

        //
        // stop streaming capture
        //
        if (channelExtension->ImageCaptureStarted) {
        //        TEST_TRAP();
            USBCAMD_StopChannel(deviceExtension,
                                channelExtension);
        }

        if (channelExtension->ChannelPrepared) {
            //
            // Free memory and bandwidth
            //
            USBCAMD_UnPrepareChannel(deviceExtension,
                                     channelExtension);
        }

        status = USBCAMD_CloseChannel(deviceExtension, channelExtension);

        if (channelExtension->VideoInfoHeader) {
            USBCAMD_ExFreePool(channelExtension->VideoInfoHeader);
            channelExtension->VideoInfoHeader = NULL;
        }

        //
        // we no longer have a channel
        //
        deviceExtension->ChannelExtension[StreamNumber] = NULL;
    }

    return status;
}


VOID STREAMAPI
USBCAMD_ReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )
{
    ULONG StreamNumber;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension =
        (PUSBCAMD_DEVICE_EXTENSION) Srb->HwDeviceExtension;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension =
        (PUSBCAMD_CHANNEL_EXTENSION) Srb->StreamObject->HwStreamExtension;
    PUSBCAMD_READ_EXTENSION readExtension =
        (PUSBCAMD_READ_EXTENSION) Srb->SRBExtension;
    BOOLEAN completedByCam = FALSE;
    PKSSTREAM_HEADER streamHeader;

    StreamNumber = channelExtension->StreamNumber;
    if ( StreamNumber != Srb->StreamObject->StreamNumber ) {
        TEST_TRAP();
    }

    USBCAMD_KdPrint(ULTRA_TRACE, ("USBCAMD_ReceiveDataPacket on stream %d\n",StreamNumber));

    USBCAMD_DbgLog(TL_SRB_TRACE, '+brS',
        Srb,
        Srb->Command,
        0
        );

    //
    // call the cam driver first
    //
    if (channelExtension->CamReceiveDataPacket) {
        (*channelExtension->CamReceiveDataPacket)(
            Srb,
            USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
            &completedByCam);
    }

    if (completedByCam == TRUE) {

        USBCAMD_DbgLog(TL_SRB_TRACE, '-brS',
            Srb,
            Srb->Command,
            Srb->Status
            );

        return;
    }

    switch (Srb->Command) {
    case SRB_READ_DATA:

        if (!deviceExtension->CameraUnplugged) {

            PKSSTREAM_HEADER dataPacket = Srb->CommandData.DataBufferArray;

            dataPacket->PresentationTime.Numerator = 1;
            dataPacket->PresentationTime.Denominator = 1;
            dataPacket->PresentationTime.Time = 0;
            dataPacket->Duration = channelExtension->VideoInfoHeader->AvgTimePerFrame;
            dataPacket->DataUsed = 0;

            // Attempt to lock out the idle state (will be released before leaving)
            if (NT_SUCCESS(USBCAMD_AcquireIdleLock(&channelExtension->IdleLock))) {

                if (channelExtension->KSState != KSSTATE_STOP) {

                    // initialize the SRB extension

                    readExtension->Srb = (PVOID) Srb;
                    readExtension->Sig = USBCAMD_READ_SIG;

                    // Queue the read to the camera driver
                    // This request will be completed asynchronously...

                    USBCAMD_KdPrint(MAX_TRACE, ("READ SRB (%d)\n",StreamNumber));

                    // make sure that the buffer passed down from DirectShow is Bigger or equal the one
                    // in biSizeImage associated with open stream. This only apply to the video pin.

                    streamHeader = ((PHW_STREAM_REQUEST_BLOCK) Srb)->CommandData.DataBufferArray;


                    if ((streamHeader->FrameExtent >= channelExtension->VideoInfoHeader->bmiHeader.biSizeImage) ||
                        (StreamNumber != STREAM_Capture)) {

                        if( StreamNumber == STREAM_Capture ) {
                            // video srbs timeout in less time than 15 sec. default.
                            Srb->TimeoutCounter = Srb->TimeoutOriginal = STREAM_CAPTURE_TIMEOUT;
                        }
                        else {
                            // we timeout the still read request every 30 secs.
                            Srb->TimeoutCounter = Srb->TimeoutOriginal = STREAM_STILL_TIMEOUT;
                        }

                        // Note: SRB cannot be touched after this is called
                        // It may already be freed if read operation completed
                        USBCAMD_ReadChannel(deviceExtension,
                                            channelExtension,
                                            readExtension);
                    }
                    else {
                       Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
                       USBCAMD_KdPrint(MIN_TRACE, ("Frame buffer (%d)< biSizeImage (%d)\n",
                                     streamHeader->FrameExtent,
                                     channelExtension->VideoInfoHeader->bmiHeader.biSizeImage ));
                       COMPLETE_STREAM_READ(Srb);
                    }
                }
                else {

                    // Stream not started, return immediately
                    Srb->Status = STATUS_SUCCESS;
                    COMPLETE_STREAM_READ(Srb);
                }

                USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
            }
            else {

                // Stream being stopped, return immediately
                Srb->Status = STATUS_SUCCESS;
                COMPLETE_STREAM_READ(Srb);
            }
        }
        else {
            // camera is unplugged, complete read with error.
            Srb->Status = STATUS_CANCELLED;
            COMPLETE_STREAM_READ(Srb);
        }

        break;

    case SRB_WRITE_DATA:
        {
        ULONG i, PipeIndex, BufferLength;
        BOOLEAN found = FALSE;
        PVOID pBuffer;
        //
        // we will handle SRB write in order to let an app sends a bulk out request for
        // the driver if needed. USBCAMD_BulkReadWrite() should be used instead from kernel
        // level.
        //

        for ( i=0, PipeIndex =0; i < deviceExtension->Interface->NumberOfPipes; i++ ) {
            // find the bulk-out pipe if any.
            if (( deviceExtension->PipePinRelations[i].PipeDirection == OUTPUT_PIPE) &&
                ( deviceExtension->PipePinRelations[i].PipeType == UsbdPipeTypeBulk) ) {
                PipeIndex = i;
                found = TRUE;
                break;
            }
        }

        if (found  && (StreamNumber == STREAM_Still) ) {

            // we only allow bulk out transfer on a still pin.
            TEST_TRAP();
            readExtension->Srb = (PVOID) Srb;
            readExtension->Sig = USBCAMD_READ_SIG;
            streamHeader = ((PHW_STREAM_REQUEST_BLOCK) Srb)->CommandData.DataBufferArray;

            pBuffer = streamHeader->Data;
            ASSERT(pBuffer != NULL);
            BufferLength = readExtension->ActualRawFrameLen = streamHeader->DataUsed;

            if ( (pBuffer == NULL) || (BufferLength == 0) ) {
                Srb->Status = STATUS_INVALID_PARAMETER;
                COMPLETE_STREAM_READ(Srb);
                return;
            }

            USBCAMD_KdPrint(MIN_TRACE, ("Write Srb : buf= %X, len = %x\n",
                                pBuffer, BufferLength));

            // inform camera driver that we are ready to start a bulk transfer.

            (*deviceExtension->DeviceDataEx.DeviceData2.CamNewVideoFrameEx)
                                        (USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                                         USBCAMD_GET_FRAME_CONTEXT(readExtension),
                                         StreamNumber,
                                         &readExtension->ActualRawFrameLen);


            Srb->Status = USBCAMD_IntOrBulkTransfer(deviceExtension,
                                                 NULL,
                                                 pBuffer,
                                                 BufferLength,
                                                 PipeIndex,
                                                 USBCAMD_BulkOutComplete,
                                                 readExtension,
                                                 0,
                                                 BULK_TRANSFER);
        }
        else {
            Srb->Status = STATUS_NOT_IMPLEMENTED;
            COMPLETE_STREAM_READ(Srb);
        }
        }
        break;

    default:

        Srb->Status = STATUS_NOT_IMPLEMENTED;
        COMPLETE_STREAM_READ(Srb);
    }
}

/*
** USBCAMD_BulkOutComplete()
**
**    Routine to complete a write SRB.
**
** Arguments:
**
**    DeviceEontext - pointer to the device extension.
**
**    Context - pointer to SRB
**
**
**    ntStatus - status return
**
** Returns:
**
** Side Effects:  none
*/


NTSTATUS
USBCAMD_BulkOutComplete(
    PVOID DeviceContext,
    PVOID Context,
    NTSTATUS ntStatus
    )
{

    PUSBCAMD_READ_EXTENSION readExtension =
        (PUSBCAMD_READ_EXTENSION) Context;
    PHW_STREAM_REQUEST_BLOCK srb = readExtension->Srb;

    srb->Status = ntStatus;
    USBCAMD_KdPrint(MIN_TRACE, ("Write Srb %x is completed, status = %x\n",
                                srb, srb->Status));
    COMPLETE_STREAM_READ(srb);
    return ntStatus;
}




/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    Srb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID VideoGetProperty(PHW_STREAM_REQUEST_BLOCK Srb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension =
        Srb->StreamObject->HwStreamExtension;
    ULONG StreamNumber = channelExtension->StreamNumber;

    pSPD = Srb->CommandData.PropertyInfo;

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set)) {
        VideoStreamGetConnectionProperty (Srb);
    }
    else if (IsEqualGUID (&PROPSETID_VIDCAP_DROPPEDFRAMES, &pSPD->Property->Set)) {
        if (StreamNumber == STREAM_Capture) {
            VideoStreamGetDroppedFramesProperty (Srb);
        }
        else {
          Srb->Status = STATUS_NOT_IMPLEMENTED;
        }
    }
    else {
       Srb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** VideoStreamGetConnectionProperty()
**
**    Reports Frame size for the allocater.
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID VideoStreamGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK Srb
    )
{
    PUSBCAMD_CHANNEL_EXTENSION channelExtension =
        Srb->StreamObject->HwStreamExtension;
    ULONG StreamNumber = channelExtension->StreamNumber;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = Srb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

    case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        if (channelExtension->VideoInfoHeader) {
            PKSALLOCATOR_FRAMING Framing =
                (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

            Framing->RequirementsFlags =
                KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
            Framing->PoolType = PagedPool;
            // allocate one frame per still pin only.
            Framing->Frames = (StreamNumber == STREAM_Capture) ? 5:2;
            Framing->FrameSize =
                channelExtension->VideoInfoHeader->bmiHeader.biSizeImage;

             USBCAMD_KdPrint(ULTRA_TRACE,
                ("'KSPROPERTY_CONNECTION_ALLOCATORFRAMING (%d)\n",
                     Framing->FrameSize));

            Framing->FileAlignment = 0; // FILE_BYTE_ALIGNMENT;
            Framing->Reserved = 0;
            Srb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);
            Srb->Status = STATUS_SUCCESS;
        } else {
            Srb->Status = STATUS_INVALID_PARAMETER;
        }
        break;

    default:
//        TEST_TRAP();
        break;
    }
}

/*
** VideoStreamGetDroppedFramesProperty()
**
**    Reports the number of dropped frmaes since START.
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoStreamGetDroppedFramesProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PUSBCAMD_CHANNEL_EXTENSION channelExtension = pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

    case KSPROPERTY_DROPPEDFRAMES_CURRENT:
        {
            PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames =
                (PKSPROPERTY_DROPPEDFRAMES_CURRENT_S) pSPD->PropertyInfo;

            RtlCopyMemory(pDroppedFrames, pSPD->Property, sizeof(KSPROPERTY));  // initialize the unused portion

            pDroppedFrames->PictureNumber = channelExtension->FrameInfo.PictureNumber;
            pDroppedFrames->DropCount = channelExtension->FrameInfo.DropCount;
            pDroppedFrames->AverageFrameSize = channelExtension->VideoInfoHeader->bmiHeader.biSizeImage;

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_DROPPEDFRAMES_CURRENT_S);
            pSrb->Status = STATUS_SUCCESS;
            USBCAMD_KdPrint(MAX_TRACE, ("Drop# = %d, Pic.#= %d\n",
                                         (ULONG) channelExtension->FrameInfo.DropCount,
                                         (ULONG) channelExtension->FrameInfo.PictureNumber));

        }
        break;

    default:
//        TEST_TRAP();
        break;
    }
}



//==========================================================================;
//                   Clock Handling Routines
//==========================================================================;

//
// Another clock is being assigned as the Master clock
//

VOID VideoIndicateMasterClock (PHW_STREAM_REQUEST_BLOCK Srb)
{
    PUSBCAMD_CHANNEL_EXTENSION channelExtension =
        Srb->StreamObject->HwStreamExtension;

    USBCAMD_KdPrint(MIN_TRACE,
        ("VideoIndicateMasterClock\n"));

    if (channelExtension->StreamNumber == STREAM_Capture ) {
        channelExtension->MasterClockHandle =
            Srb->CommandData.MasterClockHandle;
    }
    else {
        channelExtension->MasterClockHandle = NULL;
    }

    Srb->Status = STATUS_SUCCESS;
}


/*
** VideoSetFormat()
**
**   Sets the format for a video stream.  This happens both when the
**   stream is first opened, and also when dynamically switching formats
**   on the preview pin.
**
**   It is assumed that the format has been verified for correctness before
**   this call is made.
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns:
**
**   TRUE if the format could be set, else FALSE
**
** Side Effects:  none
*/

NTSTATUS
USBCAMD_SetVideoFormat(
    IN PVOID DeviceContext,
    IN  PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PUSBCAMD_DEVICE_EXTENSION pHwDevExt;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension;
    PKSDATAFORMAT           pKSDataFormat;

    pHwDevExt = USBCAMD_GET_DEVICE_EXTENSION(DeviceContext);

    channelExtension =
        (PUSBCAMD_CHANNEL_EXTENSION) pSrb->StreamObject->HwStreamExtension;
    pKSDataFormat = pSrb->CommandData.OpenFormat;

    // -------------------------------------------------------------------
    // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
    // -------------------------------------------------------------------

    if (IsEqualGUID (&pKSDataFormat->Specifier, &KSDATAFORMAT_SPECIFIER_VIDEOINFO) &&
        pKSDataFormat->FormatSize >= sizeof(KS_DATAFORMAT_VIDEOINFOHEADER)) {

        PKS_VIDEOINFOHEADER pVideoInfoHdrRequested =
            &((PKS_DATAFORMAT_VIDEOINFOHEADER)pKSDataFormat)->VideoInfoHeader;

        // Calculate the actual format buffer size (includes bmiHeader.biSize).
        // Validate each step of the size calculations for arithmetic overflow,
        // and verify that the specified sizes correlate
        // (with unsigned math, a+b < b iff an arithmetic overflow occured).
        ULONG videoHeaderSize = pVideoInfoHdrRequested->bmiHeader.biSize +
            FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader);
        ULONG formatSize = videoHeaderSize +
            FIELD_OFFSET(KS_DATAFORMAT_VIDEOINFOHEADER,VideoInfoHeader);
        ULONG imageSize = 0;

        if (videoHeaderSize < FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader) ||
            formatSize < FIELD_OFFSET(KS_DATAFORMAT_VIDEOINFOHEADER,VideoInfoHeader) ||
            formatSize > pKSDataFormat->FormatSize) {

            pSrb->Status = STATUS_INVALID_PARAMETER;
            return FALSE;
        }

        // Validate the image size and dimension parameters
        // (the equivalent of using the KS_DIBSIZE macro)
        if (!NT_SUCCESS(CalculateImageSize(pVideoInfoHdrRequested, &imageSize)) ||
            pKSDataFormat->SampleSize < imageSize) {

            pSrb->Status = STATUS_INVALID_PARAMETER;
            return FALSE;
        }

        USBCAMD_KdPrint(MIN_TRACE, ("USBCAMD: New VideoInfoHdrRequested\n"));
        USBCAMD_KdPrint(MIN_TRACE, ("Width=%d  Height=%d  FrameTime (ms)= %d\n",
                                pVideoInfoHdrRequested->bmiHeader.biWidth,
                                pVideoInfoHdrRequested->bmiHeader.biHeight,
                                pVideoInfoHdrRequested->AvgTimePerFrame/10000));
        //
        // If a previous format was in use, release the memory
        //
        if (channelExtension->VideoInfoHeader) {
            USBCAMD_ExFreePool(channelExtension->VideoInfoHeader);
            channelExtension->VideoInfoHeader = NULL;
        }

        // Since the VIDEOINFOHEADER is of potentially variable size
        // allocate memory for it

        channelExtension->VideoInfoHeader = USBCAMD_ExAllocatePool(NonPagedPool, videoHeaderSize);

        if (channelExtension->VideoInfoHeader == NULL) {
            USBCAMD_KdPrint(MIN_TRACE, ("USBCAMD: ExAllocatePool failed\n"));
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            return FALSE;
        }

        // Copy the VIDEOINFOHEADER requested to our storage
        RtlCopyMemory(
                channelExtension->VideoInfoHeader,
                pVideoInfoHdrRequested,
                videoHeaderSize);
    }

    else {
        // Unknown format
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return FALSE;
    }

    return TRUE;
}

/*
** USBCAMD_ReceiveCtrlPacket()
**
**   Receives packet commands that control the Audio stream
**
** Arguments:
**
**   Srb - The stream request block for the Audio stream
**
** Returns:
**
** Side Effects:  none
*/

VOID STREAMAPI
USBCAMD_ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )
{
    PUSBCAMD_DEVICE_EXTENSION deviceExtension =
         Srb->HwDeviceExtension;
    BOOLEAN completedByCam = FALSE;
    KSSTATE    PreviousState;
    BOOL       Busy;
    int        StreamNumber = Srb->StreamObject->StreamNumber;
    
    PUSBCAMD_CHANNEL_EXTENSION channelExtension =
        (PUSBCAMD_CHANNEL_EXTENSION) Srb->StreamObject->HwStreamExtension;
    PreviousState = channelExtension->KSState;

    USBCAMD_KdPrint(MAX_TRACE, ("USBCAMD_ReceiveCtrlPacket %x\n", Srb->Command));

    //
    // If we're already processing an SRB, add it to the queue
    //
    Busy = AddToListIfBusy (
                        Srb,
                        &deviceExtension->ControlSRBSpinLock,
                        &deviceExtension->ProcessingControlSRB[StreamNumber],
                        &deviceExtension->StreamControlSRBList[StreamNumber]);

    if (Busy) {
        return;
    }

    while (TRUE) {

        USBCAMD_DbgLog(TL_SRB_TRACE, '+brS',
            Srb,
            Srb->Command,
            0
            );

        //
        // call the cam driver first
        //

        if (channelExtension->CamReceiveCtrlPacket) {
            (*channelExtension->CamReceiveCtrlPacket)(
                Srb,
                USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                &completedByCam);
        }

        if (completedByCam == TRUE) {

            USBCAMD_DbgLog(TL_SRB_TRACE, '-brS',
                Srb,
                Srb->Command,
                Srb->Status
                );

            goto CtrlPacketDone;
        }

        switch (Srb->Command) {

        case SRB_PROPOSE_DATA_FORMAT:

            USBCAMD_KdPrint(MAX_TRACE, ("Cam driver should have handled PrposeDataFormat SRB.\n"));
            Srb->Status = STATUS_NOT_IMPLEMENTED;
            break;

        case SRB_SET_DATA_FORMAT:

            USBCAMD_KdPrint(MAX_TRACE, ("Cam driver should have handled SetDataFormat SRB.\n"));
            Srb->Status = STATUS_NOT_IMPLEMENTED;
            break;

        case SRB_GET_DATA_FORMAT:

            USBCAMD_KdPrint(MAX_TRACE, ("Cam driver should have handled GetDataFormat SRB.\n"));
            Srb->Status = STATUS_NOT_IMPLEMENTED;
            break;

        case SRB_GET_STREAM_STATE:

            Srb->CommandData.StreamState = channelExtension->KSState;
            Srb->ActualBytesTransferred = sizeof (KSSTATE);
            Srb->Status = STATUS_SUCCESS;

            // A very odd rule:
            // When transitioning from stop to pause, DShow tries to preroll
            // the graph.  Capture sources can't preroll, and indicate this
            // by returning VFW_S_CANT_CUE in user mode.  To indicate this
            // condition from drivers, they must return ERROR_NO_DATA_DETECTED

            if (channelExtension->KSState == KSSTATE_PAUSE) {
                Srb->Status = STATUS_NO_DATA_DETECTED;
            }

            break;

        case SRB_SET_STREAM_STATE:
            {
            // we will not allow virtual still pin's stata to change if capture pin is
            // not streaming.
            if ((StreamNumber == STREAM_Still) &&
                 (deviceExtension->ChannelExtension[STREAM_Capture] == NULL) &&
                 (channelExtension->VirtualStillPin )){
                Srb->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            // don't allow stream state change if we are not in D0 state.
            if (deviceExtension->CurrentPowerState != PowerDeviceD0 ) {
                Srb->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            USBCAMD_KdPrint(MAX_TRACE, ("set stream state %x\n", Srb->CommandData.StreamState));

            switch (Srb->CommandData.StreamState)  {

            case KSSTATE_STOP:

                USBCAMD_KdPrint(MIN_TRACE, ("Stream %d STOP  \n",StreamNumber));

                if (channelExtension->ImageCaptureStarted) {
#if DBG
                    LARGE_INTEGER StopTime;
                    ULONG FramesPerSec = 0;

                    KeQuerySystemTime(&StopTime);

                    StopTime.QuadPart -= channelExtension->StartTime.QuadPart;
                    StopTime.QuadPart /= 10000; // convert to milliseconds

                    if (StopTime.QuadPart != 0) {

                        // Calculate the Frames/Sec (with enough precision to show one decimal place)
                        FramesPerSec = (ULONG)(
                            (channelExtension->FrameCaptured * 10000) / StopTime.QuadPart
                            );
                    }

                    USBCAMD_KdPrint(MIN_TRACE, ("**ActualFramesPerSecond: %d.%d\n",
                        FramesPerSec / 10, FramesPerSec % 10
                        ));
#endif
                    Srb->Status =
                        USBCAMD_StopChannel(deviceExtension,
                                            channelExtension);

                } else {
                    Srb->Status = STATUS_SUCCESS;
                }

                break;

            case KSSTATE_PAUSE:

                USBCAMD_KdPrint(MIN_TRACE, ("Stream %d PAUSE\n",StreamNumber));
                //
                // On a transition to pause from acquire or stop, start our timer running.
                //

                if (PreviousState == KSSTATE_ACQUIRE || PreviousState == KSSTATE_STOP) {

                    // Zero the frame counters
#if DBG
                    channelExtension->FrameCaptured = 0;                // actual frames captured
                    channelExtension->VideoFrameLostCount = 0;          // actual dropped frames
                    KeQuerySystemTime(&channelExtension->StartTime);    // the tentative start time
#endif
                    channelExtension->FrameInfo.PictureNumber = 0;
                    channelExtension->FrameInfo.DropCount = 0;
                    channelExtension->FrameInfo.dwFrameFlags = 0;
                    channelExtension->FirstFrame = TRUE;
                }
                Srb->Status = STATUS_SUCCESS;
                break;

            case KSSTATE_ACQUIRE:

                USBCAMD_KdPrint(MIN_TRACE, ("Stream %d ACQUIRE\n",StreamNumber));
                Srb->Status = STATUS_SUCCESS;
                break;

            case KSSTATE_RUN:

                USBCAMD_KdPrint(MIN_TRACE, ("Stream %d RUN\n",StreamNumber));

                // we will not start the channel again if we are toggling between pause & run.
                if (!channelExtension->ImageCaptureStarted && !deviceExtension->InPowerTransition) {

                    Srb->Status = USBCAMD_StartChannel(deviceExtension,channelExtension);
#if DBG
                    KeQuerySystemTime(&channelExtension->StartTime);        // the real start time
#endif
                }
                else
                    Srb->Status = STATUS_SUCCESS;
                break;

            default:

//              TEST_TRAP();
                Srb->Status = STATUS_NOT_IMPLEMENTED;
                break;
            }
            
            channelExtension->KSState = Srb->CommandData.StreamState;
            
            }
            break;

        case SRB_INDICATE_MASTER_CLOCK:

            //
            // Assigns a clock to a stream
            //

            VideoIndicateMasterClock (Srb);

            break;

        case SRB_GET_STREAM_PROPERTY:

            // Ensure the return code reflects the state of the device
            if (deviceExtension->CameraUnplugged) {

                Srb->Status = STATUS_NO_SUCH_DEVICE;
            }
            else {

                VideoGetProperty(Srb);
            }
            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //

//          TEST_TRAP();

            Srb->Status = STATUS_NOT_IMPLEMENTED;
        }

        
        COMPLETE_STREAM_READ(Srb);

CtrlPacketDone:

        //
        // See if there's anything else on the queue
        //
        Busy = RemoveFromListIfAvailable (
                        &Srb,
                        &deviceExtension->ControlSRBSpinLock,
                        &deviceExtension->ProcessingControlSRB[StreamNumber],
                        &deviceExtension->StreamControlSRBList[StreamNumber]);

        if (!Busy) {
            break;
        }

    }
}



/*
** USBCAMD_CompleteRead()
**
**   Complete am Srb
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/

VOID
USBCAMD_CompleteRead(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_READ_EXTENSION ReadExtension,
    IN NTSTATUS NtStatus,
    IN ULONG BytesTransferred
    )
{
    PHW_STREAM_REQUEST_BLOCK srb;
    PKSSTREAM_HEADER dataPacket;
    PKS_FRAME_INFO    pFrameInfo;
    ULONG StreamNumber ;
    
    srb = ReadExtension->Srb;
    StreamNumber = srb->StreamObject->StreamNumber;
    srb->Status = NtStatus;
    dataPacket = srb->CommandData.DataBufferArray;
    dataPacket->DataUsed = BytesTransferred;

    if ( StreamNumber == STREAM_Capture ) {
        pFrameInfo = (PKS_FRAME_INFO) (dataPacket + 1);
        ChannelExtension->FrameInfo.ExtendedHeaderSize = pFrameInfo->ExtendedHeaderSize;
    }
    
    if ( ChannelExtension->MasterClockHandle && (StreamNumber == STREAM_Capture ) &&
         (NtStatus != STATUS_CANCELLED) ){

        dataPacket->PresentationTime.Time = (LONGLONG)GetStreamTime(srb, ChannelExtension);

        // Check if we've seen frames yet (we cannot depend on the frame number...
        // ... 1+ frames may have been dropped before the first SRB was available)
        if (!ChannelExtension->FirstFrame) {
            LONGLONG PictureNumber =    // calculate a picture number (rounded properly)
                (dataPacket->Duration / 2 + dataPacket->PresentationTime.Time) / dataPacket->Duration;

            // Is the PictureNumber guess okay?
            if (PictureNumber > ChannelExtension->FrameInfo.PictureNumber) {

                // Calculate the delta between picture numbers
                ULONG PictureDelta = (ULONG)
                    (PictureNumber - ChannelExtension->FrameInfo.PictureNumber);

                // Update the Picture Number
                ChannelExtension->FrameInfo.PictureNumber += PictureDelta;

                // Update the drop count (never calculated directly to avoid decreasing values)
                ChannelExtension->FrameInfo.DropCount += PictureDelta - 1;
#if DBG
                if (PictureDelta - 1) {
                    USBCAMD_KdPrint(MAX_TRACE, ("Graph dropped %d frame(s): P#%d,D#%d,P-T=%d\n",
                        (LONG) (PictureDelta - 1),
                        (LONG) ChannelExtension->FrameInfo.PictureNumber,
                        (LONG) ChannelExtension->FrameInfo.DropCount,
                        (ULONG) dataPacket->PresentationTime.Time /10000));
                }
#endif
            }
            else {

                // Is clock running backwards?
                if (dataPacket->PresentationTime.Time < ChannelExtension->PreviousStreamTime) {

                    USBCAMD_KdPrint(MIN_TRACE, ("Clock went backwards: PT=%d, Previous PT=%d\n",
                        (ULONG) dataPacket->PresentationTime.Time / 10000,
                        (ULONG) ChannelExtension->PreviousStreamTime / 10000 ));

                    // Use the previous stream time
                    dataPacket->PresentationTime.Time = ChannelExtension->PreviousStreamTime;
                }

                // All we can do is bump the Picture Number by one while the clock is lagging
                ChannelExtension->FrameInfo.PictureNumber += 1;
            }
        }
        else {

            ChannelExtension->FirstFrame = FALSE;

            // Initialize the Picture Number
            ChannelExtension->FrameInfo.PictureNumber = 1;

            // Initialize the drop count (nothing dropped before this frame)
            ChannelExtension->FrameInfo.DropCount = 0;
        }

        // Save presentation time for use with the next frame
        ChannelExtension->PreviousStreamTime = dataPacket->PresentationTime.Time;

#if DBG
        USBCAMD_KdPrint(MAX_TRACE, ("P#%d,D#%d,P-T=%d,LF=%d\n",
            (LONG) ChannelExtension->FrameInfo.PictureNumber,
            (LONG) ChannelExtension->FrameInfo.DropCount,
            (ULONG) dataPacket->PresentationTime.Time /10000,
            ReadExtension->CurrentLostFrames));

#endif
    }
                                                
    // we set the options flags to key frames only if Cam driver didn't indicate otherwise.
    if ( dataPacket->OptionsFlags == 0 ) {
        // Every frame we generate is a key frame (aka SplicePoint)
        dataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;
    }

    //
    // if we have a master clock
    //
    if (ChannelExtension->MasterClockHandle ) {
            dataPacket->OptionsFlags |=
                KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
    }
    else {
    // clear the timestamp valid flags
            dataPacket->OptionsFlags &=
                ~(KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                KSSTREAM_HEADER_OPTIONSF_DURATIONVALID);
    }

    if ( StreamNumber == STREAM_Capture )
       *pFrameInfo = ChannelExtension->FrameInfo ;

    // only free the buffer if we allocate not DSHOW.
    if ( !ChannelExtension->NoRawProcessingRequired) {
        if ( ReadExtension->RawFrameBuffer) {
            USBCAMD_FreeRawFrameBuffer(ReadExtension->RawFrameBuffer);
        }
    }

    // Enforce that we are done with this destination
    ReadExtension->RawFrameBuffer = NULL;

    if ( ChannelExtension->StreamNumber == 1) {
        USBCAMD_KdPrint(MAX_TRACE, ("Read Srb %x for stream %d is completed, status = %x\n",
                                    srb,ChannelExtension->StreamNumber, srb->Status));
    }
    COMPLETE_STREAM_READ(srb);
}

/*
** USBCAMD_GetFrameBufferFromSrb()
**
**   Complete am Srb
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/

PVOID
USBCAMD_GetFrameBufferFromSrb(
    IN PVOID Srb,
    OUT PULONG MaxLength
    )
{
    PVOID frameBuffer =NULL;
    PKSSTREAM_HEADER streamHeader;

#if 0   // PIO = FALSE
    PIRP irp;

    irp = ((PHW_STREAM_REQUEST_BLOCK) Srb)->Irp;

    USBCAMD_KdPrint(MIN_TRACE, ("'SRB MDL = %x\n",
        irp->MdlAddress));

    frameBuffer = MmGetSystemAddressForMdl(irp->MdlAddress);
#else
    // PIO = TRUE
    frameBuffer = ((PHW_STREAM_REQUEST_BLOCK) Srb)->CommandData.DataBufferArray->Data;
#endif
    streamHeader = ((PHW_STREAM_REQUEST_BLOCK) Srb)->CommandData.DataBufferArray;
    USBCAMD_KdPrint(ULTRA_TRACE, ("SRB Length = %x\n",
        streamHeader->FrameExtent));
    USBCAMD_KdPrint(ULTRA_TRACE, ("frame buffer = %x\n", frameBuffer));
    *MaxLength = streamHeader->FrameExtent;

    return frameBuffer;
}

/*
** AddToListIfBusy ()
**
**   Grabs a spinlock, checks the busy flag, and if set adds an SRB to a queue
**
** Arguments:
**
**   pSrb - Stream request block
**
**   SpinLock - The spinlock to use when checking the flag
**
**   BusyFlag - The flag to check
**
**   ListHead - The list onto which the Srb will be added if the busy flag is set
**
** Returns:
**
**   The state of the busy flag on entry.  This will be TRUE if we're already
**   processing an SRB, and FALSE if no SRB is already in progress.
**
** Side Effects:  none
*/

BOOL
STREAMAPI
AddToListIfBusy (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN KSPIN_LOCK              *SpinLock,
    IN OUT BOOL                *BusyFlag,
    IN LIST_ENTRY              *ListHead
    )
{
    KIRQL                       Irql;
    PUSBCAMD_READ_EXTENSION    pSrbExt = (PUSBCAMD_READ_EXTENSION)pSrb->SRBExtension;

    KeAcquireSpinLock (SpinLock, &Irql);

    // If we're already processing another SRB, add this current request
    // to the queue and return TRUE

    if (*BusyFlag == TRUE) {
        // Save the SRB pointer away in the SRB Extension
        pSrbExt->Srb = pSrb;
        USBCAMD_KdPrint(ULTRA_TRACE, ("Queuing CtrlPacket %x\n", pSrb->Command));
        InsertTailList(ListHead, &pSrbExt->ListEntry);
        KeReleaseSpinLock(SpinLock, Irql);
        return TRUE;
    }

    // Otherwise, set the busy flag, release the spinlock, and return FALSE

    *BusyFlag = TRUE;
    KeReleaseSpinLock(SpinLock, Irql);

    return FALSE;
}

/*
** RemoveFromListIfAvailable ()
**
**   Grabs a spinlock, checks for an available SRB, and removes it from the list
**
** Arguments:
**
**   &pSrb - where to return the Stream request block if available
**
**   SpinLock - The spinlock to use
**
**   BusyFlag - The flag to clear if the list is empty
**
**   ListHead - The list from which an SRB will be removed if available
**
** Returns:
**
**   TRUE if an SRB was removed from the list
**   FALSE if the list is empty
**
** Side Effects:  none
*/

BOOL
STREAMAPI
RemoveFromListIfAvailable (
    IN OUT PHW_STREAM_REQUEST_BLOCK *pSrb,
    IN KSPIN_LOCK                   *SpinLock,
    IN OUT BOOL                     *BusyFlag,
    IN LIST_ENTRY                   *ListHead
    )
{
    KIRQL                       Irql;

    KeAcquireSpinLock (SpinLock, &Irql);

    //
    // If the queue is now empty, clear the busy flag, and return
    //
    if (IsListEmpty(ListHead)) {
        *BusyFlag = FALSE;
        KeReleaseSpinLock(SpinLock, Irql);
        return FALSE;
    }
    //
    // otherwise extract the SRB
    //
    else {
        PUSBCAMD_READ_EXTENSION  pSrbExt;
        PLIST_ENTRY listEntry;

        listEntry = RemoveHeadList(ListHead);

        pSrbExt = (PUSBCAMD_READ_EXTENSION) CONTAINING_RECORD(listEntry,
                                             USBCAMD_READ_EXTENSION,
                                             ListEntry);
        *BusyFlag = TRUE;
        KeReleaseSpinLock(SpinLock, Irql);
        *pSrb = pSrbExt->Srb;
    }
    return TRUE;
}

/*
** GetStreamTime ()
**
**   Get current stream time from the graph master clock
**
** Arguments:
**
**   Srb - pointer to current SRB
**
**   ChannelExtension - ptr to current channel extension
**
**
** Returns:
**
**   current stream time in ULONGULONG
**
** Side Effects:  none
*/

ULONGLONG GetStreamTime(
            IN PHW_STREAM_REQUEST_BLOCK Srb,
            IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension)
{

    HW_TIME_CONTEXT  timeContext;

    timeContext.HwDeviceExtension =
        (struct _HW_DEVICE_EXTENSION *)ChannelExtension->DeviceExtension;
    timeContext.HwStreamObject = Srb->StreamObject;
    timeContext.Function = TIME_GET_STREAM_TIME;
    timeContext.Time = timeContext.SystemTime =0;

    if ( ChannelExtension->MasterClockHandle)
        StreamClassQueryMasterClockSync(ChannelExtension->MasterClockHandle,&timeContext);

    return (timeContext.Time);
}


/*++

Routine Description:

    This routine will notify STI stack that a trigger button has been pressd

Arguments:



Return Value:

    NT status code

--*/


VOID USBCAMD_NotifyStiMonitor(PUSBCAMD_DEVICE_EXTENSION deviceExtension)
{

    if (deviceExtension->EventCount)
    {
        StreamClassDeviceNotification(
            SignalMultipleDeviceEvents,
            deviceExtension,
            &USBCAMD_KSEVENTSETID_VIDCAPTOSTI,
            KSEVENT_VIDCAPTOSTI_EXT_TRIGGER);
    }
}


/*++

Routine Description:

    This routine will get called by stream class to enable/disable device events.

Arguments:



Return Value:

    NT status code

--*/

NTSTATUS STREAMAPI USBCAMD_DeviceEventProc (PHW_EVENT_DESCRIPTOR pEvent)
{
    PUSBCAMD_DEVICE_EXTENSION deviceExtension=
            (PUSBCAMD_DEVICE_EXTENSION)(pEvent->DeviceExtension);

    if (pEvent->Enable)
    {
        deviceExtension->EventCount++;
    }
    else
    {
        deviceExtension->EventCount--;
    }
    return STATUS_SUCCESS;
}

#if DBG

ULONGLONG
GetSystemTime( IN PUSBCAMD_DEVICE_EXTENSION DevExt )
{

    ULONGLONG ticks;

    KeQueryTickCount((PLARGE_INTEGER)&ticks);
    ticks *= DevExt->TimeIncrement;
    return(ticks);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\usbcamd\dbglog.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

  dbglog.c

Abstract:

   Debug logging code USB camera driver

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

    Original 3/96 John Dunn
    Updated  3/98 Husni Roukbi

--*/

#include "usbcamd.h"


VOID
USBCAMD_Debug_LogEntry(
    IN CHAR *Name,
    IN ULONG_PTR Info1,
    IN ULONG Info2,
    IN ULONG Info3
    )

{
#if DBG
    // If any vendor log level selected, then all vendor-initiated logs are enabled
    if (USBCAMD_LogBuffer && (TL_VND_MASK & USBCAMD_LogMask)) {

        ULONG Tag;
        int idx;

        // Fill the tag with the vendor-supplied characters
        for (Tag = '    ', idx = 0; idx < sizeof(ULONG) && Name[idx]; idx++) {
            Tag |= Name[idx] << (idx*8);
        }

        USBCAMD_DbgLogInternal(Tag, (ULONG_PTR)Info1, (ULONG_PTR)Info2, (ULONG_PTR)Info3);
    }
#endif
}

#if DBG
PCHAR PnPSystemPowerStateString(
        ULONG SystemPowerState
)
{
    static char szBuffer[80];
    switch (SystemPowerState) {
    case PowerSystemUnspecified:
        return "<PowerSystemUnspecified>"; 
    case PowerSystemWorking:
        return "S0(Working)";
    case PowerSystemSleeping1:
        return "S1(Sleeping1)";
    case PowerSystemSleeping2:
        return "S2(Sleeping2)";
    case PowerSystemSleeping3:
        return "S3(Sleeping3)";
    case PowerSystemHibernate:
        return "S4(Hibernate)";
    case PowerSystemShutdown:
        return "S5(Shutdown)";
    case PowerSystemMaximum:
        return "<PowerSystemMaximum>";
    default: 
        sprintf(szBuffer,"Unknown SystemPowerState(0x%x)", SystemPowerState);
        return szBuffer;
    }
}

PCHAR PnPDevicePowerStateString(
        ULONG DevicePowerState
)
{
    static char szBuffer[80];
    switch (DevicePowerState)
    {
    case PowerDeviceUnspecified:
        return "<PowerDeviceUnspecified>";
    case PowerDeviceD0:
        return "D0(Fully On)";
    case PowerDeviceD1:
        return "D1(Almost On)";
    case PowerDeviceD2:
        return "D2(Almost Off)";
    case PowerDeviceD3:
        return "D3(Fully Off)";
    case PowerDeviceMaximum:
        return "<PowerDeviceMaximum>";
    default:
        sprintf(szBuffer,"Unknown DevicePowerState(0x%x)", DevicePowerState);
        return szBuffer;
    }
}


PCHAR
PnPPowerString (
    UCHAR MinorFunction
)
{
    static char szBuffer[80];
    switch (MinorFunction) 
    {
        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE";
        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE";
        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER";
        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER";
        default:
            sprintf(szBuffer,"Unknown Power Irp: MinorFunction=0x%x", MinorFunction);
            return szBuffer;
    }
}
//*****************************************************************************
//
// PnPMinorFunctionString()
//
// MinorFunction - The IRP_MJ_PNP minor function
//
//*****************************************************************************

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
)
{
    static char szBuffer[80];
    switch (MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        default:
            sprintf(szBuffer,"Unknown PnP Irp: MinorFunction=0x%x", MinorFunction);
            return szBuffer;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\usbcamd\reset.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

  reset.c

Abstract:

   Isochronous transfer code for usbcamd USB camera driver

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

    Original 3/96 John Dunn
    Updated  3/98 Husni Roukbi

--*/

#include "usbcamd.h"


NTSTATUS
USBCAMD_GetPortStatus(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION channelExtension,
    IN PULONG PortStatus
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceExtension - pointer to the device extension for this instance of an USB camera

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus; 
    
    USBCAMD_SERIALIZE(DeviceExtension);

    USBCAMD_KdPrint (MAX_TRACE, ("enter USBCAMD_GetPortStatus on Stream #%d \n",
                     channelExtension->StreamNumber));

    *PortStatus = 0;
    ntStatus = USBCAMD_CallUSBD(DeviceExtension, NULL, 
                                IOCTL_INTERNAL_USB_GET_PORT_STATUS,PortStatus);    

    USBCAMD_KdPrint(MIN_TRACE, ("GetPortStatus returns (0x%x), Port Status (0x%x)\n",ntStatus, *PortStatus));
    
    USBCAMD_RELEASE(DeviceExtension);

    return ntStatus;
}


NTSTATUS
USBCAMD_EnablePort(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceExtension - pointer to the device extension for this instance of an USB camera

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;

    USBCAMD_KdPrint (MIN_TRACE, ("enter USBCAMD_EnablePort\n"));
    //
    // issue a synchronous request
    //
    ntStatus = USBCAMD_CallUSBD(DeviceExtension, NULL, 
                                 IOCTL_INTERNAL_USB_ENABLE_PORT,NULL);
    if (STATUS_NOT_SUPPORTED == ntStatus) {
        // This means the device is not on a root hub, so try resetting instead
        ntStatus = USBCAMD_CallUSBD(DeviceExtension, NULL, 
                                     IOCTL_INTERNAL_USB_RESET_PORT,NULL);
    }

    if (!NT_SUCCESS(ntStatus)) {
        USBCAMD_KdPrint (MIN_TRACE, ("Failed to enable port (%x) \n", ntStatus));
        // TEST_TRAP(); // This can happen during surprise removal.
    }
    return ntStatus;
}


/*++

Routine Description:

    This function restarts the streaming process from an error state at 
    PASSIVE_LEVEL.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.
                    
    ChannelExtension - Channel to reset.    

Return Value:

--*/   
NTSTATUS
USBCAMD_ResetChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN ULONG portUsbStatus,
    IN ULONG portNtStatus
    )    
{
    NTSTATUS ntStatus ;
    ULONG status;
    LONG StreamNumber;

    USBCAMD_SERIALIZE(DeviceExtension);

    ntStatus = STATUS_SUCCESS;

    StreamNumber = ChannelExtension->StreamNumber;
    USBCAMD_KdPrint (MAX_TRACE, ("USBCAMD_ResetChannel #%d\n", StreamNumber));
    ASSERT_CHANNEL(ChannelExtension);

    if (!ChannelExtension->ChannelPrepared) {

        USBCAMD_RELEASE(DeviceExtension);

        return ntStatus;
    }

    if (NT_SUCCESS(portNtStatus) && !(portUsbStatus & USBD_PORT_ENABLED)) {
        ntStatus = USBCAMD_EnablePort(DeviceExtension); // re-enable the disabled port.
        if (!NT_SUCCESS(ntStatus) ) {
            USBCAMD_RELEASE(DeviceExtension);
            USBCAMD_KdPrint (MIN_TRACE, ("Failed to Enable usb port(0x%X)\n",ntStatus ));
            // TEST_TRAP(); // This can happen during surprise removal.
            return ntStatus;
        }
    }

    //
    // channel may not be in error mode, make sure and issue 
    // an abort before waiting for the channel to spin down
    //

    ntStatus = USBCAMD_ResetPipes(DeviceExtension,
                       ChannelExtension, 
                       DeviceExtension->Interface,
                       TRUE);   
    
    if (NT_SUCCESS(ntStatus)) {

        //
        // Block the reset for now, waiting for all iso irps to be completed
        //
        ntStatus = USBCAMD_WaitForIdle(&ChannelExtension->IdleLock, USBCAMD_RESET_STREAM);
        if (STATUS_TIMEOUT == ntStatus) {

            KIRQL oldIrql;
            int idx;

            // A timeout requires that we take harsher measures to reset the stream

            // Hold the spin lock while cancelling the IRPs
            KeAcquireSpinLock(&ChannelExtension->TransferSpinLock, &oldIrql);

            // Cancel the IRPs
            for (idx = 0; idx < USBCAMD_MAX_REQUEST; idx++) {

                PUSBCAMD_TRANSFER_EXTENSION TransferExtension = &ChannelExtension->TransferExtension[idx];

                if (TransferExtension->SyncIrp) {
                    IoCancelIrp(TransferExtension->SyncIrp);
                }

                if (TransferExtension->DataIrp) {
                    IoCancelIrp(TransferExtension->DataIrp);
                }
            }

            KeReleaseSpinLock(&ChannelExtension->TransferSpinLock, oldIrql);

            // Try waiting one more time
            ntStatus = USBCAMD_WaitForIdle(&ChannelExtension->IdleLock, USBCAMD_RESET_STREAM);
        }

        if (STATUS_SUCCESS == ntStatus) {

            // go ahead and attempt to restart the channel.
            //
            // now reset the pipes
            //

            ntStatus = USBCAMD_ResetPipes(DeviceExtension,
                                          ChannelExtension,
                                          DeviceExtension->Interface,
                                          FALSE);
            if (NT_SUCCESS(ntStatus)) {

                //
                // Idle lock Acquire/Release is done here to detect if the stream is being
                // stopped during a reset. The real acquires are done later when the bulk or
                // iso streams are started, and the real releases are done in the completion
                // routines.
                //
                ntStatus = USBCAMD_AcquireIdleLock(&ChannelExtension->IdleLock);
                if (NT_SUCCESS(ntStatus)) {

                    //
                    // only restart the stream if it is already in the running state
                    //

                    if (ChannelExtension->ImageCaptureStarted) {

                        if (DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {

                            // send hardware stop and re-start
                            ntStatus = (*DeviceExtension->DeviceDataEx.DeviceData2.CamStopCaptureEx)(
                                        DeviceExtension->StackDeviceObject,      
                                        USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                                        StreamNumber);

                            if (NT_SUCCESS(ntStatus)) {
                                ntStatus = (*DeviceExtension->DeviceDataEx.DeviceData2.CamStartCaptureEx)(
                                            DeviceExtension->StackDeviceObject,
                                            USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                                            StreamNumber);    
   
                            }                    
                        }
                        else {

                            // send hardware stop and re-start
                            ntStatus = (*DeviceExtension->DeviceDataEx.DeviceData.CamStopCapture)(
                                        DeviceExtension->StackDeviceObject,      
                                        USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension));

                            if (NT_SUCCESS(ntStatus)) {
                                ntStatus = (*DeviceExtension->DeviceDataEx.DeviceData.CamStartCapture)(
                                            DeviceExtension->StackDeviceObject,
                                            USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension));    
                            }                    

                        }

                        if (NT_SUCCESS(ntStatus)) {

                            ChannelExtension->SyncPipe = DeviceExtension->SyncPipe;
                            if (StreamNumber == DeviceExtension->IsoPipeStreamType ) {
                                ChannelExtension->DataPipe = DeviceExtension->DataPipe;
                                ChannelExtension->DataPipeType = UsbdPipeTypeIsochronous;   
                                USBCAMD_StartIsoStream(DeviceExtension, ChannelExtension);
                            }
                            else if (StreamNumber == DeviceExtension->BulkPipeStreamType ) {
                                ChannelExtension->DataPipe = DeviceExtension->BulkDataPipe;
                                ChannelExtension->DataPipeType = UsbdPipeTypeBulk;  
                                USBCAMD_StartBulkStream(DeviceExtension, ChannelExtension);                    
                            }
                        }        
                    }
                    else {
                        USBCAMD_KdPrint (MIN_TRACE, ("ImageCaptureStarted is False. \n"));
                    }

                    USBCAMD_ReleaseIdleLock(&ChannelExtension->IdleLock);
                }
                else {
                    USBCAMD_KdPrint (MIN_TRACE, ("Stream stopped during reset. \n"));
                }
            }
        }
        else {
            USBCAMD_KdPrint (MIN_TRACE, ("Stream requests not aborting, giving up.\n"));
        }
    }

    USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_ResetChannel exit (0x%X) \n", ntStatus));
    USBCAMD_RELEASE(DeviceExtension);

    return ntStatus;
}            


NTSTATUS
USBCAMD_ResetPipes(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    IN BOOLEAN Abort
    )
/*++

Routine Description:

    Reset both pipes associated with a video channel on the
    camera.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PURB urb;

    USBCAMD_KdPrint (MAX_TRACE, ("USBCAMD_ResetPipes\n"));

    urb = USBCAMD_ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_PIPE_REQUEST));

    if (urb) {
    
        urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = (USHORT) (Abort ? URB_FUNCTION_ABORT_PIPE : 
                                                    URB_FUNCTION_RESET_PIPE);
                                                            
        urb->UrbPipeRequest.PipeHandle = 
            InterfaceInformation->Pipes[ChannelExtension->DataPipe].PipeHandle;

        ntStatus = USBCAMD_CallUSBD(DeviceExtension, urb,0,NULL);
        if ( !NT_SUCCESS(ntStatus) )  {
            if (Abort) {
                USBCAMD_KdPrint (MIN_TRACE, ("Abort Data Pipe Failed (0x%x) \n", ntStatus));
               // TEST_TRAP();
            }
        }

        if (NT_SUCCESS(ntStatus) && ChannelExtension->SyncPipe != -1)  {
            urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
            urb->UrbHeader.Function =(USHORT) (Abort ? URB_FUNCTION_ABORT_PIPE : 
                                                        URB_FUNCTION_RESET_PIPE);
            urb->UrbPipeRequest.PipeHandle = 
                InterfaceInformation->Pipes[ChannelExtension->SyncPipe].PipeHandle;
                
            ntStatus = USBCAMD_CallUSBD(DeviceExtension, urb,0,NULL);
            if ( !NT_SUCCESS(ntStatus) )  {
                if (Abort) {
                    USBCAMD_KdPrint (MIN_TRACE, ("Abort Sync Pipe Failed (0x%x) \n", ntStatus));
                 //   TEST_TRAP();
                }
            }
        }            

        USBCAMD_ExFreePool(urb);
        
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;       
    }       

    return ntStatus;
}   


VOID
USBCAMD_CancelQueuedSRBs(
    PUSBCAMD_CHANNEL_EXTENSION channelExtension
    )
/*++

Routine Description:

    Cancel or set aside all queued SRBs 
    
Arguments:

    channelExtension - Pointer to the ChannelExtension object.

Return Value:

    None.

--*/
{
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    PUSBCAMD_READ_EXTENSION readExtension = NULL;
    LIST_ENTRY LocalList;
    KIRQL Irql;

    deviceExtension = channelExtension->DeviceExtension;
        
    ASSERT_CHANNEL(channelExtension);
    ASSERT(channelExtension->ChannelPrepared == TRUE);
    ASSERT(channelExtension->ImageCaptureStarted);
    
    InitializeListHead(&LocalList);

    //
    // complete any pending reads in queue
    //

    // Always grab these spinlocks in this order
    KeAcquireSpinLock(&channelExtension->CurrentRequestSpinLock, &Irql);
    KeAcquireSpinLockAtDpcLevel(&channelExtension->PendingIoListSpin);

    //
    // If we have an SRB for the current frame, move it to the head of the
    // PendingIoList
    //
    if (channelExtension->CurrentRequest) {
    
        readExtension = channelExtension->CurrentRequest;              
        channelExtension->CurrentRequest = NULL;

        InsertHeadList(&channelExtension->PendingIoList, &readExtension->ListEntry);
    }

    //
    // If not intentionally going idle, or the camera has been unplugged,
    // then the SRBs need to be cancelled
    //
    if (!channelExtension->IdleIsoStream || deviceExtension->CameraUnplugged) {

        // Move these to a private list before calling USBCAMD_CompleteRead
        while (!IsListEmpty(&channelExtension->PendingIoList)) {

            PLIST_ENTRY listEntry = RemoveHeadList(&channelExtension->PendingIoList);

            InsertTailList(&LocalList, listEntry);
        }
    }

    // Always release these spinlocks in the reverse order
    KeReleaseSpinLockFromDpcLevel(&channelExtension->PendingIoListSpin);
    KeReleaseSpinLock(&channelExtension->CurrentRequestSpinLock, Irql);

    // Now that we're outside the spinlocks, do the actual cancellation
    while (!IsListEmpty(&LocalList)) {

        PLIST_ENTRY listEntry = RemoveHeadList(&LocalList);

        readExtension = (PUSBCAMD_READ_EXTENSION)
            CONTAINING_RECORD(listEntry, USBCAMD_READ_EXTENSION, ListEntry);

        USBCAMD_KdPrint(MIN_TRACE, ("Cancelling queued read SRB on stream %d, Ch. Flag(0x%x)\n",
            channelExtension->StreamNumber,
            channelExtension->Flags
            ));    
   
        USBCAMD_CompleteRead(channelExtension,readExtension,STATUS_CANCELLED,0);
    }
}


BOOLEAN
USBCAMD_ProcessResetRequest(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    )
/*++

Routine Description:

    Request a reset of the ISO stream.
    This function is re-entarnt and can be called at DPC level

Arguments:

Return Value:

    None.

--*/
{
    PUSBCAMD_WORK_ITEM pWorkItem;

    ASSERT_CHANNEL(ChannelExtension);


    if (InterlockedIncrement(&DeviceExtension->TimeoutCount[ChannelExtension->StreamNumber]) > 0) {
        USBCAMD_KdPrint (MIN_TRACE, ("Stream # %d reset already scheduled\n", ChannelExtension->StreamNumber));
        InterlockedDecrement(&DeviceExtension->TimeoutCount[ChannelExtension->StreamNumber]);
        return FALSE;
    }
    
    USBCAMD_KdPrint (MAX_TRACE, ("Stream # %d reset scheduled\n", ChannelExtension->StreamNumber));
    pWorkItem = (PUSBCAMD_WORK_ITEM)USBCAMD_ExAllocatePool(NonPagedPool, sizeof(USBCAMD_WORK_ITEM));

    if (pWorkItem) {

        ExInitializeWorkItem(&pWorkItem->WorkItem,
                             USBCAMD_ResetWorkItem,
                             pWorkItem);

        pWorkItem->ChannelExtension = ChannelExtension;

        ChannelExtension->StreamError = TRUE;

        ExQueueWorkItem(&pWorkItem->WorkItem, CriticalWorkQueue);

    } else {
        //
        // failed to schedule the timeout
        //
        InterlockedDecrement(&DeviceExtension->TimeoutCount[ChannelExtension->StreamNumber]);
    }
    return TRUE;
}


VOID
USBCAMD_ResetWorkItem(
    PVOID Context
    )
/*++

Routine Description:

    Work item executed at passive level to reset the camera

Arguments:

Return Value:

    None.

--*/
{
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension;
    ULONG StreamNumber;

    channelExtension = ((PUSBCAMD_WORK_ITEM)Context)->ChannelExtension;
    ASSERT_CHANNEL(channelExtension);
    deviceExtension = channelExtension->DeviceExtension;
    StreamNumber = channelExtension->StreamNumber;
    
    // if we are dealing with a virtual still channel. then no HW reset is required on 
    // this channel. The video channel will eventually reset the ISO pipe since they both
    // use the same pipe.

    if (!channelExtension->VirtualStillPin) {
        NTSTATUS ntStatus;
        ULONG portStatus;

        //
        // Check the port state.
        //

        ntStatus = USBCAMD_GetPortStatus(
            deviceExtension,
            channelExtension, 
            &portStatus
            );

        if (NT_SUCCESS(ntStatus)) {

            if (!(portStatus & USBD_PORT_CONNECTED) ) {

                USBCAMD_KdPrint (MIN_TRACE, ("***ERROR*** :USB Port Disconnected...\n"));
            }
        
            // Either an ISO or BULK transfer has gone bad, and we need
            // to reset the pipe associated with this channel
    
            USBCAMD_KdPrint(MIN_TRACE, ("USB Error on Stream # %d. Reset Pipe.. \n", StreamNumber));

    #ifdef MAX_DEBUG
            USBCAMD_DumpReadQueues(deviceExtension);
    #endif

            USBCAMD_ResetChannel(deviceExtension,
                                 channelExtension,
                                 portStatus,
                                 ntStatus);  

            // Indicate that the stream error condition is over (for now)
            channelExtension->StreamError = FALSE;
        }
        else {
            USBCAMD_KdPrint(MIN_TRACE, ("Fatal USB Error on Stream # %d... \n", StreamNumber));

            if ( channelExtension->ImageCaptureStarted) {
                //
                // stop this channel and cancel all IRPs, SRBs.
                //
                USBCAMD_KdPrint(MIN_TRACE,("S#%d stopping on error.\n", StreamNumber));
                USBCAMD_StopChannel(deviceExtension,channelExtension);
            }

            if ( channelExtension->ChannelPrepared) {
                //
                // Free memory and bandwidth
                //
                USBCAMD_KdPrint(MIN_TRACE,("S#%d unpreparing on error.\n", StreamNumber));
                USBCAMD_UnPrepareChannel(deviceExtension,channelExtension);
            }
        }
    }

    // OK to handle another reset now
    InterlockedDecrement(&deviceExtension->TimeoutCount[StreamNumber]);
    
    USBCAMD_ExFreePool(Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\usbcamd\usbcamd.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    usbcamd.c

Abstract:

    USB device driver for camera

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

    Original 3/96 John Dunn
    Updated  3/98 Husni Roukbi
    Updated  3/01 David Goll

--*/

#include "usbcamd.h"

BOOLEAN Win98 = FALSE;

#if DBG
// Global debug vars
ULONG USBCAMD_StreamEnable = 1;                 // Non-zero permits streaming
ULONG USBCAMD_DebugTraceLevel = NON_TRACE;      // Governs debug output
PUSBCAMD_LOG_ENTRY USBCAMD_LogBuffer = NULL;    // Address of memory log buffer (if used)
ULONG USBCAMD_LogRefCnt = 0;                    // The number of instances using the log buffer
ULONG USBCAMD_LogMask = 0;                      // Determines the type of log entries
LONG USBCAMD_MaxLogEntries = 0;                 // The number of 16-byte log entries to allow
LONG USBCAMD_LastLogEntry = -1;                 // The index into the log buffer (16-byte boundary)

NTSTATUS
USBCAMD_GetRegValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *Information
    )

/*++

Routine Description:

    Copied from IopGetRegistryValue().
    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePool( NonPagedPool, keyValueLength );
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}

NTSTATUS
USBCAMD_GetRegDword(
    HANDLE h,
    PWCHAR ValueName,
    PULONG pDword)
{
    NTSTATUS Status;
    PKEY_VALUE_FULL_INFORMATION pFullInfo;

    Status = USBCAMD_GetRegValue( h, ValueName, &pFullInfo );
    if ( NT_SUCCESS( Status ) ) {
        *pDword = *(PULONG)((PUCHAR)pFullInfo+pFullInfo->DataOffset);
        ExFreePool( pFullInfo );
    }
    return Status;
}

NTSTATUS
USBCAMD_SetRegDword(
    IN HANDLE KeyHandle,
    IN PWCHAR ValueName,
    IN ULONG  ValueData
    )

/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) 
type.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the name of the value key

    ValueData - Supplies a pointer to the value to be stored in the key.  

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    ASSERT(ValueName);

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Set the registry value
    //
    Status = ZwSetValueKey(KeyHandle,
                    &unicodeString,
                    0,
                    REG_DWORD,
                    &ValueData,
                    sizeof(ValueData));
    
    return Status;
}


NTSTATUS
USBCAMD_CreateDbgReg(void)
{
    NTSTATUS Status;
    HANDLE   hDebugRegKey;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING  PathName;
    ULONG ulDisposition;
    ULONG dword;
    static WCHAR strDebugTraceLevel[]=L"DebugTraceLevel";
    static WCHAR strMaxLogEntries[]=L"MaxLogEntries";
    static WCHAR strLogMask[]=L"LogMask";

    RtlInitUnicodeString(&PathName, USBCAMD_REG_DBG_STREAM);
    
    InitializeObjectAttributes(
        &objectAttributes,
        &PathName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    
    Status = ZwCreateKey(
        &hDebugRegKey,
        KEY_ALL_ACCESS,
        &objectAttributes,
        0,                  // title index
        NULL,               // class
        0,                  // create options
        &ulDisposition
        );
    if (NT_SUCCESS(Status)) {
        //
        // getset USBCAMD_DebugTraceLevel
        //
        Status = USBCAMD_GetRegDword( hDebugRegKey, strDebugTraceLevel, &dword);
        if ( NT_SUCCESS( Status )) {
            USBCAMD_DebugTraceLevel = dword;
        }
        else if ( STATUS_OBJECT_NAME_NOT_FOUND == Status ) {
            //
            // create one with the default value
            //
            Status = USBCAMD_SetRegDword(hDebugRegKey, strDebugTraceLevel, NON_TRACE);
            ASSERT( NT_SUCCESS( Status ));

            USBCAMD_DebugTraceLevel = NON_TRACE;
        }

        //
        // getset LogMask
        //        
        Status = USBCAMD_GetRegDword( hDebugRegKey, strLogMask, &dword);
        if ( NT_SUCCESS( Status )) {
            USBCAMD_LogMask=dword;
        }
        else if ( STATUS_OBJECT_NAME_NOT_FOUND == Status ) {
            //
            // create one with the default
            //
            Status = USBCAMD_SetRegDword(hDebugRegKey, strLogMask, DEFAULT_LOG_LEVEL);
            ASSERT( NT_SUCCESS( Status ));

            USBCAMD_LogMask = DEFAULT_LOG_LEVEL;
        }        
        
        //
        // getset MaxLogEntries
        //
        Status = USBCAMD_GetRegDword( hDebugRegKey, strMaxLogEntries, &dword);
        if ( NT_SUCCESS( Status )) {
            USBCAMD_MaxLogEntries=(LONG)dword;
        }
        
        else if ( STATUS_OBJECT_NAME_NOT_FOUND == Status ) {
            //
            // create one with the default value
            //
            Status = USBCAMD_SetRegDword(hDebugRegKey, strMaxLogEntries, DEFAULT_MAX_LOG_ENTRIES);
            ASSERT( NT_SUCCESS( Status ));

            USBCAMD_MaxLogEntries = DEFAULT_MAX_LOG_ENTRIES;
        }

        ZwClose(hDebugRegKey);
    }

    return Status;
}

NTSTATUS
USBCAMD_InitDbg(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (InterlockedIncrement(&USBCAMD_LogRefCnt) == 1) {

        // First one here, so go ahead and initialize

        Status = USBCAMD_CreateDbgReg(); // read or create

        if (NT_SUCCESS(Status)) {

            if (USBCAMD_MaxLogEntries) {

                USBCAMD_LogBuffer = ExAllocatePool( NonPagedPool, USBCAMD_MaxLogEntries*sizeof(USBCAMD_LOG_ENTRY));            
                if (NULL == USBCAMD_LogBuffer ) {

                    USBCAMD_KdPrint(MIN_TRACE, ("Cannot allocate log buffer for %d entries\n", USBCAMD_MaxLogEntries));
                    USBCAMD_LogMask = 0; // disable logging

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
                else {
                    USBCAMD_KdPrint(MIN_TRACE, ("Allocated log buffer for %d entries\n", USBCAMD_MaxLogEntries));
                }
            }
        }
    }
    return Status;
}

NTSTATUS
USBCAMD_ExitDbg(void)
{
    if (InterlockedDecrement(&USBCAMD_LogRefCnt) == 0) {

        // Last one out, free the buffer

        if (USBCAMD_LogBuffer) {

            USBCAMD_KdPrint(MIN_TRACE, ("Log buffer released\n"));

            ExFreePool(USBCAMD_LogBuffer);
            USBCAMD_LogBuffer = NULL;
        }
    }

    return STATUS_SUCCESS;
}

void
USBCAMD_DbgLogInternal(
    ULONG Tag,
    ULONG_PTR Arg1,
    ULONG_PTR Arg2,
    ULONG_PTR Arg3
    )
{
    PUSBCAMD_LOG_ENTRY LogEntry;
    LONG Index;

    // The following loop allows for rolling the index over when multiple threads are
    // competing for the privilege.
    while ( (Index = InterlockedIncrement(&USBCAMD_LastLogEntry)) >= USBCAMD_MaxLogEntries) {

        // Attempt to be the first to restart the counter. Even if another thread beat us
        // to it, the next iteration will dump us out of the loop with a valid index.
        InterlockedCompareExchange(&USBCAMD_LastLogEntry, -1L, USBCAMD_MaxLogEntries);
    }

    LogEntry = &USBCAMD_LogBuffer[Index];
    
    LogEntry->u.Tag = Tag;
    LogEntry->Arg1 = Arg1;
    LogEntry->Arg2 = Arg2;
    LogEntry->Arg3 = Arg3;

    return;
}

#define USBCAMD_DBG_TIMER_LIMIT 8
static LARGE_INTEGER StartTimes[USBCAMD_DBG_TIMER_LIMIT] = { 0 };
static int TimeIndex = 0;

NTSTATUS
USBCAMD_StartClock(void)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (TimeIndex < USBCAMD_DBG_TIMER_LIMIT) {

        KeQuerySystemTime(&StartTimes[TimeIndex]);
        TimeIndex++;
    }
    else
        ntStatus = STATUS_UNSUCCESSFUL;

    return ntStatus;
}

ULONG
USBCAMD_StopClock(void)
{
    ULONG rc = 0;

    if (TimeIndex > 0) {

        LARGE_INTEGER StopTime;

        KeQuerySystemTime(&StopTime);
        TimeIndex--;

        StopTime.QuadPart -= StartTimes[TimeIndex].QuadPart;
        StopTime.QuadPart /= 10000; // convert to ms

        rc = (ULONG)StopTime.QuadPart;
    }

    return rc;
}

#endif // DBG

NTSTATUS
USBCAMD_QueryCapabilities(
    IN PUSBCAMD_DEVICE_EXTENSION pDeviceExt
    )

/*++

Routine Description:

    This routine generates an internal IRP from this driver to the PDO
    to obtain information on the Physical Device Object's capabilities.
    We are most interested in learning which system power states
    are to be mapped to which device power states for honoring 
IRP_MJ_SET_POWER Irps.

    This is a blocking call which waits for the IRP completion routine
    to set an event on finishing.

Arguments:


Return Value:

    NTSTATUS value from the IoCallDriver() call.

--*/

{
    PDEVICE_CAPABILITIES pDeviceCapabilities = &pDeviceExt->DeviceCapabilities;
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    // Build an IRP for us to generate an internal query request to the PDO
    irp = IoAllocateIrp(pDeviceExt->StackDeviceObject->StackSize, FALSE);

    if (!irp) 
        return STATUS_INSUFFICIENT_RESOURCES;
    
    nextStack = IoGetNextIrpStackLocation(irp);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;

    // init an event to tell us when the completion routine's been called
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    // Set a completion routine so it can signal our event when
    //  the next lower driver is done with the Irp
    IoSetCompletionRoutine(irp,USBCAMD_CallUsbdCompletion,&event,TRUE,TRUE,TRUE);   

    RtlZeroMemory(pDeviceCapabilities, sizeof(*pDeviceCapabilities));
    pDeviceCapabilities->Size = sizeof(*pDeviceCapabilities);
    pDeviceCapabilities->Version = 1;
    pDeviceCapabilities->Address = -1;
    pDeviceCapabilities->UINumber = -1;

    // set our pointer to the DEVICE_CAPABILITIES struct
    nextStack->Parameters.DeviceCapabilities.Capabilities = pDeviceCapabilities;

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    ntStatus = IoCallDriver(pDeviceExt->StackDeviceObject,irp);

    if (ntStatus == STATUS_PENDING) {       // wait for irp to complete
       KeWaitForSingleObject(&event,Suspended,KernelMode,FALSE,NULL);
       ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);
    return ntStatus;
}


//---------------------------------------------------------------------------
// USBCAMD_StartDevice
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_StartDevice(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Initializes a given instance of the camera device on the USB.

Arguments:

    deviceExtension - points to the driver specific DeviceExtension

    Irp - Irp associated with this request


Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
    PURB urb;
    ULONG siz,i;

    USBCAMD_KdPrint (MIN_TRACE, ("enter USBCAMD_StartDevice\n"));

    KeInitializeSemaphore(&DeviceExtension->Semaphore, 1, 1);
    KeInitializeSemaphore(&DeviceExtension->CallUSBSemaphore, 1, 1);

    //
    // Fetch the device descriptor for the device
    //
    urb = USBCAMD_ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (urb) {

        siz = sizeof(USB_DEVICE_DESCRIPTOR);

        deviceDescriptor = USBCAMD_ExAllocatePool(NonPagedPool,
                                                  siz);

        if (deviceDescriptor) {

            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_DEVICE_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         deviceDescriptor,
                                         NULL,
                                         siz,
                                         NULL);

            ntStatus = USBCAMD_CallUSBD(DeviceExtension, urb,0,NULL);

            if (NT_SUCCESS(ntStatus)) {
                USBCAMD_KdPrint (MAX_TRACE, ("'Device Descriptor = %x, len %x\n",
                                deviceDescriptor,
                                urb->UrbControlDescriptorRequest.TransferBufferLength));

                USBCAMD_KdPrint (MAX_TRACE, ("'USBCAMD Device Descriptor:\n"));
                USBCAMD_KdPrint (MAX_TRACE, ("'-------------------------\n"));
                USBCAMD_KdPrint (MAX_TRACE, ("'bLength %d\n", deviceDescriptor->bLength));
                USBCAMD_KdPrint (MAX_TRACE, ("'bDescriptorType 0x%x\n", deviceDescriptor->bDescriptorType));
                USBCAMD_KdPrint (MAX_TRACE, ("'bcdUSB 0x%x\n", deviceDescriptor->bcdUSB));
                USBCAMD_KdPrint (MAX_TRACE, ("'bDeviceClass 0x%x\n", deviceDescriptor->bDeviceClass));
                USBCAMD_KdPrint (MAX_TRACE, ("'bDeviceSubClass 0x%x\n", deviceDescriptor->bDeviceSubClass));
                USBCAMD_KdPrint (MAX_TRACE, ("'bDeviceProtocol 0x%x\n", deviceDescriptor->bDeviceProtocol));
                USBCAMD_KdPrint (MAX_TRACE, ("'bMaxPacketSize0 0x%x\n", deviceDescriptor->bMaxPacketSize0));
                USBCAMD_KdPrint (MAX_TRACE, ("'idVendor 0x%x\n", deviceDescriptor->idVendor));
                USBCAMD_KdPrint (MAX_TRACE, ("'idProduct 0x%x\n", deviceDescriptor->idProduct));
                USBCAMD_KdPrint (MAX_TRACE, ("'bcdDevice 0x%x\n", deviceDescriptor->bcdDevice));
                USBCAMD_KdPrint (MIN_TRACE, ("'iManufacturer 0x%x\n", deviceDescriptor->iManufacturer));
                USBCAMD_KdPrint (MAX_TRACE, ("'iProduct 0x%x\n", deviceDescriptor->iProduct));
                USBCAMD_KdPrint (MAX_TRACE, ("'iSerialNumber 0x%x\n", deviceDescriptor->iSerialNumber));
                USBCAMD_KdPrint (MAX_TRACE, ("'bNumConfigurations 0x%x\n", deviceDescriptor->bNumConfigurations));
            }
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (NT_SUCCESS(ntStatus)) {
            DeviceExtension->DeviceDescriptor = deviceDescriptor;
        } else if (deviceDescriptor) {
            USBCAMD_ExFreePool(deviceDescriptor);
        }

        USBCAMD_ExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now configure the device.
    //

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBCAMD_ConfigureDevice(DeviceExtension);
    }

    if (NT_SUCCESS(ntStatus)) {
        //
        // initialize our f ref count and semaphores
        //
        for ( i=0; i< MAX_STREAM_COUNT; i++) {
            DeviceExtension->ActualInstances[i] = 0;
        }


        for (i=0; i < MAX_STREAM_COUNT; i++) {
            DeviceExtension->TimeoutCount[i] = -1;
        }
    }

    if (ntStatus != STATUS_SUCCESS){
    //
    // since this failure will return all the way in the IRP_MN_SATRT_DEVICE.
    // the driver will unload w/o sending IRP_MN_REMOVE_DEVICE where we typically
    // do the clean up of our allocated memory. Hence, we need to do it now.
    //
        if (DeviceExtension->DeviceDescriptor) {
            USBCAMD_ExFreePool(DeviceExtension->DeviceDescriptor);
            DeviceExtension->DeviceDescriptor = NULL;
        }
        if (DeviceExtension->Interface) {
            USBCAMD_ExFreePool(DeviceExtension->Interface);
            DeviceExtension->Interface = NULL;
        }
        if ( DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
            if (DeviceExtension->PipePinRelations) {
                USBCAMD_ExFreePool(DeviceExtension->PipePinRelations);
                DeviceExtension->PipePinRelations = NULL;
            }
        }
        //
        // call client driver in order to do some clean up as well
        //
        if ( DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
                     (*DeviceExtension->DeviceDataEx.DeviceData2.CamConfigureEx)(
                                DeviceExtension->StackDeviceObject,
                                USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                                NULL,
                                NULL,
                                0,
                                NULL,
                                NULL);

        }
        else {
                (*DeviceExtension->DeviceDataEx.DeviceData.CamConfigure)(
                     DeviceExtension->StackDeviceObject,
                     USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                     NULL,
                     NULL,
                     NULL,
                     NULL);
        }
    }

    USBCAMD_KdPrint (MIN_TRACE, ("exit USBCAMD_StartDevice (%x)\n", ntStatus));
    return ntStatus;
}


//---------------------------------------------------------------------------
// USBCAMD_RemoveDevice
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_RemoveDevice(
    IN PUSBCAMD_DEVICE_EXTENSION  DeviceExtension
    )
/*++

Routine Description:

    Removes a given instance of the USB camera.

    NOTE: When we get a remove we can asume the device is gone.

Arguments:

    deviceExtension - points to the driver specific DeviceExtension

    Irp - Irp associated with this request

Return Value:

    NT status code

--*/
{
    USBCAMD_KdPrint (MIN_TRACE, ("enter USBCAMD_RemoveDevice\n"));

    if (DeviceExtension->DeviceDescriptor) {

        ASSERT((DeviceExtension->ActualInstances[STREAM_Capture] == 0) &&
            (DeviceExtension->ActualInstances[STREAM_Still] == 0));

        (*DeviceExtension->DeviceDataEx.DeviceData.CamUnInitialize)(
            DeviceExtension->StackDeviceObject,
            USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension)
            );

        if ( DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
            //
            // make sure that camera driver has cancelled a bulk or Interrupt
            // transfer request.
            //

            USBCAMD_CancelOutstandingBulkIntIrps(DeviceExtension,FALSE);

            //
            // and any pipeconif structures.
            //

            if (DeviceExtension->PipePinRelations) {

                USBCAMD_ExFreePool(DeviceExtension->PipePinRelations);
                DeviceExtension->PipePinRelations = NULL;
            }
        }
    
        //
        // Free up any interface structures
        //

        if (DeviceExtension->Interface) {

            USBCAMD_ExFreePool(DeviceExtension->Interface);
            DeviceExtension->Interface = NULL;
        }

        USBCAMD_ExFreePool(DeviceExtension->DeviceDescriptor);
        DeviceExtension->DeviceDescriptor = NULL;
    }

    USBCAMD_KdPrint (MIN_TRACE, ("exit USBCAMD_RemoveDevice\n"));

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// USBCAMD_CallUsbdCompletion()
//
// Completion routine used by USBCAMD_CallUsbd() 
//
//******************************************************************************

NTSTATUS
USBCAMD_CallUsbdCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT kevent = (PKEVENT)Context;
    KeSetEvent(kevent, IO_NO_INCREMENT,FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

//---------------------------------------------------------------------------
// USBCAMD_CallUSBD
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_CallUSBD(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PURB Urb,
    IN ULONG IoControlCode,
    IN PVOID pArgument1
)
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceExtension - pointer to the device extension for this instance of an USB camera

    Urb - pointer to Urb request block
    IoControlCode - If null, will default to IOCTL_INTERNAL_USB_SUBMIT_URB

    pArgument1 - if null, will default to Urb
Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIRP irp;
    KEVENT TimeoutEvent;
    PIO_STACK_LOCATION nextStack;

    USBCAMD_DbgLog(TL_PRF_TRACE, '+bsU', 0, USBCAMD_StartClock(), ntStatus);
    KeWaitForSingleObject(&DeviceExtension->CallUSBSemaphore,Executive,KernelMode,FALSE,NULL);

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&TimeoutEvent,SynchronizationEvent,FALSE);

    // Allocate the Irp
    //
    irp = IoAllocateIrp(DeviceExtension->StackDeviceObject->StackSize, FALSE);

    if (irp == NULL){
        ntStatus =  STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_CallUSB;
    }
    //
    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode =  IoControlCode ? IoControlCode: IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->Parameters.Others.Argument1 = pArgument1? pArgument1: Urb;
    //
    // Set the completion routine.
    //
    IoSetCompletionRoutine(irp,USBCAMD_CallUsbdCompletion,&TimeoutEvent, TRUE, TRUE,TRUE);   
    //
    // pass the irp down usb stack
    //
    if (DeviceExtension->Initialized ) {
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        ntStatus = IoCallDriver(DeviceExtension->StackDeviceObject,irp);
    } else {
        ntStatus = STATUS_DEVICE_NOT_CONNECTED;
    }

    if (ntStatus == STATUS_PENDING) {
        // Irp is pending. we have to wait till completion..
        LARGE_INTEGER timeout;

        // Specify a timeout of 5 seconds to wait for this call to complete.
        //
        timeout.QuadPart = -5 * SECONDS;

        ntStatus = KeWaitForSingleObject(&TimeoutEvent, Executive,KernelMode,FALSE, &timeout);
        if (ntStatus == STATUS_TIMEOUT) {
            ntStatus = STATUS_IO_TIMEOUT;

            // Cancel the Irp we just sent.
            //
            IoCancelIrp(irp);

            // And wait until the cancel completes
            //
            KeWaitForSingleObject(&TimeoutEvent,Executive, KernelMode, FALSE,NULL);
        }
        else {
            ntStatus = irp->IoStatus.Status;
        }
    }
#if DBG
    else {

        USBCAMD_KdPrint (MAX_TRACE, ("return from IoCallDriver USBD %x\n", ntStatus));
    }
#endif

    // Done with the Irp, now free it.
    //
    IoFreeIrp(irp);

Exit_CallUSB:

    USBCAMD_DbgLog(TL_PRF_TRACE, '-bsU', 0, USBCAMD_StopClock(), ntStatus);
    KeReleaseSemaphore(&DeviceExtension->CallUSBSemaphore,LOW_REALTIME_PRIORITY,1,FALSE);

    if (NT_ERROR(ntStatus)) {
        USBCAMD_KdPrint(MIN_TRACE, ("***Error*** USBCAMD_CallUSBD (%x)\n", ntStatus));
    }

    return ntStatus;
}


//---------------------------------------------------------------------------
// USBCAMD_ConfigureDevice
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_ConfigureDevice(
    IN  PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Configure the USB camera.

Arguments:

    DeviceExtension - pointer to the device object for this instance of the USB camera
                    devcice.


Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    ULONG siz;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;

    USBCAMD_KdPrint (MIN_TRACE, ("enter USBCAMD_ConfigureDevice\n"));

    //
    // configure the device
    //

    urb = USBCAMD_ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (urb) {

        siz = 0x40;

get_config_descriptor_retry:

        configurationDescriptor = USBCAMD_ExAllocatePool(NonPagedPool,
                                                 siz);

        if (configurationDescriptor) {

            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         configurationDescriptor,
                                         NULL,
                                         siz,
                                         NULL);

            ntStatus = USBCAMD_CallUSBD(DeviceExtension, urb,0,NULL);

            USBCAMD_KdPrint (MAX_TRACE, ("'Configuration Descriptor = %x, len %x\n",
                            configurationDescriptor,
                            urb->UrbControlDescriptorRequest.TransferBufferLength));
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // if we got some data see if it was enough.
        //
        // NOTE: we may get an error in URB because of buffer overrun
        //
        if (urb->UrbControlDescriptorRequest.TransferBufferLength>0 &&
                configurationDescriptor->wTotalLength > siz) {

            siz = configurationDescriptor->wTotalLength;
            USBCAMD_ExFreePool(configurationDescriptor);
            configurationDescriptor = NULL;
            goto get_config_descriptor_retry;
        }

        USBCAMD_ExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (configurationDescriptor) {

        //
        // Get our pipes
        //
        if (NT_SUCCESS(ntStatus)) {
            ntStatus = USBCAMD_SelectConfiguration(DeviceExtension, configurationDescriptor);

            if (NT_SUCCESS(ntStatus)) {
                ntStatus = (*DeviceExtension->DeviceDataEx.DeviceData.CamInitialize)(
                      DeviceExtension->StackDeviceObject,
                      USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension));
            }
        }

        USBCAMD_ExFreePool(configurationDescriptor);
    }

    USBCAMD_KdPrint (MIN_TRACE, ("'exit USBCAMD_ConfigureDevice (%x)\n", ntStatus));

//    TRAP_ERROR(ntStatus);

    return ntStatus;
}


//---------------------------------------------------------------------------
// USBCAMD_SelectConfiguration
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_SelectConfiguration(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/*++

Routine Description:

    Initializes the USBCAMD camera to configuration one, interface zero

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    ConfigurationDescriptor - pointer to the USB configuration
                    descriptor containing the interface and endpoint
                    descriptors.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PURB urb = NULL;
    ULONG numberOfInterfaces, numberOfPipes,i;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION interface;
    PUSBD_INTERFACE_LIST_ENTRY interfaceList, tmp;
    PUSBCAMD_Pipe_Config_Descriptor PipeConfig = NULL;

    USBCAMD_KdPrint (MIN_TRACE, ("'enter USBCAMD_SelectConfiguration\n"));

    //
    // get this from the config descriptor
    //
    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;

    // We only support cameras with one interface
  //  ASSERT(numberOfInterfaces == 1);


    tmp = interfaceList =
        USBCAMD_ExAllocatePool(PagedPool, sizeof(USBD_INTERFACE_LIST_ENTRY) *
                       (numberOfInterfaces+1));


    if (tmp) {
        
        for ( i = 0; i < numberOfInterfaces; i++ ) {

            interfaceDescriptor =
                USBD_ParseConfigurationDescriptorEx(
                    ConfigurationDescriptor,
                    ConfigurationDescriptor,
                    i,    // interface number
                    -1, //alt setting, don't care
                    -1, // hub class
                    -1, // subclass, don't care
                    -1); // protocol, don't care

            interfaceList->InterfaceDescriptor =
                interfaceDescriptor;
            interfaceList++;

        }
        interfaceList->InterfaceDescriptor = NULL;

        //
        // Allocate a URB big enough for this request
        //

        urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

        if (urb) {

            if ( DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
                numberOfPipes = tmp->Interface->NumberOfPipes;
                PipeConfig = USBCAMD_ExAllocatePool(PagedPool,
                                    sizeof(USBCAMD_Pipe_Config_Descriptor) * numberOfPipes);
                if (PipeConfig ) {

                    ntStatus =
                        (*DeviceExtension->DeviceDataEx.DeviceData2.CamConfigureEx)(
                                DeviceExtension->StackDeviceObject,
                                USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                                tmp->Interface,
                                ConfigurationDescriptor,
                                numberOfPipes,
                                PipeConfig,
                                DeviceExtension->DeviceDescriptor);

                }
                else {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            else {
                ntStatus =
                    (*DeviceExtension->DeviceDataEx.DeviceData.CamConfigure)(
                            DeviceExtension->StackDeviceObject,
                            USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                            tmp->Interface,
                            ConfigurationDescriptor,
                            &DeviceExtension->DataPipe,
                            &DeviceExtension->SyncPipe);
                //
                // initialize the new parameters to default values in order to
                // insure backward compatibilty.
                //

                DeviceExtension->IsoPipeStreamType = STREAM_Capture;
                DeviceExtension->BulkPipeStreamType = -1;
                DeviceExtension->BulkDataPipe = -1;
                DeviceExtension->VirtualStillPin = FALSE;
            }
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        USBCAMD_ExFreePool(tmp);

    }
    else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus)) {

        interface = &urb->UrbSelectConfiguration.Interface;

        USBCAMD_KdPrint (MAX_TRACE, ("'size of interface request = %d\n", interface->Length));

        ntStatus = USBCAMD_CallUSBD(DeviceExtension, urb,0,NULL);

        if (NT_SUCCESS(ntStatus) && USBD_SUCCESS(URB_STATUS(urb))) {

            if ( DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {

                DeviceExtension->PipePinRelations = USBCAMD_ExAllocatePool(NonPagedPool,
                        sizeof(USBCAMD_PIPE_PIN_RELATIONS) * numberOfPipes);
                if ( DeviceExtension->PipePinRelations) {
                    for (i=0; i < numberOfPipes; i++) {
                        DeviceExtension->PipePinRelations[i].PipeType =
                            interface->Pipes[i].PipeType & USB_ENDPOINT_TYPE_MASK;
                        DeviceExtension->PipePinRelations[i].PipeDirection =
                            (interface->Pipes[i].EndpointAddress & USB_ENDPOINT_DIRECTION_MASK) ? INPUT_PIPE : OUTPUT_PIPE;
                        DeviceExtension->PipePinRelations[i].MaxPacketSize =
                            interface->Pipes[i].MaximumPacketSize;
                        DeviceExtension->PipePinRelations[i].PipeConfig = PipeConfig[i];
                        InitializeListHead(&DeviceExtension->PipePinRelations[i].IrpPendingQueue);
                        InitializeListHead(&DeviceExtension->PipePinRelations[i].IrpRestoreQueue);
                        KeInitializeSpinLock (&DeviceExtension->PipePinRelations[i].OutstandingIrpSpinlock);
                    }
                    ntStatus = USBCAMD_Parse_PipeConfig(DeviceExtension,numberOfPipes);
                }
                else {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            //
            // Save the configuration handle for this device
            //

            DeviceExtension->ConfigurationHandle =
                urb->UrbSelectConfiguration.ConfigurationHandle;


            DeviceExtension->Interface = USBCAMD_ExAllocatePool(NonPagedPool,
                                                        interface->Length);

            if (DeviceExtension->Interface) {
                ULONG j;

                //
                // save a copy of the interface information returned
                //
                RtlCopyMemory(DeviceExtension->Interface, interface, interface->Length);

                //
                // Dump the interface to the debugger
                //
                USBCAMD_KdPrint (MAX_TRACE, ("'---------\n"));
                USBCAMD_KdPrint (MAX_TRACE, ("'NumberOfPipes 0x%x\n", DeviceExtension->Interface->NumberOfPipes));
                USBCAMD_KdPrint (MAX_TRACE, ("'Length 0x%x\n", DeviceExtension->Interface->Length));
                USBCAMD_KdPrint (MAX_TRACE, ("'Alt Setting 0x%x\n", DeviceExtension->Interface->AlternateSetting));
                USBCAMD_KdPrint (MAX_TRACE, ("'Interface Number 0x%x\n", DeviceExtension->Interface->InterfaceNumber));

                // Dump the pipe info

                for (j=0; j<interface->NumberOfPipes; j++) {
                    PUSBD_PIPE_INFORMATION pipeInformation;

                    pipeInformation = &DeviceExtension->Interface->Pipes[j];

                    USBCAMD_KdPrint (MAX_TRACE, ("'---------\n"));
                    USBCAMD_KdPrint (MAX_TRACE, ("'PipeType 0x%x\n", pipeInformation->PipeType));
                    USBCAMD_KdPrint (MAX_TRACE, ("'EndpointAddress 0x%x\n", pipeInformation->EndpointAddress));
                    USBCAMD_KdPrint (MAX_TRACE, ("'MaxPacketSize 0x%x\n", pipeInformation->MaximumPacketSize));
                    USBCAMD_KdPrint (MAX_TRACE, ("'Interval 0x%x\n", pipeInformation->Interval));
                    USBCAMD_KdPrint (MAX_TRACE, ("'Handle 0x%x\n", pipeInformation->PipeHandle));
                }

                USBCAMD_KdPrint (MAX_TRACE, ("'---------\n"));

            }
            else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (urb)
    {
        ExFreePool(urb);
        urb = NULL;
    }

    USBCAMD_KdPrint (MIN_TRACE, ("'exit USBCAMD_SelectConfiguration (%x)\n", ntStatus));

    if ( DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
        if (PipeConfig) 
            USBCAMD_ExFreePool(PipeConfig);
    }

    return ntStatus;
}

/*++

Routine Description:


Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.


Return Value:

    NT status code

--*/

NTSTATUS
USBCAMD_Parse_PipeConfig(
     IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
     IN ULONG NumberOfPipes
     )
{
    int i;
    ULONG PinCount;
    NTSTATUS ntStatus= STATUS_SUCCESS;

    PUSBCAMD_PIPE_PIN_RELATIONS PipePinArray;

    PipePinArray = DeviceExtension->PipePinRelations;

    DeviceExtension->VirtualStillPin = FALSE;
    DeviceExtension->DataPipe = -1;
    DeviceExtension->SyncPipe = -1;
    DeviceExtension->BulkDataPipe = -1;
    DeviceExtension->IsoPipeStreamType = -1;
    DeviceExtension->BulkPipeStreamType = -1;
    PinCount = 0;

    ASSERT (PipePinArray);

    for ( i=0; i < (int)NumberOfPipes; i++) {

        if (PipePinArray[i].PipeConfig.PipeConfigFlags & USBCAMD_DONT_CARE_PIPE) {
            continue; // this pipe has no use for us.
        }
        switch ( PipePinArray[i].PipeConfig.PipeConfigFlags) {

        case USBCAMD_MULTIPLEX_PIPE:

            if ((PipePinArray[i].PipeConfig.StreamAssociation & USBCAMD_VIDEO_STILL_STREAM) &&
                (PipePinArray[i].PipeDirection & INPUT_PIPE  ) ) {
                    // we found an input data pipe (iso or bulk) that is used for both
                    // video & still.
                    if ( PipePinArray[i].PipeType & UsbdPipeTypeIsochronous) {
                        // we found an input iso pipe that is used for video data.
                        DeviceExtension->DataPipe = i;
                        DeviceExtension->IsoPipeStreamType = STREAM_Capture;
                    }
                    else if (PipePinArray[i].PipeType & UsbdPipeTypeBulk) {
                        // we found an input bulk pipe that is used for video data.
                        DeviceExtension->BulkDataPipe = i;
                        DeviceExtension->BulkPipeStreamType = STREAM_Capture;
                    }
                    DeviceExtension->VirtualStillPin = TRUE;
                    PinCount += 2;
            }
            break;

        case USBCAMD_SYNC_PIPE:

            if ((PipePinArray[i].PipeType & UsbdPipeTypeIsochronous) &&
                (PipePinArray[i].PipeDirection & INPUT_PIPE  ) ) {
                    // we found an input iso pipe that is used for out of band signalling.
                    DeviceExtension->SyncPipe = i;
            }
            break;

        case USBCAMD_DATA_PIPE:

            if ((PipePinArray[i].PipeConfig.StreamAssociation != USBCAMD_VIDEO_STILL_STREAM )&&
                (PipePinArray[i].PipeDirection & INPUT_PIPE  ) ) {
                // we found an input iso or bulk pipe that is used exclusively per video or still
                // stream.
                if ( PipePinArray[i].PipeType & UsbdPipeTypeIsochronous) {
                    // we found an input iso pipe that is used for video or still.
                    DeviceExtension->DataPipe = i;
                    DeviceExtension->IsoPipeStreamType =
                        (PipePinArray[i].PipeConfig.StreamAssociation & USBCAMD_VIDEO_STREAM ) ?
                            STREAM_Capture: STREAM_Still;
                }
                else if (PipePinArray[i].PipeType & UsbdPipeTypeBulk) {
                    // we found an input bulk pipe that is used for video or still data.
                    DeviceExtension->BulkDataPipe = i;
                    DeviceExtension->BulkPipeStreamType =
                        PipePinArray[i].PipeConfig.StreamAssociation & USBCAMD_VIDEO_STREAM  ?
                            STREAM_Capture: STREAM_Still;
                }
                PinCount++;
            }
            break;

        default:
            break;
        }
    }

    // override the default pin count of one with the actual pin count.
    if ( PinCount != 0 ) {
        DeviceExtension->StreamCount = PinCount;
    }

    //
    // Dump the result to the debugger
    //
    USBCAMD_KdPrint (MIN_TRACE, ("NumberOfPins %d\n", PinCount));
    USBCAMD_KdPrint (MIN_TRACE, ("IsoPipeIndex %d\n", DeviceExtension->DataPipe));
    USBCAMD_KdPrint (MIN_TRACE, ("IsoPipeStreamtype %d\n", DeviceExtension->IsoPipeStreamType));
    USBCAMD_KdPrint (MIN_TRACE, ("Sync Pipe Index %d\n", DeviceExtension->SyncPipe));
    USBCAMD_KdPrint (MIN_TRACE, ("Bulk Pipe Index %d\n", DeviceExtension->BulkDataPipe));
    USBCAMD_KdPrint (MIN_TRACE, ("BulkPipeStreamType %d\n", DeviceExtension->BulkPipeStreamType));

    // do some error checing in here.
    // if both data pipe and bulk data pipes are not set, then return error.
    if (((DeviceExtension->DataPipe == -1) && (DeviceExtension->BulkDataPipe == -1)) ||
         (PinCount > MAX_STREAM_COUNT)){
        // cam driver provided mismatched data.
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
}

//---------------------------------------------------------------------------
// USBCAMD_SelectAlternateInterface
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_SelectAlternateInterface(
    IN PVOID DeviceContext,
    IN PUSBD_INTERFACE_INFORMATION RequestInterface
    )
/*++

Routine Description:

    Select one of the cameras alternate interfaces

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    ChannelExtension - extension specific to this video channel

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    ULONG siz;
    PUSBD_INTERFACE_INFORMATION interface;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;

    USBCAMD_KdPrint (MIN_TRACE, ("'enter USBCAMD_SelectAlternateInterface\n"));

    USBCAMD_DbgLog(TL_PRF_TRACE, '+IAS', 0, USBCAMD_StartClock(), 0);
    deviceExtension = USBCAMD_GET_DEVICE_EXTENSION(DeviceContext);

    if (deviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {

        //
        // before we process this request, we need to cancel all outstanding
        // IRPs for this interface on all pipes (bulk, interupt)
        //
        ntStatus = USBCAMD_CancelOutstandingBulkIntIrps(deviceExtension,TRUE);

        if (!NT_SUCCESS(ntStatus)) {
            USBCAMD_KdPrint (MIN_TRACE, ("Failed to Cancel outstanding (Bulk/Int.)IRPs.\n"));
            ntStatus = STATUS_DEVICE_DATA_ERROR;
            return ntStatus;
        }
    }

    //
    // Dump the current interface
    //

    ASSERT(deviceExtension->Interface != NULL);


    siz = GET_SELECT_INTERFACE_REQUEST_SIZE(deviceExtension->Interface->NumberOfPipes);

    USBCAMD_KdPrint (MAX_TRACE, ("size of interface request Urb = %d\n", siz));

    urb = USBCAMD_ExAllocatePool(NonPagedPool, siz);

    if (urb) {

        interface = &urb->UrbSelectInterface.Interface;

        RtlCopyMemory(interface,
                      RequestInterface,
                      RequestInterface->Length);

        // set up the request for the first and only interface

        USBCAMD_KdPrint (MAX_TRACE, ("'size of interface request = %d\n", interface->Length));

        urb->UrbHeader.Function = URB_FUNCTION_SELECT_INTERFACE;
        urb->UrbHeader.Length = (int)siz;
        urb->UrbSelectInterface.ConfigurationHandle =
            deviceExtension->ConfigurationHandle;

        ntStatus = USBCAMD_CallUSBD(deviceExtension, urb,0,NULL);


        if (NT_SUCCESS(ntStatus) && USBD_SUCCESS(URB_STATUS(urb))) {

            ULONG j;

            //
            // save a copy of the interface information returned
            //
            RtlCopyMemory(deviceExtension->Interface, interface, interface->Length);
            RtlCopyMemory(RequestInterface, interface, interface->Length);

            //
            // Dump the interface to the debugger
            //
            USBCAMD_KdPrint (MAX_TRACE, ("'---------\n"));
            USBCAMD_KdPrint (MAX_TRACE, ("'NumberOfPipes 0x%x\n", deviceExtension->Interface->NumberOfPipes));
            USBCAMD_KdPrint (MAX_TRACE, ("'Length 0x%x\n", deviceExtension->Interface->Length));
            USBCAMD_KdPrint (MIN_TRACE, ("'Alt Setting 0x%x\n", deviceExtension->Interface->AlternateSetting));
            USBCAMD_KdPrint (MAX_TRACE, ("'Interface Number 0x%x\n", deviceExtension->Interface->InterfaceNumber));

            // Dump the pipe info

            for (j=0; j<interface->NumberOfPipes; j++) {
                PUSBD_PIPE_INFORMATION pipeInformation;

                pipeInformation = &deviceExtension->Interface->Pipes[j];

                USBCAMD_KdPrint (MAX_TRACE, ("'---------\n"));
                USBCAMD_KdPrint (MAX_TRACE, ("'PipeType 0x%x\n", pipeInformation->PipeType));
                USBCAMD_KdPrint (MAX_TRACE, ("'EndpointAddress 0x%x\n", pipeInformation->EndpointAddress));
                USBCAMD_KdPrint (MAX_TRACE, ("'MaxPacketSize 0x%x\n", pipeInformation->MaximumPacketSize));
                USBCAMD_KdPrint (MAX_TRACE, ("'Interval 0x%x\n", pipeInformation->Interval));
                USBCAMD_KdPrint (MAX_TRACE, ("'Handle 0x%x\n", pipeInformation->PipeHandle));
            }

            //
            // success update our internal state to
            // indicate the new frame rate
            //

            USBCAMD_KdPrint (MAX_TRACE, ("'Selecting Camera Interface\n"));
        }

        USBCAMD_ExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (deviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {

        // restore the cancelled Interrupt or bulk IRPs if any.
        USBCAMD_RestoreOutstandingBulkIntIrps(deviceExtension);
    }

    USBCAMD_KdPrint (MIN_TRACE, ("'exit USBCAMD_SelectAlternateInterface (%x)\n", ntStatus));

//    TRAP_ERROR(ntStatus);
    USBCAMD_DbgLog(TL_PRF_TRACE, '-IAS', 0, USBCAMD_StopClock(), ntStatus);

    return ntStatus;
}


//---------------------------------------------------------------------------
// USBCAMD_OpenChannel
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_OpenChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PVOID Format
    )
/*++

Routine Description:

    Opens a video or still stream on the device.

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension
    ChannelExtension - context data for this channel.
    Format - pointer to format information associated with this
            channel.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG i,StreamNumber;

    USBCAMD_SERIALIZE(DeviceExtension);

    USBCAMD_KdPrint( MIN_TRACE, ("'enter USBCAMD_OpenChannel %x\n", Format));

    //
    // Initialize structures for this channel
    //
    ChannelExtension->Sig = USBCAMD_CHANNEL_SIG;
    ChannelExtension->DeviceExtension = DeviceExtension;
    ChannelExtension->CurrentFormat = Format;
    ChannelExtension->RawFrameLength = 0;
    ChannelExtension->CurrentFrameIsStill = FALSE;
    ChannelExtension->IdleIsoStream = FALSE;


#if DBG
    // verify our serialization is working
    ChannelExtension->InCam = 0;
    ChannelExtension->InCam++;
    ASSERT(ChannelExtension->InCam == 1);
#endif

    StreamNumber = ChannelExtension->StreamNumber;

    if (DeviceExtension->ActualInstances[StreamNumber] > 0) {
        // channel already open
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        goto USBCAMD_OpenChannel_Done;
    }


    //
    // empty read list
    //
    InitializeListHead(&ChannelExtension->PendingIoList);

    //
    // no current Irp
    //
    ChannelExtension->CurrentRequest = NULL;

    //
    // streaming is off
    //
    ChannelExtension->ImageCaptureStarted = FALSE;

    //
    // Channel not prepared
    //
    ChannelExtension->ChannelPrepared = FALSE;

    //
    // No error condition
    //
    ChannelExtension->StreamError = FALSE;

    //
    // no stop requests are pending
    //
    ChannelExtension->Flags = 0;

    //
    // initialize the io list spin lock
    //

    KeInitializeSpinLock(&ChannelExtension->PendingIoListSpin);

    //
    // and current request spin lock.
    //
    KeInitializeSpinLock(&ChannelExtension->CurrentRequestSpinLock);

    //
    // and current transfer spin lock.
    //
    KeInitializeSpinLock(&ChannelExtension->TransferSpinLock);

    //
    // initialize the idle transfer lock
    //
    USBCAMD_InitializeIdleLock(&ChannelExtension->IdleLock);

    //
    // initialize streaming structures
    //

    for (i=0; i< USBCAMD_MAX_REQUEST; i++) {
        ChannelExtension->TransferExtension[i].ChannelExtension = NULL;
        ChannelExtension->TransferExtension[i].DataIrp = NULL;
        ChannelExtension->TransferExtension[i].DataUrb = NULL;
        ChannelExtension->TransferExtension[i].SyncIrp = NULL;
        ChannelExtension->TransferExtension[i].SyncUrb = NULL;
        ChannelExtension->TransferExtension[i].WorkBuffer = NULL;
    }


USBCAMD_OpenChannel_Done:

    USBCAMD_KdPrint( MIN_TRACE, ("'exit USBCAMD_OpenChannel (%x)\n", ntStatus));


#if DBG
    ChannelExtension->InCam--;
    ASSERT(ChannelExtension->InCam == 0);
#endif

    USBCAMD_RELEASE(DeviceExtension);

    return ntStatus;
}


//---------------------------------------------------------------------------
// USBCAMD_CloseChannel
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_CloseChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    )
/*++

Routine Description:

    Closes a video channel.

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension

    ChannelExtension - context data for this channel.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBCAMD_READ_EXTENSION readExtension;
    int StreamNumber;
    USBCAMD_SERIALIZE(DeviceExtension);

    USBCAMD_KdPrint( MIN_TRACE, ("'enter USBCAMD_CloseChannel\n"));

#if DBG
    ChannelExtension->InCam++;
    ASSERT(ChannelExtension->InCam == 1);
#endif


    StreamNumber = ChannelExtension->StreamNumber;
    DeviceExtension->ActualInstances[StreamNumber]--;

    //
    // since we only support one channel this
    // should be zero
    //
    ASSERT(DeviceExtension->ActualInstances[StreamNumber] == 0);

    //
    // NOTE:
    // image capture should be stopped/unprepared when we get here
    //

    ASSERT_CHANNEL(ChannelExtension);
    ASSERT(ChannelExtension->ImageCaptureStarted == FALSE);
    ASSERT(ChannelExtension->CurrentRequest == NULL);
    ASSERT(ChannelExtension->ChannelPrepared == FALSE);

#if DBG
    ChannelExtension->InCam--;
    ASSERT(ChannelExtension->InCam == 0);
#endif

    USBCAMD_RELEASE(DeviceExtension);

    //
    // allow any pending reset events to run now
    //
    while (DeviceExtension->TimeoutCount[StreamNumber] >= 0) {

        LARGE_INTEGER dueTime;

        dueTime.QuadPart = -2 * MILLISECONDS;

        KeDelayExecutionThread(KernelMode,
                                      FALSE,
                                      &dueTime);
    }

    USBCAMD_KdPrint( MIN_TRACE, ("'exit USBCAMD_CloseChannel (%x)\n", ntStatus));

    return ntStatus;
}


//---------------------------------------------------------------------------
// USBCAMD_PrepareChannel
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_PrepareChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    )
/*++

Routine Description:

    Prepare the Video channel for streaming, this is where the necessary
        USB BW is allocated.

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension

    Irp - Irp associated with this request.

    ChannelExtension - context data for this channel.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    LONG StreamNumber;
    ULONG i;
    HANDLE hThread;

    USBCAMD_SERIALIZE(DeviceExtension);

    USBCAMD_KdPrint (MIN_TRACE, ("'enter USBCAMD_PrepareChannel\n"));

    StreamNumber = ChannelExtension->StreamNumber;

    ASSERT_CHANNEL(ChannelExtension);

    if (ChannelExtension->ChannelPrepared ||
        ChannelExtension->ImageCaptureStarted) {
        // fail the call if the channel is not in the
        // proper state.
        TRAP();
        ntStatus = STATUS_UNSUCCESSFUL;
        goto USBCAMD_PrepareChannel_Done;
    }

    //
    // This driver function will select the appropriate alternate
    // interface.
    // This code performs the select_alt interface and gets us the
    // pipehandles
    //
    USBCAMD_DbgLog(TL_PRF_TRACE, '+WBa', StreamNumber, USBCAMD_StartClock(), ntStatus);
    if (DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {

        ntStatus =
            (*DeviceExtension->DeviceDataEx.DeviceData2.CamAllocateBandwidthEx)(
                    DeviceExtension->StackDeviceObject,
                    USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                    &ChannelExtension->RawFrameLength,
                    ChannelExtension->CurrentFormat,
                    StreamNumber);

        if (NT_SUCCESS(ntStatus)) {
            ntStatus =
                (*DeviceExtension->DeviceDataEx.DeviceData2.CamStartCaptureEx)(
                        DeviceExtension->StackDeviceObject,
                        USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                        StreamNumber);
        }

    }
    else {

        ntStatus =
            (*DeviceExtension->DeviceDataEx.DeviceData.CamAllocateBandwidth)(
                    DeviceExtension->StackDeviceObject,
                    USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                    &ChannelExtension->RawFrameLength,
                    ChannelExtension->CurrentFormat);

        if (NT_SUCCESS(ntStatus)) {
            ntStatus =
                (*DeviceExtension->DeviceDataEx.DeviceData.CamStartCapture)(
                        DeviceExtension->StackDeviceObject,
                        USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension));
        }
    }
    USBCAMD_DbgLog(TL_PRF_TRACE, '-WBa', StreamNumber, USBCAMD_StopClock(), ntStatus);

    if ( ChannelExtension->RawFrameLength == 0 ) {
        ntStatus = STATUS_DEVICE_DATA_ERROR;  // client driver provided false info.
        goto USBCAMD_PrepareChannel_Done;   // pin open will fail.
    }
    
    if (NT_SUCCESS(ntStatus)) {

        //
        // we have the BW, go ahead and initailize our iso or bulk structures
        //

        // associate the right pipe index with this channel datapipe index.
        // we will never get here for a virtual still pin open.

        if (StreamNumber == DeviceExtension->IsoPipeStreamType ) {
            ChannelExtension->DataPipe = DeviceExtension->DataPipe;
            ChannelExtension->DataPipeType = UsbdPipeTypeIsochronous;

            ntStatus = USBCAMD_StartIsoThread(DeviceExtension); // start iso thread.
            if (!NT_SUCCESS(ntStatus))
                goto USBCAMD_PrepareChannel_Done;
            else 
                USBCAMD_KdPrint (MIN_TRACE,("Iso Thread Started\n"));
        }
        else if (StreamNumber == DeviceExtension->BulkPipeStreamType ) {
            ChannelExtension->DataPipe = DeviceExtension->BulkDataPipe;
            ChannelExtension->DataPipeType = UsbdPipeTypeBulk;
            //
            // allocate bulk buffers for each transfer extension.
            //
            for ( i =0; i < USBCAMD_MAX_REQUEST; i++) {
                ChannelExtension->TransferExtension[i].DataBuffer =
                    USBCAMD_AllocateRawFrameBuffer(ChannelExtension->RawFrameLength);

                if (ChannelExtension->TransferExtension[i].DataBuffer == NULL) {
                    USBCAMD_KdPrint (MIN_TRACE, ("'Bulk buffer alloc failed\n"));
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    goto USBCAMD_PrepareChannel_Done;
                }
                ChannelExtension->TransferExtension[i].BufferLength =
                    ChannelExtension->RawFrameLength;   

                // initilize bulk transfer parms.                                        
                ntStatus = USBCAMD_InitializeBulkTransfer(DeviceExtension,
                                                    ChannelExtension,
                                                    DeviceExtension->Interface,
                                                    &ChannelExtension->TransferExtension[i],
                                                    ChannelExtension->DataPipe);
                if (ntStatus != STATUS_SUCCESS) {
                    USBCAMD_KdPrint (MIN_TRACE, ("Bulk Transfer Init failed\n"));
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    goto USBCAMD_PrepareChannel_Done;
                }
            }
        }
        else if ( ChannelExtension->VirtualStillPin) {
            ChannelExtension->DataPipe = DeviceExtension->ChannelExtension[STREAM_Capture]->DataPipe;
            ChannelExtension->DataPipeType = DeviceExtension->ChannelExtension[STREAM_Capture]->DataPipeType;
        }
        else {
            TEST_TRAP();
        }

        ChannelExtension->SyncPipe = DeviceExtension->SyncPipe;

        if ( ChannelExtension->DataPipeType == UsbdPipeTypeIsochronous ) {

            for (i=0; i< USBCAMD_MAX_REQUEST; i++) {

                ntStatus = USBCAMD_InitializeIsoTransfer(DeviceExtension, ChannelExtension, i);

                if (!NT_SUCCESS(ntStatus)) {

                    // The close channel code will clean up anything we
                    // allocated
                    //
                    break;
                }
            }
        }
    }

    if (NT_SUCCESS(ntStatus)) {

        //
        // we have the BW and memory we need
        //

        ChannelExtension->ChannelPrepared = TRUE;
    }

USBCAMD_PrepareChannel_Done:

    USBCAMD_KdPrint (MIN_TRACE, ("'exit USBCAMD_PrepareChannel (%x)\n", ntStatus));

    USBCAMD_RELEASE(DeviceExtension);

    return ntStatus;
}


NTSTATUS
USBCAMD_StartIsoThread(
IN PUSBCAMD_DEVICE_EXTENSION pDeviceExt
)
{
    NTSTATUS ntStatus ;
    HANDLE hThread;
    
    //
    // we are ready to start the thread that handle read SRb completeion 
    // after iso transfer completion routine puts them in the que.
    //
    pDeviceExt->StopIsoThread = FALSE;
    ntStatus = PsCreateSystemThread(&hThread,
                                    (ACCESS_MASK)0,
                                    NULL,
                                    (HANDLE) 0,
                                    NULL,
                                    USBCAMD_ProcessIsoIrps,
                                    pDeviceExt);
        
    if (!NT_SUCCESS(ntStatus)) {                                
        USBCAMD_KdPrint (MIN_TRACE, ("Iso Thread Creation Failed\n"));
        return ntStatus;
    }

    // assert that this DO does not already have a thread
    ASSERT(!pDeviceExt->IsoThreadObject);

    // get a pointer to the thread object.
    ntStatus = ObReferenceObjectByHandle(hThread,
                              THREAD_ALL_ACCESS,
                              NULL,
                              KernelMode,
                              (PVOID *) &pDeviceExt->IsoThreadObject,
                              NULL);
                                  
    if (!NT_SUCCESS(ntStatus)) {
        USBCAMD_KdPrint (MIN_TRACE, ("Failed to get thread object.\n"));
        pDeviceExt->StopIsoThread = TRUE; // Set the thread stop flag
        KeReleaseSemaphore(&pDeviceExt->CompletedSrbListSemaphore,0,1,FALSE);
    }

    // release the thread handle.
    ZwClose( hThread);

    return ntStatus;
}

//---------------------------------------------------------------------------
// USBCAMD_UnPrepareChannel
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_UnPrepareChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    )
/*++

Routine Description:

    Frees resources allocated in PrepareChannel.

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension

    Irp - Irp associated with this request.

    ChannelExtension - context data for this channel.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG i,StreamNumber;

    USBCAMD_SERIALIZE(DeviceExtension);

    USBCAMD_KdPrint (MIN_TRACE, ("'enter USBCAMD_UnPrepareChannel\n"));
    StreamNumber = ChannelExtension->StreamNumber;

    ASSERT_CHANNEL(ChannelExtension);

    if (!ChannelExtension->ChannelPrepared ||
        ChannelExtension->ImageCaptureStarted) {
        // fail the call if the channel is not in the
        // proper state.
        USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_UnPrepareChannel: Channel not in proper state!\n"));
        TRAP();
        ntStatus = STATUS_UNSUCCESSFUL;
        goto USBCAMD_UnPrepareChannel_Done;
    }


    //
    // hopefully put us in the mode that uses no bandwidth
    // ie select and alt interface that has a minimum iso
    // packet size
    //

    if (ChannelExtension->VirtualStillPin == TRUE) {
        ntStatus = STATUS_SUCCESS;
        goto USBCAMD_UnPrepareChannel_Done;
    }

    // attempt to stop
    if (DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
        (*DeviceExtension->DeviceDataEx.DeviceData2.CamStopCaptureEx)(
                DeviceExtension->StackDeviceObject,
                USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                StreamNumber);
    }
    else {
        (*DeviceExtension->DeviceDataEx.DeviceData.CamStopCapture)(
                DeviceExtension->StackDeviceObject,
                USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension));

    }

    if (DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
        ntStatus =
            (*DeviceExtension->DeviceDataEx.DeviceData2.CamFreeBandwidthEx)(
                    DeviceExtension->StackDeviceObject,
                    USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                    StreamNumber);
    }
    else {
        ntStatus =
            (*DeviceExtension->DeviceDataEx.DeviceData.CamFreeBandwidth)(
                    DeviceExtension->StackDeviceObject,
                    USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension));
    }

    if (!NT_SUCCESS(ntStatus)) {
        USBCAMD_KdPrint (MIN_TRACE, (
            "USBCAMD_UnPrepareChannel failed stop capture  (%x)\n", ntStatus));

        //
        // ignore any errors on the stop
        //
        ntStatus = STATUS_SUCCESS;
    }

    //
    // Note:
    // We may get an error here if the camera hs been unplugged,
    // if this is the case we still need to free up the
    // channel resources
    //
    if ( ChannelExtension->DataPipeType == UsbdPipeTypeIsochronous ) {

        for (i=0; i< USBCAMD_MAX_REQUEST; i++) {
            USBCAMD_FreeIsoTransfer(ChannelExtension,
                                    &ChannelExtension->TransferExtension[i]);
        }

        // kill the iso thread.
        USBCAMD_KillIsoThread(DeviceExtension);
    }
    else {
        //
        // free bulk buffers in channel transfer extensions.
        //
        for ( i =0; i < USBCAMD_MAX_REQUEST; i++) {
            if (ChannelExtension->TransferExtension[i].DataBuffer != NULL) {
                USBCAMD_FreeRawFrameBuffer(ChannelExtension->TransferExtension[i].DataBuffer);
                ChannelExtension->TransferExtension[i].DataBuffer = NULL;
            }

            if ( ChannelExtension->ImageCaptureStarted )
                USBCAMD_FreeBulkTransfer(&ChannelExtension->TransferExtension[i]);
        }
    }

USBCAMD_UnPrepareChannel_Done:
    //
    // channel is no longer prepared
    //

    ChannelExtension->ChannelPrepared = FALSE;


    USBCAMD_KdPrint (MIN_TRACE, ("'exit USBCAMD_UnPrepareChannel (%x)\n", ntStatus));

    USBCAMD_RELEASE(DeviceExtension);

    return ntStatus;
}

VOID
USBCAMD_KillIsoThread(
    IN PUSBCAMD_DEVICE_EXTENSION pDeviceExt)
{
    //
    // check if the thread was started..
    //
    if (!pDeviceExt->IsoThreadObject)
        return ;

    USBCAMD_KdPrint (MIN_TRACE,("Waiting for Iso Thread to Terminate\n"));
    pDeviceExt->StopIsoThread = TRUE; // Set the thread stop flag
    // Wake up the thread if asleep.
    
    if (!Win98) {
        KeReleaseSemaphore(&pDeviceExt->CompletedSrbListSemaphore,0,1,TRUE);
        // Wait for the iso thread to kill himself
        KeWaitForSingleObject(pDeviceExt->IsoThreadObject,Executive,KernelMode,FALSE,NULL);
    }
    else 
        KeReleaseSemaphore(&pDeviceExt->CompletedSrbListSemaphore,0,1,FALSE);

    USBCAMD_KdPrint (MAX_TRACE,("Iso Thread Terminated\n"));
    ObDereferenceObject(pDeviceExt->IsoThreadObject);
    pDeviceExt->IsoThreadObject = NULL;
}


//---------------------------------------------------------------------------
// USBCAMD_ReadChannel
//---------------------------------------------------------------------------
void
USBCAMD_ReadChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_READ_EXTENSION ReadExtension
    )
/*++

Routine Description:

    Reads a video frame from a channel.
    NOTE: The SRB cannot be accessed after this function returns,
    as a race condition could result due to insertion into PendingIoList

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension

    Irp - Irp associated with this request.

    ChannelExtension - context data for this channel.

    Mdl - Mdl for this read request.

    Length - Number of bytes to read.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG StreamNumber;
    PHW_STREAM_REQUEST_BLOCK Srb;

    USBCAMD_KdPrint (ULTRA_TRACE, ("'enter USBCAMD_ReadChannel\n"));
    //
    // make sure we don't get reads on a closed channel
    //
    StreamNumber = ChannelExtension->StreamNumber;

    ASSERT_READ(ReadExtension);
    ASSERT_CHANNEL(ChannelExtension);
    ASSERT(DeviceExtension->ActualInstances[StreamNumber] > 0);
    ASSERT(ChannelExtension->ChannelPrepared == TRUE);

    Srb = ReadExtension->Srb;

    if (  ChannelExtension->RawFrameLength == 0) {   
      	 Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
         COMPLETE_STREAM_READ(Srb);        
         return;  
   	}
    //
    // for streaming on bulk pipes. we use the buffer allocated in
    // transfer extension.
    //
    if (ChannelExtension->DataPipeType == UsbdPipeTypeBulk ) {

        ReadExtension->RawFrameLength = ReadExtension->ActualRawFrameLen = 
                ChannelExtension->RawFrameLength;

        ReadExtension->RawFrameBuffer = NULL;
    }
    else { 
        if ( ChannelExtension->NoRawProcessingRequired) {
            // no buffer allocation needed. use DS allocated buffer.
            if ( ChannelExtension->RawFrameLength <=
                  ChannelExtension->VideoInfoHeader->bmiHeader.biSizeImage ){
                ReadExtension->RawFrameBuffer =
                    (PUCHAR) ((PHW_STREAM_REQUEST_BLOCK) Srb)->CommandData.DataBufferArray->Data;
                ReadExtension->RawFrameLength =
                    ((PHW_STREAM_REQUEST_BLOCK) Srb)->CommandData.DataBufferArray->FrameExtent;
            }
            else {
				 Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
				 COMPLETE_STREAM_READ(Srb);   	 
				 return;  
          	}
        }
        else {

            USBCAMD_KdPrint (ULTRA_TRACE, ("RawFrameLength %d\n",ChannelExtension->RawFrameLength));

            ReadExtension->RawFrameLength = ChannelExtension->RawFrameLength;

            ReadExtension->RawFrameBuffer =
                USBCAMD_AllocateRawFrameBuffer(ReadExtension->RawFrameLength);

            if (ReadExtension->RawFrameBuffer == NULL) {
                USBCAMD_KdPrint (MIN_TRACE, ("'Read alloc failed\n"));
                Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
                COMPLETE_STREAM_READ(Srb);
                return;
            }
        }
    }
    
    USBCAMD_DbgLog(TL_SRB_TRACE, 'daeR',
        Srb,
        Srb->CommandData.DataBufferArray->Data,
        0
        );

    USBCAMD_KdPrint (MAX_TRACE, ("Que SRB (%x) S# %d.\n",
                    ReadExtension->Srb ,StreamNumber));

	// Cannot touch SRB after this point
    ExInterlockedInsertTailList( &(ChannelExtension->PendingIoList),
                                     &(ReadExtension->ListEntry),
                                     &ChannelExtension->PendingIoListSpin);

    USBCAMD_KdPrint (ULTRA_TRACE, ("'exit USBCAMD_ReadChannel 0x%x\n", ntStatus));

}

//---------------------------------------------------------------------------
// USBCAMD_StartChannel
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_StartChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION  ChannelExtension
    )
/*++

Routine Description:

    Starts the streaming process for a video channel.

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension

    ChannelExtension - context data for this channel.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG StreamNumber;

    USBCAMD_SERIALIZE(DeviceExtension);

    USBCAMD_KdPrint (MIN_TRACE, ("enter USBCAMD_StartChannel\n"));

    ASSERT_CHANNEL(ChannelExtension);
    StreamNumber = ChannelExtension->StreamNumber;


    if (ChannelExtension->ImageCaptureStarted) {
        // fail the call if the channel is not in the
        // proper state.
        TRAP();
        ntStatus = STATUS_UNSUCCESSFUL;
        goto USBCAMD_StartChannel_Done;
    }

    USBCAMD_ClearIdleLock(&ChannelExtension->IdleLock);

#if DBG
    {
        ULONG i;

        ASSERT(DeviceExtension->ActualInstances[StreamNumber] > 0);
        ASSERT(ChannelExtension->StreamError == FALSE);
        //ASSERT(ChannelExtension->Flags == 0);

        if ( ChannelExtension->VirtualStillPin == FALSE) {

            if (ChannelExtension->DataPipeType == UsbdPipeTypeIsochronous ) {
                for (i=0; i< USBCAMD_MAX_REQUEST; i++) {
                    ASSERT(ChannelExtension->TransferExtension[i].ChannelExtension != NULL);
                }
            }
        }
    }
#endif

    if ( ChannelExtension->VirtualStillPin == TRUE) {
        // check if the capture pin has started yet?
        if ( (DeviceExtension->ChannelExtension[STREAM_Capture] != NULL) &&
             (DeviceExtension->ChannelExtension[STREAM_Capture]->ImageCaptureStarted) ){
            ChannelExtension->ImageCaptureStarted = TRUE;
        }
        else{
            // We can't start a virtual still pin till after we start the capture pin.
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else {

        //
        // Perform a reset on the pipes
        //
        if ( ChannelExtension->DataPipeType == UsbdPipeTypeIsochronous ){

            ntStatus = USBCAMD_ResetPipes(DeviceExtension,
                                          ChannelExtension,
                                          DeviceExtension->Interface,
                                          FALSE);
        }

        //
        // start the stream up, we don't check for errors here
        //

        if (NT_SUCCESS(ntStatus)) {

            if ( ChannelExtension->DataPipeType == UsbdPipeTypeIsochronous ){
                ntStatus = USBCAMD_StartIsoStream(DeviceExtension, ChannelExtension);
            }
            else {
                ntStatus = USBCAMD_StartBulkStream(DeviceExtension, ChannelExtension);
            }
        }
    }

USBCAMD_StartChannel_Done:

    USBCAMD_KdPrint (MIN_TRACE, ("exit USBCAMD_StartChannel (%x)\n", ntStatus));

    USBCAMD_RELEASE(DeviceExtension);

    return ntStatus;
}

//---------------------------------------------------------------------------
// USBCAMD_StopChannel
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_StopChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    )
/*++

Routine Description:

    Stops the streaming process for a video channel.

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension

    ChannelExtension - context data for this channel.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG StreamNumber;

    USBCAMD_SERIALIZE(DeviceExtension);

    USBCAMD_KdPrint (MIN_TRACE, ("enter USBCAMD_StopChannel\n"));

    ASSERT_CHANNEL(ChannelExtension);
    StreamNumber = ChannelExtension->StreamNumber;
    ASSERT(ChannelExtension->ChannelPrepared == TRUE);
    ASSERT(DeviceExtension->ActualInstances[StreamNumber] > 0);

    if (!ChannelExtension->ImageCaptureStarted ) {
        //
        // we are not started so we just return success
        //
        USBCAMD_KdPrint (MIN_TRACE, ("stop before start -- return success\n"));
        ntStatus = STATUS_SUCCESS;
        goto USBCAMD_StopChannel_Done;
    }

    if ( ChannelExtension->DataPipeType == UsbdPipeTypeBulk ) {
        // for bulk pipes. Just make sure to cancel the current read request.
        // there is a pending IRP on this Pipe. Cancel it
        ntStatus = USBCAMD_CancelOutstandingIrp(DeviceExtension,
                                                ChannelExtension->DataPipe,
                                                FALSE);
        ChannelExtension->StreamError = FALSE;
        ChannelExtension->ImageCaptureStarted = FALSE;
        goto USBCAMD_StopChannel_Done;
    }

    //
    // first we set our stop flag
    //

    ChannelExtension->Flags |= USBCAMD_STOP_STREAM;

    //
    // now send an abort pipe for both our pipes, this should flush out any
    // transfers that are running
    //

    if ( ChannelExtension->VirtualStillPin == FALSE) {

        // we only need to abort for iso pipes.
        if ( ChannelExtension->DataPipeType == UsbdPipeTypeIsochronous ) {

            ntStatus = USBCAMD_AbortPipe(DeviceExtension,
                    DeviceExtension->Interface->Pipes[ChannelExtension->DataPipe].PipeHandle);
#if DBG
            if (NT_ERROR(ntStatus)) {
               USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_StopChannel: USBCAMD_AbortPipe(DataPipe)=0x%x\n",ntStatus));
               // TEST_TRAP(); // Can happen on surprise removal
            }
#endif
            if (ChannelExtension->SyncPipe != -1) {
                ntStatus = USBCAMD_AbortPipe(DeviceExtension,
                        DeviceExtension->Interface->Pipes[ChannelExtension->SyncPipe].PipeHandle);
                if (NT_ERROR(ntStatus)) {
                    USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_StopChannel: USBCAMD_AbortPipe(SyncPipe)=0x%x\n",ntStatus));
                    // TEST_TRAP(); // Can happen on surprise removal
                }
            }
        }
    }

    //
    // Block the stop for now, waiting for all iso irps to be completed
    //
    ntStatus = USBCAMD_WaitForIdle(&ChannelExtension->IdleLock, USBCAMD_STOP_STREAM);
    if (STATUS_TIMEOUT == ntStatus) {

        KIRQL oldIrql;
        int idx;

        // A timeout requires that we take harsher measures to stop the stream

        // Hold the spin lock while cancelling the IRPs
        KeAcquireSpinLock(&ChannelExtension->TransferSpinLock, &oldIrql);

        // Cancel the IRPs
        for (idx = 0; idx < USBCAMD_MAX_REQUEST; idx++) {

            PUSBCAMD_TRANSFER_EXTENSION TransferExtension = &ChannelExtension->TransferExtension[idx];

            if (TransferExtension->SyncIrp) {
                IoCancelIrp(TransferExtension->SyncIrp);
            }

            if (TransferExtension->DataIrp) {
                IoCancelIrp(TransferExtension->DataIrp);
            }
        }

        KeReleaseSpinLock(&ChannelExtension->TransferSpinLock, oldIrql);

        // Try waiting one more time
        ntStatus = USBCAMD_WaitForIdle(&ChannelExtension->IdleLock, USBCAMD_STOP_STREAM);
    }

    //
    // Cancel all queued read SRBs
    //
    USBCAMD_CancelQueuedSRBs(ChannelExtension);

    ChannelExtension->Flags &= ~USBCAMD_STOP_STREAM;

    //
    // clear the error state flag, we are now stopped
    //

    ChannelExtension->StreamError = FALSE;
    ChannelExtension->ImageCaptureStarted = FALSE;

USBCAMD_StopChannel_Done:


#if DBG
    USBCAMD_DebugStats(ChannelExtension);
#endif

    USBCAMD_KdPrint (MIN_TRACE, ("exit USBCAMD_StopChannel (%x)\n", ntStatus));
    USBCAMD_RELEASE(DeviceExtension);
    return ntStatus;
}




//---------------------------------------------------------------------------
// USBCAMD_AbortPipe
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_AbortPipe(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN USBD_PIPE_HANDLE PipeHandle
    )
/*++

Routine Description:

    Abort pending transfers for a given USB pipe.

Arguments:

    DeviceExtension - Pointer to the device extension for this instance of the USB camera
                    devcice.

    PipeHandle - usb pipe handle to abort trasnsfers for.


Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    ULONG currentUSBFrame = 0;

    USBCAMD_KdPrint (MIN_TRACE, ("enter Abort Pipe\n"));

    urb = USBCAMD_ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_PIPE_REQUEST));

    if (urb) {

        urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Status = 0;
        urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
        urb->UrbPipeRequest.PipeHandle = PipeHandle;

        ntStatus = USBCAMD_CallUSBD(DeviceExtension, urb,0,NULL);

        USBCAMD_ExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    USBCAMD_KdPrint (MIN_TRACE, ("exit Abort Pipe ntStatus(%x)\n",ntStatus));
    return ntStatus;
}


//---------------------------------------------------------------------------
// USBCAMD_StartStream
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_StartIsoStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    )
/*++

Routine Description:

    This is the code that starts the streaming process.

Arguments:

    DeviceExtension - Pointer to the device extension for this instance of the USB camera
                    device.

Return Value:

    NT status code.

--*/
{
    ULONG i;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG CurrentUSBFrame;

#if DBG
    // initialize debug count variables
    ChannelExtension->IgnorePacketCount =
    ChannelExtension->ErrorDataPacketCount =
    ChannelExtension->ErrorSyncPacketCount =
    ChannelExtension->SyncNotAccessedCount =
    ChannelExtension->DataNotAccessedCount = 0;

    if (USBCAMD_StreamEnable == 0) {
        return ntStatus;
    }
#endif

    // ISSUE-2001/01/17-dgoll Figure out what the 10 (below) is, and give it a name
    CurrentUSBFrame =
        USBCAMD_GetCurrentFrame(DeviceExtension) + 10;

    for (i=0; i<USBCAMD_MAX_REQUEST; i++) {

        ntStatus = USBCAMD_SubmitIsoTransfer(DeviceExtension,
                                  &ChannelExtension->TransferExtension[i],
                                  CurrentUSBFrame,
                                  FALSE);

        CurrentUSBFrame +=
            USBCAMD_NUM_ISO_PACKETS_PER_REQUEST;

    }
    if ( ntStatus == STATUS_SUCCESS) 
        ChannelExtension->ImageCaptureStarted = TRUE;
    return ntStatus;
}

//---------------------------------------------------------------------------
// USBCAMD_StartBulkStream
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_StartBulkStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    )
/*++

Routine Description:

    This is the code that starts the streaming process.

Arguments:

    DeviceExtension - Pointer to the device extension for this instance of the USB camera
                    device.

Return Value:

    NT status code.

--*/
{
  ULONG i;
  ULONG ntStatus = STATUS_SUCCESS;

#if DBG
    // initialize debug count variables
    ChannelExtension->IgnorePacketCount =
    ChannelExtension->ErrorDataPacketCount =
    ChannelExtension->ErrorSyncPacketCount =
    ChannelExtension->SyncNotAccessedCount =
    ChannelExtension->DataNotAccessedCount = 0;

#endif
    
    ChannelExtension->CurrentBulkTransferIndex = i = 0;
        
    ntStatus = USBCAMD_IntOrBulkTransfer(DeviceExtension,
                                ChannelExtension,
                                ChannelExtension->TransferExtension[i].DataBuffer,
                                ChannelExtension->TransferExtension[i].BufferLength,
                                ChannelExtension->DataPipe,
                                NULL,
                                NULL,
                                0,
                                BULK_TRANSFER);        

    if ( ntStatus == STATUS_SUCCESS) 
        ChannelExtension->ImageCaptureStarted = TRUE;

    return ntStatus;
}


//---------------------------------------------------------------------------
// USBCAMD_ControlVendorCommand
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_ControlVendorCommandWorker(
    IN PVOID DeviceContext,
    IN UCHAR Request,
    IN USHORT Value,
    IN USHORT Index,
    IN PVOID Buffer,
    IN OUT PULONG BufferLength,
    IN BOOLEAN GetData
    )
/*++

Routine Description:

    Send a vendor command to the camera to fetch data.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    Request - Request code for setup packet.

    Value - Value for setup packet.

    Index - Index for setup packet.

    Buffer - Pointer to input buffer

    BufferLength - pointer size of input/output buffer (optional)

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    BOOLEAN allocated = FALSE;
    PUCHAR localBuffer;
    PUCHAR buffer;
    PURB urb;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    ULONG length = BufferLength ? *BufferLength : 0;

    USBCAMD_KdPrint (MAX_TRACE, ("'enter USBCAMD_ControlVendorCommand\n"));

    deviceExtension = USBCAMD_GET_DEVICE_EXTENSION(DeviceContext);

    buffer = USBCAMD_ExAllocatePool(NonPagedPool,
                            sizeof(struct
                            _URB_CONTROL_VENDOR_OR_CLASS_REQUEST) + length);


    if (buffer) {
        urb = (PURB) (buffer + length);

        USBCAMD_KdPrint (ULTRA_TRACE, ("'enter USBCAMD_ControlVendorCommand req %x val %x index %x\n",
            Request, Value, Index));

        if (BufferLength && *BufferLength != 0) {
            localBuffer = buffer;
            if (!GetData) {
                RtlCopyMemory(localBuffer, Buffer, *BufferLength);
            }
        } else {
            localBuffer = NULL;
        }

        UsbBuildVendorRequest(urb,
                              URB_FUNCTION_VENDOR_DEVICE,
                              sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                              GetData ? USBD_TRANSFER_DIRECTION_IN :
                                  0,
                              0,
                              Request,
                              Value,
                              Index,
                              localBuffer,
                              NULL,
                              length,
                              NULL);

        USBCAMD_KdPrint (ULTRA_TRACE, ("'BufferLength =  0x%x buffer = 0x%x\n",
            length, localBuffer));

        ntStatus = USBCAMD_CallUSBD(deviceExtension, urb,0,NULL);

        if (NT_SUCCESS(ntStatus)) {
            if (BufferLength) {
                *BufferLength =
                    urb->UrbControlVendorClassRequest.TransferBufferLength;

                USBCAMD_KdPrint (ULTRA_TRACE, ("'BufferLength =  0x%x buffer = 0x%x\n",
                    *BufferLength, localBuffer));
                if (localBuffer && GetData) {
                    RtlCopyMemory(Buffer, localBuffer, *BufferLength);
                }
            }
        }
        else {
            USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_ControlVendorCommand Error 0x%x\n", ntStatus));            

            // Only expected failure.
            // TEST_TRAP();        
        }

        USBCAMD_ExFreePool(buffer);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        USBCAMD_KdPrint (MIN_TRACE, ("'USBCAMD_ControlVendorCommand Error 0x%x\n", ntStatus));
    }

    return ntStatus;

}


//---------------------------------------------------------------------------
// USBCAMD_ControlVendorCommand
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_ControlVendorCommand(
    IN PVOID DeviceContext,
    IN UCHAR Request,
    IN USHORT Value,
    IN USHORT Index,
    IN PVOID Buffer,
    IN OUT PULONG BufferLength,
    IN BOOLEAN GetData,
    IN PCOMMAND_COMPLETE_FUNCTION CommandComplete,
    IN PVOID CommandContext
    )
/*++

Routine Description:

    Send a vendor command to the camera to fetch data.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    Request - Request code for setup packet.

    Value - Value for setup packet.

    Index - Index for setup packet.

    Buffer - Pointer to input buffer

    BufferLength - pointer size of input/output buffer (optional)

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PCOMMAND_WORK_ITEM workitem;

    USBCAMD_KdPrint (MAX_TRACE, ("'enter USBCAMD_ControlVendorCommand2\n"));

    USBCAMD_DbgLog(TL_PRF_TRACE|TL_VND_TRACE, '+dnV', Request, USBCAMD_StartClock(), 0);
    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        //
        // we are at passive level, just do the command
        //
        ntStatus = USBCAMD_ControlVendorCommandWorker(DeviceContext,
                                                Request,
                                                Value,
                                                Index,
                                                Buffer,
                                                BufferLength,
                                                GetData);

        if (CommandComplete) {
            // call the completion handler
            (*CommandComplete)(DeviceContext, CommandContext, ntStatus);
        }

    } else {
//        TEST_TRAP();
        //
        // schedule a work item
        //
        ntStatus = STATUS_PENDING;

        workitem = USBCAMD_ExAllocatePool(NonPagedPool,
                                          sizeof(COMMAND_WORK_ITEM));
        if (workitem) {

            ExInitializeWorkItem(&workitem->WorkItem,
                                 USBCAMD_CommandWorkItem,
                                 workitem);

            workitem->DeviceContext = DeviceContext;
            workitem->Request = Request;
            workitem->Value = Value;
            workitem->Index = Index;
            workitem->Buffer = Buffer;
            workitem->BufferLength = BufferLength;
            workitem->GetData = GetData;
            workitem->CommandComplete = CommandComplete;
            workitem->CommandContext = CommandContext;

            ExQueueWorkItem(&workitem->WorkItem,
                            DelayedWorkQueue);

        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

    }
    USBCAMD_DbgLog(TL_PRF_TRACE|TL_VND_TRACE, '-dnV', Request, USBCAMD_StopClock(), ntStatus);

    return ntStatus;
}


VOID
USBCAMD_CommandWorkItem(
    PVOID Context
    )
/*++

Routine Description:

    Call the mini driver to convert a raw packet to the proper format.

Arguments:

Return Value:

    None.

--*/
{
    NTSTATUS ntStatus;
    PCOMMAND_WORK_ITEM workItem = Context;

    ntStatus = USBCAMD_ControlVendorCommandWorker(workItem->DeviceContext,
                                            workItem->Request,
                                            workItem->Value,
                                            workItem->Index,
                                            workItem->Buffer,
                                            workItem->BufferLength,
                                            workItem->GetData);


    if (workItem->CommandComplete) {
        // call the completion handler
        (*workItem->CommandComplete)(workItem->DeviceContext,
                                   workItem->CommandContext,
                                   ntStatus);
    }

    USBCAMD_ExFreePool(workItem);
}


NTSTATUS
USBCAMD_GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_NO_MEMORY;
    UNICODE_STRING keyName;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    RtlInitUnicodeString(&keyName, KeyNameString);

    length = sizeof(KEY_VALUE_FULL_INFORMATION) +
            KeyNameStringLength + DataLength;

    fullInfo = USBCAMD_ExAllocatePool(PagedPool, length);
    USBCAMD_KdPrint(MAX_TRACE, ("' USBD_GetRegistryKeyValue buffer = 0x%p\n", (ULONG_PTR) fullInfo));

    if (fullInfo) {
        ntStatus = ZwQueryValueKey(Handle,
                        &keyName,
                        KeyValueFullInformation,
                        fullInfo,
                        length,
                        &length);

        if (NT_SUCCESS(ntStatus)){
            ASSERT(DataLength == fullInfo->DataLength);
            RtlCopyMemory(Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, DataLength);
        }

        USBCAMD_ExFreePool(fullInfo);
    }

    return ntStatus;
}

#if DBG

typedef struct _RAW_SIG {
    ULONG Sig;
    ULONG length;
} RAW_SIG, *PRAW_SIG;


PVOID
USBCAMD_AllocateRawFrameBuffer(
    ULONG RawFrameLength
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PRAW_SIG rawsig;
    PUCHAR pch;

    pch = USBCAMD_ExAllocatePool(NonPagedPool,
                         RawFrameLength + sizeof(*rawsig)*2);

    if (pch) {
        // begin sig
        rawsig = (PRAW_SIG) pch;
        rawsig->Sig = USBCAMD_RAW_FRAME_SIG;
        rawsig->length = RawFrameLength;


        // end sig
        rawsig = (PRAW_SIG) (pch+RawFrameLength+sizeof(*rawsig));
        rawsig->Sig = USBCAMD_RAW_FRAME_SIG;
        rawsig->length = RawFrameLength;

        pch += sizeof(*rawsig);
    }

    return pch;
}


VOID
USBCAMD_FreeRawFrameBuffer(
    PVOID RawFrameBuffer
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR pch;

    USBCAMD_CheckRawFrameBuffer(RawFrameBuffer);

    pch = RawFrameBuffer;
    pch -= sizeof(RAW_SIG);

    USBCAMD_ExFreePool(pch);
}


VOID
USBCAMD_CheckRawFrameBuffer(
    PVOID RawFrameBuffer
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

}

typedef struct _NODE_HEADER {
    ULONG Length;
    ULONG Sig;
} NODE_HEADER, *PNODE_HEADER;

PVOID
USBCAMD_ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    )
{
    PNODE_HEADER tmp;

    tmp = ExAllocatePoolWithTag(PoolType, NumberOfBytes+sizeof(*tmp), 'MACU');

    if (tmp) {
        USBCAMD_HeapCount += NumberOfBytes;
        tmp->Length = NumberOfBytes;
        tmp->Sig = 0xDEADBEEF;
        tmp++;
    }

    USBCAMD_KdPrint(MAX_TRACE, ("'USBCAMD_ExAllocatePool(%d, %d[%d])=0x%p[0x%p]\n", 
    PoolType, NumberOfBytes, NumberOfBytes+sizeof(*tmp), (void *)tmp, (void *)(tmp-1) ));

    return tmp;
}


VOID
USBCAMD_ExFreePool(
    IN PVOID p
    )
{
    PNODE_HEADER tmp = p;

    tmp--;
    ASSERT(tmp->Sig == 0xDEADBEEF);
    tmp->Sig = 0;

    USBCAMD_HeapCount-=tmp->Length;

    USBCAMD_KdPrint(MAX_TRACE, ("'USBCAMD_ExFreePool(0x%p[0x%p]) = %d[%d] Bytes\n", 
    (void *)(tmp+1), (void *)tmp, tmp->Length, tmp->Length + sizeof(*tmp) ) );

    ExFreePool(tmp);

}

#endif

//---------------------------------------------------------------------------
// USBCAMD_SetDevicePowerState
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_SetDevicePowerState(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension

    DevicePowerState - Device power state to enter.

Return Value:

    NT status code

--*/
{
    PPOWERUP_WORKITEM workitem;
    DEVICE_POWER_STATE DevicePowerState;
    NTSTATUS ntStatus;
    
    ntStatus = STATUS_SUCCESS;
    DevicePowerState = Srb->CommandData.DeviceState;

    USBCAMD_KdPrint (MAX_TRACE, ("enter SetDevicePowerState\n"));

    if (DeviceExtension->CurrentPowerState == DevicePowerState) {
        return ntStatus;
    }

    USBCAMD_KdPrint (MIN_TRACE, ("Switching from %s to %s\n",
                                 PnPDevicePowerStateString(DeviceExtension->CurrentPowerState),
                                 PnPDevicePowerStateString(DevicePowerState)));                      

    switch (DevicePowerState ) {
    case PowerDeviceD0:
        //
        // we can't talk to usb stack till the Powerup IRP assocaited with this 
        // SRB is completed by everybody on the USB stack.
        // Schedule a delay work item to complete the powerup later.
        //
          
        USBCAMD_KdPrint (MAX_TRACE, ("Starting D0 powerup - part one.\n"));
        
        // start iso stream if any.
        if ((DeviceExtension->ChannelExtension[STREAM_Capture] != NULL) &&
            (DeviceExtension->ChannelExtension[STREAM_Capture]->DataPipeType == UsbdPipeTypeIsochronous )){
    
            //
            // Queue a delayed work item
            //
            USBCAMD_KdPrint (MAX_TRACE,("Queuing delayed powerup workitem to restart iso stream \n"));
            workitem = USBCAMD_ExAllocatePool(NonPagedPool,sizeof(POWERUP_WORKITEM));

            if (workitem) {
                ExInitializeWorkItem(&workitem->WorkItem,USBCAMD_PowerUpWorkItem,workitem);
                workitem->DeviceExtension = DeviceExtension;
                DeviceExtension->InPowerTransition = TRUE;
                ExQueueWorkItem(&workitem->WorkItem,DelayedWorkQueue);
            } 
            else 
            {
                TEST_TRAP();
            }
        USBCAMD_KdPrint (MAX_TRACE, ("Ending D0 powerup - part one.\n"));
        }                   
        break;
        
    case PowerDeviceD1:
    case PowerDeviceD2:
        break;

    case PowerDeviceD3:

        USBCAMD_KdPrint (MAX_TRACE, ("Starting D3 powerdown.\n", 
            PnPDevicePowerStateString(DeviceExtension->CurrentPowerState)));

        if ( DeviceExtension->CurrentPowerState == PowerDeviceD0 )
        {   
            // stop iso stream if any.
            if ((DeviceExtension->ChannelExtension[STREAM_Capture] != NULL) &&
                (DeviceExtension->ChannelExtension[STREAM_Capture]->DataPipeType == UsbdPipeTypeIsochronous ) &&
                (DeviceExtension->ChannelExtension[STREAM_Capture]->KSState == KSSTATE_RUN ||
                 DeviceExtension->ChannelExtension[STREAM_Capture]->KSState == KSSTATE_PAUSE) ){
            
            USBCAMD_KdPrint (MIN_TRACE, ("Stopping ISO stream before powerdown.\n"));
            USBCAMD_ProcessSetIsoPipeState(DeviceExtension,
                                        DeviceExtension->ChannelExtension[STREAM_Capture],
                                        USBCAMD_STOP_STREAM);

            if (DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) 

                // send hardware stop
                ntStatus = (*DeviceExtension->DeviceDataEx.DeviceData2.CamStopCaptureEx)(
                            DeviceExtension->StackDeviceObject,
                            USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                                    STREAM_Capture);
            else 
                // send hardware stop
                ntStatus = (*DeviceExtension->DeviceDataEx.DeviceData.CamStopCapture)(
                             DeviceExtension->StackDeviceObject,
                             USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension));

            do {
                LARGE_INTEGER DelayTime = {(ULONG)(-8*SECONDS), -1};

                USBCAMD_KdPrint (MIN_TRACE, ("Waiting %d ms for pending USB I/O to timeout....\n", 
                                 (long)DelayTime.LowPart / MILLISECONDS ));
                KeDelayExecutionThread(KernelMode,FALSE,&DelayTime);
            }
            while ( KeReadStateSemaphore(&DeviceExtension->CallUSBSemaphore) == 0 );

            USBCAMD_KdPrint (MIN_TRACE, ("Done waiting for pending USB I/O to timeout.\n"));
            }
        USBCAMD_KdPrint (MAX_TRACE, ("Finished D3 powerdown.\n"));
        }   
        ntStatus = STATUS_SUCCESS;
        break;

    default:
        ntStatus = STATUS_NOT_SUPPORTED;
        break;
    }

    DeviceExtension->CurrentPowerState = DevicePowerState;
    USBCAMD_KdPrint (MAX_TRACE, ("exit USBCAMD_SetDevicePowerState()=0x%x\n", ntStatus));
    return ntStatus;
}



VOID
USBCAMD_PowerUpWorkItem(
    PVOID Context
)
/*++

Routine Description:


Arguments:

Return Value:

    None.

--*/
{
    NTSTATUS ntStatus;
    LARGE_INTEGER DelayTime = {(ULONG)(-8 * SECONDS), -1};
    PPOWERUP_WORKITEM pWorkItem = Context;
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension = pWorkItem->DeviceExtension;
    PUSBCAMD_CHANNEL_EXTENSION pChExt = DeviceExtension->ChannelExtension[STREAM_Capture];


    USBCAMD_KdPrint (MAX_TRACE, ("Starting D0 powerup - part two.\n"));
    USBCAMD_KdPrint (MIN_TRACE, ("Delaying for %d ms for USB stack to powerup.\n",
        (long)DelayTime.LowPart / MILLISECONDS ));

    KeDelayExecutionThread(KernelMode,FALSE,&DelayTime);

    USBCAMD_KdPrint (MAX_TRACE, ("Continuing D0 powerup - part two.\n"));

    DeviceExtension->InPowerTransition = FALSE;

        // Make sure we don't try to startup the ISO stream if we have been shutdown while waiting (by WIA?)
    if ( ( pChExt != NULL) &&
         ( pChExt->DataPipeType == UsbdPipeTypeIsochronous ) &&
         ( ( pChExt->KSState == KSSTATE_PAUSE ) || ( pChExt->KSState == KSSTATE_RUN ) ) ) {
        USBCAMD_KdPrint (MIN_TRACE, ("Restarting ISO stream after powerup.\n"));
        USBCAMD_ProcessSetIsoPipeState( DeviceExtension, pChExt, USBCAMD_START_STREAM);
    }

    USBCAMD_ExFreePool(pWorkItem);
    USBCAMD_KdPrint (MAX_TRACE, ("Finished D0 powerup - part two.\n"));
}

VOID
USBCAMD_InitializeIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    )
/*++

Routine Description:

    This routine is called to initialize the idle lock on a channel.

--*/
{
    // Allow transfers
    Lock->IdleLock = FALSE;

    // Nobody waiting
    Lock->Waiting = 0;

    // No active transfers
    Lock->Busy = 0;

    // Initialize an event that only lets one thread through at a time
    KeInitializeEvent(&Lock->IdleEvent, SynchronizationEvent, FALSE);

    return;
}

NTSTATUS
USBCAMD_AcquireIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    )
/*++

Routine Description:

    This routine is called to acquire the idle lock for a channel.
    While the lock is held, clients can assume that there are outstanding
    transfer requests to be completed.

    The lock should be acquired immediately before sending a data or sync
    Irp down, and released each time an Irp completes.

Arguments:

    Lock - A pointer to an initialized USBCAMD_IDLE_LOCK structure.

Return Value:

    Returns whether or not the idle lock was obtained. If successful, the caller
    may continue with the transfer request.

    If not successful the lock was not obtained. The caller should abort the
    work, as the channel is being stopped

--*/

{
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    // Attempt to go into (or stay in) the busy state
    InterlockedIncrement(&Lock->Busy);

    // Check if waiting to go idle
    if (Lock->IdleLock) {

        USBCAMD_KdPrint (MIN_TRACE, ("Failing IdleLock acquire: waiting for idle\n"));

        // Reverse our attempt
        if (InterlockedDecrement(&Lock->Busy) == 0) {

            InterlockedIncrement(&Lock->Waiting);

            if (InterlockedDecrement(&Lock->Waiting) != 0) {

                KeSetEvent(&Lock->IdleEvent, 0, FALSE);
            }
        }

        ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}

VOID
USBCAMD_ReleaseIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    )
/*++

Routine Description:

    This routine is called to release the idle lock on the channel. It must be
    called when a data or sync Irp completes on a channel.

    When the lock count reduces to zero, this routine will check the waiting
    count, and signal the event if the count was non-zero.

Arguments:

    Lock - A pointer to an initialized USBCAMD_IDLE_LOCK structure.

Return Value:

    none

--*/

{
    // Decrement the outstanding transfer requests, and check if this was the last one
    if (InterlockedDecrement(&Lock->Busy) == 0) {

        InterlockedIncrement(&Lock->Waiting);

        if (InterlockedDecrement(&Lock->Waiting) != 0) {

            KeSetEvent(&Lock->IdleEvent, 0, FALSE);
        }
    }

    return;
}

NTSTATUS
USBCAMD_WaitForIdle(
    IN OUT PUSBCAMD_IDLE_LOCK Lock,
    IN LONG Flag
    )
/*++

Routine Description:

    This routine is called when the client would like to stop all
    transfers on a channel, and wait for outstanding transfers to
    complete. When resetting the stream, the idle lock is blocked
    while waiting, then unblocked. When stopping the stream, the idle
    lock is blocked until explicitely unblocked with the
    USBCAMD_ClearIdleLock routine. The input Flag indicates whether
    stopping or resetting. Note that this routine could be active
    for both flag values. In that case, the USBCAMD_STOP_STREAM takes
    precedence.

Arguments:

    Lock - A pointer to an initialized USBCAMD_IDLE_LOCK structure.
    Flag - Either USBCAMD_STOP_STREAM or USBCAMD_RESET_STREAM

Return Value:

    none

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    InterlockedIncrement(&Lock->Waiting);
    InterlockedIncrement(&Lock->Busy);

    switch (Flag) {

    case USBCAMD_RESET_STREAM:
        // When resetting the stream, conditionally set the IdleLock
        InterlockedCompareExchange(&Lock->IdleLock, USBCAMD_RESET_STREAM, 0);
        break;

    case USBCAMD_STOP_STREAM:
        // When stopping the stream, always set the IdleLock
        InterlockedExchange(&Lock->IdleLock, USBCAMD_STOP_STREAM);
        break;
    }

    // See if there are any outstanding transfer requests
    if (InterlockedDecrement(&Lock->Busy) != 0) {
        LARGE_INTEGER Timeout = {(ULONG)(-4 * SECONDS), -1};

        USBCAMD_KdPrint (MIN_TRACE, ("Waiting for idle state\n"));
        USBCAMD_DbgLog(TL_IDL_WARNING, '+ 8W', Lock, Flag, 0);

        // Wait for them to finish
        ntStatus = KeWaitForSingleObject(
            &Lock->IdleEvent,
            Executive,
            KernelMode,
            FALSE,
            &Timeout
            );

        USBCAMD_DbgLog(TL_IDL_WARNING, '- 8W', Lock, Flag, ntStatus);
    }

    if (STATUS_SUCCESS == ntStatus) {

        switch (Flag) {

        case USBCAMD_RESET_STREAM:
            // When resetting the stream, conditionally clear the IdleLock
            Flag = InterlockedCompareExchange(&Lock->IdleLock, 0, USBCAMD_RESET_STREAM);
#if DBG
            switch (Flag) {
            case USBCAMD_RESET_STREAM:
                USBCAMD_KdPrint (MIN_TRACE, ("Idle state, stream reset in progress\n"));
                break;

            case USBCAMD_STOP_STREAM:
                USBCAMD_KdPrint (MIN_TRACE, ("Idle state, stream stop in progress\n"));
                break;

            default:
                USBCAMD_KdPrint (MIN_TRACE, ("Idle state, unexpected IdleLock value\n"));
            }
#endif
            break;

        case USBCAMD_STOP_STREAM:
            // When stopping the stream, never clear the IdleLock
            USBCAMD_KdPrint (MIN_TRACE, ("Idle state, stream stop in progress\n"));
            break;
        }

        // See if anyone else is waiting
        if (InterlockedDecrement(&Lock->Waiting) != 0) {

            // Let them go
            KeSetEvent(&Lock->IdleEvent, 0, FALSE);
        }
    }
    else {

        USBCAMD_KdPrint (MIN_TRACE, ("Timeout waiting for idle state, not going idle\n"));
        InterlockedDecrement(&Lock->Waiting);
    }

    return ntStatus;
}

VOID
USBCAMD_ClearIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    )
/*++

Routine Description:

    This routine is called when the client is completely finished
    with stopping transfers on a channel.

Arguments:

    Lock - A pointer to an initialized USBCAMD_IDLE_LOCK structure.

Return Value:

    none

--*/
{
    // Clear the IdleLock
    InterlockedExchange(&Lock->IdleLock, 0);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\usbcamd\usbcamd.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    usbcamd.h

Abstract:



Environment:

    Kernel & user mode

Revision History:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

    Original 3/96 John Dunn
    Updated  3/98 Husni Roukbi

--*/

#ifndef   __USBCAMD_H__
#define   __USBCAMD_H__

#include "warn.h"

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#include <strmini.h>
#include <ksmedia.h>
#include "usbcamdi.h"

#define USBCAMD_NUM_ISO_PACKETS_PER_REQUEST  32

#define USBCAMD_MAX_REQUEST   2
#define MAX_STREAM_INSTANCES  1

#define CAMCONTROL_FLAG_MASK     1

#define INPUT_PIPE  1
#define OUTPUT_PIPE 0

//#define DEADMAN_TIMER

#define USBCAMD_EXTENSION_SIG 0x45564544    //"DEVE"
#define USBCAMD_CHANNEL_SIG 0x4348414e      //"CHAN"
#define USBCAMD_TRANSFER_SIG 0x5452414e     //"TRAN"
#define USBCAMD_READ_SIG 0x45425253         //"SRBE"

#define USBCAMD_RAW_FRAME_SIG 0x46574152    //"RAWF"

typedef struct _USBCAMD_pipe_pin_relations {
    UCHAR   PipeType;
    UCHAR   PipeDirection;
    USHORT  MaxPacketSize;
    USBCAMD_Pipe_Config_Descriptor  PipeConfig;
    // Int. or bulk outstanding irps.
    KSPIN_LOCK  OutstandingIrpSpinlock; // used to access the above IRPs.
    LIST_ENTRY	IrpPendingQueue;
	LIST_ENTRY  IrpRestoreQueue;
} USBCAMD_PIPE_PIN_RELATIONS, *PUSBCAMD_PIPE_PIN_RELATIONS;


typedef enum {
   STREAM_Capture,                  // we always assume vidoe stream is stream 0
   STREAM_Still
};

typedef enum {
   BULK_TRANSFER,                  // we always assume vidoe stream is stream 0
   INTERRUPT_TRANSFER
};


typedef enum {
   INTERNAL,                  // we use transferext[0] in ch ext for internal requests.
   EXETRNAL
};

typedef struct _USBCAMD_DEVICE_DATA_EX {
    union {
        USBCAMD_DEVICE_DATA  DeviceData;
        USBCAMD_DEVICE_DATA2 DeviceData2;
    };
} USBCAMD_DEVICE_DATA_EX, *PUSBCAMD_DEVICE_DATA_EX;


// we only support one video stream and one still stream.

#define MAX_STREAM_COUNT    2


#if DBG
#define STREAM_CAPTURE_TIMEOUT  15
#else
#define STREAM_CAPTURE_TIMEOUT  9
#endif
#if DBG
#define STREAM_STILL_TIMEOUT    4100
#else
#define STREAM_STILL_TIMEOUT    4100
#endif

// The follow constants are based on 10,000,000 / sec <OR> 100ns time units.
#define MICROSECONDS    (10)
#define MILLISECONDS    (1000*MICROSECONDS)
#define SECONDS         (1000*MILLISECONDS)

//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _USBCAMD_DEVICE_EXTENSION {

    ULONG Sig;
    struct _USBCAMD_CHANNEL_EXTENSION *ChannelExtension[MAX_STREAM_COUNT];

	// Control Queues for each data stream
    LIST_ENTRY               StreamControlSRBList[MAX_STREAM_COUNT];
    BOOL                     ProcessingControlSRB[MAX_STREAM_COUNT];
    KSPIN_LOCK               ControlSRBSpinLock;        // Multiprocessor safe access to AdapterSRBList

	// Completed Read SRB Queue mgmt.
    LIST_ENTRY 				CompletedReadSrbList;		
    KSPIN_LOCK              DispatchSpinLock;        // Multiprocessor safe access to AdapterSRBList
    KSEMAPHORE				CompletedSrbListSemaphore;
	BOOLEAN					StopIsoThread;
	PKTHREAD 				IsoThreadObject;

    
    LONG TimeoutCount[MAX_STREAM_COUNT];
    KSEMAPHORE Semaphore;
    KSEMAPHORE CallUSBSemaphore;
    ULONG StreamCount;
    ULONG Initialized;
    ULONG    ActualInstances[MAX_STREAM_COUNT];

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT StackDeviceObject;
    PDEVICE_OBJECT SCDeviceObject;
    PDEVICE_OBJECT RealPhysicalDeviceObject;

 
    // configuration handle for the configuration the
    // device is currently in
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;

    // ptr to the USB device descriptor
    // for this device
    PUSB_DEVICE_DESCRIPTOR DeviceDescriptor;

    // we support one interface
    PUSBD_INTERFACE_INFORMATION Interface;
	ULONG currentMaxPkt;	// used for temp storage of current alt. int. max
							// pkt size between ISO pipe stop and start.


    LONG SyncPipe;
    LONG DataPipe;
    CHAR IsoPipeStreamType;  // if data pipe iso set, indicate stream association here.
                              // if both streams are set, then create a virtual still pin.
    LONG BulkDataPipe;
    CHAR BulkPipeStreamType;   // if bulkdatpipe is set, this will indicate stream association
    BOOLEAN VirtualStillPin;
    BOOLEAN CameraUnplugged;  // set to true if camera was unplugged.
    BOOLEAN InPowerTransition; // set when waiting for pwr workitem to finish.

    DEVICE_POWER_STATE CurrentPowerState;
    ULONG CamControlFlag;
#if DBG
    ULONG InitCount;
    ULONG TimeIncrement;
#endif
    USBCAMD_DEVICE_DATA_EX DeviceDataEx;
    ULONG    Usbcamd_version;
    PUSBCAMD_PIPE_PIN_RELATIONS PipePinRelations;
    ULONG EventCount;
    DEVICE_CAPABILITIES DeviceCapabilities;

    PUCHAR CameraDeviceContext[0];

} USBCAMD_DEVICE_EXTENSION, *PUSBCAMD_DEVICE_EXTENSION;

#define DEVICE_UNINITIALIZED  0x00000000
#define DEVICE_INIT_STARTED   0x00000001
#define DEVICE_INIT_COMPLETED 0x00000002

//
// this structure defines the per request extension.  It defines any storage
// space that the mini driver may need in each request packet.
//

typedef struct _USBCAMD_READ_EXTENSION {
    ULONG Sig;
    LIST_ENTRY ListEntry;
    PVOID Srb;
    ULONG StreamNumber;
    ULONG NumberOfPackets;
    PUCHAR RawFrameBuffer;
    ULONG RawFrameLength;
    ULONG ActualRawFrameLen;
    ULONG ActualRawFrameLength;
    ULONG RawFrameOffset;
#if DBG
	ULONG CurrentLostFrames;
#endif
    BOOLEAN DropFrame;      // when set, drop the current frame and recycle read SRB.
    BOOLEAN CopyFrameToStillPin;
    struct _USBCAMD_CHANNEL_EXTENSION *ChannelExtension;
    PUCHAR MinDriverExtension[0];
} USBCAMD_READ_EXTENSION, *PUSBCAMD_READ_EXTENSION;

typedef struct _BULK_TRANSFER_CONTEXT {
    ULONG   RemainingTransferLength;
    ULONG   ChunkSize;
    ULONG   NBytesTransferred;
    PUCHAR  pTransferBuffer;
    PUCHAR  pOriginalTransferBuffer;
    ULONG   PipeIndex;
    BOOLEAN fDestinedForReadBuffer;
    KEVENT  CancelEvent;                // for cancelling bulk or INT IRPs.
    PCOMMAND_COMPLETE_FUNCTION CommandCompleteCallback;
    PVOID   CommandCompleteContext;
    BOOLEAN LoopBack;               // set if I need to resubmit an Int request after completion.
    UCHAR   TransferType;
} BULK_TRANSFER_CONTEXT, *PBULK_TRANSFER_CONTEXT;

typedef struct _USBCAMD_TRANSFER_EXTENSION {
    ULONG Sig;
    LIST_ENTRY ListEntry;
    ULONG PacketFlags;
    ULONG ValidDataOffset;
    BOOLEAN newFrame;
    ULONG BufferLength;
    PUCHAR DataBuffer;
    PUCHAR SyncBuffer;
    PURB SyncUrb;
    PURB DataUrb;
    PIRP SyncIrp;
    PIRP DataIrp;
    PUCHAR WorkBuffer;
    BULK_TRANSFER_CONTEXT BulkContext;
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension;
    struct _USBCAMD_CHANNEL_EXTENSION *ChannelExtension;
} USBCAMD_TRANSFER_EXTENSION, *PUSBCAMD_TRANSFER_EXTENSION;

typedef struct _POWERUP_WORKITEM {
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension;
    WORK_QUEUE_ITEM WorkItem;
} POWERUP_WORKITEM, *PPOWERUP_WORKITEM;

typedef struct _COMMAND_WORK_ITEM {
    PVOID DeviceContext;
    WORK_QUEUE_ITEM WorkItem;
    UCHAR Request;
    USHORT Value;
    USHORT Index;
    PVOID Buffer;
    OUT PULONG BufferLength;
    BOOLEAN GetData;
    PCOMMAND_COMPLETE_FUNCTION CommandComplete;
    PVOID CommandContext;
} COMMAND_WORK_ITEM, *PCOMMAND_WORK_ITEM;

typedef struct _EVENTWAIT_WORKITEM {
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension;
    WORK_QUEUE_ITEM WorkItem;
    struct _USBCAMD_CHANNEL_EXTENSION *ChannelExtension;
    PVOID Buffer;
    ULONG PipeIndex;
    ULONG BufferLength;
    PCOMMAND_COMPLETE_FUNCTION EventComplete;
    PVOID EventContext;
    ULONG Flag;
    BOOLEAN LoopBack;
    UCHAR TransferType;
} EVENTWAIT_WORKITEM, *PEVENTWAIT_WORKITEM;

typedef struct _USBCAMD_IDLE_LOCK {
    
    // Either USBCAMD_STOP_STREAM or USBCAMD_RESET_STREAM (see below)
    // Set when waiting for channel to go idle.
    // Cleared when channel is idle, but only if set to USBCAMD_RESET_STREAM
    // When non-zero, fail all acquire attempts
    LONG IdleLock;
    
    // The number of waiting threads
    LONG Waiting;
    
    // The number of outstanding requests
    LONG Busy;
    
    // Threads block on this
    KEVENT IdleEvent;

} USBCAMD_IDLE_LOCK, *PUSBCAMD_IDLE_LOCK;

//
// value for channel extension Flags field and idle lock stop processing
//
#define USBCAMD_STOP_STREAM             0x00000001
//
// value for idle lock reset processing
//
#define USBCAMD_RESET_STREAM            0x00000002

typedef struct _USBCAMD_WORK_ITEM *PUSBCAMD_WORK_ITEM;

typedef struct _USBCAMD_CHANNEL_EXTENSION {
    ULONG Sig;
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension;

    ULONG Flags;
    BOOL StreamError;
    BOOL ImageCaptureStarted;
    BOOL ChannelPrepared;
    BOOL VirtualStillPin;      // this still pin is piggy back the video pin.
    BOOL CurrentFrameIsStill;  // set if current frame is for the virtual still pin

    USBCAMD_IDLE_LOCK IdleLock;
    KTIMER TimeoutTimer;
    PUSBCAMD_READ_EXTENSION CurrentRequest;
    KSPIN_LOCK  CurrentRequestSpinLock; // sync. access to CurrentRequest.
    USBCAMD_TRANSFER_EXTENSION TransferExtension[USBCAMD_MAX_REQUEST];
    KSPIN_LOCK  TransferSpinLock;   // sync. access to TransferExtensions.
    KDPC TimeoutDpc;

    // Read SRB Queue mgmt.
    LIST_ENTRY PendingIoList;		
    KSPIN_LOCK PendingIoListSpin;

    ULONG RawFrameLength;
    UCHAR StreamNumber;
    UCHAR DataPipeType;

    LONG SyncPipe;
    LONG DataPipe;

    HANDLE MasterClockHandle;
    KS_FRAME_INFO               FrameInfo;          // PictureNumber, etc.

    PKS_VIDEOINFOHEADER         VideoInfoHeader;    // format (variable size!)
    KSSTATE                     KSState;            // Run, Stop, Pause

    PSTREAM_RECEIVE_PACKET CamReceiveCtrlPacket;
    PSTREAM_RECEIVE_PACKET CamReceiveDataPacket;

    //
    // the format number of the currently active stream
    //
    PVOID CurrentFormat;

	BOOLEAN         FirstFrame;
	
    BOOLEAN NoRawProcessingRequired; //
    BOOLEAN IdleIsoStream;          // set if cam driver wants to stop ISO streaming.
	LONGLONG PreviousStreamTime;

#if DBG
    //
    // DEBUG perf variables, these are reset each time the
    // channel is started.
    //
    //
    // inc'ed each time we advance to a new video frame.
    //
	ULONGLONG       FrameCaptured;		// Number of actual frames cptured
    //
    // Frames we have seen but had to toss because
    // no client request was available.
    //
    ULONG VideoFrameLostCount;

    LARGE_INTEGER   StartTime;          // The time at which frame capture started

    // count of video data packets ignored due to error
    ULONG IgnorePacketCount;

    // inc'ed for each packet that completes with an error
    ULONG ErrorDataPacketCount;
    ULONG ErrorSyncPacketCount;

    // inc'ed for each packet not accessed by the HC
    ULONG SyncNotAccessedCount;
    ULONG DataNotAccessedCount;

    // DEBUG Flags
    BOOLEAN InCam;
    UCHAR Pad[3];

#endif
    // total packets received for the current video frame
    ULONG PacketCount;
    ULONG CurrentBulkTransferIndex; // indicates which transfer extension is being used.
} USBCAMD_CHANNEL_EXTENSION, *PUSBCAMD_CHANNEL_EXTENSION;


//#define USBCAMD_SYNC_PIPE    0
//#define USBCAMD_DATA_PIPE    1

typedef struct _USBCAMD_WORK_ITEM  {
    WORK_QUEUE_ITEM WorkItem;
    PUSBCAMD_CHANNEL_EXTENSION ChannelExtension;
    NTSTATUS status;
} USBCAMD_WORK_ITEM;

typedef struct _INTERRUPT_WORK_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PUSBCAMD_DEVICE_EXTENSION pDeviceExt;
	PUSBCAMD_TRANSFER_EXTENSION pTransferExt;
	ULONG PipeIndex;
} INTERRUPT_WORK_ITEM, *PINTERRUPT_WORK_ITEM;

#define USBCAMD_TIMEOUT_INTERVAL    250
#define USBCAMD_STILL_TIMEOUT       290

#define USBCAMD_GET_FRAME_CONTEXT(se)      (&se->MinDriverExtension[0])
#define USBCAMD_GET_DEVICE_CONTEXT(de)     ((PVOID)(&(de)->CameraDeviceContext[0]))
#define USBCAMD_GET_DEVICE_EXTENSION(dc)    (PUSBCAMD_DEVICE_EXTENSION) (((PUCHAR)(dc)) - \
                                            sizeof(USBCAMD_DEVICE_EXTENSION))


#define ULTRA_TRACE 3
#define MAX_TRACE 2
#define MIN_TRACE 1
#define NON_TRACE 0

#if DBG
// The following masks are used with the USBCAMD_DbgLog macro, and will be AND-ed at
// runtime with USBCAMD_LogMask to determine what is logged into USBCAMD_LogBuffer.
#define TL_SRB_MASK         0x0000000F
#define TL_SRB_NOISE        0x00000001
#define TL_SRB_TRACE        0x00000002
#define TL_SRB_WARNING      0x00000004
#define TL_SRB_ERROR        0x00000008

#define TL_CHN_MASK         0x000000F0
#define TL_CHN_NOISE        0x00000010
#define TL_CHN_TRACE        0x00000020
#define TL_CHN_WARNING      0x00000040
#define TL_CHN_ERROR        0x00000080

#define TL_IDL_MASK         0x00000F00
#define TL_IDL_NOISE        0x00000100
#define TL_IDL_TRACE        0x00000200
#define TL_IDL_WARNING      0x00000400
#define TL_IDL_ERROR        0x00000800

#define TL_PRF_MASK         0x0000F000
#define TL_PRF_NOISE        0x00001000
#define TL_PRF_TRACE        0x00002000
#define TL_PRF_WARNING      0x00004000
#define TL_PRF_ERROR        0x00008000

#define TL_VND_MASK         0x000F0000
#define TL_VND_NOISE        0x00010000
#define TL_VND_TRACE        0x00020000
#define TL_VND_WARNING      0x00040000
#define TL_VND_ERROR        0x00080000

// This value is used to initialize USBCAMD_LogMask
#define DEFAULT_LOG_LEVEL   0x0000CCCC

// The DebugLevel, LogMask, and MaxLogEntries are stored in the registry at this location
#define USBCAMD_REG_DBG_STREAM L"\\Registry\\Machine\\system\\currentcontrolset\\services\\usbcamd"

// The format of a log entry in USBCAMD_LogBuffer
typedef struct _USBCAMD_LOG_ENTRY {
    union {
        ULONG       Tag;
        ULONG_PTR   reserved;
    } u;
    ULONG_PTR   Arg1;
    ULONG_PTR   Arg2;
    ULONG_PTR   Arg3;
} USBCAMD_LOG_ENTRY, *PUSBCAMD_LOG_ENTRY;

// Should keep the log buffer an even multiple of PAGE_SIZE for efficient use of memory
#define DEFAULT_MAX_LOG_ENTRIES (PAGE_SIZE/sizeof(USBCAMD_LOG_ENTRY))

extern ULONG USBCAMD_DebugTraceLevel;
extern PUSBCAMD_LOG_ENTRY USBCAMD_LogBuffer;
extern ULONG USBCAMD_LogRefCnt;
extern ULONG USBCAMD_LogMask;
extern LONG USBCAMD_MaxLogEntries;
extern LONG USBCAMD_LastLogEntry;

#define USBCAMD_KdPrint(_t_, _x_) \
    if (USBCAMD_DebugTraceLevel >= _t_) { \
        DbgPrint("'USBCAMD: "); \
        DbgPrint _x_ ;\
    }

NTSTATUS
USBCAMD_InitDbg(void);

NTSTATUS
USBCAMD_ExitDbg(void);

void
USBCAMD_DbgLogInternal(ULONG Tag, ULONG_PTR Arg1, ULONG_PTR Arg2, ULONG_PTR Arg3);

#define USBCAMD_DbgLog(_m_, _t_, _a1_, _a2_, _a3_) \
    if (USBCAMD_LogBuffer && ((_m_) & USBCAMD_LogMask)) { \
        USBCAMD_DbgLogInternal((ULONG)(_t_), (ULONG_PTR)(_a1_), (ULONG_PTR)(_a2_), (ULONG_PTR)(_a3_)); \
    }

NTSTATUS
USBCAMD_StartClock(void);

ULONG
USBCAMD_StopClock(void);

#define ENTER(func)			USBCAMD_KDPrint(ULTRA_TRACE,"--->" #func "()" )
#define EXIT(func)			USBCAMD_KDPrint(ULTRA_TRACE,"<---" #func "()" )


#ifdef NTKERN
#define TRAP()  _asm {int 3}
#define TEST_TRAP() _asm {int 3}
#define TRAP_ERROR(e) if (!NT_SUCCESS(e)) { _asm {int 3} }
#else
#define TRAP()  DbgBreakPoint()
#define TEST_TRAP() DbgBreakPoint()
#define TRAP_ERROR(e) if (!NT_SUCCESS(e)) { DbgBreakPoint(); }
#endif

#define ASSERT_CHANNEL(c) ASSERT((c)->Sig == USBCAMD_CHANNEL_SIG)
#define ASSERT_TRANSFER(t) ASSERT((t)->Sig == USBCAMD_TRANSFER_SIG)
#define ASSERT_DEVICE(d) ASSERT((d)->Sig == USBCAMD_DEVICE_SIG)
#define ASSERT_READ(s) ASSERT((s)->Sig == USBCAMD_READ_SIG)

PVOID
USBCAMD_ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

VOID
USBCAMD_ExFreePool(
    IN PVOID p
    );


extern ULONG USBCAMD_HeapCount;

#else

#define USBCAMD_KdPrint(_t_, _x_)
#define USBCAMD_DbgLog(_m_, _t_, _a1_, _a2_, _a3_)

#define TRAP()

#define TEST_TRAP()

#define TRAP_ERROR(e)

#define ASSERT_CHANNEL(c)
#define ASSERT_TRANSFER(t)
#define ASSERT_DEVICE(d)
#define ASSERT_READ(s)

#define USBCAMD_ExAllocatePool(x, y) ExAllocatePool(x, y)
#define USBCAMD_ExFreePool(x) ExFreePool(x)

#endif /* DBG */

#define USBCAMD_SERIALIZE(de)  { USBCAMD_KdPrint(ULTRA_TRACE, ("'***WAIT dev mutex %x\n", &(de)->Semaphore)); \
                                          KeWaitForSingleObject(&(de)->Semaphore, \
                                                                Executive,\
                                                                KernelMode, \
                                                                FALSE, \
                                                                NULL); \
                                            }

#define USBCAMD_RELEASE(de)   { USBCAMD_KdPrint(ULTRA_TRACE, ("'***RELEASE dev mutex %x\n", &(de)->Semaphore));\
                                          KeReleaseSemaphore(&(de)->Semaphore,\
                                                             LOW_REALTIME_PRIORITY,\
                                                             1,\
                                                             FALSE);\
                                            }


NTSTATUS DllUnload(void);


NTSTATUS
USBCAMD_StartDevice(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
USBCAMD_RemoveDevice(
    IN PUSBCAMD_DEVICE_EXTENSION  DeviceExtension
    );

NTSTATUS
USBCAMD_StopDevice(
    IN PUSBCAMD_DEVICE_EXTENSION  DeviceExtension
    );

NTSTATUS
USBCAMD_CallUSBD(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PURB Urb,
    IN ULONG IoControlCode,
    IN PVOID pArgument1
    );

NTSTATUS
USBCAMD_ConfigureDevice(
    IN  PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
USBCAMD_SelectConfiguration(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
USBCAMD_IsoIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

ULONG
USBCAMD_GetCurrentFrame(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
USBCAMD_InitializeIsoUrb(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN OUT PURB Urb,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PUCHAR Buffer
    );

NTSTATUS
USBCAMD_StartIsoThread(
IN PUSBCAMD_DEVICE_EXTENSION pDeviceExt
);

VOID
USBCAMD_KillIsoThread(
	IN PUSBCAMD_DEVICE_EXTENSION pDeviceExt);
    

NTSTATUS
USBCAMD_SubmitIsoTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN ULONG StartFrame,
    IN BOOLEAN Asap
    );

 NTSTATUS
 USBCAMD_TransferComplete(
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension
    );

PIRP
USBCAMD_BuildIoRequest(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN PURB Urb,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
    );

NTSTATUS
USBCAMD_OpenChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PVOID Format
    );

NTSTATUS
USBCAMD_PrepareChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

void
USBCAMD_ReadChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_READ_EXTENSION ReadExtension
    );

NTSTATUS
USBCAMD_StartChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

VOID
USBCAMD_CopyPacketToFrameBuffer(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN ULONG PacketSize,
    IN ULONG Index
    );

NTSTATUS
USBCAMD_StopChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

NTSTATUS
USBCAMD_InitializeIsoTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN ULONG index
    );

NTSTATUS
USBCAMD_AbortPipe(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN USBD_PIPE_HANDLE PipeHandle
    );

VOID
USBCAMD_PowerUpWorkItem(
    PVOID Context
);

NTSTATUS
USBCAMD_UnPrepareChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

NTSTATUS
USBCAMD_FreeIsoTransfer(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension
    );

NTSTATUS
USBCAMD_CloseChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

VOID
USBCAMD_RecycleIrp(
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN PIRP Irp,
    IN PURB Urb,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
    );

NTSTATUS
USBCAMD_ResetPipes(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    IN BOOLEAN Abort
    );

NTSTATUS
USBCAMD_GetPortStatus(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION channelExtension,
    IN PULONG PortStatus
    );


NTSTATUS
USBCAMD_ResetChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN ULONG portUsbStatus,
    IN ULONG portNtStatus
    );

VOID
USBCAMD_CancelQueuedSRBs(
    PUSBCAMD_CHANNEL_EXTENSION channelExtension
    );


VOID
USBCAMD_CompleteReadRequest(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_READ_EXTENSION ReadExtension,
    IN BOOLEAN CopyFrameToStillPin
    );

NTSTATUS
USBCAMD_StartIsoStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

NTSTATUS
USBCAMD_EnablePort(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    );


VOID
USBCAMD_ProcessIsoIrps(
    PVOID Context
    );

NTSTATUS
USBCAMD_CleanupChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN ULONG StreamNumber
    );

VOID
USBCAMD_ReadIrpCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBCAMD_ChangeMode(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PIRP Irp,
    IN OUT PULONG NewMode
    );

VOID
USBCAMD_CompleteRead(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_READ_EXTENSION ReadExtension,
    IN NTSTATUS NtStatus,
    IN ULONG BytesTransferred
    );

PVOID
USBCAMD_GetFrameBufferFromSrb(
    IN PVOID Srb,
    OUT PULONG MaxLength
    );

VOID
USBCAMD_ResetWorkItem(
    PVOID Context
    );

BOOLEAN
USBCAMD_ProcessResetRequest(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

NTSTATUS
USBCAMD_OpenStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PVOID Format
    );


NTSTATUS
USBCAMD_CloseStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

NTSTATUS
USBCAMD_SetDevicePowerState(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
USBCAMD_CommandWorkItem(
    PVOID Context
    );

VOID VideoGetProperty(
    PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID VideoStreamGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID VideoStreamGetDroppedFramesProperty(
	PHW_STREAM_REQUEST_BLOCK pSrb
	);


VOID
USBCAMD_SetIsoPipeWorkItem(
    PVOID Context
    );

VOID
USBCAMD_ProcessSetIsoPipeState(
    PUSBCAMD_DEVICE_EXTENSION deviceExtension,
    PUSBCAMD_CHANNEL_EXTENSION channelExtension,
    ULONG Flag
    );

//
// prototypes for bulk transfer functions.
//

NTSTATUS
USBCAMD_CancelOutstandingBulkIntIrps(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN BOOLEAN bSaveIrp
        );

VOID
USBCAMD_ProcessInterruptTransferWorkItem(
    PVOID Context
    );

VOID
USBCAMD_ResubmitInterruptTransfer(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN ULONG PipeIndex,
        IN PUSBCAMD_TRANSFER_EXTENSION pTransferContext
    );



NTSTATUS
USBCAMD_CancelOutstandingIrp(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN ULONG PipeIndex,
        IN BOOLEAN bSaveIrp
        );

NTSTATUS
USBCAMD_RestoreOutstandingBulkIntIrps(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension
        );

NTSTATUS
USBCAMD_RestoreOutstandingIrp(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN ULONG PipeIndex,
        IN PUSBCAMD_TRANSFER_EXTENSION pTransferContext
        );


    
ULONGLONG 
GetSystemTime( IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
);

BOOLEAN
USBCAMD_OutstandingIrp(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN ULONG    PipeIndex);

PUSBCAMD_TRANSFER_EXTENSION
USBCAMD_DequeueFirstIrp(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN ULONG    PipeIndex,
    IN PLIST_ENTRY pListHead);
    

NTSTATUS
USBCAMD_StartBulkStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );


NTSTATUS
USBCAMD_IntOrBulkTransfer(
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PVOID    pBuffer,
    IN ULONG    TransferSize,
    IN ULONG    PipeIndex,
    IN PCOMMAND_COMPLETE_FUNCTION commandComplete,
    IN PVOID    commandContext,
    IN BOOLEAN  LoopBack,
    IN UCHAR    TransferType
);

NTSTATUS
USBCAMD_BulkTransferComplete(
    IN PDEVICE_OBJECT       pDeviceObject,
	IN PIRP                 pIrp,
	IN PVOID Context
);

NTSTATUS
USBCAMD_InitializeBulkTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN ULONG PipeIndex
    );

NTSTATUS
USBCAMD_FreeBulkTransfer(
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension
    );

VOID
USBCAMD_CompleteBulkRead(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN NTSTATUS status
    );

VOID
USBCAMD_ProcessStillReadWorkItem(
    PVOID Context
    );

VOID
USBCAMD_PnPHandler(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PIRP pIrp,
    IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
    IN PIO_STACK_LOCATION ioStackLocation);

NTSTATUS
USBCAMD_CallUsbdCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

//
// prototypes for general queue management using a busy flag
//
BOOL
STREAMAPI
AddToListIfBusy (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN KSPIN_LOCK              *SpinLock,
    IN OUT BOOL                *BusyFlag,
    IN LIST_ENTRY              *ListHead
    );

BOOL
STREAMAPI
RemoveFromListIfAvailable (
    IN OUT PHW_STREAM_REQUEST_BLOCK *pSrb,
    IN KSPIN_LOCK                   *SpinLock,
    IN OUT BOOL                     *BusyFlag,
    IN LIST_ENTRY                   *ListHead
    );

ULONGLONG GetStreamTime(
	IN PHW_STREAM_REQUEST_BLOCK Srb,
	IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
	);

NTSTATUS
USBCAMD_SetIsoPipeState(
    IN PVOID DeviceContext,
    IN ULONG PipeStateFlags
    );


NTSTATUS
USBCAMD_SetVideoFormat(
    IN PVOID DeviceContext,
    IN  PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
USBCAMD_WaitOnDeviceEvent(
    IN PVOID DeviceContext,
    IN ULONG PipeIndex,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PCOMMAND_COMPLETE_FUNCTION   EventComplete,
    IN PVOID EventContext,
    IN BOOLEAN LoopBack
    );

NTSTATUS
USBCAMD_BulkReadWrite(
    IN PVOID DeviceContext,
    IN USHORT PipeIndex,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PCOMMAND_COMPLETE_FUNCTION CommandComplete,
    IN PVOID CommandContext
    );

NTSTATUS
USBCAMD_CancelBulkReadWrite(
    IN PVOID DeviceContext,
    IN ULONG PipeIndex
    );


NTSTATUS
USBCAMD_SetPipeState(
    IN PVOID DeviceContext,
    IN UCHAR PipeState,
    IN ULONG StreamNumber
    );

VOID
USBCAMD_EventWaitWorkItem(
    PVOID Context
    );

NTSTATUS
USBCAMD_Parse_PipeConfig(
     IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
     IN ULONG numberOfPipes
     ) ;

NTSTATUS STREAMAPI USBCAMD_DeviceEventProc (
      PHW_EVENT_DESCRIPTOR pEvent);

VOID USBCAMD_NotifyStiMonitor(
      PUSBCAMD_DEVICE_EXTENSION deviceExtension);

NTSTATUS
USBCAMD_BulkOutComplete(
    PVOID DeviceContext,
    PVOID Context,
    NTSTATUS ntStatus
    );
    
NTSTATUS
USBCAMD_QueryCapabilities(
    IN PUSBCAMD_DEVICE_EXTENSION pDeviceExt
    );

VOID
USBCAMD_InitializeIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    );

NTSTATUS
USBCAMD_AcquireIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    );

VOID
USBCAMD_ReleaseIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    );

NTSTATUS
USBCAMD_WaitForIdle(
    IN OUT PUSBCAMD_IDLE_LOCK Lock,
    IN LONG Flag
    );

VOID
USBCAMD_ClearIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    );

__inline void
COMPLETE_STREAM_READ(
    PHW_STREAM_REQUEST_BLOCK Srb
    )
{
    if (Srb->Command == SRB_READ_DATA) {

        if (0 == Srb->CommandData.DataBufferArray->DataUsed) {
#if 0
            // Enable this code if you want to see intermittent green frames
            ULONG maxLength;
            PVOID frameBuffer;

            frameBuffer = USBCAMD_GetFrameBufferFromSrb(Srb,&maxLength);

            RtlZeroMemory(frameBuffer, maxLength);
#else
            Srb->Status = STATUS_CANCELLED;
#endif
        }
    }

    USBCAMD_DbgLog(TL_SRB_TRACE, '-brS', Srb, Srb->Command, (ULONG_PTR)Srb->Status);
    StreamClassStreamNotification(StreamRequestComplete, Srb->StreamObject, Srb);
}


#if DBG

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR PnPSystemPowerStateString(
		ULONG SysPowerState
);

PCHAR
PnPPowerString (
    UCHAR MinorFunction
);

PCHAR PnPDevicePowerStateString(
		ULONG DevicePowerState
);


VOID
USBCAMD_DebugStats(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

PVOID
USBCAMD_AllocateRawFrameBuffer(
    ULONG RawFrameLength
    );

VOID
USBCAMD_FreeRawFrameBuffer(
    PVOID RawFrameBuffer
    );

VOID
USBCAMD_CheckRawFrameBuffer(
    PVOID RawFrameBuffer
    );

VOID
USBCAMD_DumpReadQueues(
    IN PUSBCAMD_DEVICE_EXTENSION deviceExtension
    );

#else

#define USBCAMD_AllocateRawFrameBuffer(l)  USBCAMD_ExAllocatePool(NonPagedPool, l)

#define USBCAMD_FreeRawFrameBuffer(p) ExFreePool(p)

#define USBCAMD_CheckRawFrameBuffer(p)

#endif

#endif /*  __USBCAMD_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\usbcamd\iso.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   iso.c

Abstract:

   Isochronous transfer code for usbcamd USB camera driver

Environment:

    kernel mode only

Author:

    Original 3/96 John Dunn
    Updated  3/98 Husni Roukbi

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:



--*/

#include "usbcamd.h"

#define COPY_Y 0
#define COPY_U 1
#define COPY_V 2



#if DBG
// some global debug variables
ULONG USBCAMD_VideoFrameStop = 0;
#endif

NTSTATUS
USBCAMD_InitializeIsoTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN ULONG index
    )
/*++

Routine Description:

    Initializes an Iso transfer, an iso transfer consists of two parallel iso 
    requests, one on the sync pipe and one on the data pipe.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    ChannelExtension - extension specific to this video channel

    InterfaceInformation - pointer to USBD interface information structure 
        describing the currently active interface.

    TransferExtension - context information associated with this transfer set.        


Return Value:

    NT status code

--*/
{
    PUSBCAMD_TRANSFER_EXTENSION TransferExtension = &ChannelExtension->TransferExtension[index];
    PUSBD_INTERFACE_INFORMATION InterfaceInformation = DeviceExtension->Interface;
    ULONG workspace;
    ULONG packetSize;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG offset = 0;
    
    ASSERT_CHANNEL(ChannelExtension);
       
    USBCAMD_KdPrint (MAX_TRACE, ("enter USBCAMD_InitializeIsoTransfer\n"));

    if ( ChannelExtension->VirtualStillPin ) {
        PUSBCAMD_TRANSFER_EXTENSION VideoTransferExtension;
        PUSBCAMD_CHANNEL_EXTENSION  VideoChannelExtension;

        // for virtual still pin, transfer extension should point to the same 
        // data & synch buffers as the video transfer ext.
        VideoChannelExtension = DeviceExtension->ChannelExtension[STREAM_Capture];
        VideoTransferExtension = &VideoChannelExtension->TransferExtension[index];
        RtlCopyMemory(TransferExtension,
                      VideoTransferExtension,
                      sizeof(USBCAMD_TRANSFER_EXTENSION));
        TransferExtension->ChannelExtension = ChannelExtension;
        TransferExtension->SyncIrp = TransferExtension->DataIrp = NULL;
        return STATUS_SUCCESS;
    }

    //
    // allocate some contiguous memory for this request
    //

    TransferExtension->Sig = USBCAMD_TRANSFER_SIG;     
    TransferExtension->DeviceExtension = DeviceExtension;
    TransferExtension->ChannelExtension = ChannelExtension;

    packetSize = InterfaceInformation->Pipes[ChannelExtension->DataPipe].MaximumPacketSize;
    // chk if client driver still using alt. setting 0.
    if (packetSize == 0) {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        return ntStatus;
    }
    
    TransferExtension->BufferLength = 
        (packetSize*USBCAMD_NUM_ISO_PACKETS_PER_REQUEST) + USBCAMD_NUM_ISO_PACKETS_PER_REQUEST;

    TransferExtension->SyncBuffer =       
        TransferExtension->DataBuffer =  
            USBCAMD_ExAllocatePool(NonPagedPool, 
                                   TransferExtension->BufferLength);       

    if (TransferExtension->SyncBuffer == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBCAMD_InitializeIsoTransfer_Done;
    }

    //
    // allow for one byte packets on the sync stream
    //
    
    TransferExtension->DataBuffer += USBCAMD_NUM_ISO_PACKETS_PER_REQUEST;   

    USBCAMD_KdPrint (ULTRA_TRACE, ("Data Buffer = 0x%x\n", TransferExtension->DataBuffer));
    USBCAMD_KdPrint (ULTRA_TRACE, ("Sync Buffer = 0x%x\n", TransferExtension->SyncBuffer));

    //
    // allocate working space
    //

    workspace = GET_ISO_URB_SIZE(USBCAMD_NUM_ISO_PACKETS_PER_REQUEST)*2;

    TransferExtension->WorkBuffer = USBCAMD_ExAllocatePool(NonPagedPool, workspace);
       
    if (TransferExtension->WorkBuffer) {

        TransferExtension->SyncUrb = 
            (PURB) TransferExtension->WorkBuffer; 
    
        TransferExtension->DataUrb = 
            (PURB) (TransferExtension->WorkBuffer + 
            GET_ISO_URB_SIZE(USBCAMD_NUM_ISO_PACKETS_PER_REQUEST));

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        //MmFreeContiguousMemory(TransferExtension->SyncBuffer);
        USBCAMD_ExFreePool(TransferExtension->SyncBuffer);
        TransferExtension->SyncBuffer = NULL;
    }

USBCAMD_InitializeIsoTransfer_Done:
#if DBG
    if (ntStatus != STATUS_SUCCESS)
        USBCAMD_KdPrint (MIN_TRACE, ("exit USBCAMD_InitializeIsoTransfer 0x%x\n", ntStatus));
#endif

    return ntStatus;
}


NTSTATUS
USBCAMD_FreeIsoTransfer(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension
    )
/*++

Routine Description:

    Opposite of USBCAMD_InitializeIsoTransfer, frees resources allocated for an 
    iso transfer.

Arguments:

    ChannelExtension - extension specific to this video channel

    TransferExtension - context information for this transfer (pair of iso 
        urbs).

Return Value:

    NT status code

--*/
{
    ASSERT_TRANSFER(TransferExtension);
    ASSERT_CHANNEL(ChannelExtension);
  
    USBCAMD_KdPrint (MAX_TRACE, ("Free Iso Transfer\n"));

    //
    // now free memory, SyncBuffer pointer holds the pool pointer for both sync and data buffers
    //

    if (TransferExtension->SyncBuffer) {
        USBCAMD_ExFreePool(TransferExtension->SyncBuffer);
        TransferExtension->SyncBuffer = NULL;
    }

    if (TransferExtension->WorkBuffer) {
        USBCAMD_ExFreePool(TransferExtension->WorkBuffer);
        TransferExtension->WorkBuffer = NULL;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
USBCAMD_SubmitIsoTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN ULONG StartFrame,
    IN BOOLEAN Asap
    )
/*++

Routine Description:

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    TransferExtension - context information for this transfer (pair of iso 
        urbs).

    StartFrame - usb frame number to begin transmiting this pair of iso 
        requests.

    Asap - if false transfers are started on StartFrame otherwise they are 
        scheduled to start after the current transfer queued for the endpoint.            

Return Value:

    NT status code

--*/
{
    PUSBCAMD_CHANNEL_EXTENSION channelExtension = TransferExtension->ChannelExtension;
    KIRQL oldIrql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ASSERT_TRANSFER(TransferExtension);
    ASSERT_CHANNEL(channelExtension);

    if (!DeviceExtension->Initialized || !TransferExtension->SyncBuffer) {
        return STATUS_DEVICE_DATA_ERROR;
    }

    RtlZeroMemory(TransferExtension->SyncBuffer,
        USBCAMD_NUM_ISO_PACKETS_PER_REQUEST);

    // Hold the spin lock while creating the IRPs
    KeAcquireSpinLock(&channelExtension->TransferSpinLock, &oldIrql);
    ASSERT(!TransferExtension->SyncIrp && !TransferExtension->DataIrp);

    // Allocate the IRPs separately from the rest of the logic
    if (channelExtension->SyncPipe != -1) {

        TransferExtension->SyncIrp = USBCAMD_BuildIoRequest(
            DeviceExtension,
            TransferExtension,
            TransferExtension->SyncUrb,
            USBCAMD_IsoIrp_Complete
            );
        if (TransferExtension->SyncIrp) {
            ntStatus = USBCAMD_AcquireIdleLock(&channelExtension->IdleLock);
        }
        else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }                                         

    if (STATUS_SUCCESS == ntStatus) {

        TransferExtension->DataIrp = USBCAMD_BuildIoRequest(
            DeviceExtension,
            TransferExtension,
            TransferExtension->DataUrb,
            USBCAMD_IsoIrp_Complete
            );
        if (TransferExtension->DataIrp) {
            ntStatus = USBCAMD_AcquireIdleLock(&channelExtension->IdleLock);
        }
        else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    KeReleaseSpinLock(&channelExtension->TransferSpinLock, oldIrql);
                              
    if (STATUS_SUCCESS == ntStatus) {

        if (TransferExtension->SyncIrp) {

            USBCAMD_InitializeIsoUrb(
                DeviceExtension, 
                TransferExtension->SyncUrb, 
                &DeviceExtension->Interface->Pipes[channelExtension->SyncPipe],
                TransferExtension->SyncBuffer
                );
            if (Asap) {
                // set the asap flag
                TransferExtension->SyncUrb->UrbIsochronousTransfer.TransferFlags |=
                    USBD_START_ISO_TRANSFER_ASAP;
            }
            else {
                // clear asap flag
                TransferExtension->SyncUrb->UrbIsochronousTransfer.TransferFlags &=
                    (~USBD_START_ISO_TRANSFER_ASAP);
                // set the start frame
                TransferExtension->SyncUrb->UrbIsochronousTransfer.StartFrame = StartFrame;
            }

            ntStatus = IoCallDriver(DeviceExtension->StackDeviceObject, TransferExtension->SyncIrp);
        }

        // STATUS_PENDING (from SyncIrp if any) is considered successful
        if (NT_SUCCESS(ntStatus)) {

            USBCAMD_InitializeIsoUrb(
                DeviceExtension,
                TransferExtension->DataUrb,
                &DeviceExtension->Interface->Pipes[channelExtension->DataPipe],
                TransferExtension->DataBuffer
                );

            if (Asap) {
                // set the asap flag
                TransferExtension->DataUrb->UrbIsochronousTransfer.TransferFlags |=
                    USBD_START_ISO_TRANSFER_ASAP;
            }
            else {
                // clear asap flag
                TransferExtension->DataUrb->UrbIsochronousTransfer.TransferFlags &=
                    (~USBD_START_ISO_TRANSFER_ASAP);
                TransferExtension->DataUrb->UrbIsochronousTransfer.StartFrame = StartFrame;
            }

            ntStatus = IoCallDriver(DeviceExtension->StackDeviceObject, TransferExtension->DataIrp);
            if (STATUS_PENDING == ntStatus) {
                ntStatus = STATUS_SUCCESS;
            }
        }
        else {

            USBCAMD_KdPrint (MIN_TRACE, ("USBD failed the SyncIrp = 0x%x\n", ntStatus));

            KeAcquireSpinLock(&channelExtension->TransferSpinLock, &oldIrql);

            // we haven't sent the DataIrp yet, so we can free it here
            IoFreeIrp(TransferExtension->DataIrp),
            TransferExtension->DataIrp = NULL;

            USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);

            KeReleaseSpinLock(&channelExtension->TransferSpinLock, oldIrql);
        }
    }
    else {

        KeAcquireSpinLock(&channelExtension->TransferSpinLock, &oldIrql);

        if (TransferExtension->SyncIrp) {

            IoFreeIrp(TransferExtension->SyncIrp);
            TransferExtension->SyncIrp = NULL;

            USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
        }

        if (TransferExtension->DataIrp) {

            IoFreeIrp(TransferExtension->DataIrp);
            TransferExtension->DataIrp = NULL;

            USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
        }

        KeReleaseSpinLock(&channelExtension->TransferSpinLock, oldIrql);
    }

    return ntStatus;
}


NTSTATUS
USBCAMD_IsoIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP, if this is
    the second irp of a transfer pair then the TransferComplete routine is 
    called to process the urbs associated with both irps in the transfer.  

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context, points to a transfer extension structure 
        for a pair of parallel iso requests.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PUSBCAMD_TRANSFER_EXTENSION transferExtension;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;

    BOOLEAN TransferComplete;
    KIRQL oldIrql;
   
    USBCAMD_KdPrint (ULTRA_TRACE, ("enter USBCAMD_IsoIrp_Complete = 0x%x\n", Irp));
   
    transferExtension = Context;
    channelExtension = transferExtension->ChannelExtension;
    deviceExtension = transferExtension->DeviceExtension;
    
    ASSERT_TRANSFER(transferExtension);
    ASSERT_CHANNEL(channelExtension);

    // Hold the spin lock while checking and clearing the IRP pointers
    KeAcquireSpinLock(&channelExtension->TransferSpinLock, &oldIrql);

    if (Irp == transferExtension->SyncIrp) {
        transferExtension->SyncIrp = NULL;
    }
    else
    if (Irp == transferExtension->DataIrp) {
        transferExtension->DataIrp = NULL;
    }
#if DBG
    else {

        USBCAMD_KdPrint (MIN_TRACE, ("Unexpected IRP = 0x%x!\n", Irp));
    }
#endif

    // Save the transfer state before releasing the spin lock
    TransferComplete = (!transferExtension->SyncIrp && !transferExtension->DataIrp);

    KeReleaseSpinLock(&channelExtension->TransferSpinLock, oldIrql);
                              
    if (!(channelExtension->Flags & USBCAMD_STOP_STREAM) && !channelExtension->StreamError) {

        if (!Irp->Cancel) {

            if (STATUS_SUCCESS == Irp->IoStatus.Status) {

                if (TransferComplete) {

                    NTSTATUS ntStatus = STATUS_SUCCESS;

                    //
                    // all irps completed for transfer
                    //

                    USBCAMD_KdPrint (ULTRA_TRACE, ("pending Irps Completed for transfer\n"));

                    if (transferExtension->DataUrb->UrbIsochronousTransfer.Hdr.Status ) {
                         USBCAMD_KdPrint (MIN_TRACE, ("Isoch DataUrb Transfer Failed #1, status = 0x%X\n",
                                            transferExtension->DataUrb->UrbIsochronousTransfer.Hdr.Status ));
                         USBCAMD_ProcessResetRequest(deviceExtension,channelExtension); 
                         ntStatus = STATUS_UNSUCCESSFUL;                                  
                    }
                    if (channelExtension->SyncPipe != -1) {
                        if (transferExtension->SyncUrb->UrbIsochronousTransfer.Hdr.Status ) {
                            USBCAMD_KdPrint (MIN_TRACE, ("Isoch SynchUrb Transfer Failed #2, status = 0x%X\n",
                                           transferExtension->SyncUrb->UrbIsochronousTransfer.Hdr.Status ));
                            USBCAMD_ProcessResetRequest(deviceExtension,channelExtension); 
                            ntStatus = STATUS_UNSUCCESSFUL;
                        }
                    }                

                    if (STATUS_SUCCESS == ntStatus) {

                        //
                        // Call the comnpletion handler for this transfer
                        //

                        USBCAMD_TransferComplete(transferExtension);
                    }
                }
            }
            else {

                USBCAMD_KdPrint(MIN_TRACE, ("Isoch Urb Transfer Failed, status = 0x%X\n",
                   Irp->IoStatus.Status ));

                USBCAMD_ProcessResetRequest(deviceExtension, channelExtension); 
            }
        }
        else {

            // Cancellation is not an error
            USBCAMD_KdPrint (MIN_TRACE, ("*** ISO IRP CANCELLED ***\n"));
        }
    }
#if DBG
    else {

        USBCAMD_KdPrint (MIN_TRACE, ("Iso IRP completed in stop or error state\n"));
    }
#endif

    // We're done with this IRP, so free it
    IoFreeIrp(Irp);

    // This must be released here, rather than at the beginning of the
    // completion routine, in order to avoid false idle indication
    USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);

    return STATUS_MORE_PROCESSING_REQUIRED;      
}                    


PIRP
USBCAMD_BuildIoRequest(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN PURB Urb,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
    )
/*++

Routine Description:

    Allocate an Irp and attach a urb to it.
    
Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    TransferExtension - context information for this transfer (pair of iso 
        urbs or one interrupt/bulk urb).

    Urb - Urb to attach to this irp.

Return Value:

    Allocated irp or NULL.

--*/    
{
    CCHAR stackSize;
    PIRP irp;
    PIO_STACK_LOCATION nextStack;

    stackSize = (CCHAR)(DeviceExtension->StackDeviceObject->StackSize );

    irp = IoAllocateIrp(stackSize,
                        FALSE);
    if (irp == NULL) {
        USBCAMD_KdPrint(MIN_TRACE, ("USBCAMD_BuildIoRequest: Failed to create an IRP.\n"));
        return irp;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = Urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
        IOCTL_INTERNAL_USB_SUBMIT_URB;                    
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    IoSetCompletionRoutine(irp,
            CompletionRoutine,
            TransferExtension,
            TRUE,
            TRUE,
            TRUE);

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    return irp;
}


NTSTATUS
USBCAMD_InitializeIsoUrb(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN OUT PURB Urb,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    Packetizes a buffer and initializes an iso urb request based on 
        charateristics of the input USB pipe.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    Urb - iso urb to initialize.

    PipeInformation - Usbd pipe information for the pipe this urb will be 
        submitted to.

    Buffer - Data buffer to packetize for this request

Return Value:

    NT status code.

--*/
{
    ULONG packetSize = PipeInformation->MaximumPacketSize;
    ULONG i;

    USBCAMD_KdPrint (MAX_TRACE, ("enter USBCAMD_InitializeIsoUrb = 0x%x packetSize = 0x%x\n",
        Urb, packetSize, PipeInformation->PipeHandle));

    USBCAMD_KdPrint (ULTRA_TRACE, ("handle = 0x%x\n", PipeInformation->PipeHandle));        
        
    RtlZeroMemory(Urb, GET_ISO_URB_SIZE(USBCAMD_NUM_ISO_PACKETS_PER_REQUEST));
    
    Urb->UrbIsochronousTransfer.Hdr.Length = 
                GET_ISO_URB_SIZE(USBCAMD_NUM_ISO_PACKETS_PER_REQUEST);
    Urb->UrbIsochronousTransfer.Hdr.Function = 
                URB_FUNCTION_ISOCH_TRANSFER;
    Urb->UrbIsochronousTransfer.PipeHandle = 
                PipeInformation->PipeHandle;
    Urb->UrbIsochronousTransfer.TransferFlags = 
                USBD_START_ISO_TRANSFER_ASAP | USBD_TRANSFER_DIRECTION_IN;
                
    Urb->UrbIsochronousTransfer.NumberOfPackets = USBCAMD_NUM_ISO_PACKETS_PER_REQUEST;
    Urb->UrbIsochronousTransfer.UrbLink = NULL;

    for (i=0; i< Urb->UrbIsochronousTransfer.NumberOfPackets; i++) {
        Urb->UrbIsochronousTransfer.IsoPacket[i].Offset
                    = i * packetSize;
    }

    Urb->UrbIsochronousTransfer.TransferBuffer = Buffer;
        
    Urb->UrbIsochronousTransfer.TransferBufferMDL = NULL;
    Urb->UrbIsochronousTransfer.TransferBufferLength = 
        Urb->UrbIsochronousTransfer.NumberOfPackets * packetSize;     

    USBCAMD_KdPrint (MAX_TRACE, ("Init Iso Urb Length = 0x%x buf = 0x%x start = 0x%x\n", 
        Urb->UrbIsochronousTransfer.TransferBufferLength,
        Urb->UrbIsochronousTransfer.TransferBuffer,
        Urb->UrbIsochronousTransfer.StartFrame));     

    USBCAMD_KdPrint (MAX_TRACE, ("exit USBCAMD_InitializeIsoUrb\n"));        


    return STATUS_SUCCESS;        
}


ULONG
USBCAMD_GetCurrentFrame(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Get the current USB frame number.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

Return Value:

    Current Frame Number

--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    ULONG currentUSBFrame = 0;

    urb = USBCAMD_ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER));
                         
    if (urb) {

        urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_GET_CURRENT_FRAME_NUMBER);
        urb->UrbHeader.Function = URB_FUNCTION_GET_CURRENT_FRAME_NUMBER;

        ntStatus = USBCAMD_CallUSBD(DeviceExtension, urb,0,NULL);

        USBCAMD_KdPrint (MAX_TRACE, ("Current Frame = 0x%x\n", 
            urb->UrbGetCurrentFrameNumber.FrameNumber));

        if (NT_SUCCESS(ntStatus) && USBD_SUCCESS(URB_STATUS(urb))) {
            currentUSBFrame = urb->UrbGetCurrentFrameNumber.FrameNumber;
        }

        USBCAMD_ExFreePool(urb);
        
    } else {
        USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_GetCurrentFrame: USBCAMD_ExAllocatePool(%d) failed!\n", 
                         sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER) ) ); 
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;       
    }       

    USBCAMD_KdPrint (MAX_TRACE, ("exit USBCAMD_GetCurrentFrame status = 0x%x current frame = 0x%x\n", 
        ntStatus, currentUSBFrame));    


    // TRAP_ERROR(ntStatus);
    
    return currentUSBFrame;         
}   


NTSTATUS
USBCAMD_TransferComplete(
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension
    )
/*++

Routine Description:

    Called when the both the data and sync request are complete for a transfer
    this is the guts of the stream processing code.

Arguments:

    TransferExtension - context information for this transfer (pair of iso 
        urbs).

Return Value:

    NT status code.

--*/    
{
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    ULONG numPackets, i;
    PLIST_ENTRY listEntry;
    ULONG packetSize;
    BOOLEAN nextFrameIsStill;
    ULONG receiveLength = 0;
    PURB syncUrb, dataUrb;
    PVOID pCamSrbExt;

    ASSERT_TRANSFER(TransferExtension);
    deviceExtension = TransferExtension->DeviceExtension;
    

    packetSize = 
        deviceExtension->Interface->Pipes[TransferExtension->ChannelExtension->DataPipe].MaximumPacketSize;

    // 
    // walk through the buffer extracting video frames
    //
    numPackets = 
        TransferExtension->DataUrb->UrbIsochronousTransfer.NumberOfPackets;

#if DBG
    if (TransferExtension->SyncUrb && TransferExtension->ChannelExtension->SyncPipe != -1) {
        ASSERT(TransferExtension->SyncUrb->UrbIsochronousTransfer.NumberOfPackets ==
                TransferExtension->DataUrb->UrbIsochronousTransfer.NumberOfPackets);        
    }  
#endif    

    USBCAMD_KdPrint (ULTRA_TRACE, ("Transfer req. completed \n"));
    
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    KeAcquireSpinLockAtDpcLevel(&TransferExtension->ChannelExtension->CurrentRequestSpinLock);

    for (i=0; i<numPackets; i++) {               
        syncUrb = TransferExtension->SyncUrb;
        dataUrb = TransferExtension->DataUrb;

#if DBG   
        //
        // DEBUG stats
        //
        // keep a count of the number of packets processed for this
        // vid frame.
        //
        if (USBCAMD_VideoFrameStop &&
            TransferExtension->ChannelExtension->FrameCaptured == USBCAMD_VideoFrameStop) {
            //
            // This will cause us to stop when we begin processing 
            // video frame number x where x=USBCAMD_VideoFrameStop
            //
            
            TRAP();
        }           

        if (syncUrb && USBD_ERROR(syncUrb->UrbIsochronousTransfer.IsoPacket[i].Status)
            && TransferExtension->ChannelExtension->SyncPipe != -1) {
            TransferExtension->ChannelExtension->ErrorSyncPacketCount++;    
        }            

        if (USBD_ERROR(dataUrb->UrbIsochronousTransfer.IsoPacket[i].Status)) {
            TransferExtension->ChannelExtension->ErrorDataPacketCount++;    
        }            

        if (syncUrb && 
            (syncUrb->UrbIsochronousTransfer.IsoPacket[i].Status & 0x0FFFFFFF)
              == (USBD_STATUS_NOT_ACCESSED & 0x0FFFFFFF) && 
              TransferExtension->ChannelExtension->SyncPipe != -1) {   
            TransferExtension->ChannelExtension->SyncNotAccessedCount++;    
        }            

        if ((dataUrb->UrbIsochronousTransfer.IsoPacket[i].Status & 0x0FFFFFFF)
            == (USBD_STATUS_NOT_ACCESSED & 0x0FFFFFFF)) {   
            TransferExtension->ChannelExtension->DataNotAccessedCount++;    
        }       

#endif    

        // process the packet
        TransferExtension->newFrame = FALSE;
//        TransferExtension->nextFrameIsStill = FALSE;
        TransferExtension->ValidDataOffset= 0; // offset of which we will start copying from this pckt.
        TransferExtension->PacketFlags = 0;
        if ( deviceExtension->ChannelExtension[STREAM_Still] && 
             deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest ) {
            pCamSrbExt = USBCAMD_GET_FRAME_CONTEXT(deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest) ;
        }
        else if (TransferExtension->ChannelExtension->CurrentRequest ){
            pCamSrbExt = USBCAMD_GET_FRAME_CONTEXT(TransferExtension->ChannelExtension->CurrentRequest);
        }
        else {
            pCamSrbExt = NULL;
        }

        if ( deviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
            receiveLength =  (*deviceExtension->DeviceDataEx.DeviceData2.CamProcessUSBPacketEx)(
                deviceExtension->StackDeviceObject,
                USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                pCamSrbExt,
                &syncUrb->UrbIsochronousTransfer.IsoPacket[i],
                TransferExtension->SyncBuffer+i,
                &dataUrb->UrbIsochronousTransfer.IsoPacket[i],
                TransferExtension->DataBuffer + 
                   TransferExtension->DataUrb->UrbIsochronousTransfer.IsoPacket[i].Offset,
                &TransferExtension->newFrame,
                &TransferExtension->PacketFlags,
                &TransferExtension->ValidDataOffset);                    
        }
        else{
            receiveLength =  (*deviceExtension->DeviceDataEx.DeviceData.CamProcessUSBPacket)(
                deviceExtension->StackDeviceObject,
                USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                pCamSrbExt,
                &syncUrb->UrbIsochronousTransfer.IsoPacket[i],
                TransferExtension->SyncBuffer+i,
                &dataUrb->UrbIsochronousTransfer.IsoPacket[i],
                TransferExtension->DataBuffer + 
                   TransferExtension->DataUrb->UrbIsochronousTransfer.IsoPacket[i].Offset,
                &TransferExtension->newFrame,
                &nextFrameIsStill);   
            // 
            // set validdataoffset to zero for compatibility.
            //
            TransferExtension->ValidDataOffset = 0;
        }
        
        // process pkt flags
        if ( TransferExtension->PacketFlags & USBCAMD_PROCESSPACKETEX_CurrentFrameIsStill) {
            TransferExtension->ChannelExtension->CurrentFrameIsStill = TRUE;
        }
        
        
        if ( TransferExtension->PacketFlags & USBCAMD_PROCESSPACKETEX_DropFrame) {
            if (deviceExtension->ChannelExtension[STREAM_Still] && 
                deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest ) {
                deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest->DropFrame = TRUE;
            }
            else if (deviceExtension->ChannelExtension[STREAM_Capture] &&  
                 deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest ) {
                deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest->DropFrame = TRUE;
            }                
        }
        
        
        if (TransferExtension->newFrame) {

            PUSBCAMD_READ_EXTENSION readExtension;
            PHW_STREAM_REQUEST_BLOCK srb;
            ULONG StreamNumber;
#if DBG            
            // we increment framecaptured cntr at every SOV.
            // this will happen regardless of SRBs availability.
            
            if (!(TransferExtension->PacketFlags & USBCAMD_PROCESSPACKETEX_NextFrameIsStill)) {

                TransferExtension->ChannelExtension->FrameCaptured++;  

            }   
#endif
            if ( deviceExtension->ChannelExtension[STREAM_Still] && 
                 deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest ) {
                readExtension = deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest ;
            }
            else if (deviceExtension->ChannelExtension[STREAM_Capture] && 
                     deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest ) { 
                readExtension = deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest ;
            }
            else {
                readExtension = NULL;
            }
                
            if (readExtension) {
                srb = readExtension->Srb;
                StreamNumber = srb->StreamObject->StreamNumber;
            
                ASSERT(STREAM_Capture == StreamNumber || STREAM_Still == StreamNumber);
                deviceExtension->ChannelExtension[StreamNumber]->CurrentRequest = NULL; 

                //
                // if we have an Irp for the current video frame complete it.
                //

                if ( TransferExtension->ChannelExtension->CurrentFrameIsStill)  {

                    USBCAMD_KdPrint (MIN_TRACE, ("Current frame is Still. \n"));

                    // we need to replicate the same frame on the still pin.
                    USBCAMD_CompleteReadRequest( TransferExtension->ChannelExtension, 
                                                     readExtension,
                                                     TRUE);

                    TransferExtension->ChannelExtension->CurrentFrameIsStill = FALSE;
                }
                else{
                    if ( readExtension->DropFrame) {
                        readExtension->DropFrame = FALSE;

                        USBCAMD_KdPrint (MAX_TRACE, ("Dropping current frame on Stream # %d\n",
                                                StreamNumber));
                           
                        // recycle the read SRB
                        ExInterlockedInsertHeadList( &(deviceExtension->ChannelExtension[StreamNumber]->PendingIoList),
                                             &(readExtension->ListEntry),
                                             &deviceExtension->ChannelExtension[StreamNumber]->PendingIoListSpin);
                
                    } // end of drop frame
                    else {
                        if ( StreamNumber == STREAM_Capture ) {

                            USBCAMD_KdPrint (ULTRA_TRACE, ("current raw video frame is completed\n"));
                            USBCAMD_CompleteReadRequest( deviceExtension->ChannelExtension[STREAM_Capture], 
                                                             readExtension,
                                                             FALSE);
                        }
                        else {
                            USBCAMD_KdPrint (ULTRA_TRACE, ("current raw still frame is completed. \n"));
                            USBCAMD_CompleteReadRequest( deviceExtension->ChannelExtension[STREAM_Still], 
                                                         readExtension,
                                                         FALSE);
                        }                               
                    }
                }
                // end of complete current frame.
                
                USBCAMD_KdPrint (ULTRA_TRACE, ("Completed/Dropped Raw Frame SRB = 0x%x\n",srb));
                USBCAMD_KdPrint (ULTRA_TRACE,("Raw Frame Size = 0x%x \n",readExtension->RawFrameOffset));
                
            }   // end of current request

            //                       
            // start of new video or still frame
            //


            if (TransferExtension->PacketFlags & USBCAMD_PROCESSPACKETEX_NextFrameIsStill) {
                listEntry = 
                    ExInterlockedRemoveHeadList( &(deviceExtension->ChannelExtension[STREAM_Still]->PendingIoList),
                                                 &deviceExtension->ChannelExtension[STREAM_Still]->PendingIoListSpin);         
                StreamNumber = STREAM_Still;
                USBCAMD_KdPrint (MAX_TRACE, ("New frame is Still\n"));
            }
            else {
                listEntry = 
                    ExInterlockedRemoveHeadList( &(deviceExtension->ChannelExtension[STREAM_Capture]->PendingIoList),
                                                 &deviceExtension->ChannelExtension[STREAM_Capture]->PendingIoListSpin);         
                StreamNumber = STREAM_Capture;
            }
            
            if (listEntry != NULL) {
                PUCHAR dst, end;
          
                readExtension = 
                    (PUSBCAMD_READ_EXTENSION) CONTAINING_RECORD(listEntry, 
                                             USBCAMD_READ_EXTENSION, 
                                             ListEntry);                        

                ASSERT_READ(readExtension);                            
                srb = readExtension->Srb;
#if DBG
                if ( StreamNumber != srb->StreamObject->StreamNumber ) {
                    USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_TransferComplete: Srb does not match streamnumber!\n"));
                    TEST_TRAP();
                }
#endif
                StreamNumber = srb->StreamObject->StreamNumber;

                ASSERT(NULL == deviceExtension->ChannelExtension[StreamNumber]->CurrentRequest);
                deviceExtension->ChannelExtension[StreamNumber]->CurrentRequest = readExtension;
                USBCAMD_KdPrint (MAX_TRACE, ("Stream # %d New Frame SRB = 0x%x \n", 
                                    StreamNumber , srb));
                
                //
                // use the data in the packet
                //

                readExtension->RawFrameOffset = 0;
                readExtension->NumberOfPackets = 0;
                readExtension->ActualRawFrameLength = 0;
                readExtension->DropFrame = FALSE;
                

                if ( deviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
#if DBG
                    if (StreamNumber == STREAM_Still) {
                        USBCAMD_KdPrint (MAX_TRACE, ("Call NewframeEx for this still frame (0x%x) \n",
                            readExtension->RawFrameLength));
                    }
#endif
                    readExtension->ActualRawFrameLen = readExtension->RawFrameLength;

                    (*deviceExtension->DeviceDataEx.DeviceData2.CamNewVideoFrameEx)
                        (USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                         USBCAMD_GET_FRAME_CONTEXT(readExtension),
                         StreamNumber,
                         &readExtension->ActualRawFrameLen);
                }
                else {
                    (*deviceExtension->DeviceDataEx.DeviceData.CamNewVideoFrame)
                        (USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                         USBCAMD_GET_FRAME_CONTEXT(readExtension));
                }

                if (receiveLength)  {

                    if (readExtension->RawFrameBuffer)  {

                        readExtension->NumberOfPackets = 1;     
                        readExtension->ActualRawFrameLength = receiveLength;

                        dst = readExtension->RawFrameBuffer +
                                   readExtension->RawFrameOffset + receiveLength;
                        end = readExtension->RawFrameBuffer + 
                                   readExtension->RawFrameLength;

                  
                        USBCAMD_KdPrint (ULTRA_TRACE, ("Raw buff = 0x%x SRB = 0x%x\n", 
                            readExtension->RawFrameBuffer,srb));
                        USBCAMD_KdPrint (ULTRA_TRACE, ("Raw Offset = 0x%x rec length = 0x%x\n", 
                            readExtension->RawFrameOffset,
                            receiveLength));

                        if (dst <= end) {   
#if DBG
                            if (TransferExtension->ChannelExtension->NoRawProcessingRequired) {
                                if (0 == readExtension->RawFrameOffset) {
                                    USBCAMD_DbgLog(TL_SRB_TRACE, '1ypC',
                                        srb,
                                        readExtension->RawFrameBuffer,
                                        0
                                        );
                                }
                            }
#endif
                            RtlCopyMemory(readExtension->RawFrameBuffer +
                                            readExtension->RawFrameOffset,
                                          TransferExtension->DataBuffer + 
                                            TransferExtension->DataUrb->UrbIsochronousTransfer.IsoPacket[i].Offset+
                                            TransferExtension->ValidDataOffset,receiveLength);
                                  
                            readExtension->RawFrameOffset += receiveLength;
                        }                            
                    }
                }
            }
#if DBG
            else {
                //
                // No irps are queued we'll have to miss
                // this frame
                //
                ASSERT(NULL == deviceExtension->ChannelExtension[StreamNumber]->CurrentRequest);

                //
                // No buffer was available when we should have captured one

                // Increment the counter which keeps track of
                // actual dropped frames

                TransferExtension->ChannelExtension->VideoFrameLostCount++;
            }
#endif
        } else {   

            PUCHAR dst, end;
            PUSBCAMD_READ_EXTENSION readExtension;
            PHW_STREAM_REQUEST_BLOCK srb;
            ULONG StreamNumber;

            //
            // video data is for current frame
            //
            if ( deviceExtension->ChannelExtension[STREAM_Still] && 
                 deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest ) {
                readExtension = deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest;
            }
            else if (deviceExtension->ChannelExtension[STREAM_Capture] && 
                 deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest ) {
                readExtension = deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest;
            }
            else {
                readExtension = NULL;
 //               TEST_TRAP();
            }

            
            if (receiveLength  && (readExtension != NULL )) {

                srb = readExtension->Srb;
                StreamNumber = srb->StreamObject->StreamNumber;

                //
                // No errors, if we have a video frame copy the data
                //

                if (readExtension->RawFrameBuffer) {
                
                    dst = readExtension->RawFrameBuffer + readExtension->RawFrameOffset + receiveLength;
                    end = readExtension->RawFrameBuffer + readExtension->RawFrameLength;
                           
                    USBCAMD_KdPrint (ULTRA_TRACE, ("Raw buff = 0x%x SRB = 0x%x\n",
                                     readExtension->RawFrameBuffer, srb));
                    USBCAMD_KdPrint (ULTRA_TRACE, ("Raw Offset = 0x%x rec length = 0x%x\n", 
                                     readExtension->RawFrameOffset,receiveLength));

                    //
                    // check for buffer overrun
                    // if the camera is using two pipes it is possible we
                    // will miss the sync info and keep on trying to 
                    // recieve data frame data into the raw buffer, if this
                    // happens we just throw the extra data away.
                    //
                    if (dst <= end) {   
                        readExtension->NumberOfPackets++;  
                        readExtension->ActualRawFrameLength += receiveLength;
#if DBG
                        if (TransferExtension->ChannelExtension->NoRawProcessingRequired) {
                            if (0 == readExtension->RawFrameOffset) {
                                USBCAMD_DbgLog(TL_SRB_TRACE, '2ypC',
                                    srb,
                                    readExtension->RawFrameBuffer,
                                    0
                                    );
                            }
                        }
#endif
                        RtlCopyMemory(readExtension->RawFrameBuffer + readExtension->RawFrameOffset,
                                      TransferExtension->DataBuffer + 
                                          TransferExtension->DataUrb->UrbIsochronousTransfer.IsoPacket[i].Offset+
                                            TransferExtension->ValidDataOffset,receiveLength);
                                  
                        readExtension->RawFrameOffset += receiveLength;
                    }
                }
            }
        }  /* process packet */
        
    } /* end for loop*/

    // release current request spinlock
    KeReleaseSpinLockFromDpcLevel(&TransferExtension->ChannelExtension->CurrentRequestSpinLock);

    //
    // re-submit this request
    //
    USBCAMD_SubmitIsoTransfer(deviceExtension,
                              TransferExtension,
                              0,
                              TRUE);

    return STATUS_SUCCESS;
}

#if DBG
VOID
USBCAMD_DebugStats(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension    
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    USBCAMD_KdPrint (MIN_TRACE, ("**ActualLostFrames %d\n", 
                        ChannelExtension->VideoFrameLostCount)); 
    USBCAMD_KdPrint (MIN_TRACE, ("**FrameCaptured %d\n", 
                        ChannelExtension->FrameCaptured));  
    USBCAMD_KdPrint (ULTRA_TRACE, ("**ErrorSyncPacketCount %d\n",
                        ChannelExtension->ErrorSyncPacketCount));                         
    USBCAMD_KdPrint (ULTRA_TRACE, ("**ErrorDataPacketCount %d\n", 
                        ChannelExtension->ErrorDataPacketCount));                         
    USBCAMD_KdPrint (ULTRA_TRACE, ("**IgnorePacketCount %d\n", 
                        ChannelExtension->IgnorePacketCount));                              
    USBCAMD_KdPrint (ULTRA_TRACE, ("**Sync Not Accessed Count %d\n", 
                        ChannelExtension->SyncNotAccessedCount));                                   
    USBCAMD_KdPrint (ULTRA_TRACE, ("**Data Not Accessed Count %d\n", 
                        ChannelExtension->DataNotAccessedCount));                                
}
#endif /* DBG */


VOID
USBCAMD_CompleteReadRequest(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_READ_EXTENSION ReadExtension,
    IN BOOLEAN CopyFrameToStillPin
    )
/*++

Routine Description:

    This routine completes the read for the camera

Arguments:

Return Value:

--*/    
{
    PUSBCAMD_DEVICE_EXTENSION deviceExtension = ChannelExtension->DeviceExtension;
    NTSTATUS Status;

#if DBG
    ReadExtension->CurrentLostFrames = ChannelExtension->VideoFrameLostCount;
#endif
    ReadExtension->ChannelExtension = ChannelExtension;
    ReadExtension->CopyFrameToStillPin = CopyFrameToStillPin;
    ReadExtension->StreamNumber = ChannelExtension->StreamNumber;

    // We need to synchronize the SRB completion with our stop and reset logic
    Status = USBCAMD_AcquireIdleLock(&ChannelExtension->IdleLock);
    if (STATUS_SUCCESS == Status) {

        // insert completed read SRB in the thread que.
        ExInterlockedInsertTailList( &deviceExtension->CompletedReadSrbList,
                                     &ReadExtension->ListEntry,
                                     &deviceExtension->DispatchSpinLock);
                                 
        // Increment the count of the que's semaphore.
        KeReleaseSemaphore(&deviceExtension->CompletedSrbListSemaphore,0,1,FALSE);
    }
    else {

        // The SRB is completed from this routine with STATUS_SUCCESS and a zero length buffer
        USBCAMD_CompleteRead(ChannelExtension, ReadExtension, STATUS_SUCCESS, 0);
    }
}

//
// code to handle packet processing outside the DPC routine
//

VOID
USBCAMD_ProcessIsoIrps(
    PVOID Context
    )
/*++

Routine Description:

    this thread Calls the mini driver to convert a raw packet to the proper format.
    and then completes the read SRB.

Arguments:

Return Value:

    None.

--*/
{
    ULONG maxLength;
    PVOID StillFrameBuffer;
    ULONG StillMaxLength;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension,StillChannelExtension;    
    PVOID frameBuffer;
    ULONG bytesTransferred;
    NTSTATUS status;
    PHW_STREAM_REQUEST_BLOCK srb;
    PKSSTREAM_HEADER dataPacket;
    PLIST_ENTRY listEntry;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    PUSBCAMD_READ_EXTENSION readExtension,StillReadExtension;
    
    deviceExtension = (PUSBCAMD_DEVICE_EXTENSION) Context;

    // set the thread priority
    KeSetPriorityThread(KeGetCurrentThread(),LOW_REALTIME_PRIORITY);

    // start the infinite loop of processing completed read SRBs.

    while (TRUE) {

        // wait for ever till a read SRB is completed and inserted
        // in the que by the iso transfer completion routine.
        KeWaitForSingleObject(&deviceExtension->CompletedSrbListSemaphore,
                              Executive,KernelMode,FALSE,NULL);
        // 
        // We are ready to go. chk if the stop flag is on.
        //
        if ( deviceExtension->StopIsoThread ) {
            // we have been signaled to terminate. flush the thread queue first.
            while ( listEntry = ExInterlockedRemoveHeadList( &deviceExtension->CompletedReadSrbList,
                                                             &deviceExtension->DispatchSpinLock) ) {
                readExtension = (PUSBCAMD_READ_EXTENSION) CONTAINING_RECORD(listEntry, 
                                                                            USBCAMD_READ_EXTENSION, 
                                                                            ListEntry);                                             
                ASSERT_READ(readExtension);
                channelExtension = readExtension->ChannelExtension;
                USBCAMD_CompleteRead(channelExtension, readExtension, STATUS_CANCELLED,0);

                USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
            }

            USBCAMD_KdPrint (MIN_TRACE, ("Iso thread is terminating.\n"));
            PsTerminateSystemThread(STATUS_SUCCESS);
        }

        // get the just completed read srb.
        listEntry = ExInterlockedRemoveHeadList( &deviceExtension->CompletedReadSrbList,
                                              &deviceExtension->DispatchSpinLock);
                                              
        if (listEntry == NULL ) {
            // something went wrong in here.
            USBCAMD_KdPrint (MIN_TRACE, ("No read SRB found!  Why were we triggered??\n"));
            TEST_TRAP();
            continue;
        }

        readExtension = (PUSBCAMD_READ_EXTENSION) CONTAINING_RECORD(listEntry,
                                                                USBCAMD_READ_EXTENSION, 
                                                                ListEntry);                        
        ASSERT_READ(readExtension);
        channelExtension = readExtension->ChannelExtension;
        srb = readExtension->Srb;   

        // before we pass this raw frame to Cam driver, we will clear the stream header options flag
        // and let the Cam driver set it appropriately if it needs to indicate anything other than 
        // key frames in there in case it process compressed data (ex. h.263, etc..). Otherwise, we 
        // set the default flag (key frames only) in USBCAMD_CompleteRead.

        dataPacket = srb->CommandData.DataBufferArray;
        dataPacket->OptionsFlags =0;    
        status  = STATUS_SUCCESS;
   
        frameBuffer = USBCAMD_GetFrameBufferFromSrb(srb,&maxLength);
        //
        // if we need to drop this frame. Just complete the SRB with zero len buffer.
        //
        if (readExtension->DropFrame ) {
            readExtension->DropFrame = FALSE;
            USBCAMD_CompleteRead(channelExtension,readExtension,STATUS_SUCCESS, 0); 
            USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
            continue;
        }

        StillReadExtension = NULL;

        // DSHOW buffer len returned will be equal raw frame len unless we 
        // process raw frame buffer in ring 0.
        bytesTransferred = readExtension->ActualRawFrameLength;

        // Ensure that the buffer size appears to be exactly what was requested
        ASSERT(maxLength >= channelExtension->VideoInfoHeader->bmiHeader.biSizeImage);
        maxLength = channelExtension->VideoInfoHeader->bmiHeader.biSizeImage;

        if (deviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
        
            // only call if the cam driver indicated so during initialization.
            if ( !channelExtension->NoRawProcessingRequired) {

                USBCAMD_DbgLog(TL_SRB_TRACE, '3ypC',
                    srb,
                    frameBuffer,
                    0
                    );

                USBCAMD_KdPrint (ULTRA_TRACE, ("Call Cam ProcessFrameEX, len= x%X ,SRB=%X S#%d \n",
                    bytesTransferred,srb,readExtension->StreamNumber));

                *(PULONG)frameBuffer = 0L;  // Hack Alert (detect dup frames for some minidrivers)

                status = 
                    (*deviceExtension->DeviceDataEx.DeviceData2.CamProcessRawVideoFrameEx)(
                        deviceExtension->StackDeviceObject,
                        USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                        USBCAMD_GET_FRAME_CONTEXT(readExtension),
                        frameBuffer,
                        maxLength,
                        readExtension->RawFrameBuffer,
                        readExtension->RawFrameLength,
                        readExtension->NumberOfPackets,
                        &bytesTransferred,
                        readExtension->ActualRawFrameLength,
                        readExtension->StreamNumber);

                if (NT_SUCCESS(status) && !*(PULONG)frameBuffer) {
                    bytesTransferred = 0;   // Hack Alert (minidriver didn't really copy)
                }
            }
        }
        else {

            USBCAMD_DbgLog(TL_SRB_TRACE, '3ypC',
                srb,
                frameBuffer,
                0
                );

            *(PULONG)frameBuffer = 0L;  // Hack Alert (detect dup frames for some minidrivers)

            status = 
                (*deviceExtension->DeviceDataEx.DeviceData.CamProcessRawVideoFrame)(
                    deviceExtension->StackDeviceObject,
                    USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                    USBCAMD_GET_FRAME_CONTEXT(readExtension),
                    frameBuffer,
                    maxLength,
                    readExtension->RawFrameBuffer,
                    readExtension->RawFrameLength,
                    readExtension->NumberOfPackets,             
                    &bytesTransferred);

            if (NT_SUCCESS(status) && !*(PULONG)frameBuffer) {
                bytesTransferred = 0;   // Hack Alert (minidriver didn't really copy)
            }
        }

        USBCAMD_KdPrint (ULTRA_TRACE, ("return from Cam ProcessRawframeEx : S# %d, len= x%X SRB=%X\n",
                                  srb->StreamObject->StreamNumber,bytesTransferred,
                                  srb));
    
        if (readExtension->CopyFrameToStillPin) {
        
            //
            // notify STI mon that a still button has been pressed.
            //
            if (deviceExtension->CamControlFlag & USBCAMD_CamControlFlag_EnableDeviceEvents) 
                USBCAMD_NotifyStiMonitor(deviceExtension);

            //
            // we need to copy the same frame to still pin buffer if any.
            //
        
            StillChannelExtension = deviceExtension->ChannelExtension[STREAM_Still];

            if ( StillChannelExtension && StillChannelExtension->ChannelPrepared && 
                StillChannelExtension->ImageCaptureStarted ) {

                listEntry = 
                    ExInterlockedRemoveHeadList( &(StillChannelExtension->PendingIoList),
                                             &StillChannelExtension->PendingIoListSpin);         
                if (listEntry != NULL) {
            
                    StillReadExtension = (PUSBCAMD_READ_EXTENSION) CONTAINING_RECORD(listEntry, 
                                                 USBCAMD_READ_EXTENSION, 
                                                 ListEntry); 
                    StillFrameBuffer = USBCAMD_GetFrameBufferFromSrb(StillReadExtension->Srb,
                                                                &StillMaxLength);
                    if ( StillMaxLength >= bytesTransferred ) {

                        USBCAMD_DbgLog(TL_SRB_TRACE, '4ypC',
                            StillReadExtension->Srb,
                            StillFrameBuffer,
                            0
                            );

                        // copy the video frame to still pin buffer.
                        RtlCopyMemory(StillFrameBuffer,frameBuffer,bytesTransferred);  
                    }
                    else {
                        USBCAMD_KdPrint (MIN_TRACE, ("Still Frame buffer is smaller than raw buffer.\n"));
                        // recycle read SRB.
                        ExInterlockedInsertHeadList( &(StillChannelExtension->PendingIoList),
                                                 &(StillReadExtension->ListEntry),
                                                 &StillChannelExtension->PendingIoListSpin);
                        StillReadExtension = NULL;                                                 
                    }
                } 
                else 
                    USBCAMD_KdPrint (MAX_TRACE, ("Still Frame Dropped \n"));
            }
        }

        // The number of bytes transfer of the read is set above just before
        // USBCAMD_CompleteReadRequest is called.

        USBCAMD_CompleteRead(channelExtension,readExtension,status,bytesTransferred); 
    
        if (StillReadExtension) {

            USBCAMD_KdPrint (MIN_TRACE, ("Still Frame Completed \n"));

            // we need to complete another read SRB on the still pin.
            USBCAMD_CompleteRead(StillChannelExtension,StillReadExtension, status, 
                                 bytesTransferred); 
        }

        USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\usbcamd\usbcamd\warn.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    warn.h

Abstract:



Environment:

    Kernel & user mode

Revision History:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

--*/

/*
4214
4201 nonstandard extension using nameless struct/union
4115
4200
4514 unreferenced inline function
**4100 unreferenced formal parameter
4057
*/

#pragma warning(disable:4214 4201 4115 4200 4100 4514 4057 4220)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\dvd\class\codcls.h ===
#define ENABLE_STREAM_CLASS_AS_ALLOCATOR
#define ENABLE_KS_METHODS
#define ENABLE_MULTIPLE_FILTER_TYPES 1	// enable/disable support for multiple
										// filters on a single hardware/driver.
//
// when the code for the method support is finally done, STRMINI.H will have
// to be checked into the tree also, in the include directory.
//

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    codcls.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the common CODEC class driver.

Author:
    Bill Parry (billpa)

Environment:

   Kernel mode only

Revision History:

--*/

#ifndef _STREAMCLASS_H
#define _STREAMCLASS_H

#include "messages.h"
#include "strmini.h"
#include <stdarg.h>

//
// I don't want to try to include cfgmgr32 just for this.
//
#ifndef MAX_DEVICE_ID_LEN
#define MAX_DEVICE_ID_LEN 200
#endif // MAX_DEVICE_ID_LEN

#ifndef _WIN64
// 4 byte alignment causes Alignment Fault for spinlock.
#pragma pack(4)
#endif

#if ENABLE_MULTIPLE_FILTER_TYPES
#define IF_MF( s ) s
#define IF_MFS( s ) { s }
#define IFN_MF( s )
#define IFN_MFS( s )
#define MFTRACE( s ) StreamClassDebugPrint s
#else
#define IF_MF( s ) 
#define IF_MFS( s )
#define IFN_MF( s ) s
#define IFN_MFS( s ) { s }
#define MFTRACE( s ) 
#endif 

#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
//
// this is a debug string header
//
#define STR_MODULENAME "STREAM.SYS:"
//
// define some data allocation tags
//
#define STREAMCLASS_TAG_STREAMHEADER      'pdCS'
#define STREAMCLASS_TAG_FILTERCONNECTION  '10CS'
#define STREAMCLASS_TAG_DATAFORMAT        '20CS'
#define ID_DATA_DESTINATION_PIN     0
#define ID_DATA_SOURCE_PIN          1
#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR

#define MAX_STRING_LENGTH 256

#define TRAP DEBUG_BREAKPOINT()

//
// the following macros are used to correctly synchronize class driver entry
// points called by the minidriver.
//

#define BEGIN_MINIDRIVER_STREAM_CALLIN(DeviceExtension, Irql) { \
    DeviceExtension->BeginMinidriverCallin(DeviceExtension, \
                                           Irql);  \
    ASSERT(++DeviceExtension->LowerApiThreads == 1);\
}                                                  

#define END_MINIDRIVER_STREAM_CALLIN(StreamObject, Irql) { \
    ASSERT(--DeviceExtension->LowerApiThreads == 0);\
    DeviceExtension->EndMinidriverStreamCallin(StreamObject, \
                                      Irql); \
}


#define BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, Irql) { \
    DeviceExtension->BeginMinidriverCallin(DeviceExtension, \
                                      Irql);  \
    ASSERT(++DeviceExtension->LowerApiThreads == 1);\
}

#define END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, Irql) { \
    ASSERT(--DeviceExtension->LowerApiThreads == 0);\
    DeviceExtension->EndMinidriverDeviceCallin(DeviceExtension, \
                                      Irql); \
}

//
// The following flags should not be cleared from the interrupt data structure
// by SCGetInterruptState.
//

#define STREAM_FLAGS_INTERRUPT_FLAG_MASK 0

//
// Device Extension flags follow - PASSIVE LEVEL ACCESS ONLY!!!!!!
//

//
// Indicates that the PNP start function has been received for the device.
//

#define DEVICE_FLAGS_PNP_STARTED               0x00001

//
// Indicates that this device is a child device (PDO)
//

#define DEVICE_FLAGS_CHILD                     0x0002

//
// indicates that the device has been removed
//

#define DEVICE_FLAGS_DEVICE_INACCESSIBLE   0x00100

//
// debug flag indicates that we've warned of too many low pri calls
//

#define DEVICE_FLAGS_PRI_WARN_GIVEN 0x00200

//
// flag indicates that we've received an NT style surprise remove call
//

#define DEVICE_FLAGS_SURPRISE_REMOVE_RECEIVED 0x00400

//
// flag indicated that a Child device ( PDO ) has received a remove
//

#define DEVICE_FLAGS_CHILD_MARK_DELETE 0x00800

//
// flag indicates (FDO) has enum children from registry
//

#define DEVICE_FLAGS_CHILDREN_ENUMED 0x01000

//
// device registry flags follow
//

//
// page out the driver when not opened
//

#define DEVICE_REG_FL_PAGE_CLOSED 0x00000001

//
// page out the driver when opened but idle
//

#define DEVICE_REG_FL_PAGE_IDLE 0x00000002

//
// power down the device when not opened
//

#define DEVICE_REG_FL_POWER_DOWN_CLOSED 0x00000004

//
// don't suspend if any pins are running
//

#define DEVICE_REG_FL_NO_SUSPEND_IF_RUNNING 0x00000008

//
// This driver uses SWEnum to load, which means it is a kernel mode
// streaming driver that has no hardware associated with it. We need to
// AddRef/DeRef this driver special.
//

#define DRIVER_USES_SWENUM_TO_LOAD 0x00000010

//
// This flag indicates that the dirver is OK for system power to go to
// hibernation, even the driver does not process/support the irp_mn_query_power
// for system power hinbernation.
//

#define DEVICE_REG_FL_OK_TO_HIBERNATE 0x00000020

//
// The following flags should not be cleared from the interrupt data structure
// by SCGetInterruptState.
//

#define DEVICE_FLAGS_INTERRUPT_FLAG_MASK        0


//
// Interrupt flags follow.
//
//
// Indicates that StreamClassCompletionDpc needs to be run.  This is set when
// A minidriver makes a request which must be done at DPC and is cleared when
// when the request information is gotten by MpGetInterruptState.
//

#define INTERRUPT_FLAGS_NOTIFICATION_REQUIRED     0x00001

//
// Indicates the minidriver is wants a timer request.  Set by
// StreamClassNotification and cleared by MpGetInterruptState.  This flag is
// stored in the interrupt data structure. The timer request parameters are
// stored in the interrupt data structure.
//

#define INTERRUPT_FLAGS_TIMER_CALL_REQUEST        0x00002

//
// Indicates the minidriver is wants a priority change.  Set by
// StreamClassRequestNewPriority and cleared by SCGetInterruptState.  This flag
// is stored in the interrupt data structure. The timer request parameters are
// stored in the interrupt data structure.
//

#define INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST   0x00004

//
// Indicates that the PNP stop function has been received for the device.
//

#define INTERRUPT_FLAGS_LOG_ERROR                 0x00008

//
// Indicates that the clock is beinq queried.
//

#define INTERRUPT_FLAGS_CLOCK_QUERY_REQUEST       0x00010

//
// Indicates that the streams need to be rescanned.
//

#define INTERRUPT_FLAGS_NEED_STREAM_RESCAN       0x00020

//
// Pointer to the synchronize execution routine.
//

typedef
BOOLEAN
(__stdcall * PSYNCHRONIZE_ROUTINE) (
	IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext);

//
// Pointer to the begin minidriver callin routine.
//

typedef         VOID
                (__stdcall * PBEGIN_CALLIN_ROUTINE) (
                              IN struct _DEVICE_EXTENSION * DeviceExtension,
                                                              IN PKIRQL Irql
);

//
// Pointer to the end minidriver callin routine.
//

typedef
                VOID
                (__stdcall * PEND_DEVICE_CALLIN_ROUTINE) (
                              IN struct _DEVICE_EXTENSION * DeviceExtension,
                                                              IN PKIRQL Irql
);

typedef
                VOID
                (__stdcall * PEND_STREAM_CALLIN_ROUTINE) (
                                    IN struct _STREAM_OBJECT * StreamObject,
                                                              IN PKIRQL Irql
);

//
// Queue link for mapped addresses stored for unmapping.
//

typedef struct _MAPPED_ADDRESS {
    struct _MAPPED_ADDRESS *NextMappedAddress;
    PVOID           MappedAddress;
    ULONG           NumberOfBytes;
    LARGE_INTEGER   IoAddress;
    ULONG           BusNumber;
}               MAPPED_ADDRESS, *PMAPPED_ADDRESS;

//
// error log entry definition
//

typedef struct _ERROR_LOG_ENTRY {
    NTSTATUS        ErrorCode;  // error code
    ULONG           SequenceNumber; // request sequence number
    ULONG           UniqueId;   // uniqe ID for the error
}               ERROR_LOG_ENTRY, *PERROR_LOG_ENTRY;

//
// callback procedure definition
//

typedef         NTSTATUS
                (*PSTREAM_CALLBACK_PROCEDURE) (
                                                               IN PVOID SRB
);

typedef         VOID
                (*PSTREAM_ASYNC_CALLBACK_PROCEDURE) (
                                                               IN  struct _STREAM_REQUEST_BLOCK *SRB
);

//
// STREAM request block
//

typedef struct _STREAM_REQUEST_BLOCK {
    HW_STREAM_REQUEST_BLOCK HwSRB;
    ULONG           Flags;
    ULONG           SequenceNumber;
    ULONG           ExtensionLength;
    PMDL            Mdl;
    PVOID           MapRegisterBase;
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG           Length;
    PSTREAM_ASYNC_CALLBACK_PROCEDURE Callback;
    LIST_ENTRY      SRBListEntry;
    KEVENT          Event;
    ULONG           StreamHeaderSize;
    BOOLEAN         DoNotCallBack;
    KEVENT          DmaEvent;
    BOOLEAN         bMemPtrValid;
    PVOID           *pMemPtrArray;
}               STREAM_REQUEST_BLOCK, *PSTREAM_REQUEST_BLOCK;

//
// SRB flags (not to be confused with the HW SRB flags)
//

#define SRB_FLAGS_IS_ACTIVE 0x00000001

//
// define the minidriver information structure
//

typedef struct _MINIDRIVER_INFORMATION {
    HW_INITIALIZATION_DATA HwInitData;
    ULONG           Flags;
    KEVENT          ControlEvent;
    ULONG           UseCount;
    ULONG           OpenCount;
} MINIDRIVER_INFORMATION, *PMINIDRIVER_INFORMATION;

//
// flags for minidriver information Flags field above
//

//
// indicates that the driver may not be paged out
//

#define DRIVER_FLAGS_NO_PAGEOUT 0x01

//
// indicates that the driver has been paged out
//

#define DRIVER_FLAGS_PAGED_OUT 0x02

//
// pin info not contained in the pin description
//

typedef struct _ADDITIONAL_PIN_INFO {

    ULONG           CurrentInstances;
    ULONG           MaxInstances;

    // NextFileObject must be per instance, i.e. can't be here. 
    // Move to streamobject
	#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
    //PFILE_OBJECT    NextFileObject;         // The chained file object
	#endif
	ULONG           Reserved;
} ADDITIONAL_PIN_INFO, *PADDITIONAL_PIN_INFO;

//
// Define data storage for access at interrupt Irql.
//

typedef struct _INTERRUPT_DATA {

    //
    // interrupt flags
    //

    ULONG           Flags;

    ERROR_LOG_ENTRY LogEntry;

    //
    // List head for singlely linked list of complete IRPs.
    //

    PHW_STREAM_REQUEST_BLOCK CompletedSRB;

    //
    // Minidriver timer request routine.
    //

    PHW_TIMER_ROUTINE HwTimerRoutine;

    //
    // Mindriver timer request time in micro seconds.
    //

    ULONG           HwTimerValue;

    PVOID           HwTimerContext;

    //
    // Mindriver priority change routine.
    //

    PHW_PRIORITY_ROUTINE HwPriorityRoutine;

    //
    // Mindriver priority change level.
    //

    STREAM_PRIORITY HwPriorityLevel;
    PVOID           HwPriorityContext;

    PHW_QUERY_CLOCK_ROUTINE HwQueryClockRoutine;
    TIME_FUNCTION   HwQueryClockFunction;


}               INTERRUPT_DATA, *PINTERRUPT_DATA;

//
// object common to both stream and filter instances
//

typedef struct _COMMON_OBJECT {
    PVOID DeviceHeader;
    ULONG Cookie;
#ifdef _WIN64
    ULONG Alignment;
#endif // _WIN64
    INTERRUPT_DATA  InterruptData;
    PHW_TIMER_ROUTINE HwTimerRoutine;   // Timer request routine
    PVOID           HwTimerContext;
    KTIMER          MiniDriverTimer;    // Miniclass timer object.
    KDPC            MiniDriverTimerDpc; // Miniclass DPC for timer object.
    WORK_QUEUE_ITEM WorkItem;
	#if DBG
    BOOLEAN         PriorityWorkItemScheduled;
	#endif    
}               COMMON_OBJECT, *PCOMMON_OBJECT;

//
// stream name info
//

typedef struct _STREAM_OPEN_INFORMATION {
    WCHAR           Guid[11];
    ULONG           Instance;
}               STREAM_OPEN_INFORMATION, *PSTREAM_OPEN_INFORMATION;

//
// clock instance structure
//

typedef struct _CLOCK_INSTANCE {

    PVOID DeviceHeader;
    PFILE_OBJECT    ParentFileObject;
    //PFILE_OBJECT    ClockFileObject; johnlee
    struct _STREAM_OBJECT *StreamObject;
}               CLOCK_INSTANCE, *PCLOCK_INSTANCE;

//
// master clock info structure
//

typedef struct _MASTER_CLOCK_INFO {

    PFILE_OBJECT    ClockFileObject;
    KSCLOCK_FUNCTIONTABLE FunctionTable;
} MASTER_CLOCK_INFO, *PMASTER_CLOCK_INFO;


#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
typedef enum {
    PinStopped,
    PinStopPending,
    PinPrepared,
    PinRunning
} PIN_STATE;

typedef enum {
    IrpSource,
    IrpSink,
} PIN_TYPE;

#define READ  0
#define WRITE 1
typedef struct _QUEUE {
    KSPIN_LOCK      QueueLock;
    LIST_ENTRY      ActiveQueue;
    WORK_QUEUE_ITEM     WorkItem;
    BOOL                WorkItemQueued;
    } QUEUE, PQUEUE;

#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR

//
// TODO: WORKITEM: remove this once KS can multiplex cleanup calls.
//
#define STREAM_OBJECT_COOKIE 0xd73afe3f
typedef struct _COOKIE_CHECK {
    
    PVOID Header;
    ULONG PossibleCookie;

} COOKIE_CHECK, *PCOOKIE_CHECK;

//
// stream object definition
//


typedef struct _STREAM_OBJECT {
    COMMON_OBJECT   ComObj;
    PFILE_OBJECT    FilterFileObject;
    PFILE_OBJECT    FileObject;
    struct _FILTER_INSTANCE *FilterInstance;
    HW_STREAM_OBJECT HwStreamObject;
    LIST_ENTRY      DataPendingQueue;
    LIST_ENTRY      ControlPendingQueue;
    LIST_ENTRY      OutstandingQueue;
    LIST_ENTRY      NextStream;
    LIST_ENTRY      NotifyList;
    struct _DEVICE_EXTENSION *DeviceExtension;
    struct _STREAM_OBJECT *NextNeedyStream;
    PKSPROPERTY_SET PropertyInfo;
    ULONG           PropInfoSize;
    PKSEVENT_SET EventInfo;
    ULONG           EventInfoCount;
    KEVENT          ControlSetMasterClock; // to serialize SetMasterClock
    KSPIN_LOCK      LockUseMasterClock;    // control use of MasterClockInfo
    PMASTER_CLOCK_INFO MasterClockInfo;
    PCLOCK_INSTANCE ClockInstance;
    PKSPROPERTY_SET ConstructedPropertyInfo;
    ULONG           ConstructedPropInfoSize;
    KSSTATE         CurrentState;
    BOOLEAN         ReadyForNextControlReq;
    BOOLEAN         ReadyForNextDataReq;
    BOOLEAN         OnNeedyQueue;
    BOOLEAN         InFlush;
    
	#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR

    PIN_STATE       PinState;
    PIN_TYPE        PinType;            // IrpSource or IrpSink
    PFILE_OBJECT    AllocatorFileObject;
    PFILE_OBJECT    NextFileObject;
    LIST_ENTRY      FreeQueue;
    KSPIN_LOCK      FreeQueueLock;
    KEVENT              StopEvent;
    PKSDATAFORMAT       DataFormat;
    ULONG               PinId;
    HANDLE              PinToHandle;
    KSALLOCATOR_FRAMING Framing;
    BOOL                EndOfStream;
    QUEUE               Queues[2];

	#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR

	#ifdef ENABLE_KS_METHODS
    PKSMETHOD_SET   MethodInfo;
    ULONG           MethodInfoSize;
	#endif

    BOOLEAN         StandardTransport;
    
    //
    // This keeps track of the number of frames in circulation between the
    // output and the downstream input.  It is a total count of those frames
    // queued to EITHER pin or in a pending list OTHER THAN THE FREE LIST
    // on the output pin.
    //
    LONG            QueuedFramesPlusOne;

} STREAM_OBJECT, *PSTREAM_OBJECT;

#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
//
// NOTE!  This is the minimal structure size for STREAM_HEADER_EX.
// The connected pins are queried for the actual header size (including
// whatever extended header size is required).
//

typedef struct _STREAM_HEADER_EX *PSTREAM_HEADER_EX;
typedef struct _STREAM_HEADER_EX {
    ULONG               WhichQueue;
    ULONG               Id;
    IO_STATUS_BLOCK     IoStatus;
    KEVENT              CompletionEvent;
    LIST_ENTRY          ListEntry;
    ULONG               ReferenceCount;
    PFILE_OBJECT        OwnerFileObject;
    PFILE_OBJECT        NextFileObject;     // next one to stream to.
    
	#if (DBG)
    PVOID               Data;
    ULONG               OnFreeList;
    ULONG               OnActiveList;
	#else
    ULONG               Reserved;
	#endif
	
    KSSTREAM_HEADER     Header;

} STREAM_HEADER_EX, *PSTREAM_HEADER_EX;
#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR
 
//
// struct for retrieving the interrupt data
//

typedef struct _INTERRUPT_CONTEXT {
    PSTREAM_OBJECT  NeedyStream;
    struct _DEVICE_EXTENSION *DeviceExtension;
    PINTERRUPT_DATA SavedStreamInterruptData;
    PINTERRUPT_DATA SavedDeviceInterruptData;
} INTERRUPT_CONTEXT, *PINTERRUPT_CONTEXT;

//
// Performance improvement chance - array for stream prop & event pointers
//

typedef struct _STREAM_ADDITIONAL_INFO {
   PKSPROPERTY_SET StreamPropertiesArray;
   PKSEVENT_SET StreamEventsArray;
} STREAM_ADDITIONAL_INFO, *PSTREAM_ADDITIONAL_INFO;

//
// filter instance structure
// (right now, this is global across all same filter creates!)
//

#if ENABLE_MULTIPLE_FILTER_TYPES

//
// for forward reference in FILTER_INSTANCE
//
typedef struct _DEVICE_EXTENSION;

//
// I claim that as it currently stands, 5/17/99 "No multiple instance
// mini driver works" because the bug in stream.sys. Therefore, backward
// compatibility is only a concern for single instance mini drivers.
//
// The reason is the implemention following:
//   FilterDispatchGlobalCreate()
//   {
//		...
//		if (!DeviceExtension->GlobalFilterInstance) {
//			
//
//			Status = SCOpenMinidriverInstance(DeviceExtension,
//                                  &FilterInstance,
//                                  SCGlobalInstanceCallback,
//                                  Irp);
//			...
//	        if (NT_SUCCESS(Status)) {
//				...
//			    DeviceExtension->GlobalFilterInstance = FilterInstance;
//				...
//			}
//		}
//		else { // will not call mini drivers
//		}
//	  }
//
//  At the 2nd call, the FilterInstance will point to the same 1st one.
//  
// We are braching out code here to support Multiple Filters without
// disturbing the exisitng support to max the backward compatibilty.
// The multiple filter support include 1 type n instances,
// and m types p instances.
//
// MinidriverData->HwInitData.
// 1 x 1	FilterInstanceExtensionSize =0 NumNameExtension	=0
// 1 x n	FilterInstanceExtensionSize!=0 NumNameExtension =0
// m x p	FilterInstanceExtensionSize!=0 NumNameExtension!=0 
//

typedef struct _FILTER_TYPE_INFORMATION {
    UNICODE_STRING          *SymbolicLinks;
    ULONG                   LinkNameCount;
    PHW_STREAM_DESCRIPTOR   StreamDescriptor;
    ULONG                   Reserved;
} FILTER_TYPE_INFO;

typedef FILTER_TYPE_INFO *PFILTER_TYPE_INFO;

#endif

typedef struct _DEVICE_EXTENSION;

typedef struct _FILTER_INSTANCE {
    PVOID           DeviceHeader;
    PDEVICE_OBJECT  DeviceObject;
    LIST_ENTRY      NextFilterInstance; // internal linked list of filter I's.
    LIST_ENTRY      FirstStream;
    PVOID           HwInstanceExtension;	
    PADDITIONAL_PIN_INFO PinInstanceInfo;   // pointer to array of pins
                                            // allocated directly below this
                                            // structure.
	#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
	//
	// Feature work: add per filter filter type when data splitting is enabled!
	//
    PKSWORKER           WorkerRead;         
    PKSWORKER           WorkerWrite;        

	#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR

	#ifdef ENABLE_KS_METHODS
	IF_MF(	
	 	PKSMETHOD_SET DeviceMethodsArray;	// from pDevExt
	)
	#endif

	#define SIGN_FILTER_INSTANCE 'FrtS' //StrF
	#if ENABLE_MULTIPLE_FILTER_TYPES
	#define ASSERT_FILTER_INSTANCE(FI) ASSERT((FI)->Signature==SIGN_FILTER_INSTANCE)
	#else
	#define ASSERT_FILTER_INSTANCE(FI)
	#endif
	
	IF_MF( 
	    ULONG   Signature;
	    PKSPIN_DESCRIPTOR PinInformation; 	// moved from pDevExt
  		//ULONG           PinInformationSize;	// from pDevExt,not used
	    ULONG           NumberOfPins;		    // from pDevExt
	    PKSEVENT_SET 	EventInfo;				// from pDevExt
    	ULONG           EventInfoCount;			// from pDevExt
		LIST_ENTRY		NotifyList;				// from pDevExt
		PHW_EVENT_ROUTINE HwEventRoutine;		// from pDevExt
	    PKSPROPERTY_SET DevicePropertiesArray;	// from pDevExt
	    PSTREAM_ADDITIONAL_INFO StreamPropEventArray; // ditto
	    ULONG           Reenumerated;           // if 1, StreamDescriptor is newly alloc
	                                            // need to be freed. Else, it points into
	                                            // the global one which belong to DevExt.
	    ULONG           NeedReenumeration;      // requesting reenumeration
	    ULONG           StreamDescriptorSize;   // the new size for streamdescriptor;
	    struct _DEVICE_EXTENSION *DeviceExtension;
   	    PHW_STREAM_DESCRIPTOR StreamDescriptor;
	    ULONG		 	FilterTypeIndex;
	    //
	    // Performance improvement chance. Per filterinstance ControlEvent etc might be
	    // better.For now, let them share ones in DeviceExtension
	    //
		//KEVENT          ControlEvent
		//PHW_TIMER_ROUTINE HwTimerRoutine;   // Timer request routine
	    //PVOID           HwTimerContext;
	    //KTIMER          MiniDriverTimer;    // Miniclass timer object.
	    //KDPC            MiniDriverTimerDpc; // Miniclass DPC for timer object.
	    //WORK_QUEUE_ITEM WorkItem;
	) // IF_MF
	
} FILTER_INSTANCE, *PFILTER_INSTANCE;

//
// Per Device data
//

typedef struct _DEVICE_EXTENSION {
    COMMON_OBJECT   ComObj;
    ULONG           Flags;                  // per device flags (PD_xx)
    PDEVICE_OBJECT  DeviceObject;           // device object
    PDEVICE_OBJECT  AttachedPdo;            // device object returned from the attach
    ULONG           RegistryFlags;          // registry flags
    // callback routine on DMA allocate
    // callback function for
    // KeSynch execution

    PKINTERRUPT     InterruptObject;        // Interrupt object and routine
    PKSERVICE_ROUTINE InterruptRoutine;
    PADAPTER_OBJECT DmaAdapterObject;       // Dma Adapter information.
    ULONG           NumberOfMapRegisters;   // max. number of map registers
    // for
    // device
    PVOID           MapRegisterBase;
    PMINIDRIVER_INFORMATION MinidriverData; // pointer to minidriver data
    PDEVICE_OBJECT  PhysicalDeviceObject;   // pointer to PDO for adapter
    PVOID           HwDeviceExtension;      // minidriver's device extension
    PPORT_CONFIGURATION_INFORMATION ConfigurationInformation;
    // configuration info for adapter
    PMAPPED_ADDRESS MappedAddressList;      // address map list head

    //
    // Routine to call to synchronize execution for the minidriver.
    //

    PSYNCHRONIZE_ROUTINE SynchronizeExecution;

    KSPIN_LOCK      SpinLock;

    ULONG           SequenceNumber;         // offset 0x30

    ULONG           DmaBufferLength;
    PHYSICAL_ADDRESS DmaBufferPhysical;
    PVOID           DmaBuffer;

    LIST_ENTRY      PendingQueue;
    LIST_ENTRY      OutstandingQueue;
    KDPC            WorkDpc;

    IFN_MF(
    	//
    	// Move to FilterInstance for IF_MF
    	//
    	PKSPIN_DESCRIPTOR PinInformation;
    	ULONG           PinInformationSize;
    	ULONG           NumberOfPins;
    )

    #define SIGN_DEVICE_EXTENSION 'DrtS' //StrD
    #if ENABLE_MULTIPLE_FILTER_TYPES
    #define ASSERT_DEVICE_EXTENSION(DE) ASSERT((DE)->Signature==SIGN_DEVICE_EXTENSION)
    #else
    #define ASSERT_DEVICE_EXTENSION(DE)
    #endif

    ULONG           Signature2;
    LIST_ENTRY      FilterInstanceList;
    ULONG           NumberOfOpenInstances;
    
    IFN_MF(
    	//
    	// Don't need for IF_MF
    	//
    	PFILTER_INSTANCE GlobalFilterInstance;
	    ULONG           NumberOfGlobalInstances;
	)
	
    struct _STREAM_OBJECT *NeedyStream;
   	PHW_STREAM_DESCRIPTOR StreamDescriptor;    
	KEVENT          ControlEvent;
    KEVENT          RemoveEvent;
    BOOLEAN         NoSync;
    PMINIDRIVER_INFORMATION DriverInfo;
    PBEGIN_CALLIN_ROUTINE BeginMinidriverCallin;
    PEND_STREAM_CALLIN_ROUTINE EndMinidriverStreamCallin;
    PEND_DEVICE_CALLIN_ROUTINE EndMinidriverDeviceCallin;
    LONG            OneBasedIoCount;
    UNICODE_STRING    *SymbolicLinks;
    DEVICE_POWER_STATE DeviceState[PowerSystemMaximum];
    DEVICE_POWER_STATE CurrentPowerState;
    LIST_ENTRY Children;
    LIST_ENTRY DeadEventList;
    WORK_QUEUE_ITEM EventWorkItem;
    WORK_QUEUE_ITEM RescanWorkItem;
    WORK_QUEUE_ITEM PowerCompletionWorkItem; // this is used for S Irp, S and D Irps dont exclude between.
    WORK_QUEUE_ITEM DevIrpCompletionWorkItem; // this is for D Irp as opposed to S Irp which uses above
    BOOLEAN ReadyForNextReq;
    BOOLEAN DeadEventItemQueued;

   	IFN_MF( 
		//
		// move to FilterInstace for MF
		// 
    	PKSEVENT_SET 	EventInfo;
    	ULONG           EventInfoCount;
    	LIST_ENTRY      NotifyList;
	    PHW_EVENT_ROUTINE HwEventRoutine;
	    PKSPROPERTY_SET DevicePropertiesArray;
	    PSTREAM_ADDITIONAL_INFO StreamPropEventArray;
	)

	#ifdef ENABLE_KS_METHODS
	IFN_MF(
		//
		// move to FilterInstance for MF
	 	PKSMETHOD_SET DeviceMethodsArray;
	)
	#endif

	IF_MF(
	    ULONG       NumberOfNameExtensions;
	    ULONG       NumberOfFilterTypes;
	    PKSOBJECT_CREATE_ITEM CreateItems;
	    PFILTER_TYPE_INFO FilterTypeInfos;
	    ULONG       Signature;
        ULONG       FilterExtensionSize;	    
	)

	#if DBG
    ULONG LowerApiThreads;
    ULONG NumberOfRequests;
    ULONG NumberOfLowPriCalls;
	#endif

    LIST_ENTRY PendedIrps;
    KSPIN_LOCK PendedIrpsLock;
    KSPIN_LOCK PowerLock;
    SYSTEM_POWER_STATE CurrentSystemState;
    KEVENT BlockPoweredDownEvent;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// debug work item trap structure
//

#if DBG

typedef struct _DEBUG_WORK_ITEM {
    PCOMMON_OBJECT Object;
    PHW_PRIORITY_ROUTINE    HwPriorityRoutine;
    PVOID           HwPriorityContext;
} DEBUG_WORK_ITEM, *PDEBUG_WORK_ITEM;
    
#endif

//
// registry entry structure
//

typedef struct _STREAM_REGISTRY_ENTRY {
    PWCHAR          String;
    ULONG           StringLength;
    ULONG           Flags;
}               STREAM_REGISTRY_ENTRY, *PSTREAM_REGISTRY_ENTRY;

//
// power context structure
//

typedef struct _POWER_CONTEXT {
    KEVENT   Event;
    NTSTATUS Status;
}               POWER_CONTEXT, *PPOWER_CONTEXT;


//
// child device extension
//

typedef struct _CHILD_DEVICE_EXTENSION {
    COMMON_OBJECT   ComObj;
    ULONG           Flags;      // per device flags (PD_xx)
    PDEVICE_OBJECT ChildDeviceObject;
    PDEVICE_OBJECT ParentDeviceObject;
    LIST_ENTRY ChildExtensionList;
    PWCHAR   DeviceName;
    ULONG DeviceIndex;
}               CHILD_DEVICE_EXTENSION, *PCHILD_DEVICE_EXTENSION;

//
// Function declarations
//

NTSTATUS
StreamClassOpen(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
);

NTSTATUS
StreamClassClose(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
);

NTSTATUS
StreamClassDeviceControl(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp
);

NTSTATUS
StreamClassNull(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
);

VOID
StreamClassDpc(
               IN PKDPC Dpc,
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp,
               IN PVOID Context
);

BOOLEAN
StreamClassInterrupt(
                     IN PKINTERRUPT InterruptObject,
                     IN PDEVICE_OBJECT DeviceObject
);

NTSTATUS
StreamClassShutDown(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
);

BOOLEAN
SCGetInterruptState(
                    IN PVOID ServiceContext
);

VOID
SCMinidriverDeviceTimerDpc(
                           IN struct _KDPC * Dpc,
                           IN PVOID DeviceObject,
                           IN PVOID SystemArgument1,
                           IN PVOID SystemArgument2
);



VOID
SCMinidriverStreamTimerDpc(
                           IN struct _KDPC * Dpc,
                           IN PVOID Context,
                           IN PVOID SystemArgument1,
                           IN PVOID SystemArgument2
);


PSTREAM_REQUEST_BLOCK
SCBuildRequestPacket(
                     IN PDEVICE_EXTENSION DeviceExtension,
                     IN PIRP Irp,
                     IN ULONG AdditionalSize1,
                     IN ULONG AdditionalSize2
);

BOOLEAN
SCSynchronizeExecution(
                       IN PKINTERRUPT Interrupt,
                       IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
                       IN PVOID SynchronizeContext
);

VOID
SCLogError(
           IN PDEVICE_OBJECT DeviceObject,
           IN ULONG SequenceNumber,
           IN NTSTATUS ErrorCode,
           IN ULONG UniqueId
);

VOID
SCLogErrorWithString(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN OPTIONAL PDEVICE_EXTENSION DeviceExtension,
                     IN NTSTATUS ErrorCode,
                     IN ULONG UniqueId,
                     IN PUNICODE_STRING String1
);

VOID
SCMinidriverTimerDpc(
                     IN struct _KDPC * Dpc,
                     IN PVOID Context,
                     IN PVOID SystemArgument1,
                     IN PVOID SystemArgument2
);

BOOLEAN
SCSetUpForDMA(
              IN PDEVICE_OBJECT DeviceObject,
              IN PSTREAM_REQUEST_BLOCK Request
);

IO_ALLOCATION_ACTION
StreamClassDmaCallback(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp,
                       IN PVOID MapRegisterBase,
                       IN PVOID Context
);

VOID
SCStartMinidriverRequest(
                         IN PSTREAM_OBJECT StreamObject,
                         IN PSTREAM_REQUEST_BLOCK Request,
                         IN PVOID EntryPoint
);

NTSTATUS
SCProcessCompletedRequest(
                          IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
StreamClassUninitializeMinidriver(
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN PIRP Irp);

NTSTATUS
StreamClassVideoRegister(
                         IN PVOID Argument1,
                         IN PVOID Argument2,
                         IN PHW_INITIALIZATION_DATA HwInitializationData
);

NTSTATUS
StreamClassCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

void
SCSetCurrentDPowerState (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN DEVICE_POWER_STATE PowerState
    );

void
SCSetCurrentSPowerState (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN SYSTEM_POWER_STATE PowerState
    );

void
SCRedispatchPendedIrps (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN FailRequests
    );

NTSTATUS
StreamClassPassThroughIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
StreamClassPnP(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
StreamClassPower(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
StreamClassPnPAddDevice(
                        IN PDRIVER_OBJECT DriverObject,
                        IN PDEVICE_OBJECT PhysicalDeviceObject
);

VOID
SCFreeAllResources(
                   IN PDEVICE_EXTENSION DeviceExtension
);

VOID
StreamClassUnload(
                  IN PDRIVER_OBJECT DriverObject
);



BOOLEAN
StreamClassSynchronizeExecution(
                                IN PKINTERRUPT Interrupt,
                                IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
                                IN PVOID SynchronizeContext
);

VOID
StreamClassDebugPrint(
                      STREAM_DEBUG_LEVEL DebugPrintLevel,
                      PSCHAR DebugMessage,
                      ...
);

NTSTATUS
SCCompleteIrp(
              IN PIRP Irp,
              IN NTSTATUS Status,
              IN PDEVICE_EXTENSION DeviceExtension
);


NTSTATUS
SCUninitializeMinidriver(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp);


BOOLEAN
SCDummyMinidriverRoutine(
                         IN PVOID Context
);

NTSTATUS
SCStreamInfoCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
FilterDispatchGlobalCreate(
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PIRP Irp
);

NTSTATUS
StreamDispatchCreate(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
);

NTSTATUS
FilterDispatchIoControl(
                        IN PDEVICE_OBJECT DeviceObject,
                        IN PIRP Irp
);

NTSTATUS
FilterDispatchClose
(
 IN PDEVICE_OBJECT pdo,
 IN PIRP pIrp
);

NTSTATUS
SCStreamDeviceState
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSSTATE DeviceState
);

NTSTATUS
StreamDispatchIoControl
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
);


NTSTATUS        StreamDispatchRead
                (
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PIRP Irp
);

NTSTATUS        StreamDispatchWrite
                (
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PIRP Irp
);

NTSTATUS
SCLocalInstanceCallback(
                        IN PSTREAM_REQUEST_BLOCK SRB
);

IFN_MF(
NTSTATUS
SCGlobalInstanceCallback(
                         IN PSTREAM_REQUEST_BLOCK SRB
);
)

NTSTATUS
SCOpenStreamCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

VOID
SCRequestDpcForStream(
                      IN PSTREAM_OBJECT StreamObject

);

NTSTATUS
SCSubmitRequest(
                IN SRB_COMMAND Command,
                IN PVOID Buffer,
                IN ULONG BufferLength,
                IN PSTREAM_CALLBACK_PROCEDURE Callback,
                IN PDEVICE_EXTENSION DeviceExtension,
                IN PVOID InstanceExtension,
                IN PHW_STREAM_OBJECT HwStreamObject,
                IN PIRP Irp,
                OUT PBOOLEAN RequestIssued,
                IN PLIST_ENTRY Queue,
                IN PVOID MinidriverRoutine
);

NTSTATUS
SCCloseInstanceCallback(
                        IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCFilterPinInstances(
                     IN PIRP Irp,
                     IN PKSPROPERTY Property,
                     IN OUT PVOID Data);

NTSTATUS
SCFilterPinDataRouting(
                       IN PIRP Irp,
                       IN PKSPROPERTY Property,
                       IN OUT PVOID Data);

NTSTATUS
SCFilterPinDataIntersection(
                            IN PIRP Irp,
                            IN PKSPROPERTY Property,
                            IN OUT PVOID Data);

NTSTATUS
SCFilterPinPropertyHandler(
                           IN PIRP Irp,
                           IN PKSPROPERTY Property,
                           IN OUT PVOID Data);

NTSTATUS
SCFilterProvider(
                 IN PIRP Irp,
                 IN PKSPROPERTY Property,
                 IN OUT PVOID Data);


NTSTATUS
StreamDispatchClose
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
);

NTSTATUS
StreamDispatchCleanup 
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
);

NTSTATUS
SCCloseStreamCallback(
                      IN PSTREAM_REQUEST_BLOCK SRB
);


BOOLEAN
SCProcessPioDataBuffers(
                       IN PKSSTREAM_HEADER FirstHeader,
                       IN ULONG NumberOfHeaders,
                       IN PSTREAM_OBJECT StreamObject,
                       IN PMDL FirstMdl,
                       IN ULONG StreamHeaderSize,
                       IN PVOID *pMemPtrArray,
                       IN BOOLEAN Write
);

VOID
SCProcessDmaDataBuffers(
                       IN PKSSTREAM_HEADER FirstHeader,
                       IN ULONG NumberOfHeaders,
                       IN PSTREAM_OBJECT StreamObject,
                       IN PMDL FirstMdl,
                       OUT PULONG NumberOfPages,
                       IN ULONG StreamHeaderSize,
                       IN BOOLEAN Write
);
VOID
SCErrorDataSRB(
               IN PHW_STREAM_REQUEST_BLOCK SRB
);

VOID
SCCheckOutstandingRequestsForTimeouts(
                                      IN PLIST_ENTRY ListEntry
);

VOID
SCCheckFilterInstanceStreamsForTimeouts(
                                        IN PFILTER_INSTANCE FilterInstance
);

VOID
StreamClassTickHandler(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PVOID Context
);

VOID
StreamClassCancelOutstandingIrp(
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PIRP Irp
);

VOID
StreamClassCancelPendingIrp(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp
);

VOID
SCCancelOutstandingIrp(
                       IN PDEVICE_EXTENSION DeviceExtension,
                       IN PIRP Irp
);

BOOLEAN
SCCheckFilterInstanceStreamsForIrp(
                                   IN PFILTER_INSTANCE FilterInstance,
                                   IN PIRP Irp
);

BOOLEAN
SCCheckRequestsForIrp(
                      IN PLIST_ENTRY ListEntry,
                      IN PIRP Irp,
                      IN BOOLEAN IsIrpQueue,
                      IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SCNotifyMinidriverCancel(
                         IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCProcessCompletedPropertyRequest(
                                  IN PSTREAM_REQUEST_BLOCK SRB
);


NTSTATUS
StreamClassMinidriverDeviceGetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);

NTSTATUS
StreamClassMinidriverDeviceSetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);


NTSTATUS
StreamClassMinidriverStreamGetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);

NTSTATUS
StreamClassMinidriverStreamSetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);

NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
);


NTSTATUS
SCOpenMinidriverInstance(
                         IN PDEVICE_EXTENSION DeviceExtension,
                         OUT PFILTER_INSTANCE * ReturnedFilterInstance,
                         IN PSTREAM_CALLBACK_PROCEDURE Callback,
                         IN PIRP Irp
);

NTSTATUS
SCMinidriverDevicePropertyHandler
(
 IN SRB_COMMAND Command,
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);

NTSTATUS
SCMinidriverStreamPropertyHandler
(
 IN SRB_COMMAND Command,
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);

VOID
SCStartRequestOnStream(
                       IN PSTREAM_OBJECT StreamObject,
                       IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
StreamClassPnPAddDeviceWorker(
                              IN PDRIVER_OBJECT DriverObject,
                              IN PDEVICE_OBJECT PhysicalDeviceObject,
                          IN OUT PDEVICE_EXTENSION * ReturnedDeviceExtension
);

NTSTATUS
SCProcessDataTransfer(
                      IN PDEVICE_EXTENSION DeviceExtension,
                      IN PIRP Irp,
                      IN SRB_COMMAND Command
);

VOID
SCUpdateMinidriverProperties(
                             IN ULONG NumProps,
                             IN PKSPROPERTY_SET MinidriverProps,
                             IN BOOLEAN Stream
);

VOID
SCInitializeWorkItem(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCInitializeCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

VOID
SCStreamInfoWorkItem(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCDequeueAndDeleteSrb(
                      IN PSTREAM_REQUEST_BLOCK SRB
);


VOID
SCReadRegistryValues(IN PDEVICE_EXTENSION DeviceExtension,
                     IN PDEVICE_OBJECT PhysicalDeviceObject
);

NTSTATUS
SCGetRegistryValue(
                   IN HANDLE Handle,
                   IN PWCHAR KeyNameString,
                   IN ULONG KeyNameStringLength,
                   IN PVOID Data,
                   IN ULONG DataLength
);


VOID
SCInsertStreamInFilter(
                       IN PSTREAM_OBJECT StreamObject,
                       IN PDEVICE_EXTENSION DeviceExtension

);

VOID
SCReferenceDriver(
                  IN PDEVICE_EXTENSION DeviceExtension

);

VOID
SCDereferenceDriver(
                    IN PDEVICE_EXTENSION DeviceExtension

);

VOID
SCQueueSrbWorkItem(
                   IN PSTREAM_REQUEST_BLOCK Srb
);


VOID
SCProcessPriorityChangeRequest(
                               IN PCOMMON_OBJECT CommonObject,
                               IN PINTERRUPT_DATA SavedInterruptData,
                               IN PDEVICE_EXTENSION DeviceExtension

);

VOID
SCProcessTimerRequest(
                      IN PCOMMON_OBJECT CommonObject,
                      IN PINTERRUPT_DATA SavedInterruptData

);

NTSTATUS
SCPowerCallback(
                  IN PSTREAM_REQUEST_BLOCK SRB
);

BOOLEAN
SCCheckIfOkToPowerDown(
                       IN PDEVICE_EXTENSION DeviceExtension

);


NTSTATUS
SCIssueRequestToDevice(
                       IN PDEVICE_EXTENSION DeviceExtension,
                       IN PSTREAM_OBJECT StreamObject,
                       PSTREAM_REQUEST_BLOCK Request,
                       IN PVOID MinidriverRoutine,
                       IN PLIST_ENTRY Queue,
                       IN PIRP Irp
);

VOID
SCBeginSynchronizedMinidriverCallin(
                                    IN PDEVICE_EXTENSION DeviceExtension,
                                    IN PKIRQL Irql
);

VOID
SCBeginUnsynchronizedMinidriverCallin(
                                      IN PDEVICE_EXTENSION DeviceExtension,
                                      IN PKIRQL Irql
);

VOID
SCEndUnsynchronizedMinidriverDeviceCallin(
                                       IN PDEVICE_EXTENSION DeviceExtension,
                                          IN PKIRQL Irql
);

VOID
SCEndUnsynchronizedMinidriverStreamCallin(
                                          IN PSTREAM_OBJECT StreamObject,
                                          IN PKIRQL Irql
);

VOID
SCEndSynchronizedMinidriverStreamCallin(
                                        IN PSTREAM_OBJECT StreamObject,
                                        IN PKIRQL Irql
);

VOID
SCEndSynchronizedMinidriverDeviceCallin(
                                        IN PDEVICE_EXTENSION DeviceExtension,
                                        IN PKIRQL Irql
);


NTSTATUS
SCStartWorker(
                IN PIRP Irp
);


NTSTATUS
SCShowIoPending(
                IN PDEVICE_EXTENSION DeviceExtension,
                IN PIRP Irp
);

VOID
SCWaitForOutstandingIo(
                       IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SCCheckPoweredUp(
                 IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SCCheckPowerDown(
                 IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
SCUninitializeCallback(
                       IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCRemoveComplete(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp,
                 IN PVOID Context
);

VOID
SCRemoveCompleteWorkItem(
                         IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SCDetachDevice(
               IN PDEVICE_OBJECT Fdo,
               IN PDEVICE_OBJECT Pdo
);

NTSTATUS
SCQueryWorker(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
);


NTSTATUS
SCCallNextDriver(
                 IN PDEVICE_EXTENSION DeviceExtension,
                 IN PIRP Irp
);

VOID
StreamFlushIo(
                    IN PDEVICE_EXTENSION DeviceExtension,
                    IN PSTREAM_OBJECT StreamObject
);

NTSTATUS
ClockDispatchCreate(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
);

NTSTATUS
SCOpenMasterCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCSetMasterClock(
                 IN PIRP Irp,
                 IN PKSPROPERTY Property,
                 IN OUT PHANDLE ClockHandle
);

NTSTATUS
SCClockGetTime(
               IN PIRP Irp,
               IN PKSPROPERTY Property,
               IN OUT PULONGLONG StreamTime
);

NTSTATUS
SCClockGetPhysicalTime(
                       IN PIRP Irp,
                       IN PKSPROPERTY Property,
                       IN OUT PULONGLONG PhysicalTime
);

NTSTATUS
SCClockGetSynchronizedTime(
                           IN PIRP Irp,
                           IN PKSPROPERTY Property,
                           IN OUT PKSCORRELATED_TIME SyncTime
);

NTSTATUS
SCClockGetFunctionTable(
                        IN PIRP Irp,
                        IN PKSPROPERTY Property,
                        IN OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
);

NTSTATUS
ClockDispatchClose(
                   IN PDEVICE_OBJECT DeviceObject,
                   IN PIRP Irp
);

ULONGLONG       FASTCALL
                SCGetSynchronizedTime(
                                                 IN PFILE_OBJECT FileObject,
                                                    IN PULONGLONG SystemTime

);

ULONGLONG       FASTCALL
                SCGetPhysicalTime(
                                                  IN PFILE_OBJECT FileObject

);

ULONGLONG
SCGetStreamTime(
                IN PFILE_OBJECT FileObject

);

VOID
SCMinidriverTimeFunction(
                         IN PHW_TIME_CONTEXT TimeContext
);

NTSTATUS
ClockDispatchIoControl(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp
);

VOID
StreamClassQueryMasterClock(
                            IN PHW_STREAM_OBJECT HwStreamObject,
                            IN HANDLE MasterClockHandle,
                            IN TIME_FUNCTION TimeFunction,
                            IN PHW_QUERY_CLOCK_ROUTINE ClockCallbackRoutine
);

NTSTATUS
SCSendUnknownCommand(
                                  IN PIRP Irp,
                                  IN PDEVICE_EXTENSION DeviceExtension,
                                  IN PVOID Callback,
                                  OUT PBOOLEAN RequestIssued
);

NTSTATUS
SCPNPQueryCallback(
    IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCUnknownPNPCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCUnknownPowerCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

BOOLEAN
SCMapMemoryAddress(PACCESS_RANGE AccessRanges,
                   PHYSICAL_ADDRESS TranslatedAddress,                                 
                   PPORT_CONFIGURATION_INFORMATION     ConfigInfo,
                   PDEVICE_EXTENSION        DeviceExtension,
                   PCM_RESOURCE_LIST ResourceList,
                   PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor
);


VOID
SCUpdatePersistedProperties(IN PSTREAM_OBJECT StreamObject,
                            IN PDEVICE_EXTENSION DeviceExtension,
                            IN PFILE_OBJECT FileObject
);

VOID
SCCreateSymbolicLinks(
                   IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SCDestroySymbolicLinks(
                   IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
SCSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

VOID
SCSignalSRBEvent(
                   IN PSTREAM_REQUEST_BLOCK Srb
);

NTSTATUS
SCFilterTopologyHandler(
                           IN PIRP Irp,
                           IN PKSPROPERTY Property,
                           IN OUT PVOID Data);

NTSTATUS
SCStreamProposeNewFormat
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSDATAFORMAT Format
);

NTSTATUS
SCGetMasterClock(
                 IN PIRP Irp,
                 IN PKSPROPERTY Property,
                 IN OUT PHANDLE ClockHandle
);

NTSTATUS
SCCloseClockCallback(
                      IN PSTREAM_REQUEST_BLOCK SRB
);


NTSTATUS
SCStreamDeviceRate
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSRATE DeviceRate
);

NTSTATUS
SCStreamDeviceRateCapability
(
 IN PIRP Irp,
 IN PKSRATE_CAPABILITY RateCap,
 IN OUT PKSRATE DeviceRate
);

NTSTATUS
SCFilterPinIntersectionHandler(
    IN PIRP     Irp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
    );

NTSTATUS
SCIntersectHandler(
    IN PIRP             Irp,
    IN PKSP_PIN         Pin,
    IN PKSDATARANGE     DataRange,
    OUT PVOID           Data
);

NTSTATUS
SCDataIntersectionCallback(
                      IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCQueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    );

NTSTATUS
SCSynchPowerCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DeviceState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
);

NTSTATUS
SCGetStreamDeviceState
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSSTATE DeviceState
);

NTSTATUS
SCCreateChildPdo(
                 IN PVOID PnpId,
                 IN PDEVICE_OBJECT DeviceObject,
                 IN ULONG InstanceNumber
);

NTSTATUS
SCEnumerateChildren(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
StreamClassEnumPnp(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
StreamClassEnumPower(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
SCEnumGetCaps(
    IN  PCHILD_DEVICE_EXTENSION       DeviceExtension,
    OUT PDEVICE_CAPABILITIES    Capabilities
);


NTSTATUS
SCQueryEnumId(
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      BUS_QUERY_ID_TYPE   BusQueryIdType,
    IN  OUT PWSTR             * BusQueryId
);

NTSTATUS
AllocatorDispatchCreate(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
);


NTSTATUS
StreamClassEnableEventHandler(
                                  IN PIRP Irp,
                           IN PKSEVENTDATA EventData,
                           IN PKSEVENT_ENTRY EventEntry
);

VOID
StreamClassDisableEventHandler(
                               IN PFILE_OBJECT FileObject,
                               IN PKSEVENT_ENTRY EventEntry
);

VOID
SCUpdateMinidriverEvents(
                             IN ULONG NumEvents,
                             IN PKSEVENT_SET MinidriverEvents,
                             IN BOOLEAN Stream
);

NTSTATUS
SCEnableEventSynchronized(
                    IN PVOID ServiceContext
);

VOID
SCGetDeadListSynchronized(
                               IN PLIST_ENTRY NewListEntry
);

VOID
SCFreeDeadEvents(
                               IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
StreamClassForwardUnsupported(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
SCStreamSetFormat
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSDATAFORMAT Format
);

VOID
SCInsertStreamInfo(
                IN PDEVICE_EXTENSION DeviceExtension,
                IN PKSPIN_DESCRIPTOR PinDescs,
                IN PHW_STREAM_DESCRIPTOR StreamDescriptor,
                IN ULONG NumberOfPins
);

VOID
SCRescanStreams(
                 IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
SCGetStreamHeaderSize(
                       IN PIRP Irp,
                       IN PKSPROPERTY Property,
                       IN OUT PULONG StreamHeaderSize
);

VOID
SCInterlockedRemoveEntryList(
                       PDEVICE_EXTENSION DeviceExtension,
                       PLIST_ENTRY List
);

VOID
SCInsertFiltersInDevice(
                       IN PFILTER_INSTANCE FilterInstance,
                       IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
SCBustedSynchPowerCompletionRoutine(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN UCHAR MinorFunction,
                              IN POWER_STATE DeviceState,
                              IN PVOID Context,
                              IN PIO_STATUS_BLOCK IoStatus
);

BOOLEAN
SCCheckIfStreamsRunning(
                IN PFILTER_INSTANCE FilterInstance
);

#if DBG

BOOLEAN
SCDebugKeSynchronizeExecution(
                                IN PKINTERRUPT Interrupt,
                                IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
                                IN PVOID SynchronizeContext
);

#endif // DEBUG

NTSTATUS
SCEnableDeviceEventSynchronized(
                          IN PVOID ServiceContext
);

NTSTATUS
StreamClassEnableDeviceEventHandler(
                              IN PIRP Irp,
                              IN PKSEVENTDATA EventData,
                              IN PKSEVENT_ENTRY EventEntry
);

VOID
StreamClassDisableDeviceEventHandler(
                               IN PFILE_OBJECT FileObject,
                               IN PKSEVENT_ENTRY EventEntry
);


VOID
SCCallBackSrb(
                  IN PSTREAM_REQUEST_BLOCK Srb,
                  IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
DllUnload(
    VOID
);

VOID 
SCPowerCompletionWorker(
                            IN PIRP SystemIrp
);

VOID
SCSendSurpriseNotification(
              IN PDEVICE_EXTENSION DeviceExtension,
              IN PIRP Irp
);

#if DBG
VOID
SCDebugPriorityWorkItem(
                 IN PDEBUG_WORK_ITEM WorkItemStruct
);
#endif 

PKSPROPERTY_SET
SCCopyMinidriverProperties(
                             IN ULONG NumProps,
                             IN PKSPROPERTY_SET MinidriverProps
);

PKSEVENT_SET
SCCopyMinidriverEvents(
                         IN ULONG NumEvents,
                         IN PKSEVENT_SET MinidriverEvents
);

#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
NTSTATUS
SCStreamAllocatorFraming(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSALLOCATOR_FRAMING Framing
);

NTSTATUS
SCStreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE AllocatorHandle
);

NTSTATUS
IoCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
);

NTSTATUS
CleanupTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject
);

NTSTATUS
EndTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT   StreamObject
);

NTSTATUS
BeginTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject
    );

NTSTATUS
PrepareTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject
);

NTSTATUS 
PinCreateHandler(
    IN PIRP Irp,
    IN PSTREAM_OBJECT StreamObject
);

NTSTATUS 
AllocateFrame(
    PFILE_OBJECT Allocator,
    PVOID *Frame
    );

NTSTATUS
FreeFrame(
    PFILE_OBJECT Allocator,
    PVOID Frame
    );
#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR

#ifdef ENABLE_KS_METHODS

NTSTATUS
SCProcessCompletedMethodRequest(
                                  IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
StreamClassMinidriverStreamMethod
(
 IN PIRP Irp,
 IN PKSMETHOD Method,
 IN OUT PVOID MethodInfo
);

NTSTATUS
StreamClassMinidriverDeviceMethod
(
 IN PIRP Irp,
 IN PKSMETHOD Method,
 IN OUT PVOID MethodInfo
);

NTSTATUS
SCMinidriverStreamMethodHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSMETHOD Method,
                                  IN OUT PVOID MethodInfo
);

NTSTATUS
SCMinidriverDeviceMethodHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSMETHOD Method,
                                  IN OUT PVOID MethodInfo
);

VOID
SCUpdateMinidriverMethods(
                             IN ULONG NumMethods,
                             IN PKSMETHOD_SET MinidriverMethods,
                             IN BOOLEAN Stream
);

PKSMETHOD_SET
SCCopyMinidriverMethods(
                         IN ULONG NumMethods,
                         IN PKSMETHOD_SET MinidriverMethods
);


NTSTATUS
SCStreamMethodHandler(
 IN PIRP Irp,
 IN PKSMETHOD Method,
 IN OUT PVOID MethodInfo
);

NTSTATUS
SCStreamAllocatorMethodHandler(
 IN PIRP Irp,
 IN PKSMETHOD Method,
 IN OUT PVOID MethodInfo
);

#endif

#if ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SciOnFilterStreamDescriptor(
    PFILTER_INSTANCE FilterInstance,
    PHW_STREAM_DESCRIPTOR StreamDescriptor);
    
VOID
SciInsertFilterStreamInfo(
                   IN PFILTER_INSTANCE FilterInstance,
                   IN PKSPIN_DESCRIPTOR PinDescs,
                   IN ULONG NumberOfPins);

NTSTATUS
SciFreeFilterInstance(
    PFILTER_INSTANCE pFilterInstance
);                   

NTSTATUS
SciQuerySystemPowerHiberCallback(
                   IN PSTREAM_REQUEST_BLOCK SRB
);

#endif // ENABLE_MULTIPLE_FILTER_TYPES

#define SCLOG_FLAGS_CLOCK   0x00000001
#define SCLOG_FLAGS_PNP     0x00000002
#define SCLOG_FLAGS_PRINT   0x80000000

#if (DBG) && !defined(_WIN64)

NTSTATUS SCLog( ULONG ulTag, ULONG ulArg1, ULONG ulArg2, ULONG ulArg3 );
NTSTATUS SCLogWithTime( ULONG ulTag, ULONG ulArg1, ULONG ulArg2 );
#define SCLOG( ulTag, Arg1, Arg2, Arg3 ) SCLog( ulTag, (ULONG)Arg1, (ULONG)Arg2, (ULONG)Arg3 )
#define SCLOGWITHTIME( ulTag, Arg1, Arg2 ) SCLogWithTime( ulTag, Arg1, Arg2 )

#else

#define SCLOG( ulTag, Arg1, Arg2, Arg3 )
#define SCLOGWITHTIME( ulTag, Arg1, Arg2 )

#endif


#endif  // #ifndef _STREAMCLASS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\dvd\class\messages.h ===
/*---
Copyright (c) 1995  Microsoft Corporation

Module Name:

    messages.h

Abstract:

    Log message file for Codec Class Driver

Author:

	 billpa

Revision History:

--*/


//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_CODCLASS_ERROR_CODE     0x6
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: CODCLASS_NO_ADAPTERS_FOUND
//
// MessageText:
//
//  Codec Minidriver found no usable adapter cards.
//
#define CODCLASS_NO_ADAPTERS_FOUND       ((NTSTATUS)0xC0060001L)

//
// MessageId: CODCLASS_ADAPTER_FOUND
//
// MessageText:
//
//  Codec Minidriver found adapter card.
//
#define CODCLASS_ADAPTER_FOUND           ((NTSTATUS)0x40060002L)

//
// MessageId: CODCLASS_CLASS_MINIDRIVER_MISMATCH
//
// MessageText:
//
//  Codec Minidriver does not match the revision of the Codec Class driver.
//
#define CODCLASS_CLASS_MINIDRIVER_MISMATCH  ((NTSTATUS)0xC0060003L)

//
// MessageId: CODCLASS_MINIDRIVER_MISSING_ENTRIES
//
// MessageText:
//
//  Codec Minidriver is missing required entries in HW_INITIALIZATION_DATA structure.
//  (HwInitialize, HwFindAdapter or HwStartIo)
//
#define CODCLASS_MINIDRIVER_MISSING_ENTRIES ((NTSTATUS)0xC0060004L)

//
// MessageId: CODCLASS_NO_PAGEDPOOL
//
// MessageText:
//
//  Codec Class driver could not allocate sufficient Paged Pool.
//
#define CODCLASS_NO_PAGEDPOOL            ((NTSTATUS)0xC0060005L)

//
// MessageId: CODCLASS_NO_NONPAGEDPOOL
//
// MessageText:
//
//  Codec Class driver could not allocate sufficient Non-Paged Pool.
//
#define CODCLASS_NO_NONPAGEDPOOL         ((NTSTATUS)0xC0060006L)

//
// MessageId: CODCLASS_COULD_NOT_CREATE_VIDEO_DEVICE
//
// MessageText:
//
//  Codec Class driver could not create Video device for %1.
//
#define CODCLASS_COULD_NOT_CREATE_VIDEO_DEVICE ((NTSTATUS)0xC0060007L)

//
// MessageId: CODCLASS_COULD_NOT_CREATE_AUDIO_DEVICE
//
// MessageText:
//
//  Codec Class driver could not create Video device for %1.
//
#define CODCLASS_COULD_NOT_CREATE_AUDIO_DEVICE ((NTSTATUS)0xC0060008L)

//
// MessageId: CODCLASS_COULD_NOT_CREATE_OVERLAY_DEVICE
//
// MessageText:
//
//  Codec Class driver could not create Video device for %1.
//
#define CODCLASS_COULD_NOT_CREATE_OVERLAY_DEVICE ((NTSTATUS)0xC0060009L)

//
// MessageId: CODCLASS_MINIDRIVER_BAD_CONFIG
//
// MessageText:
//
//  Codec Minidriver reported Bad Configuration info.
//  Possibly insufficient I/O resources.
//
#define CODCLASS_MINIDRIVER_BAD_CONFIG     ((NTSTATUS)0xC006000AL)

//
// MessageId: CODCLASS_MINIDRIVER_INTERNAL
//
// MessageText:
//
//  Codec Minidriver %1 reported an invalid error code while attempting to find the adapter.
//
#define CODCLASS_MINIDRIVER_INTERNAL       ((NTSTATUS)0xC006000BL)

//
// MessageId: CODCLASS_RESOURCE_CONFLICT
//
// MessageText:
//
//  A conflict was detected while reporting resources.
//
#define CODCLASS_RESOURCE_CONFLICT       ((NTSTATUS)0xC006000CL)

//
// MessageId: CODCLASS_INTERRUPT_CONNECT
//
// MessageText:
//
//  Codec Minidriver unable to connect to Interrupt.
//
#define CODCLASS_INTERRUPT_CONNECT       ((NTSTATUS)0xC006000DL)

//
// MessageId: CODCLASS_MINIDRIVER_HWINITIALIZE
//
// MessageText:
//
//  Codec Minidriver Hardware Initialize failed.
//
#define CODCLASS_MINIDRIVER_HWINITIALIZE   ((NTSTATUS)0xC006000EL)

//
// MessageId: CODCLASS_DOSNAME
//
// MessageText:
//
//  Codec Class failed creating DOS name: %2.
//
#define CODCLASS_DOSNAME                 ((NTSTATUS)0xC006000FL)

//
// MessageId: CODCLASS_DMA_ALLOCATE
//
// MessageText:
//
//  Codec Class could not Get DMA Adapter.
//
#define CODCLASS_DMA_ALLOCATE            ((NTSTATUS)0xC0060010L)

//
// MessageId: CODCLASS_DMA_BUFFER_ALLOCATE
//
// MessageText:
//
//  Codec Class could not allocate DMA buffer.
//
#define CODCLASS_DMA_BUFFER_ALLOCATE     ((NTSTATUS)0xC0060011L)

//
// MessageId: CODCLASS_MINIDRIVER_ERROR
//
// MessageText:
//
//  Codec Minidriver reported unspecified error:
//   (%2).
//
#define CODCLASS_MINIDRIVER_ERROR          ((NTSTATUS)0xC0060012L)

//
// MessageId: CODCLASS_MINIDRIVER_REVISION_MISMATCH
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Class / Minidriver revision mismatch (%2).
//
#define CODCLASS_MINIDRIVER_REVISION_MISMATCH ((NTSTATUS)0xC0060013L)

//
// MessageId: CODCLASS_MINIDRIVER_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Insufficient resources available (%2).
//
#define CODCLASS_MINIDRIVER_INSUFFICIENT_RESOURCES ((NTSTATUS)0xC0060014L)

//
// MessageId: CODCLASS_MINIDRIVER_INVALID_INTERRUPT
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Invalid interrupt setting (%2).
//
#define CODCLASS_MINIDRIVER_INVALID_INTERRUPT ((NTSTATUS)0xC0060015L)

//
// MessageId: CODCLASS_MINIDRIVER_INVALID_DMA
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Invalid DMA channel setting (%2).
//
#define CODCLASS_MINIDRIVER_INVALID_DMA    ((NTSTATUS)0xC0060016L)

//
// MessageId: CODCLASS_MINIDRIVER_NO_DMA_BUFFER
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Insufficient resources for DMA buffer (%2).
//
#define CODCLASS_MINIDRIVER_NO_DMA_BUFFER  ((NTSTATUS)0xC0060017L)

//
// MessageId: CODCLASS_MINIDRIVER_INVALID_MEMORY
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Invalid Memory address range specified  (%2).
//
#define CODCLASS_MINIDRIVER_INVALID_MEMORY ((NTSTATUS)0xC0060018L)

//
// MessageId: CODCLASS_MINIDRIVER_INVALID_CLASS
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Invalid Class address range specified (%2).
//
#define CODCLASS_MINIDRIVER_INVALID_CLASS   ((NTSTATUS)0xC0060019L)

//
// MessageId: CODCLASS_MINIDRIVER_HW_UNSUPCLASSED
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Revision of hardware detected is not supported (%2).
//
#define CODCLASS_MINIDRIVER_HW_UNSUPCLASSED ((NTSTATUS)0xC006001AL)

//
// MessageId: CODCLASS_NO_GLOBAL_INFO_POOL
//
// MessageText:
//
//   Could not allocate MPEG info structure.
//
#define CODCLASS_NO_GLOBAL_INFO_POOL ((NTSTATUS)0xC006001BL)

//
// MessageId: CODCLASS_NO_MINIDRIVER_INFO
//
// MessageText:
//
//   Could not find MPEG info structure.
//
#define CODCLASS_NO_MINIDRIVER_INFO ((NTSTATUS)0xC006001CL)

//
// MessageId: CODCLASS_NO_ACCESS_RANGE_POOL
//
// MessageText:
//
//   Could not allocate access range space
//

#define CODCLASS_NO_ACCESS_RANGE_POOL ((NTSTATUS)0xC006001DL)

//
// MessageId: CODCLASS_NO_STREAM_INFO_POOL
//
// MessageText:
//
// Could not allocate stream information structure
//
#define CODCLASS_NO_STREAM_INFO_POOL ((NTSTATUS)0xC006001EL)

//
// MessageId: CODCLASS_MINIDRIVER_VIDEO_FAILED
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Video device failed (%2).
//
#define CODCLASS_MINIDRIVER_VIDEO_FAILED   ((NTSTATUS)0xC006001FL)

//
// MessageId: CODCLASS_MINIDRIVER_AUDIO_FAILED
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Audio device failed (%2).
//
#define CODCLASS_MINIDRIVER_AUDIO_FAILED   ((NTSTATUS)0xC0060020L)

//
// MessageId: CODCLASS_MINIDRIVER_OVERLAY_FAILED
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Overlay device failed (%2).
//
#define CODCLASS_MINIDRIVER_OVERLAY_FAILED ((NTSTATUS)0xC0060021L)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\dvd\class\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF
$(O)\codcls.def: ..\codcls.def
        $(C_PREPROCESSOR) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\dvd\class\lowerapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   decinit.c

Abstract:

   This is the WDM decoder class driver.  This module contains code related
   to request processing.

Author:

    billpa

Environment:

   Kernel mode only


Revision History:

--*/

#include "codcls.h"

#if DBG

#if WIN95_BUILD
ULONG           StreamDebug = DebugLevelInfo;
#else
ULONG           StreamDebug = DebugLevelError;
#endif

#define STREAM_BUFFER_SIZE 256
UCHAR           StreamBuffer[STREAM_BUFFER_SIZE];
#endif

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'PscS')
#endif


VOID
StreamClassStreamNotification(
             IN STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType,
                              IN PHW_STREAM_OBJECT HwStreamObject,
                              ...
)
/*++

Routine Description:

  stream notification routine for minidriver

Arguments:

  NotificationType - indicates what has happened
  HwStreamObject - address of minidriver's stream struct

Return Value:

  none

--*/

{
    va_list         Arguments;
    PSTREAM_REQUEST_BLOCK SRB;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     HwStreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
                                                    );
    PDEVICE_EXTENSION DeviceExtension;
    KIRQL           Irql;

    #if DBG
    PMDL            CurrentMdl;
    #endif

    va_start(Arguments, HwStreamObject);

    ASSERT(HwStreamObject != NULL);

    DeviceExtension = StreamObject->DeviceExtension;

    ASSERT((DeviceExtension->BeginMinidriverCallin == SCBeginSynchronizedMinidriverCallin) ||
           (DeviceExtension->BeginMinidriverCallin == SCBeginUnsynchronizedMinidriverCallin));

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    //
    // optimization for async drivers - just directly call back the request
    // rather than queuing it on the DPC processed completed list.
    //

    if ((DeviceExtension->NoSync) && (NotificationType == StreamRequestComplete)) {

        SRB = CONTAINING_RECORD(va_arg(Arguments,
                                       PHW_STREAM_REQUEST_BLOCK),
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

        //
        // Clear the active flag.
        //

        ASSERT(SRB->Flags & SRB_FLAGS_IS_ACTIVE);
        SRB->Flags &= ~SRB_FLAGS_IS_ACTIVE;

        #if DBG
        //
        // assert the MDL list.
        //

        if (SRB->HwSRB.Irp) {
            CurrentMdl = SRB->HwSRB.Irp->MdlAddress;

            while (CurrentMdl) {

                CurrentMdl = CurrentMdl->Next;
            }                   // while

        }                       // if IRP
        ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST);

        if ((SRB->HwSRB.Command == SRB_READ_DATA) ||
            (SRB->HwSRB.Command == SRB_WRITE_DATA)) {

            ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER);
        } else {

            ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER));
        }                       // if read/write
        #endif


        if (SRB->DoNotCallBack) {

            DebugPrint((DebugLevelError, "'ScNotify: NOT calling back request - Irp = %x, S# = %x\n",
                SRB->HwSRB.Irp, StreamObject->HwStreamObject.StreamNumber));
            KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
            return;

        }                       // if NoCallback
        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

        DebugPrint((DebugLevelTrace, "'SCNotification: Completing async stream Irp %x, S# = %x, SRB = %x, Func = %x, Callback = %x, SRB->IRP = %x\n",
                  SRB->HwSRB.Irp, StreamObject->HwStreamObject.StreamNumber,
                    SRB, SRB->HwSRB.Command, SRB->Callback, SRB->HwSRB.Irp));
        (SRB->Callback) (SRB);

        return;

    }                           // if nosync & complete
    BEGIN_MINIDRIVER_STREAM_CALLIN(DeviceExtension, &Irql);

    switch (NotificationType) {

    case ReadyForNextStreamDataRequest:

        //
        // Start next data packet on adapter's stream queue.
        //

        DebugPrint((DebugLevelTrace, "'StreamClassStreamNotify: ready for next stream data request, S# = %x\n",
                    StreamObject->HwStreamObject.StreamNumber));

        ASSERT(!(StreamObject->ReadyForNextDataReq));
        ASSERT(!(DeviceExtension->NoSync));

        StreamObject->ReadyForNextDataReq = TRUE;
        break;

    case ReadyForNextStreamControlRequest:

        //
        // Start next data packet on adapter's stream queue.
        //

        DebugPrint((DebugLevelTrace, "'StreamClassStreamNotify: ready for next stream control request, S# = %x\n",
                    StreamObject->HwStreamObject.StreamNumber));

        ASSERT(!(StreamObject->ReadyForNextControlReq));
        ASSERT(!(DeviceExtension->NoSync));

        StreamObject->ReadyForNextControlReq = TRUE;
        break;

    case StreamRequestComplete:

        SRB = CONTAINING_RECORD(va_arg(Arguments,
                                       PHW_STREAM_REQUEST_BLOCK),
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        DebugPrint((DebugLevelTrace, "'SCStreamNot: completing Irp %x, S# = %x, SRB = %x, Command = %x\n",
                    SRB->HwSRB.Irp, StreamObject->HwStreamObject.StreamNumber, SRB, SRB->HwSRB.Command));
        ASSERT(SRB->HwSRB.Status != STATUS_PENDING);
        ASSERT(SRB->Flags & SRB_FLAGS_IS_ACTIVE);

        //
        // Clear the active flag.
        //

        SRB->Flags &= ~SRB_FLAGS_IS_ACTIVE;

        //
        // add the SRB to the list of completed SRB's.
        //

        SRB->HwSRB.NextSRB = StreamObject->ComObj.InterruptData.CompletedSRB;
        StreamObject->ComObj.InterruptData.CompletedSRB = &SRB->HwSRB;

        #if DBG
        //
        // assert the MDL list.
        //

        if (SRB->HwSRB.Irp) {
            CurrentMdl = SRB->HwSRB.Irp->MdlAddress;

            while (CurrentMdl) {

                CurrentMdl = CurrentMdl->Next;
            }                   // while

        }                       // if IRP
        ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST);

        if ((SRB->HwSRB.Command == SRB_READ_DATA) ||
            (SRB->HwSRB.Command == SRB_WRITE_DATA)) {

            ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER);
        } else {

            ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER));
        }                       // if read/write
        #endif

        break;

    case SignalMultipleStreamEvents:
        {

            GUID           *EventGuid = va_arg(Arguments, GUID *);
            ULONG           EventItem = va_arg(Arguments, ULONG);

            //
            // signal all events that match the criteria.  note that we are
            // already
            // at the level required for synchronizing the list, so no lock
            // type is specified.
            //

            KsGenerateEventList(EventGuid,
                                EventItem,
                                &StreamObject->NotifyList,
                                KSEVENTS_NONE,
                                NULL);


        }                       // case event

        break;

    case SignalStreamEvent:

        KsGenerateEvent(va_arg(Arguments, PKSEVENT_ENTRY));
        break;


    case DeleteStreamEvent:
        {

            PKSEVENT_ENTRY  EventEntry;

            //
            // remove the entry from the list, and add it to the dead list.
            // note
            // that we are already at the correct sync level to do this.
            //

            EventEntry = va_arg(Arguments, PKSEVENT_ENTRY);
            RemoveEntryList(&EventEntry->ListEntry);

            InsertTailList(&DeviceExtension->DeadEventList,
                           &EventEntry->ListEntry);

        }
        break;

    default:

        ASSERT(0);
    }

    va_end(Arguments);

    END_MINIDRIVER_STREAM_CALLIN(StreamObject, &Irql);

}                               // end StreamClassStreamNotification()



VOID
StreamClassDeviceNotification(
             IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
                              IN PVOID HwDeviceExtension,
                              ...
)
/*++

Routine Description:

  device notification routine for minidriver

Arguments:

  NotificationType - indicates what has happened
  HwDeviceExtension - address of minidriver's device extension

Return Value:

  none

--*/

{
    va_list         Arguments;
    PSTREAM_REQUEST_BLOCK SRB;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) HwDeviceExtension - 1;

    KIRQL           Irql;

    va_start(Arguments, HwDeviceExtension);

    ASSERT(HwDeviceExtension != NULL);

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    switch (NotificationType) {

    case ReadyForNextDeviceRequest:

        //
        // Start next control packet on adapter's device queue.
        //

        DebugPrint((DebugLevelTrace, "'StreamClassDeviceNotify: ready for next stream.\n"));
        ASSERT(!(DeviceExtension->ReadyForNextReq));
        ASSERT(!(DeviceExtension->NoSync));
        DeviceExtension->ReadyForNextReq = TRUE;
        break;

    case DeviceRequestComplete:

        SRB = CONTAINING_RECORD(va_arg(Arguments, PHW_STREAM_REQUEST_BLOCK),
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        DebugPrint((DebugLevelTrace, "'StreamClassDeviceNotify: stream request complete.\n"));
        ASSERT(SRB->HwSRB.Status != STATUS_PENDING);
        ASSERT(SRB->Flags & SRB_FLAGS_IS_ACTIVE);
        ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST));
        ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER));

        //
        // Clear the active flag.
        //

        SRB->Flags &= ~SRB_FLAGS_IS_ACTIVE;

        //
        // add the SRB to the list of completed SRB's.
        //

        SRB->HwSRB.NextSRB = DeviceExtension->ComObj.InterruptData.CompletedSRB;
        DeviceExtension->ComObj.InterruptData.CompletedSRB = &SRB->HwSRB;

        break;

    case SignalMultipleDeviceEvents:
        {

            GUID           *EventGuid = va_arg(Arguments, GUID *);
            ULONG           EventItem = va_arg(Arguments, ULONG);

            //
            // signal all events that match the criteria.  note that we are
            // already
            // at the level required for synchronizing the list, so no lock
            // type is specified.
            //

            PFILTER_INSTANCE FilterInstance;
            
            ASSERT( 0 == DeviceExtension->MinidriverData->
                         HwInitData.FilterInstanceExtensionSize);
                         
            //
            // this is synced should not need to avoid race
            //

            FilterInstance = (PFILTER_INSTANCE)
                              DeviceExtension->FilterInstanceList.Flink;

            if ( (PLIST_ENTRY)FilterInstance == 
                    &DeviceExtension->FilterInstanceList ) {

                DebugPrint((DebugLevelWarning, "Filter Closed\n"));                    
                break;
            }
            
            FilterInstance = CONTAINING_RECORD(FilterInstance,
                                       FILTER_INSTANCE,
                                       NextFilterInstance);
                                       
            KsGenerateEventList(EventGuid,
                                EventItem,
                                &FilterInstance->NotifyList,
                                KSEVENTS_NONE,
                                NULL);
                                
        }
        
        break;
    #if ENABLE_MULTIPLE_FILTER_TYPES
    case SignalMultipleDeviceInstanceEvents:
        {            
            PFILTER_INSTANCE FilterInstance =
                (PFILTER_INSTANCE)va_arg( Arguments, PVOID) -1;
            GUID           *EventGuid = va_arg(Arguments, GUID *);
            ULONG           EventItem = va_arg(Arguments, ULONG);

            //
            // signal all events that match the criteria.  note that we are
            // already
            // at the level required for synchronizing the list, so no lock
            // type is specified.
            //
            
            KsGenerateEventList(EventGuid,
                                EventItem,
                                &FilterInstance->NotifyList,
                                KSEVENTS_NONE,
                                NULL);
        } 
        break;
    #endif // ENABLE_MULTIPLE_FILTER_TYPES

    case SignalDeviceEvent:

        KsGenerateEvent(va_arg(Arguments, PKSEVENT_ENTRY));
        break;


    case DeleteDeviceEvent:
        {

            PKSEVENT_ENTRY  EventEntry;

            //
            // remove the entry from the list, and add it to the dead list.
            // note
            // that we are already at the correct sync level to do this.
            //

            EventEntry = va_arg(Arguments, PKSEVENT_ENTRY);
            RemoveEntryList(&EventEntry->ListEntry);

            InsertTailList(&DeviceExtension->DeadEventList,
                           &EventEntry->ListEntry);

        }
        break;

    default:

        ASSERT(0);
    }

    va_end(Arguments);

    //
    // Request a DPC be queued after the interrupt completes.
    //

    END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

}                               // end StreamClassDeviceNotification()



VOID
StreamClassScheduleTimer(
                         IN OPTIONAL PHW_STREAM_OBJECT HwStreamObject,
                         IN PVOID HwDeviceExtension,
                         IN ULONG NumberOfMicroseconds,
                         IN PHW_TIMER_ROUTINE TimerRoutine,
                         IN PVOID Context
)
/*++

Routine Description:

  schedules a timer callback for the minidriver

Arguments:

  HwStreamObject - address of minidriver's stream struct
  HwDeviceExtension - address of minidriver's device extension
  NumberOfMicroseconds - # of microseconds that should elapse before calling
  TimerRoutine - routine to call when the time expires
  Context - value to pass into the timer routine

Return Value:

  none

--*/

{
    PSTREAM_OBJECT  StreamObject;
    KIRQL           Irql;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
    (HwDeviceExtension) - 1;
    PCOMMON_OBJECT  ComObj;

    ASSERT(HwDeviceExtension != NULL);

    StreamObject = CONTAINING_RECORD(
                                     HwStreamObject,
                                     STREAM_OBJECT,
                                     HwStreamObject
        );

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    //
    // The driver wants to set the timer.
    // Save the timer parameters.
    //

    BEGIN_MINIDRIVER_STREAM_CALLIN(DeviceExtension, &Irql);

    if (HwStreamObject) {

        ComObj = &StreamObject->ComObj;
        //DebugPrint((DebugLevelVerbose, "'StreamClassScheduleTimer for stream.\n"));

    } else {

        StreamObject = NULL;
        ComObj = &DeviceExtension->ComObj;
        ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;
        DebugPrint((DebugLevelVerbose, "'StreamClassScheduleTimer for device.\n"));

    }

    //
    // assert that a timer is not scheduled multiple times.
    //

    #if DBG
    if ((ComObj->InterruptData.Flags & INTERRUPT_FLAGS_TIMER_CALL_REQUEST) &&
        ((NumberOfMicroseconds != 0) && (ComObj->InterruptData.HwTimerValue
                                         != 0))) {

        DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled same timer twice!\n"));
        DEBUG_BREAKPOINT();
        ASSERT(1 == 0);
    }                           // if scheduled twice
    #endif

    ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_TIMER_CALL_REQUEST;
    ComObj->InterruptData.HwTimerRoutine = TimerRoutine;
    ComObj->InterruptData.HwTimerValue = NumberOfMicroseconds;
    ComObj->InterruptData.HwTimerContext = Context;

    if (StreamObject) {
        END_MINIDRIVER_STREAM_CALLIN(StreamObject, &Irql);

    } else {

        END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);
    }                           // if streamobject
}



VOID
StreamClassCallAtNewPriority(
                             IN OPTIONAL PHW_STREAM_OBJECT HwStreamObject,
                             IN PVOID HwDeviceExtension,
                             IN STREAM_PRIORITY Priority,
                             IN PHW_PRIORITY_ROUTINE PriorityRoutine,
                             IN PVOID Context
)
/*++

Routine Description:

  schedules a callback at the specified priority

Arguments:

  HwStreamObject - address of minidriver's stream struct
  HwDeviceExtension - address of minidriver's device extension
  Priority - priority at which to call minidriver
  PriorityRoutine - routine to call at specified priority
  Context - value to pass into the priority routine

Return Value:

  none

--*/

{
    PSTREAM_OBJECT  StreamObject;
    KIRQL           Irql;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
    (HwDeviceExtension) - 1;
    PCOMMON_OBJECT  ComObj;

    ASSERT(HwDeviceExtension != NULL);

    StreamObject = CONTAINING_RECORD(
                                     HwStreamObject,
                                     STREAM_OBJECT,
                                     HwStreamObject
        );

    //
    // The driver wants to get called back at a different priority.
    // Save the priority parameters.
    //

    if (Priority == LowToHigh) {

        //
        // the minidriver wishes to be called from low priority to high
        // we must call it directly from this routine as we cannot use
        // the interruptcontext structure due to the possibility of
        // reentrancy.
        //


        DebugPrint((DebugLevelVerbose, "'StreamClassChangePriority LowToHigh.\n"));
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

        DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                                              (PVOID) PriorityRoutine,
                                              Context);

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);


        //
        // Call the DPC directly to check for work.
        //

        StreamClassDpc(NULL,
                       DeviceExtension->DeviceObject,
                       NULL,
                       NULL);

        KeLowerIrql(Irql);

    } else {

        if (HwStreamObject) {

            DebugPrint((DebugLevelVerbose, "'StreamClassChangePriority to %x for stream %x\n",
                        StreamObject->ComObj.InterruptData.HwPriorityLevel, StreamObject->HwStreamObject.StreamNumber));
            ComObj = &StreamObject->ComObj;
            SCRequestDpcForStream(StreamObject);

        } else {

            DebugPrint((DebugLevelVerbose, "'StreamClassChangePriority for device.\n"));
            ComObj = &DeviceExtension->ComObj;
            ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;

        }                       // if streamobject

        #if DBG
        if ((ComObj->InterruptData.Flags &
            INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) || 
             ((ComObj->PriorityWorkItemScheduled) && (Priority == Low))) {

            DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled priority twice!\n"));
            DEBUG_BREAKPOINT();
            ASSERT(1 == 0);
        }                       // if scheduled twice

        ComObj->PriorityWorkItemScheduled = TRUE;

        #endif

        ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST;
        ComObj->InterruptData.HwPriorityLevel = Priority;
        ComObj->InterruptData.HwPriorityRoutine = PriorityRoutine;
        ComObj->InterruptData.HwPriorityContext = Context;
    }                           // if lowtohigh

}

VOID
StreamClassLogError(
                    IN PVOID HwDeviceExtension,
                    IN PHW_STREAM_REQUEST_BLOCK hwSRB OPTIONAL,
                    IN ULONG ErrorCode,
                    IN ULONG UniqueId
)
/*++

Routine Description:

    This routine saves the error log information, and queues a DPC if necessary.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data storage.

    SRB - Supplies an optional pointer to SRB if there is one.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension =
    ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PDEVICE_OBJECT  DeviceObject = deviceExtension->DeviceObject;
    PERROR_LOG_ENTRY errorLogEntry;
    PSTREAM_REQUEST_BLOCK SRB;
    KIRQL           Irql;

    //
    // If the error log entry is already full, then dump the error.
    //

    DEBUG_BREAKPOINT();
    ASSERT(HwDeviceExtension != NULL);
    BEGIN_MINIDRIVER_DEVICE_CALLIN(deviceExtension, &Irql);

    DebugPrint((DebugLevelError, "StreamClassLogError.\n"));
    if (deviceExtension->ComObj.InterruptData.Flags & INTERRUPT_FLAGS_LOG_ERROR) {
        DEBUG_BREAKPOINT();
        DebugPrint((1, "'StreamClassLogError: Ignoring error log packet.\n"));
        return;
    }
    //
    // Save the error log data in the log entry.
    //

    errorLogEntry = &deviceExtension->ComObj.InterruptData.LogEntry;
    errorLogEntry->ErrorCode = ErrorCode;
    errorLogEntry->UniqueId = UniqueId;

    //
    // Get the sequence number from the SRB.
    //

    if (hwSRB != NULL) {

        DEBUG_BREAKPOINT();
        SRB = CONTAINING_RECORD(hwSRB,
                                STREAM_REQUEST_BLOCK,
                                HwSRB);
        errorLogEntry->SequenceNumber = SRB->SequenceNumber;
    } else {

        DEBUG_BREAKPOINT();
        errorLogEntry->SequenceNumber = 0;
    }

    //
    // Indicate that the error log entry is in use and that a
    // notification
    // is required.
    //

    deviceExtension->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_LOG_ERROR;

    END_MINIDRIVER_DEVICE_CALLIN(deviceExtension, &Irql);

    return;

}                               // end StreamClassLogError()


#if DBG


VOID
StreamClassDebugPrint(
                      STREAM_DEBUG_LEVEL DebugPrintLevel,
                      PSCHAR DebugMessage,
                      ...
)
/*++

Routine Description:

    Debug print routine

Arguments:

    DebugPrintLevel - Debug print level
    DebugMessage - message to print


Return Value:

    None

--*/

{
    va_list         ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= (INT) StreamDebug) {

        _vsnprintf(StreamBuffer, STREAM_BUFFER_SIZE-1, DebugMessage, ap);

        DbgPrint(StreamBuffer);
    }
    va_end(ap);

}                               // end StreamClassDebugPrint()

#else

//
// StreamClassDebugPrint stub
//

VOID
StreamClassDebugPrint(
                      STREAM_DEBUG_LEVEL DebugPrintLevel,
                      PSCHAR DebugMessage,
                      ...
)
{
}

#endif




STREAM_PHYSICAL_ADDRESS
StreamClassGetPhysicalAddress(
                              IN PVOID HwDeviceExtension,
                              IN PHW_STREAM_REQUEST_BLOCK HwSRB OPTIONAL,
                              IN PVOID VirtualAddress,
                              IN STREAM_BUFFER_TYPE Type,
                              OUT ULONG * Length
)
/*++

Routine Description:

    Convert virtual address to physical address for DMA.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data storage.
    HwSRB - Supplies an optional pointer to SRB if there is one.
    VirtualAddress - pointer to address for which to retrieve physical address
    Type - type of buffer in VirtualAddress

Return Value:

    Returns phys address and length or NULL if invalid address

--*/

{
    PDEVICE_EXTENSION deviceExtension = ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PKSSTREAM_HEADER CurrentHeader;
    PKSSCATTER_GATHER ScatterList;
    PSTREAM_REQUEST_BLOCK SRB;
    ULONG           VirtualOffset;
    PHYSICAL_ADDRESS address;
    ULONG           NumberOfBuffers,
                    i,
                    SizeSoFar = 0,
                    ListSize = 0;
    ULONG           DataBytes;
    PHW_STREAM_OBJECT HwStreamObject;

    ASSERT(HwDeviceExtension != NULL);

    switch (Type) {

    case PerRequestExtension:

        ASSERT(HwSRB);
        SRB = CONTAINING_RECORD((PHW_STREAM_REQUEST_BLOCK) HwSRB,
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        VirtualOffset = (ULONG) ((ULONG_PTR) VirtualAddress - (ULONG_PTR) (SRB + 1));
        *Length = SRB->ExtensionLength - VirtualOffset;
        address.QuadPart = SRB->PhysicalAddress.QuadPart +
            sizeof(STREAM_REQUEST_BLOCK) +
            VirtualOffset;

        return (address);

    case DmaBuffer:
        VirtualOffset = (ULONG) ((ULONG_PTR) VirtualAddress - (ULONG_PTR) deviceExtension->DmaBuffer);
        *Length = deviceExtension->DmaBufferLength - VirtualOffset;
        address.QuadPart = deviceExtension->DmaBufferPhysical.QuadPart
            + VirtualOffset;

        return (address);

    case SRBDataBuffer:
        ASSERT(HwSRB);

        SRB = CONTAINING_RECORD((PHW_STREAM_REQUEST_BLOCK) HwSRB,
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        HwStreamObject = SRB->HwSRB.StreamObject;
        ASSERT(HwStreamObject);

        CurrentHeader = SRB->HwSRB.CommandData.DataBufferArray;

        NumberOfBuffers = SRB->HwSRB.NumberOfBuffers;

        for (i = 0; i < NumberOfBuffers; i++) {

            if (SRB->HwSRB.Command == SRB_WRITE_DATA) {

                DataBytes = CurrentHeader->DataUsed;

            } else {            // if write

                DataBytes = CurrentHeader->FrameExtent;

            }                   // if write


            //
            // see if the buffer is within the range of this element
            //

            VirtualOffset = (ULONG) ((ULONG_PTR) VirtualAddress - (ULONG_PTR) CurrentHeader->Data + 1);
            if (VirtualOffset > DataBytes) {

                //
                // buffer not within this element.  add the size of this one
                // to our total.
                //

                SizeSoFar += DataBytes;

            } else {

                //
                // we've found the element.  Now calculate the phys
                // address from the phys list.
                //
                // GUBGUB - This function is seldom called. n is most ofen small
                // <=3. The O(n^2) performance concern is insignificant.
                // - this algorithm gets n^2 expensive for long lists
                // an alternative is to build a separate array which holds
                // the mapping between the stream headers and the s/g
                // elements
                // for each header.  We currently don't get that many
                // elements
                // so the below is more efficient now.
                //

                ScatterList = SRB->HwSRB.ScatterGatherBuffer;

                while (SizeSoFar > ListSize) {

                    ListSize += ScatterList++->Length;
                }

                //
                // Now ScatterList points to the correct scatter/gather
                // element.
                //


                while (VirtualOffset > ScatterList->Length) {
                    VirtualOffset -= ScatterList->Length;
                    ScatterList++;
                }

                *Length = ScatterList->Length - VirtualOffset + 1;
                address.QuadPart = ScatterList->PhysicalAddress.QuadPart
                    + VirtualOffset - 1;
                return (address);
            }                   // if buffer

            CurrentHeader = ((PKSSTREAM_HEADER) ((PBYTE) CurrentHeader +
                                 HwStreamObject->StreamHeaderMediaSpecific +
                                    HwStreamObject->StreamHeaderWorkspace));

        }                       // for # buffers

        DebugPrint((DebugLevelFatal, "StreamClassGetPhysicalAddress: address not in SRB!\n"));

    default:
        DEBUG_BREAKPOINT();
        *Length = 0;
        address.QuadPart = (LONGLONG) 0;
        return (address);

    }                           // switch

}                               // end StreamClassGetPhysicalAddress()

VOID
StreamClassDebugAssert(
                       IN PCHAR File,
                       IN ULONG Line,
                       IN PCHAR AssertText,
                       IN ULONG AssertValue
)
/*++

Routine Description:

    This is the minidriver debug assert call.  When running a checked version
    of the class driver, asserts are recognized resulting in a debug
    message and breakpoint.  When running a free version of the port driver,
    asserts are ignored.

Arguments:
    File - file name where assert occurred
    Line - line number of assert
    AssertText - Text to be printed
    AssertValue - value to be printed

Return Value:

    none

--*/
{
    DebugPrint((DebugLevelError, "(%s:%d) Assert failed (%s)=0x%x\n", File, Line, AssertText, AssertValue));
    DbgBreakPoint();
}



VOID
SCRequestDpcForStream(
                      IN PSTREAM_OBJECT StreamObject

)
/*++

Routine Description:

    This routine places a stream object on the NeedyStream queue if it is
    not already there

Arguments:

    StreamObject - pointer to stream object

Return Value:

    none

--*/
{
    PDEVICE_EXTENSION DeviceExtension = StreamObject->DeviceExtension;

    //
    // add the stream to the queue of needy streams unless it is already
    // there.
    //

    #if DBG
    if (DeviceExtension->NeedyStream) {

        ASSERT(DeviceExtension->NeedyStream->OnNeedyQueue);
    }
    #endif

    ASSERT(StreamObject->NextNeedyStream != StreamObject);

    if (!(StreamObject->OnNeedyQueue)) {

        ASSERT(!StreamObject->NextNeedyStream);

        DebugPrint((DebugLevelVerbose, "'SCRequestDpc: Stream %x added to needy queue, Next = %x\n",
                    StreamObject, StreamObject->NextNeedyStream));

        StreamObject->OnNeedyQueue = TRUE;
        StreamObject->NextNeedyStream = DeviceExtension->NeedyStream;
        DeviceExtension->NeedyStream = StreamObject;

        ASSERT(StreamObject->NextNeedyStream != StreamObject);

    } else {

        DebugPrint((DebugLevelVerbose, "'SCRequestDpc: Stream %x already on needy queue\n",
                    StreamObject));
    }                           // if on needy queue

    StreamObject->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;

}



VOID
StreamClassAbortOutstandingRequests(
                                    IN PVOID HwDeviceExtension,
                                    IN PHW_STREAM_OBJECT HwStreamObject,
                                    IN NTSTATUS Status
)
/*++

Routine Description:

  aborts outstanding requests on the specified device or stream

Arguments:

  HwStreamObject - address of minidriver's stream struct
  HwDeviceExtension - device extension
  Status - NT Status to use for aborting

Return Value:

  none

--*/

{
    PSTREAM_OBJECT  StreamObject = NULL;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) HwDeviceExtension - 1;
    KIRQL           Irql;
    PLIST_ENTRY     SrbEntry,
                    ListEntry;
    PSTREAM_REQUEST_BLOCK CurrentSrb;
    PHW_STREAM_OBJECT CurrentHwStreamObject;
    PSTREAM_OBJECT  CurrentStreamObject;

    ASSERT(HwDeviceExtension != NULL);

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    if (HwStreamObject) {

        DEBUG_BREAKPOINT();
        StreamObject = CONTAINING_RECORD(HwStreamObject,
                                         STREAM_OBJECT,
                                         HwStreamObject);
    }
    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    DebugPrint((DebugLevelError, "StreamClassAbortOutstandingRequests.\n"));

    //
    // walk the outstanding queue and abort all requests on it.
    //

    SrbEntry = ListEntry = &DeviceExtension->OutstandingQueue;

    while (SrbEntry->Flink != ListEntry) {

        SrbEntry = SrbEntry->Flink;

        //
        // follow the link to the Srb
        //

        CurrentSrb = CONTAINING_RECORD(SrbEntry,
                                       STREAM_REQUEST_BLOCK,
                                       SRBListEntry);

        CurrentHwStreamObject = CurrentSrb->HwSRB.StreamObject;

        if ((!HwStreamObject) || (CurrentHwStreamObject ==
                                  HwStreamObject)) {


            //
            // abort this one and show that it's ready for a next request,
            // assuming it's active.  it might not be active if the
            // minidriver
            // just called it back.
            //

            if (CurrentSrb->Flags & SRB_FLAGS_IS_ACTIVE) {

                //
                // Clear the active flag.
                //

                CurrentSrb->Flags &= ~SRB_FLAGS_IS_ACTIVE;

                CurrentSrb->HwSRB.Status = Status;

                if (CurrentSrb->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST) {

                    CurrentStreamObject = CONTAINING_RECORD(
                                                      CurrentHwStreamObject,
                                                            STREAM_OBJECT,
                                                            HwStreamObject
                        );
                    //
                    // indicate that the appropriate queue is ready for a
                    // next
                    // request.
                    //

                    if (CurrentSrb->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER) {

                        CurrentStreamObject->ReadyForNextDataReq = TRUE;

                    } else {    // if data

                        CurrentStreamObject->ReadyForNextControlReq = TRUE;
                    }           // if data

                    DebugPrint((DebugLevelTrace, "'SCAbort: aborting stream IRP %x\n",
                                CurrentSrb->HwSRB.Irp));

                    //
                    // add the SRB to the list of completed stream SRB's.
                    //

                    CurrentSrb->HwSRB.NextSRB = CurrentStreamObject->ComObj.InterruptData.CompletedSRB;
                    CurrentStreamObject->ComObj.InterruptData.CompletedSRB = &CurrentSrb->HwSRB;

                    //
                    // add this stream to the queue of needy streams
                    //

                    SCRequestDpcForStream(CurrentStreamObject);

                } else {        // if stream

                    DebugPrint((DebugLevelTrace, "'SCAbort: aborting device IRP %x\n",
                                CurrentSrb->HwSRB.Irp));

                    //
                    // add the SRB to the list of completed device SRB's.
                    //

                    DEBUG_BREAKPOINT();
                    CurrentSrb->HwSRB.NextSRB = DeviceExtension->ComObj.InterruptData.CompletedSRB;
                    DeviceExtension->ComObj.InterruptData.CompletedSRB = &CurrentSrb->HwSRB;

                    DeviceExtension->ReadyForNextReq = TRUE;

                }               // if stream

            }                   // if active
        }                       // if aborting this one
    }                           // while list entry

    //
    // all necessary requests have been aborted.  exit.
    //

    END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);
}


PKSEVENT_ENTRY
StreamClassGetNextEvent(
                        IN PVOID HwInstanceExtension_OR_HwDeviceExtension,
                        IN OPTIONAL PHW_STREAM_OBJECT HwStreamObject,
                        IN OPTIONAL GUID * EventGuid,
                        IN OPTIONAL ULONG EventItem,
                        IN OPTIONAL PKSEVENT_ENTRY CurrentEvent
)
/*++

Routine Description:

Arguments:
    HwInstanceExtenion: was HwDeviceExtension. But we now support multiinstances.
    Therefore, we need the HwInstanceExtension instead for MF.

    CurrentEvent - event (if any) to get the next from

Return Value:

  next event, if any

--*/

{

    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(HwStreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject);

    PFILTER_INSTANCE FilterInstance;    
    PDEVICE_EXTENSION DeviceExtension;
    
    //(PDEVICE_EXTENSION) HwDeviceExtension - 1;
    PLIST_ENTRY     EventListEntry,
                    EventEntry;
    PKSEVENT_ENTRY  NextEvent,
                    ReturnEvent = NULL;
    KIRQL           Irql;

    //
    // see which is HwInstanceExtension_OR_HwDeviceExtension
    // need to try HwInstanceExtension first because is has a smaller
    // offset backward so we don't touch invalid memory.
    //
    // try
    FilterInstance = (PFILTER_INSTANCE) 
                     HwInstanceExtension_OR_HwDeviceExtension-1;
                     
    if ( SIGN_FILTER_INSTANCE != FilterInstance->Signature ) {
        //
        // single instance legacy driver
        //    
        DeviceExtension = (PDEVICE_EXTENSION)
                          HwInstanceExtension_OR_HwDeviceExtension -1;
                          
        ASSERT( 0 == DeviceExtension->MinidriverData->
                     HwInitData.FilterInstanceExtensionSize);

        if (DeviceExtension->NoSync) {
            KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);
        }

        if ( IsListEmpty( &DeviceExtension->FilterInstanceList ) ) {
			//
			// filter has been closed. but we are called. 
			// Single instance drivers do not receive open/close
			// they don't know when to sotp calling this. 
			// We need to check.
			//
			DebugPrint((DebugLevelWarning, "GetNextEvent no open filters\n"));
			
            if (DeviceExtension->NoSync) {
                KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
            }
            
			return NULL;
		}
		

        FilterInstance = (PFILTER_INSTANCE)
                         DeviceExtension->FilterInstanceList.Flink;

        if (DeviceExtension->NoSync) {
            KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
        }
                                           
        FilterInstance = CONTAINING_RECORD(FilterInstance,
                                           FILTER_INSTANCE,
                                           NextFilterInstance);
    }
    
    else {
        DeviceExtension = FilterInstance ->DeviceExtension;        
    }
    
    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }
    
    #endif
    //
    // take the spinlock if we are unsynchronized.
    //

    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    //
    // loop thru the events, trying to find the requested one.
    //

    if (HwStreamObject) {

        EventListEntry = EventEntry = &StreamObject->NotifyList;

    } else { 
    
        EventListEntry = EventEntry = &FilterInstance->NotifyList;
    }

    while (EventEntry->Flink != EventListEntry) {

        EventEntry = EventEntry->Flink;
        NextEvent = CONTAINING_RECORD(EventEntry,
                                      KSEVENT_ENTRY,
                                      ListEntry);


        if ((EventItem == NextEvent->EventItem->EventId) &&
            (!EventGuid || IsEqualGUIDAligned(EventGuid, NextEvent->EventSet->Set))) {

            //
            // if we are to return the 1st event which matches, break.
            //

            if (!CurrentEvent) {

                ReturnEvent = NextEvent;
                break;

            }                   // if !current
            //
            // if we are to return the next event after the specified one,
            // check
            // to see if these match.   If they do, zero the specified event
            // so
            // that we will return the next event of the specified type.
            //

            if (CurrentEvent == NextEvent) {
                CurrentEvent = NULL;

            }                   // if cur=next
        }                       // if guid & id match
    }                           // while events

    //
    // if we are unsynchronized, release the spinlock acquired in the macro
    // above.
    //

    ASSERT(--DeviceExtension->LowerApiThreads == 0); // typo barfs. but this is truely ok

    if (DeviceExtension->NoSync) {

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
    }
    //
    // return the next event, if any.
    //

    return (ReturnEvent);
}


VOID
StreamClassQueryMasterClock(
                            IN PHW_STREAM_OBJECT HwStreamObject,
                            IN HANDLE MasterClockHandle,
                            IN TIME_FUNCTION TimeFunction,
                            IN PHW_QUERY_CLOCK_ROUTINE ClockCallbackRoutine
)
/*++

Routine Description:

Arguments:

  HwStreamObject - address of minidriver's stream struct
  Context - value to pass into the time callback routine

Return Value:

  none

--*/

{

    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(HwStreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject);

    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) StreamObject->DeviceExtension;
    KIRQL           Irql;

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    BEGIN_MINIDRIVER_STREAM_CALLIN(DeviceExtension, &Irql);

    //
    // save away the parameters for the clock query.  The DPC will do the
    // actual processing.
    //

    StreamObject->ComObj.InterruptData.HwQueryClockRoutine = ClockCallbackRoutine;
    StreamObject->ComObj.InterruptData.HwQueryClockFunction = TimeFunction;

    StreamObject->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_CLOCK_QUERY_REQUEST;


    END_MINIDRIVER_STREAM_CALLIN(StreamObject, &Irql);
}

#if ENABLE_MULTIPLE_FILTER_TYPES
VOID
StreamClassFilterReenumerateStreams(
    IN PVOID HwInstanceExtension,
    IN ULONG StreamDescriptorSize )
/*++

    Description:

        Reenumerates all streams on the filter instance.
        This is used to increase the number of pins exposed to
        the world so that application can make connections on
        new streams exposed. It's caller's responsibility
        not to change the order of the streams that have been
        open ( connected ). If there is no reduction of the streams
        This won't be an issue.

    Arguments;

        HwInstanceExtension:
            The instanc extension pointer we gave to the mini driver

        StreamDecriptorSize:
            # of bytes to contain the new stream descriptor for the filter

    Return Valuse:

        None    
--*/
{
    PFILTER_INSTANCE    FilterInstance;
    PDEVICE_EXTENSION   DeviceExtension; 
    KIRQL               Irql;

    FilterInstance = ( PFILTER_INSTANCE ) HwInstanceExtension -1;
    DeviceExtension = FilterInstance->DeviceExtension;
    
    //
    // take the spinlock if we are unsynchronized.
    //

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }
    #   endif

    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    //
    // show that we need to rescan the stream info, and set the new size in
    // the config info structure.
    //

    DeviceExtension->ComObj.InterruptData.Flags |=
        INTERRUPT_FLAGS_NEED_STREAM_RESCAN;

    InterlockedExchange( &FilterInstance->NeedReenumeration, 1 );
    FilterInstance->StreamDescriptorSize = StreamDescriptorSize;

    //
    // queue a DPC to service the request.
    //

    END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);
    return;
}
#endif // ENABLE_MULTIPLE_FILTER_TYPES

VOID
StreamClassReenumerateStreams(
                              IN PVOID HwDeviceExtension,
                              IN ULONG StreamDescriptorSize
)
/*++

Routine Description:

    Reenumerates all streams on the device

Arguments:

    HwDeviceExtension - pointer to minidriver's device extension
    StreamDescriptorSize - size of the buffer needed by the minidriver to
     hold the stream info.

Return Value:

    none

--*/

{

    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) HwDeviceExtension - 1;
    KIRQL           Irql;

    //
    // take the spinlock if we are unsynchronized.
    //

    TRAP;
    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    //
    // show that we need to rescan the stream info, and set the new size in
    // the config info structure.
    //

    ASSERT(!DeviceExtension->ComObj.InterruptData.Flags &
           INTERRUPT_FLAGS_NEED_STREAM_RESCAN);

    DeviceExtension->ComObj.InterruptData.Flags |=
        INTERRUPT_FLAGS_NEED_STREAM_RESCAN;
    DeviceExtension->ConfigurationInformation->StreamDescriptorSize =
        StreamDescriptorSize;

    //
    // queue a DPC to service the request.
    //

    END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);
    return;
}



#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

// OK to have zero instances of pin In this case you will have to
// Create a pin to have even one instance
#define REG_PIN_B_ZERO 0x1

// The filter renders this input
#define REG_PIN_B_RENDERER 0x2

// OK to create many instance of  pin
#define REG_PIN_B_MANY 0x4

// This is an Output pin
#define REG_PIN_B_OUTPUT 0x8

typedef struct {
    ULONG           Version;
    ULONG           Merit;
    ULONG           Pins;
    ULONG           Reserved;
}               REGFILTER_REG;

typedef struct {
    ULONG           Signature;
    ULONG           Flags;
    ULONG           PossibleInstances;
    ULONG           MediaTypes;
    ULONG           MediumTypes;
    ULONG           CategoryOffset;
    ULONG           MediumOffset;   // By definition, we always have a Medium
    //#ifdef _WIN64
    //This method create filterdata that upset ring3 code.
    //ULONG           ulPad;        // align to quadword to make ia64 happy
    //#endif
}               REGFILTERPINS_REG2;


NTSTATUS
StreamClassRegisterFilterWithNoKSPins(
                                      IN PDEVICE_OBJECT DeviceObject,
                                      IN const GUID * InterfaceClassGUID,
                                      IN ULONG PinCount,
                                      IN BOOL * PinDirection,
                                      IN KSPIN_MEDIUM * MediumList,
                                      IN OPTIONAL GUID * CategoryList
)
/*++

Routine Description:

    This routine is used to register filters with DShow which have no
    KS pins and therefore do not stream in kernel mode.  This is typically
    used for TvTuners, Crossbars, and the like.  On exit, a new binary
    registry key, "FilterData" is created which contains the Mediums and
    optionally the Categories for each pin on the filter.

Arguments:

    DeviceObject -
           Device object

    InterfaceClassGUID
           GUID representing the class to register

    PinCount -
           Count of the number of pins on this filter

    PinDirection -
           Array of BOOLS indicating pin direction for each pin (length PinCount)
           If TRUE, this pin is an output pin

    MediumList -
           Array of PKSMEDIUM_DATA (length PinCount)

    CategoryList -
           Array of GUIDs indicating pin categories (length PinCount) OPTIONAL


Return Value:

    NTSTATUS SUCCESS if the Blob was created

--*/
{
    NTSTATUS        Status;
    ULONG           CurrentPin;
    ULONG           TotalCategories;
    REGFILTER_REG  *RegFilter;
    REGFILTERPINS_REG2 UNALIGNED * RegPin;
    GUID            UNALIGNED * CategoryCache;
    KSPIN_MEDIUM    UNALIGNED * MediumCache;
    ULONG           FilterDataLength;
    PUCHAR          FilterData;
    PWSTR           SymbolicLinkList;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    if ((PinCount == 0) || (!InterfaceClassGUID) || (!PinDirection) || (!MediumList)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    //
    // Calculate the maximum amount of space which could be taken up by
    // this cache data.
    //
    
    TotalCategories = (CategoryList ? PinCount : 0);

    FilterDataLength = sizeof(REGFILTER_REG) +
        PinCount * sizeof(REGFILTERPINS_REG2) +
        PinCount * sizeof(KSPIN_MEDIUM) +
        TotalCategories * sizeof(GUID);
    //
    // Allocate space to create the BLOB
    //

    FilterData = ExAllocatePool(PagedPool, FilterDataLength);
    if (!FilterData) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Place the header in the data, defaulting the Merit to "unused".
    //

    DebugPrint((DebugLevelTrace,
                "FilterData:%p\n",
                FilterData ));

    RegFilter = (REGFILTER_REG *) FilterData;
    RegFilter->Version = 2;
    RegFilter->Merit = 0x200000;
    RegFilter->Pins = PinCount;
    RegFilter->Reserved = 0;

    //
    // Calculate the offset to the list of pins, and to the
    // MediumList and CategoryList
    //

    RegPin = (REGFILTERPINS_REG2 *) (RegFilter + 1);
    MediumCache = (PKSPIN_MEDIUM) ((PUCHAR) (RegPin + PinCount));
    CategoryCache = (GUID *) (MediumCache + PinCount);

    //
    // Create each pin header, followed by the list of Mediums
    // followed by the list of optional categories.
    //

    for (CurrentPin = 0; CurrentPin < PinCount; CurrentPin++, RegPin++) {

        //
        // Initialize the pin header.
        //
        
        DebugPrint((DebugLevelTrace,
                    "CurrentPin:%d RegPin:%p MediumCache:%p CategoryCache:%p\n",
                    CurrentPin, RegPin, MediumCache, CategoryCache ));
                    
        RegPin->Signature = FCC('0pi3');
        (*(PUCHAR) & RegPin->Signature) += (BYTE) CurrentPin;
        RegPin->Flags = (PinDirection[CurrentPin] ? REG_PIN_B_OUTPUT : 0);
        RegPin->PossibleInstances = 1;
        RegPin->MediaTypes = 0;
        RegPin->MediumTypes = 1;
        RegPin->MediumOffset = (ULONG) ((PUCHAR) MediumCache - (PUCHAR) FilterData);

        *MediumCache++ = MediumList[CurrentPin];

        if (CategoryList) {
            RegPin->CategoryOffset = (ULONG) ((PUCHAR) CategoryCache - (PUCHAR) FilterData);
            *CategoryCache++ = CategoryList[CurrentPin];
        } else {
            RegPin->CategoryOffset = 0;
        }

    }

    //
    // Now create the BLOB in the registry
    //

	//
	// Note for using the flag DEVICE_INTERFACE_INCLUDE_NONACTIVE following:
	// PnP change circa 3/30/99 made the funtion IoSetDeviceInterfaceState() become
	// asynchronous. It returns SUCCESS even when the enabling is deferred. Now when
	// we arrive here, the DeviceInterface is still not enabled, we receive empty 
	// Symbolic link if the flag is not set. Here we only try to write relevent
	// FilterData to the registry. I argue this should be fine for 
	// 1. Currently, if a device is removed, the registry key for the DeviceClass
	//	  remains and with FilterData.Whatever components use the FilterData should
	//	  be able to handle if the device is removed by either check Control\Linked
	//	  or handling the failure in attempt to make connection to the non-exiting device.
	// 2. I have found that if a device is moved between slots ( PCI, USB ports ) the
	//	  DeviceInterface at DeviceClass is reused or at lease become the first entry in 
	//    the registry. Therefore, we will be updating the right entry with the proposed flag.
	//
    if (NT_SUCCESS(Status = IoGetDeviceInterfaces(
                       InterfaceClassGUID,   // ie.&KSCATEGORY_TVTUNER,etc.
                       DeviceObject, // IN PDEVICE_OBJECT PhysicalDeviceObject,OPTIONAL,
                       DEVICE_INTERFACE_INCLUDE_NONACTIVE,    // IN ULONG Flags,
                       &SymbolicLinkList // OUT PWSTR *SymbolicLinkList
                       ))) {
        UNICODE_STRING  SymbolicLinkListU;
        HANDLE          DeviceInterfaceKey;

        RtlInitUnicodeString(&SymbolicLinkListU, SymbolicLinkList);

        DebugPrint((DebugLevelVerbose,
                    "NoKSPin for SymbolicLink %S\n",
                    SymbolicLinkList ));
                    
        if (NT_SUCCESS(Status = IoOpenDeviceInterfaceRegistryKey(
                           &SymbolicLinkListU,    // IN PUNICODE_STRING SymbolicLinkName,
                           STANDARD_RIGHTS_ALL,   // IN ACCESS_MASK DesiredAccess,
                           &DeviceInterfaceKey    // OUT PHANDLE DeviceInterfaceKey
                           ))) {

            UNICODE_STRING  FilterDataString;

            RtlInitUnicodeString(&FilterDataString, L"FilterData");

            Status = ZwSetValueKey(DeviceInterfaceKey,
                                   &FilterDataString,
                                   0,
                                   REG_BINARY,
                                   FilterData,
                                   FilterDataLength);

            ZwClose(DeviceInterfaceKey);
        }
        
        // START NEW MEDIUM CACHING CODE
        for (CurrentPin = 0; CurrentPin < PinCount; CurrentPin++) {
            NTSTATUS LocalStatus;

            LocalStatus = KsCacheMedium(&SymbolicLinkListU, 
                                        &MediumList[CurrentPin],
                                        (DWORD) ((PinDirection[CurrentPin] ? 1 : 0))   // 1 == output
                                        );
            #if DBG
            if (LocalStatus != STATUS_SUCCESS) {
                DebugPrint((DebugLevelError,
                           "KsCacheMedium: SymbolicLink = %S, Status = %x\n",
                           SymbolicLinkListU.Buffer, LocalStatus));
            }
            #endif
        }
        // END NEW MEDIUM CACHING CODE
        
        ExFreePool(SymbolicLinkList);
    }
    ExFreePool(RegFilter);

    return Status;
}

BOOLEAN
StreamClassReadWriteConfig(
                           IN PVOID HwDeviceExtension,
                           IN BOOLEAN Read,
                           IN PVOID Buffer,
                           IN ULONG Offset,
                           IN ULONG Length
)
/*++

Routine Description:

    Sends down a config space read/write.   MUST BE CALLED AT PASSIVE LEVEL!

Arguments:

    HwDeviceExtension - device extension

    Read - TRUE if read, FALSE if write.

    Buffer - The info to read or write.

    Offset - The offset in config space to read or write.

    Length - The length to transfer.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP            irp;
    NTSTATUS        ntStatus;
    KEVENT          event;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) HwDeviceExtension - 1;
    PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;

    PAGED_CODE();

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    if (Read) {
        memset(Buffer, '\0', Length);
    }
    irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (!irp) {
        DebugPrint((DebugLevelError, "StreamClassRWConfig: no IRP.\n"));
        TRAP;
        return (FALSE);
    }

    //
    // new rule says all PnP Irp must be initialized to this
    //
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           SCSynchCompletionRoutine,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);


    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction = IRP_MJ_PNP;
    nextStack->MinorFunction = Read ? IRP_MN_READ_CONFIG : IRP_MN_WRITE_CONFIG;
    nextStack->Parameters.ReadWriteConfig.WhichSpace = 0;
    nextStack->Parameters.ReadWriteConfig.Buffer = Buffer;
    nextStack->Parameters.ReadWriteConfig.Offset = Offset;
    nextStack->Parameters.ReadWriteConfig.Length = Length;

    ASSERT( DeviceExtension->HwDeviceExtension == HwDeviceExtension );
    ntStatus = IoCallDriver(DeviceExtension->PhysicalDeviceObject,
                            irp);

    if (ntStatus == STATUS_PENDING) {
        // wait for irp to complete

        TRAP;
        KeWaitForSingleObject(
                              &event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
    }
    if (!NT_SUCCESS(ntStatus)) {
        DebugPrint((DebugLevelError, "StreamClassRWConfig: bad status!.\n"));
        TRAP;
    }
    IoFreeIrp(irp);
    return (TRUE);

}


VOID
StreamClassQueryMasterClockSync(
                                IN HANDLE MasterClockHandle,
                                IN OUT PHW_TIME_CONTEXT TimeContext
)
/*++

Routine Description:

  synchronously returns the current time requested, based on the TimeContext
  parameter.

Arguments:

Return Value:

  none

--*/

{

    PHW_STREAM_OBJECT HwStreamObject = TimeContext->HwStreamObject;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(HwStreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject);

    LARGE_INTEGER       ticks;
    ULONGLONG       rate;
    KIRQL           SavedIrql;

    ASSERT(MasterClockHandle);
    ASSERT(TimeContext->HwDeviceExtension);
    ASSERT(HwStreamObject);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Lock the use of MasterClock, so it won't dispear under us
    // 
    KeAcquireSpinLock( &StreamObject->LockUseMasterClock, &SavedIrql );

    if ( NULL == StreamObject->MasterClockInfo ) {
        //
        // If we are called when MasterClockInfo is NULL,
        // the mini driver has screwed up. We don't want to fault.
        //    
        ASSERT(0 && "Mini driver queries clock while there is no master clock" );
        //
        // give a hint that something is wrong via Time, since we return void.
        //
        TimeContext->Time = (ULONGLONG)-1;
        goto Exit;
    }

    //
    // process the requested time function
    //

    switch (TimeContext->Function) {

    case TIME_GET_STREAM_TIME:

        TimeContext->Time = StreamObject->MasterClockInfo->
            FunctionTable.GetCorrelatedTime(
                             StreamObject->MasterClockInfo->ClockFileObject,
                                            &TimeContext->SystemTime);
        break;


    case TIME_READ_ONBOARD_CLOCK:

        TRAP;

        TimeContext->Time = StreamObject->MasterClockInfo->
            FunctionTable.GetTime(
                            StreamObject->MasterClockInfo->ClockFileObject);

        //
        // timestamp the value as close as possible
        //

        ticks = KeQueryPerformanceCounter((PLARGE_INTEGER) & rate);

        TimeContext->SystemTime = KSCONVERT_PERFORMANCE_TIME( rate, ticks );
            

        break;

    default:
        DebugPrint((DebugLevelFatal, "SCQueryClockSync: unknown type!"));
        TRAP;
    }

Exit:
    KeReleaseSpinLock( &StreamObject->LockUseMasterClock, SavedIrql );
    return;
}

VOID
StreamClassCompleteRequestAndMarkQueueReady(
                                            IN PHW_STREAM_REQUEST_BLOCK Srb
)
/*++

Routine Description:

  completes a stream request and marks the appropriate queue as ready for next

Arguments:

Return Value:

  none

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) Srb->HwDeviceExtension - 1;

    ASSERT(!(DeviceExtension->NoSync));

    ASSERT(Srb->Status != STATUS_PENDING);

    DebugPrint((DebugLevelTrace, "'StreamClassComplete&Mark:SRB = %p\n",
                Srb));

    switch (Srb->Flags & (SRB_HW_FLAGS_DATA_TRANSFER |
                          SRB_HW_FLAGS_STREAM_REQUEST)) {

    case SRB_HW_FLAGS_STREAM_REQUEST | SRB_HW_FLAGS_DATA_TRANSFER:

        StreamClassStreamNotification(StreamRequestComplete,
                                      Srb->StreamObject,
                                      Srb);

        StreamClassStreamNotification(ReadyForNextStreamDataRequest,
                                      Srb->StreamObject);

        break;

    case SRB_HW_FLAGS_STREAM_REQUEST:


        StreamClassStreamNotification(StreamRequestComplete,
                                      Srb->StreamObject,
                                      Srb);

        StreamClassStreamNotification(ReadyForNextStreamControlRequest,
                                      Srb->StreamObject);

        break;

    default:


        StreamClassDeviceNotification(DeviceRequestComplete,
                                      Srb->HwDeviceExtension,
                                      Srb);

        StreamClassDeviceNotification(ReadyForNextDeviceRequest,
                                      Srb->HwDeviceExtension);

        break;

    }                           // switch

}

#if ENABLE_MULTIPLE_FILTER_TYPES

VOID STREAMAPI
StreamClassFilterNotification(
	IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwInstanceExtension,
    ...
);

VOID STREAMAPI
StreamClassFilterScheduleTimer(
    IN PVOID HwInstanceExtension,
    IN ULONG NumberOfMicroseconds,
    IN PHW_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
);


PKSEVENT_ENTRY
StreamClassDeviceInstanceGetNextEvent(
    IN PVOID HwInstanceExtension,
    IN OPTIONAL GUID * EventGuid,
	IN OPTIONAL ULONG EventItem,
    IN OPTIONAL PKSEVENT_ENTRY CurrentEvent
)
/*++

Routine Description:

Arguments:

    CurrentEvent - event (if any) to get the next from

Return Value:

  next event, if any

--*/
{
	PFILTER_INSTANCE FilterInstance= (PFILTER_INSTANCE)
										HwInstanceExtension - 1;
    PDEVICE_EXTENSION DeviceExtension =
					    FilterInstance->DeviceObject->DeviceExtension;
    PLIST_ENTRY     EventListEntry, EventEntry;
    PKSEVENT_ENTRY  NextEvent, ReturnEvent = NULL;
    KIRQL           Irql;

	#if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
	#endif

    //
    // take the spinlock if we are unsynchronized.
    //

    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    //
    // loop thru the events, trying to find the requested one.
    //

    EventListEntry = EventEntry = &FilterInstance->NotifyList;

    while (EventEntry->Flink != EventListEntry) {

        EventEntry = EventEntry->Flink;
        NextEvent = CONTAINING_RECORD(EventEntry,
                                      KSEVENT_ENTRY,
                                      ListEntry);


        if ((EventItem == NextEvent->EventItem->EventId) &&
            (!EventGuid || IsEqualGUIDAligned(EventGuid, NextEvent->EventSet->Set))) {

            //
            // if we are to return the 1st event which matches, break.
            //

            if (!CurrentEvent) {

                ReturnEvent = NextEvent;
                break;

            }                   // if !current
            //
            // if we are to return the next event after the specified one,
            // check
            // to see if these match.   If they do, zero the specified event
            // so
            // that we will return the next event of the specified type.
            //

            if (CurrentEvent == NextEvent) {
                CurrentEvent = NULL;

            }                   // if cur=next
        }                       // if guid & id match
    }                           // while events

    //
    // if we are unsynchronized, release the spinlock acquired in the macro
    // above.
    //

    ASSERT(--DeviceExtension->LowerApiThreads == 0); // typo barfs. but this is truely ok.

    if (DeviceExtension->NoSync) {

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
    }
    //
    // return the next event, if any.
    //

    return (ReturnEvent);
}


#endif // ENABLE_MULTIPLE_FILTER_TYPES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\dvd\class\codinit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   codinit.c

Abstract:

   This is the WDM streaming class driver.  This module contains code related
   to driver initialization.

Author:

    billpa

Environment:

   Kernel mode only


Revision History:

--*/

#include "codcls.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, StreamClassRegisterAdapter)

#if ENABLE_MULTIPLE_FILTER_TYPES
//#pragma alloc_text(PAGE, StreamClassRegisterNameExtensions)
#endif

#pragma alloc_text(PAGE, StreamClassPnPAddDevice)
#pragma alloc_text(PAGE, StreamClassPnPAddDeviceWorker)
#pragma alloc_text(PAGE, StreamClassPnP)
#pragma alloc_text(PAGE, SCStartWorker)
#pragma alloc_text(PAGE, SCUninitializeMinidriver)
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SCFreeAllResources)
#pragma alloc_text(PAGE, SCInitializeCallback)
#pragma alloc_text(PAGE, SCStreamInfoCallback)
#pragma alloc_text(PAGE, SCUninitializeCallback)
#pragma alloc_text(PAGE, SCUnknownPNPCallback)
#pragma alloc_text(PAGE, SCUnknownPowerCallback)
#pragma alloc_text(PAGE, SciQuerySystemPowerHiberCallback)
#pragma alloc_text(PAGE, SCInsertStreamInfo)
#pragma alloc_text(PAGE, SCPowerCallback)
#pragma alloc_text(PAGE, SCCreateSymbolicLinks)
#pragma alloc_text(PAGE, SCDestroySymbolicLinks)
#pragma alloc_text(PAGE, SCCreateChildPdo)
#pragma alloc_text(PAGE, SCEnumerateChildren)
#pragma alloc_text(PAGE, SCEnumGetCaps)
#pragma alloc_text(PAGE, SCQueryEnumId)
#pragma alloc_text(PAGE, StreamClassForwardUnsupported)
#pragma alloc_text(PAGE, SCPowerCompletionWorker)
#pragma alloc_text(PAGE, SCSendSurpriseNotification)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

static const WCHAR EnumString[] = L"Enum";
static const WCHAR PnpIdString[] = L"PnpId";

//
// To make the bus enumeration code more readable:
//
//    STREAM_BUSENUM_STRING: The prepended enumerator string
//    STREAM_BUSENUM_STRING_LENGTH: The length of the above string in WCHARS
//    STREAM_BUSENUM_SEPARATOR_LENGTH: The length of the separator "#" string
//                                       in WCHARS
//
#define STREAM_BUSENUM_STRING L"Stream\\"
#define STREAM_BUSENUM_STRING_LENGTH \
    ((sizeof (STREAM_BUSENUM_STRING) - 1) / sizeof (WCHAR))
#define STREAM_BUSENUM_SEPARATOR_LENGTH 1

// CleanUp - the following three strings should go away

static const WCHAR ClsIdString[] = L"CLSID";
static const WCHAR DriverDescString[] = L"DriverDesc";
static const WCHAR FriendlyNameString[] = L"FriendlyName";

static const WCHAR DeviceTypeName[] = L"GLOBAL";

static const    DEFINE_KSCREATE_DISPATCH_TABLE(CreateItems)
{
    DEFINE_KSCREATE_ITEM(
                         FilterDispatchGlobalCreate,
                         DeviceTypeName,
                         NULL),
};

//
// list anchor for global minidriver info.
//

DEFINE_KSPIN_INTERFACE_TABLE(PinInterfaces)
{
    DEFINE_KSPIN_INTERFACE_ITEM(
                                KSINTERFACESETID_Standard,
                                KSINTERFACE_STANDARD_STREAMING),
};

DEFINE_KSPIN_MEDIUM_TABLE(PinMediums)
{
    DEFINE_KSPIN_MEDIUM_ITEM(
                             KSMEDIUMSETID_Standard,
                             KSMEDIUM_TYPE_ANYINSTANCE),
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

NTSTATUS
StreamClassRegisterAdapter(
                           IN PVOID Argument1,
                           IN PVOID Argument2,
                           IN PHW_INITIALIZATION_DATA HwInitializationData
)
/*++

Routine Description:

    This routine registers a new streaming minidriver.

Arguments:
    Argument1 - Pointer to driver object created by system.
    Argument2 - Pointer to a UNICODE string of the registry path created
            by system.
    HwInitializationData - Minidriver initialization structure.

Return Value:

    Returns STATUS_SUCCESS if successful

--*/
{
    NTSTATUS        Status;

    PDRIVER_OBJECT  driverObject = Argument1;
    PDEVICE_EXTENSION deviceExtension = NULL;
    PMINIDRIVER_INFORMATION pMinidriverInfo;

    PAGED_CODE();

    DebugPrint((DebugLevelVerbose, "'StreamClassInitialize: enter\n"));

    //
    // Check that the length of this structure is what the
    // port driver expects it to be. This is effectively a
    // version check.
    //
    #if ENABLE_MULTIPLE_FILTER_TYPES
    //
    // we split the ULONG HwInitializationDataSize into two ushorts, one for 
    // SizeOfThisPacket, another for StreamClassVersion which must be 0x0200 to
    // indicate the two reserved fields now NumNameExtesnions and NameExtensionArray,
    // contain valid information.
    //
     
    if (HwInitializationData->SizeOfThisPacket != sizeof(HW_INITIALIZATION_DATA) ||
        ( HwInitializationData->StreamClassVersion != 0 &&
          HwInitializationData->StreamClassVersion != STREAM_CLASS_VERSION_20)) {
          
        DebugPrint((DebugLevelFatal, "StreamClassInitialize: Minidriver wrong version\n"));
        SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_CLASS_MINIDRIVER_MISMATCH, 0x1002);
        ASSERT( 0 );
        return (STATUS_REVISION_MISMATCH);
    }
    
    #else // ENABLE_MULTIPLE_FILTER_TYPES
    
    if (HwInitializationData->HwInitializationDataSize < sizeof(HW_INITIALIZATION_DATA)) {
        DebugPrint((DebugLevelFatal, "StreamClassInitialize: Minidriver wrong version\n"));
        SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_CLASS_MINIDRIVER_MISMATCH, 0x1002);
        ASSERT( 0 );
        return (STATUS_REVISION_MISMATCH);
    }
    #endif // ENABLE_MULTIPLE_FILTER_TYPES
    
    //
    // Check that each required entry is not NULL.
    //

    if ((!HwInitializationData->HwReceivePacket) ||
        (!HwInitializationData->HwRequestTimeoutHandler)) {
        DebugPrint((DebugLevelFatal,
                    "StreamClassInitialize: Minidriver driver missing required entry\n"));
        SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_MINIDRIVER_MISSING_ENTRIES, 0x1003);
        return (STATUS_REVISION_MISMATCH);
    }
    //
    // set up dummy routines for each unsupported function
    //

    if (!HwInitializationData->HwCancelPacket) {
        HwInitializationData->HwCancelPacket = SCDummyMinidriverRoutine;
    }
    //
    // Set up the device driver entry points.
    //

    driverObject->MajorFunction[IRP_MJ_PNP] = StreamClassPnP;
    driverObject->MajorFunction[IRP_MJ_POWER] = StreamClassPower;
    driverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = StreamClassForwardUnsupported;
    // TODO: remove this once KS can multiplex cleanup Irps
    driverObject->MajorFunction[IRP_MJ_CLEANUP] = StreamClassCleanup;
    driverObject->DriverUnload = KsNullDriverUnload;
    driverObject->DriverExtension->AddDevice = StreamClassPnPAddDevice;

    //
    // set ioctl interface
    //
    driverObject->MajorFunction[IRP_MJ_CREATE] = StreamClassPassThroughIrp;
    driverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = 
        StreamClassPassThroughIrp;
    driverObject->MajorFunction[IRP_MJ_CLOSE] = StreamClassPassThroughIrp;
    driverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = 
        StreamClassPassThroughIrp;

    //
    // Allocate a driver object extension to contain the minidriver's
    // vectors.
    //

    Status = IoAllocateDriverObjectExtension(driverObject,
                                             (PVOID) StreamClassPnP,
                                             sizeof(MINIDRIVER_INFORMATION),
                                             &pMinidriverInfo);

    if (!NT_SUCCESS(Status)) {
        DebugPrint((DebugLevelError,
                    "StreamClassInitialize: No pool for global info"));
        SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_NO_GLOBAL_INFO_POOL, 0x1004);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlZeroMemory(pMinidriverInfo, sizeof(MINIDRIVER_INFORMATION));

    RtlCopyMemory(pMinidriverInfo, HwInitializationData,
                  sizeof(HW_INITIALIZATION_DATA));

    #if ENABLE_MULTIPLE_FILTER_TYPES
    if ( HwInitializationData->StreamClassVersion != STREAM_CLASS_VERSION_20 ) {
        //
        // name extension not supplied.
        //
        pMinidriverInfo->HwInitData.NumNameExtensions = 0;
        pMinidriverInfo->HwInitData.NameExtensionArray = NULL;
    }

    else {
        //
        // ver20, should have filter extension size
        // 
        if ( 0 == pMinidriverInfo->HwInitData.FilterInstanceExtensionSize ) {
            DebugPrint((DebugLevelWarning, "Version 20 driver should not "
                        " have FilterInstanceExtensionSize 0" ));
            pMinidriverInfo->HwInitData.FilterInstanceExtensionSize = 4;
        }
    }
    #endif

    //
    // initialize the control event for this driver
    //

    KeInitializeEvent(&pMinidriverInfo->ControlEvent,
                      SynchronizationEvent,
                      TRUE);

    return STATUS_SUCCESS;
}

NTSTATUS
StreamClassPassThroughIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Pass through all Irps before being multiplexed through KS.  If the device
    cannot handle the request right now (the device is in a low power state
    like D3), queue the Irp and complete it later.

Arguments:

    DeviceObject -
        The device object

    Irp -
        The Irp in question

Return Value:

    Either STATUS_PENDING or per the KS multiplex

--*/

{

    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
        DeviceObject -> DeviceExtension;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Block user mode requests here in D3.  Queue kernel mode ones.
    //
    if (Irp -> RequestorMode == UserMode) {

        //
        // Only do this rigmarole if we look to be outside D0.
        //
        if (DeviceExtension -> CurrentPowerState != PowerDeviceD0) {

            //
            // Handle PowerDownUnopened cases specially since they don't
            // actually go into D0 until an instance is opened.  We cannot
            // block an open request in that case.
            //
            if (DeviceExtension -> RegistryFlags & 
                DEVICE_REG_FL_POWER_DOWN_CLOSED) {

                KIRQL OldIrql;

                KeAcquireSpinLock (&DeviceExtension -> PowerLock, &OldIrql);

                if (DeviceExtension -> CurrentSystemState == 
                        PowerSystemWorking &&
                    DeviceExtension -> CurrentPowerState !=
                        PowerDeviceD0)  {

                    KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

                    //
                    // If we got here, the Irp must pass through as transition
                    // to D0 is keyed off it.
                    //
                    return KsDispatchIrp (DeviceObject, Irp);

                }

                KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

                //
                // At this point, we're not sleeping and not in SystemWorking.
                // We're safe to block.  Yes -- this might be an open -- and
                // yes -- we might transition to SystemWorking before the
                // KeWaitForSingleObject; however -- if that's the case, 
                // this **Notification** event will be signalled by that
                // transition and we don't block the D0 key Irp.
                //

            }

            ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);

            //
            // At this point, it appeared that we weren't in D0.  Block this
            // thread until the device actually wakes.  It doesn't matter if
            // a state transition happened between the time we check and now
            // since this is a notification event.
            //
            KeWaitForSingleObject (
                &DeviceExtension -> BlockPoweredDownEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );

        }

        return KsDispatchIrp (DeviceObject, Irp);
    
    }

    //
    // If we're in a low power state, queue the Irp and redispatch it later.
    //
    if (DeviceExtension -> CurrentPowerState != PowerDeviceD0) {
        //
        // Guard against PM changes while we're queueing the Irp.  I don't 
        // want to get pre-empted before adding it to the queue, redispatch
        // a bunch of Irps, and THEN have this one queued only to be lost
        // until the next power transition.
        //
        // As an optimization, only grab the spinlock when it looks like we
        // care.  I don't want to spinlock on every Irp.
        //
        KIRQL OldIrql;
        KeAcquireSpinLock (&DeviceExtension -> PowerLock, &OldIrql);

        //
        // DEVICE_REG_FL_POWER_DOWN_CLOSED devices will not power up until
        // an open happens and they power down when not opened.  We cannot
        // queue creates on them unless they are not in D0 due to an actual
        // S-state transition.  This is guarded against racing with an 
        // S-state transition by the PowerLock spinlock.
        //  
        // NOTE: this will implicitly only allow creates to pass in non-D0
        // for these power down closed devices because the only way we are
        // in D3 / SystemWorking for these devices is when there are no opens
        // currently on the device.  Any Irp that comes through here at that
        // time will be a create.
        //
        if (DeviceExtension -> CurrentPowerState != PowerDeviceD0 &&
            !((DeviceExtension -> RegistryFlags & 
                    DEVICE_REG_FL_POWER_DOWN_CLOSED) &&
                DeviceExtension -> CurrentSystemState == PowerSystemWorking)) {
    
            IoMarkIrpPending (Irp);
    
            KsAddIrpToCancelableQueue (
                &DeviceExtension -> PendedIrps,
                &DeviceExtension -> PendedIrpsLock,
                Irp,
                KsListEntryTail,
                NULL
                );

            KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

            return STATUS_PENDING;

        }

        KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

    }

    return KsDispatchIrp (DeviceObject, Irp);

}

void
SCRedispatchPendedIrps (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN FailRequests
    )

/*++

Routine Description:

    Redispatch any Irps that were queued as a result of the device being
    unavailable.

Arguments:

    DeviceExtension -
        The device extension

    FailRequests -
        Indication of whether to fail the requests or redispatch them
        to the device.

Return Value:

    None

--*/

{

    PIRP Irp;

    //
    // If we redispatch for any reason, allow Irps through.
    //
    KeSetEvent (
        &DeviceExtension -> BlockPoweredDownEvent, 
        IO_NO_INCREMENT, 
        FALSE
        );

    Irp = KsRemoveIrpFromCancelableQueue (
        &DeviceExtension -> PendedIrps,
        &DeviceExtension -> PendedIrpsLock,
        KsListEntryHead,
        KsAcquireAndRemove
        );

    while (Irp) {
        //
        // If we were to fail the requests instead of redispatching, do
        // this for everything but close Irps.
        //
        PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
        if (FailRequests &&
            IrpSp -> MajorFunction != IRP_MJ_CLOSE) {

            Irp -> IoStatus.Status = STATUS_DEVICE_BUSY;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
        }
        else {
            KsDispatchIrp (DeviceExtension -> DeviceObject, Irp);
        }

        Irp = KsRemoveIrpFromCancelableQueue (
            &DeviceExtension -> PendedIrps,
            &DeviceExtension -> PendedIrpsLock,
            KsListEntryHead,
            KsAcquireAndRemove
            );

    }

}

void
SCSetCurrentDPowerState (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN DEVICE_POWER_STATE PowerState
    )

{
    KIRQL OldIrql;

    KeAcquireSpinLock (&DeviceExtension->PowerLock, &OldIrql);
    //
    // On any transition out of D0, block user mode requests until we're back
    // in D0.
    //
    if (PowerState != PowerDeviceD0) {
        KeResetEvent (&DeviceExtension->BlockPoweredDownEvent);
    }
    DeviceExtension->CurrentPowerState = PowerState;
    KeReleaseSpinLock (&DeviceExtension->PowerLock, OldIrql);
}

void
SCSetCurrentSPowerState (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN SYSTEM_POWER_STATE PowerState
    )

{
    KIRQL OldIrql;

    KeAcquireSpinLock (&DeviceExtension->PowerLock, &OldIrql);
    DeviceExtension->CurrentSystemState = PowerState;
    KeReleaseSpinLock (&DeviceExtension->PowerLock, OldIrql);

}

NTSTATUS
StreamClassPnPAddDevice(
                        IN PDRIVER_OBJECT DriverObject,
                        IN PDEVICE_OBJECT PhysicalDeviceObject
)
/*++

Routine Description:

    This routine is called to create a new instance of the streaming minidriver

Arguments:

    DriverObject - Pointer to our driver object

    PhysicalDeviceObject - Pointer to Device Object created by parent

Return Value:

    Returns status of the worker routine.

--*/

{

    PDEVICE_EXTENSION DeviceExtension;

    PAGED_CODE();

    //
    // call the worker routine and return its status
    //

    return (StreamClassPnPAddDeviceWorker(DriverObject,
                                          PhysicalDeviceObject,
                                          &DeviceExtension));
}

NTSTATUS
StreamClassPnPAddDeviceWorker(
                              IN PDRIVER_OBJECT DriverObject,
                              IN PDEVICE_OBJECT PhysicalDeviceObject,
                          IN OUT PDEVICE_EXTENSION * ReturnedDeviceExtension
)
/*++

Routine Description:

    This routine is the worker for processing the PNP add device call.

Arguments:

    DriverObject - Pointer to our driver object

    PhysicalDeviceObject - Pointer to Device Object created by parent

    ReturnedDeviceExtension - pointer to the minidriver's extension

Return Value:

    Status is returned.

--*/

{
    PMINIDRIVER_INFORMATION pMinidriverInfo;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS        Status;
    PDEVICE_OBJECT  DeviceObject,
                    AttachedPdo;

    PAGED_CODE();

    DebugPrint((DebugLevelVerbose, "StreamClassAddDevice: enter\n"));

    pMinidriverInfo = IoGetDriverObjectExtension(DriverObject,
                                                 (PVOID) StreamClassPnP);


    if (pMinidriverInfo == NULL) {
        DebugPrint((DebugLevelError,
                    "StreamClassAddDevice: No minidriver info"));
                    
        SCLogError((PDEVICE_OBJECT) DriverObject, 0, CODCLASS_NO_MINIDRIVER_INFO, 0x1004);
        return (STATUS_DEVICE_DOES_NOT_EXIST);
    }
    //
    // bump the add count in the minidriver object
    //

    pMinidriverInfo->OpenCount++;

    //
    // Create our device object with a our STREAM specific device extension
    // No need to name it thanks to Plug N Play.
    //

    Status = IoCreateDevice(
                            DriverObject,
                            sizeof(DEVICE_EXTENSION) +
                            pMinidriverInfo->HwInitData.DeviceExtensionSize,
                            NULL,
                            FILE_DEVICE_KS,
                            FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &DeviceObject
        );

    if (!NT_SUCCESS(Status)) {

        return (Status);

    }
    //
    // Attach ourself into the driver stack on top of our parent.
    //

    AttachedPdo = IoAttachDeviceToDeviceStack(DeviceObject, PhysicalDeviceObject);

    if (!(AttachedPdo)) {

        DEBUG_BREAKPOINT();
        DebugPrint((DebugLevelFatal, "StreamClassAddDevice: could not attach"));
        IoDeleteDevice(DeviceObject);
        return (Status);

    }
    *ReturnedDeviceExtension = DeviceExtension = DeviceObject->DeviceExtension;

    (*ReturnedDeviceExtension)->Signature = SIGN_DEVICE_EXTENSION;
    (*ReturnedDeviceExtension)->Signature2 = SIGN_DEVICE_EXTENSION;

    //
    // set the minidriver info in the device extension
    //

    DeviceExtension->AttachedPdo = AttachedPdo;

    //
    // set the I/O counter
    //

    DeviceExtension->OneBasedIoCount = 1;

    DeviceExtension->DriverInfo = pMinidriverInfo;

    //
    // Initialize timer.
    //

    IoInitializeTimer(DeviceObject, StreamClassTickHandler, NULL);

    ///
    /// move from start device, we could have child PDO if we start and stop
    ///
    InitializeListHead(&DeviceExtension->Children);
       
    //
    // Moved from StartDevice. We use the control event at Remove_device
    // which can come in before the device starts.
    //
    KeInitializeEvent(&DeviceExtension->ControlEvent,
                      SynchronizationEvent,
                      TRUE);

    //
    // set the current power state to D0
    //

    DeviceExtension->CurrentPowerState = PowerDeviceD0;
    DeviceExtension->CurrentSystemState = PowerSystemWorking;

    //
    // fill in the minidriver info pointer to the dev extension
    //

    DeviceExtension->MinidriverData = pMinidriverInfo;

    //
    // keep this handy
    //
    DeviceExtension->FilterExtensionSize = 
        pMinidriverInfo->HwInitData.FilterInstanceExtensionSize;

    DeviceExtension->DeviceObject = DeviceObject;
    DeviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    DeviceExtension->HwDeviceExtension = (PVOID) (DeviceExtension + 1);

    //
    // Initialize the pended Irp list.
    //
    InitializeListHead (&DeviceExtension -> PendedIrps);
    KeInitializeSpinLock (&DeviceExtension -> PendedIrpsLock);
    KeInitializeSpinLock (&DeviceExtension -> PowerLock);
    KeInitializeEvent (&DeviceExtension -> BlockPoweredDownEvent, NotificationEvent, TRUE);

    //
    // Mark this object as supporting direct I/O so that I/O system
    // will supply mdls in read/write irps.
    //

    DeviceObject->Flags |= DO_DIRECT_IO;

    {
		PKSOBJECT_CREATE_ITEM 	pCreateItems;
		PWCHAR					*NameInfo;
		ULONG					i;
		ULONG                   NumberOfFilterTypes;
		PFILTER_TYPE_INFO FilterTypeInfo;
	    //
    	// build an on-the-fly table of name extensions (including "GLOBAL"),
    	// from the minidriver's table.
    	//

        InitializeListHead( &DeviceExtension->FilterInstanceList );
        
        NumberOfFilterTypes = pMinidriverInfo->HwInitData.NumNameExtensions;
        DeviceExtension->NumberOfNameExtensions = NumberOfFilterTypes;
        if ( 0 == NumberOfFilterTypes ) {
            NumberOfFilterTypes = 1;
        }

        DebugPrint((DebugLevelVerbose,
                   "Sizeof(FILTER_TYPE_INFO)=%x\n",
                   sizeof(FILTER_TYPE_INFO)));
                   
    	FilterTypeInfo = ExAllocatePool(NonPagedPool, 
                                   (sizeof(FILTER_TYPE_INFO) +
                                    sizeof(KSOBJECT_CREATE_ITEM))*
                                    NumberOfFilterTypes);

	    if (!(FilterTypeInfo)) {

    	    DebugPrint((DebugLevelFatal, 
    	               "StreamClassAddDevice: could not alloc createitems"));
	        TRAP;
    	    IoDetachDevice(DeviceExtension->AttachedPdo);
	        IoDeleteDevice(DeviceObject);
	        return (Status);
    	}

    	pCreateItems = (PKSOBJECT_CREATE_ITEM)(FilterTypeInfo+NumberOfFilterTypes);

        DebugPrint((DebugLevelVerbose,
                   "FilterTypeInfo@%x,pCreateItems@%x\n",
                   FilterTypeInfo,pCreateItems ));        


        DeviceExtension->NumberOfFilterTypes = NumberOfFilterTypes;
    	DeviceExtension->FilterTypeInfos = FilterTypeInfo;

	    //
	    // first copy the single default create item.   
	    //
	    ASSERT( sizeof(CreateItems) == sizeof(KSOBJECT_CREATE_ITEM));

	    RtlCopyMemory(pCreateItems, CreateItems, sizeof (KSOBJECT_CREATE_ITEM));

	    //
	    // now construct the rest of the table based on the minidriver's values.
	    //

	    NameInfo = pMinidriverInfo->HwInitData.NameExtensionArray;

	    for (i = 0; 
    	     i < DeviceExtension->NumberOfNameExtensions; 
        	 i++, NameInfo++) {

        	 LONG StringLength;
                  
	         StringLength = wcslen(*NameInfo)*sizeof(WCHAR);

    	     pCreateItems[i].ObjectClass.Length = (USHORT)StringLength;
	         pCreateItems[i].ObjectClass.MaximumLength = (USHORT)(StringLength + sizeof(UNICODE_NULL));
    	     pCreateItems[i].ObjectClass.Buffer = *NameInfo;
        	 pCreateItems[i].Create = FilterDispatchGlobalCreate;        
	         pCreateItems[i].Context = ULongToPtr(i);
	         pCreateItems[i].SecurityDescriptor = NULL;
	         pCreateItems[i].Flags = 0;

	    } // for # createitems
	    DeviceExtension->CreateItems = pCreateItems;
	    KsAllocateDeviceHeader(&DeviceExtension->ComObj.DeviceHeader,
                           i==0 ? 1: i,
                           (PKSOBJECT_CREATE_ITEM) pCreateItems);

    }

    //
    // set the flag indicating whether we need to do synchronization.
    //

    DeviceExtension->NoSync =
        pMinidriverInfo->HwInitData.TurnOffSynchronization;

    //
    // presuppose we will need synchronization.
    //

    #if DBG
    DeviceExtension->SynchronizeExecution = SCDebugKeSynchronizeExecution;
    #else
    DeviceExtension->SynchronizeExecution = KeSynchronizeExecution;
    #endif

    //
    // set the synchronized minidriver callin routine vectors
    //

    DeviceExtension->BeginMinidriverCallin = (PVOID) SCBeginSynchronizedMinidriverCallin;
    DeviceExtension->EndMinidriverDeviceCallin = (PVOID) SCEndSynchronizedMinidriverDeviceCallin;
    DeviceExtension->EndMinidriverStreamCallin = (PVOID) SCEndSynchronizedMinidriverStreamCallin;

    if (DeviceExtension->NoSync) {

        //
        // we won't do synchronization, so use the dummy sync routine.
        //

        DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;
        DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

        //
        // set the unsynchronized minidriver callin routine vectors
        //


        DeviceExtension->BeginMinidriverCallin = (PVOID) SCBeginUnsynchronizedMinidriverCallin;
        DeviceExtension->EndMinidriverDeviceCallin = (PVOID) SCEndUnsynchronizedMinidriverDeviceCallin;
        DeviceExtension->EndMinidriverStreamCallin = (PVOID) SCEndUnsynchronizedMinidriverStreamCallin;

    }
    //
    // read registry settings for this adapter
    //

    SCReadRegistryValues(DeviceExtension, PhysicalDeviceObject);

    //
    // if the device cannot be paged out when closed, turn off this feature
    // for the whole driver
    //

    if (!(DeviceExtension->RegistryFlags & DEVICE_REG_FL_PAGE_CLOSED)) {

        pMinidriverInfo->Flags |= DRIVER_FLAGS_NO_PAGEOUT;
    }
    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    DeviceObject->Flags |= DO_POWER_PAGABLE;

    DebugPrint((DebugLevelVerbose, "StreamClassAddDevice: leave\n"));

    return (STATUS_SUCCESS);

}

NTSTATUS
StreamClassPnP(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
)
/*++

Routine Description:

    This routine processes the various Plug N Play messages

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    NTSTATUS        Status;
    PHW_INITIALIZATION_DATA HwInitData;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack,
                    NextStack;
    BOOLEAN         RequestIssued;
    DEVICE_CAPABILITIES DeviceCapabilities;

    PAGED_CODE();

    DeviceExtension = DeviceObject->DeviceExtension;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // check to see if the device is a child
    //
    
	DebugPrint((DebugLevelVerbose, "'SCPNP:DevObj=%x,Irp=%x\n",DeviceObject, Irp ));
	
    if (DeviceExtension->Flags & DEVICE_FLAGS_CHILD) {

        PCHILD_DEVICE_EXTENSION ChildExtension = (PCHILD_DEVICE_EXTENSION) DeviceExtension;

        switch (IrpStack->MinorFunction) {

        case IRP_MN_QUERY_INTERFACE:

            IoCopyCurrentIrpStackLocationToNext( Irp );

            DebugPrint((DebugLevelInfo, 
                       "Child PDO=%x forwards Query_Interface to Parent FDO=%x\n",
                       DeviceObject,
                       ChildExtension->ParentDeviceObject));
            
            return (IoCallDriver(ChildExtension->ParentDeviceObject,
                                 Irp));

        case IRP_MN_START_DEVICE:
        	DebugPrint((DebugLevelInfo,
        	            "StartChild DevObj=%x Flags=%x\n" 
        	            ,DeviceObject,
        	            ChildExtension->Flags ));
            ChildExtension->Flags &= ~DEVICE_FLAGS_CHILD_MARK_DELETE;
            Status = STATUS_SUCCESS;
            goto done;

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_STOP_DEVICE:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            Status = STATUS_SUCCESS;
            goto done;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            if (IrpStack->Parameters.QueryDeviceRelations.Type ==
                TargetDeviceRelation) {

                PDEVICE_RELATIONS DeviceRelations = NULL;

                DeviceRelations = ExAllocatePool(PagedPool, sizeof(*DeviceRelations));

                if (DeviceRelations == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    //
                    // TargetDeviceRelation reported PDOs need to be ref'ed.
                    // PNP will deref this later.
                    //
                    ObReferenceObject(DeviceObject);
                    DeviceRelations->Count = 1;
                    DeviceRelations->Objects[0] = DeviceObject;
                    Status = STATUS_SUCCESS;
                }

                Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;

            } else {
                Status = Irp->IoStatus.Status;
            }

            goto done;

        case IRP_MN_REMOVE_DEVICE:

            DEBUG_BREAKPOINT();

            DebugPrint((DebugLevelInfo,
                        "Child PDO %x receives REMOVE\n",
                        DeviceObject ));

            //
            // remove this extension from the list.
            // This is true - pierre tells me that PNP won't reenter me.  Verify
            // that this is true on NT also.
            //
            //
            // When a PDO first receives this msg, it is usually forwarded
            // from FDO. We can't just delete this PDO, but mark it delete
            // pending.
            //

            if ( !(ChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE )) {
                Status = STATUS_SUCCESS;
                goto done;
            }
            
	        RemoveEntryList(&ChildExtension->ChildExtensionList);

	        //
    	    // free the device name string if it exists.
        	//

	        if (ChildExtension->DeviceName) {

	            ExFreePool(ChildExtension->DeviceName);
    	    }

	        //
    	    // delete the PDO
        	//

	        IoDeleteDevice(DeviceObject);

            Status = STATUS_SUCCESS;

            goto done;

        case IRP_MN_QUERY_CAPABILITIES:

            Status = SCEnumGetCaps(ChildExtension,
                      IrpStack->Parameters.DeviceCapabilities.Capabilities);
            goto done;

        case IRP_MN_QUERY_ID:

            //
            // process the ID query for the child devnode.
            //

            Status = SCQueryEnumId(DeviceObject,
                                   IrpStack->Parameters.QueryId.IdType,
                                   (PWSTR *) & (Irp->IoStatus.Information));
            goto done;

        default:
            Status = STATUS_NOT_IMPLEMENTED;

    done:

            Irp->IoStatus.Status = Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return (Status);

        }                       // switch
    }                           // if child
    //
    // this is not a child device.  do adult processing
    //

    HwInitData = &(DeviceExtension->MinidriverData->HwInitData);

    //
    // show one more reference to driver.
    //

    SCReferenceDriver(DeviceExtension);

    //
    // show one more I/O pending
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    switch (IrpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPNP: Start Device %x\n",
                    DeviceObject));

        //
        // reinitialize the minidriver's device extension.   This is
        // necessary as we may receive a start before a remove, such as in
        // the case of a PNP rebalance.
        //

        RtlZeroMemory(DeviceExtension->HwDeviceExtension,
               DeviceExtension->DriverInfo->HwInitData.DeviceExtensionSize);

        //
        // clear the inaccessible flag since we may have stopped the
        // device previously.
        //

        DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

        //
        // The START message gets passed to the PhysicalDeviceObject
        // we were give in PnPAddDevice, so call 'er down first.
        //

        SCCallNextDriver(DeviceExtension, Irp);

        //
        // get the capabilities of our parent.   This info is used for
        // controlling the system power state.
        //

        Status = SCQueryCapabilities(DeviceExtension->AttachedPdo,
                                     &DeviceCapabilities);

        ASSERT(NT_SUCCESS(Status));

        //
        // copy the device state info into the device extension.
        //

        if (NT_SUCCESS(Status)) {

            RtlCopyMemory(&DeviceExtension->DeviceState[0],
                          &DeviceCapabilities.DeviceState[0],
                          sizeof(DeviceExtension->DeviceState));

        }                       // if query succeeded
        //
        // call the worker routine to complete the start processing.
        // this routine completes the IRP.
        //

        Status = SCStartWorker(Irp);

        //
        // dereference the minidriver which will page it out if possible.
        //

        SCDereferenceDriver(DeviceExtension);
        return (Status);


    case IRP_MN_QUERY_DEVICE_RELATIONS:


        DebugPrint((DebugLevelInfo, 
                   "StreamClassPNP: Query Relations %x\n",
                   DeviceObject));
                   
        switch (IrpStack->Parameters.QueryDeviceRelations.Type) {

        case TargetDeviceRelation:

            //
            // just call the next driver and fall thru, since we're being
            // called for the FDO of a PDO for which we are not the parent.
            //

            Status = SCCallNextDriver(DeviceExtension, Irp);
            break;

        case BusRelations:

            //
            // invoke routine to enumerate any child devices
            //

            Status = SCEnumerateChildren(DeviceObject,
                                         Irp);
            break;


        default:
            //
            // pass down unmodified irp. see bug 282915.
            //
            Status = SCCallNextDriver(DeviceExtension, Irp);

        }                       // switch

        SCDereferenceDriver(DeviceExtension);
        return (SCCompleteIrp(Irp, Status, DeviceExtension));

    case IRP_MN_QUERY_STOP_DEVICE:

        //
        // According to DDK, QUERY_STOP and QUERY_REMOVE
        // requeire very different repsonses. It's not best to
        // handle by the same code, if not erroneous.
        //
        DebugPrint((DebugLevelInfo, 
                   "StreamClassPNP: Query Stop %x\n",
                   DeviceObject));

        //
        // presuppose good status.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // Performace improvement chance: The ControlEvent should be init in AddDevice, so 
        // that we don't need a check here. This check is not an optimal
        // fix for 283057. Refix it and the same in Query_Remove.
        //
        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057
        {
            //
            // take the event to avoid race
            //

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);

        }
        
        //
        // Refer to DDK.
        //   We must fail a query_stop if any of the following is true. 
        //      a. we are notified with IRP_MN_DEVICE_USAGE_NOTIFICATION
        //          that the device is in the path of a paging, hiberation
        //          or crash dump file.
        //      b. The device's hardware resources cannot be released.
        //
        // Assuming we are not in the paging path for a. For b, we will
        // pass this Irp down to the mini driver to let it have a say.
        // We will not reject the Query just because of outstanding opens.
        // 

        //DeviceExtension->Flags |= DEVICE_FLAGS_DEVICE_INACCESSIBLE;

        //
        // calldown to next driver will be done in the callback.
        //
        //Status = SCSendUnknownCommand(Irp,
        //                              DeviceExtension,
        //                              SCPNPQueryCallback,
        //                              &RequestIssued);

        //
        // However, to achieve the noble goal, as everything stands now, is opening
        // a whole can of worms. I will keep this old behavior that existed 
        // since win98. The bug OSR4.1 #98132 said to be a regression is completely
        // false. This code is in win98 and win2k. And I have set up win98 to repro
        // this behavior to disapprove the regression claim.
        // 

        if (DeviceExtension->NumberOfOpenInstances == 0) {

            //
            // if there are no open instances, there can be no outstanding
            // I/O, so mark the device as going away.
            //


            DeviceExtension->Flags |= DEVICE_FLAGS_DEVICE_INACCESSIBLE;

            SCCallNextDriver(DeviceExtension, Irp);

            //
            // call the worker routine to complete the query processing.
            // this routine calls back the IRP.
            //

            Status = SCQueryWorker(DeviceObject, Irp);

        } else {

            //
            // the device is open.  fail the query.
            //

            Status = SCCompleteIrp(Irp, STATUS_DEVICE_BUSY, DeviceExtension);

        }


        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057
        {
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        }
        //
        // show one fewer reference to driver.
        //

        SCDereferenceDriver(DeviceExtension);

        return (Status);
        
    case IRP_MN_QUERY_REMOVE_DEVICE:

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPNP: Query Remove %x\n",
                   DeviceObject));

        //
        // presuppose good status.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057
        {
            //
            // take the event to avoid race
            //

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);

        }
        
        //
        // According DDK, if there are opens that can't be closed
        // we must fail the query.
        // So, if there are opened files, just fail the query.
        //
        if (DeviceExtension->NumberOfOpenInstances == 0) {

            //
            // if there are no open instances, there can be no outstanding
            // I/O, so mark the device as going away.
            //


            DeviceExtension->Flags |= DEVICE_FLAGS_DEVICE_INACCESSIBLE;

            SCCallNextDriver(DeviceExtension, Irp);

            //
            // call the worker routine to complete the query processing.
            // this routine calls back the IRP.
            //

            Status = SCQueryWorker(DeviceObject, Irp);

        } else {

            //
            // the device is open.  fail the query.
            //

            Status = SCCompleteIrp(Irp, STATUS_DEVICE_BUSY, DeviceExtension);

        }

        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057
        {
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        }
        //
        // show one fewer reference to driver.
        //

        SCDereferenceDriver(DeviceExtension);

        return (Status);

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        //
        // clear the inaccessible flag and call'er down
        //

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPnP: MN_CANCEL_REMOVE %x\n",
                   DeviceObject));
                   
        DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

        //
        // call next driver
        //

        SCCallNextDriver(DeviceExtension, Irp);

        //
        // dereference the driver which will page out if possible.
        //

        SCDereferenceDriver(DeviceExtension);

        return (SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension));

    case IRP_MN_CANCEL_STOP_DEVICE:

        //
        // clear the inaccessible flag and call'er down
        //

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPnP: MN_CANCEL_STOP %x\n",
                   DeviceObject));
                   
        DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

        //
        // call next driver
        //

        SCCallNextDriver(DeviceExtension, Irp);

        //
        // dereference the driver which will page out if possible.
        //

        SCDereferenceDriver(DeviceExtension);

        return (SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension));

        break;

    case IRP_MN_STOP_DEVICE:

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPnP: MN_STOP_DEVICE %x\n",
                   DeviceObject));

        //
        // presuppose good status.  if we have actually started the device,
        // stop it now.
        //

        Status = STATUS_SUCCESS;

        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {

            //
            // call routine to uninitialize minidriver
            //

            Status = SCUninitializeMinidriver(DeviceObject, Irp);

            //
            // now call the next driver in the stack with the IRP, which will
            // determine the final status.
            //

        }                       // if started
        if (NT_SUCCESS(Status)) {
            Status = SCCallNextDriver(DeviceExtension, Irp);
        }

        //
        // Fail everything that's been queued.
        //
        SCRedispatchPendedIrps (DeviceExtension, TRUE);

        //
        // call routine to complete the IRP
        //

        SCCompleteIrp(Irp, Status, DeviceExtension);

        //
        // show one less reference to driver.
        //

        SCDereferenceDriver(DeviceExtension);

        return (Status);

    case IRP_MN_REMOVE_DEVICE:

        DebugPrint((DebugLevelInfo, 
                    "StreamClassPnP: MN_REMOVE_DEVICE %x\n",
                    DeviceObject));

        //
        // handle a "suprise" style removal if we have not been stopped.
        // set success status in case we have already stopped.
        //

        Status = STATUS_SUCCESS;

        if ( DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED ) {
            
            SCSendSurpriseNotification(DeviceExtension, Irp);

            Status = SCUninitializeMinidriver(DeviceObject, Irp);

        }
        
        if (NT_SUCCESS(Status)) {

            Status = SCCallNextDriver(DeviceExtension, Irp);
        }

        //
        // Fail any pended Irps.
        //
        SCRedispatchPendedIrps (DeviceExtension, TRUE);

        //
        // call routine to complete the IRP
        //

        Status = SCCompleteIrp(Irp, Status, DeviceExtension);

        //
        // dereference the driver
        //

        SCDereferenceDriver(DeviceExtension);

        if (NT_SUCCESS(Status)) {

            //
            // free the device header.
            //

            if ( NULL != DeviceExtension->ComObj.DeviceHeader ) {
                KsFreeDeviceHeader(DeviceExtension->ComObj.DeviceHeader);
            }

            //
            // take the event to avoid race
            //

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,    // not alertable
                                  NULL);

            //
            // detach from the PDO now if the opened file count is zero.
            //

            if (DeviceExtension->NumberOfOpenInstances == 0) {

                DebugPrint((DebugLevelInfo,
                            "SCPNP: detaching %x from %x\n",
                            DeviceObject,
                            DeviceExtension->AttachedPdo));

                if ( NULL != DeviceExtension->AttachedPdo ) {
                    //
                    // detach could happen at close, check before leap.
                    // event is taken, check is safe.
                    //
                    IoDetachDevice(DeviceExtension->AttachedPdo);
                    DeviceExtension->AttachedPdo = NULL;
                }
                
                ///
                /// mark child pdos if any
                ///
                {
                    PLIST_ENTRY Node;
                    PCHILD_DEVICE_EXTENSION ChildExtension;
                
                    while (!IsListEmpty( &DeviceExtension->Children )) {
                        Node = RemoveHeadList( &DeviceExtension->Children );
                        ChildExtension = CONTAINING_RECORD(Node,
                                                       CHILD_DEVICE_EXTENSION,
                                                       ChildExtensionList);  
                        DebugPrint((DebugLevelInfo, 
                                "Marking and delete childpdo Extension %p\n",
                                ChildExtension));
      
                        ChildExtension->Flags |= DEVICE_FLAGS_CHILD_MARK_DELETE;
                        IoDeleteDevice(ChildExtension->ChildDeviceObject);
                    }                
                }            
            }
            
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

            //
            // delete the device
            //
            
            // A dev could be stop and start. Free stuff allocated
            // at AddDevice.
            // FilterTypeInfos includes FilterTypeInfos CreateItems.
            // Free these here at remove_device
    	    if (  DeviceExtension->FilterTypeInfos ) {
                ExFreePool( DeviceExtension->FilterTypeInfos );    	        
                DeviceExtension->FilterTypeInfos = NULL;
                DeviceExtension->CreateItems = NULL;
            }
            
            IoDeleteDevice(DeviceExtension->DeviceObject);
        }
        return (Status);

    case IRP_MN_SURPRISE_REMOVAL:

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPnP: MN_SURPRISE_REMOVAL %x\n",
                   DeviceObject));

        //
        // handle a "suprise" style removal if we have not been stopped.
        // set success status in case we have already stopped.
        //

        Status = STATUS_SUCCESS;

        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {
                                  
            SCSendSurpriseNotification(DeviceExtension, Irp);
            Status = SCUninitializeMinidriver(DeviceObject, Irp);
        }
        
        //
        // forward the surprise removal IRP to the next layer, regardless of
        // our status.
        //

        Status = SCCallNextDriver(DeviceExtension, Irp);

        //
        // call routine to complete the IRP
        //

        Status = SCCompleteIrp(Irp, Status, DeviceExtension);

        //
        // dereference the driver
        //

        SCDereferenceDriver(DeviceExtension);

        //
        // indicate that we received an "NT style" surprise removal
        // notification
        // so that we won't do the "memphis style" behavior on filter close.
        //

        DeviceExtension->Flags |= DEVICE_FLAGS_SURPRISE_REMOVE_RECEIVED;

        return (Status);

    case IRP_MN_QUERY_CAPABILITIES:

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPNP: Query Caps\n",
                   DeviceObject));

        //
        // indicate that suprise removal is OK after calling request down
        // to next level.
        //

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        Status = SCCallNextDriver(DeviceExtension, Irp);

        IrpStack->Parameters.DeviceCapabilities.
            Capabilities->SurpriseRemovalOK = TRUE;

        Status = SCCompleteIrp(Irp, Status, DeviceExtension);

        //
        // show one less reference to driver.
        //

        SCDereferenceDriver(DeviceExtension);

        return (Status);

    default:

        DebugPrint((DebugLevelInfo, 
                   "StreamPnP: unknown function\n",
                   DeviceObject));

        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {

            //
            // unknown function, so call it down to the minidriver as such.
            // this routine completes the IRP if we are able to issue the
            // request.
            //

            Status = SCSendUnknownCommand(Irp,
                                          DeviceExtension,
                                          SCUnknownPNPCallback,
                                          &RequestIssued);

            if (!RequestIssued) {
                //
                // could not send the unknown command down.  show one fewer
                // I/O
                // pending and fall thru to generic handler.
                //

                DEBUG_BREAKPOINT();
                Status = SCCompleteIrp(Irp, STATUS_INSUFFICIENT_RESOURCES, DeviceExtension);
            }            
        } 

        else {

            //
            // call next driver
            //

            Status = SCCallNextDriver(DeviceExtension, Irp);

            SCCompleteIrp(Irp, Status, DeviceExtension);

        }                       // if started

        //
        // dereference the driver
        //

        SCDereferenceDriver(DeviceExtension);
        return (Status);

    }

}

NTSTATUS
StreamClassCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    TODO: Remove this once KS can multiplex CLEANUP Irps.

    Manual multiplex of cleanup Irps.  Note that FsContext is NOT NECESSARILY
    OURS.  The cookie check is done to check for streams until KS handles
    this correctly.

Arguments:

    DeviceObject -
        The device object

    Irp -
        The CLEANUP irp

Return Value:

    The Irp return code set appropriately.

--*/

{

    PIO_STACK_LOCATION IoStack = IoGetCurrentIrpStackLocation (Irp);
    PCOOKIE_CHECK CookieCheck = 
        (PCOOKIE_CHECK) IoStack -> FileObject -> FsContext;

    //
    // Check for the cookie.  If it's not there or the context is not there,
    // bail.
    //
    if (CookieCheck &&
        CookieCheck -> PossibleCookie == STREAM_OBJECT_COOKIE) {

        return StreamDispatchCleanup (DeviceObject, Irp);

    }

    Irp -> IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return STATUS_INVALID_DEVICE_REQUEST;

}

NTSTATUS
SciQuerySystemPowerHiberCallback(
                       IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of an unknown Power command for query system hiber

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status, MiniStatus;

    PAGED_CODE();

    //
    // delete the SRB since we are done with it
    //

    MiniStatus = SCDequeueAndDeleteSrb(SRB);

    if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {
        MiniStatus = STATUS_NOT_SUPPORTED;
    }

    if ( STATUS_NOT_SUPPORTED == MiniStatus ) {

        //
        // not surprising, old driver doesn't handle this.
        //

        if ( 0 != (DeviceExtension->RegistryFlags &
                   DRIVER_USES_SWENUM_TO_LOAD )  || 
             0 != (DeviceExtension->RegistryFlags &
                   DEVICE_REG_FL_OK_TO_HIBERNATE ) ) {
                              
            //
            // default for swenum driver is OK to hiber
            // No hiber for other drivers unless explicitly
            // say so in the registry
            //

            DebugPrint((DebugLevelInfo, 
                        "%ws Allow hibernation!\n",
                        DeviceExtension->DeviceObject->
                        DriverObject->DriverName.Buffer));
            MiniStatus = STATUS_SUCCESS;
        }

        else {

            //
            // for others, disallow
            //
            
            DebugPrint((DebugLevelInfo, 
                        "%ws Disallow hibernation!\n",
                        DeviceExtension->DeviceObject->
                        DriverObject->DriverName.Buffer));
            MiniStatus = STATUS_DEVICE_BUSY;
        }
    }
    
    if ( NT_SUCCESS( MiniStatus )) {

        //
        // it is not explicitly failed by the mini driver pass down the Irp
        //

        Status = SCCallNextDriver(DeviceExtension, Irp);
        if ( Status == STATUS_NOT_SUPPORTED ) {
        
            //
            // no one below knows/cares. Use our mini status
            //
            
            Status = MiniStatus;
        }
    }

    else {
    
        //
        // mini driver explicitly failed this
        //
        
        Status = MiniStatus;
    }
    
    //
    // complete the IRP with the final status
    //

    return (SCCompleteIrp(Irp, Status, DeviceExtension));
}


NTSTATUS
SCSysWakeCallNextDriver(
                 IN PDEVICE_EXTENSION DeviceExtension,
                 IN PIRP Irp
)
/*++

Routine Description:

    This is called when we receive a wake up system Irp which we can't not block. 
    If we block, the lower driver might queue this Irp ( such as acpi ) and the
    po system could be dead locked. In theory, we should complete the requested
    D Irp and use the status as the status for the SWake Irp. In practise, we can
    just send down this Irp assuming all is well. In the unlikely condition, the SWake
    Irp was unsuccessful, the D Irp will fail. But there is really nothing we can 
    improve or nothing will get worse.

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    none.

--*/
{
    NTSTATUS        Status;

    //
    // call down and be done with this SWake Irp; the D Irp completion routine
    // should not complete this SWake Irp.
    //
    
    PoStartNextPowerIrp( Irp );
    IoSkipCurrentIrpStackLocation( Irp );
    Status = PoCallDriver(DeviceExtension->AttachedPdo, Irp);

    //
    // If we get an error, we complete this S irp in the caller with the error.
    //
    
    return (Status);
}

VOID
SCDevIrpCompletionWorker(
    PIRP pIrp
)
/*++

    Description:

        This is the worker routine for Device Power Wakeup Irp which schedule
        a workitem to continue the work at the Irp on its way up. We
        need to schedule this work because the completion routine could be called at
        DISPATCH_LEVEL. We schedule the workitem so we can safely take 
        control event and call to our mini driver.
        IRQL < DISPATCH_LEVEL
        

    Parameter:

        pIrp: the original Irp which we have marked MORE_PROCEESING_REQUIRED.
             We will complete it after we call our mini driver.

    Return: 

        None.

--*/
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(pIrp);
    PDEVICE_EXTENSION DeviceExtension = IrpStack->DeviceObject->DeviceExtension;
    BOOLEAN         RequestIssued;
    NTSTATUS Status;

    
    PAGED_CODE();
    
    //
    // take the event to avoid race
    //    

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,    // not alertable
                          NULL);

    //
    // send a set power SRB to the device.
    // additional processing will be done by the callback
    // procedure.  This routine completes the IRP if it is able
    // to issue the request.
    //

    Status = SCSubmitRequest(SRB_CHANGE_POWER_STATE,
                              (PVOID) PowerDeviceD0,
                              0,
                              SCPowerCallback,
                              DeviceExtension,
                              NULL,
                              NULL,
                              pIrp,
                              &RequestIssued,
                              &DeviceExtension->PendingQueue,
                              (PVOID) DeviceExtension->
                              MinidriverData->HwInitData.
                              HwReceivePacket );


    if (!RequestIssued) {

        //
        // If we fail to issue SRB, the SCPowerCallback won't happen.
        // We need to carry out the power IRP processing here;
        //
        // set the new power state in the device extension.
        //
        SCSetCurrentDPowerState (DeviceExtension, PowerDeviceD0);

        PoStartNextPowerIrp( pIrp );
        SCCompleteIrp(pIrp, STATUS_SUCCESS, DeviceExtension);
    }

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    //
    // Redispatch any Irps pended because of lower power states.
    //
    SCRedispatchPendedIrps (DeviceExtension, FALSE);

    //
    // show one fewer reference to driver.
    //

    SCDereferenceDriver(DeviceExtension);
    return;
}


NTSTATUS 
SCDevWakeCompletionRoutine(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp,
                         IN PVOID pContext
)
/*++

Routine Description:

    This routine is for Device wakeup Irp completion.
    We sent it to NextDeviceObject first. Now this is back.
    We process out work for the mini driver. We might be called
    at Dispatch_LEVEL.

    IRQL <= DISPATCH_LEVEL

Arguments:

    DriverObject - Pointer to driver object created by system.
    Irp - Irp that just completed
    pContext - the context

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Schedule a work item in case we are called at DISPATCH_LEVEL
    // note that we can use a global Devcice Power item since we have 
    // not yet issued the PoNextPowerIrp call which is called at the callback
    // of the power Srb
    //

    ExInitializeWorkItem(&DeviceExtension->DevIrpCompletionWorkItem,
                         SCDevIrpCompletionWorker,
                         Irp);

    ExQueueWorkItem(&DeviceExtension->DevIrpCompletionWorkItem,
                    DelayedWorkQueue);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SCDevWakeCallNextDriver(
                 IN PDEVICE_EXTENSION DeviceExtension,
                 IN PIRP Irp
)
/*++

Routine Description:

    Receive device wake up Irp. Need to send down the Irp 1st.
    Also this can't be synchronous. We could dead lock, if we do this
    synchronously. Send it down without waiting. Process it when it compltes
    back to us.

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    none.

--*/
{
    NTSTATUS        Status;

    IoCopyCurrentIrpStackLocationToNext( Irp );
    
    IoSetCompletionRoutine(Irp,
                           SCDevWakeCompletionRoutine,
                           NULL,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // We are to schedule a workitem to complete the work
    // in the completion routin. Mark the Irp pending
    //
    IoMarkIrpPending( Irp );
    
    Status = PoCallDriver(DeviceExtension->AttachedPdo, Irp);

    ASSERT( NT_SUCCESS( Status ));
    return STATUS_PENDING;
}


NTSTATUS
StreamClassPower(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
)
/*++

Routine Description:

    This routine processes the various Plug N Play messages

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    NTSTATUS        Status;
    PHW_INITIALIZATION_DATA HwInitData;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    DeviceExtension = DeviceObject->DeviceExtension;
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    if (DeviceExtension->Flags & DEVICE_FLAGS_CHILD) {

        switch (IrpStack->MinorFunction) {

        default:
            PoStartNextPowerIrp( Irp ); // shut down would bugcheck w/o this
            Status = Irp->IoStatus.Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return (Status);

        }
    }                           // if child
    //
    // if the device is stopped, just call the power message down to the next
    // level.
    //

    if (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE) {

        Status = SCCallNextDriver(DeviceExtension, Irp);
        PoStartNextPowerIrp( Irp );
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return (Status);
    }                           // if inaccessible
    HwInitData = &(DeviceExtension->MinidriverData->HwInitData);

    //
    // show one more reference to driver.
    //

    SCReferenceDriver(DeviceExtension);

    //
    // show one more I/O pending
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    switch (IrpStack->MinorFunction) {

    case IRP_MN_QUERY_POWER:

        //
        // presuppose good status.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        switch (IrpStack->Parameters.Power.Type) {

        case SystemPowerState:

            DebugPrint((DebugLevelInfo, 
                        "Query_power S[%d]\n",
                        IrpStack->Parameters.Power.State.SystemState));            

            //
            // some minidrivers want to not suspend if their pins are in
            // the RUN state.   check for this case.
            //

            DebugPrint((DebugLevelInfo,
                       "POWER Query_Power DevObj %x RegFlags=%x SysState=%x\n",
                       DeviceObject,
                       DeviceExtension->RegistryFlags,
                       IrpStack->Parameters.Power.State.SystemState));

            #ifdef WIN9X_STREAM

            if ( PowerSystemHibernate == 
                 IrpStack->Parameters.Power.State.SystemState ) {
                 
                //
                // Power query to hibernation state. Many existing drivers
                // are hibernation unaware. We will reject this query. Or
                // drivers' devices woken up from hiber will be in un-init
                // state. Some drivers would fault. Lucky others do not but
                // would not work. For less of the evil, we try to protect
                // the system by rejecting the hibernation. Note though, this
                // chance to reject is not available with forced ( low battery
                // or user force ) hibernation.
                //
                //
                // unknown function, so call it down to the minidriver as such.
                // this routine completes the IRP if it is able to issue the request.
                //
                
                Status = SCSendUnknownCommand(Irp,
                                              DeviceExtension,
                                              SciQuerySystemPowerHiberCallback,
                                              &RequestIssued);

                if (!RequestIssued) {
                
                    //
                    // could not send the unknown command down.  show one fewer I/O
                    // pending and fall thru to generic handler.
                    //
                    
                    PoStartNextPowerIrp(Irp);
                    Status = SCCompleteIrp(Irp, 
                                           STATUS_INSUFFICIENT_RESOURCES, 
                                           DeviceExtension);
                }
                
                //
                // dereference the driver
                //

                SCDereferenceDriver(DeviceExtension);
                return Status;
            } else 

            #endif //WIN9X_STREAM

            if (DeviceExtension->RegistryFlags &
                DEVICE_REG_FL_NO_SUSPEND_IF_RUNNING) {


                PFILTER_INSTANCE FilterInstance;
                KIRQL           Irql;
                PLIST_ENTRY     FilterEntry,
                                FilterListHead;

                KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);
                
                FilterListHead = FilterEntry = &DeviceExtension->FilterInstanceList;

                while (FilterEntry->Flink != FilterListHead) {

                    FilterEntry = FilterEntry->Flink;

                    //
                    // follow the link to the instance
                    //

                    FilterInstance = CONTAINING_RECORD(FilterEntry,
                                                       FILTER_INSTANCE,
                                                       NextFilterInstance);


                    if (SCCheckIfStreamsRunning(FilterInstance)) {

                        DebugPrint((DebugLevelInfo, 
                                    "POWER Query_Power FilterInstance %x busy\n",
                                    FilterInstance ));
                                    
                        Status = STATUS_DEVICE_BUSY;
                        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
                        goto QuerySystemSuspendDone;
                    }           // if streams running
                    //
                    // get the list entry for the next instance
                    //

                    FilterEntry = &FilterInstance->NextFilterInstance;

                }               // while local filter instances

                KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

            }                   // if no suspend if running
            Status = SCCallNextDriver(DeviceExtension, Irp);


    QuerySystemSuspendDone:

            //
            // indicate we're ready for next power irp
            //

            PoStartNextPowerIrp(Irp);

            //
            // show one fewer reference to driver.
            //

            SCDereferenceDriver(DeviceExtension);
            return (SCCompleteIrp(Irp, Status, DeviceExtension));

        case DevicePowerState:

            switch (IrpStack->Parameters.Power.State.DeviceState) {

            default:
            case PowerDeviceD2:
            case PowerDeviceD3:

                //
                // check to see if the device is opened.
                //
                if (!DeviceExtension->NumberOfOpenInstances) {

                    //
                    // show pending status and call next driver without a
                    // completion
                    // handler
                    //
                    Status = SCCallNextDriver(DeviceExtension, Irp);

                } else {

                    //
                    // the device is opened.  Don't do the power down.
                    //
                    Status = STATUS_DEVICE_BUSY;
                }

                PoStartNextPowerIrp(Irp);

                //
                // show one fewer reference to driver.
                //

                SCDereferenceDriver(DeviceExtension);

                return (SCCompleteIrp(Irp, Status, DeviceExtension));
            }

        default:

            //
            // unknown power type: indicate we're ready for next power irp
            //

            PoStartNextPowerIrp(Irp);

            //
            // show one fewer reference to driver.
            //

            SCDereferenceDriver(DeviceExtension);
            return (SCCompleteIrp(Irp, STATUS_NOT_SUPPORTED, DeviceExtension));



        }                       // switch minorfunc
        break;

    case IRP_MN_SET_POWER:

        //
        // presuppose good status.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        switch (IrpStack->Parameters.Power.Type) {

        case SystemPowerState:

            if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {
            
          		//
            	// Only care if the device is started.
            	// We depend on DE->ControlEvent being inited at SCStartWorker.
            	//
            	
                POWER_STATE     PowerState;
                SYSTEM_POWER_STATE RequestedSysState =
                IrpStack->Parameters.Power.State.SystemState;
                //
                // look up the correct device power state in the table
                //

                PowerState.DeviceState =
                    DeviceExtension->DeviceState[RequestedSysState];

                DebugPrint((DebugLevelInfo, 
                            "SCPower: DevObj %x S[%d]->D[%d]\n",
                            DeviceExtension->PhysicalDeviceObject,
                            RequestedSysState,
                            PowerState.DeviceState));

                //
                // if this is a wakeup, we must first pass the request down
                // to the PDO for preprocessing.
                //

                if (RequestedSysState == PowerSystemWorking) {

                    //
                    // Send down this S power IRP to the next layer and be
                    // done with it, except requesting D Irp in the following
                    // condition that related to the S Irp but does not reference
                    // it any further.
                    //

                    Status = SCSysWakeCallNextDriver(DeviceExtension, Irp);
                    ASSERT( NT_SUCCESS( Status ) );

                    //
                    // Nullify Irp, so at the D Irp completion, we dont complete this Irp.
                    // Be careful not to touch the Irp afterwards.
                    //

                    InterlockedDecrement(&DeviceExtension->OneBasedIoCount);
                    Irp = NULL; 
                    
                }

                //
                // Mark the S State.
                //
                SCSetCurrentSPowerState (DeviceExtension, RequestedSysState);

                //
                // take the event to avoid race.
                //

                KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                      Executive,
                                      KernelMode,
                                      FALSE,    // not alertable
                                      NULL);

                if ((RequestedSysState == PowerSystemWorking) &&
                    (!DeviceExtension->NumberOfOpenInstances) &&
                    (DeviceExtension->RegistryFlags & DEVICE_REG_FL_POWER_DOWN_CLOSED)) {

                    // We are awakening from a suspend.
                    // we don't want to wake up the device at this
                    // point.  We'll just wait til the first open
                    // occurs to wake it up.
                    //

                    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

                    //
                    // Since there are no open instances, there can only be
                    // pended creates.  Since we key device powerup off the
                    // creates, redispatch them now if there are any. 
                    //
                    SCRedispatchPendedIrps (DeviceExtension, FALSE);

                    return Status;

                } else {        // if state = working

                    //
                    // now send down a set power based on this info.
                    //

                    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

                    //
                    // per Pierre and Lonny, we should use D3 instead of the
                    // mapped array value, as the array value is always D0!
                    // of course, they'll change this next week...
                    //

                    if (RequestedSysState != PowerSystemWorking) {

                        PowerState.DeviceState = PowerDeviceD3;

                    }
                    DebugPrint((DebugLevelInfo, 
                                "SCPower: PoRequestPowerIrp %x to state=%d\n",
                                DeviceExtension->PhysicalDeviceObject,
                                PowerState));

                    //
                    // when (RequestedSysState == PowerSystemWorking) but 
                    // (DeviceExtension->NumberOfOpenInstances) ||
                    // !(DeviceExtension->RegistryFlags & DEVICE_REG_FL_POWER_DOWN_CLOSED)
                    // we come here with Irp==NULL. Don't touch NULL Irp.
                    //
                    
                    if ( NULL != Irp ) {
                        IoMarkIrpPending (Irp);
                    }
                                
                    Status = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
                                               IRP_MN_SET_POWER,
                                               PowerState,
                                               SCSynchPowerCompletionRoutine,
                                               Irp, // when NULL, it tells callback don't bother.
                                               NULL);

                    if (!NT_SUCCESS (Status) && NULL != Irp ) {                        
                        PoStartNextPowerIrp (Irp);
                        SCCompleteIrp (Irp, Status, DeviceExtension);
                    }
                    
                    //
                    // The Irp has been marked pending.  We MUST return
                    // pending.  Error case will complete the Irp with the
                    // appropriate status.
                    //
                    return STATUS_PENDING;

                }               // if system state working

                //
                // if this is a NOT wakeup, we must first pass the request
                // down to the PDO for postprocessing.
                //

                if (RequestedSysState != PowerSystemWorking) {

                    //
                    // send down the power IRP to the next layer.  this
                    // routine
                    // has a completion routine which does not complete the
                    // IRP.
                    //

                    Status = SCCallNextDriver(DeviceExtension, Irp);

                    #if DBG
                    if (!NT_SUCCESS(Status)) {

                        DebugPrint((DebugLevelError, "'SCPower: PDO failed power request!\n"));
                    }
                    #endif
                }
          	}
          	else {
          		//
            	// We have not started the device, don't bother.
            	// Besides, we can't use the DE->ControlEvent which is not
            	// inited yet in this case.
            	//
            	Status = STATUS_SUCCESS;
            }
            
            //
            // indicate that we're ready for the next power IRP.
            //

            PoStartNextPowerIrp(Irp);

            //
            // show one fewer reference to driver.
            //

            SCDereferenceDriver(DeviceExtension);

            //
            // now complete the original request
            //

            return (SCCompleteIrp(Irp, Status, DeviceExtension));

            // end of set system power state

        case DevicePowerState:

            {

                DEVICE_POWER_STATE DeviceState;
                DeviceState = IrpStack->Parameters.Power.State.DeviceState;

                //
                // if this is a power up, send the IRP down first to allow
                // the PDO to preprocess it.
                //

                if (DeviceState == PowerDeviceD0) {

                    //
                    // Call down async or the Wakeup might dead lock.
                    // The subsequent work continues in the completion routine.
                    //
                    
                    return SCDevWakeCallNextDriver(DeviceExtension, Irp);
                }
                //
                // take the event to avoid race
                //

                KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                      Executive,
                                      KernelMode,
                                      FALSE,    // not alertable
                                      NULL);

                //
                // send down a set power SRB to the device.
                // additional processing will be done by the callback
                // procedure.  This routine completes the IRP if it is able
                // to issue the request.
                //

                Status = SCSubmitRequest(SRB_CHANGE_POWER_STATE,
                                         (PVOID) DeviceState,
                                         0,
                                         SCPowerCallback,
                                         DeviceExtension,
                                         NULL,
                                         NULL,
                                         Irp,
                                         &RequestIssued,
                                         &DeviceExtension->PendingQueue,
                                         (PVOID) DeviceExtension->
                                         MinidriverData->HwInitData.
                                         HwReceivePacket
                    );


                if (!RequestIssued) {

                    //
                    // If we fail to issue SRB, the SCPowerCallback won't happen.
                    // We need to carry out the power IRP processing here;
                    //
                    // set the new power state in the device extension.
                    //
                    SCSetCurrentDPowerState (DeviceExtension, DeviceState);

                    //
                    // send the Irp down to the next layer, and return that status
                    // as the final one.
                    //
                    Status = SCCallNextDriver(DeviceExtension, Irp);

                    PoStartNextPowerIrp( Irp );
                    SCCompleteIrp(Irp, Status, DeviceExtension);
                }
            }

            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

            //
            // show one fewer reference to driver.
            //

            SCDereferenceDriver(DeviceExtension);
            return (Status);

        }                       // case devicepowerstate

    default:

        DebugPrint((DebugLevelInfo, 
                   "StreamPower: unknown function %x\n",
                   DeviceObject));

        //
        // unknown function, so call it down to the minidriver as such.
        // this routine completes the IRP if it is able to issue the request.
        //

        Status = SCSendUnknownCommand(Irp,
                                      DeviceExtension,
                                      SCUnknownPowerCallback,
                                      &RequestIssued);

        if (!RequestIssued) {
            //
            // could not send the unknown command down.  show one fewer I/O
            // pending and fall thru to generic handler.
            //
            PoStartNextPowerIrp(Irp);
            Status = SCCompleteIrp(Irp, STATUS_INSUFFICIENT_RESOURCES, DeviceExtension);
        }
        //
        // dereference the driver
        //

        SCDereferenceDriver(DeviceExtension);
        return (Status);

    }
}

NTSTATUS
SCPNPQueryCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of an PNP Query Stop/Remove command.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status, MiniStatus;

    //
    // delete the SRB
    //

    MiniStatus = SCDequeueAndDeleteSrb(SRB);

    //
    // IRP_MJ_PnP, IRP_MJ_POWER and IRP_MJ_SYSTEM_CONTROL
    // are supposed to traverse the whole device stack unless
    // it is to be failed right here.
    // It should have been STATUS_NOT_SUUPORTED ||
    // NT_SUCCESS( Status ), add STATUS_NOT_IMPLEMENTED as
    // there are some mini drivers return it which should
    // have been STATUS_NOT_SUPPORTED
    //

    if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {
        MiniStatus = STATUS_NOT_SUPPORTED;
    }
    
    if ( STATUS_NOT_SUPPORTED == MiniStatus ||
         NT_SUCCESS( MiniStatus ) ) {

        //
        // Mini driver did not explicitly failed this, passs down the Irp
        //

        Status = SCCallNextDriver(DeviceExtension, Irp);

        if ( Status == STATUS_NOT_SUPPORTED ) {
            //
            // noone below knows/cares. Use our mini status
            //
            Status = MiniStatus;
        }
    }

    else {
        //
        // mini driver explcitly failed this Irp, use MiniStatus
        //
        Status = MiniStatus;
    }

    if ( !NT_SUCCESS( Status ) ) {    
        //
        // query is vetoed, reset the INACCESSIBLE flag
        //
        KIRQL Irql;
        
        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);
        DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;
        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
    }

    //
    // complete the IRP with the final status
    //
    return (SCCompleteIrp(Irp, Status, DeviceExtension));
}


NTSTATUS
SCUnknownPNPCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of an unknown PNP command.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status, MiniStatus;

    PAGED_CODE();

    //
    // delete the SRB
    //

    MiniStatus = SCDequeueAndDeleteSrb(SRB);

    //
    // IRP_MJ_PnP, IRP_MJ_POWER and IRP_MJ_SYSTEM_CONTROL
    // are supposed to traverse the whole device stack unless
    // it is to be failed right here.
    // It should have been STATUS_NOT_SUUPORTED ||
    // NT_SUCCESS( Status ), add STATUS_NOT_IMPLEMENTED as
    // there are some mini drivers return it which should
    // have been STATUS_NOT_SUPPORTED
    //

    if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {
        MiniStatus = STATUS_NOT_SUPPORTED;
    }
    
    if ( STATUS_NOT_SUPPORTED == MiniStatus ||
         NT_SUCCESS( MiniStatus ) ) {

        //
        // Mini driver did not explicitly failed this, passs down the Irp
        //

        Status = SCCallNextDriver(DeviceExtension, Irp);

        if ( Status == STATUS_NOT_SUPPORTED ) {
            //
            // noone below knows/cares. Use our mini status
            //
            Status = MiniStatus;
        }
    }

    else {
        //
        // mini driver explcitly failed this Irp, use MiniStatus
        //
        Status = MiniStatus;
    }

    //
    // complete the IRP with the final status
    //

    return (SCCompleteIrp(Irp, Status, DeviceExtension));
}


NTSTATUS
SCUnknownPowerCallback(
                       IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of an unknown PNP command.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status, MiniStatus;

    PAGED_CODE();

    //
    // delete the SRB
    //

    MiniStatus = SCDequeueAndDeleteSrb(SRB);

    if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {
        MiniStatus = STATUS_NOT_SUPPORTED;
    }
    
    if ( STATUS_NOT_SUPPORTED == MiniStatus || 
         NT_SUCCESS( MiniStatus )) {

        //
        // it is not explicitly failed by the mini driver pass down the Irp
        //

        Status = SCCallNextDriver(DeviceExtension, Irp);
        if ( Status == STATUS_NOT_SUPPORTED ) {
            //
            // noone below knows/cares. Use our mini status
            //
            Status = MiniStatus;
        }
    }

    else {
        //
        // mini driver explicitly failed this
        //
        Status = MiniStatus;
    }
    //
    // complete the IRP with the final status
    //

    PoStartNextPowerIrp( Irp );
    return (SCCompleteIrp(Irp, Status, DeviceExtension));
}

NTSTATUS
SCQueryWorker(
              IN PDEVICE_OBJECT DeviceObject,
              IN PIRP Irp
)
/*++

Routine Description:

     IRP completion handler for querying removal of the hardware

Arguments:

     DeviceObject - pointer to device object
     Irp - pointer to Irp

Return Value:

     NTSTATUS returned.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    KIRQL           Irql;

    //
    // if the query did not succeed, reenable the device.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {

        //
        // clear the inaccessible bit.
        //

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

        DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

    }
    return (SCCompleteIrp(Irp, Irp->IoStatus.Status, DeviceExtension));
}


NTSTATUS
SCStartWorker(
              IN PIRP Irp
)
/*++

Routine Description:

     Passive level routine to process starting the hardware.

Arguments:

     Irp - pointer to Irp

Return Value:

     None.

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT  DeviceObject = IrpStack->DeviceObject;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo;
    PHW_INITIALIZATION_DATA HwInitData;
    PCM_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_LIST PartialResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor;
    KAFFINITY       affinity;
    PVOID           Buffer;
    PACCESS_RANGE   pAccessRanges = NULL;
    ULONG           CurrentRange = 0;
    BOOLEAN         interruptSharable = TRUE;
    DEVICE_DESCRIPTION deviceDescription;
    ULONG           numberOfMapRegisters;
    ULONG           DmaBufferSize;
    ULONG           i;
    PHYSICAL_ADDRESS TranslatedAddress;
    NTSTATUS        Status = Irp->IoStatus.Status;
    BOOLEAN         RequestIssued;
    INTERFACE_TYPE  InterfaceBuffer;
    ULONG           InterfaceLength;


    PAGED_CODE();

    //
    // continue processing if we got good status from our parent.
    //

    if (NT_SUCCESS(Status)) {

        HwInitData = &(DeviceExtension->MinidriverData->HwInitData);

        DebugPrint((DebugLevelInfo, 
                   "SCPNPStartWorker %x\n",
                   DeviceObject));

        //
        // Initialize spin lock for critical sections.
        //

        KeInitializeSpinLock(&DeviceExtension->SpinLock);

        //
        // initialize a worker DPC for this device
        //

        KeInitializeDpc(&DeviceExtension->WorkDpc,
                        StreamClassDpc,
                        DeviceObject);
        //
        // initialize the control and remove events for this device
        //
        // move this to AddDevice, we use the control event at Remove_device
        // which can come in before the device starts.
        // KeInitializeEvent(&DeviceExtension->ControlEvent,
        //                  SynchronizationEvent,
        //                  TRUE);

        KeInitializeEvent(&DeviceExtension->RemoveEvent,
                          SynchronizationEvent,
                          FALSE);

        //
        // Initialize minidriver timer and timer DPC for this stream
        //

        KeInitializeTimer(&DeviceExtension->ComObj.MiniDriverTimer);
        KeInitializeDpc(&DeviceExtension->ComObj.MiniDriverTimerDpc,
                        SCMinidriverDeviceTimerDpc,
                        DeviceExtension);

        //
        // retrieve the resources for the device
        //

        ResourceList = IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated;

        //
        // allocate space for the config info structure.
        //

        ConfigInfo = ExAllocatePool(NonPagedPool,
                                    sizeof(PORT_CONFIGURATION_INFORMATION)
            					   );


        if (ConfigInfo == NULL) {

            DebugPrint((DebugLevelFatal, "StreamClassPNP: ConfigInfo alloc failed."));

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
        DebugPrint((DebugLevelVerbose, "StreamClassPNP: ConfigInfo = %x\n", ConfigInfo));

        RtlZeroMemory(ConfigInfo, sizeof(PORT_CONFIGURATION_INFORMATION));

        DeviceExtension->ConfigurationInformation = ConfigInfo;

        //
        // fill in the ConfigInfo fields we know about.
        //

        ConfigInfo->SizeOfThisPacket = sizeof(PORT_CONFIGURATION_INFORMATION);

		#if DBG

        //
        // make sure that the minidriver handles receiving a bigger structure
        // so we can expand it later
        //

        ConfigInfo->SizeOfThisPacket *= ConfigInfo->SizeOfThisPacket;
		#endif
		
        //
        // set the callable PDO in the configinfo structure
        //

        ConfigInfo->PhysicalDeviceObject = DeviceExtension->AttachedPdo;
        ConfigInfo->RealPhysicalDeviceObject = DeviceExtension->PhysicalDeviceObject;

        ConfigInfo->BusInterruptVector = MP_UNINITIALIZED_VALUE;
        ConfigInfo->InterruptMode = Latched;
        ConfigInfo->DmaChannel = MP_UNINITIALIZED_VALUE;
        ConfigInfo->Irp = Irp;

        //
        // Now we get to chew thru the resources the OS found for us, if any.
        //

        if (ResourceList) {

            FullResourceDescriptor = &ResourceList->List[0];

            PartialResourceList = &FullResourceDescriptor->PartialResourceList;

            //
            // fill in the bus # and interface type based on the device
            // properties
            // for the PDO.  default to InterfaceTypeUndefined if
            // failure to retrieve interface type (if the miniport tries to
            // use
            // this value when filling in DEVICE_DESCRIPTION.InterfaceType
            // for
            // calling IoGetDmaAdapter, the right thing will happen, since
            // PnP
            // will automatically pick the correct legacy bus in the system
            // (ISA or MCA).
            //

            if (!NT_SUCCESS(
                  IoGetDeviceProperty(
                  		DeviceExtension->PhysicalDeviceObject,
                        DevicePropertyBusNumber,
                        sizeof(ULONG),
                        (PVOID) & (ConfigInfo->SystemIoBusNumber),
                        &InterfaceLength))) {
                //
                // Couldn't retrieve bus number property--assume bus zero.
                //
                ConfigInfo->SystemIoBusNumber = 0;
            }
            if (NT_SUCCESS(
                  IoGetDeviceProperty(
                  		DeviceExtension->PhysicalDeviceObject,
                        DevicePropertyLegacyBusType,
                        sizeof(INTERFACE_TYPE),
                        &InterfaceBuffer,
                        &InterfaceLength))) {


                ASSERT(InterfaceLength == sizeof(INTERFACE_TYPE));
                ConfigInfo->AdapterInterfaceType = InterfaceBuffer;

            } else {            // if success
                //
                // Couldn't retrieve bus interface type--initialize to
                // InterfaceTypeUndefined.
                //
                ConfigInfo->AdapterInterfaceType = InterfaceTypeUndefined;

            }                   // if success


            //
            // allocate space for access ranges.  We use the Count field
            // in the resource list for determining this size, as the count
            // will be >= the max # of ranges we will need.
            //

            if (PartialResourceList->Count) {

                pAccessRanges = ExAllocatePool(NonPagedPool,
                                               sizeof(ACCESS_RANGE) *
                                               PartialResourceList->Count
                    						  );

                if (pAccessRanges == NULL) {

                    DebugPrint((DebugLevelFatal,
                                "StreamClassPNP: No pool for global info"));

                    Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                    SCFreeAllResources(DeviceExtension);
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }
            }                   // if count

            //
            // Stash the AccessRanges structure at this time so that
            // SCFreeAllResources will free it on resource failures below.
            //
            ConfigInfo->AccessRanges = pAccessRanges;

            //
            // Now update the port configuration info structure by looping
            // thru the config
            //

            for (i = 0; i < PartialResourceList->Count; i++) {

                switch (PartialResourceList->PartialDescriptors[i].Type) {

                case CmResourceTypePort:

                    DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Port Resources Found at %x, Length  %x\n",
                    PartialResourceList->PartialDescriptors[i].u.Port.Start,
                                PartialResourceList->PartialDescriptors[i].u.Port.Length));

                    //
                    // translate the bus address for the minidriver
                    //

                    TranslatedAddress = PartialResourceList->PartialDescriptors[i].u.Port.Start;

                    //
                    // set the access range in the structure.
                    //

                    pAccessRanges[CurrentRange].RangeStart = TranslatedAddress;

                    pAccessRanges[CurrentRange].RangeLength =
                        PartialResourceList->
                        PartialDescriptors[i].u.Port.Length;

                    pAccessRanges[CurrentRange++].RangeInMemory =
                        FALSE;

                    break;

                case CmResourceTypeInterrupt:

                    DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Interrupt Resources Found!  Level = %x Vector = %x\n",
                                PartialResourceList->PartialDescriptors[i].u.Interrupt.Level,
                                PartialResourceList->PartialDescriptors[i].u.Interrupt.Vector));

                    //
                    // Set the interrupt vector in the config info
                    //

                    ConfigInfo->BusInterruptVector = PartialResourceList->PartialDescriptors[i].u.Interrupt.Vector;

                    ;
                    affinity = PartialResourceList->PartialDescriptors[i].u.Interrupt.Affinity;

                    ConfigInfo->BusInterruptLevel = (ULONG) PartialResourceList->PartialDescriptors[i].u.Interrupt.Level;

                    ConfigInfo->InterruptMode = PartialResourceList->PartialDescriptors[i].Flags;

                    //
                    // Go to next resource for this Adapter
                    //

                    break;

                case CmResourceTypeMemory:

                    //
                    // translate the bus address for the minidriver
                    //

                    DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Memory Resources Found @ %x'%x, Length = %x\n",
                                PartialResourceList->PartialDescriptors[i].u.Memory.Start.HighPart,
                                PartialResourceList->PartialDescriptors[i].u.Memory.Start.LowPart,
                                PartialResourceList->PartialDescriptors[i].u.Memory.Length));


                    TranslatedAddress = PartialResourceList->PartialDescriptors[i].u.Memory.Start;

                    if (!SCMapMemoryAddress(&pAccessRanges[CurrentRange++],
                                            TranslatedAddress,
                                            ConfigInfo,
                                            DeviceExtension,
                                            ResourceList,
                                            &PartialResourceList->
                                            PartialDescriptors[i])) {

                        SCFreeAllResources(DeviceExtension);
                        Status = STATUS_CONFLICTING_ADDRESSES;
                        goto exit;

                    }           // if !scmapmemoryaddress
                default:

                    break;

                }

            }

        }                       // if resources
        //
        // reference the access range structure to the
        // config info structure & the ConfigInfo structure to the
        // device extension & indicate # of ranges.
        //

        ConfigInfo->NumberOfAccessRanges = CurrentRange;

        //
        // Determine if a Dma Adapter must be allocated.
        //

        DmaBufferSize = HwInitData->DmaBufferSize;

        if ((HwInitData->BusMasterDMA) || (DmaBufferSize)) {

            //
            // Get the adapter object for this card.
            //

            DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Allocating DMA adapter\n"));

            RtlZeroMemory(&deviceDescription, sizeof(deviceDescription));
            deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
            deviceDescription.DmaChannel = ConfigInfo->DmaChannel;
            deviceDescription.InterfaceType = ConfigInfo->AdapterInterfaceType;
            deviceDescription.DmaWidth = Width32Bits;
            deviceDescription.DmaSpeed = Compatible;
            deviceDescription.ScatterGather = TRUE;
            deviceDescription.Master = TRUE;
            deviceDescription.Dma32BitAddresses = !(HwInitData->Dma24BitAddresses);
            deviceDescription.AutoInitialize = FALSE;
            deviceDescription.MaximumLength = (ULONG) - 1;

            DeviceExtension->DmaAdapterObject = IoGetDmaAdapter(
                                      DeviceExtension->PhysicalDeviceObject,
                                                         &deviceDescription,
                                                       &numberOfMapRegisters
                );
            ASSERT(DeviceExtension->DmaAdapterObject);

            //
            // Set maximum number of pages
            //

            DeviceExtension->NumberOfMapRegisters = numberOfMapRegisters;

            //
            // expose the object to the minidriver
            //

            ConfigInfo->DmaAdapterObject = DeviceExtension->DmaAdapterObject;


        } else {

            //
            // no DMA adapter object.  show unlimited map registers so
            // we won't have to do a real time check later for DMA.
            //

            DeviceExtension->NumberOfMapRegisters = -1;

        }

        if (DmaBufferSize) {

            Buffer = HalAllocateCommonBuffer(DeviceExtension->DmaAdapterObject,
                                             DmaBufferSize,
                                        &DeviceExtension->DmaBufferPhysical,
                                             FALSE);

            if (Buffer == NULL) {
                DEBUG_BREAKPOINT();
                DebugPrint((DebugLevelFatal, "StreamClassPnPStart: Could not alloc buffer, size: %d\n", DmaBufferSize));
                SCFreeAllResources(DeviceExtension);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            //
            // zero init the common buffer.
            //

            RtlZeroMemory(Buffer, DmaBufferSize);

            //
            // save virtual address of buffer
            //

            DeviceExtension->DmaBuffer = Buffer;
            DeviceExtension->DmaBufferLength = DmaBufferSize; // osr#99489

        }                       // if DMA buffer
        //
        // Performance Improvement chance 
        //   - on rebalance, the uninitialize handler clears the sync
        // vector when the interrupt is disconnected, but since we
        // initialized this vector ONLY at AddDevice time, it wasn't getting
        // reset correctly since only a new start (and not an adddevice) is
        // sent on a rebalance.  the correct fix is to move all of the
        // initial vector setting to here, but I'm worried that there could
        // be a case where if they aren't set up on the adddevice we could
        // reference a null.   So, I've duplicated the following few lines to
        // reset the vector here.   For code savings, this should be done
        // only in one place.
        //

        //
        // presuppose full synch
        //

		#if DBG
        DeviceExtension->SynchronizeExecution = SCDebugKeSynchronizeExecution;
		#else
        DeviceExtension->SynchronizeExecution = KeSynchronizeExecution;
		#endif

        if (DeviceExtension->NoSync) {

            //
            // we won't do synchronization, so use the dummy sync routine.
            //

            DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;
            DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

        }
        //
        // see if the driver has an interrupt, and process if so.
        //

        if (HwInitData->HwInterrupt == NULL ||
            (ConfigInfo->BusInterruptLevel == 0 &&
             ConfigInfo->BusInterruptVector == 0)) {

            //
            // There is no interrupt so use the dummy sync routine.
            //

            DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;
            DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

            DebugPrint((1, "'StreamClassInitialize: Adapter has no interrupt.\n"));

        } else {

            DebugPrint((1,
                        "'StreamClassInitialize: STREAM adapter IRQ is %d\n",
                        ConfigInfo->BusInterruptLevel));

            //
            // Set up for a real interrupt.
            //

            Status = IoConnectInterrupt(
            			&DeviceExtension->InterruptObject,
                        StreamClassInterrupt,
                        DeviceObject,
                        (PKSPIN_LOCK) NULL,
                        ConfigInfo->BusInterruptVector,
                        (UCHAR) ConfigInfo->BusInterruptLevel,
                        (UCHAR) ConfigInfo->BusInterruptLevel,
                        ConfigInfo->InterruptMode,
                        interruptSharable,
                        affinity,
                        FALSE);

            if (!NT_SUCCESS(Status)) {

                DebugPrint((1, "'SCStartWorker: Can't connect interrupt %d\n",
                            ConfigInfo->BusInterruptLevel));
                DeviceExtension->InterruptObject = NULL;
                SCFreeAllResources(DeviceExtension);
                goto exit;
            }
            //
            // set the interrupt object for the minidriver
            //

            ConfigInfo->InterruptObject = DeviceExtension->InterruptObject;

        }

        //
        // point the config info structure to the device extension &
        // device object as
        // we can only pass in one context value to KeSync....
        //

        ConfigInfo->HwDeviceExtension =
            DeviceExtension->HwDeviceExtension;

        ConfigInfo->ClassDeviceObject = DeviceObject;

        //
        // Start timer.
        //

        IoStartTimer(DeviceObject);

        //
        // the ConfigInfo structure is filled in and the IRQ hooked.
        // call the minidriver to find the specified adapter.
        //

        //
        // initialize the device extension queues
        //

        InitializeListHead(&DeviceExtension->PendingQueue);
        InitializeListHead(&DeviceExtension->OutstandingQueue);

        /// move to add device, we could have child PDO if we start and stop
        ///InitializeListHead(&DeviceExtension->Children);
        InitializeListHead(&DeviceExtension->DeadEventList);
        IFN_MF(InitializeListHead(&DeviceExtension->NotifyList);)

        ExInitializeWorkItem(&DeviceExtension->EventWorkItem,
                             SCFreeDeadEvents,
                             DeviceExtension);

        ExInitializeWorkItem(&DeviceExtension->RescanWorkItem,
                             SCRescanStreams,
                             DeviceExtension);

        ExInitializeWorkItem(&DeviceExtension->PowerCompletionWorkItem,
                             SCPowerCompletionWorker,
                             DeviceExtension);

        ExInitializeWorkItem(&DeviceExtension->DevIrpCompletionWorkItem,
                             SCDevIrpCompletionWorker,
                             DeviceExtension);


        //
        // show that the device is ready for its first request.
        //

        DeviceExtension->ReadyForNextReq = TRUE;

        //
        // submit the initialize command.
        // additional processing will be done by the callback procedure.
        //

        Status = SCSubmitRequest(
        			SRB_INITIALIZE_DEVICE,
                    ConfigInfo,
                    sizeof(PORT_CONFIGURATION_INFORMATION),
                    SCInitializeCallback,
                    DeviceExtension,
                    NULL,
                    NULL,
                    Irp,
                    &RequestIssued,
                    &DeviceExtension->PendingQueue,
                    (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket
            	 );

        //
        // If the device failed to start then set the error and return.
        //

        if (!RequestIssued) {

            DebugPrint((DebugLevelFatal, "StreamClassPnP: Adapter not found\n"));

            SCFreeAllResources(DeviceExtension);
            goto exit;
        }
    }
    return (Status);

exit:
    return (SCCompleteIrp(Irp, Status, DeviceExtension));

}


NTSTATUS
SCInitializeCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the minidriver's stream info structure.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PHW_STREAM_DESCRIPTOR StreamBuffer;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;
    PIRP            Irp = SRB->HwSRB.Irp;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo =
    SRB->HwSRB.CommandData.ConfigInfo;
    BOOLEAN         RequestIssued;
    NTSTATUS        Status;

    PAGED_CODE();

    if (NT_SUCCESS(SRB->HwSRB.Status)) {

        DebugPrint((DebugLevelVerbose, "'Stream: returned from HwInitialize\n"));

        //
        // send an SRB to retrieve the stream information
        //

        ASSERT(ConfigInfo->StreamDescriptorSize);

        StreamBuffer =
            ExAllocatePool(NonPagedPool,
                           ConfigInfo->StreamDescriptorSize
            );

        if (!StreamBuffer) {

            SCUninitializeMinidriver(DeviceObject, Irp);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return (SCProcessCompletedRequest(SRB));
        }
        //
        // zero-init the buffer
        //

        RtlZeroMemory(StreamBuffer, ConfigInfo->StreamDescriptorSize);


        //
        // submit the command.
        // additional processing will be done by the callback
        // procedure.
        //

        Status = SCSubmitRequest(SRB_GET_STREAM_INFO,
                   StreamBuffer,
                   ConfigInfo->StreamDescriptorSize,
                   SCStreamInfoCallback,
                   DeviceExtension,
                   NULL,
                   NULL,
                   Irp,
                   &RequestIssued,
                   &DeviceExtension->PendingQueue,
                   (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket
            	 );

        if (!RequestIssued) {

            ExFreePool(StreamBuffer);
            SCUninitializeMinidriver(DeviceObject, Irp);
            return (SCProcessCompletedRequest(SRB));

        }
    } else {

        //
        // If the device failed to start then set the error and
        // return.
        //

        DebugPrint((DebugLevelFatal, "StreamClassPnP: Adapter not found\n"));
        SCFreeAllResources(DeviceExtension);
        return (SCProcessCompletedRequest(SRB));
    }

    //
    // dequeue and delete the SRB for initialize.  Null out the IRP field
    // so the dequeue routine won't try to access it, as it has been freed.
    //

    SRB->HwSRB.Irp = NULL;
    SCDequeueAndDeleteSrb(SRB);
    return (Status);

}


#if ENABLE_MULTIPLE_FILTER_TYPES

PUNICODE_STRING
SciCreateSymbolicLinks(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG FilterTypeIndex,
    IN PHW_STREAM_HEADER StreamHeader)
/*++

Routine Description:

    Create symbolic links for all categories in the Topology of 
    one filter type so that clients can find them.
    The Symbolic link array is kept in the FilterType so that
    they can be released later.

Arguments:

    DeviceExtenion: The device instance.
    FiltertypeIndex: The filter type to create symbolic links.
    StreamHeader: Go thru the categories in the Topology.

Return Value:

    NTSTATUS

--*/
{
   	LPGUID  GuidIndex = (LPGUID)StreamHeader->Topology->Categories;
   	ULONG   ArrayCount = StreamHeader->Topology->CategoriesCount;
   	PUNICODE_STRING NamesArray;
    ULONG           i,j;
    HANDLE          ClassHandle, PdoHandle=NULL; // prefixbug 17135
    UNICODE_STRING  TempUnicodeString;
    PVOID           DataBuffer[MAX_STRING_LENGTH];
    //ULONG           NumberOfFilterTypes;
    NTSTATUS        Status=STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT_DEVICE_EXTENSION( DeviceExtension );
    
    //
    // allocate space for the array of catagory names
    //
    NamesArray = ExAllocatePool(PagedPool, sizeof(UNICODE_STRING) * ArrayCount);
    if ( NULL == NamesArray ) {
        DEBUG_BREAKPOINT();                           
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    //
    // zero the array in case we're unable to fill it in below.  the Destroy
    // routine below will then correctly handle this case.
    //

    RtlZeroMemory(NamesArray, sizeof(UNICODE_STRING) * ArrayCount);

    //
    // open the PDO
    //

    Status = IoOpenDeviceRegistryKey(
                            DeviceExtension->PhysicalDeviceObject,
                            PLUGPLAY_REGKEY_DRIVER,
                            STANDARD_RIGHTS_ALL,
                            &PdoHandle);
                            
    if ( !NT_SUCCESS(Status) ) {
        DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't open Pdo\n"));
        PdoHandle = NULL;
        goto Exit;
    }
    
    //
    // loop through each of the catagory GUID's for each of the pins,
    // creating a symbolic link for each one.
    //

    for (i = 0; i < ArrayCount; i++) {
        //
        // Create the symbolic link for each category
        //
        PKSOBJECT_CREATE_ITEM CreateItem;

        CreateItem = &DeviceExtension->CreateItems[FilterTypeIndex];

        DebugPrint((DebugLevelVerbose, 
                   "RegisterDeviceInterface FType %d,"
                   "CreateItemName=%S\n",
                   FilterTypeIndex,
                   CreateItem->ObjectClass.Buffer));
        
        Status = IoRegisterDeviceInterface(
                    DeviceExtension->PhysicalDeviceObject,
                    &GuidIndex[i],
                    (PUNICODE_STRING) &CreateItem->ObjectClass,
                    &NamesArray[i]);
                        
        if ( !NT_SUCCESS(Status)) {
            //
            //  Can't register device interface
            //
            DebugPrint((DebugLevelError,
                       "StreamCreateSymLinks: couldn't register\n"));
            DEBUG_BREAKPOINT();
            goto Exit;
        }

        DebugPrint((DebugLevelVerbose,
                   "SymbolicLink:%S\n",
                   NamesArray[i].Buffer));
        //
        // Now set the symbolic link for the association
        //
        Status = IoSetDeviceInterfaceState(&NamesArray[i], TRUE);
        if (!NT_SUCCESS(Status)) {
            //
            //  unsuccessful
            //
            DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't set\n"));
            DEBUG_BREAKPOINT();
            goto Exit;
        }
        //
        // add the strings from the PDO's key to the association key.
        // Performance Improvement Chance 
        //   - the INF should be able to directly propogate these;
        // forrest & lonny are fixing.
        //

        Status = IoOpenDeviceInterfaceRegistryKey(&NamesArray[i],
                                                  STANDARD_RIGHTS_ALL,
                                                  &ClassHandle);
        if ( !NT_SUCCESS( Status )) {
            //
            //  unsuccessful open Class interface
            //
            DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't set\n"));
            DEBUG_BREAKPOINT();
            goto Exit;
        }

        //
        // write the class ID for the proxy, if any.
        //
        Status = SCGetRegistryValue(PdoHandle,
                                    (PWCHAR) ClsIdString,
                                    sizeof(ClsIdString),
                                    DataBuffer,
                                    MAX_STRING_LENGTH);
                                    
        if ( NT_SUCCESS(Status) ){
            //
            // write the class ID for the proxy
            //
            RtlInitUnicodeString(&TempUnicodeString, ClsIdString);

            ZwSetValueKey(ClassHandle,
                          &TempUnicodeString,
                          0,
                          REG_SZ,
                          DataBuffer,
                          MAX_STRING_LENGTH);
        } // if cls guid read
        //
        // first check if a friendly name has already been propogated
        // to the class via the INF.   If not, we'll just use the device
        // description string for this.
        //
        Status = SCGetRegistryValue(ClassHandle,
                                    (PWCHAR) FriendlyNameString,
                                    sizeof(FriendlyNameString),
                                    DataBuffer,
                                    MAX_STRING_LENGTH);
                                    
        if ( !NT_SUCCESS(Status) ) {
            //
            // friendly name non-exists yet.
            // write the friendly name for the device, if any.
            //

            Status = SCGetRegistryValue(PdoHandle,
                                        (PWCHAR) DriverDescString,
                                        sizeof(DriverDescString),
                                        DataBuffer,
                                        MAX_STRING_LENGTH);
                                       
            if ( NT_SUCCESS(Status) ) {
                //
                // driver descrption string available, use it. 
                //
                RtlInitUnicodeString(&TempUnicodeString, FriendlyNameString);

                ZwSetValueKey(ClassHandle,
                              &TempUnicodeString,
                              0,
                              REG_SZ,
                              DataBuffer,
                              MAX_STRING_LENGTH);


            }
        }
        ZwClose(ClassHandle);

    } // for # Categories

    //
    // If we reach here, consider as successful.
    // 
    Status = STATUS_SUCCESS;

    Exit: {
        if ( NULL != PdoHandle ) {
            ZwClose(PdoHandle);
        }
        if ( !NT_SUCCESS( Status ) ) {
            if ( NULL != NamesArray ) {
                ExFreePool( NamesArray );
                NamesArray = NULL;
            }
        }
        return NamesArray;
    }
}


NTSTATUS
SciOnFilterStreamDescriptor(
    PFILTER_INSTANCE FilterInstance,
    PHW_STREAM_DESCRIPTOR StreamDescriptor)
/*++

Routine Description:

     Process the minidriver's stream descriptor structure.
     This is used for one FilterType specific streams.
     
Arguments:

     FilterInstance: The one that we are to process for.
     StreamDescriptor: Point to the descriptor to process for the filter.

Return Value:

     None.

--*/
{
    ULONG           NumberOfPins, i;
    PKSPIN_DESCRIPTOR PinDescs = NULL;
    PHW_STREAM_INFORMATION CurrentInfo;
    ULONG           PinSize;
    PSTREAM_ADDITIONAL_INFO NewStreamArray;
    NTSTATUS Status=STATUS_SUCCESS;
    
    PAGED_CODE();

    NumberOfPins = StreamDescriptor->StreamHeader.NumberOfStreams;

    DebugPrint((DebugLevelVerbose,
               "Parsing StreamInfo Pins=%x\n", NumberOfPins ));

    if (StreamDescriptor->StreamHeader.SizeOfHwStreamInformation < 
        sizeof(HW_STREAM_INFORMATION)) {

        DebugPrint((DebugLevelError, "minidriver stream info too small!"));

        DEBUG_BREAKPOINT();
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }    

    if (NumberOfPins) {
        //
        // parse the minidriver's info into CSA format to build the
        // mother of all structures.
        //

        PinSize = (sizeof(KSPIN_DESCRIPTOR) + sizeof(STREAM_ADDITIONAL_INFO))*
                    NumberOfPins;

        PinDescs = ExAllocatePool(NonPagedPool, PinSize);
        if (PinDescs == NULL) {
            DebugPrint((DebugLevelError, "Stream: No pool for stream info"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        RtlZeroMemory(PinDescs, PinSize);

        //
        // we need a new array to hold the new copies of the
        // stream properties and events which are allocated below.
        //

        NewStreamArray = (PSTREAM_ADDITIONAL_INFO) 
            ((PBYTE) PinDescs + sizeof(KSPIN_DESCRIPTOR) * NumberOfPins);

        FilterInstance->StreamPropEventArray = NewStreamArray;

        CurrentInfo = &StreamDescriptor->StreamInfo;

        for (i = 0; i < StreamDescriptor->StreamHeader.NumberOfStreams; i++) {
            //
            // process each pin info
            //
            
            PinDescs[i].InterfacesCount = SIZEOF_ARRAY(PinInterfaces);
            PinDescs[i].Interfaces = PinInterfaces;

            //
            // use default medium if minidriver does not specify
            //
            if (CurrentInfo->MediumsCount) {
                PinDescs[i].MediumsCount = CurrentInfo->MediumsCount;
                PinDescs[i].Mediums = CurrentInfo->Mediums;

            }
            else {
                PinDescs[i].MediumsCount = SIZEOF_ARRAY(PinMediums);
                PinDescs[i].Mediums = PinMediums;
            }

            //
            // set the # of data format blocks
            //

            PinDescs[i].DataRangesCount = 
                    CurrentInfo->NumberOfFormatArrayEntries;

            //
            // point to the data format blocks for the pin
            //

            PinDescs[i].DataRanges = CurrentInfo->StreamFormatsArray;

            //
            // set the data flow direction
            //

            PinDescs[i].DataFlow = (KSPIN_DATAFLOW) CurrentInfo->DataFlow;

            //
            // set the communication field
            //

            if (CurrentInfo->BridgeStream) {
                PinDescs[i].Communication = KSPIN_COMMUNICATION_BRIDGE;
            }
            else {
                #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
                PinDescs[i].Communication = KSPIN_COMMUNICATION_BOTH;
				#else
                PinDescs[i].Communication = KSPIN_COMMUNICATION_SINK;
				#endif
            }

            //
            // copy the pointers for the pin name and category
            //
            PinDescs[i].Category = CurrentInfo->Category;
            PinDescs[i].Name = CurrentInfo->Name;

            if ( CurrentInfo->NumStreamPropArrayEntries) {

                ASSERT(CurrentInfo->StreamPropertiesArray);
                //
                // make a copy of the properties since we modify the struct
                // though parts of it may be marked as a const.
                // Performance Imporovement Chance 
                //   - check for const in future if possible
                //

                if (!(NewStreamArray[i].StreamPropertiesArray = 
               		  SCCopyMinidriverProperties(
               		      CurrentInfo->NumStreamPropArrayEntries,
                          CurrentInfo->StreamPropertiesArray))) {
                        //
                        // Fail to copy
                        //
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                }
            }
            if (CurrentInfo->NumStreamEventArrayEntries) {

                ASSERT(CurrentInfo->StreamEventsArray);
                //
                // make a copy of the events since we modify the
                // struct
                // though parts of it may be marked as a const.
                // Performance Improvement Chance 
                //   - check for const in future if possible
                //
                    
                if (!(NewStreamArray[i].StreamEventsArray = 
                      SCCopyMinidriverEvents(
                            CurrentInfo->NumStreamEventArrayEntries,
                            CurrentInfo->StreamEventsArray))) {
                        //
                        // Fail to copy
                        //
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                }
                
            //
            // update the minidriver's properties for this stream.
            //
            SCUpdateMinidriverProperties(
            	    CurrentInfo->NumStreamPropArrayEntries,
            	    NewStreamArray[i].StreamPropertiesArray,
                    TRUE);

            //
            // update the minidriver's events for this stream.
            //
            SCUpdateMinidriverEvents(
	                CurrentInfo->NumStreamEventArrayEntries,
	                NewStreamArray[i].StreamEventsArray,
                    TRUE);


            //
            // index to next streaminfo structure.
            //
            CurrentInfo++;
        } // for # pins
    } // if there are pins

    if (StreamDescriptor->StreamHeader.NumDevPropArrayEntries) {

        ASSERT(StreamDescriptor->StreamHeader.DevicePropertiesArray);

        //
        // make a copy of the properties since we modify the struct
        // though parts of it may be marked as a const.
        // Performance Improvement Chance
        // - check for const in future if possible
        //

        if (!(FilterInstance->DevicePropertiesArray =
              SCCopyMinidriverProperties(
                StreamDescriptor->StreamHeader.NumDevPropArrayEntries,
                StreamDescriptor->StreamHeader.DevicePropertiesArray))) {
            //
            // Fail to copy
            //
            ASSERT( 0 );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
    }
    
    if (StreamDescriptor->StreamHeader.NumDevEventArrayEntries) {

        ASSERT(StreamDescriptor->StreamHeader.DeviceEventsArray);

        //
        // make a copy of the events since we modify the struct
        // though parts of it may be marked as a const.
        // Performance Improvement Chance
        //   - check for const in future if possible
        //

        if (!(FilterInstance->EventInfo =
              SCCopyMinidriverEvents(
                StreamDescriptor->StreamHeader.NumDevEventArrayEntries,
                StreamDescriptor->StreamHeader.DeviceEventsArray))) {
            //
            // Fail to copy
            //
            ASSERT( 0 );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
    }

    #ifdef ENABLE_KS_METHODS
    //
    // process the device methods
    //
    if (StreamDescriptor->StreamHeader.NumDevMethodArrayEntries) {

        ASSERT(StreamDescriptor->StreamHeader.DeviceMethodsArray);

        //
        // make a copy of the properties since we modify the struct
        // though parts of it may be marked as a const.
        // Performance Improvement Chance
        //   - check for const in future if possible
        //

        if (!(FilterInstance->DeviceMethodsArray =
              SCCopyMinidriverMethods(
                StreamDescriptor->StreamHeader.NumDevMethodArrayEntries,
                StreamDescriptor->StreamHeader.DeviceMethodsArray))) {
            //
            // Fail to copy
            //
            ASSERT( 0 );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
    }
	#endif
  
    //
    // process the minidriver's device properties.
    //

    SCUpdateMinidriverProperties(
          StreamDescriptor->StreamHeader.NumDevPropArrayEntries,
          FilterInstance->DevicePropertiesArray,
          FALSE);


    //
    // process the minidriver's device events.
    //

    SCUpdateMinidriverEvents(
          StreamDescriptor->StreamHeader.NumDevEventArrayEntries,
          FilterInstance->EventInfo,
          FALSE);

	#ifdef ENABLE_KS_METHODS
    //
    // process the minidriver's device methods.
    //

    SCUpdateMinidriverMethods(
          StreamDescriptor->StreamHeader.NumDevMethodArrayEntries,
          FilterInstance->DeviceMethodsArray,
              FALSE);
	#endif

    //
    // set the event info count in the device extension
    //

    FilterInstance->EventInfoCount = 
            StreamDescriptor->StreamHeader.NumDevEventArrayEntries;

    FilterInstance->HwEventRoutine = 
            StreamDescriptor->StreamHeader.DeviceEventRoutine;

    //
    // call routine to save new stream info
    //

    SciInsertFilterStreamInfo(FilterInstance,
                              PinDescs,
                              NumberOfPins);
	
    Exit:{
        // ToDo: need to cleanup in error conditions.
        return Status;
    }
}

VOID
SciInsertFilterStreamInfo(
    IN PFILTER_INSTANCE FilterInstance,
    IN PKSPIN_DESCRIPTOR PinDescs,
    IN ULONG NumberOfPins)
/*++

Routine Description:

Arguments:

Return Value:

     None.

--*/
{
    PAGED_CODE();

    //
    // save the pin info in the dev extension
    //

    if (FilterInstance->PinInformation) {

        ExFreePool(FilterInstance->PinInformation);
    }
    FilterInstance->PinInformation = PinDescs;
    FilterInstance->NumberOfPins = NumberOfPins;
    
    return;
}

NTSTATUS
SCStreamInfoCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the minidriver's stream info structure(s). This is used to 
     process an StreamDescriptor list as well as for one StreamInfo when 
     called by StreamClassReenumerateFilterStreams() to rescan.
     
Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/
{
	PHW_STREAM_DESCRIPTOR StreamDescriptor;
	PDEVICE_EXTENSION 	  DeviceExtension;
	NTSTATUS              Status;
	
	DeviceExtension= (PDEVICE_EXTENSION)SRB->HwSRB.HwDeviceExtension -1;

	ASSERT_DEVICE_EXTENSION( DeviceExtension );
	
	if ( NULL == SRB->HwSRB.HwInstanceExtension ) {
		//
		// This is a complete list of StreamInfos for the mini driver
		//
	
		//
		// some validations and Just hang it off the DeviceExtension
		//
		ULONG TotalLength;
		ULONG ul;
		PFILTER_TYPE_INFO FilterTypeInfo;
		PHW_STREAM_DESCRIPTOR NextStreamDescriptor;
		BOOLEAN         RequestIssued;


        FilterTypeInfo = DeviceExtension->FilterTypeInfos;
		StreamDescriptor = 
			(PHW_STREAM_DESCRIPTOR) SRB->HwSRB.CommandData.StreamBuffer;
		DeviceExtension->StreamDescriptor = StreamDescriptor;
		NextStreamDescriptor = StreamDescriptor;
		
		Status = STATUS_SUCCESS;

        //
        // take the event early here. an open could come in the middle of
        // enabling device interface.
        //
        KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);
		
		for ( ul=0, TotalLength=0; 
			  ul < DeviceExtension->NumberOfFilterTypes;
			  ul++) {
	        //
	        // need a StreamDescriptor for each filter type
	        //
	        if ((TotalLength+sizeof(HW_STREAM_HEADER) >
                 SRB->HwSRB.ActualBytesTransferred ) ||
                (sizeof(HW_STREAM_INFORMATION) !=
                 NextStreamDescriptor->StreamHeader.SizeOfHwStreamInformation)){
                //
                // Invalid data, bail out                
                //
                DEBUG_BREAKPOINT();
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if ( !(DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD )) {
                //
                // Don't create symbolic link if loaded by SWEnum which
                // will create a duplicate one.
                //
                // create the symbolic link to the device.
                //

                FilterTypeInfo[ul].SymbolicLinks = 
                    SciCreateSymbolicLinks( 
                           DeviceExtension,
                           ul,
                           &NextStreamDescriptor->StreamHeader );
                FilterTypeInfo[ul].LinkNameCount = 
                    NextStreamDescriptor->StreamHeader.Topology->CategoriesCount;
            }

            else {
                //
                // no creation, 0 count and null pointer.
                //
                FilterTypeInfo[ul].LinkNameCount = 0;
                FilterTypeInfo[ul].SymbolicLinks = NULL;
            }

    		FilterTypeInfo[ul].StreamDescriptor = NextStreamDescriptor;
    		

		    TotalLength = TotalLength + 
		                  sizeof(HW_STREAM_HEADER) +
		                  (sizeof(HW_STREAM_INFORMATION) *
		                   NextStreamDescriptor->StreamHeader.NumberOfStreams);

	        DebugPrint((DebugLevelVerbose, "TotalLength=%d\n", TotalLength ));
		                     
            NextStreamDescriptor = (PHW_STREAM_DESCRIPTOR)
                    ((PBYTE) StreamDescriptor + TotalLength);
            
		}
		
	    if ( TotalLength != SRB->HwSRB.ActualBytesTransferred ) {
	        DebugPrint((DebugLevelWarning,
	                   "TotalLength %x of StreamInfo not equal to "
	                   "ActualBytesTransferred %x\n",
	                   TotalLength,
	                   SRB->HwSRB.ActualBytesTransferred ));
	    }

	    DeviceExtension->Flags |= DEVICE_FLAGS_PNP_STARTED;

        //
        // call the minidriver to indicate that initialization is
        // complete.
        //

        SCSubmitRequest(SRB_INITIALIZATION_COMPLETE,
                NULL,
                0,
                SCDequeueAndDeleteSrb,
                DeviceExtension,
                NULL,
                NULL,
                SRB->HwSRB.Irp,
                &RequestIssued,
                &DeviceExtension->PendingQueue,
                (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket
                );


        //
        // tell the device to power down now, since it is not yet opened.
        // acquire the control event since this routine needs it.
        //
        
        //KeWaitForSingleObject(&DeviceExtension->ControlEvent,
        //                      Executive,
        //                      KernelMode,
        //                      FALSE,    // not alertable
        //                      NULL);

        SCCheckPowerDown(DeviceExtension);

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
	}

	else {
        //
        // This is a rescan for the specific FilterInstance
        //

		PFILTER_INSTANCE FilterInstance;

		FilterInstance = (PFILTER_INSTANCE) SRB->HwSRB.HwInstanceExtension-1;
		StreamDescriptor = (PHW_STREAM_DESCRIPTOR) 
		                    SRB->HwSRB.CommandData.StreamBuffer;

		Status = SciOnFilterStreamDescriptor(
		                FilterInstance,
		                StreamDescriptor);

        if ( NT_SUCCESS( Status ) ) {
            ASSERT( NULL != FilterInstance->StreamDescriptor );
            ExFreePool( FilterInstance->StreamDescriptor );
            ///if ( InterlockedExchange( &FilterInstance->Reenumerated, 1)) {
            ///    ASSERT( FilterInstance->StreamDescriptor );
            ///    ExFreePool( FilterInstance->StreamDescriptor );
            ///}
            FilterInstance->StreamDescriptor = StreamDescriptor;
        }
	}
	
    return (SCProcessCompletedRequest(SRB));
}



#else // ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SCStreamInfoCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the minidriver's stream info structure.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{

    PHW_STREAM_DESCRIPTOR StreamDescriptor = SRB->HwSRB.CommandData.StreamBuffer;
    ULONG           NumberOfPins,
                    i;
    PKSPIN_DESCRIPTOR PinDescs = NULL;
    PHW_STREAM_INFORMATION CurrentInfo;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    ULONG           PinSize;
    BOOLEAN         Rescan = FALSE;
    BOOLEAN         RequestIssued;
    PSTREAM_ADDITIONAL_INFO NewStreamArray;

    PAGED_CODE();

    //
    // if this is a stream rescan, set the boolean
    //

    if (DeviceExtension->StreamDescriptor) {

        Rescan = TRUE;

    }
    if (NT_SUCCESS(SRB->HwSRB.Status)) {
        NumberOfPins = StreamDescriptor->StreamHeader.NumberOfStreams;

        if (StreamDescriptor->StreamHeader.SizeOfHwStreamInformation < sizeof(HW_STREAM_INFORMATION)) {

            DebugPrint((DebugLevelError,
                    "DecoderClassInit: minidriver stream info too small!"));

            DEBUG_BREAKPOINT();
            SRB->HwSRB.Status = STATUS_REVISION_MISMATCH;

            //
            // if this is not a rescan, uninitialize
            //

            if (!Rescan) {

                SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                         SRB->HwSRB.Irp);
            }
            return (SCProcessCompletedRequest(SRB));
        }
        if (NumberOfPins) {

            //
            // parse the minidriver's info into CSA format to build the
            // mother of all structures.
            //

            PinSize = (sizeof(KSPIN_DESCRIPTOR) + sizeof(STREAM_ADDITIONAL_INFO)) * NumberOfPins;

            PinDescs = ExAllocatePool(NonPagedPool,
                                      PinSize);
            if (PinDescs == NULL) {
                DebugPrint((DebugLevelError,
                            "DecoderClassInit: No pool for stream info"));

                SRB->HwSRB.Status = STATUS_INSUFFICIENT_RESOURCES;

                //
                // if this is not a rescan, uninitialize
                //

                if (!Rescan) {
                    SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                             SRB->HwSRB.Irp);
                }
                return (SCProcessCompletedRequest(SRB));
            }
            RtlZeroMemory(PinDescs, PinSize);

            //
            // we need a new array to hold the new copies of the
            // stream properties and events which are allocated below.
            //

            NewStreamArray = (PSTREAM_ADDITIONAL_INFO) ((ULONG_PTR) PinDescs + sizeof(KSPIN_DESCRIPTOR) * NumberOfPins);

            DeviceExtension->StreamPropEventArray = NewStreamArray;

            CurrentInfo = &StreamDescriptor->StreamInfo;

            for (i = 0; i < StreamDescriptor->StreamHeader.NumberOfStreams; i++) {


                PinDescs[i].InterfacesCount = SIZEOF_ARRAY(PinInterfaces);
                PinDescs[i].Interfaces = PinInterfaces;

                //
                // use default medium if minidriver does not specify
                //

                if (CurrentInfo->MediumsCount) {

                    PinDescs[i].MediumsCount = CurrentInfo->MediumsCount;
                    PinDescs[i].Mediums = CurrentInfo->Mediums;

                } else {

                    PinDescs[i].MediumsCount = SIZEOF_ARRAY(PinMediums);
                    PinDescs[i].Mediums = PinMediums;

                }               // if minidriver mediums

                //
                // set the # of data format blocks
                //

                PinDescs[i].DataRangesCount =
                    CurrentInfo->NumberOfFormatArrayEntries;

                //
                // point to the data format blocks for the pin
                //

                PinDescs[i].DataRanges = CurrentInfo->StreamFormatsArray;

                //
                // set the data flow direction
                //

                PinDescs[i].DataFlow = (KSPIN_DATAFLOW) CurrentInfo->DataFlow;

                //
                // set the communication field
                //

                if (CurrentInfo->BridgeStream) {

                    PinDescs[i].Communication = KSPIN_COMMUNICATION_BRIDGE;

                } else {

					#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
                    PinDescs[i].Communication = KSPIN_COMMUNICATION_BOTH;
					#else
                    PinDescs[i].Communication = KSPIN_COMMUNICATION_SINK;
					#endif
                }

                //
                // copy the pointers for the pin name and category
                //

                PinDescs[i].Category = CurrentInfo->Category;
                PinDescs[i].Name = CurrentInfo->Name;


                if ((!Rescan) && (CurrentInfo->NumStreamPropArrayEntries)) {

                    ASSERT(CurrentInfo->StreamPropertiesArray);

                    //
                    // make a copy of the properties since we modify the struct
                    // though parts of it may be marked as a const.
                    // Performance Improvement Chance
                    //   - check for const in future if possible
                    //

                    if (!(NewStreamArray[i].StreamPropertiesArray = SCCopyMinidriverProperties(CurrentInfo->NumStreamPropArrayEntries,
                                     CurrentInfo->StreamPropertiesArray))) {


                        SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                                 SRB->HwSRB.Irp);
                        return (SCProcessCompletedRequest(SRB));
                    }
                }
                if ((!Rescan) && (CurrentInfo->NumStreamEventArrayEntries)) {

                    ASSERT(CurrentInfo->StreamEventsArray);

                    //
                    // make a copy of the events since we modify the struct
                    // though parts of it may be marked as a const.
                    // Performance Improvement Chance:
                    //   - check for const in future if possible
                    //

                    if (!(NewStreamArray[i].StreamEventsArray = SCCopyMinidriverEvents(CurrentInfo->NumStreamEventArrayEntries,
                                         CurrentInfo->StreamEventsArray))) {


                        SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                                 SRB->HwSRB.Irp);
                        return (SCProcessCompletedRequest(SRB));
                    }
                }
                //
                // update the minidriver's properties for this stream.
                //

                SCUpdateMinidriverProperties(
                                     CurrentInfo->NumStreamPropArrayEntries,
                                    NewStreamArray[i].StreamPropertiesArray,
                                             TRUE);

                //
                // update the minidriver's events for this stream.
                //

                SCUpdateMinidriverEvents(
                                    CurrentInfo->NumStreamEventArrayEntries,
                                         NewStreamArray[i].StreamEventsArray,
                                         TRUE);


                //
                // index to next streaminfo structure.
                //

                CurrentInfo++;


            }                   // for # pins

        }                       // if pins
        if ((!Rescan) && (StreamDescriptor->StreamHeader.NumDevPropArrayEntries)) {

            ASSERT(StreamDescriptor->StreamHeader.DevicePropertiesArray);

            //
            // make a copy of the properties since we modify the struct
            // though parts of it may be marked as a const.
            // Performance Improvement Chance:
            //   - check for const in future if possible
            //

            if (!(DeviceExtension->DevicePropertiesArray =
                  SCCopyMinidriverProperties(StreamDescriptor->StreamHeader.NumDevPropArrayEntries,
                   StreamDescriptor->StreamHeader.DevicePropertiesArray))) {


                SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                         SRB->HwSRB.Irp);
                return (SCProcessCompletedRequest(SRB));
            }
        }
        if ((!Rescan) && (StreamDescriptor->StreamHeader.NumDevEventArrayEntries)) {

            ASSERT(StreamDescriptor->StreamHeader.DeviceEventsArray);

            //
            // make a copy of the events since we modify the struct
            // though parts of it may be marked as a const.
            // Performance Improvement Chance
            //   - check for const in future if possible
            //

            if (!(DeviceExtension->EventInfo =
                  SCCopyMinidriverEvents(StreamDescriptor->StreamHeader.NumDevEventArrayEntries,
                       StreamDescriptor->StreamHeader.DeviceEventsArray))) {


                SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                         SRB->HwSRB.Irp);
                return (SCProcessCompletedRequest(SRB));
            }
        }

		#ifdef ENABLE_KS_METHODS
        //
        // process the device methods
        //
        if ((!Rescan) && (StreamDescriptor->StreamHeader.NumDevMethodArrayEntries)) {

            ASSERT(StreamDescriptor->StreamHeader.DeviceMethodsArray);

            //
            // make a copy of the properties since we modify the struct
            // though parts of it may be marked as a const.
            // Performance Improvement Chance
            //   - check for const in future if possible
            //

            if (!(DeviceExtension->DeviceMethodsArray =
                  SCCopyMinidriverMethods(StreamDescriptor->StreamHeader.NumDevMethodArrayEntries,
                   StreamDescriptor->StreamHeader.DeviceMethodsArray))) {


                SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                         SRB->HwSRB.Irp);
                return (SCProcessCompletedRequest(SRB));
            }
        }
		#endif
  
        //
        // process the minidriver's device properties.
        //

        SCUpdateMinidriverProperties(
                      StreamDescriptor->StreamHeader.NumDevPropArrayEntries,
                                     DeviceExtension->DevicePropertiesArray,
                                     FALSE);


        //
        // process the minidriver's device events.
        //

        SCUpdateMinidriverEvents(
                     StreamDescriptor->StreamHeader.NumDevEventArrayEntries,
                                 DeviceExtension->EventInfo,
                                 FALSE);

		#ifdef ENABLE_KS_METHODS
        //
        // process the minidriver's device methods.
        //

        SCUpdateMinidriverMethods(
                     StreamDescriptor->StreamHeader.NumDevMethodArrayEntries,
                                 DeviceExtension->DeviceMethodsArray,
                                 FALSE);
		#endif

        //
        // set the event info count in the device extension
        //

        DeviceExtension->EventInfoCount = StreamDescriptor->StreamHeader.NumDevEventArrayEntries;

        DeviceExtension->HwEventRoutine = StreamDescriptor->StreamHeader.DeviceEventRoutine;

        //
        // call routine to save new stream info
        //

        SCInsertStreamInfo(DeviceExtension,
                		   PinDescs,
                           StreamDescriptor,
                           NumberOfPins);


        if (!Rescan) {

            //
            // show device is started from PNP's perspective
            //            

            DeviceExtension->Flags |= DEVICE_FLAGS_PNP_STARTED;

            //
            // create the symbolic link to the device.
            //

            if ( !(DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD )) {
                //
                // Don't create symbolic link if loaded by SWEnum which
                // will create a duplicate one.
                //
                // create the symbolic link to the device.
                //

                SCCreateSymbolicLinks(DeviceExtension);
            }

            //
            // call the minidriver to indicate that initialization is
            // complete.
            //


            SCSubmitRequest(SRB_INITIALIZATION_COMPLETE,
                            NULL,
                            0,
                            SCDequeueAndDeleteSrb,
                            DeviceExtension,
                            NULL,
                            NULL,
                            SRB->HwSRB.Irp,
                            &RequestIssued,
                            &DeviceExtension->PendingQueue,
                            (PVOID) DeviceExtension->
                            MinidriverData->HwInitData.
                            HwReceivePacket
                );


            //
            // tell the device to power down now, since it is not yet opened.
            // acquire the control event since this routine needs it.

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,    // not alertable
                                  NULL);

            SCCheckPowerDown(DeviceExtension);

        }                       // if !rescan
        //
        // release the event. if we are doing a rescan, this is taken
        // by the caller.  If not, we took it a few lines above.
        //

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    }                           // if good status
    //
    // complete this SRB and the original IRP with the final
    // status.
    //

    return (SCProcessCompletedRequest(SRB));

}

VOID
SCInsertStreamInfo(
                   IN PDEVICE_EXTENSION DeviceExtension,
                   IN PKSPIN_DESCRIPTOR PinDescs,
                   IN PHW_STREAM_DESCRIPTOR StreamDescriptor,
                   IN ULONG NumberOfPins
)
/*++

Routine Description:

Arguments:

Return Value:

     None.

--*/

{
    PAGED_CODE();

    //
    // save the pin info in the dev extension
    //

    if (DeviceExtension->PinInformation) {

        ExFreePool(DeviceExtension->PinInformation);
    }
    DeviceExtension->PinInformation = PinDescs;
    DeviceExtension->NumberOfPins = NumberOfPins;

    //
    // save the minidriver's descriptor also.
    //

    if (DeviceExtension->StreamDescriptor) {

        ExFreePool(DeviceExtension->StreamDescriptor);
    }
    DeviceExtension->StreamDescriptor = StreamDescriptor;

    return;

}

#endif //ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SCPowerCallback(
                IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     SRB callback procedure for powering down the hardware

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    NTSTATUS        Status = STATUS_SUCCESS;
    PIRP            Irp = SRB->HwSRB.Irp;

    PAGED_CODE();

    // These are the return codes that the minidriver is permitted to return,
    // but there is no reason to make this a retail check since we are mandated
    // to never fail a power IRP.
    ASSERT(
        SRB->HwSRB.Status == STATUS_SUCCESS ||
        SRB->HwSRB.Status == STATUS_NOT_IMPLEMENTED ||
        SRB->HwSRB.Status == STATUS_NOT_SUPPORTED ||
        SRB->HwSRB.Status == STATUS_IO_DEVICE_ERROR
        );

    //
    // set the new power state in the device extension.
    //
    SCSetCurrentDPowerState (DeviceExtension, SRB->HwSRB.CommandData.DeviceState);

    //
    // free our SRB structure
    //

    SCDequeueAndDeleteSrb(SRB);

    //
    // if the state is NOT a power up, we must now send it to the PDO
    // for postprocessing.
    //

    if (DeviceExtension->CurrentPowerState != PowerDeviceD0) {

        //
        // send the Irp down to the next layer, and return that status
        // as the final one.
        //

        Status = SCCallNextDriver(DeviceExtension, Irp);

		#if DBG
        if (!NT_SUCCESS(Status)) {

            DebugPrint((DebugLevelError, "'SCPowerCB: PDO failed power request!\n"));
        }
		#endif

    }
    PoStartNextPowerIrp(Irp);
    SCCompleteIrp(Irp, Status, DeviceExtension);

    return (Status);
}


NTSTATUS
SCUninitializeMinidriver(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp)
/*++

Routine Description:

    This function calls the minidriver's HWUninitialize routine.  If
    successful, all adapter resources are freed, and the adapter is marked
    as stopped.

Arguments:

    DeviceObject - pointer to device object for adapter
    Irp - pointer to the PNP Irp.

Return Value:

     NT status code is returned.

--*/

{
    PHW_INITIALIZATION_DATA HwInitData;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    //
    // call minidriver to indicate we are uninitializing.
    //

    DeviceExtension = DeviceObject->DeviceExtension;

    //
    // remove the symbolic links for the device
    //

    SCDestroySymbolicLinks(DeviceExtension);

    //
    // show one less I/O on this call since our wait logic won't
    // finish until the I/O count goes to zero.
    //

    InterlockedDecrement(&DeviceExtension->OneBasedIoCount);

    //
    // wait for any outstanding I/O to complete
    //

    SCWaitForOutstandingIo(DeviceExtension);
    
    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);
    // release event at the callback. or next if !RequestIssued.
        
    //
    // restore I/O count to one as we have the PNP I/O outstanding.
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    HwInitData = &DeviceExtension->MinidriverData->HwInitData;

    Status = SCSubmitRequest(SRB_UNINITIALIZE_DEVICE,
                             NULL,
                             0,
                             SCUninitializeCallback,
                             DeviceExtension,
                             NULL,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket);

    if (!RequestIssued) {
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    }                             
                             
    return (Status);

}


NTSTATUS
SCUninitializeCallback(
                       IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

    SRB callback procedure for uninitialize

Arguments:

    SRB - pointer to the uninitialize SRB

Return Value:

     NT status code is returned.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status = SRB->HwSRB.Status;

    PAGED_CODE();

    //
    // free all adapter resources we allocated on the START
    // function if the minidriver did not fail
    //

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);


    if (Status != STATUS_ADAPTER_HARDWARE_ERROR) {

        //
        // show not started
        //

        DeviceExtension->Flags &= ~DEVICE_FLAGS_PNP_STARTED;

        //
        // free all resources on our device.
        //

        SCFreeAllResources(DeviceExtension);

    }                           // if hwuninitialize
    //
    // free the SRB but don't call back the IRP.
    //

    SCDequeueAndDeleteSrb(SRB);

    return (Status);
}

PVOID
StreamClassGetDmaBuffer(
                        IN PVOID HwDeviceExtension)
/*++

Routine Description:

     This function returns the DMA buffer previously allocated.


Arguments:

    HwDeviceExtension - Supplies a pointer to the minidriver's device extension.

Return Value:

    A pointer to the uncached device extension or NULL if the extension could
    not be allocated.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) HwDeviceExtension - 1;
    return (DeviceExtension->DmaBuffer);
}



NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    Entry point for explicitely loaded stream class.

Arguments:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - unused.

Return Value:

   STATUS_SUCCESS

--*/
{

    UNREFERENCED_PARAMETER(DriverObject);
    PAGED_CODE();
    DEBUG_BREAKPOINT();
    return STATUS_SUCCESS;
}

#if DBG

#define DEFAULT_STREAMDEBUG     1
#define DEFAULT_MAX_LOG_ENTRIES 1024
#define SCLOG_LEVEL             0
#define SCLOG_MASK              0
#define SCLOG_FL_PNP            0x0001

#define STR_REG_DBG_STREAM L"\\Registry\\Machine\\system\\currentcontrolset\\services\\stream"

typedef struct _SCLOG_ENTRY {
    ULONG ulTag;
    ULONG ulArg1;
    ULONG ulArg2;
    ULONG ulArg3;
} SCLOG_ENTRY, *PSCLOG_ENTRY;

PSCLOG_ENTRY psclogBuffer;
ULONG scLogNextEntry;
ULONG scMaxLogEntries;
ULONG sclogMask;
ULONG ulTimeIncrement;

NTSTATUS
SCLog(
	ULONG ulTag,
	ULONG ulArg1,
	ULONG ulArg2,
	ULONG ulArg3 )
/*++
	Description:
	    Log the information to the psclogBuffer in a circular mannar. Start from entry 0.
    	Wrap around when we hit the end.

    Parameters:
        ulTag: Tag for the log entry
        ulArg1: argument 1
        ulArg2: argument 2
        ulArg3: argument 3

    Return:
        SUCCESS: if logged
        UNSUCCESSFUL: otherwise

--*/
{
    NTSTATUS Status=STATUS_UNSUCCESSFUL;
	ULONG ulMyLogEntry;

	if ( NULL == psclogBuffer ) return Status;

    //
    // grab the line ticket
    //
	ulMyLogEntry = (ULONG)InterlockedIncrement( &scLogNextEntry );
	//
	// land in the range
	//
	ulMyLogEntry = ulMyLogEntry % scMaxLogEntries;

    //
    // fill the entry
    //
	psclogBuffer[ulMyLogEntry].ulTag = ulTag;
	psclogBuffer[ulMyLogEntry].ulArg1 = ulArg1;
	psclogBuffer[ulMyLogEntry].ulArg2 = ulArg2;
	psclogBuffer[ulMyLogEntry].ulArg3 = ulArg3;

	if ( sclogMask & SCLOG_FLAGS_PRINT)  {
		char *pCh=(char*) &ulTag;
		DbgPrint( "++scLOG %c%c%c%c %08x %08x %08x\n", 
				 pCh[0], pCh[1], pCh[2], pCh[3],
				 ulArg1,
				 ulArg2,
				 ulArg3);
	}
	return STATUS_SUCCESS;
}

NTSTATUS SCLogWithTime(
    ULONG ulTag,
    ULONG ulArg1,
    ULONG ulArg2 )
/*++
    Description:
        A wrapper to SCLog to also log time in ms in the record. We can have one less
        Argument because time use 1.

    Parameters:
        ulTag: Tag for the log entry
        ulArg1: argument 1
        ulArg2: argument 2

    Return:
        SUCCESS: if logged
        UNSUCCESSFUL: otherwise

--*/
{
    LARGE_INTEGER liTime;
    ULONG ulTime;


    KeQueryTickCount(&liTime);
	ulTime = (ULONG)(liTime.QuadPart*ulTimeIncrement/10000); // convert to ms
    
    if ( NULL == psclogBuffer ) return STATUS_UNSUCCESSFUL;
    return SCLog( ulTag, ulArg1, ulArg2, ulTime );
}

NTSTATUS
DbgDllUnload()
/*++
    called by DllUnload to undo the work at DllInitialize

--*/
{
    if ( NULL != psclogBuffer ) {
        ExFreePool( psclogBuffer );
    }

    return STATUS_SUCCESS;
}



NTSTATUS
SCGetRegValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *Information
    )

/*++

Routine Description:

    Copied from IopGetRegistryValue().
    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePool( NonPagedPool, keyValueLength );
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}

NTSTATUS
SCGetRegDword(
    HANDLE h,
    PWCHAR ValueName,
    PULONG pDword)
{
    NTSTATUS Status;
    PKEY_VALUE_FULL_INFORMATION pFullInfo;

    Status = SCGetRegValue( h, ValueName, &pFullInfo );
    if ( NT_SUCCESS( Status ) ) {
        *pDword = *(PULONG)((PUCHAR)pFullInfo+pFullInfo->DataOffset);
        ExFreePool( pFullInfo );
    }
    return Status;
}

NTSTATUS
SCSetRegDword(
    IN HANDLE KeyHandle,
    IN PWCHAR ValueName,
    IN ULONG  ValueData
    )

/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) 
type.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the name of the value key

    ValueData - Supplies a pointer to the value to be stored in the key.  

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    ASSERT(ValueName);

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Set the registry value
    //
    Status = ZwSetValueKey(KeyHandle,
                    &unicodeString,
                    0,
                    REG_DWORD,
                    &ValueData,
                    sizeof(ValueData));
    
    return Status;
}


NTSTATUS
SCCreateDbgReg(void)
{
    NTSTATUS Status;
    HANDLE   hStreamDebug;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING  PathName;
    UNICODE_STRING  uiStreamDebug;
    ULONG ulDisposition;
    ULONG dword;
    static WCHAR strStreamDebug[]=L"StreamDebug";
    static WCHAR strMaxLogEntries[]=L"MaxLogEntries";
    static WCHAR strLogMask[]=L"MaxMask";

    RtlInitUnicodeString( &PathName, STR_REG_DBG_STREAM );
    
    InitializeObjectAttributes(&objectAttributes,
                                &PathName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);
    
    Status = ZwCreateKey( &hStreamDebug,
                            KEY_ALL_ACCESS,
                            &objectAttributes,
                            0, // title index
                            NULL, // class
                            0,// create options
                            &ulDisposition);

    if ( NT_SUCCESS( Status )) {
        //
        // getset StreamDebug
        //
        Status = SCGetRegDword( hStreamDebug, strStreamDebug, &dword);
        if ( NT_SUCCESS( Status )) {
            extern ULONG StreamDebug;
            StreamDebug = dword;
        }
        else if ( STATUS_OBJECT_NAME_NOT_FOUND == Status ) {
            //
            // create one with the default value
            //
            Status = SCSetRegDword(hStreamDebug, strStreamDebug, DEFAULT_STREAMDEBUG);
            ASSERT( NT_SUCCESS( Status ));
        }

        //
        // getset LogMask
        //        
        Status = SCGetRegDword( hStreamDebug, strLogMask, &dword);
        if ( NT_SUCCESS( Status )) {
            sclogMask=dword;
        }
        else if ( STATUS_OBJECT_NAME_NOT_FOUND == Status ) {
            //
            // create one with the default to all ( 0x7fffffff )
            //
            Status = SCSetRegDword(hStreamDebug, strLogMask, 0x7fffffff);
            ASSERT( NT_SUCCESS( Status ));
        }        
        
        //
        // getset MaxLogEntries
        //
        Status = SCGetRegDword( hStreamDebug, strMaxLogEntries, &dword);
        if ( NT_SUCCESS( Status )) {
            scMaxLogEntries=dword;
        }
        
        else if ( STATUS_OBJECT_NAME_NOT_FOUND == Status ) {
            //
            // create one with the default value
            //
            Status = SCSetRegDword(hStreamDebug, strMaxLogEntries, DEFAULT_MAX_LOG_ENTRIES);
            ASSERT( NT_SUCCESS( Status ));
        }

        ZwClose( hStreamDebug );
    }

    return Status;
}

NTSTATUS
SCInitDbg( 
    void )
{
    NTSTATUS Status;
    

    Status = SCCreateDbgReg(); // read or create

    if ( NT_SUCCESS( Status ) ) {
        if ( scMaxLogEntries ) {
            psclogBuffer = ExAllocatePool( NonPagedPool, scMaxLogEntries*sizeof(SCLOG_ENTRY));            
            if ( NULL == psclogBuffer ) {
                DbgPrint( "SC: Cant allocate log buffer for %d entries\n", scMaxLogEntries );
                sclogMask = 0; // disable logging
            }
            else {
                DbgPrint( "SC: Allocate log buffer for %d entries\n", scMaxLogEntries );
                ulTimeIncrement = KeQueryTimeIncrement();
            }
        }
    }
    return Status;
}


#endif // DBG

NTSTATUS
DllInitialize(
    IN PUNICODE_STRING RegistryPath
    )
/*++
Description:
    System invokes this entry point when it load the image in memory.

Arguments:
    RegistryPath - unreferenced parameter.

Return:
    STATUS_SUCCESS or appropriate error code.        
--*/
{
    //UNICODE_STRING DriverName;
    NTSTATUS Status=STATUS_SUCCESS;

    PAGED_CODE();

    #if DBG
    Status = SCInitDbg();
    #endif 
    //RtlInitUnicodeString(&DriverName, STREAM_DRIVER_NAME);
    //Status = IoCreateDriver(&DriverName, StreamDriverEntry);
        
    if(!NT_SUCCESS(Status)){
        DbgPrint("Stream DLL Initialization failed = %x\n",Status);
        ASSERT(FALSE);        
    }
    return Status;
}


VOID
SCFreeAllResources(
    IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    This functions deletes all of the storage associated with a device
    extension, disconnects from the timers and interrupts.
    This function can be called any time during the initialization.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension to be processed.

Return Value:

    None.

--*/
{

    PMAPPED_ADDRESS tempPointer;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo;
    PADAPTER_OBJECT DmaAdapterObject;
    ULONG           DmaBufferSize;
    ULONG           i;
    PSTREAM_ADDITIONAL_INFO NewStreamArray;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCFreeAllResources: enter\n"));

    //
    // take the event to avoid race with the CLOSE handler, which is
    // the only code that will be executed at this point since the
    // INACCESSIBLE bit has been set.
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    //
    // if an interrupt is in use, disconnect from it.
    //

    if ((DeviceExtension->InterruptObject != (PKINTERRUPT) DeviceExtension) &&
        (DeviceExtension->InterruptObject != NULL)) {

        DebugPrint((DebugLevelVerbose, "'SCFreeAllResources: Interrupt Disconnect\n"));
        IoDisconnectInterrupt(DeviceExtension->InterruptObject);

        //
        // change the synchronization mechanism to internal, since
        // the IRQ is gone away, hence IRQL level sync.
        //

        DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;
        DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

    }
    //
    // Free the configuration information structure if it exists.
    //

    ConfigInfo = DeviceExtension->ConfigurationInformation;
    if (ConfigInfo) {

        //
        // free the access range structure if it exists
        //

        if (ConfigInfo->AccessRanges) {
            ExFreePool(ConfigInfo->AccessRanges);
        }
        DebugPrint((DebugLevelVerbose, "'SCFreeAllResources: freeing ConfigurationInfo\n"));
        ExFreePool(ConfigInfo);
        DeviceExtension->ConfigurationInformation = NULL;
    }
    //
    // free the DMA adapter object and DMA buffer if present
    //

    DmaAdapterObject = DeviceExtension->DmaAdapterObject;


    if (DmaAdapterObject) {

        DmaBufferSize = DeviceExtension->DriverInfo->HwInitData.DmaBufferSize;

        if (DeviceExtension->DmaBufferPhysical.QuadPart) {

            //
            // free the DMA buffer
            //

            DebugPrint((DebugLevelVerbose, "'StreamClass SCFreeAllResources- Freeing DMA stuff\n"));
            HalFreeCommonBuffer(DmaAdapterObject,
                                DmaBufferSize,
                                DeviceExtension->DmaBufferPhysical,
                                DeviceExtension->DmaBuffer,
                                FALSE);
        }
        DeviceExtension->DmaAdapterObject = NULL;
    }
    //
    // Unmap any mapped areas.
    //

    while (DeviceExtension->MappedAddressList != NULL) {
        DebugPrint((DebugLevelVerbose, "'SCFreeAllResources: unmapping addresses\n"));
        MmUnmapIoSpace(
                       DeviceExtension->MappedAddressList->MappedAddress,
                       DeviceExtension->MappedAddressList->NumberOfBytes
            );

        tempPointer = DeviceExtension->MappedAddressList;
        DeviceExtension->MappedAddressList =
            DeviceExtension->MappedAddressList->NextMappedAddress;

        ExFreePool(tempPointer);
    }

    DeviceExtension->MappedAddressList = NULL;

	//
	// We can't free FilterInstances or PinInstances. They
	// must be freed at close calls. However, release StreamDescriptor
	// which is allocated at Start device
	//
    if ( DeviceExtension->StreamDescriptor ) {
        ExFreePool( DeviceExtension->StreamDescriptor );
        DeviceExtension->StreamDescriptor = NULL;
    }
	
    //
    // Stop our timers and release event.
    //

    IoStopTimer(DeviceExtension->DeviceObject);
    KeCancelTimer(&DeviceExtension->ComObj.MiniDriverTimer);

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
}


#if ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SciFreeFilterInstance(
    PFILTER_INSTANCE pFilterInstance
)
/*++

    Free all resources associated with a FilterInstance and the filter
    instance itself. This function assume Device control event is taken
    by the caller.

    Argument:

        pFilterInstance : pointer to the filter instance to free

    Return:

        NTSTATUS: STATUS_SUCCESS of successful, error otherwise

--*/
{
    PDEVICE_EXTENSION       pDeviceExtension;
    PSTREAM_ADDITIONAL_INFO NewStreamArray;
    ULONG                   i;

    ASSERT_FILTER_INSTANCE( pFilterInstance );
    
    pDeviceExtension = pFilterInstance->DeviceExtension;

    ASSERT_DEVICE_EXTENSION( pDeviceExtension );


    NewStreamArray = pFilterInstance->StreamPropEventArray;
    pFilterInstance->StreamPropEventArray = NULL;

    DebugPrint((DebugLevelInfo,
               "Freeing filterinstance %x\n", pFilterInstance));

    while (!IsListEmpty( &pFilterInstance->FirstStream )) {

        //
        // free all stream instances
        //
        PLIST_ENTRY         Node;
        PSTREAM_OBJECT  StreamObject;

        DebugPrint((DebugLevelWarning,
                   "Freeing filterinstance %x still open streams\n", pFilterInstance));
        
        Node = RemoveHeadList( &pFilterInstance->FirstStream );

        StreamObject = CONTAINING_RECORD(Node,
                                         STREAM_OBJECT,
                                         NextStream);

        if ( NULL != StreamObject->ComObj.DeviceHeader )                                             {
            KsFreeObjectHeader( StreamObject->ComObj.DeviceHeader );
        }

        //
        // null out FsContext for "surprise" stop cases
        //
        ASSERT( StreamObject->FileObject );
        ASSERT( StreamObject->FileObject->FsContext );
        StreamObject->FileObject->FsContext = NULL;
        ExFreePool( StreamObject );
    }
		    
    if (pFilterInstance->StreamDescriptor) {

        //
   	    // free each of the property buffers for the pins
       	//

        DebugPrint((DebugLevelInfo,
                    "FI StreamDescriptor %x has %x pins\n",
                    pFilterInstance->StreamDescriptor,
                    pFilterInstance->StreamDescriptor->StreamHeader.NumberOfStreams));

        for (i = 0;
	       	 i < pFilterInstance->StreamDescriptor->StreamHeader.NumberOfStreams;
	       	 i++) {

	        if (NewStreamArray[i].StreamPropertiesArray) {
	        
   	        	DebugPrint((DebugLevelInfo,"\tFree pin %x Prop %x\n",
   	        	            i, NewStreamArray[i].StreamPropertiesArray));
    	        ExFreePool(NewStreamArray[i].StreamPropertiesArray);
        	}
        	
	        if (NewStreamArray[i].StreamEventsArray) {
   	        	DebugPrint((DebugLevelInfo,"\tFree pin %x event %x\n",
   	                       i, NewStreamArray[i].StreamEventsArray));
	    	    ExFreePool(NewStreamArray[i].StreamEventsArray);
    	    } 
    	}

	    if (pFilterInstance->DevicePropertiesArray) {
	    
        	DebugPrint((DebugLevelInfo,"Free dev prop %x\n",
   	    	            pFilterInstance->DevicePropertiesArray));
            ExFreePool(pFilterInstance->DevicePropertiesArray);
            pFilterInstance->DevicePropertiesArray = NULL;

	    }
	     
	    if (pFilterInstance->EventInfo) {
	     
            DebugPrint((DebugLevelInfo,"Free dev Event %x\n",
   	                   pFilterInstance->EventInfo));	    	    
    	    ExFreePool(pFilterInstance->EventInfo);
	    	pFilterInstance->EventInfo = NULL;
    	}

        //
    	// always allocate, always free
        //
        DebugPrint((DebugLevelInfo,"Free StreamDescriptor %x\n",
	               pFilterInstance->StreamDescriptor));
	                   
        ExFreePool(pFilterInstance->StreamDescriptor);
    	pFilterInstance->StreamDescriptor = NULL;
    }
    
	if (pFilterInstance->PinInformation) {
	
        DebugPrint((DebugLevelInfo,"Free pininformationn %x\n",
   	              		            pFilterInstance->PinInformation));
    	ExFreePool(pFilterInstance->PinInformation);
	    pFilterInstance->PinInformation = NULL;
	 }

	 if ( NULL != pFilterInstance->DeviceHeader ) {
	    KsFreeObjectHeader( pFilterInstance->DeviceHeader );
	    pFilterInstance->DeviceHeader = NULL;
	 }

	 if ( pFilterInstance->WorkerRead ) {
    	 KsUnregisterWorker( pFilterInstance->WorkerRead );
    	 pFilterInstance->WorkerRead = NULL;
     }

     if ( pFilterInstance->WorkerWrite ) {
       	 KsUnregisterWorker( pFilterInstance->WorkerWrite );
    	 pFilterInstance->WorkerWrite = NULL;
     }

	 //
	 // finally the pFilterInstance itself.
	 //
	 ExFreePool( pFilterInstance );

	 return STATUS_SUCCESS;
}

VOID
SCDestroySymbolicLinks(
    IN PDEVICE_EXTENSION DeviceExtension)
/*++

Routine Description:

    For all device interfaces of all filter types of a device, disable
    it and free the name list ofeach filter type

Arguments:

    DeviceExtension - pointer to the device extension to be processed.

Return Value:

    None.

--*/
{
    PFILTER_TYPE_INFO   FilterTypeInfo;
    ULONG               i, j;
    UNICODE_STRING      *LinkNames;
    ULONG               LinkNameCount;

    PAGED_CODE();

    for ( i =0; i < DeviceExtension->NumberOfFilterTypes; i++ ) {
    
        LinkNames = DeviceExtension->FilterTypeInfos[i].SymbolicLinks;
        LinkNameCount = DeviceExtension->FilterTypeInfos[i].LinkNameCount;
        //
        // if no names array, we're done.
        //

        if ( NULL == LinkNames ) {
            continue;
        }
        
        //
        // loop through each of the catagory GUID's for each of the pins,
        // deleting the symbolic link for each one.
        //

        for (j = 0; j < LinkNameCount; j++) {

            if (LinkNames[j].Buffer) {

                //
                // Delete the symbolic link, ignoring the status.
                //
                 DebugPrint((DebugLevelVerbose, 
                            " Deleteing symbolic link %S\n",
                            LinkNames[j].Buffer));
                            
                IoSetDeviceInterfaceState(&LinkNames[j], FALSE);

                //
                // free the buffer allocated by
                // IoRegisterDeviceClassAssociation.
                //
                ExFreePool(LinkNames[j].Buffer);
            }
        }

        //
        // free the links structure and null the pointer
        //

        ExFreePool(LinkNames);
        DeviceExtension->FilterTypeInfos[i].SymbolicLinks = NULL;
        
    } // for # of FilterTypes
    
    return;
}

#else // ENABLE_MULTIPLE_FILTER_TYPES

VOID
SCCreateSymbolicLinks(
                      IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

Arguments:

    DeviceExtension - Supplies a pointer to the device extension to be processed.

Return Value:

    None.

--*/
{
   	PHW_STREAM_DESCRIPTOR StreamDescriptor = DeviceExtension->StreamDescriptor;
   	LPGUID	GuidIndex = (LPGUID) StreamDescriptor->StreamHeader.Topology->Categories;
   	ULONG    ArrayCount = StreamDescriptor->StreamHeader.Topology->CategoriesCount;
	UNICODE_STRING *NamesArray;
    ULONG           i;
    HANDLE          ClassHandle,
                    PdoHandle;
    UNICODE_STRING  TempUnicodeString;
    PVOID           DataBuffer[MAX_STRING_LENGTH];

    PAGED_CODE();

    //
    // allocate space for the array of catagory names
    //

    if (!(NamesArray = ExAllocatePool(PagedPool,
                                    sizeof(UNICODE_STRING) * ArrayCount))) {
        return;
    }
    //
    // zero the array in case we're unable to fill it in below.  the Destroy
    // routine below will then correctly handle this case.
    //

    RtlZeroMemory(NamesArray,
                  sizeof(UNICODE_STRING) * ArrayCount);

    DeviceExtension->SymbolicLinks = NamesArray;


    //
    // open the PDO
    //


    if (!NT_SUCCESS(IoOpenDeviceRegistryKey(DeviceExtension->PhysicalDeviceObject,
                                            PLUGPLAY_REGKEY_DRIVER,
                                            STANDARD_RIGHTS_ALL,
                                            &PdoHandle))) {

        DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't open\n"));
        return;

    }
    //
    // loop through each of the catagory GUID's for each of the pins,
    // creating a symbolic link for each one.
    //

    for (i = 0; i < ArrayCount; i++) {

        //
        // Create the symbolic link
        //

        if (!NT_SUCCESS(IoRegisterDeviceInterface(
                                      DeviceExtension->PhysicalDeviceObject,
                                                  &GuidIndex[i],
                             (PUNICODE_STRING) & CreateItems[0].ObjectClass,
                                                  &NamesArray[i]))) {
            DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't register\n"));
            DEBUG_BREAKPOINT();
            return;

        }
        //
        // Now set the symbolic link for the association
        //

        if (!NT_SUCCESS(IoSetDeviceInterfaceState(&NamesArray[i], TRUE))) {

            DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't set\n"));
            DEBUG_BREAKPOINT();
            return;

        }
        //
        // add the strings from the PDO's key to the association key.
        // Performance Improvement Chance 
        //   - the INF should be able to directly propogate these;
        // forrest & lonny are fixing.
        //

        if (NT_SUCCESS(IoOpenDeviceInterfaceRegistryKey(&NamesArray[i],
                                                        STANDARD_RIGHTS_ALL,
                                                        &ClassHandle))) {


            //
            // write the class ID for the proxy, if any.
            //

            if (NT_SUCCESS(SCGetRegistryValue(PdoHandle,
                                              (PWCHAR) ClsIdString,
                                              sizeof(ClsIdString),
                                              &DataBuffer,
                                              MAX_STRING_LENGTH))) {


                RtlInitUnicodeString(&TempUnicodeString, ClsIdString);

                ZwSetValueKey(ClassHandle,
                              &TempUnicodeString,
                              0,
                              REG_SZ,
                              &DataBuffer,
                              MAX_STRING_LENGTH
                    );

            }                   // if cls guid read
            //
            // first check if a friendly name has already been propogated
            // to the class via the INF.   If not, we'll just use the device
            // description string for this.
            //

            if (!NT_SUCCESS(SCGetRegistryValue(ClassHandle,
                                               (PWCHAR) FriendlyNameString,
                                               sizeof(FriendlyNameString),
                                               &DataBuffer,
                                               MAX_STRING_LENGTH))) {


                //
                // write the friendly name for the device, if any.
                //

                if (NT_SUCCESS(SCGetRegistryValue(PdoHandle,
                                                  (PWCHAR) DriverDescString,
                                                  sizeof(DriverDescString),
                                                  &DataBuffer,
                                                  MAX_STRING_LENGTH))) {


                    RtlInitUnicodeString(&TempUnicodeString, FriendlyNameString);

                    ZwSetValueKey(ClassHandle,
                                  &TempUnicodeString,
                                  0,
                                  REG_SZ,
                                  &DataBuffer,
                                  MAX_STRING_LENGTH
                        );


                }               // if cls guid read
            }                   // if !friendly name already
            ZwClose(ClassHandle);

        }                       // if class key opened
    }                           // for # Categories

    ZwClose(PdoHandle);

}


VOID
SCDestroySymbolicLinks(
                       IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

Arguments:

    DeviceExtension - Supplies a pointer to the device extension to be processed.

Return Value:

    None.

--*/
{
    PHW_STREAM_DESCRIPTOR StreamDescriptor = DeviceExtension->StreamDescriptor;

    PAGED_CODE();

    if (StreamDescriptor) {

        ULONG           ArrayCount = StreamDescriptor->StreamHeader.Topology->CategoriesCount;
        UNICODE_STRING *NamesArray;
        ULONG           i;

        //
        // if no names array, we're done.
        //

        if (NULL == DeviceExtension->SymbolicLinks) {

            return;
        }

        NamesArray = DeviceExtension->SymbolicLinks;
        
        //
        // loop through each of the catagory GUID's for each of the pins,
        // deleting the symbolic link for each one.
        //

        for (i = 0; i < ArrayCount; i++) {


            if (NamesArray[i].Buffer) {

                //
                // Delete the symbolic link, ignoring the status.
                //

                IoSetDeviceInterfaceState(&NamesArray[i], FALSE);

                //
                // free the buffer allocated by
                // IoRegisterDeviceClassAssociation.
                //

                ExFreePool(NamesArray[i].Buffer);

            }                   // if buffer
        }                       // for # Categories

        //
        // free the links structure and null the pointer
        //

        ExFreePool(NamesArray);
        DeviceExtension->SymbolicLinks = NULL;

    }                           // if StreamDescriptor
}

#endif // ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SCSynchCompletionRoutine(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp,
                         IN PKEVENT Event
)
/*++

Routine Description:

    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp - Irp that just completed

    Event - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{

    KeSetEvent((PKEVENT) Event, IO_NO_INCREMENT, FALSE);
    return (STATUS_MORE_PROCESSING_REQUIRED);

}

NTSTATUS
SCSynchPowerCompletionRoutine(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN UCHAR MinorFunction,
                              IN POWER_STATE DeviceState,
                              IN PVOID Context,
                              IN PIO_STATUS_BLOCK IoStatus
)
/*++

Routine Description:

    This routine is for use with synchronous IRP power processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    SetState - TRUE for set, FALSE for query.

    DevicePowerState - power state

    Context - Driver defined context, in our case, an IRP.

    IoStatus - The status of the IRP.

Return Value:

    None.

--*/

{
    PIRP            SystemIrp = Context;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack;

    if ( NULL == SystemIrp ) {
    
        //
        // SystemIrp has been completed if it is a Wake Irp
        //
        
        return ( IoStatus->Status );
    }

    IrpStack = IoGetCurrentIrpStackLocation(SystemIrp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    //
    // cache the status of the device power irp we sent in the system IRP
    //

    SystemIrp->IoStatus.Status = IoStatus->Status;

    //
    // schedule a worker item to complete processing.   note that we can use
    // a global item since we have not yet issued the PoNextPowerIrp call.
    //

    ExInitializeWorkItem(&DeviceExtension->PowerCompletionWorkItem,
                         SCPowerCompletionWorker,
                         SystemIrp);

    ExQueueWorkItem(&DeviceExtension->PowerCompletionWorkItem,
                    DelayedWorkQueue);

    return (IoStatus->Status);
}

VOID
SCPowerCompletionWorker(
                        IN PIRP SystemIrp
)
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(SystemIrp);
    PDEVICE_EXTENSION DeviceExtension = IrpStack->DeviceObject->DeviceExtension;

    //
    // preset the status to the status of the Device request, which we cached
    // in the system IRP's status field.   We'll override it with the status
    // of the system request if we haven't sent it yet.
    //

    NTSTATUS        Status = SystemIrp->IoStatus.Status;

    PAGED_CODE();

    //
    // if this is a NOT wakeup, we must first pass the request down
    // to the PDO for postprocessing.
    //

    if (IrpStack->Parameters.Power.State.SystemState != PowerSystemWorking) {


        //
        // send down the system power IRP to the next layer.  this routine
        // has a completion routine which does not complete the IRP.
        // preset the status to SUCCESS in this case.
        //

        SystemIrp->IoStatus.Status = STATUS_SUCCESS;
        Status = SCCallNextDriver(DeviceExtension, SystemIrp);

    }
    //
    // indicate that we're ready for the next power IRP.
    //

    PoStartNextPowerIrp(SystemIrp);

    //
    // show one fewer reference to driver.
    //

    SCDereferenceDriver(DeviceExtension);

    //
    // now complete the system power IRP.
    //

    SCCompleteIrp(SystemIrp, Status, DeviceExtension);
}


NTSTATUS
SCBustedSynchPowerCompletionRoutine(
                                    IN PDEVICE_OBJECT DeviceObject,
                                    IN UCHAR MinorFunction,
                                    IN POWER_STATE DeviceState,
                                    IN PVOID Context,
                                    IN PIO_STATUS_BLOCK IoStatus
)
/*++

Routine Description:

    (I don't see this can go away) this routine needs to go away
    This routine is for use with synchronous IRP power processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    SetState - TRUE for set, FALSE for query.

    DevicePowerState - power state

    Context - Driver defined context, in our case, an event.

    IoStatus - The status of the IRP.

Return Value:

    None.

--*/

{
    PPOWER_CONTEXT  PowerContext = Context;

    PAGED_CODE();

    PowerContext->Status = IoStatus->Status;
    KeSetEvent(&PowerContext->Event, IO_NO_INCREMENT, FALSE);
    return (PowerContext->Status);

}

NTSTATUS
SCCreateChildPdo(
                 IN PVOID PnpId,
                 IN PDEVICE_OBJECT DeviceObject,
                 IN ULONG InstanceNumber
)
/*++

Routine Description:

    Called to create a PDO for a child device.

Arguments:

    PnpId - ID of device to create

    ChildNode - node for the device

Return Value:

    Status is returned.

--*/
{
    PDEVICE_OBJECT  ChildPdo;
    NTSTATUS        Status;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PCHILD_DEVICE_EXTENSION ChildDeviceExtension;
    PWCHAR          NameBuffer;

    PAGED_CODE();

    //
    // create a PDO for the child device.
    //

    Status = IoCreateDevice(DeviceObject->DriverObject,
                            sizeof(CHILD_DEVICE_EXTENSION),
                            NULL,
                            FILE_DEVICE_UNKNOWN,
                            FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &ChildPdo);                            

    if (!NT_SUCCESS(Status)) {

        DEBUG_BREAKPOINT();
        return Status;
    }
    //
    // set the stack size to be the # of stacks used by the FDO.
    //

    ChildPdo->StackSize = DeviceObject->StackSize+1;

    //
    // Initialize fields in the ChildDeviceExtension.
    //

    ChildDeviceExtension = ChildPdo->DeviceExtension;
    ChildDeviceExtension->ChildDeviceObject = ChildPdo;
    ChildDeviceExtension->Flags |= DEVICE_FLAGS_CHILD;
    ChildDeviceExtension->DeviceIndex = InstanceNumber;
    ChildDeviceExtension->ParentDeviceObject = DeviceObject;


    //
    // create a new string for the device name and save it away in the device
    // extension.   I spent about 4 hours trying to find a way to
    // get unicode strings to work with this.   If you ask me why I didn't
    // use a unicode string, I will taunt you and #%*&# in your general
    // direction.
    //


    if (NameBuffer = ExAllocatePool(PagedPool,
                                    wcslen(PnpId) * 2 + 2)) {


        wcscpy(NameBuffer,
               PnpId);

        //
        // save the device name pointer. this is freed when the device is
        // removed.
        //

        ChildDeviceExtension->DeviceName = NameBuffer;

    }                           // if namebuffer
    //
    // initialize the link and insert this node
    //

    InitializeListHead(&ChildDeviceExtension->ChildExtensionList);

    InsertTailList(
                   &DeviceExtension->Children,
                   &ChildDeviceExtension->ChildExtensionList);

    ChildPdo->Flags |= DO_POWER_PAGABLE;
    ChildPdo->Flags &= ~DO_DEVICE_INITIALIZING;
    return Status;
}

NTSTATUS
SCEnumerateChildren(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
)
/*++

Routine Description:

    Called in the context of an IRP_MN_QUERY_DEVICE_RELATIONS

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PVOID           PnpId;
    PCHILD_DEVICE_EXTENSION ChildDeviceExtension = NULL,
                    CurrentChildExtension;
    PDEVICE_RELATIONS DeviceRelations = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS        Status;
    HANDLE          ParentKey,
                    RootKey,
                    ChildKey;

    UNICODE_STRING  UnicodeEnumName;
    ULONG           NumberOfChildren,
                    RelationsSize;
    PDEVICE_OBJECT *ChildPdo;
    PLIST_ENTRY     ListEntry,
                    ChildEntry;

    PAGED_CODE();

    DebugPrint((DebugLevelInfo,
                "EnumChilds for %x %s\n",
                DeviceObject,
                (DeviceExtension->Flags & DEVICE_FLAGS_CHILDREN_ENUMED) == 0 ?
                    "1st Time": "has enumed" ));
                    
    if ( 0 == (DeviceExtension->Flags & DEVICE_FLAGS_CHILDREN_ENUMED) ) {
        //
        // we haven't enumerated children from the registry
        // do it now.
        //

        Status = IoOpenDeviceRegistryKey(DeviceExtension->PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &ParentKey);


        if (!NT_SUCCESS(Status)) {

            DebugPrint((DebugLevelError, "SCEnumerateChildren: couldn't open\n"));
            return STATUS_NOT_IMPLEMENTED;

        }
        //
        // create the subkey for the enum section, in the form "\enum"
        //

        RtlInitUnicodeString(&UnicodeEnumName, EnumString);

        //
        // read the registry to determine if children are present.
        //

        InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeEnumName,
                               OBJ_CASE_INSENSITIVE,
                               ParentKey,
                               NULL);

        if (!NT_SUCCESS(Status = ZwOpenKey(&RootKey, KEY_READ, &ObjectAttributes))) {

            ZwClose(ParentKey);
            return Status;
        }
        
        //
        // allocate a buffer to contain the ID string.  Performance Improvement Chance
        // - this should
        // really get the size and alloc only that size, but I have an existing
        // routine that reads the registry, & this is a temp allocation only.
        //

        if (!(PnpId = ExAllocatePool(PagedPool, MAX_STRING_LENGTH))) {

            ZwClose(RootKey);
            ZwClose(ParentKey);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        //
        // Loop through all the values until either no more entries exist, or an
        // error occurs.
        //

        for (NumberOfChildren = 0;; NumberOfChildren++) {

            ULONG           BytesReturned;
            PKEY_BASIC_INFORMATION BasicInfoBuffer;
            KEY_BASIC_INFORMATION BasicInfoHeader;

            //
            // Retrieve the value size.
            //

            Status = ZwEnumerateKey(
                                RootKey,
                                NumberOfChildren,
                                KeyBasicInformation,
                                &BasicInfoHeader,
                                sizeof(BasicInfoHeader),
                                &BytesReturned);

            if ((Status != STATUS_BUFFER_OVERFLOW) && !NT_SUCCESS(Status)) {

                //
                // exit the loop, as we either had an error or reached the end
                // of the list of keys.
                //

                break;
            }                       // if error
            //
            // Allocate a buffer for the actual size of data needed.
            //

            BasicInfoBuffer = (PKEY_BASIC_INFORMATION)
                ExAllocatePool(PagedPool,
                           BytesReturned);

            if (!BasicInfoBuffer) {

                break;
            }
            //
            // Retrieve the name of the nth child device
            //

            Status = ZwEnumerateKey(
                                RootKey,
                                NumberOfChildren,
                                KeyBasicInformation,
                                BasicInfoBuffer,
                                BytesReturned,
                                &BytesReturned);

            if (!NT_SUCCESS(Status)) {

                ExFreePool(BasicInfoBuffer);
                break;

            }
            //
            // build object attributes for the key, & try to open it.
            //

            UnicodeEnumName.Length = (USHORT) BasicInfoBuffer->NameLength;
            UnicodeEnumName.MaximumLength = (USHORT) BasicInfoBuffer->NameLength;
            UnicodeEnumName.Buffer = (PWCHAR) BasicInfoBuffer->Name;

            InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeEnumName,
                                   OBJ_CASE_INSENSITIVE,
                                   RootKey,
                                   NULL);


            if (!NT_SUCCESS(Status = ZwOpenKey(&ChildKey, KEY_READ, &ObjectAttributes))) {

                ExFreePool(BasicInfoBuffer);
                break;
            }
            //
            // we've now opened the key for the child.  We next read in the PNPID
            // value, and if present, create a PDO of that name.
            //

            if (!NT_SUCCESS(Status = SCGetRegistryValue(ChildKey,
                                                    (PWCHAR) PnpIdString,
                                                    sizeof(PnpIdString),
                                                    PnpId,
                                                    MAX_STRING_LENGTH))) {

                ExFreePool(BasicInfoBuffer);
                ZwClose(ChildKey);
                break;
            }

            //
            // create a PDO representing the child.
            //

            Status = SCCreateChildPdo(PnpId,
                                  DeviceObject,
                                  NumberOfChildren);

            //
            // free the Basic info buffer and close the child key
            //

            ExFreePool(BasicInfoBuffer);
            ZwClose(ChildKey);

            if (!NT_SUCCESS(Status)) {

                //
                // break out of the loop if we could not create the
                // PDO
                //

                DEBUG_BREAKPOINT();
                break;
            }                       // if !success
        }                           // for NumberOfChildren

        //
        // close the root and parent keys and free the ID buffer
        //

        ZwClose(RootKey);
        ZwClose(ParentKey);
        ExFreePool(PnpId);

        //
        // has enumed, remember this
        //
        
        DeviceExtension->Flags |= DEVICE_FLAGS_CHILDREN_ENUMED;

        //
        // we now have processed all children, and have a linked list of
        // them.
        //

        if (!NumberOfChildren) {

            //
            // if no children, just return not supported.  this means that the
            // device did not have children.
            //

            return (STATUS_NOT_IMPLEMENTED);

        }                           // if !NumberOfChildren
        
    }
    
    else {
        
        //
        // count children which are not marked delete pending
        //
        ListEntry = ChildEntry = &DeviceExtension->Children;
        NumberOfChildren = 0;
        
        while (ChildEntry->Flink != ListEntry) {

            ChildEntry = ChildEntry->Flink;

            CurrentChildExtension = CONTAINING_RECORD(ChildEntry,
                                                  CHILD_DEVICE_EXTENSION,
                                                  ChildExtensionList );
            if (!(CurrentChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE)){
                NumberOfChildren++;
            }
        }
    }

    //
    // allocate the device relations buffer.   This will be freed by the
    // caller.
    //

    RelationsSize = sizeof(DEVICE_RELATIONS) +
            (NumberOfChildren * sizeof(PDEVICE_OBJECT));

    DeviceRelations = ExAllocatePool(PagedPool, RelationsSize);

    if (DeviceRelations == NULL) {

        //
        // return, but keep the list of children allocated.
        //

        DEBUG_BREAKPOINT();
        return STATUS_INSUFFICIENT_RESOURCES;

    }                           // if no heap
    RtlZeroMemory(DeviceRelations, RelationsSize);

    //
    // Walk our chain of children, and initialize the relations
    //

    ChildPdo = &(DeviceRelations->Objects[0]);

    //
    // get the 1st child from the parent device extension anchor
    //

    ListEntry = ChildEntry = &DeviceExtension->Children;

    while (ChildEntry->Flink != ListEntry) {

        ChildEntry = ChildEntry->Flink;

        CurrentChildExtension = CONTAINING_RECORD(ChildEntry,
                                                  CHILD_DEVICE_EXTENSION,
                                                  ChildExtensionList);

        DebugPrint((DebugLevelInfo,
                    "Enumed Child DevObj %x%s marked delete\n",
                    CurrentChildExtension->ChildDeviceObject,
                    (CurrentChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE)==0 ?
                        " not" : ""));

        if ( CurrentChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE ) {
            continue;
        }
        
        *ChildPdo = CurrentChildExtension->ChildDeviceObject;

        //
        // per DDK doc we need to inc ref count
        //
        ObReferenceObject( *ChildPdo );
        
        ChildPdo++;

    }                           // while Children


    DeviceRelations->Count = NumberOfChildren;

    //
    // Stuff that pDeviceRelations into the IRP and return SUCCESS.
    //

    Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;

    return STATUS_SUCCESS;

}


NTSTATUS
SCEnumGetCaps(
              IN PCHILD_DEVICE_EXTENSION DeviceExtension,
              OUT PDEVICE_CAPABILITIES Capabilities
)
/*++

Routine Description:

    Called to get the capabilities of a child

Arguments:

    DeviceExtension - child device extension
    Capibilities - capabilities structure

Return Value:

    Status is returned.

--*/

{
    ULONG           i;
    PAGED_CODE();

    //
    // fill in the structure with non-controversial values
    //

    Capabilities->SystemWake = PowerSystemUnspecified;
    Capabilities->DeviceWake = PowerDeviceUnspecified;
    Capabilities->D1Latency = 10;
    Capabilities->D2Latency = 10;
    Capabilities->D3Latency = 10;
    Capabilities->LockSupported = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable = FALSE;
    Capabilities->DockDevice = FALSE;
    Capabilities->UniqueID = FALSE; // set to false so PNP will make us

    for (i = 0; i < PowerDeviceMaximum; i++) {
        Capabilities->DeviceState[i] = PowerDeviceD0;

    }                           // for i

    return STATUS_SUCCESS;
}

NTSTATUS
SCBuildChildIds (
    IN PDEVICE_OBJECT ParentPDO,
    IN BOOLEAN HardwareIDs,
    IN PWCHAR ChildDeviceName,
    OUT PWCHAR *IDBuffer
    )

/*++

Routine Description:

    Called to build the hardware ID or compatible ID list for a child device.
    This list is built based on the old Stream\<vendor PnPId> naming
    style as a compatible ID and everything else as a munged version of
    the corresponding parent ID (with child information prepended)

Arguments:

    ParentPDO -
        The PDO of the parent

    HardwareIDs -
        TRUE -
            Build hardware ID list

        FALSE -
            Build compatible ID list

    ChildDeviceName -
        The vendor supplied PnPId which used to be the device ID.

Return Value:

    Success / Failure

--*/

{
    PWCHAR ParentId = NULL;
    PWCHAR ChildId = NULL;
    PWCHAR NameBuffer;
    ULONG ParentIdLength;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // The format for the HWId & CompatId now is going to be:
    //
    // Stream\<vendor supplied PnPId>#<parent ID (w \ -> # replacement)
    //
    // Since we have no understanding of the format of the ID string
    // (as we can be on any bus) and we cannot simply report the most
    // specific ID, all HWIDs from the parent will need to be munged
    // and reported as child HWIDs.
    //
    Status = IoGetDeviceProperty (
        ParentPDO,
        HardwareIDs ? 
            DevicePropertyHardwareID : DevicePropertyCompatibleIDs,
        0,
        NULL,
        &ParentIdLength
        );

    //
    // If the device has no compat IDs and doesn't return a NULL MULTI-SZ,
    // special case the addition of the old HWID.
    //
    if (Status != STATUS_BUFFER_TOO_SMALL && !HardwareIDs) {

        //
        // Length for: Stream\<vendor ID>00
        //
        ULONG CompatLength = sizeof (WCHAR) * (
            STREAM_BUSENUM_STRING_LENGTH +
            wcslen (ChildDeviceName)
            ) + 2 * sizeof (UNICODE_NULL);

        NameBuffer = (PWCHAR)ExAllocatePool (PagedPool, CompatLength);
        
        if (!NameBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            RtlZeroMemory (NameBuffer, CompatLength);
            swprintf (
                NameBuffer,
                STREAM_BUSENUM_STRING L"%s",
                ChildDeviceName
                );

            //
            // Double NULL terminated by virtue of the RtlZeroMemory.
            //
            *IDBuffer = NameBuffer;
        }

        return Status;
    }

    while (Status == STATUS_BUFFER_TOO_SMALL) {

        if (ParentId) {
            ExFreePool (ParentId);
        }

        ParentId = 
            (PWCHAR) ExAllocatePool (PagedPool, ParentIdLength);

        if (!ParentId) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            Status = IoGetDeviceProperty (
                ParentPDO,
                HardwareIDs ?
                    DevicePropertyHardwareID : DevicePropertyCompatibleIDs,
                ParentIdLength,
                ParentId,
                &ParentIdLength
                );
        }
    }

    if (NT_SUCCESS (Status)) {
        //
        // Count the total string length of all parent ID's, add necessary
        // munging, and allocate a buffer large enough to report back
        // the MULTI_SZ child HWIDs.
        //
        PWCHAR CurCh = ParentId;
        ULONG ParentLength = 0;
        ULONG ParentCount = 0;
        ULONG ChildLength;

        while (*CurCh) {
            for (; *CurCh; CurCh++) {
                //
                // Munge \ into #
                //
                if (*CurCh == L'\\') *CurCh = L'#';
                ParentLength++;
            }
            CurCh++;
            ParentCount++;
        }

        //
        // Account for parent strings total then for adding Stream\ # NULL
        // for each string then for the <vendor PnPId> for each 
        // string.  The additional wchar is for the extra NULL terminator
        // for the MULTI_SZ.
        //
        ChildLength = sizeof (WCHAR) * (
            ParentLength +
            ParentCount * (
                STREAM_BUSENUM_STRING_LENGTH +
                STREAM_BUSENUM_SEPARATOR_LENGTH +
                1 + /* each NULL terminator for each string of the MULTI_SZ */
                wcslen (ChildDeviceName) 
                )
            ) + sizeof (UNICODE_NULL);

        //
        // If the string is an empty MULTI_SZ, we need a NULL string at the
        // beginning.
        //
        if (!ParentCount) {
            ChildLength += sizeof (UNICODE_NULL);
        }

        //
        // We need the old hardware ID tacked as least ranked compat ID if that
        // is what we are querying.
        //
        if (!HardwareIDs) {
            ChildLength += sizeof (WCHAR) * (
                STREAM_BUSENUM_STRING_LENGTH +
                wcslen (ChildDeviceName) 
                ) + sizeof (UNICODE_NULL);
        }

        ChildId = NameBuffer = (PWCHAR)ExAllocatePool (PagedPool, ChildLength);

        if (!NameBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (NT_SUCCESS (Status)) {
            RtlZeroMemory (NameBuffer, ChildLength);
            CurCh = ParentId;

            //
            // Munge each parent ID into a child ID by prefixing the
            // Stream\<vendor PnPId># string.
            //
            while (ParentCount--) {

                ASSERT (*CurCh != 0);

                _snwprintf (
                    NameBuffer,
                    MAX_DEVICE_ID_LEN - 1,
                    STREAM_BUSENUM_STRING L"%s#%s",
                    ChildDeviceName, 
                    CurCh
                    );

                NameBuffer += wcslen (NameBuffer) + 1;
                CurCh += wcslen (CurCh) + 1;

            }
        }

        //
        // Tack on the old hardware ID if we're reporting the new compat IDs.
        //
        if (!HardwareIDs) {
            swprintf (
                NameBuffer,
                STREAM_BUSENUM_STRING L"%s",
                ChildDeviceName
                );
        }

    }

    if (NT_SUCCESS (Status)) {
        *IDBuffer = ChildId;
    }
    else {
        if (ChildId) ExFreePool (ChildId);
    }

    if (ParentId) {
        ExFreePool (ParentId);
    }

    return Status;

}


NTSTATUS
SCQueryEnumId(
              IN PDEVICE_OBJECT DeviceObject,
              IN BUS_QUERY_ID_TYPE BusQueryIdType,
              IN OUT PWSTR * BusQueryId
)
/*++

Routine Description:

    Called to get the ID of a child device

Arguments:

    DeviceObject - device object from child
    QueryIdType - ID type from PNP
    BusQueryId - buffer containing the info requested if successful

Return Value:

    Status is returned.

--*/

{


    PWCHAR         NameBuffer = NULL;
    NTSTATUS        Status = STATUS_SUCCESS;
    PCHILD_DEVICE_EXTENSION DeviceExtension =
    (PCHILD_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PDEVICE_EXTENSION ParentExtension =
        (PDEVICE_EXTENSION) DeviceExtension->ParentDeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // process the query
    //

    switch (BusQueryIdType) {

    case BusQueryDeviceID:
        //
        // In order not to orphan any devices installed prior to changing the
        // format of the hardware ID's, the device ID will continue to be
        // reported as Stream\<vendor supplied PnPId> (also a CID) while
        // the hardware ID will contain the more specific munged names.
        //
        NameBuffer = (PWCHAR)ExAllocatePool (
            PagedPool,
            sizeof (WCHAR) * (
                STREAM_BUSENUM_STRING_LENGTH +
                wcslen (DeviceExtension -> DeviceName)
                ) + sizeof (UNICODE_NULL)
            );

        swprintf (
            NameBuffer,
            STREAM_BUSENUM_STRING L"%s",
            DeviceExtension -> DeviceName
            );

        break;

    case BusQueryCompatibleIDs:

        //
        // Compatible IDs are reported as:
        //
        //      Stream\<Vendor PnPId>
        //          - This was the old hardware / device ID
        //
        //      Stream\<Vendor PnPId>#<Munged Parent Compat ID>
        //          - These are new compat IDs based off EVERY parent compat ID
        //  
        Status = SCBuildChildIds (
            ParentExtension -> PhysicalDeviceObject,
            FALSE,
            DeviceExtension -> DeviceName,
            &NameBuffer
            );

        break;

    case BusQueryHardwareIDs:
        
        //
        // Hardware IDs are reported as:
        //
        //      Stream\<Vendor PnPId>#<Munged Parent Hardware ID>
        //          - These are new hardware IDs pased off EVERY parent HWId
        //
        Status = SCBuildChildIds (
            ParentExtension -> PhysicalDeviceObject,
            TRUE,
            DeviceExtension -> DeviceName,
            &NameBuffer
            );

        break;


    case BusQueryInstanceID:

        {

            UNICODE_STRING  DeviceName;
            WCHAR           Buffer[8];

            //
            // convert the instance # from the device extension to unicode,
            // then copy it over to the output buffer.
            //

            DeviceName.Buffer = Buffer;
            DeviceName.Length = 0;
            DeviceName.MaximumLength = 8;

            RtlIntegerToUnicodeString(DeviceExtension->DeviceIndex,
                                      10,
                                      &DeviceName);

            NameBuffer = (PWCHAR)ExAllocatePool (
                PagedPool,
                8 * sizeof (WCHAR)
                );

            if (!NameBuffer) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RtlZeroMemory (NameBuffer, 8 * sizeof (WCHAR));
                wcscpy(NameBuffer, DeviceName.Buffer);
            }

            break;

        }

    default:

        return (STATUS_NOT_SUPPORTED);
    }

    //
    // return the string and good status.
    //

    *BusQueryId = NameBuffer;

    return (Status);
}

NTSTATUS
StreamClassForwardUnsupported(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN PIRP Irp
)
/*++

Routine Description:

    This routine forwards unsupported major function calls to the PDO.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS Status;

    PAGED_CODE();

    DeviceExtension = DeviceObject->DeviceExtension;

    Irp->IoStatus.Information = 0;


    DebugPrint((DebugLevelVerbose, "'StreamClassForwardUnsupported: enter\n"));

    if ( !(DeviceExtension->Flags & DEVICE_FLAGS_CHILD)) {

        //
        // show one more reference to driver.
        //
        SCReferenceDriver(DeviceExtension);

        //
        // show one more I/O pending & verify that we can actually do I/O.
        //
        Status = SCShowIoPending(DeviceExtension, Irp);

        if ( !NT_SUCCESS( Status )) {
            //
            // the device is currently not accessible, so just return with error
            //
            Irp->IoStatus.Status= Status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return Status;
        }
        
        //
        // synchronouosly call the next driver in the stack.
        //
        SCCallNextDriver(DeviceExtension, Irp);

        //
        // dereference the driver
        //

        SCDereferenceDriver(DeviceExtension);
        //
        // complete the IRP and return status
        //
        return (SCCompleteIrp(Irp, Irp->IoStatus.Status, DeviceExtension));
    } else {
        //
        // We are the PDO, return error and complete the Irp
        //
        Irp->IoStatus.Status = Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return Status;
    }
}

VOID
SCSendSurpriseNotification(
                           IN PDEVICE_EXTENSION DeviceExtension,
                           IN PIRP Irp
)
/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    BOOLEAN         RequestIssued;

    PAGED_CODE();
    SCSubmitRequest(SRB_SURPRISE_REMOVAL,
                    NULL,
                    0,
                    SCDequeueAndDeleteSrb,
                    DeviceExtension,
                    NULL,
                    NULL,
                    Irp,
                    &RequestIssued,
                    &DeviceExtension->PendingQueue,
                    (PVOID) DeviceExtension->
                    MinidriverData->HwInitData.
                    HwReceivePacket
        );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\dvd\class\sources.inc ===
TARGETNAME=stream
TARGETTYPE=EXPORT_DRIVER
DRIVERTYPE=WDM
DLLDEF=$(O)\codcls.def

TARGETPATH=obj

INCLUDES=..\inc

TARGETLIBS=$(DDK_LIB_PATH)\ks.lib \
           $(DDK_LIB_PATH)\ksguid.lib

PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(DDK_LIB_PATH)\$(TARGETNAME).lib}

MSC_WARNING_LEVEL=/W3

LINKER_FLAGS =$(LINKER_FLAGS) -merge:PAGECONST=PAGE
C_DEFINES=$(C_DEFINES) -DUSE_DMA_MACROS


SOURCES=codguts.c        \
        codinit.c        \
        lowerapi.c        \
        upperapi.c      \
        codcls.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\dvd\class\millen\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\dvd\class\nt\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\dvd\class\codguts.c ===
/* ++
  * 
  * Copyright (c) 1996  Microsoft Corporation
  * 
  * Module Name:
  * 
  * codguts.c
  * 
  * Abstract:
  * 
  * This is the WDM streaming class driver.  This module contains code related
  * to internal processing.
  * 
  * Author:
  * 
  * billpa
  * 
  * Environment:
  * 
  * Kernel mode only
  * 
  * 
  * Revision History:
  * 
  * -- */

#include "codcls.h"
#include <stdlib.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SCBuildRequestPacket)
#pragma alloc_text(PAGE, SCProcessDmaDataBuffers)
#pragma alloc_text(PAGE, SCProcessPioDataBuffers)
#pragma alloc_text(PAGE, SCOpenMinidriverInstance)
#pragma alloc_text(PAGE, SCMinidriverDevicePropertyHandler)
#pragma alloc_text(PAGE, SCMinidriverStreamPropertyHandler)
#pragma alloc_text(PAGE, SCUpdateMinidriverProperties)
#pragma alloc_text(PAGE, SCProcessCompletedPropertyRequest)
#pragma alloc_text(PAGE, SCLogError)
#pragma alloc_text(PAGE, SCLogErrorWithString)
#pragma alloc_text(PAGE, SCReferenceDriver)
#pragma alloc_text(PAGE, SCDereferenceDriver)
#pragma alloc_text(PAGE, SCReadRegistryValues)
#pragma alloc_text(PAGE, SCGetRegistryValue)
#pragma alloc_text(PAGE, SCSubmitRequest)
#pragma alloc_text(PAGE, SCProcessDataTransfer)
#pragma alloc_text(PAGE, SCShowIoPending)
#pragma alloc_text(PAGE, SCCheckPoweredUp)
#pragma alloc_text(PAGE, SCCheckPowerDown)
#pragma alloc_text(PAGE, SCCallNextDriver)
#pragma alloc_text(PAGE, SCSendUnknownCommand)
#pragma alloc_text(PAGE, SCMapMemoryAddress)
#pragma alloc_text(PAGE, SCUpdatePersistedProperties)
#pragma alloc_text(PAGE, SCProcessCompletedPropertyRequest)
#pragma alloc_text(PAGE, SCUpdateMinidriverEvents)
#pragma alloc_text(PAGE, SCQueryCapabilities)
#pragma alloc_text(PAGE, SCRescanStreams)
#pragma alloc_text(PAGE, SCCopyMinidriverProperties)
#pragma alloc_text(PAGE, SCCopyMinidriverEvents)
#endif

#ifdef ENABLE_KS_METHODS
#pragma alloc_text(PAGE, SCCopyMinidriverMethods)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

extern KSDISPATCH_TABLE FilterDispatchTable;

//
// registry string indicating that the minidriver should be paged out when
// unopened
//

static const WCHAR PageOutWhenUnopenedString[] = L"PageOutWhenUnopened";

//
// registry string indicating that the minidriver should be paged out when
// idle
//

static const WCHAR PageOutWhenIdleString[] = L"PageOutWhenIdle";

//
// registry string indicating that the device should be powered down when
// unopened
//

static const WCHAR PowerDownWhenUnopenedString[] = L"PowerDownWhenUnopened";

//
// registry string indicating that the device should not be suspended when
// pins are in run state
//

static const WCHAR DontSuspendIfStreamsAreRunning[] = L"DontSuspendIfStreamsAreRunning";

//
// This driver uses SWEnum to load, which means it is a kernel mode
// streaming driver that has no hardware associated with it. We need to
// AddRef/DeRef this driver special.
//

static const WCHAR DriverUsesSWEnumToLoad[] = L"DriverUsesSWEnumToLoad";

//
//
//

static const WCHAR OkToHibernate[] = L"OkToHibernate";

//
// array of registry settings to be read when the device is initialized
//

static const STREAM_REGISTRY_ENTRY RegistrySettings[] = {
    {
        (PWCHAR) PageOutWhenUnopenedString,
        sizeof(PageOutWhenUnopenedString),
        DEVICE_REG_FL_PAGE_CLOSED
    },

    {
        (PWCHAR) PageOutWhenIdleString,
        sizeof(PageOutWhenIdleString),
        DEVICE_REG_FL_PAGE_IDLE
    },

    {
        (PWCHAR) PowerDownWhenUnopenedString,
        sizeof(PowerDownWhenUnopenedString),
        DEVICE_REG_FL_POWER_DOWN_CLOSED
    },

    {
        (PWCHAR) DontSuspendIfStreamsAreRunning,
        sizeof(DontSuspendIfStreamsAreRunning),
        DEVICE_REG_FL_NO_SUSPEND_IF_RUNNING
    },

    {
        (PWCHAR) DriverUsesSWEnumToLoad,
        sizeof(DriverUsesSWEnumToLoad),
        DRIVER_USES_SWENUM_TO_LOAD
    },
    
    {
        (PWCHAR) OkToHibernate,
        sizeof(OkToHibernate),
        DEVICE_REG_FL_OK_TO_HIBERNATE
    }
};

//
// this structure indicates the handlers for CreateFile on Streams
//

static const WCHAR PinTypeName[] = KSSTRING_Pin;

static const KSOBJECT_CREATE_ITEM CreateHandlers[] = {

    DEFINE_KSCREATE_ITEM(StreamDispatchCreate,
                         PinTypeName,
                         0)
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

//
// Routines start
//

NTSTATUS
SCDequeueAndStartStreamDataRequest(
                                   IN PSTREAM_OBJECT StreamObject
)
/*++

Routine Description:

    Start the queued data IRP for the stream.
    THE SPINLOCK MUST BE TAKEN ON THIS CALL AND A DATA IRP MUST BE ON THE
    QUEUE!


Arguments:

    StreamObject - address of stream info structure.

Return Value:

    NTSTATUS returned

--*/

{
    PIRP            Irp;
    PSTREAM_REQUEST_BLOCK Request;
    PLIST_ENTRY     Entry;
    BOOLEAN         Status;
    PDEVICE_EXTENSION DeviceExtension = StreamObject->DeviceExtension;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    Entry = RemoveTailList(&StreamObject->DataPendingQueue);
    Irp = CONTAINING_RECORD(Entry,
                            IRP,
                            Tail.Overlay.ListEntry);

    ASSERT(Irp);

//    ASSERT((IoGetCurrentIrpStackLocation(Irp)->MajorFunction ==
//                       IOCTL_KS_READ_STREAM) ||
//            (IoGetCurrentIrpStackLocation(Irp)->MajorFunction ==
//                        IOCTL_KS_WRITE_STREAM));
    ASSERT((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] > 0x40000000);


    DebugPrint((DebugLevelVerbose, "'SCStartStreamDataReq: Irp = %x, S# = %x\n",
                Irp, StreamObject->HwStreamObject.StreamNumber));

    //
    // clear the ready flag as we are going to send one down.
    //

    ASSERT(StreamObject->ReadyForNextDataReq);

    StreamObject->ReadyForNextDataReq = FALSE;

    //
    // set the cancel routine to outstanding
    //

    IoSetCancelRoutine(Irp, StreamClassCancelOutstandingIrp);

    //
    // release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    //
    // get the request packet from the IRP
    //

    Request = Irp->Tail.Overlay.DriverContext[0];

    //
    // build scatter/gather list if necessary
    //

    if (StreamObject->HwStreamObject.Dma) {

        //
        // allocate the adapter channel. call cannot fail as the only
        // time it would is when there aren't enough map registers, and
        // we've already checked for that condition.
        //

        Status = SCSetUpForDMA(DeviceExtension->DeviceObject,
                               Request);
        ASSERT(Status);

        //
        // DMA adapter allocation requires a
        // callback, so just exit
        //

        return (STATUS_PENDING);

    }                           // if DMA
    //
    // start the request for the PIO case.
    //

    SCStartMinidriverRequest(StreamObject,
                             Request,
                             (PVOID)
                             StreamObject->HwStreamObject.ReceiveDataPacket);

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    return (STATUS_PENDING);

}



NTSTATUS
SCDequeueAndStartStreamControlRequest(
                                      IN PSTREAM_OBJECT StreamObject
)
/*++

Routine Description:

    Start the queued control IRP for the stream.
    THE SPINLOCK MUST BE TAKEN ON THIS CALL AND A DATA IRP MUST BE ON THE
    QUEUE!


Arguments:

    StreamObject - address of stream info structure.

Return Value:

    NTSTATUS returned

--*/

{
    PIRP            Irp;
    PSTREAM_REQUEST_BLOCK Request;
    PLIST_ENTRY     Entry;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    Entry = RemoveTailList(&StreamObject->ControlPendingQueue);
    Irp = CONTAINING_RECORD(Entry,
                            IRP,
                            Tail.Overlay.ListEntry);

    ASSERT(Irp);
    DebugPrint((DebugLevelTrace, "'SCStartStreamControlReq: Irp = %x, S# = %x\n",
                Irp, StreamObject->HwStreamObject.StreamNumber));

    //
    // clear the ready flag as we are going
    // to send one down.
    //

    ASSERT(StreamObject->ReadyForNextControlReq);

    StreamObject->ReadyForNextControlReq = FALSE;

    //
    // release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&StreamObject->DeviceExtension->SpinLock);

    //
    // get the request packet from the IRP
    //

    Request = Irp->Tail.Overlay.DriverContext[0];

    //
    // start the request.
    //

    SCStartMinidriverRequest(StreamObject,
                             Request,
                             (PVOID)
                         StreamObject->HwStreamObject.ReceiveControlPacket);

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    return (STATUS_PENDING);

}



NTSTATUS
SCDequeueAndStartDeviceRequest(
                               IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Start the queued device IRP.
    THE DEV SPINLOCK MUST BE TAKEN ON THIS CALL AND AN IRP MUST BE ON THE QUEUE!


Arguments:

    DeviceExtension - address of device extension.

Return Value:

    NTSTATUS

--*/

{
    PIRP            Irp;
    PLIST_ENTRY     Entry;
    PSTREAM_REQUEST_BLOCK Request;

    Entry = RemoveTailList(&DeviceExtension->PendingQueue);
    Irp = CONTAINING_RECORD(Entry,
                            IRP,
                            Tail.Overlay.ListEntry);

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(Irp);

    //
    // clear the ready flag as we are going
    // to send one down.
    //

    ASSERT(DeviceExtension->ReadyForNextReq);

    DeviceExtension->ReadyForNextReq = FALSE;

    //
    // get the request packet from the IRP
    //

    Request = Irp->Tail.Overlay.DriverContext[0];

    ASSERT(Request);

    //
    // show that the request is active.
    //

    Request->Flags |= SRB_FLAGS_IS_ACTIVE;

    //
    // place the request on the outstanding
    // queue
    //

    InsertHeadList(
                   &DeviceExtension->OutstandingQueue,
                   &Request->SRBListEntry);

    //
    // set the cancel routine to outstanding
    //

    IoSetCancelRoutine(Irp, StreamClassCancelOutstandingIrp);

    //
    // send down the request to the
    // minidriver.
    //

    DebugPrint((DebugLevelTrace, "'SCDequeueStartDevice: starting Irp %x, SRB = %x, Command = %x\n",
                Request->HwSRB.Irp, Request, Request->HwSRB.Command));

    DeviceExtension->SynchronizeExecution(
                                          DeviceExtension->InterruptObject,
        (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket,
                                          &Request->HwSRB);

    //
    // release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    return (STATUS_PENDING);
}



PSTREAM_REQUEST_BLOCK
SCBuildRequestPacket(
                     IN PDEVICE_EXTENSION DeviceExtension,
                     IN PIRP Irp,
                     IN ULONG AdditionalSize1,      // scatter gather size
                     IN ULONG AdditionalSize2       // saved ptr array size
)
/*++

Routine Description:

    Routine builds an SRB and fills in generic fields

Arguments:

    DeviceExtension - address of device extension.
    Irp - Address of I/O request packet.
    AdditionalSize1 - additional size needed for scatter/gather, etc.
    AdditionalSize2 - additional size needed for the Saved pointer array.

Return Value:

    Address of the streaming request packet.

--*/

{
    ULONG           BlockSize;
    PSTREAM_REQUEST_BLOCK Request;

    PAGED_CODE();

    //
    // compute the size of the block needed.
    //

    BlockSize = sizeof(STREAM_REQUEST_BLOCK) +
        DeviceExtension->
        MinidriverData->HwInitData.PerRequestExtensionSize +
        AdditionalSize1+
        AdditionalSize2;

    Request = ExAllocatePool(NonPagedPool, BlockSize);

    if (Request == NULL) {
        DebugPrint((DebugLevelError,
                    "SCBuildRequestPacket: No pool for packet"));
        ASSERT(0);
        return (NULL);
    }
    //
    // alloc MDL for the request.
    //
    // GUBGUB  This a marginal performace enhancment chance. 
    // - should find a way to avoid allocating both an MDL and
    // SRB per request.   Maybe have a list of MDL's around and allocate only
    // if we run out.   Forrest won't like this.
    //
    //

    Request->Mdl = IoAllocateMdl(Request,
                                 BlockSize,
                                 FALSE,
                                 FALSE,
                                 NULL
        );

    if (Request->Mdl == NULL) {
        ExFreePool(Request);
        DebugPrint((DebugLevelError,
                    "SCBuildRequestPacket: can't get MDL"));
        return (NULL);
    }
    MmBuildMdlForNonPagedPool(Request->Mdl);

    //
    // fill in the various SRB fields
    // generically
    //

    Request->Length = BlockSize;
    Request->HwSRB.SizeOfThisPacket = sizeof(HW_STREAM_REQUEST_BLOCK);

    Request->HwSRB.Status = STATUS_PENDING;
    Request->HwSRB.StreamObject = NULL;
    Request->HwSRB.HwInstanceExtension = NULL;
    Request->HwSRB.NextSRB = (PHW_STREAM_REQUEST_BLOCK) NULL;
    Request->HwSRB.SRBExtension = Request + 1;
    Request->HwSRB.Irp = Irp;
    Request->Flags = 0;
    Request->MapRegisterBase = 0;
    Request->HwSRB.Flags = 0;
    Request->HwSRB.TimeoutCounter = 15;
    Request->HwSRB.TimeoutOriginal = 15;
    Request->HwSRB.ScatterGatherBuffer =
        (PKSSCATTER_GATHER) ((ULONG_PTR) Request->HwSRB.SRBExtension +
                             (ULONG_PTR) DeviceExtension->
                        MinidriverData->HwInitData.PerRequestExtensionSize);

    Request->pMemPtrArray = (PVOID) (((ULONG_PTR) Request->HwSRB.SRBExtension +
                            (ULONG_PTR) DeviceExtension->
                            MinidriverData->HwInitData.PerRequestExtensionSize) +
                            AdditionalSize1);
    //
    // point the IRP workspace to the request
    // packet
    //

    Irp->Tail.Overlay.DriverContext[0] = Request;

    return (Request);

}                               // end SCBuildRequestPacket()

VOID
SCProcessDmaDataBuffers(
                     IN PKSSTREAM_HEADER FirstHeader,
                     IN ULONG NumberOfHeaders,
                     IN PSTREAM_OBJECT StreamObject,
                     IN PMDL FirstMdl,
                     OUT PULONG NumberOfPages,
                     IN ULONG StreamHeaderSize,
                     IN BOOLEAN Write

)
/*++

Routine Description:

    Processes each data buffer for PIO &| DMA case

Arguments:

    FirstHeader - Address of the 1st s/g packet
    StreamObject- pointer to stream object
    NumberOfPages - number of pages in the request

Return Value:

--*/

{
    PKSSTREAM_HEADER CurrentHeader;
    PMDL            CurrentMdl;
    ULONG           i;
    ULONG           DataBytes;
    
    PAGED_CODE();

    //
    // loop through each scatter/gather elements
    //

    CurrentHeader = FirstHeader;
    CurrentMdl = FirstMdl;

    for (i = 0; i < NumberOfHeaders; i++) {

        //
        // pick up the correct data buffer, based on the xfer direction
        //

        if (Write) {

            DataBytes = CurrentHeader->DataUsed;

        } else {                // if write

            DataBytes = CurrentHeader->FrameExtent;

        }                       // if write

        //
        // if this header has data, process it.
        //

        if (DataBytes) {
            #if DBG
            if (CurrentHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEVALID) {
                DebugPrint((DebugLevelVerbose, "'SCProcessData: time = %x\n",
                            CurrentHeader->PresentationTime.Time));
            }
            #endif
            //
            // add # pages to total if DMA
            //
            *NumberOfPages += ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                         MmGetMdlVirtualAddress(CurrentMdl),
                                                                 DataBytes);
            CurrentMdl = CurrentMdl->Next;
        }
        //
        // offset to the next buffer
        //

        CurrentHeader = ((PKSSTREAM_HEADER) ((PBYTE) CurrentHeader +
                                             StreamHeaderSize));

    }                           // for # elements

}                               // end SCProcessDmaDataBuffers()

//
// mmGetSystemAddressForMdl() is defined as a macro in wdm.h which
// calls mmMapLockedPages() which is treated as an evil by verifier.
// mmMapLockedPages is reimplemented by mm via
// mmMapLockedPagesSpecifyCache(MDL,Mode,mmCaches,NULL,TRUE,HighPriority)
// where TRUE is to indicate a bug check, should the call fails.
// I don't need the bug check, therefore, I specify FALSE below.
//

#ifdef WIN9X_STREAM
#define SCGetSystemAddressForMdl(MDL) MmGetSystemAddressForMdl(MDL)

#else
#define SCGetSystemAddressForMdl(MDL)                       \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |         \
            MDL_SOURCE_IS_NONPAGED_POOL)) ?                 \
                  ((MDL)->MappedSystemVa) :                 \
                  (MmMapLockedPagesSpecifyCache((MDL),      \
                                    KernelMode,             \
                                    MmCached,               \
                                    NULL,                   \
                                    FALSE,                  \
                                    HighPagePriority)))
#endif                                    

BOOLEAN
SCProcessPioDataBuffers(
                     IN PKSSTREAM_HEADER FirstHeader,
                     IN ULONG NumberOfHeaders,
                     IN PSTREAM_OBJECT StreamObject,
                     IN PMDL FirstMdl,
                     IN ULONG StreamHeaderSize,
                     IN PVOID *pDataPtrArray,
                     IN BOOLEAN Write
)
/*++

Routine Description:

    Processes each data buffer for PIO &| DMA case

Arguments:

    FirstHeader - Address of the 1st s/g packet
    StreamObject- pointer to stream object
    NumberOfPages - number of pages in the request

Return Value:

--*/

{
    PKSSTREAM_HEADER CurrentHeader;
    PMDL            CurrentMdl;
    ULONG           i;
    ULONG           DataBytes;
    BOOLEAN         ret = FALSE;

    PAGED_CODE();

    //
    // loop through each scatter/gather elements
    //

    CurrentHeader = FirstHeader;
    CurrentMdl = FirstMdl;

    for (i = 0; i < NumberOfHeaders; i++) {

        //
        // pick up the correct data buffer, based on the xfer direction
        //

        if (Write) {

            DataBytes = CurrentHeader->DataUsed;

        } else {                // if write

            DataBytes = CurrentHeader->FrameExtent;

        }                       // if write

        //
        // if this header has data, process it.
        //

        if (DataBytes) {
            //
            // fill in the system virtual pointer
            // to the buffer if mapping is
            // needed
            //

            #if (DBG)
            if ( 0 !=  ( CurrentMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |
                    MDL_SOURCE_IS_NONPAGED_POOL))) {

                ASSERT(CurrentHeader->Data == (PVOID) ((ULONG_PTR) CurrentMdl->StartVa +
                                                   CurrentMdl->ByteOffset));                
            }
            #endif
            
            DebugPrint((DebugLevelVerbose, "Saving: Index:%x, Ptr:%x\n",
                i, CurrentHeader->Data));

            ret = TRUE;
            pDataPtrArray[i] = CurrentHeader->Data;
            CurrentHeader->Data = SCGetSystemAddressForMdl(CurrentMdl);

            DebugPrint((DebugLevelVerbose, "'SCPio: buff = %x, length = %x\n",
                        CurrentHeader->Data, DataBytes));
           
            CurrentMdl = CurrentMdl->Next;
        }
        //
        // offset to the next buffer
        //

        CurrentHeader = ((PKSSTREAM_HEADER) ((PBYTE) CurrentHeader +
                                             StreamHeaderSize));

    }                           // for # elements

    return(ret);
}                               // end SCProcessPioDataBuffers()


BOOLEAN
SCSetUpForDMA(
              IN PDEVICE_OBJECT DeviceObject,
              IN PSTREAM_REQUEST_BLOCK Request

)
/*++

Routine Description:

    process read/write DMA request.  allocate adapter channel.

Arguments:

    DeviceObject - device object for the device
    Request - address of Codec Request Block

Return Value:

    returns TRUE if channel is allocated

--*/

{
    NTSTATUS        status;

    //
    // Allocate the adapter channel with sufficient map registers
    // for the transfer.
    //

    status = IoAllocateAdapterChannel(
    ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->DmaAdapterObject,
                                      DeviceObject,
                                   Request->HwSRB.NumberOfPhysicalPages + 1,    // one more for the SRB
    // extension
                                      StreamClassDmaCallback,
                                      Request);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }
    return TRUE;

}


IO_ALLOCATION_ACTION
StreamClassDmaCallback(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP InputIrp,
                       IN PVOID MapRegisterBase,
                       IN PVOID Context
)
/*++

Routine Description:

    continues to process read/write request after DMA adapter is allocated
     builds scatter/gather list from logical buffer list.

Arguments:

     DeviceObject - dev object for adapter
     InputIrp - bogus
     MapRegisterBase - base address of map registers
     Context - address of Codec Request Block

Return Value:

     returns the appropriate I/O allocation action.

--*/

{
    PSTREAM_REQUEST_BLOCK Request = Context;
    PKSSCATTER_GATHER scatterList;
    BOOLEAN         writeToDevice;
    PVOID           dataVirtualAddress;
    ULONG           totalLength,
                    NumberOfBuffers;
    PIRP            Irp = Request->HwSRB.Irp;

    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                Request->HwSRB.StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
    );
    PMDL            CurrentMdl;
    ULONG           NumberOfElements = 0;

    //
    // Save the MapRegisterBase for later use
    // to deallocate the map
    // registers.
    //

    Request->MapRegisterBase = MapRegisterBase;

    //
    // determine whether this is a write request
    //

    writeToDevice = Request->HwSRB.Command == SRB_WRITE_DATA ? TRUE : FALSE;

    scatterList = Request->HwSRB.ScatterGatherBuffer;

    NumberOfBuffers = Request->HwSRB.NumberOfBuffers;

    ASSERT(Irp);

    CurrentMdl = Irp->MdlAddress;

    while (CurrentMdl) {

        //
        // Determine the virtual address of the buffer
        //

        dataVirtualAddress = (PSCHAR) MmGetMdlVirtualAddress(CurrentMdl);

        //
        // flush the buffers since we are doing DMA.
        //

        KeFlushIoBuffers(CurrentMdl,
        (BOOLEAN) (Request->HwSRB.Command == SRB_WRITE_DATA ? TRUE : FALSE),
                         TRUE);

        //
        // Build the scatter/gather list by looping through the buffers
        // calling I/O map transfer.
        //

        totalLength = 0;

        while (totalLength < CurrentMdl->ByteCount) {

            NumberOfElements++;

            //
            // Request that the rest of the transfer be mapped.
            //

            scatterList->Length = CurrentMdl->ByteCount - totalLength;

            //
            // Since we are a master call I/O map transfer with a NULL
            // adapter.
            //

            scatterList->PhysicalAddress = IoMapTransfer(((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))
                                                         ->DmaAdapterObject,
                                                         CurrentMdl,
                                                         MapRegisterBase,
                                                 (PSCHAR) dataVirtualAddress
                                                         + totalLength,
                                                       &scatterList->Length,
                                                         writeToDevice);

            DebugPrint((DebugLevelVerbose, "'SCDma: seg = %x'%x, length = %x\n",
                scatterList->PhysicalAddress.HighPart,
                scatterList->PhysicalAddress.LowPart,
                scatterList->Length));

            totalLength += scatterList->Length;
            scatterList++;
        }


        CurrentMdl = CurrentMdl->Next;

    }                           // while CurrentMdl

    Request->HwSRB.NumberOfScatterGatherElements = NumberOfElements;

    //
    // now map the transfer for the SRB in case the minidriver needs the
    // physical address of the extension.
    //
    // NOTE:  This function changes the length field in the SRB, which
    // makes it invalid.   It is not used elsewhere, however.
    //
    // We must flush the buffers appropriately as the SRB extension
    // may be DMA'ed both from and to. According to JHavens, we want to
    // tell IOMapXfer and KeFlushIoBuffers that this is a write, and upon
    // completion tell IoFlushAdapterBuffers that this is a read.
    //
    // Need to investigate if doing these extra calls add more overhead than
    // maintaining a queue of SRB's & extensions.   However, on x86
    // platforms the KeFlush call gets compiled out and
    // on PCI systems the IoFlush call doesn't get made, so there is no
    // overhead on these system except the map xfer call.
    //

    //
    // flush the SRB buffer since we are doing DMA.
    //

    KeFlushIoBuffers(Request->Mdl,
                     FALSE,
                     TRUE);

    //
    // get the physical address of the SRB
    //

    Request->PhysicalAddress = IoMapTransfer(((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))
                                             ->DmaAdapterObject,
                                             Request->Mdl,
                                             MapRegisterBase,
                                             (PSCHAR) MmGetMdlVirtualAddress(
                                                              Request->Mdl),
                                             &Request->Length,
                                             TRUE);

    //
    // if we are async, signal the event which will cause the request to be
    // called down on the original thread; otherwise, send the request down
    // now at dispatch level.
    //


    if (((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->NoSync) {

        KeSetEvent(&Request->DmaEvent, IO_NO_INCREMENT, FALSE);

    } else {

        //
        // send the request to the minidriver
        //

        SCStartMinidriverRequest(StreamObject,
                                 Request,
                                 (PVOID)
                            StreamObject->HwStreamObject.ReceiveDataPacket);

    }                           // if nosync

    //
    // keep the map registers but release the I/O adapter channel
    //

    return (DeallocateObjectKeepRegisters);
}



VOID
SCStartMinidriverRequest(
                         IN PSTREAM_OBJECT StreamObject,
                         IN PSTREAM_REQUEST_BLOCK Request,
                         IN PVOID EntryPoint
)
/*++

Routine Description:

    adds request to outstanding queue and starts the minidriver.

Arguments:

     StreamObject - Address stream info struct
     Request - Address of streaming data packet
     EntryPoint - Minidriver routine to be called

Return Value:

--*/

{
    PIRP            Irp = Request->HwSRB.Irp;
    PDEVICE_EXTENSION DeviceExtension =
    StreamObject->DeviceExtension;

    //
    // show that the request is active.
    //

    Request->Flags |= SRB_FLAGS_IS_ACTIVE;

    //
    // place the request on the outstanding queue
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    InsertHeadList(
                   &DeviceExtension->OutstandingQueue,
                   &Request->SRBListEntry);

    //
    // set the cancel routine to outstanding
    //

    IoSetCancelRoutine(Irp, StreamClassCancelOutstandingIrp);

    //
    // send down the request to the minidriver.  Protect the call with the
    // device spinlock to synchronize timers, etc.
    //

#if DBG
    if (DeviceExtension->NeedyStream) {

        ASSERT(DeviceExtension->NeedyStream->OnNeedyQueue);
    }
#endif

    DebugPrint((DebugLevelTrace, "'SCStartMinidriverRequeest: starting Irp %x, S# = %x, SRB = %x, Command = %x\n",
                Request->HwSRB.Irp, StreamObject->HwStreamObject.StreamNumber, Request, Request->HwSRB.Command));


    DeviceExtension->SynchronizeExecution(
                                          DeviceExtension->InterruptObject,
                                          EntryPoint,
                                          &Request->HwSRB);


#if DBG
    if (DeviceExtension->NeedyStream) {

        ASSERT(DeviceExtension->NeedyStream->OnNeedyQueue);
    }
#endif

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    return;

}                               // SCStartMinidriverRequest



VOID
StreamClassDpc(
               IN PKDPC Dpc,
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp,
               IN PVOID Context
)
/*++

Routine Description:

    this routine processes requests and notifications from the minidriver

Arguments:

    Dpc - pointer to Dpc structure
    DeviceObject - device object for the adapter
    Irp - not used
    Context - StreamObject structure

Return Value:

    None.

--*/

{
    PSTREAM_OBJECT  StreamObject = Context,
                    NeedyStream;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    INTERRUPT_CONTEXT interruptContext;
    INTERRUPT_DATA  SavedStreamInterruptData;
    INTERRUPT_DATA  SavedDeviceInterruptData;
    PSTREAM_REQUEST_BLOCK SRB;
    PERROR_LOG_ENTRY LogEntry;
    HW_TIME_CONTEXT TimeContext;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Dpc);

    interruptContext.SavedStreamInterruptData = &SavedStreamInterruptData;
    interruptContext.SavedDeviceInterruptData = &SavedDeviceInterruptData;
    interruptContext.DeviceExtension = DeviceExtension;

    DebugPrint((DebugLevelVerbose, "'StreamClassDpc: enter\n"));

    //
    // if a stream object is passed in, first
    // check if work is pending
    //

    if (StreamObject) {

        SCStartRequestOnStream(StreamObject, DeviceExtension);

    }                           // if streamobject
RestartDpc:

    //
    // Check for a ready for next packet on
    // the device.
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    if ((DeviceExtension->ReadyForNextReq) &&
        (!IsListEmpty(&DeviceExtension->PendingQueue))) {

        //
        // start the device request, which
        // clears the ready flag and
        // releases the spinlock.  Then
        // reacquire the spinloc.
        //

        SCDequeueAndStartDeviceRequest(DeviceExtension);
        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    }
    //
    // Get the interrupt state snapshot. This copies the interrupt state to
    // saved state where it can be processed. It also clears the interrupt
    // flags.  We acquired the device spinlock to protect the structure as
    // the minidriver could have requested a DPC call from this routine,
    // which could be preempted in the middle of minidriver's changing the
    // below structure, and we'd then take a snapshot of the structure while
    // it was changing.
    //

    interruptContext.NeedyStream = NULL;

    SavedDeviceInterruptData.CompletedSRB = NULL;
    SavedStreamInterruptData.CompletedSRB = NULL;
    SavedDeviceInterruptData.Flags = 0;
    SavedStreamInterruptData.Flags = 0;

    if (!DeviceExtension->SynchronizeExecution(DeviceExtension->InterruptObject,
                                               SCGetInterruptState,
                                               &interruptContext)) {

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
        return;
    }
    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    NeedyStream = interruptContext.NeedyStream;

    if (NeedyStream) {

        //
        // try to start a request on this
        // stream
        //

        SCStartRequestOnStream(NeedyStream, DeviceExtension);

        //
        // Process any completed stream requests.
        //

        while (SavedStreamInterruptData.CompletedSRB != NULL) {

            //
            // Remove the request from the
            // linked-list.
            //

            SRB = CONTAINING_RECORD(SavedStreamInterruptData.CompletedSRB,
                                    STREAM_REQUEST_BLOCK,
                                    HwSRB);

            SavedStreamInterruptData.CompletedSRB = SRB->HwSRB.NextSRB;

            DebugPrint((DebugLevelTrace, "'SCDpc: Completing stream Irp %x, S# = %x, SRB = %x, Func = %x, Callback = %x, SRB->IRP = %x\n",
                   SRB->HwSRB.Irp, NeedyStream->HwStreamObject.StreamNumber,
                   SRB, SRB->HwSRB.Command, SRB->Callback, SRB->HwSRB.Irp));

            SCCallBackSrb(SRB, DeviceExtension);

        }

        //
        // Check for timer requests.
        //

        if (SavedStreamInterruptData.Flags & INTERRUPT_FLAGS_TIMER_CALL_REQUEST) {

            SCProcessTimerRequest(&NeedyStream->ComObj,
                                  &SavedStreamInterruptData);
        }
        //
        // check to see if a change priority call has been requested.
        //

        if (SavedStreamInterruptData.Flags &
            INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) {

            SCProcessPriorityChangeRequest(&NeedyStream->ComObj,
                                           &SavedStreamInterruptData,
                                           DeviceExtension);
        }
        //
        // Check for master clock queries.
        //

        if (SavedStreamInterruptData.Flags & INTERRUPT_FLAGS_CLOCK_QUERY_REQUEST) {

            LARGE_INTEGER   ticks;
            ULONGLONG       rate;
            KIRQL           SavedIrql;

            //
            // call the master clock's entry point then call the minidriver's
            // callback procedure to report the time.
            //

            TimeContext.HwDeviceExtension = DeviceExtension->HwDeviceExtension;
            TimeContext.HwStreamObject = &NeedyStream->HwStreamObject;
            TimeContext.Function = SavedStreamInterruptData.HwQueryClockFunction;

            //
            // take the lock so MasterCliockinfo won't disapear under us
            //
            KeAcquireSpinLock( &NeedyStream->LockUseMasterClock, &SavedIrql );

            if ( NULL == NeedyStream->MasterClockInfo ) {
                ASSERT( 0 && "Mini driver queries clock while we have no master clock");
                //
                // give a hint that something is wrong via Time, since we return void.
                //
                TimeContext.Time = (ULONGLONG)-1;
                goto callminidriver;
            }
                

            switch (SavedStreamInterruptData.HwQueryClockFunction) {

            case TIME_GET_STREAM_TIME:

                TimeContext.Time = NeedyStream->MasterClockInfo->
                    FunctionTable.GetCorrelatedTime(
                              NeedyStream->MasterClockInfo->ClockFileObject,
                                                    &TimeContext.SystemTime);

                goto callminidriver;

            case TIME_READ_ONBOARD_CLOCK:

                TimeContext.Time = NeedyStream->MasterClockInfo->
                    FunctionTable.GetTime(
                             NeedyStream->MasterClockInfo->ClockFileObject);

                //
                // timestamp the value as close as possible
                //

                ticks = KeQueryPerformanceCounter((PLARGE_INTEGER) & rate);

                TimeContext.SystemTime = KSCONVERT_PERFORMANCE_TIME( rate, ticks );
                    

        callminidriver:

                //
                // finish using MasterClockInfo.
                //
                
                KeReleaseSpinLock( &NeedyStream->LockUseMasterClock, SavedIrql );                            

                //
                // call the minidriver's callback procedure
                //


                if (!DeviceExtension->NoSync) {

                    //
                    // Acquire the device spinlock.
                    //

                    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

                }
                DebugPrint((DebugLevelTrace, "'SCDPC: calling time func, S# = %x, Command = %x\n",
                            NeedyStream->HwStreamObject.StreamNumber, TimeContext.Function));

                DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                                                      (PKSYNCHRONIZE_ROUTINE) SavedStreamInterruptData.HwQueryClockRoutine,
                                                      &TimeContext
                    );

                if (!DeviceExtension->NoSync) {

                    //
                    // Release the spinlock.
                    //

                    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                }
                break;


            default:
                KeReleaseSpinLock( &NeedyStream->LockUseMasterClock, SavedIrql );                            
                ASSERT(0);
            }                   // switch clock func
        }                       // if queryclock
    }                           // if needystream
    //
    // Check for an error log request.
    //

    if (SavedDeviceInterruptData.Flags & INTERRUPT_FLAGS_LOG_ERROR) {

        //
        // Process the error log request.
        //

        LogEntry = &SavedDeviceInterruptData.LogEntry;

        SCLogError(DeviceObject,
                   LogEntry->SequenceNumber,
                   LogEntry->ErrorCode,
                   LogEntry->UniqueId
            );

    }                           // if log error
    //
    // Process any completed device requests.
    //

    while (SavedDeviceInterruptData.CompletedSRB != NULL) {

        //
        // Remove the request from the linked-list.
        //

        SRB = CONTAINING_RECORD(SavedDeviceInterruptData.CompletedSRB,
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        SavedDeviceInterruptData.CompletedSRB = SRB->HwSRB.NextSRB;

        DebugPrint((DebugLevelTrace, "'SCDpc: Completing device Irp %x\n", SRB->HwSRB.Irp));

        SCCallBackSrb(SRB, DeviceExtension);
    }

    //
    // Check for device timer requests.
    //

    if (SavedDeviceInterruptData.Flags & INTERRUPT_FLAGS_TIMER_CALL_REQUEST) {

        SCProcessTimerRequest(&DeviceExtension->ComObj,
                              &SavedDeviceInterruptData);
    }
    //
    // check if we have any dead events that need discarding.  if so, we'll
    // schedule a work item to get rid of them.
    //

    if ((!IsListEmpty(&DeviceExtension->DeadEventList)) &&
        (!(DeviceExtension->DeadEventItemQueued))) {

        DeviceExtension->DeadEventItemQueued = TRUE;

        ExQueueWorkItem(&DeviceExtension->EventWorkItem,
                        DelayedWorkQueue);
    }
    //
    // check to see if a change priority call
    // has been requested for the device.
    //

    if (SavedDeviceInterruptData.Flags &
        INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) {

        SCProcessPriorityChangeRequest(&DeviceExtension->ComObj,
                                       &SavedDeviceInterruptData,
                                       DeviceExtension);

    }                           // if change priority
    //
    // Check for stream rescan request.
    //

    if (SavedDeviceInterruptData.Flags & INTERRUPT_FLAGS_NEED_STREAM_RESCAN) {

        TRAP;
        ExQueueWorkItem(&DeviceExtension->RescanWorkItem,
                        DelayedWorkQueue);
    }
    //
    // Check for minidriver work requests. Note this is an unsynchronized
    // test on bits that can be set by the interrupt routine; however,
    // the worst that can happen is that the completion DPC checks for work
    // twice.
    //

    if ((DeviceExtension->NeedyStream)
        || (DeviceExtension->ComObj.InterruptData.Flags &
            INTERRUPT_FLAGS_NOTIFICATION_REQUIRED)) {

        //
        // Start over from the top.
        //

        DebugPrint((DebugLevelVerbose, "'StreamClassDpc: restarting\n"));
        goto RestartDpc;
    }
    return;

}                               // end StreamClassDpc()


VOID
SCStartRequestOnStream(
                       IN PSTREAM_OBJECT StreamObject,
                       IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Routine tries to start either a control or data request on the specified
    stream.

Arguments:

    StreamObject - pointer to stream object
    DeviceExtension - pointer to device extension.

Return Value:

    None

Notes:

--*/
{
    //
    // Check for a ready for next packet. Acquire spinlock to protect
    // READY bits.  Note that we don't snapshot the ready flags as we do with
    // the remaining notification flags, as we don't want to clear the flags
    // unconditionally in the snapshot in case there is not currently a
    // request pending.   Also, starting a request before the snapshot will
    // give a slight perf improvement.  Note that the flags can be set via
    // the minidriver while we are checking them, but since the minidriver
    // cannot clear them and the minidriver cannot call for a next request
    // more than once before it receives one, this is not a problem.
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    if ((StreamObject->ReadyForNextDataReq) &&
        (!IsListEmpty(&StreamObject->DataPendingQueue))) {

        //
        // start the request, which clears the ready flag and releases
        // the spinlock, then reobtain the spinlock.
        //

        SCDequeueAndStartStreamDataRequest(StreamObject);
        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    }                           // if ready for data
    if ((StreamObject->ReadyForNextControlReq) &&
        (!IsListEmpty(&StreamObject->ControlPendingQueue))) {

        //
        // start the request, which clears the ready flag and releases
        // the spinlock.
        //

        SCDequeueAndStartStreamControlRequest(StreamObject);

    } else {

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    }                           // if ready for control

    return;
}



BOOLEAN
SCGetInterruptState(
                    IN PVOID ServiceContext
)
/*++

Routine Description:

    This routine saves the InterruptFlags, error log info, and
    CompletedRequests fields and clears the InterruptFlags.

Arguments:

    ServiceContext - Supplies a pointer to the interrupt context which contains
        pointers to the interrupt data and where to save it.

Return Value:

    Returns TRUE if there is new work and FALSE otherwise.

Notes:

    Called via KeSynchronizeExecution with the port device extension spinlock
    held.

--*/
{
    PINTERRUPT_CONTEXT interruptContext = ServiceContext;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  NeedyStream;
    BOOLEAN         Work = FALSE;

    DeviceExtension = interruptContext->DeviceExtension;

    //
    // get the needy streams and zero the
    // link.
    //

    interruptContext->NeedyStream = NeedyStream = DeviceExtension->NeedyStream;

    //
    // capture the state of needy stream
    //

    if (NeedyStream) {

        //
        // Move the interrupt state to save
        // area.
        //

        ASSERT(NeedyStream->NextNeedyStream != NeedyStream);
        ASSERT(NeedyStream->ComObj.InterruptData.Flags & INTERRUPT_FLAGS_NOTIFICATION_REQUIRED);
        ASSERT(NeedyStream->OnNeedyQueue);

        DebugPrint((DebugLevelVerbose, "'SCGetInterruptState: Snapshot for stream %p, S# = %x, NextNeedy = %p\n",
                    NeedyStream, NeedyStream->HwStreamObject.StreamNumber, NeedyStream->NextNeedyStream));

        NeedyStream->OnNeedyQueue = FALSE;

        *interruptContext->SavedStreamInterruptData =
            NeedyStream->ComObj.InterruptData;

        //
        // Clear the interrupt state.
        //

        NeedyStream->ComObj.InterruptData.Flags &= STREAM_FLAGS_INTERRUPT_FLAG_MASK;
        NeedyStream->ComObj.InterruptData.CompletedSRB = NULL;

        Work = TRUE;

        DeviceExtension->NeedyStream = (PSTREAM_OBJECT) NeedyStream->NextNeedyStream;
        NeedyStream->NextNeedyStream = NULL;

#if DBG
        if (DeviceExtension->NeedyStream) {

            ASSERT(DeviceExtension->NeedyStream->OnNeedyQueue);
        }
#endif

    }                           // if NeedyStream
    //
    // now copy over the device interrupt
    // data if necessary
    //

    if (DeviceExtension->ComObj.InterruptData.Flags &
        INTERRUPT_FLAGS_NOTIFICATION_REQUIRED) {

        *interruptContext->SavedDeviceInterruptData =
            DeviceExtension->ComObj.InterruptData;

        //
        // Clear the device interrupt state.
        //

        DeviceExtension->ComObj.InterruptData.Flags &=
            DEVICE_FLAGS_INTERRUPT_FLAG_MASK;

        DeviceExtension->ComObj.InterruptData.CompletedSRB = NULL;
        Work = TRUE;
    }
    return (Work);
}



NTSTATUS
SCProcessCompletedRequest(
                          IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    This routine processes a request which has completed.

Arguments:

    SRB- address of completed STREAM request block

Return Value:

    None.

--*/

{
    PIRP            Irp = SRB->HwSRB.Irp;

    //
    // complete the IRP
    //

    return (SCCompleteIrp(Irp,
                          SCDequeueAndDeleteSrb(SRB),
                     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1));

}



NTSTATUS
SCDequeueAndDeleteSrb(
                      IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    This routine dequeues and deletes a completed SRB

Arguments:

    SRB- address of completed STREAM request block

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    NTSTATUS        Status = SRB->HwSRB.Status;
    KIRQL           irql;

    //
    // remove the SRB from our outstanding
    // queue.  protect list with
    // spinlock.
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

    RemoveEntryList(&SRB->SRBListEntry);

    if (SRB->HwSRB.Irp) {

        IoSetCancelRoutine(SRB->HwSRB.Irp, NULL);
    }
    KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

    //
    // free the SRB and MDL
    //
    
    if ( !NT_SUCCESS( Status )) {
        DebugPrint((DebugLevelWarning, 
                   "SCDequeueAndDeleteSrb Command:%x Status=%x\n",
                   SRB->HwSRB.Command, 
                   Status ));
    }
    
    IoFreeMdl(SRB->Mdl);
    ExFreePool(SRB);
    return (Status);
}


VOID
SCProcessCompletedDataRequest(
                              IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    This routine processes a data request which has completed.  It completes any
    pending transfers, releases the adapter objects and map registers.

Arguments:

    SRB- address of completed STREAM request block

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    PMDL            CurrentMdl;
    ULONG           i = 0;

    if (Irp) {

        PIO_STACK_LOCATION IrpStack;
        PKSSTREAM_HEADER CurrentHeader;

        CurrentHeader = SRB->HwSRB.CommandData.DataBufferArray;

        ASSERT(CurrentHeader);

        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        ASSERT(IrpStack);

#if DBG

        //
        // assert the MDL list.
        //

        CurrentMdl = Irp->MdlAddress;

        while (CurrentMdl) {

            CurrentMdl = CurrentMdl->Next;
        }                       // while
#endif

        CurrentMdl = Irp->MdlAddress;

        while (CurrentMdl) {

            //
            // flush the buffers if we did PIO data in
            //

            if (SRB->HwSRB.StreamObject->Pio) {

                //
                // find the first header with data...
                //

                while (!(CurrentHeader->DataUsed) && (!CurrentHeader->FrameExtent)) {

                    CurrentHeader = ((PKSSTREAM_HEADER) ((PBYTE) CurrentHeader +
                                                    SRB->StreamHeaderSize));
                }

                //
                // restore the pointer we changed
                //

//                CurrentHeader->Data = (PVOID) ((ULONG_PTR) CurrentMdl->StartVa +
//                                               CurrentMdl->ByteOffset);
//
                if (SRB->bMemPtrValid) { // safety first!
                    DebugPrint((DebugLevelVerbose, "Restoring: Index:%x, Ptr:%x\n",
                            i, SRB->pMemPtrArray[i]));

                    CurrentHeader->Data = SRB->pMemPtrArray[i];
                }

                DebugPrint((DebugLevelVerbose, "'SCPioComplete: Irp = %x, header = %x, Data = %x\n",
                            Irp, CurrentHeader, CurrentHeader->Data));

                //
                // update to the next header
                //
                i++;
                CurrentHeader = ((PKSSTREAM_HEADER) ((PBYTE) CurrentHeader +
                                                     SRB->StreamHeaderSize));

                if (SRB->HwSRB.Command == SRB_READ_DATA) {

                    KeFlushIoBuffers(CurrentMdl,
                                     TRUE,
                                     FALSE);

                }               // if data in
            }                   // if PIO
            //
            // Flush the adapter buffers if we had map registers => DMA.
            //

            if (SRB->MapRegisterBase) {

                //
                // Since we are a master call I/O flush adapter buffers
                // with a NULL adapter.
                //

                IoFlushAdapterBuffers(DeviceExtension->DmaAdapterObject,
                                      CurrentMdl,
                                      SRB->MapRegisterBase,
                                      MmGetMdlVirtualAddress(CurrentMdl),
                                      CurrentMdl->ByteCount,
                                      (BOOLEAN) (SRB->HwSRB.Command ==
                                               SRB_READ_DATA ? FALSE : TRUE)
                    );

            }                   // if DMA
            CurrentMdl = CurrentMdl->Next;


        }                       // while CurrentMdl

        //
        // flush the buffer for the SRB extension in case the adapter DMA'ed
        // to it.   JHavens says we must treat this as a READ.
        //

        //
        // Flush the adapter buffer for the SRB if we had map registers =>
        // DMA.
        //

        if (SRB->MapRegisterBase) {

            IoFlushAdapterBuffers(DeviceExtension->DmaAdapterObject,
                                  SRB->Mdl,
                                  SRB->MapRegisterBase,
                                  MmGetMdlVirtualAddress(
                                                         SRB->Mdl),
                                  SRB->Length,
                                  FALSE);

            //
            // Free the map registers if DMA.
            //

            IoFreeMapRegisters(DeviceExtension->DmaAdapterObject,
                               SRB->MapRegisterBase,
                               SRB->HwSRB.NumberOfPhysicalPages);

        }                       // if MapRegisterBase
        //
        // free the extra data, if any.
        //

        if (IrpStack->Parameters.Others.Argument4 != NULL) {

            TRAP;
            ExFreePool(IrpStack->Parameters.Others.Argument4);

        }                       // if extradata
    }                           // if Irp
    //
    // call the generic completion handler
    //

    SCProcessCompletedRequest(SRB);

}                               // SCProcessCompletedDataRequest



VOID
SCMinidriverStreamTimerDpc(
                           IN struct _KDPC * Dpc,
                           IN PVOID Context,
                           IN PVOID SystemArgument1,
                           IN PVOID SystemArgument2
)
/*++

Routine Description:

    This routine calls the minidriver when its requested timer fires.
    It interlocks either with the port spinlock and the interrupt object.

Arguments:

    Dpc - Unsed.
    Context - Supplies a pointer to the stream object for this adapter.
    SystemArgument1 - Unused.
    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{
    PSTREAM_OBJECT  StreamObject = ((PSTREAM_OBJECT) Context);
    PDEVICE_EXTENSION DeviceExtension = StreamObject->DeviceExtension;

    //
    // Acquire the device spinlock if synchronized.
    //

    if (!(DeviceExtension->NoSync)) {

        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
    }
    //
    // Make sure the timer routine is still
    // desired.
    //

    if (StreamObject->ComObj.HwTimerRoutine != NULL) {

        DebugPrint((DebugLevelTrace, "'SCTimerDpc: Calling MD timer callback, S# = %x, Routine = %p\n",
                    StreamObject->HwStreamObject.StreamNumber, StreamObject->ComObj.HwTimerRoutine));

        DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) StreamObject->ComObj.HwTimerRoutine,
                                         StreamObject->ComObj.HwTimerContext
            );

    }
    //
    // Release the spinlock if we're synchronized.
    //

    if (!(DeviceExtension->NoSync)) {

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    }
    //
    // Call the DPC directly to check for work.
    //

    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   StreamObject);

}



VOID
SCMinidriverDeviceTimerDpc(
                           IN struct _KDPC * Dpc,
                           IN PVOID Context,
                           IN PVOID SystemArgument1,
                           IN PVOID SystemArgument2
)
/*++

Routine Description:

    This routine calls the minidriver when its requested timer fires.
    It interlocks either with the port spinlock and the interrupt object.

Arguments:

    Dpc - Unsed.

    Context - Supplies a pointer to the stream object for this adapter.

    SystemArgument1 - Unused.

    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = Context;

    //
    // Acquire the device spinlock.
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    //
    // Make sure the timer routine is still
    // desired.
    //

    if (DeviceExtension->ComObj.HwTimerRoutine != NULL) {

        DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
             (PKSYNCHRONIZE_ROUTINE) DeviceExtension->ComObj.HwTimerRoutine,
                                      DeviceExtension->ComObj.HwTimerContext
            );

    }
    //
    // Release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    //
    // Call the DPC directly to check for
    // work.
    //

    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   NULL);

}



VOID
SCLogError(
           IN PDEVICE_OBJECT DeviceObject,
           IN ULONG SequenceNumber,
           IN NTSTATUS ErrorCode,
           IN ULONG UniqueId
)
/*++

Routine Description:

    This function logs an error.

Arguments:

    DeviceObject - device or driver object
    SequenceNumber - supplies the sequence # of the error.
    ErrorCode - Supplies the error code for this error.
    UniqueId - Supplies the UniqueId for this error.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET packet;

    PAGED_CODE();
    packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceObject,
                                               sizeof(IO_ERROR_LOG_PACKET));

    if (packet) {
        packet->ErrorCode = ErrorCode;
        packet->SequenceNumber = SequenceNumber;
        packet->MajorFunctionCode = 0;
        packet->RetryCount = (UCHAR) 0;
        packet->UniqueErrorValue = UniqueId;
        packet->FinalStatus = STATUS_SUCCESS;
        packet->DumpDataSize = 0;

        IoWriteErrorLogEntry(packet);
    }
}



VOID
SCLogErrorWithString(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN OPTIONAL PDEVICE_EXTENSION DeviceExtension,
                     IN NTSTATUS ErrorCode,
                     IN ULONG UniqueId,
                     IN PUNICODE_STRING String1
)
/*++

Routine Description

    This function logs an error and includes the string provided.

Arguments:

    DeviceObject - device or driver object
    DeviceExtension - Supplies a pointer to the port device extension.
    ErrorCode - Supplies the error code for this error.
    UniqueId - Supplies the UniqueId for this error.
    String1 - The string to be inserted.

Return Value:

    None.

--*/

{
    ULONG           length;
    PCHAR           dumpData;
    PIO_ERROR_LOG_PACKET packet;

    PAGED_CODE();
    length = String1->Length + sizeof(IO_ERROR_LOG_PACKET) + 2;
    if (length > ERROR_LOG_MAXIMUM_SIZE) {
        length = ERROR_LOG_MAXIMUM_SIZE;
    }
    packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceObject,
                                                            (UCHAR) length);
    if (packet) {
        packet->ErrorCode = ErrorCode;
        packet->SequenceNumber = (DeviceExtension != NULL) ?
            DeviceExtension->SequenceNumber++ : 0;
        packet->MajorFunctionCode = 0;
        packet->RetryCount = (UCHAR) 0;
        packet->UniqueErrorValue = UniqueId;
        packet->FinalStatus = STATUS_SUCCESS;
        packet->NumberOfStrings = 1;
        packet->StringOffset = (USHORT) ((PUCHAR) & packet->DumpData[0] - (PUCHAR) packet);
        packet->DumpDataSize = (USHORT) (length - sizeof(IO_ERROR_LOG_PACKET));
        packet->DumpDataSize /= sizeof(ULONG);
        dumpData = (PUCHAR) & packet->DumpData[0];

        RtlCopyMemory(dumpData, String1->Buffer, String1->Length);
        dumpData += String1->Length;
        *dumpData++ = '\0';
        *dumpData++ = '\0';


        IoWriteErrorLogEntry(packet);
    }
    return;
}




BOOLEAN
StreamClassSynchronizeExecution(
                                IN PKINTERRUPT Interrupt,
                                IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
                                IN PVOID SynchronizeContext
)
/*++

Routine Description:

    This routine calls the minidriver entry point which was passed in as
    a parameter.  It acquires a spin lock so that all accesses to the
    minidriver's routines are synchronized.  This routine is used as a
    subsitute for KeSynchronizedExecution for minidrivers which do not use
    hardware interrupts.


Arguments:

    Interrrupt - Supplies a pointer to the port device extension.
    SynchronizeRoutine - Supplies a pointer to the routine to be called.
    SynchronizeContext - Supplies the context to pass to the
        SynchronizeRoutine.

Return Value:

    Returns the returned by the SynchronizeRoutine.

--*/

{
    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION) Interrupt;
    BOOLEAN         returnValue;

#if DBG
    ULONGLONG       ticks;
    ULONGLONG       rate;
    ULONGLONG       StartTime,
                    EndTime;

    ticks = (ULONGLONG) KeQueryPerformanceCounter((PLARGE_INTEGER) & rate).QuadPart;

    StartTime = ticks * 10000 / rate;
#endif

    returnValue = SynchronizeRoutine(SynchronizeContext);

#if DBG
    ticks = (ULONGLONG) KeQueryPerformanceCounter((PLARGE_INTEGER) & rate).QuadPart;

    EndTime = ticks * 10000 / rate;

    DebugPrint((DebugLevelVerbose, "'SCDebugSync: minidriver took %d microseconds at dispatch level.\n",
                (EndTime - StartTime) * 10));

    if ((EndTime - StartTime) > 100) {

        DebugPrint((DebugLevelFatal, "Stream Class: minidriver took %I64d millisecond(s) at "
                    "dispatch level.   See dev owner.  Type LN %p for the name of the minidriver\n",
                    (EndTime - StartTime) / 100, SynchronizeRoutine));
    }
#endif

    return (returnValue);
}

#if DBG

BOOLEAN
SCDebugKeSynchronizeExecution(
                              IN PKINTERRUPT Interrupt,
                              IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
                              IN PVOID SynchronizeContext
)
/*++

Routine Description:

Arguments:

    Interrrupt - Supplies a pointer to the port device extension.
    SynchronizeRoutine - Supplies a pointer to the routine to be called.
    SynchronizeContext - Supplies the context to pass to the
        SynchronizeRoutine.

Return Value:

    Returns the returned by the SynchronizeRoutine.

--*/

{
    ULONGLONG       ticks;
    ULONGLONG       rate;
    ULONGLONG       StartTime,
                    EndTime;
    BOOLEAN         returnValue;

    ticks = (ULONGLONG) KeQueryPerformanceCounter((PLARGE_INTEGER) & rate).QuadPart;

    StartTime = ticks * 10000 / rate;

    returnValue = KeSynchronizeExecution(Interrupt,
                                         SynchronizeRoutine,
                                         SynchronizeContext);

    ticks = (ULONGLONG) KeQueryPerformanceCounter((PLARGE_INTEGER) & rate).QuadPart;

    EndTime = ticks * 10000 / rate;

    DebugPrint((DebugLevelVerbose, "'SCDebugSync: minidriver took %d microseconds at raised IRQL.\n",
                (EndTime - StartTime) * 10));

    if ((EndTime - StartTime) > 50) {

        DebugPrint((DebugLevelFatal, "Stream Class: minidriver took %d%d millisecond(s) at raised IRQL.   See dev owner.  Type LN %x for the name of the minidriver\n",
                    (EndTime - StartTime) / 100, SynchronizeRoutine));
    }
    return (returnValue);
}

#endif

NTSTATUS
SCCompleteIrp(
              IN PIRP Irp,
              IN NTSTATUS Status,
              IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Routine generically calls back a completed IRP, and shows one less I/O
    pending.

Arguments:

    Irp - IRP to complete
    Status - Status to complete it with
    DeviceExtension - pointer to device extension

Return Value:

    Returns the Status parameter

--*/

{

	#if DBG
    PMDL            CurrentMdl;
	#endif

    if (Irp) {
        Irp->IoStatus.Status = Status;

		#if DBG

        //
        // random asserts follow...
        // make sure we have not freed the system buffer.
        //


        if (Irp->AssociatedIrp.SystemBuffer) {

            DebugPrint((DebugLevelVerbose, "'SCComplete: Irp = %p, sys buffer = %p\n",
                        Irp, Irp->AssociatedIrp.SystemBuffer));
        }
        //
        // assert the MDL list.
        //

        CurrentMdl = Irp->MdlAddress;

        while (CurrentMdl) {

            CurrentMdl = CurrentMdl->Next;
        }                       // while
		#endif
		
        if ( Irp->CurrentLocation < Irp->StackCount+1 ) {
        
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            
        } else {
            //
            // we got a dummy Irp we created. IoVerifier code will pews if
            // we call IoCompleteRequest because the Current Stack location
            // is at the end of last stack location. We can't use 
            // IoBuildIoControlRequest to create the Irp becuase it will
            // be added to a thread and the only way to get it off is to
            // call IoCompleteRequest.
            //
            IoFreeIrp( Irp );
        }  
    }
    
    if (!(InterlockedDecrement(&DeviceExtension->OneBasedIoCount))) {

        //
        // the device is being removed and all I/O is complete.  Signal the
        // removal thread to wake up.
        //

        KeSetEvent(&DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE);
    }
    ASSERT(DeviceExtension->OneBasedIoCount >= 0);
    return (Status);
}


BOOLEAN
SCDummyMinidriverRoutine(
                         IN PVOID Context
)
/*++

Routine Description:

    Routine used when the minidriver fills in a null for an optional routine

Arguments:

    Context - unreferenced

Return Value:

    TRUE

--*/

{

    return (TRUE);
}


#if ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SCOpenMinidriverInstance(
    IN PDEVICE_EXTENSION DeviceExtension,
    OUT PFILTER_INSTANCE * ReturnedFilterInstance,
    IN PSTREAM_CALLBACK_PROCEDURE SCGlobalInstanceCallback,
    IN PIRP Irp)
/*++

Routine Description:

    Worker routine to process opening of a filter instance.
    Once open, we issue srb_get_stream_info.

Arguments:

    DeviceExtension - pointer to device extension
    ReturnedFilterInstance - pointer to the filter instance structure
    SCGlobalInstanceCallback - callback procedure to be called if we call the minidriver
    Irp - pointer to the irp

Return Value:

    Returns NTSTATUS and a filter instance structure if successfull

--*/

{
    ULONG                   FilterExtensionSize;
    PFILTER_INSTANCE        FilterInstance;
    PHW_STREAM_INFORMATION  CurrentInfo;
    PADDITIONAL_PIN_INFO    CurrentAdditionalInfo;
    ULONG                   i;
    BOOLEAN                 RequestIssued;
   	PKSOBJECT_CREATE_ITEM   CreateItem;
	ULONG                   FilterTypeIndex;
	ULONG                   NumberOfPins;
    NTSTATUS                Status = STATUS_SUCCESS;

    PAGED_CODE();

   	//
   	// The CreateItem is in Irp->Tail.Overlay.DriverContext[0] from KS
   	//
    CreateItem = (PKSOBJECT_CREATE_ITEM)Irp->Tail.Overlay.DriverContext[0];
	ASSERT( CreateItem != NULL );
    FilterTypeIndex = (ULONG)(ULONG_PTR)CreateItem->Context;
    
    ASSERT( FilterTypeIndex == 0 ||
            FilterTypeIndex < 
            DeviceExtension->MinidriverData->HwInitData.NumNameExtensions);
            
    FilterExtensionSize = DeviceExtension->FilterExtensionSize;

    ASSERT( DeviceExtension->FilterExtensionSize ==
        	DeviceExtension->MinidriverData->
        	    HwInitData.FilterInstanceExtensionSize);
        	    
    FilterInstance = NULL;

    NumberOfPins = DeviceExtension->FilterTypeInfos[FilterTypeIndex].
                        StreamDescriptor->StreamHeader.NumberOfStreams;

    //
    // don't call the minidriver to open the filter instance if 1x1 for backward
    // compat. We do this so that minidrivers that don't support
    // instancing (the vast majority) don't have to respond to this call.
    // 

    if ( DeviceExtension->NumberOfOpenInstances > 0 && 
         0 == FilterExtensionSize ) {
   		//
   		// Legacy 1x1 and non-1st open. assign the same
   		// FilterInstance and succeed it.
   		//

   		PLIST_ENTRY node;
   		ASSERT( !IsListEmpty( &DeviceExtension->FilterInstanceList));
   		node = DeviceExtension->FilterInstanceList.Flink;
        FilterInstance = CONTAINING_RECORD(node,
                                           FILTER_INSTANCE,
                                           NextFilterInstance);
        ASSERT_FILTER_INSTANCE( FilterInstance );
        *ReturnedFilterInstance = FilterInstance;
   		Status = STATUS_SUCCESS;
   		return Status; // can't goto Exit, it will insert FI again.
    }

    FilterInstance =
        ExAllocatePool(NonPagedPool, sizeof(FILTER_INSTANCE) + 
        							     FilterExtensionSize +
			            	             sizeof(ADDITIONAL_PIN_INFO) *
        				    	         NumberOfPins);

    if (!FilterInstance) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    RtlZeroMemory(FilterInstance, sizeof(FILTER_INSTANCE) + 
                                    FilterExtensionSize +
        	            	        sizeof(ADDITIONAL_PIN_INFO) *
                                    NumberOfPins);

    FilterInstance->Signature = SIGN_FILTER_INSTANCE;
    FilterInstance->DeviceExtension = DeviceExtension; // keep this handy    
    //
	// To get FilterInstance from HwInstanceExtension we need
	// to arrange the memory layout 
	// [FilterInstnace][HwInstanceExtension][AddionalPinInfo...]
	// as opposed to 
	// [FilterInstance][AdditionalPinInfo...][HwInstanceExtension]
	//

    FilterInstance->HwInstanceExtension = FilterInstance + 1;
    
	FilterInstance->PinInstanceInfo = 
		(PADDITIONAL_PIN_INFO) ((PBYTE)(FilterInstance+1) + FilterExtensionSize);

   	FilterInstance->FilterTypeIndex = FilterTypeIndex;
	
    //
    // initialize the filter instance list
    //

    InitializeListHead(&FilterInstance->FirstStream);
    InitializeListHead(&FilterInstance->NextFilterInstance);
    InitializeListHead(&FilterInstance->NotifyList);

	#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
        Status = KsRegisterWorker( CriticalWorkQueue, &FilterInstance->WorkerRead );
        if (!NT_SUCCESS( Status )) {            
            ExFreePool(FilterInstance);
            FilterInstance = NULL;
            Status = STATUS_INSUFFICIENT_RESOURCES;            
            ASSERT( 0 );
            goto Exit;
        }

        Status = KsRegisterWorker( CriticalWorkQueue, &FilterInstance->WorkerWrite );
        if (!NT_SUCCESS( Status )) {
            KsUnregisterWorker( FilterInstance->WorkerRead );
            ExFreePool(FilterInstance);
            FilterInstance = NULL;
            Status = STATUS_INSUFFICIENT_RESOURCES;
            ASSERT( 0 );
            goto Exit;
        }
        DebugPrint((DebugLevelVerbose,
                   "RegisterReadWorker %x WriteWorker %x\n",
                   FilterInstance->WorkerRead,
                   FilterInstance->WorkerWrite));
	#endif
	
    //
    // initialize the current and max instances
    //

	
    CurrentAdditionalInfo = FilterInstance->PinInstanceInfo;
    CurrentInfo = &DeviceExtension->StreamDescriptor->StreamInfo;

    for (i = 0; i < NumberOfPins; i++) {

        CurrentAdditionalInfo[i].CurrentInstances = 0;
        CurrentAdditionalInfo[i].MaxInstances =
            CurrentInfo->NumberOfPossibleInstances;

        //
   	    // index to next streaminfo and additional info structures.
       	//

        CurrentInfo++;
   	}

    //
    // fill in the filter dispatch table pointer
    //

    KsAllocateObjectHeader(&FilterInstance->DeviceHeader,
                           SIZEOF_ARRAY(CreateHandlers),
                           (PKSOBJECT_CREATE_ITEM) CreateHandlers,
                           Irp,
                           (PKSDISPATCH_TABLE) & FilterDispatchTable);

    if (FilterExtensionSize) {

        //
        // call the minidriver to open the instance if the call is supported.
        // final status will be processed in the callback procedure.
        //

        //
        // C4312 fix: This union corresponds to the _CommandData union within
        // HW_STREAM_REQUEST_BLOCK.  This is done to correctly align
        // FilterTypeIndex for assignment on 64-bit such that it doesn't
        // break on big endian machines.  I don't want to waste stack
        // space with an entire HW_STREAM_REQUEST_BLOCK for a 64-bit safe
        // cast.
        //
        union {
            PVOID Buffer;
            LONG FilterTypeIndex;
        } u;

        u.Buffer = NULL;
        u.FilterTypeIndex = (LONG)FilterTypeIndex;

        Status = SCSubmitRequest(
        			SRB_OPEN_DEVICE_INSTANCE,
                    u.Buffer,
                    0,
                    SCDequeueAndDeleteSrb, //SCGlobalInstanceCallback,
                    DeviceExtension,
                    FilterInstance->HwInstanceExtension,
                    NULL,
                    Irp,
                    &RequestIssued,
                    &DeviceExtension->PendingQueue,
                    (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket
            	 );

        if (!RequestIssued) {

            //
            // if request not issued, fail the request as we could not send
            // it down.
            //

            ASSERT(Status != STATUS_SUCCESS);

            KsFreeObjectHeader(FilterInstance->DeviceHeader);
			#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
            KsUnregisterWorker( FilterInstance->WorkerRead );
            KsUnregisterWorker( FilterInstance->WorkerWrite );
			#endif
            //ExFreePool(FilterInstance);
        }        
    } // if minidriver supports multiple filter
	
    Exit: {
        if ( NT_SUCCESS( Status ) ) {
            DebugPrint((DebugLevelInfo,
                       "Inserting FilterInstance %x\n",
                       FilterInstance));
                       
   			SCInsertFiltersInDevice( FilterInstance, DeviceExtension );
   		}
   		else if ( NULL != FilterInstance) {
            ExFreePool( FilterInstance );
            FilterInstance = NULL;
        }
        
        *ReturnedFilterInstance = FilterInstance;        
        return (Status);
    }
}

#else // ENABLE_MULTIPLE_FILTER_TYPES
#endif // ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SCSubmitRequest(
                IN SRB_COMMAND Command,
                IN PVOID Buffer,
                IN ULONG DataSize,
                IN PSTREAM_CALLBACK_PROCEDURE Callback,
                IN PDEVICE_EXTENSION DeviceExtension,
                IN PVOID InstanceExtension,
                IN OPTIONAL PHW_STREAM_OBJECT HwStreamObject,
                IN PIRP Irp,
                OUT PBOOLEAN RequestIssued,
                IN PLIST_ENTRY Queue,
                IN PVOID MinidriverRoutine
)
/*++

Routine Description:

    This routine generically submits a non-data SRB to the minidriver.  The
    callback procedure is called back at PASSIVE level.

Arguments:

    Command - command to issue
    Buffer - data buffer, if any
    DataSize - length of transfer
    Callback - procedure to call back at passive level
    DeviceExtension - pointer to device extension
    InstanceExtension - pointer to instance extension, if any
    HwStreamObject - optional pointer to minidriver's stream object
    Irp - pointer to IRP
    RequestIssued - pointer to boolean which is set if request issued
    Queue - queue upon which to enqueue the request
    MinidriverRoutine - request routine to call with the request

Return Value:

     Status
--*/

{
    PSTREAM_OBJECT  StreamObject = 0;
    PSTREAM_REQUEST_BLOCK Request = SCBuildRequestPacket(DeviceExtension,
                                                         Irp,
                                                         0,
                                                         0);
    NTSTATUS        Status;

    PAGED_CODE();

    //
    // assume request will be successfully issued.
    //

    *RequestIssued = TRUE;


    //
    // if the alloc failed, call the callback procedure with a null SRB
    //

    if (!Request) {

        *RequestIssued = FALSE;
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    if (HwStreamObject) {
        StreamObject = CONTAINING_RECORD(
                                         HwStreamObject,
                                         STREAM_OBJECT,
                                         HwStreamObject
            );


        //
        // hack.  we need to set the stream request flag if this is a stream
        // request.  the only case that we would NOT set this when a stream
        // object is passed in is on an OPEN or CLOSE, where the stream
        // object is
        // passed in on a device request.  special case this.  if later
        // this assumption changes, an assert will be hit in lowerapi.
        //

        if ((Command != SRB_OPEN_STREAM) && (Command != SRB_CLOSE_STREAM)) {

            Request->HwSRB.Flags |= SRB_HW_FLAGS_STREAM_REQUEST;
        }
    }
    //
    // initialize event for blocking for completion
    //

    KeInitializeEvent(&Request->Event, SynchronizationEvent, FALSE);

    Request->HwSRB.Command = Command;

    Request->Callback = SCSignalSRBEvent;
    Request->HwSRB.HwInstanceExtension = InstanceExtension;
    Request->HwSRB.StreamObject = HwStreamObject;
    Request->HwSRB.CommandData.StreamBuffer = Buffer;
    Request->HwSRB.HwDeviceExtension = DeviceExtension->HwDeviceExtension;
    Request->HwSRB.NumberOfBytesToTransfer = DataSize;
    Request->DoNotCallBack = FALSE;

    //
    // call routine to actually submit request to the device
    //

    Status = SCIssueRequestToDevice(DeviceExtension,
                                    StreamObject,
                                    Request,
                                    MinidriverRoutine,
                                    Queue,
                                    Irp);

    //
    // block waiting for completion if pending
    //

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Request->Event, Executive, KernelMode, FALSE, NULL);
    }
    return (Callback(Request));

}


VOID
SCSignalSRBEvent(
                 IN PSTREAM_REQUEST_BLOCK Srb
)
/*++

Routine Description:

    Sets the event for a completed SRB

Arguments:

    Srb - pointer to the request

Return Value:

     none
--*/

{

    KeSetEvent(&Srb->Event, IO_NO_INCREMENT, FALSE);
    return;
}


NTSTATUS
SCProcessDataTransfer(
                      IN PDEVICE_EXTENSION DeviceExtension,
                      IN PIRP Irp,
                      IN SRB_COMMAND Command
)
/*++

Routine Description:

    Process a data transfer request to a stream

Arguments:

    DeviceExtension - address of device extension.
    Irp - pointer to the IRP
    Command - read or write command

Return Value:

     NTSTATUS returned as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PSTREAM_REQUEST_BLOCK Request;
    PSTREAM_OBJECT  StreamObject = IrpStack->FileObject->FsContext;
    NTSTATUS        Status;
    PKSSTREAM_HEADER OutputBuffer = NULL;
    ULONG           NumberOfPages = 0,
                    NumberOfBuffers = 0;
    ULONG           Flags =
                        KSPROBE_STREAMWRITE | 
                        KSPROBE_ALLOCATEMDL | 
                        KSPROBE_PROBEANDLOCK | 
                        KSPROBE_ALLOWFORMATCHANGE;
    ULONG           HeaderSize=0; // prefixbug 17392
    ULONG           ExtraSize=0; // prefixbug 17391
    #if DBG
    PMDL            CurrentMdl;
    #endif
    PVOID           pMemPtrArray = NULL;


    PAGED_CODE();

    //
    // if we are flushing, we must error any I/O during this period.
    //

    if (StreamObject->InFlush) {


        DebugPrint((DebugLevelError,
                    "'StreamDispatchIOControl: Aborting IRP during flush!"));
        TRAP;

        return (STATUS_DEVICE_NOT_READY);

    }                           // if flushing
    Irp->IoStatus.Information = 0;

    #if DBG
    DeviceExtension->NumberOfRequests++;
    #endif

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength) {

        //
        // get the size of the header and the expansion from the minidriver.
        //

        HeaderSize = StreamObject->HwStreamObject.StreamHeaderMediaSpecific +
            sizeof(KSSTREAM_HEADER);
        ExtraSize = StreamObject->HwStreamObject.StreamHeaderWorkspace;

        //
        // we assumed this was a write. do additional processing if a read.
        //

        if (Command == SRB_READ_DATA) {

            Flags =
                KSPROBE_STREAMREAD | KSPROBE_ALLOCATEMDL | KSPROBE_PROBEANDLOCK;

            //
            // this is a read, so set the information field in the irp to
            // copy back the headers when the I/O is complete.
            //

            Irp->IoStatus.Information =
                IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

        }
        //
        // lock and probe the buffer
        //
        DebugPrint((DebugLevelVerbose, "Stream: HeaderSize:%x\n",HeaderSize));
        DebugPrint((DebugLevelVerbose, "Stream: sizeof(KSSSTREAM_HEADER):%x\n",sizeof(KSSTREAM_HEADER)));
        DebugPrint((DebugLevelVerbose, "Stream: MediaSpecific:%x\n",StreamObject->HwStreamObject.StreamHeaderMediaSpecific));
        DebugPrint((DebugLevelVerbose, "Stream: StreamHeader->Size:%x\n",((PKSSTREAM_HEADER)(Irp->UserBuffer))->Size));


        if (!NT_SUCCESS(Status =
                        KsProbeStreamIrp(Irp,
                                         Flags,
                                         HeaderSize))) {

            DebugPrint((DebugLevelError, "Stream: ProbeStreamIrp failed!"));

            return (Status);

        }
        if (!ExtraSize) {

            OutputBuffer = (PKSSTREAM_HEADER)
                Irp->AssociatedIrp.SystemBuffer;

            IrpStack->Parameters.Others.Argument4 = NULL;
        } else {

            TRAP;
            if (!NT_SUCCESS(Status = KsAllocateExtraData(Irp,
                                                         ExtraSize,
                                                         &OutputBuffer))) {


                DebugPrint((DebugLevelError, "Stream: AllocExtraData failed!"));

                return (Status);
            }                   // if not success
            IrpStack->Parameters.Others.Argument4 = OutputBuffer;


        }


        #if DBG

        //
        // assert the MDL list.
        //

        CurrentMdl = Irp->MdlAddress;

        while (CurrentMdl) {

            CurrentMdl = CurrentMdl->Next;
        }                       // while
        #endif

        //
        // calculate the # of buffers.
        //

        NumberOfBuffers = IrpStack->Parameters.
            DeviceIoControl.OutputBufferLength / HeaderSize;


        //
        // do addtional processing on the data buffers.
        //
        if (StreamObject->HwStreamObject.Dma) {     // an optimization
            SCProcessDmaDataBuffers(OutputBuffer,
                             NumberOfBuffers,
                             StreamObject,
                             Irp->MdlAddress,
                             &NumberOfPages,
                             HeaderSize + ExtraSize,
                             (BOOLEAN) (Command == SRB_WRITE_DATA));
        }
        //
        // if number of pages is > than the max supported, return error.
        // Allow
        // for one extra map register for the SRB extension.
        //
        // GUBGUB - This is really a workitem to make it correct. 
        // need to break up requests that have too many elements.
        //

        if (NumberOfPages > (DeviceExtension->NumberOfMapRegisters - 1)) {

            return (STATUS_INSUFFICIENT_RESOURCES);
        }
    }                           // if BufferSize
    //
    // build an SRB and alloc workspace for the request.   Allocate
    // scatter/gather space also if needed.
    //

    Request = SCBuildRequestPacket(DeviceExtension,
                                   Irp,
                                   NumberOfPages * sizeof(KSSCATTER_GATHER),
                                   NumberOfBuffers * sizeof(PVOID));

    if (Request == NULL) {

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

        //
        // do more addtional processing on the data buffers.
        //
        if (StreamObject->HwStreamObject.Pio) {     // a small optimization
            Request->bMemPtrValid = SCProcessPioDataBuffers(OutputBuffer,
                                    NumberOfBuffers,
                                    StreamObject,
                                    Irp->MdlAddress,
                                    HeaderSize + ExtraSize,
                                    Request->pMemPtrArray,
                                    (BOOLEAN) (Command == SRB_WRITE_DATA));
            }
    //
    // set # of physical pages
    //

    Request->HwSRB.NumberOfPhysicalPages = NumberOfPages;

    //
    // set # of data buffers
    //

    Request->HwSRB.NumberOfBuffers = NumberOfBuffers;

    //
    // set the command code in the packet.
    //

    Request->HwSRB.Command = Command;

    //
    // set the input and output buffers
    //

    Request->HwSRB.CommandData.DataBufferArray = OutputBuffer;
    Request->HwSRB.HwDeviceExtension = DeviceExtension->HwDeviceExtension;
    Request->Callback = SCProcessCompletedDataRequest;
    Request->HwSRB.StreamObject = &StreamObject->HwStreamObject;
    Request->StreamHeaderSize = HeaderSize + ExtraSize;
    Request->DoNotCallBack = FALSE;
    Request->HwSRB.Flags |= (SRB_HW_FLAGS_DATA_TRANSFER
                             | SRB_HW_FLAGS_STREAM_REQUEST);

    ASSERT_FILTER_INSTANCE( StreamObject->FilterInstance );
    Request->HwSRB.HwInstanceExtension = 
        StreamObject->FilterInstance->HwInstanceExtension;

    //
    // point the IRP workspace to the request
    // packet
    //

    Irp->Tail.Overlay.DriverContext[0] = Request;

    IoMarkIrpPending(Irp);

//    ASSERT((IoGetCurrentIrpStackLocation(Irp)->MajorFunction ==
//                       IOCTL_KS_READ_STREAM) ||
//            (IoGetCurrentIrpStackLocation(Irp)->MajorFunction ==
//                        IOCTL_KS_WRITE_STREAM));
    ASSERT((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] > 0x40000000);

    return (SCIssueRequestToDevice(DeviceExtension,
                                   StreamObject,
                                   Request,
                             StreamObject->HwStreamObject.ReceiveDataPacket,
                                   &StreamObject->DataPendingQueue,
                                   Irp));

}

VOID
SCErrorDataSRB(
               IN PHW_STREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    Dummy routine invoked when a data request is received for non-data
    receiving stream.

Arguments:

    SRB- address of STREAM request block

Return Value:

    None.

--*/

{

    //
    // just call the SRB back with error
    //

    SRB->Status = STATUS_NOT_SUPPORTED;
    StreamClassStreamNotification(StreamRequestComplete,
                                  SRB->StreamObject);
    StreamClassStreamNotification(ReadyForNextStreamDataRequest,
                                  SRB->StreamObject);
}                               // SCErrorDataSRB


NTSTATUS
SCIssueRequestToDevice(
                       IN PDEVICE_EXTENSION DeviceExtension,
                       IN OPTIONAL PSTREAM_OBJECT StreamObject,
                       PSTREAM_REQUEST_BLOCK Request,
                       IN PVOID MinidriverRoutine,
                       IN PLIST_ENTRY Queue,
                       IN PIRP Irp
)
/*++

Routine Description:

    This routine calls the minidriver's request vector with a request.
    Both data and non-data requests are handled by this routine.  The routine
    either synchronizes the call or not, based on the NoSync boolean.

Arguments:

    DeviceExtension - pointer to device extension
    StreamObject - optional pointer to stream object
    MinidriverRoutine - request routine to call with the request
    Queue - queue upon which to enqueue the request
    Irp - pointer to IRP

Return Value:

     Status
--*/

{
    KIRQL           irql;
        
    KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

    if (DeviceExtension->NoSync) {

        //
        // place the request on the
        // outstanding queue and call it down
        // immediately
        //

        ASSERT((DeviceExtension->BeginMinidriverCallin == SCBeginSynchronizedMinidriverCallin) ||
               (DeviceExtension->BeginMinidriverCallin == SCBeginUnsynchronizedMinidriverCallin));

        Request->Flags |= SRB_FLAGS_IS_ACTIVE;
        
        InsertHeadList(
                       &DeviceExtension->OutstandingQueue,
                       &Request->SRBListEntry);

        IoSetCancelRoutine(Irp, StreamClassCancelOutstandingIrp);

        KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

        if ((StreamObject) && (StreamObject->HwStreamObject.Dma) &&
            (Request->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER)) {

            //
            // allocate the adapter channel. call cannot fail as the only
            // time it would is when there aren't enough map registers, and
            // we've already checked for that condition.  Block waiting til
            // it's allocated.
            //
            KIRQL oldIrql;

            KeInitializeEvent(&Request->DmaEvent, SynchronizationEvent, FALSE);

            ASSERT( PASSIVE_LEVEL == KeGetCurrentIrql());

            KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
            SCSetUpForDMA(DeviceExtension->DeviceObject,
                          Request);
            KeLowerIrql( oldIrql );

            KeWaitForSingleObject(&Request->DmaEvent, Executive, KernelMode, FALSE, NULL);


        }
        // this could open a race window. It should be protected in spinlock.
        //Request->Flags |= SRB_FLAGS_IS_ACTIVE;

        ((PHW_RECEIVE_STREAM_CONTROL_SRB) (MinidriverRoutine))
            (&Request->HwSRB);

    } else {

        //
        // insert the item on the queue
        //

        InsertHeadList(
                       Queue,
                       &Irp->Tail.Overlay.ListEntry);

        //
        // set the cancel routine to pending
        //

        IoSetCancelRoutine(Irp, StreamClassCancelPendingIrp);

        //
        // check to see if the IRP is already cancelled.
        //

        if (Irp->Cancel) {

            //
            // the IRP is cancelled.   Make sure that the cancel routine
            // will be called.
            //

            if (IoSetCancelRoutine(Irp, NULL)) {

                //
                // wow, the cancel routine will not be invoked.
                // dequeue the request ourselves and complete
                // with cancelled status.

                RemoveEntryList(&Request->SRBListEntry);
                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

                //
                // free the SRB and MDL
                //

                IoFreeMdl(Request->Mdl);

                ExFreePool(Request);
                return (STATUS_CANCELLED);

            } else {            // if we must cancel

                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
            }                   // if we must cancel

            return (STATUS_PENDING);
        }                       // if cancelled
        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        //
        // call the DPC routine directly. GUBGUB questionable performance improvement chance
        // BGP - is this really
        // faster than scheduling it?
        //

        StreamClassDpc(NULL, DeviceExtension->DeviceObject, Irp, StreamObject);

        KeLowerIrql(irql);
    }
    return (STATUS_PENDING);
}


BOOLEAN
SCCheckFilterInstanceStreamsForIrp(
                                   IN PFILTER_INSTANCE FilterInstance,
                                   IN PIRP Irp
)
/*++
Routine Description:

    This routine checks all filter instance streams for the specified IRP.

Arguments:

    FilterInstance - pointer to the filter instance
    Irp - pointer to the IRP.

Return Value:

    TRUE if the IRP is found.

--*/

{

    PSTREAM_OBJECT  StreamObject;
    PLIST_ENTRY     StreamListEntry,
                    StreamObjectEntry;

    StreamListEntry = StreamObjectEntry = &FilterInstance->FirstStream;

    while (StreamObjectEntry->Flink != StreamListEntry) {

        StreamObjectEntry = StreamObjectEntry->Flink;

        //
        // follow the link to the stream
        // object
        //

        StreamObject = CONTAINING_RECORD(StreamObjectEntry,
                                         STREAM_OBJECT,
                                         NextStream);

        if (SCCheckRequestsForIrp(
                                  &StreamObject->DataPendingQueue, Irp, TRUE, StreamObject->DeviceExtension)) {

            return (TRUE);
        }
        if (SCCheckRequestsForIrp(
                                  &StreamObject->ControlPendingQueue, Irp, TRUE, StreamObject->DeviceExtension)) {

            return (TRUE);
        }
    }

    return (FALSE);

}                               // SCCheckFilterInstanceStreamsForIrp




BOOLEAN
SCCheckRequestsForIrp(
                      IN PLIST_ENTRY ListEntry,
                      IN PIRP Irp,
                      IN BOOLEAN IsIrpQueue,
                      IN PDEVICE_EXTENSION DeviceExtension
)
/*++
Routine Description:

    This routine checks all requests on a queue for the specified IRP.
    If the IRP parameter is NULL, the first IRP on the queue is cancelled.

Arguments:

    ListEntry - list to check for the IRP
    Irp - pointer to the IRP or NULL to cancel the first IRP.
    IsIrpQueue - TRUE indicates an IRP queue, FALSE indicates an SRB queue
    DeviceExtension - pointer to the device extension

Return Value:

    TRUE if the IRP is found or if we cancel it.

--*/

{

    PLIST_ENTRY     IrpEntry = ListEntry;
    PIRP            CurrentIrp;

    while (IrpEntry->Flink != ListEntry) {

        IrpEntry = IrpEntry->Flink;

        ASSERT(IrpEntry);
        ASSERT(IrpEntry->Flink);
        ASSERT(IrpEntry->Blink);

        //
        // follow the link to the IRP
        //

        if (IsIrpQueue) {

            CurrentIrp = CONTAINING_RECORD(IrpEntry,
                                           IRP,
                                           Tail.Overlay.ListEntry);
        } else {

            CurrentIrp = ((PSTREAM_REQUEST_BLOCK) (CONTAINING_RECORD(IrpEntry,
                                                       STREAM_REQUEST_BLOCK,
                                                 SRBListEntry)))->HwSRB.Irp;
        }

        //
        // this routine is used to cancel irp's if IRP is null.
        //

        if ((!Irp) && (!CurrentIrp->Cancel)) {

            //
            // The IRP has not been previously cancelled, so cancel it after
            // releasing the spinlock to avoid deadlock with the cancel
            // routine.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            //
            // This code is suspicious that the CurrentIrp is not protected, i.e.
            // it could be processed and freed from other thread. However, we
            // are not never called with (!Irp). Therefore, we should never
            // come in executing this piece of code. here is the analysis.
            // 1. We are called from
            //      a. SCCheckFilterInstanceStreamIrp()
            //      b. SCCancelOutstandingIrp()
            //      c. StreamClassCancelPendingIrp()
            // 2. Further inspection shows that a. SCCheckFilterInstanceStreamForIrp() is
            //    only called by StreamClassCancelPendingIrp() which always has non-null Irp.
            // 3. SCCancelOutstandingIrp() is called by
            //      a. StreamClassCancelPendingIrp() which always has non-NULL irp.
            //      b. StreamClassCancelOutstandingIrp() which always has non-NULL irp.
            // The concusion is that we are never called with null irp. Therefore, this
            // piece code is never executed. But this driver has been thru win2k extenteded
            // test cycle. I rather be conservative. Add an Assertion instead of removing
            // the code for now.
            //
            ASSERT( 0 );
            IoCancelIrp(CurrentIrp);

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
            return (TRUE);
        }
        if (Irp == CurrentIrp) {

            return (TRUE);
        }
    }                           // while list entry

    return (FALSE);

}                               // SCCheckRequestsForIrp

VOID
SCNotifyMinidriverCancel(
                         IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    Synchronized routine to notify minidriver that an IRP has been canceled

Arguments:

    SRB - pointer to SRB that has been canceled.

Return Value:

    none

--*/


{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

    //
    // if the active flag is still set in the SRB, the minidriver still
    // has it so call him to abort it.
    //

    if (SRB->Flags & SRB_FLAGS_IS_ACTIVE) {

        //
        // call the minidriver with the SRB.
        //

        (DeviceExtension->MinidriverData->HwInitData.HwCancelPacket)
            (&SRB->HwSRB);
    }
    return;
}

VOID
SCCancelOutstandingIrp(
                       IN PDEVICE_EXTENSION DeviceExtension,
                       IN PIRP Irp
)
/*++
Routine Description:

    Routine to notify minidriver that an IRP has been canceled.   Device
    spinlock NUST be taken before this routine is called.

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to the IRP.

Return Value:

    none

--*/

{
    PSTREAM_REQUEST_BLOCK Srb;

    //
    // just return if the request is not on
    // our queue.
    //

    if ((!IsListEmpty(&DeviceExtension->OutstandingQueue)) &&
        (SCCheckRequestsForIrp(
        &DeviceExtension->OutstandingQueue, Irp, FALSE, DeviceExtension))) {

        //
        // the request is sitting on our
        // outstanding queue.  call the
        // minidriver
        // via a synchronize routine to
        // cancel it.
        //

        Srb = Irp->Tail.Overlay.DriverContext[0];

#if DBG
        if (Srb->HwSRB.StreamObject) {

            DebugPrint((DebugLevelWarning, "'SCCancelOutstanding: canceling, Irp = %x, Srb = %x, S# = %x\n",
                        Irp, Srb, Srb->HwSRB.StreamObject->StreamNumber));

        } else {

            DebugPrint((DebugLevelWarning, "'SCCancelOutstanding: canceling nonstream, Irp = %x\n",
                        Irp));
        }                       // if SO

#endif

        if (DeviceExtension->NoSync) {

            //
            // we need to ensure that the SRB memory is valid for the async
            // minidriver, EVEN if it happens to call back the request just
            // before we call it to cancel it!   This is done for two
            // reasons:
            // it obviates the need for the minidriver to walk its request
            // queues to find the request, and I failed to pass the dev ext
            // pointer to the minidriver in the below call, which means that
            // the SRB HAS to be valid, and it's too late to change the API.
            //
            // Oh, well.   Spinlock is now taken (by caller).
            //

            if (!(Srb->Flags & SRB_FLAGS_IS_ACTIVE)) {
                return;
            }
            Srb->DoNotCallBack = TRUE;

            //
            // release the spinlock temporarily since we need to call the
            // minidriver.   The caller won't be affected by this.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            (DeviceExtension->MinidriverData->HwInitData.HwCancelPacket)
                (&Srb->HwSRB);

            //
            // reacquire the spinlock since the caller will release it
            //

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

            Srb->DoNotCallBack = FALSE;

            //
            // if the ACTIVE flag is now clear, it indicates that the
            // SRB was completed during the above call into the minidriver.
            // since we blocked the internal completion of the request,
            // we must call it back ourselves in this case.
            //

            if (!(Srb->Flags & SRB_FLAGS_IS_ACTIVE)) {

                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                (Srb->Callback) (Srb);

                KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
            }                   // if ! active
        } else {

            DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                                           (PVOID) SCNotifyMinidriverCancel,
                                                  Srb);
        }                       // if nosync

    }                           // if on our queue
    return;
}

NTSTATUS
SCMinidriverDevicePropertyHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSPROPERTY Property,
                                  IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process get/set property to the device.

Arguments:

    Command - either GET or SET property
    Irp - pointer to the IRP
    Property - pointer to the property structure
    PropertyInfo - buffer for property information

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PFILTER_INSTANCE FilterInstance;
    PSTREAM_PROPERTY_DESCRIPTOR PropDescriptor;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    FilterInstance = IrpStack->FileObject->FsContext;

    PropDescriptor = ExAllocatePool(NonPagedPool,
                                    sizeof(STREAM_PROPERTY_DESCRIPTOR));
    if (PropDescriptor == NULL) {
        DebugPrint((DebugLevelError,
                    "SCDevicePropHandler: No pool for descriptor"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // compute the index of the property set.
    //
    // this value is calculated by subtracting the base property set
    // pointer from the requested property set pointer.
    //
    // The requested property set is pointed to by Context[0] by
    // KsPropertyHandler.
    //

    PropDescriptor->PropertySetID = (ULONG)
        ((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] -
        IFN_MF( (ULONG_PTR) DeviceExtension->DevicePropertiesArray)
        IF_MF( (ULONG_PTR) FilterInstance->DevicePropertiesArray)
        )/ sizeof(KSPROPERTY_SET);

    PropDescriptor->Property = Property;
    PropDescriptor->PropertyInfo = PropertyInfo;
    PropDescriptor->PropertyInputSize =
        IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    PropDescriptor->PropertyOutputSize =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // send a get or set property SRB to the device.
    //

    Status = SCSubmitRequest(Command,
                             PropDescriptor,
                             0,
                             SCProcessCompletedPropertyRequest,
                             DeviceExtension,
                             FilterInstance->HwInstanceExtension,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket
        );
    if (!RequestIssued) {

        ExFreePool(PropDescriptor);
    }
    return (Status);
}

NTSTATUS
SCMinidriverStreamPropertyHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSPROPERTY Property,
                                  IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process get or set property to the device.

Arguments:

    Command - either GET or SET property
    Irp - pointer to the IRP
    Property - pointer to the property structure
    PropertyInfo - buffer for property information

Return Value:

     None.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    PSTREAM_PROPERTY_DESCRIPTOR PropDescriptor;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    StreamObject = IrpStack->FileObject->FsContext;

    PropDescriptor = ExAllocatePool(NonPagedPool,
                                    sizeof(STREAM_PROPERTY_DESCRIPTOR));
    if (PropDescriptor == NULL) {
        DebugPrint((DebugLevelError,
                    "SCDevicePropHandler: No pool for descriptor"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // compute the index of the property set.
    //
    // this value is calculated by subtracting the base property set
    // pointer from the requested property set pointer.
    //
    // The requested property set is pointed to by Context[0] by
    // KsPropertyHandler.
    //

    PropDescriptor->PropertySetID = (ULONG)
        ((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] -
         (ULONG_PTR) StreamObject->PropertyInfo)
        / sizeof(KSPROPERTY_SET);

    PropDescriptor->Property = Property;
    PropDescriptor->PropertyInfo = PropertyInfo;
    PropDescriptor->PropertyInputSize =
        IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    PropDescriptor->PropertyOutputSize =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    //
    // send a get or set property SRB to the stream.
    //

    Status = SCSubmitRequest(Command,
                             PropDescriptor,
                             0,
                             SCProcessCompletedPropertyRequest,
                             DeviceExtension,
                          StreamObject->FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             (PVOID) StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );

    if (!RequestIssued) {

        ExFreePool(PropDescriptor);
    }
    return (Status);
}

NTSTATUS
SCProcessCompletedPropertyRequest(
                                  IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    This routine processes a property request which has completed.

Arguments:

    SRB- address of completed STREAM request block

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // free the prop info structure and
    // complete the request
    //

    ExFreePool(SRB->HwSRB.CommandData.PropertyInfo);

    //
    // set the information field from the SRB
    // transferlength field
    //

    SRB->HwSRB.Irp->IoStatus.Information = SRB->HwSRB.ActualBytesTransferred;

    return (SCDequeueAndDeleteSrb(SRB));

}

VOID
SCUpdateMinidriverProperties(
                             IN ULONG NumProps,
                             IN PKSPROPERTY_SET MinidriverProps,
                             IN BOOLEAN Stream
)
/*++

Routine Description:

     Process get property to the device.

Arguments:

    NumProps - number of properties to process
    MinidriverProps - pointer to the array of properties to process
    Stream - TRUE indicates we are processing a set for the stream

Return Value:

     None.

--*/

{
    PKSPROPERTY_ITEM CurrentPropId;
    PKSPROPERTY_SET CurrentProp;
    ULONG           i,
                    j;

    PAGED_CODE();

    //
    // walk the minidriver's property info to fill in the dispatch
    // vectors as appropriate.
    //

    CurrentProp = MinidriverProps;

    for (i = 0; i < NumProps; i++) {

        CurrentPropId = (PKSPROPERTY_ITEM) CurrentProp->PropertyItem;

        for (j = 0; j < CurrentProp->PropertiesCount; j++) {

            //
            // if support handler is supported, send it to the "get" handler
            //

            if (CurrentPropId->SupportHandler) {

                if (Stream) {

                    CurrentPropId->SupportHandler = StreamClassMinidriverStreamGetProperty;

                } else {

                    CurrentPropId->SupportHandler = StreamClassMinidriverDeviceGetProperty;
                }               // if stream

            }
            //
            // if get prop routine is
            // supported, add our vector.
            //

            if (CurrentPropId->GetPropertyHandler) {

                if (Stream) {

                    CurrentPropId->GetPropertyHandler = StreamClassMinidriverStreamGetProperty;
                } else {

                    CurrentPropId->GetPropertyHandler = StreamClassMinidriverDeviceGetProperty;
                }               // if stream

            }                   // if get supported
            //
            // if get prop routine is
            // supported, add our vector.
            //

            if (CurrentPropId->SetPropertyHandler) {

                if (Stream) {

                    CurrentPropId->SetPropertyHandler = StreamClassMinidriverStreamSetProperty;

                } else {

                    CurrentPropId->SetPropertyHandler = StreamClassMinidriverDeviceSetProperty;
                }               // if stream

            }
            //
            // index to next property item in
            // array
            //

            CurrentPropId++;

        }                       // for number of property items

        //
        // index to next property set in
        // array
        //

        CurrentProp++;

    }                           // for number of property sets

}

VOID
SCUpdateMinidriverEvents(
                         IN ULONG NumEvents,
                         IN PKSEVENT_SET MinidriverEvents,
                         IN BOOLEAN Stream
)
/*++

Routine Description:

     Process get property to the device.

Arguments:

    NumEvents - number of event sets to process
    MinidriverEvents - pointer to the array of properties to process
    Stream - TRUE indicates we are processing a set for the stream

Return Value:

     None.

--*/

{
    PKSEVENT_ITEM   CurrentEventId;
    PKSEVENT_SET    CurrentEvent;
    ULONG           i,
                    j;

    PAGED_CODE();

    //
    // walk the minidriver's event info to fill in the dispatch
    // vectors as appropriate.
    //

    CurrentEvent = MinidriverEvents;

    for (i = 0; i < NumEvents; i++) {

        CurrentEventId = (PKSEVENT_ITEM) CurrentEvent->EventItem;

        for (j = 0; j < CurrentEvent->EventsCount; j++) {

            if (Stream) {

                //
                // set up the add and remove handlers for the stream.
                // GUBGUB - Still not see justifications. 
                // don't support IsSupported currently, until
                // a good justification of it is made.
                //

                CurrentEventId->AddHandler = StreamClassEnableEventHandler;
                CurrentEventId->RemoveHandler = StreamClassDisableEventHandler;

            } else {

                //
                // set up the add and remove handlers for the device.
                // GUBGUB - still not see justifications
                // - don't support IsSupported currently, until
                // a good justification of it is made.
                //

                CurrentEventId->AddHandler = StreamClassEnableDeviceEventHandler;
                CurrentEventId->RemoveHandler = StreamClassDisableDeviceEventHandler;

            }                   // if stream


            //
            // index to next property item in
            // array
            //

            CurrentEventId++;

        }                       // for number of event items

        //
        // index to next event set in array
        //

        CurrentEvent++;

    }                           // for number of event sets

}


VOID
SCReadRegistryValues(IN PDEVICE_EXTENSION DeviceExtension,
                     IN PDEVICE_OBJECT PhysicalDeviceObject
)
/*++

Routine Description:

    Reads all registry values for the device

Arguments:

    DeviceExtension - pointer to the device extension
    PhysicalDeviceObject - pointer to the PDO

Return Value:

     None.

--*/

{
    ULONG           i;
    NTSTATUS        Status;
    HANDLE          handle;
    ULONG           DataBuffer;

    PAGED_CODE();

    Status = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    //
    // loop through our table of strings,
    // reading the registry for each.
    //

    if (NT_SUCCESS(Status)) {

        for (i = 0; i < SIZEOF_ARRAY(RegistrySettings); i++) {

            //
            // read the registry value and set
            // the flag if the setting is true.
            //

            //
            // Need to init each time besides 
            // we only obtain one byte in the DataBuffer
            //
            
            DataBuffer = 0;
            
            Status = SCGetRegistryValue(handle,
                                        RegistrySettings[i].String,
                                        RegistrySettings[i].StringLength,
                                        &DataBuffer,
                                        1);

            DebugPrint((DebugLevelInfo,
                       "Reg Key %S value %x\n",
                       RegistrySettings[i].String,
                       (BYTE)DataBuffer));             
                       
            if ((NT_SUCCESS(Status)) && DataBuffer) {


                //
                // setting is true, so or in the
                // appropriate flag
                //

                DeviceExtension->RegistryFlags |= RegistrySettings[i].Flags;                
            }                   // if true            
        }                       // while strings
        DebugPrint((DebugLevelInfo,"====DeviceObject %x DeviceExtenion %x has RegFlags %x\n",
                   DeviceExtension->DeviceObject,
                   DeviceExtension,
                   DeviceExtension->RegistryFlags ));
                   

        //
        // close the registry handle.
        //

        ZwClose(handle);

    }                           // status = success
}


NTSTATUS
SCGetRegistryValue(
                   IN HANDLE Handle,
                   IN PWCHAR KeyNameString,
                   IN ULONG KeyNameStringLength,
                   IN PVOID Data,
                   IN ULONG DataLength
)
/*++

Routine Description:

    Reads the specified registry value

Arguments:

    Handle - handle to the registry key
    KeyNameString - value to read
    KeyNameStringLength - length of string
    Data - buffer to read data into
    DataLength - length of data buffer

Return Value:

    NTSTATUS returned as appropriate

--*/
{
    NTSTATUS        Status = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING  KeyName;
    ULONG           Length;
    PKEY_VALUE_FULL_INFORMATION FullInfo;

    PAGED_CODE();

    RtlInitUnicodeString(&KeyName, KeyNameString);

    Length = sizeof(KEY_VALUE_FULL_INFORMATION) +
        KeyNameStringLength + DataLength;

    FullInfo = ExAllocatePool(PagedPool, Length);

    if (FullInfo) {
        Status = ZwQueryValueKey(Handle,
                                 &KeyName,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 Length,
                                 &Length);

        if (NT_SUCCESS(Status)) {

            if (DataLength >= FullInfo->DataLength) {
                RtlCopyMemory(Data, ((PUCHAR) FullInfo) + FullInfo->DataOffset, FullInfo->DataLength);

            } else {

                Status = STATUS_BUFFER_TOO_SMALL;
            }                   // buffer right length

        }                       // if success
        ExFreePool(FullInfo);

    }                           // if fullinfo
    return Status;

}

NTSTATUS
SCReferenceSwEnumDriver(
                  IN PDEVICE_EXTENSION DeviceExtension,
                  IN BOOLEAN Reference  // AddRef or DeRef

)
/*++

Routine Description:

    This routine shows one more reference to the minidriver, and pages
    in the minidriver if the count was zero

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    none.

--*/

{
    NTSTATUS            Status;
    KEVENT              Event;
    IO_STATUS_BLOCK     IoStatusBlock;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpStackNext;
    PBUS_INTERFACE_REFERENCE    BusInterface;

    PMINIDRIVER_INFORMATION MinidriverInfo = DeviceExtension->DriverInfo;

    PAGED_CODE();

    BusInterface = ExAllocatePool(NonPagedPool,
                                  sizeof(BUS_INTERFACE_REFERENCE));
    if (BusInterface == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // There is no file object associated with this Irp, so the event may be located
    // on the stack as a non-object manager object.
    //
    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    Irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       DeviceExtension->AttachedPdo,
                                       NULL,
                                       0,
                                       NULL,
                                       &Event,
                                       &IoStatusBlock);
    if (Irp != NULL)
    {
        Irp->RequestorMode = KernelMode;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IrpStackNext = IoGetNextIrpStackLocation(Irp);
        //
        // Create an interface query out of the Irp.
        //
        IrpStackNext->MinorFunction = IRP_MN_QUERY_INTERFACE;
        IrpStackNext->Parameters.QueryInterface.InterfaceType = (GUID*)&REFERENCE_BUS_INTERFACE;
        IrpStackNext->Parameters.QueryInterface.Size = sizeof(BUS_INTERFACE_REFERENCE);
        IrpStackNext->Parameters.QueryInterface.Version = BUS_INTERFACE_REFERENCE_VERSION;
        IrpStackNext->Parameters.QueryInterface.Interface = (PINTERFACE)BusInterface;
        IrpStackNext->Parameters.QueryInterface.InterfaceSpecificData = NULL;
        Status = IoCallDriver(DeviceExtension->AttachedPdo, Irp);
        if (Status == STATUS_PENDING)
        {
            //
            // This waits using KernelMode, so that the stack, and therefore the
            // event on that stack, is not paged out.
            //
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            Status = IoStatusBlock.Status;
        }
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) 
    {
        if (Reference)
            BusInterface->ReferenceDeviceObject(BusInterface->Interface.Context);
        else    
            BusInterface->DereferenceDeviceObject(BusInterface->Interface.Context);
    }

    ExFreePool(BusInterface);

    return Status;

}

VOID
SCDereferenceDriver(
                    IN PDEVICE_EXTENSION DeviceExtension

)
/*++

Routine Description:

    This routine shows one fewer reference to the minidriver, and pages
    out the minidriver if the count goes to zero

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    none.

--*/

{

    PMINIDRIVER_INFORMATION MinidriverInfo;
    PDEVICE_EXTENSION CurrentDeviceExtension;
    BOOLEAN         RequestIssued,
                    DontPage = FALSE;
    KEVENT          Event;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP            Irp;
    PDEVICE_OBJECT  DeviceObject;
    NTSTATUS        Status;

    PAGED_CODE();

    //
    // if the driver said it was a SWENUM driver, dereference it.
    //

    if (DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD)
    {
        SCReferenceSwEnumDriver(DeviceExtension,FALSE);
    }

    MinidriverInfo = IoGetDriverObjectExtension(DeviceExtension->DeviceObject->DriverObject,
                                                (PVOID) StreamClassPnP);

    DebugPrint(( DebugLevelVerbose, 
                 "DerefernceDriver %x Count %x DriverFlags=%x\n",
                 DeviceExtension->DeviceObject->DriverObject,
                 MinidriverInfo->UseCount, MinidriverInfo->Flags));
                 
    if (!(MinidriverInfo->Flags & DRIVER_FLAGS_NO_PAGEOUT)) {

        KeWaitForSingleObject(&MinidriverInfo->ControlEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);

        //
        // dec the refcount and see if we can page out.
        //
        DebugPrint(( DebugLevelVerbose, 
                    "DerefernceDriver CountDown\n"));

        ASSERT((LONG) MinidriverInfo->UseCount > 0);

        if (!(--MinidriverInfo->UseCount)) {

            //
            // page out the minidriver after alerting it that we are going to.
            // PNP is supposed to be serialized, so there should be
            // no need to protect this list.  I'm worried about this, tho.
            // need to research. 
            // My unstderstanding is that PnP is serialized.
            //
            // This is by-design, not a bug. 
            // This code assumes that the minidriver will bind only
            // with the stream class.   this needs to be doc'ed in the spec
            // that only single binders will be able to use autopage.
            //

            //
            // find the first device object chained to the driver object.
            //

            DeviceObject = DeviceExtension->DeviceObject->DriverObject->DeviceObject;

                    
            while (DeviceObject) {

                CurrentDeviceExtension = DeviceObject->DeviceExtension;

                DebugPrint((DebugLevelVerbose, 
                        "DerefernceDriver Checking Device=%x\n",
                        DeviceObject));
                        

                //
                // if the device is not started, don't call the minidriver
                // also don't process a child device
                //

                if ((CurrentDeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) &&
                  (!(CurrentDeviceExtension->Flags & DEVICE_FLAGS_CHILD))) {

                    KeInitializeEvent(&Event, NotificationEvent, FALSE);

                    //
                    // allocate IRP for issuing the pageout.  Since this IRP
                    // should not really be referenced, use dummy IOCTL code.
                    // I chose this one since it will always fail in the KS
                    // property handler if someone is silly enough to try to
                    // process it. Also make the irp internal i/o control.
                    //
                    // IoVerifier.c test code does not check IrpStack bound like
                    // the formal production code. And the owner does not want to
                    // fix it. It's more productive just work around here.

                    //Irp = IoBuildDeviceIoControlRequest(
                    //                                    IOCTL_KS_PROPERTY,
                    //                                    DeviceObject,
                    //                                    NULL,
                    //                                    0,
                    //                                    NULL,
                    //                                    0,
                    //                                    TRUE,
                    //                                    &Event,
                    //                                    &IoStatusBlock);
                    
                    Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

                    if (!Irp) {

                        //
                        // could not allocate IRP.  don't page out.
                        //

                        DontPage = TRUE;

                        break;
                    }

                    else {
                        PIO_STACK_LOCATION NextStack;
                        //
                        // This is a dummy Irp, the MJ/MN are arbitrary
                        //
                        NextStack = IoGetNextIrpStackLocation(Irp);
                        ASSERT(NextStack != NULL);
                        NextStack->MajorFunction = IRP_MJ_PNP;
                        NextStack->MinorFunction = IRP_MN_CANCEL_STOP_DEVICE;
                        Irp->UserIosb = &IoStatusBlock;
                        Irp->UserEvent = &Event;                        
                    }                                                        

                    //
                    // show one more I/O pending on the device.
                    //
                    DebugPrint((DebugLevelVerbose, 
                            "Sending SRB_PAGING_OUT_DRIVER to Device=%x\n",
                            DeviceObject));

                    InterlockedIncrement(&CurrentDeviceExtension->OneBasedIoCount);

                    Status = SCSubmitRequest(SRB_PAGING_OUT_DRIVER,
                                             (PVOID) NULL,
                                             0,
                                             SCProcessCompletedRequest,
                                             CurrentDeviceExtension,
                                             NULL,
                                             NULL,
                                             Irp,
                                             &RequestIssued,
                                      &CurrentDeviceExtension->PendingQueue,
                                             (PVOID) CurrentDeviceExtension->
                                             MinidriverData->HwInitData.
                                             HwReceivePacket
                        );

                    if (!RequestIssued) {

                        //
                        // could not issue SRB.  complete IRP and don't page
                        // out.
                        //

                        DontPage = TRUE;
                        SCCompleteIrp(Irp, Status, CurrentDeviceExtension);
                        break;

                    }           // if ! requestissued
                    //
                    // check status.  note that we do not check for pending,
                    // since the above call is sync and won't return til the
                    // request is complete.
                    //

                    if (!NT_SUCCESS(Status)) {

                        //
                        // if the minidriver did not OK the pageout, don't
                        // page
                        // out.
                        //

                        DontPage = TRUE;
                        break;

                    }           // if !success
                }               // if started
                DeviceObject = DeviceObject->NextDevice;
            }                   // while deviceobject

            //
            // if we were able to alert each device controlled by the driver
            // that a pageout is emminent, page the driver out.
            //

            if (!DontPage) {

                DebugPrint((DebugLevelVerbose, 
                            "mmPageEntireDriver %x\n",
                            DeviceExtension->DeviceObject->DriverObject));
                            
                MinidriverInfo->Flags |= DRIVER_FLAGS_PAGED_OUT;
                MmPageEntireDriver(MinidriverInfo->HwInitData.HwReceivePacket);

            }                   // if ! dontpage
        }                       // if !usecount
        //
        // release the control event.
        //

        KeSetEvent(&MinidriverInfo->ControlEvent, IO_NO_INCREMENT, FALSE);

    }                           // if pageable
}

VOID
SCReferenceDriver(
                  IN PDEVICE_EXTENSION DeviceExtension

)
/*++

Routine Description:

    This routine shows one more reference to the minidriver, and pages
    in the minidriver if the count was zero

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    none.

--*/

{

    PMINIDRIVER_INFORMATION MinidriverInfo = DeviceExtension->DriverInfo;

    PAGED_CODE();

    //
    // if the driver said it was a SWENUM driver, reference it.
    //

    if (DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD)
    {
        SCReferenceSwEnumDriver(DeviceExtension,TRUE);
    }
    
    DebugPrint(( DebugLevelVerbose, 
                 "ReferenceDriver %x Count %x DriverFlags=%x\n",
                 DeviceExtension->DeviceObject->DriverObject,
                 MinidriverInfo->UseCount, MinidriverInfo->Flags));

    if (!(MinidriverInfo->Flags & DRIVER_FLAGS_NO_PAGEOUT)) {

        KeWaitForSingleObject(&MinidriverInfo->ControlEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);

        DebugPrint(( DebugLevelVerbose, 
                     "RefernceDriver Countup\n"));

        //
        // inc the refcount and see if we
        // need to page in.
        //

        ASSERT((LONG) MinidriverInfo->UseCount >= 0);

        if (!(MinidriverInfo->UseCount++)) {

            //
            // page in the minidriver
            //

            MmResetDriverPaging(MinidriverInfo->HwInitData.HwReceivePacket);
            MinidriverInfo->Flags &= ~(DRIVER_FLAGS_PAGED_OUT);

        }                       // if !usecount
        KeSetEvent(&MinidriverInfo->ControlEvent, IO_NO_INCREMENT, FALSE);

    }                           // if pageable
}


VOID
SCInsertStreamInFilter(
                       IN PSTREAM_OBJECT StreamObject,
                       IN PDEVICE_EXTENSION DeviceExtension

)
/*++

Routine Description:

    Inserts a new stream in the stream queue on the filter instance

Arguments:

    StreamObject = pointer to stream object

Return Value:

    none.

--*/
{

    KIRQL           Irql;

    //
    // insert the stream object in the filter
    // instance list
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    InsertHeadList(&((PFILTER_INSTANCE) (StreamObject->FilterInstance))->
                   FirstStream,
                   &StreamObject->NextStream);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

    return;
}

VOID
SCInsertFiltersInDevice(
                        IN PFILTER_INSTANCE FilterInstance,
                        IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Inserts a new filter in the device list at DPC level

Arguments:

Return Value:

    none.

--*/
{
    KIRQL           Irql;

    //
    // insert the filter instance in the global list
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    InsertHeadList(
                   &DeviceExtension->FilterInstanceList,
                   &FilterInstance->NextFilterInstance);


    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
}

VOID
SCInterlockedRemoveEntryList(
                             PDEVICE_EXTENSION DeviceExtension,
                             PLIST_ENTRY List
)
/*++

Routine Description:

    Removes the specified entry under spinlock

Arguments:

Return Value:

    none.

--*/
{
    KIRQL           Irql;

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    RemoveEntryList(List);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

}

VOID
SCProcessTimerRequest(
                      IN PCOMMON_OBJECT CommonObject,
                      IN PINTERRUPT_DATA SavedInterruptData

)
/*++

Routine Description:

    This routine handles a minidriver request to either set or clear a timer

Arguments:

    CommonObject - pointer to common object
    SavedInterruptData - captured interrupt data

Return Value:

    none.

--*/
{
    LARGE_INTEGER   timeValue;

    CommonObject->HwTimerRoutine =
        SavedInterruptData->HwTimerRoutine;

    CommonObject->HwTimerContext =
        SavedInterruptData->HwTimerContext;

    //
    // The minidriver wants a timer request.
    // If the requested timer value is zero,
    // then cancel the timer.
    //

    if (SavedInterruptData->HwTimerValue == 0) {

        KeCancelTimer(&CommonObject->MiniDriverTimer);

    } else {

        //
        // Convert the timer value from
        // microseconds to a negative
        // 100
        // nanoseconds.
        //

//        timeValue.QuadPart = Int32x32To64(
//                   SavedInterruptData->HwTimerValue,
//                   -10);

        timeValue.LowPart = SavedInterruptData->HwTimerValue * -10;
        timeValue.HighPart = -1;

        //
        // Set the timer.
        //

        KeSetTimer(&CommonObject->MiniDriverTimer,
                   timeValue,
                   &CommonObject->MiniDriverTimerDpc);
    }
}


VOID
SCProcessPriorityChangeRequest(
                               IN PCOMMON_OBJECT CommonObject,
                               IN PINTERRUPT_DATA SavedInterruptData,
                               IN PDEVICE_EXTENSION DeviceExtension

)
/*++

Routine Description:

    Routine handles priority change requests from the minidriver

Arguments:

    CommonObject - pointer to common object
    SavedInterruptData - captured interrupt data
    DeviceExtension - pointer to device extension

Return Value:

    none.

--*/
{

#if DBG
    PDEBUG_WORK_ITEM DbgWorkItemStruct;
#endif

    if (SavedInterruptData->HwPriorityLevel == Dispatch) {

        DebugPrint((DebugLevelVerbose, "'SCDpc: Dispatch priority callout\n"));

        //
        // Acquire the device spinlock so
        // nothing else starts.
        //

        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

        //
        // call the minidriver at dispatch
        // level.
        //

        SavedInterruptData->HwPriorityRoutine(SavedInterruptData->HwPriorityContext);

        if ((CommonObject->InterruptData.Flags &
             INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST)
            &&
            (CommonObject->InterruptData.HwPriorityLevel == High)) {

            DebugPrint((DebugLevelVerbose, "'SCDpc: High priority callout\n"));

            //
            // if the minidriver now wants a high priority callback,
            // do so now.  This is safe since we have the device
            // spinlock and the minidriver cannot make
            // another priority request for this stream while one is
            // requested.
            //

            CommonObject->InterruptData.Flags &=
                ~(INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST);

            DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                      (PVOID) CommonObject->InterruptData.HwPriorityRoutine,
                             CommonObject->InterruptData.HwPriorityContext);


        }                       // if high requested
        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    } else if (SavedInterruptData->HwPriorityLevel == Low) {

#if DBG

        //
        // make sure that the minidriver is not misusing this function.
        //

        if (DeviceExtension->NumberOfRequests > 0xFFFFFFF0) {
            DeviceExtension->Flags |= DEVICE_FLAGS_PRI_WARN_GIVEN;

        }
        if ((++DeviceExtension->NumberOfLowPriCalls > 100) &&
            ((DeviceExtension->NumberOfLowPriCalls) >
             DeviceExtension->NumberOfRequests / 4) &&
            (!(DeviceExtension->Flags & DEVICE_FLAGS_PRI_WARN_GIVEN))) {

            DeviceExtension->Flags |= DEVICE_FLAGS_PRI_WARN_GIVEN;


            DebugPrint((DebugLevelFatal, "Stream Class has determined that a minidriver is scheduling\n"));
            DebugPrint((DebugLevelFatal, "a low priority callback for more than 25 percent of the requests\n"));
            DebugPrint((DebugLevelFatal, "it has received.   This driver should probably be setting the\n"));
            DebugPrint((DebugLevelFatal, "TurnOffSynchronization boolean and doing its own synchronization.\n"));
            DebugPrint((DebugLevelFatal, "Please open a bug against the dev owner of this minidriver.\n"));
            DebugPrint((DebugLevelFatal, "Do an LN of %x to determine the name of the minidriver.\n", SavedInterruptData->HwPriorityRoutine));
            TRAP;
        }                       // if bad pri
        if (CommonObject->InterruptData.Flags &
            INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) {

            DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled priority twice!\n"));
            ASSERT(1 == 0);
        }                       // if scheduled twice
        DbgWorkItemStruct = ExAllocatePool(NonPagedPool, sizeof(DEBUG_WORK_ITEM));
//        DebugPrint((DebugLevelFatal, "A %x\n", DbgWorkItemStruct));
        if (DbgWorkItemStruct) {

            DbgWorkItemStruct->HwPriorityRoutine = SavedInterruptData->HwPriorityRoutine;
            DbgWorkItemStruct->HwPriorityContext = SavedInterruptData->HwPriorityContext;
            DbgWorkItemStruct->Object = CommonObject;

            ExInitializeWorkItem(&CommonObject->WorkItem,
                                 SCDebugPriorityWorkItem,
                                 DbgWorkItemStruct);
        } else {

            ExInitializeWorkItem(&CommonObject->WorkItem,
                                 SavedInterruptData->HwPriorityRoutine,
                                 SavedInterruptData->HwPriorityContext);
        }

#else



        ExInitializeWorkItem(&CommonObject->WorkItem,
                             SavedInterruptData->HwPriorityRoutine,
                             SavedInterruptData->HwPriorityContext);
#endif

        ExQueueWorkItem(&CommonObject->WorkItem,
                        DelayedWorkQueue);
    }                           // if priority
}

VOID
SCBeginSynchronizedMinidriverCallin(
                                    IN PDEVICE_EXTENSION DeviceExtension,
                                    IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles begin processing of a synchronized minidriver callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/
{
    return;
}

VOID
SCBeginUnsynchronizedMinidriverCallin(
                                      IN PDEVICE_EXTENSION DeviceExtension,
                                      IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles begin processing of an unsynchronized minidriver callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/

{
    KeAcquireSpinLock(&DeviceExtension->SpinLock, Irql);
    \
        return;
}

VOID
SCEndSynchronizedMinidriverStreamCallin(
                                        IN PSTREAM_OBJECT StreamObject,
                                        IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles end processing of a synchronized minidriver
    stream callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/

{
    SCRequestDpcForStream(StreamObject);
    return;
}

VOID
SCEndSynchronizedMinidriverDeviceCallin(
                                        IN PDEVICE_EXTENSION DeviceExtension,
                                        IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles end processing of a synchronized minidriver
    device callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/

{

    DeviceExtension->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;
    return;
}

VOID
SCEndUnsynchronizedMinidriverDeviceCallin(
                                       IN PDEVICE_EXTENSION DeviceExtension,
                                          IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles end processing of an unsynchronized minidriver
    device callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/

{
    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    DeviceExtension->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;
    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   NULL);
    KeLowerIrql(*Irql);
    return;
}

VOID
SCEndUnsynchronizedMinidriverStreamCallin(
                                          IN PSTREAM_OBJECT StreamObject,
                                          IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles end processing of an unsynchronized minidriver
    stream callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/

{
    KeReleaseSpinLockFromDpcLevel(&StreamObject->DeviceExtension->SpinLock);
    SCRequestDpcForStream(StreamObject);

    StreamClassDpc(NULL,
                   StreamObject->DeviceExtension->DeviceObject,
                   NULL,
                   StreamObject);
    KeLowerIrql(*Irql);
    return;
}


VOID
SCCheckPoweredUp(
                 IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    This routine powers up the HW if necessary

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    none.

--*/
{

    NTSTATUS        Status;
    POWER_STATE     PowerState;
    POWER_CONTEXT   PowerContext;

    PAGED_CODE();

    //
    // check to see if we are powered down
    //

    if (DeviceExtension->RegistryFlags & DEVICE_REG_FL_POWER_DOWN_CLOSED) {
        while (DeviceExtension->CurrentPowerState != PowerDeviceD0) {

            //
            // release the event to avoid deadlocks with the power up code.
            //

            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

            //
            // tell the power manager to power up the device.
            //

            PowerState.DeviceState = PowerDeviceD0;

            //
            // now send down a set power based on this info.
            //

            KeInitializeEvent(&PowerContext.Event, NotificationEvent, FALSE);

            Status = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
                                       IRP_MN_SET_POWER,
                                       PowerState,
                                       SCBustedSynchPowerCompletionRoutine,
                                       &PowerContext,
                                       NULL);

            if (Status == STATUS_PENDING) {

                //
                // wait for the IRP to complete
                //

                KeWaitForSingleObject(
                                      &PowerContext.Event,
                                      Suspended,
                                      KernelMode,
                                      FALSE,
                                      NULL);
            }
            //
            // reacquire the event and loop if good status. The only reason
            // we would get a good status here is if the HW powered up, but
            // some
            // policy maker instantly powered it down again.  This should
            // never
            // happen more than once, but if it does this thread could be
            // stuck.
            //

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,    // not alertable
                                  NULL);

            if (!NT_SUCCESS(PowerContext.Status)) {

                //
                // if we could not power up, go ahead and let the request go
                // through.   The worst that will happen is that the request
                // will fail at the HW level.
                //

                break;
            }
        }

    }                           // if power down when closed
    return;
}

VOID
SCCheckPowerDown(
                 IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    This routine powers down the hardware if possible

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    none.

--*/
{
    NTSTATUS        Status;
    POWER_STATE     PowerState;
    POWER_CONTEXT   PowerContext;

    PAGED_CODE();

    //
    // only power down if there are not open files
    //

    if (DeviceExtension->RegistryFlags & DEVICE_REG_FL_POWER_DOWN_CLOSED) {
        if (!DeviceExtension->NumberOfOpenInstances) {

            //
            // release the event to avoid deadlocks with the power up code.
            //

            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

            //
            // tell the power manager to power down the device.
            //

            PowerState.DeviceState = PowerDeviceD3;

            //
            // now send down a set power based on this info.
            //

            KeInitializeEvent(&PowerContext.Event, NotificationEvent, FALSE);

            Status = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
                                       IRP_MN_SET_POWER,
                                       PowerState,
                                       SCBustedSynchPowerCompletionRoutine,
                                       &PowerContext,
                                       NULL);

            if (Status == STATUS_PENDING) {

                //
                // wait for the IRP to complete
                //

                KeWaitForSingleObject(
                                      &PowerContext.Event,
                                      Suspended,
                                      KernelMode,
                                      FALSE,
                                      NULL);
            }
            //
            // reacquire the event.
            //

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,    // not alertable
                                  NULL);
        }
    }                           // if power down closed
    return;
}

VOID
SCWaitForOutstandingIo(
                       IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    This routine decs the one based I/O counter and blocks until the counter
    goes to zero.

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    none.

--*/
{
    KIRQL           Irql;
    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    DeviceExtension->Flags |= DEVICE_FLAGS_DEVICE_INACCESSIBLE;

    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

    if (InterlockedDecrement(&DeviceExtension->OneBasedIoCount)) {

#ifdef wecandothis

        PFILTER_INSTANCE FilterInstance;
        KIRQL           Irql;
        PLIST_ENTRY     FilterEntry,
                        FilterListEntry;

        //
        // there is I/O outstanding.   Cancel all outstanding IRP's.
        //

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

checkfilters:
        FilterInstance = DeviceExtension->GlobalFilterInstance;

        if (FilterInstance) {

            if (SCCheckFilterInstanceStreamsForIrp(FilterInstance, NULL)) {

                DebugPrint((DebugLevelWarning, "'SCCancelPending: found Irp on global instance\n"));

                //
                // we found one.  jump back to loop back through since the
                // spinlock
                // had to be released and reaquired to cancel the irp.
                //

                goto checkfilters;
            }
        }
        FilterListEntry = FilterEntry = &DeviceExtension->FilterInstanceList;

        while (FilterEntry->Flink != FilterListEntry->Blink) {

            FilterEntry = FilterEntry->Flink;

            //
            // follow the link to the instance
            //

            FilterInstance = CONTAINING_RECORD(FilterListEntry,
                                               FILTER_INSTANCE,
                                               NextFilterInstance);

            //
            // process the streams on this list
            //

            if (SCCheckFilterInstanceStreamsForIrp(FilterInstance, NULL)) {

                //
                // we found one.  jump back to loop back through since the
                // spinlock
                // had to be released and reaquired to cancel the irp.
                //

                goto checkfilters;

            }
            //
            // get the list entry for this instance
            //

            FilterListEntry = &FilterInstance->NextFilterInstance;
        }

        //
        // now process any requests on the device itself
        //

        while (SCCheckRequestsForIrp(
         &DeviceExtension->OutstandingQueue, NULL, TRUE, DeviceExtension)) {

        }

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

#endif

        //
        // Block on the removal event which is signaled as the last I/O
        // completes.
        //

        KeWaitForSingleObject(&DeviceExtension->RemoveEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);
    }
    //
    // restore the counter to 1-based, since we've now assured that all
    // I/O to the device has completed.
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    return;
}

NTSTATUS
SCShowIoPending(
                IN PDEVICE_EXTENSION DeviceExtension,
                IN PIRP Irp
)
/*++

Routine Description:

    This routine shows that one more I/O is outstanding, or errors the I/O
    if the device is inaccessible.

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    TRUE if I/O can be submitted.

--*/
{
    PAGED_CODE();

    //
    // assume that the device is accessible and show one more request.
    // if it's not accessible, we'll show one less.   do it in this order
    // to prevent a race where the inaccessible flag has been set, but the
    // the i/o count has not been dec'd yet.
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    if (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE) {

        NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

        InterlockedDecrement(&DeviceExtension->OneBasedIoCount);

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return (Status);
    }
    return (STATUS_SUCCESS);

}


NTSTATUS
SCCallNextDriver(
                 IN PDEVICE_EXTENSION DeviceExtension,
                 IN PIRP Irp
)
/*++

Routine Description:

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    none.

--*/
{
    KEVENT          Event;
    PIO_STACK_LOCATION IrpStack,
                    NextStack;
    NTSTATUS        Status;

    PAGED_CODE();

    if ( NULL == DeviceExtension->AttachedPdo ) {
        //
        // DO has been detached, return success directly.
        //
        return STATUS_SUCCESS;
    }

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    NextStack = IoGetNextIrpStackLocation(Irp);
    ASSERT(NextStack != NULL);
    RtlCopyMemory(NextStack, IrpStack, sizeof(IO_STACK_LOCATION));

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    IoSetCompletionRoutine(Irp,
                           SCSynchCompletionRoutine,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    if ( IRP_MJ_POWER != IrpStack->MajorFunction ) {
    
        Status = IoCallDriver(DeviceExtension->AttachedPdo, Irp);
        
    } else {

        //
        // power Irp, use PoCallDriver()
        //
        Status = PoCallDriver( DeviceExtension->AttachedPdo, Irp );
    }
       

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = Irp->IoStatus.Status;
    }
    return (Status);
}

VOID
SCMinidriverTimeFunction(
                         IN PHW_TIME_CONTEXT TimeContext
)
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{

    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) TimeContext->HwDeviceExtension - 1;
    KIRQL           Irql;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                TimeContext->HwStreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject);

    //
    // call the minidriver to process the time function
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);


    DeviceExtension->SynchronizeExecution(
                                          DeviceExtension->InterruptObject,
                                          (PVOID) StreamObject->
                               HwStreamObject.HwClockObject.HwClockFunction,
                                          TimeContext);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

}


ULONGLONG
SCGetStreamTime(
                IN PFILE_OBJECT FileObject

)
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    HW_TIME_CONTEXT TimeContext;

    PCLOCK_INSTANCE ClockInstance = (PCLOCK_INSTANCE) FileObject->FsContext;

    TimeContext.HwStreamObject = &ClockInstance->StreamObject->HwStreamObject;

    TimeContext.HwDeviceExtension = ClockInstance->StreamObject->
        DeviceExtension->HwDeviceExtension;

    TimeContext.Function = TIME_GET_STREAM_TIME;

    SCMinidriverTimeFunction(&TimeContext);

    return (TimeContext.Time);
}

ULONGLONG       FASTCALL
                SCGetPhysicalTime(
                                                  IN PFILE_OBJECT FileObject

)
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    HW_TIME_CONTEXT TimeContext;

    PCLOCK_INSTANCE ClockInstance = (PCLOCK_INSTANCE) FileObject->FsContext;

    TimeContext.HwStreamObject = &ClockInstance->StreamObject->HwStreamObject;

    TimeContext.HwDeviceExtension = ClockInstance->StreamObject->
        DeviceExtension->HwDeviceExtension;

    TimeContext.Function = TIME_READ_ONBOARD_CLOCK;

    SCMinidriverTimeFunction(&TimeContext);

    return (TimeContext.Time);
}


ULONGLONG       FASTCALL
                SCGetSynchronizedTime(
                                                 IN PFILE_OBJECT FileObject,
                                                    IN PULONGLONG SystemTime

)
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    HW_TIME_CONTEXT TimeContext;

    PCLOCK_INSTANCE ClockInstance = (PCLOCK_INSTANCE) FileObject->FsContext;

    TimeContext.HwStreamObject = &ClockInstance->StreamObject->HwStreamObject;

    TimeContext.HwDeviceExtension = ClockInstance->StreamObject->
        DeviceExtension->HwDeviceExtension;

    TimeContext.Function = TIME_GET_STREAM_TIME;

    SCMinidriverTimeFunction(&TimeContext);

    *SystemTime = TimeContext.SystemTime;
    return (TimeContext.Time);
}

NTSTATUS
SCSendUnknownCommand(
                     IN PIRP Irp,
                     IN PDEVICE_EXTENSION DeviceExtension,
                     IN PVOID Callback,
                     OUT PBOOLEAN RequestIssued
)
/*++

Routine Description:


Arguments:

    Irp - pointer to the IRP

Return Value:

     NTSTATUS returned as appropriate.

--*/

{

    PAGED_CODE();

    //
    // send an UNKNOWN_COMMAND SRB to the minidriver.
    //

    return (SCSubmitRequest(SRB_UNKNOWN_DEVICE_COMMAND,
                            NULL,
                            0,
                            Callback,
                            DeviceExtension,
                            NULL,
                            NULL,
                            Irp,
                            RequestIssued,
                            &DeviceExtension->PendingQueue,
                            (PVOID) DeviceExtension->
                            MinidriverData->HwInitData.
                            HwReceivePacket
                            ));

}


BOOLEAN
SCMapMemoryAddress(PACCESS_RANGE AccessRanges,
                   PHYSICAL_ADDRESS TranslatedAddress,
                   PPORT_CONFIGURATION_INFORMATION ConfigInfo,
                   PDEVICE_EXTENSION DeviceExtension,
                   PCM_RESOURCE_LIST ResourceList,
                   PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor)
/*++

Routine Description:

Arguments:

Return Value:

     None.

--*/

{
    PMAPPED_ADDRESS newMappedAddress;

    PAGED_CODE();

    //
    // Now we need to map a linear address to the physical
    // address that HalTranslateBusAddress provided us.
    //

    //
    // set the access range in the structure.
    //

    AccessRanges->RangeLength = PartialResourceDescriptor->u.Memory.Length;

    AccessRanges->RangeInMemory = TRUE;

    AccessRanges->RangeStart.QuadPart = (ULONG_PTR) MmMapIoSpace(
                                                          TranslatedAddress,
                                                  AccessRanges->RangeLength,
                                                                 FALSE  // No caching
        );

    if (AccessRanges->RangeStart.QuadPart == 0) {

        //
        // Couldn't translate the resources, return an error
        // status
        //

        DebugPrint((DebugLevelFatal, "StreamClassPnP: Couldn't translate Memory Slot Resources\n"));
        return FALSE;

    }
    //
    // Allocate memory to store mapped address for unmap.
    //

    newMappedAddress = ExAllocatePool(NonPagedPool,
                                      sizeof(MAPPED_ADDRESS));

    //
    // save a link to the resources if the alloc succeeded.
    // if it failed, don't worry about it.
    //

    if (newMappedAddress != NULL) {

        //
        // Store mapped address, bytes count, etc.
        //

        newMappedAddress->MappedAddress = (PVOID)
            AccessRanges->RangeStart.QuadPart;
        newMappedAddress->NumberOfBytes =
            AccessRanges->RangeLength;
        newMappedAddress->IoAddress =
            PartialResourceDescriptor->u.Memory.Start;
        newMappedAddress->BusNumber =
            ConfigInfo->SystemIoBusNumber;

        //
        // Link current list to new entry.
        //

        newMappedAddress->NextMappedAddress =
            DeviceExtension->MappedAddressList;

        //
        // Point anchor at new list.
        //

        DeviceExtension->MappedAddressList = newMappedAddress;

    }                           // if newmappedaddress
    return TRUE;
}


VOID
SCUpdatePersistedProperties(IN PSTREAM_OBJECT StreamObject,
                            IN PDEVICE_EXTENSION DeviceExtension,
                            IN PFILE_OBJECT FileObject
)
/*++

Routine Description:

Arguments:

Return Value:

     None.

--*/

{
    NTSTATUS        Status;
    HANDLE          handle;
    CHAR            AsciiKeyName[32];
    ANSI_STRING     AnsiKeyName;
    UNICODE_STRING  UnicodeKeyName;

    PAGED_CODE();

    Status = IoOpenDeviceRegistryKey(DeviceExtension->PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    //
    // loop through our table of strings,
    // reading the registry for each.
    //

    if (NT_SUCCESS(Status)) {

        //
        // create the subkey for the pin, in the form of "Pin0\Properties",
        // etc.
        //

        sprintf(AsciiKeyName, "Pin%d\\Properties", StreamObject->HwStreamObject.StreamNumber);
        RtlInitAnsiString(&AnsiKeyName, AsciiKeyName);


        if (NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeKeyName,
                                                    &AnsiKeyName, TRUE))) {
            //
            // call KS to unserialize the properties.
            //

            KsUnserializeObjectPropertiesFromRegistry(FileObject,
                                                      handle,
                                                      &UnicodeKeyName);
            //
            // free the unicode string
            //

            RtlFreeUnicodeString(&UnicodeKeyName);

        }                       // if rtl..
        //
        // close the registry handle.
        //

        ZwClose(handle);


    }                           // status = success
}

NTSTATUS
SCQueryCapabilities(
                    IN PDEVICE_OBJECT PdoDeviceObject,
                    IN PDEVICE_CAPABILITIES DeviceCapabilities
)
/*++

Routine Description:

    This routine reads the capabilities of our parent.

Arguments:

    DeviceObject        - "Real" physical device object

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION NextStack;
    PIRP            Irp;
    NTSTATUS        Status;
    KEVENT          Event;

    PAGED_CODE();

    //
    // allocate an IRP for the call.
    //

    Irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

    if (!Irp) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    NextStack = IoGetNextIrpStackLocation(Irp);

    ASSERT(NextStack != NULL);
    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;

    //
    // Initialize the capabilities that we will send down
    //
    RtlZeroMemory(DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
    DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Version = 1;
    DeviceCapabilities->Address = -1;
    DeviceCapabilities->UINumber = -1;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp,
                           SCSynchCompletionRoutine,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    NextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    DebugPrint((DebugLevelInfo, 
                "Capabilities Version %x Flags %x\n", 
                (ULONG)DeviceCapabilities->Version,
                *(UNALIGNED ULONG*)(&DeviceCapabilities->Version+1)));

    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;    // bug #282910

    Status = IoCallDriver(PdoDeviceObject,
                          Irp);

    if (Status == STATUS_PENDING) {

        //
        // block waiting for completion
        //

        KeWaitForSingleObject(
                              &Event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
    }
    //
    // obtain final status and free IRP.
    //

    Status = Irp->IoStatus.Status;

    IoFreeIrp(Irp);

    return (Status);

}

NTSTATUS
SCEnableEventSynchronized(
                          IN PVOID ServiceContext
)
/*++

Routine Description:

    This routine inserts the new event on the queue, and calls the minidriver
    with the event.

Arguments:

    ServiceContext - Supplies a pointer to the interrupt context which contains
        pointers to the interrupt data and where to save it.

Return Value:

    Returns TRUE if there is new work and FALSE otherwise.

Notes:

    Called via KeSynchronizeExecution with the port device extension spinlock
    held.

--*/
{
    PHW_EVENT_DESCRIPTOR Event = ServiceContext;
    NTSTATUS        Status = STATUS_SUCCESS;

    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     Event->StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject);

    PDEVICE_EXTENSION DeviceExtension = StreamObject->DeviceExtension;

    //
    // insert the event on our list, in case the minidriver decides to signal
    // from within this call.
    //

    InsertHeadList(&StreamObject->NotifyList,
                   &Event->EventEntry->ListEntry);

    //
    // call the minidriver's event routine, if present.
    //

    if (StreamObject->HwStreamObject.HwEventRoutine) {

        Status = StreamObject->HwStreamObject.HwEventRoutine(Event);

    }                           // if eventroutine
    if (!NT_SUCCESS(Status)) {

        //
        // minidriver did not like it.  remove the entry from the list.
        //

        DebugPrint((DebugLevelError, "StreamEnableEvent: minidriver failed enable!\n"));

        RemoveEntryList(&Event->EventEntry->ListEntry);
    }
    return (Status);
}

NTSTATUS
SCEnableDeviceEventSynchronized(
                                IN PVOID ServiceContext
)
/*++

Routine Description:

    This routine inserts the new event on the queue, and calls the minidriver
    with the event.

Arguments:

    ServiceContext - Supplies a pointer to the interrupt context which contains
        pointers to the interrupt data and where to save it.

Return Value:

    Returns TRUE if there is new work and FALSE otherwise.

Notes:


--*/
{
    PHW_EVENT_DESCRIPTOR Event = ServiceContext;
    NTSTATUS        Status = STATUS_SUCCESS;

    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)Event->DeviceExtension - 1;
    IF_MF( PFILTER_INSTANCE FilterInstance = (PFILTER_INSTANCE)Event->HwInstanceExtension -1;)

    //
    // insert the event on our list, in case the minidriver decides to signal
    // from within this call.
    //
	IFN_MF(InsertHeadList(&DeviceExtension->NotifyList,&Event->EventEntry->ListEntry);)
	IF_MF(InsertHeadList(&FilterInstance->NotifyList,&Event->EventEntry->ListEntry);)

    //
    //