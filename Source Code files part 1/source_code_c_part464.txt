

            //--- Expand last two digits - e.g. "nineteen", "hundred", or "oh nine".
            if ( pItemInfo->pYear[2] != '0' )
            {
                //--- the tens is not zero - e.g. 1919 -> "nineteen nineteen" 
                ExpandTwoDigits( pItemInfo->pYear + 2, Garbage, WordList );
            }
            else if ( pItemInfo->pYear[3] == '0' )
            {
                //--- tens and ones are both zero - expand as "hundred", e.g. 1900 -> "nineteen hundred" 
                Word.pWordText  = g_quantifiers[0].pStr;
                Word.ulWordLen  = g_quantifiers[0].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            else
            {
                //--- just the tens is zero, expand as "oh x" - e.g. 1909 -> "nineteen oh nine", 
                //---   unless both thousands and hundreds were also zero - e.g. 0002 -> "two"
                if ( pItemInfo->pYear[0] != '0' ||
                     pItemInfo->pYear[1] != '0' )
                {
                    Word.pWordText  = g_O.pStr;
                    Word.ulWordLen  = g_O.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                ExpandDigit( pItemInfo->pYear[3], Garbage, WordList );
            }
        }
    }
    return hr;
} /* ExpandYear */

/***********************************************************************************************
* IsDecade *
*----------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a Decade.
*
*   RegExp:
*       { ddd0s || d0s || 'd0s || ddd0's || d0's }
*   
*   Types assigned:
*       Decade
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsDecade( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsDecade" );

    HRESULT hr = S_OK;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);

    if ( ulTokenLen < 3 ||
         ulTokenLen > 6 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        switch ( ulTokenLen )
        {

        case 6:
            if ( m_pNextChar[5] == L's'     &&
                 m_pNextChar[4] == L'\''     &&
                 m_pNextChar[3] == L'0'    &&
                 iswdigit( m_pNextChar[2] ) &&
                 iswdigit( m_pNextChar[1] ) &&
                 iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form ddd0's
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = m_pNextChar;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[2] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        case 5:
            if ( m_pNextChar[4] == L's'     &&
                 m_pNextChar[3] == L'0'     &&
                 iswdigit( m_pNextChar[2] ) &&
                 iswdigit( m_pNextChar[1] ) &&
                 iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form ddd0s
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = m_pNextChar;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[2] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        case 4:
            if ( m_pNextChar[3] == L's'     &&
                 m_pNextChar[2] == L'0'     &&
                 iswdigit( m_pNextChar[1] ) &&
                 m_pNextChar[0] == L'\'' )
            {
                //--- Decade of form 'd0s
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = NULL;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[1] - L'0';
                }
            }
            else if ( m_pNextChar[3] == L's'  &&
                      m_pNextChar[2] == L'\'' &&
                      m_pNextChar[1] == L'0'  &&
                      iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form d0's
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = NULL;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[0] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        case 3:
            if ( m_pNextChar[2] == L's' &&
                 m_pNextChar[1] == L'0' &&
                 iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form d0s
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = NULL;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[0] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        default:
            hr = E_INVALIDARG;
            break;
        }
    }            
    
    return hr;
} /* IsDecade */

/***********************************************************************************************
* ExpandDecade *
*--------------*
*   Description:
*       Expands Items previously determined to be of type Decade by IsDecade.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandDecade( TTSDecadeItemInfo* pItemInfo, CWordList& WordList )
{
    HRESULT hr = S_OK;
    BOOL fDone = false;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Four digit form 
    if ( pItemInfo->pCentury )
    {
        //--- Cover special cases first 

        //--- 00dds 
        if ( pItemInfo->pCentury[0] == '0' &&
             pItemInfo->pCentury[1] == '0' )
        {
            //--- 0000s - expand as "zeroes"
            if ( pItemInfo->ulDecade == 0 )
            {
                Word.pWordText  = g_Zeroes.pStr;
                Word.ulWordLen  = g_Zeroes.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                fDone = true;
            }
            //--- 00d0s 
            else 
            {
                // Just expand the decade part as we normally would
                NULL;
            }
        }
        //--- 0dd0s - expand as "d hundreds" or "d hundred [decade part]"
        else if ( pItemInfo->pCentury[0] == '0' )
        {
            //--- insert first digit
            Word.pWordText  = g_ones[ pItemInfo->pCentury[0] - L'0' ].pStr;
            Word.ulWordLen  = g_ones[ pItemInfo->pCentury[0] - L'0' ].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- 0d00s - expand as "d hundreds" 
            if ( SUCCEEDED( hr ) &&
                 pItemInfo->ulDecade == 0 )
            {
                Word.pWordText  = g_Hundreds.pStr;
                Word.ulWordLen  = g_Hundreds.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                fDone = true;
            }
            //--- 0dd0s - expand as "d hundred [decade part]"
            else if ( SUCCEEDED( hr ) )
            {
                Word.pWordText  = g_hundred.pStr;
                Word.ulWordLen  = g_hundred.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
        }
        //--- d000s, dd00s - expand as "d thousands" or "dd hundreds"
        else if ( pItemInfo->ulDecade == 0 )
        {
            //--- d000s - "d thousands" ( "thousands" will get inserted below )
            if ( pItemInfo->pCentury[1] == '0' )
            {
                Word.pWordText  = g_ones[ pItemInfo->pCentury[0] - L'0' ].pStr;
                Word.ulWordLen  = g_ones[ pItemInfo->pCentury[0] - L'0' ].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            //--- dd00s - "dd hundreds"
            else
            {
                NumberGroup Garbage;
                ExpandTwoDigits( pItemInfo->pCentury, Garbage, WordList );

                Word.pWordText  = g_Hundreds.pStr;
                Word.ulWordLen  = g_Hundreds.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                fDone = true;
            }
        }
        //--- Default case: ddd0s - expand as "dd [decade part]"
        else
        {
            NumberGroup Garbage;
            ExpandTwoDigits( pItemInfo->pCentury, Garbage, WordList );
        }
    }
    //--- Special case - 00s should expand as "two thousands"
    else if ( pItemInfo->ulDecade == 0 )
    {
        Word.pWordText  = g_ones[2].pStr;
        Word.ulWordLen  = g_ones[2].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    //--- Expand decade part, if necessary 
    if ( SUCCEEDED(hr) &&
         !fDone )
    {
        Word.pWordText  = g_Decades[ pItemInfo->ulDecade ].pStr;
        Word.ulWordLen  = g_Decades[ pItemInfo->ulDecade ].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    return hr;
} /* ExpandDecade */

/***********************************************************************************************
* MatchMonthString *
*------------------*
*   Description:
*       This is just a helper function - it returns the integer value of the month found in 
*   its WCHAR string parameter ("January" is 1, "February" 2, etc.) or zero if it finds no match.
*   It also checks three letter abbreviations - "Jan", "Feb", etc.
*   Note: This function does not do parameter validation. Assumed to be done by caller
*   (GetNumber should be called first to get the NumberInfo structure and valiDate parameters).
********************************************************************* AH **********************/
ULONG CStdSentEnum::MatchMonthString( WCHAR*& pMonth, ULONG ulLength )
{
    ULONG ulMonth = 0;

    //--- Check full months strings 
    for ( int i = 0; i < sp_countof(g_months); i++ )
    {
        if ( ulLength >= (ULONG) g_months[i].Len && 
             wcsnicmp( pMonth, g_months[i].pStr, g_months[i].Len ) == 0 )
        {
            ulMonth = i + 1;
            pMonth  = pMonth + g_months[i].Len;
            break;
        }
    }
    //--- Check month abbreviations 
    if ( !ulMonth )
    {
        for ( i = 0; i < sp_countof(g_monthAbbreviations); i++ )
        {
            if ( ulLength >= (ULONG) g_monthAbbreviations[i].Len &&
                 wcsnicmp( pMonth, g_monthAbbreviations[i].pStr, g_monthAbbreviations[i].Len ) == 0 ) 
            {
                if ( i > 8 )
                {
                    ulMonth = i;
                }
                else
                {
                    ulMonth = i + 1;
                }
                pMonth = pMonth + g_monthAbbreviations[i].Len;
                if ( *pMonth == L'.' )
                {
                    pMonth++;
                }
                break;
            }
        }
    }

    return ulMonth;
} /* MatchMonthString */

/***********************************************************************************************
* MatchDayString *
*----------------*
*   Description:
*       This is just a helper function - it returns the integer value of the day found in 
*   its WCHAR string parameter ("Monday" is 0, "Tuesday" 1, etc.) or -1 if it finds no match.
*   It also checks abbreviations - "Mon", "Tue", etc.
*   Note: This function does not do parameter validation. Assumed to be done by caller
********************************************************************* AH **********************/
ULONG CStdSentEnum::MatchDayString( WCHAR*& pDayString, WCHAR* pEndChar )
{
    ULONG ulDay = 0;

    //--- Check full day strings 
    for ( int i = 0; i < sp_countof(g_days); i++ )
    {
        if ( pEndChar - pDayString >= g_days[i].Len && 
             wcsnicmp( pDayString, g_days[i].pStr, g_days[i].Len ) == 0 )
        {
            ulDay = i + 1;
            pDayString = pDayString + g_days[i].Len;
            break;
        }
    }
    //--- Check month abbreviations 
    if ( !ulDay )
    {
        for ( i = 0; i < sp_countof(g_dayAbbreviations); i++ )
        {
            if ( pEndChar - pDayString >= g_dayAbbreviations[i].Len &&
                 wcsncmp( pDayString, g_dayAbbreviations[i].pStr, g_dayAbbreviations[i].Len ) == 0 )
            {
                switch (i)
                {
                //--- Mon, Tues
                case 0:
                case 1:
                    ulDay = i + 1;
                    break;
                //--- Tue, Wed, Thurs
                case 2:
                case 3:
                case 4:
                    ulDay = i;
                    break;
                //--- Thur, Thu
                case 5:
                case 6:
                    ulDay = 4;
                    break;
                //--- Fri, Sat, Sun
                case 7:
                case 8:
                case 9:
                    ulDay = i - 2;
                    break;
                }

                pDayString = pDayString + g_dayAbbreviations[i].Len;
                if ( *pDayString == L'.' )
                {
                    pDayString++;
                }
                break;
            }
        }
    }

    return ulDay;
} /* MatchDayString */

/***********************************************************************************************
* MatchDateDelimiter *
*--------------------*
*   Description:
*       This is just a helper function - it returns true or false based on whether the first
*   character in its parameter string is a valid Date Delimiter.  It also advances its parameter
*   string pointer one position (past the Date Delimiter) and replaces a valid delimiter with
*   a null terminator.
*   Note: This function does not do parameter validation. Assumed to be done by caller
*   (GetNumber should be called first to get the NumberInfo structure and valiDate parameters).
********************************************************************* AH **********************/
bool CStdSentEnum::MatchDateDelimiter( WCHAR** DateString )
{
    bool bIsDelimiter = false;

    if (DateString)
    {
        for (int i = 0; i < sp_countof(g_DateDelimiters); i++)
        {
            if (*DateString[0] == g_DateDelimiters[i])
            {
                bIsDelimiter = true;
                *DateString = *DateString + 1;
                break;
            }
        }
    }

    return bIsDelimiter;
} /* MatchDateDelimiter */

//------------End Of File-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\frontend.cpp ===
/*******************************************************************************
* Frontend.cpp *
*--------------*
*   Description:
*       This module is the main implementation file for the CFrontend class.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif
#ifndef SPDebug_h
#include "spdebug.h"
#endif
#ifndef FeedChain_H
#include "FeedChain.h"
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif
#include "sapi.h"

#include "StdSentEnum.h"


//-----------------------------
// Data.cpp
//-----------------------------
extern  const short   g_IPAToAllo[];
extern const float  g_RateScale[];


/*****************************************************************************
* CFrontend::CFrontend *
*----------------------*
*   Description:
*       
********************************************************************** MC ***/
CFrontend::CFrontend()
{
    SPDBG_FUNC( "CFrontend::CFrontend" );
    m_pUnits        = NULL;
    m_unitCount     = 0;
    m_CurUnitIndex  = 0;
    m_pAllos        = NULL;   
    m_pSrcObj       = NULL;
} /* CFrontend::CFrontend */


/*****************************************************************************
* CFrontend::~CFrontend *
*-----------------------*
*   Description:
*       
********************************************************************** MC ***/
CFrontend::~CFrontend()
{
    SPDBG_FUNC( "CFrontend::~CFrontend" );

    DisposeUnits();
    if( m_pAllos )
    {
        delete m_pAllos;
        m_pAllos = NULL;
    }
    DeleteTokenList();
} /* CFrontend::~CFrontend */

/*****************************************************************************
* CFrontend::CntrlToRatio *
*-------------------------*
*   Description:
*   Return rate ratio from control
*       
********************************************************************** MC ***/
float CFrontend::CntrlToRatio( long rateControl )
{
    SPDBG_FUNC( "CFrontend::CntrlToRatio" );
    float   rateRatio;

    if( rateControl < 0 )
    {
        //--------------------------------
        // DECREASE the rate
        //--------------------------------
        if( rateControl < MIN_USER_RATE )
        {
            rateControl = MIN_USER_RATE;        // clip to min
        }
        rateRatio = 1.0f / ::g_RateScale[0 - rateControl];
    }
    else
    {
        //--------------------------------
        // INCREASE the rate
        //--------------------------------
        if( rateControl > MAX_USER_RATE )
        {
            rateControl = MAX_USER_RATE;        // clip to max
        }
        rateRatio = ::g_RateScale[rateControl];
    }

    return rateRatio;
} /* CFrontend::CntrlToRatio */



/*****************************************************************************
* CFrontend::Init *
*-----------------*
*   Description:
*   Init voice dependent variables, call once when object is created+++
*       
********************************************************************** MC ***/
HRESULT CFrontend::Init( IMSVoiceData* pVoiceDataObj, CFeedChain *pSrcObj, MSVOICEINFO* pVoiceInfo )
{
    SPDBG_FUNC( "CFrontend::Init" );
    HRESULT hr = S_OK;
    
    m_pSrcObj   = pSrcObj;
    m_BasePitch = (float)pVoiceInfo->Pitch;
    m_pVoiceDataObj = pVoiceDataObj;
    m_ProsodyGain = ((float)pVoiceInfo->ProsodyGain) / 100.0f;
    m_SampleRate = (float)pVoiceInfo->SampleRate;

    // NOTE: move these to voice data?
	// m_VoiceWPM = pVoiceInfo->Rate;
	// m_PitchRange = pVoiceInfo->PitchRange;
    m_VoiceWPM		= 180;
	m_PitchRange	= 0.40f;       // +/- 0.5 octave


    m_RateRatio_API = m_RateRatio_PROSODY = 1.0f;

    return hr;        
} /* CFrontend::Init */





static ULONG IPA_to_Allo( WCHAR* pSrc, ALLO_CODE* pDest )
{
    ULONG       iIpa, iAllo, i;
    ULONG       gotMatch;           // for debugging

    iIpa = iAllo = 0;
    while( pSrc[iIpa] > 0 )
    {
        gotMatch = false;
        //-----------------------------------------
        // ...then search for single word IPA's
        //-----------------------------------------
        for( i = 0; i < NUMBER_OF_ALLO; i++ )
        {
            if( pSrc[iIpa] == g_IPAToAllo[i] )
            {
                pDest[iAllo] = (ALLO_CODE)i;
                gotMatch = true;
                break;
            }
        }

        if( gotMatch )
        {
            iAllo++;
        }
        /*else
        {
            // Should NEVER get here. Unsupported IPA unicode!
            // Ignore it and go on.
        }*/

        //----------------------------------
        // Clip at max length
        //----------------------------------
        if( iAllo >= (SP_MAX_PRON_LENGTH-1) )
        {
            iAllo = SP_MAX_PRON_LENGTH-1;
            break;
        }
        iIpa++;
    }
    return iAllo;
}




/*****************************************************************************
* CFrontend::AlloToUnit *
*-----------------------*
*   Description:
*   Transform ALLO stream into backend UNIT stream+++
*       
********************************************************************** MC ***/
HRESULT CFrontend::AlloToUnit( CAlloList *pAllos, UNITINFO *pu )
{
    SPDBG_FUNC( "CFrontend::AlloToUnit" );
    bool		bFirstPass;
    long		msPhon, attr;
    ULONG       numOfCells;
    CAlloCell   *pCurCell, *pNextCell;
    HRESULT		hr = S_OK;
    
	bFirstPass = true;
    numOfCells = pAllos->GetCount();
	pCurCell = pAllos->GetHeadCell();    
	pNextCell = pAllos->GetNextCell();
    while( pCurCell )
    {
        //--------------------------------------
        // Get next allo ID
        //--------------------------------------
        if( pNextCell )
        {
            pu->NextAlloID = (USHORT)pNextCell->m_allo;
        }
        else
        {
            pu->NextAlloID = _SIL_;
        }

        //--------------------------------------
        // Convert to Whistler phon code
        //--------------------------------------
        attr = 0;
        if( pCurCell->m_ctrlFlags & PRIMARY_STRESS )
        {
            attr |= ALLO_IS_STRESSED;
        }
        hr = m_pVoiceDataObj->AlloToUnit( (short)pCurCell->m_allo, attr, &msPhon );
		if( FAILED(hr) )
		{
			//------------------------
			// allo ID is invalid
			//------------------------
			break;
		}
		else
		{
			pu->PhonID = msPhon;
			pu->AlloID = (USHORT)pCurCell->m_allo;
			pu->flags = 0;
			pu->AlloFeatures = 0;
			pu->ctrlFlags = pCurCell->m_ctrlFlags;
			//--------------------------------------
			// Flag WORD boundary
			//--------------------------------------
			if( pCurCell->m_ctrlFlags & WORD_START )
			{
				pu->flags |= WORD_START_FLAG;
				//----------------------------------------------
				// Remember source word position and length
				//----------------------------------------------
				pu->srcPosition = pCurCell->m_SrcPosition;
				pu->srcLen = pCurCell->m_SrcLen;
			}
        
			//----------------------------------------------------
			// Flag SENTENCE boundary on 1st displayable word
			//----------------------------------------------------
			if( bFirstPass && (pCurCell->m_SentenceLen > 0) )
			{
				bFirstPass = false;
				pu->flags |= SENT_START_FLAG;
				//----------------------------------------------
				// Remember source word position and length
				//----------------------------------------------
				pu->sentencePosition = pCurCell->m_SentencePosition;
				pu->sentenceLen = pCurCell->m_SentenceLen;
			}

			pu->nKnots      = KNOTS_PER_PHON;
			/*for( k = 0; k < pu->nKnots; k++ )
			{
				pu->pTime[k]    = pCurCell->m_ftTime[k] * m_SampleRate;
				pu->pF0[k]      = pCurCell->m_ftPitch[k];
				pu->pAmp[k]     = pu->ampRatio;
			}*/

			//----------------------------
			// Controls and events
			//----------------------------
			pu->user_Volume = pCurCell->m_user_Volume;
			pu->pBMObj = (void*)pCurCell->m_pBMObj;
			pCurCell->m_pBMObj = NULL;
        
			//----------------------------------------
			// Pass features for viseme event
			//----------------------------------------
			if( pCurCell->m_ctrlFlags & PRIMARY_STRESS )
			{
				pu->AlloFeatures |= SPVFEATURE_STRESSED;
			}
			if( pCurCell->m_ctrlFlags & EMPHATIC_STRESS )
			{
				pu->AlloFeatures |= SPVFEATURE_EMPHASIS;
			}

			pu->duration = PITCH_BUF_RES;

			pu->silenceSource = pCurCell->m_SilenceSource;
			pu++;
		}
		pCurCell = pNextCell;
		pNextCell = pAllos->GetNextCell();
	}
	return hr;
} /* CFrontend::AlloToUnit */





/*****************************************************************************
* CFrontend::PrepareSpeech *
*--------------------------*
*   Description:
*   Prepare frontend for new speech
*       
********************************************************************** MC ***/
void    CFrontend::PrepareSpeech( IEnumSpSentence* pEnumSent, ISpTTSEngineSite *pOutputSite )
{
    SPDBG_FUNC( "CFrontend::PrepareSpeech" );

    m_pEnumSent = pEnumSent;
    m_SpeechState = SPEECH_CONTINUE;
    m_CurUnitIndex = m_unitCount = 0;
	m_HasSpeech = false;
	m_pOutputSite = pOutputSite;
	m_fInQuoteProsody = m_fInParenProsody = false;
	m_CurPitchOffs = 0;
	m_CurPitchRange = 1.0;
	m_RateRatio_PROSODY = 1.0f;
} /* CFrontend::PrepareSpeech */








/*****************************************************************************
* IsTokenPunct *
*--------------*
*   Description:
*   Return TRUE if char is , . ! or ?
*       
********************************************************************** MC ***/
bool fIsPunctuation( TTSSentItem Item )
{
    SPDBG_FUNC( "IsTokenPunct" );

    return ( Item.pItemInfo->Type == eCOMMA ||
             Item.pItemInfo->Type == eSEMICOLON ||
             Item.pItemInfo->Type == eCOLON ||
             Item.pItemInfo->Type == ePERIOD ||
             Item.pItemInfo->Type == eQUESTION ||
             Item.pItemInfo->Type == eEXCLAMATION );
} /* fIsPunctuation */




/*****************************************************************************
* CFrontend::ToBISymbols *
*------------------------*
*   Description:
*   Label each word with ToBI prosody notation+++
*       
********************************************************************** MC ***/
HRESULT CFrontend::ToBISymbols()
{
    SPDBG_FUNC( "CFrontend::ToBISymbols" );
    TOBI_PHRASE    *pTPhrase; 
    long			i, cPhrases;
    PROSODY_POS		prevPOS, curPOS;
    bool			possible_YNQ = false;
    long			cTok;
    CFEToken		*pTok, *pPrevTok, *pAuxTok;
	bool			hasEmph = false;
	SPLISTPOS		listPos;


	//----------------------------------
	// Get memory for phrase array
	//----------------------------------
	pAuxTok = NULL;			// To quiet the compiler
    cTok = m_TokList.GetCount();
	if( cTok )
	{
		pTPhrase = new TOBI_PHRASE[cTok];		// worse case: each token is a phrase
		if( pTPhrase )
		{
			//---------------------------------------------
			// Find sub-phrases from POS
			// For now, detect function/content boundaries
			//---------------------------------------------
			hasEmph = false;
			cPhrases	= 0;
			i = 0;
			listPos = m_TokList.GetHeadPosition();
			pTok = m_TokList.GetNext( listPos );
			prevPOS = pTok->m_posClass;
			while( pTok->phon_Str[0] == _SIL_ )
			{
				if( i >= (cTok-1) )
				{
					break;
				}
				i++;
				if( listPos != NULL )
				{
					pTok = m_TokList.GetNext( listPos );
				}
			}
			if( pTok->m_posClass == POS_AUX ) 
			{
				//---------------------------------
				// Could be a yes/no question
				//---------------------------------
				possible_YNQ = true;
				pAuxTok = pTok;
			}       
			pTPhrase[cPhrases].start = i;
			for( ; i < cTok; i++ )
			{
				curPOS = pTok->m_posClass;
				if( (curPOS != prevPOS) && (pTok->phon_Str[0] != _SIL_) )
				{
					pTPhrase[cPhrases].posClass = prevPOS;
					pTPhrase[cPhrases].end = i-1;
					cPhrases++;
					pTPhrase[cPhrases].start = i;
					prevPOS = curPOS;
				}
				if( pTok->user_Emph > 0 )
				{
					hasEmph = true;
				}
				if( listPos != NULL )
				{
					pTok = m_TokList.GetNext( listPos );
				}
			}
			//-------------------------------
			// Complete last phrase
			//-------------------------------
			pTPhrase[cPhrases].posClass = prevPOS;
			pTPhrase[cPhrases].end = i-1;
			cPhrases++;
        
			for( i = 0; i < cPhrases; i++ )
			{
				//-------------------------------------------------------
				// Sequence of function words, place a low tone 
				// on the LAST word in a func sequence,
				// if there are more than 1 words in the sequence.
				//-------------------------------------------------------
				if( ((pTPhrase[i].posClass == POS_FUNC) || (pTPhrase[i].posClass == POS_AUX)) && 
					(pTPhrase[i].end - pTPhrase[i].start) )
				{
					pTok = (CFEToken*)m_TokList.GetAt( m_TokList.FindIndex( pTPhrase[i].end ));
					if( pTok->m_Accent == K_NOACC )
					{
						pTok->m_Accent = K_LSTAR;
						pTok->m_Accent_Prom = 2;
						pTok->m_AccentSource = ACC_FunctionSeq;
					}
				}
            
				//-------------------------------------------------------
				// Sequence of content words, place a high or 
				// rising tone, of random prominence,
				// on the FIRST word in the content sequence
				//-------------------------------------------------------
				else if ( ((pTPhrase[i].posClass == POS_CONTENT) || (pTPhrase[i].posClass == POS_UNK)) )
				{
					pTok = (CFEToken*)m_TokList.GetAt( m_TokList.FindIndex( pTPhrase[i].start ));
					if( pTok->m_Accent == K_NOACC )
					{
						pTok->m_Accent = K_HSTAR;
						pTok->m_Accent_Prom = rand() % 5;
						pTok->m_AccentSource = ACC_ContentSeq;
					}
				}
			}
        
        
			delete pTPhrase;
        
			//-----------------------------------------
			// Now, insert the BOUNDARY tags
			//-----------------------------------------
			listPos = m_TokList.GetHeadPosition();
			pPrevTok = m_TokList.GetNext( listPos );
			for( i = 1; i < cTok; i++ )
			{
				pTok = m_TokList.GetNext( listPos );
				//--------------------------------
				// Place a terminal boundary
				//--------------------------------
				if( pTok->m_TuneBoundaryType != NULL_BOUNDARY )
				{
					switch( pTok->m_TuneBoundaryType )
					{
					case YN_QUEST_BOUNDARY:
						{
							pPrevTok->m_Accent = K_LSTAR;
							pPrevTok->m_Accent_Prom = 10;
							pPrevTok->m_Boundary = K_HMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 10;
							//-- Diagnostic
							if( pPrevTok->m_AccentSource == ACC_NoSource )
							{
								pPrevTok->m_AccentSource = ACC_YNQuest;
							}
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_YNQuest;
							}
							//-------------------------------------------------------
							// Accent an aux verb in initial position (possible ynq)
							//-------------------------------------------------------
							if( possible_YNQ )
							{
								pAuxTok->m_Accent = K_HSTAR;
								pAuxTok->m_Accent_Prom = 5;
								pAuxTok->m_AccentSource = ACC_InitialVAux;
							}
						}
						break;
					case WH_QUEST_BOUNDARY:
					case DECLAR_BOUNDARY:
					case EXCLAM_BOUNDARY:
						{
							if (pPrevTok->m_posClass == POS_CONTENT)
							{
								pPrevTok->m_Accent = K_HSTAR;
								pPrevTok->m_Accent_Prom = 4;
								//-- Diagnostic
								if( pPrevTok->m_AccentSource == ACC_NoSource )
								{
									pPrevTok->m_AccentSource = ACC_Period;
								}
							}
							pPrevTok->m_Boundary = K_LMINUSLPERC;
							pPrevTok->m_Boundary_Prom = 10;
							//--- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_Period;
							}
						}
						break;
					case PHRASE_BOUNDARY:
						{
							if (pPrevTok->m_posClass == POS_CONTENT)
							{
								pPrevTok->m_Accent = K_LHSTAR;
								pPrevTok->m_Accent_Prom = 10;
								//-- Diagnostic
								if( pPrevTok->m_AccentSource == ACC_NoSource )
								{
									pPrevTok->m_AccentSource = ACC_Comma;
								}
							}
							pPrevTok->m_Boundary = K_LMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 5;
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_Comma;
							}
						}
						break;
					case NUMBER_BOUNDARY:
						{
							pPrevTok->m_Boundary = K_LMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 5;
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_NumberTemplate;
							}
						}
						break;
					default:
						{
							// Use comma for all other boundaries
							if (pPrevTok->m_posClass == POS_CONTENT)
							{
								pPrevTok->m_Accent = K_LHSTAR;
								pPrevTok->m_Accent_Prom = 10;
								//-- Diagnostic
								if( pPrevTok->m_AccentSource == ACC_NoSource )
								{
									pPrevTok->m_AccentSource = pTok->m_AccentSource;
								}
							}
							pPrevTok->m_Boundary = K_LMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 5;
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = pTok->m_BoundarySource;
							}
						}
						break;
					}
				}
				pPrevTok = pTok;
			}

			//--------------------------------------------
			// Loop through each word and increase 
			// pitch prominence if EMPHASIZED and
			// decrease prominence for all others
			//--------------------------------------------
			if( hasEmph )
			{
				SPLISTPOS listPos;

				pPrevTok = NULL;
				listPos = m_TokList.GetHeadPosition();
				while( listPos )
				{
					pTok = m_TokList.GetNext( listPos );
					//------------------------------
					// Is this word emphasized?
					//------------------------------
					if( pTok->user_Emph > 0 )
					{
						//------------------------------
						// Add my clever H*+L* tag
						//------------------------------
						pTok->m_Accent = K_HSTARLSTAR;
						pTok->m_Accent_Prom = 10;
						pTok->m_Boundary = K_NOBND;			// Delete any boundary tag here... 
						if( pPrevTok )
						{
							pPrevTok->m_Boundary = K_NOBND;	// ...or before
						}
					}
					else
					{
						//-----------------------------------
						// Is non-emphasized word accented?
						//-----------------------------------
						if( (pTok->m_Accent != K_NOACC) && (pTok->m_Accent_Prom > 5) )
						{
							//------------------------------
							// Then clip its prominence at 5
							//------------------------------
							pTok->m_Accent_Prom = 5;
						}
						//------------------------------
						// Is it a boundary?
						//------------------------------
						/*if( (pTok->m_Boundary != K_NOBND) && (pTok->m_Boundary_Prom > 5) )
						{
							//------------------------------
							// Then clip its prominence at 5
							//------------------------------
							pTok->m_Boundary_Prom = 5;
						}*/
					}
					pPrevTok = pTok;
				}
			}
		}
	}
    return S_OK;
} /* ToBISymbols */


/*****************************************************************************
* CFrontend::TokensToAllo *
*------------------------*
*   Description:
*   Transform TOKENS into ALLOS
*       
********************************************************************** MC ***/
HRESULT CFrontend::TokensToAllo( CFETokenList *pTokList, CAlloList *pAllo )
{
    SPDBG_FUNC( "CFrontend::TokToAllo" );
    CAlloCell   *pLastCell;
    long        i;
    long        cTok;
    CFEToken    *pCurToken, *pNextToken, *pPrevTok;
	SPLISTPOS	listPos;

    
    pLastCell = pAllo->GetTailCell();        // Get end (silence)
    if( pLastCell )
    {
		pPrevTok = NULL;
		listPos = pTokList->GetHeadPosition();
		pCurToken = pTokList->GetNext( listPos );
        cTok = pTokList->GetCount();
        for( i = 0; i < cTok; i++ )
        {
			//----------------------------
			// Get NEXT word
			//----------------------------
			if( i < (cTok -1) )
			{
				pNextToken = pTokList->GetNext( listPos );
			}
			else
			{
				pNextToken = NULL;
			}
			if( pAllo->WordToAllo( pPrevTok, pCurToken, pNextToken, pLastCell ) )
			{
				m_HasSpeech = true;
			}
			//----------------------------
			// Bump the pipeline
			//----------------------------
			pPrevTok	= pCurToken;
			pCurToken	= pNextToken;
        }
    }
            
    return S_OK;
    
} /* CFrontend::TokensToAllo */




/*****************************************************************************
* CFrontend::GetItemControls *
*----------------------------*
*   Description:
*   Set user control values from Sent Enum item.
********************************************************************** MC ***/
void CFrontend::GetItemControls( const SPVSTATE* pXmlState, CFEToken* pToken )
{
    SPDBG_FUNC( "CFrontend::GetItemControls" );

    pToken->user_Volume = pXmlState->Volume;
    pToken->user_Rate  = pXmlState->RateAdj;
    pToken->user_Pitch = pXmlState->PitchAdj.MiddleAdj;
    pToken->user_Emph  = pXmlState->EmphAdj;
    pToken->m_DurScale = CntrlToRatio( pToken->user_Rate );
    if( (pToken->m_DurScale * m_RateRatio_API * m_RateRatio_PROSODY) 
				< DISCRETE_BKPT )
    {
        //-- If the total rate is low enough, insert breaks between words
        pToken->m_TermSil = 0.050f / 
			(pToken->m_DurScale * m_RateRatio_API * m_RateRatio_PROSODY);
        pToken->m_DurScale = DISCRETE_BKPT;
    }
	else
	{
		pToken->m_TermSil = 0;
	}

} /* CFrontend::GetItemControls */




/*****************************************************************************
* CFrontend::GetPOSClass *
*------------------------*
*   Description:
*   Transform SAPI POS code to func/content/aux class.
********************************************************************** MC ***/
PROSODY_POS CFrontend::GetPOSClass( ENGPARTOFSPEECH sapiPOS )
{
    SPDBG_FUNC( "CFrontend::GetPOSClass" );
	PROSODY_POS		posClass;

	posClass = POS_UNK;
	switch( sapiPOS )
	{
	case MS_Noun:
	case MS_Verb:
	case MS_Adj:
	case MS_Adv:
	case MS_Interjection:
		{
			posClass = POS_CONTENT;
			break;
		}
	case MS_VAux:
		{
			posClass = POS_AUX;
			break;
		}
	case MS_Modifier:
	case MS_Function:
	case MS_Interr:
	case MS_Pron:
	case MS_ObjPron:
	case MS_SubjPron:
	case MS_RelPron:
	case MS_Conj:
	case MS_CConj:
	case MS_Det:
	case MS_Contr:
	case MS_Prep:
		{
			posClass = POS_FUNC;
			break;
		}
	}

	return posClass;
} /* CFrontend::GetPOSClass */



#define	QUOTE_HESITATION	100		// Number of msec
#define	PAREN_HESITATION	100		// Number of msec
#define	PAREN_HESITATION_TAIL	100		// Number of msec
#define	EMPH_HESITATION	1		// Number of msec

/*****************************************************************************
* CFrontend::StateQuoteProsody *
*------------------------------*
*   Description:
*       
********************************************************************** MC ***/
bool CFrontend::StateQuoteProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil )
{
    SPDBG_FUNC( "CFrontend::StateQuoteProsody" );
	bool		result = false;

	if( !m_fInParenProsody )
	{
		if( m_fInQuoteProsody )
		{
			//------------------------------
			// Stop quote prosody
			//------------------------------
			m_fInQuoteProsody = false;
			m_CurPitchOffs = 0.0f;
			m_CurPitchRange = 1.0f;
			if( fInsertSil )
			{
				(void)InsertSilenceAtTail( pWordTok, pSentItem, QUOTE_HESITATION );
				pWordTok->m_SilenceSource = SIL_QuoteEnd;
			}
		}
		else
		{
			//------------------------------
			// Begin quote prosody
			//------------------------------
			m_fInQuoteProsody = true;
			m_CurPitchOffs = 0.1f;
			m_CurPitchRange = 1.25f;
			if( fInsertSil )
			{
				(void)InsertSilenceAtTail( pWordTok, pSentItem, QUOTE_HESITATION );
				pWordTok->m_SilenceSource = SIL_QuoteStart;
			}
		}
		result = true;
	}
	return result;
} /* CFrontend::StateQuoteProsody */



/*****************************************************************************
* CFrontend::StartParenProsody *
*------------------------------*
*   Description:
*       
********************************************************************** MC ***/
bool CFrontend::StartParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil )
{
    SPDBG_FUNC( "CFrontend::StartParenProsody" );
	bool		result = false;

	if( (!m_fInParenProsody) && (!m_fInQuoteProsody) )
	{
		m_CurPitchOffs = -0.2f;
		m_CurPitchRange = 0.75f;
		m_fInParenProsody = true;
		m_RateRatio_PROSODY = 1.25f;
		if( fInsertSil )
		{
			(void)InsertSilenceAtTail( pWordTok, pSentItem, PAREN_HESITATION );
			pWordTok->m_SilenceSource = SIL_ParenStart;
		}
		result = true;
	}
	return result;
} /* CFrontend::StartParenProsody */


/*****************************************************************************
* CFrontend::EndParenProsody *
*----------------------------*
*   Description:
*       
********************************************************************** MC ***/
bool CFrontend::EndParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil )
{
    SPDBG_FUNC( "CFrontend::EndParenProsody" );
	bool		result = false;

	if( m_fInParenProsody )
	{
		m_fInParenProsody = false;
		m_CurPitchOffs = 0.0f;
		m_CurPitchRange = 1.0f;
		m_RateRatio_PROSODY = 1.0f;
		if( fInsertSil )
		{
			(void)InsertSilenceAtTail( pWordTok, pSentItem, PAREN_HESITATION_TAIL );
			pWordTok->m_SilenceSource = SIL_ParenStart;
		}
		result = true;
	}
	return result;
} /* CFrontend::EndParenProsody */





/*****************************************************************************
* CFrontend::InsertSilenceAtTail *
*--------------------------------*
*   Description:
*       
********************************************************************** MC ***/
SPLISTPOS CFrontend::InsertSilenceAtTail( CFEToken *pWordTok, TTSSentItem *pSentItem, long msec )
{
    SPDBG_FUNC( "CFrontend::InsertSilenceAtTail" );

	if( msec > 0 )
	{
		pWordTok->user_Break = msec;
	}
	pWordTok->phon_Len    = 1;
	pWordTok->phon_Str[0] = _SIL_;
	pWordTok->srcPosition = pSentItem->ulItemSrcOffset;
	pWordTok->srcLen      = pSentItem->ulItemSrcLen;
	pWordTok->tokStr[0]   = 0;        // There's no orth for Break
	pWordTok->tokLen      = 0;
	pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
	pWordTok->m_PitchRangeScale = m_CurPitchRange;
	pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;
	//----------------------------------
	// Advance to next token
	//----------------------------------
	return m_TokList.AddTail( pWordTok );
} /* CFrontend::InsertSilenceAtTail */



/*****************************************************************************
* CFrontend::InsertSilenceAfterPos  *
*-----------------------------------*
*   Description:
*	Insert silence token AFTER 'position'
*       
********************************************************************** MC ***/
SPLISTPOS CFrontend::InsertSilenceAfterPos( CFEToken *pWordTok, SPLISTPOS position )
{
    SPDBG_FUNC( "CFrontend::InsertSilenceAfterPos" );

	pWordTok->phon_Len		= 1;
	pWordTok->phon_Str[0]	= _SIL_;
	pWordTok->srcPosition	= 0;
	pWordTok->srcLen		= 0;
	pWordTok->tokStr[0]		= '+';      // punctuation
	pWordTok->tokStr[1]		= 0;                   // delimiter
	pWordTok->tokLen		= 1;
	pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
	pWordTok->m_PitchRangeScale = m_CurPitchRange;
	pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;
	pWordTok->m_DurScale	= 0;
	//----------------------------------
	// Advance to next token
	//----------------------------------
	return m_TokList.InsertAfter( position, pWordTok );
} /* CFrontend::InsertSilenceAfterPos */


/*****************************************************************************
* CFrontend::InsertSilenceBeforePos  *
*------------------------------------*
*   Description:
*	Insert silence token BEFORE 'position'
*       
********************************************************************** MC ***/
SPLISTPOS CFrontend::InsertSilenceBeforePos( CFEToken *pWordTok, SPLISTPOS position )
{
    SPDBG_FUNC( "CFrontend::InsertSilenceBeforePos" );

	pWordTok->phon_Len		= 1;
	pWordTok->phon_Str[0]	= _SIL_;
	pWordTok->srcPosition	= 0;
	pWordTok->srcLen		= 0;
	pWordTok->tokStr[0]		= '+';      // punctuation
	pWordTok->tokStr[1]		= 0;                   // delimiter
	pWordTok->tokLen		= 1;
	pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
	pWordTok->m_PitchRangeScale = m_CurPitchRange;
	pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;
	pWordTok->m_DurScale	= 0;
	//----------------------------------
	// Advance to next token
	//----------------------------------
	return m_TokList.InsertBefore( position, pWordTok );
} /* CFrontend::InsertSilenceBeforePos */






#define K_ACCENT_PROM	((rand() % 4) + 4)
#define K_DEACCENT_PROM 5
#define K_ACCENT		K_HSTAR
#define K_DEACCENT		K_NOACC



/*****************************************************************************
* CFrontend::ProsodyTemplates *
*-----------------------------*
*   Description:
*   Call prosody template function for supported item types.
*       
********************************************************************** MC ***/
void CFrontend::ProsodyTemplates( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::ProsodyTemplates" );
	long				cWordCount;
	CFEToken			*pClusterTok;

	switch( pSentItem->pItemInfo->Type )
	{
		//---------------------------------------
		// Numbers
		//---------------------------------------
        case eNUM_ROMAN_NUMERAL:
		case eNUM_ROMAN_NUMERAL_ORDINAL:
            {
                if ( ( (TTSRomanNumeralItemInfo*) pSentItem->pItemInfo )->pNumberInfo->Type != eDATE_YEAR )
                {
                    if ( ((TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo)->pIntegerPart )
                    {
                        DoIntegerTemplate( &clusterPos, 
	    								   (TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo, 
		    							   pSentItem->ulNumWords );
                    }

                    if ( ((TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo)->pDecimalPart )
                    {
                        DoNumByNumTemplate( &clusterPos, 
                                            ((TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo)->pDecimalPart->ulNumDigits );
                    }
                }
            }
        break;

		case eNUM_CARDINAL:
		case eNUM_DECIMAL:
		case eNUM_ORDINAL:
		case eNUM_MIXEDFRACTION:
			{
                if ( ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pIntegerPart )
                {
    				cWordCount = DoIntegerTemplate( &clusterPos, 
	    											(TTSNumberItemInfo*) pSentItem->pItemInfo, 
		    										pSentItem->ulNumWords );
                }

                if( ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pDecimalPart )
                {
					//-----------------------------------------
					// Skip "point" string...
					//-----------------------------------------
					(void) m_TokList.GetNext( clusterPos );
					//-----------------------------------------
					// ...and do single digit prosody
					//-----------------------------------------
				    DoNumByNumTemplate( &clusterPos, 
                                        ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pDecimalPart->ulNumDigits );
                }

                if ( ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pFractionalPart )
                {
					//-----------------------------------------
					// Skip "and" string...
					//-----------------------------------------
					pClusterTok = m_TokList.GetNext( clusterPos );
 					if( pClusterTok->m_Accent == K_NOACC )
					{
						//--------------------------------------
						// Force POS for "and" to noun 
						//  so phrasing rules don't kick in!
						//--------------------------------------
						pClusterTok->m_Accent = K_DEACCENT;
						pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
						pClusterTok->POScode = MS_Noun;
						pClusterTok->m_posClass = POS_CONTENT;
					}
					//-----------------------------------------
					// ...and do fraction prosody
					//-----------------------------------------
    				cWordCount = DoFractionTemplate( &clusterPos, 
	    											(TTSNumberItemInfo*) pSentItem->pItemInfo, 
		    										pSentItem->ulNumWords );
                }
			}
        break;

		//---------------------------------------
		// Fraction
		//---------------------------------------
		case eNUM_FRACTION:
			{
    			cWordCount = DoFractionTemplate( &clusterPos, 
	    										(TTSNumberItemInfo*) pSentItem->pItemInfo, 
		    									pSentItem->ulNumWords );
			}
		break;

		//---------------------------------------
		// Money
		//---------------------------------------
		case eNUM_CURRENCY:
			{
				 DoCurrencyTemplate( clusterPos, pSentItem );
			}
		break;

		//---------------------------------------
		// Phone Numbers
		//---------------------------------------
		case eNUM_PHONENUMBER:
		case eNEWNUM_PHONENUMBER:
			{
				DoPhoneNumberTemplate( clusterPos, pSentItem );
			}
		break;

		//---------------------------------------
		// Time-of-Day
		//---------------------------------------
		case eTIMEOFDAY:
			{
				DoTODTemplate( clusterPos, pSentItem );
			}
		break;

		case eELLIPSIS:
			{
				CFEToken	*pWordTok;

				pWordTok = new CFEToken;
				if( pWordTok )
				{
					clusterPos = InsertSilenceAtTail( pWordTok, pSentItem, 0 );
					//clusterPos = m_TokList.GetTailPosition( );
					//clusterPos = InsertSilenceAfterPos( pWordTok, clusterPos );
					pWordTok->m_SilenceSource = SIL_Ellipsis;
					pWordTok->m_TuneBoundaryType = ELLIPSIS_BOUNDARY;
					pWordTok->m_BoundarySource = BND_Ellipsis;
				}
			}
		break;
	}

} /* CFrontend::ProsodyTemplates */




/*****************************************************************************
* CFrontend::DoTODTemplate *
*--------------------------*
*   Description:
*   Prosody template for time-of-day.
* 
*	TODO: Temp kludge - needs more info in TTSTimeOfDayItemInfo    
********************************************************************** MC ***/
void CFrontend::DoTODTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::DoTODTemplate" );
	TTSTimeOfDayItemInfo	*pTOD;
	CFEToken				*pWordTok;
	CFEToken				*pClusterTok;
	SPLISTPOS				curPos, nextPos, prevPos;


	curPos = nextPos = clusterPos;
	pTOD = (TTSTimeOfDayItemInfo*)&pSentItem->pItemInfo->Type;

	// Can't do 24 hr because there's no way to tell 
	// if it's 1 or 2 digits (18: vs 23:)
	if( !pTOD->fTwentyFourHour )
	{
		//-------------------------------------
		// Get HOUR token
		//-------------------------------------
		pClusterTok = m_TokList.GetNext( nextPos );
		//-------------------------------------
		// Accent hour
		//-------------------------------------
		pClusterTok->m_Accent = K_ACCENT;
		pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
		pClusterTok->m_AccentSource = ACC_TimeOFDay_HR;

		//---------------------------------
		// Insert SILENCE after hour
		//---------------------------------
		pWordTok = new CFEToken;
		if( pWordTok )
		{
			nextPos = InsertSilenceAfterPos( pWordTok, clusterPos );
			pWordTok->m_SilenceSource = SIL_TimeOfDay_HR;
			pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
			pWordTok->m_BoundarySource = BND_TimeOFDay_HR;
			pWordTok = NULL;
			//----------------------------
			// Skip last digit
			//----------------------------
			if( clusterPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
		}
		if( pTOD->fMinutes )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			//-------------------------------------
			// Accent 1st digit for minutes
			//-------------------------------------
			pClusterTok->m_Accent = K_ACCENT;
			pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
			pClusterTok->m_AccentSource = ACC_TimeOFDay_1stMin;
		}

		if( pTOD->fTimeAbbreviation )
		{
			curPos = prevPos = m_TokList.GetTailPosition( );
			pClusterTok = m_TokList.GetPrev( prevPos );
			pWordTok = new CFEToken;
			if( pWordTok )
			{
				prevPos = InsertSilenceBeforePos( pWordTok, prevPos );
				pWordTok->m_SilenceSource = SIL_TimeOfDay_AB;
				pWordTok->m_TuneBoundaryType = TOD_BOUNDARY;
				pWordTok->m_BoundarySource = BND_TimeOFDay_AB;
				pWordTok = NULL;
				//pClusterTok = m_TokList.GetNext( clusterPos );
				//pClusterTok = m_TokList.GetNext( clusterPos );
			}
			//-------------------------------------
			// Accent "M"
			//-------------------------------------
			pClusterTok = m_TokList.GetNext( curPos );
			pClusterTok->m_Accent = K_ACCENT;
			pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
			pClusterTok->m_AccentSource = ACC_TimeOFDay_M;
		}
	}
} /* CFrontend::DoTODTemplate */





CFEToken *CFrontend::InsertPhoneSilenceAtSpace( SPLISTPOS *pClusterPos, 
												BOUNDARY_SOURCE bndSrc, 
												SILENCE_SOURCE	silSrc )
{
	CFEToken		*pWordTok;
	SPLISTPOS		curPos, nextPos;

	curPos = nextPos = *pClusterPos;
	//---------------------------------
	// Insert SILENCE after area code
	//---------------------------------
	pWordTok = new CFEToken;
	if( pWordTok )
	{
		nextPos = InsertSilenceBeforePos( pWordTok, curPos );
		pWordTok->m_SilenceSource = silSrc;
		pWordTok->m_TuneBoundaryType = PHONE_BOUNDARY;
		pWordTok->m_BoundarySource = bndSrc;
		pWordTok->m_AccentSource = ACC_PhoneBnd_AREA;		// @@@@ ???
		pWordTok = NULL;
		//----------------------------
		// Skip last digit
		//----------------------------
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pWordTok = m_TokList.GetNext( nextPos );
		}
	}
	//pWordTok = m_TokList.GetNext( clusterPos );
	//-----------------------------------------
	// Filter and embedded silences
	//-----------------------------------------
	while( (pWordTok->phon_Str[0] == _SIL_) && (nextPos != NULL) )
	{
		curPos = nextPos;
		pWordTok = m_TokList.GetNext( nextPos );
	}
	*pClusterPos = curPos;

	return pWordTok;
}




void CFrontend::InsertPhoneSilenceAtEnd( BOUNDARY_SOURCE bndSrc, 
										 SILENCE_SOURCE	silSrc )
{
	CFEToken		*pWordTok;
	SPLISTPOS		curPos, nextPos;

	curPos = m_TokList.GetTailPosition( );
	//---------------------------------
	// Insert SILENCE after area code
	//---------------------------------
	pWordTok = new CFEToken;
	if( pWordTok )
	{
		nextPos = InsertSilenceAfterPos( pWordTok, curPos );
		pWordTok->m_SilenceSource = silSrc;
		pWordTok->m_TuneBoundaryType = PHONE_BOUNDARY;
		pWordTok->m_BoundarySource = bndSrc;
		pWordTok->m_AccentSource = ACC_PhoneBnd_AREA;		// @@@@ ???
	}
}








/*****************************************************************************
* CFrontend::DoPhoneNumberTemplate *
*----------------------------------*
*   Description:
*   Prosody template for phone numbers.
*       
********************************************************************** MC ***/
void CFrontend::DoPhoneNumberTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::DoPhoneNumberTemplate" );
	TTSPhoneNumberItemInfo	*pFone;
	CFEToken				*pClusterTok;
	long					cWordCount;
	SPLISTPOS				curPos, nextPos;

	curPos = nextPos = clusterPos;
	pFone = (TTSPhoneNumberItemInfo*)&pSentItem->pItemInfo->Type;

	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// COUNTRY CODE
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	if( pFone->pCountryCode )
	{
		//-------------------------------------
		// Skip "country" and...
		//-------------------------------------
		curPos = nextPos;
		pClusterTok = m_TokList.GetNext( nextPos );
		
		//-------------------------------------
		// ...skip "code"
		//-------------------------------------
		curPos = nextPos;
		pClusterTok = m_TokList.GetNext( nextPos );

		cWordCount = DoIntegerTemplate( &nextPos, 
										pFone->pCountryCode, 
										pSentItem->ulNumWords );
		pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_COUNTRY, SIL_Phone_COUNTRY );
	}
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// "One"
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	if( pFone->fOne )
	{
		//-------------------------------------
		// Skip "One"
		//-------------------------------------
		curPos = nextPos;
		pClusterTok = m_TokList.GetNext( nextPos );
		//-------------------------------------
		// and add silence
		//-------------------------------------
		pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_ONE, SIL_Phone_ONE );
		
	}
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// AREA CODE
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	if( pFone->pAreaCode )
	{

		if( (pFone->fIs800) && nextPos )
		{
			//--------------------------
			// Skip digit
			//--------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			//--------------------------
			// Skip "hundred"
			//--------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			if( nextPos )
			{
				pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_AREA, SIL_Phone_AREA );
			}
		}
		else
		{
			//-------------------------------------
			// Skip "area" and...
			//-------------------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			//-------------------------------------
			// ...skip "code"
			//-------------------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );

			DoNumByNumTemplate( &nextPos, pFone->pAreaCode->ulNumDigits );
			if( nextPos )
			{
				pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_AREA, SIL_Phone_AREA );
			}
		}
	}
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// Digits
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	unsigned long		i;

	for( i = 0; i < pFone->ulNumGroups; i++ )
	{
		DoNumByNumTemplate( &nextPos, pFone->ppGroups[i]->ulNumDigits );
		if( nextPos )
		{
			pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_DIGITS, SIL_Phone_DIGITS );
		}
	}
	InsertPhoneSilenceAtEnd( BND_Phone_DIGITS, SIL_Phone_DIGITS );
} /* CFrontend::DoPhoneNumberTemplate */

/*****************************************************************************
* CFrontend::DoCurrencyTemplate *
*-------------------------------*
*   Description:
*   Prosody template for currency.
*       
********************************************************************** MC ***/
void CFrontend::DoCurrencyTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::DoCurrencyTemplate" );
	TTSCurrencyItemInfo		*pMoney;
	CFEToken				*pWordTok;
	CFEToken				*pClusterTok = NULL;
	long					cWordCount;
	SPLISTPOS				curPos, nextPos;

	pMoney = (TTSCurrencyItemInfo*)&pSentItem->pItemInfo->Type;

	curPos = nextPos = clusterPos;
	if( pMoney->pPrimaryNumberPart->Type != eNUM_CARDINAL )
	{
		return;
	}
	cWordCount = DoIntegerTemplate( &nextPos, 
									pMoney->pPrimaryNumberPart, 
									pSentItem->ulNumWords );
	curPos = nextPos;
	if( cWordCount > 1 )
	{
		if( pMoney->fQuantifier )
		{
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
			cWordCount--;
		}
	}
	if( cWordCount > 1 )
	{
		//---------------------------------
		// Insert SILENCE after "dollars"
		//---------------------------------
		pWordTok = new CFEToken;
		if( pWordTok )
		{
			nextPos = InsertSilenceAfterPos( pWordTok, curPos );
			pWordTok->m_SilenceSource = SIL_Currency_DOLLAR;
			pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
			pWordTok->m_BoundarySource = BND_Currency_DOLLAR;
			pWordTok = NULL;
			//----------------------------
			// Skip "dollar(s)"
			//----------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
		}
		if( pMoney->pSecondaryNumberPart != NULL )
		{
			//----------------------------
			// Skip SILENCE
			//----------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
			cWordCount--;
			//----------------------------
			// Skip AND
			//----------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
 				if( pClusterTok->m_Accent == K_NOACC )
				{
					//--------------------------------------
					// Force POS for "and" to noun 
					//  so phrasing rules don't kick in!
					//--------------------------------------
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
					pClusterTok->POScode = MS_Noun;
					pClusterTok->m_posClass = POS_CONTENT;
				}
				pClusterTok = m_TokList.GetNext( nextPos );
			}
			cWordCount--;
			cWordCount = DoIntegerTemplate( &curPos, 
											pMoney->pSecondaryNumberPart, 
											cWordCount );
		}
	}
} /* CFrontend::DoCurrencyTemplate */





/*****************************************************************************
* CFrontend::DoNumByNumTemplate *
*---------------------------------*
*   Description:
*   Prosody template for RIGHT hand side of the decimal point.
*       
********************************************************************** MC ***/
void CFrontend::DoNumByNumTemplate( SPLISTPOS *pClusterPos, long cWordCount )
{
    SPDBG_FUNC( "CFrontend::DoNumByNumTemplate" );
	CFEToken			*pClusterTok;
	SPLISTPOS			curPos, nextPos;

	curPos = nextPos = *pClusterPos;
	while( cWordCount > 1 )
	{
		pClusterTok = NULL;
		//-------------------------------------------------------------
		// Right side of decimal point - add H* to every other word 
		//-------------------------------------------------------------
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
		}
		cWordCount--;

		if( pClusterTok )
		{
			pClusterTok->m_Accent = K_ACCENT;
			pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
			pClusterTok->m_AccentSource = ACC_NumByNum;
		}
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
		}
		cWordCount--;
	}
	if( cWordCount > 0 )
	{
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
		}
		cWordCount--;
	}
	*pClusterPos = nextPos;
} /* CFrontend::DoNumByNumTemplate */






/*****************************************************************************
* CFrontend::DoFractionTemplate *
*------------------------------*
*   Description:
*   Prosody template for RIGHT side of the decimal point.
*       
********************************************************************** MC ***/
long CFrontend::DoFractionTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount )
{
    SPDBG_FUNC( "CFrontend::DoFractionTemplate" );
	CFEToken				*pClusterTok;
	TTSFractionItemInfo	    *pFInfo;
	CFEToken				*pWordTok;

	pFInfo = pNInfo->pFractionalPart;

    //--- Do Numerator...
    if ( pFInfo->pNumerator->pIntegerPart )
    {
    	cWordCount = DoIntegerTemplate( pClusterPos, pFInfo->pNumerator, cWordCount );
    }
    if( pFInfo->pNumerator->pDecimalPart )
    {
		//-----------------------------------------
		// Skip "point" string...
		//-----------------------------------------
		(void) m_TokList.GetNext( *pClusterPos );
		//-----------------------------------------
		// ...and do single digit prosody
		//-----------------------------------------
		DoNumByNumTemplate( pClusterPos, pFInfo->pNumerator->pDecimalPart->ulNumDigits );
    }

    //--- Special case - a non-standard fraction (e.g. 1/4)
	if( !pFInfo->fIsStandard )
	{
		if( !*pClusterPos )
		{
			*pClusterPos = m_TokList.GetTailPosition( );
		}
		else
		{
			pClusterTok = m_TokList.GetPrev( *pClusterPos );
		}
	}

	pWordTok = new CFEToken;
	if( pWordTok )
	{
		*pClusterPos = InsertSilenceBeforePos( pWordTok, *pClusterPos );
		pWordTok->m_SilenceSource = SIL_Fractions_NUM;
		pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
		pWordTok->m_BoundarySource = BND_Frac_Num;
		pWordTok = NULL;
		//----------------------------
		// Skip numerator
		//----------------------------
		if( *pClusterPos != NULL )
		{
			pClusterTok = m_TokList.GetNext( *pClusterPos );
		}
	}

    //--- Do Denominator...
    if ( pFInfo->pDenominator->pIntegerPart )
    {
		//-----------------------------------------
		// Skip "over" string...
		//-----------------------------------------
		pClusterTok = m_TokList.GetNext( *pClusterPos );
 		if( pClusterTok->m_Accent == K_NOACC )
		{
			//--------------------------------------
			// Force POS for "and" to noun 
			//  so phrasing rules don't kick in!
			//--------------------------------------
			pClusterTok->m_Accent = K_DEACCENT;
			pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
			pClusterTok->POScode = MS_Noun;
			pClusterTok->m_posClass = POS_CONTENT;
		}
    	cWordCount = DoIntegerTemplate( pClusterPos, pFInfo->pDenominator, cWordCount );
    }
    if( pFInfo->pDenominator->pDecimalPart )
    {
		//-----------------------------------------
		// Skip "point" string...
		//-----------------------------------------
		(void) m_TokList.GetNext( *pClusterPos );
		//-----------------------------------------
		// ...and do single digit prosody
		//-----------------------------------------
		DoNumByNumTemplate( pClusterPos, pFInfo->pDenominator->pDecimalPart->ulNumDigits );
    }

	return cWordCount;
} /* CFrontend::DoFractionTemplate */




/*****************************************************************************
* CFrontend::DoIntegerTemplate *
*------------------------------*
*   Description:
*   Prosody template for LEFT hand side of the decimal point.
*       
********************************************************************** MC ***/
long CFrontend::DoIntegerTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount )
{
    SPDBG_FUNC( "CFrontend::DoIntegerTemplate" );
	long				i;
	CFEToken			*pClusterTok;
    CFEToken			*pWordTok = NULL;
	SPLISTPOS			curPos, nextPos;

	//------------------------------------------
	// Special currency hack...sorry
	//------------------------------------------
	if( pNInfo->pIntegerPart->fDigitByDigit )
	{
		DoNumByNumTemplate( pClusterPos, pNInfo->pIntegerPart->ulNumDigits );
		return cWordCount - pNInfo->pIntegerPart->ulNumDigits;
	}

	nextPos = curPos = *pClusterPos;
	pClusterTok = m_TokList.GetNext( nextPos );
	pClusterTok->m_Accent = K_DEACCENT;
	pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
	if( pNInfo->fNegative )
	{
		//---------------------------------
		// Skip "NEGATIVE"
		//---------------------------------
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			pClusterTok->m_Accent = K_DEACCENT;
			pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
		}
		cWordCount--;
	}
	for( i = (pNInfo->pIntegerPart->lNumGroups -1); i >= 0; i-- )
	{
		//------------------------------------
		// Accent 1st digit in group
		//------------------------------------
		pClusterTok->m_Accent = K_ACCENT;
		pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
		pClusterTok->m_AccentSource = ACC_IntegerGroup;


		if( pNInfo->pIntegerPart->Groups[i].fHundreds )
		{
			//---------------------------------
			// Skip "X HUNDRED"
			//---------------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
		}
		if( pNInfo->pIntegerPart->Groups[i].fTens )
		{
			//---------------------------------
			// Skip "X-TY"
			//---------------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
		}
		if( pNInfo->pIntegerPart->Groups[i].fOnes )
		{
			//---------------------------------
			// Skip "X"
			//---------------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
		}
		if( pNInfo->pIntegerPart->Groups[i].fQuantifier )
		{
			//---------------------------------
			// Insert SILENCE after quant
			//---------------------------------
			if( pWordTok == NULL )
			{
				pWordTok = new CFEToken;
			}
			if( pWordTok )
			{
				nextPos = InsertSilenceAfterPos( pWordTok, curPos );
				pWordTok->m_SilenceSource = SIL_Integer_Quant;
				pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
				pWordTok->m_BoundarySource = BND_IntegerQuant;
				pWordTok = NULL;
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
				if( nextPos != NULL )
				{
					//------------------------------
					// Skip inserted silence
					//------------------------------
					curPos = nextPos;
					pClusterTok = m_TokList.GetNext( nextPos );
				}
				if( nextPos != NULL )
				{
					//-----------------------------------
					// Skip quantifier string
					//-----------------------------------
					curPos = nextPos;
					pClusterTok = m_TokList.GetNext( nextPos );
				}
				cWordCount--;
			}
		}
	}

	*pClusterPos = curPos;
	return cWordCount;
} /* CFrontend::DoIntegerTemplate */






/*****************************************************************************
* CFrontend::GetSentenceTokens *
*------------------------------*
*   Description:
*   Collect Senence Enum tokens.
*   Copy tokens into 'm_TokList' and token count into 'm_cNumOfWords'
*   S_FALSE return means no more input sentences.+++
*       
********************************************************************** MC ***/
HRESULT CFrontend::GetSentenceTokens( DIRECTION eDirection )
{
    SPDBG_FUNC( "CFrontend::GetSentenceTokens" );
    HRESULT        eHR = S_OK;
    bool			fLastItem = false;
    IEnumSENTITEM  *pItemizer;
    TTSSentItem    sentItem;
    long           tokenIndex;
    CFEToken       *pWordTok;
    bool           lastWasTerm = false;
	bool			lastWasSil = true;
	TUNE_TYPE		defaultTune = PHRASE_BOUNDARY;
	long			cNumOfItems, cCurItem, cCurWord;
	SPLISTPOS		clusterPos, tempPos;

    m_cNumOfWords = 0;
    pWordTok = NULL;
	clusterPos = NULL;

    if ( eDirection == eNEXT )
    {
        eHR = m_pEnumSent->Next( &pItemizer );
    }
    else
    {
        eHR = m_pEnumSent->Previous( &pItemizer );
    }


    if( eHR == S_OK )
    {
        //--------------------------------------------
        // There's still another sentence to speak
        //--------------------------------------------
        tokenIndex = 0;

		CItemList& ItemList = ((CSentItemEnum*)pItemizer)->_GetList(); 
		cNumOfItems = (ItemList.GetCount()) -1;
		cCurItem = 0;
		
        //------------------------------------
        // Collect all sentence tokens
        //------------------------------------
        while( (eHR = pItemizer->Next( &sentItem )) == S_OK )
        {
			clusterPos = NULL;
            cCurWord = sentItem.ulNumWords;
            for ( ULONG i = 0; i < sentItem.ulNumWords; i++ )
            {
				//------------------------------
				// Always have a working token
				//------------------------------
				if( pWordTok == NULL )
				{
					pWordTok = new CFEToken;
				}
				if( pWordTok )
				{

					if( sentItem.pItemInfo->Type & eWORDLIST_IS_VALID )
					{
						//------------------------------------------
						// Get tag values (vol, rate, pitch, etc.)
						//------------------------------------------
						GetItemControls( sentItem.Words[i].pXmlState, pWordTok );

						//------------------------------------------
						// 
						//------------------------------------------
						
						//-------------------------------------
						// Switch on token type
						//-------------------------------------
						switch ( sentItem.Words[i].pXmlState->eAction )
						{
							case SPVA_Speak:
							case SPVA_SpellOut:
							{
								//----------------------------------
								// Speak this token
								//----------------------------------
								pWordTok->tokLen = sentItem.Words[i].ulWordLen;
								if( pWordTok->tokLen > (TOKEN_LEN_MAX -1) )
								{
									//-----------------------------------
									// Clip to max string length
									//-----------------------------------
									pWordTok->tokLen = TOKEN_LEN_MAX -1;
								}
								//--------------------------
								// Copy token string
								// Append C-string delimiter
								//--------------------------
								memcpy( &pWordTok->tokStr[0], &sentItem.Words[i].pWordText[0], 
										pWordTok->tokLen * sizeof(WCHAR) );
								pWordTok->tokStr[pWordTok->tokLen] = 0;        //string delimiter

								pWordTok->phon_Len = IPA_to_Allo( sentItem.Words[i].pWordPron, 
																	pWordTok->phon_Str );
								pWordTok->POScode = sentItem.Words[i].eWordPartOfSpeech;
								pWordTok->m_posClass = GetPOSClass( pWordTok->POScode );
								pWordTok->srcPosition = sentItem.ulItemSrcOffset;
								pWordTok->srcLen = sentItem.ulItemSrcLen;
								pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
								pWordTok->m_PitchRangeScale = m_CurPitchRange;
								pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;

								//----------------------------------
								// Advance to next token
								//----------------------------------
								tempPos = m_TokList.AddTail( pWordTok );
								if( clusterPos == NULL )
								{
									//--------------------------------------
									// Remember where currentitem started
									//--------------------------------------
									clusterPos = tempPos;
								}
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = false;
								lastWasSil = false;
								
								break;
							}

							case SPVA_Silence:
							{
								(void)InsertSilenceAtTail( pWordTok, &sentItem, sentItem.Words[i].pXmlState->SilenceMSecs );
								pWordTok->m_SilenceSource = SIL_XML;
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = false;
								break;
							}

							case SPVA_Pronounce:
							{
								pWordTok->tokStr[0] = 0;        // There's no orth for Pron types
								pWordTok->tokLen = 0;
								pWordTok->phon_Len = IPA_to_Allo( sentItem.Words[i].pXmlState->pPhoneIds, pWordTok->phon_Str );
								pWordTok->POScode = sentItem.Words[i].eWordPartOfSpeech;
								pWordTok->m_posClass = GetPOSClass( pWordTok->POScode );
								pWordTok->srcPosition = sentItem.ulItemSrcOffset;
								pWordTok->srcLen = sentItem.ulItemSrcLen;
								pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
								pWordTok->m_PitchRangeScale = m_CurPitchRange;
								pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;

								//----------------------------------
								// Advance to next token
								//----------------------------------
								tempPos = m_TokList.AddTail( pWordTok );
								if( clusterPos == NULL )
								{
									//--------------------------------------
									// Remember where currentitem started
									//--------------------------------------
									clusterPos = tempPos;
								}
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = false;
								lastWasSil = false;
								break;
							}

							case SPVA_Bookmark:
							{
								BOOKMARK_ITEM   *pMarker;
								//-------------------------------------------------
								// Create bookmark list if it's not already there
								//-------------------------------------------------
								if( pWordTok->pBMObj == NULL )
								{
									pWordTok->pBMObj = new CBookmarkList;
								}
								if( pWordTok->pBMObj )
								{
									//--------------------------------------------------------
									// Allocate memory for bookmark string
									// (add 1 to length for string delimiter)
									//--------------------------------------------------------
									pWordTok->tokLen = sentItem.Words[i].ulWordLen;
									pMarker = new BOOKMARK_ITEM;
									if (pMarker)
									{
										//----------------------------------------
										// We'll need the text ptr and length
										// when this bookmark event gets posted
										//----------------------------------------
										pMarker->pBMItem = (LPARAM)sentItem.pItemSrcText;
										//--- Punch NULL character into end of bookmark string for Event...
										WCHAR* pTemp = (WCHAR*) sentItem.pItemSrcText + sentItem.ulItemSrcLen;
										*pTemp = 0;

										//-----------------------------------
										// Add this bookmark to list
										//-----------------------------------
										pWordTok->pBMObj->m_BMList.AddTail( pMarker );
									}
								}
								break;
							}

							default:
							{
								SPDBG_DMSG1( "Unknown SPVSTATE eAction: %d\n", sentItem.Words[i].pXmlState->eAction );
								break;
							}
						}
					}
					else
					{
						//-----------------------------
						// Maybe token is punctuation
						//-----------------------------
						if ( fIsPunctuation(sentItem) )
						{
							TUNE_TYPE    bType = NULL_BOUNDARY;

							switch ( sentItem.pItemInfo->Type )
							{
								case eCOMMA:
								case eSEMICOLON:
								case eCOLON:
									if( !lastWasSil )
									{
										bType = PHRASE_BOUNDARY;
									}
									break;
								case ePERIOD:
									if( fLastItem )
									{
										bType = DECLAR_BOUNDARY;
									}
									else
									{
										defaultTune = DECLAR_BOUNDARY;
									}
									break;
								case eQUESTION:
									if( fLastItem )
									{
										bType = YN_QUEST_BOUNDARY;
									}
									else
									{
										defaultTune = YN_QUEST_BOUNDARY;
									}
									break;
								case eEXCLAMATION:
									if( fLastItem )
									{
										bType = EXCLAM_BOUNDARY;
									}
									else
									{
										defaultTune = EXCLAM_BOUNDARY;
									}
									break;
							}

							if( (bType != NULL_BOUNDARY) && (tokenIndex > 0) )
							{
								pWordTok->m_TuneBoundaryType = bType;

								pWordTok->phon_Len = 1;
								pWordTok->phon_Str[0] = _SIL_;
								pWordTok->srcPosition = sentItem.ulItemSrcOffset;
								pWordTok->srcLen = sentItem.ulItemSrcLen;
								pWordTok->tokStr[0] = sentItem.pItemSrcText[0]; // punctuation
								pWordTok->tokStr[1] = 0;                       // delimiter
								pWordTok->tokLen = 1;
								pWordTok->m_SilenceSource = SIL_Term;
								pWordTok->m_TermSil = 0;
								//----------------------------------
								// Advance to next token
								//----------------------------------
								tempPos = m_TokList.AddTail( pWordTok );
								if( clusterPos == NULL )
								{
									//--------------------------------------
									// Remember where currentitem started
									//--------------------------------------
									clusterPos = tempPos;
								}
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = true;
								lastWasSil = true;
							}
						}
						else
						{
							switch ( sentItem.pItemInfo->Type )
							{
								//case eSINGLE_QUOTE:
								case eDOUBLE_QUOTE:
									if( StateQuoteProsody( pWordTok, &sentItem, (!fLastItem) & (!lastWasSil) ) )
									{
										if( (!fLastItem) & (!lastWasSil) )
										{
											pWordTok = NULL;         // Get a new ptr next time
											tokenIndex++;
										}
										lastWasTerm = false;
										lastWasSil = true;
									}
									break;

								case eOPEN_PARENTHESIS:
								case eOPEN_BRACKET:
								case eOPEN_BRACE:
									if( StartParenProsody( pWordTok, &sentItem, !fLastItem ) )
									{
										if( !fLastItem )
										{
											pWordTok = NULL;         // Get a new ptr next time
											tokenIndex++;
										}
										lastWasTerm = false;
										lastWasSil = true;
									}
									break;

								case eCLOSE_PARENTHESIS:
								case eCLOSE_BRACKET:
								case eCLOSE_BRACE:
									if( EndParenProsody( pWordTok, &sentItem, !fLastItem ) )
									{
										if( !fLastItem )
										{
											pWordTok = NULL;         // Get a new ptr next time
											tokenIndex++;
										}
										lastWasTerm = false;
										lastWasSil = true;
									}
									break;
							}
						}
					}
				}    
				else
				{
					eHR = E_OUTOFMEMORY;
					break;
				}
				if( --cCurWord == 0 )
				{
					cCurItem++;
				}
				if( cCurItem == cNumOfItems )
				{
					fLastItem = true;
				}
			}
			
			//-------------------------------------
			// Tag special word clusters
			//-------------------------------------
			ProsodyTemplates( clusterPos, &sentItem );
			
		}

        pItemizer->Release();

        //------------------------------------------------------
        // Make sure sentence ends on termination
        //------------------------------------------------------
        if( !lastWasTerm )
        {
            //------------------------
            // Add a comma
            //------------------------
            if( pWordTok == NULL )
            {
                pWordTok = new CFEToken;
            }
            if( pWordTok )
            {
                pWordTok->m_TuneBoundaryType = defaultTune;
				pWordTok->m_BoundarySource = BND_ForcedTerm;
				pWordTok->m_SilenceSource = SIL_Term;
                pWordTok->phon_Len = 1;
                pWordTok->phon_Str[0] = _SIL_;
                pWordTok->srcPosition = sentItem.ulItemSrcOffset;
                pWordTok->srcLen = sentItem.ulItemSrcLen;
                pWordTok->tokStr[0] = '.';      // punctuation
                pWordTok->tokStr[1] = 0;                   // delimiter
                pWordTok->tokLen = 1;
               // pWordTok->m_BoundarySource = bndSource;
                //----------------------------------
                // Advance to next token
                //----------------------------------
				tempPos = m_TokList.AddTail( pWordTok );
				if( clusterPos == NULL )
				{
					//--------------------------------------
					// Remember where current item started
					//--------------------------------------
					clusterPos = tempPos;
				}
                pWordTok = NULL;         // Get a new ptr next time
                tokenIndex++;
            }
            else
            {
                //----------------------------------
                // Bail-out or we'll crash
                //----------------------------------
                eHR = E_OUTOFMEMORY;
            }
        }
        m_cNumOfWords = tokenIndex;
        if( eHR == S_FALSE )
        {
            //----------------------------------
            // Return only errors 
            //----------------------------------
            eHR = S_OK;
        }
    }
	else
	{
		eHR = eHR;		// !!!!
	}

    //-------------------------------
    // Cleanup memory allocation
    //-------------------------------
    if( pWordTok != NULL )
    {
        delete pWordTok;
    }

	//---------------------------------------------------
	// Get sentence position and length for SAPI events
	//---------------------------------------------------
	CalcSentenceLength();

    return eHR;
} /* CFrontend::GetSentenceTokens */





/*****************************************************************************
* CFrontend::CalcSentenceLength *
*-------------------------------*
*   Description:
*   Loop thru token list and sum the source char count.
*       
********************************************************************** MC ***/
void CFrontend::CalcSentenceLength()
{
	long		firstIndex, lastIndex, lastLen;
	bool		firstState;
	SPLISTPOS	listPos;
    CFEToken    *pWordTok, *pFirstTok = NULL;

	//---------------------------------------------
	// Find the 1st and last words in sentence
	//---------------------------------------------
	firstIndex = lastIndex = lastLen = 0;
	firstState = true;
	listPos = m_TokList.GetHeadPosition();
	while( listPos )
	{
		pWordTok = m_TokList.GetNext( listPos );
		//-------------------------------------------
		// Look at at displayable words only
		//-------------------------------------------
		if( pWordTok->srcLen > 0 )
		{
			if( firstState )
			{
				firstState = false;
				firstIndex = pWordTok->srcPosition;
				pFirstTok = pWordTok;
			}
			else
			{
				lastIndex = pWordTok->srcPosition;
				lastLen = pWordTok->srcLen;
			}
		}
	}
	//--------------------------------------------------
	// Calculate sentence length for head list item
	//--------------------------------------------------
	if( pFirstTok )
	{
		pFirstTok->sentencePosition = firstIndex;						// Sentence starts here...
		pFirstTok->sentenceLen = (lastIndex - firstIndex) + lastLen;	// ...and this is the length
	}
}



/*****************************************************************************
* CFrontend::DisposeUnits *
*-------------------------*
*   Description:
*   Delete memory allocated to 'm_pUnits'.
*   Clean-up memory for Bookmarks 
*       
********************************************************************** MC ***/
void CFrontend::DisposeUnits( )
{
    SPDBG_FUNC( "CFrontend::DisposeUnits" );
    ULONG   unitIndex;

    if( m_pUnits )
    {
        //-----------------------------------------
        // Clean-up Bookmark memory allocation
        //-----------------------------------------

        for( unitIndex = m_CurUnitIndex; unitIndex < m_unitCount; unitIndex++)
        {
            if( m_pUnits[unitIndex].pBMObj != NULL )
            {
                //---------------------------------------
                // Dispose bookmark list
                //---------------------------------------
                delete m_pUnits[unitIndex].pBMObj;
                m_pUnits[unitIndex].pBMObj = NULL;
            }
        }
        delete m_pUnits;
        m_pUnits = NULL;
    }
} /* CFrontend::DisposeUnits */



/*****************************************************************************
* CFrontend::ParseNextSentence *
*------------------------------*
*   Description:
*   Fill 'm_pUnits' array with next sentence.
*   If there's no more input text, 
*      return with 'm_SpeechState' set to SPEECH_DONE +++
*       
********************************************************************** MC ***/
HRESULT CFrontend::ParseSentence( DIRECTION eDirection )
{
    SPDBG_FUNC( "CFrontend::ParseNextSentence" );
    HRESULT hr = S_OK;
   
    //-----------------------------------------------------
    // If there's a previous unit array, free its memory
    //-----------------------------------------------------
    DisposeUnits();
    m_CurUnitIndex = 0;
    m_unitCount = 0;
    DeleteTokenList();
    m_pUnits = NULL;
    //-----------------------------------------------------
    // If there's a previous allo array, free its memory
    //-----------------------------------------------------
    if( m_pAllos )
    {
        delete m_pAllos;
        m_pAllos = NULL;
    }
    
    //-----------------------------------------------------
    // Fill token array with next sentence
    // Skip empty sentences.
    // NOTE: includes non-speaking items
    //-----------------------------------------------------
    do
    {
        hr = GetSentenceTokens( eDirection );
    } while( (hr == S_OK) && (m_cNumOfWords == 0) );

    if( hr == S_OK )
    {
        //--------------------------------------------
        // Prepare word emphasis
        //--------------------------------------------
		DoWordAccent();

        //--------------------------------------------
        // Word level prosodic lables
        //--------------------------------------------
        DoPhrasing();
        ToBISymbols();

        //--------------------------------------------
        // Convert tokens to allo list
        //--------------------------------------------
         m_pAllos = new CAlloList;
        if (m_pAllos == NULL)
        {
            //-----------------------
            // Out of memory
            //-----------------------
            hr = E_FAIL;
        }
        if(  SUCCEEDED(hr) )
        {
            //--------------------------------
            // Convert word to allo strteam
            //-------------------------------
            TokensToAllo( &m_TokList, m_pAllos );

            //----------------------------
            // Tag sentence syllables
            //----------------------------
            m_SyllObj.TagSyllables( m_pAllos );

           //--------------------------------------------
            // Dispose token array, no longer needed
            //--------------------------------------------
            DeleteTokenList();

            //--------------------------------------------
			// Create the unit array
			// NOTE: 
            //--------------------------------------------
			hr = UnitLookahead ();
			if( hr == S_OK )
			{
				//--------------------------------------------
				// Compute allo durations
				//--------------------------------------------
                UnitToAlloDur( m_pAllos, m_pUnits );
				m_DurObj.AlloDuration( m_pAllos, m_RateRatio_API );
				//--------------------------------------------
				// Modulate allo pitch
				//--------------------------------------------
				m_PitchObj.AlloPitch( m_pAllos, m_BasePitch, m_PitchRange );
			}

			
        }
        if( hr == S_OK )
        {
			AlloToUnitPitch( m_pAllos, m_pUnits );
        }
    }

    if( FAILED(hr) )
    {
        //------------------------------------------
        // Either the input text is dry or we failed.
        // Try to fail gracefully
        //      1 - Clean up memory
        //      2 - End the speech
        //------------------------------------------
        if( m_pAllos )
        {
            delete m_pAllos;
			m_pAllos = 0;
        }
        DeleteTokenList();
        DisposeUnits();
        m_SpeechState = SPEECH_DONE;
    }
    else if( hr == S_FALSE )
    {
        //---------------------------------
        // No more input text
        //---------------------------------
        hr = S_OK;
        m_SpeechState = SPEECH_DONE;
    }


    return hr;
} /* CFrontend::ParseNextSentence */



/*****************************************************************************
* CFrontend::UnitLookahead *
*--------------------------*
*   Description:
*       
********************************************************************** MC ***/
HRESULT CFrontend::UnitLookahead ()
{
    SPDBG_FUNC( "CFrontend::UnitLookahead" );
    HRESULT		hr = S_OK;
	UNIT_CVT	*pPhon2Unit = NULL;
	ULONG		i;

    m_unitCount = m_pAllos->GetCount();

    m_pUnits = new UNITINFO[m_unitCount];
    if( m_pUnits )
    {
		pPhon2Unit = new UNIT_CVT[m_unitCount];
		if( pPhon2Unit )
		{
            //--------------------------------------------
            // Convert allo list to unit array
            //--------------------------------------------
            memset( m_pUnits, 0, m_unitCount * sizeof(UNITINFO) );
            hr = AlloToUnit( m_pAllos, m_pUnits );

			if( SUCCEEDED(hr) )
			{
				//--------------------------------------------
				// Initialize UNIT_CVT
				//--------------------------------------------
				for( i = 0; i < m_unitCount; i++ )
				{
					pPhon2Unit[i].PhonID = m_pUnits[i].PhonID;
					pPhon2Unit[i].flags = m_pUnits[i].flags;
				}
				//--------------------------------------------
				// Compute triphone IDs
				//--------------------------------------------
				hr = m_pVoiceDataObj->GetUnitIDs( pPhon2Unit, m_unitCount );

				if( SUCCEEDED(hr) )
				{
					//--------------------------------------------
					// Copy UNIT_CVT to UNITINFO
					//--------------------------------------------
					for( i = 0; i < m_unitCount; i++ )
					{
						m_pUnits[i].UnitID      = pPhon2Unit[i].UnitID;
						m_pUnits[i].SenoneID    = pPhon2Unit[i].SenoneID;
						m_pUnits[i].duration    = pPhon2Unit[i].Dur;
						m_pUnits[i].amp         = pPhon2Unit[i].Amp;
						m_pUnits[i].ampRatio    = pPhon2Unit[i].AmpRatio;
						strcpy( m_pUnits[i].szUnitName, pPhon2Unit[i].szUnitName );
					}
				}
				else
				{
					//-----------------------
					// Can't get unit ID's
					//-----------------------
					delete m_pUnits;
					m_pUnits = NULL;
				}
			}
			else
			{
				//-----------------------
				// Can't convert allos
				//-----------------------
				delete m_pUnits;
				m_pUnits = NULL;
			}
		}
		else
		{
			//-----------------------
			// Out of memory
			//-----------------------
			delete m_pUnits;
			m_pUnits = NULL;
			hr = E_FAIL;
		}
    }
	else
	{
        //-----------------------
        // Out of memory
        //-----------------------
        hr = E_FAIL;
	}

	//------------------------------
	// Cleanup before exit
	//------------------------------
    if( pPhon2Unit )
    {
        delete pPhon2Unit;
    }


	return hr;
} /* CFrontend::UnitLookahead */


/*****************************************************************************
* CFrontend::UnitToAlloDur *
*--------------------------*
*   Description:
*       
********************************************************************** MC ***/
void    CFrontend::UnitToAlloDur( CAlloList *pAllos, UNITINFO *pu )
{
    SPDBG_FUNC( "CFrontend::UnitToAlloDur" );
    CAlloCell   *pCurCell;
    
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
        pCurCell->m_UnitDur = pu->duration;
        pu++;
		pCurCell = pAllos->GetNextCell();
    }
} /* CFrontend::UnitToAlloDur */



/*****************************************************************************
* CFrontend::AlloToUnitPitch *
*----------------------------*
*   Description:
*       
********************************************************************** MC ***/
void    CFrontend::AlloToUnitPitch( CAlloList *pAllos, UNITINFO *pu )
{
    SPDBG_FUNC( "CFrontend::AlloToUnitPitch" );
    ULONG       k;
    CAlloCell   *pCurCell;
    
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
        pu->duration = pCurCell->m_ftDuration;
        for( k = 0; k < pu->nKnots; k++ )
        {
            pu->pTime[k]    = pCurCell->m_ftTime[k] * m_SampleRate;
            pu->pF0[k]      = pCurCell->m_ftPitch[k];
            pu->pAmp[k]     = pu->ampRatio;
        }
        pu++;
		pCurCell = pAllos->GetNextCell();
    }
} /* CFrontend::AlloToUnitPitch */


/*****************************************************************************
* CAlloList::DeleteTokenList *
*----------------------------*
*   Description:
*   Remove every item in link list.
*       
********************************************************************** MC ***/
void CFrontend::DeleteTokenList()
{
    SPDBG_FUNC( "CFrontend::DeleteTokenList" );
    CFEToken   *pTok;

    while( !m_TokList.IsEmpty() )
    {
        pTok = (CFEToken*)m_TokList.RemoveHead();
        delete pTok;
    }

} /* CFrontend::DeleteTokenList */



/*****************************************************************************
* AdjustQuestTune *
*-----------------*
*   Description:
*   Adjust termination for either YN or WH sentence tune.
*       
********************************************************************** MC ***/
static void AdjustQuestTune( CFEToken *pTok, bool fIsYesNo )
{
    SPDBG_FUNC( "AdjustQuestTune" );
    if ( pTok->m_TuneBoundaryType > NULL_BOUNDARY )
    {
	if( (pTok->m_TuneBoundaryType == YN_QUEST_BOUNDARY) ||
        (pTok->m_TuneBoundaryType == WH_QUEST_BOUNDARY) )
		{
		//------------------------------------
		// Is this a yes/no question phrase
		//------------------------------------
		if( fIsYesNo )
			{
			//------------------------------------------
			// Put out a final yes/no question marker
			//------------------------------------------
			pTok->m_TuneBoundaryType = YN_QUEST_BOUNDARY;
			pTok->m_BoundarySource = BND_YNQuest;
			}
		else 
			{
		
			//------------------------------------------------------------------------
			// Use declarative phrase marker (for WH questions)
			//------------------------------------------------------------------------
			pTok->m_TuneBoundaryType = WH_QUEST_BOUNDARY;
			pTok->m_BoundarySource = BND_WHQuest;
			}
		}
    }
} /* AdjustQuestTune */


typedef enum
{
	p_Interj,
    P_Adv,
	P_Verb,
	P_Adj,
    P_Noun,
	PRIORITY_SIZE,
} CONTENT_PRIORITY;

#define	NO_POSITION	-1


/*****************************************************************************
* CFrontend::ExclamEmph *
*-----------------------*
*   Description:
*   Find a likely word to emph if sentence has exclamation
*       
********************************************************************** MC ***/
void    CFrontend::ExclamEmph()
{
    SPDBG_FUNC( "CFrontend::ExclamEmph" );
    CFEToken        *pCur_Tok;
	SPLISTPOS		listPos, targetPos, curPos, contentPos[PRIORITY_SIZE];
	long			cContent, cWords;
	long			i;

	for(i = 0; i < PRIORITY_SIZE; i++ )
	{
		contentPos[i] = (SPLISTPOS)NO_POSITION;
	}

	listPos = m_TokList.GetTailPosition();
	pCur_Tok = m_TokList.GetNext( listPos );

	//---------------------------------------------------
	// First, check last token fors an exclamation
	//---------------------------------------------------
	if( pCur_Tok->m_TuneBoundaryType == EXCLAM_BOUNDARY )
	{
		//-----------------------------------------------------
		// Then, see if there's only one content word
		// in the sentence
		//-----------------------------------------------------
		cContent = cWords = 0;
		listPos = m_TokList.GetHeadPosition();
		while( listPos )
		{
			curPos = listPos;
			pCur_Tok = m_TokList.GetNext( listPos );
			if( pCur_Tok->m_posClass == POS_CONTENT )
			{
				cContent++;
				cWords++;
				if( cContent == 1)
				{
					targetPos = curPos;
				}
				//--------------------------------------------------------
				// Fill the famous Azara Content Prominence Hierarchy (ACPH)
				//--------------------------------------------------------
				if( (pCur_Tok->POScode == MS_Noun) && (contentPos[P_Noun] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Noun] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Verb) && (contentPos[P_Verb] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Verb] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Adj) && (contentPos[P_Adj] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Adj] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Adv) && (contentPos[P_Adv] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Adv] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Interjection) && (contentPos[p_Interj] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[p_Interj] = curPos;
				}
			}
			else if( pCur_Tok->m_posClass == POS_FUNC )
			{
				cWords++;
				if( cWords == 1)
				{
					targetPos = curPos;
				}
			}
		}

		//--------------------------------------------
		// If there's only one word or content word
		// then EMPHASIZE it
		//--------------------------------------------
		if( (cContent == 1) || (cWords == 1) )
		{
			pCur_Tok = m_TokList.GetNext( targetPos );
			pCur_Tok->user_Emph = 1;
		}
		else if( cContent > 1 )
		{
			for(i = 0; i < PRIORITY_SIZE; i++ )
			{
				if( contentPos[i] != (SPLISTPOS)NO_POSITION )
				{
					targetPos = contentPos[i];
					break;
				}
			}
			pCur_Tok = m_TokList.GetNext( targetPos );
			pCur_Tok->user_Emph = 1;
		}
	}
} //ExclamEmph



/*****************************************************************************
* CFrontend::DoWordAccent *
*-------------------------*
*   Description:
*   Prepare word for emphasis
*       
********************************************************************** MC ***/
void    CFrontend::DoWordAccent()
{
    SPDBG_FUNC( "CFrontend::DoWordAccent" );
    long            cNumOfWords;
    long            iCurWord;
    CFEToken        *pCur_Tok, *pNext_Tok, *pPrev_Tok, *pTempTok;
	SPLISTPOS		listPos;
    TUNE_TYPE       cur_Bnd, prev_Bnd;

    //-----------------------------
    // Initilize locals
    //-----------------------------
	cNumOfWords = m_TokList.GetCount();
	if( cNumOfWords > 0 )
	{
		ExclamEmph();
		prev_Bnd = PHRASE_BOUNDARY;			// Assume start of sentence
		//-------------------------------------
		// Fill the token pipeline
		//-------------------------------------
		listPos = m_TokList.GetHeadPosition();

		//-- Previous
		pPrev_Tok = NULL;

		//-- Current
		pCur_Tok = m_TokList.GetNext( listPos );

		//-- Next
		if( listPos )
		{
			pNext_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext_Tok = NULL;
		}

		//-----------------------------------
		// Step through entire word array
		//  (skip last)
		//-----------------------------------
		for( iCurWord = 0; iCurWord < (cNumOfWords -1); iCurWord++ )
		{
			cur_Bnd = pCur_Tok->m_TuneBoundaryType;
			if( pCur_Tok->user_Emph > 0 )
			{
				//-----------------------------------
				// Current word is emphasized
				//-----------------------------------
				if( prev_Bnd == NULL_BOUNDARY ) 
				{
					pTempTok = new CFEToken;
					if( pTempTok )
					{
						pTempTok->user_Break	  = EMPH_HESITATION;
						pTempTok->m_TuneBoundaryType = NULL_BOUNDARY;
						pTempTok->phon_Len = 1;
						pTempTok->phon_Str[0] = _SIL_;
						pTempTok->srcPosition = pCur_Tok->srcPosition;
						pTempTok->srcLen = pCur_Tok->srcLen;
						pTempTok->tokStr[0] = 0;        // There's no orth for Break
						pTempTok->tokLen = 0;
						pTempTok->m_TermSil = 0;
						pTempTok->m_SilenceSource = SIL_Emph;
						pTempTok->m_DurScale	= 0;
						if( pPrev_Tok )
						{
							//pTempTok->m_DurScale = pPrev_Tok->m_DurScale;
							pTempTok->m_ProsodyDurScale = pPrev_Tok->m_ProsodyDurScale;
							pTempTok->user_Volume = pPrev_Tok->user_Volume;
						}
						else
						{
							//pTempTok->m_DurScale = 1.0f;
							pTempTok->m_ProsodyDurScale = 1.0f;
						}

						m_TokList.InsertBefore( m_TokList.FindIndex( iCurWord ), pTempTok );
						pCur_Tok = pTempTok;
						m_cNumOfWords++;
						cNumOfWords++;
						iCurWord++;
					}
				}
			}
			//------------------------------
			// Shift the token pipeline
			//------------------------------
			prev_Bnd	= cur_Bnd;
			pPrev_Tok	= pCur_Tok;
			pCur_Tok	= pNext_Tok;
			if( listPos )
			{
				pNext_Tok = m_TokList.GetNext( listPos );
			}
			else
			{	
				pNext_Tok = NULL;
			}

		}
	}
} /* CFrontend::DoWordAccent */



/*****************************************************************************
* CFrontend::DoPhrasing *
*-----------------------*
*   Description:
*   Insert sub-phrase boundaries into word token array
*       
********************************************************************** MC ***/
void    CFrontend::DoPhrasing()
{
    SPDBG_FUNC( "CFrontend::DoPhrasing" );
    long            iCurWord;
    CFEToken        *pCur_Tok, *pNext_Tok, *pNext2_Tok, *pNext3_Tok, *pTempTok, *pPrev_Tok;
    ENGPARTOFSPEECH  cur_POS, next_POS, next2_POS, next3_POS, prev_POS;
    bool            fNext_IsPunct, fNext2_IsPunct, fNext3_IsPunct;
    bool            fIsYesNo, fMaybeWH, fHasDet, fInitial_Adv, fIsShortSent, fIsAlphaWH;
    TUNE_TYPE       cur_Bnd, prev_Punct;
    long            punctDistance;
    long            cNumOfWords;
	SPLISTPOS		listPos;
    BOUNDARY_SOURCE   bndNum;
    ACCENT_SOURCE	  accNum;
   
    //-----------------------------
    // Initialize locals
    //-----------------------------
	cNumOfWords = m_TokList.GetCount();
	if( cNumOfWords > 0 )
	{
		cur_Bnd			= NULL_BOUNDARY;
		prev_POS		= MS_Unknown;
		prev_Punct		= PHRASE_BOUNDARY;			// Assume start of sentence
		punctDistance	= 0;						// To quiet the compiler...
		fIsYesNo		= fMaybeWH = fHasDet = fIsAlphaWH = false;    // To quiet the compiler...
		fMaybeWH		= false;
		fInitial_Adv	= false;
		if (cNumOfWords <= 9) 
		{
			fIsShortSent = true;
		}
		else
		{
			fIsShortSent = false;
		}
    
		//-------------------------------------
		// Fill the token pipeline
		//-------------------------------------
		listPos = m_TokList.GetHeadPosition();
		//-- Previous
		pPrev_Tok = NULL;
		//-- Current
		pCur_Tok = m_TokList.GetNext( listPos );
		//-- Next
		if( listPos )
		{
			pNext_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext_Tok = NULL;
		}
		//-- Next 2
		if( listPos )
		{
			pNext2_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext2_Tok = NULL;
		}
		//-- Next 3
		if( listPos )
		{
			pNext3_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext3_Tok = NULL;
		}

		//-----------------------------------
		// Step through entire word array
		//  (skip last)
		//-----------------------------------
		for( iCurWord = 0; iCurWord < (cNumOfWords -1); iCurWord++ )
		{
			bndNum = BND_NoSource;
			accNum = ACC_NoSource;

			if( (prev_Punct > NULL_BOUNDARY) && (prev_Punct < SUB_BOUNDARY_1) )
			{
				punctDistance = 1;
				fIsYesNo = true;
				fMaybeWH = false;
				fHasDet = false;
				fIsAlphaWH = false;
			}
			else
			{
				punctDistance++;
			}
			//------------------------------------
			// Process new word
			//------------------------------------
			cur_POS = pCur_Tok->POScode;
			cur_Bnd = NULL_BOUNDARY;
			//------------------------------------
			// Don't depend on POS to detect 
			// "WH" question
			//------------------------------------
			if( ((pCur_Tok->tokStr[0] == 'W') || (pCur_Tok->tokStr[0] == 'w')) &&
				((pCur_Tok->tokStr[1] == 'H') || (pCur_Tok->tokStr[1] == 'h')) )
			{
				fIsAlphaWH = true;
			}
			else
			{
				fIsAlphaWH = false;
			}
        
			//------------------------------------
			// Look ahead to NEXT word
			//------------------------------------
			next_POS = pNext_Tok->POScode;
			if( pNext_Tok->m_TuneBoundaryType != NULL_BOUNDARY )
			{
				fNext_IsPunct = true;
			}
			else
			{
				fNext_IsPunct = false;
			}
        
			//------------------------------------
			// Look ahead 2 positions
			//------------------------------------
			if( pNext2_Tok )
			{
				next2_POS = pNext2_Tok->POScode;
				if( pNext2_Tok->m_TuneBoundaryType != NULL_BOUNDARY )
				{
					fNext2_IsPunct = true;
				}
				else
				{
					fNext2_IsPunct = false;
				}
			}
			else
			{
				next2_POS = MS_Unknown;
				fNext2_IsPunct = false;
			}
        
			//------------------------------------
			// Look ahead 3 positions
			//------------------------------------
			if( pNext3_Tok )
			{
				next3_POS = pNext3_Tok->POScode;
				if( pNext3_Tok->m_TuneBoundaryType != NULL_BOUNDARY )
				{
					fNext3_IsPunct = true;
				}
				else
				{
					fNext3_IsPunct = false;
				}
			}
			else
			{
				next3_POS = MS_Unknown;
				fNext3_IsPunct = false;
			}
        
			//------------------------------------------------------------------------
			// Is phrase a yes/no question?
			//------------------------------------------------------------------------
			if( punctDistance == 1 )
			{
				if( (cur_POS == MS_Interr) || (fIsAlphaWH) )
				{
					//---------------------------------
					// It's a "WH" question
					//---------------------------------
					fIsYesNo = false;
				}
				else if( (cur_POS == MS_Prep) || (cur_POS == MS_Conj) || (cur_POS == MS_CConj) )
				{
					fMaybeWH = true;
				}
			}
			else if( (punctDistance == 2) && (fMaybeWH) && 
					 ((cur_POS == MS_Interr) || (cur_POS == MS_RelPron) || (fIsAlphaWH)) )
			{
				fIsYesNo = false;
			}

			//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
			// SUB_BOUNDARY_1: Insert boundary after sentence-initial adverb
			//
			// Reluctantly __the cat sat on the mat.
			//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
			if( fInitial_Adv )
			{
				cur_Bnd = SUB_BOUNDARY_1;
				fInitial_Adv = false;
				bndNum = BND_PhraseRule1;
				accNum = ACC_PhraseRule1;
			}
			else
			{

				if( (punctDistance == 1) && 
					(cur_POS == MS_Adv) && (next_POS == MS_Det) )
				// include
				//LEX_SUBJPRON // he
				//LEX_DPRON  // this
				//LEX_IPRON  // everybody
				//NOT LEX_PPRON  // myself 
				{
					fInitial_Adv = true;
				}
				else 
				{
					fInitial_Adv = false;
				}

				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before coordinating conjunctions
				// The cat sat on the mat __and cleaned his fur.
				//
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				if( (cur_POS == MS_CConj) &&
					(fHasDet == false) &&
					(punctDistance > 3) &&
					(next2_POS != MS_Conj) )
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule2;
					accNum = ACC_PhraseRule2;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before adverb
				// The cat sat on the mat __reluctantly.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if(    (cur_POS == MS_Adv) && 
					(punctDistance > 4) && 
					(next_POS != MS_Adj) )
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule3;
					accNum = ACC_PhraseRule3;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary after object pronoun
				// The cat sat with me__ on the mat.
				//
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (prev_POS == MS_ObjPron) && (punctDistance > 2))
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule4;
					accNum = ACC_PhraseRule4;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before subject pronoun or contraction
				// The cat sat on the mat _I see.
				// The cat sat on the mat _I'm sure.
				//
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ((cur_POS == MS_SubjPron) || (cur_POS == MS_Contr) ) && 
					(punctDistance > 3) && (prev_POS != MS_RelPron) && (prev_POS != MS_Conj))
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule5;
					accNum = ACC_PhraseRule5;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before interr
				// The cat sat on the mat _how odd.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (cur_POS == MS_Interr) && (punctDistance > 4)  )
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule6;
					accNum = ACC_PhraseRule6;
				}
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after subject noun phrase followed by aux verb 
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary before vaux after noun phrase
				// The gray cat __should sit on the mat.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (punctDistance > 2) && 
					( ((prev_POS == MS_Noun) || (prev_POS == MS_Verb)) && (prev_POS != MS_VAux) ) && 
					(cur_POS == MS_VAux)
					)
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule7;
					accNum = ACC_PhraseRule7;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after MS_Interr
				// The gray cat __should sit on the mat.
				// SEE ABOVE???
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				/*else if( (prev_POS == MS_Noun) && ((next_POS != MS_RelPron) && 
					(next_POS != MS_VAux) && (next_POS != MS_RVAux) && 
					(next2_POS != MS_VAux) && (next2_POS != MS_RVAux)) && 
					(punctDistance > 4) && 
					((cur_POS == MS_VAux) || (cur_POS == MS_RVAux)))
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule8;
					accNum = ACC_PhraseRule8;
				}*/
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after MS_Interr
				// The cat sat on the mat _how odd.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (prev_POS == MS_Noun) && (next_POS != MS_RelPron) && 
					(next_POS != MS_Conj) &&  
					(next_POS != MS_CConj) && (punctDistance > 3)  && (cur_POS == MS_Verb))
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule9;
					accNum = ACC_PhraseRule9;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after MS_Interr
				// The cat sat on the mat _how odd.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				/*else if( (prev_POS == MS_Noun) && (cur_POS != MS_RelPron) && 
					(cur_POS != MS_RVAux) && (cur_POS != MS_CConj) && 
					(cur_POS != MS_Conj) && (punctDistance > 2) && 
					((punctDistance > 2) || (fIsShortSent)) && (cur_POS == MS_Verb))
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule10;
					accNum = ACC_PhraseRule10;
				}
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_4:Insert boundary before conjunction
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ((cur_POS == MS_Conj) && (punctDistance > 3) && 
					(fNext_IsPunct == false) && 
					(prev_POS != MS_Conj) && (prev_POS != MS_CConj) &&
					(fNext2_IsPunct == false)) ||
                
					( (prev_POS == MS_VPart) && (cur_POS != MS_Prep) && 
					(cur_POS != MS_Det) && 
					(punctDistance > 2) && 
					((cur_POS == MS_Noun) || (cur_POS == MS_Noun) || (cur_POS == MS_Adj))) ||
                
					( (cur_POS == MS_Interr) && (punctDistance > 2) && 
					(cur_POS == MS_SubjPron)) )
				{
					cur_Bnd = SUB_BOUNDARY_4;
					bndNum = BND_PhraseRule11;
					accNum = ACC_PhraseRule11;
				}
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_5:Insert boundary before relative pronoun
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ( (cur_POS == MS_RelPron) && (punctDistance >= 3)  && 
					(prev_POS != MS_Prep) && (next3_POS != MS_VAux) && 
					(next3_POS != MS_RVAux)  && 
					( (prev_POS == MS_Noun) || (prev_POS == MS_Verb) ) ) ||
                
					( (cur_POS == MS_Quant) && (punctDistance > 5) && 
					(prev_POS != MS_Adj) && (prev_POS != MS_Det) && 
					(prev_POS != MS_VAux) && (prev_POS != MS_RVAux) && 
					(prev_POS != MS_Det) && (next2_POS != MS_CConj) && 
					(fNext_IsPunct == false)))
				{
					cur_Bnd = SUB_BOUNDARY_5;
					bndNum = BND_PhraseRule12;
					accNum = ACC_PhraseRule12;
				}*/
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_6:Silverman87-style, content/function tone group boundaries. 
				// Does trivial sentence-final function word look-ahead check.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ( (prev_POS == MS_Noun) || (prev_POS == MS_Verb) || (prev_POS == MS_Adj) || (prev_POS == MS_Adv)) 
					&& ((cur_POS != MS_Noun) && (cur_POS != MS_Verb) && (cur_POS != MS_Adj) && (cur_POS != MS_Adv))
					&& (fNext_IsPunct == false)) 
				{
					cur_Bnd = SUB_BOUNDARY_6;
					bndNum = BND_PhraseRule13;
					accNum = ACC_PhraseRule13;
				}
			}
			//------------------------------------------------------------------------
			// If phrasing was found, save it
			//------------------------------------------------------------------------
			if( (cur_Bnd != NULL_BOUNDARY) && (iCurWord > 0) &&
				//!(fNext_IsPunct) && 
				!(prev_Punct) &&
				(pCur_Tok->m_TuneBoundaryType == NULL_BOUNDARY) )
			{
				//pCur_Tok->m_TuneBoundaryType = cur_Bnd;
				pTempTok = new CFEToken;
				if( pTempTok )
				{
					pTempTok->m_TuneBoundaryType = cur_Bnd;
					pTempTok->phon_Len = 1;
					pTempTok->phon_Str[0] = _SIL_;
					pTempTok->srcPosition = pCur_Tok->srcPosition;
					pTempTok->srcLen = pCur_Tok->srcLen;
					pTempTok->tokStr[0] = '+';				// punctuation
					pTempTok->tokStr[1] = 0;                // delimiter
					pTempTok->tokLen = 1;
					pTempTok->m_TermSil = 0;
					pTempTok->m_DurScale	= 0;
					if( pPrev_Tok )
					{
						pPrev_Tok->m_AccentSource = accNum;
						pPrev_Tok->m_BoundarySource = bndNum;
						pPrev_Tok->m_Accent = K_LHSTAR;
					}
					pTempTok->m_SilenceSource = SIL_SubBound;
					if( pPrev_Tok )
					{
						//pTempTok->m_DurScale = pPrev_Tok->m_DurScale;
						pTempTok->m_ProsodyDurScale = pPrev_Tok->m_ProsodyDurScale;
						pTempTok->user_Volume = pPrev_Tok->user_Volume;
					}
					else
					{
						//pTempTok->m_DurScale = 1.0f;
						pTempTok->m_ProsodyDurScale = 1.0f;
					}

					m_TokList.InsertBefore( m_TokList.FindIndex( iCurWord ), pTempTok );
					pCur_Tok = pTempTok;
					m_cNumOfWords++;
					cNumOfWords++;
					iCurWord++;
				}
			}
			//-------------------------------
			// Process sentence punctuation
			//-------------------------------
			 AdjustQuestTune( pCur_Tok, fIsYesNo );
       
			//-------------------------------
			// Prepare for next word
			//-------------------------------
			prev_Punct = pCur_Tok->m_TuneBoundaryType;
			prev_POS = cur_POS;
			pPrev_Tok = pCur_Tok;

			//------------------------------
			// Shift the token pipeline
			//------------------------------
			pCur_Tok	= pNext_Tok;
			pNext_Tok	= pNext2_Tok;
			pNext2_Tok	= pNext3_Tok;
			if( listPos )
			{
				pNext3_Tok = m_TokList.GetNext( listPos );
			}
			else
			{	
				pNext3_Tok = NULL;
			}

			//------------------------------------------------------------------------
			// Keep track of when determiners encountered to help in deciding 
			// when to allow a strong 'and' boundary (SUB_BOUNDARY_2)
			//------------------------------------------------------------------------
			if( punctDistance > 2) 
			{
				fHasDet = false;
			}
			if( cur_POS == MS_Det )
			{
				fHasDet = true;
			}
		}
		//-------------------------------------
		// Process final sentence punctuation
		//-------------------------------------
		pCur_Tok = (CFEToken*)m_TokList.GetTail();
		AdjustQuestTune( pCur_Tok, fIsYesNo );
	}


} /* CFrontend::DoPhrasing */



/*****************************************************************************
* CFrontend::RecalcProsody *
*--------------------------*
*   Description:
*   In response to a real-time rate change, recalculate duration and pitch
*       
********************************************************************** MC ***/
void CFrontend::RecalcProsody()
{
    SPDBG_FUNC( "CFrontend::RecalcProsody" );
    UNITINFO*   pu;
    CAlloCell*  pCurCell;
    ULONG		k;

    //--------------------------------------------
    // Compute new allo durations
    //--------------------------------------------
	/*pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        //pCurCell->m_DurScale = 1.0;
		pCurCell = m_pAllos->GetNextCell();
    }*/
    m_DurObj.AlloDuration( m_pAllos, m_RateRatio_API );

    //--------------------------------------------
    // Modulate allo pitch
    //--------------------------------------------
    m_PitchObj.AlloPitch( m_pAllos, m_BasePitch, m_PitchRange );

    pu = m_pUnits;
	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        pu->duration = pCurCell->m_ftDuration;
        for( k = 0; k < pu->nKnots; k++ )

        {
            pu->pTime[k]    = pCurCell->m_ftTime[k] * m_SampleRate;
            pu->pF0[k]      = pCurCell->m_ftPitch[k];
            pu->pAmp[k]     = pu->ampRatio;
        }
        pu++;
		pCurCell = m_pAllos->GetNextCell();
    }
} /* CFrontend::RecalcProsody */


/*****************************************************************************
* CFrontend::NextData *
*---------------------*
*   Description:
*   This gets called from the backend when UNIT stream is dry.
*   Parse TOKENS to ALLOS to UNITS
*       
********************************************************************** MC ***/
HRESULT CFrontend::NextData( void **pData, SPEECH_STATE *pSpeechState )
{
    SPDBG_FUNC( "CFrontend::NextData" );
    bool    haveNewRate = false;
    HRESULT hr = S_OK;

    //-----------------------------------
    // First, check and see if SAPI has an action
    //-----------------------------------
	// Check for rate change
	long baseRateRatio;
	if( m_pOutputSite->GetActions() & SPVES_RATE )
	{
		hr = m_pOutputSite->GetRate( &baseRateRatio );
		if ( SUCCEEDED( hr ) )
		{
			if( baseRateRatio > SPMAX_VOLUME )
			{
				//--- Clip rate to engine maximum
				baseRateRatio = MAX_USER_RATE;
			}
			else if ( baseRateRatio < MIN_USER_RATE )
			{
				//--- Clip rate to engine minimum
				baseRateRatio = MIN_USER_RATE;
			}
			m_RateRatio_API = CntrlToRatio( baseRateRatio );
			haveNewRate = true;
		}
	}

    //---------------------------------------------
    // Async stop?
    //---------------------------------------------
    if( SUCCEEDED( hr ) && ( m_pOutputSite->GetActions() & SPVES_ABORT ) )
    {
        m_SpeechState = SPEECH_DONE;
    }

    //---------------------------------------------
    // Async skip?
    //---------------------------------------------
    if( SUCCEEDED( hr ) && ( m_pOutputSite->GetActions() & SPVES_SKIP ) )
    {
		SPVSKIPTYPE SkipType;
		long SkipCount = 0;

		hr = m_pOutputSite->GetSkipInfo( &SkipType, &SkipCount );

		if ( SUCCEEDED( hr ) && SkipType == SPVST_SENTENCE )
		{
			IEnumSENTITEM *pGarbage;
			//--- Skip Forwards
			if ( SkipCount > 0 )
			{
				long OriginalSkipCount = SkipCount;
				while ( SkipCount > 1 && 
						( hr = m_pEnumSent->Next( &pGarbage ) ) == S_OK )
				{
					SkipCount--;
					pGarbage->Release();
				}
				if ( hr == S_OK )
				{
					hr = ParseSentence( eNEXT );
					if ( SUCCEEDED( hr ) )
					{
						SkipCount--;
					}
				}
				else if ( hr == S_FALSE )
				{
					m_SpeechState = SPEECH_DONE;
				}
				SkipCount = OriginalSkipCount - SkipCount;
			}
			//--- Skip Backwards
			else if ( SkipCount < 0 )
			{
				long OriginalSkipCount = SkipCount;
				while ( SkipCount < -1 &&
						( hr = m_pEnumSent->Previous( &pGarbage ) ) == S_OK )
				{
					SkipCount++;
					pGarbage->Release();
				}
				if ( hr == S_OK )
				{
					hr = ParseSentence( ePREVIOUS );
                    // This case is different from the forward skip, needs to test that
                    // Parse sentence found something to parse!
					if ( SUCCEEDED( hr ) && m_SpeechState != SPEECH_DONE)
					{
						SkipCount++;
					}
				}
				else if ( hr == S_FALSE )
				{
					m_SpeechState = SPEECH_DONE;
				}
				SkipCount = OriginalSkipCount - SkipCount;
			}
			//--- Skip to beginning of this sentence
			else
			{
				m_CurUnitIndex = 0;
			}
			hr = m_pOutputSite->CompleteSkip( SkipCount );
		}
    }

    //---------------------------------------------
    // Make sure we're still speaking
    //---------------------------------------------
    if( SUCCEEDED( hr ) && m_SpeechState != SPEECH_DONE )
    {
        if( m_CurUnitIndex >= m_unitCount)
        {
            //-----------------------------------
            // Get next sentence from Normalizer
            //-----------------------------------
            hr = ParseSentence( eNEXT );
			//m_SpeechState = SPEECH_DONE;
        }
        else if( haveNewRate )
        {
            //-----------------------------------
            // Recalculate prosody to new rate
            //-----------------------------------
            RecalcProsody();
        }

		if( SUCCEEDED(hr) )
		{
			if( m_SpeechState != SPEECH_DONE )
			{
				//-----------------------------------
				// Get next phon
				//-----------------------------------
				m_pUnits[m_CurUnitIndex].hasSpeech = m_HasSpeech;
				*pData =( void*)&m_pUnits[m_CurUnitIndex];
				m_CurUnitIndex++;
			}
		}
    }
    //-------------------------------------------
    // Let client know if text input is dry
    //-------------------------------------------
    *pSpeechState = m_SpeechState;

    return hr;
} /* CFrontend::NextData */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\data.cpp ===
/*******************************************************************************
* Data.cpp *
*----------*
*   Description:
*       Constant data tables.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

#include "stdafx.h"

#ifndef AlloOps_H
#include "AlloOps.h"
#endif
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif


#pragma warning(disable : 4305)
#pragma warning(disable : 4309)

#define	PUNCT_GAIN		1.67
#define	PUNCT_GAIN1		1.33
#define	SUB1_GAIN		1.00
#define	SUB2_GAIN		1.00




// I don't understand why I had to add "extern" here.
// If YOU do, please explain here for the rest of us:

extern const float g_BoundryStretchTbl[] =
{
    1.0,			// NULL_BOUNDARY = 0,  // no boundary
    PUNCT_GAIN1,    // PHRASE_BOUNDARY,    // comma
    PUNCT_GAIN,    // EXCLAM_BOUNDARY,    // exclamatory utterance terminator
    PUNCT_GAIN,    // YN_QUEST_BOUNDARY,     // yes-no question terminator
    PUNCT_GAIN,    // WH_QUEST_BOUNDARY,     // yes-no question terminator
    PUNCT_GAIN,    // DECLAR_BOUNDARY,    // declarative terminator
    SUB1_GAIN,    // PAREN_L_BOUNDARY,   // left paren
    SUB1_GAIN,    // PAREN_R_BOUNDARY,   // right paren
    SUB1_GAIN,    // QUOTE_L_BOUNDARY,   // left quote
    SUB1_GAIN,    // QUOTE_R_BOUNDARY,   // right quote
    SUB1_GAIN,    // PHONE_BOUNDARY,	// Telephone number
    1.30,			// TOD_BOUNDARY,		// Time-of-day

    SUB2_GAIN,    // SUB_BOUNDARY_1,     // NOTE: always put these at the end
    SUB2_GAIN,    // SUB_BOUNDARY_2,
    SUB2_GAIN,    // SUB_BOUNDARY_3,
    SUB2_GAIN,    // SUB_BOUNDARY_4,
    SUB2_GAIN,    // SUB_BOUNDARY_5,
    SUB2_GAIN,    // SUB_BOUNDARY_6,
    SUB2_GAIN,    // NUMBER_BOUNDARY,

	1.0,			// TAIL_BOUNDARY
};



extern const float   g_BoundryDurTbl[] =
{
    0.200,    // NULL_BOUNDARY = 0,  // no boundary
    0.200,    // PHRASE_BOUNDARY,    // comma
    0.300,    // EXCLAM_BOUNDARY,    // exclamatory utterance terminator
    0.300,    // YN_QUEST_BOUNDARY,     // yes-no question terminator
    0.300,    // WH_QUEST_BOUNDARY,     // wh question terminator
    0.300,    // DECLAR_BOUNDARY,    // declarative terminator
    0.200,    // PAREN_L_BOUNDARY,   // left paren
    0.200,    // PAREN_R_BOUNDARY,   // right paren
    0.200,    // QUOTE_L_BOUNDARY,   // left quote
    0.200,    // QUOTE_R_BOUNDARY,   // right quote
    0.100,    // PHONE_BOUNDARY,	// Telephone number
    0.010,    // TOD_BOUNDARY,		// Time-of-day
    0.200,    // ELLIPSIS_BOUNDARY,		// Ellipsis

    0.001,    // SUB_BOUNDARY_1,     // NOTE: always put these at the end
    0.001,    // SUB_BOUNDARY_2,
    0.001,    // SUB_BOUNDARY_3,
    0.001,    // SUB_BOUNDARY_4,
    0.001,    // SUB_BOUNDARY_5,
    0.001,    // SUB_BOUNDARY_6,

    0.001,    // NUMBER_BOUNDARY,

    0.001,    // TAIL_BOUNDARY,
};






//-------------------------------------------
// Translate -24 <--> +24 pitch control to 
// 24th root of two pitch scale
//-------------------------------------------
extern const float   g_PitchScale[] =
{
    1.0,
    1.0293022366434920287823718007739,
    1.0594630943592952645618252949463,
    1.0905077326652576592070106557607,
    1.1224620483093729814335330496792,
    1.1553526968722730102453370986819,
    1.1892071150027210667174999705605,
    1.2240535433046552391321602168255,
    1.2599210498948731647672106072777,
    1.2968395546510096659337541177919,
    1.3348398541700343648308318811839,
    1.3739536474580891017766557477492,
    1.4142135623730950488016887242091,
    1.4556531828421873543551155614673,
    1.4983070768766814987992807320292,
    1.5422108254079408236122918620901,
    1.5874010519681994747517056392717,
    1.6339154532410998436782440504114,
    1.6817928305074290860622509524658,
    1.7310731220122860533901844375553,
    1.7817974362806786094804524111803,
    1.8340080864093424634870831895876,
    1.8877486253633869932838263133343,
    1.9430638823072117374865788316417,
    2.0
};

//-------------------------------------------
// Translate -10 <--> +10 rate control to 
// 10th root of three rate scale
//-------------------------------------------
extern const float   g_RateScale[] =
{
    1.0,
    1.1161231740339044344426141383771,
    1.2457309396155173259666803366403,
    1.3903891703159093404852542946161,
    1.5518455739153596742733451355167,
    1.7320508075688772935274463415059,
    1.9331820449317627515248789432662,
    2.1576692799745930995549489159803,
    2.4082246852806920462855086141912,
    2.6878753795222865835819210737269,
    3,
    3.348369522101713303327842415131,
    3.7371928188465519779000410099203,
    4.1711675109477280214557628838472,
    4.6555367217460790228200354065486,
    5.1961524227066318805823390245155,
    5.7995461347952882545746368297956,
    6.4730078399237792986648467479371,
    7.2246740558420761388565258425687,
};







extern const unsigned short  g_Opcode_To_ASCII[] =
{
    'IY',   'IH',   'EH',   'AE',   'AA',   'AH',   'AO',   'UH',   'AX',   'ER',
    'EY',   'AY',   'OY',   'AW',   'OW',   'UW',
    'IX',   '_',   'w',    'y',
    'r',    'l',    'h',    'm',    'n',    'NG',   'f',    'v',    'TH',   'DH',
    's',    'z',    'SH',   'ZH',   'p',    'b',    't',    'd',    'k',    'g',
    'CH',   'JH',   'DX',   '1',    '2',    '3',    '/',
    0x5C,   '>',    '<',    '=',    '_',    '*',    '$',    ',',    '.',    '?',
    '!',    '-',    '#',    '+',    '~',    '@',    0,      0,      0,      0
};



extern const unsigned long   g_AlloFlags[] =
{

// IY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KYGLIDEENDF + KFRONTF,

// IH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// EH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// AE
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// AA
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// AH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// AO
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// UH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// AX
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// ER
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// EY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KYGLIDEENDF + KFRONTF + KDIPHTHONGF,

// AY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// OY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// AW
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// OW
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// UW
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// IX
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// SIL
    KSONORANT1F,

// W
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF + KLIQGLIDE2F,

// Y
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF + KYGLIDESTARTF + KYGLIDEENDF,

// R
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF + KLIQGLIDE2F,

// L
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF,

// H
    KSONORANT1F + KCONSONANTF,

// M
    KVOICEDF + KSONORANTF + KSONORANT1F + KNASALF + KCONSONANTF + KSONORCONSONF + KOBSTF + KLABIALF + KHASRELEASEF,

// N
    KVOICEDF + KSONORANTF + KSONORANT1F + KNASALF + KCONSONANTF + KSONORCONSONF + KOBSTF + KALVEOLARF + KHASRELEASEF,

// NG
    KVOICEDF + KSONORANTF + KSONORANT1F + KNASALF + KCONSONANTF + KSONORCONSONF + KOBSTF + KVELAR + KHASRELEASEF,

// F
    KPLOSFRICF + KCONSONANTF + KLABIALF + KFRIC,

// V
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KLABIALF + KFRIC,

// TH
    KPLOSFRICF + KCONSONANTF + KDENTALF + KFRIC,

// DH
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KDENTALF + KFRIC,

// S
    KPLOSFRICF + KCONSONANTF + KALVEOLARF + KFRIC,

// Z
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KALVEOLARF + KFRIC,

// SH
    KPLOSFRICF + KCONSONANTF + KPALATALF + KFRIC,

// ZH
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KPALATALF + KFRIC,

// P
    KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KLABIALF + KHASRELEASEF,

// B
    KVOICEDF + KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KLABIALF + KHASRELEASEF,

// T
    KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KALVEOLARF + KHASRELEASEF,

// D
    KVOICEDF + KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KALVEOLARF + KHASRELEASEF,

// K
    KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KVELAR + KHASRELEASEF,

// G
    KVOICEDF + KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KVELAR + KHASRELEASEF,

// CH
    KPLOSFRICF + KCONSONANTF + KPLOSIVEF + KOBSTF + KPALATALF + KAFFRICATEF,

// JH
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KPLOSIVEF + KOBSTF + KPALATALF + KAFFRICATEF,

// DX
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KOBSTF,
};








extern const short   g_IPAToAllo[] =
{
    28,     // _IY_
    27,     // _IH_
    21,     // _EH_
    11,     // _AE_
    10,     // _AA_
    12,     // _AH_
    13,     // _AO_
    43,     // _UH_
    15,     // _AX_
    22,     // _ER_
    23,     // _EY_
    16,     // _AY_
    36,     // _OY_
    14,     // _AW_
    35,     // _OW_
    44,     // _UW_
    NO_IPA,     // _IX_
    7,     // _SIL_
    46,       // _w_
    47,       // _y_
    38,       // _r_     0x279
    31,       // _l_
    26,      // _h_      0x68
    32,       // _m_
    33,       // _n_
    34,      // _NG_
    24,       // _f_
    45,       // _v_
    42,      // _TH_
    20,      // _DH_
    39,       // _s_
    48,       // _z_
    40,      // _SH_
    49,      // _ZH_
    37,       // _p_
    17,       // _b_
    41,       // _t_
    19,       // _d_
    30,       // _k_
    25,       // _g_     0x67
    18,      // _CH_
    29,      // _JH_     0x2a4
    NO_IPA,       // _DX_       // @@@@
    8,      // _STRESS1_
    9,      // _STRESS2_
    NO_IPA,      // _EMPHSTRESS_
    1,      // _SYLLABLE_
};




extern const short   g_AlloToViseme[] =
{
    SP_VISEME_6,     // _IY_
    SP_VISEME_6,     // _IH_
    SP_VISEME_4,     // _EH_
    SP_VISEME_1,     // _AE_
    SP_VISEME_2,     // _AA_
    SP_VISEME_1,     // _AH_
    SP_VISEME_3,     // _AO_
    SP_VISEME_4,     // _UH_
    SP_VISEME_1,     // _AX_
    SP_VISEME_5,     // _ER_
    SP_VISEME_4,     // _EY_
    SP_VISEME_11,    // _AY_
    SP_VISEME_10,    // _OY_
    SP_VISEME_9,     // _AW_
    SP_VISEME_8,     // _OW_
    SP_VISEME_7,     // _UW_
    SP_VISEME_6,     // _IX_
    SP_VISEME_0,     // _SIL_
    SP_VISEME_7,       // _w_
    SP_VISEME_6,       // _y_
    SP_VISEME_13,       // _r_ 
    SP_VISEME_14,       // _l_
    SP_VISEME_12,      // _h_ 
    SP_VISEME_21,       // _m_
    SP_VISEME_19,       // _n_
    SP_VISEME_20,      // _NG_
    SP_VISEME_18,       // _f_
    SP_VISEME_18,       // _v_
    SP_VISEME_17,      // _TH_
    SP_VISEME_17,      // _DH_
    SP_VISEME_15,       // _s_
    SP_VISEME_15,       // _z_
    SP_VISEME_16,      // _SH_
    SP_VISEME_16,      // _ZH_
    SP_VISEME_21,       // _p_
    SP_VISEME_21,       // _b_
    SP_VISEME_19,       // _t_
    SP_VISEME_19,       // _d_
    SP_VISEME_20,       // _k_
    SP_VISEME_20,       // _g_
    SP_VISEME_16,      // _CH_
    SP_VISEME_16,      // _JH_ 
    SP_VISEME_13,       // _DX_       // @@@@
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\frontend.h ===
/******************************************************************************
* Frontend.h *
*------------*
*  This is the header file for the CFrontend implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** MC ****/
#ifndef Frontend_H
#define Frontend_H

#ifndef FeedChain_H
#include "FeedChain.h"
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#include "sapi.h"


//static const float DISCRETE_BKPT   = 0.6667f; 
static const float DISCRETE_BKPT   = 0.3333f; 

//-----------------------------------------
// Parse Next Sentence or Previous Sentence
//-----------------------------------------
enum DIRECTION
{
    eNEXT = 0,
    ePREVIOUS = 1,
};

//------------------------------------------------------
// Tag Values
//------------------------------------------------------
enum USER_VOLUME_VALUE
{   
    MIN_USER_VOL = 0,
    MAX_USER_VOL = 100,
    DEFAULT_USER_VOL = MAX_USER_VOL
};

enum USER_PITCH_VALUE
{   
    MIN_USER_PITCH = (-24),
    MAX_USER_PITCH = 24,
    DEFAULT_USER_PITCH = 0       // None
};

enum USER_EMPH_VALUE
{   
    MIN_USER_EMPH = (-10),
    MAX_USER_EMPH = 10,
    SAPI_USER_EMPH = 5,
    DEFAULT_USER_EMPH = 0        // None
};



//------------------------
// ToBI phrasing
//------------------------
typedef struct
{
    PROSODY_POS  posClass;
    long     start;
    long     end;
} TOBI_PHRASE;



class CFrontend: public CFeedChain
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    CFrontend( );
    ~CFrontend( );
    void PrepareSpeech( IEnumSpSentence* pEnumSent, ISpTTSEngineSite* pOutputSite );
    HRESULT Init( IMSVoiceData* pVoiceDataObj, CFeedChain *pSrcObj, MSVOICEINFO* pVoiceInfo );

private:
    HRESULT AlloToUnit( CAlloList *pAllos, UNITINFO *pu );
    HRESULT ParseSentence( DIRECTION eDirection );
    HRESULT TokensToAllo( CFETokenList *pTokList, CAlloList *pAllo );
    HRESULT GetSentenceTokens( DIRECTION eDirection );
    void GetItemControls( const SPVSTATE* pXmlState, CFEToken* pToken );
    void DisposeUnits( );
    void RecalcProsody();
    HRESULT ToBISymbols();
    void DoPhrasing();
    void DeleteTokenList();
	HRESULT UnitLookahead ();
	void AlloToUnitPitch( CAlloList *pAllos, UNITINFO *pu );
    void UnitToAlloDur( CAlloList *pAllos, UNITINFO *pu );
    float CntrlToRatio( long rateControl );
	PROSODY_POS GetPOSClass( ENGPARTOFSPEECH sapiPOS );
	bool StateQuoteProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	bool StartParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	bool EndParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	bool EmphSetup( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	SPLISTPOS InsertSilenceAtTail( CFEToken *pWordTok, TTSSentItem *pSentItem, long msec );
	SPLISTPOS InsertSilenceAfterPos( CFEToken *pWordTok, SPLISTPOS position );
	SPLISTPOS InsertSilenceBeforePos( CFEToken *pWordTok, SPLISTPOS position );
	void DoWordAccent();
	void ExclamEmph();
	void ProsodyTemplates( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	long DoIntegerTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount );
	void DoNumByNumTemplate( SPLISTPOS *pClusterPos, long cWordCount );
	void DoCurrencyTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	void DoPhoneNumberTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	void DoTODTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	long DoFractionTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount );
	CFEToken *InsertPhoneSilenceAtSpace( SPLISTPOS *pClusterPos, 
													BOUNDARY_SOURCE bndSrc, 
													SILENCE_SOURCE	silSrc );
	void InsertPhoneSilenceAtEnd( BOUNDARY_SOURCE bndSrc, 
								  SILENCE_SOURCE	silSrc );
	void CalcSentenceLength();

    //--------------------------------
    // CFeedChain methods
    //--------------------------------
    virtual HRESULT NextData( void**pData, SPEECH_STATE *pSpeechState ) ;
    
    //--------------------------------
    // Members
    //--------------------------------
    UNITINFO*       m_pUnits;
    ULONG           m_unitCount;
    ULONG           m_CurUnitIndex;
    SPEECH_STATE    m_SpeechState;
    
    CFeedChain      *m_pSrcObj;
    long            m_VoiceWPM;         // Voice defined speaking rate (wpm)
    float            m_RateRatio_API;         // API modulated speaking rate (ratio)
    float            m_CurDurScale;		// control tag (ratio)
    float            m_RateRatio_BKPT;        // Below this, add pauses (ratio)
    float            m_RateRatio_PROSODY;         // API modulated speaking rate (ratio)
    float           m_BasePitch;		// FROM VOICE: Baseline pitch in hz
	float			m_PitchRange;		// FROM VOICE: Pitch range in +/- octaves
	bool			m_HasSpeech;
    
    CFETokenList    m_TokList;
    long            m_cNumOfWords;
    
    CPitchProsody   m_PitchObj;
    IEnumSpSentence    *m_pEnumSent;
    CDuration       m_DurObj;
    CSyllableTagger m_SyllObj;
    IMSVoiceData*   m_pVoiceDataObj;
    float           m_ProsodyGain;
    float           m_SampleRate;
    CAlloList       *m_pAllos;
	bool			m_fInQuoteProsody;		// Special prosody mode
	bool			m_fInParenProsody;		// Special prosody mode
	float			m_CurPitchOffs;			// Pitch offset in octaves
	float			m_CurPitchRange;		// Pitch range scale (0 - 2.0)

	ISpTTSEngineSite *m_pOutputSite;
};



#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\feedchain.h ===
/******************************************************************************
* FeedChain.h *
*-------------*
*  This is the header file for the CFeedChain implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

#ifndef FeedChain_H
#define FeedChain_H

#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef SPCollec_h
#include <SPCollec.h>
#endif



// Maximum posody breakpoints for each phon
typedef enum KNOTSLEN
{
    KNOTS_PER_PHON  = 20
}KNOTSLEN;



//-----------------------------------------------------
// This is the unit data the BE gets fron the FE
//-----------------------------------------------------
typedef struct UNITINFO
{
    ULONG       UnitID;         // Inventory table ID
    float       duration;       // Duration in seconds
    float       amp;			// Abs amplitude
    float       ampRatio;       // Amplitude gain
    ULONG       nKnots;         // Number of prosody breakpoints
    float       pTime[KNOTS_PER_PHON];  // Breakpoint length
    float       pF0[KNOTS_PER_PHON];    // Pitch breakpoint
    float       pAmp[KNOTS_PER_PHON];   // Amplitude gain breakpoint
    ULONG       PhonID;         // Phoneme ID
	ULONG		SenoneID;		// Context offset from PhonID
	USHORT		AlloID;
	USHORT		NextAlloID;
	USHORT		AlloFeatures;	// for viseme
    ULONG	    flags;          // Misc flags
    ULONG       csamplesOut;    // Number of rendered samples
	float		speechRate;

    //-- Event data
    ULONG       srcPosition;    // Position for WORD events
    ULONG       srcLen;         // Length for WORD events
    ULONG       sentencePosition;    // Position for SENTENCE events
    ULONG       sentenceLen;         // Length for SENTENCE events
    void        *pBMObj;        // Ptr to bookmark list

    //-- Control data
    ULONG       user_Volume;    // Output volume level
	bool		hasSpeech;
    
	//-- Debug output
	enum SILENCE_SOURCE		silenceSource;
    CHAR        szUnitName[15];
	long		ctrlFlags;
    /*long        cur_TIME;
    long        decompress_TIME;
    long        prosody_TIME;
    long        stretch_TIME;
    long        lpc_TIME;*/
} UNITINFO;



//-------------------------------------------------
// Since bookmarks can be stacked, we need to 
// save each individually into a list
//-------------------------------------------------
typedef struct 
{
    LPARAM  pBMItem;      // Ptr to text data
} BOOKMARK_ITEM;


class CBookmarkList
{
public:
    //----------------------------------------
    // Needs destructor to dealloc 
    // 'BOOKMARK_ITEM' memory
    //----------------------------------------
    ~CBookmarkList();

    //----------------------------------------
    // Linked list bookmark items
    //----------------------------------------
    CSPList<BOOKMARK_ITEM*, BOOKMARK_ITEM*> m_BMList;
};

//---------------------------------------------------
// Speech states
//---------------------------------------------------
enum SPEECH_STATE
{   
    SPEECH_CONTINUE,
    SPEECH_DONE
};



class CFeedChain
{
public:
    
    virtual HRESULT NextData( void **pData, SPEECH_STATE *pSpeechState ) = 0;
};



#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\mainnorm.cpp ===
/*******************************************************************************
* MainNorm.cpp *
*--------------*
*	Description:
*		
*-------------------------------------------------------------------------------
*  Created By: AH										  Date: 01/18/2000
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

/*****************************************************************************
* CStdSentEnum::Normalize *
*-------------------------*
*  
********************************************************************** AH ***/
HRESULT CStdSentEnum::Normalize( CItemList& ItemList, SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::Normalize" );
    HRESULT hr = S_OK;
    TTSItemInfo* pItemNormInfo = NULL;
    CWordList WordList;
    const SPVTEXTFRAG* pTempFrag = m_pCurrFrag;
    TTSSentItem& TempItem = ItemList.GetAt( ListPos );
    if ( TempItem.pItemInfo )
    {
        pItemNormInfo = TempItem.pItemInfo;
    }

    //--- Match the normalization category of the current token.
    if ( m_pCurrFrag->State.eAction == SPVA_Speak )
    {
        if ( !pItemNormInfo                         || 
             ( pItemNormInfo->Type != eABBREVIATION &&
               pItemNormInfo->Type != eINITIALISM ) )
        {
            hr = MatchCategory( pItemNormInfo, MemoryManager, WordList );
        }
    }
    //--- Action must be SPVA_SpellOut - assign eSPELLOUT as category
    else
    {
        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eSPELLOUT;
        }
    }

    if (SUCCEEDED(hr))
    {
        switch ( pItemNormInfo->Type )
        {

        //--- Alpha Word - just insert into the Item List.
        case eALPHA_WORD:
            {
                CSentItem Item;
                Item.pItemSrcText       = m_pNextChar;
                Item.ulItemSrcLen       = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                Item.ulItemSrcOffset    = pTempFrag->ulTextSrcOffset +
                                          (ULONG)( m_pNextChar - pTempFrag->pTextStart );
                Item.ulNumWords         = 1;
                Item.Words              = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( Item.Words, sizeof(TTSWord) );
                    Item.Words[0].pXmlState         = &pTempFrag->State;
                    Item.Words[0].pWordText         = m_pNextChar;
                    Item.Words[0].ulWordLen         = Item.ulItemSrcLen;
                    Item.Words[0].pLemma            = Item.Words[0].pWordText;
                    Item.Words[0].ulLemmaLen        = Item.Words[0].ulWordLen;
                    Item.Words[0].eWordPartOfSpeech = MS_Unknown;
                    Item.eItemPartOfSpeech          = MS_Unknown;
                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo*), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo->Type = eALPHA_WORD;
                        ItemList.SetAt( ListPos, Item );
                    }
                }
            }
            break;

        case eABBREVIATION:
        case eABBREVIATION_NORMALIZE:
        case eINITIALISM:
            break;

        //--- Multi-token categories have already been expanded into WordList, now just accumulate
        //---   words, and insert back into the Item List.
        case eNEWNUM_PHONENUMBER:
            //--- Special case - remove parentheses (of area code), if present in the item list
            {
                SPLISTPOS TempPos = ListPos;
                CSentItem Item = ItemList.GetPrev( TempPos );
                if ( TempPos )
                {
                    SPLISTPOS RemovePos = TempPos;
                    Item = ItemList.GetPrev( TempPos );
                    if ( Item.pItemInfo->Type == eOPEN_PARENTHESIS &&
                         ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode )
                    {
                        ItemList.RemoveAt( RemovePos );
                        m_pNextChar--;
                    }
                }
            }
        case eNUM_CURRENCY:
        case eNUM_CURRENCYRANGE:
        case eTIMEOFDAY:
        case eDATE_LONGFORM:
        case eSTATE_AND_ZIPCODE:
        case eTIME_RANGE:
            {
                //--- Set Item data, and add to ItemList.
                if ( SUCCEEDED( hr ) )
                {
                    CSentItem Item;
                    Item.pItemSrcText       = m_pNextChar;
                    Item.ulItemSrcLen       = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                    Item.ulItemSrcOffset    = pTempFrag->ulTextSrcOffset +
                                              (ULONG)( m_pNextChar - pTempFrag->pTextStart );
                    hr = SetWordList( Item, WordList, MemoryManager );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo = pItemNormInfo;
                        ItemList.SetAt( ListPos, Item );
                    }
                }
            }
            break;

        //--- Expand the single token, according to its normalization category.
        default:
            hr = ExpandCategory( pItemNormInfo, ItemList, ListPos, MemoryManager );
            break;
        }
    }

    return hr;
} /* Normalize */

/*****************************************************************************
* CStdSentEnum::MatchCategory *
*-----------------------------*
*  
********************************************************************** AH ***/
HRESULT CStdSentEnum::MatchCategory( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager,
                                     CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::MatchCategory" );
    SPDBG_ASSERT( m_pNextChar );

    HRESULT hr = E_INVALIDARG;

    //--- Context has been specified
    if ( m_pCurrFrag->State.Context.pCategory )
    {
        if ( wcsicmp( m_pCurrFrag->State.Context.pCategory, L"ADDRESS" ) == 0 )
        {
            hr = IsZipCode( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
        }
        else if ( wcsnicmp( m_pCurrFrag->State.Context.pCategory, L"DATE", 4 ) == 0 )
        {
            hr = IsNumericCompactDate( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            if ( hr == E_INVALIDARG )
            {
                hr = IsMonthStringCompactDate( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            }
        }
        else if ( wcsnicmp( m_pCurrFrag->State.Context.pCategory, L"TIME", 4 ) == 0 )
        {
            hr = IsTime( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
        }
        else if ( wcsnicmp( m_pCurrFrag->State.Context.pCategory, L"NUM", 3 ) == 0 )
        {
            hr = IsNumberCategory( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            if ( hr == E_INVALIDARG )
            {
                hr = IsRomanNumeral( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            }
        }
        else if ( wcsicmp( m_pCurrFrag->State.Context.pCategory, L"PHONE_NUMBER" ) == 0 )
        {
            hr = IsPhoneNumber( pItemNormInfo, L"PHONE_NUMBER", MemoryManager, WordList );
        }
    }
    //--- Default Context
    if ( hr == E_INVALIDARG )
    {
        //--- Do ALPHA Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsAlphaWord( m_pNextChar, m_pEndOfCurrItem, pItemNormInfo, MemoryManager );
            //--- Check ALPHA Exceptions
            if ( SUCCEEDED( hr ) )
            {
				hr = E_INVALIDARG;
                if ( hr == E_INVALIDARG )
                {
                    hr = IsLongFormDate_DMDY( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = IsLongFormDate_DDMY( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = IsStateAndZipcode( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = IsCurrency( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = S_OK;
                }
            }
        }
        //--- Do Multi-Token Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsLongFormDate_DMDY( pItemNormInfo, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsLongFormDate_DDMY( pItemNormInfo, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsCurrency( pItemNormInfo, MemoryManager, WordList );
        }
        //--- Do TIME Normalization check
        if ( hr == E_INVALIDARG )
        {
            hr = IsTimeRange( pItemNormInfo, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsTimeOfDay( pItemNormInfo, MemoryManager, WordList );
        }
        //--- Do NUMBER Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsPhoneNumber( pItemNormInfo, NULL, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsNumberCategory( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsNumberRange( pItemNormInfo, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsCurrencyRange( pItemNormInfo, MemoryManager, WordList );
        }
        //--- Do DATE Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsNumericCompactDate( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsMonthStringCompactDate( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsDecade( pItemNormInfo, MemoryManager );
        }
        //--- Do TIME Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsTime( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsHyphenatedString( m_pNextChar, m_pEndOfCurrItem, pItemNormInfo, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsSuffix( m_pNextChar, m_pEndOfCurrItem, pItemNormInfo, MemoryManager );
        }
    }

    if ( hr == E_INVALIDARG &&
         !pItemNormInfo )
    {
        hr = S_OK;
        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eUNMATCHED;
        }
    }
    else if ( hr == E_INVALIDARG &&
              pItemNormInfo )
    {
        hr = S_OK;
    }

    return hr;
} /* MatchCategory */

/*****************************************************************************
* CStdSentEnum::ExpandCategory *
*------------------------------*
*  Expands previously matched items in the Item List into their normalized
* forms.
********************************************************************** AH ***/
HRESULT CStdSentEnum::ExpandCategory( TTSItemInfo*& pItemNormInfo, CItemList& ItemList, SPLISTPOS ListPos, 
                                      CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandCategory" );

    HRESULT hr = S_OK;
    CSentItem Item;
    CWordList WordList;
    
    Item.pItemSrcText = m_pNextChar;
    Item.ulItemSrcLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    Item.ulItemSrcOffset = m_pCurrFrag->ulTextSrcOffset +
                           (ULONG)( m_pNextChar - m_pCurrFrag->pTextStart );
    
    switch ( pItemNormInfo->Type )
    {

    case eNUM_ROMAN_NUMERAL:
        switch ( ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo->Type )
        {
        case eDATE_YEAR:
            hr = ExpandYear( (TTSYearItemInfo*) ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo, 
                             WordList );
            break;
        default:
            hr = ExpandNumber( (TTSNumberItemInfo*) ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo, 
                               WordList );
            break;
        }
        break;

    case eNUM_CARDINAL:
    case eNUM_ORDINAL:
    case eNUM_DECIMAL:
    case eNUM_FRACTION:
    case eNUM_MIXEDFRACTION:
        hr = ExpandNumber( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_PERCENT:
        hr = ExpandPercent( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_DEGREES:
        hr = ExpandDegrees( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_SQUARED:
        hr = ExpandSquare( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_CUBED:
        hr = ExpandCube( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_ZIPCODE:
        hr = ExpandZipCode( (TTSZipCodeItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_RANGE:
        hr = ExpandNumberRange( (TTSNumberRangeItemInfo*) pItemNormInfo, WordList );
        break;

    case eDATE:
        hr = ExpandDate( (TTSDateItemInfo*) pItemNormInfo, WordList );
        break;

    case eDATE_YEAR:
        hr = ExpandYear( (TTSYearItemInfo*) pItemNormInfo, WordList );
        break;

    case eDECADE:
        hr = ExpandDecade( (TTSDecadeItemInfo*) pItemNormInfo, WordList );
        break;

    case eTIME:
        hr = ExpandTime( (TTSTimeItemInfo*) pItemNormInfo, WordList );
        break;

    case eHYPHENATED_STRING:
        hr = ExpandHyphenatedString( (TTSHyphenatedStringInfo*) pItemNormInfo, WordList );
        break;

    case eSUFFIX:
        hr = ExpandSuffix( (TTSSuffixItemInfo*) pItemNormInfo, WordList );
        break;

    case eSPELLOUT:
        hr = SpellOutString( WordList );
        break;

    case eUNMATCHED:
    default:
        hr = ExpandUnrecognizedString( WordList, MemoryManager );
        break;

    }

    //--- Set Item data, and add to ItemList.
    if ( SUCCEEDED( hr ) )
    {
        hr = SetWordList( Item, WordList, MemoryManager );
        if ( SUCCEEDED( hr ) )
        {
            Item.pItemInfo = pItemNormInfo;
            ItemList.SetAt( ListPos, Item );
        }
    }

    return hr;
} /* ExpandCategory */

/*****************************************************************************
* CStdSentEnum::DoUnicodeToAsciiMap *
*-----------------------------------*
*   Description:
*       Maps incoming strings to known values.
********************************************************************* AH ****/
HRESULT CStdSentEnum::DoUnicodeToAsciiMap( const WCHAR *pUnicodeString, ULONG ulUnicodeStringLength,
                                           WCHAR *pConvertedString )
{
    SPDBG_FUNC( "CSpVoice::DoUnicodeToAsciiMap" );
    HRESULT hr = S_OK;
    unsigned char *pBuffer = NULL;
    WCHAR *pWideCharBuffer = NULL;

    if ( pUnicodeString )
    {
        //--- Make copy of pUnicodeString 
        pWideCharBuffer = new WCHAR[ulUnicodeStringLength+1];
        if ( !pWideCharBuffer )
        {
            hr = E_OUTOFMEMORY;
        }
        if ( SUCCEEDED( hr ) )
        {
            wcsncpy( pWideCharBuffer, pUnicodeString, ulUnicodeStringLength );
            pWideCharBuffer[ulUnicodeStringLength] = 0;

            pBuffer = new unsigned char[ulUnicodeStringLength+1];
            if ( !pBuffer || !pWideCharBuffer )
            {
                hr = E_OUTOFMEMORY;
            }
            if ( SUCCEEDED(hr) )
            {
                pBuffer[ulUnicodeStringLength] = 0;
                if ( ulUnicodeStringLength > 0 ) 
                {
                    //--- Map WCHARs to ANSI chars 
                    if ( !WideCharToMultiByte( 1252, NULL, pWideCharBuffer, ulUnicodeStringLength, (char*) pBuffer, 
                                               ulUnicodeStringLength, &g_pFlagCharacter, NULL ) )
                    {
                        hr = E_UNEXPECTED;
                    }
                    //--- Use internal table to map ANSI to ASCII 
                    for (ULONG i = 0; i < ulUnicodeStringLength && SUCCEEDED(hr); i++)
                    {
                        pBuffer[i] = g_AnsiToAscii[pBuffer[i]];
                    }
                    //--- Map back to WCHARs 
                    for ( i = 0; i < ulUnicodeStringLength && SUCCEEDED(hr); i++ )
                    {
                        pConvertedString[i] = pBuffer[i];
                    }
                }
            }
        }
    }
    else
    {
        pConvertedString = NULL;
    }
    
    if (pBuffer)
    {
        delete [] pBuffer;
    }
    if (pWideCharBuffer)
    {
        delete [] pWideCharBuffer;
    }

    return hr;
} /* CStdSentEnum::DoUnicodeToAsciiMap */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\morph.cpp ===
/*******************************************************************************
* morph.cpp *
*-----------*
*   Description:
*       This is the implementation of the CSMorph class, which attempts to find
*   pronunciations for morphologcical variants (which are not in the lexicon) of
*   root words (which are in the lexicon).
*-------------------------------------------------------------------------------
*  Created By: AH, based partly on code by MC                     Date: 08/16/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

// Additional includes...
#include "stdafx.h"
#include "morph.h"
#include "spttsengdebug.h"

/*****************************************************************************
* CSMorph::CSMorph *
*------------------*
*	Description:    Constructor - just sets the Master Lexicon pointer...
*		
********************************************************************** AH ***/
CSMorph::CSMorph( ISpLexicon *pMasterLex, HRESULT *phr ) 
{
    SPDBG_FUNC( "CSMorph::CSMorph" );
    SPDBG_ASSERT( phr != NULL );

    m_pMasterLex = pMasterLex;

    // Initialize the SuffixInfoTable - obtain lock to make sure this only happens once...
    g_SuffixInfoTableCritSec.Lock();
    if (!SuffixInfoTableInitialized)
    {
        CComPtr<ISpPhoneConverter> pPhoneConv;
        *phr = SpCreatePhoneConverter(1033, NULL, NULL, &pPhoneConv);

        for (int i = 0; i < sp_countof(g_SuffixInfoTable); i++)
        {
            *phr = pPhoneConv->PhoneToId(g_SuffixInfoTable[i].SuffixString, g_SuffixInfoTable[i].SuffixString);
            if ( FAILED( *phr ) )
            {
                break;
            }
        }

        if (SUCCEEDED(*phr))
        {
            *phr = pPhoneConv->PhoneToId(g_phonS, g_phonS);
            if (SUCCEEDED(*phr))
            {
                *phr = pPhoneConv->PhoneToId(g_phonZ, g_phonZ);
                if (SUCCEEDED(*phr))
                {
                    *phr = pPhoneConv->PhoneToId(g_phonAXz, g_phonAXz);
                    if (SUCCEEDED(*phr))
                    {
                        *phr = pPhoneConv->PhoneToId(g_phonT, g_phonT);
                        if (SUCCEEDED(*phr))
                        {
                            *phr = pPhoneConv->PhoneToId(g_phonD, g_phonD);
                            if (SUCCEEDED(*phr))
                            {
                                *phr = pPhoneConv->PhoneToId(g_phonAXd, g_phonAXd);
                                if (SUCCEEDED(*phr))
                                {
                                    *phr = pPhoneConv->PhoneToId(g_phonAXl, g_phonAXl);
                                    if ( SUCCEEDED( *phr ) )
                                    {
                                        *phr = pPhoneConv->PhoneToId(g_phonIY, g_phonIY);
                                        if ( SUCCEEDED( *phr ) )
                                        {
                                            *phr = pPhoneConv->PhoneToId(g_phonL, g_phonL);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (SUCCEEDED(*phr))
    {
        SuffixInfoTableInitialized = true;
    }
    g_SuffixInfoTableCritSec.Unlock();

} /* CSMorph::CSMorph */


/*****************************************************************************
* CSMorph::DoSuffixMorph *
*------------------------*
*	Description:    This is the only interface function of CSMorph - it 
*       takes the same arguments as a GetPronunciations() call, and does
*       basically the same thing.  
*		
********************************************************************** AH ***/
HRESULT CSMorph::DoSuffixMorph( const WCHAR *pwWord, WCHAR *pwRoot, LANGID LangID, DWORD dwFlags,
                                SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    SPDBG_FUNC( "CSMorph::DoSuffixMorph" );
    HRESULT hr = S_OK;
    SUFFIX_TYPE suffixCode;
    WCHAR TargWord[SP_MAX_WORD_LENGTH] = {0};
    long RootLen = 0;
    CSuffixList SuffixList;
    bool    bGotMorph, bNotDone, bLTS;

    if ( !pwWord || !pWordPronunciationList )
    {
        hr = E_POINTER;
    }

    else if ( SP_IS_BAD_WRITE_PTR( pwRoot )                        ||
              SPIsBadLexWord(pwWord)                               || 
              SPIsBadWordPronunciationList(pWordPronunciationList) || 
              LangID != 1033)
    {
        hr = E_INVALIDARG;
    }
    
    if (SUCCEEDED(hr)) 
    {        
        // INITIALIZE locals...
        suffixCode = NO_MATCH;
        bGotMorph = false;
        bNotDone = true;
        bLTS = false;

        wcscpy( TargWord, pwWord );           // Copy orth string...
        _wcsupr( TargWord );                  // ...and convert to uppercase
        RootLen = wcslen( TargWord );
        
        // Keep trying to match another suffix until a root word is matched in the lexicon, or
        // until some error condition is reached - no more suffix matches, etc.
        while ( !bGotMorph && bNotDone )
        {
            // Try to match a suffix...
            suffixCode = MatchSuffix( TargWord, &RootLen );
            // ...add it to the suffix list...
            if (suffixCode != NO_MATCH)
            {
                SuffixList.AddHead(&g_SuffixInfoTable[suffixCode]);
            }
            
            // ...and then behave appropriately.
            switch (suffixCode)
            {

                //------------------------------------------------------------
                // S - two special cases for +s suffix...
                //------------------------------------------------------------
            case S_SUFFIX:
                
                //--- Don't strip an S if it is preceded by another S...
                if ( TargWord[RootLen-1] == L'S' )
                {
                    bNotDone = false;
                    RootLen++;
                    SuffixList.RemoveHead();
                    if (!SuffixList.IsEmpty() && (dwFlags & eLEXTYPE_PRIVATE2))
                    {
                        hr = LTSLookup(pwWord, RootLen, pWordPronunciationList);
                        if (SUCCEEDED(hr))
                        {
                            bLTS = true;
                            bGotMorph = true;
                        }
                    }
                    else 
                    {
                        hr = SPERR_NOT_IN_LEX;
                    }
                    break; 
                }

                hr = LexLookup(TargWord, RootLen, dwFlags, pWordPronunciationList);
                if ( SUCCEEDED(hr) ) 
                {
                    bGotMorph = true;
                } 
                else if ( hr != SPERR_NOT_IN_LEX ) 
                {
                    bNotDone = false;
                }
                else if ( TargWord[RootLen - 1] == L'E' )
                {
                    hr = CheckYtoIEMutation(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if (SUCCEEDED(hr))
                    {
                        bGotMorph = true;
                    }
                    else if (hr != SPERR_NOT_IN_LEX)
                    {
                        bNotDone = false;
                    }
                    else
                    {
                        hr = LexLookup(TargWord, RootLen - 1, dwFlags, pWordPronunciationList);
                        if (SUCCEEDED(hr))
                        {
                            bGotMorph = true;
                        }
                        else if (hr != SPERR_NOT_IN_LEX)
                        {
                            bNotDone = false;
                        }
                    }
                }
                break;

                //------------------------------------------------------------
                // ICALLY_SUFFIX - special case, RAID #3201
                //------------------------------------------------------------
            case ICALLY_SUFFIX:
                hr = LexLookup( TargWord, RootLen + 2, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    bGotMorph = true;
                }
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                }
                else
                {
                    RootLen += 2;
                }
                break;

                //-------------------------------------------------------------
                // ILY_SUFFIX - special case, RAID #6571
                //-------------------------------------------------------------
            case ILY_SUFFIX:
                hr = CheckForMissingY( TargWord, RootLen, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    RootLen++;
                    bGotMorph = true;
                }
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                }
                break;

                //------------------------------------------------------------
                // ICISM_SUFFIX, ICIZE_SUFFIX - special case, RAID #6492
                //------------------------------------------------------------
            case ICISM_SUFFIX:
            case ICIZE_SUFFIX:
                hr = LexLookup( TargWord, RootLen + 2, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    bGotMorph = true;
                    for ( SPWORDPRONUNCIATION* pIterator = pWordPronunciationList->pFirstWordPronunciation;
                          pIterator; pIterator = pIterator->pNextWordPronunciation )
                    {
                        pIterator->szPronunciation[ wcslen( pIterator->szPronunciation ) - 1 ] = g_phonS[0];
                    }
                }
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                }
                else
                {
                    RootLen += 2;
                }
                break;

                //------------------------------------------------------------
                // NO_MATCH
                //------------------------------------------------------------
            case NO_MATCH:

                bNotDone = false;
                if (!SuffixList.IsEmpty() && (dwFlags & eLEXTYPE_PRIVATE2))
                {
                    hr = LTSLookup(pwWord, RootLen, pWordPronunciationList);
                    if (SUCCEEDED(hr))
                    {
                        bLTS = true;
                        bGotMorph = true;
                    }
                }
                else 
                {
                    hr = SPERR_NOT_IN_LEX;
                }
                break; 

                //----------------------------------------------------------------
                // ABLY - special case (for probably, etc.) RAID #3168
                //----------------------------------------------------------------
            case ABLY_SUFFIX:
                hr = CheckAbleMutation( TargWord, RootLen, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    for ( SPWORDPRONUNCIATION *pIterator = pWordPronunciationList->pFirstWordPronunciation;
                          pIterator; pIterator = pIterator->pNextWordPronunciation )
                    {
                        if ( wcslen( pIterator->szPronunciation ) > 2 &&
                             wcscmp( ( pIterator->szPronunciation + 
                                       ( wcslen( pIterator->szPronunciation ) - 2 ) ),
                                     g_phonAXl ) == 0 )
                        {
                            wcscpy( ( pIterator->szPronunciation +
                                      ( wcslen( pIterator->szPronunciation ) - 2 ) ),
                                    g_phonL );
                        }
                    }
                    SuffixList.RemoveHead();
                    SuffixList.AddHead( &g_SuffixInfoTable[Y_SUFFIX] );
                    bGotMorph = true;
                    break;
                }   
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                    break;
                }
                //--- else no break - just continue on to default behavior...

                //------------------------------------------------------------
                // ALL OTHER SUFFIXES
                //------------------------------------------------------------
                
            default:

                // If applicable, try looking up the root with an added e first - this prevents things like
                // "taping" coming out as "tapping" rather than "tape +ing"
                // FIX BUG #2301, #3649 - ONLY Try with added e if the root does not end in o, e, w, or y
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) && 
                     (g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckForMissingE) &&
                     TargWord[RootLen-1] != L'O' &&
                     ( TargWord[RootLen-1] != L'E' || suffixCode == ED_SUFFIX ) &&
                     TargWord[RootLen-1] != L'W' &&
                     TargWord[RootLen-1] != L'Y' )
                {
                    hr = CheckForMissingE(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        RootLen++;
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                // Try looking up the root...
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) )
                {
                    hr = LexLookup(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                // If previous lookups failed, try looking up the root with a 'y' in place of the final 'i'...
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) && 
                     (g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckYtoIMutation) )
                {
                    hr = CheckYtoIMutation(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                // If previous lookups failed, try looking up the root with an undoubled ending...
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) && 
                     (g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckDoubledMutation) )
                {
                    hr = CheckDoubledMutation(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        RootLen--;
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                //--- If previous lookups failed, try looking up the root with an added 'l'
                if ( ( SUCCEEDED( hr ) || hr == SPERR_NOT_IN_LEX ) &&
                     ( g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckForMissingL ) )
                {
                    hr = CheckForMissingL( TargWord, RootLen, dwFlags, pWordPronunciationList );
                    if ( SUCCEEDED( hr ) )
                    {
                        RootLen++;
                        bGotMorph = true;
                        break;
                    }
                    else if ( hr != SPERR_NOT_IN_LEX )
                    {
                        bNotDone = false;
                        break;
                    }
                }

                break;

            } // switch (SuffixCode)
        } // while ( !bGotMorph && bNotDone )
        if ( SUCCEEDED(hr) && bGotMorph ) 
        {
            if (!SuffixList.IsEmpty())
            {
                //--- Copy found root word into out parameter, pwRoot
                wcsncpy( pwRoot, TargWord, RootLen );
                //--- Log info to debug file
                TTSDBG_LOGMORPHOLOGY( pwRoot, SuffixList, STREAM_MORPHOLOGY );
                if (bLTS)
                {
                    hr = AccumulateSuffixes_LTS( &SuffixList, pWordPronunciationList );
                }
                else
                {
                    hr = AccumulateSuffixes( &SuffixList, pWordPronunciationList );
                }
            }
        }
    }

    return hr;
} /* CSMorph::DoSuffixMorph */


/*****************************************************************************
* CSMorph::MatchSuffix *
*----------------------*
*	Description:    This function attempts to match a suffix in TargWord.
*		
********************************************************************** AH ***/
SUFFIX_TYPE CSMorph::MatchSuffix( WCHAR *TargWord, long *RootLen )
{
    SPDBG_FUNC( "CSMorph::MatchSuffix" );
    SUFFIX_TYPE suffixCode = NO_MATCH;
    long RootEnd = *RootLen - 1;
    const WCHAR *pTempSuffix = NULL;

    for (int i = 0; i < sp_countof(g_SuffixTable); i++) 
    {
        pTempSuffix = g_SuffixTable[i].Orth;
        while ( (TargWord[RootEnd] == *pTempSuffix) && (RootEnd > 1) && (suffixCode == NO_MATCH) )
        {
            RootEnd--;
            pTempSuffix++;
            if ( *pTempSuffix == '\0' )
            {
                suffixCode = g_SuffixTable[i].Type;
            }
        }
        if (suffixCode != NO_MATCH)
        {
            *RootLen = RootEnd + 1;
            break;
        }
        else
        {
            RootEnd = *RootLen - 1;
        }
    }

    return suffixCode;
} /* CSMorph::MatchSuffix */


/*****************************************************************************
* CSMorph::LexLookup *
*--------------------*
*	Description:    Try to look up the hypothesized root in the lexicon.
*		
********************************************************************** MC ***/
HRESULT CSMorph::LexLookup( const WCHAR *pOrth, long length, DWORD dwFlags, 
                            SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    SPDBG_FUNC( "CSMorph::LexLookup" );
    WCHAR  targRoot[SP_MAX_WORD_LENGTH];
    memset (targRoot, 0, SP_MAX_WORD_LENGTH * sizeof(WCHAR));
    HRESULT hr = SPERR_NOT_IN_LEX;
    
    //---------------------------------
    // Copy root candidate only...
    //---------------------------------
    for( long i = 0; i < length; i++ )
    {
        targRoot[i] = pOrth[i];
    }
    targRoot[i] = 0;    // Delimiter
    
    //---------------------------------
    // ...and look it up
    //---------------------------------
    if (dwFlags & eLEXTYPE_USER)
    {
        hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_USER, pWordPronunciationList );
    }
    if ((hr == SPERR_NOT_IN_LEX) && (dwFlags & eLEXTYPE_APP))
    {
        hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_APP, pWordPronunciationList );
    }
    if ((hr == SPERR_NOT_IN_LEX) && (dwFlags & eLEXTYPE_PRIVATE1))
    {
        hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_PRIVATE1, pWordPronunciationList );
    }

    return hr;
} /* CSMorph::LexLookup */


/*****************************************************************************
* CSMorph::LTSLookup *
*--------------------*
*	Description:    Try to get a pronunciation for the hypothesized root from 
*       the LTS lexicon...
*		
********************************************************************** AH ***/
HRESULT CSMorph::LTSLookup( const WCHAR *pOrth, long length, 
                            SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    SPDBG_FUNC( "CSMorph::LTSLookup" );
    WCHAR targRoot[SP_MAX_WORD_LENGTH];
    memset(targRoot, 0, SP_MAX_WORD_LENGTH * sizeof(WCHAR));
    HRESULT hr = S_OK;

    //-------------------------------
    // Copy root candidate only...
    //-------------------------------
    for ( long i = 0; i < length; i++ )
    {
        targRoot[i] = pOrth[i];
    }
    targRoot[i] = 0;

    //-------------------------------
    // ...and look it up
    //-------------------------------
    hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_PRIVATE2, pWordPronunciationList );

    return hr;
} /* CSMorph::LTSLookup */


/*****************************************************************************
* CSMorph::AccumulateSuffixes *
*-----------------------------*
*	Description:    Append pronunciations of all the suffixes to the
*       retrieved pronunciation of the root word.
*   
*   First attempt a very strict derivation, where each suffix appended has
*   a "To" part of speech which matches the part of speech of the current
*   state of the entire word.  Ex:
*
*       govern (Verb) + ment (Verb -> Noun) + s (Noun -> Noun) -> governments (Noun)
*
*   If this fails, just accumulate all the pronunciations, and use all of
*   the "To" parts of speech of the last suffix.  Ex:
*
*       cat (Noun) + ing (Verb -> Verb, Verb -> Adj, Verb -> Noun) -> catting (Verb, Adj, Noun)
*		
********************************************************************** AH ***/
HRESULT CSMorph::AccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList ) 
{
    /********** Local Variable Declarations **********/
    SPWORDPRONUNCIATIONLIST *pTempWordPronunciationList;
    SPWORDPRONUNCIATION *pWordPronIterator = NULL, *pTempWordPronunciation = NULL;
    SPLISTPOS ListPos;
    SUFFIXPRON_INFO *SuffixPronInfo;
    ENGPARTOFSPEECH ActivePos[NUM_POS] = {MS_Unknown}, FinalPos[NUM_POS] = {MS_Unknown};
    WCHAR pBuffer[SP_MAX_PRON_LENGTH], pSuffixString[10];
    DWORD dwTotalSize = 0, dwNumActivePos = 0, dwNumFinalPos = 0;
    HRESULT hr = S_OK;
    bool bPOSMatch = false, bDerivedAWord = false;

    /********** Allocate enough space for the modified pronunciations **********/
    dwTotalSize = sizeof(SPWORDPRONUNCIATIONLIST) + 
        (NUM_POS * (sizeof(SPWORDPRONUNCIATION) + (SP_MAX_PRON_LENGTH * sizeof(WCHAR))));
    pTempWordPronunciationList = new SPWORDPRONUNCIATIONLIST;
    if ( !pTempWordPronunciationList )
    {
        hr = E_OUTOFMEMORY;
    }
    if ( SUCCEEDED( hr ) )
    {
        memset(pTempWordPronunciationList, 0, sizeof(SPWORDPRONUNCIATIONLIST));
        hr = ReallocSPWORDPRONList( pTempWordPronunciationList, dwTotalSize );
    }

    /************************************
     *  First Attempt Strict Derivation *
     ************************************/

    /********** Set Initial Values of prounciation list iterators **********/
    if (SUCCEEDED(hr))
    {
        pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
        pTempWordPronunciation = pTempWordPronunciationList->pFirstWordPronunciation;
    }

    /********** Iterate over pWordPronunciationList **********/
    while (SUCCEEDED(hr) && pWordPronIterator)
    {
        // Store the pronunciation in a buffer...
        wcscpy(pBuffer, pWordPronIterator->szPronunciation);

        // Initialize variables which are local to the next loop...
        bPOSMatch = true;
        ListPos = pSuffixList->GetHeadPosition();

        ActivePos[0] = (ENGPARTOFSPEECH)pWordPronIterator->ePartOfSpeech;
        dwNumActivePos = 1;

        /********** Iterate over the SuffixList **********/
        while ( SUCCEEDED(hr) && ListPos && bPOSMatch ) 
        {
            // Initialize variables which are local to the next loop...
            bPOSMatch = false;
            SuffixPronInfo = pSuffixList->GetNext( ListPos );
            wcsncpy(pSuffixString, SuffixPronInfo->SuffixString,10);
            pSuffixString[9] = L'\0';
            ENGPARTOFSPEECH NextActivePos[NUM_POS] = {MS_Unknown};
            DWORD dwNumNextActivePos = 0;
            
            /********** Iterate over the active parts of speech **********/
            for (DWORD j = 0; j < dwNumActivePos; j++)
            {
                /********** Iterate over the possible conversions of each suffix **********/
                for (short i = 0; i < SuffixPronInfo->NumConversions; i++)
                {
                    /********** Check POS compatability **********/
                    if (SuffixPronInfo->Conversions[i].FromPos == ActivePos[j])
                    {
                        if (!SearchPosSet(SuffixPronInfo->Conversions[i].ToPos, NextActivePos, dwNumNextActivePos))
                        {
                            NextActivePos[dwNumNextActivePos] = SuffixPronInfo->Conversions[i].ToPos;
                            dwNumNextActivePos++;

                            /********** One time only - concatenate pronunciation, and change POSMatch flag to true **********/
                            if (dwNumNextActivePos == 1)
                            {
                                bPOSMatch = true;

                                // Append suffix to the rest of the pronunciation...
                                // Special Cases...
                                if (pSuffixString[0] == g_phonS[0] && pSuffixString[1] == '\0')
                                {
                                    hr = Phon_SorZ( pBuffer, wcslen(pBuffer) - 1 );
                                }
                                else if (pSuffixString[0] == g_phonD[0] && pSuffixString[1] == '\0')
                                {
                                    hr = Phon_DorED( pBuffer, wcslen(pBuffer) - 1 );
                                }
                                // Default Case...
                                else
                                {
                                    if ( SuffixPronInfo == g_SuffixInfoTable + ICISM_SUFFIX ||
                                         SuffixPronInfo == g_SuffixInfoTable + ICIZE_SUFFIX )
                                    {
                                        pBuffer[ wcslen( pBuffer ) - 1 ] = g_phonS[0];
                                    }

                                    // Make sure we don't write past the end of the buffer...
                                    if ( wcslen(pBuffer) + wcslen(pSuffixString) < SP_MAX_PRON_LENGTH )
                                    {
                                        wcscat(pBuffer, pSuffixString);
                                    }
                                    else
                                    {
                                        hr = E_FAIL;
                                    }
                                }
                            }
                        }
                    }
                } // for (short i = 0; i < SuffixPronInfo->NumConversions; i++)
            } // for (DWORD j = 0; j < dwNumActivePos; j++)

            /********** Update ActivePos values **********/
            for (DWORD i = 0; i < dwNumNextActivePos; i++)
            {
                ActivePos[i] = NextActivePos[i];
            }
            dwNumActivePos = dwNumNextActivePos;

        } // while ( SUCCEEDED(hr) && ListPos && bPOSMatch )

        /********** Check to see if any derivations have succeeded **********/
        if ( SUCCEEDED(hr) && bPOSMatch )
        {
            for (DWORD i = 0; i < dwNumActivePos; i++)
            {
                if (!SearchPosSet(ActivePos[i], FinalPos, dwNumFinalPos))
                {
                    // We have succeeded in deriving a word - add it to the temporary word pron list...
                    FinalPos[dwNumFinalPos] = ActivePos[i];
                    dwNumFinalPos++;
                    if ( bDerivedAWord )
                    {
                        // This is not the first successful pronunciation match - need to advance the iterator...
                        pTempWordPronunciation->pNextWordPronunciation = CreateNextPronunciation( pTempWordPronunciation );
                        pTempWordPronunciation = pTempWordPronunciation->pNextWordPronunciation;
                    }
                    bDerivedAWord = true;
                    pTempWordPronunciation->eLexiconType = (SPLEXICONTYPE)(pWordPronIterator->eLexiconType | eLEXTYPE_PRIVATE3);
                    pTempWordPronunciation->ePartOfSpeech = (SPPARTOFSPEECH) ActivePos[i];
                    pTempWordPronunciation->LangID = pWordPronIterator->LangID;
                    wcscpy(pTempWordPronunciation->szPronunciation, pBuffer);
                    pTempWordPronunciation->pNextWordPronunciation = NULL;
                }
            }
        }

        // Advance SPWORDPRONUNCIATIONLIST iterator...
        if (SUCCEEDED(hr))
        {
            pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
        }

    } // while (SUCCEEDED(hr) && pWordPronIterator)


    /****************************************
     * Did we succeed in deriving anything? *
     ****************************************/

    /**********************************************************
     * If so, copy it into pWordPronunciationList and return. *
     **********************************************************/
    if ( SUCCEEDED(hr) && bDerivedAWord )
    {
        // Copy successful words into pWordPronunciationList for eventual return to DoSuffixMorph() caller...
        hr = ReallocSPWORDPRONList(pWordPronunciationList, pTempWordPronunciationList->ulSize);
        if (SUCCEEDED(hr))
        {
            pWordPronIterator = pTempWordPronunciationList->pFirstWordPronunciation;
            pTempWordPronunciation = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
            while (SUCCEEDED(hr) && pWordPronIterator)
            {
                pTempWordPronunciation->eLexiconType = (SPLEXICONTYPE)(pWordPronIterator->eLexiconType);
                pTempWordPronunciation->ePartOfSpeech = pWordPronIterator->ePartOfSpeech;
                pTempWordPronunciation->LangID = pWordPronIterator->LangID;
                wcscpy(pTempWordPronunciation->szPronunciation, pWordPronIterator->szPronunciation);
                pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
                if (pWordPronIterator)
                {
                    pTempWordPronunciation->pNextWordPronunciation = CreateNextPronunciation( pTempWordPronunciation );
                    pTempWordPronunciation = pTempWordPronunciation->pNextWordPronunciation;
                }
                else
                {
                    pTempWordPronunciation->pNextWordPronunciation = NULL;
                }
            }
        }
    }
    /***************************************
     * If not, just do default derivation. *
     ***************************************/
    else if ( SUCCEEDED(hr) )
    {
        hr = DefaultAccumulateSuffixes( pSuffixList, pWordPronunciationList );
    }
    ::CoTaskMemFree(pTempWordPronunciationList->pvBuffer);
    delete pTempWordPronunciationList;

    return hr;
} /* CSMorph::AccumulateSuffixes */


/*****************************************************************************
* CSMorph::AccumulateSuffixes_LTS *
*---------------------------------*
*	Description:    Append pronunciations of all the suffixes to the
*       retrieved pronunciation of the root word.
*		
********************************************************************** AH ***/
HRESULT CSMorph::AccumulateSuffixes_LTS( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList ) 
{
    HRESULT hr = S_OK;
    SPWORDPRONUNCIATION *pTempWordPronunciation = NULL, *pOriginalWordPronunciation = NULL;
    DWORD dwTotalSize = 0, dwNumPos = 0;
    SUFFIXPRON_INFO *SuffixPronInfo;
    ENGPARTOFSPEECH PartsOfSpeech[NUM_POS] = {MS_Unknown};
    WCHAR pBuffer[SP_MAX_PRON_LENGTH];
    SPLEXICONTYPE OriginalLexType;
    LANGID OriginalLangID;
    WORD OriginalReservedField;

    /*** Get the original pronunciation ***/
    pOriginalWordPronunciation = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
    OriginalLexType = pOriginalWordPronunciation->eLexiconType;
    OriginalLangID  = pOriginalWordPronunciation->LangID;
    OriginalReservedField = pOriginalWordPronunciation->wReserved;

    /*** Get First Suffix ***/
    SuffixPronInfo = pSuffixList->RemoveHead();

    /*** Copy the pronunciation of the root ***/
    wcscpy( pBuffer, pOriginalWordPronunciation->szPronunciation );

    /*** Append the pronunciation of the first suffix ***/
    if ( SuffixPronInfo->SuffixString[0] == g_phonS[0] && 
         SuffixPronInfo->SuffixString[1] == 0 )
    {
        hr = Phon_SorZ( pBuffer, wcslen(pBuffer) - 1 );
    }
    else if ( SuffixPronInfo->SuffixString[0] == g_phonD[0] &&
              SuffixPronInfo->SuffixString[1] == 0 )
    {
        hr = Phon_DorED( pBuffer, wcslen(pBuffer) - 1 );
    }
    else if ( wcslen(pBuffer) + wcslen(SuffixPronInfo->SuffixString) < SP_MAX_PRON_LENGTH )
    {
        if ( SuffixPronInfo == g_SuffixInfoTable + ICISM_SUFFIX ||
             SuffixPronInfo == g_SuffixInfoTable + ICIZE_SUFFIX )
        {
            pBuffer[ wcslen( pBuffer ) - 1 ] = g_phonS[0];
        }

        wcscat( pBuffer, SuffixPronInfo->SuffixString );
    }

    if ( SUCCEEDED( hr ) )
    {
        /*** Allocate enough space for all of the pronunciations ***/
        dwTotalSize = sizeof(SPWORDPRONUNCIATIONLIST) + 
                      ( NUM_POS * ( sizeof(SPWORDPRONUNCIATION) + (SP_MAX_PRON_LENGTH * sizeof(WCHAR) ) ) );
        hr = ReallocSPWORDPRONList( pWordPronunciationList, dwTotalSize );
    }

    if ( SUCCEEDED( hr ) )
    {
        /*** Build list of parts of speech ***/
        for ( int i = 0; i < SuffixPronInfo->NumConversions; i++ )
        {
            if ( !SearchPosSet( SuffixPronInfo->Conversions[i].ToPos, PartsOfSpeech, dwNumPos ) )
            {
                PartsOfSpeech[dwNumPos] = SuffixPronInfo->Conversions[i].ToPos;
                dwNumPos++;
            }
        }

        pTempWordPronunciation = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;

        /*** Build TempWordPronunciationList to send to AccumulateSuffixes ***/
        for ( i = 0; i < (int) dwNumPos; i++ )
        {
            if ( i > 0 )
            {
                pTempWordPronunciation->pNextWordPronunciation = CreateNextPronunciation( pTempWordPronunciation );
                pTempWordPronunciation = pTempWordPronunciation->pNextWordPronunciation;
            }
            pTempWordPronunciation->eLexiconType           = (SPLEXICONTYPE)(OriginalLexType | eLEXTYPE_PRIVATE3);
            pTempWordPronunciation->LangID                 = OriginalLangID;
            pTempWordPronunciation->wReserved              = OriginalReservedField;
            pTempWordPronunciation->ePartOfSpeech          = (SPPARTOFSPEECH)PartsOfSpeech[i];
            pTempWordPronunciation->pNextWordPronunciation = NULL;
            wcscpy(pTempWordPronunciation->szPronunciation, pBuffer);
        }
    }

    if ( SUCCEEDED( hr ) &&
         !pSuffixList->IsEmpty() )
    {
        /*** Pass accumulated list to AccumulateSuffixes ***/
        hr = AccumulateSuffixes( pSuffixList, pWordPronunciationList );
    }

    return hr;
} /* CSMorph::AccumulateSuffixes_LTS */

/*****************************************************************************
* CSMorph::DefaultAccumulateSuffixes *
*------------------------------------*
*	Description:    Append pronunciations of all the suffixes to the
*       retrieved pronunciation of the root word.
*   
*   Just accumulate all the pronunciations, and use all of
*   the "To" parts of speech of the last suffix.  Ex:
*
*       cat (Noun) + ing (Verb -> Verb, Verb -> Adj, Verb -> Noun) -> catting (Verb, Adj, Noun)
*		
********************************************************************** AH ***/
HRESULT CSMorph::DefaultAccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    HRESULT hr = S_OK;
    ENGPARTOFSPEECH PartsOfSpeech[NUM_POS] = { MS_Unknown };
    SPWORDPRONUNCIATION *pWordPronIterator = NULL;
    WCHAR pBuffer[SP_MAX_PRON_LENGTH];
    SUFFIXPRON_INFO *SuffixPronInfo = NULL;
    SPLISTPOS ListPos;
    DWORD dwTotalSize = 0;
    int NumPOS = 0;
    SPLEXICONTYPE OriginalLexType;
    LANGID OriginalLangID;
    WORD OriginalReservedField;

    /*** Initialize pBuffer and OriginalXXX variables ***/
    ZeroMemory( pBuffer, sizeof( pBuffer ) );
    OriginalLexType = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->eLexiconType;
    OriginalLangID  = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->LangID;
    OriginalReservedField = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->wReserved;

    /****************************************************************
     *** Get Desired Pronunciation of result, and Parts of Speech ***
     ****************************************************************/

    //--- Get pronunciation of root word
    wcscpy( pBuffer, ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->szPronunciation );

    //--- Loop through suffix list, appending pronunciations of suffixes to that of the root.
    ListPos = pSuffixList->GetHeadPosition();

    //--- List should never be empty at this point
    SPDBG_ASSERT( ListPos );
    while ( ListPos )
    {
        SuffixPronInfo = pSuffixList->GetNext( ListPos );
        if ( wcslen(pBuffer) + wcslen(SuffixPronInfo->SuffixString) < SP_MAX_PRON_LENGTH )
        {
            wcscat( pBuffer, SuffixPronInfo->SuffixString );
        }
    }
    
    //--- Get the "to" parts of speech of the last suffix
    for ( int i = 0; i < SuffixPronInfo->NumConversions; i++ )
    {
        PartsOfSpeech[i] = SuffixPronInfo->Conversions[i].ToPos;
    }
    NumPOS = i;

    /***********************************************************************************
     * Now put derived words into pWordPronunciationList for return from DoSuffixMorph *
     ***********************************************************************************/

    //--- First make sure there is enough room
    dwTotalSize = sizeof(SPWORDPRONUNCIATIONLIST) + ( NumPOS * PronSize(pBuffer) );                      
    hr = ReallocSPWORDPRONList( pWordPronunciationList, dwTotalSize );

    if ( SUCCEEDED( hr ) )
    {
        //--- Now add pronunciation once for each part of speech
        pWordPronIterator = pWordPronunciationList->pFirstWordPronunciation;
        for ( i = 0; i < NumPOS; i++ )
        {
            pWordPronIterator->eLexiconType  = (SPLEXICONTYPE) ( OriginalLexType |  eLEXTYPE_PRIVATE3 );
            pWordPronIterator->LangID        = OriginalLangID;
            pWordPronIterator->wReserved     = OriginalReservedField;
            pWordPronIterator->ePartOfSpeech = (SPPARTOFSPEECH)PartsOfSpeech[i];
            wcscpy( pWordPronIterator->szPronunciation, pBuffer );
            if ( i < NumPOS - 1 )
            {
                pWordPronIterator->pNextWordPronunciation = CreateNextPronunciation( pWordPronIterator );
                pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
            }
            else
            {
                pWordPronIterator->pNextWordPronunciation = NULL;
            }
        }
    }

    return hr;
}

/*****************************************************************************
* CSMorph::CheckForMissingE *
*---------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'e' 
*       e.g. make -> making
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckForMissingE( WCHAR *pOrth, long length, DWORD dwFlags, 
                                 SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    WCHAR   charSave;
    
    charSave = pOrth[length];			// save orig before we...
    pOrth[length] = L'E'; 				// ...end root with E
    hr = LexLookup( pOrth, length+1, dwFlags, pWordPronunciationList );
    if ( FAILED(hr) )
    {
        pOrth[length] = charSave;		// restore original char   
    }
    else if ( length > 0 &&
              pOrth[length - 1] == L'L' )
    {
        //--- Check for juggle -> juggler schwa deletion
        SPWORDPRONUNCIATION *pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
        while ( pWordPronIterator )
        {
            if ( wcslen( pWordPronIterator->szPronunciation ) >= 2 )
            {
                WCHAR *pLastTwoPhonemes = pWordPronIterator->szPronunciation + 
                    ( wcslen( pWordPronIterator->szPronunciation ) - 2 );
                if ( wcscmp( pLastTwoPhonemes, g_phonAXl ) == 0 )
                {
                    //--- Orthography ends in -le and pronunciation ends in -AXl, delete AX...
                    pLastTwoPhonemes[0] = pLastTwoPhonemes[1];
                    pLastTwoPhonemes[1] = 0;
                }
                pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
            }
        }
    }
    return hr;
} /* CSMorph::CheckForMissingE */

/*****************************************************************************
* CSMorph::CheckForMissingY *
*---------------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'y' 
*       e.g. happy -> happily
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckForMissingY( WCHAR *pOrth, long length, DWORD dwFlags, 
                                   SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    WCHAR   charSave;
    
    charSave = pOrth[length];			// save orig before we...
    pOrth[length] = L'Y'; 				// ...end root with E
    hr = LexLookup( pOrth, length+1, dwFlags, pWordPronunciationList );
    if ( FAILED(hr) )
    {
        pOrth[length] = charSave;		// restore original char   
    }
    else 
    {
        //--- Delete IY at end of pronunciations ( e.g. happy + ily -> [ H AE 1 P (IY) ] + [ AX L IY ] )
        for ( SPWORDPRONUNCIATION *pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation; 
              pWordPronIterator; pWordPronIterator = pWordPronIterator->pNextWordPronunciation )
        {
            if ( pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] == g_phonIY[0] )
            {
                pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] = 0;
            }
        }
    }
    return hr;
} /* CSMorph::CheckForMissingY */

/*****************************************************************************
* CSMorph::CheckForMissingL *
*---------------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'l' 
*       e.g. chill -> chilly
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckForMissingL( WCHAR *pOrth, long length, DWORD dwFlags, 
                                   SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    WCHAR   charSave;
    
    charSave = pOrth[length];			// save orig before we...
    pOrth[length] = L'L'; 				// ...end root with E
    hr = LexLookup( pOrth, length+1, dwFlags, pWordPronunciationList );
    if ( FAILED(hr) )
    {
        pOrth[length] = charSave;		// restore original char   
    }
    else 
    {
        //--- Delete l at end of pronunciations ( e.g. chill +ly -> [ ch ih 1 (l) ] + [ l iy ] )
        for ( SPWORDPRONUNCIATION *pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation; 
              pWordPronIterator; pWordPronIterator = pWordPronIterator->pNextWordPronunciation )
        {
            if ( pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] == g_phonL[0] )
            {
                pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] = 0;
            }
        }
    }
    return hr;
} /* CSMorph::CheckForMissingL */

/*****************************************************************************
* CSMorph::CheckYtoIMutation *
*---------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'y' to
*       an 'i'
*       e.g. steady + est -> steadiest
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckYtoIMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                    SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    
    if ( pOrth[length - 1] == L'I' )
    {
        pOrth[length - 1] = L'Y'; 				// end root with Y
        hr = LexLookup( pOrth, length, dwFlags, pWordPronunciationList );
        if ( FAILED(hr) )
        {
            pOrth[length - 1] = L'I';		    // restore I 
        }
    } 
    else 
    {
        hr = SPERR_NOT_IN_LEX;
    }
    return hr;
} /* CSMorph::CheckYtoIMutation */


/*****************************************************************************
* CSMorph::CheckDoubledMutation *
*----------------------*
*	Description:    Check Lexicon to see if the root word has a doubled 
*       consonant.
*       e.g. run + ing -> running
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckDoubledMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                       SPWORDPRONUNCIATIONLIST *pWordPronunciationList)
{
    HRESULT hr = S_OK;

    switch ( pOrth[length - 1] )
    {
        // Filter the vowels, which never double...
    case L'A':
    case L'E':
    case L'I':
    case L'O':
    case L'U':
    case L'Y':
        // Filter consonants which never double, or are doubled in roots...
    case L'F':
    case L'H':
    case L'K':
    case L'S':
    case L'W':
    case L'Z':
        hr = SPERR_NOT_IN_LEX;
        break;

    default:
		if(pOrth[length-1] == pOrth[length-2]) {
	        hr = LexLookup( pOrth, length - 1, dwFlags, pWordPronunciationList );
		    break;
		}
		else {
			hr = SPERR_NOT_IN_LEX;
			break;
		}
    }
    return hr;
} /* CSMorph::CheckDoubledMutation */

/*****************************************************************************
* CSMorph::CheckYtoIEMutation *
*---------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'y' to
*       an 'ie'
*       e.g. company + s -> companies
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckYtoIEMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                    SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    
    if ( pOrth[length - 1] == L'E' && pOrth[length-2] == L'I' )
    {
        pOrth[length - 2] = L'Y'; 				// end root with Y
        hr = LexLookup( pOrth, length - 1, dwFlags, pWordPronunciationList );
        if ( FAILED(hr) )
        {
            pOrth[length - 2] = L'I';		    // restore I 
        }
    } 
    else 
    {
        hr = SPERR_NOT_IN_LEX;
    }
    return hr;
} /* CSMorph::CheckYtoIMutation */

/*****************************************************************************
* CSMorph::CheckAbleMutation *
*----------------------------*
*	Description:    Check Lexicon for special -able -> -ably cases (e.g.
*       probable -> probably )
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckAbleMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                    SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    
    //--- Look up word ending in -able
    pOrth[length+3] = L'E';
    hr = LexLookup( pOrth, length + 4, dwFlags, pWordPronunciationList );
    if ( FAILED( hr ) )
    {
        //--- restore "y"
        pOrth[length+3] = L'Y';
    }
    return hr;
} /* CSMorph::CheckAbleMutation */

/*****************************************************************************
* CSMorph::Phon_SorZ *
*--------------------*
*	Description:    Figure out what phoneme the S suffix should be - s, z, or 
*                   IXz
*		
********************************************************************** AH ***/
HRESULT CSMorph::Phon_SorZ( WCHAR *pPronunciation, long length )
{
    HRESULT hr = S_OK;

    if ( SUCCEEDED(hr) && pPronunciation[length] < sp_countof(g_PhonTable) ) 
    {
        if ( ((PHONTYPE)g_PhonTable[pPronunciation[length]] & ePALATALF) || 
             (pPronunciation[length] == g_phonS[0])           || 
             (pPronunciation[length] == g_phonZ[0]) )
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonAXz) < SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonAXz);
            }
        } 
        else if( ((PHONTYPE)g_PhonTable[pPronunciation[length]] & eCONSONANTF) && 
                 !((PHONTYPE)g_PhonTable[pPronunciation[length]] & eVOICEDF) )
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonZ) < SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonS);
            }
        }
        else
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonS) < SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonZ);
            }
        }
    }
    else 
    {
        hr = E_FAIL;
    }

    return hr;
} /* CSMorph::Phon_SorZ */

/*****************************************************************************
* CSMorph::Phon_DorED *
*---------------------*
*	Description:    Figure out what phoneme the D suffix should be - d, t,
*                   or AXd
*		
********************************************************************** AH ***/
HRESULT CSMorph::Phon_DorED( WCHAR *pPronunciation, long length )
{
    HRESULT hr = S_OK;

    if ( SUCCEEDED(hr) && pPronunciation[length] < sp_countof(g_PhonTable) ) 
    {
        if ( (pPronunciation[length] == g_phonT[0]) || (pPronunciation[length] == g_phonD[0]) )
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonAXd) < SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonAXd);
            }
        } 
        else if ((PHONTYPE)g_PhonTable[pPronunciation[length]] & eVOICEDF)
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonD) < SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonD);
            }
        }
        else 
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonT) < SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonT);
            }
        }
    }
    else 
    {
        hr = E_FAIL;
    }

    return hr;
} /* CSMorph::Phon_DorED */

//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\makefile.inc ===
SelfRegister :
!if defined(MAKEDLL)
	regsvr32 /s $(O)\$(TARGETNAME).dll
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\miscnorm.cpp ===
/***********************************************************************************************
* MiscNorm.cpp *
*--------------*
*  Description:
*   These are miscallaneous functions used in normalization.
*-----------------------------------------------------------------------------------------------
*  Created by AH                                                                August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

/*****************************************************************************
* IsStateAndZipcode *
*-------------------*
*       This function checks to see if the next two tokens are a state
*   abbreviation and zipcode.
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::IsStateAndZipcode( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                         CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsStateAndZipcode" );
    HRESULT hr = S_OK;

    const StateStruct *pState = NULL;
    const WCHAR temp = *m_pEndOfCurrItem;
    *( (WCHAR*) m_pEndOfCurrItem ) = 0;

    //--- Try to match a state abbreviation
    pState = (StateStruct*) bsearch( (void*) m_pNextChar, (void*) g_StateAbbreviations, sp_countof( g_StateAbbreviations),
                                     sizeof( StateStruct ), CompareStringAndStateStruct );

    if ( pState )
    {
        *( (WCHAR*) m_pEndOfCurrItem ) = temp;

        const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfCurrItem = m_pEndOfCurrItem;
        const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;
        CItemList PostStateList;
        TTSItemInfo *pZipCodeInfo;
        
        m_pNextChar = m_pEndOfCurrItem;
        if ( *m_pNextChar == L',' || 
             *m_pNextChar == L';' )
        {
            m_pNextChar++;
        }

        hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostStateList );

        if ( !m_pNextChar &&
             SUCCEEDED( hr ) )
        {
            hr = E_INVALIDARG;
        }
        else if ( SUCCEEDED( hr ) )
        {
            m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
            while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) )  != eUNMATCHED ||
                    IsGroupEnding( *(m_pEndOfCurrItem - 1) )      != eUNMATCHED ||
                    IsQuotationMark( *(m_pEndOfCurrItem - 1) )    != eUNMATCHED ||
                    IsEOSItem( *(m_pEndOfCurrItem - 1) )          != eUNMATCHED )
            {
                m_pEndOfCurrItem--;
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = IsZipCode( pZipCodeInfo, L"ZIPCODE", MemoryManager );
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo = 
                    (TTSStateAndZipCodeItemInfo*) MemoryManager.GetMemory( sizeof( TTSStateAndZipCodeItemInfo ), 
                                                                           &hr );
                if ( SUCCEEDED( hr ) )
                {
                    pItemNormInfo->Type = eSTATE_AND_ZIPCODE;
                    ( (TTSStateAndZipCodeItemInfo*) pItemNormInfo )->pZipCode = (TTSZipCodeItemInfo*) pZipCodeInfo;

                    TTSWord Word;
                    ZeroMemory( &Word, sizeof( TTSWord ) );

                    //--- Some states have multi-word names 
                    const WCHAR *pNextPointer = NULL, *pPrevPointer = NULL;
                    ULONG ulLength = 0;

                    pNextPointer = pState->FullName.pStr;
                    do {
                        pPrevPointer = pNextPointer;
                        pNextPointer = wcschr(pPrevPointer, L' ');
                        if (pNextPointer)
                        {
                            ulLength = (ULONG)(pNextPointer - pPrevPointer);
                            pNextPointer++;
                        }
                        else
                        {
                            ulLength = wcslen(pPrevPointer);
                        }
                        Word.pXmlState          = &pTempFrag->State;
                        Word.pWordText          = pPrevPointer;
                        Word.ulWordLen          = ulLength;
                        Word.pLemma             = pPrevPointer;
                        Word.ulLemmaLen         = ulLength;
                        Word.eWordPartOfSpeech  = MS_Unknown;
                        WordList.AddTail( Word );

                    } while ( pNextPointer );
                    
                    while( !PostStateList.IsEmpty() )
                    {
                        WordList.AddTail( ( PostStateList.RemoveHead() ).Words[0] );
                    }

                    hr = ExpandZipCode( (TTSZipCodeItemInfo*) pZipCodeInfo, WordList );
                }
            }
            else
            {
                m_pNextChar      = pTempNextChar;
                m_pEndOfCurrItem = pTempEndOfCurrItem;
                m_pEndChar       = pTempEndChar;
                m_pCurrFrag      = pTempFrag;
                hr = E_INVALIDARG;
            }
        }
        m_pNextChar = pTempNextChar;
    }
    else
    {
        *( (WCHAR*) m_pEndOfCurrItem ) = temp;
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsStateAndZipcode */

/*****************************************************************************
* IsHyphenatedString *
*--------------------*
*       This function checks to see if the next token is a hyphenated string
*   consisting of two alpha words or numbers, or one of these and another
*   hyphenated string.
********************************************************************* AH ****/
HRESULT CStdSentEnum::IsHyphenatedString( const WCHAR* pStartChar, const WCHAR* pEndChar, 
                                          TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsHyphenatedString" );
    HRESULT hr = S_OK;
    TTSItemInfo *pFirstChunkInfo = NULL, *pSecondChunkInfo = NULL;

    const WCHAR* pHyphen = NULL, *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    for ( pHyphen = pStartChar; pHyphen < pEndChar; pHyphen++ )
    {
        if ( *pHyphen == L'-' )
        {
            break;
        }
    }

    if ( *pHyphen == L'-'       && 
         pHyphen > pStartChar   &&
         pHyphen < pEndChar - 1 )
    {        
        hr = IsAlphaWord( pStartChar, pHyphen, pFirstChunkInfo, MemoryManager );
        if ( hr == E_INVALIDARG )
        {
            m_pNextChar      = pStartChar;
            m_pEndOfCurrItem = pHyphen;
            hr = IsNumberCategory( pFirstChunkInfo, L"NUMBER", MemoryManager );
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = IsAlphaWord( pHyphen + 1, pEndChar, pSecondChunkInfo, MemoryManager );
            if ( hr == E_INVALIDARG )
            {
                m_pNextChar      = pHyphen + 1;
                m_pEndOfCurrItem = pEndChar;
                hr = IsNumberCategory( pSecondChunkInfo, L"NUMBER", MemoryManager );
            }
            if ( hr == E_INVALIDARG )
            {
                hr = IsHyphenatedString( pHyphen + 1, pEndChar, pSecondChunkInfo, MemoryManager );
            }
            if ( hr == E_INVALIDARG )
            {
                if ( pFirstChunkInfo->Type != eALPHA_WORD )
                {
                    delete ( (TTSNumberItemInfo*) pFirstChunkInfo )->pWordList;
                }
            }
        }
        m_pNextChar      = pTempNextChar;
        m_pEndOfCurrItem = pTempEndOfItem;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        pItemNormInfo = (TTSHyphenatedStringInfo*) MemoryManager.GetMemory( sizeof(TTSHyphenatedStringInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eHYPHENATED_STRING;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pFirstChunkInfo  = pFirstChunkInfo;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pSecondChunkInfo = pSecondChunkInfo;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pFirstChunk      = pStartChar;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pSecondChunk     = pHyphen + 1;
        }
    }

    return hr;
} /* IsHyphenatedString */

/*****************************************************************************
* ExpandHyphenatedString *
*------------------------*
*       This function expands hyphenated strings.
********************************************************************* AH ****/
HRESULT CStdSentEnum::ExpandHyphenatedString( TTSHyphenatedStringInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandHyphenatedString" );
    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( pItemInfo->pFirstChunkInfo->Type == eALPHA_WORD )
    {
        Word.pWordText  = pItemInfo->pFirstChunk;
        Word.ulWordLen  = (ULONG)(pItemInfo->pSecondChunk - pItemInfo->pFirstChunk - 1);
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }
    else
    {
        hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pFirstChunkInfo, WordList );
    }

    if ( SUCCEEDED( hr ) )
    {
        if ( pItemInfo->pSecondChunkInfo->Type == eALPHA_WORD )
        {
            Word.pWordText  = pItemInfo->pSecondChunk;
            Word.ulWordLen  = (ULONG)(m_pEndOfCurrItem - pItemInfo->pSecondChunk);
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else if ( pItemInfo->pSecondChunkInfo->Type == eHYPHENATED_STRING )
        {
            hr = ExpandHyphenatedString( (TTSHyphenatedStringInfo*) pItemInfo->pSecondChunkInfo, WordList );
        }
        else
        {
            hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pSecondChunkInfo, WordList );
        }
    }

    return hr;
} /* ExpandHyphenatedString */

/*****************************************************************************
* IsSuffix *
*----------*
*       This function checks to see if the next token is a suffix string 
*   consisting of a hyphen followed by alpha characters.
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::IsSuffix( const WCHAR* pStartChar, const WCHAR* pEndChar, 
                                TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsSuffix" );
    HRESULT hr = S_OK;

    if ( *pStartChar == L'-' )
    {
        const WCHAR *pIterator = pStartChar + 1;
        while ( pIterator < pEndChar &&
                iswalpha( *pIterator ) )
        {
            pIterator++;
        }

        if ( pIterator == pEndChar &&
             pIterator != ( pStartChar + 1 ) )
        {
            pItemNormInfo = (TTSSuffixItemInfo*) MemoryManager.GetMemory( sizeof( TTSSuffixItemInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo->Type = eSUFFIX;
                ( (TTSSuffixItemInfo*) pItemNormInfo )->pFirstChar = pStartChar + 1;
                ( (TTSSuffixItemInfo*) pItemNormInfo )->ulNumChars = (ULONG)( ( pEndChar - pStartChar ) - 1 );
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsSuffix */

/*****************************************************************************
* ExpandSuffix *
*--------------*
*       This function expands strings determined to by suffixes by IsSuffix
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::ExpandSuffix( TTSSuffixItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandSuffix" );
    HRESULT hr = S_OK;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    for ( ULONG i = 0; i < pItemInfo->ulNumChars; i++ )
    {
        Word.pWordText  = g_ANSICharacterProns[ pItemInfo->pFirstChar[i] ].pStr;
        Word.ulWordLen  = g_ANSICharacterProns[ pItemInfo->pFirstChar[i] ].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    return hr;
} /* ExpandSuffix */

/*****************************************************************************
* ExpandPunctuation *
*-------------------*
*       This function expands punctuation marks into words - e.g. '.' becomes
*   "period".  It actually just uses the same table that 
*   ExpandUnrecognizedString uses to look up string versions of characters.
********************************************************************* AH ****/
void CStdSentEnum::ExpandPunctuation( CWordList& WordList, WCHAR wc )
{
    const WCHAR *pPrevPointer = NULL, *pNextPointer = NULL;
    ULONG ulLength = 0;
    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    switch ( wc )
    {
    //--- Periods normally are pronounced as "dot", rather than "period".
    case L'.':
        Word.pWordText  = g_periodString.pStr;
        Word.ulWordLen  = g_periodString.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        break;

    default:
        //--- Some characters have multi-word names 
        pNextPointer = g_ANSICharacterProns[wc].pStr;
        do {
            pPrevPointer = pNextPointer;
            pNextPointer = wcschr(pPrevPointer, L' ');
            if (pNextPointer)
            {
                ulLength = (ULONG)(pNextPointer - pPrevPointer);
                pNextPointer++;
            }
            else
            {
                ulLength = wcslen(pPrevPointer);
            }
            Word.pXmlState          = &m_pCurrFrag->State;
            Word.pWordText          = pPrevPointer;
            Word.ulWordLen          = ulLength;
            Word.pLemma             = pPrevPointer;
            Word.ulLemmaLen         = ulLength;
            Word.eWordPartOfSpeech  = MS_Unknown;
            WordList.AddTail( Word );

        } while ( pNextPointer );

        break;
    }

} /* ExpandPunctuation */

/*****************************************************************************
* ExpandUnrecognizedString *
*--------------------------*
*       This function is where text ends up if it needs to be normalized, 
*   and wasn't recognized as anything (e.g. a number or a date).  Contiguous 
*   alpha characters are grouped together for lookup, contiguous digits are
*   expanded as numbers, and all other characters are expanded by name (e.g.
*   '(' -> "left parenthesis").
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::ExpandUnrecognizedString( CWordList& WordList, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandUnrecognizedString" );
    HRESULT hr = S_OK;

    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );

    const WCHAR *pCurr = m_pNextChar, *pPrev, *pEnd = m_pEndOfCurrItem;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const WCHAR *pPrevPointer = NULL, *pNextPointer = NULL;
    WCHAR Temp = 0;
    ULONG ulTempCount = 0;
    ULONG ulLength;
    bool bDone = false;

    //--- RAID 9143, 1/05/2001
    if ( _wcsnicmp( pCurr, L"AT&T", pEnd - pCurr ) == 0 )
    {
        //--- "A"
        Word.pXmlState         = &m_pCurrFrag->State;
        Word.pWordText         = pCurr;
        Word.ulWordLen         = 1;
        Word.pLemma            = Word.pWordText;
        Word.ulLemmaLen        = Word.ulWordLen;
        Word.eWordPartOfSpeech = MS_Unknown;
        WordList.AddTail( Word );

        //--- "T"
        Word.pWordText         = pCurr + 1;
        Word.pLemma            = Word.pWordText;
        WordList.AddTail( Word );

        //--- "And"
        Word.pWordText         = g_And.pStr;
        Word.ulWordLen         = g_And.Len;
        Word.pLemma            = Word.pWordText;
        Word.ulLemmaLen        = Word.ulWordLen;
        WordList.AddTail( Word );

        //--- "T"
        Word.pWordText         = pCurr + 3;
        Word.ulWordLen         = 1;
        Word.pLemma            = Word.pWordText;
        Word.ulLemmaLen        = Word.ulWordLen;
        WordList.AddTail( Word );
    }
    else
    {
        while (pCurr < pEnd && SUCCEEDED(hr) && !bDone)
        {
            pPrev = pCurr;

            //--- Special Case: alpha characters 
            if (iswalpha(*pCurr))
            {
                ulTempCount = 0;
                do {
                    pCurr++;
                } while (pCurr < pEnd && iswalpha(*pCurr));

                Word.pXmlState          = &m_pCurrFrag->State;
                Word.pWordText          = pPrev;
                Word.ulWordLen          = (ULONG)(pCurr - pPrev);
                Word.pLemma             = Word.pWordText;
                Word.ulLemmaLen         = Word.ulWordLen;
                Word.eWordPartOfSpeech  = MS_Unknown;
                WordList.AddTail( Word );
            }
            //--- Special Case: digits 
            else if (isdigit(*pCurr))
            {
                ulTempCount = 0;
                do {
                    pCurr++;
                } while (pCurr < pEnd && isdigit(*pCurr));

                TTSItemInfo* pGarbage;
                m_pNextChar      = pPrev;
                m_pEndOfCurrItem = pCurr;

                hr = IsNumber( pGarbage, L"NUMBER", MemoryManager, false );
                if ( SUCCEEDED( hr ) )
                {
                    hr = ExpandNumber( (TTSNumberItemInfo*) pGarbage, WordList );
                }

                m_pNextChar      = pTempNextChar;
                m_pEndOfCurrItem = pTempEndOfItem;
            }
            //--- Default Case 
            else if (0 <= *pCurr && *pCurr <= sp_countof(g_ANSICharacterProns) &&
                        g_ANSICharacterProns[*pCurr].Len != 0)
            {
                if ( ulTempCount == 0 )
                {
                    Temp = *pCurr;
                    ulTempCount++;
                }
                else if ( Temp == *pCurr )
                {
                    ulTempCount++;
                }
                else
                {
                    Temp = *pCurr;
                    ulTempCount = 1;
                }
             
                if ( ulTempCount < 4 )
                {
                    //--- Some characters have multi-word names 
                    pNextPointer = g_ANSICharacterProns[*pCurr].pStr;
                    do {
                        pPrevPointer = pNextPointer;
                        pNextPointer = wcschr(pPrevPointer, L' ');
                        if (pNextPointer)
                        {
                            ulLength = (ULONG )(pNextPointer - pPrevPointer);
                            pNextPointer++;
                        }
                        else
                        {
                            ulLength = wcslen(pPrevPointer);
                        }
                        Word.pXmlState          = &m_pCurrFrag->State;
                        Word.pWordText          = pPrevPointer;
                        Word.ulWordLen          = ulLength;
                        Word.pLemma             = pPrevPointer;
                        Word.ulLemmaLen         = ulLength;
                        Word.eWordPartOfSpeech  = MS_Unknown;
                        WordList.AddTail( Word );

                    } while (SUCCEEDED(hr) && pNextPointer);
                }

                pCurr++;
            }
            else // Character is not expandable
            {
                pCurr++;
            }
        }
    }

    return hr;
} /* ExpandUnrecognizedString */

/*****************************************************************************
* SpellOutString *
*----------------*
*       This function expands strings surrounded by the <SPElL> XML tag.  
*   It uses the same table to look up character expansions as 
*   ExpandUnrecognizedString, but ALL characters are expanded by name.
********************************************************************* AH ****/
HRESULT CStdSentEnum::SpellOutString( CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::SpellOutString" );
    HRESULT hr = S_OK;

    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );

    const WCHAR *pCurr = m_pNextChar, *pPrev, *pEnd = m_pEndOfCurrItem;
    const WCHAR *pPrevPointer = NULL, *pNextPointer = NULL;
    ULONG ulLength;
    bool bDone = false;

    while (pCurr < pEnd && SUCCEEDED(hr) && !bDone)
    {
        pPrev = pCurr;

        if ( 0 <= *pCurr                                && 
             *pCurr <= sp_countof(g_ANSICharacterProns) &&
             g_ANSICharacterProns[*pCurr].Len != 0 )
        {

            //--- Some characters have multi-word names 
            pNextPointer = g_ANSICharacterProns[*pCurr].pStr;
            do {
                pPrevPointer = pNextPointer;
                pNextPointer = wcschr(pPrevPointer, L' ');
                if (pNextPointer)
                {
                    ulLength = (ULONG)(pNextPointer - pPrevPointer);
                    pNextPointer++;
                }
                else
                {
                    ulLength = wcslen(pPrevPointer);
                }
                Word.pXmlState          = &m_pCurrFrag->State;
                Word.pWordText          = pPrevPointer;
                Word.ulWordLen          = ulLength;
                Word.pLemma             = pPrevPointer;
                Word.ulLemmaLen         = ulLength;
                Word.eWordPartOfSpeech  = MS_Unknown;
                WordList.AddTail( Word );

            } while (SUCCEEDED(hr) && pNextPointer);

            pCurr++;
        }
        else // Character is not expandable
        {
            pCurr++;
        }
    }

    return hr;
} /* SpellOutString */

//-----------End Of File-------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\morph.h ===
/*******************************************************************************
* morph.h *
*---------*
*   Description:
*       This is the header file for the CSMorph implementation.  This class 
*   attempts to find pronunciations for morphological variants (which do not
*   occur in the lexicon) of root words (which do occur in the lexicon).  
*-------------------------------------------------------------------------------
*  Created By: AH                            Date: 08/16/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/
#ifndef Morph_h
#define Morph_h

#ifndef __spttseng_h__
#include "spttseng.h"
#endif

// Additional includes...
#include "stdafx.h"
#include "commonlx.h"

//== CONSTANTS ================================================================

#define MAX_POSCONVERSIONS 4
#define NUM_POS 5


/*** SUFFIX_TYPE **************************************************************
* This enumeration contains values for all of the suffixes which can be matched
* and accounted for by the CSMorph class.
*/
static const enum SUFFIX_TYPE
{
    S_SUFFIX = 0,
    ED_SUFFIX,
    ING_SUFFIX,
    APOSTROPHES_SUFFIX,
    APOSTROPHE_SUFFIX,
    ER_SUFFIX,
    EST_SUFFIX,
    OR_SUFFIX,
    MENT_SUFFIX,
    AGE_SUFFIX,
    LESS_SUFFIX,
    Y_SUFFIX,
    EDLY_SUFFIX,
    LY_SUFFIX,
    ABLE_SUFFIX,
    NESS_SUFFIX,
    ISM_SUFFIX,
    IZE_SUFFIX,
    IZ_SUFFIX,
    HOOD_SUFFIX,
    FUL_SUFFIX,
    LIKE_SUFFIX,
    WISE_SUFFIX,
    ISH_SUFFIX,
    ABLY_SUFFIX,
    SHIP_SUFFIX,
    ICALLY_SUFFIX,
    SOME_SUFFIX,
    ILY_SUFFIX,
    ICISM_SUFFIX,
    ICIZE_SUFFIX,
    NO_MATCH = -1,
};


/* SUFFIX_INFO, g_SuffixTable[] ***********************************************
* This table is used to map the orthographic forms of suffixes to their suffix
* types.  Each suffix is stored in reverse order for easier comparison with 
* the ends of strings...
*/
struct SUFFIX_INFO 
{
    WCHAR       Orth[10];
    SUFFIX_TYPE Type;
};

static const SUFFIX_INFO g_SuffixTable[] = 
{ 
    { L"RE",        ER_SUFFIX },
    { L"TSE",       EST_SUFFIX },
    { L"GNI",       ING_SUFFIX },
    { L"ELBA",      ABLE_SUFFIX },
    { L"ELBI",      ABLE_SUFFIX },
    { L"YLDE",      EDLY_SUFFIX },
    { L"YLBA",      ABLY_SUFFIX },
    { L"YLBI",      ABLY_SUFFIX },
    { L"YLLACI",    ICALLY_SUFFIX },
    { L"YLI",       ILY_SUFFIX },
    { L"YL",        LY_SUFFIX },
    { L"Y",         Y_SUFFIX },
    { L"TNEM",      MENT_SUFFIX },
    { L"RO",        OR_SUFFIX },
    { L"SSEN",      NESS_SUFFIX },
    { L"SSEL",      LESS_SUFFIX },
    { L"EZICI",     ICIZE_SUFFIX },
    { L"EZI",       IZE_SUFFIX },
    { L"ZI",        IZ_SUFFIX },
    { L"MSICI",     ICISM_SUFFIX },
    { L"MSI",       ISM_SUFFIX },
    { L"DE",        ED_SUFFIX },
    { L"S'",        APOSTROPHES_SUFFIX },
    { L"S",         S_SUFFIX },
    { L"'",         APOSTROPHE_SUFFIX },
    { L"EGA",       AGE_SUFFIX },
    { L"DOOH",      HOOD_SUFFIX },
    { L"LUF",       FUL_SUFFIX },
    { L"EKIL",      LIKE_SUFFIX },
    { L"ESIW",      WISE_SUFFIX },
    { L"HSI",       ISH_SUFFIX },
    { L"PIHS",      SHIP_SUFFIX },
    { L"EMOS",      SOME_SUFFIX },
};


/*** PHONTYPE *****************************************************************
* This enumeration creates flags which can be used to determine the relevant
* features of each phone.
*/
static const enum PHONTYPE
{	
    eCONSONANTF = (1<<0),
    eVOICEDF = (1<<1),
    ePALATALF = (1<<2),
};


/*** g_PhonTable[], g_PhonS, g_PhonZ *******************************************
* This table is used to map the internal values of phones to their types, which 
* are just clusters of features relevant to the necessary phonological rules.
* g_PhonS, g_PhonZ, g_PhonD, g_PhonT are just used to make the code a bit more
* readable.
*/
static const long g_PhonTable[] = 
{
    eCONSONANTF,                        // Default value - 0 is not a valid phone
    eCONSONANTF,                        // 1 is a syllable boundary - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 2 is an exclamation point - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 3 is a word boundary - treated as a consonant
    eCONSONANTF,                        // 4 is a comma - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 5 is a period - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 6 is a question mark - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 7 is a silence - shouldn't ever occur at the end of a word
    eVOICEDF,                           // 8 is primary stress - treat as a vowel since it should always be attached to a vowel nucleus
    eVOICEDF,                           // 9 is secondatry stress - see primary stress
    eVOICEDF,                           // 10 -> AA
    eVOICEDF,                           // 11 -> AE
    eVOICEDF,                           // 12 -> AH
    eVOICEDF,                           // 13 -> AO
    eVOICEDF,                           // 14 -> AW
    eVOICEDF,                           // 15 -> AX
    eVOICEDF,                           // 16 -> AY
    eCONSONANTF + eVOICEDF,             // 17 -> b
    eCONSONANTF + ePALATALF,            // 18 -> CH
    eCONSONANTF + eVOICEDF,             // 19 -> d
    eCONSONANTF + eVOICEDF,             // 20 -> DH
    eVOICEDF,                           // 21 -> EH
    eVOICEDF,                           // 22 -> ER
    eVOICEDF,                           // 23 -> EY
    eCONSONANTF,                        // 24 -> f
    eCONSONANTF + eVOICEDF,             // 25 -> g
    eCONSONANTF,                        // 26 -> h
    eVOICEDF,                           // 27 -> IH
    eVOICEDF,                           // 28 -> IY
    eCONSONANTF + eVOICEDF + ePALATALF, // 29 -> JH
    eCONSONANTF,                        // 30 -> k
    eCONSONANTF + eVOICEDF,             // 31 -> l
    eCONSONANTF + eVOICEDF,             // 32 -> m
    eCONSONANTF + eVOICEDF,             // 33 -> n
    eCONSONANTF + eVOICEDF,             // 34 -> NG
    eVOICEDF,                           // 35 -> OW
    eVOICEDF,                           // 36 -> OY
    eCONSONANTF,                        // 37 -> p
    eCONSONANTF + eVOICEDF,             // 38 -> r
    eCONSONANTF,                        // 39 -> s
    eCONSONANTF + ePALATALF,            // 40 -> SH
    eCONSONANTF,                        // 41 -> t
    eCONSONANTF,                        // 42 -> TH
    eVOICEDF,                           // 43 -> UH
    eVOICEDF,                           // 44 -> UW
    eCONSONANTF + eVOICEDF,             // 45 -> v
    eCONSONANTF + eVOICEDF,             // 46 -> w
    eCONSONANTF + eVOICEDF,             // 47 -> y
    eCONSONANTF + eVOICEDF,             // 48 -> z
    eCONSONANTF + eVOICEDF + ePALATALF, // 49 -> ZH
};

static WCHAR g_phonAXl[] = L" AX l";
static WCHAR g_phonAXz[] = L" AX z";
static WCHAR g_phonS[] = L" s";
static WCHAR g_phonZ[] = L" z";
static WCHAR g_phonD[] = L" d";
static WCHAR g_phonAXd[] = L" AX d";
static WCHAR g_phonT[] = L" t";
static WCHAR g_phonIY[] = L" IY";
static WCHAR g_phonL[] = L" l";

/*** struct POS_CONVERT *******************************************************
* This struct stores the From and To parts of speech for a suffix...
*/
struct POS_CONVERT
{
    ENGPARTOFSPEECH FromPos;
    ENGPARTOFSPEECH ToPos;
};

/*** MorphSpecialCaseFlags ****************************************************
* This enum allows DoSuffixMorph to be nearly completely table driven.  Each
* suffix has a MorphSpecialCaseFlags entry in the SuffixInfoTable which tells
* DoSuffixMorph which special case functions (check for missing E, etc.) need
* to be called if the initial lex lookup fails.
*/
typedef enum MorphSpecialCaseFlags
{
    eCheckForMissingE       = 1L << 0,
    eCheckYtoIMutation      = 1L << 1,
    eCheckDoubledMutation   = 1L << 2,
    eCheckForMissingY       = 1L << 3,
    eCheckForMissingL       = 1L << 4,
} MorphSpecialCaseFlags;

/*** struct SUFFIXPRON_INFO ***************************************************
* This struct stores the pronunciation of a suffix, as well as the POS 
* categories it takes as input and output.
*/
struct SUFFIXPRON_INFO 
{
    WCHAR SuffixString[SP_MAX_PRON_LENGTH];
    POS_CONVERT Conversions[MAX_POSCONVERSIONS];
    short NumConversions;
    DWORD dwMorphSpecialCaseFlags;
};

/*** bool SuffixInfoTableInitialized *******************************************
* This bool just lets threads know whether they are the first to use the 
* following table, and thus whether they need to initialize it or not.
*/
static bool SuffixInfoTableInitialized = false;

/*** SUFFIXPRON_INFO g_SuffixInfoTable *****************************************
* This table drives the DoSuffixMorph function, by storing the pronunciation, 
* conversions, number of conversions, and special case flags for each suffix...
*/
static SUFFIXPRON_INFO g_SuffixInfoTable [] =
{
/********************************************************************************************************/
/*    Pronunciation     *  Conversions  *   NumConversions * Special Case Flags      *   SuffixType      */
/********************************************************************************************************/
    { L" s",            { {MS_Verb,   MS_Verb}, 
                          {MS_Noun,   MS_Noun}  },    2,  0 },                          // S_SUFFIX
    { L" d",            { {MS_Verb,   MS_Verb}, 
                          {MS_Verb,   MS_Adj}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ED_SUFFIX
    { L" IH NG",        { {MS_Verb,   MS_Verb}, 
                          {MS_Verb,   MS_Adj},
                          {MS_Verb,   MS_Noun}  },    3,  eCheckForMissingE +
                                                          eCheckDoubledMutation   },    // ING_SUFFIX
    { L" s",            { {MS_Noun,   MS_Noun}  },    1,  0 },                          // APOSTROPHES_SUFFIX
    { L" s",            { {MS_Noun,   MS_Noun}  },    1,  0 },                          // APOSTROPHE_SUFFIX
    { L" ER",           { {MS_Verb,   MS_Noun},
                          {MS_Adj,    MS_Adj}, 
                          {MS_Adv,    MS_Adv}, 
                          {MS_Adj,    MS_Adv}   },    4,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ER_SUFFIX
    { L" AX s t",       { {MS_Adj,    MS_Adj}, 
                          {MS_Adv,    MS_Adv},
                          {MS_Adj,    MS_Adv}   },    3,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // EST_SUFFIX
    { L" ER",           { {MS_Verb,   MS_Noun}  },    1,  eCheckForMissingE +
                                                          eCheckDoubledMutation },      // OR_SUFFIX
    { L" m AX n t",     { {MS_Verb,   MS_Noun}  },    1,  eCheckYtoIMutation },         // MENT_SUFFIX
    { L" IH JH",        { {MS_Verb,   MS_Noun}  },    1,  eCheckForMissingE + 
                                                          eCheckDoubledMutation   },    // AGE_SUFFIX
    { L" l IH s",       { {MS_Noun,   MS_Adj}   },    1,  eCheckYtoIMutation      },    // LESS_SUFFIX
    { L" IY",           { {MS_Noun,   MS_Adj},
                          {MS_Adj,    MS_Adv}   },    2,  eCheckForMissingE +
                                                          eCheckDoubledMutation   },    // Y_SUFFIX
    { L" AX d l IY",    { {MS_Verb,   MS_Adj},
                          {MS_Verb,   MS_Adv}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // EDLY_SUFFIX
    { L" l IY",         { {MS_Noun,   MS_Adj},
                          {MS_Adj,    MS_Adv}   },    2,  eCheckForMissingL },          // LY_XUFFIX
    { L" AX - b AX l",  { {MS_Verb,   MS_Adj},
                          {MS_Noun,   MS_Adj}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ABLE_SUFFIX
    { L" n IH s",       { {MS_Adj,    MS_Noun}  },    1,  eCheckYtoIMutation      },    // NESS_SUFFIX
    { L" IH z AX m",    { {MS_Adj,    MS_Noun},
                          {MS_Noun,   MS_Noun}  },    2,  eCheckForMissingE       },    // ISM_SUFFIX
    { L" AY z",         { {MS_Noun,   MS_Verb}, 
                          {MS_Adj,    MS_Verb}  },    2,  eCheckForMissingE       },    // IZE_SUFFIX
    { L" AY z",         { {MS_Noun,   MS_Verb},
                          {MS_Adj,    MS_Verb}  },    2,  eCheckForMissingE       },    // IZ_SUFFIX
    { L" h UH d",       { {MS_Noun,   MS_Noun}  },    1,  0 },                          // HOOD_SUFFIX
    { L" f AX l",       { {MS_Noun,   MS_Adj},
                          {MS_Verb,   MS_Adj}   },    2,  0 } ,                         // FUL_SUFFIX
    { L" l AY k",       { {MS_Noun,   MS_Adj}   },    1,  0 },                          // LIKE_SUFFIX
    { L" w AY z",       { {MS_Noun,   MS_Adj}   },    1,  eCheckYtoIMutation },                        // WISE_SUFFIX
    { L" IH SH",        { {MS_Noun,   MS_Adj}   },    1,  eCheckForMissingE +
                                                          eCheckDoubledMutation   },    // ISH_SUFFIX
    { L" AX - b l IY",  { {MS_Verb,   MS_Adv},
                          {MS_Noun,   MS_Adv}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ABLY_SUFFIX
    { L" SH IH 2 p",    { {MS_Noun,   MS_Noun}  },    1,  0 },                          // SHIP_SUFFIX
    { L" L IY",         { {MS_Adj,    MS_Adv}   },    1,  0 },                          // ICALLY_SUFFIX
    { L" S AX M",       { {MS_Noun,   MS_Adj}   },    1,  eCheckYtoIMutation      },    // SOME_SUFFIX
    { L" AX L IY",      { {MS_Noun,   MS_Adv}   },    1,  eCheckDoubledMutation +
                                                          eCheckForMissingY       },    // ILY_SUFFIX
    { L" IH z AX m",    { {MS_Adj,    MS_Noun},
                          {MS_Noun,   MS_Noun}  },    2,  eCheckForMissingE       },    // ICISM_SUFFIX
    { L" AY z",         { {MS_Noun,   MS_Verb}, 
                          {MS_Adj,    MS_Verb}  },    2,  eCheckForMissingE       },    // ICIZE_SUFFIX
};

/*** CSuffixList **************************************************************
* This typedef just makes the code a little easier to read.  A CSuffixList is
* used to keep track of each of the suffixes which has been stripped from a
* word, so that their pronunciations can be concatenated with that of the root.
*/
typedef CSPList<SUFFIXPRON_INFO*, SUFFIXPRON_INFO*> CSuffixList;

/*** CComAutoCriticalSection g_SuffixInfoTableCritSec *************************
* This critical section is used to make sure the SuffixInfoTable only gets
* initialized once.
*/
static CComAutoCriticalSection g_SuffixInfoTableCritSec;

/*** CSMorph ******************************************************************
* This is the definition of the CSMorph class.
*/
class CSMorph
{
public:

    /*=== PUBLIC METHODS =====*/
    CSMorph( ISpLexicon *pMasterLex=0, HRESULT *hr=0 );

    /*=== INTERFACE METHOD =====*/
    HRESULT DoSuffixMorph( const WCHAR *pwWord, WCHAR *pwRoot, LANGID LangID, DWORD dwFlags,
                           SPWORDPRONUNCIATIONLIST *pWordPronunciationList );

private:


    /*=== PRIVATE METHODS =====*/
    SUFFIX_TYPE MatchSuffix( WCHAR *TargWord, long *RootLen );
    HRESULT LexLookup( const WCHAR *pOrth, long length, DWORD dwFlags, 
                       SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT LTSLookup( const WCHAR *pOrth, long length,
                       SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT AccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT AccumulateSuffixes_LTS( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT DefaultAccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList );

    HRESULT CheckForMissingE( WCHAR *pOrth, long length, DWORD dwFlags,
                              SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckForMissingY( WCHAR *pOrth, long length, DWORD dwFlags,
                              SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT CheckForMissingL( WCHAR *pOrth, long length, DWORD dwFlags,
                              SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT CheckYtoIMutation( WCHAR *pOrth, long length, DWORD dwFlags, 
                               SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckDoubledMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                  SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckYtoIEMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckAbleMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                               SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT Phon_SorZ( WCHAR *pPronunciation, long length );
    HRESULT Phon_DorED( WCHAR *pPronunciation, long length ); 

    /*=== MEMBER DATA =====*/

    // Pointer to the Master Lexicon...
    ISpLexicon  *m_pMasterLex;
};

inline BOOL SearchPosSet( ENGPARTOFSPEECH Pos, const ENGPARTOFSPEECH *Set, ULONG Count )
{
    for( ULONG i = 0; i < Count; ++i )
    {
        if( Pos == Set[i] )
        {
            return true;
        }
    }
    return false;
}

#endif //--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\normdata.h ===
/******************************************************************************
* NormData.h *
*------------*
*   This file contains lists of data used in the normalization process.
*------------------------------------------------------------------------------
*   Copyright (C) 1999 Microsoft Corporation         Date: 08/11/99
*   All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef NormData_h
#define NormData_h

//  Abbrev.txt -- list of common abbreviations.  Words following the
//  abbreviations in this list will not start a sentence unless they are in
//  the list of common first words (frstwrds.txt)
//  The code handles all abbreviations containing single upper-case characters
//  followed by a period, such as A.A. and B.F.A., so they don't need to be
//  in the list.
//  Some abbreviations are confusable with actual words.  Where this may occur
//  regularly (with no., for example) a special case may need to be added in
//  the sentence separator code.
static const SPLSTR g_CommonAbbrev[] =
{
// L"A.A." ),
// L"A.A.S." ),
// L"A.B." ),
// L"A.B.A." ),
// L"A.C.T." ),
// L"A.D." ),
// L"A.F." ),         // "A.F. of L." ),
// L"A.G." ),
// L"A.H." ),
// L"A.M." ),
// L"A.P." ),
// L"A.R." ),
// L"A.S." ),
// L"A.S.P.C.A." ),
// L"A.S.S.R." ),
// L"A.U." ),
// L"A.U.C." ),
// L"A.h." ),
DEF_SPLSTR( "Adj." ),
DEF_SPLSTR( "Adjt." ),
DEF_SPLSTR( "Afg." ),
DEF_SPLSTR( "Afr." ),
DEF_SPLSTR( "Ala." ),
DEF_SPLSTR( "Alas." ),
DEF_SPLSTR( "Alb." ),
DEF_SPLSTR( "Ald." ),
DEF_SPLSTR( "Alg." ),
DEF_SPLSTR( "Alta." ),
DEF_SPLSTR( "Am." ),
DEF_SPLSTR( "Amer." ),
DEF_SPLSTR( "And." ),         // Andorra
DEF_SPLSTR( "Ang." ),
DEF_SPLSTR( "Angl." ),
DEF_SPLSTR( "Ant." ),
DEF_SPLSTR( "Apoc." ),
DEF_SPLSTR( "Apr." ),
DEF_SPLSTR( "Ar." ),
DEF_SPLSTR( "Arch." ),
DEF_SPLSTR( "Archbp." ),
DEF_SPLSTR( "Arg." ),
DEF_SPLSTR( "Ariz." ),
DEF_SPLSTR( "Ark." ),
DEF_SPLSTR( "Arm." ),
DEF_SPLSTR( "As." ),
DEF_SPLSTR( "Atl." ),
DEF_SPLSTR( "Att." ),
// "Att. Gen." ),
// "Atty." ),         // already in titles.txt
// "Atty. Gen." ),
DEF_SPLSTR( "Aug." ),
DEF_SPLSTR( "Aus." ),
DEF_SPLSTR( "Aust." ),
DEF_SPLSTR( "Austl." ),
DEF_SPLSTR( "Av." ),
DEF_SPLSTR( "Ave." ),                                 // PaulCa 4/15/99 (Bug 108)
// "B.A." ),
// "B.A.E." ),
DEF_SPLSTR( "B.A.Ed." ),
// "B.A.M." ),
// "B.A.S." ),
DEF_SPLSTR( "B.A.Sc." ),
// "B.A.T." ),
DEF_SPLSTR( "B.Ae.E." ),
DEF_SPLSTR( "B.Arch." ),
// "B.B.A." ),
// "B.C." ),
// "B.C.B.G." ),
// "B.C.E." ),
// "B.C.L." ),
DEF_SPLSTR( "B.Ch.E." ),
// "B.D." ),
// "B.D.S." ),
// "B.E." ),
DEF_SPLSTR( "B.Ed." ),
DEF_SPLSTR( "B.Eng." ),
DEF_SPLSTR( "B.Eng.Sci." ),
DEF_SPLSTR( "B.Engr." ),
// "B.F.A." ),
// "B.J." ),
// "B.L." ),
// "B.L.A." ),
// "B.L.S." ),
DEF_SPLSTR( "B.Lit." ),
DEF_SPLSTR( "B.Litt." ),
// "B.M." ),
// "B.M.E." ),
// "B.M.S." ),
DEF_SPLSTR( "B.Mus." ),
// "B.O.D." ),
// "B.P." ),
// "B.P.E." ),
DEF_SPLSTR( "B.Pd." ),
DEF_SPLSTR( "B.Ph." ),
DEF_SPLSTR( "B.Phil." ),
DEF_SPLSTR( "B.R.E." ),
// "B.S." ),
// "B.S.A." ),
// "B.S.A.A." ),
DEF_SPLSTR( "B.S.Arch." ),
DEF_SPLSTR( "B.S.Ch." ),
// "B.S.E.E." ),
DEF_SPLSTR( "B.S.Ec." ),
DEF_SPLSTR( "B.S.Ed." ),
// "B.S.F.S." ),
DEF_SPLSTR( "B.S.For." ),
// "B.S.N." ),
DEF_SPLSTR( "B.Sc." ),
// "B.T." ),
DEF_SPLSTR( "B.Th." ),
// "B.V.D." ),
// "B.V.M." ),
// "B.W.I." ),
DEF_SPLSTR( "Bab." ),
DEF_SPLSTR( "Bap." ),
DEF_SPLSTR( "Bapt." ),
DEF_SPLSTR( "Belg." ),
DEF_SPLSTR( "Benj." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Bhn." ),
DEF_SPLSTR( "Bhu." ),
DEF_SPLSTR( "Bib." ),
DEF_SPLSTR( "Bibl." ),
// "Bn." ),       // already in titles.txt
DEF_SPLSTR( "Bol." ),
DEF_SPLSTR( "Br." ),
DEF_SPLSTR( "Braz." ),
DEF_SPLSTR( "Brig." ),
DEF_SPLSTR( "Brit." ),
// "Bt." ),       // already in titles.txt
// "Btss." ),     // already in titles.txt
DEF_SPLSTR( "Bulg." ),
DEF_SPLSTR( "Bur." ),
// "C. of C." ),
// "C. of E." ),
// "C. of S." ),
// "C.A." ),
// "C.A.F." ),
// "C.A.G.S." ),
// "C.B.D." ),
// "C.C.A." ),
// "C.D." ),
// "C.E." ),
// "C.G." ),      // already in titles.txt
// "C.J." ),
// "C.L." ),
// "C.O." ),
// "C.P." ),
// "C.R." ),
// "C.S.A." ),
// "C.S.T." ),
// "C.V." ),
// "C.Z." ),
DEF_SPLSTR( "Calif." ),
DEF_SPLSTR( "Can." ),
DEF_SPLSTR( "Cant." ),
// "Capt." ),     // already in titles.txt
DEF_SPLSTR( "Card." ),
// "Cdr." ),      // already in titles.txt
DEF_SPLSTR( "Ch." ),
DEF_SPLSTR( "Ch.E." ),
DEF_SPLSTR( "Chas." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Chmn." ),
DEF_SPLSTR( "Chr." ),
DEF_SPLSTR( "Chron." ),
DEF_SPLSTR( "Cmd." ),
DEF_SPLSTR( "Cmdr." ),
DEF_SPLSTR( "Co." ),
// "Col." ),      // already in titles.txt
DEF_SPLSTR( "Colo." ),
// "Com." ),      // already in titles.txt
// "Comdr." ),    // already in titles.txt
DEF_SPLSTR( "Comdt." ),
DEF_SPLSTR( "Comm." ),
DEF_SPLSTR( "Comr." ),
DEF_SPLSTR( "Con." ),
DEF_SPLSTR( "Cong." ),
DEF_SPLSTR( "Conn." ),
DEF_SPLSTR( "Cons." ),
DEF_SPLSTR( "Const." ),
DEF_SPLSTR( "Conv." ),
DEF_SPLSTR( "Cop." ),
DEF_SPLSTR( "Copt." ),
DEF_SPLSTR( "Cor." ),
// "Cpl." ),      // already in titles.txt
// "Cpt." ),      // already in titles.txt
// "Ct." ),       // already in titles.txt
// "D.A." ),
// "D.B.A." ),
// "D.B.E." ),
DEF_SPLSTR( "D.Bib." ),
// "D.C." ),
// "D.C.L." ),
// "D.D." ),
// "D.D.S." ),
DEF_SPLSTR( "D.Ed." ),
// "D.F." ),      // already in titles.txt
// "D.F.A." ),
// "D.H." ),
// "D.H.L." ),
// "D.J." ),
// "D.L.S." ),
DEF_SPLSTR( "D.Lit." ),
DEF_SPLSTR( "D.Litt." ),                              // PaulCa 4/15/99 (Bug 108)
// "D.M.A." ),
// "D.M.D." ),
// "D.M.L." ),
// "D.O." ),
// "D.O.M." ),
// "D.P." ),
DEF_SPLSTR( "D.Ph." ),
DEF_SPLSTR( "D.Phil." ),
// "D.S." ),
DEF_SPLSTR( "D.Sc." ),                                // PaulCa 4/15/99 (Bug 108)
// "D.T." ),
// "D.V." ),
// "D.V.M." ),
DEF_SPLSTR( "Da." ),
DEF_SPLSTR( "Danl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Dec." ),
DEF_SPLSTR( "Del." ),
DEF_SPLSTR( "Dem." ),
DEF_SPLSTR( "Den." ),
DEF_SPLSTR( "Deut." ),
DEF_SPLSTR( "Dist." ),        // "Dist. Atty." ),
DEF_SPLSTR( "Div." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Divs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Dom." ),
DEF_SPLSTR( "Dor." ),
// "Dr." ),       // already in titles.txt
// "Drs." ),      // already in titles.txt
DEF_SPLSTR( "Dt." ),
// "Du." ),       // already in titles.txt
// "E.D." ),
// "E.E." ),
// "E.M." ),
// "E.Q." ),
// "E.T." ),
DEF_SPLSTR( "Ec." ),
DEF_SPLSTR( "Eccles." ),
DEF_SPLSTR( "Ecua." ),
DEF_SPLSTR( "Ed.M." ),
DEF_SPLSTR( "Edw." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Eng." ),
DEF_SPLSTR( "Engl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Ens." ),
DEF_SPLSTR( "Ep." ),
DEF_SPLSTR( "Eph." ),
DEF_SPLSTR( "Epis." ),
DEF_SPLSTR( "Episc." ),
DEF_SPLSTR( "Epist." ),
DEF_SPLSTR( "Esk." ),
// "Esq." ),      // already in titles.txt
DEF_SPLSTR( "Est." ),
DEF_SPLSTR( "Esth." ),
DEF_SPLSTR( "Eth." ),
DEF_SPLSTR( "Eur." ),
DEF_SPLSTR( "Ex." ),
// "Exc." ),      // already in titles.txt
DEF_SPLSTR( "Exch." ),
DEF_SPLSTR( "Exod." ),
DEF_SPLSTR( "Ezek." ),
// "F.A." ),
// "F.B." ),
// "F.D." ),
// "F.E.T." ),
// "F.F.A." ),
// "F.M." ),
// "F.O." ),
// "F.R.G." ),
DEF_SPLSTR( "Far." ),
DEF_SPLSTR( "Feb." ),
DEF_SPLSTR( "Fin." ),
DEF_SPLSTR( "Fla." ),
DEF_SPLSTR( "Flem." ),
// "Fr." ),       // already in titles.txt
DEF_SPLSTR( "Fri." ),
DEF_SPLSTR( "Fris." ),
// "Frl." ),      // already in titles.txt
DEF_SPLSTR( "Frs." ),
DEF_SPLSTR( "Ft." ),
// "G.A." ),
// "G.B." ),
// "G.C.B." ),
// "G.D." ),
// "G.D.R." ),
// "G.I." ),
// "G.M." ),
// "G.P." ),
// "G.T.C." ),
// "G.m.a.t." ),
DEF_SPLSTR( "Ga." ),
DEF_SPLSTR( "Gal." ),
// "Gen." ),      // already in titles.txt
DEF_SPLSTR( "Geo." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Ger." ),
DEF_SPLSTR( "Gib." ),
DEF_SPLSTR( "Gk." ),
DEF_SPLSTR( "Gn." ),
DEF_SPLSTR( "Goth." ),
// "Gov." ),      // already in titles.txt
DEF_SPLSTR( "Gr." ),
// "Gr. Brit." ),
DEF_SPLSTR( "Gt." ),          // "Gt. Brit."
DEF_SPLSTR( "Guat." ),
DEF_SPLSTR( "Guin." ),
// "H. Rept." ),
// "H. Res." ),
// "H.C." ),
// "H.C.F." ),
// "H.E." ),       // already in titles.txt
// "H.H." ),       // already in titles.txt
// "H.I." ),
// "H.I.H." ),    // already in titles.txt
// "H.I.M." ),    // already in titles.txt
// "H.L." ),
// "H.M." ),      // already in titles.txt
// "H.R." ),
// "H.R.E." ),
// "H.R.H." ),    // already in titles.txt
// "H.S.H." ),    // already in titles.txt
// "H.S.T." ),
// "H.V." ),
DEF_SPLSTR( "HH.D." ),
DEF_SPLSTR( "Hab." ),
DEF_SPLSTR( "Hag." ),
DEF_SPLSTR( "Heb." ),
DEF_SPLSTR( "Hebr." ),
DEF_SPLSTR( "Hind." ),
DEF_SPLSTR( "Hitt." ),
// "Hon." ),      // already in titles.txt
DEF_SPLSTR( "Hond." ),
DEF_SPLSTR( "Hos." ),
// "Hr." ),       // already in titles.txt
DEF_SPLSTR( "Hts." ),
DEF_SPLSTR( "Hung." ),
// "I.D." ),
// "I.N.R.I." ),
// "I.P.A." ),
// "I.R.A." ),
DEF_SPLSTR( "Ia." ),
DEF_SPLSTR( "Ice." ),
DEF_SPLSTR( "Icel." ),
DEF_SPLSTR( "Id." ),
DEF_SPLSTR( "Ill." ),
DEF_SPLSTR( "Ind." ),
DEF_SPLSTR( "Inf." ),
DEF_SPLSTR( "Inst." ),
DEF_SPLSTR( "Ion." ),
DEF_SPLSTR( "Ir." ),
DEF_SPLSTR( "Ire." ),
DEF_SPLSTR( "Is." ),
DEF_SPLSTR( "Isl." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Isr." ),
DEF_SPLSTR( "It." ),
DEF_SPLSTR( "Ital." ),
// "J.A." ),
// "J.A.G." ),
// "J.C.D." ),
// "J.C.S." ),
// "J.D." ),
// "J.P." ),
// "J.S.D." ),
DEF_SPLSTR( "Jam." ),
DEF_SPLSTR( "Jan." ),
DEF_SPLSTR( "Jas." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Jav." ),
DEF_SPLSTR( "Jb." ),
DEF_SPLSTR( "Jdt." ),
DEF_SPLSTR( "Jer." ),
DEF_SPLSTR( "Jg." ),
DEF_SPLSTR( "Jl." ),
DEF_SPLSTR( "Jm." ),
DEF_SPLSTR( "Jn." ),
DEF_SPLSTR( "Jos." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Jr." ),
DEF_SPLSTR( "Judg." ),
DEF_SPLSTR( "Jul." ),
DEF_SPLSTR( "Jun." ),
// "K.C." ),
// "K.G." ),
// "K.G.B." ),
DEF_SPLSTR( "Kan." ),
DEF_SPLSTR( "Kans." ),
DEF_SPLSTR( "Knt." ),
DEF_SPLSTR( "Kor." ),
DEF_SPLSTR( "Ky." ),
// "L.A." ),
// "L.C." ),
// "L.Cpl." ),    // already in titles.txt
// "L.I." ),
// "L.S." ),
DEF_SPLSTR( "LL.B." ),
DEF_SPLSTR( "LL.D." ),
DEF_SPLSTR( "LL.M." ),
DEF_SPLSTR( "La." ),
DEF_SPLSTR( "Lab." ),
DEF_SPLSTR( "Lam." ),
DEF_SPLSTR( "Lat." ),
// "Ld." ),       // already in titles.txt
DEF_SPLSTR( "Leb." ),
DEF_SPLSTR( "Lev." ),
DEF_SPLSTR( "Levit." ),
DEF_SPLSTR( "Lib." ),
DEF_SPLSTR( "Liech." ),
DEF_SPLSTR( "Lit.B." ),
DEF_SPLSTR( "Lit.D." ),
DEF_SPLSTR( "Lith." ),
DEF_SPLSTR( "Litt.B." ),
DEF_SPLSTR( "Litt.D." ),
// "Lt." ),       // already in titles.txt
// "Lt. Col." ),
// "Lt. Comdr." ),
// "Lt. Gen." ),
// "Lt. Gov." ),
DEF_SPLSTR( "Ltd." ),
DEF_SPLSTR( "Lux." ),
// "M. o. T." ),
// "M.A." ),
// "M.A.B.E." ),
// "M.A.E." ),
DEF_SPLSTR( "M.A.Ed." ),
// "M.A.L.S." ),
// "M.A.T." ),
DEF_SPLSTR( "M.Agr." ),
// "M.B.A." ),
// "M.C." ),
// "M.C.L." ),
// "M.D." ),
// "M.D.S." ),
DEF_SPLSTR( "M.Div." ),
// "M.E." ),
DEF_SPLSTR( "M.Ed." ),
// "M.F.A." ),
// "M.F.H." ),
// "M.H.L." ),
// "M.L.S." ),
// "M.M." ),      // already in titles.txt
// "M.P.A." ),
// "M.P.E." ),
// "M.R.E." ),
// "M.S." ),
// "M.S. in L.S." ),
// "M.S.N." ),
// "M.S.T." ),
// "M.S.T.S." ),
// "M.S.W." ),
DEF_SPLSTR( "M.Sc." ),
// "M.Sgt." ),    // already in titles.txt
// "M.T." ),
DEF_SPLSTR( "MM." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "MS." ),
DEF_SPLSTR( "MSS." ),
DEF_SPLSTR( "Macc." ),
DEF_SPLSTR( "Maced." ),
DEF_SPLSTR( "Mad." ),
DEF_SPLSTR( "Madag." ),
// "Maj." ),      // already in titles.txt
// "Maj. Gen." ),
DEF_SPLSTR( "Mal." ),
DEF_SPLSTR( "Man." ),
DEF_SPLSTR( "Mar." ),
DEF_SPLSTR( "Mart." ),
DEF_SPLSTR( "Mass." ),
DEF_SPLSTR( "Md." ),
// "Mdm." ),      // already in titles.txt
DEF_SPLSTR( "Me." ),
// "Med. Gr." ),
// "Med. Lat." ),
DEF_SPLSTR( "Medit." ),
// "Messrs." ),   // already in titles.txt
DEF_SPLSTR( "Mex." ),
// "Mgr." ),      // already in titles.txt
DEF_SPLSTR( "Mich." ),
DEF_SPLSTR( "Midn." ),
DEF_SPLSTR( "Minn." ),
DEF_SPLSTR( "Miss." ),
// "Mlle." ),     // already in titles.txt
// "Mlles." ),    // already in titles.txt
// "Mme." ),      // already in titles.txt
// "Mmes." ),     // already in titles.txt
DEF_SPLSTR( "Mo." ),
DEF_SPLSTR( "Mon." ),
DEF_SPLSTR( "Mont." ),
DEF_SPLSTR( "Mor." ),
DEF_SPLSTR( "Moz." ),
// "Mr." ),       // already in titles.txt
// "Mrs." ),      // already in titles.txt
// "Ms." ),       // already in titles.txt
DEF_SPLSTR( "Mses." ),
// "Msgr." ),     // already in titles.txt
DEF_SPLSTR( "Mss." ),
DEF_SPLSTR( "Mt." ),
DEF_SPLSTR( "Mtn." ),
DEF_SPLSTR( "Mts." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Mus.B." ),
DEF_SPLSTR( "Mus.D." ),
DEF_SPLSTR( "Mus.Dr." ),
DEF_SPLSTR( "Mus.M." ),
// "N.A." ),
// "N.B." ),
// "N.C." ),
// "N.D." ),
DEF_SPLSTR( "N.Dak." ),
// "N.E." ),
// "N.E.P." ),
// "N.F." ),
// "N.H." ),
DEF_SPLSTR( "N.Ire." ),
// "N.J." ),
// "N.M." ),
DEF_SPLSTR( "N.Mex." ),
// "N.P." ),
// "N.S." ),
// "N.S.P.C.A." ),
// "N.T." ),
// "N.W.T." ),
// "N.Y." ),
// "N.Y.C." ),
// "N.Z." ),
DEF_SPLSTR( "Na." ),
DEF_SPLSTR( "Nb." ),
DEF_SPLSTR( "Ne." ),
DEF_SPLSTR( "Neb." ),
DEF_SPLSTR( "Nebr." ),
DEF_SPLSTR( "Neh." ),
DEF_SPLSTR( "Nep." ),
DEF_SPLSTR( "Neth." ),
DEF_SPLSTR( "Nev." ),
// "New Test." ),
DEF_SPLSTR( "Newf." ),
DEF_SPLSTR( "Nfld." ),
DEF_SPLSTR( "Nic." ),
DEF_SPLSTR( "Nig." ),
DEF_SPLSTR( "Nor." ),
DEF_SPLSTR( "Norw." ),
DEF_SPLSTR( "Nos." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Nov." ),
DEF_SPLSTR( "Num." ),
// "O.B.E." ),
// "O.C." ),
// "O.D." ),
// "O.F.M." ),
// "O.K." ),
// "O.M." ),
// "O.N." ),
// "O.O.D." ),
// "O.P." ),
// "O.R." ),
// "O.S." ),
// "O.T." ),
DEF_SPLSTR( "OM." ),
DEF_SPLSTR( "Ob." ),
DEF_SPLSTR( "Obad." ),
DEF_SPLSTR( "Obs." ),
DEF_SPLSTR( "Oc." ),
DEF_SPLSTR( "Oct." ),
DEF_SPLSTR( "Okla." ),
DEF_SPLSTR( "Ont." ),
DEF_SPLSTR( "Op." ),
DEF_SPLSTR( "Ore." ),
DEF_SPLSTR( "Oxon." ),                                // PaulCa 4/15/99 (Bug 108)
// "P. S." ),
// "P.A." ),
// "P.B." ),
// "P.C." ),
// "P.D." ),
// "P.E." ),
// "P.E.I." ),
// "P.G." ),
// "P.M." ),
// "P.M.G." ),
// "P.P.S." ),
// "P.Q." ),
// "P.R." ),
// "P.S." ),
// "P.T." ),
// "P.W.A." ),
// "PFC." ),      // already in titles.txt
DEF_SPLSTR( "PP." ),
DEF_SPLSTR( "Pa." ),
DEF_SPLSTR( "Pac." ),
DEF_SPLSTR( "Pacif." ),
DEF_SPLSTR( "Pak." ),
DEF_SPLSTR( "Pal." ),
DEF_SPLSTR( "Par." ),
DEF_SPLSTR( "Parl." ),
DEF_SPLSTR( "Pd.B." ),
DEF_SPLSTR( "Pd.D." ),
DEF_SPLSTR( "Pd.M." ),
DEF_SPLSTR( "Penn." ),
DEF_SPLSTR( "Penna." ),
DEF_SPLSTR( "Pers." ),
DEF_SPLSTR( "Pet." ),
DEF_SPLSTR( "Pg." ),
DEF_SPLSTR( "Ph.B." ),
DEF_SPLSTR( "Ph.C." ),
DEF_SPLSTR( "Ph.D." ),
DEF_SPLSTR( "Ph.G." ),
DEF_SPLSTR( "Ph.M." ),
DEF_SPLSTR( "Phar.B." ),
DEF_SPLSTR( "Phar.D." ),
DEF_SPLSTR( "Phar.M." ),
DEF_SPLSTR( "Phil." ),
// "Phil. I." ),
// "Phil. Is." ),
DEF_SPLSTR( "Philem." ),
DEF_SPLSTR( "Pl." ),
DEF_SPLSTR( "Pol." ),
// "Pr." ),       // already in titles.txt
// "Pres." ),     // already in titles.txt
DEF_SPLSTR( "Presb." ),
DEF_SPLSTR( "Presby." ),
// "Prof." ),     // already in titles.txt
// "Profs." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Pros." ),        // "Pros. Atty."
DEF_SPLSTR( "Prot." ),
DEF_SPLSTR( "Prov." ),
DEF_SPLSTR( "Pvt." ),
// "Q. C." ),
// "Q.B." ),
// "Q.C." ),
// "Q.E.D." ),
// "Q.E.F." ),
// "Q.M." ),
DEF_SPLSTR( "Que." ),
// "R. A. F." ),
// "R. C." ),
// "R.A." ),      // already in titles.txt
// "R.A.M." ),
DEF_SPLSTR( "R.C.Ch." ),
// "R.C.P." ),
// "R.C.S." ),
// "R.E." ),
// "R.I." ),
// "R.I.P." ),
// "R.M.S." ),
// "R.P." ),
// "R.Q." ),
// "R.R." ),      // already in titles.txt
// "R.S." ),
// "R.S.F.S.R." ),
// "R.S.V.P." ),
// "R.V." ),
// "R.W." ),      // already in titles.txt
DEF_SPLSTR( "Ra." ),
DEF_SPLSTR( "Rd." ),
DEF_SPLSTR( "Re." ),
// "Rep." ),      // already in titles.txt
DEF_SPLSTR( "Rept." ),
DEF_SPLSTR( "Repub." ),
DEF_SPLSTR( "Res." ),
// "Rev." ),      // already in titles.txt
// "Rev. Ver." ),
DEF_SPLSTR( "Rm." ),
DEF_SPLSTR( "Rom." ),
DEF_SPLSTR( "Rt." ),
// "Rt. Hon." ),
// "Rt. Rev." ),
DEF_SPLSTR( "Rus." ),
DEF_SPLSTR( "Rv." ),
// "S. of Sol." ),
// "S.A." ),
DEF_SPLSTR( "S.Afr." ),
// "S.B." ),
// "S.C." ),
// "S.D." ),
DEF_SPLSTR( "S.Dak." ),
// "S.F.S.R." ),
// "S.G." ),
// "S.J." ),
// "S.J.D." ),
// "S.M." ),
// "S.M.Sgt." ),  // already in titles.txt
// "S.P.Q.R." ),
// "S.S." ),
// "S.S.R." ),
// "S.Sgt." ),    // already in titles.txt
DEF_SPLSTR( "Sab." ),
DEF_SPLSTR( "Sask." ),
DEF_SPLSTR( "Sat." ),
DEF_SPLSTR( "Sax." ),
DEF_SPLSTR( "Sc." ),
DEF_SPLSTR( "Sc.B." ),
DEF_SPLSTR( "Sc.D." ),
DEF_SPLSTR( "Scand." ),
DEF_SPLSTR( "Schil." ),       // Added 1/12/2000 by AaronHal to match currency abbreviations
DEF_SPLSTR( "Script." ),
DEF_SPLSTR( "Sec." ),
DEF_SPLSTR( "Sem." ),
// "Sen." ),      // already in titles.txt
DEF_SPLSTR( "Sept." ),
// "Sgt." ),      // already in titles.txt
// "Sgt.Maj." ),  // already in titles.txt
DEF_SPLSTR( "Sib." ),
DEF_SPLSTR( "Sic." ),
DEF_SPLSTR( "Sig." ),
DEF_SPLSTR( "Skr." ),
DEF_SPLSTR( "Skt." ),
DEF_SPLSTR( "Slav." ),
// "So." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Soc." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Sol." ),
DEF_SPLSTR( "Som." ),
DEF_SPLSTR( "Sp." ),
DEF_SPLSTR( "Span." ),
// "Sr." ),   // already in titles.txt
// "Sra." ),  // already in titles.txt
// "Srta." ), // already in titles.txt
// "St." ),   // already in titles.txt
// "St. Ex." ),
DEF_SPLSTR( "Ste." ),
DEF_SPLSTR( "Str." ),
DEF_SPLSTR( "Suff." ),
DEF_SPLSTR( "Sun." ),
DEF_SPLSTR( "Sup.Ct." ),
DEF_SPLSTR( "Sw." ),
DEF_SPLSTR( "Swaz." ),
DEF_SPLSTR( "Swe." ),
DEF_SPLSTR( "Swed." ),
DEF_SPLSTR( "Switz." ),
DEF_SPLSTR( "Syr." ),
// "T.B." ),
// "T.D." ),
// "T.F." ),
// "T.M." ),
// "T.S." ),
// "T.Sgt." ),// already in titles.txt
// "T.U." ),
DEF_SPLSTR( "Tanz." ),
DEF_SPLSTR( "Tas." ),
DEF_SPLSTR( "Tenn." ),
//"Test." ), Removed by AaronHal 2/4/2000 (Raid#2154)
DEF_SPLSTR( "Teut." ),
DEF_SPLSTR( "Tex." ),
DEF_SPLSTR( "Th." ),
DEF_SPLSTR( "Th.B." ),
DEF_SPLSTR( "Th.D." ),
DEF_SPLSTR( "Th.M." ),
DEF_SPLSTR( "Theo." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Thos." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Thur." ),
DEF_SPLSTR( "Thurs." ),
DEF_SPLSTR( "Tit." ),
DEF_SPLSTR( "Tu." ),
DEF_SPLSTR( "Tues." ),
DEF_SPLSTR( "Tun." ),
DEF_SPLSTR( "Tur." ),
// "U.A.E." ),
// "U.A.R." ),
// "U.K." ),
// "U.N." ),
// "U.S." ),
// "U.S.A." ),
// "U.S.C." ),
// "U.S.C.A." ),
// "U.S.M." ),
// "U.S.P." ),
// "U.S.S." ),
// "U.S.S.R." ),
DEF_SPLSTR( "Uni." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Univ." ),
DEF_SPLSTR( "Urug." ),
DEF_SPLSTR( "Ut." ),
// "V.A." ),  // already in titles.txt
// "V.Adm." ),// already in titles.txt
// "V.C." ),
// "V.F." ),
// "V.G." ),
// "V.I." ),
// "V.M.D." ),
// "V.P." ),
// "V.S." ),
DEF_SPLSTR( "Va." ),
DEF_SPLSTR( "Vat." ),
// "Ven." ),  // already in titles.txt
DEF_SPLSTR( "Venez." ),
DEF_SPLSTR( "Ver." ),
DEF_SPLSTR( "Viet." ),
// "Vis." ),  // already in titles.txt
// "Visct." ),// already in titles.txt
DEF_SPLSTR( "Vt." ),
DEF_SPLSTR( "Vul." ),
DEF_SPLSTR( "Vulg." ),
// "W.B." ),
// "W.C." ),
// "W.I." ),
DEF_SPLSTR( "W.Va." ),
// "W.W.I" ),                             // PaulCa 4/15/99 (Bug 108)
// "W.W.II" ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Wash." ),
DEF_SPLSTR( "Wed." ),
DEF_SPLSTR( "Wis." ),
DEF_SPLSTR( "Wm." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Wyo." ),
// "Y.T." ),
DEF_SPLSTR( "Yug." ),
DEF_SPLSTR( "Yugo." ),
DEF_SPLSTR( "a.b." ),
DEF_SPLSTR( "a.c." ),
DEF_SPLSTR( "a.d." ),
DEF_SPLSTR( "a.d.c." ),
DEF_SPLSTR( "a.i." ),
DEF_SPLSTR( "a.k.a." ),
DEF_SPLSTR( "a.l.s." ),
DEF_SPLSTR( "a.m." ),
DEF_SPLSTR( "a.p." ),
DEF_SPLSTR( "a.s.a.p." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "a.u." ),
DEF_SPLSTR( "a.v." ),
DEF_SPLSTR( "a.w." ),
DEF_SPLSTR( "ab." ),
DEF_SPLSTR( "abb." ),
DEF_SPLSTR( "abbr." ),
DEF_SPLSTR( "abbrs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "abl." ),
DEF_SPLSTR( "abp." ),
DEF_SPLSTR( "abr." ),
DEF_SPLSTR( "abs." ),
DEF_SPLSTR( "abt." ),
DEF_SPLSTR( "ac." ),
DEF_SPLSTR( "acad." ),
DEF_SPLSTR( "acc." ),
DEF_SPLSTR( "acct." ),
DEF_SPLSTR( "accts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "acet." ),
DEF_SPLSTR( "ack." ),
DEF_SPLSTR( "acpt." ),
DEF_SPLSTR( "actg." ),
DEF_SPLSTR( "ad loc." ),
DEF_SPLSTR( "addl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "addn." ),
DEF_SPLSTR( "addnl." ),
DEF_SPLSTR( "adj." ),
DEF_SPLSTR( "adjs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "adjt." ),
DEF_SPLSTR( "adm." ),
// "admin." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "adv." ),
DEF_SPLSTR( "advs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "advt." ),
DEF_SPLSTR( "agcy." ),
DEF_SPLSTR( "agri." ),
DEF_SPLSTR( "agric." ),
DEF_SPLSTR( "agt." ),
DEF_SPLSTR( "al." ),
DEF_SPLSTR( "alc." ),
DEF_SPLSTR( "alg." ),
DEF_SPLSTR( "alky." ),
DEF_SPLSTR( "alt." ),
DEF_SPLSTR( "amt." ),
DEF_SPLSTR( "amts." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "an." ),
DEF_SPLSTR( "anat." ),
DEF_SPLSTR( "anc." ),
DEF_SPLSTR( "and." ),         // andante
DEF_SPLSTR( "anhydr." ),
DEF_SPLSTR( "anim." ),
DEF_SPLSTR( "ann." ),
DEF_SPLSTR( "anon." ),
DEF_SPLSTR( "ans." ),
DEF_SPLSTR( "anthrop." ),
DEF_SPLSTR( "antiq." ),
DEF_SPLSTR( "aor." ),
DEF_SPLSTR( "ap." ),
DEF_SPLSTR( "app." ),
DEF_SPLSTR( "appl." ),
DEF_SPLSTR( "approx." ),
DEF_SPLSTR( "appt." ),
DEF_SPLSTR( "apptd." ),
DEF_SPLSTR( "apt." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "apts." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "aq." ),
DEF_SPLSTR( "ar." ),
DEF_SPLSTR( "archit." ),
DEF_SPLSTR( "archt." ),
DEF_SPLSTR( "arg." ),
DEF_SPLSTR( "arr." ),
// "art." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "arty." ),
DEF_SPLSTR( "asg." ),
DEF_SPLSTR( "asgd." ),
DEF_SPLSTR( "asgmt." ),
DEF_SPLSTR( "assn." ),
DEF_SPLSTR( "assns." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "assoc." ),
DEF_SPLSTR( "assocs." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "asst." ),
DEF_SPLSTR( "asstd." ),
DEF_SPLSTR( "assts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "assy." ),
DEF_SPLSTR( "astrol." ),
DEF_SPLSTR( "astron." ),
//"at." ),                                  // at. no.; special case no longer handled
DEF_SPLSTR( "athl." ),
DEF_SPLSTR( "atm." ),
DEF_SPLSTR( "atmos." ),
DEF_SPLSTR( "att." ),
DEF_SPLSTR( "attn." ),
DEF_SPLSTR( "attrib." ),
DEF_SPLSTR( "atty." ),
DEF_SPLSTR( "attys." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "aud." ),
DEF_SPLSTR( "aug." ),
DEF_SPLSTR( "auth." ),
DEF_SPLSTR( "aux." ),
// "aux. v." ),
DEF_SPLSTR( "av." ),
DEF_SPLSTR( "avdp." ),
DEF_SPLSTR( "ave." ),
DEF_SPLSTR( "avg." ),
DEF_SPLSTR( "avn." ),
DEF_SPLSTR( "az." ),
DEF_SPLSTR( "b.c." ),
DEF_SPLSTR( "b.c.e." ),
DEF_SPLSTR( "b.f." ),
DEF_SPLSTR( "b.i.d." ),
DEF_SPLSTR( "b.m." ),
DEF_SPLSTR( "b.p." ),
DEF_SPLSTR( "b.y." ),
DEF_SPLSTR( "bact." ),
DEF_SPLSTR( "bal." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "bbl." ),
DEF_SPLSTR( "bd." ),
// "bd. ft." ),
DEF_SPLSTR( "bdle." ),
DEF_SPLSTR( "bdrm." ),
DEF_SPLSTR( "bds." ),
DEF_SPLSTR( "bef." ),
DEF_SPLSTR( "bg." ),
DEF_SPLSTR( "bhd." ),
DEF_SPLSTR( "bibl." ),
DEF_SPLSTR( "bibliog." ),
DEF_SPLSTR( "biog." ),
DEF_SPLSTR( "biol." ),
DEF_SPLSTR( "bk." ),
DEF_SPLSTR( "bkg." ),
DEF_SPLSTR( "bkgd." ),
DEF_SPLSTR( "bklr." ),
DEF_SPLSTR( "bkpg." ),
DEF_SPLSTR( "bkpt." ),
DEF_SPLSTR( "bks." ),
DEF_SPLSTR( "bl." ),
DEF_SPLSTR( "bld." ),
DEF_SPLSTR( "bldg." ),
DEF_SPLSTR( "bldr." ),
DEF_SPLSTR( "blk." ),
DEF_SPLSTR( "blvd." ),
DEF_SPLSTR( "bm." ),
DEF_SPLSTR( "bn." ),
DEF_SPLSTR( "bor." ),
DEF_SPLSTR( "bot." ),
DEF_SPLSTR( "boul." ),
DEF_SPLSTR( "bp." ),
DEF_SPLSTR( "br." ),
DEF_SPLSTR( "brev." ),
DEF_SPLSTR( "bro." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "bros." ),
DEF_SPLSTR( "bsh." ),
DEF_SPLSTR( "bsk." ),
DEF_SPLSTR( "btry." ),
DEF_SPLSTR( "bu." ),
DEF_SPLSTR( "bul." ),
DEF_SPLSTR( "bur." ),
DEF_SPLSTR( "bvt." ),
DEF_SPLSTR( "bx." ),
DEF_SPLSTR( "c.a." ),
DEF_SPLSTR( "c.c." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.c.s." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.d." ),
DEF_SPLSTR( "c.f." ),
DEF_SPLSTR( "c.f.i." ),
DEF_SPLSTR( "c.g." ),
DEF_SPLSTR( "c.h." ),
DEF_SPLSTR( "c.i.f." ),
DEF_SPLSTR( "c.l." ),
DEF_SPLSTR( "c.m." ),
DEF_SPLSTR( "c.o." ),
DEF_SPLSTR( "c.o.d." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.o.s." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.v." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.w.o." ),
DEF_SPLSTR( "ca." ),      // circa
DEF_SPLSTR( "cal." ),
DEF_SPLSTR( "calc." ),
DEF_SPLSTR( "canc." ),
// "cap." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cath." ),
DEF_SPLSTR( "caus." ),
DEF_SPLSTR( "cav." ),
DEF_SPLSTR( "cc." ),
DEF_SPLSTR( "cckw." ),
DEF_SPLSTR( "ccw." ),
DEF_SPLSTR( "cen." ),
DEF_SPLSTR( "cert." ),
DEF_SPLSTR( "certif." ),
DEF_SPLSTR( "certifs." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cet." ),   // "cet. par."
DEF_SPLSTR( "cf." ), // Moved from titles.txt 8/18/99 - edc
DEF_SPLSTR( "ch." ),
DEF_SPLSTR( "chan." ),
DEF_SPLSTR( "chap." ),  // chapter
// "chaps." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "char." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "chars." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "chem." ),
DEF_SPLSTR( "chg." ),
DEF_SPLSTR( "chl." ),
DEF_SPLSTR( "chm." ),
DEF_SPLSTR( "chron." ),
DEF_SPLSTR( "chronol." ),
DEF_SPLSTR( "cie." ),
DEF_SPLSTR( "cir." ),
DEF_SPLSTR( "circ." ),
DEF_SPLSTR( "circum." ),
DEF_SPLSTR( "cit." ),
DEF_SPLSTR( "civ." ),
DEF_SPLSTR( "ck." ),
DEF_SPLSTR( "cl." ),
DEF_SPLSTR( "cld." ),
DEF_SPLSTR( "clk." ),
DEF_SPLSTR( "clm." ),
DEF_SPLSTR( "cm." ),
DEF_SPLSTR( "cmd." ),
DEF_SPLSTR( "cmdg." ),
DEF_SPLSTR( "cml." ),
DEF_SPLSTR( "co." ),
DEF_SPLSTR( "col." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "coll." ),
DEF_SPLSTR( "collat." ),
DEF_SPLSTR( "colloq." ),
DEF_SPLSTR( "cols." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "com." ),
DEF_SPLSTR( "comd." ),
DEF_SPLSTR( "comdg." ),
DEF_SPLSTR( "coml." ),
DEF_SPLSTR( "comm." ),
DEF_SPLSTR( "comp." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "compar." ),
DEF_SPLSTR( "compd." ),
DEF_SPLSTR( "compt." ),
DEF_SPLSTR( "conc." ),
DEF_SPLSTR( "cond." ),
DEF_SPLSTR( "conf." ),
DEF_SPLSTR( "confed." ),
DEF_SPLSTR( "cong." ),
DEF_SPLSTR( "conj." ),
DEF_SPLSTR( "conjs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cons." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "consol." ),
DEF_SPLSTR( "const." ),
DEF_SPLSTR( "constr." ),
DEF_SPLSTR( "cont." ),
DEF_SPLSTR( "contd." ),
DEF_SPLSTR( "contemp." ),
DEF_SPLSTR( "contr." ),
DEF_SPLSTR( "contrib." ),
DEF_SPLSTR( "conv." ),
DEF_SPLSTR( "coop." ),
DEF_SPLSTR( "cop." ),
DEF_SPLSTR( "cor." ),
DEF_SPLSTR( "corol." ),
DEF_SPLSTR( "corp." ),
// "corps." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "corr." ),
DEF_SPLSTR( "correl." ),
DEF_SPLSTR( "cos." ),
DEF_SPLSTR( "cp." ),
DEF_SPLSTR( "cpd." ),
DEF_SPLSTR( "cr." ),
DEF_SPLSTR( "crim." ),
DEF_SPLSTR( "crit." ),
DEF_SPLSTR( "cs." ),
DEF_SPLSTR( "csk." ),
DEF_SPLSTR( "ct." ),
DEF_SPLSTR( "ctf." ),
DEF_SPLSTR( "ctg." ),
DEF_SPLSTR( "ctge." ),
DEF_SPLSTR( "ctn." ),
DEF_SPLSTR( "ctr." ),
DEF_SPLSTR( "cu." ),
DEF_SPLSTR( "cum." ),
// "cur." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cv." ),
DEF_SPLSTR( "cvt." ),
DEF_SPLSTR( "cw." ),
DEF_SPLSTR( "cwt." ),
DEF_SPLSTR( "d.b.a." ),
DEF_SPLSTR( "d.b.h." ),
DEF_SPLSTR( "d.s." ),
DEF_SPLSTR( "d.s.p." ),
DEF_SPLSTR( "d.t." ),
DEF_SPLSTR( "dat." ),
DEF_SPLSTR( "dbl." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dble." ),
DEF_SPLSTR( "dd." ),
DEF_SPLSTR( "deb." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dec." ),
DEF_SPLSTR( "decd." ),
DEF_SPLSTR( "decl." ),
DEF_SPLSTR( "def." ),
DEF_SPLSTR( "deg." ),
DEF_SPLSTR( "del." ),
DEF_SPLSTR( "dely." ),
DEF_SPLSTR( "dem." ),
DEF_SPLSTR( "denom." ),
DEF_SPLSTR( "dep." ),
DEF_SPLSTR( "dept." ),
DEF_SPLSTR( "depts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "der." ),
DEF_SPLSTR( "deriv." ),
DEF_SPLSTR( "det." ),
DEF_SPLSTR( "dev." ),
DEF_SPLSTR( "dft." ),
DEF_SPLSTR( "dia." ),
DEF_SPLSTR( "diag." ),
DEF_SPLSTR( "diam." ),
DEF_SPLSTR( "dict." ),
DEF_SPLSTR( "dif." ),
DEF_SPLSTR( "diff." ),
DEF_SPLSTR( "dil." ),
DEF_SPLSTR( "dimin." ),
DEF_SPLSTR( "dipl." ),
DEF_SPLSTR( "dir." ),
DEF_SPLSTR( "dirs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dis." ),
// "disc." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "disp." ),
DEF_SPLSTR( "diss." ),
DEF_SPLSTR( "dissd." ),
DEF_SPLSTR( "dist." ),
DEF_SPLSTR( "distr." ),
DEF_SPLSTR( "div." ),
DEF_SPLSTR( "dk." ),
DEF_SPLSTR( "dlr." ),
DEF_SPLSTR( "dm." ),
DEF_SPLSTR( "dn." ),
DEF_SPLSTR( "doc." ),
DEF_SPLSTR( "dol." ),
DEF_SPLSTR( "dom." ),
DEF_SPLSTR( "doz." ),
DEF_SPLSTR( "dpt." ),
DEF_SPLSTR( "dr." ),
DEF_SPLSTR( "dup." ),
DEF_SPLSTR( "dupl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dupls." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dups." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dwt." ),
DEF_SPLSTR( "dy." ),
DEF_SPLSTR( "dz." ),
DEF_SPLSTR( "e.e." ),
DEF_SPLSTR( "e.g." ), // Moved from titles.txt - edc 8/18/99
DEF_SPLSTR( "e.o." ),
DEF_SPLSTR( "e.o.m." ),
DEF_SPLSTR( "e.p.t." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "e.s.p." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "e.t.a." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "e.t.d." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ea." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "eccl." ),
DEF_SPLSTR( "eccles." ),
DEF_SPLSTR( "ecol." ),
DEF_SPLSTR( "ed." ),
DEF_SPLSTR( "eds." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "educ." ),
DEF_SPLSTR( "eff." ),
DEF_SPLSTR( "el." ),
DEF_SPLSTR( "elec." ),
DEF_SPLSTR( "elem." ),
DEF_SPLSTR( "elev." ),
DEF_SPLSTR( "emer." ),
DEF_SPLSTR( "emp." ),
DEF_SPLSTR( "enc." ),
DEF_SPLSTR( "encl." ),
DEF_SPLSTR( "ency." ),
DEF_SPLSTR( "encyc." ),
DEF_SPLSTR( "encycl." ),
DEF_SPLSTR( "eng." ),
DEF_SPLSTR( "engr." ),
DEF_SPLSTR( "enl." ),
DEF_SPLSTR( "entom." ),
DEF_SPLSTR( "eq." ),
DEF_SPLSTR( "eqn." ),
DEF_SPLSTR( "eqns." ),
DEF_SPLSTR( "equip." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "equiv." ),
DEF_SPLSTR( "esp." ),
DEF_SPLSTR( "esq." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "est." ),
// "et al." ),
// "et seq." ),
// "et ux." ),
DEF_SPLSTR( "etc." ),
DEF_SPLSTR( "etym." ),
DEF_SPLSTR( "evan." ),
DEF_SPLSTR( "evang." ),
DEF_SPLSTR( "evap." ),
DEF_SPLSTR( "evg." ),
DEF_SPLSTR( "ex." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "exc." ),
DEF_SPLSTR( "exch." ),
DEF_SPLSTR( "excl." ),
// "exec." ),                             // PaulCa 4/15/99 (Bug 108)
// "execs." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "exp." ),
DEF_SPLSTR( "expt." ),
DEF_SPLSTR( "exptl." ),
DEF_SPLSTR( "exr." ),
DEF_SPLSTR( "exrx." ),
DEF_SPLSTR( "ext." ),
DEF_SPLSTR( "f.a." ),
DEF_SPLSTR( "f.a.a." ),
DEF_SPLSTR( "f.a.s." ),
DEF_SPLSTR( "f.c." ),
DEF_SPLSTR( "f.h.b." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "f.o.b." ),
DEF_SPLSTR( "f.r." ),
DEF_SPLSTR( "f.v." ),
DEF_SPLSTR( "fac." ),
DEF_SPLSTR( "fam." ),
DEF_SPLSTR( "fasc." ),
DEF_SPLSTR( "fcap." ),
DEF_SPLSTR( "fcp." ),
DEF_SPLSTR( "fcy." ),
DEF_SPLSTR( "fec." ),
// "fed." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "fem." ),
DEF_SPLSTR( "ff." ),
DEF_SPLSTR( "fgt." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "fict." ),
DEF_SPLSTR( "fig." ),                                 // special case
DEF_SPLSTR( "figs." ),                                // special case
DEF_SPLSTR( "fl." ),
DEF_SPLSTR( "fld." ),
DEF_SPLSTR( "fm." ),
DEF_SPLSTR( "fn." ),
DEF_SPLSTR( "fol." ),
DEF_SPLSTR( "fp." ),
DEF_SPLSTR( "fr." ),
DEF_SPLSTR( "freq." ),
DEF_SPLSTR( "frt." ),
DEF_SPLSTR( "ft." ),
DEF_SPLSTR( "fth." ),
DEF_SPLSTR( "furn." ),
DEF_SPLSTR( "fut." ),
DEF_SPLSTR( "fwd." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "g.m.b.h." ),
DEF_SPLSTR( "g.p.d." ),
DEF_SPLSTR( "g.p.m." ),
DEF_SPLSTR( "g.p.s." ),
DEF_SPLSTR( "ga." ),
// "gal." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "galv." ),
DEF_SPLSTR( "gaz." ),
DEF_SPLSTR( "gd." ),
DEF_SPLSTR( "gds." ),
DEF_SPLSTR( "gen." ),
DEF_SPLSTR( "genit." ),
DEF_SPLSTR( "genl." ),
DEF_SPLSTR( "geog." ),
DEF_SPLSTR( "geol." ),
DEF_SPLSTR( "geom." ),
DEF_SPLSTR( "ger." ),
DEF_SPLSTR( "gl." ),
DEF_SPLSTR( "gld." ),
DEF_SPLSTR( "gm." ),
DEF_SPLSTR( "gnd." ),
DEF_SPLSTR( "gov." ),
DEF_SPLSTR( "govt." ),
DEF_SPLSTR( "gr." ),
// "gr. wt." ),
DEF_SPLSTR( "gro." ),
DEF_SPLSTR( "gt." ),
DEF_SPLSTR( "gtd." ),
DEF_SPLSTR( "gtt." ),
DEF_SPLSTR( "guar." ),
DEF_SPLSTR( "gyn." ),
DEF_SPLSTR( "gynecol." ),
DEF_SPLSTR( "h.c." ),
DEF_SPLSTR( "h.q." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "h.r." ),
DEF_SPLSTR( "hab." ),     // "hab. corp." ),
DEF_SPLSTR( "hd." ),
DEF_SPLSTR( "hdbk." ),
DEF_SPLSTR( "hdkf." ),
DEF_SPLSTR( "hdlg." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hdqrs." ),
DEF_SPLSTR( "hdwe." ),
DEF_SPLSTR( "hf." ),
DEF_SPLSTR( "hgb." ),
DEF_SPLSTR( "hgt." ),
DEF_SPLSTR( "hgwy." ),
DEF_SPLSTR( "hist." ),
DEF_SPLSTR( "hld." ),
DEF_SPLSTR( "hm." ),
DEF_SPLSTR( "ho." ),
// "hon." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hor." ),
DEF_SPLSTR( "horol." ),
DEF_SPLSTR( "hort." ),
DEF_SPLSTR( "hosp." ),
DEF_SPLSTR( "hp." ),      // horsepower
DEF_SPLSTR( "hr." ),
DEF_SPLSTR( "ht." ),                                  // PaulCa 4/15/99 (Bug 108)
// "http." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hwy." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hyd." ),
DEF_SPLSTR( "hypoth." ),
DEF_SPLSTR( "i.a." ),
DEF_SPLSTR( "i.d." ),
DEF_SPLSTR( "i.e." ),  // Moved from titles.txt - edc 8/18/99
DEF_SPLSTR( "i.q." ),
DEF_SPLSTR( "i.w." ),
DEF_SPLSTR( "ib." ),
DEF_SPLSTR( "ibid." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ichth." ),
DEF_SPLSTR( "ign." ),
DEF_SPLSTR( "illus." ),
DEF_SPLSTR( "imit." ),
DEF_SPLSTR( "immun." ),
DEF_SPLSTR( "in." ),      // inch
DEF_SPLSTR( "inbd." ),
DEF_SPLSTR( "inc." ),
DEF_SPLSTR( "incl." ),
DEF_SPLSTR( "incog." ),
DEF_SPLSTR( "incr." ),
DEF_SPLSTR( "ind." ),
DEF_SPLSTR( "indef." ),
DEF_SPLSTR( "indic." ),
DEF_SPLSTR( "indn." ),
DEF_SPLSTR( "indus." ),
DEF_SPLSTR( "inf." ),
DEF_SPLSTR( "infin." ),
DEF_SPLSTR( "infl." ),
DEF_SPLSTR( "infs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "inj." ),
DEF_SPLSTR( "inq." ),
DEF_SPLSTR( "ins." ),
DEF_SPLSTR( "insol." ),
DEF_SPLSTR( "insp." ),
DEF_SPLSTR( "inst." ),
DEF_SPLSTR( "instr." ),
// "int'l." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "int." ),
DEF_SPLSTR( "inter." ),
DEF_SPLSTR( "interj." ),
DEF_SPLSTR( "interp." ),
DEF_SPLSTR( "interrog." ),
DEF_SPLSTR( "intl." ),
DEF_SPLSTR( "intr." ),
// "intro." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "inv." ),
DEF_SPLSTR( "irid." ),
DEF_SPLSTR( "irreg." ),
DEF_SPLSTR( "isl." ),
DEF_SPLSTR( "isth." ),
DEF_SPLSTR( "ital." ),
DEF_SPLSTR( "jct." ),
DEF_SPLSTR( "jnr." ),
DEF_SPLSTR( "jnt." ),
DEF_SPLSTR( "jour." ),
DEF_SPLSTR( "jr." ),
DEF_SPLSTR( "jt." ),
DEF_SPLSTR( "jun." ),
DEF_SPLSTR( "junc." ),
DEF_SPLSTR( "juv." ),
DEF_SPLSTR( "jwlr." ),
DEF_SPLSTR( "kc." ),
DEF_SPLSTR( "km." ),
DEF_SPLSTR( "kmh." ),
DEF_SPLSTR( "kn." ),
DEF_SPLSTR( "kr." ),
DEF_SPLSTR( "kt." ),
DEF_SPLSTR( "l." ),      // liter
DEF_SPLSTR( "l.c." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "l.c.d." ),
DEF_SPLSTR( "l.c.m." ),
DEF_SPLSTR( "l.t." ),
DEF_SPLSTR( "lang." ),
DEF_SPLSTR( "langs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "lat." ),
DEF_SPLSTR( "lav." ),
DEF_SPLSTR( "lb." ),
DEF_SPLSTR( "lbs." ),
DEF_SPLSTR( "ld." ),
DEF_SPLSTR( "ldg." ),
DEF_SPLSTR( "lea." ),
DEF_SPLSTR( "lect." ),
DEF_SPLSTR( "lectr." ),
DEF_SPLSTR( "legis." ),
DEF_SPLSTR( "lg." ),
DEF_SPLSTR( "lge." ),
DEF_SPLSTR( "li." ),
DEF_SPLSTR( "lieut." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "lim." ),
DEF_SPLSTR( "lin." ),
DEF_SPLSTR( "ling." ),
DEF_SPLSTR( "liq." ),
// "lit." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "lith." ),
DEF_SPLSTR( "litho." ),
DEF_SPLSTR( "lithog." ),
DEF_SPLSTR( "ll." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "loc." ),
// "loc. cit." ),
// "long." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "loq." ),
DEF_SPLSTR( "lt." ),
DEF_SPLSTR( "ltd." ),
DEF_SPLSTR( "ltda." ),
DEF_SPLSTR( "lv." ),
DEF_SPLSTR( "lyr." ),
DEF_SPLSTR( "m.d." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "m.f." ),
DEF_SPLSTR( "m.m." ),
DEF_SPLSTR( "m.o." ),
DEF_SPLSTR( "m.o.m." ),
DEF_SPLSTR( "m.p.g." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "m.p.h." ),
DEF_SPLSTR( "m.s.l." ),
DEF_SPLSTR( "m.t." ),
DEF_SPLSTR( "m.y." ),
DEF_SPLSTR( "mach." ),
DEF_SPLSTR( "mag." ),
DEF_SPLSTR( "manuf." ),
DEF_SPLSTR( "manufac." ),
DEF_SPLSTR( "marg." ),
DEF_SPLSTR( "masc." ),
// "max." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mc." ),
DEF_SPLSTR( "mdse." ),
DEF_SPLSTR( "meas." ),
DEF_SPLSTR( "mech." ),
DEF_SPLSTR( "med." ),
DEF_SPLSTR( "mer." ),
DEF_SPLSTR( "metall." ),
DEF_SPLSTR( "metaph." ),
DEF_SPLSTR( "mfd." ),
DEF_SPLSTR( "mfg." ),
DEF_SPLSTR( "mfr." ),
DEF_SPLSTR( "mfrs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mg." ),     // milligram
DEF_SPLSTR( "mgmt." ),
DEF_SPLSTR( "mgr." ),
DEF_SPLSTR( "mgrs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mgt." ),
DEF_SPLSTR( "mhz." ),
DEF_SPLSTR( "mi." ),
DEF_SPLSTR( "mid." ),
DEF_SPLSTR( "min." ),
DEF_SPLSTR( "misc." ),
DEF_SPLSTR( "mk." ),
DEF_SPLSTR( "mkt." ),
DEF_SPLSTR( "mktg." ),
DEF_SPLSTR( "ml." ),  // milliliter
DEF_SPLSTR( "mm." ),
DEF_SPLSTR( "mngr." ),
DEF_SPLSTR( "mo." ),
DEF_SPLSTR( "mol." ),
DEF_SPLSTR( "mon." ),
DEF_SPLSTR( "morph." ),
DEF_SPLSTR( "mos." ),
DEF_SPLSTR( "mph." ),
DEF_SPLSTR( "msec." ),
DEF_SPLSTR( "msg." ),
DEF_SPLSTR( "mt." ),
DEF_SPLSTR( "mtg." ),
DEF_SPLSTR( "mtge." ),
DEF_SPLSTR( "mtgs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mtn." ),
DEF_SPLSTR( "mts." ),
DEF_SPLSTR( "mus." ),
DEF_SPLSTR( "mxd." ),
DEF_SPLSTR( "myc." ),
DEF_SPLSTR( "mycol." ),
DEF_SPLSTR( "mythol." ),
DEF_SPLSTR( "n.b." ),
DEF_SPLSTR( "n.d." ),
DEF_SPLSTR( "n.e.s." ),
DEF_SPLSTR( "n.l." ),
DEF_SPLSTR( "n.m." ),
DEF_SPLSTR( "n.o.p." ),
DEF_SPLSTR( "n.o.s." ),
DEF_SPLSTR( "n.s." ),
DEF_SPLSTR( "n.s.f." ),
DEF_SPLSTR( "n.t.p." ),
DEF_SPLSTR( "n.wt." ),
DEF_SPLSTR( "nat." ),
DEF_SPLSTR( "natl." ),
DEF_SPLSTR( "naut." ),
DEF_SPLSTR( "nav." ),
DEF_SPLSTR( "ne." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "neg." ),
DEF_SPLSTR( "neur." ),
DEF_SPLSTR( "neurol." ),
DEF_SPLSTR( "neut." ),
DEF_SPLSTR( "no." ),                                  // special case handled in the code
DEF_SPLSTR( "nol." ),     // "nol. pros." ),
DEF_SPLSTR( "nom." ),
DEF_SPLSTR( "nos." ),
DEF_SPLSTR( "nt." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "nt.wt." ),
DEF_SPLSTR( "num." ),
DEF_SPLSTR( "numis." ),
DEF_SPLSTR( "nw." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "o.c." ),
DEF_SPLSTR( "o.d." ),
DEF_SPLSTR( "o.k." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "o.n.o." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "o.s." ),
DEF_SPLSTR( "o.t." ),
DEF_SPLSTR( "ob." ),
DEF_SPLSTR( "obj." ),
DEF_SPLSTR( "obl." ),
DEF_SPLSTR( "obs." ),
DEF_SPLSTR( "obstet." ),
DEF_SPLSTR( "oc." ),
DEF_SPLSTR( "occ." ),
DEF_SPLSTR( "occas." ),
DEF_SPLSTR( "oct." ),
DEF_SPLSTR( "op." ),
// L"op. cit." ),
DEF_SPLSTR( "opp." ),
DEF_SPLSTR( "opt." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "orch." ),
DEF_SPLSTR( "ord." ),
DEF_SPLSTR( "ordn." ),
DEF_SPLSTR( "org." ),
DEF_SPLSTR( "orig." ),
DEF_SPLSTR( "ornith." ),
DEF_SPLSTR( "orth." ),
DEF_SPLSTR( "otol." ),
DEF_SPLSTR( "oz" ),
DEF_SPLSTR( "oz." ),
DEF_SPLSTR( "p.a." ),
DEF_SPLSTR( "p.c." ),
DEF_SPLSTR( "p.d." ),
DEF_SPLSTR( "p.m." ),
DEF_SPLSTR( "p.n." ),
DEF_SPLSTR( "p.o." ),
DEF_SPLSTR( "p.o.e." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "p.p." ),
DEF_SPLSTR( "p.p.a." ),
DEF_SPLSTR( "p.q." ),
DEF_SPLSTR( "p.r." ),
DEF_SPLSTR( "p.r.n." ),
DEF_SPLSTR( "p.s." ),   // A bogus abbreviation for Post Scriptum. Also covers "P.S." and "P.s."
DEF_SPLSTR( "p.t." ),
DEF_SPLSTR( "p.t.o." ),
DEF_SPLSTR( "pam." ),
DEF_SPLSTR( "par." ),   // "cet. par."
DEF_SPLSTR( "paren." ),
DEF_SPLSTR( "parl." ),
// L"pat." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "patd." ),
// L"pats." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "payt." ),
DEF_SPLSTR( "pct." ),
DEF_SPLSTR( "pd." ),
DEF_SPLSTR( "per." ),
DEF_SPLSTR( "perp." ),
DEF_SPLSTR( "pers." ),
DEF_SPLSTR( "petr." ),
DEF_SPLSTR( "petrog." ),
DEF_SPLSTR( "pf." ),
DEF_SPLSTR( "pfd." ),
DEF_SPLSTR( "pfg." ),
DEF_SPLSTR( "pg." ),
DEF_SPLSTR( "ph." ),
DEF_SPLSTR( "phar." ),
DEF_SPLSTR( "pharm." ),
DEF_SPLSTR( "phil." ),
DEF_SPLSTR( "philos." ),
DEF_SPLSTR( "phon." ),
DEF_SPLSTR( "photog." ),
DEF_SPLSTR( "photom." ),
DEF_SPLSTR( "phr." ),
DEF_SPLSTR( "phren." ),
DEF_SPLSTR( "phys." ),
// L"phys. ed." ),
DEF_SPLSTR( "physiol." ),
DEF_SPLSTR( "pinx." ),
DEF_SPLSTR( "pizz." ),
DEF_SPLSTR( "pk." ),
DEF_SPLSTR( "pkg." ),
DEF_SPLSTR( "pkgs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pkt." ),
DEF_SPLSTR( "pl." ),
DEF_SPLSTR( "plf." ),
DEF_SPLSTR( "pln." ),
DEF_SPLSTR( "pls." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "plu." ),
DEF_SPLSTR( "pm." ),
DEF_SPLSTR( "pmk." ),
DEF_SPLSTR( "pmt." ),
DEF_SPLSTR( "pmts." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pneum." ),
DEF_SPLSTR( "pol." ),
DEF_SPLSTR( "polit." ),
DEF_SPLSTR( "por." ),
DEF_SPLSTR( "pos." ),
DEF_SPLSTR( "poss." ),
DEF_SPLSTR( "pp." ),
DEF_SPLSTR( "ppd." ),
DEF_SPLSTR( "pph." ),
DEF_SPLSTR( "ppt." ),
DEF_SPLSTR( "pptn." ),
DEF_SPLSTR( "pr." ),
DEF_SPLSTR( "prec." ),
DEF_SPLSTR( "pred." ),
DEF_SPLSTR( "pref." ),
DEF_SPLSTR( "prem." ),
// L"prep." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "prepd." ),
DEF_SPLSTR( "prepn." ),
DEF_SPLSTR( "preps." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pres." ),
DEF_SPLSTR( "pret." ),
DEF_SPLSTR( "prev." ),
DEF_SPLSTR( "prf." ),
DEF_SPLSTR( "prin." ),
DEF_SPLSTR( "priv." ),
DEF_SPLSTR( "prob." ),
DEF_SPLSTR( "probs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "proc." ),
// L"prod." ),                             // PaulCa 4/15/99 (Bug 108)
// L"prods." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "prof." ),
DEF_SPLSTR( "pron." ),
DEF_SPLSTR( "propr." ),
DEF_SPLSTR( "pros." ),
DEF_SPLSTR( "protec." ),
DEF_SPLSTR( "prov." ),
DEF_SPLSTR( "prox." ),
DEF_SPLSTR( "ps." ),  // A bogus abbreviation for Post Scriptum. Also covers "PS." and "Ps."
DEF_SPLSTR( "psec." ),
DEF_SPLSTR( "pseud." ),
DEF_SPLSTR( "psf." ),
DEF_SPLSTR( "pstg." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "psych." ),
DEF_SPLSTR( "psychol." ),
DEF_SPLSTR( "pt." ),
DEF_SPLSTR( "pta." ),
DEF_SPLSTR( "ptg." ),
DEF_SPLSTR( "pty." ),
// L"pub." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "publ." ),
// L"pubs." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pwr." ),
DEF_SPLSTR( "pwt." ),
DEF_SPLSTR( "pxt." ),
DEF_SPLSTR( "pyro." ),
// L"q. t." ),
DEF_SPLSTR( "q.b." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "q.i.d." ),
DEF_SPLSTR( "q.p." ),
DEF_SPLSTR( "q.s." ),
DEF_SPLSTR( "q.t." ),
DEF_SPLSTR( "q.v." ),
DEF_SPLSTR( "ql." ),
DEF_SPLSTR( "qlty." ),
DEF_SPLSTR( "qn." ),
DEF_SPLSTR( "qq." ),
DEF_SPLSTR( "qq.v." ),
DEF_SPLSTR( "qr." ),
DEF_SPLSTR( "qrs." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "qt." ),
DEF_SPLSTR( "qto." ),
DEF_SPLSTR( "qtr." ),   //
DEF_SPLSTR( "qtrs." ),  // Noah 2.0, bug #70: the first two qtrs. of CY 95
DEF_SPLSTR( "qty." ),
DEF_SPLSTR( "qu." ),
DEF_SPLSTR( "qual." ),
DEF_SPLSTR( "quant." ),
DEF_SPLSTR( "quar." ),
DEF_SPLSTR( "ques." ),
DEF_SPLSTR( "quot." ),
DEF_SPLSTR( "r.h." ),
DEF_SPLSTR( "r.i.p." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "r.n." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "r.o.t.c." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rad." ),
DEF_SPLSTR( "rcpt." ),
DEF_SPLSTR( "rct." ),
DEF_SPLSTR( "rd." ),
DEF_SPLSTR( "rec." ),
// L"rec. sec." ),
DEF_SPLSTR( "recd." ),
DEF_SPLSTR( "recip." ),
DEF_SPLSTR( "recs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rect." ),
// L"red." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ref." ),
DEF_SPLSTR( "refl." ),
// L"refs." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "reg." ),
DEF_SPLSTR( "regd." ),
DEF_SPLSTR( "regt." ),
DEF_SPLSTR( "rel." ),
DEF_SPLSTR( "rem." ),
DEF_SPLSTR( "rep." ),
DEF_SPLSTR( "repl." ),
// L"reps." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rept." ),
DEF_SPLSTR( "req." ),
DEF_SPLSTR( "reqd." ),
DEF_SPLSTR( "res." ),
DEF_SPLSTR( "resp." ),
DEF_SPLSTR( "ret." ),
DEF_SPLSTR( "rev." ),
DEF_SPLSTR( "rf." ),
DEF_SPLSTR( "rhbdr." ),
DEF_SPLSTR( "rheo." ),
DEF_SPLSTR( "rhet." ),
DEF_SPLSTR( "rhomb." ),
DEF_SPLSTR( "rit." ),
DEF_SPLSTR( "riv." ),
DEF_SPLSTR( "rm." ),
DEF_SPLSTR( "rms." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rnd." ),
DEF_SPLSTR( "ro." ),
DEF_SPLSTR( "rom." ),
DEF_SPLSTR( "rpt." ),
DEF_SPLSTR( "rt." ),
DEF_SPLSTR( "rte." ),
DEF_SPLSTR( "rtes." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rul." ),
DEF_SPLSTR( "rwy." ),
DEF_SPLSTR( "ry." ),
DEF_SPLSTR( "s.a." ),
DEF_SPLSTR( "s.ap." ),
DEF_SPLSTR( "s.b." ),
DEF_SPLSTR( "s.d." ),
DEF_SPLSTR( "s.l." ),
DEF_SPLSTR( "s.l.a.n." ),
DEF_SPLSTR( "s.n." ),
DEF_SPLSTR( "s.o." ),
DEF_SPLSTR( "s.p." ),
DEF_SPLSTR( "s.p.a." ),
DEF_SPLSTR( "s.p.s." ),
DEF_SPLSTR( "s.t." ),
DEF_SPLSTR( "s.w.a.t." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "sanit." ),
DEF_SPLSTR( "satd." ),
DEF_SPLSTR( "sb." ),
DEF_SPLSTR( "sc." ),
DEF_SPLSTR( "sch." ),
DEF_SPLSTR( "sci." ),
DEF_SPLSTR( "scr." ),
DEF_SPLSTR( "sculp." ),
DEF_SPLSTR( "sd." ),
DEF_SPLSTR( "se." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "sec." ),
DEF_SPLSTR( "sect." ),                                // special case
DEF_SPLSTR( "secy." ),
DEF_SPLSTR( "sed." ),
DEF_SPLSTR( "sel." ),
DEF_SPLSTR( "sem." ),
DEF_SPLSTR( "sen." ),
DEF_SPLSTR( "sep." ),
DEF_SPLSTR( "sepd." ),
DEF_SPLSTR( "seq." ),
DEF_SPLSTR( "seqq." ),
DEF_SPLSTR( "ser." ),
DEF_SPLSTR( "serv." ),
DEF_SPLSTR( "sess." ),
DEF_SPLSTR( "sf." ),
DEF_SPLSTR( "sfz." ),
DEF_SPLSTR( "sgd." ),
DEF_SPLSTR( "sh." ),
DEF_SPLSTR( "shpt." ),
DEF_SPLSTR( "shpts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "shr." ),
DEF_SPLSTR( "sht." ),
DEF_SPLSTR( "sig." ),
// L"sing." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "sk." ),
DEF_SPLSTR( "sl." ),
DEF_SPLSTR( "sld." ),
DEF_SPLSTR( "sm." ),
DEF_SPLSTR( "soc." ),
DEF_SPLSTR( "sol." ),
DEF_SPLSTR( "soln." ),
DEF_SPLSTR( "soph." ),
DEF_SPLSTR( "sou." ),
DEF_SPLSTR( "sp." ),
DEF_SPLSTR( "spec." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "specif." ),
DEF_SPLSTR( "spp." ),
DEF_SPLSTR( "spr." ),
DEF_SPLSTR( "spt." ),
DEF_SPLSTR( "sq." ),
DEF_SPLSTR( "sr." ),
DEF_SPLSTR( "ss." ),
DEF_SPLSTR( "ssp." ),
DEF_SPLSTR( "st." ),
DEF_SPLSTR( "sta." ),
DEF_SPLSTR( "stacc." ),
DEF_SPLSTR( "stat." ),
DEF_SPLSTR( "stbd." ),
DEF_SPLSTR( "std." ),
DEF_SPLSTR( "sten." ),
DEF_SPLSTR( "stenog." ),
DEF_SPLSTR( "ster." ),
DEF_SPLSTR( "stg." ),
DEF_SPLSTR( "stge." ),
DEF_SPLSTR( "stip." ),
DEF_SPLSTR( "stk." ),
DEF_SPLSTR( "stmt." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "stmts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "str." ),
// L"sub." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "subj." ),
DEF_SPLSTR( "subjs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "subs." ),
DEF_SPLSTR( "subsp." ),
DEF_SPLSTR( "subst." ),
DEF_SPLSTR( "suf." ),
DEF_SPLSTR( "suff." ),
DEF_SPLSTR( "supp." ),
DEF_SPLSTR( "suppl." ),
DEF_SPLSTR( "supr." ),
DEF_SPLSTR( "supt." ),
DEF_SPLSTR( "supvr." ),
DEF_SPLSTR( "sur." ),
DEF_SPLSTR( "surg." ),
DEF_SPLSTR( "surr." ),
DEF_SPLSTR( "svgs." ),
DEF_SPLSTR( "sw." ),
DEF_SPLSTR( "syl." ),
DEF_SPLSTR( "syll." ),
DEF_SPLSTR( "sym." ),
DEF_SPLSTR( "syn." ),
DEF_SPLSTR( "synd." ),
DEF_SPLSTR( "syst." ),
DEF_SPLSTR( "t.b." ),
DEF_SPLSTR( "t.g." ),
DEF_SPLSTR( "t.i.d." ),
DEF_SPLSTR( "t.l." ),
DEF_SPLSTR( "t.l.o." ),
DEF_SPLSTR( "t.m." ),
DEF_SPLSTR( "t.o." ),
DEF_SPLSTR( "t.p." ),
DEF_SPLSTR( "tab." ),
DEF_SPLSTR( "tbs." ),
DEF_SPLSTR( "tbsp." ),
DEF_SPLSTR( "tchr." ),
DEF_SPLSTR( "tec." ),
DEF_SPLSTR( "tech." ),
DEF_SPLSTR( "technol." ),
DEF_SPLSTR( "tel." ),
DEF_SPLSTR( "teleg." ),
// L"temp." ),                             // PaulCa 4/15/99 (Bug 108)
// L"temps." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ter." ),
DEF_SPLSTR( "terr." ),
DEF_SPLSTR( "tfr." ),
DEF_SPLSTR( "tgt." ),
DEF_SPLSTR( "theat." ),
DEF_SPLSTR( "theol." ),
DEF_SPLSTR( "therap." ),
DEF_SPLSTR( "therm." ),
DEF_SPLSTR( "tinct." ),
DEF_SPLSTR( "tk." ),
DEF_SPLSTR( "tkt." ),
DEF_SPLSTR( "tlr." ),
DEF_SPLSTR( "tn." ),
DEF_SPLSTR( "tng." ),
DEF_SPLSTR( "tnpk." ),
DEF_SPLSTR( "topog." ),
DEF_SPLSTR( "tp." ),
DEF_SPLSTR( "tpk." ),
DEF_SPLSTR( "tr." ),
DEF_SPLSTR( "trans." ),
DEF_SPLSTR( "transf." ),
DEF_SPLSTR( "transl." ),
DEF_SPLSTR( "transp." ),
DEF_SPLSTR( "trav." ),
DEF_SPLSTR( "treas." ),
DEF_SPLSTR( "trib." ),
DEF_SPLSTR( "trigon." ),
DEF_SPLSTR( "tripl." ),
DEF_SPLSTR( "trop." ),
DEF_SPLSTR( "trp." ),
DEF_SPLSTR( "tsp." ),
DEF_SPLSTR( "twp." ),
DEF_SPLSTR( "typ." ),
DEF_SPLSTR( "u.c." ),
DEF_SPLSTR( "u.p.s." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "u.s." ),
DEF_SPLSTR( "u.s.a." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ult." ),
DEF_SPLSTR( "unan." ),
DEF_SPLSTR( "unb." ),
DEF_SPLSTR( "unbd." ),
DEF_SPLSTR( "univ." ),
DEF_SPLSTR( "unp." ),
DEF_SPLSTR( "uns." ),
DEF_SPLSTR( "urol." ),
DEF_SPLSTR( "usu." ),
DEF_SPLSTR( "util." ),
DEF_SPLSTR( "ux." ),
DEF_SPLSTR( "v.d." ),
DEF_SPLSTR( "v.i." ),
DEF_SPLSTR( "v.s." ),
DEF_SPLSTR( "v.v." ),
DEF_SPLSTR( "vac." ),
DEF_SPLSTR( "val." ),
DEF_SPLSTR( "var." ),
DEF_SPLSTR( "vars." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "vb." ),
DEF_SPLSTR( "vbs." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "veg." ),
DEF_SPLSTR( "vel." ),
DEF_SPLSTR( "ver." ),
DEF_SPLSTR( "vert." ),
DEF_SPLSTR( "veter." ),
DEF_SPLSTR( "vic." ),
DEF_SPLSTR( "vil." ),
DEF_SPLSTR( "vis." ),
DEF_SPLSTR( "viz." ),
DEF_SPLSTR( "vo." ),
DEF_SPLSTR( "voc." ),
DEF_SPLSTR( "vocab." ),
DEF_SPLSTR( "vol." ),
DEF_SPLSTR( "vols." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "vou." ),
DEF_SPLSTR( "vs." ), // Moved from titles.txt - edc 8/18/99
DEF_SPLSTR( "vss." ),
DEF_SPLSTR( "vulg." ),
DEF_SPLSTR( "vv." ),
DEF_SPLSTR( "w.b." ),
DEF_SPLSTR( "w.f." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "w.g." ),
DEF_SPLSTR( "w.i." ),
DEF_SPLSTR( "w.l." ),
DEF_SPLSTR( "w.o.c." ),
DEF_SPLSTR( "w.p.m." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "wd." ),
DEF_SPLSTR( "wh." ),
DEF_SPLSTR( "whf." ),
DEF_SPLSTR( "whs." ),
DEF_SPLSTR( "whsle." ),
DEF_SPLSTR( "wid." ),
DEF_SPLSTR( "wk." ),
DEF_SPLSTR( "wkly." ),
DEF_SPLSTR( "wm." ),
DEF_SPLSTR( "wmk." ),
DEF_SPLSTR( "wpn." ),
DEF_SPLSTR( "wrnt." ),
DEF_SPLSTR( "wt." ),
DEF_SPLSTR( "x-div." ),
DEF_SPLSTR( "x-int." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "yd." ),
DEF_SPLSTR( "yel." ),
DEF_SPLSTR( "yeo." ),
DEF_SPLSTR( "yr." ),
DEF_SPLSTR( "yrs." ),
DEF_SPLSTR( "zool." ),
};

// This is an alphabetized list of all non-proper-noun words which
// appear within the list of the 200 most frequent first words
// in sentences in both the Brown and WSJ corpora.
static const SPLSTR g_FirstWords[] =
{
DEF_SPLSTR( "A" ),
DEF_SPLSTR( "About" ),
DEF_SPLSTR( "According" ),
DEF_SPLSTR( "After" ),
DEF_SPLSTR( "Again" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "All" ),
DEF_SPLSTR( "Also" ),
DEF_SPLSTR( "Although" ),
//L"American" ),                             // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Among" ),
DEF_SPLSTR( "An" ),
DEF_SPLSTR( "And" ),
DEF_SPLSTR( "Another" ),
DEF_SPLSTR( "Any" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Anyway" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Are" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "As" ),
DEF_SPLSTR( "At" ),
DEF_SPLSTR( "Back" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Because" ),
DEF_SPLSTR( "Before" ),
DEF_SPLSTR( "Besides" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Both" ),
DEF_SPLSTR( "But" ),
DEF_SPLSTR( "By" ),
DEF_SPLSTR( "Can" ),                                  // PaulCa added 4/14/99 (Bug 107)
//L"Click" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Consequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Dear" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Despite" ),
DEF_SPLSTR( "Did" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Do" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Does" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Don't" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "During" ),
DEF_SPLSTR( "Each" ),
DEF_SPLSTR( "Early" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Even" ),
DEF_SPLSTR( "Every" ),                                // PaulCa added 4/14/99 (Bug 107)
//L"Executive" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Finally" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "First" ),
DEF_SPLSTR( "Following" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "For" ),
//L"Founded" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Four" ),
DEF_SPLSTR( "From" ),
DEF_SPLSTR( "Further" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Furthermore" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Generally" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Given" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Go" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Great" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Had" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Have" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Having" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "He" ),
DEF_SPLSTR( "Her" ),
DEF_SPLSTR( "Here" ),
DEF_SPLSTR( "His" ),
DEF_SPLSTR( "How" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "However" ),
DEF_SPLSTR( "I" ),
DEF_SPLSTR( "If" ),
DEF_SPLSTR( "In" ),
DEF_SPLSTR( "Indeed" ),
//L"Industrial" ),                           // PaulCa added 4/14/99 (Bug 107)
//L"Information" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Initially" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Instead" ),
DEF_SPLSTR( "Is" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "It" ),
DEF_SPLSTR( "Its" ),
DEF_SPLSTR( "Just" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"King" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Last" ),
DEF_SPLSTR( "Later" ),
DEF_SPLSTR( "Let" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Like" ),
//L"Little" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Many" ),
DEF_SPLSTR( "Maybe" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Meanwhile" ),
DEF_SPLSTR( "More" ),
DEF_SPLSTR( "Moreover" ),
DEF_SPLSTR( "Most" ),
DEF_SPLSTR( "Much" ),
DEF_SPLSTR( "My" ),    // Added to fix bug #385
DEF_SPLSTR( "Neither" ),
DEF_SPLSTR( "Never" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nevertheless" ),
DEF_SPLSTR( "New" ),
DEF_SPLSTR( "Next" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "No" ),
DEF_SPLSTR( "None" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nonetheless" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nor" ),
DEF_SPLSTR( "Not" ),
DEF_SPLSTR( "Nothing" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Now" ),
DEF_SPLSTR( "Of" ),
DEF_SPLSTR( "On" ),
DEF_SPLSTR( "Once" ),
DEF_SPLSTR( "One" ),
DEF_SPLSTR( "Only" ),
DEF_SPLSTR( "Or" ),
DEF_SPLSTR( "Other" ),
DEF_SPLSTR( "Others" ),
DEF_SPLSTR( "Our" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Over" ),
DEF_SPLSTR( "People" ),
DEF_SPLSTR( "Perhaps" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Please" ),                               // PaulCa added 4/14/99 (Bug 107)
//L"President" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Previous" ),                             // PaulCa added 4/14/99 (Bug 107)
//L"Public" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Recent" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Right" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Second" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "See" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Several" ),
DEF_SPLSTR( "She" ),
DEF_SPLSTR( "Shortly" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Similarly" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Since" ),
DEF_SPLSTR( "So" ),
DEF_SPLSTR( "Some" ),
DEF_SPLSTR( "Sometimes" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Soon" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"Special" ),                              // PaulCa added 4/14/99 (Bug 107)
//L"State" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Still" ),
DEF_SPLSTR( "Subsequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Such" ),
DEF_SPLSTR( "Take" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "That" ),
DEF_SPLSTR( "The" ),
DEF_SPLSTR( "Their" ),
DEF_SPLSTR( "Then" ),
DEF_SPLSTR( "There" ),
DEF_SPLSTR( "Thereafter" ),                           // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Therefore" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "These" ),
DEF_SPLSTR( "They" ),
DEF_SPLSTR( "This" ),
DEF_SPLSTR( "Those" ),
DEF_SPLSTR( "Though" ),
DEF_SPLSTR( "Three" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Through" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Thus" ),
DEF_SPLSTR( "To" ),
DEF_SPLSTR( "Today" ),
DEF_SPLSTR( "Two" ),
DEF_SPLSTR( "Under" ),
//L"United" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Unlike" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Until" ),
DEF_SPLSTR( "Upon" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"Water" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "We" ),
DEF_SPLSTR( "Well" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"West" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "What" ),
DEF_SPLSTR( "When" ),
DEF_SPLSTR( "Where" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Whether" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Which" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "While" ),
//L"White" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Who" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Why" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Will" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "With" ),
DEF_SPLSTR( "Within" ),
DEF_SPLSTR( "Without" ),                              // PaulCa added 4/14/99 (Bug 107)
//L"Women" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yes" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yet" ),
DEF_SPLSTR( "You" ),
DEF_SPLSTR( "Your" ),
};

// When the following abbreviations are followed by an uppercase word, 
// it is unlikely that the uppercase word starts a new sentence.
// 
static const SPLSTR g_Titles[] =
{
DEF_SPLSTR( "Adm." ),
DEF_SPLSTR( "Atty." ),
DEF_SPLSTR( "Bn." ),
DEF_SPLSTR( "Bt." ),
DEF_SPLSTR( "Btss." ),
DEF_SPLSTR( "C.G." ),
DEF_SPLSTR( "Capt." ),
DEF_SPLSTR( "Cdr." ),
DEF_SPLSTR( "Cf." ),  // See "cf." below
DEF_SPLSTR( "Chi." ), // Mr.(?) in India
DEF_SPLSTR( "Col." ),
DEF_SPLSTR( "Com." ),
DEF_SPLSTR( "Comdr." ),
DEF_SPLSTR( "Cpl." ),
DEF_SPLSTR( "Cpt." ),
DEF_SPLSTR( "Ct." ),
DEF_SPLSTR( "D.F." ),
DEF_SPLSTR( "Dr." ),
DEF_SPLSTR( "Drs." ),
DEF_SPLSTR( "Du." ),
DEF_SPLSTR( "E.g." ), // See "e.g." below
DEF_SPLSTR( "Esq." ),
DEF_SPLSTR( "Exc." ),
DEF_SPLSTR( "Fr." ),
DEF_SPLSTR( "Frl." ),
DEF_SPLSTR( "Gen." ),
DEF_SPLSTR( "Gov." ),
DEF_SPLSTR( "H.E." ),
DEF_SPLSTR( "H.H." ),
DEF_SPLSTR( "H.I.H." ),
DEF_SPLSTR( "H.I.M." ),
DEF_SPLSTR( "H.M." ),
DEF_SPLSTR( "H.R.H." ),
DEF_SPLSTR( "H.S.H." ),
DEF_SPLSTR( "Hon." ),
DEF_SPLSTR( "Hr." ),
DEF_SPLSTR( "I.e." ), // See "i.e." below
DEF_SPLSTR( "Km." ),  // Mr. or Ms. (?) in India
DEF_SPLSTR( "L.Cpl." ),
DEF_SPLSTR( "Ld." ),
DEF_SPLSTR( "Lt." ),
DEF_SPLSTR( "M.M." ),
DEF_SPLSTR( "M.Sgt." ),
DEF_SPLSTR( "Maj." ),
DEF_SPLSTR( "Mdm." ),
DEF_SPLSTR( "Messrs." ),
DEF_SPLSTR( "Mgr." ),
DEF_SPLSTR( "Mgrs." ),
DEF_SPLSTR( "Mlle." ),
DEF_SPLSTR( "Mlles." ),
DEF_SPLSTR( "Mme." ),
DEF_SPLSTR( "Mmes." ),
DEF_SPLSTR( "Mr." ),
DEF_SPLSTR( "Mrs." ),
DEF_SPLSTR( "Ms." ),
DEF_SPLSTR( "Msgr." ),
DEF_SPLSTR( "PFC." ),  // Private First Class // Sometimes used with a period
DEF_SPLSTR( "Pfc." ),
DEF_SPLSTR( "Pr." ),
DEF_SPLSTR( "Pres." ),
DEF_SPLSTR( "Prof." ),
DEF_SPLSTR( "R.A." ),
DEF_SPLSTR( "R.R." ),
DEF_SPLSTR( "R.W." ),
DEF_SPLSTR( "Rep." ),
DEF_SPLSTR( "Reps." ),
DEF_SPLSTR( "Rev." ),
DEF_SPLSTR( "S.M.Sgt." ),
DEF_SPLSTR( "S.Sgt." ),
DEF_SPLSTR( "Sen." ),
DEF_SPLSTR( "Sens." ),
DEF_SPLSTR( "Sgt." ),
DEF_SPLSTR( "Sgt.Maj." ),
DEF_SPLSTR( "Smt." ),     // Mr. or Ms. (?) in India
DEF_SPLSTR( "Sow." ),     // Mrs. or Ms. (?) in India
DEF_SPLSTR( "Sr." ),
DEF_SPLSTR( "Sra." ),
DEF_SPLSTR( "Srta." ),
DEF_SPLSTR( "St." ),
DEF_SPLSTR( "Supt." ),
DEF_SPLSTR( "T.Sgt." ),
DEF_SPLSTR( "V.A." ),
DEF_SPLSTR( "V.Adm." ),
DEF_SPLSTR( "Ven." ),
DEF_SPLSTR( "Vis." ),
DEF_SPLSTR( "Visct." ),
};

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\normdata.cpp ===
/******************************************************************************
* NormData.cpp *
*--------------*
*  This file stores the const data used in normalization
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 05/02/2000
*  All Rights Reserved
*
****************************************************************** AARONHAL ***/

#include "stdafx.h"
#include "stdsentenum.h"

//--- Constants used to map incoming ANSI characters to Ascii ones...
const char g_pFlagCharacter = 0x00;
const unsigned char g_AnsiToAscii[] = 
{
    /*** Control characters - map to whitespace ***/
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20,
    /*** ASCII displayables ***/
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,
    /*** Control character ***/
    0x20,
    /*** Euro symbol ***/
    0x80,
    /*** Control character ***/
    0x20,
    /*** Extended ASCII values ***/
    0x27,     // low single quote - map to single quote
    0x20,     // f-like character - map to space
    0x22,     // low double quote - map to double quote
    0x2C,     // elipsis - map to comma
    0x20,     // cross - map to space
    0x20,     // double cross - map to space
    0x5E,     // caret like accent - map to caret
    0x89,     // strange percent like sign
    0x53,     // S-hat - map to S
    0x27,     // left angle bracket like thing - map to single quote
    0x20,     // weird OE character - map to space
    0x20,     // control characters - map to space
    0x20,
    0x20,
    0x20,
    0x27,     // left single quote - map to single quote
    0x27,     // right single quote - map to single quote
    0x22,     // left double quote - map to double quote
    0x22,     // right double quote - map to double quote
    0x20,     // bullet - map to space
    0x2D,     // long hyphen - map to hyphen
    0x2D,     // even longer hyphen - map to hyphen
    0x7E,     // tilde-like thing - map to tilde
    0x99,     // TM
    0x73,     // s-hat - map to s
    0x27,     // right angle bracket like thing - map to single quote
    0x20,     // weird oe like character - map to space
    0x20,     // control character - map to space
    0x20,     // control character - map to space
    0x59,     // Y with umlaut like accent - map to Y
    0x20,     // space? - map to space
    0x20,     // upside-down exclamation point - map to space
    0xA2,     // cents symbol
    0xA3,     // pounds symbol
    0x20,     // generic currency symbol - map to space
    0xA5,     // yen symbol
    0x7C,     // broken bar - map to bar
    0x20,     // strange symbol - map to space 
    0x20,     // umlaut - map to space
    0xA9,     // copyright symbol
    0x20,     // strange a character - map to space
    0x22,     // strange <<-like character - map to double quote
    0x20,     // strange line-like character - map to space
    0x2D,     // hyphen-like character - map to hyphen
    0xAE,     // registered symbol
    0x20,     // high line - map to space
    0xB0,     // degree sign
    0xB1,     // plus-minus sign
    0xB2,     // superscript 2
    0xB3,     // superscript 3
    0xB4,     // single prime
    0x20,     // greek character - map to space
    0x20,     // paragraph symbol - map to space
    0x20,     // mid-height dot - map to space
    0x20,     // cedilla - map to space
    0xB9,     // superscript one
    0x20,     // circle with line - map to space
    0x22,     // strange >>-like character - map to double quote
    0xBC,     // vulgar 1/4
    0xBD,     // vulgar 1/2
    0xBE,     // vulgar 3/4
    0x20,     // upside-down question mark - map to space
    0x41,     // Accented uppercase As - map to A
    0x41,
    0x41,
    0x41,
    0x41,
    0x41,
    0x41,
    0x43,     // C with cedilla - map to C
    0x45,     // Accented uppercase Es - map to E
    0x45,
    0x45,
    0x45,
    0x49,     // Accented uppercase Is - map to I
    0x49,
    0x49,
    0x49,
    0x20,     // strange character - map to space
    0x4E,     // Accented uppercase N - map to N
    0x4F,     // Accented uppercase Os - map to O
    0x4F,
    0x4F,
    0x4F,
    0x4F,
    0x20,     // strange character - map to space
    0x4F,     // another O? - map to O
    0x55,     // Accented uppercase Us - map to U
    0x55,
    0x55,
    0x55,
    0x59,     // Accented uppercase Y - map to Y
    0x20,     // strange character - map to space
    0xDF,     // Beta
    0x61,     // Accented lowercase as - map to a
    0x61,
    0x61,
    0x61,
    0x61,
    0x61,
    0x61,
    0x63,     // c with cedilla - map to c
    0x65,     // Accented lowercase es - map to e
    0x65,
    0x65,
    0x65,
    0x69,    // Accented lowercase is - map to i
    0x69,
    0x69,
    0x69,
    0x75,    // eth - map to t
    0x6E,    // Accented lowercase n - map to n
    0x6F,    // Accented lowercase os - map to o
    0x6F,
    0x6F,
    0x6F,
    0x6F,
    0xF7,     // division symbol
    0x6F,     // another o? - map to o
    0x76,    // Accented lowercase us - map to u
    0x76,
    0x76,
    0x76,
    0x79,     // accented lowercase y - map to y
    0x20,     // strange character - map to space
    0x79,     // accented lowercase y - map to y
};

//--- Constants used by number normalization
const SPLSTR g_O            = DEF_SPLSTR( "o" );
const SPLSTR g_negative     = DEF_SPLSTR( "negative" );
const SPLSTR g_decimalpoint = DEF_SPLSTR( "point" );
const SPLSTR g_a            = DEF_SPLSTR( "a" );
const SPLSTR g_of           = DEF_SPLSTR( "of" );
const SPLSTR g_percent      = DEF_SPLSTR( "percent" );
const SPLSTR g_degree       = DEF_SPLSTR( "degree" );
const SPLSTR g_degrees      = DEF_SPLSTR( "degrees" );
const SPLSTR g_squared      = DEF_SPLSTR( "squared" );
const SPLSTR g_cubed        = DEF_SPLSTR( "cubed" );
const SPLSTR g_to           = DEF_SPLSTR( "to" );
const SPLSTR g_dash         = DEF_SPLSTR( "dash" );

const SPLSTR g_ones[] = 
{   
    DEF_SPLSTR( "zero"  ), 
    DEF_SPLSTR( "one"   ),
    DEF_SPLSTR( "two"   ), 
    DEF_SPLSTR( "three" ), 
    DEF_SPLSTR( "four"  ), 
    DEF_SPLSTR( "five"  ), 
    DEF_SPLSTR( "six"   ), 
    DEF_SPLSTR( "seven" ), 
    DEF_SPLSTR( "eight" ), 
    DEF_SPLSTR( "nine"  )
};

const SPLSTR g_tens[]  = 
{
    DEF_SPLSTR( "zero"    ),
    DEF_SPLSTR( "ten"     ), 
    DEF_SPLSTR( "twenty"  ), 
    DEF_SPLSTR( "thirty"  ), 
    DEF_SPLSTR( "forty"   ), 
    DEF_SPLSTR( "fifty"   ), 
    DEF_SPLSTR( "sixty"   ), 
    DEF_SPLSTR( "seventy" ), 
    DEF_SPLSTR( "eighty"  ), 
    DEF_SPLSTR( "ninety"  )
};

const SPLSTR g_teens[]  = 
{
    DEF_SPLSTR( "ten"       ), 
    DEF_SPLSTR( "eleven"    ), 
    DEF_SPLSTR( "twelve"    ), 
    DEF_SPLSTR( "thirteen"  ), 
    DEF_SPLSTR( "fourteen"  ), 
    DEF_SPLSTR( "fifteen"   ), 
    DEF_SPLSTR( "sixteen"   ), 
    DEF_SPLSTR( "seventeen" ), 
    DEF_SPLSTR( "eighteen"  ), 
    DEF_SPLSTR( "nineteen"  )
};

const SPLSTR g_onesOrdinal[]  = 
{
    DEF_SPLSTR( "zeroth"  ), 
    DEF_SPLSTR( "first"   ), 
    DEF_SPLSTR( "second"  ), 
    DEF_SPLSTR( "third"   ), 
    DEF_SPLSTR( "fourth"  ), 
    DEF_SPLSTR( "fifth"   ), 
    DEF_SPLSTR( "sixth"   ), 
    DEF_SPLSTR( "seventh" ), 
    DEF_SPLSTR( "eighth"  ), 
    DEF_SPLSTR( "ninth"   )
}; 

const SPLSTR g_tensOrdinal[]  = 
{
    DEF_SPLSTR( ""           ), 
    DEF_SPLSTR( "tenth"      ), 
    DEF_SPLSTR( "twentieth"  ), 
    DEF_SPLSTR( "thirtieth"  ), 
    DEF_SPLSTR( "fortieth"   ), 
    DEF_SPLSTR( "fiftieth"   ), 
    DEF_SPLSTR( "sixtieth"   ), 
    DEF_SPLSTR( "seventieth" ), 
    DEF_SPLSTR( "eightieth"  ), 
    DEF_SPLSTR( "ninetieth"  )
}; 

const SPLSTR g_teensOrdinal[]  =
{
    DEF_SPLSTR( "tenth"       ), 
    DEF_SPLSTR( "eleventh"    ), 
    DEF_SPLSTR( "twelfth"     ), 
    DEF_SPLSTR( "thirteenth"  ), 
    DEF_SPLSTR( "fourteenth"  ), 
    DEF_SPLSTR( "fifteenth"   ), 
    DEF_SPLSTR( "sixteenth"   ), 
    DEF_SPLSTR( "seventeenth" ),
    DEF_SPLSTR( "eighteenth"  ), 
    DEF_SPLSTR( "nineteenth"  )
};

const SPLSTR g_quantifiers[]  =
{
    DEF_SPLSTR( "hundred"  ), 
    DEF_SPLSTR( "thousand" ), 
    DEF_SPLSTR( "million"  ), 
    DEF_SPLSTR( "billion"  ), 
    DEF_SPLSTR( "trillion" ),
    DEF_SPLSTR( "quadrillion" )
};

const SPLSTR g_quantifiersOrdinal[]  =
{
    DEF_SPLSTR( "hundredth"  ), 
    DEF_SPLSTR( "thousandth" ), 
    DEF_SPLSTR( "millionth"  ), 
    DEF_SPLSTR( "billionth"  ), 
    DEF_SPLSTR( "trillionth" ),
    DEF_SPLSTR( "quadrillionth" )
};

//--- Constants used by currency normalization

WCHAR g_Euro[2] = { 0x0080, 0x0000 };

const CurrencySign g_CurrencySigns[] =
{
    { DEF_SPLSTR( "$" ),        DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "pounds" ),         DEF_SPLSTR( "pence" )       },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "yen" ),            DEF_SPLSTR( "sen" )         },
    { DEF_SPLSTR( "EUR" ),      DEF_SPLSTR( "euros" ),          DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "US$" ),      DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { { &g_Euro[0], 1 },        DEF_SPLSTR( "euros" ),          DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "euros" ),          DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "DM" ),       DEF_SPLSTR( "deutschemarks" ),  DEF_SPLSTR( "pfennigs" )    },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "cents" ),          DEF_SPLSTR( "" )            },
    { DEF_SPLSTR( "USD" ),      DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "dol." ),     DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "schil." ),   DEF_SPLSTR( "schillings" ),     DEF_SPLSTR( "" )            },
    { DEF_SPLSTR( "dol" ),      DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "schil" ),    DEF_SPLSTR( "schillings" ),     DEF_SPLSTR( "" )            }
};

const SPLSTR g_SingularPrimaryCurrencySigns[] =
{   
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "pound" ),
    DEF_SPLSTR( "yen" ),
    DEF_SPLSTR( "euro" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "euro" ),
    DEF_SPLSTR( "euro" ),
    DEF_SPLSTR( "deutschemark" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "schilling" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "schilling" )
};

const SPLSTR g_SingularSecondaryCurrencySigns[] =
{
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "penny" ),
    DEF_SPLSTR( "sen" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "pfennig" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "" ),
};

//--- Constants used by date normalization

const WCHAR g_DateDelimiters[] = { '/', '-', '.' };

const SPLSTR g_months[]  =
{
    DEF_SPLSTR( "January"   ), 
    DEF_SPLSTR( "February"  ), 
    DEF_SPLSTR( "March"     ), 
    DEF_SPLSTR( "April"     ), 
    DEF_SPLSTR( "May"       ),
    DEF_SPLSTR( "June"      ),
    DEF_SPLSTR( "July"      ),
    DEF_SPLSTR( "August"    ),
    DEF_SPLSTR( "September" ),
    DEF_SPLSTR( "October"   ),
    DEF_SPLSTR( "November"  ),
    DEF_SPLSTR( "December"  )
};

const SPLSTR g_monthAbbreviations[] =
{
    DEF_SPLSTR( "jan" ),
    DEF_SPLSTR( "feb" ),
    DEF_SPLSTR( "mar" ),
    DEF_SPLSTR( "apr" ),
    DEF_SPLSTR( "may" ),
    DEF_SPLSTR( "jun" ),
    DEF_SPLSTR( "jul" ),
    DEF_SPLSTR( "aug" ),
    DEF_SPLSTR( "sept" ),
    DEF_SPLSTR( "sep" ),
    DEF_SPLSTR( "oct" ),
    DEF_SPLSTR( "nov" ),
    DEF_SPLSTR( "dec" )
};

const SPLSTR g_days[]    =
{
    DEF_SPLSTR( "Monday"    ),
    DEF_SPLSTR( "Tuesday"   ),
    DEF_SPLSTR( "Wednesday" ),
    DEF_SPLSTR( "Thursday"  ),
    DEF_SPLSTR( "Friday"    ),
    DEF_SPLSTR( "Saturday"  ),
    DEF_SPLSTR( "Sunday"    )
};

const SPLSTR g_dayAbbreviations[] =
{
    DEF_SPLSTR( "Mon"   ),
    DEF_SPLSTR( "Tues"   ),
    DEF_SPLSTR( "Tue"  ),
    DEF_SPLSTR( "Wed"   ),
    DEF_SPLSTR( "Thurs"  ),
    DEF_SPLSTR( "Thur" ),
    DEF_SPLSTR( "Thu" ),
    DEF_SPLSTR( "Fri"   ),
    DEF_SPLSTR( "Sat"   ),
    DEF_SPLSTR( "Sun"   ),
};

//--- Constants used by phone number normalization

const SPLSTR g_Area     = DEF_SPLSTR( "area" );
const SPLSTR g_Country  = DEF_SPLSTR( "country" );
const SPLSTR g_Code     = DEF_SPLSTR( "code" );

//--- Constants used by fraction normalization

const SPLSTR g_Half         = DEF_SPLSTR( "half" );
const SPLSTR g_Tenths       = DEF_SPLSTR( "tenths" );
const SPLSTR g_Hundredths   = DEF_SPLSTR( "hundredths" );
const SPLSTR g_Sixteenths   = DEF_SPLSTR( "sixteenths" );
const SPLSTR g_Over         = DEF_SPLSTR( "over" );

const SPLSTR g_PluralDenominators[]  = 
{
    DEF_SPLSTR( "" ), 
    DEF_SPLSTR( "" ), 
    DEF_SPLSTR( "halves"   ), 
    DEF_SPLSTR( "thirds"   ), 
    DEF_SPLSTR( "fourths"  ), 
    DEF_SPLSTR( "fifths"   ), 
    DEF_SPLSTR( "sixths"   ), 
    DEF_SPLSTR( "sevenths" ), 
    DEF_SPLSTR( "eighths"  ), 
    DEF_SPLSTR( "ninths"   )
}; 

//--- Constants used by time normalization

const SPLSTR g_A        = DEF_SPLSTR( "a" );
const SPLSTR g_M        = DEF_SPLSTR( "m" );
const SPLSTR g_P        = DEF_SPLSTR( "p" );
const SPLSTR g_OClock   = DEF_SPLSTR( "o'clock" );
const SPLSTR g_hundred  = DEF_SPLSTR( "hundred" );
const SPLSTR g_hours    = DEF_SPLSTR( "hours" );
const SPLSTR g_hour     = DEF_SPLSTR( "hour" );
const SPLSTR g_minutes  = DEF_SPLSTR( "minutes" );
const SPLSTR g_minute   = DEF_SPLSTR( "minute" );
const SPLSTR g_seconds  = DEF_SPLSTR( "seconds" );
const SPLSTR g_second   = DEF_SPLSTR( "second" );

//--- Default normalization table

const SPLSTR g_ANSICharacterProns[] =
{
    DEF_SPLSTR( "" ),   // NULL
    DEF_SPLSTR( "" ),   // Start of heading
    DEF_SPLSTR( "" ),   // Start of text
    DEF_SPLSTR( "" ),   // Break/End of text
    DEF_SPLSTR( "" ),   // End of transmission
    DEF_SPLSTR( "" ),   // Enquiry
    DEF_SPLSTR( "" ),   // Positive acknowledgement
    DEF_SPLSTR( "" ),   // Bell
    DEF_SPLSTR( "" ),   // Backspace
    DEF_SPLSTR( "" ),   // Horizontal tab
    DEF_SPLSTR( "" ),   // Line feed
    DEF_SPLSTR( "" ),   // Vertical tab
    DEF_SPLSTR( "" ),   // Form feed
    DEF_SPLSTR( "" ),   // Carriage return
    DEF_SPLSTR( "" ),   // Shift out
    DEF_SPLSTR( "" ),   // Shift in/XON (resume output)
    DEF_SPLSTR( "" ),   // Data link escape
    DEF_SPLSTR( "" ),   // Device control character 1
    DEF_SPLSTR( "" ),   // Device control character 2
    DEF_SPLSTR( "" ),   // Device control character 3
    DEF_SPLSTR( "" ),   // Device control character 4
    DEF_SPLSTR( "" ),   // Negative acknowledgement
    DEF_SPLSTR( "" ),   // Synchronous idle
    DEF_SPLSTR( "" ),   // End of transmission block
    DEF_SPLSTR( "" ),   // Cancel
    DEF_SPLSTR( "" ),   // End of medium
    DEF_SPLSTR( "" ),   // substitute/end of file
    DEF_SPLSTR( "" ),   // Escape
    DEF_SPLSTR( "" ),   // File separator
    DEF_SPLSTR( "" ),   // Group separator
    DEF_SPLSTR( "" ),   // Record separator
    DEF_SPLSTR( "" ),   // Unit separator
    DEF_SPLSTR( "" ),   // Space
    DEF_SPLSTR( "exclamation point" ),   
    DEF_SPLSTR( "double quote" ),
    DEF_SPLSTR( "number sign" ),
    DEF_SPLSTR( "dollars" ),
    DEF_SPLSTR( "percent" ),
    DEF_SPLSTR( "and" ),
    DEF_SPLSTR( "single quote" ),
    DEF_SPLSTR( "left parenthesis" ),
    DEF_SPLSTR( "right parenthesis" ),
    DEF_SPLSTR( "asterisk" ),
    DEF_SPLSTR( "plus" ),
    DEF_SPLSTR( "comma" ),
    DEF_SPLSTR( "hyphen" ),             
    DEF_SPLSTR( "dot" ),          
    DEF_SPLSTR( "slash" ),              
    DEF_SPLSTR( "zero" ),
    DEF_SPLSTR( "one" ),
    DEF_SPLSTR( "two" ),
    DEF_SPLSTR( "three" ),
    DEF_SPLSTR( "four" ),
    DEF_SPLSTR( "five" ),
    DEF_SPLSTR( "six" ),
    DEF_SPLSTR( "seven" ),
    DEF_SPLSTR( "eight" ),
    DEF_SPLSTR( "nine" ),
    DEF_SPLSTR( "colon" ),
    DEF_SPLSTR( "semicolon" ),
    DEF_SPLSTR( "less than" ),
    DEF_SPLSTR( "equals" ),
    DEF_SPLSTR( "greater than" ),
    DEF_SPLSTR( "question mark" ),
    DEF_SPLSTR( "at" ),
    DEF_SPLSTR( "a" ),
    DEF_SPLSTR( "b" ),
    DEF_SPLSTR( "c" ),
    DEF_SPLSTR( "d" ),
    DEF_SPLSTR( "e" ),
    DEF_SPLSTR( "f" ),
    DEF_SPLSTR( "g" ),
    DEF_SPLSTR( "h" ),
    DEF_SPLSTR( "i" ),
    DEF_SPLSTR( "j" ),
    DEF_SPLSTR( "k" ),
    DEF_SPLSTR( "l" ),
    DEF_SPLSTR( "m" ),
    DEF_SPLSTR( "n" ),
    DEF_SPLSTR( "o" ),
    DEF_SPLSTR( "p" ),
    DEF_SPLSTR( "q" ),
    DEF_SPLSTR( "r" ),
    DEF_SPLSTR( "s" ),
    DEF_SPLSTR( "t" ),
    DEF_SPLSTR( "u" ),
    DEF_SPLSTR( "v" ),
    DEF_SPLSTR( "w" ),
    DEF_SPLSTR( "x" ),
    DEF_SPLSTR( "y" ),
    DEF_SPLSTR( "z" ),
    DEF_SPLSTR( "left square bracket" ),
    DEF_SPLSTR( "backslash" ),
    DEF_SPLSTR( "right square bracket" ),
    DEF_SPLSTR( "circumflex accent" ),
    DEF_SPLSTR( "underscore" ),
    DEF_SPLSTR( "grave accent" ),
    DEF_SPLSTR( "a" ),
    DEF_SPLSTR( "b" ),
    DEF_SPLSTR( "c" ),
    DEF_SPLSTR( "d" ),
    DEF_SPLSTR( "e" ),
    DEF_SPLSTR( "f" ),
    DEF_SPLSTR( "g" ),
    DEF_SPLSTR( "h" ),
    DEF_SPLSTR( "i" ),
    DEF_SPLSTR( "j" ),
    DEF_SPLSTR( "k" ),
    DEF_SPLSTR( "l" ),
    DEF_SPLSTR( "m" ),
    DEF_SPLSTR( "n" ),
    DEF_SPLSTR( "o" ),
    DEF_SPLSTR( "p" ),
    DEF_SPLSTR( "q" ),
    DEF_SPLSTR( "r" ),
    DEF_SPLSTR( "s" ),
    DEF_SPLSTR( "t" ),
    DEF_SPLSTR( "u" ),
    DEF_SPLSTR( "v" ),
    DEF_SPLSTR( "w" ),
    DEF_SPLSTR( "x" ),
    DEF_SPLSTR( "y" ),
    DEF_SPLSTR( "z" ),
    DEF_SPLSTR( "left curly bracket" ),
    DEF_SPLSTR( "vertical line" ),
    DEF_SPLSTR( "right curly bracket" ),
    DEF_SPLSTR( "tilde" ),
    DEF_SPLSTR( "" ),                       // DELETE
    DEF_SPLSTR( "euros" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to comma
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to caret
    DEF_SPLSTR( "per thousand" ),
    DEF_SPLSTR( "" ),                       // maps to S
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // Control characters - map to space
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to hyphen
    DEF_SPLSTR( "" ),                       // maps to hyphen
    DEF_SPLSTR( "" ),                       // maps to tilde
    DEF_SPLSTR( "trademark" ),
    DEF_SPLSTR( "" ),                       // maps to s
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to Y
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "cents" ),
    DEF_SPLSTR( "pounds" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "yen" ),
    DEF_SPLSTR( "" ),                       // maps to |
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "copyright" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to hyphen
    DEF_SPLSTR( "registered trademark" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "degrees" ),
    DEF_SPLSTR( "plus minus" ),
    DEF_SPLSTR( "superscript two" ),
    DEF_SPLSTR( "superscript three" ),
    DEF_SPLSTR( "prime" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "times" ),                  // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "superscript one" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "one fourth" ),
    DEF_SPLSTR( "one half" ),
    DEF_SPLSTR( "three fourths" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to C
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to N
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to Y
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "beta" ),
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to c
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to t
    DEF_SPLSTR( "" ),                       // maps to n
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "divided by" ),
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to y
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to y
};

//--- Constants used in decade normalization

const SPLSTR g_Decades[] =
{
    DEF_SPLSTR( "thousands" ),   // this will be handled as a special case - "two thousands"
    DEF_SPLSTR( "tens"      ),
    DEF_SPLSTR( "twenties"  ),
    DEF_SPLSTR( "thirties"  ),
    DEF_SPLSTR( "forties"   ),
    DEF_SPLSTR( "fifties"   ),
    DEF_SPLSTR( "sixties"   ),
    DEF_SPLSTR( "seventies" ),
    DEF_SPLSTR( "eighties"  ),
    DEF_SPLSTR( "nineties"  ),
};

const SPLSTR g_Zeroes = DEF_SPLSTR( "zeroes" );
const SPLSTR g_Hundreds = DEF_SPLSTR( "hundreds" );

//--- Miscellaneous constants

const StateStruct g_StateAbbreviations[] =
{
    { DEF_SPLSTR( "AA" ), DEF_SPLSTR( "Armed Forces" ) },
    { DEF_SPLSTR( "AE" ), DEF_SPLSTR( "Armed Forces" ) },
    { DEF_SPLSTR( "AK" ), DEF_SPLSTR( "Alaska" ) },
    { DEF_SPLSTR( "AL" ), DEF_SPLSTR( "Alabama" )  },
    { DEF_SPLSTR( "AP" ), DEF_SPLSTR( "Armed Forces" ) },
    { DEF_SPLSTR( "AR" ), DEF_SPLSTR( "Arkansas" ) },
    { DEF_SPLSTR( "AS" ), DEF_SPLSTR( "American Samoa" ) },
    { DEF_SPLSTR( "AZ" ), DEF_SPLSTR( "Arizona" )  },
    { DEF_SPLSTR( "CA" ), DEF_SPLSTR( "California" ) },
    { DEF_SPLSTR( "CO" ), DEF_SPLSTR( "Colorado" ) },
    { DEF_SPLSTR( "CT" ), DEF_SPLSTR( "Connecticut" ) },
    { DEF_SPLSTR( "DC" ), DEF_SPLSTR( "D C" ) },
    { DEF_SPLSTR( "DE" ), DEF_SPLSTR( "Deleware" ) },
    { DEF_SPLSTR( "FL" ), DEF_SPLSTR( "Florida" ) },
    { DEF_SPLSTR( "FM" ), DEF_SPLSTR( "Federated States Of Micronesia" ) },
    { DEF_SPLSTR( "GA" ), DEF_SPLSTR( "Georgia" ) },
    { DEF_SPLSTR( "GU" ), DEF_SPLSTR( "Guam" ) },
    { DEF_SPLSTR( "HI" ), DEF_SPLSTR( "Hawaii" ) },
    { DEF_SPLSTR( "IA" ), DEF_SPLSTR( "Iowa" ) },
    { DEF_SPLSTR( "ID" ), DEF_SPLSTR( "Idaho" ) },
    { DEF_SPLSTR( "IL" ), DEF_SPLSTR( "Illinois" ) },
    { DEF_SPLSTR( "IN" ), DEF_SPLSTR( "Indiana" ) },
    { DEF_SPLSTR( "KS" ), DEF_SPLSTR( "Kansas" ) },
    { DEF_SPLSTR( "KY" ), DEF_SPLSTR( "Kentucky" ) },
    { DEF_SPLSTR( "LA" ), DEF_SPLSTR( "Louisiana" ) },
    { DEF_SPLSTR( "MA" ), DEF_SPLSTR( "Massachusetts" ) },
    { DEF_SPLSTR( "MD" ), DEF_SPLSTR( "Maryland" ) },
    { DEF_SPLSTR( "ME" ), DEF_SPLSTR( "Maine" ) },
    { DEF_SPLSTR( "MH" ), DEF_SPLSTR( "Marshall Islands" ) },
    { DEF_SPLSTR( "MI" ), DEF_SPLSTR( "Michigan" ) },
    { DEF_SPLSTR( "MN" ), DEF_SPLSTR( "Minnesota" ) },
    { DEF_SPLSTR( "MO" ), DEF_SPLSTR( "Missouri" ) },
    { DEF_SPLSTR( "MP" ), DEF_SPLSTR( "Northern Mariana Islands" ) },
    { DEF_SPLSTR( "MS" ), DEF_SPLSTR( "Mississippi" ) },
    { DEF_SPLSTR( "MT" ), DEF_SPLSTR( "Montana" ) },
    { DEF_SPLSTR( "NC" ), DEF_SPLSTR( "North Carolina" ) },
    { DEF_SPLSTR( "ND" ), DEF_SPLSTR( "North Dakota" ) },
    { DEF_SPLSTR( "NE" ), DEF_SPLSTR( "Nebraska" ) },
    { DEF_SPLSTR( "NH" ), DEF_SPLSTR( "New Hampshire" ) },
    { DEF_SPLSTR( "NJ" ), DEF_SPLSTR( "New Jersey" ) },
    { DEF_SPLSTR( "NM" ), DEF_SPLSTR( "New Mexico" ) },
    { DEF_SPLSTR( "NV" ), DEF_SPLSTR( "Nevada" ) },
    { DEF_SPLSTR( "NY" ), DEF_SPLSTR( "New York" ) },
    { DEF_SPLSTR( "OH" ), DEF_SPLSTR( "Ohio" ) },
    { DEF_SPLSTR( "OK" ), DEF_SPLSTR( "Oklahoma" ) },
    { DEF_SPLSTR( "OR" ), DEF_SPLSTR( "Oregon" ) },
    { DEF_SPLSTR( "PA" ), DEF_SPLSTR( "Pennsylvania" ) },
    { DEF_SPLSTR( "PR" ), DEF_SPLSTR( "Puerto Rico" ) },
    { DEF_SPLSTR( "PW" ), DEF_SPLSTR( "Palau" ) },
    { DEF_SPLSTR( "RI" ), DEF_SPLSTR( "Rhode Island" ) },
    { DEF_SPLSTR( "SC" ), DEF_SPLSTR( "South Carolina" ) },
    { DEF_SPLSTR( "SD" ), DEF_SPLSTR( "South Dakota" ) },
    { DEF_SPLSTR( "TN" ), DEF_SPLSTR( "Tennessee" ) },
    { DEF_SPLSTR( "TX" ), DEF_SPLSTR( "Texas" ) },
    { DEF_SPLSTR( "UT" ), DEF_SPLSTR( "Utah" ) },
    { DEF_SPLSTR( "VA" ), DEF_SPLSTR( "Virginia" ) },
    { DEF_SPLSTR( "VI" ), DEF_SPLSTR( "Virgin Islands" ) },
    { DEF_SPLSTR( "VT" ), DEF_SPLSTR( "Vermont" ) },
    { DEF_SPLSTR( "WA" ), DEF_SPLSTR( "Washington" ) },
    { DEF_SPLSTR( "WI" ), DEF_SPLSTR( "Wisconsin" ) },
    { DEF_SPLSTR( "WV" ), DEF_SPLSTR( "West Virginia" ) },
    { DEF_SPLSTR( "WY" ), DEF_SPLSTR( "Wyoming" ) },
};

const SPVSTATE g_DefaultXMLState = 
{
    SPVA_Speak,     // SPVACTIONS
    0,              // LangID
    0,              // wReserved
    0,              // EmphAdj
    0,              // RateAdj
    100,            // Volume
    { 0, 0 },       // PitchAdj
    0,              // SilenceMSecs
    0,              // pPhoneIds
    SPPS_Unknown,   // POS
    { 0, 0, 0 }     // Context
};

const SPLSTR g_And = DEF_SPLSTR( "and" );

extern const SPLSTR g_comma = DEF_SPLSTR( "," );
extern const SPLSTR g_period = DEF_SPLSTR( "." );
extern const SPLSTR g_periodString = DEF_SPLSTR( "period" );
extern const SPLSTR g_slash = DEF_SPLSTR( "or" );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\miscdata.cpp ===
/******************************************************************************
* MiscData.cpp *
*--------------*
*  This file stores the const data used in various non-normalization front-end
*  code
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 05/02/2000
*  All Rights Reserved
*
****************************************************************** AARONHAL ***/

#include "stdafx.h"
#include"stdsentenum.h"

//--- Variable used to make sure initialization of pronunciations only happens once!
BOOL g_fAbbrevTablesInitialized = false;

//--- Helper function used to delete dynamically allocated memory (for the abbreviation
//    table) at DLL exit time...
void CleanupAbbrevTables( void ) 
{
    if ( g_fAbbrevTablesInitialized )
    {
        for ( ULONG i = 0; i < sp_countof( g_AbbreviationTable ); i++ )
        {
            if ( g_AbbreviationTable[i].pPron1 )
            {
                delete [] g_AbbreviationTable[i].pPron1;
            }
            if ( g_AbbreviationTable[i].pPron2 )
            {
                delete [] g_AbbreviationTable[i].pPron2;
            }
            if ( g_AbbreviationTable[i].pPron3 )
            {
                delete [] g_AbbreviationTable[i].pPron3;
            }
        }
        for ( i = 0; i < sp_countof( g_AmbiguousWordTable ); i++ )
        {
            if ( g_AmbiguousWordTable[i].pPron1 )
            {
                delete [] g_AmbiguousWordTable[i].pPron1;
            }
            if ( g_AmbiguousWordTable[i].pPron2 )
            {
                delete [] g_AmbiguousWordTable[i].pPron2;
            }
            if ( g_AmbiguousWordTable[i].pPron3 )
            {
                delete [] g_AmbiguousWordTable[i].pPron3;
            }
        }
        for ( i = 0; i < sp_countof( g_PostLexLookupWordTable ); i++ )
        {
            if ( g_PostLexLookupWordTable[i].pPron1 )
            {
                delete [] g_PostLexLookupWordTable[i].pPron1;
            }
            if ( g_PostLexLookupWordTable[i].pPron2 )
            {
                delete [] g_PostLexLookupWordTable[i].pPron2;
            }
            if ( g_PostLexLookupWordTable[i].pPron3 )
            {
                delete [] g_PostLexLookupWordTable[i].pPron3;
            }
        }
        if ( g_pOfA )
        {
            delete [] g_pOfA;
        }
        if ( g_pOfAn )
        {
            delete [] g_pOfAn;
        }
    }
}

const BrillPatch g_POSTaggerPatches [] =
{
    { MS_Adj, MS_Noun, CAP, MS_Unknown, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1T, MS_Adj, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, CAP, MS_Unknown, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Conj, MS_Adv, NEXT2T, MS_Conj, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, NEXT1T, MS_Verb, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1TNEXT1T, MS_Noun, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV2T, MS_Prep, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_SubjPron, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Pron, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Adv, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, NEXT1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1TNEXT1T, MS_Verb, MS_Adj, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1TNEXT1T, MS_Noun, MS_Verb, NULL, NULL },
    { MS_Noun, MS_Adj, NEXT1T, MS_Adj, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, NEXT1T, MS_CConj, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Adv, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Adj, NULL, NULL },
    { MS_Adv, MS_Prep, PREV1TNEXT1T, MS_Noun, MS_Prep, NULL, NULL },
    { MS_Adv, MS_Prep, PREV1TNEXT2T, MS_Verb, MS_Noun, NULL, NULL },
    { MS_Adj, MS_Adv, NEXT1T, MS_Adv, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, NEXT1T, MS_ObjPron, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Adj, PREV1TNEXT1T, MS_Prep, MS_Noun, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Interr, MS_Prep, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1TNEXT1T, MS_Adv, MS_Adj, NULL, NULL },
    { MS_Prep, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Conj, NEXT1T, MS_SubjPron, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Adj, MS_Prep, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT2T, MS_Interr, MS_Noun, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1TNEXT1T, MS_Unknown, MS_Verb, NULL, NULL },
    { MS_Adj, MS_Verb, PREV1TNEXT1T, MS_Verb, MS_Adj, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1TNEXT1T, MS_Unknown, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Prep, PREV1TNEXT2T, MS_Prep, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, PREV2TNEXT1T, MS_Verb, MS_Adj, NULL, NULL },
    { MS_Adv, MS_Prep, NEXT1T, MS_Noun, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1TNEXT1T, MS_Conj, MS_Verb, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Prep, MS_Prep, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Pron, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Noun, MS_Verb, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Noun, NEXT1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, NEXT1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Unknown, MS_Prep, NULL, NULL },
    { MS_Verb, MS_Noun, PREV2TNEXT1T, MS_Unknown, MS_Verb, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_SubjPron, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Adv, NULL, NULL },
    { MS_Adv, MS_Adj, PREV1TNEXT1T, MS_Conj, MS_Noun, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1TNEXT1T, MS_Prep, MS_Adj, NULL, NULL },
    { MS_Adv, MS_Prep, NEXT1T, MS_Verb, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Adj, NEXT1T, MS_Adj, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Conj, NEXT1T, MS_Pron, MS_Unknown, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Adv, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV2TNEXT1T, MS_CConj, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Pron, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Adj, PREV2TNEXT1T, MS_Prep, MS_Noun, NULL, NULL },
    { MS_Noun, MS_Adj, PREV1TNEXT1T, MS_Adv, MS_Noun, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1TNEXT1T, MS_Adv, MS_Adj, NULL, NULL },
    //--- Inserted by hand - convert "A" from Det to Noun after Det...
    { MS_Det, MS_Noun, CURRWPREV1T, MS_Det, MS_Unknown, L"a", NULL },
    { MS_Verb, MS_Adj, PREV1TNEXT1T, MS_Det, MS_Noun, NULL, NULL },
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
AbbrevRecord g_AbbreviationTable[] =
{
    { L"a",     L"EY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"amp",   L"AE 1 M P", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"app",   L"AE 1 P", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"apr",   L"EY 1 - P R AX L", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"apt",   L"ax - p aa 1 r t - m ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"assoc", L"ax - s ow 2 - s iy - ey 1 - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"asst",  L"ax - s ih 1 s - t ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"aug",   L"ao 1 - g ax s t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ave",   L"ae 1 v - ax - n uw 2", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"b",     L"B IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"bldg",  L"b ih 1 l - d ih ng", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"blvd",  L"b uh 1 l - ax - v aa 2 r d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"bu",    L"b uh 1 sh - ax l", MS_Noun, L"b uh 1 sh - ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Initial - never EOS
    { L"c",     L"s eh 1 l - s iy - ax s", MS_Noun, L"s iy 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"cal",   L"k ae 1 l - ax - r iy", MS_Noun, L"k ae 1 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    { L"cals",  L"k ae 1 l - ax - r iy Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ch",    L"ch ae 1 p - t er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"cl",    L"s eh 1 n - t ax - l iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"cm",    L"s eh 1 n - t ax - m iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"cms",   L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"cntr",  L"s eh 1 n - t er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"co",    L"k ah 1 m - p ax - n iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"cont",  L"k ax n - t ih 1 n - y uw D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"corp",  L"k ao 2 r - p ax - r ey 1 - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"ct",    L"k ao 1 r t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"ctr",   L"s eh 1 n - t er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
	//--- IfEOSNotAbbreviation
    { L"cu",    L"k y uw 1 - b ih k", MS_Noun, L"k y uw 1 - b ih k", MS_Noun, NULL, MS_Unknown, 1, 4 },
    //--- Initial - never EOS
    { L"d",     L"D IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"db",    L"d eh 1 s - ax - b ax l", MS_Noun, L"d eh 1 s - ax - b ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"dec",   L"d ih - s eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"deg",   L"d ih - g r iy 1", MS_Noun, L"d ih - g r iy 1 z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"dept",  L"d ih - p aa 1 r t - m ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"dist",  L"d ih 1 s - t r ax k t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"doc",   L"D AA 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"doz",   L"d ah 1 z - ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- DoctorDriveAbbreviation
    { L"dr",    L"d aa 1 k - t er", MS_Noun, L"D R AY 1 V", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- Initial - never EOS
    { L"e",     L"IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"ed",    L"eh 2 jh - ax - k ey 1 - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"esq",   L"eh 1 s - k w ay 2 r", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"est",   L"ax - s t ae 1 b - l ax sh T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"etc",   L"EH T & s eh 1 t - er - ax", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"ex",    L"ih g - z ae 1 m - p ax l", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"ext",   L"ih k - s t eh 1 n - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"f",     L"f ae 1 r - ax n - h ay 2 t", MS_Noun, L"eh 1 f", MS_Noun, NULL, MS_Unknown, 0, 3 },
    { L"feb",   L"f eh 1 b - r uw - eh 2 r - iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"fig",   L"f ih 1 g - y er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- IfEOSNotAbbreviation
    { L"figs",  L"f ih 1 g - y er Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- IfEOSNotAbbreviation
    { L"fl",    L"f l uw 1 - ih d", MS_Noun, L"f l uw 1 - ih d", MS_Noun, NULL, MS_Unknown, 1, 4 },
    { L"fn",    L"f uh 1 t - n ow 2 t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"freq",  L"f r iy 1 - k w ax n - s iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"fri",   L"f r ay 1 - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"ft",    L"F UH 1 T", MS_Noun, L"F IY 1 T", MS_Noun, L"F AO 1 R T", MS_Noun, 0, 0 },
    { L"fwd",   L"f ao 1 r - w er d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"g",     L"G R AE 1 M", MS_Noun, L"G R AE 1 M Z", MS_Noun, L"JH IY 1", MS_Noun, 1, 0 },
    //--- SingleOrPluralAbbreviation
    { L"gal",   L"g ae 1 l - ax n", MS_Noun, L"g ae 1 l - ax n Z", MS_Noun, L"G AE 1 L", MS_Noun, 0, 0 },
    //--- TITLE - never EOS
    { L"gen",   L"jh eh 1 n - er - ax l", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"gov",   L"g ah 1 v - er - n ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- Initial - never EOS
    { L"h",     L"EY 1 CH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"hr",    L"AW 1 ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"hrs",   L"AW 1 ER Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ht",    L"H AY 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"hwy",   L"h ay 1 w ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"hz",    L"H ER 1 T S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"i",     L"AY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"in",    L"IH 1 N CH", MS_Noun, L"IH 1 N CH AX Z", MS_Noun, L"IH 1 N", MS_Prep, 1, 0 },
    { L"inc",   L"ih n - k ao 1 r - p ax - r ey 2 - t AX D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"incl",  L"ih n - k l uw 1 - d AX D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"intl",  L"ih 2 n - t er - n ae 1 sh - ax - n ax l", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSAndLowercaseNotAbbreviation
    { L"is",    L"ay 1 - l ax n d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 2, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"j",     L"JH UW 1 L", MS_Noun, L"JH UW 1 L Z", MS_Noun, L"JH EY 1", MS_Noun, 1, 0 },
    //--- IfEOSNotAbbreviation
    { L"jan",   L"jh ae 1 n - y uw - eh 2 r - iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"jr",    L"jh uw 1 n - y er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"jul",   L"jh uh - l ay 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"jun",   L"JH UW 1 N", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"k",     L"k eh 1 l - v ax n", MS_Noun, L"k ey 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"kb",    L"k ih 1 l - ax - b ay 2 t", MS_Noun, L"k ih 1 l - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kcal",  L"k ih 1 l - ax - k ae 2 l - ax - r iy", MS_Noun, L"k ih 1 l - ax - k ae 2 l - ax - r iy Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kg",    L"k ih 1 l - ax - g r ae 2 m", MS_Noun, L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"kgs",   L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"khz",   L"k ih 1 l - ax - h er 2 t s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"kj",    L"k ih 1 l - ax - jh uw 2 l", MS_Noun, L"k ih 1 l - ax - jh uw 2 l z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"km",    L"k ih - l aa 1 m - ih - t er", MS_Noun, L"k ih - l aa 1 m - ih - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kw",    L"k ih 1 l - ax - w aa 2 t", MS_Noun, L"k ih 1 l - ax - w aa 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"l",     L"l iy 1 - t er", MS_Noun, L"l iy 1 - t er Z", MS_Noun, L"EH 1 L", MS_Noun, 1, 0 },
    //--- SingleOrPluralAbbreviation
    { L"lb",    L"P AW 1 N D", MS_Noun, L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"lbs",   L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"lg",    L"L AA 1 R JH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ln",    L"l ey 1 n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Title - never EOS
    { L"lt",    L"l uw - t eh 1 n - ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"ltd",   L"l ih 1 m - ih - t AX D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"m",     L"M IY 1 T ER", MS_Noun, L"M IY 1 T ER Z", MS_Noun, L"EH 1 M", MS_Noun, 1, 0 },
    //--- IfEOSNotAbbreviation???
    { L"mar",   L"M AA 1 R CH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"mb",    L"m eh 1 g - ax - b ay 2 t", MS_Noun, L"m eh 1 g - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mfg",   L"m ae 2 n - y ax - f ae 1 k - ch er - IH NG", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"mg",    L"m ih 1 l - ax - g r ae 2 m", MS_Noun, L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mgr",   L"m ae 1 n - ih - jh ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mgs",   L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mhz",   L"m eh 1 g - ax - h er 2 t s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"mi",    L"M AY 1 L", MS_Noun, L"M AY 1 L Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mic",   L"M AY 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"min",   L"m ih 1 n - ax t", MS_Noun, L"m ih 1 n - ax t S", MS_Noun, L"m ih 1 n - ax - m ax m", MS_Noun, 0, 0 },
    { L"misc",  L"m ih 2 s - ax - l ey 1 - n iy - ax s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"ml",    L"m ih 1 l - ax - l iy 2 - t er", MS_Noun, L"m ih 1 l - ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mm",    L"m ih 1 l - ax - m iy 2 - t er", MS_Noun, L"m ih 1 l - ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mon",   L"m ah 1 n - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- TITLE - never EOS
    { L"mr",    L"M IH 1 S - T ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- TITLE - never EOS
    { L"mrs",   L"M IH 1 S - AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"ms",    L"M IH 1 Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"msec",  L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"msecs", L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mt",    L"M AW 1 N T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mtn",   L"m aw 1 n - t ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"n",     L"EH 1 N", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"no",    L"N UH 1 M - B ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"nov",   L"n ow - v eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"o",     L"OW 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"oct",   L"aa k - t ow 1 - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"op",    L"OW 1 - P AX S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"oz",    L"AW 1 N S", MS_Noun, L"AW 1 N - S AX Z", MS_Noun, L"AA 1 Z", MS_Noun, 0, 0 },
    { L"ozs",   L"AW 1 N - S AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- AbbreviationFollowedByDigit
    { L"p",     L"P EY 1 JH", MS_Noun, L"P IY 1", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- IfEOSNotAbbreviation
    { L"pg",    L"P EY 1 JH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"pgs",   L"P EY 1 - JH AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pkg",   L"p ae 1 k - ih jh", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pkwy",  L"p aa 1 r k - w ey 2", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pl",    L"P L EY 1 S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pp",    L"P EY 1 - JH AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- TITLE - never EOS
    { L"pres",  L"p r eh 1 z - ax - d ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- TITLE - never EOS
    { L"prof",  L"p r ax - f eh 1 - s ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"pt",    L"P OY 1 N T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"q",     L"K Y UW 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"qt",    L"k w ao 1 r t", MS_Noun, L"k w ao 1 r t Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Initial - never EOS
    { L"r",     L"AA 1 R", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"rd",    L"r ow 1 d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rec",   L"R EH 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rep",   L"r eh 2 p - r ih - z eh 1 n - t ax - t ih v", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rt",    L"R UW 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rte",    L"R UW 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"s",     L"EH 1 S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSAndLowercaseNotAbbreviation
    { L"sat",   L"s ae 1 t - er - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 2, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"sec",   L"s eh 1 k - ax n d", MS_Noun, L"s eh 1 k - ax n d z", MS_Noun, NULL, MS_Unknown, 1, 0 },
    //--- TITLE - never EOS
    { L"sen",   L"s eh 1 n - ax - t ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"sep",   L"s eh p - t eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"sept",  L"s eh p - t eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"sm",    L"S M AO 1 L", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 }, 
    { L"sq",    L"S K W EH 1 R", MS_Noun, L"S K W EH 1 R", MS_Noun, NULL, MS_Unknown, 0, 4 },
    //--- IfEOSNotAbbreviation
    { L"sr",    L"s iy 1 n - y er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- DoctorDriveAbbreviation
    { L"st",    L"S EY 1 N T", MS_Noun, L"S T R IY 1 T", MS_Noun, NULL, MS_Unknown, 0, 1 },
    { L"ste",   L"s w iy 1 t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"sun",   L"s ah 1 n - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- Initial - never EOS
    { L"t",     L"T IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"tbsp",  L"t ey 1 - b ax l - s p uw 2 n", MS_Noun, L"t ey 1 - b ax l - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"tech",  L"T EH 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"thu",   L"th er 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"thur",  L"th er 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"thurs", L"th er 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"tsp",   L"t iy 1 - s p uw 2 n", MS_Noun, L"t iy 1 - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"tue",   L"t uw 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"tues",  L"t uw 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"u",     L"Y UW 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"univ",  L"y uw 2 - n ax - v er 1 - s ih - t iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"v",     L"V IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"ver",   L"v er 1 - zh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"vers",  L"v er 1 - zh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"vol",   L"v aa 1 l - y uw m", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"vs",    L"v er 1 - s ax s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"w",     L"d ah 1 b - ax l - y uw", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSAndLowercaseNotAbbreviation
    { L"wed",   L"w eh 1 n z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 2, -1 },
    { L"wk",    L"W IY 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"wt",    L"W EY 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"wy",    L"W EY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"x",     L"EH 1 K S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- Initial - never EOS
    { L"y",     L"W AY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"yd",    L"Y AA 1 R D", MS_Noun, L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"yds",   L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"yr",    L"Y IY 1 R", MS_Noun, L"Y IY 1 R Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Initial - never EOS
    { L"z",     L"Z IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
AbbrevRecord g_AmbiguousWordTable[] =
{
    //--- ADisambig
    { L"a",     L"EY 1", MS_Noun, L"AX", MS_Det, NULL, MS_Unknown, 0, 8 },
    //--- AllCapsAbbreviation
    { L"al",    L"EY 1 & EH 1 L", MS_Noun, L"AE 1 L", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"apr",   L"ey 1 & p iy 1 & aa 1 r", MS_Noun, L"ey 1 - p r ax l", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"as",    L"EY 1 & EH 1 S", MS_Noun, L"AE 1 Z", MS_Conj, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"bu",    L"b uh 1 sh - ax l", MS_Noun, L"b uh 1 sh - ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- DegreeAbbreviation
    { L"c",     L"s eh 1 l - s iy - ax s", MS_Noun, L"s iy 1", MS_Noun, NULL, MS_Unknown, 0, 6 },
    //--- SingleOrPluralAbbreviation
    { L"cal",   L"k ae 1 l - ax - r iy", MS_Noun, L"k ae 1 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"cl",    L"s eh 1 n - t ax - l iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"cm",    L"s eh 1 n - t ax - m iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"co",    L"S IY 1 & OW 1", MS_Noun, L"k ah 1 m - p ax - n iy", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"ct",    L"s iy 1 & t iy 1", MS_Noun, L"k ao 1 r t", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- MeasurementModifier
    { L"cu",    L"S IY 1 & Y UW 1", MS_Noun, L"k y uw 1 - b ih k", MS_Noun, NULL, MS_Unknown, 0, 7 },
    //--- SingleOrPluralAbbreviation
    { L"db",    L"d eh 1 s - ax - b ax l", MS_Noun, L"d eh 1 s - ax - b ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"deg",   L"d ih - g r iy 1", MS_Noun, L"d ih - g r iy 1 z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- DoctorDriveAbbreviation
    { L"dr",    L"d aa 1 k - t er", MS_Noun, L"D R AY 1 V", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- DegreeAbbreviation
    { L"f",     L"f ae 1 r - ax n - h ay 2 t", MS_Noun, L"eh 1 f", MS_Noun, NULL, MS_Unknown, 0, 6 },
    //--- AbbreviationFollowedByDigit
    { L"fig",   L"f ih 1 g - y er", MS_Noun, L"F IH 1 G", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- AbbreviationFollowedByDigit
    { L"figs",  L"f ih 1 g - y er Z", MS_Noun, L"F IH 1 G Z", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementModifier
    { L"fl",    L"eh 1 f & eh 1 l", MS_Noun, L"f l uw 1 - ih d", MS_Noun, NULL, MS_Unknown, 0, 7 },
    //--- SingleOrPluralAbbreviation
    { L"ft",    L"F UH 1 T", MS_Noun, L"F IY 1 T", MS_Noun, L"F AO 1 R T", MS_Noun, 0, 0 },
    //--- G, Gram, Grams
    { L"g",     L"G R AE 1 M", MS_Noun, L"G R AE 1 M Z", MS_Noun, L"JH IY 1", MS_Noun, 0, 5 },
    //--- DoctorDriveAbbreviation
    { L"gov",   L"g ah 1 v - er - n ER", MS_Noun, L"G AH 1 V", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- AllCapsAbbreviation
    { L"hi",    L"EY 1 CH & AY 1", MS_Noun, L"H AY 1", MS_Interjection, NULL, MS_Unknown, 0, 3 },
    //--- HR hour hours
    { L"hr",    L"AW 1 ER", MS_Noun, L"AW 1 ER Z", MS_Noun, L"EY 1 CH AA 1 R", MS_Noun, 0, 5 },
    //--- J, Joule, Joules
    { L"j",     L"JH UW 1 L", MS_Noun, L"JH UW 1 L Z", MS_Noun, L"JH EY 1", MS_Noun, 0, 5 },
    //--- DegreeAbbreviation
    { L"k",     L"k eh 1 l - v ax n", MS_Noun, L"k ey 1", MS_Noun, NULL, MS_Unknown, 0, 6 },
    //--- SingleOrPluralAbbreviation
    { L"kb",    L"k ih 1 l - ax - b ay 2 t", MS_Noun, L"k ih 1 l - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kcal",  L"k ih 1 l - ax - k ae 2 l - ax - r iy", MS_Noun, L"k ih 1 l - ax - k ae 2 l - ax - r iy Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kg",    L"k ih 1 l - ax - g r ae 2 m", MS_Noun, L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kj",    L"k ih 1 l - ax - jh uw 2 l", MS_Noun, L"k ih 1 l - ax - jh uw 2 l z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"km",    L"k ih - l aa 1 m - ih - t er", MS_Noun, L"k ih - l aa 1 m - ih - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kw",    L"k ih 1 l - ax - w aa 2 t", MS_Noun, L"k ih 1 l - ax - w aa 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- L, Liter, Liters
    { L"l",     L"l iy 1 - t er", MS_Noun, L"l iy 1 - t er Z", MS_Noun, L"EH 1 L", MS_Noun, 0, 5 },
    //--- AllCapsAbbreviation
    { L"la",    L"EH 1 L & EY 1", MS_Noun, L"L AH 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"lb",    L"P AW 1 N D", MS_Noun, L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"lts",   L"eh 1 l & t iy 1 & eh 1 s", MS_Noun, L"l uw t eh 1 n ax n t s", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- M, Meter, Meters
    { L"m",     L"M IY 1 - T ER", MS_Noun, L"M IY 1 - T ER Z", MS_Noun, L"EH 1 M", MS_Noun, 0, 5 },
    //--- AllCapsAbbreviation
    { L"ma",    L"EH 1 M & AA 1", MS_Noun, L"M AA 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- March Mar
    { L"mar",   L"M AA 1 R CH", MS_Noun, L"M AA 1 R", MS_Verb, NULL, MS_Unknown, 0, 4 },
    //--- SingleOrPluralAbbreviation
    { L"mb",    L"m eh 1 g - ax - b ay 2 t", MS_Noun, L"m eh 1 g - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"me",    L"EH 1 M & IY 1", MS_Noun, L"M IY 1", MS_ObjPron, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"mg",    L"m ih 1 l - ax - g r ae 2 m", MS_Noun, L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mi",    L"M AY 1 L", MS_Noun, L"M AY 1 L Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"min",   L"m ih 1 n - ax t", MS_Noun, L"m ih 1 n - ax t S", MS_Noun, L"m ih 1 n - ax - m ax m", MS_Noun, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"ml",    L"m ih 1 l - ax - l iy 2 - t er", MS_Noun, L"m ih 1 l - ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mm",    L"m ih 1 l - ax - m iy 2 - t er", MS_Noun, L"m ih 1 l - ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mpg", L"m ay 1 l & p er 1 & g ae 1 l ax n", MS_Noun, L"m ay 1 l z & p er 1 & g ae 1 l ax n", MS_Noun, L"eh 1 m & p iy 1 & jh iy 1", MS_Noun, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mph",   L"m ay 1 l & p er 1 & aw 1 er", MS_Noun, L"m ay 1 l z & p er 1 & aw 1 er", MS_Noun, L"eh 1 m & p iy 1 & ey 1 ch", MS_Noun, 0, 0 },
    //--- MS millisecond milliseconds
    { L"ms",    L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, L"eh 1 m & eh 1 s", MS_Noun, 0, 5 },
    //--- SingleOrPluralAbbreviation
    { L"msec",  L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"mt",    L"EH 1 M & T IY 1", MS_Noun, L"M AW 1 N T", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"oh",    L"OW 1 & EY 1 CH", MS_Noun, L"OW 1", MS_Interjection, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"or",    L"OW 1 & AA 1 R", MS_Noun, L"AO 1 R", MS_CConj, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"oz",    L"AW 1 N S", MS_Noun, L"AW 1 N S AX Z", MS_Noun, L"AA 1 Z", MS_Noun, 0, 0 },
    //--- AbbreviationFollowedByDigit
    { L"p",     L"P EY 1 JH", MS_Noun, L"P IY 1", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- AllCapsAbbreviation
    { L"pa",    L"P IY 1 & EY 1", MS_Noun, L"P AA 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"pg",    L"P IY 1 & JH IY 1", MS_Noun, L"P EY 1 JH", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"po",    L"p iy 1 & ow 1", MS_Noun, L"p ow 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- PolishDisambig
    { L"polish", L"p ow 1 l - ax sh", MS_Adj, L"p aa 1 l - ih sh", MS_Verb, L"p aa 1 l - ih sh", MS_Noun, 0, 9 },
    //--- SingleOrPluralAbbreviation
    { L"qt",    L"K W AO 1 R T", MS_Noun, L"K W AO 1 R T Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Saturday Sat
    { L"sat",   L"s ae 1 t - er - d ey", MS_Noun, L"S AE 1 T", MS_Verb, NULL, MS_Unknown, 0, 4 },
    //--- SEC Second Seconds
    { L"sec",   L"s eh 1 k - ax n d", MS_Noun, L"s eh 1 k - ax n d Z", MS_Noun, L"EH 1 S & IY 1 & S IY 1", MS_Noun, 0, 5 },
    //--- MeasurementModifier
    { L"sq",    L"S K W EH 1 R", MS_Noun, L"S K W EH 1 R", MS_Noun, NULL, MS_Unknown, 0, 7 },
	//--- AllCapsAbbreviation
    { L"sr",    L"EH 1 S & AA 1 R", MS_Noun, L"s iy 1 n - y er", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- DoctorDriveAbbreviation
    { L"st",    L"S EY 1 N T", MS_Noun, L"S T R IY 1 T", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- SingleOrPluralAbbreviation
    { L"tbsp",  L"t ey 1 - b ax l - s p uw 2 n", MS_Noun, L"t ey 1 - b ax l - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"tsp",   L"t iy 1 - s p uw 2 n", MS_Noun, L"t iy 1 - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"us",    L"Y UW 1 & EH 1 S", MS_Noun, L"AH 1 S", MS_ObjPron, NULL, MS_Unknown, 0, 3 },
    //--- Wednesday Wed
    { L"wed",   L"w eh 1 n z - d ey", MS_Noun, L"W EH 1 D", MS_Verb, NULL, MS_Unknown, 0, 4 },
    //--- AllCapsAbbreviation
    { L"wy",    L"d ah 1 b - ax l - y uw & W AY 1", MS_Noun, L"W EY 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"yd",    L"Y AA 1 R D", MS_Noun, L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"yr",    L"Y IY 1 R", MS_Noun, L"Y IY 1 R Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
AbbrevRecord g_PostLexLookupWordTable[] =
{
    //--- MeasurementDisambig
    { L"bu",    L"b uh 1 sh - ax l", MS_Noun, L"b uh 1 sh - ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"cal",   L"k ae 1 l - ax - r iy", MS_Noun, L"k ae 1 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"cl",    L"s eh 1 n - t ax - l iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"cm",    L"s eh 1 n - t ax - m iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"db",    L"d eh 1 s - ax - b ax l", MS_Noun, L"d eh 1 s - ax - b ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"deg",   L"d ih - g r iy 1", MS_Noun, L"d ih - g r iy 1 z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"ft",    L"F UH 1 T", MS_Noun, L"F IY 1 T", MS_Noun, L"F AO 1 R T", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"g",     L"G R AE 1 M", MS_Noun, L"G R AE 1 M Z", MS_Noun, L"JH IY 1", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"gal",   L"g ae 1 l - ax n", MS_Noun, L"g ae 1 l - ax n Z", MS_Noun, L"G AE 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"hr",    L"AW 1 ER", MS_Noun, L"AW 1 ER Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"in",    L"IH 1 N CH", MS_Noun, L"IH 1 N CH AX Z", MS_Noun, L"IH 1 N", MS_Prep, 0, 0 },
    //--- MeasurementDisambig
    { L"j",     L"JH UW 1 L", MS_Noun, L"JH UW 1 L Z", MS_Noun, L"JH EY 1", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"kb",    L"k ih 1 l - ax - b ay 2 t", MS_Noun, L"k ih 1 l - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"kcal",  L"k ih 1 l - ax - k ae 2 l - ax - r iy", MS_Noun, L"k ih 1 l - ax - k ae 2 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"kg",    L"k ih 1 l - ax - g r ae 2 m", MS_Noun, L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"kj",    L"k ih 1 l - ax - jh uw 2 l", MS_Noun, L"k ih 1 l - ax - jh uw 2 l z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"km",    L"k ih - l aa 1 m - ih - t er", MS_Noun, L"k ih - l aa 1 m - ih - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"kw",    L"k ih 1 l - ax - w aa 2 t", MS_Noun, L"k ih 1 l - ax - w aa 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"l",     L"l iy 1 - t er", MS_Noun, L"l iy 1 - t er Z", MS_Noun, L"EH 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"lb",    L"P AW 1 N D", MS_Noun, L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"m",     L"M IY 1 - T ER", MS_Noun, L"M IY 1 - T ER Z", MS_Noun, L"EH 1 M", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"mb",    L"m eh 1 g - ax - b ay 2 t", MS_Noun, L"m eh 1 g - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mg",    L"m ih 1 l - ax - g r ae 2 m", MS_Noun, L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mi",    L"M AY 1 L", MS_Noun, L"M AY 1 L Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"min",   L"m ih 1 n - ax t", MS_Noun, L"m ih 1 n - ax t S", MS_Noun, L"m ih 1 n - ax - m ax m", MS_Noun, 0, 0 },
    //--- ReadDisambig
    { L"misread", L"m ih s - r iy 1 d", MS_Verb, L"m ih s - r eh 1 d", MS_Verb, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementDisambig
    { L"ml",    L"m ih 1 l - ax - l iy 2 - t er", MS_Noun, L"m ih 1 l - ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mm",    L"m ih 1 l - ax - m iy 2 - t er", MS_Noun, L"m ih 1 l - ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mpg", L"m ay 1 l & p er 1 & g ae 1 l ax n", MS_Noun, L"m ay 1 l z & p er 1 & g ae 1 l ax n", MS_Noun, L"eh 1 m & p iy 1 & jh iy 1", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"mph",   L"m ay 1 l & p er 1 & aw 1 er", MS_Noun, L"m ay 1 l z & p er 1 & aw 1 er", MS_Noun, L"eh 1 m & p iy 1 & ey 1 ch", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"msec",  L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"oz",    L"AW 1 N S", MS_Noun, L"AW 1 N S AX Z", MS_Noun, L"AA 1 Z", MS_Noun, 0, 0 },
    //--- ReadDisambig
    { L"proofread", L"p r uw 1 f - r iy 2 d", MS_Verb, L"p r uw 1 f - r eh 2 d", MS_Verb, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementDisambig
    { L"qt",    L"K W AO 1 R T", MS_Noun, L"K W AO 1 R T Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- ReadDisambig
    { L"read",  L"R IY 1 D", MS_Verb, L"R EH 1 D", MS_Verb, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementDisambig
    { L"sec",   L"S EH 1 k - ax n d", MS_Noun, L"s eh 1 k - ax n d z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"tbsp",  L"t ey 1 - b ax l - s p uw 2 n", MS_Noun, L"t ey 1 - b ax l - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- TheDisambig
    { L"the",   L"DH IY 2", MS_Det, L"DH AX 2", MS_Det, NULL, MS_Unknown, 0, 1 },
    //--- MeasurementDisambig
    { L"tsp",   L"t iy 1 - s p uw 2 n", MS_Noun, L"t iy 1 - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"yd",    L"Y AA 1 R D", MS_Noun, L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"yr",    L"Y IY 1 R", MS_Noun, L"Y IY 1 R Z", MS_Noun, NULL, MS_Unknown, 0, 0 },

};

WCHAR *g_pOfA = L"ah 2 v & ax 2 &";
WCHAR *g_pOfAn = L"ah 2 v & ax 2 n &";

const SentBreakDisambigFunc g_SentBreakDisambigTable[] = 
{
    CStdSentEnum::IsAbbreviationEOS,
    CStdSentEnum::IfEOSNotAbbreviation,
    CStdSentEnum::IfEOSAndLowercaseNotAbbreviation,
};

const PronDisambigFunc g_PronDisambigTable[] = 
{
    CStdSentEnum::SingleOrPluralAbbreviation,
    CStdSentEnum::DoctorDriveAbbreviation,
    CStdSentEnum::AbbreviationFollowedByDigit,
    CStdSentEnum::DegreeAbbreviation,
    CStdSentEnum::AbbreviationModifier,
};

const PronDisambigFunc g_AmbiguousWordDisambigTable[] =
{
    CStdSentEnum::SingleOrPluralAbbreviation,
    CStdSentEnum::DoctorDriveAbbreviation,
    CStdSentEnum::AbbreviationFollowedByDigit,
    CStdSentEnum::AllCapsAbbreviation,
    CStdSentEnum::CapitalizedAbbreviation,
    CStdSentEnum::SECAbbreviation,
    CStdSentEnum::DegreeAbbreviation,
	CStdSentEnum::AbbreviationModifier,
    CStdSentEnum::ADisambig,
    CStdSentEnum::PolishDisambig,
};

const PostLexLookupDisambigFunc g_PostLexLookupDisambigTable[] =
{
    CStdSentEnum::MeasurementDisambig,
    CStdSentEnum::TheDisambig,
    CStdSentEnum::ReadDisambig,
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
// This is an alphabetized list of all non-proper-noun words which
// appear within the list of the 200 most frequent first words
// in sentences in both the Brown and WSJ corpora.
const SPLSTR g_FirstWords[] =
{
DEF_SPLSTR( "A" ),
DEF_SPLSTR( "About" ),
DEF_SPLSTR( "According" ),
DEF_SPLSTR( "After" ),
DEF_SPLSTR( "Again" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "All" ),
DEF_SPLSTR( "Also" ),
DEF_SPLSTR( "Although" ),
DEF_SPLSTR( "Among" ),
DEF_SPLSTR( "An" ),
DEF_SPLSTR( "And" ),
DEF_SPLSTR( "Another" ),
DEF_SPLSTR( "Any" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Anyway" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Are" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "As" ),
DEF_SPLSTR( "At" ),
DEF_SPLSTR( "Back" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Because" ),
DEF_SPLSTR( "Before" ),
DEF_SPLSTR( "Besides" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Both" ),
DEF_SPLSTR( "But" ),
DEF_SPLSTR( "By" ),
DEF_SPLSTR( "Can" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Consequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Dear" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Despite" ),
DEF_SPLSTR( "Did" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Do" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Does" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Don't" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "During" ),
DEF_SPLSTR( "Each" ),
DEF_SPLSTR( "Early" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Even" ),
DEF_SPLSTR( "Every" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Finally" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "First" ),
DEF_SPLSTR( "Following" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "For" ),
DEF_SPLSTR( "Four" ),
DEF_SPLSTR( "From" ),
DEF_SPLSTR( "Further" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Furthermore" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Generally" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Given" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Go" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Great" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Had" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Have" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Having" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "He" ),
DEF_SPLSTR( "Her" ),
DEF_SPLSTR( "Here" ),
DEF_SPLSTR( "His" ),
DEF_SPLSTR( "How" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "However" ),
DEF_SPLSTR( "I" ),
DEF_SPLSTR( "If" ),
DEF_SPLSTR( "In" ),
DEF_SPLSTR( "Indeed" ),
DEF_SPLSTR( "Initially" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Instead" ),
DEF_SPLSTR( "Is" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "It" ),
DEF_SPLSTR( "Its" ),
DEF_SPLSTR( "Just" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Last" ),
DEF_SPLSTR( "Later" ),
DEF_SPLSTR( "Let" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Like" ),
DEF_SPLSTR( "Many" ),
DEF_SPLSTR( "Maybe" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Meanwhile" ),
DEF_SPLSTR( "More" ),
DEF_SPLSTR( "Moreover" ),
DEF_SPLSTR( "Most" ),
DEF_SPLSTR( "Much" ),
DEF_SPLSTR( "My" ),    // Added to fix bug #385
DEF_SPLSTR( "Neither" ),
DEF_SPLSTR( "Never" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nevertheless" ),
DEF_SPLSTR( "New" ),
DEF_SPLSTR( "Next" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "No" ),
DEF_SPLSTR( "None" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nonetheless" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nor" ),
DEF_SPLSTR( "Not" ),
DEF_SPLSTR( "Nothing" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Now" ),
DEF_SPLSTR( "Of" ),
DEF_SPLSTR( "On" ),
DEF_SPLSTR( "Once" ),
DEF_SPLSTR( "One" ),
DEF_SPLSTR( "Only" ),
DEF_SPLSTR( "Or" ),
DEF_SPLSTR( "Other" ),
DEF_SPLSTR( "Others" ),
DEF_SPLSTR( "Our" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Over" ),
DEF_SPLSTR( "People" ),
DEF_SPLSTR( "Perhaps" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Please" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Previous" ),                             // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Recent" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Right" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Second" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "See" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Several" ),
DEF_SPLSTR( "She" ),
DEF_SPLSTR( "Shortly" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Similarly" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Since" ),
DEF_SPLSTR( "So" ),
DEF_SPLSTR( "Some" ),
DEF_SPLSTR( "Sometimes" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Soon" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Still" ),
DEF_SPLSTR( "Subsequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Such" ),
DEF_SPLSTR( "Take" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "That" ),
DEF_SPLSTR( "The" ),
DEF_SPLSTR( "Their" ),
DEF_SPLSTR( "Then" ),
DEF_SPLSTR( "There" ),
DEF_SPLSTR( "Thereafter" ),                           // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Therefore" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "These" ),
DEF_SPLSTR( "They" ),
DEF_SPLSTR( "This" ),
DEF_SPLSTR( "Those" ),
DEF_SPLSTR( "Though" ),
DEF_SPLSTR( "Three" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Through" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Thus" ),
DEF_SPLSTR( "To" ),
DEF_SPLSTR( "Today" ),
DEF_SPLSTR( "Two" ),
DEF_SPLSTR( "Under" ),
DEF_SPLSTR( "Unlike" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Until" ),
DEF_SPLSTR( "Upon" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "We" ),
DEF_SPLSTR( "Well" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "What" ),
DEF_SPLSTR( "When" ),
DEF_SPLSTR( "Where" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Whether" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Which" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "While" ),
DEF_SPLSTR( "Who" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Why" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Will" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "With" ),
DEF_SPLSTR( "Within" ),
DEF_SPLSTR( "Without" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yes" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yet" ),
DEF_SPLSTR( "You" ),
DEF_SPLSTR( "Your" ),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\reverbfx.cpp ===
/*******************************************************************************
* ReverbFX.cpp *
*-------------*
*   Description:
*       This module is the implementation file for the CReverbFX class.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

#include "stdafx.h"
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef ReverbFX_H
#include "ReverbFX.h"
#endif



/*****************************************************************************
* CReverbFX::DecibelToPercent *
*-----------------------------*
*   Description:
*   Converts Voltage percentage from dB
*       v = 10^(dB/20)      
*       
********************************************************************** MC ***/
REVERBL CReverbFX::DecibelToPercent( float flDecibel )
{
    SPDBG_FUNC( "CReverbFX::DecibelToPercent" );
    float    fltIntVol;
    
    if( flDecibel >= REVERB_MIN_DB )
    {
        fltIntVol = (float) pow( 10.0, (double)flDecibel / 20.0 );
    }
    else
    {
        fltIntVol = 0.0;
    }
    
#ifdef FLOAT_REVERB
    return fltIntVol;
#else
    fltIntVol = fltIntVol * REVERB_VOL_LEVELS;
    return (REVERBL)fltIntVol;
#endif
} /* CReverbFX::DecibelToPercent */




/*****************************************************************************
* CReverbFX::ClearReverb *
*------------------------*
*   Description:
*   Fills the delay line with silence.
*       
********************************************************************** MC ***/
void CReverbFX::ClearReverb( LP_Reverb_Mod mod )
{
    SPDBG_FUNC( "CReverbFX::ClearReverb" );
    long        i;
    REVERBT     *dPtr;
    
    dPtr = mod->psDelayBuffer;
    for( i = 0; i < mod->dwDelayBufferSize; i++ )
    {
        *dPtr++ = 0;
    }
} /* CReverbFX::ClearReverb */




/*****************************************************************************
* CReverbFX::AllocReverbModule *
*------------------------------*
*   Description:
*       
********************************************************************** MC ***/
short   CReverbFX::AllocReverbModule 
                    (
                     LP_Reverb_Mod  mod,
                     REVERBL        lGain,              // Gain of the amplifiers.
                     long           dwDelay,            // Length of the delay line.
                     long           dwDelayBufferSize   // Size of the delay buffer.
                    )
{
    SPDBG_FUNC( "CReverbFX::AllocReverbModule" );
    short       result;
    
    
    result = KREVERB_NOERROR;
    mod->lGain              = lGain;
    mod->dwDelay            = dwDelay;
    mod->dwDelayBufferSize  = dwDelayBufferSize;
    mod->psDelayBuffer      = new REVERBT[mod->dwDelayBufferSize];
    if( mod->psDelayBuffer == NULL )
    {
        result = KREVERB_MEMERROR;
    }
    else
    {
        mod->psDelayEnd = mod->psDelayBuffer + mod->dwDelayBufferSize;
        mod->psDelayOut = mod->psDelayBuffer;
        if( mod->dwDelayBufferSize == mod->dwDelay )
        {
            mod->psDelayIn  = mod->psDelayBuffer;
        }
        else
        {
            mod->psDelayIn  = mod->psDelayBuffer + mod->dwDelay;
        }
        ClearReverb( mod );
    }
    
    return result;
} /* CReverbFX::AllocReverbModule */




/*****************************************************************************
* CReverbFX::CreateReverbModules *
*--------------------------------*
*   Description:
*   Creates an array of reverb modules.
*       
********************************************************************** MC ***/
short CReverbFX::CreateReverbModules
                (
                 short          wModules,       // Number of modules to create.
                 LP_Reverb_Mod  *mods,
                 float *        pfltDelay,      // Array of delay values for the modules.
                 float *        pfltDB,         // Array of gain values for the modules.
                 float          fltSamplesPerMS // Number of samples per millisecond.
                 )
{
    SPDBG_FUNC( "CReverbFX::CreateReverbModules" );
    long        dwDelay, i;
    float       tempF;
    REVERBL     vol;
    short       result = KREVERB_NOERROR;
    
    
    if( wModules > 0 )
    {
        for( i = 0; i < wModules; i++ )
        {
            mods[i] = new Reverb_Mod;
            if( !mods[i] )
            {
                //---------------------------------------
                // Not enough memory
                //---------------------------------------
                result = KREVERB_MEMERROR;
                break;
            }
            else
            {
                tempF = *pfltDelay++ * fltSamplesPerMS;
                dwDelay = (long) tempF;
                if( dwDelay < 2 )
                    dwDelay = 2;                // @@@@
                vol = DecibelToPercent( *pfltDB++ );
                result = AllocReverbModule( mods[i], vol, dwDelay, dwDelay );
                if( result != KREVERB_NOERROR )
                    break;
            }
        }
    }
    
    return result;
} /* CReverbFX::CreateReverbModules */





  
/*****************************************************************************
* CReverbFX::DeleteReverbModules *
*--------------------------------*
*   Description:
*   Deletes an array of reverb modules.
*       
********************************************************************** MC ***/
void CReverbFX::DeleteReverbModules( )
{
    SPDBG_FUNC( "CReverbFX::DeleteReverbModules" );
    long    i;
    
    for( i = 0; i < KMAXREVBMODS; i++ )
    {
        if( m_Reverb_Mods[i] != NULL )
        {
            if( m_Reverb_Mods[i]->psDelayBuffer != NULL )
            {
                delete m_Reverb_Mods[i]->psDelayBuffer;
            }
            delete m_Reverb_Mods[i];
            m_Reverb_Mods[i] = NULL;
        }
    }
    
    if( m_pWorkBuf != NULL )
    {
        delete m_pWorkBuf;
        m_pWorkBuf = NULL;
    }
} /* CReverbFX::DeleteReverbModules */







/*****************************************************************************
* CReverbFX::GetReverbConfig *
*----------------------------*
*   Description:
*       
********************************************************************** MC ***/
LPREVERBCONFIG  CReverbFX::GetReverbConfig( REVERBTYPE dwReverbConfig )
{
    SPDBG_FUNC( "CReverbFX::GetReverbConfig" );
    LPREVERBCONFIG      pReverbConfig = NULL;
    
    switch( dwReverbConfig )
    {
    //-----------------------------
    // Hall
    //-----------------------------
    case REVERB_TYPE_HALL:
        {
            static float afltLeftDelay[]    = { (float)(float)(30.6),   (float)(20.83),     (float)(14.85),     (float)(10.98)  };
            static float afltLeftGain[]     = { (float)(-2.498),        (float)(-2.2533),   (float)(-2.7551),   (float)(-2.5828)    };
            
            static REVERBCONFIG reverbConfig =
            {
                (-17.0),            // Wet
                    (-2.0),             // Dry
                    4,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
        //-----------------------------
        // Stadium
        //-----------------------------
    case REVERB_TYPE_STADIUM:
        {
            static float afltLeftDelay[]    = { (float)(40.6*4),    (float)(27.65*4),   (float)(17.85*4),   (float)(10.98*4)    };
            static float afltLeftGain[]     = { (float)(-2.498),    (float)(-2.2533),   (float)(-2.7551),   (float)(-2.5828)    };
            
            static REVERBCONFIG reverbConfig =
            {
                (-3.0),             // Wet
                    (-5.0),             // Dry
                    4,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
    //-----------------------------
    // Church
    //-----------------------------
    case REVERB_TYPE_CHURCH:
        {
            static float afltLeftDelay[]    = { (float)(40.6*2),    (float)(27.65*2),   (float)(17.85*2),   (float)(10.98*2)    };
            static float afltLeftGain[]     = { (float)(-2.498),    (float)(-2.2533),   (float)(-2.7551),   (float)(-2.5828)    };
            
            static REVERBCONFIG reverbConfig =
            {
                (-5.0),             // Wet
                    (-5.0),             // Dry
                    4,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
        
    //-----------------------------
    // Bathtub
    //-----------------------------
    case REVERB_TYPE_BATHTUB:
        {
            static float afltLeftDelay[]    = { (float)(10.0)   };
            static float afltLeftGain[]     = { (float)(-0.5)   };
            
            static REVERBCONFIG reverbConfig =
            {
                (7.0),              // Wet
                    (9.0),              // Dry
                    1,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
    //-----------------------------
    // Room
    //-----------------------------
    case REVERB_TYPE_ROOM:
        {
            static float afltLeftDelay[]    = { (float)(10.6)       };
            static float afltLeftGain[]     = { (float)(-10.498)    };
            
            static REVERBCONFIG reverbConfig =
            {
                (0.0),              // Wet
                    (0.0),              // Dry
                    1,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
    //-----------------------------
    // Echo
    //-----------------------------
    case REVERB_TYPE_ECHO:
        {
            static float afltLeftDelay[]    = { (float)(400.6)  };
            static float afltLeftGain[]     = { (float)(-10.498)    };
            
            static REVERBCONFIG reverbConfig =
            {
                (-10.0),                // Wet
                    (0.0),              // Dry
                    1,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
    //-----------------------------
    // Sequencer
    //-----------------------------
    case REVERB_TYPE_ROBOSEQ:
        {
            static float afltLeftDelay[]    = { (float)(10.0)   };
            static float afltLeftGain[]     = { (float)(-0.5)   };
            
            static REVERBCONFIG reverbConfig =
            {
                (6.5),              // Wet
                    (9.0),              // Dry
                    1,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.05,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
    }
    
    return pReverbConfig;
} /* CReverbFX::GetReverbConfig */







/*****************************************************************************
* CReverbFX::Reverb_Init *
*------------------------*
*   Description:
*   Initialize a reverberator array.
*       
********************************************************************** MC ***/
short CReverbFX::Reverb_Init( REVERBTYPE reverbPreset, long nSamplesPerSec, long  stereoOut )
{
    SPDBG_FUNC( "CReverbFX::Reverb_Init" );
    short       result = KREVERB_NOERROR;
    float       fltSamplesPerMS;
    
    
    m_StereoOut = stereoOut;
    if( reverbPreset > REVERB_TYPE_OFF )
    {
        //----------------------------------------------
        // Get params from preset number
        //----------------------------------------------
        m_pReverbConfig = GetReverbConfig( reverbPreset );
        m_numOfMods     = m_pReverbConfig->numOfReflect;
        
        //----------------------------------------------
        // Convert dB's to linear gain
        //----------------------------------------------
        m_wetVolGain = DecibelToPercent( m_pReverbConfig->wetGain_dB );
        m_dryVolGain = DecibelToPercent( m_pReverbConfig->dryGain_dB );
        
        fltSamplesPerMS = (float)nSamplesPerSec / (float)1000.0;
        
        result = CreateReverbModules
            (
            (short)m_numOfMods,
            (LP_Reverb_Mod*)&m_Reverb_Mods,
            m_pReverbConfig->gain_ms_Array,
            m_pReverbConfig->gain_dB_Array,
            fltSamplesPerMS
            );
        if( result != KREVERB_NOERROR )
        {
            //--------------------------------
            // Failure! Not enough memory
            //--------------------------------
            return result;
        }
        
        if( m_pWorkBuf == NULL )
        {
            m_pWorkBuf = new REVERBT[m_dwWorkBufferSize];
            if( m_pWorkBuf == NULL )
            {
                //--------------------------------
                // Failure! Not enough memory
                //--------------------------------
                result = KREVERB_MEMERROR;
                return result;
            }
        }
    }
    else
    {
        DeleteReverbModules( );
        result = KREVERB_OFF;
    }
    return result;
} /* CReverbFX::Reverb_Init */










/*****************************************************************************
* CReverbFX::CReverbFX *
*----------------------*
*   Description:
*       
********************************************************************** MC ***/
CReverbFX::CReverbFX( void )
{
    SPDBG_FUNC( "CReverbFX::CReverbFX" );
    long            i;
    
    //--------------------------------
    // Initilize
    //--------------------------------
    m_dwWorkBufferSize  = KWORKBUFLEN;
    m_pWorkBuf          = NULL;
    m_wetVolGain        = 0;
    m_dryVolGain        = 0;
    m_numOfMods         = 0;
    m_Count             = 0;
    m_StereoOut         = false;
    for( i = 0; i < KMAXREVBMODS; i++ )
    {
        m_Reverb_Mods[i] = NULL;
    }
} /* CReverbFX::CReverbFX */




/*****************************************************************************
* CReverbFX::~CReverbFX *
*-----------------------*
*   Description:
*       
********************************************************************** MC ***/
CReverbFX::~CReverbFX( void )
{
    SPDBG_FUNC( "CReverbFX::~CReverbFX" );
    DeleteReverbModules( );
} /* CReverbFX::~CReverbFX */






//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// Run-time
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


/*****************************************************************************
* CReverbFX::CopyWithGain *
*-------------------------*
*   Description:
*   Copies audio buffer with gain
*       
********************************************************************** MC ***/
void CReverbFX::CopyWithGain 
                        (   REVERBT    *psDest,
                            REVERBT    *psSource,
                            long       dwSamples,
                            REVERBL    gain)
{   
    SPDBG_FUNC( "CReverbFX::CopyWithGain" );
    
    if( gain <= REVERB_VOL_OFF )
    {
        //----------------------------------------
        // Clear buffer, gain = 0
        //----------------------------------------
        memset( psDest, 0, sizeof(REVERBT) * dwSamples );
    }
    else if( gain == REVERB_VOL_UNITY )
    {
        //----------------------------------------
        // Copy buffer, gain = 1
        //----------------------------------------
        memcpy( psDest, psSource, sizeof(REVERBT) * dwSamples );
    }
    else
    {
        //----------------------------------------
        // Copy with gain
        //----------------------------------------
        while( dwSamples )
        {
#ifdef FLOAT_REVERB
            *psDest++ = (*psSource++) * gain;
#else
            *psDest++ = (short) (( (long)(*psSource++) * (long)gain) >> REVERB_VOL_SHIFT);
#endif
            dwSamples--;
        }
    }
} /* CReverbFX::CopyWithGain */






/*****************************************************************************
* CReverbFX::MixWithGain_MONO *
*-----------------------------*
*   Description:
*  (psDest * gain) + psSource -> psDest
*   Clipping is performed.
*       
********************************************************************** MC ***/
void CReverbFX::MixWithGain_MONO
                        (
                         REVERBT    *pWet,
                         REVERBT    *pDry,
                         short      *pDest,
                         long       dwSamples,
                         REVERBL    gain
                         )
{   
    SPDBG_FUNC( "CReverbFX::MixWithGain_MONO" );
    REVERBL     lSample;                    // long or float
    
    if( gain <= REVERB_VOL_OFF )
    {
        //----------------------------------
        // Do nothing...I guess
        //----------------------------------
    }
    else if( gain == REVERB_VOL_UNITY )
    {
        //----------------------------------
        // Don't apply any gain (= 1.0)
        //----------------------------------
        while( dwSamples )
        {
            lSample = (REVERBL)(*pWet++) + *pDry;
            //------------------------------------
            // Clip signal if overflow
            //------------------------------------
            if( lSample < -32768 )
            {
                lSample = -32768;
            }
            else if( lSample > 32767 )
            {
                lSample = 32767;
            }
            *pDest++ = (short)lSample;
            
            pDry++;
            dwSamples--;
        }
    }
    else
    {
        while( dwSamples )
        {
            //----------------------------------
            // Mix with gain on source audio
            //----------------------------------
#ifdef FLOAT_REVERB
            lSample =  ((*pDry) * gain) + *pWet++;
#else
            lSample = ((long)(*pDry * (long)(gain)) >> REVERB_VOL_SHIFT) + *pWet++;
#endif
            //------------------------------------
            // Clip signal if overflow
            //------------------------------------
            if( lSample < -32768 )
            {
                lSample = -32768;
            }
            else if( lSample > 32767 )
            {
                lSample = 32767;
            }
            *pDest++ = (short)lSample;
            
            pDry++;
            dwSamples--;
        }
    }
} /* CReverbFX::MixWithGain_MONO */






/*****************************************************************************
* CReverbFX::MixWithGain_STEREO *
*-------------------------------*
*   Description:
*       
********************************************************************** MC ***/
void CReverbFX::MixWithGain_STEREO
                            (
                             REVERBT    *pWet,
                             REVERBT    *pDry,
                             short      *pDest,
                             long       dwSamples,
                             REVERBL    gain
                             )
{   
    SPDBG_FUNC( "CReverbFX::MixWithGain_STEREO" );
    REVERBL     lSample, hold;      // long or float
    REVERBL     lSample_B;      // long or float
    
    if( gain <= REVERB_VOL_OFF )
    {
        //----------------------------------
        // Do nothing...I guess
        //----------------------------------
    }
    else if( gain == REVERB_VOL_UNITY )
    {
        //----------------------------------
        // Don't apply any gain (= 1.0)
        //----------------------------------
        while( dwSamples )
        {
            lSample = (REVERBL)(*pWet++) + (*pDry++);
            //------------------------------------
            // Clip signal if overflow
            //------------------------------------
            if( lSample < -32768 )
            {
                lSample = -32768;
            }
            else if( lSample > 32767 )
            {
                lSample = 32767;
            }
            *pDest++ = (short)lSample;
            *pDest++ = (short)(0 - (short)lSample);
            dwSamples--;
        }
    }
    else
    {
        while( dwSamples )
        {
            //----------------------------------
            // Mix with gain on source audio
            //----------------------------------
#ifdef FLOAT_REVERB
            hold = ((*pDry) * gain);
            lSample =  hold + *pWet;
            lSample_B =  hold - *pWet++;
            //lSample_B = 0 - lSample_B;
            //lSample_B = (0 - hold) - *pWet++;
#else
            lSample = ((long)(*pDry * (long)(gain)) >> REVERB_VOL_SHIFT) + *pWet;
            lSample_B = ((long)(*pDry * (long)(gain)) >> REVERB_VOL_SHIFT) - *pWet++;
#endif
            //------------------------------------
            // Clip signal if overflow
            //------------------------------------
            if( lSample < -32768 )
            {
                lSample = -32768;
            }
            else if( lSample > 32767 )
            {
                lSample = 32767;
            }
            *pDest++ = (short)lSample;
            
            if( lSample < -32768 )
            {
                lSample = -32768;
            }
            else if( lSample > 32767 )
            {
                lSample = 32767;
            }
            *pDest++ = (short)lSample_B;
            
            pDry++;
            dwSamples--;
        }
    }
} /* CReverbFX::MixWithGain_STEREO */







/*****************************************************************************
* CReverbFX::ProcessReverbModule *
*-------------------*
*   Description:
*   Process one delay buffer
*       
********************************************************************** MC ***/
void    CReverbFX::ProcessReverbModule
                     (
                     LP_Reverb_Mod  mod,
                     long           dwDestSamples,      // Number of samples to process.
                     REVERBT        *pSource,           // Source sample buffer.
                     REVERBT        *pDestination       // Destination sample buffer.
                     )
{
    SPDBG_FUNC( "CReverbFX::ProcessReverbModule" );
    REVERBT     sDelayOut;
    REVERBT     sDelayIn;
    REVERBT     *psDelayEnd;
    
    //(void) QueryPerformanceCounter (&g_StartTime );
    
    psDelayEnd = mod->psDelayBuffer + (long)((float)mod->dwDelayBufferSize * m_LenScale);
    dwDestSamples++;
    while( --dwDestSamples )
    {
        //----------------------------------------
        // Delay + current --> delay buffer
        //----------------------------------------
        sDelayOut   = *mod->psDelayOut;
#ifdef FLOAT_REVERB
        sDelayIn    = (sDelayOut * mod->lGain) + *pSource;
        //------------------------------------------------------------
        // Take this test out and you'll die in about 10 sec...
        //------------------------------------------------------------
        if( sDelayIn > 0) 
        {
            if( sDelayIn < 0.001 )
                sDelayIn = 0;
        }
        else if( sDelayIn > -0.001 )
        {
            sDelayIn = 0;
        }
#else
        sDelayIn    = ((sDelayOut * mod->lGain) >> REVERB_VOL_SHIFT) + *pSource;
#endif
        *mod->psDelayIn++ = sDelayIn;
        
        //----------------------------------------
        // Delay - (Delay + current) --> current 
        //----------------------------------------
#ifdef FLOAT_REVERB
        *pDestination = sDelayOut - (sDelayIn * mod->lGain);
#else
        *pDestination = sDelayOut - ((sDelayIn * mod->lGain) >> REVERB_VOL_SHIFT);
#endif
        
        //---------------------------------------
        // Wrap circular buffer ptrs
        //---------------------------------------
        if( mod->psDelayIn >= psDelayEnd )
        {
            mod->psDelayIn = mod->psDelayBuffer;
        }
        mod->psDelayOut++;
        if( mod->psDelayOut >= psDelayEnd )
        {
            mod->psDelayOut = mod->psDelayBuffer;
        }
        pSource++;
        pDestination++;
    }
    //(void) QueryPerformanceCounter (&g_EndTime);
    //g_LapseTime.QuadPart = (g_EndTime.QuadPart - g_StartTime.QuadPart);
} /* CReverbFX::ProcessReverbModule */




//----------------------------------------------------------------------------
// Applies an array of reverb modules to a block of samples.
//----------------------------------------------------------------------------
/*****************************************************************************
* CReverbFX::ProcessReverbBuffer *
*--------------------------------*
*   Description:
*   Applies an array of reverb modules to a block of samples.
*       
********************************************************************** MC ***/
void    CReverbFX::ProcessReverbBuffer 
                     (  REVERBT        *psSample,      // Samples to process (in/out).
                        long           dwSamples,      // Number of samples to process.
                        LP_Reverb_Mod  *mods           // Array of modules to apply.
                     )
{
    SPDBG_FUNC( "CReverbFX::ProcessReverbBuffer" );
    short   i;
    
    for (i = 0; i < KMAXREVBMODS; i++)
    {
        if( mods[i] != NULL )
        {
            ProcessReverbModule( mods[i], dwSamples, psSample, psSample );
        }
        else
            break;
    }
    
} /* CReverbFX::ProcessReverbBuffer */


/*****************************************************************************
* CReverbFX::Reverb_Process *
*---------------------------*
*   Description:
*       
********************************************************************** MC ***/
short CReverbFX::Reverb_Process( float *sampleBuffer, 
                                long dwSamplesRemaining, float audioGain )
{
    SPDBG_FUNC( "CReverbFX::Reverb_Process" );
    long    dwSamplesToProcess;
    short   *pOutBuffer;
    REVERBL totalWetGain, totalDryGain;

    if( m_numOfMods )
    {
        #ifdef FLOAT_REVERB
            totalWetGain = m_wetVolGain * audioGain;
            if (totalWetGain < REVERB_MIN_MIX)
                totalWetGain = REVERB_MIN_MIX;
            totalDryGain = m_dryVolGain * audioGain;
            if (totalDryGain < REVERB_MIN_MIX)
                totalDryGain = REVERB_MIN_MIX;
        #else
            totalWetGain = (REVERBL)(m_wetVolGain * audioGain * (float)REVERB_VOL_LEVELS);
            totalDryGain = (REVERBL)(m_dryVolGain * audioGain * (float)REVERB_VOL_LEVELS);
        #endif
        pOutBuffer = (short*)sampleBuffer;
        m_LenScale = (float)1.0 - (m_Count * m_pReverbConfig->seqIndex);
        
        while( dwSamplesRemaining > 0 )
        {
            //----------------------------------------------------------------------------
            // Process client's buffer using 'work buffer' chunks
            //----------------------------------------------------------------------------
            if( dwSamplesRemaining < m_dwWorkBufferSize )
            {
                dwSamplesToProcess = dwSamplesRemaining;
            }
            else
            {
                dwSamplesToProcess = m_dwWorkBufferSize;
            }
            
            //-----------------------------------------------------------------
            // Copy audio into WET buffer with wet gain
            //      sampleBuffer * totalWetGain --> m_pWorkBuf
            //-----------------------------------------------------------------
            CopyWithGain( m_pWorkBuf, sampleBuffer, dwSamplesToProcess, totalWetGain  );
            
            //-----------------------------------------------------------------
            // Perform reverb processing on the work buffer
            //-----------------------------------------------------------------
            ProcessReverbBuffer
                            (
                                m_pWorkBuf,
                                dwSamplesToProcess,
                                (LP_Reverb_Mod*)&m_Reverb_Mods
                            );
            
            //-----------------------------------------------------------------
            // Mix the dry with wet samples
            //     (sampleBuffer * totalDryGain) + m_pWorkBuf   --> sampleBuffer
            //-----------------------------------------------------------------
            if( m_StereoOut )
            {
                MixWithGain_STEREO( m_pWorkBuf, sampleBuffer, pOutBuffer, dwSamplesToProcess, totalDryGain );
                pOutBuffer += dwSamplesToProcess * 2;
            }
            else
            {
                MixWithGain_MONO( m_pWorkBuf, sampleBuffer, pOutBuffer, dwSamplesToProcess, totalDryGain );
                pOutBuffer += dwSamplesToProcess;
            }
            
            sampleBuffer        += dwSamplesToProcess;
            dwSamplesRemaining  -= dwSamplesToProcess;
        }
    }
    
    m_Count = (float)rand() / (float)4096;      // 0 - 32K -> 0 - 8
    
    return 0;
} /* CReverbFX::Reverb_Process */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by spttseng.rc
//
#define IDS_PROJNAME                    100
#define IDR_MSTTSENGINE                 101
#define IDR_MSVOICEDATA                 102
#define IDR_SPTTSENGUI                  103
#define IDD_TTS_ADV                     201
#define IDC_COMMA_PERIOD                201
#define IDC_PERIOD_COMMA                202
#define IDC_MDY                         203
#define IDC_DMY                         204
#define IDC_YMD                         205
#define IDRESTORE                       254

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         204
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\numnorm.cpp ===
/***********************************************************************************************
* NumNorm.cpp *
*-------------*
*  Description:
*   These functions normalize ordinary ordinal and cardinal numbers
*-----------------------------------------------------------------------------------------------
*  Created by AH                                                                August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

/***********************************************************************************************
* IsNumberCategory *
*------------------*
*   Description:
*       Checks the next token in the text stream to determine if it is a number category -
*   percents, degrees, squared and cubed numbers, and plain old numbers get matched here.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumberCategory( TTSItemInfo*& pItemNormInfo, const WCHAR* Context,
                                        CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

    TTSItemInfo *pNumberInfo = NULL;
    hr = IsNumber( pNumberInfo, Context, MemoryManager );
    if ( SUCCEEDED( hr )                 &&
         pNumberInfo->Type != eDATE_YEAR &&
         ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar == m_pEndOfCurrItem - 1 )
    {
        if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'%' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_PERCENT;
        }
        else if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_DEGREES;
        }
        else if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_SQUARED;
        }
        else if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_CUBED;
        }
        else
        {
            hr = E_INVALIDARG;
            delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
        }
    }
    else if ( SUCCEEDED( hr ) &&
              ( pNumberInfo->Type == eDATE_YEAR ||
                ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar == m_pEndOfCurrItem ) )
    {
        pItemNormInfo = pNumberInfo;
    }
    else if ( SUCCEEDED( hr ) )
    {
        hr = E_INVALIDARG;

        if ( pNumberInfo->Type != eDATE_YEAR )
        {
            delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
        }

        m_pNextChar      = pTempNextChar;
        m_pEndChar       = pTempEndChar;
        m_pEndOfCurrItem = pTempEndOfItem;
        m_pCurrFrag      = pTempFrag;
    }

    return hr;
} /* IsNumberCategory */

/***********************************************************************************************
* IsNumber *
*----------*
*   Description:
*       Checks the next token in the text stream to determine if it is a number.
*
*   RegExp:
*       [-]? { d+ || d(1-3)[,ddd]+ } { { .d+ } || { "st" || "nd" || "rd" || "th" } }?
*   It is actually a bit more complicated than this - for instance, the ordinal
*   strings may only follow certain digits (1st, 2nd, 3rd, 4-0th)...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                CSentItemMemory& MemoryManager, BOOL fMultiItem )
{
    SPDBG_FUNC( "CStdSentEnum::IsNumber" );

    HRESULT hr = S_OK;

    bool fNegative = false;
    TTSIntegerItemInfo*     pIntegerInfo        = NULL;
    TTSDigitsItemInfo*      pDecimalInfo        = NULL;
    TTSFractionItemInfo* pFractionInfo       = NULL;
    const SPVSTATE *pIntegerState = &m_pCurrFrag->State;
    CItemList PostIntegerList;
    ULONG ulOffset = 0, ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    WCHAR wcDecimalPoint;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

    if ( ulTokenLen )
    {
        //--- Set Separator and Decimal Point character preferences for this call
        if ( m_eSeparatorAndDecimal == COMMA_PERIOD )
        {
            wcDecimalPoint  = L'.';
        }
        else
        {
            wcDecimalPoint  = L',';
        }

        //--- Try to match the negative sign - [-]?
        if ( m_pNextChar[ulOffset] == L'-' )
        {
            fNegative = true;
            ulOffset++;
        }
    
        //--- Try to match the integral part
        hr = IsInteger( m_pNextChar + ulOffset, pIntegerInfo, MemoryManager );

        //--- Adjust ulOffset and hr...
        if ( SUCCEEDED( hr ) )
        {
            ulOffset += (ULONG)(pIntegerInfo->pEndChar - pIntegerInfo->pStartChar);
        }
        else if ( hr == E_INVALIDARG )
        {
            hr = S_OK;
            pIntegerInfo = NULL;
        }

        //--- Try to match a decimal part
        if ( ulOffset < ulTokenLen &&
             m_pNextChar[ulOffset] == wcDecimalPoint )
        {
            hr = IsDigitString( m_pNextChar + ulOffset + 1, pDecimalInfo, MemoryManager );
            if ( SUCCEEDED( hr ) )
            {
                ulOffset += pDecimalInfo->ulNumDigits + 1;

                //--- Check for special case - decimal number numerator...
                if ( ulOffset < ulTokenLen &&
                     m_pNextChar[ulOffset] == L'/' )
                {
                    pIntegerInfo = NULL;
                    pDecimalInfo = NULL;
                    fNegative ? ulOffset = 1 : ulOffset = 0;
                    hr = IsFraction( m_pNextChar + ulOffset, pFractionInfo, MemoryManager );
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( pFractionInfo->pVulgar )
                        {
                            ulOffset++;
                        }
                        else
                        {
                            ulOffset += (ULONG)(pFractionInfo->pDenominator->pEndChar - pFractionInfo->pNumerator->pStartChar);
                        }
                    }
                    else if ( hr == E_INVALIDARG )
                    {
                        hr = S_OK;
                    }
                }
            }
            else if ( hr == E_INVALIDARG )
            {
                hr = S_OK;
                pDecimalInfo = NULL;
            }
        }
        //--- Try to match an ordinal string
        else if ( pIntegerInfo          &&
                  ulOffset < ulTokenLen &&
                  isalpha( m_pNextChar[ulOffset] ) )
        {
            switch ( toupper( m_pNextChar[ulOffset] ) )
            {
            case 'S':
                //--- Must be of the form "...1st" but not "...11st" 
                if ( toupper( m_pNextChar[ulOffset+1] ) == L'T'  && 
                     m_pNextChar[ulOffset-1] == L'1'             &&
                     (ulOffset + 2) == ulTokenLen                &&
                     ( ulOffset == 1 ||
                       m_pNextChar[ulOffset-2] != L'1' ) )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            case 'N':
                //--- Must be of the form "...2nd" but not "...12nd" 
                if ( (ulOffset + 2) == ulTokenLen                &&
                     toupper(m_pNextChar[ulOffset+1]) == L'D'    &&
                     m_pNextChar[ulOffset-1] == L'2'             &&                
                     ( ulOffset == 1 ||
                       m_pNextChar[ulOffset-2] != L'1' ) )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            case 'R':
                //--- Must be of the form "...3rd" but not "...13rd" 
                if ( (ulOffset + 2) == ulTokenLen                &&
                     toupper(m_pNextChar[ulOffset+1]) == L'D'    &&
                     m_pNextChar[ulOffset-1] == L'3'             &&
                     ( ulOffset == 1 ||
                       m_pNextChar[ulOffset-2] != L'1' ) )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            case 'T':
                //--- Must be of the form "...[4-9]th" or "...[11-19]th" or "...[0]th" 
                if ( (ulOffset + 2) == ulTokenLen                 &&
                     toupper(m_pNextChar[ulOffset+1]) == L'H'     &&                
                     ( ( m_pNextChar[ulOffset-1] <= L'9' && m_pNextChar[ulOffset-1] >= L'4') ||
                       ( m_pNextChar[ulOffset-1] == L'0')                                    ||
                       ( ulOffset == 1 || m_pNextChar[ulOffset-2] == L'1') ) )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            default:
                // Some invalid non-digit character found at the end of the string
                break;
            }
        }
        //--- Try to match a fraction
        else
        {
            //--- Try to match an attached fraction
            if ( ulOffset < ulTokenLen )
            {
                if ( m_pNextChar[ulOffset] == L'-' )
                {
                    ulOffset++;
                }
                hr = IsFraction( m_pNextChar + ulOffset, pFractionInfo, MemoryManager );
                if ( SUCCEEDED( hr ) )
                {
                    if ( pFractionInfo->pVulgar )
                    {
                        ulOffset++;
                    }
                    else
                    {
                        ulOffset += (ULONG)(pFractionInfo->pDenominator->pEndChar - pFractionInfo->pNumerator->pStartChar);
                    }
                }
                else if ( hr == E_INVALIDARG )
                {
                    hr = S_OK;
                }
            }
            //--- Try to match an unattached fraction
            else if ( fMultiItem )
            {
                pIntegerState = &m_pCurrFrag->State;

                //--- Advance in text
                m_pNextChar = m_pEndOfCurrItem;
                hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, 
                                            true, &PostIntegerList );
                if ( !m_pNextChar &&
                     SUCCEEDED( hr ) )
                {
                    m_pNextChar = pTempNextChar;
                    m_pEndChar  = pTempEndChar;
                    m_pCurrFrag = pTempFrag;
                }
                else if ( m_pNextChar &&
                          SUCCEEDED( hr ) )
                {
                    m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                    while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) )  != eUNMATCHED ||
                            IsGroupEnding( *(m_pEndOfCurrItem - 1) )      != eUNMATCHED ||
                            IsQuotationMark( *(m_pEndOfCurrItem - 1) )    != eUNMATCHED ||
                            IsEOSItem( *(m_pEndOfCurrItem - 1) )          != eUNMATCHED )
                    {
                        m_pEndOfCurrItem--;
                    }
                
                    hr = IsFraction( m_pNextChar, pFractionInfo, MemoryManager );

                    if ( FAILED( hr ) )
                    {
                        m_pNextChar      = pTempNextChar;
                        m_pEndChar       = pTempEndChar;
                        m_pEndOfCurrItem = pTempEndOfItem;
                        m_pCurrFrag      = pTempFrag;
                        if ( hr == E_INVALIDARG )
                        {
                            hr = S_OK;
                        }
                    }
                    else
                    {
                        ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                        if ( pFractionInfo->pVulgar )
                        {
                            ulOffset = 1;
                        }
                        else
                        {
                            ulOffset = (ULONG)(pFractionInfo->pDenominator->pEndChar - 
                                               pFractionInfo->pNumerator->pStartChar);
                        }                            
                    }
                }
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    //--- If we haven't processed the whole item yet, and it isn't part of a larger item --
    //---   e.g. a percent, a degrees number, or a square or cube -- then fail to match it 
    //---   as a number...
    if ( ulOffset != ulTokenLen &&
         !( ulTokenLen == ulOffset + 1 &&
            ( m_pNextChar[ulOffset] == L'%' ||
              m_pNextChar[ulOffset] == L'' ||
              m_pNextChar[ulOffset] == L'' ||
              m_pNextChar[ulOffset] == L'' ) ) )           
    {
        m_pNextChar         = pTempNextChar;
        m_pEndOfCurrItem    = pTempEndOfItem;
		m_pEndChar          = pTempEndChar;
		m_pCurrFrag         = pTempFrag;
		hr                  = E_INVALIDARG;
    }


    //--- Fill out pItemNormInfo...
    if ( SUCCEEDED( hr ) &&
         ( pIntegerInfo ||
           pDecimalInfo ||
           pFractionInfo ) )
    {
        //--- Reset m_pNextChar to handle the Mixed Fraction case...
        m_pNextChar = pTempNextChar;

        if ( pIntegerInfo                                           && 
             pIntegerInfo->pEndChar - pIntegerInfo->pStartChar == 4 &&
             !pIntegerInfo->fSeparators                             &&
             !pIntegerInfo->fOrdinal                                &&
             !pDecimalInfo                                          &&
             !pFractionInfo                                         &&
             !fNegative                                             &&
             ulOffset == ulTokenLen                                 &&
             ( !Context ||
               _wcsnicmp( Context, L"NUMBER", 6 ) != 0 ) )
        {
            pItemNormInfo = (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof( TTSYearItemInfo ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo->Type = eDATE_YEAR;
                ( (TTSYearItemInfo*) pItemNormInfo )->pYear = m_pNextChar;
                ( (TTSYearItemInfo*) pItemNormInfo )->ulNumDigits = 4;
            }
        }
        else
        {
            pItemNormInfo = (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( pItemNormInfo, sizeof( TTSNumberItemInfo ) );
                if ( pDecimalInfo )
                {
                    pItemNormInfo->Type = eNUM_DECIMAL;
                    if ( pIntegerInfo )
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pIntegerInfo->pEndChar +
                                                                           pDecimalInfo->ulNumDigits + 1;
                    }
                    else
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = m_pNextChar + pDecimalInfo->ulNumDigits + 1;
                        if ( fNegative )
                        {
                            ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar++;
                        }
                    }
                }
                else if ( pFractionInfo )
                {
                    if ( pFractionInfo->pVulgar )
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pFractionInfo->pVulgar + 1;
                    }
                    else
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar =
                                                            pFractionInfo->pDenominator->pEndChar;
                    }
                    if ( pIntegerInfo )
                    {
                        pItemNormInfo->Type = eNUM_MIXEDFRACTION;
                    }
                    else
                    {
                        pItemNormInfo->Type = eNUM_FRACTION;
                    }
                }
                else if ( pIntegerInfo )
                {
                    if ( pIntegerInfo->fOrdinal )
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pIntegerInfo->pEndChar + 2;
                        pItemNormInfo->Type = eNUM_ORDINAL;
                    }
                    else
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pIntegerInfo->pEndChar;
                        pItemNormInfo->Type = eNUM_CARDINAL;
                    }                    
                }               
            }

            if ( SUCCEEDED( hr ) )
            {
                ( (TTSNumberItemInfo*) pItemNormInfo )->fNegative        = fNegative;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pIntegerPart     = pIntegerInfo;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pDecimalPart     = pDecimalInfo;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pFractionalPart  = pFractionInfo;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pStartChar       = m_pNextChar;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList        = new CWordList;
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    //--- Expand Number into WordList
    if ( SUCCEEDED( hr ) &&
         pItemNormInfo->Type != eDATE_YEAR )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );
        Word.pXmlState          = pIntegerState;
        Word.eWordPartOfSpeech  = MS_Unknown;

        //--- Insert "negative"
        if ( fNegative )
        {
            Word.pWordText  = g_negative.pStr;
            Word.ulWordLen  = g_negative.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( Word );
        }

        //--- Expand Integral Part
        if ( pIntegerInfo )
        {
            ExpandInteger( pIntegerInfo, Context, *( (TTSNumberItemInfo*) pItemNormInfo )->pWordList );
        }

        //--- Expand Decimal Part
        if ( pDecimalInfo )
        {
            //--- Insert "point"
            Word.pWordText  = g_decimalpoint.pStr;
            Word.ulWordLen  = g_decimalpoint.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( Word );

            ExpandDigits( pDecimalInfo, *( (TTSNumberItemInfo*) pItemNormInfo )->pWordList );
        }

        //--- Expand Fractional Part
        if ( pFractionInfo )
        {
            //--- Insert Post-Integer Non-Spoken XML States, if any
            while ( !PostIntegerList.IsEmpty() )
            {
                ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( ( PostIntegerList.RemoveHead() ).Words[0] );
            }

            //--- Insert "and", if also an integer part
            if ( pIntegerInfo )
            {
                Word.pXmlState  = &m_pCurrFrag->State;
                Word.pWordText  = g_And.pStr;
                Word.ulWordLen  = g_And.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( Word );
            }

            hr = ExpandFraction( pFractionInfo, *( (TTSNumberItemInfo*) pItemNormInfo )->pWordList );
        }
    }

    return hr;
} /* IsNumber */

/***********************************************************************************************
* ExpandNumber *
*--------------*
*   Description:
*       Expands Items previously determined to be of type NUM_CARDINAL, NUM_DECIMAL, or 
*   NUM_ORDINAL by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandNumber( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "NumNorm ExpandNumber" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    return hr;
} /* ExpandNumber */

/***********************************************************************************************
* ExpandPercent *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_PERCENT by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandPercent( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandPercent" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    Word.pWordText          = g_percent.pStr;
    Word.ulWordLen          = g_percent.Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    WordList.AddTail( Word );

    return hr;
} /* ExpandPercent */

/***********************************************************************************************
* ExpandDegree *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_DEGREES by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandDegrees( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDegrees" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( !pItemInfo->pDecimalPart       &&
         !pItemInfo->pFractionalPart    &&
         pItemInfo->pIntegerPart        &&
         pItemInfo->pIntegerPart->pEndChar - pItemInfo->pIntegerPart->pStartChar == 1 &&
         pItemInfo->pIntegerPart->pStartChar[0] == L'1' )
    {
        Word.pWordText  = g_degree.pStr;
        Word.ulWordLen  = g_degree.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
    }
    else if ( !pItemInfo->pIntegerPart   &&
              pItemInfo->pFractionalPart &&
              !pItemInfo->pFractionalPart->fIsStandard )
    {
        Word.pWordText  = g_of.pStr;
        Word.ulWordLen  = g_of.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );

        Word.pWordText  = g_a.pStr;
        Word.ulWordLen  = g_a.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );

        Word.pWordText  = g_degree.pStr;
        Word.ulWordLen  = g_degree.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
    }
    else
    {
        Word.pWordText  = g_degrees.pStr;
        Word.ulWordLen  = g_degrees.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
    }

    WordList.AddTail( Word );

    return hr;
} /* ExpandDegrees */

/***********************************************************************************************
* ExpandSquare *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_SQUARED by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandSquare( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandSquare" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    Word.pWordText          = g_squared.pStr;
    Word.ulWordLen          = g_squared.Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    WordList.AddTail( Word );

    return hr;
} /* ExpandSquare */

/***********************************************************************************************
* ExpandCube *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_CUBED by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandCube( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandCube" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    Word.pWordText          = g_cubed.pStr;
    Word.ulWordLen          = g_cubed.Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    WordList.AddTail( Word );

    return hr;
} /* ExpandCube */

/***********************************************************************************************
* IsInteger *
*-----------*
*   Description:
*       Helper for IsNumber which matches the integer part...
*
*   RegExp:
*       { d+ || d(1-3)[,ddd]+ }
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsInteger( const WCHAR* pStartChar, TTSIntegerItemInfo*& pIntegerInfo, 
                                 CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    ULONG ulOffset = 0, ulCount = 0, ulTokenLen = (ULONG)(m_pEndOfCurrItem - pStartChar);
    BOOL fSeparators = false, fDone = false;
    WCHAR wcSeparator, wcDecimalPoint;

    if ( m_eSeparatorAndDecimal == COMMA_PERIOD )
    {
        wcSeparator  = L',';
        wcDecimalPoint = L'.';
    }
    else
    {
        wcSeparator  = L'.';
        wcDecimalPoint = L',';
    }

    //--- Check for first digit 
    if ( !isdigit(pStartChar[ulOffset]) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        ulCount++;
        ulOffset++;
    }

    //--- Check for separators
    ULONG i = ulOffset + 3;
    while ( SUCCEEDED( hr ) && 
            ulOffset < i    && 
            ulOffset < ulTokenLen )
    {
        if ( pStartChar[ulOffset] == wcSeparator )
        {
            //--- Found a separator 
            fSeparators = true;
            break;
        }
        else if ( !isdigit( pStartChar[ulOffset] ) &&
                  ( pStartChar[ulOffset] == wcDecimalPoint  ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'-'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    toupper( pStartChar[ulOffset] ) == L'S' ||
                    toupper( pStartChar[ulOffset] ) == L'N' ||
                    toupper( pStartChar[ulOffset] ) == L'R' ||
                    toupper( pStartChar[ulOffset] ) == L'T' ) )
        {
            fDone = true;
            break;
        }
        else if ( isdigit( pStartChar[ulOffset] ) )
        {
            //--- Just another digit 
            ulCount++;
            ulOffset++;
        }
        else
        {
            hr = E_INVALIDARG;
            break;
        }
    }

    if ( SUCCEEDED( hr ) && 
         !fDone          && 
         ulOffset < ulTokenLen )
    {
        if ( !fSeparators )
        {
            //--- No separators.  Pattern must be {d+} if this is indeed a number, so just count digits. 
            while ( isdigit( pStartChar[ulOffset] ) && 
                    ulOffset < ulTokenLen )
            {
                ulCount++;
                ulOffset++;
            }
            if ( ulOffset != ulTokenLen &&
                 !( pStartChar[ulOffset] == wcDecimalPoint  ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'-'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    toupper( pStartChar[ulOffset] ) == L'S' ||
                    toupper( pStartChar[ulOffset] ) == L'N' ||
                    toupper( pStartChar[ulOffset] ) == L'R' ||
                    toupper( pStartChar[ulOffset] ) == L'T' ) )
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            //--- Separators.  Pattern must be { d(1-3)[,ddd]+ }, so make sure the separators match up 
            while ( SUCCEEDED( hr )                     && 
                    pStartChar[ulOffset] == wcSeparator && 
                    ( ulOffset + 3 ) < ulTokenLen)
            {
                ulOffset++;
                for ( i = ulOffset + 3; SUCCEEDED( hr ) && ulOffset < i; ulOffset++ )
                {
                    if ( isdigit( pStartChar[ulOffset] ) )
                    {
                        ulCount++;
                    }
                    else // Some non-digit character found - abort!
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }
            if ( ulOffset != ulTokenLen && 
                 !( pStartChar[ulOffset] == wcDecimalPoint  ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'-'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    toupper( pStartChar[ulOffset] ) == L'S' ||
                    toupper( pStartChar[ulOffset] ) == L'N' ||
                    toupper( pStartChar[ulOffset] ) == L'R' ||
                    toupper( pStartChar[ulOffset] ) == L'T' ) )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        pIntegerInfo = (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo ), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pIntegerInfo, sizeof( TTSIntegerItemInfo ) );
            pIntegerInfo->fSeparators = fSeparators;
            pIntegerInfo->lLeftOver   = ulCount % 3;
            pIntegerInfo->lNumGroups  = ( ulCount - 1 ) / 3;
            pIntegerInfo->pStartChar  = pStartChar;
            pIntegerInfo->pEndChar    = pStartChar + ulOffset;
        }
    }

    return hr;
} /* IsInteger */

/***********************************************************************************************
* ExpandInteger *
*---------------*
*   Description:
*       
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandInteger( TTSIntegerItemInfo* pItemInfo, const WCHAR* Context, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandInteger" );

    //--- Local variable declarations and initialization
    BOOL bFinished = false;
    const WCHAR *pStartChar = pItemInfo->pStartChar, *pEndChar = pItemInfo->pEndChar;
    ULONG ulOffset = 0, ulTokenLen = (ULONG)(pEndChar - pStartChar), ulTemp = (ULONG)(pItemInfo->lNumGroups + 1);

    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Out of range integer, or integer beginning with one or more zeroes...
    if ( pStartChar[0] == L'0'                          || 
         ( Context &&
           _wcsicmp( Context, L"NUMBER_DIGIT" ) == 0 )   ||
         pItemInfo->lNumGroups >= sp_countof(g_quantifiers) )
    {
        pItemInfo->fDigitByDigit = true;
        pItemInfo->ulNumDigits   = 0;

        for ( ULONG i = 0; i < ulTokenLen; i++ )
        {
            if ( isdigit( pStartChar[i] ) )
            {
                ExpandDigit( pStartChar[i], pItemInfo->Groups[0], WordList );
                pItemInfo->ulNumDigits++;
            }
        }
    }
    //--- Expanding a number < 1000 
    else if ( pItemInfo->lNumGroups == 0 )
    {
        // 0th through 999th...
        if ( pItemInfo->fOrdinal )
        {
            switch ( pItemInfo->lLeftOver )
            {
            case 1:
                // 0th through 9th...
                ExpandDigitOrdinal( pStartChar[ulOffset], pItemInfo->Groups[0], WordList );
                break;
            case 2:
                // 10th through 99th...
                ExpandTwoOrdinal( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                break;
            case 0:
                // 100th through 999th...
                ExpandThreeOrdinal( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                break;
            case -1:
                ulTemp = 0;
                pItemInfo->lLeftOver = 0;
                break;
            }
        }
        // 0 through 999...
        else
        {
            switch ( pItemInfo->lLeftOver )
            {
            case 1:
                // 0 through 9...
                ExpandDigit( pStartChar[ulOffset], pItemInfo->Groups[0], WordList );
                ulOffset += 1;
                break;
            case 2:
                // 10 through 99...
                ExpandTwoDigits( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                ulOffset += 2;
                break;
            case 0:
                // 100 through 999...
                ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                ulOffset += 3;
                break;
            case -1:
                ulTemp = 0;
                pItemInfo->lLeftOver = 0;
                break;
            }
        }
    } 
    else
    {
        //--- 1000 through highest number covered, e.g. 1,234,567 

        //--- Expand first grouping, e.g. 1 million 
        //--- Expand digit group 
        switch ( pItemInfo->lLeftOver )
        {
        case 1:
            ExpandDigit( pStartChar[ulOffset], pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 1;
            break;
        case 2:
            ExpandTwoDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 2;
            break;
        case 0:
            ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
            break;
        } 
        //--- Special Case: rare ordinal cases - e.g. 1,000,000th 
        if ( pItemInfo->fOrdinal    &&
             Zeroes(pStartChar + ulOffset) )
        {
            //--- Insert ordinal quantifier 
            pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
            Word.pWordText  = g_quantifiersOrdinal[pItemInfo->lNumGroups].pStr;
            Word.ulWordLen  = g_quantifiersOrdinal[pItemInfo->lNumGroups--].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            bFinished = true;
        }
        //--- Default Case 
        else
        {
            //--- Insert quantifier
            pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
            Word.pWordText  = g_quantifiers[pItemInfo->lNumGroups].pStr;
            Word.ulWordLen  = g_quantifiers[pItemInfo->lNumGroups--].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }

        //--- Expand rest of groupings which need to be followed by a quantifier 
        while ( pItemInfo->lNumGroups > 0 && 
                !bFinished )
        {
            if ( pItemInfo->fSeparators )
            {
                ulOffset++;
            }
            //--- Expand digit group 
            ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
            //--- Special case: rare ordinal cases, e.g. 1,234,000th 
            if ( pItemInfo->fOrdinal    && 
                 Zeroes( pStartChar + ulOffset ) )
            {
                //--- Insert ordinal quantifier 
                pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
                Word.pWordText  = g_quantifiersOrdinal[pItemInfo->lNumGroups].pStr;
                Word.ulWordLen  = g_quantifiersOrdinal[pItemInfo->lNumGroups--].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                bFinished = true;
            }
            //--- Default Case 
            else if ( !ThreeZeroes( pStartChar + ulOffset - 3 ) )
            {
                //--- Insert quantifier
                pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
                Word.pWordText  = g_quantifiers[pItemInfo->lNumGroups].pStr;
                Word.ulWordLen  = g_quantifiers[pItemInfo->lNumGroups--].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            //--- Special Case: this grouping is all zeroes, e.g. 1,000,567 
            else
            {
                pItemInfo->lNumGroups--;
            }
        }

        //--- Expand final grouping, which requires no quantifier 
        if ( pItemInfo->fSeparators  && 
             !bFinished )
        {
            ulOffset++;
        }

        if ( pItemInfo->fOrdinal    &&
             !bFinished )
        {
            ExpandThreeOrdinal( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
        }
        else if ( !bFinished )
        {
            ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
        }
    }
    pItemInfo->lNumGroups = (long) ulTemp;
} /* ExpandInteger */

/***********************************************************************************************
* IsDigitString *
*---------------*
*   Description:
*       Helper for IsNumber, IsPhoneNumber, etc. which matches a digit string...
*
*   RegExp:
*       d+
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsDigitString( const WCHAR* pStartChar, TTSDigitsItemInfo*& pDigitsInfo,
                                     CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    ULONG ulOffset = 0;

    while ( pStartChar + ulOffset < m_pEndOfCurrItem &&
            isdigit( pStartChar[ulOffset] ) )
    {
        ulOffset++;
    }

    if ( ulOffset )
    {
        pDigitsInfo = (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof( TTSDigitsItemInfo ), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pDigitsInfo, sizeof( pDigitsInfo ) );
            pDigitsInfo->pFirstDigit = pStartChar;
            pDigitsInfo->ulNumDigits = ulOffset;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsDigitString */

/***********************************************************************************************
* ExpandDigits *
*--------------*
*   Description:
*       Expands a string of digits, digit by digit.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandDigits( TTSDigitsItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDigits" );
    
    for ( ULONG i = 0; i < pItemInfo->ulNumDigits; i++ )
    {
        NumberGroup Garbage;
        ExpandDigit( pItemInfo->pFirstDigit[i], Garbage, WordList );
    }
} /* ExpandDigits */

/***********************************************************************************************
* IsFraction *
*------------*
*   Description:
*       Helper for IsNumber which matches a fraction...
*
*   RegExp:
*       { NUM_CARDINAL || NUM_DECIMAL } / { NUM_CARDINAL || NUM_DECIMAL }
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsFraction( const WCHAR* pStartChar, TTSFractionItemInfo*& pFractionInfo, 
                                  CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsFraction" );

    HRESULT hr = S_OK;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - pStartChar);

    if ( ulTokenLen )
    {
        //--- Check for Vulgar Fraction
        if ( pStartChar[0] == L'' ||
             pStartChar[0] == L'' ||
             pStartChar[0] == L'' )
        {
            pFractionInfo = (TTSFractionItemInfo*) MemoryManager.GetMemory( sizeof( TTSFractionItemInfo ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( pFractionInfo, sizeof( TTSFractionItemInfo ) );
                pFractionInfo->pVulgar      = pStartChar;
                pFractionInfo->pNumerator   = 
                    (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pFractionInfo->pNumerator, sizeof( TTSNumberItemInfo ) );
                    pFractionInfo->pDenominator = 
                        (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pFractionInfo->pDenominator, sizeof( TTSNumberItemInfo ) );
                        pFractionInfo->pNumerator->pIntegerPart =
                            (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( pFractionInfo->pNumerator->pIntegerPart, sizeof( TTSIntegerItemInfo ) );
                            pFractionInfo->pDenominator->pIntegerPart =
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo ), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( pFractionInfo->pDenominator->pIntegerPart, sizeof( TTSIntegerItemInfo ) );
                                pFractionInfo->fIsStandard                                  = false;
                                pFractionInfo->pNumerator->pIntegerPart->lLeftOver          = 1;
                                pFractionInfo->pNumerator->pIntegerPart->lNumGroups         = 1;
                                pFractionInfo->pNumerator->pIntegerPart->Groups[0].fOnes    = true;
                                pFractionInfo->pDenominator->pIntegerPart->lLeftOver        = 1;
                                pFractionInfo->pDenominator->pIntegerPart->lNumGroups       = 1;
                                pFractionInfo->pDenominator->pIntegerPart->Groups[0].fOnes  = true;
                            }
                        }
                    }
                }
            }
        }
        //--- Check for multi-character fraction
        else
        {
            TTSItemInfo *pNumeratorInfo = NULL, *pDenominatorInfo = NULL;
            const WCHAR* pTempNextChar = m_pNextChar, *pTempEndOfCurrItem = m_pEndOfCurrItem;
            m_pNextChar = pStartChar;
            m_pEndOfCurrItem = wcschr( pStartChar, L'/' );
            if ( !m_pEndOfCurrItem ||
                 m_pEndOfCurrItem >= pTempEndOfCurrItem )
            {
                hr = E_INVALIDARG;
            }

            //--- Try to get numerator
            if ( SUCCEEDED( hr ) )
            {
                hr = IsNumber( pNumeratorInfo, L"NUMBER", MemoryManager, false );
            }
            if ( SUCCEEDED( hr ) &&
                 pNumeratorInfo->Type != eNUM_MIXEDFRACTION &&
                 pNumeratorInfo->Type != eNUM_FRACTION      &&
                 pNumeratorInfo->Type != eNUM_ORDINAL )
            {
                if ( ( (TTSNumberItemInfo*) pNumeratorInfo )->pIntegerPart )
                {
                    m_pNextChar += ( (TTSNumberItemInfo*) pNumeratorInfo )->pIntegerPart->pEndChar -
                                   ( (TTSNumberItemInfo*) pNumeratorInfo )->pIntegerPart->pStartChar;
                }
                if ( ( (TTSNumberItemInfo*) pNumeratorInfo )->pDecimalPart )
                {
                    m_pNextChar += ( (TTSNumberItemInfo*) pNumeratorInfo )->pDecimalPart->ulNumDigits + 1;
                }
            }
            else if ( SUCCEEDED( hr ) )
            {
                delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
                hr = E_INVALIDARG;
            }
            m_pEndOfCurrItem = pTempEndOfCurrItem;

            //--- Try to get denominator
            if ( SUCCEEDED( hr ) &&
                 m_pNextChar[0] == L'/' )
            {
                m_pNextChar++;
                hr = IsNumber( pDenominatorInfo, L"NUMBER", MemoryManager, false );
                if ( SUCCEEDED( hr ) &&
                     pDenominatorInfo->Type != eNUM_MIXEDFRACTION &&
                     pDenominatorInfo->Type != eNUM_FRACTION      &&
                     pDenominatorInfo->Type != eNUM_ORDINAL )
                {
                    pFractionInfo = 
                        ( TTSFractionItemInfo*) MemoryManager.GetMemory( sizeof( TTSFractionItemInfo ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pFractionInfo, sizeof( TTSFractionItemInfo ) );
                        pFractionInfo->pNumerator   = (TTSNumberItemInfo*) pNumeratorInfo;
                        pFractionInfo->pDenominator = (TTSNumberItemInfo*) pDenominatorInfo;
                        pFractionInfo->pVulgar      = NULL;
                        pFractionInfo->fIsStandard  = false;
                    }
                }
                else if ( SUCCEEDED( hr ) )
                {
                    delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
                    delete ( (TTSNumberItemInfo*) pDenominatorInfo )->pWordList;
                    hr = E_INVALIDARG;
                }
                else
                {
                    delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
                }
            }
            else if ( SUCCEEDED( hr ) )
            {
                hr = E_INVALIDARG;
                delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
            }

            m_pNextChar = pTempNextChar;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsFraction */

/***********************************************************************************************
* ExpandFraction *
*----------------*
*   Description:
*       Expands Items previously determined to be of type NUM_FRACTION by IsFraction.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandFraction( TTSFractionItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandFraction" );

    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Special case - vulgar fractions ( , ,  )
    if ( pItemInfo->pVulgar )
    {
        if ( pItemInfo->pVulgar[0] == L'' )
        {
            Word.pWordText  = g_ones[1].pStr;
            Word.ulWordLen  = g_ones[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            Word.pWordText  = g_onesOrdinal[4].pStr;
            Word.ulWordLen  = g_onesOrdinal[4].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else if ( pItemInfo->pVulgar[0] == L'' )
        {
            Word.pWordText  = g_ones[1].pStr;
            Word.ulWordLen  = g_ones[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            Word.pWordText  = g_Half.pStr;
            Word.ulWordLen  = g_Half.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else
        {
            Word.pWordText  = g_ones[3].pStr;
            Word.ulWordLen  = g_ones[3].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            Word.pWordText  = g_PluralDenominators[4].pStr;
            Word.ulWordLen  = g_PluralDenominators[4].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
    }
    else
    {
        //--- Insert Numerator WordList
        WordList.AddTail( pItemInfo->pNumerator->pWordList );

        delete pItemInfo->pNumerator->pWordList;

        //--- Expand denominator ---//

        //--- If no decimal part, must check for special cases ( x/2 - x/9, x/10, x/100 )
        if ( !pItemInfo->pDenominator->pDecimalPart &&
             !pItemInfo->pNumerator->pDecimalPart   &&
             !pItemInfo->pDenominator->fNegative )
        {
            //--- Check for special cases - halves through ninths 
            if ( ( pItemInfo->pDenominator->pEndChar - 
                   pItemInfo->pDenominator->pStartChar ) == 1 &&
                 pItemInfo->pDenominator->pStartChar[0] != L'1' )
            { 
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    if ( pItemInfo->pDenominator->pStartChar[0] == L'2' )
                    {
                        Word.pWordText  = g_Half.pStr;
                        Word.ulWordLen  = g_Half.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );
                    }
                    else
                    {
                        ExpandDigitOrdinal( pItemInfo->pDenominator->pStartChar[0], 
                                            pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                    }
                }
                //--- Insert plural form of denominator 
                else 
                {
                    ULONG index     = pItemInfo->pDenominator->pStartChar[0] - L'0';
                    Word.pWordText  = g_PluralDenominators[index].pStr;
                    Word.ulWordLen  = g_PluralDenominators[index].Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            //--- Check for special case - tenths 
            else if ( ( pItemInfo->pDenominator->pEndChar -
                       pItemInfo->pDenominator->pStartChar ) == 2 &&
                      wcsncmp( pItemInfo->pDenominator->pStartChar, L"10", 2 ) == 0 )
            {
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    ExpandTwoOrdinal( pItemInfo->pDenominator->pStartChar, 
                                      pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                }
                //--- Insert plural form denominator 
                else
                {
                    Word.pWordText  = g_Tenths.pStr;
                    Word.ulWordLen  = g_Tenths.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            //--- Check for special case - sixteenths
            else if ( ( pItemInfo->pDenominator->pEndChar -
                       pItemInfo->pDenominator->pStartChar ) == 2 &&
                      wcsncmp( pItemInfo->pDenominator->pStartChar, L"16", 2 ) == 0 )
            {
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    ExpandTwoOrdinal( pItemInfo->pDenominator->pStartChar, 
                                      pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                }
                //--- Insert plural form denominator 
                else
                {
                    Word.pWordText  = g_Sixteenths.pStr;
                    Word.ulWordLen  = g_Sixteenths.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            //--- Check for special case - hundredths 
            else if ( ( pItemInfo->pDenominator->pEndChar - 
                        pItemInfo->pDenominator->pStartChar ) == 3 &&
                      wcsncmp( pItemInfo->pDenominator->pStartChar, L"100", 3 ) == 0 )
            {
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    ExpandThreeOrdinal( pItemInfo->pDenominator->pStartChar,
                                        pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                }
                //--- Insert plural form of denominator 
                else
                {
                    Word.pWordText  = g_Hundredths.pStr;
                    Word.ulWordLen  = g_Hundredths.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            else
            {
                pItemInfo->fIsStandard = true;
            }
        }
        else
        {
            pItemInfo->fIsStandard = true;
        }

        //--- Default case - Numerator "over" Denominator 
        if ( pItemInfo->fIsStandard )
        {
            //--- Insert "over" 
            Word.pWordText  = g_Over.pStr;
            Word.ulWordLen  = g_Over.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert denominator WordList
            WordList.AddTail( pItemInfo->pDenominator->pWordList );
        }

        delete pItemInfo->pDenominator->pWordList;
    }
    return hr;
} /* ExpandFraction */

/***********************************************************************************************
* ExpandDigit *
*-------------*
*   Description:
*       Expands single digits into words, and inserts them into WordList
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandDigit( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDigit" );
    SPDBG_ASSERT( isdigit(Number) );

    // 0-9
    ULONG Index = Number - L'0';
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.pWordText          = g_ones[Index].pStr;
    Word.ulWordLen          = g_ones[Index].Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    Word.eWordPartOfSpeech  = MS_Unknown;
    WordList.AddTail( Word );
    NormGroupInfo.fOnes = true;
} /* ExpandDigit */

/***********************************************************************************************
* ExpandTwo *
*-----------*
*   Description:
*       Expands two digit strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandTwoDigits( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandTwoDigits" );
    SPDBG_ASSERT( NumberString              &&
                  wcslen(NumberString) >= 2 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1]) ); 

    // 10-99
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';
    ULONG IndexTwo = NumberString[1] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 1 )
    {
        // 20-99, or 00-09
        if (IndexOne != 0)
        {
            Word.pWordText  = g_tens[IndexOne].pStr;
            Word.ulWordLen  = g_tens[IndexOne].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            NormGroupInfo.fTens = true;
        }
        if ( IndexTwo != 0 )
        {
            ExpandDigit( NumberString[1], NormGroupInfo, WordList );
            NormGroupInfo.fOnes = true;
        }
    } 
    else 
    {
        // 10-19
        Word.pWordText  = g_teens[IndexTwo].pStr;
        Word.ulWordLen  = g_teens[IndexTwo].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        NormGroupInfo.fOnes = true;
    }
} /* ExpandTwo */

/***********************************************************************************************
* ExpandThree *
*-------------*
*   Description:
*       Expands three digit strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandThreeDigits( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandThreeDigits" );
    SPDBG_ASSERT( NumberString              && 
                  wcslen(NumberString) >= 3 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1])  && 
                  isdigit(NumberString[2]) ); 

    // 100-999
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 0 )
    {
        // Take care of hundreds...
        ExpandDigit( NumberString[0], NormGroupInfo, WordList );
        Word.pWordText  = g_quantifiers[0].pStr;
        Word.ulWordLen  = g_quantifiers[0].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        NormGroupInfo.fHundreds = true;
        NormGroupInfo.fOnes = false;
    }
    
    // Take care of tens and ones...
    ExpandTwoDigits( NumberString + 1, NormGroupInfo, WordList );

} /* ExpandThree */

/***********************************************************************************************
* ExpandDigitOrdinal *
*--------------------*
*   Description:
*       Expands single digit ordinal strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandDigitOrdinal( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDigitOrdinal" );
    SPDBG_ASSERT( isdigit(Number) );

    // 0-9
    ULONG Index = Number - L'0';
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.pWordText          = g_onesOrdinal[Index].pStr;
    Word.ulWordLen          = g_onesOrdinal[Index].Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    Word.eWordPartOfSpeech  = MS_Unknown;
    WordList.AddTail( Word );
    NormGroupInfo.fOnes = true;
} /* ExpandDigitOrdinal */

/***********************************************************************************************
* ExpandTwoOrdinal *
*------------------*
*   Description:
*       Expands two digit ordinal strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandTwoOrdinal( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandTwoOrdinal" );
    SPDBG_ASSERT( NumberString              &&
                  wcslen(NumberString) >= 2 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1]) ); 

    // 10-99
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';
    ULONG IndexTwo = NumberString[1] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 1 )
    {
        // 20-99, or 00-09
        if (IndexOne != 0)
        {
            if ( IndexTwo != 0 )
            {
                Word.pWordText  = g_tens[IndexOne].pStr;
                Word.ulWordLen  = g_tens[IndexOne].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                NormGroupInfo.fTens = true;
                ExpandDigitOrdinal( NumberString[1], NormGroupInfo, WordList );
                NormGroupInfo.fOnes = true;
            }
            else
            {
                Word.pWordText  = g_tensOrdinal[IndexOne].pStr;
                Word.ulWordLen  = g_tensOrdinal[IndexOne].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
        }
        else
        {
            ExpandDigitOrdinal( NumberString[1], NormGroupInfo, WordList );
        }
    } 
    else 
    {
        // 10-19
        Word.pWordText  = g_teensOrdinal[IndexTwo].pStr;
        Word.ulWordLen  = g_teensOrdinal[IndexTwo].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        NormGroupInfo.fOnes = true;
    }
} /* ExpandTwoOrdinal */

/***********************************************************************************************
* ExpandThreeOrdinal *
*--------------------*
*   Description:
*       Expands three digit ordinal strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandThreeOrdinal( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandThreeDigits" );
    SPDBG_ASSERT( NumberString              && 
                  wcslen(NumberString) >= 3 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1])  && 
                  isdigit(NumberString[2]) ); 

    // 100-999
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 0 )
    {
        ExpandDigit( NumberString[0], NormGroupInfo, WordList );
        //--- Special case - x hundredth
        if ( Zeroes( NumberString + 1 ) )
        {
            Word.pWordText  = g_quantifiersOrdinal[0].pStr;
            Word.ulWordLen  = g_quantifiersOrdinal[0].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            NormGroupInfo.fHundreds = true;
            NormGroupInfo.fOnes = false;
        }
        //--- Default case - x hundred yth
        else
        {
            Word.pWordText  = g_quantifiers[0].pStr;
            Word.ulWordLen  = g_quantifiers[0].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            ExpandTwoOrdinal( NumberString + 1, NormGroupInfo, WordList );
            NormGroupInfo.fHundreds = true;
        }
    }
    //--- Special case - no hundreds
    else
    {
        ExpandTwoOrdinal( NumberString + 1, NormGroupInfo, WordList );
    }
} /* ExpandThreeOrdinal */

/***********************************************************************************************
* MatchQuantifier *
*-----------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a numerical quantifier.
********************************************************************* AH **********************/
int MatchQuantifier( const WCHAR*& pStartChar, const WCHAR*& pEndChar )
{
    int Index = -1;

    for (int i = 0; i < sp_countof(g_quantifiers); i++)
    {
        if ( pEndChar - pStartChar >= g_quantifiers[i].Len &&
             wcsnicmp( pStartChar, g_quantifiers[i].pStr, g_quantifiers[i].Len ) == 0 )
        {
            pStartChar += g_quantifiers[i].Len;
            Index = i;
            break;
        }
    }

    return Index;
} /* MatchQuantifier */

/***********************************************************************************************
* IsCurrency *
*------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a currency.  
*
*   RegExp:
*       { [CurrencySign] { d+ || d(1-3)[,ddd]+ } { [.]d+ }? } { [whitespace] [quantifier] }? ||
*       { { d+ || d(1-3)[,ddd]+ } { [.]d+ }? { [whitespace] [quantifier] }? [whitespace]? [CurrencySign] }
*
*   Types assigned:
*       NUM_CURRENCY
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsCurrency( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                  CWordList& WordList )
{
    SPDBG_FUNC( "NumNorm IsCurrency" );

    HRESULT hr = S_OK;

    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem, *pTempEndChar = m_pEndChar;
    const SPVTEXTFRAG* pTempFrag = m_pCurrFrag;

    const SPVSTATE *pNumberXMLState = NULL, *pSymbolXMLState = NULL, *pQuantifierXMLState = NULL;
    CItemList PostNumberList, PostSymbolList;
    int iSymbolIndex = -1, iQuantIndex = -1;    
    TTSItemInfo* pNumberInfo = NULL;
    BOOL fDone = false, fNegative = false;
    WCHAR wcDecimalPoint = ( m_eSeparatorAndDecimal == COMMA_PERIOD ? L'.' : L',' );

    //--- Try to match [CurrencySign] [Number] [Quantifier]
    NORM_POSITION ePosition = UNATTACHED;
    if ( m_pNextChar[0] == L'-' )
    {
        fNegative = true;
        m_pNextChar++;
    }
    iSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );
    if ( iSymbolIndex >= 0 &&
         ePosition == PRECEDING )
    {
        pSymbolXMLState = &m_pCurrFrag->State;

        //--- Skip any whitespace in between the currency sign and the number...
        hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostSymbolList );
    
        if ( !m_pNextChar )
        {
            hr = E_INVALIDARG;
        }

        if ( SUCCEEDED( hr ) )
        {
            m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
            while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                    IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                    IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                    IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
            {
                fDone = true;
                m_pEndOfCurrItem--;
            }
        }

        //--- Try to match a number string 
        if ( SUCCEEDED( hr ) )
        {
            hr = IsNumberCategory( pNumberInfo, L"NUMBER", MemoryManager );
            if ( SUCCEEDED( hr ) )
            {
                if ( pNumberInfo->Type != eNUM_CARDINAL &&
                     pNumberInfo->Type != eNUM_DECIMAL  &&
                     pNumberInfo->Type != eNUM_FRACTION &&
                     pNumberInfo->Type != eNUM_MIXEDFRACTION )
                {
                    hr = E_INVALIDARG;
                }
                else
                {
                    pNumberXMLState = &m_pCurrFrag->State;
                }
            }

            //--- Skip any whitespace in between the number and the quantifier...
            if ( !fDone &&
                 SUCCEEDED( hr ) )
            {
                const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar;
                const WCHAR *pTempEndOfItem = m_pEndOfCurrItem;
                const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

                m_pNextChar = m_pEndOfCurrItem;
                hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostNumberList );

                if ( m_pNextChar &&
                     SUCCEEDED( hr ) )
                {
                    m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                    while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
                    {
                        m_pEndOfCurrItem--;
                    }

                    //--- Try to match a quantifier
                    iQuantIndex = MatchQuantifier( m_pNextChar, m_pEndOfCurrItem );
                    if ( iQuantIndex >= 0 )
                    {
                        pQuantifierXMLState = &m_pCurrFrag->State;
                    }
                    else
                    {
                        m_pNextChar      = pTempNextChar;
                        m_pEndChar       = pTempEndChar;
                        m_pEndOfCurrItem = pTempEndOfItem;
                        m_pCurrFrag      = pTempFrag;
                    }
                }
                else
                {
                    m_pNextChar      = pTempNextChar;
                    m_pEndChar       = pTempEndChar;
                    m_pEndOfCurrItem = pTempEndOfItem;
                    m_pCurrFrag      = pTempFrag;
                }
            }
        }
    }
    //--- Try to match [Number] [CurrencySign] [Quantifier]
    else 
    {
        //--- Try to match a number string
        hr = IsNumberCategory( pNumberInfo, L"NUMBER", MemoryManager );
        if ( SUCCEEDED( hr ) )
        {
            if ( pNumberInfo->Type != eNUM_CARDINAL &&
                 pNumberInfo->Type != eNUM_DECIMAL  &&
                 pNumberInfo->Type != eNUM_FRACTION &&
                 pNumberInfo->Type != eNUM_MIXEDFRACTION )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                pNumberXMLState = &m_pCurrFrag->State;
            }
        }

        //--- Skip any whitespace and XML markup between the number and the currency sign
        if ( SUCCEEDED( hr ) )
        {
            m_pNextChar = m_pEndOfCurrItem;
            hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostNumberList );

            if ( !m_pNextChar )
            {
                hr = E_INVALIDARG;
            }

            if ( SUCCEEDED( hr ) )
            {
                m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                        IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                        IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                        IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
                {
                    m_pEndOfCurrItem--;
                    fDone = true;
                }
            }
        }

        //--- Try to match a Currency Sign
        if ( SUCCEEDED( hr ) )
        {
            iSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );
            if ( iSymbolIndex >= 0 )
            {
                pSymbolXMLState = &m_pCurrFrag->State;
            }

            //--- Skip any whitespace in between the currency sign and the quantifier
            if ( !fDone &&
                 iSymbolIndex >= 0 )
            {
                const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar;
                const WCHAR *pTempEndOfItem = m_pEndOfCurrItem;
                const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

                hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostSymbolList );

                if ( !m_pNextChar )
                {
                    m_pNextChar      = pTempNextChar;
                    m_pEndChar       = pTempEndChar;
                    m_pEndOfCurrItem = pTempEndOfItem;
                    m_pCurrFrag      = pTempFrag;
                    fDone = true;
                }

                if ( !fDone &&
                     SUCCEEDED( hr ) )
                {
                    m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                    while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
                    {
                        fDone = true;
                        m_pEndOfCurrItem--;
                    }

                    //--- Try to match quantifier
                    iQuantIndex = MatchQuantifier( m_pNextChar, m_pEndOfCurrItem );
                    if ( iQuantIndex >= 0 )
                    {
                        pQuantifierXMLState = &m_pCurrFrag->State;
                    }
                    else
                    {
                        m_pNextChar      = pTempNextChar;
                        m_pEndChar       = pTempEndChar;
                        m_pEndOfCurrItem = pTempEndOfItem;
                        m_pCurrFrag      = pTempFrag;
                    }
                }
            }
            else if ( iSymbolIndex < 0 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    //--- Successfully matched a currency!  Now expand it and fill out pItemNormInfo.
    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof(TTSWord) );
        Word.eWordPartOfSpeech = MS_Unknown;

        pItemNormInfo = (TTSCurrencyItemInfo*) MemoryManager.GetMemory( sizeof(TTSCurrencyItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            //--- Fill in known parts of pItemNormInfo
            ZeroMemory( pItemNormInfo, sizeof(TTSCurrencyItemInfo) );
            pItemNormInfo->Type = eNUM_CURRENCY;
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->fQuantifier           = iQuantIndex >= 0 ? true : false;
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart    = (TTSNumberItemInfo*) pNumberInfo;
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->lNumPostNumberStates  = PostNumberList.GetCount();
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->lNumPostSymbolStates  = PostSymbolList.GetCount();

            //--- Need to determine whether this currency will have a primary and secondary part
            //---   (e.g. "ten dollars and fifty cents") or just a primary part (e.g. "ten point
            //---   five zero cents", "one hundred dollars").

            //--- First check whether the number is a cardinal, there is a quantifier present, or the
            //---   currency unit has no secondary (e.g. cents).  In any of these cases, we need do no
            //---   further checking.
            if ( pNumberInfo->Type == eNUM_DECIMAL &&
                 iQuantIndex       == -1                &&
                 g_CurrencySigns[iSymbolIndex].SecondaryUnit.Len > 0 )
            {
                WCHAR *pDecimalPoint = wcschr( ( (TTSNumberItemInfo*) pNumberInfo )->pStartChar, wcDecimalPoint );
                SPDBG_ASSERT( pDecimalPoint );

                if ( pDecimalPoint &&
                     ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar - pDecimalPoint == 3 )
                {
                    //--- We do have a secondary part!  Fix up PrimaryNumberPart appropriately,
                    //---   and fill in pSecondaryNumberPart.
                    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
                    const WCHAR *pTemp = ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar;
                    m_pNextChar      = ( (TTSNumberItemInfo*) pNumberInfo )->pStartChar;
                    m_pEndOfCurrItem = pDecimalPoint;
                    delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
                    
                    //--- m_pNextChar == m_pEndOfCurrItem when integer part is empty and non-negative, e.g. $.50
                    //---   Other case is empty and negative, e.g. $-.50
                    if ( m_pNextChar != m_pEndOfCurrItem &&
                         !( *m_pNextChar == L'-' &&
                             m_pNextChar == m_pEndOfCurrItem - 1 ) )
                    {
                        hr = IsNumber( pNumberInfo, L"NUMBER", MemoryManager, false );
                    }
                    else
                    {
                        pNumberInfo = (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( pNumberInfo, sizeof( TTSNumberItemInfo ) );
                            if ( *m_pNextChar == L'-' )
                            {
                                ( (TTSNumberItemInfo*) pNumberInfo )->fNegative = true;
                            }
                            else
                            {
                                ( (TTSNumberItemInfo*) pNumberInfo )->fNegative = false;
                            }
                            ( (TTSNumberItemInfo*) pNumberInfo )->pStartChar = NULL;
                            ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar   = NULL;
                            ( (TTSNumberItemInfo*) pNumberInfo )->pIntegerPart =
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ( (TTSNumberItemInfo*) pNumberInfo )->pIntegerPart->fDigitByDigit = true;
                                ( (TTSNumberItemInfo*) pNumberInfo )->pIntegerPart->ulNumDigits   = 1;
                                ( (TTSNumberItemInfo*) pNumberInfo )->pWordList = new CWordList;

                                if ( ( (TTSNumberItemInfo*) pNumberInfo )->fNegative )
                                {
                                    Word.pXmlState  = pNumberXMLState;
                                    Word.pWordText  = g_negative.pStr;
                                    Word.ulWordLen  = g_negative.Len;
                                    Word.pLemma     = Word.pWordText;
                                    Word.ulLemmaLen = Word.ulWordLen;
                                    ( (TTSNumberItemInfo*) pNumberInfo )->pWordList->AddTail( Word );
                                }

                                Word.pWordText  = g_ones[0].pStr;
                                Word.ulWordLen  = g_ones[0].Len;
                                Word.pLemma     = Word.pWordText;
                                Word.ulLemmaLen = Word.ulWordLen;
                                ( (TTSNumberItemInfo*) pNumberInfo )->pWordList->AddTail( Word );
                            }
                        }
                    }

                    if ( SUCCEEDED( hr ) )
                    {
                        ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart = 
                                                                        (TTSNumberItemInfo*) pNumberInfo;
                        m_pNextChar      = m_pEndOfCurrItem + 1;
                        m_pEndOfCurrItem = pTemp;
                        
                        //--- If zeroes, don't pronounce them...
                        if ( m_pNextChar[0] != L'0' )
                        {
                            hr = IsNumber( pNumberInfo, L"NUMBER", MemoryManager, false );
                            if ( SUCCEEDED( hr ) )
                            {
                                ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart = 
                                                                        (TTSNumberItemInfo*) pNumberInfo;
                            }
                        }
                        else if ( m_pNextChar[1] != L'0' )
                        {
                            m_pNextChar++;
                            hr = IsNumber( pNumberInfo, L"NUMBER", MemoryManager, false );
                            if ( SUCCEEDED( hr ) )
                            {
                                ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart =
                                                                        (TTSNumberItemInfo*) pNumberInfo;
                            }
                        }
                    }
                    m_pNextChar      = pTempNextChar;
                    m_pEndOfCurrItem = pTempEndOfItem;
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                //--- Expand Primary number part
                if ( fNegative )
                {
                    ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->fNegative = true;
                    Word.pXmlState          = pNumberXMLState;
                    Word.eWordPartOfSpeech  = MS_Unknown;
                    Word.pWordText          = g_negative.pStr;
                    Word.ulWordLen          = g_negative.Len;
                    Word.pLemma             = Word.pWordText;
                    Word.ulLemmaLen         = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
                hr = ExpandNumber( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart, WordList );
            }

            //--- Clean up Number XML States
            SPLISTPOS WordListPos;
            if ( SUCCEEDED( hr ) )
            {
                WordListPos = WordList.GetHeadPosition();
                while ( WordListPos )
                {
                    TTSWord& TempWord = WordList.GetNext( WordListPos );
                    TempWord.pXmlState = pNumberXMLState;
                }
            
                //--- Insert PostNumber XML States
                while ( !PostNumberList.IsEmpty() )
                {
                    WordList.AddTail( ( PostNumberList.RemoveHead() ).Words[0] );
                }

                //--- If a quantifier is present, expand it
                if ( iQuantIndex >= 0 )
                { 
                    Word.pXmlState  = pQuantifierXMLState;
                    Word.pWordText  = g_quantifiers[iQuantIndex].pStr;
                    Word.ulWordLen  = g_quantifiers[iQuantIndex].Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                BOOL fFraction = false;
                //--- If a fractional unit with no quantifier, insert "of a"
                if ( iQuantIndex < 0                                          &&
                     !( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart &&
                     !( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pIntegerPart    &&
                     ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pFractionalPart  &&
                     !( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pFractionalPart->fIsStandard )
                {
                    fFraction = true;
                    Word.pXmlState  = pNumberXMLState;
                    Word.eWordPartOfSpeech = MS_Unknown;
                    Word.pWordText  = g_of.pStr;
                    Word.ulWordLen  = g_of.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );

                    Word.pWordText  = g_a.pStr;
                    Word.ulWordLen  = g_a.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                //--- Insert Main Currency Unit
                //--- Plural if not a fraction and either a quantifier is present or the integral part is not one.
                if ( !fFraction &&
                     ( iQuantIndex >= 0 ||
                       ( ( ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pEndChar -
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar != 1 ) ||
                           ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar[0] != L'1' ) &&
                         ( ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pEndChar -
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar != 2 ) ||
                           ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar[0] != L'-' ||
                           ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar[1] != L'1' ) ) ) )
                {                     
                    Word.pXmlState  = pSymbolXMLState;
                    Word.pWordText  = g_CurrencySigns[iSymbolIndex].MainUnit.pStr;
                    Word.ulWordLen  = g_CurrencySigns[iSymbolIndex].MainUnit.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
                //--- ONLY "one" or "negative one" should precede this...
                else
                {
                    Word.pXmlState  = pSymbolXMLState;
                    Word.pWordText  = g_SingularPrimaryCurrencySigns[iSymbolIndex].pStr;
                    Word.ulWordLen  = g_SingularPrimaryCurrencySigns[iSymbolIndex].Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                //--- Insert Post Symbol XML States
                while ( !PostSymbolList.IsEmpty() )
                {
                    WordList.AddTail( ( PostSymbolList.RemoveHead() ).Words[0] );
                }

                //--- Insert Secondary number part
                if ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart )
                {
                    Word.pXmlState  = pNumberXMLState;
                    Word.pWordText  = g_And.pStr;
                    Word.ulWordLen  = g_And.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );

                    WordListPos = WordList.GetTailPosition();
                
                    hr = ExpandNumber( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart, WordList );

                    //--- Clean up number XML State
                    if ( SUCCEEDED( hr ) )
                    {
                        while ( WordListPos )
                        {
                            TTSWord& TempWord  = WordList.GetNext( WordListPos );
                            TempWord.pXmlState = pNumberXMLState;
                        }
                    }

                    //--- Insert secondary currency unit
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart->pEndChar -
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart->pStartChar == 1 &&
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart->pStartChar[0] == L'1' )
                        {
                            Word.pXmlState  = pSymbolXMLState;
                            Word.pWordText  = g_SingularSecondaryCurrencySigns[iSymbolIndex].pStr;
                            Word.ulWordLen  = g_SingularSecondaryCurrencySigns[iSymbolIndex].Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                        else
                        {
                            Word.pXmlState  = pSymbolXMLState;
                            Word.pWordText  = g_CurrencySigns[iSymbolIndex].SecondaryUnit.pStr;
                            Word.ulWordLen  = g_CurrencySigns[iSymbolIndex].SecondaryUnit.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                    }
                }

                if ( SUCCEEDED( hr ) )
                {
                    m_pNextChar = pTempNextChar;
                }
            }
        }
    }
    else
    {
        if ( pNumberInfo )
        {
            delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
        }
        m_pNextChar      = pTempNextChar;
        m_pEndChar       = pTempEndChar;
        m_pEndOfCurrItem = pTempEndOfItem;
        m_pCurrFrag      = pTempFrag;
    }

    return hr;
} /* IsCurrency */


/***********************************************************************************************
* IsRomanNumeral *
*----------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a fraction.  
*
*   RegExp:
*       [M](0-3) { [CM] || [CD] || { [D]?[C](0-3) } } { [XC] || [XL] || { [L]?[X](0-3) } }
*           { [IX] || [IV] || { [V]?[I](0-3) }}
*
*   Types assigned:
*       NUM_ROMAN_NUMERAL
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsRomanNumeral( TTSItemInfo*& pItemNormInfo, const WCHAR* Context,
                                      CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "NumNorm IsRomanNumeral" );

    HRESULT hr = S_OK;
    ULONG ulValue = 0, ulIndex = 0, ulMaxOfThree = 0, ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);

    //--- Match Thousands - M(0-3) 
    while ( ulIndex < ulTokenLen         && 
            towupper( m_pNextChar[ulIndex] ) == L'M' && 
            ulMaxOfThree < 3 )
    {
        ulValue += 1000;
        ulMaxOfThree++;
        ulIndex++;
    }
    if ( ulMaxOfThree > 3 )
    {
        hr = E_INVALIDARG;
    }

    //--- Match Hundreds - { [CM] || [CD] || { [D]?[C](0-3) } } 
    if ( SUCCEEDED( hr ) )
    {
        ulMaxOfThree = 0;
        //--- Matched C first 
        if ( ulIndex < ulTokenLen &&
             towupper( m_pNextChar[ulIndex] ) == L'C' )
        {
            ulValue += 100;
            ulMaxOfThree++;
            ulIndex++;
            //--- Special Case - CM = 900 
            if ( ulIndex < ulTokenLen &&
                 towupper( m_pNextChar[ulIndex] ) == L'M' )
            {
                ulValue += 800;
                ulIndex++;
            }
            //--- Special Case - CD = 400 
            else if ( ulIndex < ulTokenLen &&
                      towupper( m_pNextChar[ulIndex] ) == L'D' )
            {
                ulValue += 300;
                ulIndex++;
            }
            //--- Default Case 
            else 
            {
                while ( ulIndex < ulTokenLen &&
                        towupper( m_pNextChar[ulIndex] ) == L'C' &&
                        ulMaxOfThree < 3 )
                {
                    ulValue += 100;
                    ulMaxOfThree++;
                    ulIndex++;
                }
                if ( ulMaxOfThree > 3 )
                {
                    hr = E_INVALIDARG;
                }
            }
        }
        //--- Matched D First 
        else if ( ulIndex < ulTokenLen &&
                  towupper( m_pNextChar[ulIndex] ) == L'D' )
        {
            ulValue += 500;
            ulIndex++;
            ulMaxOfThree = 0;
            //--- Match C's 
            while ( ulIndex < ulTokenLen &&
                    towupper( m_pNextChar[ulIndex] ) == L'C' &&
                    ulMaxOfThree < 3 )
            {
                ulValue += 100;
                ulIndex++;
                ulMaxOfThree++;
            }
            if ( ulMaxOfThree > 3 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    //--- Match Tens - { [XC] || [XL] || { [L]?[X](0-3) } } 
    if ( SUCCEEDED( hr ) )
    {
        ulMaxOfThree = 0;
        //--- Matched X First 
        if ( ulIndex < ulTokenLen &&
             towupper( m_pNextChar[ulIndex] ) == L'X' )
        {
            ulValue += 10;
            ulMaxOfThree++;
            ulIndex++;
            //--- Special Case - XC = 90 
            if ( ulIndex < ulTokenLen &&
                 towupper( m_pNextChar[ulIndex] ) == L'C' )
            {
                ulValue += 80;
                ulIndex++;
            }
            //--- Special Case - XL = 40 
            else if ( ulIndex < ulTokenLen &&
                      towupper( m_pNextChar[ulIndex] ) == 'L' )
            {
                ulValue += 30;
                ulIndex++;
            }
            //--- Default Case 
            else
            {
                while ( ulIndex < ulTokenLen &&
                        towupper( m_pNextChar[ulIndex] ) == L'X' &&
                        ulMaxOfThree < 3 )
                {
                    ulValue += 10;
                    ulMaxOfThree ++;
                    ulIndex++;
                }
                if ( ulMaxOfThree > 3 )
                {
                    hr = E_INVALIDARG;
                }
            }
        }
        //--- Matched L First 
        else if ( ulIndex < ulTokenLen &&
                  towupper( m_pNextChar[ulIndex] ) == L'L' )
        {
            ulValue += 50;
            ulIndex++;
            //--- Match X's 
            while ( ulIndex < ulTokenLen &&
                    towupper( m_pNextChar[ulIndex] ) == L'X' &&
                    ulMaxOfThree < 3 )
            {
                ulValue += 10;
                ulMaxOfThree++;
                ulIndex++;
            }
            if ( ulMaxOfThree > 3 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    //--- Match Ones - { [IX] || [IV] || { [V]?[I](0-3) } } 
    if ( SUCCEEDED( hr ) )
    {
        ulMaxOfThree = 0;
        //--- Matched I First 
        if ( ulIndex < ulTokenLen &&
             towupper( m_pNextChar[ulIndex] ) == L'I' )
        {
            ulValue += 1;
            ulMaxOfThree++;
            ulIndex++;
            //--- Special Case - IX = 9 
            if ( ulIndex < ulTokenLen &&
                 towupper( m_pNextChar[ulIndex] ) == L'X' )
            {
                ulValue += 8;
                ulIndex++;
            }
            //--- Special Case - IV = 4 
            else if ( ulIndex < ulTokenLen &&
                      towupper( m_pNextChar[ulIndex] ) == L'V' )
            {
                ulValue += 3;
                ulIndex++;
            }
            //--- Default Case 
            else
            {
                while ( ulIndex < ulTokenLen &&
                        towupper( m_pNextChar[ulIndex] ) == L'I' &&
                        ulMaxOfThree < 3 )
                {
                    ulValue += 1;
                    ulMaxOfThree++;
                    ulIndex++;
                }
                if ( ulMaxOfThree > 3 )
                {
                    hr = E_INVALIDARG;
                }
            }
        }
        //--- Matched V First 
        else if ( ulIndex < ulTokenLen &&
                  towupper( m_pNextChar[ulIndex] ) == L'V' )
        {
            ulValue += 5;
            ulIndex++;
            //--- Match I's 
            while ( ulIndex < ulTokenLen &&
                    towupper( m_pNextChar[ulIndex] ) == L'I' &&
                    ulMaxOfThree < 3 )
            {
                ulValue += 1;
                ulMaxOfThree++;
                ulIndex++;
            }
            if ( ulMaxOfThree > 3 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    if ( ulIndex != ulTokenLen )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Successfully matched a roman numeral! 

        WCHAR *tempNumberString;
        //--- Max value of ulValue is 3999, so the resultant string cannot be more than
        //---     four characters long (plus one for the comma, just in case) 
        tempNumberString = (WCHAR*) MemoryManager.GetMemory( 6 * sizeof(WCHAR), &hr );
        if ( SUCCEEDED( hr ) )
        {
            TTSItemInfo *pNumberInfo = NULL;
            _ltow( (long) ulValue, tempNumberString, 10 );

            const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
            
            m_pNextChar      = tempNumberString;
            m_pEndOfCurrItem = tempNumberString + wcslen( tempNumberString );

            hr = IsNumber( pNumberInfo, Context, MemoryManager, false );

            m_pNextChar      = pTempNextChar;
            m_pEndOfCurrItem = pTempEndOfItem;

            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo = 
                    (TTSRomanNumeralItemInfo*) MemoryManager.GetMemory( sizeof( TTSRomanNumeralItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo = pNumberInfo;
                }
                pItemNormInfo->Type = eNUM_ROMAN_NUMERAL;
            }
        }
    }
    
    return hr;
} /* IsRomanNumeral */

/***********************************************************************************************
* IsPhoneNumber *
*---------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a phone number.  
*
*   RegExp:
*       { ddd-dddd } || { ddd-ddd-dddd }     
*
*   Types assigned:
*       NUM_PHONENUMBER
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsPhoneNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager, 
                                     CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsPhoneNumber" );

    HRESULT hr = S_OK;
    const WCHAR *pCountryCode = NULL, *pAreaCode = NULL, *pGroups[4] = { NULL, NULL, NULL, NULL };
    const WCHAR *pStartChar = m_pNextChar, *pEndChar = m_pEndChar, *pEndOfItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pFrag = m_pCurrFrag;
    BOOL fMatchedLeftParen = false, fMatchedOne = false;
    ULONG ulCountryCodeLen = 0, ulAreaCodeLen = 0, ulNumGroups = 0, ulGroupLen[4] = { 0, 0, 0, 0 };
    CItemList PostCountryCodeList, PostOneList, PostAreaCodeList, PostGroupLists[4];
    const SPVSTATE *pCountryCodeState = NULL, *pOneState = NULL, *pAreaCodeState = NULL;
    const SPVSTATE *pGroupStates[4] = { NULL, NULL, NULL, NULL };
    const WCHAR *pDelimiter = NULL;

    const WCHAR *pTempEndChar = NULL;
    const SPVTEXTFRAG *pTempFrag = NULL;
    
    ULONG i = 0;

    //--- Try to match Country Code
    if ( pStartChar[0] == L'+' )
    {
        pStartChar++;
        i = 0;

        //--- Try to match d(1-3)
        while ( pEndOfItem > pStartChar + i &&
                iswdigit( pStartChar[i] ) &&
                i < 3 )
        {
            i++;
        }

        pCountryCode      = pStartChar;
        pCountryCodeState = &pFrag->State;
        ulCountryCodeLen  = i;

        //--- Try to match delimiter
        if ( i >= 1                      &&
             pEndOfItem > pStartChar + i &&
             MatchPhoneNumberDelimiter( pStartChar[i] ) )
        {
            pDelimiter = pStartChar + i;
            pStartChar += i + 1;
        }
        //--- Try to advance in text - whitespace counts as a delimiter...
        else if ( i >= 1 &&
                  pEndOfItem == pStartChar + i )
        {
            pStartChar += i;
            pCountryCodeState = &pFrag->State;

            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                        &PostCountryCodeList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr       = E_INVALIDARG;
            }
            else if ( SUCCEEDED( hr ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Try to match a "1"
    if ( SUCCEEDED( hr )        &&
         !pCountryCode          &&
         pStartChar[0] == L'1'  &&
         !iswdigit( pStartChar[1] ) )
    {
        pOneState   = &pFrag->State;
        fMatchedOne = true;
        pStartChar++;

        if ( pEndOfItem > pStartChar &&
             MatchPhoneNumberDelimiter( pStartChar[0] ) )
        {
            //--- If we've already hit a delimiter, make sure all others agree
            if ( pDelimiter )
            {
                if ( *pDelimiter != pStartChar[0] )
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                pDelimiter = pStartChar;
            }
            pStartChar++;
        }
        //--- Try to advance in text - whitespace counts as a delimiter...
        else if ( !pDelimiter &&
                  pEndOfItem == pStartChar )
        {
            pOneState = &pFrag->State;

            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                        &PostOneList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr       = E_INVALIDARG;
            }
            else if ( SUCCEEDED( hr ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }    

    //--- Try to match Area Code
    if ( SUCCEEDED( hr ) &&
         pStartChar < pEndOfItem )
    {
        i = 0;

        //--- Try to match a left parenthesis
        if ( ( pCountryCode ||
               fMatchedOne )    &&
             pStartChar[0] == L'(' )
        {
            pStartChar++;
            fMatchedLeftParen = true;
        }
        else if ( !pCountryCode                      &&
                  !fMatchedOne                       &&
                  pStartChar > pFrag->pTextStart &&
                  *( pStartChar - 1 ) == L'(' )
        {
            fMatchedLeftParen = true;
        }
        
        if ( fMatchedLeftParen )
        {
            //--- Try to match ddd?
            while ( pEndOfItem > pStartChar + i &&
                    iswdigit( pStartChar[i] ) &&
                    i < 3 )
            {
                i++;
            }

            pAreaCodeState  = &pFrag->State;
            pAreaCode       = pStartChar;
            ulAreaCodeLen   = i;

            if ( i < 2 )
            {
                //--- Failed to match at least two digits
                hr = E_INVALIDARG;
            }
            else
            {
                if ( pStartChar[i] != L')' )
                {
                    //--- Matched left parenthesis without corresponding right parenthesis
                    hr = E_INVALIDARG;
                }
                else if ( ( !( pCountryCode || fMatchedOne ) &&
                            pEndOfItem > pStartChar + i ) ||
                          ( ( pCountryCode || fMatchedOne )  &&
                            pEndOfItem > pStartChar + i + 1 ) )
                {
                    i++;
                    //--- Delimiter is optional with parentheses
                    if ( MatchPhoneNumberDelimiter( pStartChar[i] ) )
                    {
                        //--- If we've already hit a delimiter, make sure all others agree
                        if ( pDelimiter )
                        {
                            if ( *pDelimiter != pStartChar[i] )
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                        else
                        {
                            pDelimiter = pStartChar + i;
                        }
                        i++;
                    }
                    pStartChar += i;
                }
                //--- Try to advance in text - whitespace counts as a delimiter...
                else if ( !pDelimiter )
                {
                    pStartChar += i + 1;
                    pAreaCodeState = &pFrag->State;

                    hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                                &PostAreaCodeList );
                    if ( !pStartChar &&
                         SUCCEEDED( hr ) )
                    {
                        hr       = E_INVALIDARG;
                    }
                    else if ( SUCCEEDED( hr ) )
                    {
                        pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
        }
    }

    //--- Try to match main number part
    if ( SUCCEEDED( hr ) &&
         pStartChar < pEndOfItem )
    {
        //--- Try to match some groups of digits
        for ( int j = 0; SUCCEEDED( hr ) && j < 4; j++ )
        {
            i = 0;

            //--- Try to match a digit string
            while ( pEndOfItem > pStartChar + i &&
                    iswdigit( pStartChar[i] ) &&
                    i < 4 )
            {
                i++;
            }

            //--- Try to match a delimiter
            if ( i >= 2 )
            {
                pGroupStates[j] = &pFrag->State;
                ulGroupLen[j]   = i;
                pGroups[j]      = pStartChar;
                pStartChar     += i;

                if ( pEndOfItem > pStartChar + 1 &&
                     MatchPhoneNumberDelimiter( pStartChar[0] ) )
                {
                    //--- If we've already hit a delimiter, make sure all others agree
                    if ( pDelimiter )
                    {
                        if ( *pDelimiter != pStartChar[0] )
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    //--- Only allow a new delimiter to be matched on the first main number group...
                    //---   e.g. "+45 35 32 90.89" should not all match...
                    else if ( j == 0 )
                    {
                        pDelimiter = pStartChar;
                    }
                    else
                    {
                        pEndChar = pTempEndChar;
                        pFrag    = pTempFrag;
                        ulNumGroups = j;
                        break;
                    }
                    pStartChar++;
                }
                //--- Try to advance in text - whitespace counts as a delimiter...
                else if ( !pDelimiter &&
                          pEndOfItem == pStartChar )
                {
                    pGroupStates[j] = &pFrag->State;

                    pTempEndChar = pEndChar;
                    pTempFrag    = pFrag;

                    hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                                &PostGroupLists[j] );
                    if ( !pStartChar &&
                         SUCCEEDED( hr ) )
                    {
                        pEndChar = pTempEndChar;
                        pFrag    = pTempFrag;
                        ulNumGroups = j + 1;
                        break;
                    }
                    else if ( SUCCEEDED( hr ) )
                    {
                        pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    }
                }
                else if ( pEndOfItem == pStartChar + 1 )
                {
                    if ( IsGroupEnding( *pStartChar )       != eUNMATCHED  ||
                         IsQuotationMark( *pStartChar )     != eUNMATCHED  ||
                         IsMiscPunctuation( *pStartChar )   != eUNMATCHED  ||
                         IsEOSItem( *pStartChar )           != eUNMATCHED )
                    {
                        pEndOfItem--;
                        ulNumGroups = j + 1;
                        break;
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    while ( pEndOfItem != pStartChar )
                    {
                        if ( IsGroupEnding( *pEndOfItem )       != eUNMATCHED  ||
                             IsQuotationMark( *pEndOfItem )     != eUNMATCHED  ||
                             IsMiscPunctuation( *pEndOfItem )   != eUNMATCHED  ||
                             IsEOSItem( *pEndOfItem )           != eUNMATCHED )
                        {
                            pEndOfItem--;
                        }
                        else
                        {
                            break;
                        }
                    }
                    if ( pEndOfItem == pStartChar )
                    {
                        ulNumGroups = j + 1;
                        break;
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                        break;
                    }
                }
            }
            //--- Matched something like 206.709.8286.1 - definitely bad
            else if ( pDelimiter )
            {
                hr = E_INVALIDARG;
            }
            //--- Matched somethinge like 206 709 8286 1 - could be OK
            else
            {
                if ( pTempEndChar )
                {
                    pEndChar = pTempEndChar;
                    pFrag    = pTempFrag;
                }
                ulNumGroups = j;
                break;
            }
        }
        //--- Didn't hit either break statement
        if ( !ulNumGroups )
        {
            ulNumGroups = j;
        }
    }

    //--- Check for appropriate formats
    if ( SUCCEEDED( hr ) )
    {
        //--- Check for [1<sep>]?(ddd?)<sep>?ddd<sep>dddd? OR ddd<sep>dddd?
        if ( !pCountryCode      &&
             ulNumGroups == 2   &&
             ulGroupLen[0] == 3 &&
             ulGroupLen[1] >= 3 &&
             !( fMatchedOne && !pAreaCode ) )         
        {
            if ( ( !Context ||
                   _wcsicmp( Context, L"phone_number" ) != 0 ) &&
                 !pCountryCode &&
                 !pAreaCode    &&
                 !fMatchedOne  &&
                 ( pDelimiter ? (*pDelimiter == L'.') : 0 ) )
            {
                hr = E_INVALIDARG;
            }
        }
        //--- Check for [1<sep>]?ddd?<sep>ddd<sep>dddd?
        else if ( !pCountryCode             &&
                  !pAreaCode                &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] == 3        &&
                  ulGroupLen[2] >= 3 )
        {
            pAreaCode           = pGroups[0];
            ulAreaCodeLen       = ulGroupLen[0];
            pAreaCodeState      = pGroupStates[0];
            PostAreaCodeList.AddTail( &PostGroupLists[0] );
            pGroups[0]          = pGroups[1];
            ulGroupLen[0]       = ulGroupLen[1];
            pGroupStates[0]     = pGroupStates[1];
            PostGroupLists[0].RemoveAll();
            PostGroupLists[0].AddTail( &PostGroupLists[1] );
            pGroups[1]          = pGroups[2];
            ulGroupLen[1]       = ulGroupLen[2];
            pGroupStates[1]     = pGroupStates[2];
            PostGroupLists[1].RemoveAll();
            PostGroupLists[2].RemoveAll();
            ulNumGroups--;
        }
        //--- Check for (ddd?)<sep>?ddd?<sep>dd<sep>ddd?d?
        else if ( !pCountryCode             &&
                  !fMatchedOne              &&
                  pAreaCode                 &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] == 2        &&
                  ulGroupLen[2] >= 2 )
        {
            NULL;
        }
        //--- Check for +dd?d?<sep>ddd?<sep>ddd?<sep>ddd?d?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  !pAreaCode                &&
                  ulNumGroups == 4          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ( ulGroupLen[1] == 2 ||
                    ulGroupLen[1] == 3 )    &&
                  ulGroupLen[2] >= 2        &&
                  ulGroupLen[3] >= 2 )
        {
            pAreaCode           = pGroups[0];
            ulAreaCodeLen       = ulGroupLen[0];
            pAreaCodeState      = pGroupStates[0];
            PostAreaCodeList.AddTail( &PostGroupLists[0] );
            pGroups[0]          = pGroups[1];
            ulGroupLen[0]       = ulGroupLen[1];
            pGroupStates[0]     = pGroupStates[1];
            PostGroupLists[0].RemoveAll();
            PostGroupLists[0].AddTail( &PostGroupLists[1] );
            pGroups[1]          = pGroups[2];
            ulGroupLen[1]       = ulGroupLen[2];
            pGroupStates[1]     = pGroupStates[2];
            PostGroupLists[1].RemoveAll();
            PostGroupLists[1].AddTail( &PostGroupLists[2] );
            pGroups[2]          = pGroups[3];
            ulGroupLen[2]       = ulGroupLen[3];
            pGroupStates[2]     = pGroupStates[3];
            PostGroupLists[2].RemoveAll();
            PostGroupLists[3].RemoveAll();
            ulNumGroups--;
        }
        //--- Check for +dd?d?<sep>ddd?<sep>ddd?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  !pAreaCode                &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ( ulGroupLen[1] == 2 ||
                    ulGroupLen[1] == 3 )    &&
                  ulGroupLen[2] >= 2 )
        {
            pAreaCode           = pGroups[0];
            ulAreaCodeLen       = ulGroupLen[0];
            pAreaCodeState      = pGroupStates[0];
            PostAreaCodeList.AddTail( &PostGroupLists[0] );
            pGroups[0]          = pGroups[1];
            ulGroupLen[0]       = ulGroupLen[1];
            pGroupStates[0]     = pGroupStates[1];
            PostGroupLists[0].RemoveAll();
            PostGroupLists[0].AddTail( &PostGroupLists[1] );
            pGroups[1]          = pGroups[2];
            ulGroupLen[1]       = ulGroupLen[2];
            pGroupStates[1]     = pGroupStates[2];
            PostGroupLists[1].RemoveAll();
            PostGroupLists[2].RemoveAll();
            ulNumGroups--;
        }
        //--- Check for +dd?d?<sep>(ddd?)<sep>?ddd?<sep>ddd?d?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  pAreaCode                 &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] >= 2        &&
                  ulGroupLen[2] >= 2 )
        {
            NULL;
        }
        //--- Check for +dd?d?<sep>(ddd?)<sep>?ddd?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  pAreaCode                 &&
                  ulNumGroups == 2          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] >= 2 )
        {
            NULL;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Fill in pItemNormInfo
    if ( SUCCEEDED(hr) )
    {
        m_pEndOfCurrItem = pGroups[ulNumGroups-1] + ulGroupLen[ulNumGroups-1];
        m_pEndChar  = pEndChar;
        m_pCurrFrag = pFrag;

        pItemNormInfo = (TTSPhoneNumberItemInfo*) MemoryManager.GetMemory( sizeof(TTSPhoneNumberItemInfo),
                                                                                   &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pItemNormInfo, sizeof(TTSPhoneNumberItemInfo) );
            pItemNormInfo->Type = eNEWNUM_PHONENUMBER;

            //--- Fill in fOne
            if ( fMatchedOne )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->fOne = true;
            }

            //--- Fill in Country Code...
            if ( pCountryCode )
            {
                TTSItemInfo* pCountryCodeInfo;
                const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
                m_pNextChar      = pCountryCode;
                m_pEndOfCurrItem = pCountryCode + ulCountryCodeLen;

                hr = IsNumber( pCountryCodeInfo, L"NUMBER", MemoryManager, false );
                if ( SUCCEEDED( hr ) )
                {
                    ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pCountryCode = (TTSNumberItemInfo*) pCountryCodeInfo;
                }

                m_pNextChar      = pTempNextChar;
                m_pEndOfCurrItem = pTempEndOfItem;
            }

            //--- Fill in Area Code...
            if ( SUCCEEDED( hr ) &&
                 pAreaCode )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode = 
                    (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof( TTSDigitsItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode->ulNumDigits = ulAreaCodeLen;
                    ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode->pFirstDigit = pAreaCode;
                }
            }

            //--- Fill in Main Number...
            if ( SUCCEEDED( hr ) )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ulNumGroups = ulNumGroups;
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups = 
                    (TTSDigitsItemInfo**) MemoryManager.GetMemory( ulNumGroups * sizeof(TTSDigitsItemInfo*), &hr );

                for ( ULONG j = 0; SUCCEEDED( hr ) && j < ulNumGroups; j++ )
                {
                     ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j] = 
                        (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof( TTSDigitsItemInfo ), &hr );
                     if ( SUCCEEDED( hr ) )
                     {
                         ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j]->ulNumDigits = ulGroupLen[j];
                         ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j]->pFirstDigit = pGroups[j];
                     }
                }
            }
        }
    }

    //--- Expand Phone Number
    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );
        Word.eWordPartOfSpeech = MS_Unknown;
        SPLISTPOS ListPos;

        if ( pCountryCode )
        {
            //--- Insert "country"
            Word.pXmlState  = pCountryCodeState;
            Word.pWordText  = g_Country.pStr;
            Word.ulWordLen  = g_Country.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert "code" 
            Word.pWordText  = g_Code.pStr;
            Word.ulWordLen  = g_Code.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            ListPos = WordList.GetTailPosition();

            //--- Expand Country Code
            ExpandNumber( ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pCountryCode, WordList );

            //--- Clean up digits XML states...
            WordList.GetNext( ListPos );
            while ( ListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( ListPos );
                TempWord.pXmlState = pCountryCodeState;
            }

            //--- Insert Post Symbol XML States
            while ( !PostCountryCodeList.IsEmpty() )
            {
                WordList.AddTail( ( PostCountryCodeList.RemoveHead() ).Words[0] );
            }
        }

        if ( fMatchedOne )
        {
            //--- Insert "one"
            Word.pXmlState  = pOneState;
            Word.pWordText  = g_ones[1].pStr;
            Word.ulWordLen  = g_ones[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert PostOne XML States
            while ( !PostOneList.IsEmpty() )
            {
                WordList.AddTail( ( PostOneList.RemoveHead() ).Words[0] );
            }
        }

        if ( pAreaCode )
        {
            //--- Expand digits - 800 and 900 get expanded as one number, otherwise digit by digit 
            if ( ( pAreaCode[0] == L'8' ||
                   pAreaCode[0] == L'9' ) &&
                 pAreaCode[1] == L'0'     &&
                 pAreaCode[2] == L'0' )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->fIs800 = true;
                NumberGroup Garbage;

                ListPos = WordList.GetTailPosition();

                ExpandThreeDigits( pAreaCode, Garbage, WordList ); 

                //--- Clean up digits XML states...
                //--- List was possibly empty prior to inserting "eight hundred" or "nine hundred"...
                if ( !ListPos )
                {
                    ListPos = WordList.GetHeadPosition();
                }
                WordList.GetNext( ListPos );
                while ( ListPos )
                {
                    TTSWord& TempWord  = WordList.GetNext( ListPos );
                    TempWord.pXmlState = pAreaCodeState;
                }
            }
            else
            {
                //--- Insert "area"
                Word.pXmlState  = pAreaCodeState;
                Word.pWordText  = g_Area.pStr;
                Word.ulWordLen  = g_Area.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
        
                //--- Insert "code" 
                Word.pWordText  = g_Code.pStr;
                Word.ulWordLen  = g_Code.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );

                ListPos = WordList.GetTailPosition();

                ExpandDigits( ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode, WordList );

                //--- Clean up digits XML states...
                WordList.GetNext( ListPos );
                while ( ListPos )
                {
                    TTSWord& TempWord  = WordList.GetNext( ListPos );
                    TempWord.pXmlState = pAreaCodeState;
                }
            }
            //--- Insert PostAreaCode XML States
            while ( !PostAreaCodeList.IsEmpty() )
            {
                WordList.AddTail( ( PostAreaCodeList.RemoveHead() ).Words[0] );
            }
        }

        for ( ULONG j = 0; j < ulNumGroups; j++ )
        {
            ListPos = WordList.GetTailPosition();

            ExpandDigits( ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j], WordList );

            //--- Clean up digits XML states...
            //--- List was possibly empty prior to inserting "eight hundred" or "nine hundred"...
            if ( !ListPos )
            {
                ListPos = WordList.GetHeadPosition();
            }
            WordList.GetNext( ListPos );
            while ( ListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( ListPos );
                TempWord.pXmlState = pGroupStates[j];
            }

            //--- Insert Post Group XML States
            while ( !PostGroupLists[j].IsEmpty() )
            {
                WordList.AddTail( ( PostGroupLists[j].RemoveHead() ).Words[0] );
            }
        }
    }

    return hr;
} /* IsPhoneNumber */

/***********************************************************************************************
* IsZipCode *
*-----------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a zipcode.  
*
*   RegExp:
*       ddddd{-dddd}?   
*
*   Types assigned:
*       NUM_ZIPCODE
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsZipCode( TTSItemInfo*& pItemNormInfo, const WCHAR* Context,
                                 CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsZipCode" );

    HRESULT hr = S_OK;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    BOOL fLastFour = false;

    //--- length must be 5 or 10 
    if ( ulTokenLen != 5 && 
         ulTokenLen != 10 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- match 5 digits 
        for ( ULONG i = 0; i < 5; i++ )
        {
            if ( !iswdigit( m_pNextChar[i] ) )
            {
                hr = E_INVALIDARG;
                break;
            }
        }
        if ( SUCCEEDED(hr) && 
             i < ulTokenLen )
        {
            //--- match dash 
            if ( m_pNextChar[i] != L'-' )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                //--- match 4 digits 
                for ( i = 0; i < 4; i++ )
                {
                    if ( !iswdigit( m_pNextChar[i] ) )
                    {
                        hr = E_INVALIDARG;
                        break;
                    }
                }
                fLastFour = true;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        pItemNormInfo = (TTSZipCodeItemInfo*) MemoryManager.GetMemory( sizeof(TTSZipCodeItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pItemNormInfo, sizeof(TTSZipCodeItemInfo) );
            pItemNormInfo->Type = eNUM_ZIPCODE;
            ( (TTSZipCodeItemInfo*) pItemNormInfo )->pFirstFive = 
                (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof(TTSDigitsItemInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {   
                ( (TTSZipCodeItemInfo*) pItemNormInfo )->pFirstFive->ulNumDigits = 5;
                ( (TTSZipCodeItemInfo*) pItemNormInfo )->pFirstFive->pFirstDigit = m_pNextChar;
                if ( fLastFour )
                {
                    ( (TTSZipCodeItemInfo*) pItemNormInfo )->pLastFour = 
                        (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof(TTSDigitsItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ( (TTSZipCodeItemInfo*) pItemNormInfo )->pLastFour->ulNumDigits = 4;
                        ( (TTSZipCodeItemInfo*) pItemNormInfo )->pLastFour->pFirstDigit = m_pNextChar + 6;
                    }
                }
            }
        }
    }

    return hr;
} /* IsZipCode */

/***********************************************************************************************
* ExpandZipCode *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_ZIPCODE by IsZipCode.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandZipCode( TTSZipCodeItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandZipCode" );

    HRESULT hr = S_OK;

    ExpandDigits( pItemInfo->pFirstFive, WordList );
    
    if ( pItemInfo->pLastFour )
    {
        //--- Insert "dash"
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );
        Word.pXmlState          = &m_pCurrFrag->State;
        Word.eWordPartOfSpeech  = MS_Unknown;
        Word.pWordText          = g_dash.pStr;
        Word.ulWordLen          = g_dash.Len;
        Word.pLemma             = Word.pWordText;
        Word.ulLemmaLen         = Word.ulWordLen;
        WordList.AddTail( Word );

        ExpandDigits( pItemInfo->pLastFour, WordList );
    }

    return hr;
} /* ExpandZipCode */

/***********************************************************************************************
* IsNumberRange *
*---------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a number range.
*
*   RegExp:
*       [Number]-[Number]  
*
*   Types assigned:
*       NUM_RANGE
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumberRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsNumberRange" );

    HRESULT hr = S_OK;
    TTSItemInfo *pFirstNumberInfo = NULL, *pSecondNumberInfo = NULL;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const WCHAR *pHyphen = NULL;

    for ( pHyphen = m_pNextChar; pHyphen < m_pEndOfCurrItem; pHyphen++ )
    {
        if ( *pHyphen == L'-' )
        {
            break;
        }
    }

    if ( *pHyphen == L'-' &&
         pHyphen > m_pNextChar &&
         pHyphen < m_pEndOfCurrItem - 1 )
    {
        m_pEndOfCurrItem = pHyphen;
        hr = IsNumber( pFirstNumberInfo, NULL, MemoryManager );

        if ( SUCCEEDED( hr ) )
        {
            m_pNextChar      = pHyphen + 1;
            m_pEndOfCurrItem = pTempEndOfItem;
            hr = IsNumberCategory( pSecondNumberInfo, NULL, MemoryManager );					

			if ( SUCCEEDED( hr ) )
            {
                //--- Matched a number range!
                pItemNormInfo = 
                    (TTSNumberRangeItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberRangeItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    pItemNormInfo->Type = eNUM_RANGE;
                    ( (TTSNumberRangeItemInfo*) pItemNormInfo )->pFirstNumberInfo  = pFirstNumberInfo;
                    ( (TTSNumberRangeItemInfo*) pItemNormInfo )->pSecondNumberInfo = pSecondNumberInfo;
                }
            }
            else if ( pFirstNumberInfo->Type != eDATE_YEAR )
            {   
                delete ( (TTSNumberItemInfo*) pFirstNumberInfo )->pWordList;
            }
        }
        m_pNextChar      = pTempNextChar;
        m_pEndOfCurrItem = pTempEndOfItem;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsNumberRange */

/***********************************************************************************************
* ExpandNumberRange *
*-------------------*
*   Description:
*       Expands Items previously determined to be of type NUM_RANGE by IsNumberRange.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandNumberRange( TTSNumberRangeItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandNumberRange" );

    HRESULT hr = S_OK;

    //--- Expand first number (or year)...
    switch( pItemInfo->pFirstNumberInfo->Type )
    {
    case eDATE_YEAR:
        hr = ExpandYear( (TTSYearItemInfo*) pItemInfo->pFirstNumberInfo, WordList );
        break;
    default:
        hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pFirstNumberInfo, WordList );
        break;
    }

    //--- Insert "to"
    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );

        Word.pXmlState          = &m_pCurrFrag->State;
        Word.eWordPartOfSpeech  = MS_Unknown;
        Word.pWordText          = g_to.pStr;
        Word.ulWordLen          = g_to.Len;
        Word.pLemma             = Word.pWordText;
        Word.ulLemmaLen         = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    //--- Expand second number (or year)...
    if ( SUCCEEDED( hr ) )
    {
        switch( pItemInfo->pSecondNumberInfo->Type )
        {
        case eDATE_YEAR:
            hr = ExpandYear( (TTSYearItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
            break;
		case eNUM_PERCENT:
			hr = ExpandPercent( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;			
		case eNUM_DEGREES:
			hr = ExpandDegrees( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;
		case eNUM_SQUARED:
			hr = ExpandSquare( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;
	    case eNUM_CUBED:
		    hr = ExpandCube( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;
        default:
             hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
            break;
        }
    }

    return hr;
} /* ExpandNumberRange */


/***********************************************************************************************
* IsCurrencyRange *
*-------------------*
*   Description:
*       Expands Items determined to be of type CURRENCY_RANGE
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsCurrencyRange( TTSItemInfo*& pItemInfo, CSentItemMemory& MemoryManager, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsCurrencyRange" );

    HRESULT hr = S_OK;
    TTSItemInfo *pFirstNumberInfo = NULL, *pSecondNumberInfo = NULL;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem, *pTempEndChar = m_pEndChar;
    const WCHAR *pHyphen = NULL;	
	CWordList TempWordList;
	NORM_POSITION ePosition = UNATTACHED;  //for currency sign checking
	int iSymbolIndex, iTempSymbolIndex = -1;
	WCHAR *tempNumberString;

	iSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );	
	
	if(iSymbolIndex < 0)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		for ( pHyphen = m_pNextChar; pHyphen < m_pEndOfCurrItem; pHyphen++ )
		{
			if ( *pHyphen == L'-' )
			{
				break;
			}
		}

		if ( !( *pHyphen == L'-' &&
			    pHyphen > m_pNextChar &&
			    pHyphen < m_pEndOfCurrItem - 1 ) )
		{
			hr = E_INVALIDARG;
		}
		else
		{			
			*( (WCHAR*)pHyphen) = L' ';  // Token must break at hyphen, or IsCurrency() will not work
			m_pNextChar      = pTempNextChar;
			m_pEndOfCurrItem = pHyphen;			
			NORM_POSITION temp = UNATTACHED;
			iTempSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, temp );
			if( iTempSymbolIndex >= 0 && iSymbolIndex != iTempSymbolIndex ) 
			{
				hr = E_INVALIDARG;
			}
			else   //--- Get both NumberInfos
			{
				hr = IsNumber( pFirstNumberInfo, L"NUMBER", MemoryManager, false );
				if( SUCCEEDED ( hr ) )
				{
					m_pNextChar = pHyphen + 1;
					m_pEndOfCurrItem = pTempEndOfItem;
					iTempSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, temp );
					hr = IsNumber( pSecondNumberInfo, L"NUMBER", MemoryManager, false );
				}
			}
			if( SUCCEEDED ( hr ) ) 
			{
			    //--- If both currency values are cardinal numbers, then the first number can be
			    //--- expanded without saying its currency ("$10-12" -> "ten to twelve dollars")
				if( pFirstNumberInfo->Type == eNUM_CARDINAL && pSecondNumberInfo->Type == eNUM_CARDINAL )
				{   
					ExpandNumber( (TTSNumberItemInfo*) pFirstNumberInfo, TempWordList );
				}
				else  // one or both values are non-cardinal numbers, so we must 
				{     // expand the first value as a full currency.
					m_pNextChar      = pTempNextChar;
					m_pEndOfCurrItem = pHyphen;

					if( ePosition == FOLLOWING ) 
					{
						if( iTempSymbolIndex < 0 )  // No symbol on first number item - need to fill a buffer
                        {						    // with currency symbol and value to pass to IsCurrency().
							ULONG ulNumChars = (long)(m_pEndOfCurrItem - m_pNextChar + g_CurrencySigns[iSymbolIndex].Sign.Len + 1);
							tempNumberString = (WCHAR*) MemoryManager.GetMemory( (ulNumChars) * sizeof(WCHAR), &hr );
							if ( SUCCEEDED( hr ) )
							{	
								ZeroMemory( tempNumberString, ( ulNumChars ) * sizeof( WCHAR ) );
								wcsncpy( tempNumberString, m_pNextChar, m_pEndOfCurrItem - m_pNextChar );
								wcscat( tempNumberString, g_CurrencySigns[iSymbolIndex].Sign.pStr );						
								m_pNextChar      = tempNumberString;
								m_pEndOfCurrItem = tempNumberString + wcslen( tempNumberString );
								m_pEndChar = m_pEndOfCurrItem;
							}                
						}
						else if( iTempSymbolIndex != iSymbolIndex )	// mismatched symbols
						{
							hr = E_INVALIDARG;
						}
					}
					if ( SUCCEEDED ( hr ) ) 
					{
						hr = IsCurrency( pFirstNumberInfo, MemoryManager, TempWordList );
						m_pEndChar = pTempEndChar;
					}
				}
			}

			if ( SUCCEEDED ( hr ) ) 
			{						
				TTSWord Word;
				ZeroMemory( &Word, sizeof( TTSWord ) );

				Word.pXmlState          = &m_pCurrFrag->State;
				Word.eWordPartOfSpeech  = MS_Unknown;
				Word.pWordText          = g_to.pStr;
				Word.ulWordLen          = g_to.Len;
				Word.pLemma             = Word.pWordText;
				Word.ulLemmaLen         = Word.ulWordLen;
				TempWordList.AddTail( Word );
		
				m_pNextChar = pHyphen + 1;
				m_pEndOfCurrItem = pTempEndOfItem;
					
				if( ePosition == PRECEDING ) 
				{
					iTempSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );
					if( iTempSymbolIndex < 0 )  // No symbol on second number item
					{    // create temporary string from first currency sign and second number item
						ULONG ulNumChars = (long)(m_pEndOfCurrItem - m_pNextChar + g_CurrencySigns[iSymbolIndex].Sign.Len + 1);
						tempNumberString = (WCHAR*) MemoryManager.GetMemory( (ulNumChars) * sizeof(WCHAR), &hr );
						if ( SUCCEEDED( hr ) )
						{
							ZeroMemory( tempNumberString, ( ulNumChars ) * sizeof( WCHAR ) );
							wcsncpy( tempNumberString, g_CurrencySigns[iSymbolIndex].Sign.pStr, g_CurrencySigns[iSymbolIndex].Sign.Len );
							wcsncpy( tempNumberString+g_CurrencySigns[iSymbolIndex].Sign.Len, m_pNextChar, m_pEndOfCurrItem - m_pNextChar );
							m_pNextChar      = tempNumberString;
							m_pEndOfCurrItem = tempNumberString + wcslen( tempNumberString );
							m_pEndChar = m_pEndOfCurrItem;
						}                
					}
					else if( iTempSymbolIndex == iSymbolIndex )	// matched leading symbol on second number item
					{
						m_pNextChar = pHyphen + 1;
						m_pEndOfCurrItem = pTempEndOfItem;
					}
					else	// mismatched symbol
					{
						hr = E_INVALIDARG;
					}
				}
					
				if( SUCCEEDED(hr) ) 
				{
					hr = IsCurrency( pSecondNumberInfo, MemoryManager, TempWordList );						
					if ( SUCCEEDED( hr ) )
					{							
						//--- Matched a currency range!
						pItemInfo = 
							(TTSNumberRangeItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberRangeItemInfo ), &hr );
						if ( SUCCEEDED( hr ) )
						{
							pItemInfo->Type = eNUM_CURRENCYRANGE;
							( (TTSNumberRangeItemInfo*) pItemInfo )->pFirstNumberInfo  = pFirstNumberInfo;
							( (TTSNumberRangeItemInfo*) pItemInfo )->pSecondNumberInfo = pSecondNumberInfo;
			                //--- Copy temp word list to real word list if everything has succeeded...
							WordList.AddTail( &TempWordList );
						}
					}
				}
			}	
			*( (WCHAR*)pHyphen) = L'-';
		}
	}
	//Reset member variables regardless of failure or success
    m_pNextChar      = pTempNextChar;
    m_pEndOfCurrItem = pTempEndOfItem;
	m_pEndChar = pTempEndChar;
	
    return hr;
} /* IsCurrencyRange */

/***********************************************************************************************
* MatchCurrencySign *
*-------------------*
*   Description:
*       Helper function which tries to match a currency sign at the beginning of a string.
********************************************************************* AH **********************/
int MatchCurrencySign( const WCHAR*& pStartChar, const WCHAR*& pEndChar, NORM_POSITION& ePosition )
{
    int Index = -1;

    for (int i = 0; i < sp_countof(g_CurrencySigns); i++)
    {
        if ( pEndChar - pStartChar >= g_CurrencySigns[i].Sign.Len && 
             wcsnicmp( pStartChar, g_CurrencySigns[i].Sign.pStr, g_CurrencySigns[i].Sign.Len ) == 0 )
        {
            Index = i;
            pStartChar += g_CurrencySigns[i].Sign.Len;
            ePosition = PRECEDING;
            break;
        }
    }

    if ( Index == -1 )
    {
        for ( int i = 0; i < sp_countof(g_CurrencySigns); i++ )
        {
            if ( pEndChar - pStartChar >= g_CurrencySigns[i].Sign.Len &&
                 wcsnicmp( pEndChar - g_CurrencySigns[i].Sign.Len, g_CurrencySigns[i].Sign.pStr, g_CurrencySigns[i].Sign.Len ) == 0 )
            {
                Index = i;
                pEndChar -= g_CurrencySigns[i].Sign.Len;
                ePosition = FOLLOWING;
                break;
            }
        }
    }

    return Index;
} /* MatchCurrencySign */      

/***********************************************************************************************
* Zeroes *
*--------*
*   Description:
*       A helper function which simply determines if a number string contains only zeroes...
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
bool CStdSentEnum::Zeroes(const WCHAR *NumberString)
{
    bool bAllZeroes = true;
    for (ULONG i = 0; i < wcslen(NumberString); i++)
    {
        if (NumberString[i] != '0' && isdigit(NumberString[i]) )
        {
            bAllZeroes = false;
            break;
        }
        else if ( !isdigit( NumberString[i] ) && NumberString[i] != ',' )
        {
            break;
        }
    }
    return bAllZeroes;
} /* Zeroes */

/***********************************************************************************************
* ThreeZeroes *
*-------------*
*   Description:
*       A helper function which simply determines if a number string contains three zeroes...
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
bool CStdSentEnum::ThreeZeroes(const WCHAR *NumberString)
{
    bool bThreeZeroes = true;
    for (ULONG i = 0; i < 3; i++)
    {
        if (NumberString[i] != '0' && isdigit(NumberString[i]))
        {
            bThreeZeroes = false;
            break;
        }
    }
    return bThreeZeroes;
} /* ThreeZeroes */

//-----------End Of File-------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\spttseng.cpp ===
/*******************************************************************************
* spttseng.cpp *
*--------------*
*   Description:
*       This module is the implementation file for the MS TTS DLL.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/
#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

#ifndef __spttseng_h__
#include "spttseng.h"
#endif

#include "spttseng_i.c"

#ifndef TTSEngine_h
#include "TTSEngine.h"
#endif

#ifndef VoiceDataObj_h
#include "VoiceDataObj.h"
#endif

CSpUnicodeSupport g_Unicode;
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY( CLSID_MSVoiceData, CVoiceDataObj )
    OBJECT_ENTRY( CLSID_MSTTSEngine, CTTSEngine    )
END_OBJECT_MAP()

/*****************************************************************************
* DllMain *
*---------*
*   Description:
*       DLL Entry Point
********************************************************************** MC ***/
#ifdef _WIN32_WCE
extern "C"
BOOL WINAPI DllMain(HANDLE hInst, DWORD dwReason, LPVOID /*lpReserved*/)
{
    HINSTANCE hInstance = (HINSTANCE)hInst;
#else
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSTTSENGINELib);
        DisableThreadLibraryCalls(hInstance);
#ifdef _DEBUG
        // Turn on memory leak checking
        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag( tmpFlag );
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        CleanupAbbrevTables();
        _Module.Term();
    }
    return TRUE;    // ok
} /* DllMain */

/*****************************************************************************
* DllCanUnloadNow *
*-----------------*
*   Description:
*       Used to determine whether the DLL can be unloaded by OLE
********************************************************************** MC ***/
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} /* DllCanUnloadNow */

/*****************************************************************************
* DllGetClassObject *
*-------------------*
*   Description:
*       Returns a class factory to create an object of the requested type
********************************************************************** MC ***/
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
} /* DllGetClassObject */

/*****************************************************************************
* DllRegisterServer *
*-------------------*
*   Description:
*       Adds entries to the system registry
********************************************************************** MC ***/
STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
} /* DllRegisterServer */

/*****************************************************************************
* DllUnregisterServer *
*---------------------*
*   Description:
*        Removes entries from the system registry
********************************************************************** MC ***/
STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
} /* DllUnregisterServer */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\pitchprosody.cpp ===
/******************************************************************************
* PitchProsody.cpp *
*--------------------*
*
*  This is an implementation of the PitchProsody class.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 04/28/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

//--- Additional includes
#include "stdafx.h"

#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif


//-----------------------------
// Data.cpp
//-----------------------------
extern const float   g_PitchScale[];



//--------------------------------
// Interpolation direction
//--------------------------------
enum INTERP_DIR
{
    GOING_UP,
    GOING_DOWN,
};


#define M_PI		3.14159265358979323846
#define	MAX_ORDER		4096



/*****************************************************************************
* HzToOct *
*---------*
*   Description:
*   Convert liner freq ro exp pitch
*   0.69314718 is log of 2 
*   1.021975 is offset for middle C
*       
********************************************************************** MC ***/
float HzToOct( float cps)
{
    SPDBG_FUNC( "HzToOct" );

    return (float)(log(cps / 1.021975) / 0.69314718);
    
} /* HzToOct */

/*****************************************************************************
* OctToHz *
*---------*
*   Description:
*       Convert from exp pitch to linear freq
********************************************************************** MC ***/
float OctToHz( float oct)
{
    SPDBG_FUNC( "OctToHz" );

    return (float)(pow(2, oct) * 1.021975);
} /* OctToHz */



/*****************************************************************************
* CPitchProsody::DoPitchControl *
*-------------------------------*
*   Description:
*   Scale speech pitch to user control
*       
********************************************************************** MC ***/
float CPitchProsody::DoPitchControl( long pitchControl, float basePitch )
{
    SPDBG_FUNC( "CPitchProsody::DoPitchControl" );
    float   newPitch;

    if( pitchControl < 0 )
    {
        //--------------------------------
        // DECREASE the pitch
        //--------------------------------
        if( pitchControl < MIN_USER_PITCH )
        {
            pitchControl = MIN_USER_PITCH;        // clip to min
        }
        newPitch = (float)basePitch / g_PitchScale[0 - pitchControl];
    }
    else
    {
        //--------------------------------
        // INCREASE the pitch
        //--------------------------------
        if( pitchControl > MAX_USER_PITCH )
        {
            pitchControl = MAX_USER_PITCH;        // clip to max
        }
        newPitch = (float)basePitch * g_PitchScale[pitchControl];
    }
    return newPitch;
} /* CPitchProsody::DoPitchControl */





/*****************************************************************************
* CPitchProsody::SetDefaultPitch *
*--------------------------------*
*   Description:
*   Init pitch knots to monotone in case there's a failure in this object.
*       
********************************************************************** MC ***/
void CPitchProsody::SetDefaultPitch()
{
    SPDBG_FUNC( "CPitchProsody::SetDefaultPitch" );
    CAlloCell   *pCurCell;

	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        float       relTime, timeK;
        float       normalPitch;
        long        knot;

        normalPitch = pCurCell->m_Pitch_LO + ((pCurCell->m_Pitch_HI - pCurCell->m_Pitch_LO) / 2);
        timeK = pCurCell->m_ftDuration / KNOTS_PER_PHON;
        relTime = 0;
        for( knot = 0; knot < KNOTS_PER_PHON; knot++ )
        {
            pCurCell->m_ftPitch[knot] = normalPitch;
            pCurCell->m_ftTime[knot] = relTime;
            relTime += timeK;
        }
		pCurCell = m_pAllos->GetNextCell();
    }
} /* CPitchProsody::SetDefaultPitch */


/*****************************************************************************
* CPitchProsody::AlloPitch *
*--------------------------*
*   Description:
*   Tag pitch highlights
*       
********************************************************************** MC ***/
void CPitchProsody::AlloPitch( CAlloList *pAllos, float baseLine, float pitchRange )
{
    SPDBG_FUNC( "CAlloOps::AlloPitch" );
    CAlloCell   *pCurCell;
    bool        skipInitialSil;
    long        quantTotal, index;
    
    m_pAllos = pAllos;
    m_numOfCells = m_pAllos->GetCount();
    m_Tune_Style = DESCEND_TUNE;        // NOTE: maybe set from rules
    m_TotalDur = 0;
    quantTotal = 0;
    m_OffsTime = 0;
    skipInitialSil = true;


   //------------------------------
    // Calculate total duration
    // (exclude surrounding silence)
    //------------------------------
	index = 0;
	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        if( (skipInitialSil) && (pCurCell->m_allo == _SIL_) )
        {
            //---------------------------------
            // Skip leading silence
            //---------------------------------
            m_OffsTime += pCurCell->m_ftDuration;
        }
        else if( (index == (m_numOfCells -1)) && (pCurCell->m_allo == _SIL_) )
        {
            //---------------------------------
            // Skip term silence
            //---------------------------------
            break;
        }
        else
        {
            pCurCell->m_PitchBufStart = quantTotal;
            m_TotalDur += pCurCell->m_ftDuration;
            quantTotal = (long)(m_TotalDur / PITCH_BUF_RES);
            pCurCell->m_PitchBufEnd = quantTotal;
            skipInitialSil = false;
        }
		index++;
		pCurCell = pAllos->GetNextCell();
    }

    //------------------------------
    // Init pitch range
    //------------------------------
	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        float   hzVal, pitchK, rangeTemp;

        //---------------------------------------
        // Scale to possible pitch control
        //---------------------------------------
		rangeTemp = pitchRange * pCurCell->m_PitchRangeScale;
		
        hzVal = DoPitchControl( pCurCell->m_user_Pitch, baseLine );
        pitchK = HzToOct( hzVal ) + pCurCell->m_PitchBaseOffs;
        pCurCell->m_Pitch_HI = OctToHz( pitchK + rangeTemp );
        pCurCell->m_Pitch_LO = OctToHz( pitchK - rangeTemp );

		pCurCell = pAllos->GetNextCell();
    }

    //--------------------------------------------
    // In case we fail somewhere, set values to 
    // a known valid state (monotone).
    //--------------------------------------------
    SetDefaultPitch();

    if( m_TotalDur > 0 )
    {
        //--------------------------------------------
        // Generate pitch targets
        //--------------------------------------------
        PitchTrack();
    }

} /* CPitchProsody::AlloPitch */











/*****************************************************************************
* LineInterpContour  *
*--------------------*
*   Description:
*   Does linear interpolation over the pitch contour
*       
********************************************************************** MC ***/
void	LineInterpContour( long cNumOfPoints, float *pPoints )
{
    SPDBG_FUNC( "LineInterpContour" );
    long endAnch,startAnch, i;
    float bPoint1, ePoint1;
    
    
    //----------------------------------------------------
    // Scan forward from beginning to find 1st non-zero enrty
    // Use it as the START point.
    //----------------------------------------------------
    for( startAnch = 0; startAnch < cNumOfPoints; startAnch++ )
    {
        if( pPoints[startAnch] != 0 )
        {
            break;
        }
    }
    bPoint1 = pPoints[startAnch];
    
    
    //----------------------------------------------------
    // Scan back from end to find 1st non-zero enrty
    // Use it as the END point.
    //----------------------------------------------------
    for( endAnch = cNumOfPoints-1; endAnch >= 0; endAnch-- )
    {
        if( pPoints[endAnch] != 0 )
        {
            break;
        }
    }
    ePoint1 = pPoints[endAnch];
    
    
    long firstp = 0;
    long lastp = 0;
    
    while( firstp < cNumOfPoints )
    {
        //-------------------------------------------
        // Find beginning and end of current section
        //-------------------------------------------
        while( pPoints[firstp] != 0 )
        {
            if( ++firstp >= cNumOfPoints-1 ) 
            {
                break;
            }
        }
		if( firstp >= cNumOfPoints-1 )
		{
			//--------------------------------------
			// There's nothing to interpolate!
			//--------------------------------------
			break;
		}


        lastp = firstp+1;
        while( pPoints[lastp] == 0 )
        {
            if( ++lastp >= cNumOfPoints ) 
            {
				lastp = cNumOfPoints;
                break;
            }
        }
        lastp--;

        if( lastp >= firstp )
        {
            if( (lastp >= cNumOfPoints) || (firstp >= cNumOfPoints) ) 
            {
                break;
            }
            //-------------------------------------------
            // Do the interpolate
            //-------------------------------------------
            float bPoint,ePoint;
            if( firstp == 0 ) 
            {
                bPoint = bPoint1;
            }
            else 
            {
                bPoint = pPoints[firstp - 1];
            }
            
            if( lastp == cNumOfPoints-1 ) 
            {
                ePoint = ePoint1;
            }
            else 
            {
                ePoint = pPoints[lastp + 1];
            }
            
            float pointSpread = ePoint - bPoint;
            float timeSpread = (float) ((lastp - firstp)+2);
            float inc = pointSpread / timeSpread;
            float theBase = bPoint;
            for( i = firstp; i <= lastp; i++ )
            {
                theBase += inc;
                pPoints[i] = theBase;
            }
        }
        else 
        {
            pPoints[firstp] = pPoints[lastp+1];
        }
        firstp = lastp+1;
    }
} /* LineInterpContour */








/*****************************************************************************
* Interpolate2  *
*---------------*
*   Description:
*    Do a 2nd order interpolation, a little nicer than just linear
*       
********************************************************************** MC ***/
void Interpolate2( INTERP_DIR direction, float *m_theFitPoints, long theStart, long len, float theAmp, float theBase)
{
    SPDBG_FUNC( "Interpolate2" );
	long    midPoint = len / 2;
    long    i;

	theAmp -= theBase;

	for( i = theStart; i < theStart + len;i++ )
	{
		if (direction == GOING_UP)
		{
			if( i < theStart + midPoint )
			{
				m_theFitPoints[i] = theBase +
				(2 * theAmp) * ((((float)i - (float)theStart) / (float)len) * 
													(((float)i - (float)theStart) / (float)len));
			}
			else
			{
				m_theFitPoints[i] = (theBase + theAmp) - 
				((2 * theAmp) * ((1 - ((float)i - (float)theStart) / (float)len) * 
										(1 - ((float)i - (float)theStart) / (float)len)));
			}
		}
		else if( direction == GOING_DOWN ) 
		{

			if( i < theStart + midPoint )
			{
				m_theFitPoints[i] = theBase +
				theAmp - (2 * theAmp) * ((((float)i - (float)theStart) / (float)len) * 
													(((float)i - (float)theStart) / (float)len));
			}
			else
			{
				m_theFitPoints[i] = theBase + 
				(2 * theAmp) * ((1 - ((float)i - (float)theStart) / (float)len) * 
										(1 - ((float)i - (float)theStart) / (float)len));
			}
		} 
	}
} /* Interpolate2 */




/*****************************************************************************
* SecondOrderInterp  *
*--------------------*
*   Description:
*   Does 2nd order interpolation over the pitch contour
*       
********************************************************************** MC ***/
void SecondOrderInterp( long cNumOfPoints, float *pPoints )
{
    SPDBG_FUNC( "SecondOrderInterp" );
	long    endAnch,startAnch;
	float   bPoint1, ePoint1;


    //----------------------------------------------------
    // Scan forward from beginning to find 1st non-zero enrty
    // Use it as the START point.
    //----------------------------------------------------
    for( startAnch = 0; startAnch < cNumOfPoints; startAnch++ )
    {
        if( pPoints[startAnch] != 0 )
        {
            break;
        }
    }
    bPoint1 = pPoints[startAnch];
    
    
    //----------------------------------------------------
    // Scan back from end to find 1st non-zero enrty
    // Use it as the END point.
    //----------------------------------------------------
    for( endAnch = cNumOfPoints-1; endAnch >= 0; endAnch-- )
    {
        if( pPoints[endAnch] != 0 )
        {
            break;
        }
    }
    ePoint1 = pPoints[endAnch];


    long    firstp = 0;
	long    lastp = 0;

	while( firstp < cNumOfPoints-1 )
	{

        //------------------------------------------------
		// Find beginning and end of current section
        //------------------------------------------------
		while( pPoints[firstp] != 0 )
		{
			if( ++firstp >= cNumOfPoints-1 ) 
            {
                break;
            }
		}
		if( firstp >= cNumOfPoints-1 )
		{
			//--------------------------------------
			// There's nothing to interpolate!
			//--------------------------------------
			break;
		}

		lastp = firstp + 1;
		while( pPoints[lastp] == 0 )
		{
			if( ++lastp >= cNumOfPoints ) 
            {
				lastp = cNumOfPoints;
                break;
            }
		}
		lastp--;

		if( lastp >= firstp )
		{
			if( (lastp >= cNumOfPoints) || (firstp >= cNumOfPoints) ) 
            {
                break;
            }

            //--------------------------------
			// Do the interpolate
            //--------------------------------
			float   bPoint, ePoint;

			if( firstp == 0 ) 
            {
                bPoint = bPoint1;
            }
			else 
            {
                bPoint = pPoints[firstp - 1];
            }

            long    theIndex = lastp + 1;

			if( lastp == cNumOfPoints-1 ) 
            {
                ePoint = ePoint1;
            }
			else 
            {
                ePoint = pPoints[theIndex];
            }

            //--------------------------------
            // call the 2nd order routine
            //--------------------------------
            if( ePoint - bPoint > 0 )
            {
                Interpolate2( GOING_UP, pPoints, firstp, (lastp - firstp) + 1, ePoint, bPoint );
            }
            else
            {
                Interpolate2( GOING_DOWN, pPoints, firstp, (lastp - firstp) + 1, bPoint, ePoint );
            }

		}
		else 
        {
            pPoints[firstp] = pPoints[lastp+1];
        }

		firstp = lastp+1;
	}


	//---------------------------------
	// IIR Filter
	//---------------------------------
#define kPointDelay		1

	float		filter_Out1, filter_In_Gain, filter_FB_Gain;
	float		lastPoint;
	long		i;

	//--------------------------------------------------
	// Skip filter if audio len less than delay
	//--------------------------------------------------
	if( cNumOfPoints > kPointDelay )
	{
		filter_In_Gain = 0.10f;
		filter_FB_Gain = 1.0f - filter_In_Gain;
		filter_Out1 = pPoints[0];
		for( i = 0; i < cNumOfPoints; i++ )
		{
			filter_Out1 = 	(filter_In_Gain * pPoints[i]) + (filter_FB_Gain * filter_Out1);
			pPoints[i] = filter_Out1;
		}
		for( i = kPointDelay; i < cNumOfPoints; i++ )
		{
			pPoints[i-kPointDelay] = pPoints[i];
		}
		i = (cNumOfPoints - kPointDelay) -1;
		lastPoint = pPoints[i++];
		for( ; i < cNumOfPoints; i++ )
		{
			pPoints[i] = lastPoint;
		}
	}
} /* SecondOrderInterp */

/*****************************************************************************
* CPitchProsody::NewTarget  *
*---------------------------*
*   Description:
*   Insert pitch target into 'm_pContBuf'
*       
********************************************************************** MC ***/
void CPitchProsody::NewTarget( long index, float value )
{
    SPDBG_FUNC( "CPitchProsody::NewTarget" );

    m_pContBuf[index] = value;

    //--- Debug Macro - add pitch to target list for later debugging output
    TTSDBG_ADDPITCHTARGET( m_OffsTime + (PITCH_BUF_RES * index), value, m_CurAccent );

} /* CPitchProsody::NewTarget */


/*****************************************************************************
* CPitchProsody::GetKnots *
*-------------------------*
*   Description:
*   Assign pitch knots based on entries in a contour buffer.
*       
********************************************************************** MC ***/
void CPitchProsody::GetKnots ()
{
    SPDBG_FUNC( "CPitchProsody::GetKnots" );
    CAlloCell   *pCurCell;
    float       distK, scale;
    float       pitchRange;
    long        knot, loc, index;
    bool        skipInitialSil;

    skipInitialSil = true;
	pCurCell = m_pAllos->GetHeadCell();
	index = 0;
    while( pCurCell )
    {
		if( index >= m_numOfCells-1 )
		{
			//-----------------------
			// Skip last allo
			//-----------------------
			break;
		}
        if( (!skipInitialSil) || (pCurCell->m_allo != _SIL_) )
        {
            pitchRange = pCurCell->m_Pitch_HI - pCurCell->m_Pitch_LO;
            distK = 1.0f / KNOTS_PER_PHON;
            scale = 0;
            for( knot = 0; knot < KNOTS_PER_PHON; knot++ )
            {
                loc = pCurCell->m_PitchBufStart + (long)((pCurCell->m_PitchBufEnd - pCurCell->m_PitchBufStart) * scale);
                pCurCell->m_ftPitch[knot] =  pCurCell->m_Pitch_LO + (m_pContBuf[loc] * pitchRange);
                pCurCell->m_ftTime[knot] = scale * pCurCell->m_ftDuration;
                scale += distK;
            }
            skipInitialSil = false;
        }
		pCurCell = m_pAllos->GetNextCell();
		index++;
    }
} /* CPitchProsody::GetKnots */


/*****************************************************************************
* CPitchProsody::PitchTrack  *
*----------------------------*
*   Description:
*   Tag pitch highlights
*       
********************************************************************** MC ***/
void CPitchProsody::PitchTrack()
{
    SPDBG_FUNC( "CPitchProsody::PitchTrack" );
    long        i;
    CAlloCell   *pCurCell, *pNextCell;
    bool        initialWord;      // 1st word in phrase
    long        wordCntDwn;
    float       curProm;          // Current accent prominence
    long        cNumOfPoints;
    float       *pRefBuf, *pCeilBuf, *pFloorBuf;
    float       lastProm;
    long        loc;
    float       value;

    pRefBuf = pCeilBuf = pFloorBuf = m_pContBuf = NULL;
    cNumOfPoints = (long)(m_TotalDur / PITCH_BUF_RES);
    pRefBuf = new float[cNumOfPoints];
    pCeilBuf = new float[cNumOfPoints];
    pFloorBuf = new float[cNumOfPoints];
    m_pContBuf = new float[cNumOfPoints];

    if( pRefBuf && pCeilBuf && pFloorBuf && m_pContBuf)
    {
        //--------------------------------------------
        // Initialize buffers to zero
        //--------------------------------------------
        for (i = 0; i < cNumOfPoints; i++)
        {
            pCeilBuf[i] = 0;
            pFloorBuf[i] = 0.00001f;
            pRefBuf[i] = 0;
            m_pContBuf[i] = 0;
        }

        //--------------------------------------------
        // Linear CEILING slope
        //--------------------------------------------
        if( m_Tune_Style == DESCEND_TUNE )
        {
            pCeilBuf[0] = 1.0;
            pCeilBuf[cNumOfPoints-1] = 0.70f;
            ::LineInterpContour( cNumOfPoints, pCeilBuf );
        }
        else if  (m_Tune_Style == ASCEND_TUNE)
        {
            pCeilBuf[0] = 0.9f;
            pCeilBuf[cNumOfPoints-1] = 1.0f;
            ::LineInterpContour( cNumOfPoints, pCeilBuf );
        }
        else if  (m_Tune_Style == FLAT_TUNE)
        {
           pCeilBuf[0] = 1.0f;
           pCeilBuf[cNumOfPoints-1] = 1.0f;
           ::LineInterpContour( cNumOfPoints, pCeilBuf );
        }

        //--------------------------------------------
        // Linear REFERENCE slope
        //--------------------------------------------
        pRefBuf[0] = (float) (pFloorBuf[0] + (pCeilBuf[0] - pFloorBuf[0]) * 0.33f);
        pRefBuf[cNumOfPoints-1] = (float) (pFloorBuf[0] + (pCeilBuf[cNumOfPoints-1] - pFloorBuf[cNumOfPoints-1]) * 0.33f);
        ::LineInterpContour( cNumOfPoints,pRefBuf );

        //--------------------------------------------
        // Final contour buffer
        //--------------------------------------------
        m_pContBuf[0] = pRefBuf[0];
        m_pContBuf[cNumOfPoints-1] = 0.0001f;		// Something very small


        long    iPrevBegin, iPrevEnd, iCurBegin; 
        long    iCurEnd, iNextBegin, iNextEnd;
		float	cCurLen;
        long	iCellindex;

        initialWord = true;
		iCellindex = 0;
		pCurCell = m_pAllos->GetHeadCell();
        while( pCurCell->m_allo == _SIL_ )
        {
            //---------------------------------
            // Skip leading silence
            //---------------------------------
            pCurCell = m_pAllos->GetNextCell();
			iCellindex++;
        }
        wordCntDwn  = 1;                // Skip 1st word
        lastProm = 0;
        iPrevBegin = iPrevEnd = 0;

		pNextCell = m_pAllos->GetNextCell();
        while( pCurCell )
        {
			if( iCellindex >= m_numOfCells-1 )
			{
				//-----------------------
				// Skip last allo
				//-----------------------
				break;
			}
            //-----------------------------------
            // Get CURRENT allo
            //-----------------------------------
            iCurBegin = pCurCell->m_PitchBufStart;
            iCurEnd = pCurCell->m_PitchBufEnd;
			cCurLen = (float)(iCurEnd - iCurBegin);
            curProm = pCurCell->m_Accent_Prom * (float)0.1;

            //-----------------------------------
            // Get NEXT allo
            //-----------------------------------
            iNextBegin = pNextCell->m_PitchBufStart;
            iNextEnd = pNextCell->m_PitchBufEnd;

            m_CurAccent = pCurCell->m_ToBI_Accent;
			//---------------------
			// Diagnostic
			//---------------------
            m_CurAccentSource = pCurCell->m_AccentSource;
            m_CurBoundarySource = pCurCell->m_BoundarySource;
            m_pCurTextStr = pCurCell->m_pTextStr;

            switch( pCurCell->m_ToBI_Accent )
            {
                case K_RSTAR:
                    break;

                case K_HSTAR:
                    {
                        if( !initialWord )        // We never add a 'leg' to a phrase-initial word
                        {
                            //----------------------------------------------
                            // Add a L leg to start to previous allo
                            //----------------------------------------------
                            if( iPrevBegin )
                            {
								loc = (long) ((iCurBegin + (cCurLen * 0.1f)));
						        value = ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);    // H*
                                value = pRefBuf[loc] + (value * 0.25f);    // L+H*
                                NewTarget( iPrevBegin, value );
                                //NewTarget( loc, value );
                            }
                        }
                        //----------------------------------------------
                        // Now plug in the H target
						//
						// If we're at a boundary, insert H at 
						// allo mid-point else insert at allo start
                        //----------------------------------------------
				        if( pCurCell->m_ToBI_Boundary != K_NOBND )
                        {
                            //---------------------------
                            // Insert H* at allo start 
                            //---------------------------
                            loc = (long) iCurBegin;
                        }
                        else 
                        {
                            //---------------------------
                            // Insert H* at allo mid-point 
                            //---------------------------
					        loc = (long) (iCurBegin + (cCurLen * K_HSTAR_OFFSET));
                        }
                        value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);    // H*
                        NewTarget( loc, value );
                    }
                    break;

            case K_LSTAR:
                {
					//------------------------------------
					// Insert L* at mid-point
					//------------------------------------
                    loc = (long) (iCurBegin + (cCurLen * 0.3f));
                    value = pRefBuf[loc] - ((pRefBuf[loc] - pFloorBuf[loc]) * curProm);   // L*
                    NewTarget( loc, value );
                }
                break;

            case K_LSTARH:
                {
					//----------------------------------------------
					// Insert L* at current start
					//----------------------------------------------
                    value = pRefBuf[iCurBegin] - ((pRefBuf[iCurBegin] - pFloorBuf[iCurBegin]) * curProm);   // L*+H
                    NewTarget( iCurBegin, value );
                    if( iNextBegin )
                    {
						//----------------------------------------------
						// Insert H at next end
						// set prom gain?
						//----------------------------------------------
                        value = pRefBuf[iNextEnd] - ((pRefBuf[iNextEnd] - pFloorBuf[iNextEnd])  * (curProm /* * .3 */ ));
                        NewTarget( iNextEnd, value );
                    }
                    lastProm = 0;
                }
                break;

            case K_LHSTAR:
                {
                    loc = (long) (iCurBegin + (cCurLen * 0.3f));
                    if( iPrevBegin )
                    {
						//----------------------------------------------
						// Insert L at previous start
						//----------------------------------------------
                        value = (pRefBuf[iPrevBegin] - ((pRefBuf[iPrevBegin] - pFloorBuf[iPrevBegin]) * (curProm * 0.3f)));    // L+H*
                        NewTarget( iPrevBegin, value );
                    }
					//----------------------------------------------
					// Insert H* at current mid-point
					//----------------------------------------------
                    value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);         // H*
                    NewTarget( loc, value );
                    lastProm = curProm;
                }
                break;

            case K_HSTARLSTAR:
                {
                    //value = pRefBuf[iCurBegin] + ((pCeilBuf[iCurBegin] - pRefBuf[iCurBegin]) * curProm);         // H*
                    value = pRefBuf[0] + ((pCeilBuf[0] - pRefBuf[0]) * curProm);         // H*
                    NewTarget( iCurBegin, value );

                    loc = (long) (iCurBegin + (cCurLen * 0.75f));
                    value = pRefBuf[loc] - ((pRefBuf[loc] - pFloorBuf[loc]) * curProm);   // L*
                    NewTarget( loc, value );
                    lastProm = curProm;
                }
                break;
            case K_DHSTAR:
                {
                    loc = (long) ( iCurBegin + (cCurLen * 0.0f) );
                    if( lastProm )
                    {
                        lastProm *= K_HDOWNSTEP_COEFF;
                        value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * lastProm);   // !H*
                        NewTarget( loc, value );
                    }
                    //-----------------------------------------
                    // no previous H*, treat !H* like an H*
                    //-----------------------------------------
                    else 
                    {
                        value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);      // H*
                        NewTarget( loc, value );
                        lastProm = curProm;
                    }
                }
                break;

            default:        // Unknown accent specfied
                break;
            }

            //-------------------------------------------------------------
            // if there's a boundary, fill in pitch value(s)
            // assume the boundary is set to correct (voiced) final phone
            //-------------------------------------------------------------
            curProm = pCurCell->m_Boundary_Prom * (float)0.1;
            m_CurAccent =(TOBI_ACCENT) pCurCell->m_ToBI_Boundary;
			//---------------------
			// Diagnostic
			//---------------------
            m_CurAccentSource = pCurCell->m_AccentSource;
            m_CurBoundarySource = pCurCell->m_BoundarySource;
            m_pCurTextStr = pCurCell->m_pTextStr;
            switch( pCurCell->m_ToBI_Boundary )
            {
                case K_LMINUS:
                    {
                        value = pRefBuf[iCurEnd] - ((pRefBuf[iCurEnd] - pFloorBuf[iCurEnd]) * curProm);			// L-
                        NewTarget( iCurEnd, value );
                    }
                    break;

                case K_HMINUS:
                    {
                        value = pRefBuf[iCurEnd] + ((pCeilBuf[iCurEnd] - pRefBuf[iCurEnd]) * curProm);			// H-
                        NewTarget( iCurEnd, value );
                    }
                    break;

                //case K_LPERC:
                //case K_HPERC:

                case K_LMINUSLPERC:
                    {
                        value = pFloorBuf[iCurEnd];
                        //NewTarget( iCurEnd, value );
                        NewTarget( iCurBegin, value );
                    }
                    break;

                case K_HMINUSHPERC:
                    {
                        value = pCeilBuf[iCurEnd];
                        NewTarget( iCurEnd, value );
                    }
                    break;

                case K_LMINUSHPERC:																// L-H%
                    {
                        //---------------------------------------
                        // comma continuation rise
                        //---------------------------------------
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						// L starts at middle of previous phon
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        loc = iPrevBegin + (iPrevEnd - iPrevBegin) / 2;
                        value = pRefBuf[loc] - ((pRefBuf[loc] - pFloorBuf[loc]) * curProm);         // L-
                        NewTarget( loc, value );
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						// H at end of current phon
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        value = pRefBuf[iCurEnd] + ((pCeilBuf[iCurEnd] - pRefBuf[iCurEnd]) * curProm);          // H%
                        NewTarget( iCurEnd, value );
                    }
                    break;

                case K_HMINUSLPERC:
                    {
                        //---------------------------------------
                        // accent extension followed by sharp drop
                        //---------------------------------------
                        value = pRefBuf[iCurBegin] + ((pCeilBuf[iCurBegin] - pRefBuf[iCurBegin]) * curProm);          // H-
                        NewTarget( iCurBegin, value );
                        value = pFloorBuf[iCurEnd];													// L%
                        //loc = iCurBegin + ((iCurEnd - iCurBegin) * 0.1f);
                        NewTarget( iCurEnd, value );
                    }
                    break;

                default:
                    break;
            }
            //----------------------------
            // Unflag initial word
            //----------------------------
            if( (initialWord) && (pCurCell->m_ctrlFlags & WORD_START) )
            {
                wordCntDwn--;
                if( wordCntDwn < 0 )
                {
                    initialWord = false;
                }
            }

            //----------------------------
            // Setup for next allo
            //----------------------------
            iPrevBegin = iCurBegin;
            iPrevEnd = iCurEnd;

			pCurCell	= pNextCell;
			pNextCell	= m_pAllos->GetNextCell();
			iCellindex++;
        }

        //--- Debug Macro - Log pitch data to stream
        TTSDBG_LOGTOBI;

        ::SecondOrderInterp( cNumOfPoints, m_pContBuf );
        GetKnots();
    }

    if( pRefBuf )
    {
        delete pRefBuf;
    }
    if( pCeilBuf )
    {
        delete pCeilBuf;
    }
    if( pFloorBuf )
    {
        delete pFloorBuf;
    }
    if( m_pContBuf )
    {
        delete m_pContBuf;
    }
} /* CPitchProsody::PitchTrack */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\sentitemmemory.h ===
/******************************************************************************
* SentItemMemory.h *
*------------------*
*  This file defines and implements the CSentItemMemory class.  This class was
*  written to simplify memory management in the sentence enumerator.  The 
*  const SPVSTATE member of the SPVSENTITEM struct needs to be modified in the
*  sentence enumerator, both during normalization and during lexicon lookup.  
*  It was thus desireable to be able to free all of the memory which was 
*  dynamically created in the sentence enumerator at once, without having to,
*  for example, figure out which pronunciations were const (specified in the 
*  XML state) and which were dynamically created.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 12/6/99
*  All Rights Reserved
*
*********************************************************************** AKH ***/

struct MemoryChunk
{
    BYTE* pMemory;
    MemoryChunk* pNext;
};

class CSentItemMemory
{
public:

    CSentItemMemory( )
    {
        m_pHead = NULL;
        m_pCurr = NULL;
    }
    
    ~CSentItemMemory()
    {
        MemoryChunk *pIterator = m_pHead, *pTemp = 0;
        while (pIterator)
        {
            pTemp = pIterator->pNext;
            delete [] pIterator->pMemory;
            delete pIterator;
            pIterator = pTemp;
        }
    }

    void* GetMemory( ULONG ulBytes, HRESULT *hr )
    {
        void *Memory = 0;
        if (!m_pHead)
        {
            m_pHead = new MemoryChunk;
            if (m_pHead)
            {
                m_pHead->pNext = NULL;
                m_pHead->pMemory = new BYTE[ulBytes];
                if (m_pHead->pMemory)
                {
                    m_pCurr = m_pHead;
                    Memory = (void*) m_pHead->pMemory;
                }
                else
                {
                    *hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                *hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            m_pCurr->pNext = new MemoryChunk;
            if (m_pCurr->pNext)
            {
                m_pCurr = m_pCurr->pNext;
                m_pCurr->pNext = NULL;
                m_pCurr->pMemory = new BYTE[ulBytes];
                if (m_pCurr->pMemory)
                {
                    Memory = (void*) m_pCurr->pMemory;
                }
                else
                {
                    *hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                *hr = E_OUTOFMEMORY;
            }
        }
        return Memory;            
    }


private:

    MemoryChunk* m_pHead;
    MemoryChunk* m_pCurr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\spttsengdebug.h ===
/*******************************************************************************
* SpTtsEngDebug.h *
*-----------------*
*   Description:
*       This header file contains debug output services for the TTS Engine
*-------------------------------------------------------------------------------
*  Copyright (C) 1998-2000 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
********************************************************************* AKH ******/

#ifndef spttsengdebug_h
#define spttsengdebug_h

#include "stdsentenum.h"
#include "feedchain.h"

//--- This enumeration is used to index the array of IStreams used to write stuff to the debug file
typedef enum
{
    STREAM_WAVE = 0,
    STREAM_EPOCH,
    STREAM_UNIT,
    STREAM_WAVEINFO,
    STREAM_TOBI,
    STREAM_SENTENCEBREAKS,
    STREAM_NORMALIZEDTEXT,
    STREAM_LEXLOOKUP,
    STREAM_POSPOSSIBILITIES,
    STREAM_MORPHOLOGY,
    STREAM_LASTTYPE
} STREAM_TYPE;

#ifdef _DEBUG

//--- This struct is used to log units...
#pragma pack (1)
typedef struct 
{
    char        name[8];
    long        phonID;
    long        unitID;
    long        cSamples;
	float		time;
    long        cEpochs;
    long        knots;
    long        flags;
	long		ctrlFlags;
    float       pTime[KNOTS_PER_PHON];
    float       pF0[KNOTS_PER_PHON];
    float       pAmp[KNOTS_PER_PHON];
	enum SILENCE_SOURCE		silenceSource;
} UNIT_STREAM;
#pragma pack ()

//--- This struct is just used as a helper to initialize the PRONRECORD to all zeroes
struct DebugPronRecord : PRONRECORD
{
public:
    DebugPronRecord() { ZeroMemory( (void*) this, sizeof( DebugPronRecord ) ); }
    DebugPronRecord& operator =( PRONRECORD InRecord )
    {
        memcpy( this, &InRecord, sizeof( PRONRECORD ) );
        return (*this);
    }
};

//--- This struct is used to replace the SPVCONTEXT struct for outputting to the debug streams -
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugContext
{
    WCHAR Category[32];
    WCHAR Before[32];
    WCHAR After[32];
public:
    DebugContext() { ZeroMemory( (void*) this, sizeof( DebugContext ) ); }
    DebugContext& operator =( SPVCONTEXT InContext )
    {
        if ( InContext.pCategory )
        {
            wcsncpy( Category, InContext.pCategory, 
                     wcslen(InContext.pCategory) > 31 ? 31 : wcslen(InContext.pCategory) );
        }
        if ( InContext.pBefore )
        {
            wcsncpy( Before, InContext.pBefore,
                     wcslen(InContext.pBefore) > 31 ? 31 : wcslen(InContext.pBefore) );
        }
        if ( InContext.pAfter )
        {
            wcsncpy( After, InContext.pAfter,
                     wcslen(InContext.pAfter) > 31 ? 31 : wcslen(InContext.pAfter) );
        }
        return (*this);
    }
};

//--- This struct is used to replace the SPVSTATE struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugState
{
    SPVACTIONS      eAction;
    LANGID          LangID;
    WORD            wReserved;
    long            EmphAdj;
    long            RateAdj;
    ULONG           Volume;
    SPVPITCH        PitchAdj;
    ULONG           SilenceMSecs;
    SPPHONEID       PhoneIds[64];
    ENGPARTOFSPEECH  ePartOfSpeech;
    DebugContext    Context;
public:
    DebugState() { ZeroMemory( (void*) this, sizeof( DebugState ) ); }
    DebugState& operator =( SPVSTATE InState )
    {
        eAction         = InState.eAction;
        LangID          = InState.LangID;
        wReserved       = InState.wReserved;
        EmphAdj         = InState.EmphAdj;
        RateAdj         = InState.RateAdj;
        Volume          = InState.Volume;
        PitchAdj        = InState.PitchAdj;
        SilenceMSecs    = InState.SilenceMSecs;
        ePartOfSpeech   = (ENGPARTOFSPEECH)InState.ePartOfSpeech;
        Context         = InState.Context;
        if ( InState.pPhoneIds )
        {
            wcsncpy( PhoneIds, InState.pPhoneIds,
                     wcslen(InState.pPhoneIds) > 63 ? 63 : wcslen(InState.pPhoneIds) );
        }
        return (*this);
    }
};

//--- This struct is used to replace the TTSWord struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugWord
{
    DebugState      XmlState;
    WCHAR           WordText[32];
    ULONG           ulWordLen;
    WCHAR           LemmaText[32];
    ULONG           ulLemmaLen;
    SPPHONEID       WordPron[64];
    ENGPARTOFSPEECH  eWordPartOfSpeech;
public:
    DebugWord() { ZeroMemory( (void*) this, sizeof( DebugWord ) ); }
    DebugWord& operator =( TTSWord InWord )
    {
        XmlState = *(InWord.pXmlState);
        if ( InWord.pWordText )
        {
            wcsncpy( WordText, InWord.pWordText, InWord.ulWordLen > 31 ? 31 : InWord.ulWordLen );
        }
        ulWordLen = InWord.ulWordLen;
        if ( InWord.pLemma )
        {
            wcsncpy( LemmaText, InWord.pLemma, InWord.ulLemmaLen > 31 ? 31 : InWord.ulLemmaLen );
        }
        ulLemmaLen = InWord.ulLemmaLen;
        if ( InWord.pWordPron )
        {
            wcsncpy( WordPron, InWord.pWordPron,
                wcslen( InWord.pWordPron ) > 63 ? 63 : wcslen( InWord.pWordPron ) );
        }
        eWordPartOfSpeech = InWord.eWordPartOfSpeech;
        return (*this);
    }
};

struct DebugItemInfo
{
    TTSItemType Type;
public:
    DebugItemInfo() { ZeroMemory( (void*) this, sizeof( DebugItemInfo ) ); }
    DebugItemInfo& operator =( TTSItemInfo InItemInfo )
    {
        Type = InItemInfo.Type;
        return (*this);
    }
};

//--- This struct is used to replace the TTSSentItem struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugSentItem
{
    WCHAR           ItemSrcText[32];
    ULONG           ulItemSrcLen;
    ULONG           ulItemSrcOffset;
    DebugWord       Words[32];
    ULONG           ulNumWords;
    ENGPARTOFSPEECH  eItemPartOfSpeech;
    DebugItemInfo   ItemInfo;
public:
    DebugSentItem() { ZeroMemory( (void*) this, sizeof( DebugSentItem ) ); }
    DebugSentItem& operator =( TTSSentItem InItem )
    {
        if ( InItem.pItemSrcText )
        {
            wcsncpy( ItemSrcText, InItem.pItemSrcText, InItem.ulItemSrcLen > 31 ? 31 : InItem.ulItemSrcLen );
        }
        ulItemSrcLen        = InItem.ulItemSrcLen;
        ulItemSrcOffset     = InItem.ulItemSrcOffset;
        for ( ULONG i = 0; i < InItem.ulNumWords && i < 32; i++ )
        {
            Words[i] = InItem.Words[i];
        }
        ulNumWords          = InItem.ulNumWords;
        eItemPartOfSpeech   = InItem.eItemPartOfSpeech;
        if ( InItem.pItemInfo )
        {
            ItemInfo            = *(InItem.pItemInfo);
        }
        return (*this);
    }
};

//--- This enumeration should correspond to the previous one, and is used to name the array of IStreams
//---   used to write stuff to the debug file
static const SPLSTR StreamTypeStrings[] =
{
    DEF_SPLSTR( "Wave"           ),
    DEF_SPLSTR( "Epoch"          ),
    DEF_SPLSTR( "Unit"           ),
    DEF_SPLSTR( "WaveInfo"       ),
    DEF_SPLSTR( "ToBI"           ),
    DEF_SPLSTR( "SentenceBreaks" ),
    DEF_SPLSTR( "NormalizedText" ),
    DEF_SPLSTR( "LexLookup"      ),
    DEF_SPLSTR( "PosPossibilities" ),
    DEF_SPLSTR( "Morphology" ),
};

//--- This const is just the storage mode with which the debug file and its associated streams are opened
static const DWORD STORAGE_MODE = ( STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE );


#define TEXT_LEN_MAX	20
//--- This struct is used to keep track of pitch information for outputting to the debug streams
struct PITCH_TARGET
{
    float   time;
    float   level;
    enum TOBI_ACCENT accent;

	//--- Diagnostic
	enum ACCENT_SOURCE		accentSource;		
	enum BOUNDARY_SOURCE	boundarySource;
	char					textStr[TEXT_LEN_MAX];
};

//--- This class implements most of the functionality required for TTS Debugging Support
class CTTSDebug
{
public:

    //=== Interface Functions ===//

    //--- Constructor - just sets all member variables to NULL
    CTTSDebug() 
    {
        m_pDebugFile = NULL;
        for ( int i = 0; i < STREAM_LASTTYPE; i++ )
        {
            m_pDebugStreams[i] = NULL;
        }
        m_fInitialized = false;
    }

    //--- Destructor - just closes the file
    ~CTTSDebug()
    {
        CloseDebugFile();
    }

    //--- OpenDebugFile - opens a file (path is obtained from the Key DebugFile in the voices registry
    //---   entry) and associated streams...
    void OpenDebugFile( WCHAR *pFileName )
    {
        HRESULT hr = S_OK;
        hr = StgCreateDocfile( pFileName, STORAGE_MODE, 0, &m_pDebugFile );
        if ( SUCCEEDED( hr ) )
        {
            for ( int i = 0; SUCCEEDED( hr ) && i < STREAM_LASTTYPE; i++ )
            {
                hr = m_pDebugFile->CreateStream( StreamTypeStrings[i].pStr, STORAGE_MODE, 0, 0, &m_pDebugStreams[i] );
            }
        }
        if ( FAILED( hr ) )
        {
            CloseDebugFile();
        }
        else
        {
            m_fInitialized = true;
        }
    }

    //--- CloseDebugFile - just closes the file and streams opened by OpenDebugFile
    void    CloseDebugFile( void )
    {
        if ( m_pDebugFile )
        {
            for ( int i = 0; i < STREAM_LASTTYPE; i++ )
            {
                if ( m_pDebugStreams[i] )
                {
                    m_pDebugStreams[i]->Release();
                    m_pDebugStreams[i] = NULL;
                }
            }
            m_pDebugFile->Release();
            m_pDebugFile = NULL;
            m_fInitialized = false;
        }
    }

    //--- AppendToStream - writes data to the Stream specified by Type
    void    AppendToStream( STREAM_TYPE Type, void *pData, ULONG cBytes )
    {
        HRESULT hr = S_OK;
        hr = m_pDebugStreams[Type]->Write( pData, cBytes, NULL );
    }




    //--- AddPitchToList - keeps track of pitch targets which will later be output to a debug stream
    void    AddPitchToList( float time, 
							float level, 
							TOBI_ACCENT accent,
							ACCENT_SOURCE		accentSource,
							BOUNDARY_SOURCE	boundarySource,
							char *pTextStr)
    {
        PITCH_TARGET        *pNewPitch, *pNextPitch;
        SPLISTPOS           curPosition, nextPosition;

        pNewPitch = new PITCH_TARGET;
        if( pNewPitch )
        {
            pNewPitch->time = time;
            pNewPitch->level = level;
            pNewPitch->accent = accent;
			if( pTextStr )
			{
				strcpy( pNewPitch->textStr, pTextStr );
			}
			else
			{
				// No string
				pNewPitch->textStr[0] = 0;
			}
			pNewPitch->accentSource = accentSource;
			pNewPitch->boundarySource = boundarySource;

           if( PitchTargetList.IsEmpty() )
            {
                PitchTargetList.AddHead( pNewPitch );
            }
            else
            {
                nextPosition = PitchTargetList.GetHeadPosition();
                while( nextPosition )
                {
                    curPosition = nextPosition;
                    pNextPitch = (PITCH_TARGET*)PitchTargetList.GetNext( nextPosition );
                    if( time < pNextPitch->time )
                    {
                        PitchTargetList.InsertBefore( curPosition, pNewPitch );
                        break;
                    }
                    if( nextPosition == NULL )
                    {
                        PitchTargetList.AddTail( pNewPitch );
                        break;
                    }
                }
            }
        }
    }

    //--- DeletePitchList - Cleans up pitch target list after it has been output to a debug stream
    void DeletePitchList()
    {
        PITCH_TARGET *pTarget;
        while ( !PitchTargetList.IsEmpty() )
        {
            pTarget = (PITCH_TARGET*)PitchTargetList.RemoveHead();
            delete pTarget;
        }
    }

    //--- IsInitialized - Just returns true or false based on whether OpenDebugFile has been called
    //---   and has succeeded...
    bool    IsInitialized() { return m_fInitialized; }

    //=== Member Variables ===//

private:
    IStorage    *m_pDebugFile;
    IStream     *m_pDebugStreams[STREAM_LASTTYPE];
    bool        m_fInitialized;
public:
    CSPList<PITCH_TARGET*,PITCH_TARGET*> PitchTargetList;
};

inline CTTSDebug *pTTSDebug()
{
    static CTTSDebug debug;
    return &debug;
}


#define TTSDBG_OPENFILE                                                                     \
    do                                                                                      \
    {                                                                                       \
        CSpDynamicString dstrTemp;                                                          \
        CComPtr<ISpObjectToken> cpVoiceToken;                                               \
        cpVoiceToken = ((CVoiceDataObj*)m_pVoiceDataObj)->GetVoiceToken();                  \
        if ( SUCCEEDED( cpVoiceToken->GetStringValue( L"DebugFile", &dstrTemp) ) )          \
        {                                                                                   \
            pTTSDebug()->OpenDebugFile( dstrTemp );                                         \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_CLOSEFILE                                                                    \
    pTTSDebug()->CloseDebugFile()

#define TTSDBG_LOGITEMLIST( ItemList, Stream )                                              \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            SPLISTPOS ListPos = ItemList.GetHeadPosition();                                 \
            DebugSentItem Item;                                                             \
            pTTSDebug()->AppendToStream( Stream, (void*) &Item, sizeof( Item ) );           \
            while ( ListPos )                                                               \
            {                                                                               \
                ZeroMemory( &Item, sizeof( Item ) );                                        \
                Item = ItemList.GetNext( ListPos );                                         \
                pTTSDebug()->AppendToStream( Stream, (void*) &Item, sizeof( Item ) );       \
            }                                                                               \
            pItemEnum->Reset();                                                             \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_LOGPOSPOSSIBILITIES( pProns, ulNumWords, Stream )                            \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            ULONG ulIndex = 0;                                                              \
            DebugPronRecord dbgRecord;                                                      \
            pTTSDebug()->AppendToStream( Stream, (void*) &dbgRecord,                        \
                                         sizeof( DebugPronRecord ) );                       \
            while ( ulIndex < ulNumWords )                                                  \
            {                                                                               \
                dbgRecord = pProns[ulIndex];                                                \
                pTTSDebug()->AppendToStream( Stream, (void*) &dbgRecord,                    \
                                             sizeof( DebugPronRecord ) );                   \
                ulIndex++;                                                                  \
            }                                                                               \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_LOGMORPHOLOGY( pwRoot, SuffixList, Stream )                                  \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            pTTSDebug()->AppendToStream( Stream, (void*) pwRoot,                            \
                                         SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );            \
            SPLISTPOS ListPos = SuffixList.GetHeadPosition();                               \
            SUFFIXPRON_INFO* pSuffixPron;                                                   \
            while ( ListPos )                                                               \
            {                                                                               \
                pSuffixPron = SuffixList.GetNext( ListPos );                                \
                pTTSDebug()->AppendToStream( Stream, (void*) pSuffixPron->SuffixString,     \
                                             SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );        \
            }                                                                               \
            WCHAR Delimiter[SP_MAX_WORD_LENGTH];                                            \
            ZeroMemory( Delimiter, SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );                  \
            pTTSDebug()->AppendToStream( Stream, (void*) Delimiter,                         \
                                         SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );            \
        }                                                                                   \
    }                                                                                       \
    while (0)
                                             

#define TTSDBG_LOGWAVE                                                                      \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            if ( m_SpeechState == SPEECH_CONTINUE )                                         \
            {                                                                               \
                pTTSDebug()->AppendToStream( STREAM_WAVE, (void*)m_pSpeechBuf,              \
                                             m_cOutSamples_Frame * m_BytesPerSample );      \
            }                                                                               \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_ADDPITCHTARGET( time, level, accent)                                         \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            pTTSDebug()->AddPitchToList( time, level, accent, m_CurAccentSource, m_CurBoundarySource, m_pCurTextStr );                              \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_LOGTOBI                                                                      \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            SPLISTPOS       curPosition;                                                    \
            PITCH_TARGET    *pPitch;                                                        \
            curPosition = pTTSDebug()->PitchTargetList.GetHeadPosition();                   \
            while( curPosition )                                                            \
            {                                                                               \
                pPitch = (PITCH_TARGET*)pTTSDebug()->PitchTargetList.GetNext(curPosition);  \
                pTTSDebug()->AppendToStream( STREAM_TOBI, (void*)pPitch,                    \
                                             sizeof(PITCH_TARGET) );                        \
            }                                                                               \
            pTTSDebug()->DeletePitchList();                                                 \
        }                                                                                   \
    }                                                                                       \
    while (0)





#define TTSDBG_LOGSILEPOCH																		\
    do																							\
    {             																				\
        float	fEpoch;																			\
																								\
        if( pTTSDebug()->IsInitialized() )														\
        {																						\
			if( m_silMode )																		\
			{																					\
				fEpoch = (float)m_durationTarget;												\
				pTTSDebug()->AppendToStream( STREAM_EPOCH, (void*)&fEpoch, sizeof(float) );		\
			}                                                                                   \
		}																						\
    }																							\
    while (0)





#define TTSDBG_LOGEPOCHS																		\
    do																							\
    {             																				\
        if( pTTSDebug()->IsInitialized() )														\
        {																						\
			float	fEpoch;																		\
																								\
			if( OutSize > 1 )																	\
			{																					\
				fEpoch = (float)OutSize;														\
				pTTSDebug()->AppendToStream( STREAM_EPOCH, (void*)&fEpoch, sizeof(float) );		\
			}																					\
		}																						\
    }																							\
    while (0)



#define TTSDBG_LOGUNITS                                                                     \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            UNIT_STREAM         us;                                                         \
                                                                                            \
            us.phonID   = pCurUnit->PhonID;                                                 \
            us.unitID   = pCurUnit->UnitID;                                                 \
            us.flags    = pCurUnit->flags;                                                  \
			us.ctrlFlags	= pCurUnit->ctrlFlags;                                          \
            us.cEpochs  = 1;                                                                \
            us.cSamples = m_durationTarget;                                                 \
            us.time     = (float)m_cOutSamples_Total / m_SampleRate;                        \
            us.knots    = KNOTS_PER_PHON;                                                   \
            for( i = 0; i < KNOTS_PER_PHON; i++ )                                           \
            {                                                                               \
                us.pTime[i] = pCurUnit->pTime[i];                                           \
                us.pF0[i]   = pCurUnit->pF0[i];                                             \
                us.pAmp[i]  = pCurUnit->pAmp[i];                                            \
            }                                                                               \
            strcpy( us.name, pCurUnit->szUnitName );										\
			us.silenceSource = pCurUnit->silenceSource;                                     \
            pTTSDebug()->AppendToStream( STREAM_UNIT, (void*)&us, sizeof(UNIT_STREAM) );    \
        }                                                                                   \
    }                                                                                       \
    while (0)

#else // _DEBUG

#define TTSDBG_OPENFILE
#define TTSDBG_CLOSEFILE
#define TTSDBG_LOGITEMLIST(ItemList, Stream)
#define TTSDBG_LOGWAVE
#define TTSDBG_ADDPITCHTARGET(time, level, accent)
#define TTSDBG_LOGTOBI
#define TTSDBG_LOGEPOCHS
#define TTSDBG_LOGSILEPOCH
#define TTSDBG_LOGUNITS
#define TTSDBG_LOGPOSPOSSIBILITIES( pProns, ulNumWords, Stream )
#define TTSDBG_LOGMORPHOLOGY( pwRoot, SuffixList, Stream )

#endif // _DEBUG
#endif // spttsengdebug_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\reverbfx.h ===
/******************************************************************************
* ReverbFX.h *
*-------------*
*  This is the header file for the CReverbFX implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

#ifndef ReverbFX_H
#define ReverbFX_H

#ifndef __spttseng_h__
#include "spttseng.h"
#endif


//-------------------------------------------------------------
// Comment-out line below if you want 
//  integer math instead of floating point.
//
// NOTE:
//   Bathtub preset probably won't work
//   using integer math (overflow)
//-------------------------------------------------------------
#define FLOAT_REVERB    1

#ifdef FLOAT_REVERB
    #define REVERBT     float
    #define REVERBL     float
#else
    #define REVERBT     short
    #define REVERBL     long
#endif


#ifdef FLOAT_REVERB
    static const float REVERB_VOL_OFF     =  0.0;
    static const float REVERB_VOL_UNITY    =  1.0f;
    static const float REVERB_MIN_MIX      =  0.001f;
#else
    static const long REVERB_VOL_SHIFT    =  (16);
    static const long REVERB_VOL_LEVELS   =  65536;
    static const long REVERB_VOL_OFF      =  0;
    static const long REVERB_VOL_UNITY    =  REVERB_VOL_LEVELS;
#endif

static const float REVERB_MIN_DB       =  (-110.0);
static const long KMAXREVBMODS        =  5;

static const long KWORKBUFLEN         =  1024;



//-------------------------------------
// Reverb preset parametrs
//-------------------------------------
struct REVERBCONFIG
{
    float       wetGain_dB;             // WET gain (db)
    float       dryGain_dB;             // DRY gain (db)

    short       numOfReflect;           // Number of modules
    float       *gain_ms_Array;         // Array of delay values (ms)
    float       *gain_dB_Array;         // Array of gain values (db)
    float       seqIndex;               // "sequencer" fx
}; 
typedef struct REVERBCONFIG REVERBCONFIG, *LPREVERBCONFIG;



struct Reverb_Mod
{
    REVERBL     lGain;                  // Gain of the amplifiers.
    long        dwDelay;                // Length of the delay line.
    long        dwDelayBufferSize;      // Size of the delay buffer.
    REVERBT     *psDelayBuffer;         // Circular delay buffer, length dwDelay.
    REVERBT     *psDelayIn;             // Current input position in the delay.
    REVERBT     *psDelayOut;            // Current output position in the delay.
    REVERBT     *psDelayEnd;            // Location immediately following the buffer.
}; 
typedef struct Reverb_Mod Reverb_Mod, *LP_Reverb_Mod;


//----------------------------------
// Reverb error codes
//----------------------------------
static const long KREVERB_NOERROR     = 0;
static const long KREVERB_MEMERROR    = 1;
static const long KREVERB_OFF         = 2;


//-----------------------------------------
// ReverbFX Class
//-----------------------------------------
class CReverbFX
{
public:
    //----------------------------------
    // Initialization functions
    //----------------------------------
    CReverbFX( void );
    ~CReverbFX( void );

    short   Reverb_Init
                    (
                    REVERBTYPE reverbPreset,    // Configuration preset
                    long    nSamplesPerSec,     // SampleRate
                    long    stereoOut           // true = output is stero
                    );
private:
    REVERBL DecibelToPercent( float flDecibel );
    void    ClearReverb( LP_Reverb_Mod mod );
    short   AllocReverbModule 
                    (
                    LP_Reverb_Mod   mod,
                    REVERBL         lGain,              // Gain of the amplifiers.
                    long            dwDelay,            // Length of the delay line.
                    long            dwDelayBufferSize   // Size of the delay buffer.
                    );
    short   CreateReverbModules
                    (
                    short           wModules,           // Number of modules to create.
                    LP_Reverb_Mod   *mods,
                    float *         pfltDelay,          // Array of delay values for the modules.
                    float *         pfltDB,             // Array of gain values for the modules.
                    float           fltSamplesPerMS     // Number of samples per millisecond.
                    );
    void    DeleteReverbModules ();
    LPREVERBCONFIG  GetReverbConfig( REVERBTYPE dwReverbConfig );

    //----------------------------------
    // Run-time
    //----------------------------------
    void    CopyWithGain
                    (   
                    REVERBT     *psDest,
                    REVERBT     *psSource,
                    long        dwSamples,
                    REVERBL     gain
                    );
    void    MixWithGain_STEREO
                    (
                    REVERBT     *pWet,
                    REVERBT     *pDry,
                    short       *pDest,
                    long        dwSamples,
                    REVERBL     gain
                    );
    void    MixWithGain_MONO
                    (
                    REVERBT     *pWet,
                    REVERBT     *pDry,
                    short       *pDest,
                    long        dwSamples,
                    REVERBL     gain
                    );
    void    ProcessReverbModule
                    (
                    LP_Reverb_Mod   mod,
                    long            dwDestSamples,      // Number of samples to process.
                    REVERBT         *pSource,           // Source sample buffer.
                    REVERBT         *pDestination       // Destination sample buffer.
                    );
    void    ProcessReverbBuffer
                    (   
                    REVERBT         *psSample,      // Samples to process (in/out).
                    long            wSamples,       // Number of samples to process.
                    LP_Reverb_Mod   *mods           // Array of modules to apply.
                    );

public:
    short Reverb_Process( float *sampleBuffer, long dwSamplesRemaining, float audioGain );

private:
    //----------------------------------
    // Member Variables
    //----------------------------------
    long            m_StereoOut;
    long            m_dwWorkBufferSize;
    REVERBT         *m_pWorkBuf;
    REVERBL         m_wetVolGain;
    REVERBL         m_dryVolGain;
    long            m_numOfMods;
    LP_Reverb_Mod   m_Reverb_Mods[KMAXREVBMODS];

    LPREVERBCONFIG  m_pReverbConfig;

    float           m_Count;
    float           m_LenScale;
};
typedef CReverbFX *LP_CReverbFX;




#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3F7C4D2C_D007_11D2_B503_00C04F797396__INCLUDED_)
#define AFX_STDAFX_H__3F7C4D2C_D007_11D2_B503_00C04F797396__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <math.h>
#include <tchar.h>

#include <SPDDKHlp.h>
#include <SPCollec.h>
#include <spunicode.h>
//
//  String handling and conversion classes
//
/*** SPLSTR
*   This structure is for managing strings with known lengths
*/
struct SPLSTR
{
    WCHAR*  pStr;
    int     Len;
};
#define DEF_SPLSTR( s ) { L##s , sp_countof( s ) - 1 }

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3F7C4D2C_D007_11D2_B503_00C04F797396__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\stdsentenum.cpp ===
/*******************************************************************************
* StdSentEnum.cpp *
*-----------------*
*   Description:
*       This module is the main implementation file for the CStdSentEnum class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 03/19/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif
#include "spttsengdebug.h"
#include "SpAutoObjectLock.h"

//--- Locals 
CComAutoCriticalSection CStdSentEnum::m_AbbrevTableCritSec;

//=== CStdSentEnum ============================================================
//

/*****************************************************************************
* CStdSentEnum::InitPron *
*------------------------*
*   Description:
*       Inits pron tables
********************************************************************* AH ***/
HRESULT CStdSentEnum::InitPron( WCHAR** OriginalPron )
{
    HRESULT hr = S_OK;
    WCHAR *NewPron = NULL;

    NewPron = new WCHAR[ wcslen( *OriginalPron ) ];
    hr = m_cpPhonemeConverter->PhoneToId( *OriginalPron, NewPron );
    if ( SUCCEEDED( hr ) )
    {
        *OriginalPron = NewPron;
    }

    return hr;
} /* InitPron */

/*****************************************************************************
* CStdSentEnum::FinalConstruct *
*------------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT CStdSentEnum::FinalConstruct()
{
    SPDBG_FUNC( "CStdSentEnum::FinalConstruct" );
    HRESULT hr = S_OK;
    m_dwSpeakFlags  = 0;
    m_pTextFragList = NULL;
    m_pMorphLexicon = NULL;
    m_eSeparatorAndDecimal = COMMA_PERIOD;
    m_eShortDateOrder      = MONTH_DAY_YEAR;
    /*** Create phone converter ***/
    if ( SUCCEEDED( hr ) )
    {
        hr = SpCreatePhoneConverter( 1033, NULL, NULL, &m_cpPhonemeConverter );
        m_AbbrevTableCritSec.Lock();
        if ( !g_fAbbrevTablesInitialized )
        {
            for ( ULONG i = 0; SUCCEEDED( hr ) && i < sp_countof( g_AbbreviationTable ); i++ )
            {
                if ( g_AbbreviationTable[i].pPron1 )
                {
                    hr = InitPron( &g_AbbreviationTable[i].pPron1 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AbbreviationTable[i].pPron2 )
                {
                    hr = InitPron( &g_AbbreviationTable[i].pPron2 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AbbreviationTable[i].pPron3 )
                {
                    hr = InitPron( &g_AbbreviationTable[i].pPron3 );
                }
            }
            for ( i = 0; SUCCEEDED( hr ) && i < sp_countof( g_AmbiguousWordTable ); i++ )
            {
                if ( g_AmbiguousWordTable[i].pPron1 )
                {
                    hr = InitPron( &g_AmbiguousWordTable[i].pPron1 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AmbiguousWordTable[i].pPron2 )
                {
                    hr = InitPron( &g_AmbiguousWordTable[i].pPron2 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AmbiguousWordTable[i].pPron3 )
                {
                    hr = InitPron( &g_AmbiguousWordTable[i].pPron3 );
                }
            }
            for ( i = 0; SUCCEEDED( hr ) && i < sp_countof( g_PostLexLookupWordTable ); i++ )
            {
                if ( g_PostLexLookupWordTable[i].pPron1 )
                {
                    hr = InitPron( &g_PostLexLookupWordTable[i].pPron1 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_PostLexLookupWordTable[i].pPron2 )
                {
                    hr = InitPron( &g_PostLexLookupWordTable[i].pPron2 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_PostLexLookupWordTable[i].pPron3 )
                {
                    hr = InitPron( &g_PostLexLookupWordTable[i].pPron3 );
                }
            }
            if ( SUCCEEDED( hr ) )
            {
                hr = InitPron( &g_pOfA );
                if ( SUCCEEDED( hr ) )
                {
                    hr = InitPron( &g_pOfAn );
                }
            }
        }
        if ( SUCCEEDED( hr ) )
        {
            g_fAbbrevTablesInitialized = true;
        }
        m_AbbrevTableCritSec.Unlock();
    }

    return hr;
} /* CStdSentEnum::FinalConstruct */

/*****************************************************************************
* CStdSentEnum::FinalRelease *
*----------------------------*
*   Description:
*       Destructor
********************************************************************* EDC ***/
void CStdSentEnum::FinalRelease()
{
    SPDBG_FUNC( "CStdSentEnum::FinalRelease" );

    if ( m_pMorphLexicon )
    {
        delete m_pMorphLexicon;
    }
    
} /* CStdSentEnum::FinalRelease */

/*****************************************************************************
* CStdSentEnum::SetFragList *
*---------------------------*
*   The text fragment list passed in is guaranteed to be valid for the lifetime
*   of this object. Each time this method is called, the sentence enumerator
*   should reset its state.
********************************************************************* EDC ***/
STDMETHODIMP CStdSentEnum::
    SetFragList( const SPVTEXTFRAG* pTextFragList, DWORD dwSpeakFlags )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::SetFragList" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_READ_PTR( pTextFragList ) || 
        ( dwSpeakFlags & SPF_UNUSED_FLAGS ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_dwSpeakFlags   = dwSpeakFlags;
        m_pTextFragList  = pTextFragList;

        //--- Reset state
        Reset();
    }

    return hr;
} /* CStdSentEnum::SetFragList */

/*****************************************************************************
* CStdSentEnum::Next *
*--------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CStdSentEnum::Next( IEnumSENTITEM **ppSentItemEnum )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::Next" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SPIsBadWritePtr( ppSentItemEnum, sizeof( IEnumSENTITEM* ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- If this is NULL then the enum needs to be reset
        if( m_pCurrFrag )
        {
            SentencePointer NewSentencePointer;
            NewSentencePointer.pSentenceFrag = m_pCurrFrag;
            NewSentencePointer.pSentenceStart = m_pNextChar;

            hr = GetNextSentence( ppSentItemEnum );
            if( hr == S_OK ) 
            {
                //--- Update Sentence Pointer List
                hr = m_SentenceStack.Push( NewSentencePointer );
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
} /* CStdSentEnum::Next */

/*****************************************************************************
* CStdSentEnum::Previous *
*--------------------*
*
********************************************************************* AH ****/
STDMETHODIMP CStdSentEnum::Previous( IEnumSENTITEM **ppSentItemEnum )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::Previous" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SPIsBadWritePtr( ppSentItemEnum, sizeof( IEnumSENTITEM* ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Don't care if m_pCurrFrag is NULL, as long as we have enough on the SentenceStack
        //---   to skip backwards...
        if( m_SentenceStack.GetCount() >= 2 )
        {
            //--- Get the previous Sentence from the Sentence List, and then remove the Current Sentence
            SentencePointer &PreviousSentence = m_SentenceStack.Pop();
            PreviousSentence = m_SentenceStack.Pop();

            //--- Reset the current frag and the current text pointer position
            m_pCurrFrag = PreviousSentence.pSentenceFrag;
            m_pNextChar = PreviousSentence.pSentenceStart;
            m_pEndChar  = m_pCurrFrag->pTextStart + m_pCurrFrag->ulTextLen;

            hr = GetNextSentence( ppSentItemEnum );
            if( hr == S_OK ) 
            {
                //--- Update Sentence Pointer List
                hr = m_SentenceStack.Push( PreviousSentence );
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
} /* CStdSentEnum::Previous */

/*****************************************************************************
* SkipWhiteSpaceAndTags *
*-----------------------*
*   Skips m_pNextChar ahead to the next non-whitespace character (skipping
*   ahead in the frag list, if necessary) or sets it to NULL if it hits the 
*   end of the frag list text...
********************************************************************* AH ****/
HRESULT CStdSentEnum::SkipWhiteSpaceAndTags( const WCHAR*& pStartChar, const WCHAR*& pEndChar, 
                                             const SPVTEXTFRAG*& pCurrFrag, CSentItemMemory& MemoryManager, 
                                             BOOL fAddToItemList, CItemList* pItemList )
{
    SPDBG_ASSERT( pStartChar <= pEndChar );
    HRESULT hr = S_OK;

    while ( pStartChar &&
            ( IsSpace( *pStartChar ) ||
              pStartChar == pEndChar ) )
    {
        //--- Skip whitespace
        while ( pStartChar < pEndChar &&
                IsSpace( *pStartChar ) ) 
        {
            ++pStartChar;
        }
        //--- Skip to next spoken frag, if necessary
        if ( pStartChar == pEndChar )
        {
            pCurrFrag = pCurrFrag->pNext;
            while ( pCurrFrag &&
                    pCurrFrag->State.eAction != SPVA_Speak &&
                    pCurrFrag->State.eAction != SPVA_SpellOut )
            {
                pStartChar = (WCHAR*) pCurrFrag->pTextStart;
                pEndChar   = (WCHAR*) pStartChar + pCurrFrag->ulTextLen;
                //--- Add non-spoken fragments, if fAddToItemList is true.
                if ( fAddToItemList )
                {
                    CSentItem Item;
                    Item.pItemSrcText    = pCurrFrag->pTextStart;
                    Item.ulItemSrcLen    = pCurrFrag->ulTextLen;
                    Item.ulItemSrcOffset = pCurrFrag->ulTextSrcOffset;
                    Item.ulNumWords      = 1;
                    Item.Words           = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( Item.Words, sizeof(TTSWord) );
                        Item.Words[0].pXmlState         = &pCurrFrag->State;
                        Item.Words[0].eWordPartOfSpeech = MS_Unknown;
                        Item.eItemPartOfSpeech          = MS_Unknown;
                        Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            Item.pItemInfo->Type = eWORDLIST_IS_VALID;
                            pItemList->AddTail( Item );
                        }
                    }
                }
                pCurrFrag = pCurrFrag->pNext;
            }
            if ( !pCurrFrag )
            {
                pStartChar = NULL;
                pEndChar   = NULL;
            }
            else
            {
                pStartChar  = (WCHAR*) pCurrFrag->pTextStart;
                pEndChar    = (WCHAR*) pStartChar + pCurrFrag->ulTextLen;
            }
        }
    }
    return hr;
} /* SkipWhiteSpaceAndTags */

/*****************************************************************************
* FindTokenEnd *
*--------------*
*   Returns the position of the first whitespace character after pStartChar,
*   or pEndChar, or the character after SP_MAX_WORD_LENGTH, whichever comes first.
********************************************************************* AH ****/
const WCHAR* CStdSentEnum::FindTokenEnd( const WCHAR* pStartChar, const WCHAR* pEndChar )
{
    SPDBG_ASSERT( pStartChar < pEndChar );
    ULONG ulNumChars = 1;
    const WCHAR *pPos = pStartChar;

    while ( pPos              &&
            pPos < pEndChar   &&
            !IsSpace( *pPos ) &&
            ulNumChars < SP_MAX_WORD_LENGTH )
    {
        pPos++;
        ulNumChars++;
    }

    return pPos;
} /* FindTokenEnd */

/*****************************************************************************
* CStdSentEnum::AddNextSentItem *
*-------------------------------*
*   Locates the next sentence item in the stream and adds it to the list.
*   Returns true if the last item added is the end of the sentence.  
********************************************************************* AH ****/
HRESULT CStdSentEnum::AddNextSentItem( CItemList& ItemList, CSentItemMemory& MemoryManager, BOOL* pfIsEOS )
{
    SPDBG_ASSERT( m_pNextChar && pfIsEOS );
    HRESULT hr = S_OK;
    BOOL fHitPauseItem = false;
    CSentItem Item;
    ULONG ulTrailItems = 0;
    TTSItemType ItemType = eUNMATCHED;
    *pfIsEOS = false;

    //--- Skip initial whitespace characters and XML markup (by skipping ahead in the frag list).
    hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &ItemList );

    //--- This will happen when we hit the end of the frag list
    if ( !m_pNextChar )
    {
        return S_OK;
    }

    //--- Find end of the next token (next whitespace character, hyphen, or m_pEndChar).
    m_pEndOfCurrToken = FindTokenEnd( m_pNextChar, m_pEndChar );

    //--- Get Primary Insert Position
    SPLISTPOS ItemPos = ItemList.AddTail( Item );

    //--- Try looking up this token in the User Lexicon...
    WCHAR Temp = *( (WCHAR*) m_pEndOfCurrToken );
    *( (WCHAR*) m_pEndOfCurrToken ) = 0;
    SPWORDPRONUNCIATIONLIST SPList;
    ZeroMemory( &SPList, sizeof( SPWORDPRONUNCIATIONLIST ) );

    hr = m_cpAggregateLexicon->GetPronunciations( m_pNextChar, 1033, eLEXTYPE_USER, &SPList );
    if( SPList.pvBuffer )
    {
        ::CoTaskMemFree( SPList.pvBuffer );
    }
    
    *( (WCHAR*) m_pEndOfCurrToken ) = Temp;

    if ( SUCCEEDED( hr ) )
    {
        Item.eItemPartOfSpeech = MS_Unknown;
        Item.pItemSrcText      = m_pNextChar;
        Item.ulItemSrcLen      = (ULONG) ( m_pEndOfCurrToken - m_pNextChar );
        Item.ulItemSrcOffset   = m_pCurrFrag->ulTextSrcOffset +
                                 (ULONG)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords        = 1;
        Item.Words              = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState         = &m_pCurrFrag->State;
            Item.Words[0].pWordText         = m_pNextChar;
            Item.Words[0].ulWordLen         = Item.ulItemSrcLen;
            Item.Words[0].pLemma            = Item.Words[0].pWordText;
            Item.Words[0].ulLemmaLen        = Item.Words[0].ulWordLen;
            Item.Words[0].eWordPartOfSpeech = MS_Unknown;
            Item.eItemPartOfSpeech          = MS_Unknown;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo*), &hr );
            if ( SUCCEEDED( hr ) )
            {
                Item.pItemInfo->Type = eALPHA_WORD;
                ItemList.SetAt( ItemPos, Item );
            }
        }
        m_pNextChar = m_pEndOfCurrToken;
    }
    //--- Not in the user lex - itemize, normalize, etc.
    else if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = S_OK;

        //--- convert text from Unicode to Ascii
        hr = DoUnicodeToAsciiMap( m_pNextChar, (ULONG)( m_pEndOfCurrToken - m_pNextChar ), (WCHAR*)m_pNextChar );

        if ( SUCCEEDED( hr ) )
        {
            //--- Find end of the next token (next whitespace character, hyphen, or m_pEndChar) 
            //---   AGAIN, since the mapping may have introduced new whitespace characters...
            m_pEndOfCurrToken = FindTokenEnd( m_pNextChar, m_pEndChar );

            //--- Insert lead items (group beginnings, quotation marks)
            while ( m_pNextChar < m_pEndOfCurrToken &&
                    ( ( ItemType = IsGroupBeginning( *m_pNextChar ) )    != eUNMATCHED ||
                      ( ItemType = IsQuotationMark( *m_pNextChar ) )     != eUNMATCHED ) )
            {
                CSentItem LeadItem;
                LeadItem.pItemSrcText       = m_pNextChar;
                LeadItem.ulItemSrcLen       = 1;
                LeadItem.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                              (ULONG)(( m_pNextChar - m_pCurrFrag->pTextStart ));
                LeadItem.ulNumWords         = 1;
                LeadItem.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( LeadItem.Words, sizeof(TTSWord) );
                    LeadItem.Words[0].pXmlState         = &m_pCurrFrag->State;
                    LeadItem.Words[0].eWordPartOfSpeech = ConvertItemTypeToPartOfSp( ItemType );
                    LeadItem.eItemPartOfSpeech          = ConvertItemTypeToPartOfSp( ItemType );
                    LeadItem.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        LeadItem.pItemInfo->Type = ItemType;
                        if ( m_dwSpeakFlags & SPF_NLP_SPEAK_PUNC ||
                             m_pCurrFrag->State.eAction == SPVA_SpellOut )
                        {
                            CWordList TempWordList;
                            ExpandPunctuation( TempWordList, *m_pNextChar );
                            hr = SetWordList( LeadItem, TempWordList, MemoryManager );
                            LeadItem.pItemInfo->Type = eUNMATCHED;
                        }
                        ItemList.InsertBefore( ItemPos, LeadItem );
                        m_pNextChar++;
                    }
                }
                ItemType = eUNMATCHED;
            }

            //--- Insert trail items (group endings, quotation marks, misc. punctuation, EOS Items)
            m_pEndOfCurrItem = m_pEndOfCurrToken;
            BOOL fAddTrailItem = true;
            BOOL fAbbreviation = false;
            while ( (m_pEndOfCurrItem - 1) >= m_pNextChar &&
                    fAddTrailItem )
            {
                fAddTrailItem = false;
                fAbbreviation = false;

                //--- Check group endings, quotation marks, misc. punctuation.
                if ( ( ItemType = IsGroupEnding( *(m_pEndOfCurrItem - 1) ) )       != eUNMATCHED ||
                     ( ItemType = IsQuotationMark( *(m_pEndOfCurrItem - 1) ) )     != eUNMATCHED ||
                     ( ItemType = IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) )   != eUNMATCHED )
                {
                    fAddTrailItem = true;
                    if ( ItemType == eCOMMA ||
                         ItemType == eCOLON ||
                         ItemType == eSEMICOLON )
                    {
                        fHitPauseItem = true;
                    }
                }
                //--- Check EOS Items, except periods preceded by alpha characters
                else if ( ( ItemType = IsEOSItem( *(m_pEndOfCurrItem - 1) ) ) != eUNMATCHED &&
                          ! ( ItemType == ePERIOD                     &&
                              ( m_pEndOfCurrItem - 2 >= m_pNextChar ) &&
                              ( iswalpha( *(m_pEndOfCurrItem - 2) ) ) ) )
                {
                    //--- Check for ellipses
                    if ( ItemType == ePERIOD )
                    {
                        if ( m_pEndOfCurrItem == m_pEndOfCurrToken                              &&
                             ( m_pEndOfCurrItem - 2 >= m_pNextChar )                            &&
                             ( ( ItemType = IsEOSItem( *(m_pEndOfCurrItem - 2) ) ) == ePERIOD ) &&
                             ( m_pEndOfCurrItem - 3 == m_pNextChar )                            &&
                             ( ( ItemType = IsEOSItem( *(m_pEndOfCurrItem - 3) ) ) == ePERIOD ) )
                        {
                            fAddTrailItem = true;
                            ItemType      = eELLIPSIS;
                        }
                        else
                        {
                            ItemType      = ePERIOD;
                            fAddTrailItem = true;
                            *pfIsEOS      = true;
                        }
                    }
                    else
                    {
                        fAddTrailItem   = true;
                        *pfIsEOS        = true;
                    }
                }
                //--- Period preceded by alpha character - determine whether it is EOS.
                else if ( ItemType == ePERIOD )
                {
                    //--- Is it an Initialism ( e.g. "e.g." )?  If so, only EOS if the next
                    //---   word is in the common first words list...
                    hr = IsInitialism( ItemList, ItemPos, MemoryManager, pfIsEOS );
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( *pfIsEOS )
                        {
                            //--- Did we see a pause item earlier?  In that case, we should NOT listen to this 
                            //--- IsEOS decision from IsInitialism...
                            if ( fHitPauseItem )
                            {
                                *pfIsEOS = false;
                            }
                            else
                            {
                                fAddTrailItem = true;
                                fAbbreviation = true;
                            }
                        }
                    }
                    else if ( hr == E_INVALIDARG )
                    {
                        const WCHAR temp = (WCHAR) *( m_pEndOfCurrItem - 1 );
                        *( (WCHAR*) ( m_pEndOfCurrItem - 1 ) ) = 0;

                        const AbbrevRecord* pAbbrevRecord =
                            (AbbrevRecord*) bsearch( (void*) m_pNextChar, (void*) g_AbbreviationTable,
                                                     sp_countof( g_AbbreviationTable ), sizeof( AbbrevRecord ),
                                                     CompareStringAndAbbrevRecord );

                        *( (WCHAR*) ( m_pEndOfCurrItem - 1 ) ) = temp;

                        if ( pAbbrevRecord )
                        {
                            //--- Matched an abbreviation
                            if ( pAbbrevRecord->iSentBreakDisambig < 0 )
                            {
                                //--- Abbreviation will never end a sentence - just insert into ItemList
                                *pfIsEOS        = false;
                                hr              = S_OK;

                                Item.pItemSrcText       = m_pNextChar;
                                Item.ulItemSrcLen       = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                                Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                                          (ULONG)( m_pNextChar - m_pCurrFrag->pTextStart );
                                Item.ulNumWords         = 1;
                                Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof( TTSWord ), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    ZeroMemory( Item.Words, sizeof( TTSWord ) );
                                    Item.Words[0].pXmlState  = &m_pCurrFrag->State;
                                    Item.Words[0].pWordText  = Item.pItemSrcText;
                                    Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
                                    Item.Words[0].pLemma     = Item.pItemSrcText;
                                    Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
                                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
                                    if ( SUCCEEDED( hr ) )
                                    {
                                        if ( NeedsToBeNormalized( pAbbrevRecord ) )
                                        {
                                            Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                                        }
                                        else
                                        {
                                            Item.pItemInfo->Type = eABBREVIATION;
                                        }
                                        ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbrevRecord;
                                        ItemList.SetAt( ItemPos, Item );
                                    }
                                }
                            }
                            else
                            {
                                //--- Need to do some disambiguation to determine whether,
                                //---   a) this is indeed an abbreviation (e.g. "Ed.")
                                //---   b) the period doubles as EOS
                                hr = ( this->*g_SentBreakDisambigTable[pAbbrevRecord->iSentBreakDisambig] ) 
                                                ( pAbbrevRecord, ItemList, ItemPos, MemoryManager, pfIsEOS );
                                if ( SUCCEEDED( hr ) )
                                {
                                    if ( *pfIsEOS )
                                    {
                                        if ( fHitPauseItem )
                                        {
                                            *pfIsEOS = false;
                                        }
                                        else
                                        {
                                            fAddTrailItem = true;
                                            fAbbreviation = true;
                                        }
                                    }
                                }
                            }
                        }

                        if ( hr == E_INVALIDARG )
                        {
                            //--- Just check for periods internal to the item - this catches stuff like
                            //---   10:30p.m.
                            for ( const WCHAR* pIterator = m_pNextChar; pIterator < m_pEndOfCurrItem - 1; pIterator++ )
                            {
                                if ( *pIterator == L'.' )
                                {
                                    *pfIsEOS = false;
                                    break;
                                }
                            }
                            //--- If all previous checks have failed, it is EOS.
                            if ( pIterator == ( m_pEndOfCurrItem - 1 ) &&
                                 !fHitPauseItem )
                            {
                                hr              = S_OK;
                                fAddTrailItem   = true;
                                *pfIsEOS        = true;
                            }
                            else if ( hr == E_INVALIDARG )
                            {
                                hr = S_OK;
                            }
                        }
                    }
                }

                //--- Add trail item.
                if ( fAddTrailItem )
                {
                    ulTrailItems++;
                    CSentItem TrailItem;
                    if ( ItemType == eELLIPSIS )
                    {
                        TrailItem.pItemSrcText      = m_pEndOfCurrItem - 3;
                        TrailItem.ulItemSrcLen      = 3;
                        TrailItem.ulItemSrcOffset   = m_pCurrFrag->ulTextSrcOffset +
                                                      (ULONG)( m_pEndOfCurrItem - m_pCurrFrag->pTextStart - 3 );
                    }
                    else
                    {
                        TrailItem.pItemSrcText       = m_pEndOfCurrItem - 1;
                        TrailItem.ulItemSrcLen       = 1;
                        TrailItem.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                                       (ULONG)( m_pEndOfCurrItem - m_pCurrFrag->pTextStart - 1 );
                    }
                    TrailItem.ulNumWords         = 1;
                    TrailItem.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( TrailItem.Words, sizeof(TTSWord) );
                        TrailItem.Words[0].pXmlState         = &m_pCurrFrag->State;
                        TrailItem.Words[0].eWordPartOfSpeech = ConvertItemTypeToPartOfSp( ItemType );
                        TrailItem.eItemPartOfSpeech          = ConvertItemTypeToPartOfSp( ItemType );
                        TrailItem.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            TrailItem.pItemInfo->Type = ItemType;
                            if ( m_dwSpeakFlags & SPF_NLP_SPEAK_PUNC ||
                                 ( m_pCurrFrag->State.eAction == SPVA_SpellOut &&
                                   !fAbbreviation ) )
                            {
                                CWordList TempWordList;
                                ExpandPunctuation( TempWordList, *(m_pEndOfCurrItem - 1) );
                                hr = SetWordList( TrailItem, TempWordList, MemoryManager );
                                TrailItem.pItemInfo->Type = eUNMATCHED;
                            }
                            ItemList.InsertAfter( ItemPos, TrailItem );
                            if ( !fAbbreviation )
                            {
                                if ( ItemType == eELLIPSIS )
                                {
                                    m_pEndOfCurrItem -= 3;
                                    ulTrailItems = 3;
                                }
                                else
                                {
                                    m_pEndOfCurrItem--;
                                }
                            }
                        }
                    }
                    ItemType = eUNMATCHED;
                    if ( fAbbreviation )
                    {
                        break;
                    }
                }
            }

            //--- Do Main Item Insertion
            if ( SUCCEEDED( hr ) &&
                 m_pNextChar == m_pEndOfCurrItem )
            {
                ItemList.RemoveAt( ItemPos );
            }
            else if ( SUCCEEDED( hr ) )
            {
                hr = Normalize( ItemList, ItemPos, MemoryManager );
            }

            //--- Advance m_pNextChar to m_pEndOfCurrItem + once for each trail item matched.
            if ( SUCCEEDED( hr ) )
            {
                if ( !fAbbreviation &&
                     m_pEndOfCurrItem + ulTrailItems != m_pEndOfCurrToken )
                {
                    //--- Multi-token item matched in Normalize()... Remove all previously matched trail items,
                    //--- as they were matched as part of the larger item...
                    m_pNextChar = m_pEndOfCurrItem;
                    Item = ItemList.GetNext( ItemPos );
                    while ( ItemPos )
                    {
                        SPLISTPOS RemovePos = ItemPos;
                        Item = ItemList.GetNext( ItemPos );
                        ItemList.RemoveAt( RemovePos );
                    }                 
                }
                else
                {
                    m_pNextChar = m_pEndOfCurrToken;
                }
            }
        }
    }

    return hr;
} /* CStdSentEnum::AddNextSentItem */

/*****************************************************************************
* CStdSentEnum::GetNextSentence *
*-------------------------------*
*   This method is used to create a sentence item enumerator and populate it
*   with items. If the SPF_NLP_PASSTHROUGH flag is set, each item is the block
*   of text between XML states. If the SPF_NLP_PASSTHROUGH flag is not set, each
*   item is an individual word that is looked up in the current lexicon(s).
********************************************************************* EDC ***/
HRESULT CStdSentEnum::GetNextSentence( IEnumSENTITEM** ppItemEnum )
{
    HRESULT hr = S_OK;
    ULONG ulNumItems = 0;
    const SPVTEXTFRAG* pPrevFrag = m_pCurrFrag;

    //--- Is there any work to do
    if( m_pCurrFrag == NULL ) return S_FALSE;

    //--- Create sentence enum
    CComObject<CSentItemEnum> *pItemEnum;
    hr = CComObject<CSentItemEnum>::CreateInstance( &pItemEnum );

    if( SUCCEEDED( hr ) )
    {
        pItemEnum->AddRef();
        pItemEnum->_SetOwner( GetControllingUnknown() );
        *ppItemEnum = pItemEnum;
    }

    if( SUCCEEDED( hr ) )
    {
        BOOL fSentDone = false;
        BOOL fGoToNextFrag = false;
        CItemList& ItemList = pItemEnum->_GetList();
        CSentItemMemory& MemoryManager = pItemEnum->_GetMemoryManager();

        while( SUCCEEDED(hr) && m_pCurrFrag && !fSentDone && ulNumItems < 50 )
        {
            ulNumItems++;
            if( m_pCurrFrag->State.eAction == SPVA_Speak ||
                m_pCurrFrag->State.eAction == SPVA_SpellOut )
            {
                hr = AddNextSentItem( ItemList, MemoryManager, &fSentDone );

                //--- Advance fragment?
                if( SUCCEEDED( hr ) && 
                    m_pNextChar     &&
                    m_pEndChar      &&
                    m_pNextChar >= m_pEndChar )
                {
                    fGoToNextFrag = true;
                }
            }
            else
            {
                //--- Add non spoken fragments
                CSentItem Item;
                Item.pItemSrcText    = m_pCurrFrag->pTextStart;
                Item.ulItemSrcLen    = m_pCurrFrag->ulTextLen;
                Item.ulItemSrcOffset = m_pCurrFrag->ulTextSrcOffset;
                Item.ulNumWords      = 1;
                Item.Words           = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( Item.Words, sizeof(TTSWord) );
                    Item.Words[0].pXmlState         = &m_pCurrFrag->State;
                    Item.Words[0].eWordPartOfSpeech = MS_Unknown;
                    Item.eItemPartOfSpeech          = MS_Unknown;
                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo->Type = eWORDLIST_IS_VALID;
                        ItemList.AddTail( Item );
                    }
                }
                fGoToNextFrag = true;
            }

            if( SUCCEEDED( hr ) && 
                fGoToNextFrag )
            {
                fGoToNextFrag = false;
                pPrevFrag = m_pCurrFrag;
                m_pCurrFrag = m_pCurrFrag->pNext;
                if( m_pCurrFrag )
                {
                    m_pNextChar = m_pCurrFrag->pTextStart;
                    m_pEndChar  = m_pNextChar + m_pCurrFrag->ulTextLen;
                }
                else
                {
                    m_pNextChar = NULL;
                    m_pEndChar  = NULL;
                }
            }
        } // end while

        //--- If no period has been added, add one now - this will happen if the text 
        //--- is ONLY XML markup...
        if ( SUCCEEDED(hr) && !fSentDone )
        {
            CSentItem EOSItem;
            EOSItem.pItemSrcText    = g_period.pStr;
            EOSItem.ulItemSrcLen    = g_period.Len;
            EOSItem.ulItemSrcOffset = pPrevFrag->ulTextSrcOffset + pPrevFrag->ulTextLen;
            EOSItem.ulNumWords      = 1;
            EOSItem.Words           = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( EOSItem.Words, sizeof(TTSWord) );
                EOSItem.Words[0].pXmlState          = &g_DefaultXMLState;
                EOSItem.Words[0].eWordPartOfSpeech  = MS_EOSItem;
                EOSItem.eItemPartOfSpeech           = MS_EOSItem;
                EOSItem.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    EOSItem.pItemInfo->Type = ePERIOD;
                    ItemList.AddTail( EOSItem );
                }
            }
        }

        //--- Output debugging information, if sentence breaks are desired
        TTSDBG_LOGITEMLIST( pItemEnum->_GetList(), STREAM_SENTENCEBREAKS );

        if( SUCCEEDED( hr ) )
        {
            hr = DetermineProns( pItemEnum->_GetList(), pItemEnum->_GetMemoryManager() );
        }

        pItemEnum->Reset();

        //--- Output debugging information, if POS or Pronunciations are desired
        TTSDBG_LOGITEMLIST( pItemEnum->_GetList(), STREAM_LEXLOOKUP );

    }
    return hr;
} /* CStdSentEnum::GetNextSentence */

/*****************************************************************************
* CStdSentEnum::Reset *
*---------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CStdSentEnum::Reset( void )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::Reset" );
    HRESULT hr = S_OK;
    m_pCurrFrag = m_pTextFragList;
    m_pNextChar = m_pCurrFrag->pTextStart;
    m_pEndChar  = m_pNextChar + m_pCurrFrag->ulTextLen;
    m_SentenceStack.Reset();
    return hr;
} /* CStdSentEnum::Reset */

/*****************************************************************************
* CStdSentEnum::InitAggregateLexicon *
*------------------------------------*
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::InitAggregateLexicon( void )
{
    return m_cpAggregateLexicon.CoCreateInstance(CLSID_SpLexicon);
}

/*****************************************************************************
* CStdSentEnum::AddLexiconToAggregate *
*-------------------------------------*
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::AddLexiconToAggregate( ISpLexicon *pAddLexicon, DWORD dwFlags )
{
    return m_cpAggregateLexicon->AddLexicon( pAddLexicon, dwFlags );
}

/*****************************************************************************
* CStdSentEnum::InitMorphLexicon *
*--------------------------------*
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::InitMorphLexicon( void )
{
    HRESULT hr = S_OK;
    
    m_pMorphLexicon = new CSMorph( m_cpAggregateLexicon, &hr );

    return hr;
}

//
//=== CSentItemEnum =========================================================
//

/*****************************************************************************
* CSentItemEnum::Next *
*---------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CSentItemEnum::
    Next( TTSSentItem *pItemEnum )
{
    SPDBG_FUNC( "CSentItemEnum::Next" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SPIsBadWritePtr( pItemEnum, sizeof( TTSSentItem ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if ( m_ListPos )
        {
            *pItemEnum = m_ItemList.GetNext( m_ListPos );
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;
} /* CSentItemEnum::Next */

/*****************************************************************************
* CSentItemEnum::Reset *
*----------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CSentItemEnum::Reset( void )
{
    SPDBG_FUNC( "CSentItemEnum::Reset" );
    HRESULT hr = S_OK;
    m_ListPos = m_ItemList.GetHeadPosition();
    return hr;
} /* CSentItemEnum::Reset */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\timenorm.cpp ===
/***********************************************************************************************
* TimeNorm.cpp *
*-------------*
*  Description:
*   These functions normalize times of day and time measurements.
*-----------------------------------------------------------------------------------------------
*  Created by AH                                                                August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

#pragma warning (disable : 4296)

/***********************************************************************************************
* IsTimeOfDay *
*-------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a time of day.
* 
*   RegExp:
*       [01-09,1-12][:][00-09,10-59][TimeAbbreviation]?
*
*   Types assigned:
*       TIMEOFDAY
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsTimeOfDay( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager,
                                   CWordList& WordList, BOOL fMultiItem )
{
    SPDBG_FUNC( "CStdSentEnum::IsTimeOfDay" );

    HRESULT hr = S_OK;
    const WCHAR *pStartChar = m_pNextChar, *pEndOfItem = m_pEndOfCurrItem, *pEndChar = m_pEndChar;
    const SPVTEXTFRAG* pFrag = m_pCurrFrag;
    const SPVSTATE *pTimeXMLState = &pFrag->State, *pAbbreviationXMLState = NULL;
    CItemList PreAbbreviationList;
    BOOL fAdvancePointers = false;
    WCHAR *pHours = NULL, *pMinutes = NULL, *pAbbreviation = NULL;
    ULONG ulHours = 0, ulMinutes = 0;
    TIMEABBREVIATION TimeAbbreviation = UNDEFINED;
    TTSItemType ItemType = eUNMATCHED;

    //--- Max length of a string matching this regexp is 9 character 
    if ( pEndOfItem - pStartChar > 9 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        pHours = (WCHAR*) pStartChar;
        
        //--- Try to match a number for the hour of day - [01-09,1-12] 
        ulHours = my_wcstoul( pHours, &pMinutes );
        if ( pHours != pMinutes && 
             pMinutes - pHours <= 2 )
        {
            //--- Try to match the colon - [:] 
            if ( *pMinutes == ':' )
            {
                pMinutes++;
                //--- Try to match a number for the minutes - [00-09,10-59] 
                ulMinutes = my_wcstoul( pMinutes, &pAbbreviation );
                if ( pMinutes != pAbbreviation &&
                     pAbbreviation - pMinutes == 2 )
                {
                    //--- Verify that this is the end of the string 
                    if ( pAbbreviation == pEndOfItem )
                    {
                        //--- May have gotten hours and minutes - validate values 
                        if ( HOURMIN   <= ulHours   && ulHours   <= HOURMAX     &&
                             MINUTEMIN <= ulMinutes && ulMinutes <= MINUTEMAX )
                        {
                            //--- A successful match has been made, but peek ahead in text for Time Abbreviation
                            if ( fMultiItem )
                            {
                                pStartChar = pEndOfItem;
                                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, 
                                                            true, &PreAbbreviationList );
                                if ( pStartChar &&
                                     SUCCEEDED( hr ) )
                                {
								    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );

                                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                                            ( ( ItemType = IsEOSItem( *(pEndOfItem - 1) ) ) != eUNMATCHED &&
                                              ( ItemType != ePERIOD ||
                                                ( _wcsnicmp( pStartChar, L"am.", 3 ) == 0 &&
                                                  pStartChar + 3 == pEndOfItem ) ||
                                                ( _wcsnicmp( pStartChar, L"pm.", 3 ) == 0 &&
                                                  pStartChar + 3 == pEndOfItem ) ) ) )
                                    {
                                        pEndOfItem--;
                                    }
                                    pAbbreviation = (WCHAR*) pStartChar;

                                    if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                                           pAbbreviation + 2 == pEndOfItem )           ||
                                         ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                                           pAbbreviation + 4 == pEndOfItem ) )
                                    {
                                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                                        TimeAbbreviation        = AM;
                                        pAbbreviationXMLState   = &pFrag->State;
                                        fAdvancePointers        = true;
                                    }
                                    else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                                                pAbbreviation + 2 == pEndOfItem )           ||
                                              ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                                                pAbbreviation + 4 == pEndOfItem ) )
                                    {
                                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                                        TimeAbbreviation        = PM;
                                        pAbbreviationXMLState   = &pFrag->State;
                                        fAdvancePointers        = true;
                                    }
                                }
                            }
                        }
                        else // hours or minutes were out of range
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    //--- Check to see if the rest of the string is a time abbreviation - [TimeAbbreviation] 
                    else if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                                pAbbreviation + 2 == pEndOfItem ) ||
                              ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                                pAbbreviation + 4 == pEndOfItem ) )
						{
							//--- May have gotten hours and minutes and time abbreviation - validate values 
							if ( HOURMIN   <= ulHours   && ulHours   <= HOURMAX     &&
								MINUTEMIN <= ulMinutes && ulMinutes <= MINUTEMAX )
							{
								//--- A successful match has been made 
								TimeAbbreviation        = AM;
								pAbbreviationXMLState   = &pFrag->State;
							}
							else // hours or minutes were out of range
							{
								hr = E_INVALIDARG;
							}
						}
					//--- Check to see if the rest of the string is a time abbreviation - [TimeAbbreviation] 
					else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                                pAbbreviation + 2 == pEndOfItem ) ||
                              ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                                pAbbreviation + 4 == pEndOfItem ) )
					{
						//--- May have gotten hours and minutes and time abbreviation - validate values 
						if ( HOURMIN   <= ulHours   && ulHours   <= HOURMAX     &&
							MINUTEMIN <= ulMinutes && ulMinutes <= MINUTEMAX )
						{
							//--- A successful match has been made 
							pAbbreviationXMLState   = &pFrag->State;
							TimeAbbreviation        = PM;
						}
						else // hours or minutes were out of range
						{
							hr = E_INVALIDARG;
						}
					}
					else // string ended in invalid characters
					{
						hr = E_INVALIDARG;
					}
				} // failed to match a valid minutes string
                else
                {
                    hr = E_INVALIDARG;
                }
            } // failed to match the colon, could be just hours and a time abbreviation
            else if ( pMinutes < m_pEndOfCurrItem )
            {
                pAbbreviation = pMinutes;
                pMinutes      = NULL;                
                				
				
                //--- Check for TimeAbbreviation - [TimeAbbreviation] 
                if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                       pAbbreviation + 2 == pEndOfItem ) ||
                     ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                       pAbbreviation + 4 == pEndOfItem ) )
                {
                    //--- A successful match has been made - Hour AM 
                    pAbbreviationXMLState   = &pFrag->State;
                    TimeAbbreviation        = AM;
                }
                else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                            pAbbreviation + 2 == pEndOfItem ) ||
                          ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                            pAbbreviation + 4 == pEndOfItem ) )
                {
                    //--- A successful match has been made - Hour PM 
                    pAbbreviationXMLState   = &pFrag->State;
                    TimeAbbreviation        = PM;
                }
                else // failed to match a valid time abbreviation
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( fMultiItem )
            {
                //--- Set pMinutes to NULL, so we know later that we've got no minutes string...
                pMinutes      = NULL;                

                //--- Peek ahead in text for a time abbreviation
                pStartChar = pEndOfItem;
                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, 
                                            true, &PreAbbreviationList );
                if ( !pStartChar &&
                     SUCCEEDED( hr ) )
                {
                    hr = E_INVALIDARG;
                }
                else if ( pStartChar &&
                          SUCCEEDED( hr ) )
                {
                    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );

                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                            ( ( ItemType = IsEOSItem( *(pEndOfItem - 1) ) ) != eUNMATCHED &&
                              ItemType != ePERIOD ) )
                    {
                        pEndOfItem--;
                    }
                    pAbbreviation = (WCHAR*) pStartChar;

                    if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                           pAbbreviation + 2 == pEndOfItem )           ||
                         ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                           pAbbreviation + 4 == pEndOfItem ) )
                    {
                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                        TimeAbbreviation        = AM;
                        pAbbreviationXMLState   = &pFrag->State;
                        fAdvancePointers        = true;
                    }
                    else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                                pAbbreviation + 2 == pEndOfItem )           ||
                              ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                                pAbbreviation + 4 == pEndOfItem ) )
                    {
                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                        TimeAbbreviation        = PM;
                        pAbbreviationXMLState   = &pFrag->State;
                        fAdvancePointers        = true;
                    }
                    //--- Failed to match a valid Time Abbreviation
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        } // failed to match a valid hours string
        else
        {
            hr = E_INVALIDARG;
        }

        //--- Successfully matched a Time Of Day!  Now expand it and fill out pItemNormInfo
        if ( SUCCEEDED( hr ) )
        {
            NumberGroup Garbage;
            TTSWord Word;
            ZeroMemory( &Word, sizeof(TTSWord) );
            Word.eWordPartOfSpeech = MS_Unknown;

            pItemNormInfo = (TTSTimeOfDayItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeOfDayItemInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                //--- Fill out known parts of pItemNormInfo
                ZeroMemory( pItemNormInfo, sizeof(TTSTimeOfDayItemInfo) );
                pItemNormInfo->Type                                          = eTIMEOFDAY;
                ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fMinutes          = pMinutes ? true : false;
                ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fTimeAbbreviation = TimeAbbreviation != UNDEFINED ? true : false;
                ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fTwentyFourHour   = false;
                
                //--- Expand the hours
                if ( !iswdigit( pHours[1] ) )
                {
                    ExpandDigit( pHours[0], Garbage, WordList );
                }
                else
                {
                    ExpandTwoDigits( pHours, Garbage, WordList );
                }

                //--- Expand the minutes
                if ( pMinutes )
                {
                    //--- Special case: A bare o'clock - 1:00, 2:00, etc. 
                    if ( wcsncmp( pMinutes, L"00", 2 ) == 0 )
                    {
                        WCHAR *pGarbage;
                        ULONG ulHours = my_wcstoul( pHours, &pGarbage );
                        //--- Under twelve is followed by "o'clock" 
                        if ( ulHours <= 12 )
                        {
                            Word.pWordText  = g_OClock.pStr;
                            Word.ulWordLen  = g_OClock.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                        //--- Over twelve is followed by "hundred hours" 
                        else
                        {
                            ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fTwentyFourHour = true;

                            Word.pWordText  = g_hundred.pStr;
                            Word.ulWordLen  = g_hundred.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );

                            Word.pWordText  = g_hours.pStr;
                            Word.ulWordLen  = g_hours.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                    }
                    //--- Special Case: Minutes less than 10 - 1:05, 2:06, etc. 
                    else if ( pMinutes[0] == L'0' )
                    {
                        Word.pWordText  = g_O.pStr;
                        Word.ulWordLen  = g_O.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );

                        ExpandDigit( pMinutes[1], Garbage, WordList );
                    }
                    //--- Default Case 
                    else 
                    {
                        ExpandTwoDigits( pMinutes, Garbage, WordList );
                    }
                }

                //--- Clean up Time XML State
                SPLISTPOS WordListPos = WordList.GetHeadPosition();
                while ( WordListPos )
                {
                    TTSWord& TempWord  = WordList.GetNext( WordListPos );
                    TempWord.pXmlState = pTimeXMLState;
                }

                //--- Insert Pre-Abbreviation XML States
                while ( !PreAbbreviationList.IsEmpty() )
                {
                    WordList.AddTail( ( PreAbbreviationList.RemoveHead() ).Words[0] );
                }

                //--- Expand the Time Abbreviation
                //--- AM 
                if ( TimeAbbreviation == AM )
                {
                    //--- Ensure the letters are pronounced as nouns...
                    SPVSTATE* pNewState = (SPVSTATE*) MemoryManager.GetMemory( sizeof( SPVSTATE ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        memcpy( pNewState, pAbbreviationXMLState, sizeof( SPVSTATE ) );
                        pNewState->ePartOfSpeech = SPPS_Noun;

                        Word.pXmlState  = pNewState;
                        Word.pWordText  = g_A.pStr;
                        Word.ulWordLen  = g_A.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );

                        Word.pWordText  = g_M.pStr;
                        Word.ulWordLen  = g_M.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );
                    }
                }
                //--- PM 
                else if ( TimeAbbreviation == PM )
                {
                    //--- Ensure the letters are pronounced as nouns...
                    SPVSTATE* pNewState = (SPVSTATE*) MemoryManager.GetMemory( sizeof( SPVSTATE ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        memcpy( pNewState, pAbbreviationXMLState, sizeof( SPVSTATE ) );
                        pNewState->ePartOfSpeech = SPPS_Noun;

                        Word.pXmlState  = pAbbreviationXMLState;
                        Word.pWordText  = g_P.pStr;
                        Word.ulWordLen  = g_P.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );

                        Word.pWordText  = g_M.pStr;
                        Word.ulWordLen  = g_M.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );
                    }
                }

                //--- Update pointers, if necessary
                if ( fAdvancePointers )
                {
                    m_pCurrFrag      = pFrag;
                    m_pEndChar       = pEndChar;
                    m_pEndOfCurrItem = pEndOfItem;
                }
            }
        }
    }
    return hr;
} /* IsTimeOfDay */

/***********************************************************************************************
* IsTime *
*--------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a time.
* 
*   RegExp:
*       { d+ || d(1-3)[,ddd]+ }[:][00-09,10-59]{ [:][00-09,10-59] }?
*
*   Types assigned:
*       TIME_HRMIN, TIME_MINSEC, TIME_HRMINSEC
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsTime( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "TimeNorm IsTime" );

    HRESULT hr = S_OK;
    WCHAR *pFirstChunk = NULL, *pSecondChunk = NULL, *pThirdChunk = NULL, *pLeftOver = NULL;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    ULONG ulSecond = 0, ulThird = 0;
    TTSItemInfo *pFirstChunkInfo = NULL;
    BOOL fNegative = false;

    pFirstChunk = (WCHAR*) m_pNextChar;
    
    //--- Try to match a number for the hours/minutes - { d+ } 
    if ( *pFirstChunk == L'-' )
    {
        pFirstChunk++;
        fNegative = true;
    }
    while ( *pFirstChunk == L'0' )
    {
        pFirstChunk++;
    }
    if ( *pFirstChunk == L':' )
    {
        pFirstChunk--;
    }
    pSecondChunk = wcschr( pFirstChunk, L':' );

    if ( pSecondChunk &&
         pFirstChunk  < pSecondChunk &&
         pSecondChunk < m_pEndOfCurrItem - 1 )
    {
        m_pNextChar      = pFirstChunk;
        m_pEndOfCurrItem = pSecondChunk;

        hr = IsNumberCategory( pFirstChunkInfo, L"NUMBER", MemoryManager );

        m_pNextChar      = pTempNextChar;
        m_pEndOfCurrItem = pTempEndOfItem;

        if ( SUCCEEDED( hr ) &&
             ( pFirstChunkInfo->Type == eNUM_DECIMAL ||
               pFirstChunkInfo->Type == eNUM_CARDINAL ) )
        {
            if ( fNegative )
            {
                ( (TTSNumberItemInfo*) pFirstChunkInfo )->fNegative = true;
                TTSWord Word;
                ZeroMemory( &Word, sizeof( TTSWord ) );
                Word.eWordPartOfSpeech  = MS_Unknown;
                Word.pXmlState          = &m_pCurrFrag->State;
                Word.pWordText          = g_negative.pStr;
                Word.ulWordLen          = g_negative.Len;
                Word.pLemma             = Word.pWordText;
                Word.ulLemmaLen         = Word.ulWordLen;
                ( (TTSNumberItemInfo*) pFirstChunkInfo )->pWordList->AddHead( Word );
            }

            pSecondChunk++;
            //--- Try to match a number for the minutes/seconds - [00-09,10-59] 
            ulSecond = my_wcstoul( pSecondChunk, &pThirdChunk );
            if ( pSecondChunk != pThirdChunk &&
                 pThirdChunk - pSecondChunk == 2 )
            {
                //--- Verify that this is the end of the string 
                if ( pThirdChunk == m_pEndOfCurrItem )
                {
                    //--- May have gotten hours and minutes or minutes and seconds - validate values 
                    if ( MINUTEMIN <= ulSecond && ulSecond <= MINUTEMAX )
                    {
                        //--- A successful match has been made 
                        //--- Default behavior here is to assume minutes and seconds 
                        if ( Context == NULL ||
                             _wcsicmp( Context, L"TIME_MS" ) == 0 )
                        {
                            //--- Successfully matched minutes and seconds.
                            pItemNormInfo = (TTSTimeItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeItemInfo),
                                                                                        &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( pItemNormInfo, sizeof(TTSTimeItemInfo) );
                                pItemNormInfo->Type = eTIME;

                                ( (TTSTimeItemInfo*) pItemNormInfo )->pMinutes = 
                                                                        (TTSNumberItemInfo*) pFirstChunkInfo;
                                if ( *pSecondChunk != L'0' )
                                {
                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pSecondChunk;
                                }
                                else
                                {
                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pSecondChunk + 1;
                                }
                            }
                        }
                        //--- If context overrides, values represent hours and minutes 
                        else if ( _wcsicmp( Context, L"TIME_HM" ) == 0 )
                        {
                            //--- Successfully matched hours and pMinutes->
                            pItemNormInfo = (TTSTimeItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeItemInfo),
                                                                                        &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( pItemNormInfo, sizeof(TTSTimeItemInfo) );
                                pItemNormInfo->Type = eTIME;
                                ( (TTSTimeItemInfo*) pItemNormInfo )->pHours = 
                                                                    (TTSNumberItemInfo*) pFirstChunkInfo;

                                TTSItemInfo* pMinutesInfo;

                                //--- Don't want "zero zero..." behavior of numbers - strip off beginning zeroes
                                if ( *pSecondChunk == L'0' )
                                {
                                    pSecondChunk++;
                                }

                                m_pNextChar      = pSecondChunk;
                                m_pEndOfCurrItem = pThirdChunk;

                                hr = IsNumber( pMinutesInfo, L"NUMBER", MemoryManager );

                                m_pNextChar      = pTempNextChar;
                                m_pEndOfCurrItem = pTempEndOfItem;

                                if ( SUCCEEDED( hr ) )
                                {
                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pMinutes = (TTSNumberItemInfo*) pMinutesInfo;
                                }
                            }
                        }
                        else
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    else // minutes or seconds were out of range
                    {
                        hr = E_INVALIDARG;
                    }
                }
                //--- Check for seconds - TIME_HRMINS 
                else
                {
                    //--- Try to match the colon 
                    if ( *pThirdChunk == L':' )
                    {
                        pThirdChunk++;
                        //--- Try to match a number for the seconds - [00-09,10-59] 
                        ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                        if ( pThirdChunk != pLeftOver &&
                             pLeftOver - pThirdChunk == 2 )
                        {
                            //--- Verify that this is the end of the string 
                            if ( pLeftOver == m_pEndOfCurrItem )
                            {
                                //--- May have gotten hours minutes and seconds - validate values 
                                if ( MINUTEMIN <= ulSecond && ulSecond <= MINUTEMAX &&
                                     SECONDMIN <= ulThird  && ulThird  <= SECONDMAX )
                                {
                                    //--- Successfully matched hours, minutes, and seconds.
                                    pItemNormInfo = (TTSTimeItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeItemInfo),
                                                                                                &hr );
                                    if ( SUCCEEDED( hr ) )
                                    {
                                        ZeroMemory( pItemNormInfo, sizeof(TTSTimeItemInfo) );
                                        pItemNormInfo->Type = eTIME;
                                        ( (TTSTimeItemInfo*) pItemNormInfo )->pHours = 
                                                                            (TTSNumberItemInfo*) pFirstChunkInfo;

                                        if ( SUCCEEDED( hr ) )
                                        {
                                            TTSItemInfo* pMinutesInfo;

                                            //--- Don't want "zero zero..." behavior of numbers - strip off beginning zeroes
                                            if ( ulSecond != 0 )
                                            {
                                                pSecondChunk += ( ( pThirdChunk - 1 ) - pSecondChunk ) - 
                                                                (ULONG)( log10( ulSecond ) + 1 );
                                            }
                                            else
                                            {
                                                pSecondChunk = pThirdChunk - 2;
                                            }

                                            m_pNextChar      = pSecondChunk;
                                            m_pEndOfCurrItem = pThirdChunk - 1;

                                            hr = IsNumber( pMinutesInfo, L"NUMBER", MemoryManager );

                                            m_pNextChar      = pTempNextChar;
                                            m_pEndOfCurrItem = pTempEndOfItem;

                                            if ( SUCCEEDED( hr ) )
                                            {
                                                ( (TTSTimeItemInfo*) pItemNormInfo )->pMinutes = 
                                                                            (TTSNumberItemInfo*) pMinutesInfo;
                                                if ( *pThirdChunk != L'0' )
                                                {
                                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pThirdChunk;
                                                }
                                                else
                                                {
                                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pThirdChunk + 1;
                                                }
                                            }
                                        }
                                    }
                                }
                                else // minutes or seconds were out of range
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else // extra junk at end of string
                            {
                                hr = E_INVALIDARG;
                            }
                        } 
                        else // extra junk at end of string
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    else // failed to match a colon
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }
            else // failed to match a second number
            {
                hr = E_INVALIDARG;
            }
        }
        else // failed to match a colon
        {
            hr = E_INVALIDARG;
        }
    }
    else // failed to match a first number
    {
        hr = E_INVALIDARG;
    }

    if ( FAILED( hr ) )
    {
        if ( pFirstChunkInfo )
        {
            delete ( (TTSNumberItemInfo*) pFirstChunkInfo )->pWordList;
        }
    }

    return hr;
} /* IsTime */

/***********************************************************************************************
* ExpandTime *
*------------*
*   Description:
*       Expands Items previously determined to be of type TIME_HRMINSEC by IsTime.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandTime( TTSTimeItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandTime" );

    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //-------------------
    // Expand the hours
    //-------------------

    if ( pItemInfo->pHours )
    {
        //--- Expand Number 
        hr = ExpandNumber( pItemInfo->pHours, WordList );

        //--- Insert "hour" or "hours"
        if ( SUCCEEDED( hr ) )
        {
            if ( pItemInfo->pHours->pEndChar - pItemInfo->pHours->pStartChar == 1 &&
                 pItemInfo->pHours->pStartChar[0] == L'1' )
            {
                Word.pWordText  = g_hour.pStr;
                Word.ulWordLen  = g_hour.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            else
            {
                Word.pWordText  = g_hours.pStr;
                Word.ulWordLen  = g_hours.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }

        }

        //--- Insert "and"
        if ( SUCCEEDED( hr )                 &&
             pItemInfo->pMinutes->pStartChar  &&
             !pItemInfo->pSeconds )
        {
            Word.pWordText  = g_And.pStr;
            Word.ulWordLen  = g_And.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }            
    }
    
    //---------------------
    // Expand the minutes
    //---------------------

    if ( SUCCEEDED( hr ) &&
         pItemInfo->pMinutes )
    {
        //--- Expand Number 
        hr = ExpandNumber( pItemInfo->pMinutes, WordList );

        //--- Insert "minutes" 
        if ( SUCCEEDED( hr ) )
        {
            if ( pItemInfo->pMinutes->pEndChar - pItemInfo->pMinutes->pStartChar == 1 &&
                 pItemInfo->pMinutes->pStartChar[0] == L'1' )
            {
                Word.pWordText  = g_minute.pStr;
                Word.ulWordLen  = g_minute.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            else
            {
                Word.pWordText  = g_minutes.pStr;
                Word.ulWordLen  = g_minutes.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
        }

        //--- Insert "and"
        if ( SUCCEEDED( hr ) &&
             pItemInfo->pSeconds )
        {
            Word.pWordText  = g_And.pStr;
            Word.ulWordLen  = g_And.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
    }

    //---------------------
    // Expand the seconds
    //---------------------

    if ( SUCCEEDED( hr ) &&
         pItemInfo->pSeconds )
    {
        //--- Expand Number
        NumberGroup Garbage;
        if ( iswdigit( pItemInfo->pSeconds[1] ) )
        {
            ExpandTwoDigits( pItemInfo->pSeconds, Garbage, WordList );
        }
        else
        {
            ExpandDigit( pItemInfo->pSeconds[0], Garbage, WordList );
        }

        //--- Insert "seconds" 
        if ( pItemInfo->pSeconds[0] == L'1' &&
             !iswdigit( pItemInfo->pSeconds[1] ) )
        {
            Word.pWordText  = g_second.pStr;
            Word.ulWordLen  = g_second.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else
        {
            Word.pWordText  = g_seconds.pStr;
            Word.ulWordLen  = g_seconds.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
    }

    return hr;
} /* ExpandTime */

/***********************************************************************************************
* IsTimeRange *
*-------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a time range.
*
*   RegExp:
*       [TimeOfDay]-[TimeOfDay]  
*
*   Types assigned:
*       TIME_RANGE
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsTimeRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager,
                                   CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsTimeRange" );

    HRESULT hr = S_OK;
	CWordList TempWordList;
    TTSItemInfo *pFirstTimeInfo = NULL, *pSecondTimeInfo = NULL;
    const WCHAR *pHyphen = NULL;
    CItemList PreAbbreviationList;  // Needed for SkipWhitespace function calls
    BOOL fMultiItem = false;
									
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfCurrItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

    for ( pHyphen = m_pNextChar; pHyphen < m_pEndOfCurrItem; pHyphen++ )
    {
        if ( *pHyphen == L'-' )
        {
            break;
        }
    }

	//--- Might be whitespace and time suffix before hyphen
	if( pHyphen == m_pEndOfCurrItem ) 
	{
		hr = SkipWhiteSpaceAndTags( pHyphen, m_pEndChar, m_pCurrFrag, MemoryManager, 
									true, &PreAbbreviationList );
        if ( pHyphen && SUCCEEDED( hr ) )
        {
            if ( ( _wcsnicmp( pHyphen, L"am", 2 )   == 0 &&
                   pHyphen[2] == L'-' )           ||
				 ( _wcsnicmp( pHyphen, L"pm", 2 )   == 0 &&
                   pHyphen[2] == L'-' ) )
            {
				pHyphen += 2;
                *( (WCHAR*) pHyphen ) = ' ';
                fMultiItem = true;
			}
            else if ( ( _wcsnicmp( pHyphen, L"a.m.", 4 ) == 0 &&
                        pHyphen[4] == L'-' )          ||
                      ( _wcsnicmp( pHyphen, L"p.m.", 4 ) == 0 &&
                        pHyphen[4] == L'-' ) )
            {
				pHyphen +=4;
                *( (WCHAR*) pHyphen ) = ' ';
                fMultiItem = true;
            }
			else 
			{
				hr = E_INVALIDARG;
			}
		}
		else 
        {
			hr = E_INVALIDARG;
		}		
	}

	if ( SUCCEEDED( hr ) ) 
	{
		//--- Position m_pEndOfCurrItem so it is at the end of the first token, or at the hyphen,
		//--- whichever comes first (this is necessary for IsTimeOfDay to work).        
		if( ( m_pNextChar < pHyphen ) && ( pHyphen < m_pEndOfCurrItem ) ) 
		{
			m_pEndOfCurrItem = pHyphen;
		}

        //--- Check for time of day
        hr = IsTimeOfDay( pFirstTimeInfo, MemoryManager, TempWordList, fMultiItem );

        //--- Check for just a number (hour)
		if ( hr == E_INVALIDARG && ( pHyphen <= m_pNextChar + 2 ) )
		{
            WCHAR *pTemp = NULL;
			int ulHours = my_wcstoul( m_pNextChar, &pTemp );

            if ( pTemp == pHyphen   &&
                 HOURMIN <= ulHours && 
                 ulHours <= HOURMAX )
			{		
				NumberGroup Garbage;
				if ( pTemp - m_pNextChar == 1 )
                {
                    ExpandDigit( m_pNextChar[0], Garbage, TempWordList );
                }
                else
                {
                    ExpandTwoDigits( m_pNextChar, Garbage, TempWordList );
                }
				hr = S_OK;
			}
		}

        if ( SUCCEEDED( hr ) )
        {
            //--- Insert "to"
            TTSWord Word;
            ZeroMemory( &Word, sizeof( TTSWord ) );

            Word.pXmlState          = &m_pCurrFrag->State;
            Word.eWordPartOfSpeech  = MS_Unknown;
            Word.pWordText          = g_to.pStr;
            Word.ulWordLen          = g_to.Len;
            Word.pLemma             = Word.pWordText;
            Word.ulLemmaLen         = Word.ulWordLen;
            TempWordList.AddTail( Word );

            m_pNextChar      = pHyphen + 1;
			m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );

			//---Move m_pEndOfCurrItem back from any punctuation. ("4:30-5:30.")
			while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                    IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                    IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                    IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
			{
				m_pEndOfCurrItem--;
			}

            hr = IsTimeOfDay( pSecondTimeInfo, MemoryManager, TempWordList );

            if ( SUCCEEDED( hr ) )
            {
                //--- Matched a time range!
                m_pNextChar      = pTempNextChar;
                m_pEndChar       = pTempEndChar;

                pItemNormInfo = 
                    (TTSTimeRangeItemInfo*) MemoryManager.GetMemory( sizeof( TTSTimeRangeItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    pItemNormInfo->Type = eTIME_RANGE;
                    ( (TTSTimeRangeItemInfo*) pItemNormInfo )->pFirstTimeInfo = 
                                                                        (TTSTimeOfDayItemInfo*) pFirstTimeInfo;
                    ( (TTSTimeRangeItemInfo*) pItemNormInfo )->pSecondTimeInfo =
                                                                        (TTSTimeOfDayItemInfo*) pSecondTimeInfo;
                    //--- Copy temp word list to real word list if everything has succeeded...
					WordList.AddTail( &TempWordList );
                }
            }
        }
    }

	if ( !SUCCEEDED( hr ) ) 
    {	
        m_pNextChar = pTempNextChar;
        m_pEndChar  = pTempEndChar;
        m_pEndOfCurrItem = pTempEndOfCurrItem;
        m_pCurrFrag = pTempFrag;
        if ( fMultiItem )
        {
            *( (WCHAR*) pHyphen ) = L'-';
        }
    }

    return hr;
} /* IsTimeRange */
//-----------End Of File-------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\syllabletagger.cpp ===
/******************************************************************************
* SyllableTagger.cpp *
*--------------------*
*
*  This is an implementation of the CSyllableTagger class.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 04/28/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

//--- Additional includes
#include "stdafx.h"

#ifndef SPDebug_h
    #include <spdebug.h>
#endif
 
#ifndef AlloOps_H
    #include "AlloOps.h"
#endif

//-----------------------------
// Data.cpp
//-----------------------------
extern const unsigned long    g_AlloFlags[];

/*****************************************************************************
* CSyllableTagger::If_Consonant_Cluster *
*---------------------------------------*
*   Description:
*   Return TRUE if consoants can be clustered.
*       
********************************************************************** MC ***/
short CSyllableTagger::If_Consonant_Cluster( ALLO_CODE Consonant_1st, ALLO_CODE Consonant_2nd)
{
    SPDBG_FUNC( "CSyllableTagger::If_Consonant_Cluster" );
    short ret;
    
    ret = false;

    switch( Consonant_1st)
    {
        //---------------------------
        // f -> r,l
        //---------------------------
        case _f_:
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_:
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // v -> r,l
        //---------------------------
        case _v_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_: 
                {
                    ret = true;
                }
                break;
            }
        }
        break;

        //---------------------------
        // TH -> r,w
        //---------------------------
        case _TH_:
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _w_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // s -> w,l,p,t,k,m,n,f
        //---------------------------
        case _s_: 
        {
            switch( Consonant_2nd)
            {
                case _w_:
                case _l_:
                case _p_:
                case _t_:
                case _k_:
                case _m_:
                case _n_:
                case _f_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // SH -> w,l,p,t,r,m,n
        //---------------------------
        case _SH_: 
        {
            switch( Consonant_2nd)
            {
                case _w_:
                case _l_:
                case _p_:
                case _t_:
                case _r_:
                case _m_:
                case _n_: 
                {
                    ret = true;
                }
                break;
            }
        }
        break;

        //---------------------------
        // p -> r,l
        //---------------------------
        case _p_:
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // b -> r,l
        //---------------------------
        case _b_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // t -> r,w
        //---------------------------
        case _t_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _w_:
                {
                    ret = true;
                }
            }
        }
        break;

        //---------------------------
        // d -> r,w
        //---------------------------
        case _d_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _w_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // k -> r,l,w
        //---------------------------
        case _k_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_:
                case _w_:
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // g -> r,l,w
        //---------------------------
        case _g_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_:
                case _w_: 
                {
                    ret = true; 
                }
            break;
            }
        }
        break;
    }
    return ret;
} /* CSyllableTagger::If_Consonant_Cluster */





/*****************************************************************************
* CSyllableTagger::Find_Next_Word_Bound *
*---------------------------------------*
*   Description:
*   Return allo index for next word boundary
*       
********************************************************************** MC ***/
short CSyllableTagger::Find_Next_Word_Bound( short index )
{
    SPDBG_FUNC( "CSyllableTagger::Find_Next_Word_Bound" );
    ALLO_ARRAY   *pCurAllo;
    
    long   i;
    
    for( i = index+1; i < m_numOfCells; i++ )
    {
        pCurAllo = &m_pAllos[i];
        if( pCurAllo->ctrlFlags & (BOUNDARY_TYPE_FIELD | WORD_START) )
        {
            break;
        }
    }
    return (short)i;
} /* CSyllableTagger::Find_Next_Word_Bound */


/*****************************************************************************
* CSyllableTagger::MarkSyllableStart *
*------------------------------------*
*   Description:
*   Mark SYLLABLE_START positions
*  
********************************************************************** MC ***/
void CSyllableTagger::MarkSyllableStart()
{
    SPDBG_FUNC( "CSyllableTagger::MarkSyllableStart" );
    short       index;
    long        cur_Ctrl;
    long        cur_AlloFlags;
    short       dist, syllable_index;
    ALLO_CODE       phon_1st, phon_2nd;
    long        syllOrder;
    ALLO_ARRAY   *pCurAllo;
    
    syllable_index = 0;
    for( index = 0; index < m_numOfCells; )
    {
        pCurAllo = &m_pAllos[index];
        //-------------------------------
        // Skip SIL
        //-------------------------------
        while( pCurAllo->allo == _SIL_)
        {
            syllable_index++;
            index++;
            if( index >= m_numOfCells)
            {
                break;
            }
            pCurAllo = &m_pAllos[index];
        }
        if( index < m_numOfCells)
        {
            pCurAllo = &m_pAllos[index];
            cur_Ctrl = pCurAllo->ctrlFlags;
            cur_AlloFlags = ::g_AlloFlags[pCurAllo->allo];
            if( cur_AlloFlags & KVOWELF)
            {
                pCurAllo = &m_pAllos[syllable_index];
                pCurAllo->ctrlFlags |= SYLLABLE_START;
                syllOrder = cur_Ctrl & SYLLABLE_ORDER_FIELD;
                if( (syllOrder == ONE_OR_NO_SYLLABLE_IN_WORD) 
                    || (syllOrder == LAST_SYLLABLE_IN_WORD) )
                {
                    index = Find_Next_Word_Bound( index );
                    syllable_index = index;
                }
                else
                {
                    //----------------------------------------------
                    // It's either the 1st or mid vowel in word. 
                    // Scan forward for consonants.  
                    //----------------------------------------------
                    dist = (-1 );
                    do
                    {
                        index++;
                        pCurAllo = &m_pAllos[index];
                        cur_AlloFlags = g_AlloFlags[pCurAllo->allo];
                        dist++;         // count number of consonants   
                    }
                    while( !(cur_AlloFlags & KVOWELF) );
                
                    if( dist == 0)
                    {
                        syllable_index = index;
                    }
                
                    else if( dist == 1)
                    {
                        index--;        // start next syllable on consonant 
                        syllable_index = index;
                    }
                
                    else if( dist == 2)
                    {
                        pCurAllo = &m_pAllos[index-1];
                        phon_2nd = pCurAllo->allo;
                        pCurAllo = &m_pAllos[index-2];
                        phon_1st = pCurAllo->allo;
                        if( If_Consonant_Cluster( phon_1st, phon_2nd) )
                        {
                            index -= 2;     // start next syllable on cluster
                        }
                        else
                        {
                            index--;        // start next syllable on 2nd consonant 
                        }
                        syllable_index = index;
                    }
                
                    else if( dist == 3)
                    {
                        pCurAllo = &m_pAllos[index-1];
                        phon_2nd = pCurAllo->allo;
                        pCurAllo = &m_pAllos[index-2];
                        phon_1st = pCurAllo->allo;
                        if( If_Consonant_Cluster( phon_1st, phon_2nd) )
                        {
                         pCurAllo = &m_pAllos[index-3];
                           if( pCurAllo->allo == _s_)
                            {
                                index -= 3;     // start next syllable on s-cluster 
                            }
                            else
                            {
                                index -= 2;     // start next syllable on cluster 
                            }
                        }
                        else
                        {
                            index--;            // start next syllable on 3rd consonant 
                        }
                        syllable_index = index;
                    }
                    else
                    {
                        pCurAllo = &m_pAllos[index-dist];
                        phon_2nd = pCurAllo->allo;
                        pCurAllo = &m_pAllos[index-dist+1];
                        phon_1st = pCurAllo->allo;
                        if( If_Consonant_Cluster( phon_1st, phon_2nd) )
                        {
                            index = (short)(index - (dist - 2));   // start next syllable after cluster
                        }
                        else
                        {
                            index = (short)(index - (dist >> 1));  // start next syllable somewhere 
                                                    // in the middle  
                        }
                        syllable_index = index;
                    }
                }
            }
            else
            {
                index++;
            }
        
        }
    }
    return;
} /* CSyllableTagger::MarkSyllableStart */




/*****************************************************************************
* CSyllableTagger::MarkSyllableBoundry *
*--------------------------------------*
*   Description:
*   Mark phons in last syllable before boundry with boundry type flag  
*       
********************************************************************** MC ***/
void CSyllableTagger::MarkSyllableBoundry( long scanIndex)
{
    SPDBG_FUNC( "CSyllableTagger::MarkSyllableBoundry" );

    long   index;
    ALLO_CODE   cur_Allo;
    long    cur_AlloFlags;
    long    cur_Bound;
    long    boundType;
    ALLO_ARRAY   *pCurAllo;
    
    for( index = scanIndex+1; index < m_numOfCells; index++)
    {
        pCurAllo = &m_pAllos[index];
        cur_Allo = pCurAllo->allo;
        cur_AlloFlags = g_AlloFlags[cur_Allo];
        cur_Bound = pCurAllo->ctrlFlags & BOUNDARY_TYPE_FIELD;
        if( cur_Bound)
        {
            boundType = 0;
            
            if( cur_Bound & TERM_BOUND )
            {
                boundType |= (TERM_END_SYLL + WORD_END_SYLL );
            }
            if( cur_Bound & WORD_START )
            {
                boundType |= WORD_END_SYLL;
            }
            
            pCurAllo = &m_pAllos[scanIndex];
            pCurAllo->ctrlFlags |= boundType;
        }
        
        if( cur_AlloFlags & KVOWELF)
        {
            break;
        }
    }
} /* CSyllableTagger::MarkSyllableBoundry */



/*****************************************************************************
* CSyllableTagger::MarkSyllableOrder *
*------------------------------------*
*   Description:
*   Tag syllable ordering
*       
********************************************************************** MC ***/
void CSyllableTagger::MarkSyllableOrder( long scanIndex )
{
    SPDBG_FUNC( "CSyllableTagger::MarkSyllableOrder" );
    long       index;
    ALLO_CODE   cur_Allo;
    long        cur_Bound;
    long        cur_AlloFlags;
    long        order;
    long        cur_SyllableType;
    ALLO_ARRAY   *pCurAllo;
    
    //------------------------------------------------------------------------------
    // Scan backwards in PhonBuf_1 till word boundry and look for any other vowels. 
    // Set 'order' to LAST_SYLLABLE_IN_WORD if there are any.  
    //------------------------------------------------------------------------------
    order = 0;
    for( index = scanIndex-1; index > 0; index-- )
    {
        pCurAllo = &m_pAllos[index];
        cur_Allo = pCurAllo->allo;
        cur_AlloFlags = g_AlloFlags[cur_Allo];
        cur_SyllableType = pCurAllo->ctrlFlags & SYLLABLE_TYPE_FIELD;
        if( cur_SyllableType >= WORD_END_SYLL )
        {
            break;
        }
        
        if( cur_AlloFlags & KVOWELF )
        {
            order = LAST_SYLLABLE_IN_WORD;  // there's at least one proceeding vowel    
            break;
        }
    }
    
    //----------------------------------------------------------------------------------
    // Scan forward in PhonBuf_1 till word boundry and look for any other vowels 
    // If there's a fwd vowel but no bkwd vowel:  'order' = FIRST_SYLLABLE_IN_WORD 
    // If there's a fwd vowel and a bkwd vowel:  'order' = MID_SYLLABLE_IN_WORD 
    // If there's no fwd vowel but a bkwd vowel:  'order' = LAST_SYLLABLE_IN_WORD 
    // If there's no fwd vowel and no bkwd vowel:  'order' = 0  
    //----------------------------------------------------------------------------------
    for( index = scanIndex+1; index < m_numOfCells; index++ )
    {
        pCurAllo = &m_pAllos[index];
        cur_Allo = pCurAllo->allo;
        cur_AlloFlags = g_AlloFlags[cur_Allo];
        cur_Bound = pCurAllo->ctrlFlags & BOUNDARY_TYPE_FIELD;
        if( cur_Bound)
        {
            pCurAllo = &m_pAllos[scanIndex];
            pCurAllo->ctrlFlags |= order;
            break;
        }
        if( cur_AlloFlags & KVOWELF)
        {
            if( order == LAST_SYLLABLE_IN_WORD)
            {
                order = MID_SYLLABLE_IN_WORD;
            }
            else if( order == 0)
            {
                order = FIRST_SYLLABLE_IN_WORD;
            }
        }
    }
} /* CSyllableTagger::MarkSyllableOrder */







/*****************************************************************************
* CSyllableTagger::ListToArray *
*------------------------------*
*   Description:
*   Copy list to array
*       
********************************************************************** MC ***/
void CSyllableTagger::ListToArray( CAlloList *pAllos )
{
   SPDBG_FUNC( "CSyllableTagger::ListToArray" );
   CAlloCell   *pCurCell;
	long		cAllo;

	cAllo = 0;
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
		if( cAllo >= m_numOfCells )
		{
			break;
		}
		m_pAllos[cAllo].allo = pCurCell->m_allo;
		m_pAllos[cAllo].ctrlFlags = pCurCell->m_ctrlFlags;
		pCurCell = pAllos->GetNextCell();
		cAllo++;
    }
} /* CSyllableTagger::ListToArray */


/*****************************************************************************
* CSyllableTagger::ArrayToList *
*------------------------------*
*   Description:
*   Copy array values back into list
*       
********************************************************************** MC ***/
void CSyllableTagger::ArrayToList( CAlloList *pAllos )
{
    SPDBG_FUNC( "CSyllableTagger::ArrayToList" );
    CAlloCell   *pCurCell;
	long		cAllo;

	cAllo = 0;
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
		if( cAllo >= m_numOfCells )
		{
			break;
		}
		pCurCell->m_allo = m_pAllos[cAllo].allo;
		pCurCell->m_ctrlFlags = m_pAllos[cAllo].ctrlFlags;
		pCurCell = pAllos->GetNextCell();
		cAllo++;
    }
} /* CSyllableTagger::ArrayToList */


/*****************************************************************************
* CSyllableTagger::TagSyllables *
*---------------------------------*
*   Description:
*   Tag syllable boundaries
*       
********************************************************************** MC ***/
void CSyllableTagger::TagSyllables( CAlloList *pAllos )
{
    SPDBG_FUNC( "CSyllableTagger::TagSyllables" );
    ALLO_ARRAY   *pCurAllo;
    ALLO_CODE   cur_Allo;
    long    cur_Ctrl;
    long    scanIndex;
    long    cur_AlloFlags; 
    
	// Get allo count
	//------------------------------
    m_numOfCells = pAllos->GetCount();
	if( m_numOfCells > 0 )
	{
		m_pAllos = new ALLO_ARRAY[m_numOfCells];
		if( m_pAllos )
		{
			ListToArray( pAllos );
			for( scanIndex = 0; scanIndex < m_numOfCells; scanIndex++ )
			{
				pCurAllo = &m_pAllos[scanIndex];
				cur_Allo = pCurAllo->allo;
				cur_AlloFlags = g_AlloFlags[cur_Allo];
				cur_Ctrl = pCurAllo->ctrlFlags;
        
				if( cur_AlloFlags & KVOWELF)
				{
					//--------------------------
					// Phon is a VOWEL
					//--------------------------
					MarkSyllableOrder( scanIndex );
				}
				else
				{
					//--------------------------
					// Phon is a CONSONANT
					// move stress??
					//--------------------------
				}
        
				MarkSyllableBoundry( scanIndex );
			}
    
			MarkSyllableStart();
			ArrayToList( pAllos );
			delete m_pAllos;
		}
	}
} /* CSyllableTagger::TagSyllables */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\stdsentenum.h ===
/******************************************************************************
* StdSentEnum.h *
*---------------*
*  This is the header file for the CStdSentEnum implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef StdSentEnum_h
#define StdSentEnum_h

//--- Additional includes
#include "stdafx.h"
#include "spttseng.h"
#include "resource.h"
#include "SentItemMemory.h"
#include "morph.h"

//=== Constants ====================================================

typedef enum SEPARATOR_AND_DECIMAL
{
    PERIOD_COMMA = (1L << 0),
    COMMA_PERIOD = (1L << 1)
} SEPARATOR_AND_DECIMAL;

typedef enum SHORT_DATE_ORDER
{
    MONTH_DAY_YEAR = (1L << 0),
    DAY_MONTH_YEAR = (1L << 1),
    YEAR_MONTH_DAY = (1L << 2)
} SHORT_DATE_ORDER;

//--- Vowel WCHAR values - used to disambiguate pronunciations of certain words
const WCHAR g_Vowels[] = 
{
    0x0a,   // AA
    0x0b,   // AE
    0x0c,   // AH
    0x0d,   // AO
    0x0e,   // AW
    0x0f,   // AX
    0x10,   // AY
    0x15,   // EH
    0x16,   // ER
    0x17,   // EY
    0x1b,   // IH
    0x1c,   // IY
    0x23,   // OW
    0x24,   // OY
    0x2a,   // UH
    0x2b,   // UW
};

//--- Normalization constants - see NormData.cpp
extern const char g_pFlagCharacter;
extern const unsigned char g_AnsiToAscii[256];
extern const SPLSTR g_O;
extern const SPLSTR g_negative;
extern const SPLSTR g_decimalpoint;
extern const SPLSTR g_to;
extern const SPLSTR g_a;
extern const SPLSTR g_of;
extern const SPLSTR g_percent;
extern const SPLSTR g_degree;
extern const SPLSTR g_degrees;
extern const SPLSTR g_squared;
extern const SPLSTR g_cubed;
extern const SPLSTR g_ones[10];
extern const SPLSTR g_tens[10];
extern const SPLSTR g_teens[10];
extern const SPLSTR g_onesOrdinal[10]; 
extern const SPLSTR g_tensOrdinal[10];
extern const SPLSTR g_teensOrdinal[10];
extern const SPLSTR g_quantifiers[6];
extern const SPLSTR g_quantifiersOrdinal[6];
extern const SPLSTR g_dash;
extern WCHAR g_Euro[2];

struct CurrencySign
{
    SPLSTR Sign;
    SPLSTR MainUnit;
    SPLSTR SecondaryUnit;
};

struct StateStruct
{
    SPLSTR Abbreviation;
    SPLSTR FullName;
};

extern const StateStruct g_StateAbbreviations[63];
extern const CurrencySign g_CurrencySigns[14];
extern const SPLSTR g_SingularPrimaryCurrencySigns[14];
extern const SPLSTR g_SingularSecondaryCurrencySigns[14];
extern const WCHAR g_DateDelimiters[3];
extern const SPLSTR g_months[12];
extern const SPLSTR g_monthAbbreviations[13];
extern const SPLSTR g_days[7];
extern const SPLSTR g_dayAbbreviations[10];
extern const SPLSTR g_Area;
extern const SPLSTR g_Country;
extern const SPLSTR g_Code;
extern const SPLSTR g_Half;
extern const SPLSTR g_Tenths;
extern const SPLSTR g_Sixteenths;
extern const SPLSTR g_Hundredths;
extern const SPLSTR g_Over;
extern const SPLSTR g_PluralDenominators[10];
extern const SPLSTR g_A;
extern const SPLSTR g_M;
extern const SPLSTR g_P;
extern const SPLSTR g_OClock;
extern const SPLSTR g_hundred;
extern const SPLSTR g_hour;
extern const SPLSTR g_hours;
extern const SPLSTR g_minute;
extern const SPLSTR g_minutes;
extern const SPLSTR g_second;
extern const SPLSTR g_seconds;
extern const SPLSTR g_ANSICharacterProns[256];
extern const SPVSTATE g_DefaultXMLState;
extern const SPLSTR g_And;
extern const SPLSTR g_comma;
extern const SPLSTR g_period;
extern const SPLSTR g_periodString;
extern const SPLSTR g_slash;
extern const SPLSTR g_Decades[];
extern const SPLSTR g_Zeroes;
extern const SPLSTR g_Hundreds;

#define DAYMAX 31
#define DAYMIN 1
#define MONTHMAX 12
#define MONTHMIN 1
#define YEARMAX 9999
#define YEARMIN 0
#define HOURMIN 1
#define HOURMAX 23
#define MINUTEMIN 0
#define MINUTEMAX 59
#define SECONDMIN 0
#define SECONDMAX 59

//--- POS Tagger Constants - see MiscData.cpp

typedef enum TEMPLATETYPE
{
    PREV1T,
    NEXT1T,
    PREV2T,
    NEXT2T,
    PREV1OR2T,
    NEXT1OR2T,
    PREV1OR2OR3T,
    NEXT1OR2OR3T,
    PREV1TNEXT1T,
    PREV1TNEXT2T,
    PREV2TNEXT1T,
    NOTCAP,
    CAP,
    PREVNOTCAP,
    PREVCAP,
    PREV1W,
    NEXT1W,
    PREV2W,
    NEXT2W,
    PREV1OR2W,
    NEXT1OR2W,
    CURRWPREV1W,
    CURRWNEXT1W,
    CURRWPREV1T,
    CURRWNEXT1T,
    CURRW,
    PREV1WT,
    NEXT1WT,
    CURRWPREV1WT,
    CURRWNEXT1WT
} TEMPLATETYPE;

struct BrillPatch
{
    ENGPARTOFSPEECH eCurrentPOS;
    ENGPARTOFSPEECH eConvertToPOS;
    TEMPLATETYPE   eTemplateType;
    ENGPARTOFSPEECH eTemplatePOS1;
    ENGPARTOFSPEECH eTemplatePOS2;
    const WCHAR*   pTemplateWord1;
    const WCHAR*   pTemplateWord2;
};

extern const BrillPatch g_POSTaggerPatches [63];

//=== Class, Enum, Struct and Union Declarations ===================

typedef CSPList<TTSWord,TTSWord&> CWordList;
typedef CSPList<TTSSentItem,TTSSentItem&> CItemList;

//--- Structs used for normalization

typedef enum
{
    PRECEDING,
    FOLLOWING,
    UNATTACHED
} NORM_POSITION;

struct NumberGroup
{
    BOOL    fOnes;          // "one" through "nineteen"
    BOOL    fTens;          // "twenty" through "ninety"
    BOOL    fHundreds;      // "one hundred" through "nine hundred"
    BOOL    fQuantifier;    // "thousand" through "quadrillion"
};

struct TTSIntegerItemInfo
{
    long            lNumGroups;
    NumberGroup     Groups[6];
    BOOL            fOrdinal;
    BOOL            fDigitByDigit;
    ULONG           ulNumDigits;
    //--- Normalization internal only
    long            lLeftOver;
    BOOL            fSeparators;
    const WCHAR*    pStartChar;
    const WCHAR*    pEndChar;
};

struct TTSDigitsItemInfo : TTSItemInfo
{
    const WCHAR*    pFirstDigit;
    ULONG           ulNumDigits;
};

struct TTSNumberItemInfo;

struct TTSFractionItemInfo 
{
    BOOL                    fIsStandard;
    TTSNumberItemInfo*   pNumerator;
    TTSNumberItemInfo*   pDenominator;
    //--- Normalization internal only
    const WCHAR*            pVulgar;
};

struct TTSNumberItemInfo : TTSItemInfo
{
    BOOL                    fNegative;
    TTSIntegerItemInfo*     pIntegerPart;
    TTSDigitsItemInfo*      pDecimalPart;
    TTSFractionItemInfo* pFractionalPart;
    //--- Normalization internal only
    const WCHAR*            pStartChar;
    const WCHAR*            pEndChar;
    CWordList*              pWordList;
};    

struct TTSPhoneNumberItemInfo : TTSItemInfo
{
    //--- Country code members
    TTSNumberItemInfo*  pCountryCode;
    //--- Area code members
    TTSDigitsItemInfo*  pAreaCode;
    BOOL                fIs800;
    BOOL                fOne;
    //--- Main number members
    TTSDigitsItemInfo** ppGroups;
    ULONG               ulNumGroups;
};

struct TTSZipCodeItemInfo : TTSItemInfo
{
    TTSDigitsItemInfo*  pFirstFive;
    TTSDigitsItemInfo*  pLastFour;
};

struct TTSStateAndZipCodeItemInfo : TTSItemInfo
{
    TTSZipCodeItemInfo* pZipCode;
};

struct TTSCurrencyItemInfo : TTSItemInfo
{
    TTSNumberItemInfo*  pPrimaryNumberPart;
    TTSNumberItemInfo*  pSecondaryNumberPart;
    BOOL                fQuantifier;
    long                lNumPostNumberStates;
    long                lNumPostSymbolStates;
};

struct TTSYearItemInfo : TTSItemInfo
{
    const WCHAR*    pYear;
    ULONG           ulNumDigits;
};

struct TTSRomanNumeralItemInfo : TTSItemInfo
{
    TTSItemInfo*    pNumberInfo;
};

struct TTSDecadeItemInfo : TTSItemInfo
{
    const WCHAR*    pCentury;
    ULONG           ulDecade;
};

struct TTSDateItemInfo : TTSItemInfo
{
    ULONG               ulDayIndex;
    ULONG               ulMonthIndex;
    TTSIntegerItemInfo* pDay;
    TTSYearItemInfo*    pYear;
};

typedef enum
{
    AM,
    PM,
    UNDEFINED
} TIMEABBREVIATION;

struct TTSTimeOfDayItemInfo : TTSItemInfo
{
    BOOL    fTimeAbbreviation;
    BOOL    fTwentyFourHour;
    BOOL    fMinutes;
};

struct TTSTimeItemInfo : TTSItemInfo
{
    TTSNumberItemInfo*  pHours;
    TTSNumberItemInfo*  pMinutes;
    const WCHAR*        pSeconds;
};

struct TTSHyphenatedStringInfo : TTSItemInfo
{
    TTSItemInfo* pFirstChunkInfo;
    TTSItemInfo* pSecondChunkInfo;
    const WCHAR* pFirstChunk;
    const WCHAR* pSecondChunk;
};

struct TTSSuffixItemInfo : TTSItemInfo
{
    const WCHAR* pFirstChar;
    ULONG        ulNumChars;
};

struct TTSNumberRangeItemInfo : TTSItemInfo
{
    TTSItemInfo *pFirstNumberInfo;
    TTSItemInfo *pSecondNumberInfo;
};

struct TTSTimeRangeItemInfo : TTSItemInfo
{
    TTSTimeOfDayItemInfo *pFirstTimeInfo;
    TTSTimeOfDayItemInfo *pSecondTimeInfo;
};

struct AbbrevRecord 
{
    const WCHAR*    pOrth;
    WCHAR*          pPron1;
    ENGPARTOFSPEECH POS1;
    WCHAR*          pPron2;
    ENGPARTOFSPEECH POS2;
    WCHAR*          pPron3;
    ENGPARTOFSPEECH POS3;
    int             iSentBreakDisambig;
    int             iPronDisambig;
};

struct TTSAbbreviationInfo : TTSItemInfo
{
    const AbbrevRecord*   pAbbreviation;
};

//--- Structs used for Lex Lookup

typedef enum { PRON_A = 0, PRON_B = 1 };

struct PRONUNIT
{
    ULONG           phon_Len;
    WCHAR           phon_Str[SP_MAX_PRON_LENGTH];		// Allo string
    ULONG			POScount;
    ENGPARTOFSPEECH	POScode[POS_MAX];
};

struct PRONRECORD
{
    WCHAR           orthStr[SP_MAX_WORD_LENGTH];      // Orth text
    WCHAR           lemmaStr[SP_MAX_WORD_LENGTH];     // Root word
    ULONG		    pronType;                   // Pronunciation is lex or LTS
    PRONUNIT        pronArray[2];
    ENGPARTOFSPEECH	POSchoice;
    ENGPARTOFSPEECH XMLPartOfSpeech;
    bool			hasAlt;
    ULONG			altChoice;
    BOOL            fUsePron;
};

//--- Miscellaneous structs and typedefs

struct SentencePointer
{
    const WCHAR *pSentenceStart;
    const SPVTEXTFRAG *pSentenceFrag;
};

//=== Function Definitions ===========================================

// Misc Number Normalization functions and helpers
int MatchCurrencySign( const WCHAR*& pStartChar, const WCHAR*& pEndChar, NORM_POSITION& ePosition );

//=== Classes

/*** CSentenceStack *************************************************
*   This class is used to maintain a stack of sentences for the Skip
*   call to utilize.
*/
class CSentenceStack
{
  public:
    /*--- Methods ---*/
    CSentenceStack() { m_StackPtr = -1; }
    int GetCount( void ) { return m_StackPtr + 1; }
    virtual SentencePointer& Pop( void ) { SPDBG_ASSERT( m_StackPtr > -1 ); return m_Stack[m_StackPtr--]; }
    virtual HRESULT Push( const SentencePointer& val ) { ++m_StackPtr; return m_Stack.SetAtGrow( m_StackPtr, val ); }
    virtual void Reset( void ) { m_StackPtr = -1; }

  protected:
    /*--- Member data ---*/
    CSPArray<SentencePointer,SentencePointer>  m_Stack;
    int                                m_StackPtr;
};

/*** CSentItem
*   This object is a helper class
*/
class CSentItem : public TTSSentItem
{
  public:
    CSentItem() { memset( this, 0, sizeof(*this) ); }
    CSentItem( TTSSentItem& Other ) { memcpy( this, &Other, sizeof( Other ) ); }
};

/*** CSentItemEnum
*   This object is designed to be used by a single thread.
*/
class ATL_NO_VTABLE CSentItemEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IEnumSENTITEM
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSentItemEnum)
	    COM_INTERFACE_ENTRY(IEnumSENTITEM)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/
    void _SetOwner( IUnknown* pOwner ) { m_cpOwner = pOwner; }
    CItemList& _GetList( void ) { return m_ItemList; }
    CSentItemMemory& _GetMemoryManager( void ) { return m_MemoryManager; }

  /*=== Interfaces ====*/
  public:
    //--- IEnumSpSentence ----------------------------------------
	STDMETHOD(Next)( TTSSentItem *pItemEnum );
	STDMETHOD(Reset)( void );

  /*=== Member data ===*/
  private:
    CComPtr<IUnknown>   m_cpOwner;
    CItemList           m_ItemList;
    SPLISTPOS           m_ListPos;
    CSentItemMemory     m_MemoryManager;
};

/*** CStdSentEnum COM object
*/
class ATL_NO_VTABLE CStdSentEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IEnumSpSentence
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CStdSentEnum)
	    COM_INTERFACE_ENTRY(IEnumSpSentence)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    HRESULT FinalConstruct();
    void FinalRelease();

    /*--- Non interface methods ---*/
    HRESULT InitAggregateLexicon( void );
    HRESULT AddLexiconToAggregate( ISpLexicon *pAddLexicon, DWORD dwFlags );
    HRESULT InitMorphLexicon( void );

    //--- Abbreviation Sentence Breaking Disambiguation Functions
    HRESULT IsAbbreviationEOS( const AbbrevRecord* pAbbreviation, CItemList& ItemList, SPLISTPOS ItemPos, 
                               CSentItemMemory& MemoryManager, BOOL* pfIsEOS );
    HRESULT IfEOSNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList& ItemList, SPLISTPOS ItemPos,
                                  CSentItemMemory& MemoryManager, BOOL* pfIsEOS );
    HRESULT IfEOSAndLowercaseNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList& ItemList, SPLISTPOS ItemPos,
                                              CSentItemMemory& MemoryManager, BOOL* pfIsEOS );

    //--- Abbreviation Pronunciation Disambiguation Functions
    HRESULT SingleOrPluralAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                        CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT DoctorDriveAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                     CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT AbbreviationFollowedByDigit( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                         CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT AllCapsAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                 CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT CapitalizedAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                     CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT SECAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                             CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT DegreeAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                CItemList& ItemList, SPLISTPOS ListPos );
	HRESULT AbbreviationModifier( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT ADisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                       CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT PolishDisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                            CItemList& ItemList, SPLISTPOS ListPos );

    //--- Word Pronunciation Disambiguation Functions
    HRESULT MeasurementDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                 SPLISTPOS ListPos, CSentItemMemory& MemoryManager );
    HRESULT TheDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                         SPLISTPOS ListPos, CSentItemMemory& MemoryManager );
    HRESULT ReadDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                          SPLISTPOS ListPos, CSentItemMemory& MemoryManager );


  private:
    //--- Pronunciation Table init helper
    HRESULT InitPron( WCHAR** OriginalPron );

    //--- Sentence breaking helpers ---//
    HRESULT GetNextSentence( IEnumSENTITEM** pItemEnum );
    HRESULT AddNextSentItem( CItemList& ItemList, CSentItemMemory& MemoryManager, BOOL* pfIsEOS );
    HRESULT SkipWhiteSpaceAndTags( const WCHAR*& pStartChar, const WCHAR*& pEndChar, 
                                   const SPVTEXTFRAG*& pCurrFrag, CSentItemMemory& pMemoryManager, 
                                   BOOL fAddToItemList = false, CItemList* pItemList = NULL );
    const WCHAR* FindTokenEnd( const WCHAR* pStartChar, const WCHAR* pEndChar );

    //--- Lexicon and POS helpers ---//
    HRESULT DetermineProns( CItemList& ItemList, CSentItemMemory& MemoryManager );
    HRESULT Pronounce( PRONRECORD *pPron );

    //--- Normalization helpers ---//
    HRESULT Normalize( CItemList& ItemList, SPLISTPOS ListPos, CSentItemMemory& MemoryManager );
    HRESULT MatchCategory( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT ExpandCategory( TTSItemInfo*& pItemNormInfo, CItemList& ItemList, SPLISTPOS ListPos, 
                            CSentItemMemory& MemoryManager );
    HRESULT DoUnicodeToAsciiMap( const WCHAR *pUnicodeString, ULONG ulUnicodeStringLength,
                                 WCHAR *ppConvertedString );
    HRESULT IsAlphaWord( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo,
                         CSentItemMemory& MemoryManager );
    HRESULT IsInitialism( CItemList& ItemList, SPLISTPOS ItemPos, CSentItemMemory& MemoryManager,
                          BOOL* pfIsEOS );
    //--- Various Number Related Normalization helpers ---//
    HRESULT IsNumberCategory( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT IsNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager,
                      BOOL fMultiItem = true );
    HRESULT IsInteger( const WCHAR* pStartChar, TTSIntegerItemInfo*& pIntegerInfo, 
                       CSentItemMemory& MemoryManager );
    HRESULT IsDigitString( const WCHAR* pStartChar, TTSDigitsItemInfo*& pDigitsInfo,
                           CSentItemMemory& MemoryManager );
    HRESULT ExpandNumber( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandPercent( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandDegrees( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandSquare( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandCube( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    void ExpandInteger( TTSIntegerItemInfo* pItemInfo, const WCHAR* Context, CWordList &WordList );
    void ExpandDigit( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandTwoDigits( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandThreeDigits( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandDigitOrdinal( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandTwoOrdinal( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandThreeOrdinal( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandDigits( TTSDigitsItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsFraction( const WCHAR* pStartChar, TTSFractionItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager );
    HRESULT ExpandFraction( TTSFractionItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsRomanNumeral( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT IsPhoneNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT IsZipCode( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT ExpandZipCode( TTSZipCodeItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsCurrency( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                        CWordList& WordList );
    HRESULT IsNumberRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager );
    HRESULT ExpandNumberRange( TTSNumberRangeItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsCurrencyRange( TTSItemInfo*& pItemInfo, CSentItemMemory& MemoryManager, CWordList& WordList );

    //--- Date Related Normalization helpers ---//
    HRESULT IsNumericCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                  CSentItemMemory& MemoryManager );
    HRESULT IsMonthStringCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                      CSentItemMemory& MemoryManager );
    HRESULT IsLongFormDate_DMDY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT IsLongFormDate_DDMY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT ExpandDate( TTSDateItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandYear( TTSYearItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsDecade( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager );
    HRESULT ExpandDecade( TTSDecadeItemInfo* pItemInfo, CWordList& WordList );
    ULONG MatchMonthString( WCHAR*& pMonth, ULONG ulLength );
    ULONG MatchDayString( WCHAR*& pDayString, WCHAR* pEndChar );
    bool  MatchDateDelimiter( WCHAR **DateString );

    //--- Time Related Normalization helpers ---//
    HRESULT IsTimeOfDay( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList, BOOL fMultiItem = true );
    HRESULT IsTime( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT ExpandTime( TTSTimeItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsTimeRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );

    //--- SPELL tag normalization helper
    HRESULT SpellOutString( CWordList& WordList );
    void ExpandPunctuation( CWordList& WordList, WCHAR wc );

    //--- Default normalization helper
    HRESULT ExpandUnrecognizedString( CWordList& WordList, CSentItemMemory& MemoryManager );

    //--- Misc. normalization helpers
    HRESULT IsStateAndZipcode( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT IsHyphenatedString( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo, 
                                CSentItemMemory& MemoryManager );
    HRESULT ExpandHyphenatedString( TTSHyphenatedStringInfo* pItemInfo, CWordList& WordList );
    HRESULT IsSuffix( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo,
                      CSentItemMemory& MemoryManager );
    HRESULT ExpandSuffix( TTSSuffixItemInfo* pItemInfo, CWordList& WordList );
    bool Zeroes( const WCHAR* );
    bool ThreeZeroes( const WCHAR* );
    bool IsPunctuation(const TTSSentItem *Item);

  /*=== Interfaces ====*/
  public:
    //--- IEnumSpSentence ----------------------------------------
	STDMETHOD(SetFragList)( const SPVTEXTFRAG* pTextFragList, DWORD dwFlags );
	STDMETHOD(Next)( IEnumSENTITEM **ppSentItemEnum );
    STDMETHOD(Previous)( IEnumSENTITEM **ppSentItemEnum );
	STDMETHOD(Reset)( void );

  //=== Data members ===
  private:
    CComPtr<ISpContainerLexicon>    m_cpAggregateLexicon;
    CComPtr<ISpPhoneConverter>      m_cpPhonemeConverter;
    CSMorph*                        m_pMorphLexicon;
    DWORD                           m_dwSpeakFlags;
    const SPVTEXTFRAG*              m_pTextFragList;
    const SPVTEXTFRAG*              m_pCurrFrag;
    const WCHAR*                    m_pNextChar;
    const WCHAR*                    m_pEndChar;
    const WCHAR*                    m_pEndOfCurrToken;
    const WCHAR*                    m_pEndOfCurrItem;
    CSentenceStack                  m_SentenceStack;
    SEPARATOR_AND_DECIMAL           m_eSeparatorAndDecimal;
    SHORT_DATE_ORDER                m_eShortDateOrder;
    static CComAutoCriticalSection  m_AbbrevTableCritSec;
};

//--- Structs and typedefs used for abbreviation stuff

typedef HRESULT (CStdSentEnum::* SentBreakDisambigFunc)(const AbbrevRecord*, CItemList& , SPLISTPOS, 
                                                        CSentItemMemory&, BOOL*);
typedef HRESULT (CStdSentEnum::* PronDisambigFunc) ( const AbbrevRecord*, PRONRECORD*, CItemList&, SPLISTPOS );
typedef HRESULT (CStdSentEnum::* PostLexLookupDisambigFunc) ( const AbbrevRecord*, CItemList&, SPLISTPOS, CSentItemMemory& );
extern AbbrevRecord g_AbbreviationTable[177];
extern const PronDisambigFunc g_PronDisambigTable[];
extern const SentBreakDisambigFunc g_SentBreakDisambigTable[];
extern AbbrevRecord g_AmbiguousWordTable[72];
extern const PronDisambigFunc g_AmbiguousWordDisambigTable[];
extern AbbrevRecord g_PostLexLookupWordTable[41];
extern const PostLexLookupDisambigFunc g_PostLexLookupDisambigTable[];
extern WCHAR *g_pOfA;
extern WCHAR *g_pOfAn;
extern BOOL g_fAbbrevTablesInitialized;
extern void CleanupAbbrevTables( void );

//--- First words table - used in sentence breaking
extern const SPLSTR g_FirstWords[163];

//
//=== Inlines
//

inline ULONG my_wcstoul( const WCHAR *pStartChar, WCHAR **ppEndChar )
{
    if ( iswdigit( *pStartChar ) )
    {
        return wcstoul( pStartChar, ppEndChar, 10 );
    }
    else
    {
        if ( ppEndChar )
        {
            *ppEndChar = (WCHAR*) pStartChar;
        }
        return 0;
    }
}

inline ENGPARTOFSPEECH ConvertItemTypeToPartOfSp( TTSItemType ItemType )
{
    switch ( ItemType )
    {
    case eOPEN_PARENTHESIS:
    case eOPEN_BRACKET:
    case eOPEN_BRACE:
        return MS_GroupBegin;

    case eCLOSE_PARENTHESIS:
    case eCLOSE_BRACKET:
    case eCLOSE_BRACE:
        return MS_GroupEnd;

    case eSINGLE_QUOTE:
    case eDOUBLE_QUOTE:
        return MS_Quotation;

    case ePERIOD:
    case eQUESTION:
    case eEXCLAMATION:
        return MS_EOSItem;

    case eCOMMA:
    case eCOLON:
    case eSEMICOLON:
    case eHYPHEN:
    case eELLIPSIS:
        return MS_MiscPunc;

    default:
        return MS_Unknown;
    }
}

inline bool MatchPhoneNumberDelimiter( const WCHAR wc )
{
    return ( wc == L' ' || wc == L'-' || wc == L'.' );
}   

inline bool NeedsToBeNormalized( const AbbrevRecord* pAbbreviation )
{
    if( !wcscmp( pAbbreviation->pOrth, L"jan" )   ||
        !wcscmp( pAbbreviation->pOrth, L"feb" )   ||
        !wcscmp( pAbbreviation->pOrth, L"mar" )   ||
        !wcscmp( pAbbreviation->pOrth, L"apr" )   ||
        !wcscmp( pAbbreviation->pOrth, L"jun" )   ||
        !wcscmp( pAbbreviation->pOrth, L"jul" )   ||
        !wcscmp( pAbbreviation->pOrth, L"aug" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sep" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sept" )  ||
        !wcscmp( pAbbreviation->pOrth, L"oct" )   ||
        !wcscmp( pAbbreviation->pOrth, L"nov" )   ||
        !wcscmp( pAbbreviation->pOrth, L"dec" )   ||
        !wcscmp( pAbbreviation->pOrth, L"mon" )   ||
        !wcscmp( pAbbreviation->pOrth, L"tue" )   ||
        !wcscmp( pAbbreviation->pOrth, L"tues" )  ||
        !wcscmp( pAbbreviation->pOrth, L"wed" )   ||
        !wcscmp( pAbbreviation->pOrth, L"thu" )   ||
        !wcscmp( pAbbreviation->pOrth, L"thur" )  ||
        !wcscmp( pAbbreviation->pOrth, L"thurs" ) ||
        !wcscmp( pAbbreviation->pOrth, L"fri" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sat" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sun" ) )
    {
        return true;
    }
    else
    {
        return false;
    }
}

inline HRESULT SetWordList( CSentItem& Item, CWordList& WordList, CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    SPLISTPOS WordListPos = WordList.GetHeadPosition();
    Item.ulNumWords = WordList.GetCount();
    Item.Words = (TTSWord*) MemoryManager.GetMemory( Item.ulNumWords * sizeof(TTSWord), &hr );
    if ( SUCCEEDED( hr ) )
    {
        ULONG ulIndex = 0;
        while ( WordListPos )
        {
            SPDBG_ASSERT( ulIndex < Item.ulNumWords );
            Item.Words[ulIndex++] = WordList.GetNext( WordListPos );
        }
    }

    return hr;
}

inline int CompareStringAndSPLSTR( const void* _String, const void* _SPLSTR )
{
    int _StringLen = wcslen( (const WCHAR*) _String );
    int _SPLSTRLen = ( (const SPLSTR*) _SPLSTR )->Len;
    if ( _StringLen < _SPLSTRLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const SPLSTR*) _SPLSTR )->pStr, _StringLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return -1;
        }
    }
    else if ( _StringLen > _SPLSTRLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const SPLSTR*) _SPLSTR )->pStr, _SPLSTRLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return 1;
        }
    }
    else
    {
        return ( wcsnicmp( (const WCHAR*) _String , ( (const SPLSTR*) _SPLSTR )->pStr, _StringLen ) );
    }
}

inline int CompareStringAndStateStruct( const void* _String, const void* _StateStruct )
{
    int _StringLen = wcslen( (const WCHAR*) _String );
    int _StateStructLen = ( (const StateStruct*) _StateStruct )->Abbreviation.Len;
    if ( _StringLen < _StateStructLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const StateStruct*) _StateStruct )->Abbreviation.pStr, 
                               _StringLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return -1;
        }
    }
    else if ( _StringLen > _StateStructLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const StateStruct*) _StateStruct )->Abbreviation.pStr, 
                               _StateStructLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return 1;
        }
    }
    else
    {
        return ( wcsnicmp( (const WCHAR*) _String , ( (const StateStruct*) _StateStruct )->Abbreviation.pStr, 
                           _StringLen ) );
    }
}

inline int CompareStringAndAbbrevRecord( const void* _String, const void* _AbbrevRecord )
{
    return ( _wcsicmp( (const WCHAR*) _String, ( (const AbbrevRecord*) _AbbrevRecord )->pOrth ) );
}

inline int CompareWCHARAndWCHAR( const void *pWCHAR_1, const void *pWCHAR_2 )
{
    return ( *( (WCHAR*) pWCHAR_1) - *( (WCHAR*) pWCHAR_2) );
}

inline BOOL IsSpace( WCHAR wc )
{
    return ( ( wc == 0x20 ) || ( wc == 0x9 ) || ( wc == 0xD  ) ||
             ( wc == 0xA ) || ( wc == 0x200B ) );
}

inline BOOL IsCapital( WCHAR wc )
{
    return ( ( wc >= L'A' ) && ( wc <= L'Z' ) );
}

inline TTSItemType IsGroupBeginning( WCHAR wc )
{
    if ( wc == L'(' )
    {
        return eOPEN_PARENTHESIS;
    }
    else if ( wc == L'[' )
    {
        return eOPEN_BRACKET;
    }
    else if ( wc == L'{' )
    {
        return eOPEN_BRACE;
    }
    else
    {
        return eUNMATCHED;
    }
}

inline TTSItemType IsGroupEnding( WCHAR wc )
{
    if ( wc == L')' )
    {
        return eCLOSE_PARENTHESIS;
    }
    else if ( wc == L']' )
    {
        return eCLOSE_BRACKET;
    }
    else if ( wc == L'}' )
    {
        return eCLOSE_BRACE;
    }
    else
    {
        return eUNMATCHED;
    }    
}

inline TTSItemType IsQuotationMark( WCHAR wc )
{
    if ( wc == L'\'' )
    {
        return eSINGLE_QUOTE;
    }
    else if ( wc == L'\"' )
    {
        return eDOUBLE_QUOTE;
    }
    else
    {
        return eUNMATCHED;
    }
}

inline TTSItemType IsEOSItem( WCHAR wc )
{
    if ( wc == L'.' )
    {
        return ePERIOD;
    }
    else if ( wc == L'!' )
    {
        return eEXCLAMATION;
    }
    else if ( wc == L'?' )
    {
        return eQUESTION;
    }
    else
    {
        return eUNMATCHED;
    }
}

inline TTSItemType IsMiscPunctuation( WCHAR wc )
{
    if ( wc == L',' )
    {
        return eCOMMA;
    }
    else if ( wc == L';' )
    {
        return eSEMICOLON;
    }
    else if ( wc == L':' )
    {
        return eCOLON;
    }
    else if ( wc == L'-' )
    {
        return eHYPHEN;
    }
    else
    {
        return eUNMATCHED;
    }
}

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\ttsengine.cpp ===
/*******************************************************************************
* TTSEngine.cpp *
*---------------*
*   Description:
*       This module is the main implementation file for the CTTSEngine class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include <stdio.h>
#include "TTSEngine.h"
#include "stdsentenum.h"
#include "VoiceDataObj.h"
#include "commonlx.h"

/*****************************************************************************
* CTTSEngine::FinalConstruct *
*----------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT CTTSEngine::FinalConstruct()
{
    SPDBG_FUNC( "CTTSEngine::FinalConstruct" );
    HRESULT hr = S_OK;

    return hr;
} /* CTTSEngine::FinalConstruct */

/*****************************************************************************
* CTTSEngine::FinalRelease *
*--------------------------*
*   Description:
*       destructor
********************************************************************* EDC ***/
void CTTSEngine::FinalRelease()
{
    SPDBG_FUNC( "CTTSEngine::FinalRelease" );
} /* CTTSEngine::FinalRelease */

/*****************************************************************************
* CTTSEngine::VoiceInit *
*-----------------------*
*   Description:
*       This method is called by the voice data object during construction
*   to give the TTS driver object access to the voice unit data.
******************************************************************* PACOG ***/
STDMETHODIMP CTTSEngine::VoiceInit( IMSVoiceData* pVoiceData )
{
    SPDBG_FUNC( "CTTSEngine::VoiceInit" );
	HRESULT	hr = S_OK;

    //--- Create sentence enumerator and initialize
    CComObject<CStdSentEnum> *pSentEnum;
    hr = CComObject<CStdSentEnum>::CreateInstance( &pSentEnum );

    //--- Create aggregate lexicon
    if ( SUCCEEDED( hr ) )
    {
        hr = pSentEnum->InitAggregateLexicon();
    }

    //--- Get our voice token
    CComPtr<ISpObjectToken> cpVoiceToken;
    if (SUCCEEDED(hr))
    {
        cpVoiceToken = ((CVoiceDataObj*)pVoiceData)->GetVoiceToken();
    }

    //--- Create vendor lexicon and add to aggregate
    if (SUCCEEDED(hr))
    {
        CComPtr<ISpObjectToken> cpToken;
        hr = SpGetSubTokenFromToken(cpVoiceToken, L"Lex", &cpToken);

        CComPtr<ISpLexicon> cpCompressedLexicon;
        if (SUCCEEDED(hr))
        {
            hr = SpCreateObjectFromToken(cpToken, &cpCompressedLexicon);
        }

        if (SUCCEEDED(hr))
        {
            hr = pSentEnum->AddLexiconToAggregate(cpCompressedLexicon, eLEXTYPE_PRIVATE1);
        }
    }
    //--- Create LTS lexicon and add to aggregate
    if (SUCCEEDED(hr))
    {
        CComPtr<ISpObjectToken> cpToken;
        hr = SpGetSubTokenFromToken(cpVoiceToken, L"Lts", &cpToken);

        CComPtr<ISpLexicon> cpLTSLexicon;
        if (SUCCEEDED(hr))
        {
            hr = SpCreateObjectFromToken(cpToken, &cpLTSLexicon);
        }

        if (SUCCEEDED(hr))
        {
            hr = pSentEnum->AddLexiconToAggregate(cpLTSLexicon, eLEXTYPE_PRIVATE2);
        }
    }

    //--- Create morphology lexicon
    if ( SUCCEEDED( hr ) )
    {
        hr = pSentEnum->InitMorphLexicon();
    }

    //--- Set member sentence enumerator
    if ( SUCCEEDED( hr ) )
    {
        m_cpSentEnum = pSentEnum;
    }

    //--- Save voice data interface, do not AddRef or it will cause circular reference
    if( SUCCEEDED( hr ) )
    {
        m_pVoiceDataObj = pVoiceData;
	    hr = InitDriver();
    }

	return hr;
} /* CTTSEngine::VoiceInit */

/*****************************************************************************
* CTTSEngine::Speak *
*-------------------*
*   Description:
*       This method is supposed to speak the text observing the associated
*   XML state.
********************************************************************* EDC ***/
STDMETHODIMP CTTSEngine::
    Speak( DWORD dwSpeakFlags, REFGUID rguidFormatId,
           const WAVEFORMATEX * /* pWaveFormatEx ignored */,
           const SPVTEXTFRAG* pTextFragList,
           ISpTTSEngineSite* pOutputSite )
{
    SPDBG_FUNC( "CTTSEngine::Speak" );
    HRESULT hr = S_OK;

    //--- Early exit?
    if( ( rguidFormatId != SPDFID_WaveFormatEx && rguidFormatId != SPDFID_Text ) || SP_IS_BAD_INTERFACE_PTR( pOutputSite ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Debug Macro - open file for debugging output
        TTSDBG_OPENFILE;

        //--- Initialize sentence enumerator
        hr = m_cpSentEnum->SetFragList( pTextFragList, dwSpeakFlags );

        if( SUCCEEDED( hr ) )
        {

            //	The following code is here just for testing.
            //  It should be removed once all the tools accept the
            //  new way of outputing debug info.
            if( rguidFormatId == SPDFID_Text )
            {
                //--- Enumerate and write out all sentence items.
                IEnumSENTITEM *pItemEnum;
                TTSSentItem Item;

                //--- Write unicode signature
                static const WCHAR Signature = 0xFEFF;
                hr = pOutputSite->Write( &Signature, sizeof(Signature), NULL );

                while( (hr = m_cpSentEnum->Next( &pItemEnum) ) == S_OK )
                {
                    while( (hr = pItemEnum->Next( &Item )) == S_OK )
                    {
                        // Is there a valid normalized-word-list?
                        if ( Item.pItemInfo->Type & eWORDLIST_IS_VALID )
                        {
                            for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                            {
                                if ( Item.Words[i].pXmlState->eAction == SPVA_Speak ||
                                     Item.Words[i].pXmlState->eAction == SPVA_SpellOut )
                                {
                                    ULONG cb = Item.Words[i].ulWordLen * sizeof( WCHAR );
                                    hr = pOutputSite->Write( Item.Words[i].pWordText, cb, NULL );
                                    if( hr == S_OK ) 
                                    {
                                        //--- Insert space between items
                                        hr = pOutputSite->Write( L" ", sizeof( WCHAR ), NULL );
                                    }
                                }
                            }
                        }
                        else // no word list - just write the original text.
                        {
                            ULONG cb = Item.ulItemSrcLen * sizeof( WCHAR );
                            hr = pOutputSite->Write( Item.pItemSrcText, cb, NULL ); 
                            if ( SUCCEEDED(hr) )
                            {
                                //--- Insert space between items
                                hr = pOutputSite->Write( L" ", sizeof( WCHAR ), NULL );
                            }
                        }
                    }
                    pItemEnum->Release();

                    //--- Insert mark between sentences
                    if( SUCCEEDED( hr ) ) 
                    {
                        static const WCHAR CRLF[2] = { 0x000D, 0x000A };
                        hr = pOutputSite->Write( CRLF, 2*sizeof(WCHAR), NULL );
                    }
                }
                static const WCHAR ENDL = 0x0000;
                hr = pOutputSite->Write( &ENDL, sizeof(WCHAR), NULL );

            }
            else 
            {
                //--- Render the text
                m_FEObj.PrepareSpeech( m_cpSentEnum, pOutputSite );
                m_BEObj.PrepareSpeech( pOutputSite );

                do
                {
                    //--- Fill another frame of speech audio
                    hr = m_BEObj.RenderFrame( );
                }
                while( (hr == S_OK) && (m_BEObj.GetSpeechState() == SPEECH_CONTINUE) );            
            }
        }

        //--- Debug Macro - close debugging file
        TTSDBG_CLOSEFILE;
    }

    return hr;
} /* CTTSEngine::Speak */

/****************************************************************************
* CTTSEngine::GetOutputFormat *
*-----------------------------*
*   Description:
*
*   Returns:
*
******************************************************************* PACOG ***/

STDMETHODIMP CTTSEngine::GetOutputFormat(const GUID * pTargetFormatId, const WAVEFORMATEX * /* pTargetWaveFormatEx */,
                                         GUID * pDesiredFormatId, WAVEFORMATEX ** ppCoMemDesiredWaveFormatEx)
{
    SPDBG_FUNC("CTTSEngine::GetOutputFormat");
    HRESULT hr = S_OK;

    if( ( SP_IS_BAD_WRITE_PTR(pDesiredFormatId)  ) || 
		( SP_IS_BAD_WRITE_PTR(ppCoMemDesiredWaveFormatEx) ) )
    {
        hr = E_INVALIDARG;
    }
    else if (pTargetFormatId == NULL || *pTargetFormatId != SPDFID_Text)
    {
        *pDesiredFormatId = SPDFID_WaveFormatEx;
        *ppCoMemDesiredWaveFormatEx = (WAVEFORMATEX *)::CoTaskMemAlloc(sizeof(WAVEFORMATEX));
        if (*ppCoMemDesiredWaveFormatEx)
        {
            **ppCoMemDesiredWaveFormatEx = m_VoiceInfo.WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *pDesiredFormatId = SPDFID_Text;
        *ppCoMemDesiredWaveFormatEx = NULL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/*****************************************************************************
* CTTSEngine::InitDriver *
*------------------------*
*   Description:
*       Init driver with new voice.
********************************************************************** MC ***/
HRESULT CTTSEngine::InitDriver()
{
    SPDBG_FUNC( "CTTSEngine::InitDriver" );
    HRESULT hr = S_OK;
    
    //--------------------------
    // Get voice information
    //--------------------------
    hr = m_pVoiceDataObj->GetVoiceInfo( &m_VoiceInfo );
	if( SUCCEEDED(hr) )
	{
		m_SampleRate = m_VoiceInfo.SampleRate;

		//-----------------------------
		// Reverb is always stereo
		//-----------------------------
		if (m_VoiceInfo.eReverbType != REVERB_TYPE_OFF )
		{
			//------------------
			// Stereo
			//------------------
			m_IsStereo = true;
			m_BytesPerSample = 4;
		}
		else
		{
			//------------------
			// MONO
			//------------------
			m_IsStereo = false;
			m_BytesPerSample = 2;
		}

		//--------------------------
		// Initialize BACKEND obj
		//--------------------------
		hr =  m_BEObj.Init( m_pVoiceDataObj, &m_FEObj, &m_VoiceInfo );

		//--------------------------
		// Initialize FRONTEND obj
		//--------------------------
		if( SUCCEEDED( hr ))
		{
			hr =  m_FEObj.Init( m_pVoiceDataObj, NULL, &m_VoiceInfo );
		}
    }
    return hr;
} /* CTTSEngine::InitDriver */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\ttsengine.h ===
/******************************************************************************
* TTSEngine.h *
*-------------*
*  This is the header file for the CTTSEngine implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef TTSEngine_h
#define TTSEngine_h

//--- Additional includes
#ifndef __spttseng_h__
#include "spttseng.h"
#endif

#ifndef SPDDKHLP_h
#include <spddkhlp.h>
#endif

#ifndef SPHelper_h
#include <sphelper.h>
#endif

#ifndef Backend_H
#include "Backend.h"
#endif

#ifndef Frontend_H
#include "Frontend.h"
#endif

#ifndef FeedChain_H
#include "FeedChain.h"
#endif

#include "resource.h"

//=== Constants ====================================================
#define TEXT_VOICE_FMT_INDEX    1

//=== Class, Enum, Struct and Union Declarations ===================

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CTTSEngine COM object ********************************
*/
class ATL_NO_VTABLE CTTSEngine : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTTSEngine, &CLSID_MSTTSEngine>,
	public ISpTTSEngine,
    public IMSTTSEngineInit
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_MSTTSENGINE)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CTTSEngine)
	    COM_INTERFACE_ENTRY(ISpTTSEngine)
	    COM_INTERFACE_ENTRY(IMSTTSEngineInit)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    HRESULT FinalConstruct();
    void FinalRelease();

    /*--- Non interface methods ---*/
	HRESULT InitDriver();
    
    /*=== Interfaces ====*/
  public:
    //--- IMSTTSEngineInit ----------------------------------------
    STDMETHOD(VoiceInit)( IMSVoiceData* pVoiceData );

    //--- ISpTTSEngine --------------------------------------------
    STDMETHOD(Speak)( DWORD dwSpeakFlags,
                      REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx,
                      const SPVTEXTFRAG* pTextFragList, ISpTTSEngineSite* pOutputSite );
    STDMETHOD(GetOutputFormat)( const GUID * pTargetFormatId, const WAVEFORMATEX * pTargetWaveFormatEx,
                                GUID * pDesiredFormatId, WAVEFORMATEX ** ppCoMemDesiredWaveFormatEx );

  private:
  /*=== Member Data ===*/
    CComPtr<IEnumSpSentence>    m_cpSentEnum;
	CBackend                    m_BEObj;
	CFrontend                   m_FEObj;
    IMSVoiceData				*m_pVoiceDataObj;        // This should not AddRef
	ULONG                       m_BytesPerSample;
    bool                        m_IsStereo;
    ULONG                       m_SampleRate;
    MSVOICEINFO                 m_VoiceInfo;
};

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\tools\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DebugSupport.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\regvoices\makefile.inc ===
RunProgram :
	$(O)\$(TARGETNAME).exe
!if defined(MAKEDLL)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\voicedataobj.h ===
/******************************************************************************
* VoiceDataObj.h *
*----------------*
*   This is the header file for the CVoiceDataObj implementation. This object
*   is used to provide shared access to a specific voice data file.
*------------------------------------------------------------------------------
*   Copyright (C) 1999 Microsoft Corporation         Date: 05/06/99
*   All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef VoiceDataObj_h
#define VoiceDataObj_h

//--- Additional includes
#ifndef __spttseng_h__
#include "spttseng.h"
#endif

#ifndef SPDDKHLP_h
#include <spddkhlp.h>
#endif

#ifndef SPHelper_h
#include <sphelper.h>
#endif

#include <MMREG.H>

#include "resource.h"

#include "SpTtsEngDebug.h"

//=== Constants ====================================================
static const long VOICE_VERSION   = 0x10001;
static const long HEADER_VERSION  = 0x10000;
static const long MS_VOICE_TYPE   = MAKEFOURCC('V','o','i','s');
static const long MS_DATA_TYPE    = MAKEFOURCC('D','a','t','a');
static const float SIL_DURATION    = 0.01f;


//=== Class, Enum, Struct and Union Declarations ===================

//------------------------------------
// Selector for 'GetData()'
// For accessing voice data blocks
//------------------------------------
enum VOICEDATATYPE
{   
    MSVD_PHONE,
    MSVD_SENONE,
    MSVD_TREEIMAGE,
    MSVD_INVENTORY,
    MSVD_ALLOID
};

//---------------------------
// VOICEINFO data types
//---------------------------
enum GENDER
{   
    GENDER_NEUTRAL = 0,
    GENDER_FEMALE,
    GENDER_MALE
};
enum COMPRESS_TYPE
{   
    COMPRESS_NONE = 0,
    COMPRESS_LPC
};


// THis is the data 
#pragma pack (1)
struct VOICEINFO
{
    long            Type;               // Always 'MS_VOICE_TYPE'
    ULONG           Version;            // Always 'VOICE_VERSION'
    WCHAR           Copyright[256];     // INFO:
    WCHAR           VoiceName[64];      // INFO:
    WCHAR           Example[64];        // INFO: 
    LCID			LangID;
    GENDER          Gender;             // INFO: Male, female or neuter
    ULONG           Age;                // INFO: Speaker age in years
    ULONG           Rate;               // INFO & FE: Words-per-minute
    ULONG           Pitch;              // INFO & FE: Average pitch in Hz 
    COMPRESS_TYPE   CompressionType;    // BE: Always 'COMPRESS_LPC'
    REVERBTYPE      ReverbType;         // BE: Reverb param
    ULONG           NumOfTaps;          // BE: Whisper param
    float           TapCoefficients[8]; // BE: Whisper param
    ULONG           ProsodyGain;        // FE: 0 = monotone
    float           VibratoFreq;        // Hertz
    ULONG           VibratoDepth;       // 0 - 100%
    ULONG           SampleRate;         // 22050 typical
    GUID            formatID;           // SAPI audio format ID
    long            Unused[4];
};
#pragma pack ()
typedef VOICEINFO *PVOICEINFO;



//---------------------------------------------------
// Header definition for voice data block
//---------------------------------------------------
#pragma pack (1)
struct VOICEBLOCKOFFSETS
{
    long    Type;           // Always 'MS_DATA_TYPE'
    long    Version;        // Always 'HEADER_VERSION'
    GUID    DataID;         // File ID
    long    PhonOffset;     // Offset to PHON block (from beginning of file)
    long    PhonLen;        // Length of PHON block
    long    SenoneOffset;   // Offset to SENONE block (from beginning of file)
    long    SenoneLen;      // Length of SENONE block
    long    TreeOffset;     // Offset to TREE block (from beginning of file)
    long    TreeLen;        // Length of TREE block
    long    InvOffset;      // Offset to INV block (from beginning of file)
    long    InvLen;         // Length of INV block
    long    AlloIDOffset;      // Offset to AlloId block (from beginning of file)
    long    AlloIDLen;         // Length of AlloID block
};
#pragma pack ()


// Single VQ Codebook
#pragma pack (1)
typedef struct Book 
{
    long    cCodeSize;          // Number of codewords
    long    cCodeDim;           // Dimension of codeword
    long    pData;              // Offset to data (INVENTORY rel)
} BOOK, *PBOOK;
#pragma pack ()


static const long BOOKSHELF   = 32;

#pragma pack (1)
typedef struct Inventory 
{
    long        SampleRate;             // Sample rate in Hz
    long        cNumLPCBooks;           // Number of LPC Codebooks
    long        cNumResBooks;           // Number of Residual Codebooks
    long        cNumDresBooks;          // Number of Delta Residual Codebooks
    BOOK        LPCBook[BOOKSHELF];     // LPC Codebook array
    BOOK        ResBook[BOOKSHELF];     // Residual Codebook array
    BOOK        DresBook[BOOKSHELF];    // Delta residual Codebook array
    long        cNumUnits;              // Total number of units
    long        UnitsOffset;            // Offset to offset array to unit data (INVENTORY rel)
    long        cOrder;                 // LPC analysis order
    long        FFTSize;                // Size of FFT
    long        FFTOrder;               // Order of FFT
    long        TrigOffset;             // Offset to sine table (INVENTORY rel)
    long        WindowOffset;           // Offset to Hanning Window (INVENTORY rel)
    long        pGaussOffset;           // Offset to Gaussian Random noise (INVENTORY rel)
    long        GaussID;                // Gaussian sample index
} INVENTORY, *PINVENTORY;
#pragma pack ()

//------------------------
// LPC order * 2
//------------------------
static const long MAXNO   = 40;

static const float KONEPI  = 3.1415926535897931032f;
static const float KTWOPI  = (KONEPI * 2);
static const float K2 = 0.70710678118655f;


#pragma pack (1)
typedef struct 
{
    long    val;                // Phon ID
    long    obj;                // Offset to phon string
} HASH_ENTRY;
#pragma pack ()


#pragma pack (1)
typedef struct 
{
    long        size;               // Number entries in the table (127 typ.)
    long        UNUSED1; 
    long        entryArrayOffs;     // Offset to HASH_ENTRY array
    long        UNUSED2;
    long        UNUSED3;
    long        UNUSED4;
    long        UNUSED5;
} HASH_TABLE;
#pragma pack ()



#pragma pack (1)
typedef struct 
{
    HASH_TABLE      phonHash;
    long            phones_list;    // Offset to offsets to phon strings
    long            numPhones;
    long            numCiPhones;    // Number of context ind. phones
} PHON_DICT;
#pragma pack ()




#pragma pack (1)
typedef struct 
{
    long        nfeat;
    long        nint32perq;
    long        b_ques;
    long        e_ques;
    long        s_ques;
    long        eors_ques;
    long        wwt_ques;
    long        nstateq;
} FEATURE;
#pragma pack ()


#pragma pack (1)
typedef struct
{
    long        prod;           // For leaves, it means the counts.
                                //   For non-leaves, it is the offset 
                                //   into TRIPHONE_TREE.prodspace.
    short       yes;            // Negative means there is no child. so this is a leaf
    short       no;             // for leaves, it is lcdsid
    short       shallow_lcdsid; // negative means this is NOT a shallow leaf
} C_NODE;
#pragma pack ()


#pragma pack (1)
typedef struct 
{
    short       nnodes;
    short       nleaves;
    long        nodes;              // Offset
}TREE_ELEM;




#define NUM_PHONS_MAX   64

#pragma pack (1)
typedef struct 
{
    FEATURE         feat;
    long            UNUSED;                     // PHON_DICT *pd usually
    long            nsenones; 
    long            silPhoneId; 
    long            nonSilCxt; 
    
    long            nclass; 
    long            gsOffset[NUM_PHONS_MAX];    // nclass+1 entries
    
    TREE_ELEM       tree[NUM_PHONS_MAX];
    long            nuniq_prod;                 // not used for detailed tree
    long            uniq_prod_Offset;                   // Offset to table
    long            nint32perProd;
} TRIPHONE_TREE;
#pragma pack ()

static const long NO_PHON     = (-1);

#define ABS(x) ((x) >= 0 ? (x) : -(x))
#define MAX(x,y) (((x) >= (y)) ? (x) : (y))
#define MIN(x,y) (((x) <= (y)) ? (x) : (y))


#pragma pack (1)
typedef struct 
{
    float	dur;
    float	durSD;
    float	amp;
    float	ampRatio;
} UNIT_STATS;
#pragma pack ()



//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================



/*** CVoiceDataObj COM object ********************************
*/
class ATL_NO_VTABLE CVoiceDataObj : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CVoiceDataObj, &CLSID_MSVoiceData>,
    public IMSVoiceData,
    public ISpObjectWithToken
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_MSVOICEDATA)
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CVoiceDataObj)
        COM_INTERFACE_ENTRY(ISpObjectWithToken)
	    COM_INTERFACE_ENTRY(IMSVoiceData)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND( m_cpunkDrvVoice.p )
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    HRESULT FinalConstruct();
    void FinalRelease();
	ISpObjectToken* GetVoiceToken() {return m_cpToken;}

 private:
    /*--- Non interface methods ---*/
    HRESULT MapFile(const WCHAR * pszTokenValName, HANDLE * phMapping, void ** ppvData);
    HRESULT GetDataBlock( VOICEDATATYPE type, char **ppvOut, ULONG *pdwSize );
    HRESULT InitVoiceData();
    HRESULT DecompressUnit( ULONG UnitID, MSUNITDATA* pSynth );
    long DecompressEpoch( signed char *rgbyte, long cNumEpochs, float *pEpoch );
    long OrderLSP( PFLOAT pLSPFrame, INT cOrder );
    void LSPtoPC( float *pLSP, float *pLPC, long cOrder, long frame );
    void PutSpectralBand( float *pFFT, float *pBand, long StartBin, 
                          long cNumBins, long FFTSize );
    void AddSpectralBand( float *pFFT, float *pBand, long StartBin, 
                          long cNumBins, long FFTSize );
    void InverseFFT( float *pDest, long fftSize, long fftOrder, float *sinePtr );
    void SetEpochLen( float *pOutRes, long OutSize, float *pInRes, 
                      long InSize );
    void GainDeNormalize( float *pRes, long FFTSize, float Gain );
    long PhonToID( PHON_DICT *pd, char *phone_str );
    char *PhonFromID( PHON_DICT *pd, long phone_id );
    HRESULT GetTriphoneID( TRIPHONE_TREE *forest, 
                        long        phon,           // target phon              
                        long        leftPhon,       // left context
                        long        rightPhon,      // right context
                        long        pos,            // word position ("b", "e" or "s"
                        PHON_DICT   *pd,
                        ULONG       *pResult );
    long PhonHashLookup( PHON_DICT  *pPD,   // the hash table
                         char       *sym,   // The symbol to look up
                         long       *val );  // Phon ID
    void FIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps );
    void IIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps );
    HRESULT GetUnitDur( ULONG UnitID, float* pDur );
    
    /*=== Interfaces ====*/
  public:
    //--- ISpObjectWithToken ----------------------------------
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken)
        { return SpGenericGetObjectToken( ppToken, m_cpToken ); }

    //--- IMSVoiceData ----------------------------------------
    STDMETHOD(GetVoiceInfo)( MSVOICEINFO* pVoiceInfo );
    //STDMETHOD(GetUnitInfo)( UNIT_INFO* pUnitInfo );
    STDMETHOD(GetUnitIDs)( UNIT_CVT* pUnits, ULONG cUnits );
    STDMETHOD(GetUnitData)( ULONG unitID, MSUNITDATA* pUnitData );
    STDMETHOD(AlloToUnit)( short allo, long attributes, long* pUnitID );

  private:
  /*=== Member Data ===*/
    CComPtr<IUnknown> m_cpunkDrvVoice;
    CComPtr<ISpObjectToken> m_cpToken;
    HANDLE                  m_hVoiceDef;
    HANDLE                  m_hVoiceData;
    VOICEINFO*              m_pVoiceDef;
    VOICEBLOCKOFFSETS*      m_pVoiceData;

    PHON_DICT*      m_pd;
    TRIPHONE_TREE*  m_pForest;
    UNALIGNED long* m_SenoneBlock;
    ULONG           m_First_Context_Phone;
    ULONG           m_Sil_Index;

    // Unit Inventory
    INVENTORY*      m_pInv;
    float           m_SampleRate;
    long            m_cOrder;
    long           *m_pUnit;       // Pointer to offsets to unit data
    float          *m_pTrig;       // Sine table
    float          *m_pWindow;     // Hanning Window
    float          *m_pGauss;      // Gaussian Random noise
    COMPRESS_TYPE   m_CompressionType;
    ULONG           m_FFTSize;
    long            m_GaussID;
    short           *m_AlloToUnitTbl;
    long            m_NumOfAllos;
    ULONG           m_NumOfUnits;	// Inventory size
};

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\voicedataobj.cpp ===
/*******************************************************************************
* VoiceDataObj.cpp *
*------------------*
*   Description:
*       This module is the main implementation file for the CVoiceDataObj class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 05/06/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "VoiceDataObj.h"

/*****************************************************************************
* CVoiceDataObj::FinalConstruct *
*-------------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT CVoiceDataObj::FinalConstruct()
{
    //--- Init vars
    m_hVoiceDef  = NULL;
    m_hVoiceData = NULL;
    m_pVoiceData = NULL;
    m_pVoiceDef  = NULL;

    //--- Create driver voice but initialize later
    return m_cpunkDrvVoice.CoCreateInstance( CLSID_MSTTSEngine, GetControllingUnknown() );
} /* CVoiceDataObj::FinalConstruct */

/*****************************************************************************
* CVoiceDataObj::FinalRelease *
*-----------------------------*
*   Description:
*       destructor
********************************************************************* EDC ***/
void CVoiceDataObj::FinalRelease()
{
    SPDBG_FUNC( "CVoiceDataObj::FinalRelease" );

    if( m_pVoiceDef )
    {
        ::UnmapViewOfFile( (void*)m_pVoiceDef );
    }

    if( m_pVoiceData )
    {
        ::UnmapViewOfFile( (void*)m_pVoiceData );
    }

    if( m_hVoiceDef  ) ::CloseHandle( m_hVoiceDef  );
    if( m_hVoiceData ) ::CloseHandle( m_hVoiceData );
} /* CVoiceDataObj::FinalRelease */


/*****************************************************************************
* CVoiceDataObj::MapFile *
*------------------------*
*   Description:
*       Helper function used by SetObjectToken to map file.  This function
*   assumes that m_cpToken has been initialized.+++
********************************************************************* RAL ***/
HRESULT CVoiceDataObj::MapFile( const WCHAR * pszTokenVal,   // Value that contains file path
                                HANDLE * phMapping,          // Pointer to file mapping handle
                                void ** ppvData )            // Pointer to the data
{
    HRESULT hr = S_OK;
    bool fWorked;

    CSpDynamicString dstrFilePath;
    hr = m_cpToken->GetStringValue( pszTokenVal, &dstrFilePath );
    if ( SUCCEEDED( hr ) )
    {
        fWorked = false;
        *phMapping = NULL;
        *ppvData = NULL;


        HANDLE  hFile;

#ifndef _WIN32_WCE
        hFile = g_Unicode.CreateFile( 
                    dstrFilePath, 
                    GENERIC_READ, 
                    FILE_SHARE_READ, 
                    NULL, 
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 
                    NULL );
#else   //_WIN32_WCE
        hFile = g_Unicode.CreateFileForMapping( 
                    dstrFilePath, 
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL, 
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 
                    NULL );
#endif  //_WIN32_WCE
        if (hFile != INVALID_HANDLE_VALUE)
        {
            //-------------------------------------
            // Make a unique map name from path
            //-------------------------------------
            long        i;

            for( i = 0; i < _MAX_PATH-1; i++ )
            {
                if( dstrFilePath[i] == 0 )
                {
                    // End of string
                    break;
                }
                if( dstrFilePath[i] == '\\' )
                {
                    //-------------------------------------
                    // Change backslash to underscore
                    //-------------------------------------
                    dstrFilePath[i] = '_';
                }
            }

            *phMapping = g_Unicode.CreateFileMapping( hFile, NULL, PAGE_READONLY, 0, 0, dstrFilePath );

            ::CloseHandle( hFile );

        }

        if (*phMapping)
        {
            *ppvData = ::MapViewOfFile( *phMapping, FILE_MAP_READ, 0, 0, 0 );
            if (*ppvData)
            {
                fWorked = true;
            }
        }
        if (!fWorked)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            if (hr == E_HANDLE)
            {
                hr &= 0xFFFFF000;
                hr |= ERROR_FILE_NOT_FOUND;
            }

            if (*phMapping)
            {
                ::CloseHandle(*phMapping);
                *phMapping = NULL;
            }
        }
    }
    return hr;
} /* CVoiceDataObj::MapFile */
 
/*****************************************************************************
* CVoiceDataObj::SetObjectToken *
*-------------------------------*
*   Description:
*       This function performs the majority of the initialization of the voice.
*   Once the object token has been provided, the filenames are read from the
*   token key and the files are mapped.+++
********************************************************************* RAL ***/
STDMETHODIMP CVoiceDataObj::SetObjectToken(ISpObjectToken * pToken)
{
    SPDBG_FUNC( "CVoiceDataObj::SetObjectToken" );
    HRESULT hr = SpGenericSetObjectToken(pToken, m_cpToken);

    if ( SUCCEEDED( hr ) )
    {
        hr = MapFile( L"VoiceDef", &m_hVoiceDef, (void **)&m_pVoiceDef );
    }
    if ( SUCCEEDED( hr ) )
    {
        hr = MapFile( L"VoiceData", &m_hVoiceData, (void **)&m_pVoiceData );
    }

    //--- Init voice data pointers
    if (SUCCEEDED(hr))
    {
        hr = InitVoiceData();
    }

    if( SUCCEEDED( hr ))
    {
        CComQIPtr<IMSTTSEngineInit> cpInit( m_cpunkDrvVoice );
        SPDBG_ASSERT( cpInit );
        hr = cpInit->VoiceInit( this );
    }

    return hr;
} /* CVoiceDataObj::SetObjectToken */

/*****************************************************************************
* CVoiceDataObj::GetVoiceInfo *
*-----------------------------*
*   Description:
*       This method is used to retrieve the voice file data description.+++
********************************************************************* EDC ***/
STDMETHODIMP CVoiceDataObj::GetVoiceInfo( MSVOICEINFO* pVoiceInfo )
{
    SPDBG_FUNC( "CVoiceDataObj::GetVoiceInfo" );
    HRESULT hr = S_OK;
    long    i;

    //--- Check args
    if( ( SP_IS_BAD_WRITE_PTR( pVoiceInfo ) ) || ( m_pVoiceDef == NULL ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (!m_cpToken)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            pVoiceInfo->pWindow = m_pWindow;
            pVoiceInfo->FFTSize = m_FFTSize;
            pVoiceInfo->LPCOrder = m_cOrder;
            pVoiceInfo->ProsodyGain = m_pVoiceDef->ProsodyGain;
            pVoiceInfo->eReverbType = m_pVoiceDef->ReverbType;
            pVoiceInfo->Pitch = m_pVoiceDef->Pitch;
            pVoiceInfo->Rate = m_pVoiceDef->Rate;
            pVoiceInfo->LangID = m_pVoiceDef->LangID;
            pVoiceInfo->SampleRate = m_pVoiceDef->SampleRate;
            pVoiceInfo->VibratoFreq = m_pVoiceDef->VibratoFreq;
            pVoiceInfo->VibratoDepth = m_pVoiceDef->VibratoDepth;
            pVoiceInfo->NumOfTaps = m_pVoiceDef->NumOfTaps;

            // Assumes voices are ALWAYS 16-bit mono (probably valid for now)***
            pVoiceInfo->WaveFormatEx.wFormatTag         = WAVE_FORMAT_PCM;
            pVoiceInfo->WaveFormatEx.nSamplesPerSec     = pVoiceInfo->SampleRate;
            pVoiceInfo->WaveFormatEx.wBitsPerSample     = 16;   // ***
            pVoiceInfo->WaveFormatEx.nChannels          = 1;    // ***
            pVoiceInfo->WaveFormatEx.nBlockAlign        = (unsigned short)(pVoiceInfo->WaveFormatEx.nChannels * sizeof(short)); // ***
            pVoiceInfo->WaveFormatEx.nAvgBytesPerSec    = pVoiceInfo->WaveFormatEx.nSamplesPerSec * pVoiceInfo->WaveFormatEx.nBlockAlign;  
            pVoiceInfo->WaveFormatEx.cbSize             = 0;
            for (i = 0; i < MAXTAPS; i++)
            {
                pVoiceInfo->TapCoefficients[i] = m_pVoiceDef->TapCoefficients[i];
            }
        }
    }
    return hr;
} /* CVoiceDataObj::GetVoiceInfo */


/*****************************************************************************
* CVoiceDataObj::GetUnit *
*------------------------*
*   Description:
*   Retrieves and uncompresses audio data from the unit inventory. +++
*       
********************************************************************* EDC ***/
STDMETHODIMP CVoiceDataObj::GetUnitData( ULONG unitID, MSUNITDATA* pUnitData )
{
    SPDBG_FUNC( "CVoiceDataObj::GetUnit" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_WRITE_PTR( pUnitData ) )
    {
        hr = E_INVALIDARG;
    }
    else if( unitID > m_NumOfUnits )
    {
        //--------------------------
        // ID is out of range!
        //--------------------------
        hr = E_INVALIDARG;
    }
    else
    {
        if (!m_cpToken)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            if( m_CompressionType != COMPRESS_LPC ) 
            {
                //--------------------------------------
                // Unsupported compression type
                //--------------------------------------
                hr = E_FAIL;
            } 
            else 
            {
                //-------------------------------------------------------------------
                // Retrieve data from compressed inventory
                //-------------------------------------------------------------------
                hr = DecompressUnit( unitID, pUnitData );
            }
        }
    }
    return hr;
} /* CVoiceDataObj::GetUnit */


/*****************************************************************************
* CVoiceDataObj::AlloToUnit *
*---------------------------*
*   Description:
*   Converts FE allo code to BE unit phon code.+++
*       
********************************************************************* EDC ***/
STDMETHODIMP CVoiceDataObj::AlloToUnit( short allo, long attributes, long* pUnitID )
{
    SPDBG_FUNC( "CVoiceDataObj::AlloToUnit" );
    HRESULT hr = S_OK;
    long        index;
    union {
        char c[2];
        short s;
    } temp;
    char* pb;

    //--- Check args
    if( (SP_IS_BAD_READ_PTR( pUnitID )) || (allo >= m_NumOfAllos) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        index = (long)allo << 1;           // 2 entries per phon
        if( attributes & ALLO_IS_STRESSED )
        {
            //--- 2nd half
            pb = (char*) &m_AlloToUnitTbl[index + (m_NumOfAllos << 1)];
        }
        else
        {
            pb = (char*) &m_AlloToUnitTbl[index];
        }

        // We read this way to avoid missaligned data accesses in 64bit.
        temp.c[0] = *pb++;
        temp.c[1] = *pb;

        *pUnitID = (long) temp.s;            
    }

   return hr;
} /* CVoiceDataObj::AlloToUnit */



/*****************************************************************************
* CVoiceDataObj::GetUnitIDs *
*---------------------------*
*   Description:
*   Gets the inventory triphone (in context) unit code.+++
*       
********************************************************************* EDC ***/
STDMETHODIMP CVoiceDataObj::GetUnitIDs( UNIT_CVT* pUnits, ULONG cUnits )
{
    SPDBG_FUNC( "CVoiceDataObj::GetUnitIDs" );
    ULONG    i;
    ULONG    curID, prevID, nextID;
    ULONG    curF, prevF, nextF;
    char    cPos;
    ULONG    senoneID;
    UNALIGNED UNIT_STATS  *pStats;
    HRESULT hr = S_OK;

    //--- Check args
    if( (SP_IS_BAD_READ_PTR( pUnits)) ||
        (SP_IS_BAD_WRITE_PTR( pUnits)) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (!m_cpToken)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            for( i = 0; i < cUnits; i++ )
            {
                //---------------------------
                // CURRENT phon
                //---------------------------
                curID = pUnits[i].PhonID;
                curF = pUnits[i].flags;
        
                //---------------------------
                // PREVIOUS phon
                //---------------------------
                if( i == 0 )
                {
                    prevID = m_Sil_Index;
                    prevF = 0;
                }
                else
                {
                    prevID = pUnits[i-1].PhonID;
                    prevF = pUnits[i-1].flags;
                }
        
                //---------------------------
                // NEXT phon
                //---------------------------
                if( i >= cUnits -1 )
                {
                    nextID = m_Sil_Index;
                    nextF = 0;
                }
                else
                {
                    nextID = pUnits[i+1].PhonID;
                    nextF = pUnits[i+1].flags;
                }
        
                if( curID == m_Sil_Index )
                {
                    //----------------------
                    // SILENCE phon
                    //----------------------
                    pUnits[i].UnitID = 0;
                    pUnits[i].SenoneID = 0;
                    pUnits[i].szUnitName[0] = 0;
                    pUnits[i].Dur = SIL_DURATION;
                    pUnits[i].Amp = 0;
                    pUnits[i].AmpRatio = 1.0f;
                }
               else
                {
                    cPos = '\0';
                    if( curF & WORD_START_FLAG )
                    {
                        if( nextF & WORD_START_FLAG )
                            //---------------------------------------
                            // Both Cur and Next are word start
                            //---------------------------------------
                            cPos = 's';
                       else
                            //---------------------------------------
                            // Cur is word start
                            // Next is not
                            //---------------------------------------
                            cPos = 'b';
                    }
                    else if( nextF & WORD_START_FLAG )
                    {
                        //---------------------------------------
                        // Next is word start
                        // Cur is not
                        //---------------------------------------
                        cPos = 'e';
                    }
                    HRESULT     hrt;

                    hrt = GetTriphoneID( m_pForest, 
                                        curID, 
                                        prevID, 
                                        nextID, 
                                        cPos, 
                                        m_pd,
                                        &senoneID);
                    if( FAILED(hrt) )
                    {
                        //------------------------------------------------
                        // Instead of failing, I'll be robust and ignore 
                        // the error. Force triphone to something that's 
                        // valid.
                        //------------------------------------------------
                        senoneID = 0;
                    }
                    pUnits[i].UnitID = (m_pForest->gsOffset[curID] - 
                               m_First_Context_Phone) + (senoneID + 1);
                    pUnits[i].SenoneID = senoneID;

                    //-----------------------------
                    // Get phon name strings
                    //-----------------------------
                    char        *pName;
                    pName = PhonFromID( m_pd, pUnits[i].PhonID );
                    strncpy( &pUnits[i].szUnitName[0], pName, 15 );
                    pUnits[i].szUnitName[14] = '\0';

                    //-----------------------------
                    // Get unit stats
                    //-----------------------------
                    pStats = (UNALIGNED UNIT_STATS*)(m_SenoneBlock[curID] + (char*)m_SenoneBlock);
                    pStats = &pStats[senoneID+1];
                    pStats = (UNALIGNED UNIT_STATS*)(m_SenoneBlock[curID] + (char*)m_SenoneBlock);
                    pStats = &pStats[senoneID-1];

                    pStats = (UNALIGNED UNIT_STATS*)(m_SenoneBlock[curID] + (char*)m_SenoneBlock);
                    pStats = &pStats[senoneID];
                    pUnits[i].Dur = pStats->dur / 1000.0f;      // ms -> sec
                    pUnits[i].Amp = pStats->amp;
                    pUnits[i].AmpRatio = (float)sqrt(pStats->ampRatio);

                    //----------------------------------------------------------
                    // Looks like the "SENONE" table durations are 
                    //   incorrect (not even close!).
                    // Calc the real duration from inv epochs
                    // TODO: Make new table in voice data block
                    //----------------------------------------------------------
                    //hr = GetUnitDur( pUnits[i].UnitID, &pUnits[i].Dur );
                    if( FAILED(hr) )
                    {
                        break;
                    }
                }
            }
        }
    }
    return hr;
} /* CVoiceDataObj::GetUnitIDs */



/*****************************************************************************
* GetDataBlock *
*--------------*
*   Description:
*       Return ptr and length of specified voice data block. +++
*       
********************************************************************** MC ***/
HRESULT CVoiceDataObj::GetDataBlock( VOICEDATATYPE type, char **ppvOut, ULONG *pdwSize )
{
    SPDBG_FUNC( "CVoiceDataObj::GetDataBlock" );
    long    *offs;
    HRESULT hr = S_OK;
    long    dataType;
    
    if( !m_pVoiceData )
    {
        hr = E_INVALIDARG;
   }
    else
    {
        dataType    = (long)type * 2;               // x2 since each entry is an offset/length pair
        offs        = (long*)&m_pVoiceData->PhonOffset;    // Table start
        *ppvOut     = offs[dataType] + ((char*)m_pVoiceData);         // Offset -> abs address
        *pdwSize    = offs[dataType + 1];
    }
        
    
    return hr;
} /* CVoiceDataObj::GetDataBlock */




/*****************************************************************************
* InitVoiceData *
*---------------*
*   Description:
*       Create pointers to voice data blocks from m_pVoiceData offsets.+++
*       
********************************************************************** MC ***/
HRESULT CVoiceDataObj::InitVoiceData()
{
    SPDBG_FUNC( "CVoiceDataObj::InitVoiceData" );
    char    *pRawData;
    ULONG    dataSize;
    HRESULT hr = S_OK;
    
    //------------------------------------------
    // Check data type and version
    //------------------------------------------
    if( (m_pVoiceData != NULL)  
        && (m_pVoiceData->Type == MS_DATA_TYPE) 
        && (m_pVoiceData->Version == HEADER_VERSION) )
    {
        //-------------------------------
        // Get ptr to PHONs
        //-------------------------------
        hr = GetDataBlock( MSVD_PHONE, &pRawData, &dataSize );
        m_pd = (PHON_DICT*)pRawData;
    
        //-------------------------------
        // Get ptr to TREE
        //-------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_TREEIMAGE, &pRawData, &dataSize );
            m_pForest = (TRIPHONE_TREE*)pRawData;
        }
    
        //-------------------------------
        // Get ptr to SENONE
        //-------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_SENONE, &pRawData, &dataSize );
            m_SenoneBlock = (long*)pRawData;
        }
        //-------------------------------
        // Get ptr to ALLOID
        //-------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_ALLOID, &pRawData, &dataSize );
            m_AlloToUnitTbl = (short*)pRawData;
            m_NumOfAllos = dataSize / 8;
        }
    
        if( SUCCEEDED(hr) )
        {
            m_First_Context_Phone = m_pd->numCiPhones;
            m_Sil_Index = PhonToID( m_pd, "SIL" );
        }
        //-----------------------------------------------------
        // Init voice data INVENTORY parameters
        //-----------------------------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_INVENTORY, &pRawData, &dataSize );
            if( SUCCEEDED(hr) )
            {
                m_pInv = (INVENTORY*)pRawData;
                m_CompressionType = m_pVoiceDef->CompressionType;
                //---------------------------------------------
                // Convert REL to ABS
                //---------------------------------------------
                m_pUnit      = (long*)((char*)m_pInv + m_pInv->UnitsOffset);
                m_pTrig      = (float*)((char*)m_pInv + m_pInv->TrigOffset);
                m_pWindow    = (float*)((char*)m_pInv + m_pInv->WindowOffset);
                m_pGauss     = (float*)((char*)m_pInv + m_pInv->pGaussOffset);
                m_SampleRate = (float)m_pInv->SampleRate;
                m_FFTSize    = m_pInv->FFTSize;
                m_cOrder     = m_pInv->cOrder;
                if ((m_FFTSize > MAX_FFTSIZE) || (m_cOrder > MAX_LPCORDER))
                {
                    hr = E_INVALIDARG;
                }
                m_GaussID    = 0;
                m_NumOfUnits = m_pInv->cNumUnits;
           }    
        }
    }
    else
    {
        //-------------------------
        // Not a voice file!
        //-------------------------
        hr = E_FAIL;
    }

    return hr;
} /* CVoiceDataObj::InitVoiceData */





/*****************************************************************************
* CVoiceDataObj::DecompressUnit *
*-------------------------------*
*   Description:
*  Decompress acoustic unit.+++
* 
*   INPUT:
*       UnitID - unit number (1 - 3333 typ)
* 
*   OUTPUT:
*       Fills pSynth if success
*       
********************************************************************** MC ***/
HRESULT CVoiceDataObj::DecompressUnit( ULONG UnitID, MSUNITDATA* pSynth )
{
    SPDBG_FUNC( "CVoiceDataObj::DecompressUnit" );
    long            i, j, k, cNumEpochs, cBytes, cOrder = 0, VectDim;
    long            frameSize, cNumBins, startBin;
    char            *pCurStor;
    unsigned char   index;
    float           pLSP[MAX_LPCORDER], pFFT[MAX_FFTSIZE], pRes[MAX_FFTSIZE], Gain;
    float           *pCurLSP, *pCurLPC, *pMean, *pCurRes;
    HRESULT         hr = S_OK;
    
    
    memset( pSynth, 0, sizeof(MSUNITDATA) );
    //-----------------------------------------
    // Pointer to unit data from inventory
    //-----------------------------------------
    pCurStor = (char*)((char*)m_pInv + m_pUnit[UnitID] );     // Rel to abs

    //---------------------------------
    // Get epoch count - 'cNumEpochs'
    //---------------------------------
    cBytes = sizeof(long);
    memcpy( &cNumEpochs, pCurStor, cBytes );
    pSynth->cNumEpochs = cNumEpochs;
    pCurStor += cBytes;

    //---------------------------------
    // Get epoch lengths - 'pEpoch'
    //---------------------------------
    pSynth->pEpoch = new float[cNumEpochs];
    if( pSynth->pEpoch == NULL )
    {
        hr = E_OUTOFMEMORY;
    }

    if( SUCCEEDED(hr) )
    {
        cBytes = DecompressEpoch( (signed char *) pCurStor, cNumEpochs, pSynth->pEpoch );
        pCurStor += cBytes;

        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        //
        // Uncompress LPC coefficients...
        //
        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        cOrder            = m_pInv->cOrder;
        pSynth->cOrder    = cOrder;
        pSynth->pLPC      = new float[cNumEpochs * (1 + cOrder)];
        if( pSynth->pLPC == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if( SUCCEEDED(hr) )
    {
        pCurLPC = pSynth->pLPC;
        //---------------------------------
        // ... for each epoch
        //---------------------------------
        for( i = 0; i < cNumEpochs; i++, pCurLPC += (1 + cOrder) )
        {
            //-------------------------------------
            // Decode quantized LSP's...
            //-------------------------------------
            pCurLSP = pLSP;
            for( k = 0; k < m_pInv->cNumLPCBooks; k++ )
            {
                VectDim = m_pInv->LPCBook[k].cCodeDim;
                memcpy( &index, pCurStor, sizeof(char));
                pCurStor += sizeof(char);
                pMean = ((float*)((char*)m_pInv + m_pInv->LPCBook[k].pData)) + (index * VectDim);
                for( j = 0; j < VectDim; j++ )
                    pCurLSP[j] = pMean[j];
                pCurLSP += VectDim;
            }
            //--------------------------------------------------
            // ...then convert to predictor coefficients
            // (LSP's quantize better than PC's)
            //--------------------------------------------------
            LSPtoPC( pLSP, pCurLPC, cOrder, i );
        }


        //---------------------------------------
        // Get pointer to residual gains
        //---------------------------------------
        cBytes          = cNumEpochs * sizeof(float);
        pSynth->pGain = (float*) pCurStor;
        pCurStor += cBytes;


        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        //
        // Uncompress residual waveform
        //
        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        //--------------------------------------------
        // First, figure out the buffer length...
        //--------------------------------------------
        pSynth->cNumSamples = 0;
        for( j = 0; j < cNumEpochs; j++ )
        {
            pSynth->cNumSamples += (long) ABS(pSynth->pEpoch[j]);
        }
        //--------------------------------------------
        // ...get buffer memory...
        //--------------------------------------------
        pSynth->pRes = new float[pSynth->cNumSamples];
        if( pSynth->pRes == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if( SUCCEEDED(hr) )
    {
        //--------------------------------------------
        // ...and fill with uncompressed residual
        //--------------------------------------------
        pCurRes = pSynth->pRes;
        for( i = 0; i < (long)pSynth->cNumEpochs; i++ )
        {
            //-------------------------------------
            // Get epoch length
            //-------------------------------------
            frameSize = (long)(ABS(pSynth->pEpoch[i]));

            // restore whisper
            //if( (pSynth->pEpoch[i] > 0) && !(m_fModifiers & BACKEND_BITFLAG_WHISPER) )
            if( pSynth->pEpoch[i] > 0 )
            {
                //-----------------------------------------------
                // VOICED epoch
                //-----------------------------------------------
                if( (m_pInv->cNumDresBooks == 0) || (i == 0) || (pSynth->pEpoch[i - 1] < 0) )
                {
                    //--------------------------------------
                    // Do static quantization
                    //--------------------------------------
                    for( j = 0; j < m_pInv->FFTSize; j++ ) 
                    {
                        pFFT[j] = 0.0f;
                    }
                    startBin = 1;
                    for( k = 0; k < m_pInv->cNumResBooks; k++ )
                    {
                        VectDim     = m_pInv->ResBook[k].cCodeDim;
                        cNumBins    = VectDim / 2;
                        memcpy( &index, pCurStor, sizeof(char) );
                        pCurStor    += sizeof(char);
                        //------------------------------------------
                        // Uncompress spectrum using 'pResBook'
                        //------------------------------------------
                        pMean = ((float*)((char*)m_pInv + m_pInv->ResBook[k].pData)) + (index * VectDim);
                        PutSpectralBand( pFFT, pMean, startBin, cNumBins, m_pInv->FFTSize );
                        startBin    += cNumBins;
                    }
                }
                else
                {
                    //--------------------------------------
                    // Do delta quantization
                    //--------------------------------------
                    startBin = 1;
                    for( k = 0; k < m_pInv->cNumDresBooks; k++ )
                    {
                        VectDim     = m_pInv->DresBook[k].cCodeDim;
                        cNumBins    = VectDim / 2;
                        memcpy( &index, pCurStor, sizeof(char));
                        pCurStor    += sizeof(char);
                        //------------------------------------------
                        // Uncompress spectrum using 'pDresBook'
                        //------------------------------------------
                        pMean = ((float*)((char*)m_pInv + m_pInv->DresBook[k].pData)) + (index * VectDim);
                        AddSpectralBand( pFFT, pMean, startBin, cNumBins, m_pInv->FFTSize );
                        startBin    += cNumBins;
                    }
                }

                //--------------------------------------------------------
                // Convert quantized FFT back to time residual
                //--------------------------------------------------------
                memcpy( pRes, pFFT, m_pInv->FFTSize * sizeof(float) );          // preserve original for delta residual
                InverseFFT( pRes, m_pInv->FFTSize, m_pInv->FFTOrder, m_pTrig );
                GainDeNormalize( pRes, (long)m_pInv->FFTSize, ((UNALIGNED float*)pSynth->pGain)[i] );
                SetEpochLen( pCurRes, frameSize, pRes, m_pInv->FFTSize );
            }
            else
            {
                //-----------------------------------------------
                // UNVOICED epoch
                // NOTE: Assumes 'm_pGauss' is 1 sec
                //-----------------------------------------------
                Gain = 0.02f * ((UNALIGNED float*)pSynth->pGain)[i];
                if( m_GaussID + frameSize >= m_pInv->SampleRate)
                {
                    m_GaussID = 0;
                }
                //----------------------------------------------------------
                // Generate gaussian random noise for unvoiced sounds
                //----------------------------------------------------------
                for( j = 0; j < frameSize; j++ )
                {
                    pCurRes[j] = Gain * m_pGauss[j + m_GaussID];
                }
                m_GaussID += frameSize;
            }
            // restore whisper
            /*if( (pSynth->pEpoch[i] > 0) && m_fModifiers & BACKEND_BITFLAG_WHISPER)
            {
                pSynth->pEpoch[i] = - pSynth->pEpoch[i];
            }*/
            pCurRes += frameSize;
        }
    }
    

    if( FAILED(hr) )
    {
        //----------------------------------
        // Cleanup allocated memory
        //----------------------------------
        if( pSynth->pEpoch )
        {
            delete pSynth->pEpoch;
            pSynth->pEpoch = NULL;
        }
        if( pSynth->pRes )
        {
            delete pSynth->pRes;
            pSynth->pRes = NULL;
        }
        if( pSynth->pLPC )
        {
            delete pSynth->pLPC;
            pSynth->pLPC = NULL;
        }
    }

    return hr;
} /* CVoiceDataObj::DecompressUnit */





/*****************************************************************************
* CVoiceDataObj::DecompressUnit *
*-------------------------------*
*   Description:
*  Decompress acoustic unit. +++
* 
*   INPUT:
*       UnitID - unit number (1 - 3333 typ)
* 
*   OUTPUT:
*       Fills pSynth if success
*       
********************************************************************** MC ***/
HRESULT CVoiceDataObj::GetUnitDur( ULONG UnitID, float* pDur )
{
    SPDBG_FUNC( "CVoiceDataObj::GetUnitDur" );
    char        *pCurStor;
    float       *pEpoch = NULL;
    long        cBytes, cNumEpochs, i;
    float       totalDur;
    HRESULT     hr = S_OK;
   
    
    totalDur = 0;

    if( UnitID > m_NumOfUnits )
    {
        //--------------------------
        // ID is out of range!
        //--------------------------
        hr = E_INVALIDARG;
    }

    if( SUCCEEDED(hr) )
    {
        //-----------------------------------------
        // Pointer to unit data from inventory
        //-----------------------------------------
        pCurStor = (char*)((char*)m_pInv + m_pUnit[UnitID] );     // Rel to abs

        //---------------------------------
        // Get epoch count - 'cNumEpochs'
        //---------------------------------
        cBytes = sizeof(long);
        memcpy( &cNumEpochs, pCurStor, cBytes );
        pCurStor += cBytes;

        //---------------------------------
        // Get epoch lengths - 'pEpoch'
        //---------------------------------
        pEpoch = new float[cNumEpochs];
        if( pEpoch == NULL )
        {
            hr = E_OUTOFMEMORY;
        }

        if( SUCCEEDED(hr) )
        {
            cBytes = DecompressEpoch( (signed char *) pCurStor, cNumEpochs, pEpoch );
            for( i = 0; i < cNumEpochs; i++)
            {
                totalDur += ABS(pEpoch[i]);
            }
        }
    }
    *pDur = totalDur / 22050;

    //----------------------------------
    // Cleanup allocated memory
    //----------------------------------
    if( pEpoch )
    {
        delete pEpoch;
    }
    return hr;
} /* CVoiceDataObj::GetUnitDur */




/*****************************************************************************
* CVoiceDataObj::DecompressEpoch *
*--------------------------------*
*   Description:
*   Decompress epoch len stream from RLE. Fills 'pEpoch' with lengths. 
*   Returns number of 'rgbyte' src bytes consumed.
*       
********************************************************************** MC ***/
long CVoiceDataObj::DecompressEpoch( signed char *rgbyte, long cNumEpochs, float *pEpoch )
{
    SPDBG_FUNC( "CVoiceDataObj::DecompressEpoch" );
    long    iDest, iSrc;
    
    for( iSrc = 0, iDest = 0; iDest < cNumEpochs; ++iDest, ++iSrc )
    {
        //--------------------------------------
        // Decode RLE for VOICED epochs
        //--------------------------------------
        if( rgbyte[iSrc] == 127 )
        {
            pEpoch[iDest] = 127.0f;
            while( rgbyte[iSrc] == 127 )
            {
                pEpoch[iDest] += rgbyte[++iSrc];
            }
        }
        //--------------------------------------
        // Decode RLE for UNVOICED  epochs
        //--------------------------------------
        else if( rgbyte[iSrc] == - 128 )
        {
            pEpoch[iDest] = - 128.0f;
            while( rgbyte[iSrc] == - 128 )
                pEpoch[iDest] += rgbyte[++iSrc];
        }
        //--------------------------------------
        // No compression here
        //--------------------------------------
        else
        {
            pEpoch[iDest] = rgbyte[iSrc];
        }
    }
    return iSrc;
} /* CVoiceDataObj::DecompressEpoch */



/*****************************************************************************
* LSPCompare *
*------------*
*   Description:
*   QSORT callback
*       
********************************************************************** MC ***/
static  int __cdecl LSPCompare( const void *a, const void *b )
{
    SPDBG_FUNC( "LSPCompare" );

    if( *((PFLOAT) a) > *((PFLOAT) b) ) 
    {
        return 1;
    }
    else if( *((PFLOAT) a) == *((PFLOAT) b) ) 
    {
        return 0;
    }
    else 
    {
        return -1;
    }
} /* LSPCompare */


/*****************************************************************************
* CVoiceDataObj::OrderLSP *
*-------------------------*
*   Description:
*   This routine reorders the LSP frequencies so that they are monotonic
*       
********************************************************************** MC ***/
long CVoiceDataObj::OrderLSP( PFLOAT pLSPFrame, INT cOrder )
{
    SPDBG_FUNC( "CVoiceDataObj::OrderLSP" );
    long i, retCode = true;
    
    for( i = 1; i < cOrder; i++ )
    {
        if( pLSPFrame[i - 1] > pLSPFrame[i] ) 
        {
            retCode = false;
        }
    }
    qsort( (void *) pLSPFrame, (size_t) cOrder, (size_t) sizeof (float), LSPCompare );
        
    return retCode;
} /* CVoiceDataObj::OrderLSP */


/*****************************************************************************
* CVoiceDataObj::LSPtoPC *
*------------------------*
*   Description:
*   Converts line spectral frequencies to LPC predictor coefficients.
*       
********************************************************************** MC ***/
void CVoiceDataObj::LSPtoPC( float *pLSP, float *pLPC, long cOrder, long /*frame*/ )
{
    SPDBG_FUNC( "CVoiceDataObj::LSPtoPC" );
    long        i, j, k, noh;
    double      freq[MAXNO], p[MAXNO / 2], q[MAXNO / 2];
    double      a[MAXNO / 2 + 1], a1[MAXNO / 2 + 1], a2[MAXNO / 2 + 1];
    double      b[MAXNO / 2 + 1], b1[MAXNO / 2 + 1], b2[MAXNO / 2 + 1];
    double      pi, xx, xf;
    
    //----------------------------------
    // Check for non-monotonic LSPs
    //----------------------------------
    for( i = 1; i < cOrder; i++ )
    {
        if( pLSP[i] <= pLSP[i - 1] )
        {
            //-----------------------------
            // Reorder LSPs
            //-----------------------------
            OrderLSP( pLSP, cOrder );
            break;
        }
    }
    
    //--------------------------
    // Initialization
    //--------------------------
    pi = KTWOPI;
    noh = cOrder / 2;
    for( j = 0; j < cOrder; j++ )
    {
        freq[j] = pLSP[j];
    }
    for( i = 0; i < noh + 1; i++ )
    {
        a[i]    = 0.0f;
        a1[i]   = 0.0f;
        a2[i]   = 0.0f;
        b[i]    = 0.0f;
        b1[i]   = 0.0f;
        b2[i]   = 0.0f;
    }
    
    //-------------------------------------
    // LSP filter parameters
    //-------------------------------------
    for( i = 0; i < noh; i++ )
    {
        p[i] = - 2.0 * cos( pi * freq[2 * i] );
        q[i] = - 2.0 * cos( pi * freq[2 * i + 1] );
    }
    
    //-------------------------------------
    // Impulse response of analysis filter
    //-------------------------------------
    xf = 0.0f;
    for( k = 0; k < cOrder + 1; k++ )
    {
        xx = 0.0f;
        if( k == 0 )
        {
            xx = 1.0f;
        }
        a[0] = xx + xf;
        b[0] = xx - xf;
        xf = xx;
        for( i = 0; i < noh; i++ )
        {
            a[i + 1]    = a[i] + p[i] * a1[i] + a2[i];
            b[i + 1]    = b[i] + q[i] * b1[i] + b2[i];
            a2[i]       = a1[i];
            a1[i]       = a[i];
            b2[i]       = b1[i];
            b1[i]       = b[i];
        }
        if( k != 0)
        {
            pLPC[k - 1] = (float) (- 0.5 * (a[noh] + b[noh]));
        }
    }
    
    //-------------------------------------------------------
    // Convert to predictor coefficient array configuration
    //-------------------------------------------------------
    for( i = cOrder - 1; i >= 0; i-- )
    {
        pLPC[i + 1] = - pLPC[i];
    }
    pLPC[0] = 1.0f;
} /* CVoiceDataObj::LSPtoPC */



/*****************************************************************************
* CVoiceDataObj::PutSpectralBand *
*--------------------------------*
*   Description:
*   This routine copies the frequency band specified by StartBin as
*   is initial FFT bin, and containing cNumBins.
*       
********************************************************************** MC ***/
void CVoiceDataObj::PutSpectralBand( float *pFFT, float *pBand, long StartBin, 
                                    long cNumBins, long FFTSize )
{
    SPDBG_FUNC( "CVoiceDataObj::PutSpectralBand" );
    long        j, k, VectDim;
    
    VectDim = 2 * cNumBins;
    for( j = 0, k = StartBin; j < cNumBins; j++, k++ )
    {
        pFFT[k] = pBand[j];
    }
    k = FFTSize - (StartBin - 1 + cNumBins);
    for( j = cNumBins; j < 2 * cNumBins; j++, k++ )
    {
        pFFT[k] = pBand[j];
    }
} /* CVoiceDataObj::PutSpectralBand */


/*****************************************************************************
* CVoiceDataObj::AddSpectralBand *
*--------------------------------*
*   Description:
*   This routine adds the frequency band specified by StartBin as
*   is initial FFT bin, and containing cNumBins, to the existing band.
*       
********************************************************************** MC ***/
void CVoiceDataObj::AddSpectralBand( float *pFFT, float *pBand, long StartBin, 
                                    long cNumBins, long FFTSize )
{
    SPDBG_FUNC( "CVoiceDataObj::AddSpectralBand" );
    long        j, k, VectDim;
    
    VectDim = 2 * cNumBins;
    for( j = 0, k = StartBin; j < cNumBins; j++, k++ )
    {
        pFFT[k] += pBand[j];
    }
    k = FFTSize - (StartBin - 1 + cNumBins);
    for( j = cNumBins; j < 2 * cNumBins; j++, k++ )
    {
        pFFT[k] += pBand[j];
    }
} /* CVoiceDataObj::AddSpectralBand */


/*****************************************************************************
* CVoiceDataObj::InverseFFT *
*---------------------------*
*   Description:
*   Return TRUE if consoants can be clustered.
*   This subroutine computes a split-radix IFFT for real data
*   It is a C version of the FORTRAN program in "Real-Valued
*   Fast Fourier Transform Algorithms" by H. Sorensen et al.
*   in Trans. on ASSP, June 1987, pp. 849-863. It uses half 
*   of the operations than its counterpart for complex data.
*                                   *
*   Length is n = 2^(fftOrder). Decimation in frequency. Result is 
*   in place. It uses table look-up for the trigonometric functions.
* 
*   Input order:                            *
*       (Re[0], Re[1], ... Re[n/2], Im[n/2 - 1]...Im[1])
*   Output order:
*       (x[0], x[1], ... x[n - 1])
*   The output transform exhibit hermitian symmetry (i.e. real
*   part of transform is even while imaginary part is odd).
*   Hence Im[0] = Im[n/2] = 0; and n memory locations suffice.
*       
********************************************************************** MC ***/
void CVoiceDataObj::InverseFFT( float *pDest, long fftSize, long fftOrder, float *sinePtr )
{
    SPDBG_FUNC( "CVoiceDataObj::InverseFFT" );
    long    n1, n2, n4, n8, i0, i1, i2, i3, i4, i5, i6, i7, i8;
    long    is, id, i, j, k, ie, ia, ia3;
    float   xt, t1, t2, t3, t4, t5, *cosPtr, r1, cc1, cc3, ss1, ss3;
    
    cosPtr = sinePtr + (fftSize / 2);
    
    //---------------------------------
    // L shaped butterflies
    //---------------------------------
    n2 = 2 * fftSize;
    ie = 1;
    for( k = 1; k < fftOrder; k++ ) 
    {
        is = 0;
        id = n2;
        n2 = n2 / 2;
        n4 = n2 / 4;
        n8 = n4 / 2;
        ie *= 2;
        while( is < fftSize - 1 ) 
        {
            for( i = is; i < fftSize; i += id ) 
            {
                i1 = i;
                i2 = i1 + n4;
                i3 = i2 + n4;
                i4 = i3 + n4;
                t1 = pDest[i1] - pDest[i3];
                pDest[i1] = pDest[i1] + pDest[i3];
                pDest[i2] = 2 * pDest[i2];
                pDest[i3] = t1 - 2 * pDest[i4];
                pDest[i4] = t1 + 2 * pDest[i4];
                if( n4 > 1 ) 
                {
                    i1 = i1 + n8;
                    i2 = i2 + n8;
                    i3 = i3 + n8;
                    i4 = i4 + n8;
                    t1 = K2 * (pDest[i2] - pDest[i1]);
                    t2 = K2 * (pDest[i4] + pDest[i3]);
                    pDest[i1] = pDest[i1] + pDest[i2];
                    pDest[i2] = pDest[i4] - pDest[i3];
                    pDest[i3] = - 2 * (t1 + t2);
                    pDest[i4] = 2 * (t1 - t2);
                }
            }
            is = 2 * id - n2;
            id = 4 * id;
        }
        ia = 0;
        for( j = 1; j < n8; j++ ) 
        {
            ia += ie;
            ia3 = 3 * ia;
            cc1 = cosPtr[ia];
            ss1 = sinePtr[ia];
            cc3 = cosPtr[ia3];
            ss3 = sinePtr[ia3];
            is = 0;
            id = 2 * n2;
            while( is < fftSize - 1 ) 
            {
                for( i = is; i < fftSize; i += id ) 
                {
                    i1 = i + j;
                    i2 = i1 + n4;
                    i3 = i2 + n4;
                    i4 = i3 + n4;
                    i5 = i + n4 - j;
                    i6 = i5 + n4;
                    i7 = i6 + n4;
                    i8 = i7 + n4;
                    t1 = pDest[i1] - pDest[i6];
                    pDest[i1] = pDest[i1] + pDest[i6];
                    t2 = pDest[i5] - pDest[i2];
                    pDest[i5] = pDest[i2] + pDest[i5];
                    t3 = pDest[i8] + pDest[i3];
                    pDest[i6] = pDest[i8] - pDest[i3];
                    t4 = pDest[i4] + pDest[i7];
                    pDest[i2] = pDest[i4] - pDest[i7];
                    t5 = t1 - t4;
                    t1 = t1 + t4;
                    t4 = t2 - t3;
                    t2 = t2 + t3;
                    pDest[i3] = t5 * cc1 + t4 * ss1;
                    pDest[i7] = - t4 * cc1 + t5 * ss1;
                    pDest[i4] = t1 * cc3 - t2 * ss3;
                    pDest[i8] = t2 * cc3 + t1 * ss3;
                }
                is = 2 * id - n2;
                id = 4 * id;
            }
        }
    }
    //---------------------------------
    // length two butterflies
    //---------------------------------
    is = 0;
    id = 4;
    while( is < fftSize - 1 ) 
    {
        for( i0 = is; i0 < fftSize; i0 += id ) 
        {
            i1 = i0 + 1;
            r1 = pDest[i0];
            pDest[i0] = r1 + pDest[i1];
            pDest[i1] = r1 - pDest[i1];
        }
        is = 2 * (id - 1);
        id = 4 * id;
    }
    //---------------------------------
    // digit reverse counter
    //---------------------------------
    j = 0;
    n1 = fftSize - 1;
    for( i = 0; i < n1; i++ ) 
    {
        if( i < j ) 
        {
            xt = pDest[j];
            pDest[j] = pDest[i];
            pDest[i] = xt;
        }
        k = fftSize / 2;
        while( k <= j )
        {
            j -= k;
            k /= 2;
        }
        j += k;
    }
    for( i = 0; i < fftSize; i++ )
    {
        pDest[i] /= fftSize;
    }
} /* CVoiceDataObj::InverseFFT */


/*****************************************************************************
* CVoiceDataObj::SetEpochLen *
*----------------------*
*   Description:
*   Copy residual epoch to 'OutSize' length from 'pInRes' to 'pOutRes'
*       
********************************************************************** MC ***/
void CVoiceDataObj::SetEpochLen( float *pOutRes, long OutSize, float *pInRes, 
                                long InSize )
{
    SPDBG_FUNC( "CVoiceDataObj::AddSpectralBand" );
    long        j, curFrame;
    
    curFrame = MIN(InSize / 2, OutSize);
    
    //-------------------------------
    // Copy SRC to DEST
    //-------------------------------
    for( j = 0; j < curFrame; j++ )
        pOutRes[j] = pInRes[j];
    //-------------------------------
    // Pad DEST if longer
    //-------------------------------
    for( j = curFrame; j < OutSize; j++ )
        pOutRes[j] = 0.0f;
    //-------------------------------
    // Mix DEST if shorter
    //-------------------------------
    for( j = OutSize - curFrame; j < OutSize; j++ )
        pOutRes[j] += pInRes[InSize - OutSize + j];
} /* CVoiceDataObj::SetEpochLen */


/*****************************************************************************
* CVoiceDataObj::GainDeNormalize *
*--------------------------------*
*   Description:
*   Scale residual to given gain.
*       
********************************************************************** MC ***/
void CVoiceDataObj::GainDeNormalize( float *pRes, long FFTSize, float Gain )
{
    SPDBG_FUNC( "CVoiceDataObj::GainDeNormalize" );
    long        j;
    
    for( j = 0; j < FFTSize; j++ )
    {
        pRes[j] *= Gain;
    }
} /* CVoiceDataObj::GainDeNormalize */


/*****************************************************************************
* CVoiceDataObj::PhonHashLookup *
*-------------------------------*
*   Description:
*   Lookup 'sym' in 'ht' and place its associated value in
*   *val. If sym is not found place its key in *val.
*    RETURN
*   Return  0 indicating we found the 'sym' in the table.
*   Return -1 'sym' is not in ht.
*       
********************************************************************** MC ***/
long CVoiceDataObj::PhonHashLookup(    
                            PHON_DICT   *pPD,   // the hash table
                            char       *sym,    // The symbol to look up
                            long       *val )   // Phon ID
{
    SPDBG_FUNC( "CVoiceDataObj::PhonHashLookup" );
    char            *cp;
    unsigned long   key;
    long            i;
    HASH_TABLE      *ht;
    char            *pStr;
    HASH_ENTRY      *pHE;
    
    ht      = &pPD->phonHash;
    key     = 0;
    i       = -1;
    cp      = sym;
    pHE     = (HASH_ENTRY*)((char*)pPD + ht->entryArrayOffs);        // Offset to Abs address 
    do 
    {
        key += *cp++ << (0xF & i--);
    } 
    while( *cp );
    
    while( true )
    {
        key %= ht->size;
    
        if( pHE[key].obj == 0 ) 
        {
            //------------------------------
            // Not in hash table!
            //------------------------------
            *val = (long) key;
            return -1;
        }
    
        //-------------------------------
        // Offset to Abs address
        //-------------------------------
        pStr = (char*)((char*)pPD + pHE[key].obj);
        if( strcmp(pStr, sym) == 0 ) 
        {
            *val = pHE[key].val;
            return 0;
        }
        key++;
    }
} /* CVoiceDataObj::PhonHashLookup */


/*****************************************************************************
* CVoiceDataObj::PhonToID *
*-------------------------*
*   Description:
*   Return ID from phoneme string.
*       
********************************************************************** MC ***/
long CVoiceDataObj::PhonToID( PHON_DICT *pd, char *phone_str )
{
    SPDBG_FUNC( "CVoiceDataObj::PhonToID" );
    long    phon_id;
    
    if( PhonHashLookup( pd, phone_str, &phon_id ) )
    {
        phon_id = NO_PHON;
    }
    
    return phon_id;
} /* CVoiceDataObj::PhonToID */


/*****************************************************************************
* CVoiceDataObj::PhonFromID *
*---------------------------*
*   Description:
*   Return string from phoneme ID
*       
********************************************************************** MC ***/
char *CVoiceDataObj::PhonFromID( PHON_DICT *pd, long phone_id )
{
    SPDBG_FUNC( "CVoiceDataObj::PhonFromID" );
    char    *strPtr;
    long    *pOffs;
    
    pOffs = (long*)((char*)pd + pd->phones_list);
    strPtr = (char*) ((char*)pd + pOffs[phone_id]);
    return strPtr;
} /* CVoiceDataObj::PhonFromID */


#define CNODE_ISA_LEAF(n)   ((n)->yes < 0)

#define BADTREE_ERROR   (-1)
#define PARAM_ERROR (-2)
#define END_OF_PROD  65535


#define WB_BEGIN    1
#define WB_END      2
#define WB_SINGLE   4
#define WB_WWT      8

#define POS_TYPE    4

#define GET_BIT(p,feat,i,b)                             \
{                                                   \
    (i) = ( (p)+POS_TYPE+(feat)->nstateq ) / 32;        \
    (b) = 1 << ( ((p)+POS_TYPE+(feat)->nstateq ) % 32); \
}

#define GET_RBIT(p,feat,i,b)            \
{                                   \
    GET_BIT(p,feat,i,b);                \
    (i) += (feat)->nint32perq;          \
} 

#define GET_CBIT(p,feat,i,b)            \
{                                   \
    GET_BIT(p,feat,i,b);                \
    (i) += 2 * (feat)->nint32perq;      \
}

/*****************************************************************************
* AnswerQ *
*---------*
*   Description:
*   Tree node test.
*       
********************************************************************** MC ***/
static  _inline long AnswerQ( unsigned short *prod, long *uniq_prod, 
                              long li, long bitpos, long ri, long rbitpos, 
                              long pos, long nint32perProd)
{
    UNALIGNED long *p;
    
    for( ; *prod != END_OF_PROD; prod++ ) 
    {
        p = &uniq_prod[(*prod) * nint32perProd];
        if( ((p[0] & pos) == pos) && (p[li] & bitpos) && (p[ri] & rbitpos) )
        {
            return true;
        }
    }
    return false;
} /* AnswerQ */


/*****************************************************************************
* CVoiceDataObj::GetTriphoneID *
*------------------------------*
*   Description:
*   Retrieve triphone ID from phoneme context.+++
*   Store result into 'pResult'
*       
********************************************************************** MC ***/
HRESULT CVoiceDataObj::GetTriphoneID( TRIPHONE_TREE *forest, 
                        long        phon,           // target phon              
                        long        leftPhon,       // left context
                        long        rightPhon,      // right context
                        long        pos,            // word position ("b", "e" or "s"
                        PHON_DICT   *pd,
                        ULONG       *pResult)
{
    SPDBG_FUNC( "CVoiceDataObj::GetTriphoneID" );
    C_NODE          *cnode, *croot;
    TREE_ELEM       *tree = NULL;
    long            *uniq_prod;
    char            *ll, *rr;
    long            li, bitpos, ri, rbitpos, nint32perProd, c;
    unsigned short  *prodspace;
    FEATURE         *feat;
    long            *pOffs;
    HRESULT         hr = S_OK;
    long            triphoneID = 0;
    
    if( (phon       < 0)    ||  (phon       >= pd->numCiPhones) || 
        (leftPhon   < 0)    ||  (leftPhon   >= pd->numCiPhones) || 
        (rightPhon  < 0)    ||  (rightPhon  >= pd->numCiPhones) )
    {
        //--------------------------------
        // Phon out of range!
        //--------------------------------
        hr = E_INVALIDARG;
    }
    
    if( SUCCEEDED(hr) )
    {
        c = phon;
        tree = &forest->tree[c];
        if( tree->nnodes == 0 )
        {
            //--------------------------------
            // No CD triphones in tree!
            //--------------------------------
            hr = E_INVALIDARG;
        }
    }

    if( SUCCEEDED(hr) )
    {
        if( pos == 'b' || pos == 'B' ) 
        {
            pos = WB_BEGIN;
        }
        else if( pos == 'e' || pos == 'E' ) 
        {
            pos = WB_END;
        }
        else if( pos == 's' || pos == 'S' ) 
        {
            pos = WB_SINGLE;
        }
        else if( pos == '\0' ) 
        {
            pos = WB_WWT;
        }
        else 
        {
            //--------------------------------
            // Unknown word position
            //--------------------------------
            hr = E_INVALIDARG;
        }
    }
    
    if( SUCCEEDED(hr) )
    {
        pOffs = (long*)((char*)pd + pd->phones_list);
        ll = (char*) ((char*)pd + pOffs[leftPhon]);
    
        if( ll[0] == '+' || _strnicmp(ll, "SIL", 3) == 0 )
        {
            leftPhon = forest->silPhoneId;
        }
    
        rr = (char*) ((char*)pd + pOffs[rightPhon]);
        if( rr[0] == '+' || _strnicmp(rr, "SIL", 3) == 0 )      // includes SIL
        {
            rightPhon = forest->silPhoneId;
        }
        else if( forest->nonSilCxt >= 0 && (pos == WB_END || pos == WB_SINGLE) )
        {
            rightPhon = forest->nonSilCxt;
        }
    
        feat = &forest->feat;
        GET_BIT(leftPhon,feat,li,bitpos);
        GET_RBIT(rightPhon,feat,ri,rbitpos);
    
        uniq_prod = (long*)(forest->uniq_prod_Offset + (char*)forest);       // Offset to ABS
        croot = cnode = (C_NODE*)(tree->nodes + (char*)forest);              // Offset to ABS
        nint32perProd = forest->nint32perProd;
    
        while( ! CNODE_ISA_LEAF(cnode) ) 
        {
            prodspace = (unsigned short*)((char*)forest + cnode->prod);      // Offset to ABS
            if( AnswerQ (prodspace, uniq_prod, li, bitpos, ri, rbitpos, pos, nint32perProd) ) 
            {
                cnode = &croot[cnode->yes];
            }
            else 
            {
                cnode = &croot[cnode->no];
            }
        }
        //-----------------------------
        // Return successful result
        //-----------------------------
        triphoneID = (ULONG) cnode->no;
    }
    
    *pResult = triphoneID;
    return hr;
} /* CVoiceDataObj::GetTriphoneID */



/*****************************************************************************
* FIR_Filter *
*------------*
*   Description:
*   FIR filter. For an input x[n] it does an FIR filter with
*   output y[n]. Result is in place. pHistory contains the last
*   cNumTaps values.
*
*   y[n] = pFilter[0] * x[n] + pFilter[1] * x[n - 1]
*   + ... + pFilter[cNumTaps - 1] * x[n - cNumTaps - 1]
*       
 ********************************************************************** MC ***/
void CVoiceDataObj::FIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps )
{
    SPDBG_FUNC( "CVoiceDataObj::FIR_Filter" );
    long     i, j;
    float   sum;
    
    for( i = 0; i < cNumSamples; i++ )
    {
        pHistory[0] = pVector[i];
        sum = pHistory[0] * pFilter[0];
        for( j = cNumTaps - 1; j > 0; j-- )
        {
            sum += pHistory[j] * pFilter[j];
            pHistory[j] = pHistory[j - 1];
        }
        pVector[i] = sum;
    }
} /* CVoiceDataObj::FIR_Filter */





/*****************************************************************************
* IIR_Filter *
*------------*
*   Description:
*   IIR filter. For an input x[n] it does an IIR filter with
*   output y[n]. Result is in place. pHistory contains the last
*   cNumTaps values.
*
*   y[n] = pFilter[0] * x[n] + pFilter[1] * y[n - 1]
*   + ... + pFilter[cNumTaps - 1] * y[n - cNumTaps - 1]
*       
********************************************************************** MC ***/
void CVoiceDataObj::IIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps )
{
    SPDBG_FUNC( "CVoiceDataObj::IIR_Filter" );
    long     i, j;
    float   sum;
    
    for( i = 0; i < cNumSamples; i++ )
    {
        sum = pVector[i] * pFilter[0];
        for( j = cNumTaps - 1; j > 0; j-- )
        {
            pHistory[j] = pHistory[j - 1];
            sum += pHistory[j] * pFilter[j];
        }
        pVector[i] = sum;
        pHistory[0] = sum;
    }
} /* CVoiceDataObj::IIR_Filter */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\cdonts\cdonts.c ===
#include "windows.h"

STDAPI
DllCanUnloadNow (
    void
    )

{
    return 0;
}

STDAPI
DllGetClassObject (
    IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )

{
    return 0;
}

STDAPI
DllRegisterServer (
    void
    )

{
    return 0;
}

STDAPI
DllUnregisterServer (
    void
    )

{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\regvoices\regvoices.cpp ===
#include <windows.h>
#include <atlbase.h>
#include "sapi.h"
#include "sphelper.h"
#include "spddkhlp.h"
#include "spttseng.h"
#include "spttseng_i.c"
#include "spcommon.h"
#include "spcommon_i.c"
#include <spunicode.h>

#include "ms1033ltsmap.h" 

// This code does not ship

// This code creates the registry entries for the TTS voices. The
// datafiles registered here are the ones checked in the slm source tree. This is not
// done using a reg file because we need to compute the absolute path of the datafiles
// which can be different on different machines because of different root slm directories.
// BUGBUG: Check out the ATL UpdateRegistryFromResource et al. and see whether you could
// use them instead, a la RegSR.  That seems much easier.

#ifndef _WIN32_WCE
#define DIRS_TO_GO_BACK_TTSENG     4        // Back 4 levels and up 1 to 'Voices" directory
#define DIRS_TO_GO_BACK_LEX        6        // Back 6 levels to Lex Data directory
#else
#define DIRS_TO_GO_BACK_TTSENG     1        // 
#define DIRS_TO_GO_BACK_LEX        1        // 
#endif

CSpUnicodeSupport g_Unicode;

/*****************************************************************************
* CreateLexSubKey  *
*------------------*
*   Description:
*   Each TTS voice gets installed under one registry sub-key.
*   This function installs the single voice from the passed params.
*       
********************************************************************** MC ***/
HRESULT CreateLexSubKey(
    ISpObjectToken * pToken,
    const WCHAR * pszSubKeyName,
    const CLSID * pclsid,
    const WCHAR * pszFilePath, 
    const WCHAR * pszLexName,
    const WCHAR * pszPhoneMap)
{
    HRESULT hr = S_OK;

    //---------------------------------------
    // Create the lex sub-key (Lex or LTS)
    //---------------------------------------
    CComPtr<ISpObjectToken> cpSubToken;
    hr = SpGetSubTokenFromToken(pToken, pszSubKeyName, &cpSubToken, TRUE);

    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                cpSubToken, 
                pclsid, 
                NULL,
                0,
                NULL,
                NULL);
    }
    
    WCHAR szLexDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Lex DATA file location
        //--------------------------------
        wcscpy(szLexDataPath, pszFilePath);
        wcscat(szLexDataPath, pszLexName);

        hr = cpSubToken->SetStringValue(L"DataFile", szLexDataPath);
    }

    if (SUCCEEDED(hr) && pszPhoneMap)
    {
        CComPtr<ISpObjectToken> cpPhoneToken;

        if (SUCCEEDED(hr))
            hr = SpGetSubTokenFromToken(cpSubToken, L"PhoneConverter", &cpPhoneToken, TRUE);

        if (SUCCEEDED(hr))
            hr = SpSetCommonTokenData(cpPhoneToken, &CLSID_SpPhoneConverter, NULL, 0, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = cpPhoneToken->SetStringValue(L"PhoneMap", pszPhoneMap);
    }

    return hr;
}


/*****************************************************************************
* CreateVoiceSubKey  *
*--------------------*
*   Description:
*   Each TTS voice gets installed under one registry sub-key.
*   This function installs the single voice from the passed params.
*       
********************************************************************** MC ***/
HRESULT CreateVoiceSubKey(
    const WCHAR * pszSubKeyName, 
    const WCHAR  * pszDescription,
    BOOL fVendorDefault, 
    const WCHAR * pszGender,
    const WCHAR * pszAge,
    const WCHAR * pszVoicePath, 
    const WCHAR * pszVoiceName,
    const WCHAR * pszLexPath)
{
    HRESULT hr;

    CComPtr<ISpObjectToken> cpToken;
    CComPtr<ISpDataKey> cpDataKeyAttribs;
    hr = SpCreateNewTokenEx(
            SPCAT_VOICES, 
            pszSubKeyName, 
            &CLSID_MSVoiceData, 
            pszDescription,
            0x409,
            pszDescription,
            &cpToken,
            &cpDataKeyAttribs);

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Name", pszDescription);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Gender", pszGender);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Age", pszAge);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Vendor", L"Microsoft");
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Language", L"409");
    }

    if (SUCCEEDED(hr) && fVendorDefault)
    {
        hr = cpDataKeyAttribs->SetStringValue(L"VendorPreferred", L"");
    }
    
    WCHAR szVoiceDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Voice DATA file location
        //--------------------------------
        wcscpy(szVoiceDataPath, pszVoicePath);
        wcscat(szVoiceDataPath, pszVoiceName);
        wcscat(szVoiceDataPath, L".SPD");

        hr = cpToken->SetStringValue(L"VoiceData", szVoiceDataPath);
    }
    
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Voice DEF file location
        //--------------------------------
        wcscpy(szVoiceDataPath, pszVoicePath);
        wcscat(szVoiceDataPath, pszVoiceName);
        wcscat(szVoiceDataPath, L".SDF");

        hr = cpToken->SetStringValue(L"VoiceDef", szVoiceDataPath);
    }

    //------------------------------------------------
    // Register TTS lexicons
    //------------------------------------------------
    if (SUCCEEDED(hr))
    {
        hr = CreateLexSubKey(cpToken, L"Lex", &CLSID_SpCompressedLexicon, pszLexPath, L"LTTS1033.LXA", NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = CreateLexSubKey(cpToken, L"LTS", &CLSID_SpLTSLexicon, pszLexPath, L"r1033tts.lxa", pszms1033ltsmap);
    }

    return hr;
}

/*****************************************************************************
* main  *
*-------*
*   Description:
*    Locate the abs path to the Mary, Mike and Sam voices
*    and register them in the system registry.
*       
********************************************************************** MC ***/
int _tmain()
{
    HRESULT hr = S_OK;

    CoInitialize(NULL);

    //----------------------------------------
    // Get the exe's location...
    //----------------------------------------
    WCHAR szVoiceDataPath[MAX_PATH];
    if (!g_Unicode.GetModuleFileName(NULL, szVoiceDataPath, MAX_PATH))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    WCHAR szLexDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        wcscpy(szLexDataPath, szVoiceDataPath);
    }

    //----------------------------------------
    // ...and derive abs path to VOICE data
    //----------------------------------------
    if (SUCCEEDED(hr))
    {
        // modulename is "<Speech>\TTS\msttsdrv\RegVoices\obj\i386\RegVoices.exe"
        // Data is at "<Speech>\TTS\msttsdrv\voices\"
        WCHAR * psz;
        psz = szVoiceDataPath;
        
        for (int i = 0; i < DIRS_TO_GO_BACK_TTSENG; i++)
        {
            psz = wcsrchr(psz, '\\');
            if (!psz)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                *psz = 0;
                psz = szVoiceDataPath;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
#ifndef _WIN32_WCE
        wcscat(szVoiceDataPath, L"\\Voices\\");
#else
        wcscat(szVoiceDataPath, L"\\");
#endif
    }

    //----------------------------------------
    // Derive abs path to LEX data
    //----------------------------------------
    if (SUCCEEDED(hr))
    {
        // modulename is "<sapi5>\Src\TTS\msttsdrv\voices\RegVoices\debug_x86\RegVoices.exe"
        // Data is at "<sapi5>\Src\lexicon\data\"
        WCHAR * psz = szLexDataPath;
        for (int i = 0; i < DIRS_TO_GO_BACK_LEX; i++)
        {
            psz = wcsrchr(psz, '\\');
            if (!psz)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                *psz = 0;
                psz = szLexDataPath;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
#ifndef _WIN32_WCE
        wcscat(szLexDataPath, L"\\src\\lexicon\\data\\");
#else
        wcscat(szLexDataPath, L"\\");
#endif
    }

    //------------------------------------------------
    // ...then register the three Microsoft voices..
    //------------------------------------------------
    if (SUCCEEDED(hr))
    {
        hr = CreateVoiceSubKey(L"MSMary", 
                               L"Microsoft Mary", 
                               TRUE,
                               L"Female",
                               L"Adult",
                               szVoiceDataPath,
                               L"Mary",
                               szLexDataPath);
    }
#ifndef _WIN32_WCE
    if (SUCCEEDED(hr))
    {
        hr = CreateVoiceSubKey(L"MSMike", 
                               L"Microsoft Mike", 
                               FALSE,
                               L"Male", 
                               L"Adult",
                               szVoiceDataPath, 
                               L"Mike",
                               szLexDataPath);
    }
    if (SUCCEEDED(hr))
    {
        hr = CreateVoiceSubKey(L"MSSam", 
                               L"Microsoft Sam", 
                               FALSE,
                               L"Male", 
                               L"Adult",
                               szVoiceDataPath, 
                               L"Sam",
                               szLexDataPath);
    }
#endif  //_WIN32_WCE

    CoUninitialize();

    if (FAILED(hr))
        return -1;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\tools\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__44183539_C02F_475B_9A56_7260EDD0A7F4__INCLUDED_)
#define AFX_STDAFX_H__44183539_C02F_475B_9A56_7260EDD0A7F4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <string.h>
#include <atlbase.h>
#include <sphelper.h>
#include <spcollec.h>
#include <sapi.h>
#include <commonlx.h>
#include <spttseng.h>

struct PRONUNIT
{
    ULONG           phon_Len;
    WCHAR           phon_Str[SP_MAX_PRON_LENGTH];		// Allo string
    ULONG			POScount;
    ENGPARTOFSPEECH	POScode[POS_MAX];
};


struct PRONRECORD
{
    WCHAR           orthStr[SP_MAX_WORD_LENGTH];      // Orth text
    WCHAR           lemmaStr[SP_MAX_WORD_LENGTH];     // Root word
    ULONG		    pronType;                   // Pronunciation is lex or LTS
    PRONUNIT        pronArray[2];
    ENGPARTOFSPEECH	POSchoice;
    ENGPARTOFSPEECH XMLPartOfSpeech;
    bool			hasAlt;
    ULONG			altChoice;
};

//--- This struct is just used as a helper to initialize the PRONRECORD to all zeroes
struct DebugPronRecord : PRONRECORD
{
public:
    DebugPronRecord() { ZeroMemory( (void*) this, sizeof( DebugPronRecord ) ); }
    operator =( PRONRECORD InRecord )
    {
        memcpy( this, &InRecord, sizeof( PRONRECORD ) );
    }
};

//--- This struct is used to replace the SPVCONTEXT struct for outputting to the debug streams -
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugContext
{
    WCHAR Category[32];
    WCHAR Before[32];
    WCHAR After[32];
public:
    DebugContext() { ZeroMemory( (void*) this, sizeof( DebugContext ) ); }
    operator =( SPVCONTEXT InContext )
    {
        if ( InContext.pCategory )
        {
            wcsncpy( Category, InContext.pCategory, 
                     wcslen(InContext.pCategory) > 31 ? 31 : wcslen(InContext.pCategory) );
        }
        if ( InContext.pBefore )
        {
            wcsncpy( Before, InContext.pBefore,
                     wcslen(InContext.pBefore) > 31 ? 31 : wcslen(InContext.pBefore) );
        }
        if ( InContext.pAfter )
        {
            wcsncpy( After, InContext.pAfter,
                     wcslen(InContext.pAfter) > 31 ? 31 : wcslen(InContext.pAfter) );
        }
    }
};

//--- This struct is used to replace the SPVSTATE struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugState
{
    SPVACTIONS      eAction;
    LANGID          LangID;
    WORD            wReserved;
    long            EmphAdj;
    long            RateAdj;
    ULONG           Volume;
    SPVPITCH        PitchAdj;
    ULONG           SilenceMSecs;
    SPPHONEID       PhoneIds[64];
    ENGPARTOFSPEECH  ePartOfSpeech;
    DebugContext    Context;
public:
    DebugState() { ZeroMemory( (void*) this, sizeof( DebugState ) ); }
    operator =( SPVSTATE InState )
    {
        eAction         = InState.eAction;
        LangID          = InState.LangID;
        wReserved       = InState.wReserved;
        EmphAdj         = InState.EmphAdj;
        RateAdj         = InState.RateAdj;
        Volume          = InState.Volume;
        PitchAdj        = InState.PitchAdj;
        SilenceMSecs    = InState.SilenceMSecs;
        ePartOfSpeech   = (ENGPARTOFSPEECH) InState.ePartOfSpeech;
        Context         = InState.Context;
        if ( InState.pPhoneIds )
        {
            wcsncpy( PhoneIds, InState.pPhoneIds,
                     wcslen(InState.pPhoneIds) > 63 ? 63 : wcslen(InState.pPhoneIds) );
        }
    }
};

//--- This struct is used to replace the TTSWord struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugWord
{
    DebugState      XmlState;
    WCHAR           WordText[32];
    ULONG           ulWordLen;
    WCHAR           LemmaText[32];
    ULONG           ulLemmaLen;
    SPPHONEID       WordPron[64];
    ENGPARTOFSPEECH  eWordPartOfSpeech;
public:
    DebugWord() { ZeroMemory( (void*) this, sizeof( DebugWord ) ); }
    operator =( TTSWord InWord )
    {
        XmlState = *(InWord.pXmlState);
        if ( InWord.pWordText )
        {
            wcsncpy( WordText, InWord.pWordText, InWord.ulWordLen > 31 ? 31 : InWord.ulWordLen );
        }
        ulWordLen = InWord.ulWordLen;
        if ( InWord.pLemma )
        {
            wcsncpy( LemmaText, InWord.pLemma, InWord.ulLemmaLen > 31 ? 31 : InWord.ulLemmaLen );
        }
        ulLemmaLen = InWord.ulLemmaLen;
        if ( InWord.pWordPron )
        {
            wcsncpy( WordPron, InWord.pWordPron,
                wcslen( InWord.pWordPron ) > 63 ? 63 : wcslen( InWord.pWordPron ) );
        }
        eWordPartOfSpeech = InWord.eWordPartOfSpeech;
    }
};

struct DebugItemInfo
{
    TTSItemType Type;
public:
    DebugItemInfo() { ZeroMemory( (void*) this, sizeof( DebugItemInfo ) ); }
    operator =( TTSItemInfo InItemInfo )
    {
        Type = InItemInfo.Type;
    }
};

//--- This struct is used to replace the TTSSentItem struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugSentItem
{
    WCHAR           ItemSrcText[32];
    ULONG           ulItemSrcLen;
    ULONG           ulItemSrcOffset;
    DebugWord         Words[32];
    ULONG           ulNumWords;
    ENGPARTOFSPEECH  eItemPartOfSpeech;
    DebugItemInfo   ItemInfo;
public:
    DebugSentItem() { ZeroMemory( (void*) this, sizeof( DebugSentItem ) ); }
    operator =( TTSSentItem InItem )
    {
        if ( InItem.pItemSrcText )
        {
            wcsncpy( ItemSrcText, InItem.pItemSrcText, InItem.ulItemSrcLen > 31 ? 31 : InItem.ulItemSrcLen );
        }
        ulItemSrcLen        = InItem.ulItemSrcLen;
        ulItemSrcOffset     = InItem.ulItemSrcOffset;
        for ( ULONG i = 0; i < InItem.ulNumWords; i++ )
        {
            Words[i] = InItem.Words[i];
        }
        ulNumWords          = InItem.ulNumWords;
        eItemPartOfSpeech   = InItem.eItemPartOfSpeech;
        ItemInfo            = *(InItem.pItemInfo);
    }
};

//--- This enumeration is used to index the array of IStreams used to write stuff to the debug file
typedef enum
{
    STREAM_WAVE = 0,
    STREAM_EPOCH,
    STREAM_UNIT,
    STREAM_WAVEINFO,
    STREAM_TOBI,
    STREAM_SENTENCEBREAKS,
    STREAM_NORMALIZEDTEXT,
    STREAM_LEXLOOKUP,
    STREAM_POSPOSSIBILITIES,
    STREAM_MORPHOLOGY,
    STREAM_LASTTYPE
} STREAM_TYPE;

//
//  String handling and conversion classes
//
/*** SPLSTR
*   This structure is for managing strings with known lengths
*/
struct SPLSTR
{
    WCHAR*  pStr;
    int     Len;
};
#define DEF_SPLSTR( s ) { L##s , sp_countof( s ) - 1 }

//--- This enumeration should correspond to the previous one, and is used to name the array of IStreams
//---   used to write stuff to the debug file
static const SPLSTR StreamTypeStrings[] =
{
    DEF_SPLSTR( "Wave"           ),
    DEF_SPLSTR( "Epoch"          ),
    DEF_SPLSTR( "Unit"           ),
    DEF_SPLSTR( "WaveInfo"       ),
    DEF_SPLSTR( "ToBI"           ),
    DEF_SPLSTR( "SentenceBreaks" ),
    DEF_SPLSTR( "NormalizedText" ),
    DEF_SPLSTR( "LexLookup"      ),
    DEF_SPLSTR( "PosPossibilities" ),
    DEF_SPLSTR( "Morphology" ),
};

//***************************
// ToBI Constants
//***************************
// !H is removed from consideration in the first pass processing
// !H can possibly be recovered from analysis of the labeling and
// contour at later stages (tilt, prominence, pitch range, downstep)
#define ACCENT_BASE   1
enum TOBI_ACCENT
{
    K_NOACC = 0,
    K_HSTAR = ACCENT_BASE,  // peak                         rise / fall
    K_LSTAR,                // acc syll nucleus valley      early fall
    K_LSTARH,               // late rise
    K_RSTAR,                //
    K_LHSTAR,               // early rise
    K_DHSTAR,               // 
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__44183539_C02F_475B_9A56_7260EDD0A7F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\tools\ttsdbginfo.cpp ===
// DebugSupport.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

int g_StreamIndex = 0;
FILE *g_fpOutputFile = NULL;
IStorage *g_pDebugFile = NULL;

WCHAR* ConvertPOSToString( DWORD dwPartOfSpeech );
bool ParseCommandLine( int argc, char* argv[] );
void ExtractSentenceBreaks( void );
void ExtractNormalizedText( void );
void ExtractLexLookup( void );
void ExtractPOSPossibilities( void );
void ExtractMorphology( void );

int main(int argc, char* argv[])
{
    bool fSuccess = false;
    CoInitialize( NULL );

    fSuccess = ParseCommandLine( argc, argv );
    if ( fSuccess )
    {
        switch ( g_StreamIndex )
        {
        case STREAM_SENTENCEBREAKS:
            ExtractSentenceBreaks();
            break;
        case STREAM_NORMALIZEDTEXT:
            ExtractNormalizedText();
            break;
        case STREAM_LEXLOOKUP:
            ExtractLexLookup();
            break;
        case STREAM_POSPOSSIBILITIES:
            ExtractPOSPossibilities();
            break;
        case STREAM_MORPHOLOGY:
            ExtractMorphology();
            break;
        }
    }

    CoUninitialize();
	return 0;
}

bool ParseCommandLine( int argc, char* argv[] )
{
    bool fSuccess = true;

    //--- Check number of parameters
    if ( argc < 4 )
    {
        goto USAGE;
    }

    //--- Check streamname validity
    fSuccess = false;
    WCHAR StreamName[MAX_PATH];
    if ( !MultiByteToWideChar( CP_ACP, 0, argv[2], strlen( argv[2] ) + 1, StreamName, MAX_PATH ) )
    {
        goto MISC_ERROR;
    }
    else
    {
        for ( int i = 0; i < STREAM_LASTTYPE; i++ )
        {
            if ( wcscmp( StreamName, StreamTypeStrings[i].pStr ) == 0 )
            {
                fSuccess = true;
                g_StreamIndex = i;
                break;
            }
        }
    }
    if ( !fSuccess )
    {
        goto USAGE;
    }

    //--- Try to open debug info file
    WCHAR DebugFilename[MAX_PATH];
    if ( !MultiByteToWideChar( CP_ACP, 0, argv[1], strlen( argv[1] ) + 1, DebugFilename, MAX_PATH ) )
    {
        goto MISC_ERROR;
    }

    if ( FAILED( StgOpenStorage( DebugFilename, NULL, STGM_READ | STGM_SHARE_DENY_WRITE, 
                                 NULL, 0, &g_pDebugFile ) ) )
    {
        goto MISC_ERROR;
    }

    //--- Try to open file for output
    WCHAR OutputFilename[MAX_PATH];
    if ( !MultiByteToWideChar( CP_ACP, 0, argv[3], strlen( argv[3] ) + 1, OutputFilename, MAX_PATH ) )
    {
        goto MISC_ERROR;
    }

    g_fpOutputFile = _wfopen( OutputFilename, L"w" );
    if ( !g_fpOutputFile )
    {
        printf( "\n\nUnable to open file: %s\n", argv[3] );
        goto MISC_ERROR;
    }

    return true;

USAGE:
    printf( "\n\nUSAGE:\n\n\tDebugSupport [debug filename] [streamname] [output filename]\n" );
    printf( "\tStream names are:\n\t\tSentenceBreaks\n\t\tNormalizedText\n\t\tMorphology" );
    printf( "\n\t\tLexLookup\n\n" );

    return false;

MISC_ERROR:
    printf( "\n\n\tERROR in ParseCommandLine(...)\n\n" );

    return false;
}

//--- Just print the original text out, with a newline character between each sentence.
void ExtractSentenceBreaks( void )
{
    IStream *pStgStream = NULL;

    if ( g_pDebugFile->OpenStream( StreamTypeStrings[g_StreamIndex].pStr, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 
                                   0, &pStgStream) == S_OK )
    {
        DebugSentItem Item, EmptyItem;
        ULONG cbRead = 0, ulOffset = 0;
        bool fResetOffset = true;

        while ( SUCCEEDED( pStgStream->Read( (void*) &Item, sizeof( Item ), &cbRead ) ) &&
                cbRead == sizeof( Item ) )
        {
            //--- Check for delimiter
            if ( memcmp( &Item, &EmptyItem, sizeof( Item ) ) == 0 )
            {
                fwprintf( g_fpOutputFile, L"\n" );
            }
            else
            {
                //--- Print item
                fwprintf ( g_fpOutputFile, L"%s ", Item.ItemSrcText );
            }
        }
    }
}

//--- Just print the normalized text of each item out, separated by single spaces, 
//---   with a newline character between each sentence.
void ExtractNormalizedText( void )
{
    IStream *pStgStream = NULL;

    if ( g_pDebugFile->OpenStream( StreamTypeStrings[5].pStr, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 
                                   0, &pStgStream) == S_OK )
    {
        DebugSentItem Item, EmptyItem;
        ULONG cbRead = 0;

        while ( SUCCEEDED( pStgStream->Read( (void*) &Item, sizeof( Item ), &cbRead ) ) &&
                cbRead == sizeof( Item ) )
        {
            //--- Check for delimiter
            if ( memcmp( &Item, &EmptyItem, sizeof( Item ) ) == 0 )
            {
                fwprintf( g_fpOutputFile, L"\n" );
            }
            else
            {
                //--- Print item
                if ( Item.ItemInfo.Type != eALPHA_WORD          &&
                     Item.ItemInfo.Type != eOPEN_PARENTHESIS    &&
                     Item.ItemInfo.Type != eOPEN_BRACKET        &&
                     Item.ItemInfo.Type != eOPEN_BRACE          &&
                     Item.ItemInfo.Type != eCLOSE_PARENTHESIS   &&
                     Item.ItemInfo.Type != eCLOSE_BRACKET       &&
                     Item.ItemInfo.Type != eCLOSE_BRACE         &&
                     Item.ItemInfo.Type != eSINGLE_QUOTE        &&
                     Item.ItemInfo.Type != eDOUBLE_QUOTE        &&
                     Item.ItemInfo.Type != ePERIOD              &&
                     Item.ItemInfo.Type != eEXCLAMATION         &&
                     Item.ItemInfo.Type != eQUESTION            &&
                     Item.ItemInfo.Type != eCOMMA               &&
                     Item.ItemInfo.Type != eSEMICOLON           &&
                     Item.ItemInfo.Type != eCOLON               &&
                     Item.ItemInfo.Type != eHYPHEN )
                {
                    fwprintf( g_fpOutputFile, L"[ " );
                }
                for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                {
                    if ( Item.Words[i].ulWordLen > 0 )
                    {
                        fwprintf( g_fpOutputFile, L"%s ", Item.Words[i].WordText );
                    }
                    else
                    {
                        fwprintf( g_fpOutputFile, L"%s ", Item.ItemSrcText );
                    }
                }
                if ( Item.ItemInfo.Type != eALPHA_WORD          &&
                     Item.ItemInfo.Type != eOPEN_PARENTHESIS    &&
                     Item.ItemInfo.Type != eOPEN_BRACKET        &&
                     Item.ItemInfo.Type != eOPEN_BRACE          &&
                     Item.ItemInfo.Type != eCLOSE_PARENTHESIS   &&
                     Item.ItemInfo.Type != eCLOSE_BRACKET       &&
                     Item.ItemInfo.Type != eCLOSE_BRACE         &&
                     Item.ItemInfo.Type != eSINGLE_QUOTE        &&
                     Item.ItemInfo.Type != eDOUBLE_QUOTE        &&
                     Item.ItemInfo.Type != ePERIOD              &&
                     Item.ItemInfo.Type != eEXCLAMATION         &&
                     Item.ItemInfo.Type != eQUESTION            &&
                     Item.ItemInfo.Type != eCOMMA               &&
                     Item.ItemInfo.Type != eSEMICOLON           &&
                     Item.ItemInfo.Type != eCOLON               &&
                     Item.ItemInfo.Type != eHYPHEN )
                {
                    fwprintf( g_fpOutputFile, L"] " );
                }
            }
        }
    }
}

//--- Print the text of each item, and then its Pronunciation and Part of Speech. 
//---   Separate each with a newline character.
void ExtractLexLookup( void )
{
    IStream *pStgStream = NULL;

    if ( g_pDebugFile->OpenStream( StreamTypeStrings[g_StreamIndex].pStr, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 
                                   0, &pStgStream) == S_OK )
    {
        DebugSentItem Item, EmptyItem;
        ULONG cbRead = 0;

        while ( SUCCEEDED( pStgStream->Read( (void*) &Item, sizeof( Item ), &cbRead ) ) &&
                cbRead == sizeof( Item ) )
        {
            if ( memcmp( &Item, &EmptyItem, sizeof( Item ) ) == 0 )
            {
                fwprintf( g_fpOutputFile, L"\n" );
            }
            else
            {
                //--- Print Normalization delimiter
                if ( Item.ItemInfo.Type != eALPHA_WORD          &&
                     Item.ItemInfo.Type != eOPEN_PARENTHESIS    &&
                     Item.ItemInfo.Type != eOPEN_BRACKET        &&
                     Item.ItemInfo.Type != eOPEN_BRACE          &&
                     Item.ItemInfo.Type != eCLOSE_PARENTHESIS   &&
                     Item.ItemInfo.Type != eCLOSE_BRACKET       &&
                     Item.ItemInfo.Type != eCLOSE_BRACE         &&
                     Item.ItemInfo.Type != eSINGLE_QUOTE        &&
                     Item.ItemInfo.Type != eDOUBLE_QUOTE        &&
                     Item.ItemInfo.Type != ePERIOD              &&
                     Item.ItemInfo.Type != eEXCLAMATION         &&
                     Item.ItemInfo.Type != eQUESTION            &&
                     Item.ItemInfo.Type != eCOMMA               &&
                     Item.ItemInfo.Type != eSEMICOLON           &&
                     Item.ItemInfo.Type != eCOLON               &&
                     Item.ItemInfo.Type != eHYPHEN )
                {
                    fwprintf( g_fpOutputFile, L"[ " );
                }
                for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                {
                    //--- Print item
                    if ( Item.Words[i].WordText[0] != 0 )
                    {
                        fwprintf ( g_fpOutputFile, L"%s ", Item.Words[i].WordText );
                    }
                    else
                    {
                        fwprintf ( g_fpOutputFile, L"%s ", Item.ItemSrcText );
                    }
                    //--- Print pronunciation
                    //CComPtr<ISpPhoneConverter> pPhoneConv;
                    //if ( SUCCEEDED( SpCreatePhoneConverter(1033, NULL, NULL, &pPhoneConv) ) )
                    //{
                    //    if ( SUCCEEDED( pPhoneConv->IdToPhone( Item.Words[i].WordPron, Item.Words[i].WordPron ) ) )
                    //    {
                    //        fwprintf( g_fpOutputFile, L"%s", Item.Words[i].WordPron );
                    //        for ( long j = 0; j < (long)( (long)45 - (long)wcslen( Item.Words[i].WordPron ) ); j++ )
                    //        {
                    //            fwprintf( g_fpOutputFile, L" " );
                    //        }
                    //    }
                    //}
                    //--- Print POS
                    fwprintf ( g_fpOutputFile, L"(%s) ", ConvertPOSToString( Item.Words[i].eWordPartOfSpeech ) );
                }
                //--- Print Normalization delimiter
                if ( Item.ItemInfo.Type != eALPHA_WORD          &&
                     Item.ItemInfo.Type != eOPEN_PARENTHESIS    &&
                     Item.ItemInfo.Type != eOPEN_BRACKET        &&
                     Item.ItemInfo.Type != eOPEN_BRACE          &&
                     Item.ItemInfo.Type != eCLOSE_PARENTHESIS   &&
                     Item.ItemInfo.Type != eCLOSE_BRACKET       &&
                     Item.ItemInfo.Type != eCLOSE_BRACE         &&
                     Item.ItemInfo.Type != eSINGLE_QUOTE        &&
                     Item.ItemInfo.Type != eDOUBLE_QUOTE        &&
                     Item.ItemInfo.Type != ePERIOD              &&
                     Item.ItemInfo.Type != eEXCLAMATION         &&
                     Item.ItemInfo.Type != eQUESTION            &&
                     Item.ItemInfo.Type != eCOMMA               &&
                     Item.ItemInfo.Type != eSEMICOLON           &&
                     Item.ItemInfo.Type != eCOLON               &&
                     Item.ItemInfo.Type != eHYPHEN )
                {
                    fwprintf( g_fpOutputFile, L"] " );
                }
            }
        }
    }
}

void ExtractPOSPossibilities( void )
{
    IStream *pStgStream = NULL;

    if ( g_pDebugFile->OpenStream( StreamTypeStrings[g_StreamIndex].pStr, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 
                                   0, &pStgStream) == S_OK )
    {
        DebugPronRecord PronRecord, EmptyPronRecord;
        ULONG cbRead = 0;

        while ( SUCCEEDED( pStgStream->Read( (void*) &PronRecord, sizeof( PronRecord ), &cbRead ) ) &&
                cbRead == sizeof( PronRecord ) )
        {
            //--- Check for delimiter
            if ( memcmp( &PronRecord, &EmptyPronRecord, sizeof( PronRecord ) ) == 0 )
            {
                fwprintf( g_fpOutputFile, L"\n" );
            }
            else
            {
                fwprintf( g_fpOutputFile, PronRecord.orthStr );
                fwprintf( g_fpOutputFile, L" [ " );
                fwprintf( g_fpOutputFile, L"%s - ", ConvertPOSToString( PronRecord.POSchoice ) );
                for ( ULONG i = 0; i < PronRecord.pronArray[0].POScount; i++ )
                {
                    fwprintf( g_fpOutputFile, L"%s,", ConvertPOSToString( (DWORD)PronRecord.pronArray[0].POScode[i] ) );
                }
                for ( i = 0; i < PronRecord.pronArray[1].POScount; i++ )
                {
                    fwprintf( g_fpOutputFile, L"%s,", ConvertPOSToString( (DWORD)PronRecord.pronArray[1].POScode[i] ) );
                }
                fwprintf( g_fpOutputFile, L" ]\n" );
            }
        }
    }
}

void ExtractMorphology( void )
{
    IStream *pStgStream = NULL;

    if ( g_pDebugFile->OpenStream( StreamTypeStrings[g_StreamIndex].pStr, 0, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   0, &pStgStream ) == S_OK )
    {
        CComPtr<ISpPhoneConverter> pPhoneConv;
        if ( SUCCEEDED( SpCreatePhoneConverter( 1033, NULL, NULL, &pPhoneConv ) ) )
        {
            WCHAR Buffer[SP_MAX_WORD_LENGTH], EmptyBuffer[SP_MAX_WORD_LENGTH];
            ULONG cbRead = 0;
            ZeroMemory( EmptyBuffer, SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );
            BOOL fRoot = true;

            while ( SUCCEEDED( pStgStream->Read( (void*) &Buffer, SP_MAX_WORD_LENGTH * sizeof( WCHAR ), &cbRead ) ) &&
                    cbRead == SP_MAX_WORD_LENGTH * sizeof( WCHAR ) )
            {
                //--- Check for delimiter
                if ( memcmp( &Buffer, &EmptyBuffer, SP_MAX_WORD_LENGTH * sizeof( WCHAR ) ) == 0 )
                {
                    fwprintf( g_fpOutputFile, L"\n" );
                    fRoot = true;
                }
                else if ( fRoot )
                {
                    fwprintf( g_fpOutputFile, L"%s ", Buffer );
                    fRoot = false;
                }
                else
                {
                    if ( SUCCEEDED( pPhoneConv->IdToPhone( Buffer, Buffer ) ) )
                    {
                        fwprintf( g_fpOutputFile, L"- %s ", Buffer );
                    }
                }
            }
        }
    }
}

WCHAR* ConvertPOSToString( DWORD dwPartOfSpeech )
{
    switch (dwPartOfSpeech)
    {
    case MS_NotOverriden:
        return L"Noun";
    case MS_Unknown:
        return L"Unknown";
    case MS_Punctuation:
        return L"Punctuation";
    case MS_Noun:
        return L"Noun";
    case MS_Verb:
        return L"Verb";
    case MS_Modifier:
        return L"Modifier";
    case MS_Function:
        return L"Function";
    case MS_Interjection:
        return L"Interj";
    case MS_Pron:
        return L"Pron";
    case MS_SubjPron:
        return L"SubjPron";
    case MS_ObjPron:
        return L"ObjPron";
    case MS_RelPron:
        return L"RelPron";
//    case MS_PPron:
//        return L"PPron";
//    case MS_IPron:
//        return L"IPron";
//    case MS_RPron:
//        return L"RPron";
//    case MS_DPron:
//       return L"DPron";
    case MS_Adj:
        return L"Adj";
    case MS_Adv:
        return L"Adv";
    case MS_VAux:
        return L"VAux";
//    case MS_RVAux:
//        return L"RVAux";
    case MS_Conj:
        return L"Conj";
    case MS_CConj:
        return L"CConj";
    case MS_Interr:
        return L"WHWord";
    case MS_Det:
        return L"Det";
    case MS_Contr:
        return L"Contr";
//    case MS_VPart:
//        return L"VPart";
    case MS_Prep:
        return L"Prep";
//    case MS_Quant:
//        return L"Quant";
    default:
        return L"Unknown";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\cpptest\ehthrow.cxx ===
/*
*      COMMAND LINE: -Ox -GX
*/

/*

  Copyright (c) 1997  Microsoft Corporation
  
  Module Name:
    
      EhThrow.cxx
      
  Abstract:
        
      Tests some throw and rethrow situations (mostly CRT a test)
          
  Author:
            
      Louis Lafreniere (louisl) 1997
              
*/


#include <stdlib.h>
#include <stdio.h>


#define FALSE 0
#define TRUE 1
#define NO_CTOR_THROW 1
#define NO_DTOR_THROW 2


int Object[100];
int CurrentObjectNumber, Test;
int MaxTest = 10;
int MaxObjectCount = 1;
int Fail;


void FAIL(int i)
{
    printf("FAILED on %d\n", i);
    Fail++;
}

void dealloc(int i, int no_throw)
{
    /* Make sure i is valid, and object exists */
    if(i<0 || i>=MaxObjectCount || !Object[i]) 
        FAIL(i);
    
    Object[i] = 0;
}

void alloc(int i, int no_throw)
{
    if(CurrentObjectNumber > MaxObjectCount)
        MaxObjectCount = CurrentObjectNumber;
    
    /* Object already exists? */
    if(Object[i]) FAIL(i);
    
    Object[i] = 1;
}

class B
{
public:
    int i;
    int flag;
    B();
    B(int);
    B(const B &b);
    ~B();
};

B::B()
{
    i = CurrentObjectNumber++;
    printf("B ctor.  i = %d\n", i);
    alloc(i, FALSE);
}

B::B(int f)
{
    i = CurrentObjectNumber++;
    flag = f;
    printf("B ctor.  i = %d\n", i);
    alloc(i, flag==NO_CTOR_THROW);
}

B::B(const B &b)
{
    i = CurrentObjectNumber++;
    printf("B copy ctor.  i = %d\n", i);
    alloc(i, FALSE);
}

B::~B()
{
    printf("B dtor.  i = %d\n", i);
    dealloc(i, flag==NO_DTOR_THROW);
}

class A
{
public:
    int i;
    A();
    A(int) 
    {
        i = CurrentObjectNumber++;
        printf("A(int) ctor.  i = %d\n", i);
        alloc(i, FALSE);
    }
    A operator+(A a);
    A(const A &a)
    {
        /* Try objects in ctor */
        B b1 = NO_DTOR_THROW, b2 = NO_DTOR_THROW;
        
        i = CurrentObjectNumber++;
        printf("A copy ctor.  i = %d\n", i);
        alloc(i, FALSE);
    }
    
    ~A(){
        /* Try objects in dtor */
        B b1 = NO_CTOR_THROW, b2 = NO_CTOR_THROW;
        
        printf("A dtor.  i = %d\n", i);
        dealloc(i, FALSE);
    };
};

A::A()
{
    i=CurrentObjectNumber++;
    printf("A ctor.  i = %d\n", i);
    alloc(i, FALSE);
}

A A::operator+(A a)
{
    printf("A%d + A%d\n", i, a.i);
    return A();
}

void Throwa(A a)
{
    printf("Throwing\n");
    throw a;
}

void bar()
{
    A a;
    
    Throwa(a);
}

void foobar()
{
    B b;
    bar();
}

// Somehow, inlining this causes different unwinding order..

void Rethrow2()
{
    A a;
    printf("Rethrowing\n");
    throw;
}

#pragma inline_depth(0)
void Rethrow()
{
    Rethrow2();
}
#pragma inline_depth()

void foobar2()
{
    B b;
    
    try{
        A a;
        bar();
    }catch(A a){
        printf("In catch;\n");
        Rethrow();
    }
}

void foobar3()
{
    B b;
    
    try{
        A a;
        bar();
    }catch(A a){
        printf("In catch\n");
        A a2;
        
        printf("Throwing new a\n");
        throw a2;
    }
}

void foobar4()
{
    B b;
    
    try{
        B b;
        try{
            A a1, a2;
            try {
                A a1, a2;
                foobar2();
            }catch(A a){
                printf("In catch #1\n");
                B b;
                printf("Rethrowing\n");
                throw;
            }
        }catch(A &a){
            printf("In catch #2\n");
            A a2;
            
            printf("Throwing new a\n");
            throw a;
        }
    }catch(A a){
        printf("In catch #3\n");
        B b;
        printf("Rethrowing\n");
        throw;
    }
}

void throw_B_2()
{
    B b;
    printf("Throwing a new b\n");
    throw b;
}

#pragma inline_depth(0)
void throw_B()
{
    throw_B_2();
}
#pragma inline_depth()


void foobar5()
{
    try {
        B b1;
        try {
            B b2;
            try {
                B b3;
                foobar();
            }catch(B b){
                printf("In catch #1\n");
                FAIL(-1);
            }
            FAIL(-1);
        }catch(A a){
            A a2;
            printf("In catch #2\n");
            throw_B();
        }
        FAIL(-1);
    }catch(B b){
        printf("In catch #3\n");
        printf("Throwing a new a\n");
        throw A();
    }
    FAIL(-1);
}


/* Simple throw with unwinds */
void test1()
{
    A a;
    foobar();
}

/* Throw followed by a rethrow */
void test2()
{
    A a;
    foobar2();
}

/* Throw followed by a new throw */
void test3()
{
    A a;
    foobar3();
}

/* Nested trys with rethrow/throw/rethrow */
void test4()
{
    A a;
    foobar4();
}

/* Makes sure a new throw skips appropriate unwound frames. */
void test5()
{
    A a;
    foobar5();
}

// Tests 3 level of new throw
void test6()
{
    try{
        B b1;
        try{
            B b2;
            try{
                B b3;
                printf("Throwing a b\n");
                throw(b3);
            }catch(B b){
                B b4;
                printf("In catch #1\n");
                printf("Throwing a new b\n");
                throw(b4);
            }
            FAIL(-1);
        }catch(B b){
            B b5;
            printf("In catch #2\n");
            printf("Throwing a new b\n");
            throw(b5);
        }
        FAIL(-1);
    }catch(B b){
        A a1;
        printf("In catch #3\n");
        printf("Throwing a new a\n");
        throw(a1);
    }
    FAIL(-1);
}

// Testing try/catch inside a catch
void test7()
{
    B b1;
    try{
        B b2;
        try{
            B b3;
            
            printf("Throwing a b\n");
            throw(B());
        }catch(B b){
            B b4;
            printf("In catch #1\n");
            try{
                B b5;
                printf("Rethrowing b\n");
                throw;
            }catch(B b){
                B b5;
                printf("In catch #1 of catch#1\n");
                printf("Rethrowing b\n");
                throw;
            }
        }
    }catch(B b){
        B b6;
        printf("In catch #2\n");
        printf("Throwing a new A\n");
        throw(A());
    }
}

void ThrowB()
{
    B b;
    
    throw(B());
}

void bar8()
{
    try{
        B b5;
        printf("Rethrowing b\n");
        Rethrow();
    }catch(B b){
        B b5;
        printf("In catch #1 of catch#1\n");
        printf("Rethrowing b\n");
        Rethrow();
    }
}

void foo8()
{
    B b;
    try{
        B b3;
        
        printf("Throwing a b\n");
        ThrowB();
    }catch(B b){
        B b4;
        printf("In catch #1\n");
        bar8();
    }
}

// Testing call to try/catch function inside a catch
void test8()
{
    B b1;
    try{
        B b2;
        foo8();
    }catch(B b){
        B b6;
        printf("In catch #2\n");
        printf("Throwing a new A\n");
        throw(A());
    }
}

void foo9()
{
    try {
        puts("Rethrow");
        throw;
    }catch(...){
        puts("In catch #2");
    }
}

void test9()		    
{
    try{
        B b;
        puts("Throwing B");
        throw b;
    }catch(...){
        puts("In catch #1");
        foo9();
    }
    puts("End of test9, throwing a A");
    throw A();
}

void foo10()
{
    try {
        puts("Throwing a new B()");
        throw B();
    }catch(...){
        puts("In catch #2");
    }
}

void test10()		    
{
    try{
        B b;
        puts("Throwing B");
        throw b;
    }catch(...){
        puts("In catch #1");
        foo10();
    }
    puts("End of test10, throwing a A");
    throw A();
}

void main()
{
    int i;
    
    /* Call test(), with a different ctor/dtor throwing each time */
    for(Test = 1; Test <= 10; Test++)  {
        
        CurrentObjectNumber = 0;
        
        printf("\nTest #%d\n", Test);
        
        try {
            switch(Test){
            case 1:
                test1();
                break;
            case 2:
                test2();
                break;
            case 3:
                test3();
                break;
            case 4:
                test4();
                break;
            case 5:
                test5();
                break;
            case 6:
                test6();
                break;
            case 7:
#if !defined(_M_IA64)
                test7();
#else
                continue;
#endif
                break;
            case 8:
                test8();
                break;
            case 9:
#if !defined(_M_IA64)
                test9();
#else
                continue;
#endif
                break;
            case 10:
                test10();
                break;
            }
            
            FAIL(-1);
            
        }catch(A a){
            printf("In main's catch\n");
        }catch(...){
            FAIL(-1);
        }
        
        /* Any objects which didn't get dtor'd? */
        for(i = 0; i < MaxObjectCount; i++) {
            if(Object[i]) {
                FAIL(i);
                Object[i] = 0;
            }
        }
        
        printf("\n");
    }
    
    printf("\n");
    if(Fail)
        printf("FAILED %d tests\n", Fail);
    else
        printf("Passed\n");
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\cpptest\cpptest.cpp ===
#include <stdio.h>
#include <windows.h>
#include <eh.h>

extern "C"
ULONG
DbgPrint (
    PCH Format,
    ...
    );

extern "C"
VOID
DbgBreakPoint (
    VOID
    );

#define FALSE 0
#define TRUE 1
#define NO_CTOR_THROW 1
#define NO_DTOR_THROW 2


#define B0  B b0(__FUNCTION__, __LINE__)
#define B1  B b1(__FUNCTION__, __LINE__)
#define B2  B b2(__FUNCTION__, __LINE__)
#define B3  B b3(__FUNCTION__, __LINE__)
#define B4  B b4(__FUNCTION__, __LINE__)
#define B5  B b5(__FUNCTION__, __LINE__)
#define B6  B b6(__FUNCTION__, __LINE__)
#define B7  B b7(__FUNCTION__, __LINE__)
#define B8  B b8(__FUNCTION__, __LINE__)

#define A0  A a0(__FUNCTION__, __LINE__)
#define A1  A a1(__FUNCTION__, __LINE__)
#define A2  A a2(__FUNCTION__, __LINE__)
#define A3  A a3(__FUNCTION__, __LINE__)
#define A4  A a4(__FUNCTION__, __LINE__)
#define A5  A a5(__FUNCTION__, __LINE__)
#define A6  A a6(__FUNCTION__, __LINE__)
#define A7  A a7(__FUNCTION__, __LINE__)
#define A8  A a8(__FUNCTION__, __LINE__)


const unsigned int NumMaxA = 100, NumMaxB = 100, NumTests = 9;
int AObject[NumMaxA];
int BObject[NumMaxB];
int MaxTest = 10;
int MaxObjectCount = 1;
int Fail;
int A_id;
int B_id;
typedef enum ClassName{clA = 'A', clB};

/*********************************** Class C *********************************/
class C
{
protected:
    const char *FuncName;
    unsigned int LineNumber;
    int id;
    ClassName CName;

    void C::PrintCtor() {
        DbgPrint("%c  ctor.  id = %4d\t          ", CName, id);
        if (FuncName) {
            DbgPrint("\tFunction = %s\tLineNum = %4d\n", FuncName, LineNumber);
        } else {
            DbgPrint("\n");
        }
        fflush(stdout);
    }
    void C::PrintCtor(int n) {
        DbgPrint("%c cctor.  id = %4d\tpid = %4d\t", CName, id, n);
        if (FuncName) {
            DbgPrint("\tFunction = %s\tLineNum = %4d\n", FuncName, LineNumber);
        } else {
            DbgPrint("\n");
        }
        fflush(stdout);
    }
    void C::PrintDtor()
    {
        DbgPrint("%c  dtor.  id = %4d\t          ", CName, id);
        if (FuncName) {
            DbgPrint("\tFunction = %s\tLineNum = %4d\n", FuncName, LineNumber);
        } else {
            DbgPrint("\n");
        }
        fflush(stdout);
    }

    void Alloc() {
        int *Arr = NULL;
        if (CName == clB)
            Arr = BObject;
        else if(CName == clA)
            Arr = AObject;
        else
            DbgPrint("ERROR: Alloc Unknown ClassName %c\n", CName);
        if (Arr) {
            if (Arr[id]) {
                DbgPrint("Error: id#%4d for %c already exists\n", id, CName);
            }
            Arr[id] = 1;
        }
    }
    void DAlloc() {
        int *Arr = NULL;
        if (CName == clB)
            Arr = BObject;
        else if(CName == clA)
            Arr = AObject;
        else
            DbgPrint("ERROR: Alloc Unknown ClassName %c\n", CName);
        if (Arr) {
            if (Arr[id] != 1) {
                DbgPrint("Error: id#%4d for %c already destructed\n", id, CName);
            }
            Arr[id]--;
        }
    }
public:
    void print(){
        DbgPrint("%c print.  id = %4d\t          ", CName, id);
        if (FuncName) {
            DbgPrint("\tFunction = %s\tLineNum = %4d\n", FuncName, LineNumber);
        } else {
            DbgPrint("\n");
        }
    }
    C():id(0), CName(clA), FuncName(NULL), LineNumber(0){}
    ~C() {
        PrintDtor();
        DAlloc();
    }
};

/*********************************** Class B *********************************/
class B : public C
{
public:
    B();
    B(const B &b);
    B(const char *, unsigned int);
};

B::B()
{
    id = B_id++;
    CName = clB;
    PrintCtor();
    Alloc();
}

B::B(const B &b)
{
    id = B_id++;
    CName = clB;
    PrintCtor(b.id);
    Alloc();
}

B::B(const char *ch, unsigned int i){
    id = B_id++;
    CName = clB;
    FuncName = ch;
    LineNumber = i;
    PrintCtor();
    Alloc();
}

/*********************************** Class A *********************************/
class A : public C
{
public:
    A();
    A(int)
    {
        id = A_id++;
        CName = clA;
        PrintCtor();
        Alloc();
    }
    A(const A&);
    A(const char *ch, unsigned int i);
    A operator+(A a);
};

A::A()
{
    id = A_id++;
    CName = clA;
    PrintCtor();
    Alloc();
}

A::A(const A &b)
{
    id = A_id++;
    CName = clA;
    PrintCtor(b.id);
    Alloc();
}

A::A(const char *ch, unsigned int i){
    id = A_id++;
    CName = clA;
    FuncName = ch;
    LineNumber = i;
    PrintCtor();
    Alloc();
}


void ThrowA()
{
    A0;
    throw a0;
}

void ThrowB()
{
    B0;
    throw b0;
}

void SehThrow()
{
    RaiseException(STATUS_INTEGER_OVERFLOW, 0, 0, NULL);
}

void Rethrow()
{
    A0;
    throw;
}


int SehFilter(EXCEPTION_POINTERS *pExPtrs, unsigned int ExceptionCode)
{
    if (pExPtrs->ExceptionRecord->ExceptionCode == ExceptionCode)
        return EXCEPTION_EXECUTE_HANDLER;
    else
        return EXCEPTION_CONTINUE_SEARCH;
}

/*********************************** Test  1 *********************************/

void Test1foo(void) {
    A0;
    try {
        throw; // first rethrow
    }
    catch(A) {
        A1;
        DbgPrint("my exception\n");
    }
    catch(...) {
        A2;
        DbgPrint("an other exception\n");
    }
}

int Test1()
{
    A0;
    try {
        A1;
        try {
            A2;
            throw A();
        }
        catch(...) {
            A3;
            Test1foo();
            throw; // 2nd rethrow -- will result in ACCESS VIOLATION error 
        }
    }
    catch (...) {
        A4;
        try {
            A5;
            throw;
        }
        catch (A &e)
        {
            A6;
            e.print();
        }
        catch(...) {
            A7;
        }
    }

    return 0;
}
/*********************************** Test  2 *********************************/
void goandfail()
{
    DbgPrint( "throwing in goandfail\n" );
    throw (long)10;
}

void dosomething()
{
    A0;
    try
    {
        A1;
        goandfail();
    }
    catch( long & sc )
    {
        A2;
        DbgPrint( "catch in dosomething\n" );
        throw sc;
    }
}

class BTest2 : public B
{
    char * _p;
public:
    BTest2() : _p(0) {}
    ~BTest2()
    {
        try
        {
            A1;
            dosomething();
        }
        catch( long & sc )
        {
            A2;
            DbgPrint( "catch in ~B\n" );
        }

        delete [] _p;
    }

    void print() {
        DbgPrint("BTest2 _p = %p\n", _p );
        B::print();
    }

};

int Test2()
{
    DbgPrint( "top\n" );

    try
    {
        A1;
        BTest2 b;
        b.print();
        goandfail();
    }
    catch( long & sc )
    {
        A2;
        DbgPrint( "catch in main\n" );
    }

    DbgPrint( "all done\n" );

    return 0;
}

/*********************************** Test  3 *********************************/
void Test3()
{
    A0;
    try
    {
        A1;
        char* pStr = NULL;
        try
        {
            A2;
            throw "1st throw\n";
        }
        catch( char* str )
        {
            A3;
            DbgPrint("%s%s", "A ", str);
            try
            {
                A4;
                throw "2nd throw\n";
            }
            catch( char* str )
            {
                A5;
                DbgPrint("%s%s", "B ", str);
            }
            throw;
        }
    }
    catch ( char* str )
    {
        A6;
        DbgPrint("%s%s", "C ", str);
    }
    DbgPrint("Done\n");
}
/*********************************** Test  4 *********************************/



void SehTest4()
{
    int i;
    __try{
        i = 0;
        ThrowA();
    } __finally {
        if (i) {
            DbgPrint("Error: Finally in same function called %2d times\n", i+1);
            Fail = 1;
        }
        i++;
    }
}

void Test4foo()
{
    A0;
    try {
        A1;
        try {
            A2;
            SehTest4();
        } catch(A ac) {
            A3;
            ThrowB();
        }
    } catch(B bc) {
        A4;
        throw;
    };
}

void Test4boo()
{
    A0;
    try{
        A1;
        Test4foo();
    } catch (B bc) {
        A2;
        SehThrow();
    }
}

void Test4()
{
    __try {
        Test4boo();
    } __except(1) {
        DbgPrint("Test4: Test4 __except\n");
    }
}
/*********************************** Test  5 *********************************/

void SehTest5()
{
    int i;
    __try{
        i = 0;
        ThrowA();
    } __finally {
        i++;
        if (i-1) {
            DbgPrint("Error: Finally in same function called %2d times\n", i);
            Fail = 1;
        } else {
            SehThrow();
        }
    }
}

void Test5foo()
{
    A0;
    try {
        A1;
        try {
            A2;
            SehTest5();
        } catch (...) {
            A3;
        }
    } catch (...) {
        A4;
    };
}

void Test5()
{
    __try {
        Test5foo();
    } __except(1) {
        DbgPrint("Test5: Test5 __except\n");
    }
}

void Test5Seh()
{
    __try {
        SehTest5();
    } __except(1) {
        DbgPrint("Test5: Test5 __except\n");
    }
}

/*********************************** Test  6 *********************************/
void Test6SeTrans( unsigned int u, EXCEPTION_POINTERS*pExp)
{
    B0;
    if (pExp->ExceptionRecord->ExceptionCode == STATUS_INTEGER_OVERFLOW)
        throw b0;
}

void Test6TTrans()
{
    static int i = 0;
    A0;
    try {
        A1;
        SehThrow();
    } catch (B b) {
        if (i == 0) {
            i++;
            Rethrow();
        } else {
            ThrowB();
        }
    }
}

void Test6SehFunc()
{
    __try {
        Test6TTrans();
    } __except(SehFilter(exception_info(), STATUS_INTEGER_OVERFLOW)) {
        DbgPrint("In Test6SehFunc __except\n");
    }
}


void Test6CppFunc()
{
    int i = 0;
    A0;
    try {
        A1;
        Test6SehFunc();
    } catch(B b) {
        A2;
        DbgPrint("Error: Test6CppFunc catch(B b)\n");
        Fail = 1;
    }
    try {
        try {
            A3;
            Test6SehFunc();
        } catch(B b) {
            A4;
            i = 1;
        }
    } catch(...) {
        DbgPrint("Error: Missed catch(B b) in Test6CppFunc\n");
        Fail = 1;
    }
}

void Test6()
{
    __try {
        _set_se_translator(Test6SeTrans);
        Test6CppFunc();
    } __except(1) {
        DbgPrint("Error: Test6 __except\n");
        Fail = 1;
    }
    _set_se_translator(NULL);
}

/*********************************** Test  7 *********************************/

void Test7();

void Test7foo()
{
    static int i = 0;
    A0;
    try {
        if (i == 0) 
            SehThrow();
        else
            Rethrow();
    } catch(...) {
        if (i++ == 0)
            Test7();
        else
            Rethrow();
    }
}

void Test7() {
    static int i = 0;
    int j = i++;
    __try {
        Test7foo();
    } __except(SehFilter(exception_info(), STATUS_INTEGER_OVERFLOW)) {
        if (j == 0) {
            DbgPrint("Error: missed one Except After rethrow\n");
            Fail = 1;
        }
    }
}


/*********************************** Test  8 *********************************/


void Test8()
{
    A0;
    try{
        A1;
        try {
            ThrowB();
        } catch (B b1) {
            try {
                A2;
                throw a2;
            } catch (A a) {
                A3;
            }
            throw;
        }
    } catch (B b2) {
        A4;
    }
                
}
int TestOver()
{
    int i;
    int ret = 0;
    for (i = 0; i < NumMaxB; i++)
    {
        if (BObject[i] > 0) {
            DbgPrint("Error: id#%4d for B not destructed\n", i);
            ret = 1;
        } else if (BObject[i] < 0) {
            DbgPrint("Error: id#%4d for B destructed %d times", i, 1-AObject[i]);
            ret = 1;
        }
        BObject[i] = 0;
    }
    for (i = 0; i < NumMaxA; i++)
    {
        if (AObject[i] > 0) {
            DbgPrint("Error: id#%4d for A not destructed\n", i);
            ret = 1;
        } else if (AObject[i] < 0) {
            DbgPrint("Error: id#%4d for A destructed %d times", i, 1-AObject[i]);
            ret = 1;
        }
        AObject[i] = 0;
    }
    if (Fail) {
        ret = 1;
        Fail = 0;
    }
    A_id = B_id = 0;
    return ret;
}

/*********************************** Test  9 *********************************/

struct TEST9 
{
    int i;
    TEST9() {
        A0;
        i = 0;
    }
    ~TEST9() {
        A0;
        try {
            A1;
            ThrowB();
        } catch (B) {
            A2;
        }
    }
};

void Test9TEST()
{
    TEST9 T;
    ThrowA();
}

void Test9()
{
    A0;
    try {
        A1;
        Test9TEST();
    } catch (A a) {
        A2;
    }
}


main()
{
    int i;

    DbgBreakPoint();

    __try {
        for (i = 0; i < NumTests; i++) {
            switch (i) {
            case 0:
                Test1();
                break;
            case 1:
                Test2();
                break;
            case 2:
                Test3();
                break;
            case 3:
                Test4();
                break;
            case 4:
                Test5();
                DbgPrint("One live B expected\n");
                break;
            case 5:
                Test6();
                break;
            case 6:
                Test7();
                break;
            case 7:
                Test8();
                break;
            case 8:
                Test9();
                break;
            }
            if (TestOver()) {
                DbgPrint("TEST#%2d FAILED\n", i+1);
            } else {
                DbgPrint("TEST#%2d PASSED\n", i+1);
            }
        }
    } __except(DbgBreakPoint()) {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\dskimage\identify.h ===
//
// IDENTIFY data
//

#pragma pack (push,1)
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumCylinders;                    // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumHeads;                        // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT NumSectorsPerTrack;              // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    UCHAR  SerialNumber[20];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81
    USHORT Reserved6[6];                    //     82-87
    USHORT UltraDMASupport : 8;             //     88
    USHORT UltraDMAActive  : 8;             //
    USHORT Reserved7[37];                   //     89-125
    USHORT LastLun:3;                       //     126
    USHORT Reserved8:13;
    USHORT MediaStatusNotification:2;       //     127
    USHORT Reserved9:6;
    USHORT DeviceWriteProtect:1;
    USHORT Reserved10:7;
    USHORT Reserved11[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\cpptest\ihateeh.cxx ===
/*
 *      COMMAND LINE: -Ox -GX
 */

/*

Copyright (c) 1997  Microsoft Corporation

Module Name:

    IhateEH.cxx

Abstract:

    Tests some nasty EH unwinds, throwing from weird ctors and dtors

Author:

    Louis Lafreniere (louisl) 1997

*/


#include <stdlib.h>
#include <stdio.h>


#define FALSE 0
#define TRUE 1
#define NO_CTOR_THROW 1
#define NO_DTOR_THROW 2


int Object[100];
int CurrentObjectNumber, ThrowCount, MaxObjectCount = 1;
int Fail;


void FAIL(int i)
{
    printf("FAILED on %d\n", i);
    Fail++;
}

void dealloc(int i, int no_throw)
{
    /* Make sure i is valid, and object exists */
    if(i<0 || i>=MaxObjectCount || !Object[i]) 
	FAIL(i);

    Object[i] = 0;

    /* Try throw in this dtor.. */
#ifdef TEST_DTOR
    if(i+MaxObjectCount == ThrowCount && !no_throw){
	printf("Throwing\n");
	throw(1);
    }
#endif
}

void alloc(int i, int no_throw)
{
    if(CurrentObjectNumber > MaxObjectCount)
	MaxObjectCount = CurrentObjectNumber;

    /* Object already exists? */
    if(Object[i]) FAIL(i);

    /* Try throw in this ctor.. */
    if(i == ThrowCount && !no_throw){
	printf("Throwing\n");
	throw(1);
    }

    Object[i] = 1;
}

class B
{
  public:
    int i;
    int flag;
    B();
    B(int);
    ~B();
};

B::B()
{
    i = CurrentObjectNumber++;
    printf("B ctor.  i = %d\n", i);
    alloc(i, FALSE);
}

B::B(int f)
{
    i = CurrentObjectNumber++;
    flag = f;
    printf("B ctor.  i = %d\n", i);
    alloc(i, flag==NO_CTOR_THROW);
}

B::~B()
{
    printf("B dtor.  i = %d\n", i);
    dealloc(i, flag==NO_DTOR_THROW);
}

class A
{
  public:
    int i;
    A();
    A(int) 
    {
	i = CurrentObjectNumber++;
	printf("A(int) ctor.  i = %d\n", i);
	alloc(i, FALSE);
    }
    A operator+(A a);
    A(const A &a)
    {
	/* Try objects in ctor */
	B b1 = NO_DTOR_THROW, b2 = NO_DTOR_THROW;

	i = CurrentObjectNumber++;
	printf("A copy ctor.  i = %d\n", i);
	alloc(i, FALSE);
    }

    ~A(){
	/* Try objects in dtor */
	B b1 = NO_CTOR_THROW, b2 = NO_CTOR_THROW;

	printf("A dtor.  i = %d\n", i);
	dealloc(i, FALSE);
    };
};

A::A()
{
    i=CurrentObjectNumber++;
    printf("A ctor.  i = %d\n", i);
    alloc(i, FALSE);
}

A A::operator+(A a)
{
    printf("A%d + A%d\n", i, a.i);
    return A();
}
    
A foo(A a1, A a2)
{ 
    return a1+a2; 
};

A test()
{
    /* Try simple ctor */
    A a1;

    /* Try question op ctor */
    A a2 = (ThrowCount & 1) ? A() : ThrowCount;

    /* try mbarg copy ctors, and return UDT */
    A a3 = foo(a1, a3);

    /* Try temporary expressions, and return UDT */
    return a1 + A() + a2 + a3;
}

void main()
{
    int i;

    /* Call test(), with a different ctor/dtor throwing each time */
    for(ThrowCount = 0; ThrowCount < MaxObjectCount*2; ThrowCount++)  {

	printf("ThrowCount = %d   MaxObjectCount = %d\n", ThrowCount, MaxObjectCount);

	CurrentObjectNumber = 0;

	try {
	    test();
	}catch(int){
	    printf("In catch\n");
	}

	/* Any objects which didn't get dtor'd? */
	for(i = 0; i < MaxObjectCount; i++) {
	    if(Object[i]) {
		FAIL(i);
		Object[i] = 0;
	    }
	}

	printf("\n");
    }

    printf("\n");
    if(Fail)
	printf("FAILED %d tests\n", Fail);
    else
	printf("Passed\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\cpptest\ehtry.cxx ===
/*
    COMMAND LINE: -Ox -GX
    DESCRIPTION: test some weird EH flow.
*/


#include <stdio.h>

int i;

class C
{
  public:
    C(char *s) { printf("Constructing %s0\n", s); str = s; inst = 0; }
    C(const C &c) { 
                    str = c.str;
                    inst = c.inst + 1;
		    printf("Copying %s%d from %s%d\n", c.str, c.inst, str, inst); 
                  }
    ~C() { printf("Destructing %s%d\n", str, inst); str = NULL; }
    char * str;
    int inst;
};

void foo()
{
    C f("InFoo");

    i++;

    if(i&1)
        throw(f);
}

void bar()
{
    C b("InBar");

    i++;

    if(i&3)
        throw(b);
}

void nothing()
{
}

/* CRT implementation gives a different destruction order if bar is being 
   inlined.. */
#pragma inline_depth(0)
C test()
{
    C c1("c1");

    try{
        C c2("c2");
        if(i){
            try{
                C c3("c3");
                foo();
                return c3;
            }catch(C c4){
		printf("Caught %s%d\n", c4.str, c4.inst);
                C c5("c5");
                bar();
                return c5;
            }
        }
        foo();
    }catch(C &c6){
	printf("Caught %s%d\n", c6.str, c6.inst);
        nothing();
    }
    nothing();
    return c1;
}
#pragma inline_depth()

int main()
{
    printf("i = %d\n", i);
    test();
    printf("i = %d\n", i);
    test();
    printf("i = %d\n", i);
    test();
    printf("i = %d\n", i);
    test();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\dskimage\dskimage.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <ntddvol.h>
#include <ntdddisk.h>
#include <align.h>
#include <bootmbr.h>
#include "identify.h"

#define SECTOR_SIZE 512
#define SECTOR_MASK (SECTOR_SIZE - 1)

#define BOOTSECT_SECTORS 16
#define BOOTSECT_SIZE (BOOTSECT_SECTORS * SECTOR_SIZE)

#define MAX_NUM_CHS_ADDRESSABLE_SECTORS 16514064

#define NTLDR_FIND    L"NTLDR"
#define NTLDR_REPLACE L"$LDR$"
#define NTLDR_LEN     (sizeof(NTLDR_FIND)-sizeof(WCHAR))

//
// Perform the copy using 8 outstanding I/Os of 128k each
//

#define COPYBUF_SIZE (128 * 1024)
#define COPYBUF_COUNT 8

//
// A failed assert will abort the process
//

#define assert(x) if (!(x)) { printf("Assert failed: %s\n", #x); exit(-1); }

typedef struct _COPYBUF {
    OVERLAPPED Overlapped;
    ULONG State;
    ULONG Bytes;
    PVOID Buffer;
} COPYBUF, *PCOPYBUF;

//
// Three possible states for a copybuf
//

#define CB_FREE  0x0
#define CB_READ  0x1
#define CB_WRITE 0x2

//
// CUSTOM_IDENTIFY_DATA consists of an IDENTIFY_DATA structure,
// along with three fields in which to pass along the "BIOS" disk
// geometry to the SIMICS simulator.
//

#pragma pack(push,1)

typedef union _CUSTOM_IDENTIFY_DATA {
    IDENTIFY_DATA IdentifyData;
    struct {
        USHORT Reserved[128];
        ULONG  Cylinders;
        USHORT Heads;
        USHORT SectorsPerTrack;
    } BiosData;
} CUSTOM_IDENTIFY_DATA, *PCUSTOM_IDENTIFY_DATA;

#pragma pack(pop)

BOOLEAN
DisplayDiskGeometry(
    IN HANDLE handle
    );

VOID
DoWrite (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG64 Offset,
    IN PCOPYBUF CopyBuf
    );

VOID
GetBootSectors (
    IN LARGE_INTEGER Offset
    );

BOOLEAN
GetIdentifyData(
               IN HANDLE Handle,
               OUT PIDENTIFY_DATA IdentifyData
               );

BOOLEAN
GetVolumeInfo (
    IN PCHAR DrivePath,
    OUT PULONG DriveNumber,
    OUT PULONG PartitionNumber,
    OUT PULONG64 StartingOffset,
    OUT PULONG64 ExtentLength
    );

VOID
InitializeCopyBuffers (
    VOID
    );

VOID
MassageIdentifyData(
    VOID
    );

VOID
ProcessCompletedCopy (
    PCOPYBUF CopyBuf
    );

BOOL
ScanCopyBuffers (
    VOID
    );

VOID
StartRead (
    IN OUT PCOPYBUF CopyBuf
    );

VOID
StartWrite (
    IN OUT PCOPYBUF CopyBuf
    );

VOID
WriteMBRCode(
    IN PUCHAR FilePath
    );

//
// Global data declarations follow
//

COPYBUF CopyBufArray[COPYBUF_COUNT];

//
//  Identifies the PhysicalDrive.
//

INT gDeviceNumber;

//
// Identifies the position of the drive on the controller
// ie. master == 0, slave == 1.
//

UCHAR gDriveNumber = 1;

HANDLE DriveHandle;
HANDLE FileHandle;

//
// CopyOffset is the byte offset between data on the source disk image and
// corresponding data in the output file.  This is used to account for the
// sector-sized prefix in the output file.
//

ULONG CopyOffset;

ULONG64 CurrentOffset;
ULONG64 DriveSize;
ULONG64 MaxSize;
UCHAR PercentComplete;
ULONG OutstandingIo;

IDENTIFY_DATA IdentifyData;
DISK_GEOMETRY DiskGeometry;

//
// Array of event handles, one per copy buffer
//

HANDLE IoEvents[COPYBUF_COUNT];

int
_cdecl main (
            int argc,
            char *argv[]
            )
{
 
    char deviceBuffer[20];
    PCHAR outputFileName;
    PCHAR drive;
    PCHAR options;
    BOOLEAN result;
    BOOLEAN writeBootSect;
    ULONG64 volumeOffset;
    ULONG64 volumeSize;
    ULONG partitionNumber;
    DWORD waitResult;
    PCOPYBUF copyBuf;
    ULONG i;
    ULONG openAttributes;

    writeBootSect = FALSE;
 
    //
    // Must be invoked with two arguments
    // 
 
    if (argc != 3 && argc != 4) {
        fprintf(stderr,
                "Usage: %s <drive:> <OutputFile> [/b]\n",
                argv[0]);
        exit(1);
    }
 
    InitializeCopyBuffers();
 
    //
    // Extract arguments
    // 
 
    drive = argv[1];
    outputFileName = argv[2];
 
    result = GetVolumeInfo(drive,
                           &gDeviceNumber,
                           &partitionNumber,
                           &volumeOffset,
                           &volumeSize);
 
    if (result == FALSE) {
        exit(1);
    }

    if (argc == 4) {
        options = argv[3];
        if (_stricmp(options, "/b") != 0) {
            fprintf(stderr, "Invalid option %s specified\n",options);
            exit(1);
        }

        writeBootSect = TRUE;
    }
 
    //
    // Calculate how many sectors need to be in the image
    //
 
    MaxSize = (volumeOffset + volumeSize + SECTOR_MASK) / SECTOR_SIZE;
 
    sprintf(deviceBuffer,"\\\\.\\PhysicalDrive%d",
            gDeviceNumber);

    openAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING;
    if (writeBootSect == FALSE) {
        openAttributes |= FILE_FLAG_OVERLAPPED;
    }
 
    //
    // Open the physical source drive.
    //
 
    DriveHandle = CreateFile(deviceBuffer,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             openAttributes,
                             NULL);
 
    if (INVALID_HANDLE_VALUE == DriveHandle){
        printf("Couldn't open: %s. Drive may not exist. ",
               deviceBuffer);
        return -1;
    }
 
    //
    // Retrieve and display the BIOS disk geometry
    //
 
    result = DisplayDiskGeometry( DriveHandle );
    if (result == FALSE) {
        printf("Could not retrieve disk geometry\n");
        exit(1);
    }
 
    //
    // Reteive the identify data, if possible.  If the data could not be
    // retrieved, MassageIdentifyData() will attempt to fabricate the relevant
    // portions based on the BIOS disk geometry retrieved previously.
    //
 
    GetIdentifyData( DriveHandle,
                     &IdentifyData );
    MassageIdentifyData();
 
    DriveSize = IdentifyData.UserAddressableSectors * (ULONGLONG)512;
    if (MaxSize == 0) {
        MaxSize = DriveSize;
    } else {
        MaxSize *= 512;
    }
    printf("Drive size %dMB\n",(ULONG)(DriveSize / (1024 * 1024)));
    printf("Image size %dMB\n",(ULONG)(MaxSize / (1024 * 1024)));
 
    //
    // Open the output file
    //
 
    FileHandle = CreateFile(outputFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            openAttributes,
                            NULL);
    if (FileHandle == INVALID_HANDLE_VALUE) {
        printf("Could not create %s\n", outputFileName);
        return -1;
    }

    if (writeBootSect != FALSE) {

        //
        // We're just creating bootsect.dat.
        // 

        LARGE_INTEGER offset;

        offset.QuadPart = volumeOffset;
        GetBootSectors(offset);
        goto closeHandles;
    }
 
    //
    // Write the identify data
    //
 
    CopyOffset = 0;
    CurrentOffset = 0;
 
    DoWrite(&IdentifyData,
            sizeof(IDENTIFY_DATA),
            0,
            &CopyBufArray[0]);
 
 
    //
    // Kick off reads on all of the remaining copy buffers
    //
 
    CopyOffset = sizeof(IDENTIFY_DATA);
    for (i = 1; i < COPYBUF_COUNT; i++) {
        StartRead(&CopyBufArray[i]);
    }

    //
    // Loop, processing completed I/O as appropriate.  When all
    // outstanding io has completed, the copy is complete.
    // 
 
    do {
 
        waitResult = WaitForMultipleObjects( COPYBUF_COUNT,
                                             IoEvents,
                                             FALSE,
                                             INFINITE );

        waitResult -= WAIT_OBJECT_0;
        assert(waitResult < COPYBUF_COUNT);
 
        copyBuf = &CopyBufArray[waitResult];
        ProcessCompletedCopy(copyBuf);

    } while (OutstandingIo > 0);

closeHandles:

    //
    // The copy is finished.
    // 

    printf("%s created\n", outputFileName);
 
    CloseHandle(DriveHandle);
    CloseHandle(FileHandle);

#if 0
    if (writeBootSect == FALSE) {

        //
        // Write the MBR code into the output image
        // 
    
        WriteMBRCode(outputFileName);
    }
#endif
 
    return 0;
}


VOID
InitializeCopyBuffers (
    VOID
    )
{
    ULONG bytes;
    PCOPYBUF copyBuf;
    PCOPYBUF copyBufEnd;
    ULONG i;
    HANDLE event;

    PCHAR copyBuffer;

    //
    // Make a single, sector-aligned allocation to contain all of the copy
    // buffers
    //

    bytes = COPYBUF_SIZE * COPYBUF_COUNT + SECTOR_MASK;
    copyBuffer = malloc(bytes);
    if (copyBuffer == NULL) {
        printf("Out of memory\n");
        exit(-1);
    }

    copyBuffer =
        (PCHAR)(((ULONG_PTR)copyBuffer + SECTOR_MASK) & ~SECTOR_MASK);

    //
    // Walk the copyBuf array, initializing each to point to it's portion of
    // the copy buffer
    // 

    copyBuf = CopyBufArray;

    for (i = 0; i < COPYBUF_COUNT; i++) {

        copyBuf->State = CB_FREE;
        copyBuf->Buffer = copyBuffer;

        event = CreateEvent( NULL,
                             FALSE,
                             FALSE,
                             NULL );
        assert(event != NULL);
        copyBuf->Overlapped.hEvent = event;
        IoEvents[i] = event;

        copyBuffer += COPYBUF_SIZE;
        copyBuf++;
    }
}

BOOLEAN
GetVolumeInfo (
    IN PCHAR DrivePath,
    OUT PULONG DriveNumber,
    OUT PULONG PartitionNumber,
    OUT PULONG64 StartingOffset,
    OUT PULONG64 ExtentLength
    )
{
    char deviceBuffer[20];
    HANDLE volumeHandle;
    BOOL result;
    STORAGE_DEVICE_NUMBER deviceNumber;
    PARTITION_INFORMATION partitionInformation;
    ULONG bytesReturned;

    //
    // Determine which physical drive contains the specified partition by
    //
    // - Opening the volume
    //
    // - Sending IOCTL_STORAGE_GET_DEVICE_NUMBER to retrieve the device and
    //   partition number
    //
    // - Sending IOCTL_DISK_GET_PARTITION_INFO to retrieve the starting
    //   offset and length of the volume
    //
    // - Closing the volume
    //

    sprintf(deviceBuffer, "\\\\.\\%s", DrivePath);

    volumeHandle = CreateFile(deviceBuffer,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL |
                                  FILE_FLAG_NO_BUFFERING |
                                  FILE_FLAG_OVERLAPPED,
                              NULL);

    if (volumeHandle == INVALID_HANDLE_VALUE) {
        printf("Error %d opening %s\n", GetLastError(), deviceBuffer);
        return FALSE;
    }

    result = DeviceIoControl(volumeHandle,
                             IOCTL_STORAGE_GET_DEVICE_NUMBER,
                             NULL,
                             0,
                             &deviceNumber,
                             sizeof(deviceNumber),
                             &bytesReturned,
                             NULL);
    if (result == FALSE) {

        printf("Could not get device number for %s\n", deviceBuffer);
        CloseHandle(volumeHandle);
        return FALSE;
    }

    if (deviceNumber.DeviceType != FILE_DEVICE_DISK) {
        printf("%s is not a disk\n",deviceBuffer);
        CloseHandle(volumeHandle);
        return FALSE;
    }

    bytesReturned = 0;
    result = DeviceIoControl(volumeHandle,
                             IOCTL_DISK_GET_PARTITION_INFO,
                             NULL,
                             0,
                             &partitionInformation,
                             sizeof(partitionInformation),
                             &bytesReturned,
                             NULL);
    CloseHandle(volumeHandle);
    if (result == FALSE) {
        printf("Error %d retrieving partition information for %s\n",
               GetLastError(),
               deviceBuffer);
        return FALSE;
    }

    //
    // All of the information was successfully retrieved.  Fill in the
    // output parameters and return.
    //  

    *DriveNumber = deviceNumber.DeviceNumber;
    *PartitionNumber = deviceNumber.PartitionNumber;
    *StartingOffset = partitionInformation.StartingOffset.QuadPart;
    *ExtentLength = partitionInformation.PartitionLength.QuadPart;

    return TRUE;
}

BOOLEAN
GetIdentifyData(
               IN HANDLE Handle,
               OUT PIDENTIFY_DATA IdentifyData
               )
{

    SENDCMDINPARAMS inputParams;
    PSENDCMDOUTPARAMS outputParams;
    PIDENTIFY_DATA    identifyData;
    ULONG bytesReturned;
    ULONG bufSize;
 
    ZeroMemory(&inputParams, sizeof(SENDCMDINPARAMS));
 
    bufSize = sizeof(SENDCMDOUTPARAMS) - 1 + IDENTIFY_BUFFER_SIZE;
    bufSize *= 2;
 
    outputParams = (PSENDCMDOUTPARAMS) malloc(bufSize);
    if (!outputParams) {
        printf("Out of memory\n");
        return FALSE;
    }
 
    ZeroMemory(outputParams, bufSize);
 
    //
    // Build register structure to send SMART command.
    //
 
    inputParams.irDriveRegs.bFeaturesReg     = 0;
    inputParams.irDriveRegs.bSectorCountReg  = 1;
    inputParams.irDriveRegs.bSectorNumberReg = 1;
    inputParams.irDriveRegs.bCylLowReg       = 0;
    inputParams.irDriveRegs.bCylHighReg      = 0;
    inputParams.irDriveRegs.bDriveHeadReg    = 0xA0 | ((gDriveNumber & 1) << 4);
    inputParams.irDriveRegs.bCommandReg      = ID_CMD; 
 
    bytesReturned = 0;
 
    if (!DeviceIoControl (Handle,
                          SMART_RCV_DRIVE_DATA,
                          &inputParams,
                          sizeof(SENDCMDINPARAMS) - 1,
                          outputParams,
                          bufSize,
                          &bytesReturned,
                          NULL)) {
        printf("IDE_IDENTIFY failed with 0x%x, %d bytes returned\n",
               GetLastError(),
               bytesReturned);
        
        printf("WARNING: This image file will work with the SIMICS simulator\n"
               "         but not simnow.\n");
        
        memset(IdentifyData, 0, sizeof(IDENTIFY_DATA));
        free(outputParams);
        return FALSE;
    }
 
    identifyData = (PIDENTIFY_DATA)outputParams->bBuffer;
    *IdentifyData = *identifyData;
 
    free(outputParams);
    return TRUE;
}

VOID
MassageIdentifyData(
    VOID
    )

/*++

Routine Description:

    This routine sets the bios CHS geometry in the IdentifyData structure
    in a place previously agreed upon with Simics.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PCUSTOM_IDENTIFY_DATA custom;
    ULONG sectorCount;

    USHORT ideCylinders;
    USHORT ideHeads;
    USHORT ideSectorsPerTrack;

    C_ASSERT(FIELD_OFFSET(IDENTIFY_DATA,NumCylinders)/2 == 1);
    C_ASSERT(FIELD_OFFSET(IDENTIFY_DATA,NumHeads)/2 == 3);
    C_ASSERT(FIELD_OFFSET(IDENTIFY_DATA,NumSectorsPerTrack)/2 == 6);
    C_ASSERT(FIELD_OFFSET(IDENTIFY_DATA,CurrentSectorCapacity)/2 == 57);

    //
    // Set the BIOS disk geometry in the new fields that are passed
    // along to the SIMICS simulator.
    // 

    custom = (PCUSTOM_IDENTIFY_DATA)&IdentifyData;
    custom->BiosData.Cylinders = DiskGeometry.Cylinders.LowPart;
    custom->BiosData.Heads = (USHORT)DiskGeometry.TracksPerCylinder;
    custom->BiosData.SectorsPerTrack = (USHORT)DiskGeometry.SectorsPerTrack;

    if (IdentifyData.NumCylinders == 0) {

        //
        // The IDENTIFY_DATA ioctl failed (SMART isn't supported), so parts
        // of the IDE geometry must be fabricated, including:
        //
        // - NumCylinders
        // - NumHeads
        // - NumSectorsPerTrack
        // - CurrentSectorCapacity
        // - UserAddressableSectors
        //

        sectorCount = DiskGeometry.Cylinders.LowPart *
                      DiskGeometry.TracksPerCylinder *
                      DiskGeometry.SectorsPerTrack;
    
        if (sectorCount > MAX_NUM_CHS_ADDRESSABLE_SECTORS) {

            IdentifyData.NumCylinders = 16383;
            IdentifyData.NumHeads = 16;
            IdentifyData.NumSectorsPerTrack = 63;

        } else {

            IdentifyData.NumSectorsPerTrack =
                (USHORT)DiskGeometry.SectorsPerTrack;
                
            IdentifyData.NumHeads = 16;

            IdentifyData.NumCylinders = (USHORT)
                (sectorCount / (IdentifyData.NumSectorsPerTrack *
                               IdentifyData.NumHeads));
        }

        IdentifyData.CurrentSectorCapacity = sectorCount;
        IdentifyData.UserAddressableSectors = sectorCount;
    }

    printf("IDE disk geometry:\n"
           "  Cyls    %d\n"
           "  Heads   %d\n"
           "  Sct/Trk %d\n\n"
           "BIOS disk geometry:\n"
           "  Cyls    %d\n"
           "  Heads   %d\n"
           "  Sct/Trk %d\n",

           IdentifyData.NumCylinders,
           IdentifyData.NumHeads,
           IdentifyData.NumSectorsPerTrack,

           custom->BiosData.Cylinders,
           custom->BiosData.Heads,
           custom->BiosData.SectorsPerTrack);
}


VOID
DoWrite (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG64 Offset,
    IN PCOPYBUF CopyBuf
    )
{
    LARGE_INTEGER offset;
    BOOL result;

    offset.QuadPart = Offset;

    CopyBuf->Overlapped.Offset = offset.HighPart;
    CopyBuf->Overlapped.OffsetHigh = offset.LowPart;
    CopyBuf->State = CB_READ;

    memcpy(CopyBuf->Buffer,Buffer,Length);
    CopyBuf->Bytes = Length;

    StartWrite(CopyBuf);
}

VOID
StartWrite (
    IN OUT PCOPYBUF CopyBuf
    )
{
    LARGE_INTEGER offset;
    BOOL result;
    ULONG error;

    CopyBuf->State = CB_WRITE;

    //
    // Adjust the offset
    //

    offset.LowPart = CopyBuf->Overlapped.Offset;
    offset.HighPart = CopyBuf->Overlapped.OffsetHigh;
    offset.QuadPart += CopyOffset;
    CopyBuf->Overlapped.Offset = offset.LowPart;
    CopyBuf->Overlapped.OffsetHigh = offset.HighPart;

    result = WriteFile( FileHandle,
                        CopyBuf->Buffer,
                        CopyBuf->Bytes,
                        NULL,
                        &CopyBuf->Overlapped );
    if (result == FALSE) {
        error = GetLastError();
        if (error != ERROR_IO_PENDING &&
            error != ERROR_IO_INCOMPLETE) {

            printf("Error %d returned from write\n",error);
            exit(-1);
        }
    }

    OutstandingIo += 1;
}

VOID
StartRead (
    IN OUT PCOPYBUF CopyBuf
    )
{
    LARGE_INTEGER offset;
    BOOL result;
    ULONG64 length;
    ULONG error;

    if (CurrentOffset == MaxSize) {
        return;
    }

    length = MaxSize - CurrentOffset;
    if (length > COPYBUF_SIZE) {
        length = COPYBUF_SIZE;
    }

    CopyBuf->State = CB_READ;

    offset.QuadPart = CurrentOffset;
    CurrentOffset += length;

    CopyBuf->Overlapped.Offset = offset.LowPart;
    CopyBuf->Overlapped.OffsetHigh = offset.HighPart;

    result = ReadFile( DriveHandle,
                       CopyBuf->Buffer,
                       (ULONG)length,
                       NULL,
                       &CopyBuf->Overlapped );

    if (result == FALSE) {
        error = GetLastError();
        if (error != ERROR_IO_PENDING &&
            error != ERROR_IO_INCOMPLETE) {

            printf("Error %d returned from read\n",error);
            exit(-1);
        }
    }

    OutstandingIo += 1;
}

BOOLEAN
DisplayDiskGeometry(
    IN HANDLE handle
    )
{
    BOOL result;
    ULONG bytesReturned;

    result = DeviceIoControl(handle,
                             IOCTL_DISK_GET_DRIVE_GEOMETRY,
                             NULL,
                             0,
                             &DiskGeometry,
                             sizeof(DiskGeometry),
                             &bytesReturned,
                             NULL);
    if (result == FALSE) {
        return FALSE;
    }

    printf("%I64d Cylinders %d Heads %d Sectors/Track\n",
            DiskGeometry.Cylinders.QuadPart,
            DiskGeometry.TracksPerCylinder,
            DiskGeometry.SectorsPerTrack);

    return TRUE;
}

VOID
ProcessCompletedCopy (
    PCOPYBUF CopyBuf
    )
{
    UCHAR percent;
    HANDLE handle;
    BOOL result;

    //
    // Decrement the outstanding Io count.  Successfully starting another
    // read or write will increment it again.
    //

    OutstandingIo -= 1;

    //
    // We have found a buffer with either a read or a write in progress.
    // Retrieve the number of bytes transferred.
    // 

    if (CopyBuf->State == CB_READ) {
        handle = DriveHandle;
    } else {
        handle = FileHandle;
    }

    result = GetOverlappedResult( handle,
                                  &CopyBuf->Overlapped,
                                  &CopyBuf->Bytes,
                                  FALSE );
    assert(result != FALSE);

    if (CopyBuf->State == CB_READ) {

        //
        // This buffer contains data read from the drive, kick off a write
        // to the output file.
        //

        StartWrite(CopyBuf);

    } else {

        //
        // This buffer represents data that has been written to the drive.
        // Use it to start another read.
        //

        percent = (UCHAR)((CurrentOffset * 100) / MaxSize);
        if (percent != PercentComplete) {
            printf("%d%%\r",percent);
            PercentComplete = percent;
        }

        StartRead(CopyBuf);
    }
}

VOID
GetBootSectors (
    IN LARGE_INTEGER VolumeOffset
    )

/*++

 Routine Description:

    Reads the first BOOT_SECT sectors from the cmd-line-supplied volume,
    searches for NTLDR and replaces with $LDR$, and writes the sectors
    to the output file.

 Arguments:

    VolumeOffset - Physical disk offset of the start of the boot sectors

 Return Value:

    None.  Program is aborted on failure.

--*/

{
    UCHAR buffer[ BOOTSECT_SIZE + SECTOR_SIZE - 1 ];
    OVERLAPPED overlapped;
    PUCHAR sectorData;
    ULONG bytesTransferred;
    PCHAR search;
    BOOL result;

    //
    // Read the boot sectors into sectorData
    //  

    sectorData = ROUND_UP_POINTER(buffer,SECTOR_SIZE);
    RtlZeroMemory(&overlapped,sizeof(overlapped));

    overlapped.Offset = VolumeOffset.LowPart;
    overlapped.OffsetHigh = VolumeOffset.HighPart;

    result = ReadFile(DriveHandle,
                      sectorData,
                      BOOTSECT_SIZE,
                      &bytesTransferred,
                      &overlapped);
    if (result == FALSE || bytesTransferred != BOOTSECT_SIZE) {
        fprintf(stderr,
                "Error %d reading boot sectors\n",
                GetLastError());
        exit(1);
    }

    //
    // Find "NTLDR" and replace it with "$LDR$".  The magic numbers here
    // came directly from code in setup... start the search at offset 1024
    // and work backwards, giving up if not found by offset 62.
    //

    search = sectorData + 1024 - NTLDR_LEN;
    while (TRUE) {

        if (memcmp(search,NTLDR_FIND,NTLDR_LEN) == 0) {

            //
            // Found it.  Copy $LDR$ in instead.
            //

            memcpy(search,NTLDR_REPLACE,NTLDR_LEN);
            break;
        }

        search -= sizeof(WCHAR);
        if (search == (sectorData + 62)) {

            //
            // Couldn't find the string, give up
            //

            fprintf(stderr,"Couldn't find NTLDR string\n");
            exit(1);
        }
    }

    RtlZeroMemory(&overlapped,sizeof(overlapped));
    overlapped.Offset = 0;

    result = WriteFile(FileHandle,
                       sectorData,
                       BOOTSECT_SECTORS * SECTOR_SIZE,
                       &bytesTransferred,
                       &overlapped);
    if (result == FALSE) {
        fprintf(stderr,
                "Error %d reading boot sectors\n",
                GetLastError());
        exit(1);
    }
}

VOID
WriteMBRCode(
    IN PUCHAR FilePath
    )
{
    HANDLE handle;
    BOOL result;
    DWORD bytesWritten;

    handle = CreateFile(FilePath,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (handle == INVALID_HANDLE_VALUE) {
        fprintf(stderr,"Error %d opening %s\n", GetLastError(),FilePath);
        exit(1);
    }

    result = WriteFile(handle,
                       x86BootCode,
                       440,
                       &bytesWritten,
                       NULL);
    if (result == FALSE) {
        fprintf(stderr,"Error %d writing MBR code\n", GetLastError());
        exit(1);
    }

    CloseHandle(handle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\dvdauth\dvdauth.c ===
int dDVDHIL_M2IA_CreateSurface(void)
{
    return -1;
}

int dDVDHIL_M2IA_DestroySurface(void)
{
    return -1;
}

int dDVDHIL_M2IA_Lock(void)
{
    return -1;
}

int dDVDHIL_M2IA_Unlock(void)
{
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\msdasc\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( msdasc )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( msdasc ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\mqlogmgr\mqlogmgr.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    hlink.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 1-Mar-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}

//STUBFUNC(?CreateInstance@CLogMgr@@SAJPEAPEAV1@PEAUIUnknown@@@Z
//STUBFUNC(?DllGetDTCLOG@@YAHAEBU_GUID@@0PEAPEAX@Z
STUBFUNC(DllGetClassObject)
STUBFUNC(DllRegisterServer)
STUBFUNC(DllUnregisterServer)
STUBFUNC(DynCanUseCompareExchange64)
STUBFUNC(DynCoGetInterceptor)
STUBFUNC(DynComPs_CStdStubBuffer_AddRef)
STUBFUNC(DynComPs_CStdStubBuffer_Connect)
STUBFUNC(DynComPs_CStdStubBuffer_CountRefs)
STUBFUNC(DynComPs_CStdStubBuffer_DebugServerQueryInterface)
STUBFUNC(DynComPs_CStdStubBuffer_DebugServerRelease)
STUBFUNC(DynComPs_CStdStubBuffer_Disconnect)
STUBFUNC(DynComPs_CStdStubBuffer_Invoke)
STUBFUNC(DynComPs_CStdStubBuffer_IsIIDSupported)
STUBFUNC(DynComPs_CStdStubBuffer_QueryInterface)
STUBFUNC(DynComPs_IUnknown_AddRef_Proxy)
STUBFUNC(DynComPs_IUnknown_QueryInterface_Proxy)
STUBFUNC(DynComPs_IUnknown_Release_Proxy)
STUBFUNC(DynComPs_NdrCStdStubBuffer_Release)
STUBFUNC(DynComPs_NdrDllCanUnloadNow)
STUBFUNC(DynComPs_NdrDllGetClassObject)
STUBFUNC(DynComPs_NdrDllRegisterProxy)
STUBFUNC(DynComPs_NdrDllUnregisterProxy)
STUBFUNC(DynCreateFileW)
STUBFUNC(DynCreateProcessW)
STUBFUNC(DynDeleteFileW)
STUBFUNC(DynGetCommandLineW)
STUBFUNC(DynGetComputerNameW)
STUBFUNC(DynGetDiskFreeSpaceW)
STUBFUNC(DynGetDriveTypeW)
STUBFUNC(DynGetEnvironmentVariableW)
STUBFUNC(DynGetFileAttributesW)
STUBFUNC(DynGetLocaleInfoW)
STUBFUNC(DynGetModuleFileNameW)
STUBFUNC(DynGetModuleHandleW)
STUBFUNC(DynGetSystemDirectoryW)
STUBFUNC(DynLoadStringW)
STUBFUNC(DynMessageBoxW)
STUBFUNC(DynRegConnectRegistryW)
STUBFUNC(DynRegCreateKeyExW)
STUBFUNC(DynRegCreateKeyW)
STUBFUNC(DynRegDeleteKeyW)
STUBFUNC(DynRegDeleteValueW)
STUBFUNC(DynRegEnumKeyExW)
STUBFUNC(DynRegEnumKeyW)
STUBFUNC(DynRegEnumValueW)
STUBFUNC(DynRegOpenKeyExW)
STUBFUNC(DynRegOpenKeyW)
STUBFUNC(DynRegQueryInfoKeyW)
STUBFUNC(DynRegQueryValueExW)
STUBFUNC(DynRegQueryValueW)
STUBFUNC(DynRegSetValueExW)
STUBFUNC(DynSetFileAttributesW)
STUBFUNC(DynlstrcmpW)
STUBFUNC(DynlstrcmpiW)
STUBFUNC(DynlstrcpyW)
STUBFUNC(DynlstrcpynW)
STUBFUNC(DynlstrlenW)
STUBFUNC(DynwsprintfW)
STUBFUNC(g_fDTCWin95Present)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\msxml2\msxml2_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for msxml2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSXML2,0xf5078f18,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMImplementation,0x2933BF8F,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNode,0x2933BF80,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocumentFragment,0x3efaa413,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocument,0x2933BF81,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMSchemaCollection,0x373984c8,0xb845,0x449b,0x91,0xe7,0x45,0xac,0x83,0x03,0x6a,0xde);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocument2,0x2933BF95,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNodeList,0x2933BF82,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNamedNodeMap,0x2933BF83,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMCharacterData,0x2933BF84,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMAttribute,0x2933BF85,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMElement,0x2933BF86,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMText,0x2933BF87,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMComment,0x2933BF88,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMProcessingInstruction,0x2933BF89,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMCDATASection,0x2933BF8A,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocumentType,0x2933BF8B,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNotation,0x2933BF8C,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMEntity,0x2933BF8D,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMEntityReference,0x2933BF8E,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMParseError,0x3efaa426,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXTLRuntime,0x3efaa425,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXSLTemplate,0x2933BF93,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXSLProcessor,0x2933BF92,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_ISAXXMLReader,0xa4f96ed0,0xf829,0x476e,0x81,0xc0,0xcd,0xc7,0xbd,0x2a,0x08,0x02);


MIDL_DEFINE_GUID(IID, IID_ISAXXMLFilter,0x70409222,0xca09,0x4475,0xac,0xb8,0x40,0x31,0x2f,0xe8,0xd1,0x45);


MIDL_DEFINE_GUID(IID, IID_ISAXLocator,0x9b7e472a,0x0de4,0x4640,0xbf,0xf3,0x84,0xd3,0x8a,0x05,0x1c,0x31);


MIDL_DEFINE_GUID(IID, IID_ISAXEntityResolver,0x99bca7bd,0xe8c4,0x4d5f,0xa0,0xcf,0x6d,0x90,0x79,0x01,0xff,0x07);


MIDL_DEFINE_GUID(IID, IID_ISAXContentHandler,0x1545cdfa,0x9e4e,0x4497,0xa8,0xa4,0x2b,0xf7,0xd0,0x11,0x2c,0x44);


MIDL_DEFINE_GUID(IID, IID_ISAXDTDHandler,0xe15c1baf,0xafb3,0x4d60,0x8c,0x36,0x19,0xa8,0xc4,0x5d,0xef,0xed);


MIDL_DEFINE_GUID(IID, IID_ISAXErrorHandler,0xa60511c4,0xccf5,0x479e,0x98,0xa3,0xdc,0x8d,0xc5,0x45,0xb7,0xd0);


MIDL_DEFINE_GUID(IID, IID_ISAXLexicalHandler,0x7f85d5f5,0x47a8,0x4497,0xbd,0xa5,0x84,0xba,0x04,0x81,0x9e,0xa6);


MIDL_DEFINE_GUID(IID, IID_ISAXDeclHandler,0x862629ac,0x771a,0x47b2,0x83,0x37,0x4e,0x68,0x43,0xc1,0xbe,0x90);


MIDL_DEFINE_GUID(IID, IID_ISAXAttributes,0xf078abe1,0x45d2,0x4832,0x91,0xea,0x44,0x66,0xce,0x2f,0x25,0xc9);


MIDL_DEFINE_GUID(IID, IID_IVBSAXXMLReader,0x8c033caa,0x6cd6,0x4f73,0xb7,0x28,0x45,0x31,0xaf,0x74,0x94,0x5f);


MIDL_DEFINE_GUID(IID, IID_IVBSAXXMLFilter,0x1299eb1b,0x5b88,0x433e,0x82,0xde,0x82,0xca,0x75,0xad,0x4e,0x04);


MIDL_DEFINE_GUID(IID, IID_IVBSAXLocator,0x796e7ac5,0x5aa2,0x4eff,0xac,0xad,0x3f,0xaa,0xf0,0x1a,0x32,0x88);


MIDL_DEFINE_GUID(IID, IID_IVBSAXEntityResolver,0x0c05d096,0xf45b,0x4aca,0xad,0x1a,0xaa,0x0b,0xc2,0x55,0x18,0xdc);


MIDL_DEFINE_GUID(IID, IID_IVBSAXContentHandler,0x2ed7290a,0x4dd5,0x4b46,0xbb,0x26,0x4e,0x41,0x55,0xe7,0x7f,0xaa);


MIDL_DEFINE_GUID(IID, IID_IVBSAXDTDHandler,0x24fb3297,0x302d,0x4620,0xba,0x39,0x3a,0x73,0x2d,0x85,0x05,0x58);


MIDL_DEFINE_GUID(IID, IID_IVBSAXErrorHandler,0xd963d3fe,0x173c,0x4862,0x90,0x95,0xb9,0x2f,0x66,0x99,0x5f,0x52);


MIDL_DEFINE_GUID(IID, IID_IVBSAXLexicalHandler,0x032aac35,0x8c0e,0x4d9d,0x97,0x9f,0xe3,0xb7,0x02,0x93,0x55,0x76);


MIDL_DEFINE_GUID(IID, IID_IVBSAXDeclHandler,0xe8917260,0x7579,0x4be1,0xb5,0xdd,0x7a,0xfb,0xfa,0x6f,0x07,0x7b);


MIDL_DEFINE_GUID(IID, IID_IVBSAXAttributes,0x10dc0586,0x132b,0x4cac,0x8b,0xb3,0xdb,0x00,0xac,0x8b,0x7e,0xe0);


MIDL_DEFINE_GUID(IID, IID_IMXWriter,0x4d7ff4ba,0x1565,0x4ea8,0x94,0xe1,0x6e,0x72,0x4a,0x46,0xf9,0x8d);


MIDL_DEFINE_GUID(IID, IID_IMXAttributes,0xf10d27cc,0x3ec0,0x415c,0x8e,0xd8,0x77,0xab,0x1c,0x5e,0x72,0x62);


MIDL_DEFINE_GUID(IID, IID_IMXReaderControl,0x808f4e35,0x8d5a,0x4fbe,0x84,0x66,0x33,0xa4,0x12,0x79,0xed,0x30);


MIDL_DEFINE_GUID(IID, IID_IXMLElementCollection,0x65725580,0x9B5D,0x11d0,0x9B,0xFE,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLDocument,0xF52E2B61,0x18A1,0x11d1,0xB1,0x05,0x00,0x80,0x5F,0x49,0x91,0x6B);


MIDL_DEFINE_GUID(IID, IID_IXMLDocument2,0x2B8DE2FE,0x8D2D,0x11d1,0xB2,0xFC,0x00,0xC0,0x4F,0xD9,0x15,0xA9);


MIDL_DEFINE_GUID(IID, IID_IXMLElement,0x3F7F31AC,0xE15F,0x11d0,0x9C,0x25,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLElement2,0x2B8DE2FF,0x8D2D,0x11d1,0xB2,0xFC,0x00,0xC0,0x4F,0xD9,0x15,0xA9);


MIDL_DEFINE_GUID(IID, IID_IXMLAttribute,0xD4D4A0FC,0x3B73,0x11d1,0xB2,0xB4,0x00,0xC0,0x4F,0xB9,0x25,0x96);


MIDL_DEFINE_GUID(IID, IID_IXMLError,0x948C5AD3,0xC58D,0x11d0,0x9C,0x0B,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMSelection,0xAA634FC7,0x5888,0x44a7,0xA2,0x57,0x3A,0x47,0x15,0x0D,0x3A,0x0E);


MIDL_DEFINE_GUID(IID, DIID_XMLDOMDocumentEvents,0x3efaa427,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IDSOControl,0x310afa62,0x0575,0x11d2,0x9c,0xa9,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLHTTPRequest,0xED8C108D,0x4349,0x11D2,0x91,0xA4,0x00,0xC0,0x4F,0x79,0x69,0xE8);


MIDL_DEFINE_GUID(IID, IID_IServerXMLHTTPRequest,0x2e9196bf,0x13ba,0x4dd4,0x91,0xca,0x6c,0x57,0x1f,0x28,0x14,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument,0xF6D90F11,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument26,0xf5078f1b,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument30,0xf5078f32,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument,0xF6D90F12,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument26,0xf5078f1c,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument30,0xf5078f33,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache,0x373984c9,0xb845,0x449b,0x91,0xe7,0x45,0xac,0x83,0x03,0x6a,0xde);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache26,0xf5078f1d,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache30,0xf5078f34,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate,0x2933BF94,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate26,0xf5078f21,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate30,0xf5078f36,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl,0xF6D90F14,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl26,0xf5078f1f,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl30,0xf5078f39,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP,0xF6D90F16,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP26,0xf5078f1e,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP30,0xf5078f35,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_ServerXMLHTTP,0xafba6b42,0x5692,0x48ea,0x81,0x41,0xdc,0x51,0x7d,0xcf,0x0e,0xf1);


MIDL_DEFINE_GUID(CLSID, CLSID_ServerXMLHTTP30,0xafb40ffd,0xb609,0x40a3,0x98,0x28,0xf8,0x8b,0xbe,0x11,0xe4,0xe3);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXXMLReader,0x079aa557,0x4a18,0x424a,0x8e,0xee,0xe3,0x9f,0x0a,0x8d,0x41,0xb9);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXXMLReader30,0x3124c396,0xfb13,0x4836,0xa6,0xad,0x13,0x17,0xf1,0x71,0x36,0x88);


MIDL_DEFINE_GUID(CLSID, CLSID_MXXMLWriter,0xfc220ad8,0xa72a,0x4ee8,0x92,0x6e,0x0b,0x7a,0xd1,0x52,0xa0,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_MXXMLWriter30,0x3d813dfe,0x6c91,0x4a4e,0x8f,0x41,0x04,0x34,0x6a,0x84,0x1d,0x9c);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXAttributes,0x4dd441ad,0x526d,0x4a77,0x9f,0x1b,0x98,0x41,0xed,0x80,0x2f,0xb0);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXAttributes30,0x3e784a01,0xf3ae,0x4dc0,0x93,0x54,0x95,0x26,0xb9,0x37,0x0e,0xba);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLDocument,0xCFC399AF,0xD876,0x11d0,0x9C,0x10,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for msxml2.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSXML2,0xf5078f18,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMImplementation,0x2933BF8F,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNode,0x2933BF80,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocumentFragment,0x3efaa413,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocument,0x2933BF81,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMSchemaCollection,0x373984c8,0xb845,0x449b,0x91,0xe7,0x45,0xac,0x83,0x03,0x6a,0xde);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocument2,0x2933BF95,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNodeList,0x2933BF82,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNamedNodeMap,0x2933BF83,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMCharacterData,0x2933BF84,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMAttribute,0x2933BF85,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMElement,0x2933BF86,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMText,0x2933BF87,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMComment,0x2933BF88,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMProcessingInstruction,0x2933BF89,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMCDATASection,0x2933BF8A,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocumentType,0x2933BF8B,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNotation,0x2933BF8C,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMEntity,0x2933BF8D,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMEntityReference,0x2933BF8E,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMParseError,0x3efaa426,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXTLRuntime,0x3efaa425,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXSLTemplate,0x2933BF93,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXSLProcessor,0x2933BF92,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_ISAXXMLReader,0xa4f96ed0,0xf829,0x476e,0x81,0xc0,0xcd,0xc7,0xbd,0x2a,0x08,0x02);


MIDL_DEFINE_GUID(IID, IID_ISAXXMLFilter,0x70409222,0xca09,0x4475,0xac,0xb8,0x40,0x31,0x2f,0xe8,0xd1,0x45);


MIDL_DEFINE_GUID(IID, IID_ISAXLocator,0x9b7e472a,0x0de4,0x4640,0xbf,0xf3,0x84,0xd3,0x8a,0x05,0x1c,0x31);


MIDL_DEFINE_GUID(IID, IID_ISAXEntityResolver,0x99bca7bd,0xe8c4,0x4d5f,0xa0,0xcf,0x6d,0x90,0x79,0x01,0xff,0x07);


MIDL_DEFINE_GUID(IID, IID_ISAXContentHandler,0x1545cdfa,0x9e4e,0x4497,0xa8,0xa4,0x2b,0xf7,0xd0,0x11,0x2c,0x44);


MIDL_DEFINE_GUID(IID, IID_ISAXDTDHandler,0xe15c1baf,0xafb3,0x4d60,0x8c,0x36,0x19,0xa8,0xc4,0x5d,0xef,0xed);


MIDL_DEFINE_GUID(IID, IID_ISAXErrorHandler,0xa60511c4,0xccf5,0x479e,0x98,0xa3,0xdc,0x8d,0xc5,0x45,0xb7,0xd0);


MIDL_DEFINE_GUID(IID, IID_ISAXLexicalHandler,0x7f85d5f5,0x47a8,0x4497,0xbd,0xa5,0x84,0xba,0x04,0x81,0x9e,0xa6);


MIDL_DEFINE_GUID(IID, IID_ISAXDeclHandler,0x862629ac,0x771a,0x47b2,0x83,0x37,0x4e,0x68,0x43,0xc1,0xbe,0x90);


MIDL_DEFINE_GUID(IID, IID_ISAXAttributes,0xf078abe1,0x45d2,0x4832,0x91,0xea,0x44,0x66,0xce,0x2f,0x25,0xc9);


MIDL_DEFINE_GUID(IID, IID_IVBSAXXMLReader,0x8c033caa,0x6cd6,0x4f73,0xb7,0x28,0x45,0x31,0xaf,0x74,0x94,0x5f);


MIDL_DEFINE_GUID(IID, IID_IVBSAXXMLFilter,0x1299eb1b,0x5b88,0x433e,0x82,0xde,0x82,0xca,0x75,0xad,0x4e,0x04);


MIDL_DEFINE_GUID(IID, IID_IVBSAXLocator,0x796e7ac5,0x5aa2,0x4eff,0xac,0xad,0x3f,0xaa,0xf0,0x1a,0x32,0x88);


MIDL_DEFINE_GUID(IID, IID_IVBSAXEntityResolver,0x0c05d096,0xf45b,0x4aca,0xad,0x1a,0xaa,0x0b,0xc2,0x55,0x18,0xdc);


MIDL_DEFINE_GUID(IID, IID_IVBSAXContentHandler,0x2ed7290a,0x4dd5,0x4b46,0xbb,0x26,0x4e,0x41,0x55,0xe7,0x7f,0xaa);


MIDL_DEFINE_GUID(IID, IID_IVBSAXDTDHandler,0x24fb3297,0x302d,0x4620,0xba,0x39,0x3a,0x73,0x2d,0x85,0x05,0x58);


MIDL_DEFINE_GUID(IID, IID_IVBSAXErrorHandler,0xd963d3fe,0x173c,0x4862,0x90,0x95,0xb9,0x2f,0x66,0x99,0x5f,0x52);


MIDL_DEFINE_GUID(IID, IID_IVBSAXLexicalHandler,0x032aac35,0x8c0e,0x4d9d,0x97,0x9f,0xe3,0xb7,0x02,0x93,0x55,0x76);


MIDL_DEFINE_GUID(IID, IID_IVBSAXDeclHandler,0xe8917260,0x7579,0x4be1,0xb5,0xdd,0x7a,0xfb,0xfa,0x6f,0x07,0x7b);


MIDL_DEFINE_GUID(IID, IID_IVBSAXAttributes,0x10dc0586,0x132b,0x4cac,0x8b,0xb3,0xdb,0x00,0xac,0x8b,0x7e,0xe0);


MIDL_DEFINE_GUID(IID, IID_IMXWriter,0x4d7ff4ba,0x1565,0x4ea8,0x94,0xe1,0x6e,0x72,0x4a,0x46,0xf9,0x8d);


MIDL_DEFINE_GUID(IID, IID_IMXAttributes,0xf10d27cc,0x3ec0,0x415c,0x8e,0xd8,0x77,0xab,0x1c,0x5e,0x72,0x62);


MIDL_DEFINE_GUID(IID, IID_IMXReaderControl,0x808f4e35,0x8d5a,0x4fbe,0x84,0x66,0x33,0xa4,0x12,0x79,0xed,0x30);


MIDL_DEFINE_GUID(IID, IID_IXMLElementCollection,0x65725580,0x9B5D,0x11d0,0x9B,0xFE,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLDocument,0xF52E2B61,0x18A1,0x11d1,0xB1,0x05,0x00,0x80,0x5F,0x49,0x91,0x6B);


MIDL_DEFINE_GUID(IID, IID_IXMLDocument2,0x2B8DE2FE,0x8D2D,0x11d1,0xB2,0xFC,0x00,0xC0,0x4F,0xD9,0x15,0xA9);


MIDL_DEFINE_GUID(IID, IID_IXMLElement,0x3F7F31AC,0xE15F,0x11d0,0x9C,0x25,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLElement2,0x2B8DE2FF,0x8D2D,0x11d1,0xB2,0xFC,0x00,0xC0,0x4F,0xD9,0x15,0xA9);


MIDL_DEFINE_GUID(IID, IID_IXMLAttribute,0xD4D4A0FC,0x3B73,0x11d1,0xB2,0xB4,0x00,0xC0,0x4F,0xB9,0x25,0x96);


MIDL_DEFINE_GUID(IID, IID_IXMLError,0x948C5AD3,0xC58D,0x11d0,0x9C,0x0B,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMSelection,0xAA634FC7,0x5888,0x44a7,0xA2,0x57,0x3A,0x47,0x15,0x0D,0x3A,0x0E);


MIDL_DEFINE_GUID(IID, DIID_XMLDOMDocumentEvents,0x3efaa427,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IDSOControl,0x310afa62,0x0575,0x11d2,0x9c,0xa9,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLHTTPRequest,0xED8C108D,0x4349,0x11D2,0x91,0xA4,0x00,0xC0,0x4F,0x79,0x69,0xE8);


MIDL_DEFINE_GUID(IID, IID_IServerXMLHTTPRequest,0x2e9196bf,0x13ba,0x4dd4,0x91,0xca,0x6c,0x57,0x1f,0x28,0x14,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument,0xF6D90F11,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument26,0xf5078f1b,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument30,0xf5078f32,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument,0xF6D90F12,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument26,0xf5078f1c,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument30,0xf5078f33,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache,0x373984c9,0xb845,0x449b,0x91,0xe7,0x45,0xac,0x83,0x03,0x6a,0xde);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache26,0xf5078f1d,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache30,0xf5078f34,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate,0x2933BF94,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate26,0xf5078f21,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate30,0xf5078f36,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl,0xF6D90F14,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl26,0xf5078f1f,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl30,0xf5078f39,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP,0xF6D90F16,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP26,0xf5078f1e,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP30,0xf5078f35,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_ServerXMLHTTP,0xafba6b42,0x5692,0x48ea,0x81,0x41,0xdc,0x51,0x7d,0xcf,0x0e,0xf1);


MIDL_DEFINE_GUID(CLSID, CLSID_ServerXMLHTTP30,0xafb40ffd,0xb609,0x40a3,0x98,0x28,0xf8,0x8b,0xbe,0x11,0xe4,0xe3);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXXMLReader,0x079aa557,0x4a18,0x424a,0x8e,0xee,0xe3,0x9f,0x0a,0x8d,0x41,0xb9);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXXMLReader30,0x3124c396,0xfb13,0x4836,0xa6,0xad,0x13,0x17,0xf1,0x71,0x36,0x88);


MIDL_DEFINE_GUID(CLSID, CLSID_MXXMLWriter,0xfc220ad8,0xa72a,0x4ee8,0x92,0x6e,0x0b,0x7a,0xd1,0x52,0xa0,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_MXXMLWriter30,0x3d813dfe,0x6c91,0x4a4e,0x8f,0x41,0x04,0x34,0x6a,0x84,0x1d,0x9c);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXAttributes,0x4dd441ad,0x526d,0x4a77,0x9f,0x1b,0x98,0x41,0xed,0x80,0x2f,0xb0);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXAttributes30,0x3e784a01,0xf3ae,0x4dc0,0x93,0x54,0x95,0x26,0xb9,0x37,0x0e,0xba);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLDocument,0xCFC399AF,0xD876,0x11d0,0x9C,0x10,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\msxml2\domdocument_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for msxml2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument2,0xF6D90F11,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for msxml2.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument2,0xF6D90F11,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\msdasc\msdasc_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdasc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IService,0x06210E88,0x01F5,0x11D1,0xB5,0x12,0x00,0x80,0xC7,0x81,0xC3,0x84);


MIDL_DEFINE_GUID(IID, IID_IDBPromptInitialize,0x2206CCB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, IID_IDataInitialize,0x2206CCB1,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, LIBID_MSDASC,0x2206CEB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, IID_IDataSourceLocator,0x2206CCB2,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_DataLinks,0x2206CDB2,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_MSDAINITIALIZE,0x2206CDB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_PDPO,0xCCB4EC60,0xB9DC,0x11D1,0xAC,0x80,0x00,0xA0,0xC9,0x03,0x48,0x73);


MIDL_DEFINE_GUID(CLSID, CLSID_RootBinder,0xFF151822,0xB0BF,0x11D1,0xA8,0x0D,0x00,0x00,0x00,0x00,0x00,0x00);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdasc.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IService,0x06210E88,0x01F5,0x11D1,0xB5,0x12,0x00,0x80,0xC7,0x81,0xC3,0x84);


MIDL_DEFINE_GUID(IID, IID_IDBPromptInitialize,0x2206CCB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, IID_IDataInitialize,0x2206CCB1,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, LIBID_MSDASC,0x2206CEB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, IID_IDataSourceLocator,0x2206CCB2,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_DataLinks,0x2206CDB2,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_MSDAINITIALIZE,0x2206CDB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_PDPO,0xCCB4EC60,0xB9DC,0x11D1,0xAC,0x80,0x00,0xA0,0xC9,0x03,0x48,0x73);


MIDL_DEFINE_GUID(CLSID, CLSID_RootBinder,0xFF151822,0xB0BF,0x11D1,0xA8,0x0D,0x00,0x00,0x00,0x00,0x00,0x00);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\nntpsnap\nntpsnap.c ===
#include "windows.h"

STDAPI
DllCanUnloadNow (
    void
    )

{
    return 0;
}

STDAPI
DllGetClassObject (
    IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )

{
    return 0;
}

STDAPI
DllRegisterServer (
    void
    )

{
    return 0;
}

STDAPI
DllUnregisterServer (
    void
    )

{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\msxml2\msxml2did.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*         Copyright (c) 1996 - 1999 Microsoft Corporation. All rights reserved.**///*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __MSXML2DID_H__
#define __MSXML2DID_H__
//;end_internal

#define DISPID_XOBJ_MIN                 0x00010000
#define DISPID_XOBJ_MAX                 0x0001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN


#define DISPID_XMLELEMENTCOLLECTION             DISPID_XOBJ_BASE

#define DISPID_XMLELEMENTCOLLECTION_LENGTH     DISPID_XMLELEMENTCOLLECTION + 1
#define DISPID_XMLELEMENTCOLLECTION_NEWENUM     DISPID_NEWENUM
#define DISPID_XMLELEMENTCOLLECTION_ITEM        DISPID_XMLELEMENTCOLLECTION + 3


#define DISPID_XMLDOCUMENT                      DISPID_XMLELEMENTCOLLECTION + 100

#define DISPID_XMLDOCUMENT_ROOT                 DISPID_XMLDOCUMENT + 1
#define DISPID_XMLDOCUMENT_FILESIZE             DISPID_XMLDOCUMENT + 2
#define DISPID_XMLDOCUMENT_FILEMODIFIEDDATE     DISPID_XMLDOCUMENT + 3
#define DISPID_XMLDOCUMENT_FILEUPDATEDDATE      DISPID_XMLDOCUMENT + 4
#define DISPID_XMLDOCUMENT_URL                  DISPID_XMLDOCUMENT + 5
#define DISPID_XMLDOCUMENT_MIMETYPE             DISPID_XMLDOCUMENT + 6
#define DISPID_XMLDOCUMENT_READYSTATE           DISPID_XMLDOCUMENT + 7
#define DISPID_XMLDOCUMENT_CREATEELEMENT        DISPID_XMLDOCUMENT + 8
#define DISPID_XMLDOCUMENT_CHARSET              DISPID_XMLDOCUMENT + 9
#define DISPID_XMLDOCUMENT_VERSION              DISPID_XMLDOCUMENT + 10
#define DISPID_XMLDOCUMENT_DOCTYPE              DISPID_XMLDOCUMENT + 11
#define DISPID_XMLDOCUMENT_DTDURL               DISPID_XMLDOCUMENT + 12
#define DISPID_XMLDOCUMENT_ASYNC                DISPID_XMLDOCUMENT + 13
#define DISPID_XMLDOCUMENT_CASEINSENSITIVE      DISPID_XMLDOCUMENT + 14
#define DISPID_XMLDOCUMENT_BASEURL              DISPID_XMLDOCUMENT + 15
#define DISPID_XMLDOCUMENT_XML                  DISPID_XMLDOCUMENT + 16
#define DISPID_XMLDOCUMENT_LASTERROR            DISPID_XMLDOCUMENT + 17
#define DISPID_XMLDOCUMENT_TRIMWHITESPACE       DISPID_XMLDOCUMENT + 18
#define DISPID_XMLDOCUMENT_COMMIT				DISPID_XMLDOCUMENT + 19

#define DISPID_XMLELEMENT                       DISPID_XMLDOCUMENT + 100

#define DISPID_XMLELEMENT_TAGNAME               DISPID_XMLELEMENT + 1
#define DISPID_XMLELEMENT_PARENT                DISPID_XMLELEMENT + 2
#define DISPID_XMLELEMENT_SETATTRIBUTE          DISPID_XMLELEMENT + 3
#define DISPID_XMLELEMENT_GETATTRIBUTE          DISPID_XMLELEMENT + 4
#define DISPID_XMLELEMENT_REMOVEATTRIBUTE       DISPID_XMLELEMENT + 5
#define DISPID_XMLELEMENT_CHILDREN              DISPID_XMLELEMENT + 6
#define DISPID_XMLELEMENT_TYPE                  DISPID_XMLELEMENT + 7
#define DISPID_XMLELEMENT_TEXT                  DISPID_XMLELEMENT + 8
#define DISPID_XMLELEMENT_ADDCHILD              DISPID_XMLELEMENT + 9
#define DISPID_XMLELEMENT_REMOVECHILD           DISPID_XMLELEMENT + 10
#define DISPID_XMLELEMENT_ATTRIBUTES            DISPID_XMLELEMENT + 11

#define DISPID_XMLNOTIFSINK                     DISPID_XMLELEMENT + 100 

#define DISPID_XMLNOTIFSINK_CHILDADDED          DISPID_XMLNOTIFSINK + 1

#define DISPID_XMLATTRIBUTE                     DISPID_XMLNOTIFSINK + 100

#define DISPID_XMLATTRIBUTE_NAME                DISPID_XMLATTRIBUTE + 1
#define DISPID_XMLATTRIBUTE_VALUE               DISPID_XMLATTRIBUTE + 2


// IXMLError2
#define DISPID_XMLERROR                         DISPID_XMLNOTIFSINK + 100
#define DISPID_XMLERROR_REASON                  DISPID_XMLERROR + 1
#define DISPID_XMLERROR_LINE                    DISPID_XMLERROR + 2
#define DISPID_XMLERROR_POS                     DISPID_XMLERROR + 3

// INode
#define DISPID_NODE                             DISPID_XMLERROR + 100
#define DISPID_NODE_NAME                        DISPID_NODE + 1
#define DISPID_NODE_PARENT                      DISPID_NODE + 2
#define DISPID_NODE_TYPE                        DISPID_NODE + 3

#define DISPID_NODE_VALUE                       DISPID_NODE + 4

#define DISPID_NODE_SETATTRIBUTE                DISPID_NODE + 5
#define DISPID_NODE_GETATTRIBUTE                DISPID_NODE + 6
#define DISPID_NODE_REMOVEATTRIBUTE             DISPID_NODE + 7
#define DISPID_NODE_ATTRIBUTES                  DISPID_NODE + 8

#define DISPID_NODE_ADD                         DISPID_NODE + 9
#define DISPID_NODE_REMOVE                      DISPID_NODE + 10
#define DISPID_NODE_CHILDREN                    DISPID_NODE + 11

// INodeList
#define DISPID_NODELIST                         DISPID_NODE + 100
#define DISPID_NODELIST_NEWENUM                 DISPID_NODELIST + 1
#define DISPID_NODELIST_NEXT                    DISPID_NODELIST + 2
#define DISPID_NODELIST_CURRENT                 DISPID_NODELIST + 3
#define DISPID_NODELIST_MOVE                    DISPID_NODELIST + 4
#define DISPID_NODELIST_MOVETONODE              DISPID_NODELIST + 5

#define DISPID_NODELIST_LENGTH                  DISPID_NODELIST + 6
#define DISPID_NODELIST_ITEM                    DISPID_NODELIST + 7


// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_COLLECTION_BASE	1000000
#define DISPID_DOM_COLLECTION_MAX	2999999

#define DISPID_DOM_NODE                             (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME                    (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE                   (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE                    (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM                (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE                  (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES                  (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD                  (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD                   (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING             (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING                 (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES                  (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE                (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD                (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD                 (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD                 (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES               (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC                    (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE                   (DISPID_DOM_NODE + 18)
#define DISPID_XMLDOM_NODE                          (DISPID_DOM_NODE + 19)
#define DISPID_XMLDOM_NODE_STRINGTYPE               (DISPID_XMLDOM_NODE + 1)
#define DISPID_XMLDOM_NODE_SPECIFIED                (DISPID_XMLDOM_NODE + 2)
#define DISPID_XMLDOM_NODE_DEFINITION               (DISPID_XMLDOM_NODE + 3)
#define DISPID_XMLDOM_NODE_TEXT                     (DISPID_XMLDOM_NODE + 4)
#define DISPID_XMLDOM_NODE_NODETYPEDVALUE           (DISPID_XMLDOM_NODE + 5)
#define DISPID_XMLDOM_NODE_DATATYPE                 (DISPID_XMLDOM_NODE + 6)
#define DISPID_XMLDOM_NODE_XML                      (DISPID_XMLDOM_NODE + 7)
#define DISPID_XMLDOM_NODE_TRANSFORMNODE            (DISPID_XMLDOM_NODE + 8)
#define DISPID_XMLDOM_NODE_SELECTNODES              (DISPID_XMLDOM_NODE + 9)
#define DISPID_XMLDOM_NODE_SELECTSINGLENODE         (DISPID_XMLDOM_NODE + 10)
#define DISPID_XMLDOM_NODE_PARSED                   (DISPID_XMLDOM_NODE + 11)
#define DISPID_XMLDOM_NODE_NAMESPACE                (DISPID_XMLDOM_NODE + 12)
#define DISPID_XMLDOM_NODE_PREFIX                   (DISPID_XMLDOM_NODE + 13)
#define DISPID_XMLDOM_NODE_BASENAME                 (DISPID_XMLDOM_NODE + 14)
#define DISPID_XMLDOM_NODE_TRANSFORMNODETOOBJECT    (DISPID_XMLDOM_NODE + 15)
#define DISPID_XMLDOM_NODE__TOP                     (DISPID_XMLDOM_NODE + 16)

#define DISPID_DOM_DOCUMENT                        (DISPID_XMLDOM_NODE__TOP + 1)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT                     (DISPID_DOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNODE        (DISPID_XMLDOM_DOCUMENT + 1)
#define DISPID_XMLDOM_DOCUMENT_CREATENODE          (DISPID_XMLDOM_DOCUMENT + 2)
#define DISPID_XMLDOM_DOCUMENT_CREATENODEEX        (DISPID_XMLDOM_DOCUMENT + 3)
#define DISPID_XMLDOM_DOCUMENT_NODEFROMID          (DISPID_XMLDOM_DOCUMENT + 4)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNAMESPACES  (DISPID_XMLDOM_DOCUMENT + 5)
#define DISPID_XMLDOM_DOCUMENT_LOAD                (DISPID_XMLDOM_DOCUMENT + 6)
#define DISPID_XMLDOM_DOCUMENT_PARSEERROR          (DISPID_XMLDOM_DOCUMENT + 7)
#define DISPID_XMLDOM_DOCUMENT_URL                 (DISPID_XMLDOM_DOCUMENT + 8)
#define DISPID_XMLDOM_DOCUMENT_ASYNC               (DISPID_XMLDOM_DOCUMENT + 9)
#define DISPID_XMLDOM_DOCUMENT_ABORT               (DISPID_XMLDOM_DOCUMENT + 10)
#define DISPID_XMLDOM_DOCUMENT_LOADXML             (DISPID_XMLDOM_DOCUMENT + 11)
#define DISPID_XMLDOM_DOCUMENT_SAVE                (DISPID_XMLDOM_DOCUMENT + 12)
#define DISPID_XMLDOM_DOCUMENT_VALIDATE            (DISPID_XMLDOM_DOCUMENT + 13)
#define DISPID_XMLDOM_DOCUMENT_RESOLVENAMESPACE    (DISPID_XMLDOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT_PRESERVEWHITESPACE  (DISPID_XMLDOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_ONREADYSTATECHANGE  (DISPID_XMLDOM_DOCUMENT + 16)
#define DISPID_XMLDOM_DOCUMENT_ONDATAAVAILABLE     (DISPID_XMLDOM_DOCUMENT + 17)
#define DISPID_XMLDOM_DOCUMENT_ONTRANSFORMNODE     (DISPID_XMLDOM_DOCUMENT + 18)
#define DISPID_XMLDOM_DOCUMENT__TOP                (DISPID_XMLDOM_DOCUMENT + 19)

#define DISPID_DOM_NODELIST             (DISPID_XMLDOM_DOCUMENT__TOP + 1)
#define DISPID_DOM_NODELIST_ITEM        (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH      (DISPID_DOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST          (DISPID_DOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST_NEXTNODE (DISPID_XMLDOM_NODELIST + 1)
#define DISPID_XMLDOM_NODELIST_RESET    (DISPID_XMLDOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST_NEWENUM  (DISPID_XMLDOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST__TOP     (DISPID_XMLDOM_NODELIST + 4)


#define DISPID_DOM_NAMEDNODEMAP                         (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM         (DISPID_DOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP                      (DISPID_DOM_NAMEDNODEMAP + 6)
#define DISPID_XMLDOM_NAMEDNODEMAP_GETQUALIFIEDITEM     (DISPID_XMLDOM_NAMEDNODEMAP + 1)
#define DISPID_XMLDOM_NAMEDNODEMAP_REMOVEQUALIFIEDITEM  (DISPID_XMLDOM_NAMEDNODEMAP + 2)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEXTNODE             (DISPID_XMLDOM_NAMEDNODEMAP + 3)
#define DISPID_XMLDOM_NAMEDNODEMAP_RESET                (DISPID_XMLDOM_NAMEDNODEMAP + 4)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEWENUM              (DISPID_XMLDOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP__TOP                 (DISPID_XMLDOM_NAMEDNODEMAP + 6)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_XMLDOM_NAMEDNODEMAP__TOP + 1)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS + 1)
#define DISPID_DOM_DOCUMENTFRAGMENT__TOP       (DISPID_DOM_DOCUMENTFRAGMENT + 1)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENTFRAGMENT__TOP + 1)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT__TOP                    (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT__TOP + 1)
#define DISPID_DOM_DATA_DATA                   (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 7)
#define DISPID_DOM_DATA__TOP                   (DISPID_DOM_DATA + 8)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA__TOP + 1)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_VALUE             (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE__TOP              (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE__TOP + 1)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT__TOP           (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT__TOP + 1)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI__TOP      (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI__TOP + 1)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE__TOP       (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE__TOP + 1)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION__TOP           (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION__TOP + 1)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY__TOP             (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY__TOP)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_W3CWRAPPERS_TOP + 1)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)
#define DISPID_DOM_IMPLEMENTATION__TOP         (DISPID_DOM_IMPLEMENTATION + 2)

#define DISPID_DOM__TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)


#define  DISPID_DOM_ERROR                      (DISPID_DOM__TOP  + 1)
#define  DISPID_DOM_ERROR_ERRORCODE            (DISPID_DOM_ERROR  +  1)
#define  DISPID_DOM_ERROR_URL                  (DISPID_DOM_ERROR  +  2)
#define  DISPID_DOM_ERROR_REASON               (DISPID_DOM_ERROR  +  3)
#define  DISPID_DOM_ERROR_SRCTEXT              (DISPID_DOM_ERROR  +  4)
#define  DISPID_DOM_ERROR_LINE                 (DISPID_DOM_ERROR  +  5)
#define  DISPID_DOM_ERROR_LINEPOS              (DISPID_DOM_ERROR  +  6)
#define  DISPID_DOM_ERROR_FILEPOS              (DISPID_DOM_ERROR  +  7)
#define  DISPID_DOM_ERROR__TOP                 (DISPID_DOM_ERROR  +  8)

#define  DISPID_XTLRUNTIME                         (DISPID_DOM_ERROR__TOP + 1)
#define  DISPID_XTLRUNTIME_UNIQUEID                (DISPID_XTLRUNTIME + 1)
#define  DISPID_XTLRUNTIME_DEPTH                   (DISPID_XTLRUNTIME + 2)
#define  DISPID_XTLRUNTIME_CHILDNUMBER             (DISPID_XTLRUNTIME + 3)
#define  DISPID_XTLRUNTIME_ANCESTORCHILDNUMBER     (DISPID_XTLRUNTIME + 4)
#define  DISPID_XTLRUNTIME_ABSOLUTECHILDNUMBER     (DISPID_XTLRUNTIME + 5)
#define  DISPID_XTLRUNTIME_FORMATINDEX             (DISPID_XTLRUNTIME + 6)
#define  DISPID_XTLRUNTIME_FORMATNUMBER            (DISPID_XTLRUNTIME + 7)
#define  DISPID_XTLRUNTIME_FORMATDATE              (DISPID_XTLRUNTIME + 8)
#define  DISPID_XTLRUNTIME_FORMATTIME              (DISPID_XTLRUNTIME + 9)
#define  DISPID_XTLRUNTIME__TOP                    (DISPID_XTLRUNTIME + 10)

#define  DISPID_XMLDOMEVENT                        (DISPID_XTLRUNTIME__TOP + 1)
#define  DISPID_XMLDOMEVENT_ONREADYSTATECHANGE     (DISPID_READYSTATECHANGE)
#define  DISPID_XMLDOMEVENT_ONDATAAVAILABLE        (DISPID_XMLDOMEVENT + 1)
#define  DISPID_XMLDOMEVENT__TOP                   (DISPID_XMLDOMEVENT + 2)

#define DISPID_XMLDOM_DOCUMENT2                    (DISPID_XMLDOMEVENT__TOP + 1)
#define DISPID_XMLDOM_DOCUMENT2_NAMESPACES         (DISPID_XMLDOM_DOCUMENT2 + 1)
#define DISPID_XMLDOM_DOCUMENT2_SCHEMAS            (DISPID_XMLDOM_DOCUMENT2 + 2)
#define DISPID_XMLDOM_DOCUMENT2_VALIDATE           (DISPID_XMLDOM_DOCUMENT2 + 3)
#define DISPID_XMLDOM_DOCUMENT2_SETPROPERTY        (DISPID_XMLDOM_DOCUMENT2 + 4)
#define DISPID_XMLDOM_DOCUMENT2_GETPROPERTY        (DISPID_XMLDOM_DOCUMENT2 + 5)
#define DISPID_XMLDOM_DOCUMENT2__TOP               (DISPID_XMLDOM_DOCUMENT2 + 6)

#define DISPID_XMLDOM_SCHEMACOLLECTION               (DISPID_DOM_BASE + 1)
#define DISPID_XMLDOM_SCHEMACOLLECTION_ADD           (DISPID_XMLDOM_SCHEMACOLLECTION + 1)
#define DISPID_XMLDOM_SCHEMACOLLECTION_GET           (DISPID_XMLDOM_SCHEMACOLLECTION + 2)
#define DISPID_XMLDOM_SCHEMACOLLECTION_REMOVE        (DISPID_XMLDOM_SCHEMACOLLECTION + 3)
#define DISPID_XMLDOM_SCHEMACOLLECTION_LENGTH        (DISPID_XMLDOM_SCHEMACOLLECTION + 4)
#define DISPID_XMLDOM_SCHEMACOLLECTION_NAMESPACEURI  (DISPID_XMLDOM_SCHEMACOLLECTION + 5)
#define DISPID_XMLDOM_SCHEMACOLLECTION_ADDCOLLECTION (DISPID_XMLDOM_SCHEMACOLLECTION + 6)
#define DISPID_XMLDOM_SCHEMACOLLECTION__TOP          (DISPID_XMLDOM_SCHEMACOLLECTION + 7)

#define DISPID_XMLDOM_SELECTION                    (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_XMLDOM_SELECTION_EXPR               (DISPID_XMLDOM_SELECTION + 1)
#define DISPID_XMLDOM_SELECTION_CONTEXT            (DISPID_XMLDOM_SELECTION + 2)
#define DISPID_XMLDOM_SELECTION_PEEKNODE           (DISPID_XMLDOM_SELECTION + 3)
#define DISPID_XMLDOM_SELECTION_MATCHES            (DISPID_XMLDOM_SELECTION + 4)
#define DISPID_XMLDOM_SELECTION_REMOVENEXT         (DISPID_XMLDOM_SELECTION + 5)
#define DISPID_XMLDOM_SELECTION_REMOVEALL          (DISPID_XMLDOM_SELECTION + 6)
#define DISPID_XMLDOM_SELECTION_CLONE              (DISPID_XMLDOM_SELECTION + 7)
#define DISPID_XMLDOM_SELECTION_GETPROPERTY        (DISPID_XMLDOM_SELECTION + 8)
#define DISPID_XMLDOM_SELECTION_SETPROPERTY        (DISPID_XMLDOM_SELECTION + 9)
#define DISPID_XMLDOM_SELECTION__TOP               (DISPID_XMLDOM_SELECTION + 10)

#define DISPID_XMLDOM_TEMPLATE                    (DISPID_DOM_BASE)
#define DISPID_XMLDOM_TEMPLATE_STYLESHEET         (DISPID_XMLDOM_TEMPLATE + 1)
#define DISPID_XMLDOM_TEMPLATE_CREATEPROCESSOR    (DISPID_XMLDOM_TEMPLATE + 2)
#define DISPID_XMLDOM_TEMPLATE__TOP               (DISPID_XMLDOM_TEMPLATE + 3)

#define DISPID_XMLDOM_PROCESSOR                    (DISPID_DOM_BASE)
#define DISPID_XMLDOM_PROCESSOR_INPUT              (DISPID_XMLDOM_PROCESSOR + 1)
#define DISPID_XMLDOM_PROCESSOR_XSLTEMPLATE        (DISPID_XMLDOM_PROCESSOR + 2)
#define DISPID_XMLDOM_PROCESSOR_SETSTARTMODE       (DISPID_XMLDOM_PROCESSOR + 3)
#define DISPID_XMLDOM_PROCESSOR_STARTMODE          (DISPID_XMLDOM_PROCESSOR + 4)
#define DISPID_XMLDOM_PROCESSOR_STARTMODEURI       (DISPID_XMLDOM_PROCESSOR + 5)
#define DISPID_XMLDOM_PROCESSOR_OUTPUT             (DISPID_XMLDOM_PROCESSOR + 6)
#define DISPID_XMLDOM_PROCESSOR_TRANSFORM          (DISPID_XMLDOM_PROCESSOR + 7)
#define DISPID_XMLDOM_PROCESSOR_RESET              (DISPID_XMLDOM_PROCESSOR + 8)
#define DISPID_XMLDOM_PROCESSOR_READYSTATE         (DISPID_XMLDOM_PROCESSOR + 9)
#define DISPID_XMLDOM_PROCESSOR_ADDPARAMETER       (DISPID_XMLDOM_PROCESSOR + 10)
#define DISPID_XMLDOM_PROCESSOR_ADDOBJECT          (DISPID_XMLDOM_PROCESSOR + 11)
#define DISPID_XMLDOM_PROCESSOR_STYLESHEET         (DISPID_XMLDOM_PROCESSOR + 12)
#define DISPID_XMLDOM_PROCESSOR__TOP               (DISPID_XMLDOM_PROCESSOR + 13)


#define  DISPID_XMLDSO                       DISPID_XOBJ_BASE
#define  DISPID_XMLDSO_DOCUMENT              DISPID_XMLDSO  +  1
#define  DISPID_XMLDSO_JAVADSOCOMPATIBLE     DISPID_XMLDSO_DOCUMENT  +  1


#define DISPID_SAX_XMLREADER__MIN                 0x00000501
#define DISPID_SAX_XMLREADER__MAX                 0x00010000
#define DISPID_SAX_XMLREADER__BASE                DISPID_SAX_XMLREADER__MIN

#define DISPID_SAX_XMLREADER (DISPID_SAX_XMLREADER__BASE)
#define DISPID_SAX_XMLREADER_GETFEATURE (DISPID_SAX_XMLREADER + 1)
#define DISPID_SAX_XMLREADER_PUTFEATURE (DISPID_SAX_XMLREADER + 2)
#define DISPID_SAX_XMLREADER_GETPROPERTY (DISPID_SAX_XMLREADER + 3)
#define DISPID_SAX_XMLREADER_PUTPROPERTY (DISPID_SAX_XMLREADER + 4)
#define DISPID_SAX_XMLREADER_ENTITYRESOLVER (DISPID_SAX_XMLREADER + 5)
#define DISPID_SAX_XMLREADER_CONTENTHANDLER (DISPID_SAX_XMLREADER + 6)
#define DISPID_SAX_XMLREADER_DTDHANDLER (DISPID_SAX_XMLREADER + 7)
#define DISPID_SAX_XMLREADER_ERRORHANDLER (DISPID_SAX_XMLREADER + 8)
#define DISPID_SAX_XMLREADER_BASEURL (DISPID_SAX_XMLREADER + 9)
#define DISPID_SAX_XMLREADER_SECUREBASEURL (DISPID_SAX_XMLREADER + 10)
#define DISPID_SAX_XMLREADER_PARSE (DISPID_SAX_XMLREADER + 11)
#define DISPID_SAX_XMLREADER_PARSEURL (DISPID_SAX_XMLREADER + 12)
#define DISPID_SAX_XMLREADER_PARENT (DISPID_SAX_XMLREADER + 13)
#define DISPID_SAX_XMLREADER__TOP (DISPID_SAX_XMLREADER + 14)

#define DISPID_SAX_XMLFILTER__BASE (DISPID_SAX_XMLREADER__TOP + 1)
#define DISPID_SAX_XMLFILTER (DISPID_SAX_XMLFILTER__BASE)
#define DISPID_SAX_XMLFILTER_GETFEATURE (DISPID_SAX_XMLFILTER + 1)
#define DISPID_SAX_XMLFILTER_PUTFEATURE (DISPID_SAX_XMLFILTER + 2)
#define DISPID_SAX_XMLFILTER_GETPROPERTY (DISPID_SAX_XMLFILTER + 3)
#define DISPID_SAX_XMLFILTER_PUTPROPERTY (DISPID_SAX_XMLFILTER + 4)
#define DISPID_SAX_XMLFILTER_ENTITYRESOLVER (DISPID_SAX_XMLFILTER + 5)
#define DISPID_SAX_XMLFILTER_CONTENTHANDLER (DISPID_SAX_XMLFILTER + 6)
#define DISPID_SAX_XMLFILTER_DTDHANDLER (DISPID_SAX_XMLFILTER + 7)
#define DISPID_SAX_XMLFILTER_ERRORHANDLER (DISPID_SAX_XMLFILTER + 8)
#define DISPID_SAX_XMLFILTER_BASEURL (DISPID_SAX_XMLFILTER + 9)
#define DISPID_SAX_XMLFILTER_SECUREBASEURL (DISPID_SAX_XMLFILTER + 10)
#define DISPID_SAX_XMLFILTER_PARSE (DISPID_SAX_XMLFILTER + 11)
#define DISPID_SAX_XMLFILTER_PARSEURL (DISPID_SAX_XMLFILTER + 12)
#define DISPID_SAX_XMLFILTER_PARENT (DISPID_SAX_XMLFILTER + 13)
#define DISPID_SAX_XMLFILTER__TOP (DISPID_SAX_XMLFILTER + 15)

#define DISPID_SAX_LOCATOR__BASE (DISPID_SAX_XMLFILTER__TOP + 1)
#define DISPID_SAX_LOCATOR (DISPID_SAX_LOCATOR__BASE)
#define DISPID_SAX_LOCATOR_COLUMNNUMBER (DISPID_SAX_LOCATOR + 1)
#define DISPID_SAX_LOCATOR_LINENUMBER (DISPID_SAX_LOCATOR + 2)
#define DISPID_SAX_LOCATOR_PUBLICID (DISPID_SAX_LOCATOR + 3)
#define DISPID_SAX_LOCATOR_SYSTEMID (DISPID_SAX_LOCATOR + 4)
#define DISPID_SAX_LOCATOR__TOP (DISPID_SAX_LOCATOR + 5)

#define DISPID_SAX_ENTITYRESOLVER__BASE (DISPID_SAX_LOCATOR__TOP + 1)
#define DISPID_SAX_ENTITYRESOLVER (DISPID_SAX_ENTITYRESOLVER__BASE)
#define DISPID_SAX_ENTITYRESOLVER_RESOLVEENTITY (DISPID_SAX_ENTITYRESOLVER + 1)
#define DISPID_SAX_ENTITYRESOLVER__TOP (DISPID_SAX_ENTITYRESOLVER + 2)

#define DISPID_SAX_CONTENTHANDLER__BASE (DISPID_SAX_ENTITYRESOLVER__TOP + 1)
#define DISPID_SAX_CONTENTHANDLER (DISPID_SAX_CONTENTHANDLER__BASE)
#define DISPID_SAX_CONTENTHANDLER_DOCUMENTLOCATOR (DISPID_SAX_CONTENTHANDLER + 1)
#define DISPID_SAX_CONTENTHANDLER_STARTDOCUMENT (DISPID_SAX_CONTENTHANDLER + 2)
#define DISPID_SAX_CONTENTHANDLER_ENDDOCUMENT (DISPID_SAX_CONTENTHANDLER + 3)
#define DISPID_SAX_CONTENTHANDLER_STARTPREFIXMAPPING (DISPID_SAX_CONTENTHANDLER + 4)
#define DISPID_SAX_CONTENTHANDLER_ENDPREFIXMAPPING (DISPID_SAX_CONTENTHANDLER + 5)
#define DISPID_SAX_CONTENTHANDLER_STARTELEMENT (DISPID_SAX_CONTENTHANDLER + 6)
#define DISPID_SAX_CONTENTHANDLER_ENDELEMENT (DISPID_SAX_CONTENTHANDLER + 7)
#define DISPID_SAX_CONTENTHANDLER_CHARACTERS (DISPID_SAX_CONTENTHANDLER + 8)
#define DISPID_SAX_CONTENTHANDLER_IGNORABLEWHITESPACE (DISPID_SAX_CONTENTHANDLER + 9)
#define DISPID_SAX_CONTENTHANDLER_PROCESSINGINSTRUCTION (DISPID_SAX_CONTENTHANDLER + 10)
#define DISPID_SAX_CONTENTHANDLER_SKIPPEDENTITY (DISPID_SAX_CONTENTHANDLER + 11)
#define DISPID_SAX_CONTENTHANDLER__TOP (DISPID_SAX_CONTENTHANDLER + 12)

#define DISPID_SAX_DTDHANDLER__BASE (DISPID_SAX_CONTENTHANDLER__TOP + 1)
#define DISPID_SAX_DTDHANDLER (DISPID_SAX_DTDHANDLER__BASE)
#define DISPID_SAX_DTDHANDLER_NOTATIONDECL (DISPID_SAX_DTDHANDLER + 1)
#define DISPID_SAX_DTDHANDLER_UNPARSEDENTITYDECL (DISPID_SAX_DTDHANDLER + 2)
#define DISPID_SAX_DTDHANDLER__TOP (DISPID_SAX_DTDHANDLER + 3)

#define DISPID_SAX_ERRORHANDLER__BASE (DISPID_SAX_DTDHANDLER__TOP + 1)
#define DISPID_SAX_ERRORHANDLER (DISPID_SAX_ERRORHANDLER__BASE)
#define DISPID_SAX_ERRORHANDLER_ERROR (DISPID_SAX_ERRORHANDLER + 1)
#define DISPID_SAX_ERRORHANDLER_FATALERROR (DISPID_SAX_ERRORHANDLER + 2)
#define DISPID_SAX_ERRORHANDLER_IGNORABLEWARNING (DISPID_SAX_ERRORHANDLER + 3)
#define DISPID_SAX_ERRORHANDLER__TOP (DISPID_SAX_ERRORHANDLER + 4)

#define DISPID_SAX_ATTRIBUTES__BASE (DISPID_SAX_ERRORHANDLER__TOP + 1)
#define DISPID_SAX_ATTRIBUTES (DISPID_SAX_ATTRIBUTES__BASE)
#define DISPID_SAX_ATTRIBUTES_LENGTH (DISPID_SAX_ATTRIBUTES + 1)
#define DISPID_SAX_ATTRIBUTES_GETURI (DISPID_SAX_ATTRIBUTES + 2)
#define DISPID_SAX_ATTRIBUTES_GETLOCALNAME (DISPID_SAX_ATTRIBUTES + 3)
#define DISPID_SAX_ATTRIBUTES_GETQNAME (DISPID_SAX_ATTRIBUTES + 4)
#define DISPID_SAX_ATTRIBUTES_GETINDEXFROMNAME (DISPID_SAX_ATTRIBUTES + 5)
#define DISPID_SAX_ATTRIBUTES_GETINDEXFROMQNAME (DISPID_SAX_ATTRIBUTES + 6)
#define DISPID_SAX_ATTRIBUTES_GETTYPE (DISPID_SAX_ATTRIBUTES + 7)
#define DISPID_SAX_ATTRIBUTES_GETTYPEFROMNAME (DISPID_SAX_ATTRIBUTES + 8)
#define DISPID_SAX_ATTRIBUTES_GETTYPEFROMQNAME (DISPID_SAX_ATTRIBUTES + 9)
#define DISPID_SAX_ATTRIBUTES_GETVALUE (DISPID_SAX_ATTRIBUTES + 10)
#define DISPID_SAX_ATTRIBUTES_GETVALUEFROMNAME (DISPID_SAX_ATTRIBUTES + 11)
#define DISPID_SAX_ATTRIBUTES_GETVALUEFROMQNAME (DISPID_SAX_ATTRIBUTES + 12)
#define DISPID_SAX_ATTRIBUTES__TOP (DISPID_SAX_ATTRIBUTES + 13)

#define DISPID_SAX_LEXICALHANDLER__BASE (DISPID_SAX_ATTRIBUTES__TOP + 1)
#define DISPID_SAX_LEXICALHANDLER (DISPID_SAX_LEXICALHANDLER__BASE)
#define DISPID_SAX_LEXICALHANDLER_STARTDTD (DISPID_SAX_LEXICALHANDLER + 1)
#define DISPID_SAX_LEXICALHANDLER_ENDDTD (DISPID_SAX_LEXICALHANDLER + 2)
#define DISPID_SAX_LEXICALHANDLER_STARTENTITY (DISPID_SAX_LEXICALHANDLER + 3)
#define DISPID_SAX_LEXICALHANDLER_ENDENTITY (DISPID_SAX_LEXICALHANDLER + 4)
#define DISPID_SAX_LEXICALHANDLER_STARTCDATA (DISPID_SAX_LEXICALHANDLER + 5)
#define DISPID_SAX_LEXICALHANDLER_ENDCDATA (DISPID_SAX_LEXICALHANDLER + 6)
#define DISPID_SAX_LEXICALHANDLER_COMMENT (DISPID_SAX_LEXICALHANDLER + 7)
#define DISPID_SAX_LEXICALHANDLER__TOP (DISPID_SAX_LEXICALHANDLER + 8)

#define DISPID_SAX_DECLHANDLER__BASE (DISPID_SAX_LEXICALHANDLER__TOP + 1)
#define DISPID_SAX_DECLHANDLER (DISPID_SAX_DECLHANDLER__BASE)
#define DISPID_SAX_DECLHANDLER_ELEMENTDECL (DISPID_SAX_DECLHANDLER + 1)
#define DISPID_SAX_DECLHANDLER_ATTRIBUTEDECL (DISPID_SAX_DECLHANDLER + 2)
#define DISPID_SAX_DECLHANDLER_INTERNALENTITYDECL (DISPID_SAX_DECLHANDLER + 3)
#define DISPID_SAX_DECLHANDLER_EXTERNALENTITYDECL (DISPID_SAX_DECLHANDLER + 4)
#define DISPID_SAX_DECLHANDLER__TOP (DISPID_SAX_DECLHANDLER + 5)

#define DISPID_MX_ATTRIBUTES__BASE (DISPID_SAX_DECLHANDLER__TOP + 1)
#define DISPID_MX_ATTRIBUTES (DISPID_MX_ATTRIBUTES__BASE)
#define DISPID_MX_ATTRIBUTES_ADDATTRIBUTE (DISPID_MX_ATTRIBUTES + 1)
#define DISPID_MX_ATTRIBUTES_CLEAR (DISPID_MX_ATTRIBUTES + 2)
#define DISPID_MX_ATTRIBUTES_REMOVEATTRIBUTE (DISPID_MX_ATTRIBUTES + 3)
#define DISPID_MX_ATTRIBUTES_SETATTRIBUTE (DISPID_MX_ATTRIBUTES + 4)
#define DISPID_MX_ATTRIBUTES_SETATTRIBUTES (DISPID_MX_ATTRIBUTES + 5)
#define DISPID_MX_ATTRIBUTES_SETLOCALNAME (DISPID_MX_ATTRIBUTES + 6)
#define DISPID_MX_ATTRIBUTES_SETQNAME (DISPID_MX_ATTRIBUTES + 7)
#define DISPID_MX_ATTRIBUTES_SETTYPE (DISPID_MX_ATTRIBUTES + 8)
#define DISPID_MX_ATTRIBUTES_SETURI (DISPID_MX_ATTRIBUTES + 9)
#define DISPID_MX_ATTRIBUTES_SETVALUE (DISPID_MX_ATTRIBUTES + 10)
#define DISPID_MX_ATTRIBUTES_ADDATTRIBUTEFROMINDEX (DISPID_MX_ATTRIBUTES + 11)
#define DISPID_MX_ATTRIBUTES__TOP (DISPID_MX_ATTRIBUTES + 11)

#define DISPID_MX_WRITER__BASE (DISPID_MX_ATTRIBUTES__TOP + 1)
#define DISPID_MX_WRITER (DISPID_MX_WRITER__BASE)
#define DISPID_MX_WRITER_OUTPUT (DISPID_MX_WRITER + 1)
#define DISPID_MX_WRITER_DESTINATION (DISPID_MX_WRITER + 2)
#define DISPID_MX_WRITER_ENCODING (DISPID_MX_WRITER + 3)
#define DISPID_MX_WRITER_BYTEORDERMARK (DISPID_MX_WRITER + 4)
#define DISPID_MX_WRITER_INDENT (DISPID_MX_WRITER + 5)
#define DISPID_MX_WRITER_STANDALONE (DISPID_MX_WRITER + 6)
#define DISPID_MX_WRITER_OMITXMLDECLARATION (DISPID_MX_WRITER + 7)
#define DISPID_MX_WRITER_VERSION (DISPID_MX_WRITER + 8)
#define DISPID_MX_WRITER_DISABLEOUTPUTESCAPING (DISPID_MX_WRITER + 9)
#define DISPID_MX_WRITER_FLUSH (DISPID_MX_WRITER + 10)
#define DISPID_MX_WRITER_RESET (DISPID_MX_WRITER + 11)
#define DISPID_MX_WRITER__TOP (DISPID_MX_WRITER + 12)

#define DISPID_MX_READER_CONTROL__BASE (DISPID_MX_WRITER__TOP + 1)
#define DISPID_MX_READER_CONTROL (DISPID_MX_READER_CONTROL__BASE)
#define DISPID_MX_READER_CONTROL_ABORT (DISPID_MX_READER_CONTROL + 1)
#define DISPID_MX_READER_CONTROL_RESUME (DISPID_MX_READER_CONTROL + 2)
#define DISPID_MX_READER_CONTROL_SUSPEND (DISPID_MX_READER_CONTROL + 3)
#define DISPID_MX_READER_CONTROL__TOP (DISPID_MX_READER_CONTROL + 4)

//;begin_internal
#endif // __MSXMLDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\msdasc\msdasc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdasc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msdasc_h__
#define __msdasc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IService_FWD_DEFINED__
#define __IService_FWD_DEFINED__
typedef interface IService IService;
#endif 	/* __IService_FWD_DEFINED__ */


#ifndef __IDBPromptInitialize_FWD_DEFINED__
#define __IDBPromptInitialize_FWD_DEFINED__
typedef interface IDBPromptInitialize IDBPromptInitialize;
#endif 	/* __IDBPromptInitialize_FWD_DEFINED__ */


#ifndef __IDataInitialize_FWD_DEFINED__
#define __IDataInitialize_FWD_DEFINED__
typedef interface IDataInitialize IDataInitialize;
#endif 	/* __IDataInitialize_FWD_DEFINED__ */


#ifndef __IDataSourceLocator_FWD_DEFINED__
#define __IDataSourceLocator_FWD_DEFINED__
typedef interface IDataSourceLocator IDataSourceLocator;
#endif 	/* __IDataSourceLocator_FWD_DEFINED__ */


#ifndef __DataLinks_FWD_DEFINED__
#define __DataLinks_FWD_DEFINED__

#ifdef __cplusplus
typedef class DataLinks DataLinks;
#else
typedef struct DataLinks DataLinks;
#endif /* __cplusplus */

#endif 	/* __DataLinks_FWD_DEFINED__ */


#ifndef __MSDAINITIALIZE_FWD_DEFINED__
#define __MSDAINITIALIZE_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSDAINITIALIZE MSDAINITIALIZE;
#else
typedef struct MSDAINITIALIZE MSDAINITIALIZE;
#endif /* __cplusplus */

#endif 	/* __MSDAINITIALIZE_FWD_DEFINED__ */


#ifndef __PDPO_FWD_DEFINED__
#define __PDPO_FWD_DEFINED__

#ifdef __cplusplus
typedef class PDPO PDPO;
#else
typedef struct PDPO PDPO;
#endif /* __cplusplus */

#endif 	/* __PDPO_FWD_DEFINED__ */


#ifndef __RootBinder_FWD_DEFINED__
#define __RootBinder_FWD_DEFINED__

#ifdef __cplusplus
typedef class RootBinder RootBinder;
#else
typedef struct RootBinder RootBinder;
#endif /* __cplusplus */

#endif 	/* __RootBinder_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "oledb.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msdasc_0000 */
/* [local] */ 

//-----------------------------------------------------------------------------
// File:				.C or .H file generated by msdasc.idl 
//
// Copyright:		Copyright (c) 1998-1999 Microsoft Corporation
//
// Contents: 		.C or .H file generated by msdasc.idl
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#ifdef _WIN64

typedef LONGLONG			COMPATIBLE_LONG;

#else

typedef LONG COMPATIBLE_LONG;

#endif	// _WIN64
typedef 
enum tagEBindInfoOptions
    {	BIO_BINDER	= 0x1
    } 	EBindInfoOptions;

#define STGM_COLLECTION		0x00002000L
#define STGM_OUTPUT			0x00008000L
#define STGM_OPEN			0x80000000L
#define STGM_RECURSIVE		0x01000000L
#define STGM_STRICTOPEN		0x40000000L


extern RPC_IF_HANDLE __MIDL_itf_msdasc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msdasc_0000_v0_0_s_ifspec;

#ifndef __IService_INTERFACE_DEFINED__
#define __IService_INTERFACE_DEFINED__

/* interface IService */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("06210E88-01F5-11D1-B512-0080C781C384")
    IService : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE InvokeService( 
            /* [in] */ IUnknown *pUnkInner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IService * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *InvokeService )( 
            IService * This,
            /* [in] */ IUnknown *pUnkInner);
        
        END_INTERFACE
    } IServiceVtbl;

    interface IService
    {
        CONST_VTBL struct IServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IService_InvokeService(This,pUnkInner)	\
    (This)->lpVtbl -> InvokeService(This,pUnkInner)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IService_InvokeService_Proxy( 
    IService * This,
    /* [in] */ IUnknown *pUnkInner);


void __RPC_STUB IService_InvokeService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msdasc_0351 */
/* [local] */ 

typedef DWORD DBPROMPTOPTIONS;

typedef 
enum tagDBPROMPTOPTIONSENUM
    {	DBPROMPTOPTIONS_NONE	= 0,
	DBPROMPTOPTIONS_WIZARDSHEET	= 0x1,
	DBPROMPTOPTIONS_PROPERTYSHEET	= 0x2,
	DBPROMPTOPTIONS_BROWSEONLY	= 0x8,
	DBPROMPTOPTIONS_DISABLE_PROVIDER_SELECTION	= 0x10,
	DBPROMPTOPTIONS_DISABLESAVEPASSWORD	= 0x20
    } 	DBPROMPTOPTIONSENUM;



extern RPC_IF_HANDLE __MIDL_itf_msdasc_0351_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msdasc_0351_v0_0_s_ifspec;

#ifndef __IDBPromptInitialize_INTERFACE_DEFINED__
#define __IDBPromptInitialize_INTERFACE_DEFINED__

/* interface IDBPromptInitialize */
/* [restricted][local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDBPromptInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2206CCB0-19C1-11D1-89E0-00C04FD7A829")
    IDBPromptInitialize : public IUnknown
    {
    public:
        virtual /* [local][helpstring] */ HRESULT STDMETHODCALLTYPE PromptDataSource( 
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ ULONG cSourceTypeFilter,
            /* [size_is][in] */ DBSOURCETYPE *rgSourceTypeFilter,
            /* [in] */ LPCOLESTR pwszszzProviderFilter,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown **ppDataSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PromptFileName( 
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ LPCOLESTR pwszInitialDirectory,
            /* [in] */ LPCOLESTR pwszInitialFile,
            /* [out] */ LPOLESTR *ppwszSelectedFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBPromptInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDBPromptInitialize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDBPromptInitialize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDBPromptInitialize * This);
        
        /* [local][helpstring] */ HRESULT ( STDMETHODCALLTYPE *PromptDataSource )( 
            IDBPromptInitialize * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ ULONG cSourceTypeFilter,
            /* [size_is][in] */ DBSOURCETYPE *rgSourceTypeFilter,
            /* [in] */ LPCOLESTR pwszszzProviderFilter,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown **ppDataSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PromptFileName )( 
            IDBPromptInitialize * This,
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ LPCOLESTR pwszInitialDirectory,
            /* [in] */ LPCOLESTR pwszInitialFile,
            /* [out] */ LPOLESTR *ppwszSelectedFile);
        
        END_INTERFACE
    } IDBPromptInitializeVtbl;

    interface IDBPromptInitialize
    {
        CONST_VTBL struct IDBPromptInitializeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBPromptInitialize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBPromptInitialize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBPromptInitialize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBPromptInitialize_PromptDataSource(This,pUnkOuter,hWndParent,dwPromptOptions,cSourceTypeFilter,rgSourceTypeFilter,pwszszzProviderFilter,riid,ppDataSource)	\
    (This)->lpVtbl -> PromptDataSource(This,pUnkOuter,hWndParent,dwPromptOptions,cSourceTypeFilter,rgSourceTypeFilter,pwszszzProviderFilter,riid,ppDataSource)

#define IDBPromptInitialize_PromptFileName(This,hWndParent,dwPromptOptions,pwszInitialDirectory,pwszInitialFile,ppwszSelectedFile)	\
    (This)->lpVtbl -> PromptFileName(This,hWndParent,dwPromptOptions,pwszInitialDirectory,pwszInitialFile,ppwszSelectedFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local][helpstring] */ HRESULT STDMETHODCALLTYPE IDBPromptInitialize_PromptDataSource_Proxy( 
    IDBPromptInitialize * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ HWND hWndParent,
    /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
    /* [in] */ ULONG cSourceTypeFilter,
    /* [size_is][in] */ DBSOURCETYPE *rgSourceTypeFilter,
    /* [in] */ LPCOLESTR pwszszzProviderFilter,
    /* [in] */ REFIID riid,
    /* [iid_is][out][in] */ IUnknown **ppDataSource);


void __RPC_STUB IDBPromptInitialize_PromptDataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDBPromptInitialize_PromptFileName_Proxy( 
    IDBPromptInitialize * This,
    /* [in] */ HWND hWndParent,
    /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
    /* [in] */ LPCOLESTR pwszInitialDirectory,
    /* [in] */ LPCOLESTR pwszInitialFile,
    /* [out] */ LPOLESTR *ppwszSelectedFile);


void __RPC_STUB IDBPromptInitialize_PromptFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBPromptInitialize_INTERFACE_DEFINED__ */


#ifndef __IDataInitialize_INTERFACE_DEFINED__
#define __IDataInitialize_INTERFACE_DEFINED__

/* interface IDataInitialize */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDataInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2206CCB1-19C1-11D1-89E0-00C04FD7A829")
    IDataInitialize : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDataSource( 
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown **ppDataSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInitializationString( 
            /* [in] */ IUnknown *pDataSource,
            /* [in] */ boolean fIncludePassword,
            /* [out] */ LPOLESTR *ppwszInitString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateDBInstance( 
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppDataSource) = 0;
        
        virtual /* [local][helpstring] */ HRESULT STDMETHODCALLTYPE CreateDBInstanceEx( 
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [unique][in] */ COSERVERINFO *pServerInfo,
            /* [in] */ ULONG cmq,
            /* [size_is][out][in] */ MULTI_QI *rgmqResults) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoadStringFromStorage( 
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [out] */ LPOLESTR *ppwszInitializationString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WriteStringToStorage( 
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ DWORD dwCreationDisposition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataInitialize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataInitialize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataInitialize * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDataSource )( 
            IDataInitialize * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown **ppDataSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInitializationString )( 
            IDataInitialize * This,
            /* [in] */ IUnknown *pDataSource,
            /* [in] */ boolean fIncludePassword,
            /* [out] */ LPOLESTR *ppwszInitString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateDBInstance )( 
            IDataInitialize * This,
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppDataSource);
        
        /* [local][helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateDBInstanceEx )( 
            IDataInitialize * This,
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [unique][in] */ COSERVERINFO *pServerInfo,
            /* [in] */ ULONG cmq,
            /* [size_is][out][in] */ MULTI_QI *rgmqResults);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LoadStringFromStorage )( 
            IDataInitialize * This,
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [out] */ LPOLESTR *ppwszInitializationString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WriteStringToStorage )( 
            IDataInitialize * This,
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ DWORD dwCreationDisposition);
        
        END_INTERFACE
    } IDataInitializeVtbl;

    interface IDataInitialize
    {
        CONST_VTBL struct IDataInitializeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataInitialize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataInitialize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataInitialize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataInitialize_GetDataSource(This,pUnkOuter,dwClsCtx,pwszInitializationString,riid,ppDataSource)	\
    (This)->lpVtbl -> GetDataSource(This,pUnkOuter,dwClsCtx,pwszInitializationString,riid,ppDataSource)

#define IDataInitialize_GetInitializationString(This,pDataSource,fIncludePassword,ppwszInitString)	\
    (This)->lpVtbl -> GetInitializationString(This,pDataSource,fIncludePassword,ppwszInitString)

#define IDataInitialize_CreateDBInstance(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,riid,ppDataSource)	\
    (This)->lpVtbl -> CreateDBInstance(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,riid,ppDataSource)

#define IDataInitialize_CreateDBInstanceEx(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,pServerInfo,cmq,rgmqResults)	\
    (This)->lpVtbl -> CreateDBInstanceEx(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,pServerInfo,cmq,rgmqResults)

#define IDataInitialize_LoadStringFromStorage(This,pwszFileName,ppwszInitializationString)	\
    (This)->lpVtbl -> LoadStringFromStorage(This,pwszFileName,ppwszInitializationString)

#define IDataInitialize_WriteStringToStorage(This,pwszFileName,pwszInitializationString,dwCreationDisposition)	\
    (This)->lpVtbl -> WriteStringToStorage(This,pwszFileName,pwszInitializationString,dwCreationDisposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_GetDataSource_Proxy( 
    IDataInitialize * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPCOLESTR pwszInitializationString,
    /* [in] */ REFIID riid,
    /* [iid_is][out][in] */ IUnknown **ppDataSource);


void __RPC_STUB IDataInitialize_GetDataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_GetInitializationString_Proxy( 
    IDataInitialize * This,
    /* [in] */ IUnknown *pDataSource,
    /* [in] */ boolean fIncludePassword,
    /* [out] */ LPOLESTR *ppwszInitString);


void __RPC_STUB IDataInitialize_GetInitializationString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_CreateDBInstance_Proxy( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppDataSource);


void __RPC_STUB IDataInitialize_CreateDBInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataInitialize_RemoteCreateDBInstanceEx_Proxy( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [unique][in] */ COSERVERINFO *pServerInfo,
    /* [in] */ ULONG cmq,
    /* [size_is][size_is][in] */ const IID **rgpIID,
    /* [size_is][size_is][out] */ IUnknown **rgpItf,
    /* [size_is][out] */ HRESULT *rghr);


void __RPC_STUB IDataInitialize_RemoteCreateDBInstanceEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_LoadStringFromStorage_Proxy( 
    IDataInitialize * This,
    /* [unique][in] */ LPCOLESTR pwszFileName,
    /* [out] */ LPOLESTR *ppwszInitializationString);


void __RPC_STUB IDataInitialize_LoadStringFromStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_WriteStringToStorage_Proxy( 
    IDataInitialize * This,
    /* [unique][in] */ LPCOLESTR pwszFileName,
    /* [unique][in] */ LPCOLESTR pwszInitializationString,
    /* [in] */ DWORD dwCreationDisposition);


void __RPC_STUB IDataInitialize_WriteStringToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataInitialize_INTERFACE_DEFINED__ */



#ifndef __MSDASC_LIBRARY_DEFINED__
#define __MSDASC_LIBRARY_DEFINED__

/* library MSDASC */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_MSDASC;

#ifndef __IDataSourceLocator_INTERFACE_DEFINED__
#define __IDataSourceLocator_INTERFACE_DEFINED__

/* interface IDataSourceLocator */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDataSourceLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2206CCB2-19C1-11D1-89E0-00C04FD7A829")
    IDataSourceLocator : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ COMPATIBLE_LONG *phwndParent) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_hWnd( 
            /* [in] */ COMPATIBLE_LONG hwndParent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PromptNew( 
            /* [retval][out] */ IDispatch **ppADOConnection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PromptEdit( 
            /* [out][in] */ IDispatch **ppADOConnection,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataSourceLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataSourceLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataSourceLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataSourceLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDataSourceLocator * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDataSourceLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDataSourceLocator * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDataSourceLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            IDataSourceLocator * This,
            /* [retval][out] */ COMPATIBLE_LONG *phwndParent);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_hWnd )( 
            IDataSourceLocator * This,
            /* [in] */ COMPATIBLE_LONG hwndParent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PromptNew )( 
            IDataSourceLocator * This,
            /* [retval][out] */ IDispatch **ppADOConnection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PromptEdit )( 
            IDataSourceLocator * This,
            /* [out][in] */ IDispatch **ppADOConnection,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess);
        
        END_INTERFACE
    } IDataSourceLocatorVtbl;

    interface IDataSourceLocator
    {
        CONST_VTBL struct IDataSourceLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataSourceLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataSourceLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataSourceLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataSourceLocator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDataSourceLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDataSourceLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDataSourceLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDataSourceLocator_get_hWnd(This,phwndParent)	\
    (This)->lpVtbl -> get_hWnd(This,phwndParent)

#define IDataSourceLocator_put_hWnd(This,hwndParent)	\
    (This)->lpVtbl -> put_hWnd(This,hwndParent)

#define IDataSourceLocator_PromptNew(This,ppADOConnection)	\
    (This)->lpVtbl -> PromptNew(This,ppADOConnection)

#define IDataSourceLocator_PromptEdit(This,ppADOConnection,pbSuccess)	\
    (This)->lpVtbl -> PromptEdit(This,ppADOConnection,pbSuccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_get_hWnd_Proxy( 
    IDataSourceLocator * This,
    /* [retval][out] */ COMPATIBLE_LONG *phwndParent);


void __RPC_STUB IDataSourceLocator_get_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_put_hWnd_Proxy( 
    IDataSourceLocator * This,
    /* [in] */ COMPATIBLE_LONG hwndParent);


void __RPC_STUB IDataSourceLocator_put_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_PromptNew_Proxy( 
    IDataSourceLocator * This,
    /* [retval][out] */ IDispatch **ppADOConnection);


void __RPC_STUB IDataSourceLocator_PromptNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_PromptEdit_Proxy( 
    IDataSourceLocator * This,
    /* [out][in] */ IDispatch **ppADOConnection,
    /* [retval][out] */ VARIANT_BOOL *pbSuccess);


void __RPC_STUB IDataSourceLocator_PromptEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataSourceLocator_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DataLinks;

#ifdef __cplusplus

class DECLSPEC_UUID("2206CDB2-19C1-11D1-89E0-00C04FD7A829")
DataLinks;
#endif

EXTERN_C const CLSID CLSID_MSDAINITIALIZE;

#ifdef __cplusplus

class DECLSPEC_UUID("2206CDB0-19C1-11D1-89E0-00C04FD7A829")
MSDAINITIALIZE;
#endif

EXTERN_C const CLSID CLSID_PDPO;

#ifdef __cplusplus

class DECLSPEC_UUID("CCB4EC60-B9DC-11D1-AC80-00A0C9034873")
PDPO;
#endif

EXTERN_C const CLSID CLSID_RootBinder;

#ifdef __cplusplus

class DECLSPEC_UUID("FF151822-B0BF-11D1-A80D-000000000000")
RootBinder;
#endif
#endif /* __MSDASC_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* [local][helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_CreateDBInstanceEx_Proxy( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [unique][in] */ COSERVERINFO *pServerInfo,
    /* [in] */ ULONG cmq,
    /* [size_is][out][in] */ MULTI_QI *rgmqResults);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataInitialize_CreateDBInstanceEx_Stub( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [unique][in] */ COSERVERINFO *pServerInfo,
    /* [in] */ ULONG cmq,
    /* [size_is][size_is][in] */ const IID **rgpIID,
    /* [size_is][size_is][out] */ IUnknown **rgpItf,
    /* [size_is][out] */ HRESULT *rghr);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\msdasc\msdasc_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdasc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "msdasc.h"

#define TYPE_FORMAT_STRING_SIZE   263                               
#define PROC_FORMAT_STRING_SIZE   301                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IService_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IService_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDataInitialize_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDataInitialize_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataInitialize_RemoteCreateDBInstanceEx_Proxy( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [unique][in] */ COSERVERINFO *pServerInfo,
    /* [in] */ ULONG cmq,
    /* [size_is][size_is][in] */ const IID **rgpIID,
    /* [size_is][size_is][out] */ IUnknown **rgpItf,
    /* [size_is][out] */ HRESULT *rghr)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[150],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IDataInitialize_RemoteCreateDBInstanceEx_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IDataInitialize *This;
        REFCLSID clsidProvider;
        IUnknown *pUnkOuter;
        DWORD dwClsCtx;
        LPOLESTR pwszReserved;
        COSERVERINFO *pServerInfo;
        ULONG cmq;
        const IID **rgpIID;
        IUnknown **rgpItf;
        HRESULT *rghr;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IDataInitialize_CreateDBInstanceEx_Stub(
                                                  (IDataInitialize *) pParamStruct->This,
                                                  pParamStruct->clsidProvider,
                                                  pParamStruct->pUnkOuter,
                                                  pParamStruct->dwClsCtx,
                                                  pParamStruct->pwszReserved,
                                                  pParamStruct->pServerInfo,
                                                  pParamStruct->cmq,
                                                  pParamStruct->rgpIID,
                                                  pParamStruct->rgpItf,
                                                  pParamStruct->rghr);
    
}



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure GetDataSource */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 10 */	NdrFcShort( 0x4c ),	/* 76 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter pUnkOuter */

/* 16 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 22 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszInitializationString */

/* 28 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 30 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 32 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter riid */

/* 34 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 36 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 38 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter ppDataSource */

/* 40 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 42 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 44 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 46 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 48 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 50 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInitializationString */

/* 52 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 54 */	NdrFcLong( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x4 ),	/* 4 */
/* 60 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 62 */	NdrFcShort( 0x5 ),	/* 5 */
/* 64 */	NdrFcShort( 0x8 ),	/* 8 */
/* 66 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pDataSource */

/* 68 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 70 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 72 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter fIncludePassword */

/* 74 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 76 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 78 */	0x3,		/* FC_SMALL */
			0x0,		/* 0 */

	/* Parameter ppwszInitString */

/* 80 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 82 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 84 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 86 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 88 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 90 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateDBInstance */

/* 92 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 94 */	NdrFcLong( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x5 ),	/* 5 */
/* 100 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 102 */	NdrFcShort( 0x90 ),	/* 144 */
/* 104 */	NdrFcShort( 0x8 ),	/* 8 */
/* 106 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter clsidProvider */

/* 108 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 112 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter pUnkOuter */

/* 114 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 116 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 118 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 120 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 122 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 124 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszReserved */

/* 126 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 128 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 130 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter riid */

/* 132 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 134 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 136 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter ppDataSource */

/* 138 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 140 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 142 */	NdrFcShort( 0x40 ),	/* Type Offset=64 */

	/* Return value */

/* 144 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 146 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateDBInstanceEx */

/* 150 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 152 */	NdrFcLong( 0x0 ),	/* 0 */
/* 156 */	NdrFcShort( 0x6 ),	/* 6 */
/* 158 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 160 */	NdrFcShort( 0x54 ),	/* 84 */
/* 162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 164 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0xa,		/* 10 */

	/* Parameter clsidProvider */

/* 166 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 168 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 170 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter pUnkOuter */

/* 172 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 174 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 176 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 178 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 180 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 182 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszReserved */

/* 184 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 186 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 188 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pServerInfo */

/* 190 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 192 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 194 */	NdrFcShort( 0x4a ),	/* Type Offset=74 */

	/* Parameter cmq */

/* 196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 198 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpIID */

/* 202 */	NdrFcShort( 0x200b ),	/* Flags:  must size, must free, in, srv alloc size=8 */
/* 204 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 206 */	NdrFcShort( 0xde ),	/* Type Offset=222 */

	/* Parameter rgpItf */

/* 208 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 210 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 212 */	NdrFcShort( 0xf4 ),	/* Type Offset=244 */

	/* Parameter rghr */

/* 214 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 216 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 218 */	NdrFcShort( 0xfc ),	/* Type Offset=252 */

	/* Return value */

/* 220 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 222 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LoadStringFromStorage */

/* 226 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 228 */	NdrFcLong( 0x0 ),	/* 0 */
/* 232 */	NdrFcShort( 0x7 ),	/* 7 */
/* 234 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 240 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pwszFileName */

/* 242 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 244 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 246 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppwszInitializationString */

/* 248 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 250 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 252 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 254 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 256 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteStringToStorage */

/* 260 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 262 */	NdrFcLong( 0x0 ),	/* 0 */
/* 266 */	NdrFcShort( 0x8 ),	/* 8 */
/* 268 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 270 */	NdrFcShort( 0x8 ),	/* 8 */
/* 272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 274 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pwszFileName */

/* 276 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 280 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pwszInitializationString */

/* 282 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 284 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 286 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter dwCreationDisposition */

/* 288 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 290 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 292 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 296 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x0 ),	/* 0 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 14 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 16 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 18 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 20 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 22 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 24 */	
			0x11, 0x0,	/* FC_RP */
/* 26 */	NdrFcShort( 0x8 ),	/* Offset= 8 (34) */
/* 28 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 34 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 36 */	NdrFcShort( 0x10 ),	/* 16 */
/* 38 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 40 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 42 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (28) */
			0x5b,		/* FC_END */
/* 46 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 48 */	NdrFcShort( 0x2 ),	/* Offset= 2 (50) */
/* 50 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 52 */	0x28,		/* Corr desc:  parameter, FC_LONG */
			0x0,		/*  */
/* 54 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 56 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 58 */	NdrFcShort( 0x2 ),	/* Offset= 2 (60) */
/* 60 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 62 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 64 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 66 */	NdrFcShort( 0x2 ),	/* Offset= 2 (68) */
/* 68 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 70 */	0x28,		/* Corr desc:  parameter, FC_LONG */
			0x0,		/*  */
/* 72 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 74 */	
			0x12, 0x0,	/* FC_UP */
/* 76 */	NdrFcShort( 0x72 ),	/* Offset= 114 (190) */
/* 78 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 80 */	NdrFcShort( 0x2 ),	/* 2 */
/* 82 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 84 */	NdrFcShort( 0x4 ),	/* 4 */
/* 86 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 88 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 90 */	NdrFcShort( 0x2 ),	/* 2 */
/* 92 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 94 */	NdrFcShort( 0xc ),	/* 12 */
/* 96 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 98 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 100 */	NdrFcShort( 0x2 ),	/* 2 */
/* 102 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 104 */	NdrFcShort( 0x14 ),	/* 20 */
/* 106 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 108 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 110 */	NdrFcShort( 0x1c ),	/* 28 */
/* 112 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 114 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 116 */	NdrFcShort( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 120 */	0x12, 0x0,	/* FC_UP */
/* 122 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (78) */
/* 124 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	NdrFcShort( 0x8 ),	/* 8 */
/* 130 */	0x12, 0x0,	/* FC_UP */
/* 132 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (88) */
/* 134 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 136 */	NdrFcShort( 0x10 ),	/* 16 */
/* 138 */	NdrFcShort( 0x10 ),	/* 16 */
/* 140 */	0x12, 0x0,	/* FC_UP */
/* 142 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (98) */
/* 144 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 146 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 148 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 150 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 152 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 154 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 156 */	NdrFcShort( 0x1c ),	/* 28 */
/* 158 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 160 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 164 */	NdrFcShort( 0x8 ),	/* 8 */
/* 166 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 168 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 170 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 172 */	NdrFcShort( 0x14 ),	/* 20 */
/* 174 */	NdrFcShort( 0x14 ),	/* 20 */
/* 176 */	0x12, 0x0,	/* FC_UP */
/* 178 */	NdrFcShort( 0xffffffba ),	/* Offset= -70 (108) */
/* 180 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 182 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 184 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 186 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 188 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 190 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 192 */	NdrFcShort( 0x10 ),	/* 16 */
/* 194 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 196 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 198 */	NdrFcShort( 0x4 ),	/* 4 */
/* 200 */	NdrFcShort( 0x4 ),	/* 4 */
/* 202 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 204 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 206 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	NdrFcShort( 0x8 ),	/* 8 */
/* 212 */	0x12, 0x0,	/* FC_UP */
/* 214 */	NdrFcShort( 0xffffffc4 ),	/* Offset= -60 (154) */
/* 216 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 218 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 220 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 222 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 224 */	NdrFcShort( 0x2 ),	/* Offset= 2 (226) */
/* 226 */	
			0x12, 0x0,	/* FC_UP */
/* 228 */	NdrFcShort( 0x2 ),	/* Offset= 2 (230) */
/* 230 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 232 */	NdrFcShort( 0x10 ),	/* 16 */
/* 234 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 236 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 238 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 240 */	NdrFcShort( 0xffffff32 ),	/* Offset= -206 (34) */
/* 242 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 244 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 246 */	NdrFcShort( 0xffffff0c ),	/* Offset= -244 (2) */
/* 248 */	
			0x11, 0x0,	/* FC_RP */
/* 250 */	NdrFcShort( 0x2 ),	/* Offset= 2 (252) */
/* 252 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 254 */	NdrFcShort( 0x4 ),	/* 4 */
/* 256 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 258 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 260 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_msdasc_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IService, ver. 0.0,
   GUID={0x06210E88,0x01F5,0x11D1,{0xB5,0x12,0x00,0x80,0xC7,0x81,0xC3,0x84}} */

#pragma code_seg(".orpc")
static const unsigned short IService_FormatStringOffsetTable[] =
    {
    (unsigned short) -1
    };

static const MIDL_STUBLESS_PROXY_INFO IService_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IService_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IService_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IService_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IServiceProxyVtbl = 
{
    &IService_ProxyInfo,
    &IID_IService,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IService::InvokeService */
};

const CInterfaceStubVtbl _IServiceStubVtbl =
{
    &IID_IService,
    &IService_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_msdasc_0351, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDBPromptInitialize, ver. 0.0,
   GUID={0x2206CCB0,0x19C1,0x11D1,{0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29}} */


/* Object interface: IDataInitialize, ver. 0.0,
   GUID={0x2206CCB1,0x19C1,0x11D1,{0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29}} */

#pragma code_seg(".orpc")
static const unsigned short IDataInitialize_FormatStringOffsetTable[] =
    {
    0,
    52,
    92,
    150,
    226,
    260
    };

static const MIDL_STUBLESS_PROXY_INFO IDataInitialize_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDataInitialize_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDataInitialize_StubThunkTable[] = 
    {
    0,
    0,
    0,
    IDataInitialize_RemoteCreateDBInstanceEx_Thunk,
    0,
    0
    };

static const MIDL_SERVER_INFO IDataInitialize_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDataInitialize_FormatStringOffsetTable[-3],
    &IDataInitialize_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(9) _IDataInitializeProxyVtbl = 
{
    &IDataInitialize_ProxyInfo,
    &IID_IDataInitialize,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDataInitialize::GetDataSource */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::GetInitializationString */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::CreateDBInstance */ ,
    IDataInitialize_CreateDBInstanceEx_Proxy ,
    (void *) (INT_PTR) -1 /* IDataInitialize::LoadStringFromStorage */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::WriteStringToStorage */
};

const CInterfaceStubVtbl _IDataInitializeStubVtbl =
{
    &IID_IDataInitialize,
    &IDataInitialize_ServerInfo,
    9,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x6000158, /* MIDL Version 6.0.344 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _msdasc_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IServiceProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDataInitializeProxyVtbl,
    0
};

const CInterfaceStubVtbl * _msdasc_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IServiceStubVtbl,
    ( CInterfaceStubVtbl *) &_IDataInitializeStubVtbl,
    0
};

PCInterfaceName const _msdasc_InterfaceNamesList[] = 
{
    "IService",
    "IDataInitialize",
    0
};


#define _msdasc_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _msdasc, pIID, n)

int __stdcall _msdasc_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _msdasc, 2, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _msdasc, 2, *pIndex )
    
}

const ExtendedProxyFileInfo msdasc_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _msdasc_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _msdasc_StubVtblList,
    (const PCInterfaceName * ) & _msdasc_InterfaceNamesList,
    0, // no delegation
    & _msdasc_IID_Lookup, 
    2,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdasc.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "msdasc.h"

#define TYPE_FORMAT_STRING_SIZE   243                               
#define PROC_FORMAT_STRING_SIZE   361                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IService_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IService_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDataInitialize_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDataInitialize_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataInitialize_RemoteCreateDBInstanceEx_Proxy( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [unique][in] */ COSERVERINFO *pServerInfo,
    /* [in] */ ULONG cmq,
    /* [size_is][size_is][in] */ const IID **rgpIID,
    /* [size_is][size_is][out] */ IUnknown **rgpItf,
    /* [size_is][out] */ HRESULT *rghr)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[180],
                  ( unsigned char * )This,
                  clsidProvider,
                  pUnkOuter,
                  dwClsCtx,
                  pwszReserved,
                  pServerInfo,
                  cmq,
                  rgpIID,
                  rgpItf,
                  rghr);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IDataInitialize_RemoteCreateDBInstanceEx_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IDataInitialize *This;
        REFCLSID clsidProvider;
        IUnknown *pUnkOuter;
        DWORD dwClsCtx;
        char Pad0[4];
        LPOLESTR pwszReserved;
        COSERVERINFO *pServerInfo;
        ULONG cmq;
        char Pad1[4];
        const IID **rgpIID;
        IUnknown **rgpItf;
        HRESULT *rghr;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IDataInitialize_CreateDBInstanceEx_Stub(
                                                  (IDataInitialize *) pParamStruct->This,
                                                  pParamStruct->clsidProvider,
                                                  pParamStruct->pUnkOuter,
                                                  pParamStruct->dwClsCtx,
                                                  pParamStruct->pwszReserved,
                                                  pParamStruct->pServerInfo,
                                                  pParamStruct->cmq,
                                                  pParamStruct->rgpIID,
                                                  pParamStruct->rgpItf,
                                                  pParamStruct->rghr);
    
}



#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure GetDataSource */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 10 */	NdrFcShort( 0x4c ),	/* 76 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 16 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x1 ),	/* 1 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 26 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 30 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 32 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 36 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszInitializationString */

/* 38 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 42 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter riid */

/* 44 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 46 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 48 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter ppDataSource */

/* 50 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 52 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 54 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 56 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 58 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 60 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInitializationString */

/* 62 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 64 */	NdrFcLong( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x4 ),	/* 4 */
/* 70 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 72 */	NdrFcShort( 0x5 ),	/* 5 */
/* 74 */	NdrFcShort( 0x8 ),	/* 8 */
/* 76 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 78 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
/* 84 */	NdrFcShort( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pDataSource */

/* 88 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 90 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 92 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter fIncludePassword */

/* 94 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 96 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 98 */	0x3,		/* FC_SMALL */
			0x0,		/* 0 */

	/* Parameter ppwszInitString */

/* 100 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 102 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 104 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 108 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateDBInstance */

/* 112 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x5 ),	/* 5 */
/* 120 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 122 */	NdrFcShort( 0x90 ),	/* 144 */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 128 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 130 */	NdrFcShort( 0x1 ),	/* 1 */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter clsidProvider */

/* 138 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 140 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 142 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter pUnkOuter */

/* 144 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 146 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 148 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 152 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszReserved */

/* 156 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 158 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 160 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter riid */

/* 162 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 164 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 166 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter ppDataSource */

/* 168 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 170 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 172 */	NdrFcShort( 0x42 ),	/* Type Offset=66 */

	/* Return value */

/* 174 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 176 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateDBInstanceEx */

/* 180 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 182 */	NdrFcLong( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0x6 ),	/* 6 */
/* 188 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 190 */	NdrFcShort( 0x54 ),	/* 84 */
/* 192 */	NdrFcShort( 0x8 ),	/* 8 */
/* 194 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 196 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 198 */	NdrFcShort( 0x2 ),	/* 2 */
/* 200 */	NdrFcShort( 0x4 ),	/* 4 */
/* 202 */	NdrFcShort( 0x0 ),	/* 0 */
/* 204 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter clsidProvider */

/* 206 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 208 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 210 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter pUnkOuter */

/* 212 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 214 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 216 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 218 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 220 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszReserved */

/* 224 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 226 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 228 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pServerInfo */

/* 230 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 232 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 234 */	NdrFcShort( 0x4e ),	/* Type Offset=78 */

	/* Parameter cmq */

/* 236 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 238 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpIID */

/* 242 */	NdrFcShort( 0x200b ),	/* Flags:  must size, must free, in, srv alloc size=8 */
/* 244 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 246 */	NdrFcShort( 0xc6 ),	/* Type Offset=198 */

	/* Parameter rgpItf */

/* 248 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 250 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 252 */	NdrFcShort( 0xde ),	/* Type Offset=222 */

	/* Parameter rghr */

/* 254 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 256 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 258 */	NdrFcShort( 0xe6 ),	/* Type Offset=230 */

	/* Return value */

/* 260 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 262 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LoadStringFromStorage */

/* 266 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x7 ),	/* 7 */
/* 274 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 278 */	NdrFcShort( 0x8 ),	/* 8 */
/* 280 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 282 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0x0 ),	/* 0 */
/* 290 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pwszFileName */

/* 292 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 294 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 296 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppwszInitializationString */

/* 298 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 300 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 302 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */

	/* Return value */

/* 304 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 306 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 308 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteStringToStorage */

/* 310 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 312 */	NdrFcLong( 0x0 ),	/* 0 */
/* 316 */	NdrFcShort( 0x8 ),	/* 8 */
/* 318 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 320 */	NdrFcShort( 0x8 ),	/* 8 */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 326 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 330 */	NdrFcShort( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pwszFileName */

/* 336 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 338 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 340 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pwszInitializationString */

/* 342 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 344 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 346 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter dwCreationDisposition */

/* 348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 350 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 354 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 356 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x0 ),	/* 0 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 14 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 16 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 18 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 20 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 22 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 24 */	
			0x11, 0x0,	/* FC_RP */
/* 26 */	NdrFcShort( 0x8 ),	/* Offset= 8 (34) */
/* 28 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 34 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 36 */	NdrFcShort( 0x10 ),	/* 16 */
/* 38 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 40 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 42 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (28) */
			0x5b,		/* FC_END */
/* 46 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 48 */	NdrFcShort( 0x2 ),	/* Offset= 2 (50) */
/* 50 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 52 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 54 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 56 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 58 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 60 */	NdrFcShort( 0x2 ),	/* Offset= 2 (62) */
/* 62 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 64 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 66 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 68 */	NdrFcShort( 0x2 ),	/* Offset= 2 (70) */
/* 70 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 72 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 74 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 76 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 78 */	
			0x12, 0x0,	/* FC_UP */
/* 80 */	NdrFcShort( 0x5e ),	/* Offset= 94 (174) */
/* 82 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 84 */	NdrFcShort( 0x2 ),	/* 2 */
/* 86 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 88 */	NdrFcShort( 0x8 ),	/* 8 */
/* 90 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 92 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 94 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 96 */	NdrFcShort( 0x2 ),	/* 2 */
/* 98 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 100 */	NdrFcShort( 0x18 ),	/* 24 */
/* 102 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 104 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 106 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 108 */	NdrFcShort( 0x2 ),	/* 2 */
/* 110 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 112 */	NdrFcShort( 0x28 ),	/* 40 */
/* 114 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 116 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 118 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 120 */	NdrFcShort( 0x30 ),	/* 48 */
/* 122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 124 */	NdrFcShort( 0xc ),	/* Offset= 12 (136) */
/* 126 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 128 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 130 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 132 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 134 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 136 */	
			0x12, 0x0,	/* FC_UP */
/* 138 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (82) */
/* 140 */	
			0x12, 0x0,	/* FC_UP */
/* 142 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (94) */
/* 144 */	
			0x12, 0x0,	/* FC_UP */
/* 146 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (106) */
/* 148 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 150 */	NdrFcShort( 0x28 ),	/* 40 */
/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 154 */	NdrFcShort( 0xc ),	/* Offset= 12 (166) */
/* 156 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 158 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 160 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 162 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 164 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 166 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 168 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 170 */	
			0x12, 0x0,	/* FC_UP */
/* 172 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (118) */
/* 174 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 176 */	NdrFcShort( 0x20 ),	/* 32 */
/* 178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0xa ),	/* Offset= 10 (190) */
/* 182 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 184 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 186 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 188 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 190 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 192 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 194 */	
			0x12, 0x0,	/* FC_UP */
/* 196 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (148) */
/* 198 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 200 */	NdrFcShort( 0x2 ),	/* Offset= 2 (202) */
/* 202 */	
			0x12, 0x0,	/* FC_UP */
/* 204 */	NdrFcShort( 0x2 ),	/* Offset= 2 (206) */
/* 206 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 208 */	NdrFcShort( 0x10 ),	/* 16 */
/* 210 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 212 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 214 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 216 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 218 */	NdrFcShort( 0xffffff48 ),	/* Offset= -184 (34) */
/* 220 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 222 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 224 */	NdrFcShort( 0xffffff22 ),	/* Offset= -222 (2) */
/* 226 */	
			0x11, 0x0,	/* FC_RP */
/* 228 */	NdrFcShort( 0x2 ),	/* Offset= 2 (230) */
/* 230 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 232 */	NdrFcShort( 0x4 ),	/* 4 */
/* 234 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 236 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 238 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 240 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_msdasc_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IService, ver. 0.0,
   GUID={0x06210E88,0x01F5,0x11D1,{0xB5,0x12,0x00,0x80,0xC7,0x81,0xC3,0x84}} */

#pragma code_seg(".orpc")
static const unsigned short IService_FormatStringOffsetTable[] =
    {
    (unsigned short) -1
    };

static const MIDL_STUBLESS_PROXY_INFO IService_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IService_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IService_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IService_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IServiceProxyVtbl = 
{
    &IService_ProxyInfo,
    &IID_IService,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IService::InvokeService */
};

const CInterfaceStubVtbl _IServiceStubVtbl =
{
    &IID_IService,
    &IService_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_msdasc_0351, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDBPromptInitialize, ver. 0.0,
   GUID={0x2206CCB0,0x19C1,0x11D1,{0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29}} */


/* Object interface: IDataInitialize, ver. 0.0,
   GUID={0x2206CCB1,0x19C1,0x11D1,{0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29}} */

#pragma code_seg(".orpc")
static const unsigned short IDataInitialize_FormatStringOffsetTable[] =
    {
    0,
    62,
    112,
    180,
    266,
    310
    };

static const MIDL_STUBLESS_PROXY_INFO IDataInitialize_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDataInitialize_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDataInitialize_StubThunkTable[] = 
    {
    0,
    0,
    0,
    IDataInitialize_RemoteCreateDBInstanceEx_Thunk,
    0,
    0
    };

static const MIDL_SERVER_INFO IDataInitialize_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDataInitialize_FormatStringOffsetTable[-3],
    &IDataInitialize_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(9) _IDataInitializeProxyVtbl = 
{
    &IDataInitialize_ProxyInfo,
    &IID_IDataInitialize,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDataInitialize::GetDataSource */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::GetInitializationString */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::CreateDBInstance */ ,
    IDataInitialize_CreateDBInstanceEx_Proxy ,
    (void *) (INT_PTR) -1 /* IDataInitialize::LoadStringFromStorage */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::WriteStringToStorage */
};

const CInterfaceStubVtbl _IDataInitializeStubVtbl =
{
    &IID_IDataInitialize,
    &IDataInitialize_ServerInfo,
    9,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000158, /* MIDL Version 6.0.344 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _msdasc_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IServiceProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDataInitializeProxyVtbl,
    0
};

const CInterfaceStubVtbl * _msdasc_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IServiceStubVtbl,
    ( CInterfaceStubVtbl *) &_IDataInitializeStubVtbl,
    0
};

PCInterfaceName const _msdasc_InterfaceNamesList[] = 
{
    "IService",
    "IDataInitialize",
    0
};


#define _msdasc_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _msdasc, pIID, n)

int __stdcall _msdasc_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _msdasc, 2, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _msdasc, 2, *pIndex )
    
}

const ExtendedProxyFileInfo msdasc_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _msdasc_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _msdasc_StubVtblList,
    (const PCInterfaceName * ) & _msdasc_InterfaceNamesList,
    0, // no delegation
    & _msdasc_IID_Lookup, 
    2,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\msxml2\xmldocnf_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for xmldocnf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IXMLDocumentNotify,0x53BE4F42,0x3602,0x11d2,0x80,0x1B,0x00,0x00,0xF8,0x7A,0x6C,0xDF);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for xmldocnf.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IXMLDocumentNotify,0x53BE4F42,0x3602,0x11d2,0x80,0x1B,0x00,0x00,0xF8,0x7A,0x6C,0xDF);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\osptk\msdatsrc_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdatsrc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDATASRC,0x7c0ffab0,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);


MIDL_DEFINE_GUID(IID, IID_DataSourceListener,0x7c0ffab2,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);


MIDL_DEFINE_GUID(IID, IID_DataSource,0x7c0ffab3,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdatsrc.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDATASRC,0x7c0ffab0,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);


MIDL_DEFINE_GUID(IID, IID_DataSourceListener,0x7c0ffab2,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);


MIDL_DEFINE_GUID(IID, IID_DataSource,0x7c0ffab3,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\osptk\msdaosp_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdaosp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDAOSPT,0x0ae9a4e0,0x18d4,0x11d1,0xb3,0xb3,0x00,0xaa,0x00,0xc1,0xa9,0x24);


MIDL_DEFINE_GUID(IID, DIID_DataSourceObject,0x0ae9a4e4,0x18d4,0x11d1,0xb3,0xb3,0x00,0xaa,0x00,0xc1,0xa9,0x24);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdaosp.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDAOSPT,0x0ae9a4e0,0x18d4,0x11d1,0xb3,0xb3,0x00,0xaa,0x00,0xc1,0xa9,0x24);


MIDL_DEFINE_GUID(IID, DIID_DataSourceObject,0x0ae9a4e4,0x18d4,0x11d1,0xb3,0xb3,0x00,0xaa,0x00,0xc1,0xa9,0x24);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\msxml2\xmlparser_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for xmlparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_XMLPSR,0xd242361c,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLNodeSource,0xd242361d,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLParser,0xd242361e,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLNodeFactory,0xd242361f,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser,0xf5078f19,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser26,0xf5078f20,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser30,0xf5078f31,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for xmlparser.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_XMLPSR,0xd242361c,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLNodeSource,0xd242361d,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLParser,0xd242361e,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLNodeFactory,0xd242361f,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser,0xf5078f19,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser26,0xf5078f20,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser30,0xf5078f31,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\olepro32\olepro32.c ===
#include <windows.h>
#include <ole2.h>

STDAPI DllRegisterServer(void) {return E_NOTIMPL; }

STDAPI DllUnregisterServer(void) {return E_NOTIMPL; }

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv) { return E_NOTIMPL; }

STDAPI DllCanUnloadNow(void) { return E_NOTIMPL; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\osptk\simpdata_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for simpdata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDAOSP,0xE0E270C2,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);


MIDL_DEFINE_GUID(IID, IID_OLEDBSimpleProviderListener,0xE0E270C1,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);


MIDL_DEFINE_GUID(IID, IID_OLEDBSimpleProvider,0xE0E270C0,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for simpdata.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDAOSP,0xE0E270C2,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);


MIDL_DEFINE_GUID(IID, IID_OLEDBSimpleProviderListener,0xE0E270C1,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);


MIDL_DEFINE_GUID(IID, IID_OLEDBSimpleProvider,0xE0E270C0,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\regprep\regprep.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "regprep.h"

int ProgramStatus = 0;

BOOL 
EnableRestorePrivilege(
    VOID
    );

VOID
PerformRegMods (
    HANDLE HiveHandle
    );


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    PCHAR hivePath;
    HANDLE hiveHandle;
    BOOL result;

    if (argc != 2) {
        printf("Usage: regprep <hivepath>\n");
        exit(-1);
    }

    result = EnableRestorePrivilege();
    if (result == FALSE) {
        printf("Could not enable restore privileges\n");
        exit(-1);
    }

    hivePath = argv[1];
    hiveHandle = OpenHive(hivePath);

    RASSERT(hiveHandle != NULL,"Could not load %s",hivePath);

    PerformRegMods(hiveHandle);

    CloseHive(hiveHandle);

    return ProgramStatus;
}

VOID
PerformRegMods (
    HANDLE HiveHandle
    )
{
    HKEY subKey;
    ULONG index;
    UCHAR driveLetter;
    UCHAR buffer[MAX_PATH];
    LONG result;
    PUCHAR pch;

    printf("Processing registry\n");

    //
    // Remove the volume names for hard drives from the "MountedDevices"
    // hive, i.e.
    //
    // \DosDevices\C:
    // \DosDevices\D:
    // ...
    //

    pch = "MountedDevices";
    result = RegOpenKey(HiveHandle,pch,&subKey);
    RASSERT(result == ERROR_SUCCESS,"Could not open %s\n",pch);

    for (driveLetter = 'C'; driveLetter <= 'Z'; driveLetter++) {
        sprintf(buffer,"\\DosDevices\\%c:", driveLetter);
        result = RegDeleteValue(subKey,buffer);
    }
    RegCloseKey(subKey);

    //
    // Add
    //
    // CurrentControlSet\Control\Session Manager\KnownDLLs\DllDirectory32
    //

    index = 1;
    while (TRUE) {

        sprintf(buffer,
                "ControlSet%03d\\Control\\Session Manager\\KnownDLLs",
                index);

        result = RegOpenKey(HiveHandle,buffer,&subKey);
        if (result != ERROR_SUCCESS) {
            break;
        }

        pch = "%SystemRoot%\\SysWow64";
        result = RegSetValueEx(subKey,
                               "DllDirectory32",
                               0,
                               REG_EXPAND_SZ,
                               pch,
                               strlen(pch)+1);
        RASSERT(result == ERROR_SUCCESS,"Could not set value %s",pch);

        RegCloseKey(subKey);

        index += 1;
    }

    printf("Finished.\n");
}

BOOL 
EnableRestorePrivilege(
    VOID
    )
{
    BOOL result;
    HANDLE hToken;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    //
    // Open our process' security token.
    //

    result = OpenProcessToken(GetCurrentProcess(),
                              TOKEN_ADJUST_PRIVILEGES,
                              &hToken);
    if (result == FALSE) {
        return result;
    }

    //
    // Convert privi name to an LUID.
    //

    result = LookupPrivilegeValue(NULL, 
                                  "SeRestorePrivilege",
                                  &Luid);
    if (result == FALSE) {
        CloseHandle(hToken);
        return FALSE;
    }
    
    //
    // Construct new data struct to enable / disable the privi.
    //

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Adjust the privileges.
    //

    result = AdjustTokenPrivileges(hToken,
                                   FALSE,
                                   &NewPrivileges,
                                   0,
                                   NULL,
                                   NULL);
    CloseHandle(hToken);
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\regprep\hiveload.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntregapi.h>
#include <stdio.h>
#include <stdlib.h>
#include "regprep.h"


#define TEMP_HIVE_KEY L"\\Registry\\User\\FooTempKey"

OBJECT_ATTRIBUTES TargetKey;
UNICODE_STRING TargetKeyName;

HANDLE
OpenHive (
    IN PCHAR HivePath
    )
{
    UNICODE_STRING sourceFileName;
    UNICODE_STRING sourceNtFileName;
    OBJECT_ATTRIBUTES sourceFile;
    BOOLEAN result;
    NTSTATUS status;
    HANDLE keyHandle;
    SECURITY_DESCRIPTOR securityDescriptor;

    //
    // Open the registry root
    //

    status = RtlCreateSecurityDescriptor(&securityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION);
    RASSERT(NT_SUCCESS(status),
            "Error 0x%x from RtlCreateSecurityDescriptor",
            status);

    status = RtlSetDaclSecurityDescriptor(&securityDescriptor,
                                          TRUE,
                                          NULL,
                                          FALSE);
    RASSERT(NT_SUCCESS(status),
            "Error 0x%x from RtlSetDaclSecurityDescriptor",
            status);

    result = RtlCreateUnicodeStringFromAsciiz(&sourceFileName, HivePath);
    if (result == FALSE) {
        printf("Out of memory\n");
        return NULL;
    }

    result = RtlDosPathNameToNtPathName_U(sourceFileName.Buffer,
                                          &sourceNtFileName,
                                          NULL,
                                          NULL);
    RtlFreeUnicodeString(&sourceFileName);

    RASSERT(result != FALSE,
            "RtlDosPathNameToNtPathName() failed",
            NULL);

    InitializeObjectAttributes(&sourceFile,
                               &sourceNtFileName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               &securityDescriptor);


    RtlInitUnicodeString(&TargetKeyName, TEMP_HIVE_KEY);

    InitializeObjectAttributes(&TargetKey,
                               &TargetKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtLoadKey(&TargetKey,&sourceFile);
    RtlFreeUnicodeString(&sourceNtFileName);

    if (!NT_SUCCESS(status)) {
        printf("Error 0x%x loading %s\n",status,HivePath);
        return NULL;
    }

    //
    // The hive has been loaded, now open it
    //

    status = NtOpenKey(&keyHandle,KEY_ALL_ACCESS,&TargetKey);
    if (!NT_SUCCESS(status)) {
        NtUnloadKey(&TargetKey);
        printf("Error 0x%x opening %s\n",status,HivePath);
        return NULL;
    }

    return keyHandle;
}

VOID
CloseHive (
    IN HANDLE Handle
    )
{
    NTSTATUS status;

    NtClose(Handle);

    status = NtUnloadKey(&TargetKey);
    if (!NT_SUCCESS(status)) {
        printf("Error 0x%x unloading key\n",status);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\regprep\regprep.h ===
VOID
CloseHive (
    IN HANDLE Handle
    );

HANDLE
OpenHive (
    IN PCHAR HivePath
    );

extern int ProgramStatus;

#define RASSERT(x,m,s) if (!(x)) { printf(m,s); ProgramStatus = -1; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\stuff\smtpsnap\smtpsnap.c ===
#include "windows.h"

STDAPI
DllCanUnloadNow (
    void
    )

{
    return 0;
}

STDAPI
DllGetClassObject (
    IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )

{
    return 0;
}

STDAPI
DllRegisterServer (
    void
    )

{
    return 0;
}

STDAPI
DllUnregisterServer (
    void
    )

{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bndist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bndist.cpp
//
//--------------------------------------------------------------------------

//
//	BNDIST.CPP
//

#include <basetsd.h>
#include <iostream>
#include <fstream>

#include "symtmbn.h"

LEAK_VAR_DEF(BNDIST)

static void dumpVimd ( const VIMD & vimd )
{
	for ( int i = 0 ; i < vimd.size(); i++ )
	{
		cout << vimd[i];
		if ( i + 1 < vimd.size() )
			cout << ",";
	}	
}

static void dumpVlr ( const VLREAL & vlr )
{
	for ( int i = 0 ; i < vlr.size(); i++ )
	{
		cout << vlr[i];
		if ( i + 1 < vlr.size() )
			cout << ",";
	}	
}

static void dumpSlice ( const MDVSLICE & mslice, bool bStrides = true)
{
	VIMD vimdLengths = mslice.size();
	VIMD vimdStrides = mslice.stride();
	size_t iStart = mslice.start();

	cout << "\nslice start="
		 << (UINT) iStart
		 << "\tlengths=";
	dumpVimd( vimdLengths );
	if ( bStrides )
	{
		cout << "\tstrides=" ;
		dumpVimd( vimdStrides );
	}
	cout << "\ttotlen="
		 << (UINT) mslice._Totlen();
}

static void dumpMdv ( MDVCPD & mdv, const MDVSLICE * pslice = NULL )
{	
	if ( pslice == NULL )
		pslice = & mdv.Slice();
	dumpSlice( *pslice );
	MDVCPD::Iterator itmd(mdv, *pslice );
	while (itmd.BNext())
	{
		size_t icurr = itmd.ICurr();
		cout << "\n";
		dumpVimd( itmd.Vitmd() );
		REAL & r = itmd.Next();
		cout << "\t["
			<< (UINT) icurr
			<< "] = "
			<< r ;
	}
	cout << "\n";
}

BNDIST :: BNDIST ()
	:_edist(ED_NONE),
	_pmdvcpd(NULL),
	_mpcpdd(NULL)
{
	LEAK_VAR_UPD(1)
}

BNDIST :: ~ BNDIST ()
{
	Clear();
	LEAK_VAR_UPD(-1)
}

void BNDIST :: NoRef ()
{
	delete this;
}

BNDIST & BNDIST :: operator = ( const BNDIST & bnd )
{
	Clear();
	switch ( _edist = bnd._edist )
	{
		default:
		case ED_NONE:
			break;
		case ED_DENSE:
			_pmdvcpd = new MDVCPD( bnd.Mdvcpd() );
			assert( _pmdvcpd->first.size() == bnd.Mdvcpd().first.size() );
			break;
		case ED_CI_MAX:
		case ED_CI_PLUS:
		case ED_SPARSE:
			_mpcpdd = new MPCPDD( bnd.Mpcpdd() ) ;
			assert( _mpcpdd->size() == bnd.Mpcpdd().size() );
			break;			
	}
	return self;
}

BNDIST :: BNDIST ( const BNDIST & bnd )
	:_edist(ED_NONE),
	_pmdvcpd(NULL),
	_mpcpdd(NULL)
{
	(*this) = bnd;

	LEAK_VAR_UPD(1)
}

bool BNDIST :: BChangeSubtype ( EDIST edist )
{
	if ( BDenseType(edist) ^ BDense() )
		return false;
	_edist = edist;
	return true;
}

void BNDIST :: Dump ()
{
	if ( _pmdvcpd )
	{
		cout << "\n\tDense version:";
		DumpDense();
	}
	if ( _mpcpdd )
	{
		cout << "\n\tSparse version:";
		DumpSparse();
	}
	cout << "\n\n";
}

void BNDIST :: DumpSparse ()
{
	assert( _mpcpdd );
	MPCPDD & dmap = *_mpcpdd;
	int i = 0;
	for ( MPCPDD::iterator itdm = dmap.begin();
		  itdm != dmap.end();
		  ++itdm, ++i )
	{
		const VIMD & vimd = (*itdm).first;
		const VLREAL & vlr = (*itdm).second;
		cout << "\n["
			 << i
			 << "] (";
		dumpVimd(vimd);
		cout << ")\t";
		dumpVlr(vlr);
	}
}

void BNDIST :: DumpDense ()
{
	assert( _pmdvcpd );
	dumpMdv( *_pmdvcpd );
}

void BNDIST :: ConvertToDense ( const VIMD & vimd )
{
	assert( _edist == ED_NONE || _edist == ED_SPARSE );

	if ( _edist == ED_NONE )
	{
		assert( ! _mpcpdd );
		return;
	}
	//  See if there is a sparse distribution to convert
	if ( ! _mpcpdd )
		throw GMException( EC_DIST_MISUSE, "no prior sparse distribution to convert" );

	int cParent = vimd.size() - 1;
	int cState = vimd[cParent];
	MPCPDD & dmap = *_mpcpdd;
	VIMD vimdMt;					//  Empty subscript array
	VLREAL vlrDefault(cState);		//	Default value array

	//  First, try to find the default entry; use -1 if not found
	MPCPDD::iterator itdm = dmap.find(vimdMt);
	if ( itdm != dmap.end() )
		vlrDefault = (*itdm).second;
	else
		vlrDefault = -1;	// fill the array with -1.

	assert( vlrDefault.size() == cState );

	//  Allocate the new dense m-d array
	delete _pmdvcpd;
	_pmdvcpd = new MDVCPD( vimd );
	MDVCPD & mdv = *_pmdvcpd;
	//  Fill each DPI with the appropriate default value
	MDVCPD::Iterator itmdv(mdv);
	for ( int iState = 0; itmdv.BNext() ; iState++ )
	{
		itmdv.Next() = vlrDefault[ iState % cState ];
	}
	
	//
	//  Now, iterate over the sparse array and store in the appropriate locations.
	//	Each entry in the sparse map is a complete state set for the target node.
	//  Since the child (target) node probabilities are the fastest varying subscript,
	//  each entry in sparse map is spread across "cState" entries in the dense map.
	//	
	//	Of course, this could be more efficient, but we're just testing for now.
	//
	VIMD vimdDense(vimd.size());
	for ( itdm = dmap.begin(); itdm != dmap.end() ; ++itdm )
	{
		const VIMD & vimdSub = (*itdm).first;
		VLREAL & vlrNext = (*itdm).second;
		for ( int ip = 0 ; ip < cParent; ip++ )
		{
			vimdDense[ip] = vimdSub[ip];
		}
		for ( int ist = 0 ; ist < cState; ++ist )
		{
			vimdDense[cParent] = ist;
			mdv[vimdDense] = vlrNext[ist];
		}
	}
	
	//  Finally, nuke the old sparse distribution
	delete _mpcpdd;
	_mpcpdd = NULL;
	//  Set distribution type
	_edist = ED_DENSE;
}

//  Set distribution to "dense"
void BNDIST :: SetDense ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_pmdvcpd = new MDVCPD( vimd );
	_edist = ED_DENSE;
}

//  Set distribution to sparse
void BNDIST :: SetSparse ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_mpcpdd = new MPCPDD;
	_edist = ED_SPARSE;
}

//  Return the "leak" or "default" vector from a sparse distribution
const VLREAL * BNDIST :: PVlrLeak () const
{
	assert( BSparse() );
	const MPCPDD & dmap = Mpcpdd();
	const VIMD & vimdDim = VimdDim();
	VIMD vimdLeak;

	//  First try to find the dimensionless "default" vector.
	const VLREAL * pvlrDefault = dmap.PVlrDefault();

	//  Now try to find a specific zeroth vector; note that valarray<T>::resize
	//		stores all zeroes into the valarray by default.  Also, skip the
	//		loweest dimension, since that's the size of each vector in the
	//		sparse map.
	vimdLeak.resize( vimdDim.size() - 1 );	
	const VLREAL * pvlrLeak = NULL;
	MPCPDD::const_iterator itdm = dmap.find( vimdLeak );
	if ( itdm != dmap.end() )
		pvlrLeak = & (*itdm).second;

	return pvlrLeak
		 ? pvlrLeak
		 : pvlrDefault;
}

void BNDIST :: Clone ( const BNDIST & bndist )
{
	ASSERT_THROW( _edist == ED_NONE,
			EC_INVALID_CLONE,
			"cannot clone into non-empty structure" );
	self = bndist;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\basics.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       basics.h
//
//--------------------------------------------------------------------------

//
//	BASICS.H:  Basic STL-based declarations
//

#ifndef _BASICS_H_
#define _BASICS_H_

// handle version differences
#include "mscver.h"

#include <tchar.h>
// STL Inclusions
#include <exception>
#include <vector>

USE_STD_NAMESPACE;


//	General common typedefs
typedef TCHAR * TZC;
typedef const TCHAR * TSZC;
typedef const char * SZC;
typedef char * SZ;
typedef unsigned int UINT;
typedef unsigned short USINT;
typedef unsigned long ULONG;
typedef long	LONG;
typedef int		INT;
typedef short	SINT;
typedef double	REAL;
typedef double	DBL;
typedef double	PROB;
typedef double  COST;
typedef double	SSTAT;
typedef	double	PARAM;
typedef double  MEAN;
typedef double	COV;
typedef	double	LOGPROB;
typedef UINT	IDPI;		// 2^n, last-fastest (I)ndex indicating a (D)iscrete
							//	(P)arent (I)nstance

//  Define array indexing values and discrete state counting values identically
typedef UINT	IMD;		// Index into a multidimensional array
typedef UINT	CST;		// Count of states
typedef UINT	IST;		// Index of a discrete state
typedef INT		SIMD;		// Signed index into a multidimensonal array
typedef	float	RST;		// Real-valued state
typedef UINT	TOKEN;		// Parser token
typedef int		BOOL;		// Must remain int, because windows.h defines it also
							
#ifndef VOID
#define VOID	void		// MSRDEVBUG: Archaic usage
#endif

typedef char	CHAR;
//  'qsort' interface function prototypedef
typedef	INT		(*PFNCMP)(const VOID*, const VOID*);

#define CONSTANT static const					//  define a program-scoped constant

//  General constants
CONSTANT INT	INIL		= INT_MAX;			//  Invalid signed integer
CONSTANT UINT	UINIL		= INT_MAX;			//  Invalid unsigned integer (compatible with int)
CONSTANT long	INFINITY	= 100000000;		//  A very large integer value
CONSTANT REAL	RTINY		= 1.0e-20;			//  A number very close to zero (from Numerical Recipies)
CONSTANT REAL	RNEARLYONE	= 1.0 - RTINY;		//  A number very close to one
CONSTANT REAL   RNA			= -1.0;				//  "unassessed" value

//	Database constant values
CONSTANT IST	istMissing	= 22223;
CONSTANT IST	istInvalid	= IST(-1);			//  MSRDEVBUG: should be UINIL
CONSTANT RST	rstMissing	= (RST) 22223.12345;
CONSTANT RST	rstInvalid	= (RST) 22223.54321;


// A useful alias in member functions
#define self (*this)

//  Define common vector classes and macros to generalize declarations.

typedef vector<bool> vbool;		//  Vector of 'bool': lower case to distinguish from BOOL (in windows.h)

#define DEFINEV(T)		typedef vector<T> V##T;
#define DEFINEVP(T)		typedef vector<T *> VP##T;
#define DEFINEVCP(T)	typedef vector<const T *> VCP##T;

DEFINEV(UINT);		// Define VUINT
DEFINEV(VUINT);
DEFINEV(INT);		// Define VINT
DEFINEV(USINT);		// Define VUSINT
DEFINEV(REAL);		// Define VREAL
DEFINEV(PROB);	
DEFINEV(VPROB);	
DEFINEV(DBL);
DEFINEV(VDBL);
DEFINEV(VVDBL);
DEFINEV(SSTAT);
DEFINEV(VSSTAT);
DEFINEV(CST);
DEFINEV(VCST);
DEFINEV(IST);
DEFINEV(VIST);
DEFINEV(RST);
DEFINEV(BOOL);
DEFINEV(VBOOL);
DEFINEV(PARAM);
DEFINEV(SZ);
DEFINEV(VSZ);
DEFINEV(SZC);
DEFINEV(VSZC);
DEFINEV(MEAN);
DEFINEV(COV);
DEFINEV(IMD);		// Define VIMD: vector of indicies into an m-d array
DEFINEV(SIMD);		// Define VSIMD: for an array of SIGNED dimensions

//  Macro to control hiding of unsafe elements
#ifndef DONT_HIDE_ALL_UNSAFE
  #define HIDE_UNSAFE(T)				\
	private:							\
		T(const T &);					\
		T & operator = (const T &);
  #define HIDE_AS(T) private: T & operator = (const T &);
  #define HIDE_CC(T) T(const T &);	
#else
  #define HIDE_UNSAFE(T)
#endif


//  Macro to generate the ordering operators which must be declared
//	for use in arrays but which do not need to exist unless used.
#define DECLARE_ORDERING_OPERATORS(T)				\
	bool operator <  ( const T & ) const;			\
	bool operator >  ( const T & ) const;			\
	bool operator == ( const T & ) const;			\
	bool operator != ( const T & ) const;

//
//	UBOUND: macro to return the number of elements in a static array
//
#ifndef UBOUND
  #define UBOUND(rg)  (sizeof rg/sizeof rg[0])
#endif

#include "gmexcept.h"
#include "dyncast.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bndist.new.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bndist.cpp
//
//--------------------------------------------------------------------------

//
//	BNDIST.CPP
//

#include <basetsd.h>
#include <iostream>
#include <fstream>

#include "symtmbn.h"

LEAK_VAR_DEF(BNDIST)

static void dumpVimd ( const VIMD & vimd )
{
	for ( int i = 0 ; i < vimd.size(); i++ )
	{
		cout << vimd[i];
		if ( i + 1 < vimd.size() )
			cout << ",";
	}	
}

static void dumpVlr ( const VLREAL & vlr )
{
	for ( int i = 0 ; i < vlr.size(); i++ )
	{
		cout << vlr[i];
		if ( i + 1 < vlr.size() )
			cout << ",";
	}	
}

static void dumpSlice ( const MDVSLICE & mslice, bool bStrides = true)
{
	VIMD vimdLengths = mslice.size();
	VIMD vimdStrides = mslice.stride();
	size_t iStart = mslice.start();

	cout << "\nslice start="
		 << (UINT) iStart
		 << "\tlengths=";
	dumpVimd( vimdLengths );
	if ( bStrides )
	{
		cout << "\tstrides=" ;
		dumpVimd( vimdStrides );
	}
	cout << "\ttotlen="
		 << (UINT) mslice._Totlen();
}

static void dumpMdv ( MDVCPD & mdv, const MDVSLICE * pslice = NULL )
{	
	if ( pslice == NULL )
		pslice = & mdv.Slice();
	dumpSlice( *pslice );
	MDVCPD::Iterator itmd(mdv, *pslice );
	while (itmd.BNext())
	{
		size_t icurr = itmd.ICurr();
		cout << "\n";
		dumpVimd( itmd.Vitmd() );
		REAL & r = itmd.Next();
		cout << "\t["
			<< (UINT) icurr
			<< "] = "
			<< r ;
	}
	cout << "\n";
}

BNDIST :: BNDIST ()
	:_edist(ED_NONE),
	_pmdvcpd(NULL),
	_mpcpdd(NULL)
{
	LEAK_VAR_UPD(1)
}

BNDIST :: ~ BNDIST ()
{
	Clear();
	LEAK_VAR_UPD(-1)
}

void BNDIST :: NoRef ()
{
	delete this;
}

BNDIST & BNDIST :: operator = ( const BNDIST & bnd )
{
	Clear();
	switch ( _edist = bnd._edist )
	{
		default:
		case ED_NONE:
			break;
		case ED_DENSE:
			_pmdvcpd = new MDVCPD( bnd.Mdvcpd() );
			assert( _pmdvcpd->first.size() == bnd.Mdvcpd().first.size() );
			break;
		case ED_CI_MAX:
		case ED_CI_PLUS:
		case ED_SPARSE:
			_mpcpdd = new MPCPDD( bnd.Mpcpdd() ) ;
			assert( _mpcpdd->size() == bnd.Mpcpdd().size() );
			break;			
	}
	return self;
}

BNDIST :: BNDIST ( const BNDIST & bnd )
	:_edist(ED_NONE),
	_pmdvcpd(NULL),
	_mpcpdd(NULL)
{
	(*this) = bnd;

	LEAK_VAR_UPD(1)
}

bool BNDIST :: BChangeSubtype ( EDIST edist )
{
	if ( BDenseType(edist) ^ BDense() )
		return false;
	_edist = edist;
	return true;
}

void BNDIST :: Dump ()
{
	if ( _pmdvcpd )
	{
		cout << "\n\tDense version:";
		DumpDense();
	}
	if ( _mpcpdd )
	{
		cout << "\n\tSparse version:";
		DumpSparse();
	}
	cout << "\n\n";
}

void BNDIST :: DumpSparse ()
{
	assert( _mpcpdd );
	MPCPDD & dmap = *_mpcpdd;
	int i = 0;
	for ( MPCPDD::iterator itdm = dmap.begin();
		  itdm != dmap.end();
		  ++itdm, ++i )
	{
		const VIMD & vimd = (*itdm).first;
		const VLREAL & vlr = (*itdm).second;
		cout << "\n["
			 << i
			 << "] (";
		dumpVimd(vimd);
		cout << ")\t";
		dumpVlr(vlr);
	}
}

void BNDIST :: DumpDense ()
{
	assert( _pmdvcpd );
	dumpMdv( *_pmdvcpd );
}

void BNDIST :: ConvertToDense ( const VIMD & vimd )
{
	assert( _edist == ED_NONE || _edist == ED_SPARSE );

	if ( _edist == ED_NONE )
	{
		assert( ! _mpcpdd );
		return;
	}
	//  See if there is a sparse distribution to convert
	if ( ! _mpcpdd )
		throw GMException( EC_DIST_MISUSE, "no prior sparse distribution to convert" );

	int cParent = vimd.size() - 1;
	int cState = vimd[cParent];
	MPCPDD & dmap = *_mpcpdd;
	VIMD vimdMt;					//  Empty subscript array
	VLREAL vlrDefault(cState);		//	Default value array

	//  First, try to find the default entry; use -1 if not found
	MPCPDD::iterator itdm = dmap.find(vimdMt);
	if ( itdm != dmap.end() )
		vlrDefault = (*itdm).second;
	else
		vlrDefault = -1;	// fill the array with -1.

	assert( vlrDefault.size() == cState );

	//  Allocate the new dense m-d array
	delete _pmdvcpd;
	_pmdvcpd = new MDVCPD( vimd );
	MDVCPD & mdv = *_pmdvcpd;
	//  Fill each DPI with the appropriate default value
	MDVCPD::Iterator itmdv(mdv);
	for ( int iState = 0; itmdv.BNext() ; iState++ )
	{
		itmdv.Next() = vlrDefault[ iState % cState ];
	}
	
	//
	//  Now, iterate over the sparse array and store in the appropriate locations.
	//	Each entry in the sparse map is a complete state set for the target node.
	//  Since the child (target) node probabilities are the fastest varying subscript,
	//  each entry in sparse map is spread across "cState" entries in the dense map.
	//	
	//	Of course, this could be more efficient, but we're just testing for now.
	//
	VIMD vimdDense(vimd.size());
	for ( itdm = dmap.begin(); itdm != dmap.end() ; ++itdm )
	{
		const VIMD & vimdSub = (*itdm).first;
		VLREAL & vlrNext = (*itdm).second;
		for ( int ip = 0 ; ip < cParent; ip++ )
		{
			vimdDense[ip] = vimdSub[ip];
		}
		for ( int ist = 0 ; ist < cState; ++ist )
		{
			vimdDense[cParent] = ist;
			mdv[vimdDense] = vlrNext[ist];
		}
	}
	
	//  Finally, nuke the old sparse distribution
	delete _mpcpdd;
	_mpcpdd = NULL;
	//  Set distribution type
	_edist = ED_DENSE;
}

//  Set distribution to "dense"
void BNDIST :: SetDense ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_pmdvcpd = new MDVCPD( vimd );
	_edist = ED_DENSE;
}

//  Set distribution to sparse
void BNDIST :: SetSparse ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_mpcpdd = new MPCPDD;
	_edist = ED_SPARSE;
}

//  Return the "leak" or "default" vector from a sparse distribution
const VLREAL * BNDIST :: PVlrLeak () const
{
	assert( BSparse() );
	const MPCPDD & dmap = Mpcpdd();
	const VIMD & vimdDim = VimdDim();
	VIMD vimdLeak;

	//  First try to find the dimensionless "default" vector.
	const VLREAL * pvlrDefault = dmap.PVlrDefault();

	//  Now try to find a specific zeroth vector; note that valarray<T>::resize
	//		stores all zeroes into the valarray by default.  Also, skip the
	//		loweest dimension, since that's the size of each vector in the
	//		sparse map.
	vimdLeak.resize( vimdDim.size() - 1 );	
	VLREAL * pvlrLeak = NULL;
	//MPCPDD::iterator itdm = dmap.find( vimdLeak );
	MPCPDD::const_iterator itdm = dmap.find( vimdLeak );
	if ( itdm != dmap.end() )
		//pvlrLeak = & (*itdm).second;
		pvlrLeak = (VLREAL*)& (*itdm).second;

	return pvlrLeak
		 ? pvlrLeak
		 : pvlrDefault;
}

void BNDIST :: Clone ( const BNDIST & bndist )
{
	ASSERT_THROW( _edist == ED_NONE,
			EC_INVALID_CLONE,
			"cannot clone into non-empty structure" );
	self = bndist;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bnparse.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bnparse.cpp
//
//--------------------------------------------------------------------------

//
//	BNPARSE.CPP
//
#include <windows.h>
#include <stdarg.h>
#include <assert.h>

#include "bnparse.h"
#include "bnreg.h"

DSCPARSER :: DSCPARSER (
	MBNET & mbnet,
	PARSIN & flpIn,
	PARSOUT & _flpOut )
	: _flpIn( flpIn ),
	_flpOut( _flpOut ),
	_mbnet(mbnet),
	_cchToken(0),
	_iLine(1),
	_cError(0),
	_cWarning(0),
	_bUngetToken(false),
	_cerrorNode(0),
	_pnode(NULL),
	_bCI(false),
	_edist(BNDIST::ED_NONE),
	_bDefault(false),
	_idpi(0),
	_cdpi(0),
	_idpiLast(-1),
	_chCur(' '),
	_chUnget(0),
	_tokenCur(tokenNil),
	_bPropDefs(false),
	_cNode(0),
	_eBlk(EBLKNONE),
	_ppropMgr(NULL),
	_elbl(ESTDLBL_other),
	_ilimNext(-1)
{
	ResetParser();
}

DSCPARSER :: ~ DSCPARSER ()
{
	ResetParser();
}

bool    DSCPARSER :: BInitOpen( SZC szcFile )
{
	return _flpIn.Open( szcFile, "rt" );
}

//  Clear the string references from the parser.   Since our
//  definition of YYSTYPE contains a ZSREF, we must reset the
//  contents of all such structures so that the MBNET's symbol
//  table can be destroyed at any time.
void	DSCPARSER :: ResetParser ()
{
	_vchToken.resize( _cchTokenMax + 1 );

	//  Clear all ZSREF information maintained by the parser token ensemble
	yyval.zsr.Clear();	
	yylval.zsr.Clear();
	for ( int i = 0; i < YYMAXDEPTH; )
	{
		yyv[i++].zsr.Clear();
	}

	//  Do normal member variable clearing
	_chUnget = 0;
	_bUngetToken = false;
	delete _ppropMgr;
	_ppropMgr = NULL;
}

bool	DSCPARSER :: BParse ( UINT & cError, UINT & cWarning )
{
	bool bResult = YaccParse() == 0 && _cError == 0;

	cError = _cError;
	cWarning = _cWarning;

	//  Mark the model as having topology
	Mbnet().BSetBFlag( EIBF_Topology );

	ResetParser();
	
	_flpOut.Flush();

	return bResult;
}

GOBJMBN *	DSCPARSER :: PbnobjFind ( SZC szcName )
{
	return Mpsymtbl().find(szcName);
}

GNODEMBND *  DSCPARSER::PgndbnFind (SZC szc)
{
	GOBJMBN * pbnobj = PbnobjFind(szc);	
	if ( pbnobj == NULL )
		return NULL;
	INT ebno = pbnobj->EType() ;
	if ( ebno != GOBJMBN::EBNO_NODE )
		return NULL;
	GNODEMBND * pgndd;
	DynCastThrow(pbnobj,pgndd);
	return pgndd;
}

bool  DSCPARSER :: BChNext()
{
	if ( _chUnget > 0 )
	{
		_chCur = _chUnget;
		_chUnget = 0;
	}
	else
	{
		_chCur = (char)_flpIn.Getch();
	}
    if ( _chCur == '\n')
          _iLine++;
    return bool(_chCur != EOF);
}


void    DSCPARSER :: SkipWS()        //  skip white space
{
    while (isspace(_chCur) && BChNext());
}

void    DSCPARSER :: SkipToEOL()
{
    while (_chCur != '\n'  && BChNext());
}

//
//	Add a character to a normal token; if overlength, truncate.
//
void    DSCPARSER :: AddChar ( TCHAR tch )
{
	int cch = _vchToken.size() - 2;

    if ( _cchToken < cch )
	{
        _vchToken[_cchToken]	= tch ? tch : _chCur;
		_vchToken[_cchToken+1]	= 0;
	}
	//  Add to scanned length to report overlength token
    _cchToken++;
}

//
//	Add a character to a string token; do not truncate.
//
void    DSCPARSER :: AddCharStr ( TCHAR tch )
{
	int cch = _vchToken.size() - 2;

    if ( _cchToken >= cch )
	{
		_vchToken.resize( 2 * _vchToken.size() );
	}

    _vchToken[_cchToken]	= tch ? tch : _chCur;
	_vchToken[_cchToken+1]	= 0;
    _cchToken++;
}

char    DSCPARSER :: ChEscape()
{
    BChNext();

    switch (_chCur)
    {
      case 'n':
        return '\n';

      case 't':
        return '\t';

      case 'v':
        return '\v';

      case 'b':
        return '\b';

      case 'r':
        return '\r';

      case 'f':
        return '\f';

      case 'a':
        return '\a';

      default:
        return _chCur;
    }
}


void    DSCPARSER :: CloseIdentifier()
{
	if ( ! MBNET::BSzLegal( SzcToken() ) )
        Error("identifier \'%s\' is not legal", SzcToken() );
	CloseToken("identifier");
}

void    DSCPARSER :: CloseToken(SZC szcTokenType)
{
    if (_cchToken >= _cchTokenMax)
    {
        Warning("%s of length %u exceeded maximum length %u",
                szcTokenType, _cchToken, _cchTokenMax);
    }
}


TOKEN   DSCPARSER :: TokenKeyword()
{
	//  See if the captured token is a keyword
    TOKEN token = MBNETDSC::TokenFind( SzcToken() );	
    if ( token != tokenNil )
        return token;

	//  Intern the symbol
    yylval.zsr = Mpsymtbl().intern( SzcToken() );

	//  See if it's a property type
	GOBJMBN * pbnobj = PbnobjFind(yylval.zsr);
	if ( pbnobj && pbnobj->EType() == GOBJMBN::EBNO_PROP_TYPE )
		return tokenPropIdent;

	//  It's an identifier
    return tokenIdent;
}

void	DSCPARSER::ErrorWarn ( bool bErr, SZC szcFormat, va_list & valist )
{
	SZC szcType = bErr
				? "error"
				: "warning" ;

	if ( bErr )
		_cError++;
	else
		_cWarning++;

	int iLine =	_chCur != '\n'
			   ? _iLine
			   : _iLine - 1;

	_flpOut.Fprint("\n%s(%u) %s: ", _flpIn.ZsFn().Szc(), iLine, szcType);
    _flpOut.Vsprint(szcFormat, valist);
	_flpOut.ErrWarn( bErr, iLine );
	_flpOut.Flush();
}

void    DSCPARSER::ErrorWarn( bool bErr, SZC szcFormat, ...)
{
    va_list valist;
    va_start(valist, szcFormat);
	ErrorWarn(bErr,szcFormat,valist);
    va_end(valist);
}

void    DSCPARSER::Error( SZC szcFormat, ...)
{
    va_list valist;
    va_start(valist, szcFormat);
	ErrorWarn(true,szcFormat,valist);
    va_end(valist);
}

void    DSCPARSER::Warning(SZC szcFormat, ...)
{
    va_list  valist;
    va_start(valist, szcFormat);
	ErrorWarn(false,szcFormat,valist);
    va_end(valist);
}

void    DSCPARSER::ErrorWarnNode(bool bErr, SZC szcFormat, ...)
{
	//  If this node has already been deleted, other errors supercede
    if (!_pnode)
        return;

	//  Report the error
    ErrorWarn(bErr, "node %s: ", _pnode->ZsrefName().Szc());

    va_list     valist;
    va_start(valist, szcFormat);
    _flpOut.Vsprint(szcFormat, valist);
    va_end(valist);

    if (++_cerrorNode == 5 || bErr)
        _pnode = NULL;
}

void	DSCPARSER::WarningSkip ( ZSREF zsrBlockName )
{
	Warning("unrecognized block name \'%s\' skipped entirely",
			zsrBlockName.Szc());	
}

void DSCPARSER :: ReportNYI (SZC szcWhich)
{
	ErrorWarn(true,"** UNIMPLEMENTED FUNCTION: \'%s\' **", szcWhich);
}

TOKEN   DSCPARSER::TokenNextBasic()
{
    for (;;)
    {
        //  skip over white space and comments
        SkipWS();

        if (_chCur != '/')
            break;

        BChNext();

        if      (_chCur == '/')
        {
            //  it's a line comment
            SkipToEOL();
            BChNext();      //  discard '\n'
        }
        else
		if (_chCur == '*')
        {
            //  it's a block comment
            bool    fFoundEnd = false;

            BChNext();

            for (char chPrev = _chCur; BChNext(); chPrev = _chCur)
            {
                if (_chCur == '/' && chPrev == '*')
                {
                    fFoundEnd = true;
                    break;
                }
            }
            if (fFoundEnd)
                BChNext();      //  discard terminating '/'
            else
            {
                ErrorWarn(true,"end of file reached in block comment");
                return tokenEOF;
            }
        }
        else
        {
            //  not a comment, return '/'
            _vchToken[1] = '\0';
            return TOKEN(_vchToken[0] = '/');
        }
    }

    if (_chCur == EOF)
        return tokenEOF;

    _cchToken = 0;

	if ( MBNET::BChLegal( _chCur, MBNET::ECHNM_First ) )
    {
        AddChar();
		char chLast = _chCur;

        while (BChNext() && MBNET::BChLegal( _chCur, MBNET::ECHNM_Middle ))
		{
			//  Check for the "range" operator ".."
			if ( _chCur == chLast && _chCur == '.' )
				break;
			chLast = _chCur;
            AddChar();
		}
        CloseIdentifier();
        return TokenKeyword();
    }
    else
	if (isdigit(_chCur) || _chCur == '.')
    {
        TOKEN token  = _chCur == '.'
			   	     ? tokenReal
					 : tokenInteger;

        AddChar();

        while ( BChNext() && isdigit(_chCur) )
            AddChar();

		//  Check for the "range" operator ".."	
		if ( token == tokenReal && _chCur == '.' && _cchToken == 1 )
		{
			AddChar();
			BChNext();
			CloseToken("rangeop");
			return tokenRangeOp;
		}

        if (_cchToken == 1 && _vchToken[0] == '.')
        {
            CloseToken("punctuation");
            return TOKEN('.');
        }

        if (_chCur == '.' && token == tokenInteger)
        {
            AddChar();

            token = tokenReal;
			UINT cchOld = _cchToken;
            while (BChNext() && isdigit(_chCur))
                AddChar();

			//  Check for the "range" operator ".."	
			if ( _chCur == '.' && cchOld == _cchToken )
			{
				_vchToken[ -- _cchToken] = 0;
				_chUnget = '.';
				token = tokenInteger;
			}
			//  Note that check for [eE] below will fail
        }

        if (_chCur == 'e' || _chCur == 'E')
        {
            AddChar();
            BChNext();

            token = tokenReal;

            if (_chCur == '-' || _chCur == '+')
            {
                AddChar();
                BChNext();
            }

            if (isdigit(_chCur))
            {
                AddChar();

                while (BChNext() && isdigit(_chCur))
                    AddChar();
            }
        }
        CloseToken("integer/real");

        if (token == tokenInteger)
            yylval.ui   = UINT(::atol(SzcToken()));
        else
            yylval.real = ::atof(SzcToken());
        return token;
    }
    else
	if (_chCur == '"')
    {
        while (BChNext() && _chCur != '\n' && _chCur != '"')
        {
            if (_chCur == '\\')
                _chCur = ChEscape();

            AddCharStr();
        }

        if (_chCur == '"')
        {
            BChNext();
            CloseToken("string");

            yylval.zsr = Mpsymtbl().intern( SzcToken() );

            return tokenString;
        }

        ErrorWarn(true, _chCur == '\n' ? "new line in string" : "end of file in string");

        return tokenError;
    }

    AddChar();

    BChNext();

    CloseToken(NULL);

    return TOKEN(_vchToken[0]);
}

TOKEN  DSCPARSER::TokenNext()
{
    //  we need this to be able to skip tokens
    if (!_bUngetToken)
        _tokenCur = TokenNextBasic();
    else
        _bUngetToken = false;

    return _tokenCur;
}

void DSCPARSER::SkipUntil ( SZC szcStop, bool bDidLookAhead )
{
    UINT    cparen = 0;
    UINT    cbrace = 0;

    for (; _tokenCur != tokenEOF; TokenNext())
    {
        if      (_tokenCur == '}')
        {
            if (cbrace > 0)
                cbrace--;
            else
                break;
        }
        else
		if (_tokenCur == ')')
        {
            if (cparen > 0)
                cparen--;
            else
                break;
        }

        if (cparen == 0 && cbrace == 0)
        {
            if (_tokenCur < 256 && ::strchr(szcStop, _tokenCur))
                break;
        }

        if (_tokenCur == '{')
            cbrace++;
        else
		if (_tokenCur == '(')
            cparen++;

        bDidLookAhead = false;
    }

    if (!bDidLookAhead)
        _bUngetToken = true;
}


void DSCPARSER::SyntaxError ( SZC szcMessage )
{
	static char szTemp[256];
	static char szFile[256];

    SZC szcError = "";

    switch (_tokenCur)
    {
      case tokenIdent:
        szcError = ": unexpected identifier '%s'";
        break;

      case tokenEOF:
        szcError = ": unexpected end-of-file";
        break;

      case tokenError:
        return;

      default:
        szcError = ": unexpected token '%s'";
        break;
    }

    sprintf(szTemp, "%s%s\n", szcMessage, szcError);
    ErrorWarn(true, szTemp, SzcToken());
}


GNODEMBND * DSCPARSER::PgndbnAdd(ZSREF zsr)
{
	GOBJMBN * pbnobj = PbnobjFind(zsr);
	assert( pbnobj == NULL );

	if ( ! Mbnet().BAddElem( zsr, _pnode = new GNODEMBND ) )
	{
		delete _pnode;
		_pnode = NULL;
	}
	return _pnode;
}

void DSCPARSER::AddSymb(ZSREF zsr)
{
	_vzsr.push_back(zsr);
}

void DSCPARSER::AddStr(ZSREF zsr)
{
	Mpsymtbl().intern(zsr);
	AddSymb(zsr);
}

void DSCPARSER::AddPv ( PROPVAR & pv )
{
	_vpv.push_back(pv);
}
void DSCPARSER::AddPropVar (ZSREF zsr)
{
	AddPv( PROPVAR(zsr) );
}
void DSCPARSER::AddPropVar (REAL & r)
{
	AddPv( PROPVAR(r) );
}

void DSCPARSER::AddUi(UINT ui)
{
	_vui.push_back(ui);
}
void DSCPARSER::AddReal(REAL real)
{
	_vreal.push_back(real);
}

UINT DSCPARSER::UiDpi(ZSREF zsr)
{
    if (!_pnode || _vui.size() >= _vzsrParent.size())
        return 0;

	GNODEMBND * pParent = PgndbnFind(_vzsrParent[_vui.size()]);
	assert( pParent );

	for ( UINT is = 0; is < pParent->CState(); is++ )
	{
		if ( zsr == pParent->VzsrStates()[is] )
			return is;
	}
    ErrorWarnNode(true, "parent \'%s\' doesn\'t have a state named \'%s\'",
				pParent->ZsrefName().Szc(),
				zsr.Szc());
	return 0;
}

UINT DSCPARSER::UiDpi(UINT ui)
{
    if (!_pnode || _vui.size() >= _vzsrParent.size())
        return 0;

	GNODEMBND * pParent = PgndbnFind(_vzsrParent[_vui.size()]);
	assert( pParent );
	if ( ui < pParent->CState() )
		return ui;
    ErrorWarnNode(true, "parent \'%s\' doesn\'t have a state %d",
				pParent->ZsrefName().Szc(),
				ui) ;
	return 0;
}

void DSCPARSER::SetCreator(ZSREF zsr)
{
	Mbnet().ZsCreator() = zsr;
}

void DSCPARSER::SetFormat(ZSREF zsr)
{
	Mbnet().ZsFormat() = zsr;
}

void DSCPARSER::SetVersion(REAL r)
{
	Mbnet().RVersion() = r;
}

void DSCPARSER::SetStates ()
{
	UINT cstr = _vzsr.size();

	if (_pnode)
	{
		if ( cstr != _pnode->CState() )
		{
			ErrorWarnNode(true, "wrong number of state labels, %d != %d",
					  cstr, _pnode->CState() );
			return;
		}	
		_pnode->SetStates(_vzsr);
	}
}

void DSCPARSER::SetNetworkSymb(ZSREF zsr)
{
	Mbnet().ZsNetworkID() = zsr;
}

void DSCPARSER::ClearNodeInfo()
{
    _pnode      = NULL;
	_elbl		= ESTDLBL_other;
	RefBndist().Deref();
    _cerrorNode = 0;
    _idpi		= -1;
	_idpiLast	= -1;
	_cdpi       = 0;
    _bDefault   = false;
    _bCI        = false;

	ClearCstr();
	ClearVpv();

	_vimdDim.clear();
	_vui.clear();
	_vreal.clear();
	_vsdpi.clear();
	_vzsrParent.clear();
	_edist = BNDIST::ED_SPARSE;
}

void DSCPARSER :: StartNodeDecl ( ZSREF zsr )
{
	ClearNodeInfo();
	SetNodeSymb(zsr, true);

	//  If this is the first node we've seen and no property declarations
	//	were seen, import the standard properties from the Registry.

	if ( _cNode++ == 0 )
	{
		if ( ! _bPropDefs )
			ImportPropStandard();
	}
}

void DSCPARSER::SetNodeSymb(ZSREF zsr, bool bNew)
{	
	_pnode = PgndbnFind(zsr);
	if ( bNew && _pnode == NULL )
	{
		PgndbnAdd(zsr);
		ASSERT_THROW( _pnode != NULL, EC_INTERNAL_ERROR, "undetected duplicate name" );
	}

	if ( _pnode == NULL )
	{
		ErrorWarn(true, "identifier '%s' has %s been defined",
				zsr.Szc(),
				bNew ? "already" : "not");
	}
	else
	{
		assert( _ppropMgr );

		//  Find the standard label for this node, if any.
		PROPMBN * pprop = _ppropMgr->PFind( *_pnode, ESTDP_label );
		_elbl = pprop
			  ? (ESTDLBL) _ppropMgr->IUserToLbl( pprop->Real() )
			  : ESTDLBL_other;
	}
}

void DSCPARSER::SetNodeFullName(ZSREF zsr)
{
	assert(_pnode);
	_pnode->ZsFullName() = zsr;
}

void DSCPARSER::SetNodePosition( int x, int y )
{
	assert(_pnode);
	_pnode->PtPos()._x = x;
	_pnode->PtPos()._y = y;
}

void DSCPARSER::CheckNodeInfo()
{
	if ( ! _pnode )
		return;

	if ( ! _pnode->LtProp().Uniqify() )
	{
		ErrorWarnNode(false,"some properties defined more than once");
	}

	if ( _pnode->CState() == 0 )
	{
		ErrorWarnNode(true,"no states defined");
	}
}

void DSCPARSER::SetNodeCstate(UINT cstate)
{
	if ( ! _pnode )
		return;
	_pnode->_vzsrState.resize( cstate );
}


void DSCPARSER::ClearCstr()
{
	_vzsr.clear();
}
void DSCPARSER::ClearVpv()
{
	_vpv.clear();
}

void DSCPARSER::AddPropType(ZSREF zsrName, UINT fType, ZSREF zsrComment)
{
	GOBJMBN * pbnobj = PbnobjFind(zsrName);
	if ( pbnobj )
	{
		Error("symbol name \'%s\' has already been defined",
			   zsrName.Szc() );
	}
	else
	{
		GOBJPROPTYPE * pbnpt = new GOBJPROPTYPE;
		pbnpt->_fType = fType;
		pbnpt->_zsrComment = zsrComment;
		if ( fType & fPropChoice )
		{
			for ( UINT ichoice = 0 ; ichoice < _vzsr.size(); ichoice )
			{
				pbnpt->_vzsrChoice.push_back(_vzsr[ichoice++]);
			}
		}
		
		bool bOk = Mbnet().BAddElem( zsrName, pbnpt );
		assert( bOk );  // shouldn't happen; we've already checked for duplicates above
	}
}

void DSCPARSER::StartProperties()
{
	_eBlk = EBLKPROP;	
	_bPropDefs = true;	
}

void DSCPARSER::EndProperties()
{
	_eBlk = EBLKNONE;
	delete _ppropMgr;
	_ppropMgr = new PROPMGR( Mbnet() );
}

void DSCPARSER::CheckProperty( ZSREF zsrName )
{
	GOBJMBN * pbnobj = PbnobjFind(zsrName);
	if ( pbnobj == NULL || pbnobj->EType() != GOBJMBN::EBNO_PROP_TYPE )
	{
		Error("\'%s\' is not a valid property name",
			  zsrName.Szc() );
		return;
	}
	GOBJPROPTYPE * pbnpt = (GOBJPROPTYPE*) pbnobj;

	UINT fType = pbnpt->FPropType();
	bool bArray = (fType & fPropArray) == fPropArray;
	bool bStr = (fType & fPropString) == fPropString;
	bool bOK = true;
	UINT cpv = _vpv.size();

	//  Check the context; that is, what kind of block are we parsing?
	LTBNPROP * pLtProp = NULL;
	switch ( _eBlk )
	{		
		case EBLKNODE:		//  We're in a node block
			if ( _pnode )
				pLtProp = & _pnode->LtProp();
			break;
		case EBLKPROP:		//  We're in the properties block
			pLtProp = & _mbnet.LtProp();
			break;
		default:			//  How did the parser let this happen?
			SyntaxError("unexpected property declaration");
			return;
			break;	
	}

	if ( cpv > 1 && ! bArray )
	{
		Error("property \'%s\' is not an array property",
					zsrName.Szc() );		
		bOK = false;
	}
	else
	if ( pLtProp )
	{
		pLtProp->push_back( PROPMBN() );
		PROPMBN & bnp = pLtProp->back();
		bnp.Init( *pbnpt );

		for ( UINT ip = 0; ip < cpv ; ip++ )
		{
			REAL r = -1.0;
			ZSREF zsr;

			switch ( _vpv[ip]._eType )
			{
				case PROPVAR::ETPV_STR:
					if ( bStr)						
					{	
						zsr = _vpv[ip]._zsref;
						break;
					}
					if ( bOK = (fType & fPropChoice) > 0 )
					{
						UINT cChoice = pbnpt->VzsrChoice().size();
						ZSREF zsrChoice = _vpv[ip]._zsref;
						//  find the property choice in the array
						for ( UINT ic = 0 ; ic < cChoice; ic++ )
						{
							ZSREF zsr = pbnpt->VzsrChoice()[ic];
							if ( zsrChoice == zsr )
								break;
						}
						if ( ic == cChoice )
						{
							Error("property \'%s\' does not have a choice of \'%s\'",
								  zsrName.Szc(),
								  zsrChoice.Szc()) ;
							bOK = false;
						}	
						else
						{
							r = ic;
						}
					}
					break;

				case PROPVAR::ETPV_REAL:
					bOK = (fType & (fPropChoice | fPropString)) == 0 ;
					if ( bOK )
					{
						r = _vpv[ip]._r;
					}
					break;

				default:
					break;
			}
			if ( ! bOK )
				break;
			if ( bArray && bStr )
				bnp.Add( zsr );
			else
			if ( bArray )
				bnp.Add( r );
			else
			if ( bStr )
				bnp.Set( zsr );
			else
				bnp.Set( r );
		}
		if ( ! bOK )
		{
			Error("item number %d is invalid for this property", ip );		
		}
	}
}


//  Import the standard properties from the Registry
void DSCPARSER::ImportPropStandard()
{
	BNREG bnreg;
	try
	{
		bnreg.LoadPropertyTypes( _mbnet, true );
	}
	catch ( GMException & exbn )
	{
		if ( exbn.Ec() != EC_REGISTRY_ACCESS )
			throw exbn;
		
		Error( "standard properties failed to load, error '%s'",
			   (SZC) exbn.what() );
	}
}

//  Import a specific named property from the Registry
void DSCPARSER :: ImportProp ( ZSREF zsrName )
{
	if ( PbnobjFind(zsrName) != NULL )
	{
		Error("symbol name \'%s\' has already been defined",
			   zsrName.Szc() );
		return;
	}

	BNREG bnreg;
	try
	{
		bnreg.LoadPropertyType( _mbnet, zsrName );
	}
	catch ( GMException & exbn )
	{
		if ( exbn.Ec() != EC_REGISTRY_ACCESS )
			throw exbn;
		
		Error( "imported property \'%s\' failed to load, error '%s'",
			   zsrName.Szc(),
			   (SZC) exbn.what() );
	}
}

void DSCPARSER::CheckCIFunc(ZSREF zsr)
{
	if ( _pnode == NULL )
		return;

	ZSREF zsrMax = Mpsymtbl().intern("max");
	ZSREF zsrPlus = Mpsymtbl().intern("plus");

	if ( zsr == zsrMax )
	{
		_edist = BNDIST::ED_CI_MAX;
	}
	else
	{
		ErrorWarnNode(true,"unsupported PD function type \'%s\'", zsr.Szc());
		if ( zsr == zsrPlus )
			_edist = BNDIST::ED_CI_PLUS;
	}

	if ( _edist != BNDIST::ED_SPARSE && _vzsrParent.size() == 0 )
	{
		ErrorWarnNode(false,"parentless node cannot have distribution type \'%s\'; ignored", zsr.Szc());
		_edist = BNDIST::ED_SPARSE;
	}

	_bCI = true;
}

void DSCPARSER::CheckParentList()
{
	if ( ! _pnode )
		return;

	UINT cErrs = 0;

	if ( _vzsr.size() > 0 )
	{
		switch ( _elbl )
		{
			case ESTDLBL_fixobs:
		    case ESTDLBL_fixunobs:
			case ESTDLBL_unfix:
				ErrorWarnNode(false,"fixable node has parents");
				cErrs++;
				break;
			default:
				break;
		}
	}

	assert(_pnode);

	// Construct the probability distribution for this node & parent list
	VTKNPD vtknpd;

	// Cons-up "p(<node>|"
	vtknpd.push_back( TKNPD(DTKN_PD) );
	vtknpd.push_back( TKNPD( _pnode->ZsrefName() ) );
	_vimdDim.resize(_vzsr.size()+1);

	int iParent = 0;
	for ( UINT ip = 0 ; ip < _vzsr.size(); ip++ )
	{
		if ( ip > 0 )			
			vtknpd.push_back( TKNPD(DTKN_AND) );
		else
			vtknpd.push_back( TKNPD(DTKN_COND) );

		ZSREF zsrParent = _vzsr[ip];
		GNODEMBND * pgndbnParent = PgndbnFind(zsrParent);
		if ( ! pgndbnParent )
		{
			ErrorWarnNode(true,"named parent \'%s\' was not declared", zsrParent.Szc());
			cErrs++;
		}
		else
		if ( ifind( _vzsrParent, zsrParent ) >= 0 )
		{	
			ErrorWarnNode( true, "node \'%s\' has already been declared as a parent",
							zsrParent.Szc() );
			cErrs++;
		}
		else
		{
			_vzsrParent.push_back(zsrParent);
			vtknpd.push_back( TKNPD( pgndbnParent->ZsrefName() ) );
			_vimdDim[iParent++] = pgndbnParent->CState();

			if ( _pnode )
			{
				if ( Mbnet().BAcyclicEdge( pgndbnParent, _pnode ) )
				{
					Mbnet().AddElem( new GEDGEMBN_PROB( pgndbnParent, _pnode ) );
				}
				else
				{
					ErrorWarnNode( true, "connecting to parent \'%s\' creates a cycle",
									zsrParent.Szc() );
					cErrs++;
				}
			}
		}
	}
	_vimdDim.resize(iParent+1);

	if ( cErrs == 0 )
	{
		assert( _pnode );
		//  Add the final dimension to the dimension array
		_vimdDim[iParent]  = _pnode->CState();
		//  Create the distribution
		CreateBndist( vtknpd, _vimdDim );
	}
	//  If errors occurred, "_refbndist" remains empty
}

void DSCPARSER :: CreateBndist ( const VTKNPD & vtknpd, const VIMD & vimdDim )
{
	//  Check that there is no current distribution
	assert( ! RefBndist().BRef() );

	//  Create the new distribution and its reference
	RefBndist() = new BNDIST;
	//  Add it to the map in the model
	Mppd()[vtknpd] = RefBndist();

	//  Declare it as "sparse" and provide its dimensionality
	RefBndist()->SetSparse( _vimdDim );

	//  Check that everything worked
	assert( RefBndist().BRef() );
}

void DSCPARSER::InitProbEntries()
{
	if ( ! BNodeProbOK() )
		return;

	_cdpi = 1;
	UINT cparent = _vzsrParent.size();
    for (UINT ip = cparent; ip-- > 0; )
	{
		GNODEMBND * pgndbnParent = PgndbnFind(_vzsrParent[ip]);
		assert( pgndbnParent );

		UINT cParentState = pgndbnParent->CState();
		if ( _bCI )
			_cdpi += cParentState - 1;
		else
	        _cdpi *= cParentState;
	}

	_vsdpi.resize(_cdpi);
	for ( UINT idpi = 0; idpi < _cdpi; idpi++ )
	{
		_vsdpi[idpi] = sdpiAbsent;
	}
}

void DSCPARSER::CheckProbVector()
{
	if ( _idpiLast < 0 || ! BNodeProbOK() )
		return;		//  Error already reported at higher level

    if (_vreal.size() != _pnode->CState())
    {
        ErrorWarnNode(true, "incorrect number of probabilities, found %u, expected %u",
					_vreal.size(),
					_pnode->CState());
        return;
    }

	//	
	//	At this point, _vui has the parent instantiation info,
	//	  and _vreal has the values.  Create the subscript
	//	  array for the key to the map and the vector of
	//	  reals for the values;
	//
	//  MSRDEVBUG: the member variable arrays should be valarrays
	//			to make this more efficient
	//
	assert( _vui.size() == _vzsrParent.size() );

	VIMD vimd;
	VLREAL vlr;

	//
	//	If this is the 'default' vector, store it with an empty subscript array.
	//  This special value will trigger its propagation into any empty slots of
	//  the dense version.
	//
	if ( !_bDefault )
	{
		//  Not the 'default' vector; store it as the DPI
		vdup( vimd, _vui );
	}
	vdup( vlr, _vreal );
	//  store the DPI and values into the map.
	assert( RefBndist().BRef() );
	RefBndist()->Mpcpdd()[vimd] = vlr;
}

//  This node has an explictly empty probability distribution.  Create just the "default"
//	entry, and make it completely "unassessed" ("na" = -1.0).
void	DSCPARSER::EmptyProbEntries()
{
	if ( ! BNodeProbOK() )
        return;
	VIMD vimd;	// Empty subscript array
	//  Build default vector of "na", a.k.a -1
	VLREAL vlr( _pnode->CState() );
	vlr = RNA;
	RefBndist()->Mpcpdd()[vimd] = vlr;
}

//  Check the discrete parent instantiation in _vui
void DSCPARSER::CheckDPI(bool bDefault)
{
	_idpiLast = -1;
	
	if ( ! BNodeProbOK() )
        return;

    if (bDefault)
    {
        if (!_bDefault)
		{
            _bDefault = bDefault;
		}
        else
		{
            ErrorWarnNode(true, "default entry already defined");
			return;
		}
    }

	UINT cui = _vui.size();
	if ( (cui > 0 && _idpi > 0) || (cui == 0 && _idpi < -1) )
	{
	    ErrorWarnNode(true, "mixtures of prefixed and unprefixed probability entries are not allowed");
		return;
	}
	if ( cui > 0 )
		_idpi = -2;   // Disallow any further non-prefixed entries
	else
		_idpi++;

    if (cui != _vzsrParent.size())
    {
        ErrorWarnNode(true, "incorrect number of instantiations, found %u, expected %u",
				  cui,
				  _vzsrParent.size());
        return;
    }

    UINT idpi = 0 ;

	if ( cui > 0 )
	{
		UINT cstate = 0;
		UINT iui;
		UINT isi;

		if ( _bCI )
		{
			UINT cZeros = 0;
			for (iui = cui; iui-- > 0; )
			{   if ( _vui[iui] == 0 )
					cZeros++ ;
			}
			if ( cZeros < cui - 1 )
			{
				ErrorWarnNode(true, "invalid discrete CI parent instantiation");
				return;
			}
		
			if ( _bCI && cZeros == cui)
			{
				idpi = 0;	//  It's the leak term
			}
			else
			for (UINT iui = 0; iui < cui; iui++)
			{
				GNODEMBND * pgndbnParent = PgndbnFind(_vzsrParent[iui]);
				assert(pgndbnParent);

				isi = _vui[iui];
				cstate = pgndbnParent->CState();
				if ( isi > 0 )
				{
					idpi += isi;  // This is the only non-zero term
					break;
				}
				idpi += cstate - 1;
			}
		}
		else
		for ( iui = cui; iui-- > 0; )
		{
			GNODEMBND * pgndbnParent = PgndbnFind(_vzsrParent[iui]);
			assert(pgndbnParent);
			isi = _vui[iui];
			cstate = pgndbnParent->CState();

			if (isi >= cstate)
			{
				ErrorWarnNode(true, "invalid discrete parent instantiation");
				return;
			}
			idpi *= cstate;
			idpi += isi;
		}
	}
	else
	{
		idpi = _idpi;
	}

    assert(idpi < _cdpi);

    if (_vsdpi[idpi] != sdpiAbsent)
    {
        ErrorWarnNode(true, "DPI ");
		PrintDPI(idpi);
        _flpOut.Fprint( " %s\n", _vsdpi[idpi] == sdpiPresent
											? "already defined"
											: "not needed");
    }
    _vsdpi[idpi] = sdpiPresent;
	_idpiLast = idpi;
}

void DSCPARSER::PrintDPI ( UINT idpi )
{
    _flpOut.Fprint("(");
    for (UINT ip = 0; ip < _vzsrParent.size(); ip++)
    {
 		GNODEMBND * pgndbnParent = PgndbnFind(_vzsrParent[ip]);
		assert( pgndbnParent );
        UINT    cstate = pgndbnParent->CState();
        _flpOut.Fprint( "%s%u", ip == 0 ? "" : ", ", idpi % cstate);
        idpi /= cstate;
    }
    _flpOut.Fprint(")");
}


void DSCPARSER::CheckProbEntries()
{
	if ( ! BNodeProbOK() )
		return;

	int cErrors = _cError;

    if (!_bDefault)
    {
		UINT cdpiAbsent = 0;
        for (UINT idpi = 0; idpi < _cdpi && _pnode; idpi++)
        {
            if (_vsdpi[idpi] == sdpiAbsent)
            {	
				cdpiAbsent++;
            }
        }
		if ( _cdpi == cdpiAbsent )
		{
			Warning("probabilities not defined for node \'%s\'",
			  	    _pnode->ZsrefName().Szc());
		}
		else
        for (idpi = 0; idpi < _cdpi && _pnode; idpi++)
        {
            if (_vsdpi[idpi] == sdpiAbsent)
            {
                ErrorWarnNode(true, "no probabilities for DPI ");
                PrintDPI(idpi);
                _flpOut.Fprint( "\n");
            }
        }
    }

	// If no new errors arose, process probabilities
	if ( cErrors == _cError )
	{
		assert( BNodeProbOK() ) ;
		bool bOK = RefBndist()->BChangeSubtype( _edist );
		assert( bOK );
	}
}

void DSCPARSER :: ClearDomain()
{
	_eBlk = EBLKDOM; 	
	_domain.clear();
	_ilimNext = -1;
}

void DSCPARSER :: SetRanges( bool bLower, REAL rLower, bool bUpper, REAL rUpper)
{
	_rlimLower.first	= bLower;
	_rlimLower.second	= rLower;
	_rlimUpper.first	= bUpper;
	_rlimUpper.second	= rUpper;
	_ilimNext = rUpper;
}

void DSCPARSER :: SetRanges( ZSREF zsrLower, ZSREF zsrUpper )
{
	if ( _eBlk != EBLKDIST )
		Error("names are not allow in domain elements");
}

//  Add a subrange to the currently building RDOMAIN
void DSCPARSER :: AddRange( ZSREF zsr, bool bSingleton )
{
	if ( bSingleton )
	{
		++_ilimNext;
		SetRanges( true, _ilimNext, true, _ilimNext );
	}

	RANGEDEF rthis( _rlimLower, _rlimUpper, zsr );

	if ( ! rthis.BValid() )
	{
		Error( "range \'%s\' is invalid", zsr.Szc() );
		return;
	}
	else
	if ( _domain.size() > 0 )
	{
		RANGEDEF & rlast = _domain.back();
		//  Overlap check detects and fails on equality
		if ( rthis.BOverlap( rlast ) )
		{
			Error( "range \'%s\' overlaps with range \'%s\'",
					zsr.Szc(),
					rlast.ZsrName().Szc() );
			return;
		}
		if ( rthis < rlast )
		{
			ErrorWarn( false, "range \'%s\' is out of sequence with \'%s\'",
					zsr.Szc(),
					rlast.ZsrName().Szc() );
		}
		else
		{
			assert( rlast < rthis );
		}
		RDOMAIN::const_iterator itdm = _domain.begin();
		for ( ; itdm != _domain.end(); itdm++ )
		{
			const RANGEDEF & rdef = *itdm;
			
			if ( rdef.ZsrName() == rthis.ZsrName() )
			{
				Error( "range name \'%s\' has already been used in this domain",
					   rdef.ZsrName().Szc() );
				return;
			}			
		}
	}
	_domain.push_back( rthis );
}

void DSCPARSER::CheckDomain ( ZSREF zsr )
{
	GOBJMBN_DOMAIN * pgobjdom = new GOBJMBN_DOMAIN( & _domain );
	if ( ! Mbnet().BAddElem( zsr, pgobjdom ) )
	{
		Error( "domain name \'%s\' is already in use", zsr.Szc() );
		delete pgobjdom;
	}
	_domain.clear();
	_eBlk = EBLKNONE;
}

//  Set the state list for a node based upon a domain
void DSCPARSER::SetNodeDomain( ZSREF zsr )
{
	//  Verify the domain name referenced
	GOBJMBN_DOMAIN * pgobjdom = NULL;
	GOBJMBN * pbnobj = PbnobjFind(zsr);	
	if ( pbnobj )
		pgobjdom = dynamic_cast<GOBJMBN_DOMAIN *>(pbnobj);
	if ( pgobjdom == NULL )
	{
		Error( "domain name \'%s\' has not been defined", zsr.Szc() );
		return;
	}

	//  Copy the state names from the domain to the variable
	_pnode->SetDomain( *pgobjdom );
}

void DSCPARSER::CheckPDF( ZSREF zsr )
{
	if ( ! _pnode )
		return;
	ReportNYI("CheckPDF");
}

void DSCPARSER::CheckIdent( ZSREF zsr )
{
	ReportNYI("CheckIdent");
}

// End of BNPARSE.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bndist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bndist.h
//
//--------------------------------------------------------------------------

//
//	bndist.h: Belief Network Distributions
//

#ifndef _BNDIST_H_
#define _BNDIST_H_

#include "mddist.h"

////////////////////////////////////////////////////////////////////
//	class BNDIST:  
//
//		Base class for probability distributions used in belief networks.  
//
//		This is a reference counted object which usually lives in the 
//		distribution map of an MBNET.
//
//		However, BNDISTs are also created for various other purposes
//		such as CI network expansion.  In these cases, the BNDIST
//		is automatically deleted when the reference count goes to zero.
//		See BNDIST::NoRef().
//
////////////////////////////////////////////////////////////////////
class BNDIST : public REFCNT
{
	friend class DSCPARSER;
  public:
	BNDIST ();
	~ BNDIST ();
	BNDIST ( const BNDIST & bnd );

	enum EDIST
	{
		ED_NONE,			//  illegal value
		ED_DENSE,			//  lowest enum value for a dense distribution
		ED_SPARSE,			//  lowest enum value for a	sparse distribution
		ED_CI_MAX,			//  therefore, CI "max" is sparse
		ED_CI_PLUS,			//		as is CI "plus"
		ED_MAX				//  first unused value
	};
	EDIST Edist () const	
		{ return _edist; }

	BNDIST & operator = ( const BNDIST & bnd );

	//  Set distribution to "dense"
	void SetDense ( const VIMD & vimd );
	//  Set distribution to sparse
	void SetSparse ( const VIMD & vimd );

	static bool BDenseType ( EDIST edist )
		{ return edist >= ED_DENSE && edist < ED_SPARSE ; }
	static bool BSparseType ( EDIST edist )
		{  return edist >= ED_SPARSE && edist < ED_MAX ; }

	bool BDense () const
		{ return BDenseType( Edist() ); }
	bool BSparse () const
		{  return BSparseType( Edist() ); }

	bool BChangeSubtype ( EDIST edist );

	//  Convert a dense representation to a sparse one
	void ConvertToDense ( const VIMD & vimd );

	void Clear ()
	{
		delete _pmdvcpd;
		_pmdvcpd = NULL;
		delete _mpcpdd;
		_mpcpdd = NULL;
	}

	MDVCPD & Mdvcpd ()
	{	
		assert( _pmdvcpd );
		return *_pmdvcpd ;
	}
	const MDVCPD & Mdvcpd () const
	{	
		assert( _pmdvcpd );
		return *_pmdvcpd ;
	}

	MPCPDD & Mpcpdd ()
	{
		assert( _mpcpdd );
		return *_mpcpdd;
	}
 	const MPCPDD & Mpcpdd () const
	{
		assert( _mpcpdd );
		return *_mpcpdd;
	}
	const VIMD & VimdDim () const
		{ return _vimdDim; }

	//  Return the "leak" or "default" vector for a sparse distribution
	const VLREAL * PVlrLeak () const;

	void Dump();
	void Clone ( const BNDIST & bndist );

	LEAK_VAR_ACCESSOR

 protected:
	EDIST _edist;				// Type of distribution
	MDVCPD * _pmdvcpd;			// Ptr to dense m-d array
	MPCPDD * _mpcpdd;			// Ptr to sparse array
	VIMD _vimdDim;				// Dense dimensionality

	//  Called when object's reference count goes to zero
	void NoRef ();

	//  Dumper functions
	void DumpSparse();
	void DumpDense();

	LEAK_VAR_DECL
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\algos.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       algos.h
//
//--------------------------------------------------------------------------

//
//   algos.h: additions to <algorithms>
//  

#ifndef _ALGOS_H_
#define _ALGOS_H_

#include "mscver.h"

#include <vector>
#include <valarray>
#include <algorithm>
#include <functional>
#include <assert.h>

using namespace std;

////////////////////////////////////////////////////////////////////////////////////
//
//	Extensions to (plagarisms from) "algorithm" templates
//
////////////////////////////////////////////////////////////////////////////////////

// Template Function count_set_intersection()
//		Return the number of elements in common between two ORDERED sets.
//		Elements must support operator<.
//
//   Usage:  count_set_intersection ( iter_beg_1, iter_end_1, iter_beg_2, iter_end_2 );
//
template<class _II1, class _II2> inline
int count_set_intersection(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2)
{
	for (int _C=0; _F1 != _L1 && _F2 != _L2; )
	{
		if (*_F1 < *_F2)
			++_F1;
		else if (*_F2 < *_F1)
			++_F2;
		else
			++_F1, ++_F2, ++_C;
	}
	return _C; 
}

// Template Function count_set_intersection() with predicate.  Same as above;
//		a predicate function is used to determine ordering; must behave as 
//		operator<.
template<class _II1, class _II2, class _Pr> inline
int count_set_intersection(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _Pr _P)
{
	for (int _C=0; _F1 != _L1 && _F2 != _L2; )
	{
		if (_P(*_F1, *_F2))
			++_F1;
		else if (_P(*_F2, *_F1))
			++_F2;
		else
			++_F1, ++_F2, ++_C;
	}
	return _C; 
}


//  Template function ifind().  
//		Return the index of an item in a vector or -1 if not found.
template <class _VT, class _T>
int ifind ( const _VT & vt, _T t )
{
	_VT::const_iterator vtibeg = vt.begin();
	_VT::const_iterator vtiend = vt.end();
	_VT::const_iterator vtiter = find( vtibeg, vtiend, t );
	return vtiter == vtiend
		 ? -1 
		 : vtiter - vtibeg;
}


// Template function pexchange().
//		Exchange contents of a pair of pointers
template<class _T> 
void pexchange ( _T * & pta, _T * & ptb )
{
	_T * ptt = pta;
	pta = ptb;
	ptb = ptt;
}

//  Template function vswap(). 
//		Swap elements of a vector
template<class _T>
void vswap ( vector<_T> & vt, int ia, int ib )
{
	assert( ia < vt.size() );
	assert( ib < vt.size() );
	if ( ia != ib )
	{
		_T tt = vt[ia];
		vt[ia] = vt[ib];
		vt[ib] = tt;
	}
}

// Template function appendset(). 
//		Append to vector-based set (add if not present)
template <class _T>
bool appendset ( vector<_T> & vt, _T t )
{
	if ( ifind( vt, t ) >= 0 )
		return false;
	vt.push_back(t);
	return true;	
}

//  Template function vclear().
//		Clear a valarray or vector to a single value
template <class _VT, class _T>
_VT & vclear ( _VT & vt, const _T & t )
{
	for ( int i = 0; i < vt.size(); )
		vt[i++] = t;
	return vt;
}

//  Template function vdup().
//		Duplicate a valarray or vector from one or the other
template <class _VTA, class _VTB>
_VTA & vdup ( _VTA & vta, const _VTB & vtb )
{
	vta.resize( vtb.size() );
	for ( int i = 0; i < vta.size(); i++ )
		vta[i] = vtb[i];
	return vta;
}

//	Template function vequal()
//		Compare valarrays or vectors for equality
template <class _VTA, class _VTB>
bool vequal ( _VTA & vta, const _VTB & vtb )
{
	if ( vta.size() != vtb.size() ) 
		return false;

	for ( int i = 0; i < vta.size(); i++ )
	{
		if ( vta[i] != vtb[i] )
			return false;
	}
	return true;
}

//  Template function vdimchk()
//		Treating the first argument as a subscript vector
//		and the second as a vector of dimensions, return true
//		if the subscript vector is valid for the space.
template <class _VTA, class _VTB>
bool vdimchk ( const _VTA & vta, const _VTB & vtb )
{
	if ( vta.size() != vtb.size() ) 
		return false;

	for ( int i = 0; i < vta.size(); i++ )
	{
		if ( vta[i] >= vtb[i] )
			return false;
	}
	return true;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bnreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bnreg.h
//
//--------------------------------------------------------------------------

//
//	BNREG.H: Belief Network Registry Access
//

#include "basics.h"
#include "regkey.h"

//
//	HKEY_LOCAL_MACHINE\Software\Microsoft\DTAS\BeliefNetworks
//	HKEY_LOCAL_MACHINE\Software\Microsoft\DTAS\BeliefNetworks\PropertyTypes
//
class MBNET;
class GOBJPROPTYPE;
class BNREG
{
  public:
	BNREG ();
	~ BNREG ();

	//  Store the property types from this network into the Registry
	void StorePropertyTypes ( MBNET & mbnet, bool bStandard = false );
	//	Load the property types from the Registry into this network
	void LoadPropertyTypes ( MBNET & mbnet, bool bStandard );
	//  Load a single property type from the Registry into the network
	void LoadPropertyType ( MBNET & mbnet, SZC szcPropTypeName );
	//  Remove all property types from the Registry
	void DeleteAllPropertyTypes ();
	//  Return the flags from a Registry-based property type or -1 if not found
	LONG FPropType ( SZC szcPropType );
	
  protected:
	REGKEY _rkBn;

	void OpenOrCreate ( HKEY hk, REGKEY & rk, SZC szcKeyName );
	void CreatePropType ( REGKEY & rkParent, 
						  SZC szcPropType, 
						  GOBJPROPTYPE & bnpt, 
						  bool bStandard = false );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bnreg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bnreg.cpp
//
//--------------------------------------------------------------------------

//
//	BNREG.CPP: Use Registry to store persistent BN properties, etc.
//
#include <windows.h>
#include "bnreg.h"
#include "gmobj.h"


//
//	String constants for Registry handling
//
static const SZC szcBn				= "Software\\Microsoft\\DTAS\\BeliefNetworks";
static const SZC szcPropertyTypes	= "PropertyTypes";
static const SZC szcFlags			= "Flags";
static const SZC szcComment			= "Comment";
static const SZC szcChoices			= "Choices";
static const SZC szcCount			= "Count";


BNREG :: BNREG ()
{
	OpenOrCreate( HKEY_LOCAL_MACHINE, _rkBn, szcBn );
}


BNREG :: ~ BNREG ()
{
}

void BNREG :: OpenOrCreate ( HKEY hk, REGKEY & rk, SZC szcKeyName )
{
	LONG ec;
	ec = rk.Open( hk, szcKeyName );
	if ( ec != ERROR_SUCCESS )
		ec = rk.Create( hk, szcKeyName );
	if ( ec != ERROR_SUCCESS )
		throw GMException( EC_REGISTRY_ACCESS, "unable to open or create key" );
}

//
//  Store the property types from this network into the Registry.
//	If 'bStandard', force property types to be marked as "standard".
//
void BNREG :: StorePropertyTypes ( MBNET & mbnet, bool bStandard )
{
	REGKEY rkPtype;
	assert( _rkBn.HKey() != NULL );
	OpenOrCreate( _rkBn, rkPtype, szcPropertyTypes );

	MBNET::ITER mbnit( mbnet, GOBJMBN::EBNO_PROP_TYPE );
	GOBJMBN * pgmobj;
	SZC szcName;
	for ( ; pgmobj = *mbnit ; ++mbnit )
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GOBJPROPTYPE * pbnpt;
		DynCastThrow( pgmobj, pbnpt );
		//  Get the name of the property type
		szcName = pbnpt->ZsrefName();
		//  See if it already exists
		LONG fPropType = FPropType( szcName );
		if ( fPropType >= 0 )
		{
			//  Property type already exists; guarantee that its "standard"
			//		flag is consistent
			bool bOldStandard = (fPropType & fPropStandard) > 0;
			//  It's standard if it was already or is now being forced to be
			bool bNewStandard = (pbnpt->FPropType() & fPropStandard) > 0 || bStandard;
			if ( bNewStandard ^ bOldStandard )
				throw GMException( EC_REGISTRY_ACCESS,
						"conflict between standard and non-standard property types" );

			//  Delete any older version of this property type
			rkPtype.RecurseDeleteKey( szcName );
		}
		CreatePropType( rkPtype, szcName, *pbnpt, bStandard );
	}
}

//
//	Load the property types from the Registry into this network.  If
//  'bStandard', load only the types marked "standard" if !bStandard,
//  load only the types NOT so marked.
//
void BNREG :: LoadPropertyTypes ( MBNET & mbnet, bool bStandard )
{
	REGKEY rkPtype;
	assert( _rkBn.HKey() != NULL );
	OpenOrCreate( _rkBn, rkPtype, szcPropertyTypes );

	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	ZSTR zsPt;
	DWORD dwKey = 0;

	for (;;)
	{
		dwSize = 256;
		if ( RegEnumKeyEx(rkPtype,
						 dwKey++,
						 szBuffer,
						 & dwSize,
						 NULL,
						 NULL,
						 NULL,
						 & time ) != ERROR_SUCCESS )
			break;

		zsPt = szBuffer;
		LONG fPropType = FPropType( zsPt );
		ASSERT_THROW( fPropType >= 0,
					  EC_REGISTRY_ACCESS,
					  "registry property type load enumeration failure" );

		//  Load this type if appropriate
		if ( ((fPropType & fPropStandard) > 0) == bStandard )		
			LoadPropertyType( mbnet, zsPt );
	}	
}

//  Load a single property type from the Registry into the network
void BNREG :: LoadPropertyType ( MBNET & mbnet, SZC szcPropTypeName )
{
	REGKEY rkPtype;
	assert( _rkBn.HKey() != NULL );
	OpenOrCreate( _rkBn, rkPtype, szcPropertyTypes );

	TCHAR szValue [2000];
	DWORD dwCount;
	SZC szcError = NULL;
	GOBJPROPTYPE * pgobjPt = NULL;

	do  // false loop for error checking
	{
		//  Check that the belief network doesn't already have such a beast
		if ( mbnet.PgobjFind( szcPropTypeName ) != NULL )
		{
			szcError = "duplicate property type addition attempt";
			break;
		}
		REGKEY rkPt;
		if ( rkPt.Open( rkPtype, szcPropTypeName ) != ERROR_SUCCESS )
		{
			szcError = "property type key open failure";
			break;
		}

		LONG fPropType = FPropType( szcPropTypeName );
		if ( fPropType <  0 )
			throw GMException( EC_REGISTRY_ACCESS,
							  "property type flag query failure" );

		//  Create the new property type object
		GOBJPROPTYPE * pgobjPt = new GOBJPROPTYPE;
		//  Set its flags and mark it as "persistent" (imported)
		pgobjPt->_fType = fPropType | fPropPersist;

		//  Get the comment string
		dwCount = sizeof szValue;
		if ( rkPt.QueryValue( szValue, szcComment, & dwCount ) != ERROR_SUCCESS )
		{
			szcError = "property type key value query failure";
			break;
		}
		szValue[dwCount] = 0;
		pgobjPt->_zsrComment = mbnet.Mpsymtbl().intern( szValue );

		//  Is this a "choice" property type?
		if ( fPropType & fPropChoice )
		{
			REGKEY rkChoices;
			if ( rkChoices.Open( rkPt, szcChoices ) != ERROR_SUCCESS )
			{
				szcError = "choices key missing for property type";
				break;
			}
			//  Get the "Count" value
			if ( rkChoices.QueryValue( dwCount, szcCount ) != ERROR_SUCCESS )
			{
				szcError = "failure to create choice count value";
				break;
			}
			ZSTR zs;
			int cChoice = dwCount;
			for ( int i = 0; i < cChoice; i++ )
			{
				zs.Format("%d",i);
				dwCount = sizeof szValue;
				if ( rkChoices.QueryValue( szValue, zs, & dwCount ) != ERROR_SUCCESS )
				{
					szcError = "failure to query choice string";
					break;
				}
				szValue[dwCount] = 0;
				pgobjPt->_vzsrChoice.push_back( mbnet.Mpsymtbl().intern( szValue ) );
			}
			assert( i == cChoice );
		}

		if ( szcError )
			break;

		mbnet.AddElem( szcPropTypeName, pgobjPt );

	} while ( false );

	if ( szcError )
	{
		delete pgobjPt;
		throw GMException( EC_REGISTRY_ACCESS, szcError );
	}
}

//  Remove all property types from the Registry
void BNREG :: DeleteAllPropertyTypes ()
{
	assert( _rkBn.HKey() != NULL );
	_rkBn.RecurseDeleteKey( szcPropertyTypes );
}

//  Return the value of the property type flags or -1 if open failure
LONG BNREG :: FPropType ( SZC szcPropType )
{
	REGKEY rkPtype;
	assert( _rkBn.HKey() != NULL );
	if ( rkPtype.Open( _rkBn, szcPropertyTypes ) != ERROR_SUCCESS )
		return -1;
	REGKEY rkPt;
	if ( rkPt.Open( rkPtype, szcPropType ) != ERROR_SUCCESS )
		return -1;

	DWORD dwValue;
	if ( rkPt.QueryValue( dwValue, szcFlags ) != ERROR_SUCCESS )
		return -1;
	return dwValue;	
}

void BNREG :: CreatePropType (
	REGKEY & rkParent,
	SZC szcPropType,
	GOBJPROPTYPE & bnpt,
	bool bStandard )
{
	REGKEY rkPt;
	LONG ec = rkPt.Create( rkParent, szcPropType );
	if ( ec != ERROR_SUCCESS )
		throw GMException( EC_REGISTRY_ACCESS,
						   "property type key creation failure" );

	bool bOK = true;

	//  Add the "flags" value, clearing the "persistent" flag
	DWORD dwFlags = bnpt.FPropType();
	dwFlags &= ~ fPropPersist;
	if ( bStandard )
		dwFlags |= fPropStandard;
	bOK &= (rkPt.SetValue( dwFlags, szcFlags ) == ERROR_SUCCESS);

	//  Add the "comment" string
	bOK &= (rkPt.SetValue( bnpt.ZsrComment(), szcComment ) == ERROR_SUCCESS);

	//  Add the choices, if applicable
	if ( bnpt.VzsrChoice().size() > 0 )
	{
		// Add the "Choices" subkey
		REGKEY rkChoice;
		ZSTR zs;
		int cChoice = bnpt.VzsrChoice().size();
		ec = rkChoice.Create( rkPt, szcChoices );
		if ( ec != ERROR_SUCCESS )
			throw GMException( EC_REGISTRY_ACCESS,
							   "property type choices key creation failure" );

		bOK &= (rkChoice.SetValue( cChoice, szcCount ) == ERROR_SUCCESS);
		for ( int i = 0; i < cChoice; i++ )
		{
			zs.Format("%d",i);
			bOK &= (rkChoice.SetValue( bnpt.VzsrChoice()[i], zs ) == ERROR_SUCCESS);
		}
	}

	if ( ! bOK )
		throw GMException( EC_REGISTRY_ACCESS,
						  "property type value addition failure" );	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bntest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bntest.cpp
//
//--------------------------------------------------------------------------

//
//	BNTEST.CPP
//
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <math.h>
#include <float.h>

#include "bnparse.h"			// Parser class
#include "bnreg.h"				// Registry management
#include "testinfo.h"			// Output test file generation
#include "distdense.hxx"		// Distribution classes
#include "distsparse.h"

#ifdef TIME_DYN_CASTS
	//  Global variable containing count of calls to all forms of DynCastThrow function template
	int g_cDynCasts = 0;
#endif

enum EFN   //  File name in file name array
{
	EFN_IN,			// input DSC file
	EFN_OUT,		// output DSC file
	EFN_INFER		// output inference test file (see testinfo.cpp for format)
};

static 
inline
double RNan ()
{
	double rnan = sqrt(-1.0);
#ifndef NTALPHA
	assert( _isnan( rnan ) );
#endif
	return rnan;
}

static 
inline 
bool BFlag ( ULONG fCtl, ULONG fFlag )
{
	return (fCtl & fFlag) > 0;
}

static 
void usage ()
{
	cout << "\nBNTEST: Belief Network Test program"
		 << "\nCommand line:"
		 <<	"\n\tbntest [options] <input.DSC> [/s <output.DSC>] [/p <output.DMP>]"
		 << "\nOptions:"
		 << "\n\t/v\t\tverbose output"
		 << "\n\t/c\t\tclique the network"
		 << "\n\t/e\t\ttest CI network expansion"
		 << "\n\t/inn\t\ttest inference; nn = iterations (default 1)"
		 << "\n\t/p <filename>\twrite inference output (.dmp) file (sets /i)"
		 << "\n\t/s <filename>\trewrite input DSC into output file"
		 << "\n\t/t\t\tdisplay start and stop times"
		 << "\n\t/x\t\tpause at various stages (for memory measurement)"
		 << "\n\t/n\t\tuse symbolic names in inference output (default is full)"
		 << "\n\t/y\t\tclone the network (write cloned version if /s)"
		 << "\n\t/u\t\tinclude entropic utility records in /p output"
		 << "\n\t/b\t\tinclude troubleshooting recommendations in /p output"
		 << "\n\t/r\t\tstore property types in Registry for persistence"
		 << "\n\t/b\t\tcompute troubleshooting recommendations"
		 << "\n\t/z\t\tshow inference engine statistics"
		 << "\n\t/m<nnnnnn>\tset maximum estimated inference engine size"
		 << "\n\t/a<n.n>\t\tflag impossible evidence with numeric value"
		 << "\n\nInput DSC is read and parsed; errors and warnings go to stderr."
		 << "\nParse errors stop testing.  If cloning, output file is cloned version."
		 << "\nIf CI expansion (/e), output (/s) has pre- and post- expansion versions."
		 << "\nInference (/i or /p) takes precedence over CI expansion (/e)."
		 << "\nInference output (/p) writes file in common format with DXTEST."
		 << "\nCliquing (/c) just creates and destroys junction tree."
		 << "\n";
}

static 
void die( SZC szcFormat, ... )
{
	ZSTR zsMsg;

    va_list valist;
    va_start(valist, szcFormat);

	zsMsg.Vsprintf( szcFormat, valist );

    va_end(valist);

	cerr << "\nBNTEST error: "
		 << zsMsg.Szc()
		 << "\n";
	exit(1);
}


//  Show the debugging build options
static 
void showOptions ( ULONG fCtl )
{
	bool bComma = false;
	ZSTR zs = TESTINFO::ZsOptions( fCtl );
	cout << "(options: "
		 << zs;

	bComma = zs.length() > 0;

	// Show DYNAMIC CAST option
	if ( bComma )
		cout << ",";
	cout << 
#ifdef USE_STATIC_CAST
		"STATICCAST"
#else	
		"DYNCAST"
#endif
		;
	bComma = true;

	// Show DUMP option
#ifdef DUMP
	if ( bComma )
		cout << ",";
	cout << "DUMP";
	bComma = true;
#endif
	
	// Show DEBUG option
#ifdef _DEBUG
	if ( bComma )
		cout << ",";
	cout << "DEBUG";
	bComma = true;
#endif

	cout << ")";
}

//  Show memory leaks for primary object types, if any
static 
void showResiduals ()
{
#ifdef _DEBUG
	if  (GEDGE::CNew() + GNODE::CNew() + GNODE::CNew() )
	{
		cout << "\n(GEDGEs = "
			 << GEDGE::CNew()
			 << ", GNODESs = "
			 << GNODE::CNew()
			 << ", BNDISTs = "
			 << GNODE::CNew()
			 << ")";
	}
	if ( VMARGSUB::CNew() + MARGSUBREF::CNew() )
	{
		cout << "\n(VMARGSUBs = "
			 << VMARGSUB::CNew()
			 << ", MARGSUBREFs = "
			 << MARGSUBREF::CNew()
			 << ")";
	}
#endif
}


static 
void printResiduals ()
{
#ifdef _DEBUG
	showResiduals();
#endif
#ifdef TIME_DYN_CASTS
	cout << "\ntotal number of dynamic casts was "
		 << g_cDynCasts;
#endif
}

//  Display the message and pause if the "pause" option is active
inline
static
void pauseIf ( ULONG fCtl, SZC szcMsg )
{
	if ( (fCtl & fPause) == 0 )
		return;
	showResiduals();
	char c;
	cout << "\n"
		 << szcMsg
		 << " (pause)"
		 ;
	cin.get(c);
}

//  Display the phase message and, optionally, the time
typedef DWORD CTICKS;

inline
static
CTICKS showPhase ( ULONG fCtl, SZC szcPhase, CTICKS * ptmLast = NULL )
{
	//  Display the phase message
	cout << "\n" << szcPhase;
	CTICKS cticks = 0;

	if ( fCtl & fShowTime )
	{
		//  Save the current tick count
		cticks = ::GetTickCount();

		//  Prepare to display the current date/time
		time_t timeNow;
		time(& timeNow);
		ZSTR zsTime = ctime(&timeNow);
		int cnl = zsTime.find( '\n' );
		if ( cnl != 0 )
			zsTime.resize( cnl );
		cout << " " << zsTime;

		//  Display the elapsed time if we know it
		if ( ptmLast && *ptmLast != 0 )
		{
			CTICKS ticksElapsed = cticks - *ptmLast;
			cout << " (elapsed time "
				 << ticksElapsed
				 << " milliseconds)";
		}
	}
	return cticks;
}


static 
void testRegistry ( MBNET & mbnet )
{
	BNREG bnr;
	bnr.StorePropertyTypes( mbnet, true );
}

#ifdef TESTDIST
static void loadDistDenseFromMpcpdd ( DISTDENSE & ddense, const MPCPDD & mpcpdd )
{
	ddense.AllocateParams();

	CST cstNode = ddense.CstNode();

	// Find the default vector in the map or create a uniform vector
	const VLREAL * pvlrDefault = mpcpdd.PVlrDefault();
	VLREAL vlrDefault;
	if ( pvlrDefault )
	{
		vlrDefault = *pvlrDefault;
	}
	else
	{
		vlrDefault.resize( cstNode );
		REAL rDefault = 1 / cstNode ;
		vlrDefault = rDefault;
	}

	//  Fill the dense array with the default value
	UINT cParamgrp = ddense.Cparamgrp();
	UINT igrp = 0;
	for ( ; igrp < cParamgrp; igrp++ )
	{
		for ( UINT ist = 0; ist < cstNode; ist++ )
		{
			ddense.Param(ist, igrp) = vlrDefault[ist];
		}
	}

	//  Iterate over the sparse map, storing probabilities as parameters
	const VCST & vcstParent = ddense.VcstParent();
	VIST vist;
	for ( MPCPDD::iterator mpitcpd = mpcpdd.begin();
		  mpitcpd != mpcpdd.end();
		  mpitcpd++ )
	{
		const VIMD & vimd = (*mpitcpd).first;
		const VLREAL & vlr = (*mpitcpd).second;
		//  State vector size must match state space
		assert( vlr.size() == cstNode );
		//  Parent dimensions must match dimension index
		assert( vdimchk( vimd, vcstParent ) );
		//  Convert the vector of unsigneds to a vector of signeds
		vdup( vist, vimd );
		//	Get the parameter group index
		UINT igrp = ddense.Iparamgrp( vist );
		//  Copy the probabilities as parameters
		for ( UINT ist = 0; ist < cstNode; ist++ )
		{
			ddense.Param(ist, igrp) = vlr[ist];
		}
	}
}

static void testDistDenseWithMpcpdd( DISTDENSE & ddense, const MPCPDD & mpcpdd )
{
}

static void loadDistSparseFromMpcpdd ( DISTSPARSE & dsparse, const MPCPDD & mpcpdd )
{
	dsparse.Init( mpcpdd );
}

static void testDistSparseWithMpcpdd ( DISTSPARSE & dsparse, const MPCPDD & mpcpdd )
{
	MPCPDD mpcpddNew;
	dsparse.Fill( mpcpddNew );

	assert( mpcpddNew == mpcpdd );
}
#endif

//  Bind the model's distibutions and verify behavior of the DISTSPARSE
//  and DISTDENSE classes.
static
void testDistributions ( MBNETDSC & mbnetdsc, ULONG fCtl )
{

#ifdef TESTDIST

	//  Bind the distributions
	mbnetdsc.BindDistributions();
	GOBJMBN * pgmobj;
	for ( MBNETDSC::ITER mbnit( mbnetdsc, GOBJMBN::EBNO_NODE );
		  pgmobj = *mbnit ; 
		  ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GNODEMBND * pgndd;
		DynCastThrow( pgmobj, pgndd );
	
		// Convert this node's distribution to a DISTDENSE and
		// a DISTSPARSE, then compare them to the original
		assert( pgndd->BHasDist() );
		const BNDIST & bndist = pgndd->Bndist();
		assert( bndist.BSparse() );
		const MPCPDD & mpcpdd = bndist.Mpcpdd();

		// Get the parent list for this node; convert to a state count vector
		VPGNODEMBN vpgndParents;
		VIMD vimdParents;
		if ( ! pgndd->BGetVimd( vimdParents ) ) 
			continue;	//  Skip non-discrete ensembles
		VCST vcstParents;
		vdup( vcstParents, vimdParents );
		CST cStates = pgndd->CState();		

		DISTDENSE ddense( cStates, vcstParents );
		DISTSPARSE dsparse( cStates, vcstParents );
		loadDistDenseFromMpcpdd( ddense, mpcpdd );
		testDistDenseWithMpcpdd( ddense, mpcpdd );
		loadDistSparseFromMpcpdd( dsparse, mpcpdd );
		testDistSparseWithMpcpdd( dsparse, mpcpdd );
	}
	
	//  Release the distributions
	mbnetdsc.ClearDistributions();
#endif
}

static 
void
showInferStats ( TESTINFO & testinfo )
{
	GOBJMBN_INFER_ENGINE * pInferEng = testinfo.Mbnet().PInferEngine();
	assert( pInferEng );
	GOBJMBN_CLIQSET * pCliqset = dynamic_cast<GOBJMBN_CLIQSET *>(pInferEng);
	if ( pCliqset == NULL )
		return;		//  Don't know how to get statistics from this inference engine

	CLIQSETSTAT & cqstats = pCliqset->CqsetStat();
	cout << "\n\nInference statistics: "
		 << "\n\treloads = " << cqstats._cReload
		 << "\n\tcollects = " << cqstats._cCollect
		 << "\n\tset evidence = " << cqstats._cEnterEv
		 << "\n\tget belief = " << cqstats._cGetBel
		 << "\n\tprob norm = " << cqstats._cProbNorm
		 << "\n"
		 ;
}

static
void testInference ( ULONG fCtl, MBNETDSC & mbnet, SZC szcFnInfer, REAL rImposs )
{
	ofstream ofs;
	bool bOutput = (fCtl & fOutputFile) > 0 ;
	int cPass = fCtl & fPassCountMask;
	GOBJMBN_INFER_ENGINE * pInferEng = mbnet.PInferEngine();
	assert( pInferEng );

	if ( bOutput )
	{
		if ( szcFnInfer == NULL )
			szcFnInfer = "infer.dmp";
		ofs.open(szcFnInfer);
	}

	//  Construct the test data container
	TESTINFO testinfo( fCtl, mbnet, bOutput ? & ofs : NULL );
	testinfo._rImposs = rImposs;

	//  Run the test
	testinfo.InferTest();

	if ( bOutput )
		ofs.close();

	if ( fCtl & fInferStats )
		showInferStats( testinfo );
}

static
void testCliquingStart ( ULONG fCtl, MBNETDSC & mbnet, REAL rMaxEstSize = -1.0 )
{
#ifdef DUMP
	if ( BFlag( fCtl, fVerbose ) )
	{
		cout << "\nBNTEST: BEGIN model before cliquing";
		mbnet.Dump();
		cout << "\nBNTEST: END model before cliquing\n";
	}
#endif
	mbnet.CreateInferEngine( rMaxEstSize );

#ifdef DUMP
	if ( BFlag( fCtl, fVerbose ) )
	{
		cout << "\nBNTEST: BEGIN model after cliquing";
		mbnet.Dump();
		cout << "\nBNTEST: END model after cliquing\n";
	}
#endif
}

static
void testCliquingEnd ( MBNETDSC & mbnet, ULONG fCtl )
{
	GOBJMBN_INFER_ENGINE * pInferEng = mbnet.PInferEngine();
	if ( pInferEng == NULL )
		return;

	mbnet.DestroyInferEngine();

	//  For testing, nuke the topology
	mbnet.DestroyTopology( true );
	//  Create arcs from the given conditional probability distributions
	mbnet.CreateTopology();
	//  For testing, nuke the topology
	mbnet.DestroyTopology( false );
}

static
void testParser ( 
	ULONG fCtl, 
	SZC rgfn[], 
	REAL rMaxEstSize = -1.0,
	REAL rImposs = -1.0 )
{
	SZC szcFn		= rgfn[EFN_IN];
	SZC szcFnOut	= rgfn[EFN_OUT];
	SZC szcFnInfer	= rgfn[EFN_INFER];

	//  Instantiate the belief network
	MBNETDSC mbnet;

	//  See if there's an output file to write a DSC into
	FILE * pfOut = NULL;
	if ( (fCtl & fSaveDsc) > 0 && szcFnOut != NULL )
	{
		pfOut = fopen(szcFnOut,"w");
		if ( pfOut == NULL )
			die("error creating output DSC file \'%s\'", szcFnOut);
	}

	//  Input file wrapper object
	PARSIN_DSC flpIn;
	//  Output file wrapper object
	PARSOUT_STD flpOut(stderr);

	//  Construct the parser; errors go to 'stderr'
	DSCPARSER parser(mbnet, flpIn, flpOut);

	UINT cError, cWarning;

	try
	{
		//  Attempt to open the file
		if ( ! parser.BInitOpen( szcFn ) )
			die("unable to access input file");

		pauseIf( fCtl, "input DSC file open" );

		//	Parse the file
		if ( ! parser.BParse( cError, cWarning ) )
			die("parse failure; %d errors, %d warnings", cError, cWarning);
		if ( cWarning )
			cout << "\nBNTEST: file "
				 << szcFn
				 << " had "
				 << cWarning
				 << " warnings\n";

		if ( BFlag( fCtl, fReg ) )
			testRegistry( mbnet );

		pauseIf( fCtl, "DSC file read and processed" );

		if ( BFlag( fCtl, fDistributions ) )	
		{
			testDistributions( mbnet, fCtl );
		}

		//  If requested, test cloning
		if ( BFlag( fCtl, fClone ) )
		{
			MBNETDSC mbnetClone;
			mbnetClone.Clone( mbnet );
			if ( pfOut )
				mbnetClone.Print( pfOut );
		}
		else
		//  If requested, write out a DSC file
	    if ( pfOut )
		{
			mbnet.Print( pfOut );
		}

		//  Test cliquing if requested (/c) or required (/i)
		if ( BFlag( fCtl, fCliquing ) || BFlag( fCtl, fInference ) )
		{
			testCliquingStart( fCtl, mbnet, rMaxEstSize );

			pauseIf( fCtl, "Cliquing completed" );

			if ( BFlag( fCtl, fInference ) )
			{	
				//  Generate inference results (/i)
				testInference( fCtl, mbnet, szcFnInfer, rImposs );
				pauseIf( fCtl, "Inference output generation completed" );
			}
			testCliquingEnd( mbnet, fCtl ) ;

			pauseIf( fCtl, "Cliquing and inference completed" );
		}
		else
		//  Test if CI expansion requested (/e)
		if ( BFlag( fCtl, fExpand ) )
		{
			//  Perform CI expansion on the network.
			mbnet.ExpandCI();
			pauseIf( fCtl, "Network expansion complete" );

			//  If output file generation, do "before" and "after" expansion and reversal
			if ( pfOut )
			{
				fprintf( pfOut, "\n\n//////////////////////////////////////////////////////////////" );
				fprintf( pfOut,   "\n//          Network After Expansion                         //" );
				fprintf( pfOut,   "\n//////////////////////////////////////////////////////////////\n\n" );
				mbnet.Print( pfOut );
			}
			//  Undo the expansion
			mbnet.UnexpandCI();
			if ( pfOut )
			{
				fprintf( pfOut, "\n\n//////////////////////////////////////////////////////////////" );
				fprintf( pfOut,   "\n//          Network After Expansion Reversal                //" );
				fprintf( pfOut,   "\n//////////////////////////////////////////////////////////////\n\n" );
				mbnet.Print( pfOut );
			}
		}

		//  For testing, nuke the topology
		mbnet.DestroyTopology();
	}
	catch ( GMException & exbn )
	{
		die( exbn.what() );
	}

	if ( pfOut )
		fclose( pfOut );
}


int main (int argc, char * argv[])
{	
	int iArg ;
	short cPass = 1;
	int cFile = 0 ;
	const int cFnMax = 10 ;	
	SZC rgfn [cFnMax+1] ;
	ULONG fCtl = 0;
	REAL rMaxEstSize = -1.0;
	REAL rImposs = RNan();

	for ( int i = 0 ; i < cFnMax ; i++ )
	{
		rgfn[i] = NULL ;
	}			
	for ( iArg = 1 ; iArg < argc ; iArg++ )
	{
		switch ( argv[iArg][0] )
		{
			case '/':
			case '-':
				{
					char chOpt = toupper( argv[iArg][1] ) ;
					switch ( chOpt ) 						
					{
						case 'V':
							//  Provide verbose output
							fCtl |= fVerbose;
							break;
						case 'C':
							//  Perform cliquing
							fCtl |= fCliquing;
							break;
						case 'E':
							//  Test network CI expansion
							fCtl |= fExpand;
							break;
						case 'I':
							//  Exercise inference and optionally write the results in a standard form
							{
								int c = atoi( & argv[iArg][2] );
								if ( c > 0 )
								{
									fCtl |= fMulti;
									cPass = c;
								}
								fCtl |= fInference;
								break;
							}
						case 'P':
							//  Get the name of the inference output file
							fCtl |= fOutputFile | fInference;
							if ( ++iArg == argc )
								die("no output inference result file name given");
							rgfn[EFN_INFER] = argv[iArg];
							break;
						case 'S':
							//  Write the input DSC file as an output file
							fCtl |= fSaveDsc;
							if ( ++iArg == argc )
								die("no output DSC file name given");
							rgfn[EFN_OUT] = argv[iArg];
							break;
						case 'T':
							//  Display start and stop times
							fCtl |= fShowTime;
							break;
						case 'X':
							//  Pause at times during execution to allow the user to measure
							//		memory usage
							fCtl |= fPause;
							break;
						case 'Y':
							//  Clone the network after loading
							fCtl |= fClone;
							break;
						case 'N':
							//  Write the symbolic name into the inference exercise output file
							//		instead of the default full name.
							fCtl |= fSymName;
							break;
						case 'U':
							//  Compute utilities using inference
							fCtl |= fUtil | fInference;
							break;
						case 'B':
							//  Compute troubleshooting utilities using inference
							fCtl |= fTSUtil | fInference;
							break;
						case 'R':
							fCtl |= fReg;
							break;
						case 'Z':
							fCtl |= fInferStats;
							break;
						case 'M':
							{	//  Get the maximum estimated clique tree size
								float f = atof( & argv[iArg][2] );
								if ( f > 0.0 )
									rMaxEstSize = f;
								break;
							}
						case 'A':
							{
								if ( strlen( & argv[iArg][2] ) > 0 )
								{
									rImposs = atof( & argv[iArg][2] );
								}
								fCtl |= fImpossible;
								break;
							}
						case 'D':
							fCtl |= fDistributions;
							break;

						default:
							die("unrecognized option") ;
							break ;
					}
				}
				break;

			default:
				if ( cFile == 0 )
					rgfn[cFile++] = argv[iArg] ;
				else
					die("too many file names given");
				break ;
		}
	}

	fCtl |= fPassCountMask & cPass;


	if ( cFile == 0 )
	{
		usage();
		return 0;
	}
	
	//  Display options and the debugging build mode
	showOptions( fCtl );

	//  Display the start message
	CTICKS tmStart = showPhase( fCtl, "BNTEST starts" );

	if ( rMaxEstSize > 0.0 )
		cout << "\nMaximum clique tree size estimate is " << rMaxEstSize;

	//  Test the parser and everything else
	testParser( fCtl, rgfn, rMaxEstSize, rImposs );

	//  Display the stop message
	showPhase( fCtl, "BNTEST completed", & tmStart );

	//  Print memory leaks of primary objects, if any
	printResiduals();

	cout << "\n";

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bnparse.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bnparse.h
//
//--------------------------------------------------------------------------

//
//	BNPARSE.H
//	
#ifndef _BNPARSE_H_
#define _BNPARSE_H_

#include "symtmbn.h"		//  Symbol table defs
#include "parser.h"			//  Generated YACC parser header
#include "gmobj.h"			//  Graphical model object defs
#include "parsfile.h"		//  Parser file stream thunks
#include "domain.h"			//  Named domains
#include "tchar.h"
typedef vector<CHAR> VTCHAR;

class	DSCPARSER;			//  The parser
class	BNDIST;				//	A probability distribution

#define YYSTATIC    static
#define YYVGLOBAL			//  Make parse stack "yyv" (only) global, not static

//  Manifests to map YACC elements to class DSCPARSER
#define yyparse     DSCPARSER::YaccParse
#define YYPARSER    DSCPARSER::YaccParse
#define YYLEX       TokenNext
#define yylex       TokenNext
#define yyerror     SyntaxError
#define YYMAXDEPTH	150

struct   YYSTYPE
{
	union {
		UINT        ui;
		INT         integer;		
		REAL        real;			
	};
    ZSREF zsr;				
};

extern YYSTYPE  yylval, yyval;
extern YYSTYPE  yyv[YYMAXDEPTH];


struct PROPVAR
{
	enum ETYPE { ETPV_NONE, ETPV_STR, ETPV_REAL } _eType;
	ZSREF  _zsref;	//  String
	REAL _r;		//	Real value

	PROPVAR ()
		: _eType( ETPV_NONE )
		{}	
	PROPVAR ( ZSREF zsr )
		: _eType(ETPV_STR),
		_r(0.0)
		{
			_zsref = zsr;
		}
	PROPVAR ( GOBJMBN * pbnobj )
		: _eType(ETPV_STR),
		_r(0.0)
		{
			_zsref = pbnobj->ZsrefName();
		}
	PROPVAR ( REAL & r )
		: _eType(ETPV_REAL),
		_r(r)
		{}
	bool operator == ( const PROPVAR & bnp ) const;
	bool operator != ( const PROPVAR & bnp ) const;
	bool operator < ( const PROPVAR & bnp ) const;
	bool operator > ( const PROPVAR & bnp ) const;
};

// Define VPROPVAR
DEFINEV(PROPVAR);

enum    SDPI            //  status of discrete parent instantiation
{
    sdpiAbsent, sdpiPresent, sdpiNotNeeded,
};

DEFINEV(SDPI);

class DSCPARSER 
{
  protected:
    enum 
	{ 
		_cchTokenMax = 256,
        _cstrMax  = _cchTokenMax,
        _crealMax = _cstrMax,
        _csymbMax =  32,
        _cuiMax   = _csymbMax
    };

	enum EBLKTYPE
	{
		EBLKNONE,		//  No block
		EBLKNET,		//  Network block
		EBLKPROP,		//  Properties block
		EBLKNODE,		//  Node block
		EBLKPROB,		//  Probabilities block
		EBLKDOM,		//  Domain block
		EBLKDIST,		//  Distribution block
		EBLKIGN,		//  Ignore block
	};

  public:
	DSCPARSER ( MBNET & mbnet, 
			    PARSIN & flpIn, 
				PARSOUT & flpOut );
	~ DSCPARSER ();

	//  Open the target file
    bool    BInitOpen(SZC szcFile);
	//  Parse it; return tallies of errors and warnings
	bool	BParse ( UINT & cError, UINT & cWarning );

	//  Return the network being built
	MBNET & Mbnet ()
		{ return _mbnet ; }

  protected:
	MPSYMTBL & Mpsymtbl ()		{ return _mbnet.Mpsymtbl();	}
	MPPD &	Mppd ()				{ return _mbnet.Mppd();		}

	//  Parsing function (in PARSER.Y/PARSER.CPP)
	INT     YaccParse();	

	// Parsing functions
	GNODEMBND* PgndbnAdd(ZSREF zsr);
    void    AddSymb(ZSREF zsr);
	void	AddStr(ZSREF zsr);
	void	AddPropVar (ZSREF zsr);
	void	AddPropVar (REAL & r);
	void	AddPv ( PROPVAR & pv );
	void    AddUi(UINT ui);
    void    AddReal(REAL real);
	UINT	UiDpi(ZSREF zsr);
	UINT	UiDpi(UINT ui);
	void	SetNodeFullName(ZSREF zsr);
	void	SetNodePosition( int x, int y );
	void	SetCreator(ZSREF zsr);
	void    SetFormat(ZSREF zsr);
	void	SetVersion(REAL r);
    void    SetNetworkSymb(ZSREF zsr);
    void    ClearNodeInfo();
    void    SetNodeSymb(ZSREF zsr, bool bNew);
	void	StartNodeDecl(ZSREF zsr);
    void    CheckNodeInfo();
    void    SetNodeCstate(UINT cstate);
    void    CheckParentList();
    void    CheckProbVector();
    void    InitProbEntries();
    void    CheckProbEntries();
	void	EmptyProbEntries();
    void    CheckCIFunc(ZSREF zsr);
    void    CheckDPI(bool bDefault);
	void	AddPropType(ZSREF zsrName, UINT fType, ZSREF zsrComment);
	void	ImportPropStandard();
	void	ImportProp(ZSREF zsrName);
	void	ClearCstr();
	void	ClearVpv();
	void	CheckProperty( ZSREF zsrName );
	void	StartProperties();
	void	EndProperties();
	void	SetStates();
	void	CheckDomain(ZSREF zsr);
	void	ClearDomain();
	void	SetRanges( bool bLower, REAL rLower, bool bUpper, REAL rUpper);
	void	SetRanges( ZSREF zsrLower, ZSREF zsrUpper);
	void	AddRange( ZSREF zsr, bool bSingleton = false );
	void	SetNodeDomain( ZSREF zsr );

//NYI START
    void    CheckPDF(ZSREF zsr);
	void	CheckIdent( ZSREF zsr );
//NYI END

  // Lexing functions
    TOKEN   TokenKeyword();
    TOKEN   TokenNext();
    TOKEN   TokenNextBasic();
    SZC     SzcToken()					{ return & _vchToken[0]; }
    void    Warning(SZC szcFormat, ...);
    void    Error(SZC szcFormat, ...);
	void	ErrorWarn( bool bErr, SZC szcFormat, va_list & valist );
    void    ErrorWarn(bool bErr, SZC szcFormat, ...);
    void    ErrorWarnNode(bool bErr, SZC szcFormat, ...);
	void	WarningSkip ( ZSREF zsrBlockName );

    bool    BChNext();
    void    SkipWS();
    void    SkipToEOL();
    void    AddChar ( TCHAR tch = 0 );
    void    AddCharStr ( TCHAR tch = 0 );
    char    ChEscape();
    void    CloseToken(SZC szcTokenType);
    void    CloseIdentifier();
	GOBJMBN * PbnobjFind ( SZC szcName );
	GNODEMBND * PgndbnFind ( SZC szcName );
    void	SkipUntil(SZC szcStop, bool bDidLookAhead = false);
    void	SyntaxError(SZC szcError);
	void	ReportNYI (SZC szcWhich);
	void	PrintDPI ( UINT idpi );

	void	ResetParser ();

	//  Return true if current node and its distribution are valid	
	bool	BNodeProbOK () const
			{ return _pnode != NULL && _refbndist.BRef(); }

	//  Return the current distribution reference
	REFBNDIST & RefBndist () 
			{ return _refbndist; }

	//	Allocate and identify a new distribution
	void	CreateBndist ( const VTKNPD & vtknpd, const VIMD & vimdDim );

  protected:
	//  Parsing and lexing control variables
	PARSIN  & _flpIn;			//  Input stream
	PARSOUT & _flpOut;			//  Output Stream
	char	_chCur;				//  Last character read
	char	_chUnget;			//  Pushed-back character (if != 0)
	VTCHAR  _vchToken;			//  The current token being built
	UINT	_cchToken;			//  Length of token
	UINT	_iLine;				//  Line number
	UINT	_cError;			//  Error count
	UINT	_cWarning;			//  Warning count
    UINT    _cerrorNode;        //  Number of errors for current node
    TOKEN   _tokenCur;			//  Current token
    bool    _bUngetToken;		//  Return current token again?

	//  Semantic variables
	MBNET &	_mbnet;				//  The belief network
    GNODEMBND*  _pnode;			//  Current node
	BNDIST::EDIST _edist;		//  Type of distribution
	REFBNDIST _refbndist;		//  Current distribution for the node
	VIMD	_vimdDim;			//  Dimensions for dense prob table
    UINT    _cdpi;				//  Number of discrete parent instantiations
    VSDPI	_vsdpi;             //  Checks discrete parent instantiations
	UINT	_cui;				//  DPI checking
	INT		_idpi;				//  Number of unprefixed DPIs seen
	INT		_idpiLast;			//  Ptable index of last DPI seen
    bool    _bCI;               //  Causally independent CPT
    bool    _bDefault;          //  Does CPT have have a default entry
	bool	_bPropDefs;			//  File had private property definitions
	INT		_cNode;				//  Count of node declarations seen
	VZSREF	_vzsrParent;		//	Parents of the node
	EBLKTYPE _eBlk;				//  Type of block being parsed	
	VUINT	_vui;				//  Storage for arrays of integers
    VREAL   _vreal;				//	Storage for arrays of reals
	VZSREF  _vzsr;				//  Storage for arrays of strings
	VPROPVAR _vpv;				//  Storage for PROPVARs
	PROPMGR * _ppropMgr;		//  Property manager
	ESTDLBL  _elbl;				//  Node label
	RDOMAIN  _domain;			//  Domain list for domain declarations
	RANGELIM _rlimLower;		//  Lower bound of domain subrange
	RANGELIM _rlimUpper;		//  Upper bound of domain subrange
	INT		 _ilimNext;			//  Last upper bound given
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\clique.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       clique.cpp
//
//--------------------------------------------------------------------------

//
//	clique.cpp
//

#include <basetsd.h>
#include "cliqset.h"
#include "clique.h"
#include "cliqwork.h"

#include "parmio.h"

#ifdef _DEBUG				//  In debug mode only...
    #define CONSISTENCY			//  Do complete consistency checking on sepsets
//	#define DUMP				//  Perform general dumping of objects
//  #define DUMPCLIQUESET		//  Dump extensive tables from clique tree
//	#define INFERINIT			//  Full initial tree balancing
#endif


////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
// GEDGEMBN_CLIQ: Edges between cliques and member nodes
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

GEDGEMBN_CLIQ :: GEDGEMBN_CLIQ (
	GOBJMBN_CLIQUE * pgnSource,
	GNODEMBN * pgndSink,
	int iFcqlRole )
	: GEDGEMBN( pgnSource, pgndSink ),
	_iFcqlRole( iFcqlRole ),
	_iMark( pgndSink->IMark() ),
	_bBuilt( false )
{
}

void GEDGEMBN_CLIQ :: Build ()
{
	if ( ! BBuilt() )
	{
		GNODEMBND * pgndd;
		DynCastThrow( PgndSink(), pgndd );

		//  If role is "Family", this edge is used for marginalization of belief
		//		and creating joint distribution in clique
		if ( BFamily() )
		{
			ReorderFamily( pgndd, _vimdFamilyReorder );
			//  Build the reordered marginals table for the node
			MargCpd().CreateOrderedCPDFromNode( pgndd, _vimdFamilyReorder );
			//  Build an iterator between the CPD and the clique joint
			MiterLoadClique().Build( PclqParent()->Marginals(), MargCpd() );
			//  Build the belief marginalization structure
			MiterNodeBelief().Build( PclqParent()->Marginals(), pgndd );			
		}
	
		_bBuilt = true;
	}
}

void GEDGEMBN_CLIQ :: LoadCliqueFromNode ()
{
	assert( _bBuilt );
	MiterLoadClique().MultiplyBy( MargCpd() );	
}

GEDGEMBN_CLIQ :: ~ GEDGEMBN_CLIQ()
{
}

GOBJMBN_CLIQUE * GEDGEMBN_CLIQ :: PclqParent()
{
	GOBJMBN * pobj = PobjSource();
	GOBJMBN_CLIQUE * pclq;
	DynCastThrow( pobj, pclq );
	return pclq;
}

GNODEMBN * GEDGEMBN_CLIQ :: PgndSink()
{
	GOBJMBN * pobj = PobjSink();
	GNODEMBN * pgnd;
	DynCastThrow( pobj, pgnd );
	return pgnd;
}

//  Using the topological renumber of the nodes, produce
//		an array correlating the old family to the new order.
//		In other words, vimd[0] will be the family index of
//		the node which had the lowest topological order; vimd[1]
//		will be the family index of the next lowest, etc.
//
//	Note that node itself is always last in either ordering.
void GEDGEMBN_CLIQ :: ReorderFamily ( GNODEMBN * pgnd, VIMD & vimd )
{
	VPGNODEMBN vpgndFamily;
	//  Get the family (parents & self)
	pgnd->GetFamily( vpgndFamily );
	int cFam = vpgndFamily.size();
	vimd.resize( cFam );
	for ( int i = 0; i < cFam; i++ )
	{
		int iLow = INT_MAX;
		int iFam = INT_MAX;
		//  Find the lowest unrecorded family member
		for ( int j = 0; j < cFam; j++ )
		{
			GNODEMBN * pgndFam = vpgndFamily[j];
			if ( pgndFam == NULL )
				continue;
			if ( pgndFam->IMark() < iLow )
			{
				iLow = pgndFam->IMark();
				iFam = j;
			}
		}
		assert( iLow != INT_MAX );
		vimd[i] = iFam;
		vpgndFamily[iFam] = NULL;
	}
}

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
//	GEDGEMBN_SEPSET:  A separator marginal
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
GEDGEMBN_SEPSET :: GEDGEMBN_SEPSET (
	GOBJMBN_CLIQUE * pgnSource,
	GOBJMBN_CLIQUE * pgnSink )
	: GEDGEMBN( pgnSource, pgnSink ),
	_pmargOld( new MARGINALS ),
	_pmargNew( new MARGINALS )
{
}

GEDGEMBN_SEPSET :: ~ GEDGEMBN_SEPSET()
{
	delete _pmargOld;
	delete _pmargNew;
}

void GEDGEMBN_SEPSET :: ExchangeMarginals ()
{
	pexchange( _pmargOld, _pmargNew );
}

GOBJMBN_CLIQUE * GEDGEMBN_SEPSET :: PclqParent()
{
	GOBJMBN * pobj = PobjSource();
	GOBJMBN_CLIQUE * pclq;
	DynCastThrow( pobj, pclq );
	return pclq;
}

GOBJMBN_CLIQUE * GEDGEMBN_SEPSET :: PclqChild()
{
	GOBJMBN * pobj = PobjSink();
	GOBJMBN_CLIQUE * pclq;
	DynCastThrow( pobj, pclq );
	return pclq;
}

void GEDGEMBN_SEPSET :: GetMembers ( VPGNODEMBN & vpgnode )
{
	GOBJMBN_CLIQUE * pclqSource = PclqParent();
	GOBJMBN_CLIQUE * pclqSink = PclqChild();
	VPGNODEMBN vpgndSink;
	VPGNODEMBN vpgndSource;
	pclqSource->GetMembers( vpgndSource );
	pclqSink->GetMembers( vpgndSink );

	assert( vpgndSink.size() > 0 );
	assert( vpgndSource.size() > 0 );
	
	//  Fill the given array with the intersection of the two clique
	//	member node arrays.  Since we cannot sort them into cliqing order
	//	anymore (IMark() is unreliable after cliquing), we just search
	//  one against the other in order to guarantee that the intersection
	//  result set has the same node ordering as the original sets.

	int ibLast = -1;
	for ( int ia = 0; ia < vpgndSink.size(); ia++ )
	{	
		GNODEMBN * pa = vpgndSink[ia];
		for ( int ib = ibLast+1; ib < vpgndSource.size(); ib++ )
		{	
			GNODEMBN * pb = vpgndSource[ib];	
			if ( pa == pb )
			{	
				vpgnode.push_back(pa);
				ibLast = ib;
				break;
			}
		}
	}
#ifdef DUMP
	if ( vpgnode.size() == 0 )
	{
		cout << "\nSEPSET INTERSECTION NULL: source clique:";
		pclqSource->Dump();
		cout << "\n\t\tsink clique:";
		pclqSink->Dump();
		cout << "\n";
		cout.flush();
	}
#endif
	assert( vpgnode.size() > 0 );
}

void GEDGEMBN_SEPSET :: CreateMarginals ()
{
	VPGNODEMBN vpgnd;
	GetMembers( vpgnd );
	MarginalsOld().Init( vpgnd );
	MarginalsNew().Init( vpgnd );

}

void GEDGEMBN_SEPSET :: InitMarginals ()
{
	assert( VerifyMarginals() );
	MarginalsOld().Clear( 1.0 );
	MarginalsNew().Clear( 1.0 );

	if ( ! _miterParent.BBuilt() )
		_miterParent.Build( PclqParent()->Marginals(), MarginalsOld() );
	if ( ! _miterChild.BBuilt() )
		_miterChild.Build( PclqChild()->Marginals(), MarginalsOld() );
}

bool GEDGEMBN_SEPSET :: VerifyMarginals ()
{
	VPGNODEMBN vpgnd;
	GetMembers( vpgnd );
	VIMD vimd = MARGINALS::VimdFromVpgnd( vpgnd );
	return vimd == Marginals().Vimd(); 	
}

void GEDGEMBN_SEPSET :: UpdateRatios ()
{
	MarginalsOld().UpdateRatios( MarginalsNew() );
}

void GEDGEMBN_SEPSET :: AbsorbClique ( bool bFromParentToChild )
{
	MARGSUBITER * pmiterFrom;
	MARGSUBITER * pmiterTo;

	if ( bFromParentToChild )
	{
		pmiterFrom = & _miterParent;
		pmiterTo = & _miterChild;
	}
	else
	{
		pmiterFrom = & _miterChild;
		pmiterTo = & _miterParent;
	}	

	// Marginalize "from" probs into the "new" marginals table
	pmiterFrom->MarginalizeInto( MarginalsNew() );
	// Absorb the changes into the "old" marginals table
	UpdateRatios();
	// Multiply the table into the "to"'s marginals
	pmiterTo->MultiplyBy( MarginalsOld() );

	// Finally, exchange the marginals tables
	ExchangeMarginals();
}

void GEDGEMBN_SEPSET :: BalanceCliquesCollect ()
{
	//  Use the "new" table as a work area.

	//  Marginalize the child into the work area
	_miterChild.MarginalizeInto( MarginalsNew() );
	//	Update the parent with those values
	_miterParent.MultiplyBy( MarginalsNew() );
	//  Invert each value, so we're really dividing
	MarginalsNew().Invert();
	//  Update the child marginals by dividing by the marginals
	_miterChild.MultiplyBy( MarginalsNew() );
	//  Clear the "new" marginals back to 1.0.
	MarginalsNew().Clear( 1.0 );	
}

void GEDGEMBN_SEPSET :: BalanceCliquesDistribute ()
{
	//  Set the old marginals to the parent clique's values
	_miterParent.MarginalizeInto( MarginalsOld() );
	//  Update the child marginals by those values
	_miterChild.MultiplyBy( MarginalsOld() );
	//  "Old" marginals are left as they are
}


void GEDGEMBN_SEPSET :: UpdateParentClique ()
{
	AbsorbClique( false );
}

void GEDGEMBN_SEPSET :: UpdateChildClique ()
{
	AbsorbClique( true );
}

void GEDGEMBN_SEPSET :: Dump ()
{
	GOBJMBN_CLIQUE * pclqParent = PclqParent();
	GOBJMBN_CLIQUE * pclqChild = PclqChild();

	cout << "\n=== Sepset between parent clique "
		 << pclqParent->IClique()
		 << " and child clique "
		 << pclqChild->IClique()
		 << ", \n\n\tOld marginals:";

	_pmargOld->Dump();

	cout << "\n\n\tNew marginals:";
	_pmargNew->Dump();
	cout << "\n\n";
}

bool GEDGEMBN_SEPSET :: BConsistent ()
{
	//  Get the sepset member list for creation of temporary marginals
	VPGNODEMBN vpgnd;
	GetMembers( vpgnd );

	//  Create the marginals for the parent clique
	GOBJMBN_CLIQUE * pclqParent = PclqParent();
	MARGINALS margParent;
	margParent.Init( vpgnd );
	pclqParent->Marginals().Marginalize( margParent );

	//  Create the marginals for the child clique
	GOBJMBN_CLIQUE * pclqChild = PclqChild();
	MARGINALS margChild;
	margChild.Init( vpgnd );
	pclqChild->Marginals().Marginalize( margChild );

	//  Are they equivalent?
	bool bOK = margParent.BEquivalent( margChild, 0.00000001 );

#ifdef DUMP
	if ( ! bOK )
	{
		cout << "\nGEDGEMBN_SEPSET::BConsistent: cliques are NOT consistent, parent clique "
			 << pclqParent->IClique()
			 << ", child "
			 << pclqChild->IClique();
		MARGINALS::Iterator itParent(margParent);
		MARGINALS::Iterator itChild(margChild);
		cout << "\n\tparent marginals: "
			 << itParent;
		cout << "\n\tchild marginals: "
			 << itChild
			 << "\n";
		cout.flush();
	}
#endif

#ifdef NEVER
	MARGINALS margParent2;
	margParent2.Init( vpgnd );
	
	_miterParent.Test( margParent2 );
	_miterParent.MarginalizeInto( margParent2 );
	bOK = margParent.BEquivalent( margParent2, 0.00000001 );
#endif

	ASSERT_THROW( bOK, EC_INTERNAL_ERROR, "inconsistent cliques" );

	return bOK;
}

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
// GOBJMBN_CLIQUE: A Clique
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

GOBJMBN_CLIQUE :: GOBJMBN_CLIQUE (
	int iClique,
	int iInferEngID )
	: _iClique( iClique ),
	_iInferEngID( iInferEngID ),
	_bRoot(false),
	_bCollect(false)
{
}

GOBJMBN_CLIQUE :: ~ GOBJMBN_CLIQUE()
{
}

//	Initialize a clique by finding all edges leading from "family"
//	  arcs and initializing the marginals from there.
void GOBJMBN_CLIQUE :: LoadMarginals ()
{
	GNODEMBND * pgnddSink;
	GEDGEMBN_CLIQ * pgedgeMbr;

	//  Prepare to enumerate child member arcs
	GNODENUM<GOBJMBN> benumMembers(false);
	benumMembers.SetETypeFollow( GEDGEMBN::ETCLIQUE );

	//  Enumerate child member arcs, reloading the marginals for nodes for which this
	//		clique is their "self" clique.
	for ( benumMembers.Set( this );
		  benumMembers.PnodeCurrent();
		  benumMembers++ )
	{
		DynCastThrow( benumMembers.PgedgeCurrent(), pgedgeMbr );
		pgedgeMbr->Build();

		if ( pgedgeMbr->BFamily() )
			pgedgeMbr->LoadCliqueFromNode();
	}

	//  Enumerate child member arcs, entering evidence (clamped state) for nodes for which this
	//		clique is their "self"
 	for ( benumMembers.Set( this );
		  benumMembers.PnodeCurrent();
		  benumMembers++ )
	{
		DynCastThrow( benumMembers.PgedgeCurrent(), pgedgeMbr );
		if ( ! pgedgeMbr->BSelf() )
			continue;

		DynCastThrow( benumMembers.PnodeCurrent(), pgnddSink );
		//  Note: ClampNode is benign when node is unclamped.
		Marginals().ClampNode( pgnddSink, pgedgeMbr->Clamp() );
	}

	SetCollect();
}

void GOBJMBN_CLIQUE :: GetMembers ( VPGNODEMBN & vpgnode )
{
	GNODENUM<GOBJMBN> benumMembers(false);
	benumMembers.SetETypeFollow( GEDGEMBN::ETCLIQUE );
	for ( benumMembers.Set( this );
		  benumMembers.PnodeCurrent();
		  benumMembers++ )
	{
		GOBJMBN * pgobj = *benumMembers;
		GNODEMBN * pgnd;
		DynCastThrow( pgobj, pgnd );
		vpgnode.push_back( pgnd );
	}
	assert( vpgnode.size() > 0 );
}

void GOBJMBN_CLIQUE :: CreateMarginals ()
{
	VPGNODEMBN vpgnd;
	GetMembers( vpgnd );
	Marginals().Init( vpgnd );
}

void GOBJMBN_CLIQUE :: InitMarginals ()
{
	assert( VerifyMarginals() );
	Marginals().Clear( 1.0 );
}

bool GOBJMBN_CLIQUE :: VerifyMarginals ()
{
	VPGNODEMBN vpgnd;
	GetMembers( vpgnd );
	VIMD vimd = MARGINALS::VimdFromVpgnd( vpgnd );
	return vimd == Marginals().Vimd(); 	
}

void GOBJMBN_CLIQUE :: Dump ()
{
	cout << "\n=== Clique "
		 << _iClique
		 << ", tree ID: "
		 << _iInferEngID
		 << ", root = "
		 << _bRoot;
	_marg.Dump();
	cout << "\n\n";
}

void GOBJMBN_CLIQUE :: GetBelief ( GNODEMBN * pgnd, MDVCPD & mdvBel )
{
	GNODEMBND * pgndd;
	DynCastThrow( pgnd, pgndd );
	Marginals().Marginalize( pgndd, mdvBel );
}

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
// GOBJMBN_CLIQSET:  The graphical model junction tree
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

GOBJMBN_CLIQSET :: GOBJMBN_CLIQSET (
	MBNET & model,
	REAL rMaxEstimatedSize,
	int iInferEngID  )
	: GOBJMBN_INFER_ENGINE( model, rMaxEstimatedSize, iInferEngID )
{
	Clear() ;
}

void GOBJMBN_CLIQSET :: Clear ()
{
	_eState = CTOR;
	_cCliques = 0;
	_cCliqueMemberArcs = 0;
	_cSepsetArcs = 0;
	_cUndirArcs = 0;
	_probNorm = 1.0;
	_bReset = true;
	_bCollect = true;
	_cqsetStat.Clear();
};

GOBJMBN_CLIQSET :: ~ GOBJMBN_CLIQSET ()
{
#ifdef DUMP
	Dump();
#endif
	Destroy();
}

bool GOBJMBN_CLIQSET :: BImpossible ()
{
	return ProbNorm() == 0.0;
}
		

//  Add an undirected arc iff there isn't one already.
bool GOBJMBN_CLIQSET :: BAddUndirArc ( GNODEMBN * pgndbnSource, GNODEMBN * pgndbnSink )
{
	if ( pgndbnSource->BIsNeighbor( pgndbnSink ) )
		return false;

#ifdef DUMP
	cout << "\n\t\tADD undirected arc from "
		 << pgndbnSource->ZsrefName().Szc()
		 << " to "
		 << pgndbnSink->ZsrefName().Szc();
#endif

	Model().AddElem( new GEDGEMBN_U( pgndbnSource, pgndbnSink ) );
	++_cUndirArcs;
	return true;
}

void GOBJMBN_CLIQSET :: CreateUndirectedGraph ( bool bMarryParents )
{
	if ( EState() >= MORAL )
		return;

	int cDirArcs = 0;
	int cUndirArcs = 0;
	int cNodes = 0;
	GELEMLNK * pgelm;

#ifdef DUMP
	cout << "\n\n***** MORALIZE GRAPH";
#endif

	if ( EState() < MORAL )
	{
		//  Create an undirected arc for every directed arc.
		MODEL::MODELENUM mdlenum( Model() );
		while ( pgelm = mdlenum.PlnkelNext() )
		{	
			//  Check that it's an edge
			if ( ! pgelm->BIsEType( GELEM::EGELM_EDGE ) )
				continue;
				//  Check that it's a directed probabilistic arc
			if ( pgelm->EType() != GEDGEMBN::ETPROB )
				continue;

			GEDGEMBN * pgedge;
			DynCastThrow( pgelm, pgedge );
			GNODEMBN * pgndbnSource;
			GNODEMBN * pgndbnSink;
			DynCastThrow( pgedge->PnodeSource(), pgndbnSource );
			DynCastThrow( pgedge->PnodeSink(), pgndbnSink );

			//  If the sink (child) node has been expanded,
			//	consider only Expansion parents
			if (   pgndbnSink->BFlag( EIBF_Expanded )
				&& ! pgndbnSource->BFlag( EIBF_Expansion ) )
				continue;

			cDirArcs++;
			cUndirArcs += BAddUndirArc( pgndbnSource, pgndbnSink );
		}
		assert( cDirArcs == cUndirArcs ) ;

		//  Undirected graph has been created
		_eState = UNDIR;
	}
	if ( !bMarryParents )
		return;

#ifdef DUMP
	cout << "\n\n***** MARRY PARENTS";
#endif


	MODEL::MODELENUM mdlenum( Model() );
	GNODENUM<GNODEMBN> benumparent(true);
	benumparent.SetETypeFollow( GEDGEMBN::ETPROB );
	GNODEMBN * pgndmbn;
	VPGNODEMBN vpgnd;

	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		if ( pgelm->EType() != EBNO_NODE )
			continue;
			
		DynCastThrow( pgelm, pgndmbn );

		//  Collect the parents
		vpgnd.resize(0);
		pgndmbn->GetParents( vpgnd );

		//  Marry them
		int cParent = vpgnd.size();
		for ( int iParent = 0; iParent < cParent - 1; iParent++ )
		{
			for ( int ip2 = iParent+1; ip2 < cParent ; ip2++ )
			{
				BAddUndirArc( vpgnd[iParent], vpgnd[ip2] );
			}
		}
	}

	//  Graph is now moral
	_eState = MORAL;
}

//
//	Return the number of neighbors of this node which are unlinked
//
int GOBJMBN_CLIQSET :: CNeighborUnlinked ( GNODEMBN * pgndmbn, bool bLinkNeighbors )
{
	int cNeighborUnlinked = 0;

	//  Get the array of neighbors
	VPGNODEMBN vpgnode;
	pgndmbn->GetNeighbors( vpgnode );

#ifdef DUMP
	cout << "\n\t\tCNeighborUnlinked, called for node "
		 << pgndmbn->ZsrefName().Szc();
#endif
	
	for ( int inbor = 0; inbor < vpgnode.size(); inbor++ )
	{
		GNODEMBN * pgndNbor = vpgnode[inbor];

#ifdef DUMP
		cout << "\n\t\t\t" << pgndNbor->ZsrefName().Szc();
		int cUnlinked = 0;
#endif
		if ( pgndNbor->IMark() )
			continue;		//  Node has been eliminated already

		//  Check it against all other neighbors.
		for ( int inbor2 = inbor + 1; inbor2 < vpgnode.size(); inbor2++ )
		{
			GNODEMBN * pgndNbor2 = vpgnode[inbor2];

			//  See if node has been eliminated already or is already a neighbor
			if ( pgndNbor2->IMark() )
				continue;

			if ( pgndNbor->BIsNeighbor( pgndNbor2 ) )
			{
				assert( pgndNbor2->BIsNeighbor( pgndNbor ) );
				continue;		
			}
#ifdef DUMP
			cUnlinked++;
#endif
			++cNeighborUnlinked;

			if ( bLinkNeighbors )
			{
				BAddUndirArc( pgndNbor, pgndNbor2 );
#ifdef DUMP
				cout << "  ("
					 << pgndNbor->ZsrefName().Szc()
					 << " <-> "
					 << pgndNbor2->ZsrefName().Szc()
					 << ")  ";
#endif
			}
		}
#ifdef DUMP
		if ( cUnlinked )
			cout << " <-- unlinked to "
				 << cUnlinked
				 << " neighbors";
#endif
	}
#ifdef DUMP
	cout << "\n\t\t---- total unlinked = " << cNeighborUnlinked;
#endif	
	return cNeighborUnlinked;
}

void GOBJMBN_CLIQSET :: Eliminate ( GNODEMBN * pgndmbn, CLIQSETWORK & clqsetWork )
{
#ifdef DUMP
	cout << "\n\n***** ELIMINATE "
		 << pgndmbn->ZsrefName().Szc();
#endif

	//  Add another array to the clique set and fill it with the clique menbers
	clqsetWork._vvpgnd.push_back( VPGNODEMBN() );
	VPGNODEMBN & vpgndClique = clqsetWork._vvpgnd[ clqsetWork._vvpgnd.size() - 1 ];

	//  Complete the elimination of this node and its neighbors.
	CNeighborUnlinked( pgndmbn, true );
	pgndmbn->IMark() = ++clqsetWork._iElimIndex;

	//  Start the clique with this entry.
	vpgndClique.push_back( pgndmbn );

	//  Iterate over the neighbors, adding the unmarked ones
	GNODENUM_UNDIR gnenumUndir;
	for ( gnenumUndir = pgndmbn;
		  gnenumUndir.PnodeCurrent();
		  gnenumUndir++ )
	{
		GNODEMBN * pgndmbNeighbor = *gnenumUndir;
		if ( pgndmbNeighbor->IMark() == 0 )
			vpgndClique.push_back( pgndmbNeighbor );
	}

#ifdef DUMP
	cout << "\n\t\tNEW CLIQUE: ";
	clqsetWork.DumpClique( clqsetWork._vvpgnd.size() - 1 );
#endif
	
	assert( pgndmbn->IMark() > 0 );
}

void GOBJMBN_CLIQSET :: GenerateCliques ( CLIQSETWORK & clqsetWork )
{
	//  Reset marks in all nodes
	Model().ClearNodeMarks();
	clqsetWork._vvpgnd.clear();

#ifdef DUMP
	cout << "\n\n***** GENERATE CLIQUES";
#endif

	for(;;)
	{	
		// Find the node that requires the fewest edges to turn into a clique.
		GNODEMBN * pgndmbnMin = NULL;
		int cNeighborMin = INT_MAX;

		MODEL::MODELENUM mdlenum( Model() );
		GELEMLNK * pgelm;
		while ( pgelm = mdlenum.PlnkelNext() )
		{	
			if ( pgelm->EType() != EBNO_NODE )
				continue;
				
			GNODEMBN * pgndmbn;
			DynCastThrow( pgelm, pgndmbn );

			if ( pgndmbn->IMark() )
				continue;		//  Node has been eliminated already
	
			int cNeighborUnlinked = CNeighborUnlinked( pgndmbn );

			if ( cNeighborMin > cNeighborUnlinked )
			{	
				pgndmbnMin = pgndmbn;
				if ( (cNeighborMin = cNeighborUnlinked) == 0 )
					break;   //  zero is as few neighbors as possible
			}
		}
		if ( pgndmbnMin == NULL )
			break;

		//  Mark the node for elimination and assign an elimination order to it.  This
		//		number is crucial for the construction of the strong junction tree.

#ifdef DUMP
		cout << "\nGenerateCliques:  Eliminate "
			 << pgndmbnMin->ZsrefName().Szc()
			 << ", which has "
			 << cNeighborMin
			 << " unlinked neighbors";
#endif

		Eliminate( pgndmbnMin, clqsetWork );
	}

#ifdef DUMP
	cout << "\n\n";
#endif
}

//
//  Create the junction tree.
//
void GOBJMBN_CLIQSET :: Create ()
{
	Model().CreateTopology();

	ASSERT_THROW( EState() == CTOR, EC_INTERNAL_ERROR, "GOBJMBN_CLIQSET:Create already called" );

	//  If it hasn't been done already, create the undirected graph and moralize it.
	CreateUndirectedGraph(true);

	CLIQSETWORK clqsetWork(self);

	clqsetWork._iElimIndex = 1;

	//  Triangulate the undirected graph, eliminating nodes and accumulating cliques
	//		along the way.
	GenerateCliques( clqsetWork );
	if ( clqsetWork._vvpgnd.size() == 0 )
		return;

	_eState = CLIQUED;

#ifdef DUMP
	clqsetWork.DumpCliques();
#endif

	//  Provide a total ordering over the nodes based upon topological level
	// MSRDEVBUG:  What happened to the elimination index?  Koos doesn't use it; will we?
	//   Renumbering here overwrites the elimination order.
	clqsetWork.RenumberNodesForCliquing();
	//  Build the cliques
	clqsetWork.BuildCliques();

	//  Set clique membership and topological information
	clqsetWork.SetTopologicalInfo();

	//  Check that the running intersection property holds
	ASSERT_THROW( clqsetWork.BCheckRIP(),
				  EC_INTERNAL_ERROR,
				  "GOBJMBN_CLIQSET::Create: junction tree failed RIP test" );

	//  See if the resulting memory allocation size would violate the size estimate
	if ( _rEstMaxSize > 0.0 )
	{
		REAL rSizeEstimate = clqsetWork.REstimatedSize();
		if ( rSizeEstimate > _rEstMaxSize )
			throw GMException( EC_OVER_SIZE_ESTIMATE,
							   "Clique tree size violates estimated size limit" );
	}

	//  Create the topology-- all the trees in the forest
	clqsetWork.CreateTopology();

	//  Nuke the moral graph
	DestroyDirectedGraph();

	//  Bind the known distributions to their target nodes;
	_model.BindDistributions();

	//  Reset/initialize the "lazy" switches
	SetReset();

	//  Create the marginals in the cliques and sepsets
	CreateMarginals();

	_eState = BUILT;

	//  Load and initialize the tree
	Reload();

	//  Release the distributions from their target nodes
	_model.ClearDistributions();
}

DEFINEVP(GELEMLNK);

//
//  Destroy the junction tree.  Allow the GOBJMBN_CLIQSET object to be reused
//	for another cliquing operation later.
//
void GOBJMBN_CLIQSET :: Destroy ()
{
	if ( ! Model().Pgraph() )
		return;

	int cCliques = 0;
	int cCliqueMemberArcs = 0;
	int cSepsetArcs = 0;
	int cUndirArcs = 0;
	int cRootCliqueArcs = 0;

	VPGELEMLNK vpgelm;
	GELEMLNK * pgelm;
	MODEL::MODELENUM mdlenum( Model() );

	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		bool bDelete = false;

		int eType = pgelm->EType();

		if ( pgelm->BIsEType( GELEM::EGELM_EDGE ) )
		{
			GEDGEMBN * pgedge;
			DynCastThrow( pgelm , pgedge );
			int eType = pgedge->EType();
		
			switch ( eType )
			{
				case GEDGEMBN::ETPROB:
					break;
				case GEDGEMBN::ETCLIQUE:
					//  Clique membership arcs will go away automatically because
					//	cliques will be deleted.
					++cCliqueMemberArcs;
					break;
				case GEDGEMBN::ETJTREE:
					//  Junction tree arcs will go away automatically because
					//  cliques will be deleted.
					++cSepsetArcs;
					break;
				case GEDGEMBN::ETUNDIR:
					//  Undirected arcs must be deleted explicitly
					bDelete = true;
					++cUndirArcs;
					break;
				case GEDGEMBN::ETCLIQSET:
					++cRootCliqueArcs;
					break;
				default:
					THROW_ASSERT( EC_INTERNAL_ERROR, " GOBJMBN_CLIQSET::Destroy: Unrecognized edge object in graph" );
					break;
			}
		}
		else
		if ( pgelm->BIsEType( GELEM::EGELM_NODE ) )
		{
			GOBJMBN * pgobj;
			DynCastThrow( pgelm , pgobj );
			switch ( eType )
			{
				case GOBJMBN::EBNO_CLIQUE:
				{
					++cCliques;
					bDelete = true;
					break;
				}
				case GOBJMBN::EBNO_CLIQUE_SET:
				case GOBJMBN::EBNO_NODE:
				case GOBJMBN::EBNO_PROP_TYPE:
				case GOBJMBN::EBNO_USER:
					break;
				default:
					THROW_ASSERT( EC_INTERNAL_ERROR, " GOBJMBN_CLIQSET::Destroy: Unrecognized node object in graph" );
					break;
			}
		}
		else
		{
			THROW_ASSERT( EC_INTERNAL_ERROR, " GOBJMBN_CLIQSET::Destroy: Unrecognized object in graph" );
		}

		if ( bDelete )
			vpgelm.push_back( pgelm );
	}

	assert(	
				cCliques == _cCliques
			&&	cCliqueMemberArcs == _cCliqueMemberArcs
			&&	cSepsetArcs == _cSepsetArcs
			&&	cUndirArcs == _cUndirArcs
		  );

	for ( int i = 0; i < vpgelm.size(); )
	{
		delete vpgelm[i++];
	}
	Clear();
}

void GOBJMBN_CLIQSET :: DestroyDirectedGraph ()
{
	int cUndirArcs = 0;

	VPGELEMLNK vpgelm;	
	GELEMLNK * pgelm;
	MODEL::MODELENUM mdlenum( Model() );

	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		if ( pgelm->BIsEType( GELEM::EGELM_EDGE ) )
		{
			GEDGEMBN * pgedge;
			DynCastThrow( pgelm , pgedge );
			int eType = pgedge->EType();
		
			switch ( eType )
			{
				case GEDGEMBN::ETUNDIR:
					vpgelm.push_back( pgelm );
					++cUndirArcs;
					break;
				default:
					break;
			}
		}
	}

	assert(	cUndirArcs == _cUndirArcs );
	_cUndirArcs = 0;

	for ( int i = 0; i < vpgelm.size(); )
	{
		delete vpgelm[i++];
	}
}

//  Create and initialize all marginals tables
void GOBJMBN_CLIQSET :: CreateMarginals ()
{
	assert( _eState == CLIQUED ) ;
	//MSRDEVBUG:  The class name qualifier should not be necessary here and below.
	WalkTree( true, & GOBJMBN_CLIQSET::BCreateClique, & GOBJMBN_CLIQSET::BCreateSepset );
}

//  Reset the entire tree by reloading all marginals tables
void GOBJMBN_CLIQSET :: LoadMarginals ()
{
	assert( _eState == BUILT ) ;
	
	WalkTree( true, & GOBJMBN_CLIQSET::BLoadClique, & GOBJMBN_CLIQSET::BLoadSepset );

	_cqsetStat._cReload++;
}

//  Apply the given member function(s) to every clique tree in the forest.
int GOBJMBN_CLIQSET :: WalkTree (
	bool bDepthFirst,				//  Depth first or breadth first?
	PFNC_JTREE pfJtree,				//	Function to apply to each clique
	PFNC_SEPSET pfSepset )			//  Function to apply to each sepset
{
	int cClique = 0;		// Don't count the clique set object
	int cWalk = 0;			// Return count of cliques visited
	GNODENUM<GOBJMBN> benumChildren(false);
	benumChildren.SetETypeFollow( GEDGEMBN::ETCLIQSET );
	for ( benumChildren.Set( this );
		  benumChildren.PnodeCurrent();
		  benumChildren++ )
	{
		GOBJMBN * pgobj = *benumChildren;
		assert( pgobj->EType() == GNODEMBN::EBNO_CLIQUE );
		GOBJMBN_CLIQUE * pCliqueTreeRoot;
		DynCastThrow( pgobj, pCliqueTreeRoot );

		cWalk = bDepthFirst
			  ? WalkDepthFirst( pCliqueTreeRoot, pfJtree, pfSepset )
			  : WalkBreadthFirst( pCliqueTreeRoot, pfJtree, pfSepset );

		if ( cWalk < 0 )
			return -1;
		cClique += cWalk;
	}
	assert( cClique < 0 || cClique == _cCliques );
	return cClique;
}

//
//	Recursive depth-first walk down the tree.
//
//  Apply the given member function(s), depth first from this clique.
//  If application function call returns false, walk is aborted and
//	-1 is returned;	otherwise, count of cliques traversed is returned.
int GOBJMBN_CLIQSET :: WalkDepthFirst (
	GOBJMBN_CLIQUE * pClique,		//  Starting point
	PFNC_JTREE pfJtree,				//	Function to apply to each clique
	PFNC_SEPSET pfSepset )			//  Function to apply to each sepset
{
	assert( pClique ) ;
	assert( pClique->IInferEngID() == IInferEngID() ) ;

	if ( pfJtree )
	{
		//  Call the application function on the way down
		if ( ! (self.*pfJtree)( *pClique, true ) )
			return -1;
	}

	int cWalks = 1;		// Count the clique we just processed above
	int cWalk = 0;		// Return count of cliques visited
	GNODENUM<GOBJMBN_CLIQUE> benumChildren(false);
	benumChildren.SetETypeFollow( GEDGEMBN::ETJTREE );
	for ( benumChildren.Set( pClique );
		  benumChildren.PnodeCurrent();
		  benumChildren++ )
	{
		GOBJMBN_CLIQUE * pCliqueChild = NULL;
		GEDGEMBN_SEPSET * pgedge = NULL;

		if ( pfSepset )
		{
			//  Call the application function on the way down
			DynCastThrow( benumChildren.PgedgeCurrent(), pgedge );
			if ( ! (self.*pfSepset)( *pgedge, true ) )
				return -1;
		}
		DynCastThrow( benumChildren.PnodeCurrent(), pCliqueChild );
		cWalk = WalkDepthFirst( pCliqueChild, pfJtree, pfSepset );
		if ( cWalk < 0 )
			return -1;
		cWalks += cWalk;

		if ( pfSepset )
		{
			assert( pgedge );
			//  Call the application function on the way up
			if ( ! (self.*pfSepset)( *pgedge, false ) )
				return -1;
		}
	}

	if ( pfJtree )
	{
		//  Call the application function on the way up
		if ( ! (self.*pfJtree)( *pClique, false ) )
			return -1;
	}
	return cWalks;
}

//
//	Non-recursive breadth-first walk down the tree.
//	No "up" actions are called using the function pointers.
//
int GOBJMBN_CLIQSET :: WalkBreadthFirst (
	GOBJMBN_CLIQUE * pClique,		//  Starting point
	PFNC_JTREE pfJtree,				//	Function to apply to each clique
	PFNC_SEPSET pfSepset )			//  Function to apply to each sepset
{
	assert( pClique ) ;
	assert( pClique->IInferEngID() == IInferEngID() ) ;

	VPGEDGEMBN_SEPSET vpgedgeThis;
	VPGEDGEMBN_SEPSET vpgedgeNext;
	VPGEDGEMBN_SEPSET * pvpgedgeThis = & vpgedgeThis;
	VPGEDGEMBN_SEPSET * pvpgedgeNext = & vpgedgeNext;
	VPGEDGEMBN_SEPSET * pvpgedgeTemp = NULL;
	GOBJMBN_CLIQUE * pgobjClique = NULL;
	GEDGEMBN_SEPSET * pgedgeSepset = NULL;

	// Count the cliques we process, including this one
	int cWalk = 1;		

	// Starting clique is a special case; process it now
	if ( pfJtree )
	{
		//  Call the application function on the way down
		if ( ! (self.*pfJtree)( *pClique, true ) )
			return -1;
	}

	//  Prepare an enumerator for child cliques
	GNODENUM<GOBJMBN_CLIQUE> benumChildren(false);
	benumChildren.SetETypeFollow( GEDGEMBN::ETJTREE );

	//  Since we don't have the edge that led us here, put a NULL
	//		in its place to start iteration
	pvpgedgeNext->push_back(NULL);

	//  While there were entries at the last topological level...
	while ( pvpgedgeNext->size() )
	{
		//  Swap the array pointers and clear next pass array
		pexchange( pvpgedgeThis, pvpgedgeNext );
		pvpgedgeNext->clear();

		for ( int iEdge = 0; iEdge < pvpgedgeThis->size(); iEdge++ )
		{
			pgedgeSepset = (*pvpgedgeThis)[iEdge];
			pgobjClique = pgedgeSepset == NULL		
						? pClique		// This is the start of iteration
						: pgedgeSepset->PclqChild();

			assert( pgobjClique );
	
			//  Accumulate all child cliques of this clique,
			//		processing as necessary
			for ( benumChildren.Set( pgobjClique );
				  benumChildren.PnodeCurrent();
				  benumChildren++ )
			{
				GEDGEMBN_SEPSET * pgedge;
				DynCastThrow( benumChildren.PgedgeCurrent(), pgedge );

				if ( pfSepset )
				{
					//  Call the sepset application function on the way down
					if ( ! (self.*pfSepset)( *pgedge, true ) )
						return -1;
				}
				if ( pfJtree )
				{
					//  Call the clique application function on the way down
					GOBJMBN_CLIQUE * pCliqueChild = pgedge->PclqChild();
					if ( ! (self.*pfJtree)( *pCliqueChild, true ) )
						return -1;
				}
				cWalk++;
				pvpgedgeNext->push_back( pgedge );
			}
		}
	}

	return cWalk;
}

//
//  Terminology: "Create", "Init" and "Load":
//
//		'Create' means to size the dynamic arrays;
//		'Init'   means to initialize them to 1.0;
//		'Load'	 means to multiply in the probabilities of the clique members.
//
bool GOBJMBN_CLIQSET :: BCreateClique ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	clique.CreateMarginals();
	return true;
}

bool GOBJMBN_CLIQSET :: BLoadClique ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	clique.InitMarginals();
	clique.LoadMarginals();
	return true;
}

bool GOBJMBN_CLIQSET :: BCreateSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	sepset.CreateMarginals();
	return true;
}

bool GOBJMBN_CLIQSET :: BLoadSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	sepset.InitMarginals();
	return true;
}

//  Return the "family" or "self" clique for a node
GOBJMBN_CLIQUE * GOBJMBN_CLIQSET :: PCliqueFromNode (
	GNODEMBN * pgnd,					//  Node to find clique for
	bool bFamily, 						//	"family" clique if true, "self" clique if false
	GEDGEMBN_CLIQ * * ppgedgeClique )	//  return pointer to edge if not NULL
{
	GEDGEMBN_CLIQ::FCQLROLE fcqlRole = bFamily
									 ? GEDGEMBN_CLIQ::FAMILY
									 : GEDGEMBN_CLIQ::SELF;
	//  Prepare to iterate over the source arcs
	GNODENUM<GOBJMBN> benumMembers(true);
	benumMembers.SetETypeFollow( GEDGEMBN::ETCLIQUE );
	for ( benumMembers.Set( pgnd );
		  benumMembers.PnodeCurrent();
		  benumMembers++ )
	{
		GEDGEMBN_CLIQ * pgedgeClique;
		DynCastThrow( benumMembers.PgedgeCurrent(), pgedgeClique );
		GOBJMBN_CLIQUE * pgobjClique = pgedgeClique->PclqParent();
		if ( pgobjClique->IInferEngID() != IInferEngID() )
			continue;  //  not an edge for this junction tree
		if ( pgedgeClique->IFcqlRole() & fcqlRole )
		{
			if ( ppgedgeClique )
				*ppgedgeClique = pgedgeClique;
			return pgedgeClique->PclqParent();
		}
	}
	assert( false );
	return NULL;
}

//
//  Enter evidence for a node.
//
void GOBJMBN_CLIQSET :: EnterEvidence ( GNODEMBN * pgnd, const CLAMP & clamp )
{	
	//  Get the pointer to the node's "self" clique and the edge leading to it
	GEDGEMBN_CLIQ * pgedgeClique = NULL;
	GOBJMBN_CLIQUE * pCliqueSelf = PCliqueFromNode( pgnd, false, & pgedgeClique );
	ASSERT_THROW( pCliqueSelf,
				  EC_INTERNAL_ERROR,
				  "GOBJMBN_CLIQSET::EnterEvidence: can\'t find self clique" );
	assert( pgedgeClique );

	//  Update with evidence if it has changed
	if ( pgedgeClique->Clamp() != clamp )
	{		
		//  Evidence is NOT the same as the old evidence
		pgedgeClique->Clamp() = clamp;
		//  Indicate that we must reload the tree
		SetReset();
		pCliqueSelf->SetCollect();

		_cqsetStat._cEnterEv++;
	}
}

//
//	Return the evidence "clamp" for a node.  It is stored in the edge
//	between the node and its "self" clique: the highest clique in the tree
//	of which the node is a member.
//
void GOBJMBN_CLIQSET :: GetEvidence ( GNODEMBN * pgnd, CLAMP & clamp )
{
	//  Get the pointer to the node's "self" clique and the edge leading to it
	GEDGEMBN_CLIQ * pgedgeClique = NULL;
	GOBJMBN_CLIQUE * pCliqueSelf = PCliqueFromNode( pgnd, false, & pgedgeClique );
	ASSERT_THROW( pCliqueSelf,
				  EC_INTERNAL_ERROR,
				  "GOBJMBN_CLIQSET::GetEvidence: can\'t find self clique" );

	assert( pgedgeClique );
	clamp = pgedgeClique->Clamp();
}

void GOBJMBN_CLIQSET :: GetBelief ( GNODEMBN * pgnd, MDVCPD & mdvBel )
{
	GEDGEMBN_CLIQ * pgedgeClique = NULL;
	GOBJMBN_CLIQUE * pCliqueFamily = PCliqueFromNode( pgnd, true, & pgedgeClique );
	ASSERT_THROW( pCliqueFamily,
				  EC_INTERNAL_ERROR,
				  "GOBJMBN_CLIQSET::GetBelief: can\'t find family clique" );
	//  Perform inference if necessary
	Infer();
	//  Marginalize the clique down to one node
	GNODEMBND * pgndd;
	DynCastThrow( pgnd, pgndd );
	pgedgeClique->MiterNodeBelief().MarginalizeBelief( mdvBel, pgndd );

	_cqsetStat._cGetBel++;
}

PROB GOBJMBN_CLIQSET :: ProbNorm ()
{
	// MSRDEVBUG
	/*
	Reset();
	CollectEvidence();
	*/
	Infer();

	_cqsetStat._cProbNorm++;
	return _probNorm;
}

//
//	Reload all marginals, reset the trees
//
void GOBJMBN_CLIQSET :: Reload ()
{
	SetReset( true );
	Reset();
}

//
//	Reset all marginals, restore all clamped evidence and
//		perform the initial inference pass.
//
void GOBJMBN_CLIQSET :: Reset ()
{
	assert( EState() >= BUILT );
	if ( ! _bReset )
		return;

	_probNorm = 1.0;
	LoadMarginals();
	SetReset( false );

	//  Initialize the entire tree for inference
#ifdef INFERINIT
	InferInit();
#endif

	SetCollect(true);
}

//  Perform an inference cycle if necessary
void GOBJMBN_CLIQSET :: Infer ()
{
	Reset();		//  Reloads the tree if necessary
	if ( ! BCollect() )
		return;

#ifdef DUMPCLIQUESET
	cout << "\n\n===============================================================";
	cout <<   "\n============= Dump of clique tree before inference ===============\n";
	Dump();
	cout << "\n========= End Dump of clique tree before inference ===============";
	cout << "\n===============================================================\n\n";
	cout << "\n\nGOBJMBN_CLIQSET::Infer: begin.";
#endif

	CollectEvidence();
	DistributeEvidence();	

#ifdef CONSISTENCY
	CheckConsistency();
#endif
	
	SetCollect( false );

#ifdef DUMPCLIQUESET
	cout << "\n\n===============================================================";
	cout <<   "\n============= Dump of clique tree after inference ===============\n";
	Dump();
	cout << "\n========= End Dump of clique tree after inference ===============";
	cout << "\n===============================================================\n\n";
	cout << "\nGOBJMBN_CLIQSET::Infer: end.\n\n";
#endif
}

//   Perform initial inference collect/distribute cycle
void GOBJMBN_CLIQSET :: InferInit ()
{
#ifdef DUMPCLIQUESET
	cout << "\n\n===============================================================";
	cout <<   "\n============= Dump of clique tree before inference INIT ======\n";
	Dump();
	cout << "\n========= End Dump of clique tree before inference  INIT ======";
	cout << "\n===============================================================\n\n";
	cout << "\n\nGOBJMBN_CLIQSET::InferInit: begin.";
#endif

	CollectEvidenceInit();
	DistributeEvidenceInit();	

#ifdef DUMPCLIQUESET
	cout << "\n\n===============================================================";
	cout <<   "\n============= Dump of clique tree after inference  INIT =======\n";
	Dump();
	cout << "\n========= End Dump of clique tree after inference  INIT ========";
	cout << "\n================================================================\n\n";
	cout << "\nGOBJMBN_CLIQSET::InferInit: end.\n\n";
#endif
}

void GOBJMBN_CLIQSET :: CollectEvidence()
{
	WalkTree( true, BCollectEvidenceAtRoot,
				    BCollectEvidenceAtSepset );

	_cqsetStat._cCollect++;
}

void GOBJMBN_CLIQSET :: DistributeEvidence()
{
	WalkTree( true, BDistributeEvidenceAtRoot,
				    BDistributeEvidenceAtSepset );
}

void GOBJMBN_CLIQSET :: CollectEvidenceInit ()
{
	WalkTree( true, BCollectInitEvidenceAtRoot,
				    BCollectInitEvidenceAtSepset );
}

void GOBJMBN_CLIQSET :: DistributeEvidenceInit ()
{
	WalkTree( true, BDistributeInitEvidenceAtRoot,
				    BDistributeInitEvidenceAtSepset );
}

void GOBJMBN_CLIQSET :: CheckConsistency ()
{
	WalkTree( true, NULL, BConsistentSepset );
}

bool GOBJMBN_CLIQSET :: BConsistentSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;
	return sepset.BConsistent();
}

//  When the collection cycle has completed for a tree, recompute the
//	"prob norm" value.
bool GOBJMBN_CLIQSET :: BCollectEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( bDownwards || ! clique.BRoot() )
		return true;

	//  This is a root clique at the end of the collection cycle.
	//  Normalize the clique and maintain the norm of the the probability
	//  of the tree.
	//  MSRDEVBUG: (Explain this better!)
	REAL rProb = clique.Marginals().RSum();
	_probNorm *= rProb;
	if ( rProb != 0.0 )
	{
		rProb = 1.0 / rProb;
		clique.Marginals().Multiply( rProb );
	}

#ifdef DUMPCLIQUESET
	cout << "\nCollect Evidence (root), clique "
		 << clique._iClique
		 << ", root = "
		 << int(clique._bRoot)
		 << ", prob norm = "
		 << _probNorm;
#endif
	return true;
}

bool GOBJMBN_CLIQSET :: BDistributeEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( ! bDownwards || ! clique.BRoot() )
		return true;

#ifdef DUMPCLIQUESET
	cout << "\nDistribute Evidence (root), clique "
		 << clique._iClique
		 << ", root = "
		 << int(clique._bRoot);
#endif

	return true;
}

bool GOBJMBN_CLIQSET :: BCollectEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	GOBJMBN_CLIQUE * pCliqueChild = sepset.PclqChild();
	GOBJMBN_CLIQUE * pCliqueParent = sepset.PclqParent();

	if ( bDownwards )
		return true;

#ifdef DUMPCLIQUESET

	cout << "\nCollect Evidence (sepset), clique "
		 << pCliqueChild->_iClique
		 << ", root = "
		 << int(pCliqueChild->_bRoot)
		 << ", parent = "
		 << pCliqueParent->_iClique
		 ;
	cout.flush();
#endif

	if ( ! pCliqueChild->BCollect() )
		return true;
	pCliqueParent->SetCollect();

	sepset.UpdateParentClique();
	
	SetCollect( false );
	return true;
}

bool GOBJMBN_CLIQSET :: BDistributeEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

#ifdef DUMPCLIQUESET
	GOBJMBN_CLIQUE * pCliqueChild = sepset.PclqChild();
	GOBJMBN_CLIQUE * pCliqueParent = sepset.PclqParent();

	cout << "\nDistribute Evidence (sepset), clique "
		 << pCliqueParent->_iClique
		 << ", root = "
		 << int(pCliqueParent->_bRoot)
		 << ", child = "
		 << pCliqueChild->_iClique
		 ;
	cout.flush();
#endif

	sepset.UpdateChildClique();

	return true;
}

bool GOBJMBN_CLIQSET :: BCollectInitEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( bDownwards )
		return true;

#ifdef DUMPCLIQUESET
	GOBJMBN_CLIQUE * pCliqueChild = sepset.PclqChild();
	GOBJMBN_CLIQUE * pCliqueParent = sepset.PclqParent();

	cout << "\nCollect Initial Evidence (sepset), clique "
		 << pCliqueChild->_iClique
		 << ", root = "
		 << int(pCliqueChild->_bRoot)
		 << ", parent = "
		 << pCliqueParent->_iClique
		 ;
	cout.flush();
#endif

	sepset.BalanceCliquesCollect();

	return true;
}

bool GOBJMBN_CLIQSET :: BDistributeInitEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

#ifdef DUMPCLIQUESET
	GOBJMBN_CLIQUE * pCliqueParent = sepset.PclqParent();
	GOBJMBN_CLIQUE * pCliqueChild = sepset.PclqChild();

	cout << "\nDistribute Initial Evidence (sepset), clique "
		 << pCliqueParent->_iClique
		 << ", root = "
		 << int(pCliqueParent->_bRoot)
		 << ", child = "
		 << pCliqueChild->_iClique
		 ;
	cout.flush();
#endif

	sepset.BalanceCliquesDistribute();
	return true;
}

bool GOBJMBN_CLIQSET :: BCollectInitEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( bDownwards || ! clique.BRoot() )
		return true;

#ifdef DUMPCLIQUESET
	cout << "\nCollect Initial Evidence at root, clique "
		 << clique._iClique
		 << ", root = "
		 << int(clique._bRoot);
#endif

	clique.Marginals().Normalize();
	return true;
}

bool GOBJMBN_CLIQSET :: BDistributeInitEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	return true;
}

void GOBJMBN_CLIQSET :: Dump ()
{
	WalkTree( true, BDumpClique, BDumpSepset );
	MARGSUBITER::Dump();
}

bool GOBJMBN_CLIQSET :: BDumpSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	sepset.Dump();
	return true;
}

bool GOBJMBN_CLIQSET :: BDumpClique ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	clique.Dump();
	return true;
}

// End of CLIQUE.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\cliqset.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       cliqset.h
//
//--------------------------------------------------------------------------

//
// cliqset.h:  Definitions for the clique set object.
//
#ifndef _CLIQSET_H_
#define _CLIQSET_H_

#include "gmobj.h"
#include "infer.h"

class GEDGEMBN_CLIQ;

//  Counters maintained in the inference engine
struct CLIQSETSTAT
{
	long _cReload;		// Number of times clique tree was reloaded
	long _cCollect;		// Number of collect operations
	long _cEnterEv;		// Number of calls to EnterEvidence
	long _cGetBel;		// Number of calls to GetBelief
	long _cProbNorm;	// Number of calls to ProbNorm

	CLIQSETSTAT () { Clear(); }
	void Clear ()
	{
		_cReload = 0;
		_cCollect = 0;
		_cEnterEv = 0;
		_cGetBel = 0;
		_cProbNorm = 0;
	}
};

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//
//	GOBJMBN_CLIQSET:
//
//		Since any model may decompose into a set of clique trees
//		(assemblages with no interconnections whatever), a CLIQSET
//		is defined as the join point or grouping for the clique
//		tree "forest".
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

class GOBJMBN_CLIQSET: public GOBJMBN_INFER_ENGINE
{
	friend class CLIQSETWORK;

  public:
	GOBJMBN_CLIQSET ( MBNET & model, 
					  REAL rMaxEstimatedSize = -1.0, 
					  int iInferEngID = 0 );

	virtual ~ GOBJMBN_CLIQSET ();
	
	virtual INT EType () const
		{ return EBNO_CLIQUE_SET; }

	virtual void Create ();
	virtual void Destroy ();
	virtual void Reload ();
	virtual void EnterEvidence ( GNODEMBN * pgnd, const CLAMP & clamp );
	virtual void GetEvidence ( GNODEMBN * pgnd, CLAMP & clamp );
	virtual void Infer ();
	virtual void GetBelief ( GNODEMBN * pgnd, MDVCPD & mdvBel );
	virtual PROB ProbNorm ();
	virtual void Dump ();

	//  Return true if the state of information is impossible
	bool BImpossible ();
		
	enum ESTATE							//  State of the junction tree
	{
		CTOR,							//  Just constructed
		UNDIR,							//  Undirected graph created
		MORAL,							//  Moralized
		CLIQUED,						//  Cliques constructed
		BUILT,							//  Fully constructed
		CONSISTENT,						//  Fully propagated
		EVIDENCE						//  Unpropagated evidence present
	};

	ESTATE EState () const				{ return _eState;		}
	MBNET & Model ()					{ return _model;		}
	INT IInferEngID () const			{ return _iInferEngID;	}

	//  Force reloading of the clique tree and full inference
	void SetReset ( bool bReset = true )
		{ _bReset = bReset ; }
	//  Force full collect/distribute cycle
	void SetCollect ( bool bCollect = true )
		{ _bCollect = bCollect; }

	//  Provide access to inference statistics
	CLIQSETSTAT & CqsetStat ()			{ return _cqsetStat;	}

  protected:	
	ESTATE _eState;						//  State of junction tree

	// Tallies
	int _cCliques;						//  Number of cliques
	int _cCliqueMemberArcs;				//  Number of clique member arcs
	int _cSepsetArcs;					//  Number of sepsest (arcs)
	int _cUndirArcs;					//  Undirected arcs in moral graph

	//  Inference control
	bool _bCollect;						//  Is "collect/distribute" pass necessary?
	bool _bReset;						//  Does tree need resetting?
	REAL _probNorm;						//  Residual prob of tree

	CLIQSETSTAT _cqsetStat;				//  Statistics

  protected:
	bool BCollect() const
		{ return _bCollect; }

	//  Cliquing helper functions
	int CNeighborUnlinked ( GNODEMBN * pgndmbn, bool bLinkNeighbors = false );
	void Eliminate ( GNODEMBN * pgndmbn, CLIQSETWORK & clqsetWork ) ;
	void GenerateCliques ( CLIQSETWORK & clqsetWork );
	void CreateUndirectedGraph( bool bMarryParents = true );
	void DestroyDirectedGraph ();

	//  Inference and tree maintenance
	void Reset ();
	void CollectEvidence ();
	void DistributeEvidence ();	

	//  Create (but don't init/load) all the clique and sepset marginals
	void CreateMarginals();
	//  Load probabilities into cliques; initialize all the sepsets
	void LoadMarginals ();

	//  Return the "family" or "self" clique for a node
	GOBJMBN_CLIQUE * PCliqueFromNode ( GNODEMBN * pgnd,
									   bool bFamily,
									   GEDGEMBN_CLIQ * * ppgedgeClique = NULL );

	// Typedefs for pointer-to-member-functions; used by Walk(). If bDownwards,
	//   then object is being enumerated on the way down the tree.
	typedef bool (GOBJMBN_CLIQSET::*PFNC_JTREE) ( GOBJMBN_CLIQUE & clique,
												  bool bDownwards /*= true*/ );
	typedef bool (GOBJMBN_CLIQSET::*PFNC_SEPSET) ( GEDGEMBN_SEPSET & sepset,
												  bool bDownwards /*= true*/ );

	//  Apply the given member function(s) to all cliques and/or sepsets,
	//	  depth first.
	int WalkTree ( bool bDepthFirst,
				   PFNC_JTREE pfJtree = NULL,
				   PFNC_SEPSET pfSepset = NULL );

	//  Apply the given member function to cliques and sepsets, depth first
	int WalkDepthFirst ( GOBJMBN_CLIQUE * pClique,
						 PFNC_JTREE pfJtree = NULL,
						 PFNC_SEPSET pfSepset = NULL );
	int WalkBreadthFirst ( GOBJMBN_CLIQUE * pClique,
						 PFNC_JTREE pfJtree = NULL,
						 PFNC_SEPSET pfSepset = NULL );

	//  Add an undirected arc iff there isn't one already.
	bool BAddUndirArc ( GNODEMBN * pgndbnSource, GNODEMBN * pgndbnSink );

	//  Clique and sepset helper functions used during WalkTree().
	bool BCreateClique	( GOBJMBN_CLIQUE & clique,  bool bDownwards );
	bool BLoadClique	( GOBJMBN_CLIQUE & clique,  bool bDownwards );
	bool BCreateSepset	( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BLoadSepset	( GEDGEMBN_SEPSET & sepset, bool bDownwards );

	bool BCollectEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BDistributeEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BCollectEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards );
	bool BDistributeEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards );

	bool BCollectInitEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BDistributeInitEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BCollectInitEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards );
	bool BDistributeInitEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards );

	//   Perform initial inference collect/distribute cycle
	void InferInit ();	
	void CollectEvidenceInit ();
	void DistributeEvidenceInit ();	

	bool BDumpSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BDumpClique ( GOBJMBN_CLIQUE & clique, bool bDownwards );
	void CheckConsistency ();
	bool BConsistentSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );

private:
	void Clear ();
};

#endif // _CLIQSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\clique.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       clique.h
//
//--------------------------------------------------------------------------

//
//	clique.h: junction tree and cliquing classes
//	
#ifndef _CLIQUE_H_
#define _CLIQUE_H_

#include "gmobj.h"
#include "marginals.h"
#include "margiter.h"

class GEDGEMBN_U;
class GEDGEMBN_CLIQ;
class GEDGEMBN_SEPSET;
class GOBJMBN_CLIQUE;
class GNODENUM_UNDIR;
class GOBJMBN_CLIQSET;


////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_CLIQUE:
//		A clique; that is, an ensemble of nodes identified by linkages via
//		GEDGEMBN_CLIQ edges to nodes in the dag and GEDGEMBN_SEPSET
//		edges to other cliques in its junction tree.
////////////////////////////////////////////////////////////////////
class GOBJMBN_CLIQUE : public GOBJMBN
{
	friend class GOBJMBN_CLIQSET;
	friend class CLIQSETWORK;
  public:
	virtual ~ GOBJMBN_CLIQUE ();

 	//  Return true if this is the root clique of its junction tree
	bool BRoot () const
		{ return _bRoot ; }

 protected:
	GOBJMBN_CLIQUE ( int iClique, int iInferEngID = 0 );

  public:
	// Return the immutable object type
	virtual INT EType () const
		{ return EBNO_CLIQUE; }

	bool BCollect() const
		{ return _bCollect; }
	void SetCollect ( bool bCollect = true )
		{ _bCollect = bCollect; }

	INT & IInferEngID ()
		{ return _iInferEngID; }
	INT & IClique ()
		{ return _iClique; }

	void GetMembers ( VPGNODEMBN & vpgnode );
	void InitFromMembers ();
	void GetBelief ( GNODEMBN * pgnd, MDVCPD & mdvBel );
	const MARGINALS & Marginals () const	
		{ return _marg; }
	MARGINALS & Marginals ()
		{ return _marg; }

	void CreateMarginals ();
	void InitMarginals ();
	void LoadMarginals ();
	bool VerifyMarginals ();

	void Dump();

  protected:
	//  Identity
	int _iClique;						//  Clique index
	int _iInferEngID;					//  Junction tree identifier (unused)
	bool _bRoot;						//  Is this a root clique?
	bool _bCollect;						//  Is "collect/distribute" pass necessary?

	MARGINALS _marg;					//  The clique marginals
};

////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_CLIQSET:
//		An edge between the clique set object and a root clique
////////////////////////////////////////////////////////////////////
class GEDGEMBN_CLIQSET : public GEDGEMBN
{
  public:
	GEDGEMBN_CLIQSET ( GOBJMBN_CLIQSET * pgobjSource,
					   GOBJMBN_CLIQUE * pgobjSink )
		: GEDGEMBN( pgobjSource, pgobjSink )
		{}

	GOBJMBN_CLIQSET * PclqsetSource ()		
		{ return (GOBJMBN_CLIQSET *) GEDGE::PnodeSource();	}

	GOBJMBN_CLIQUE * PclqChild ()			
		{ return (GOBJMBN_CLIQUE *)  GEDGE::PnodeSink();	}

	virtual INT EType () const
		{ return ETCLIQSET ; }
};


////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_CLIQ:
//		An edge between a clique and its member nodes
////////////////////////////////////////////////////////////////////
class GEDGEMBN_CLIQ : public GEDGEMBN
{
  public:
	//  What role does this clique play for this node?
	enum FCQLROLE
	{	//  These are bit flags, not integer values
		NONE   = 0,			//  Just clique membership
		FAMILY = 1,			//  Link from "family" clique; i.e., smallest
							//      clique containing node and its family
		SELF   = 2			//	Link from "self" clique;
							//		i.e., the highest clique in the tree
							//		which mentions the sink node
	};

	GEDGEMBN_CLIQ ( GOBJMBN_CLIQUE * pgnSource,
				    GNODEMBN * pgndSink,
				    int iFcqlRole );

	virtual ~ GEDGEMBN_CLIQ();

	virtual INT EType () const
		{ return ETCLIQUE ; }
	
	int IFcqlRole () const
		{ return _iFcqlRole; }

	GOBJMBN_CLIQUE * PclqParent ();
	GNODEMBN * PgndSink ();

	//  Return true if this links node to its parent clique
	bool BFamily () const
		{	return _iFcqlRole & FAMILY; }
	//  Return true if this is the highest clique in the jtree in which
	//		this node appears.
	bool BSelf () const
		{	return _iFcqlRole & SELF; }

	//  Return the ordering index of the sink node at the time of cliquing
	int IMark () const
		{	return _iMark; }

	//  Return the family reordering table
	const VIMD & VimdFamilyReorder () const
	{
		assert( IFcqlRole() & (FAMILY | SELF) );
		return _vimdFamilyReorder;
	}

	void Build ();

	bool BBuilt () const
		{ return _bBuilt; }
	CLAMP & Clamp ()
		{ return _clamp ; }

	void LoadCliqueFromNode ();

	//  Return the iterator for full marginalization of the node ("family")
	MARGSUBITER & MiterNodeBelief ()
	{
		assert( BFamily() );
		return _miterBelief;
	}
	//  Return the iterator for loading the node's CPD into the clique ("family")
	MARGSUBITER & MiterLoadClique ()
	{	
		assert( BFamily() );
		return _miterLoad;
	}
	//  Return the (reordered) marginals for the node ("family")
	MARGINALS & MargCpd ()
	{
		assert( BFamily() );
		return _margCpd;
	}

  protected:
	int _iFcqlRole;			//  Role of this clique for the node
	int _iMark;				//	Node number in original clique-time ordering
	bool _bBuilt;			//  Constructed?

	//  This array is only filled for SELF and FAMILY edges.  It is the same
	//	size as the node's family, and contains, in CLIQUE ordering, the index
	//  of each member of the nodes family.  Note that the sink node has the
	//	highest index in its family set.
	VIMD _vimdFamilyReorder;

	//  The following variables are only used in "self" or "family" edges
	CLAMP _clamp;				//  Node evidence (used in "self")
	MARGINALS _margCpd;			//  Reordered marginals for node (used in "family")
	MARGSUBITER _miterBelief;	//  Marginals iterator for generating UPD (used in "family")
	MARGSUBITER _miterLoad;		//  Marginals iterator for loading CPD into clique (used in "family")

  protected:
	static void ReorderFamily ( GNODEMBN * pgnd, VIMD & vimd );
};


////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_SEPSET:
//		An edge in the junction tree between cliques; i.e., a "sepset".
//		These are directed edges that point from parent clique to child.
////////////////////////////////////////////////////////////////////
class GEDGEMBN_SEPSET : public GEDGEMBN
{
  public:
	GEDGEMBN_SEPSET ( GOBJMBN_CLIQUE * pgnSource,
					 GOBJMBN_CLIQUE * pgnSink);
	virtual ~ GEDGEMBN_SEPSET();
	virtual INT EType () const
		{ return ETJTREE; }

	void GetMembers ( VPGNODEMBN & vpgnode );

	GOBJMBN_CLIQUE * PclqParent();
	GOBJMBN_CLIQUE * PclqChild();

	const MARGINALS & Marginals () const	
		{ return *_pmargOld; }
	MARGINALS & Marginals ()
		{ return *_pmargOld; }

	const MARGINALS & MarginalsOld () const	
		{ return *_pmargOld; }
	MARGINALS & MarginalsOld ()
		{ return *_pmargOld; }

	const MARGINALS & MarginalsMew () const	
		{ return *_pmargNew; }
	MARGINALS & MarginalsNew ()
		{ return *_pmargNew; }

	void ExchangeMarginals ();
	void CreateMarginals ();
	void InitMarginals ();
	void LoadMarginals ();
	bool VerifyMarginals ();
	void UpdateParentClique ();
	void UpdateChildClique ();
	bool BConsistent ();
	void BalanceCliquesCollect ();
	void BalanceCliquesDistribute ();

	void Dump();

  protected:
	MARGINALS * _pmargOld;
	MARGINALS * _pmargNew;

  protected:
	void UpdateRatios();
	void AbsorbClique ( bool bFromParentToChild );

	MARGSUBITER	_miterParent;	//  Iterator between sepset and parent
	MARGSUBITER _miterChild;	//  Iterator between sepset and child
};

DEFINEVP(GEDGEMBN_SEPSET);

//  Node enumeration subclass for undirected arcs.
class GNODENUM_UNDIR : public GNODENUM<GNODEMBN>
{
  public:
	GNODENUM_UNDIR ()
		: GNODENUM<GNODEMBN>(true,true,true)
	{
		SetETypeFollow( GEDGEMBN::ETUNDIR );
	}
	GNODENUM_UNDIR & operator = ( GNODEMBN * pgnd )
	{ 		
		Set( pgnd );
		return *this;
	}
};

#endif   // _CLIQUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\cliqwork.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       cliqwork.h
//
//--------------------------------------------------------------------------

//
//	cliqwork.h: Helper structures and templates for junction tree formation
//
#ifndef _CLIQWORK_H_
#define _CLIQWORK_H_

#include "algos.h"		// Include the <algorithms> and additions

class NDCQINFO
{
  public:
	GNODEMBN * _pgnd;			//  Node pointer
	int _iCliqOrdSelf;			//	Index of ordered clique containing self
	int _iCliqOrdFamily;		//  Index of family clique (self & parents)

	NDCQINFO ()
		: _pgnd(NULL),
		_iCliqOrdSelf(-1),
		_iCliqOrdFamily(-1)
		{}
	DECLARE_ORDERING_OPERATORS(NDCQINFO);
};

inline bool NDCQINFO :: operator < ( const NDCQINFO & ndcq ) const
{
	assert( _pgnd && ndcq._pgnd );
	return _pgnd->ITopLevel() < ndcq._pgnd->ITopLevel() ;	
}

DEFINEV(NDCQINFO);
DEFINEVP(GOBJMBN_CLIQUE);

//  Helper structure for cliquing
class CLIQSETWORK 
{		
  public:
	CLIQSETWORK ( GOBJMBN_CLIQSET & cliqset )
		: _cliqset(cliqset),
		_iElimIndex(-1),
		_cTrees(0)
		{}

	void PrepareForBuild ();
	void RenumberNodesForCliquing ();
	int CNodesCommon ( int iClique1, int iClique2 );
	int CNodesCommon ( const VPGNODEMBN & vpgnd1,  const VPGNODEMBN & vpgnd2 );
	void SetCNodeMaxCommon ( int iClique1, int iCliqueOrdered2 );
	bool BUpdateCNodeMaxCommon ( int iClique );
	bool BBetter ( int iClique1, int iClique2 );
	void BuildCliques ();
	void SetTopologicalInfo ();
	void CreateTopology ();

	//  Return the ordered index of a clique or -1 if not in the tree yet.
	int IOrdered ( int iClique );
	bool BCheckRIP ();
	bool BCheckRIP ( int iCliqueOrdered );
	void TopSortNodeCliqueInfo ();
	static void MarkSortNodePtrArray ( VPGNODEMBN & vpgnd );

	MBNET & Model ()
		{ return _cliqset.Model(); }

	REAL REstimatedSize ();

	void DumpCliques ();
	void DumpClique ( int iClique );
	void DumpTree ();
	void DumpTopInfo ();

  public:
	GOBJMBN_CLIQSET & _cliqset;

	//  Vector of nodes pointers in total ordering
	VNDCQINFO _vndcqInfo;

	//  Vector of vectors of node pointers (clique members)
	VVPGNODEMBN _vvpgnd;

	//  Clique ordering; 
	//		< 0					==> subsumed into another clique;
	//		0 <= i < INT_MAX	==> ordering into _viOrdered;
	//		== INT_MAX			==> deleted or merged
	VINT _viOrder;

	//	Parent clique indicies by clique index
	VINT _viParent;
	
	//  Clique indicies as they are ordered
	VINT _viOrdered;

	//  Number of nodes in common with most common clique;
	//		indexed by absolute clique index.
	VINT _viCNodesCommon;

	//  Contains ordered clique index of most common clique;
	//		indexed by absolute clique index.
	VINT _viICliqCommon;

	//  Ordered parent index of each ordered clique
	VINT _viParentOrdered;
	//  Topological level of each ordered clique
	VINT _viTopLevelOrdered;  

	//	Array of pointers to cliques created
	VPGOBJMBN_CLIQUE _vpclq;

	//  Elimination index
	int _iElimIndex;

	//  Number of trees created
	int _cTrees;
};

#endif
// End Of JTREEWORK.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\domain.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       domain.h
//
//--------------------------------------------------------------------------

//
//	domain.h:  domain declarations
//

#ifndef _DOMAIN_H_
#define _DOMAIN_H_

#include "symtmbn.h"
#include <list>

////////////////////////////////////////////////////////////////////
//	Declarations for common state or range sets.
//	For continuous variables, RANGEDEFs can be open or closed.
//	For discrete variables, RANGEDEFs must have lbound and ubound
//	(i.e., be closed) and the must be the same integer value.
////////////////////////////////////////////////////////////////////

//  Boundary of a domain
struct RANGELIM : pair<bool,REAL>
{
    RANGELIM( bool b = false, REAL r = 0.0 )
		: pair<bool,REAL>(b,r)
		{}

	DECLARE_ORDERING_OPERATORS(RANGELIM);
};

class RANGEDEF
{
  public:
	RANGEDEF ( bool bLower = false, 
			 REAL rLower = 0.0, 
			 bool bUpper = false, 
			 REAL rUpper = 0.0 )
	{
		_rlimLower.first = bLower;
		_rlimLower.second = rLower;
		_rlimUpper.first = bUpper;
		_rlimUpper.second = rUpper;
	}
	RANGEDEF ( const RANGELIM & rlimLower, 
			   const RANGELIM & rlimUpper,
			   ZSREF zsrName )
		: _rlimLower(rlimLower),
		_rlimUpper(rlimUpper),
		_zsrName(zsrName)
		{}
	bool BLbound () const
		{ return _rlimLower.first; }
	REAL RLbound () const
		{ return _rlimLower.second; }
	bool BUbound () const
		{ return _rlimUpper.first; }
	REAL RUbound () const
		{ return _rlimUpper.second; }
	ZSREF ZsrName () const
		{ return _zsrName; }
	void SetName ( ZSREF zsrName )
		{ _zsrName = zsrName; } 
	const RANGELIM & RlimLower () const
		{ return _rlimLower; }
	const RANGELIM & RlimUpper () const
		{ return _rlimUpper; }
	bool BValid () const;
	bool BOverlap ( const RANGEDEF & rdef ) const;
	bool BDiscrete () const
	{
		return BLbound()
			&& BUbound()
			&& int(RLbound()) == int(RUbound());
	}
	int IDiscrete () const
	{
		assert( BDiscrete() );
		return int(RLbound());
	}
	DECLARE_ORDERING_OPERATORS(RANGEDEF);

  protected:
	ZSREF _zsrName;
	RANGELIM _rlimLower;
	RANGELIM _rlimUpper;
};

//  A RDOMAIN is a sorted list of RANGELIMs
class RDOMAIN : public list<RANGEDEF> 
{
  public:
	//  Convert a numeric value to a state name
	SZC SzcState ( REAL rValue ) const;
	bool BOverlap () const;
};

////////////////////////////////////////////////////////////////////
//	GOBJMBN_DOMAIN:  Belief network object representing
//		a named, sharable mapping of names to scalar ranges.
////////////////////////////////////////////////////////////////////
class GOBJMBN_DOMAIN : public GOBJMBN
{
  public:
	GOBJMBN_DOMAIN ( RDOMAIN * pdomain = NULL)
	{
		if ( pdomain )
			_domain = *pdomain;
	}
	~ GOBJMBN_DOMAIN() {}

	virtual INT EType () const
		{ return EBNO_VARIABLE_DOMAIN ; }

	virtual GOBJMBN * CloneNew ( MODEL & modelSelf,
								 MODEL & modelNew,
								 GOBJMBN * pgobjNew = NULL );
	RDOMAIN & Domain ()
		{ return _domain; }
	const RDOMAIN & Domain () const
		{ return _domain; } 

  protected:
	//  Vector of RANGEDEFs
	RDOMAIN _domain;	
};

#endif  // _DOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\dyncast.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       dyncast.h
//
//--------------------------------------------------------------------------

//
//	dyncast.h: Handle dynamic and static casting
//
#ifndef _DYNCAST_H_
#define _DYNCAST_H_


//  Macro to perform const_cast; i.e., cast away "const-ness" without
//	changing base type.
#define CONST_CAST(type,arg)  const_cast<type>(arg)

//
//	Function templates for generating error-detecting dynamic casts.
//	The compiler will generate the needed version of this based upon the types 
//	provided.  'DynCastThrow' should be used when you're certain of the 
//	type of an object.  'PdynCast" should be used when you intend to check
//	whether the conversion was successful (result != NULL).
//	If 'USE_STATIC_CAST' is defined, static casting is done in DynCastThrow().
//
//#define USE_STATIC_CAST	// Uncomment to force static casting
//#define TIME_DYN_CASTS	// Uncomment to generate timing information

template <class BASE, class SUB>
void DynCastThrow ( BASE * pbase, SUB * & psub )
{
#ifdef TIME_DYN_CASTS
	extern int g_cDynCasts;
	g_cDynCasts++;
#endif
#if defined(USE_STATIC_CAST) && !defined(_DEBUG) 
	psub = (SUB *) pbase;
#else
	psub = dynamic_cast<SUB *>(pbase);	
	ASSERT_THROW( psub, EC_DYN_CAST,"subclass pointer conversion failure");
#endif
}

template <class BASE, class SUB>
SUB * PdynCast ( BASE * pbase, SUB * psub )
{
	return dynamic_cast<SUB *>(pbase);	
}


#endif	// _DYNCAST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\domain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       domain.cpp
//
//--------------------------------------------------------------------------

//
//	domain.cpp
//	

#include <basetsd.h>
#include "domain.h"

bool RANGELIM :: operator < ( const RANGELIM & rlim ) const
{
	if ( first ^ rlim.first )
	{
		//  One has a bound and the other doesn't.
		//  If we do not have an bound and other does, we are "less"
		return true;
	}
	//  Both either have or don't have bounds.  Therefore,
	//	we're "less" iff both have bounds and ours is less
	//  than the other's.
	return first && second < rlim.second;
}

bool RANGELIM :: operator > ( const RANGELIM & rlim ) const
{
	if ( first ^ rlim.first )
	{
		//  One has a bound and the other doesn't.
		//  If we have a bound and the other doesn't, it is "greater"
		return true;
	}
	//  Both either have or don't have bounds.  Therefore,
	//	we're "greater" iff both have bounds and ours is greater
	//  than the other's.
	return first && second > rlim.second;
}

bool RANGELIM :: operator == ( const RANGELIM & rlim ) const
{
	return first == rlim.first
		 && ( !first || (second == rlim.second) );
}

//  Order two RANGEDEFs according to their lower bounds.
bool RANGEDEF :: operator < ( const RANGEDEF & rdef ) const
{	
	if ( self == rdef )
		return false;

	//  If the other doesn't have a lower bound, we're geq
	if ( ! rdef.BLbound() )
		return false;
	//  If we don't have an upper bound, we're gtr
	if ( ! BUbound() )
		return false;

	// The other has a lower bound and we have an upper bound;
	//		start by checking them.
	bool bResult = RUbound() <= rdef.RLbound();
	if ( BLbound() )
	{
		// Both have lower bounds; self must be < other
		bResult &= (RLbound() <= rdef.RLbound());
	}
	
	if ( rdef.BUbound() )
	{
		// Both have upper bounds; self must be < other
		bResult &= (RUbound() <= rdef.RUbound());
	}
	return bResult;
}

bool RANGEDEF :: operator == ( const RANGEDEF & rdef ) const
{
	return RlimLower() == rdef.RlimLower()
		&& RlimUpper() == rdef.RlimUpper();
}

bool RANGEDEF :: operator > ( const RANGEDEF & rdef ) const
{	
	return !(self < rdef);
}

bool RANGEDEF :: BValid () const
{
	return RlimLower() < RlimUpper()
		|| RlimLower() == RlimUpper();
}

bool RANGEDEF :: BOverlap ( const RANGEDEF & rdef ) const
{
	if ( self == rdef )
		return true;
	bool bLess = self < rdef;
	if ( bLess )
		return RlimUpper() > rdef.RlimLower();
	return rdef.RlimUpper() > RlimLower();
}

SZC RDOMAIN :: SzcState ( REAL rValue ) const
{
	RANGELIM rlim(true,rValue);

	for ( const_iterator itdm = begin();
		  itdm != end();
		  itdm++ )
	{
		const RANGEDEF & rdef = (*itdm);
		SZC szcState = rdef.ZsrName();
		if ( rdef.RlimLower() == rlim )
			return szcState;
		if ( rdef.RlimUpper() < rlim )
			break;
		if (   rdef.RlimLower() < rlim )
			return szcState;		
	}
	return NULL;
}

//  Return true if any of the RANGEDEFs overlap
bool RDOMAIN :: BOverlap () const
{
	for ( const_iterator itdm = begin();
		  itdm != end();
		  itdm++ )
	{
		const_iterator itdmNext = itdm;
		itdmNext++;
		if ( itdmNext == end() )
			continue;

		//  Check sequence of the list
		assert( *itdm < *itdmNext );
		//  If ubounds collide, it's an overlap
		if ( *itdm > *itdmNext )
			return true;
	}
	return false;
}

GOBJMBN * GOBJMBN_DOMAIN :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjNew )
{
	GOBJMBN_DOMAIN * pgdom = NULL;
	if ( pgobjNew == NULL )
	{
		pgdom = new GOBJMBN_DOMAIN;
	}
	else
	{
		DynCastThrow( pgobjNew, pgdom );
	}
	ASSERT_THROW( GOBJMBN::CloneNew( modelSelf, modelNew, pgdom ),
				  EC_INTERNAL_ERROR,
				  "cloning failed to returned object pointer" );
	
	pgdom->_domain = _domain;

	return pgdom;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\cliqwork.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       cliqwork.cpp
//
//--------------------------------------------------------------------------

//
//	cliqwork.cpp
//

#include <basetsd.h>
#include "cliqset.h"
#include "clique.h"
#include "cliqwork.h"

#ifdef _DEBUG
//	#define DUMP
#endif

//  Sort helper 'less' function for sorting arrays of node pointers into 'mark' sequence.
class MARKSRTPGND : public binary_function<const GNODEMBN *, const GNODEMBN *, bool>
{	
  public:
	bool operator () (const GNODEMBN * pa, const GNODEMBN * pb) const
		{	return pa->IMark() < pb->IMark() ;	}
};

#ifdef _DEBUG
static void seqchkVpnodeByMark (const VPGNODEMBN & vpgnd)
{
	int imrk = INT_MIN;
	int imrk2;
	for ( int i = 0; i < vpgnd.size(); i++, imrk = imrk2)
	{
		imrk2 = vpgnd[i]->IMark();
		assert( imrk2 >= 0 );
		assert( imrk2 >= imrk );
	}
}
#endif

//  Sort the clique information array into topological sequence
void CLIQSETWORK :: TopSortNodeCliqueInfo ()
{
	sort( _vndcqInfo.begin(), _vndcqInfo.end() );
}

//  Sort the given node pointer array in to "mark" (cliquing order) sequence
void CLIQSETWORK :: MarkSortNodePtrArray ( VPGNODEMBN & vpgnd )
{
	MARKSRTPGND marksorter;
	sort( vpgnd.begin(), vpgnd.end(), marksorter );

#ifdef _DEBUG
	seqchkVpnodeByMark( vpgnd );
#endif
}

//  Establish an absolute ordering based upon the topological ordering
void  CLIQSETWORK :: RenumberNodesForCliquing ()
{
	//  Perform a topological sort of the network
	Model().TopSortNodes();

	MODEL::MODELENUM mdlenum( Model() );
	GELEMLNK * pgelm;
	_vndcqInfo.clear();

	//  Collect all the nodes into a pointer array
	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		if ( pgelm->EType() != GOBJMBN::EBNO_NODE )
			continue;
			
		NDCQINFO ndcq;
		DynCastThrow( pgelm, ndcq._pgnd );

		_vndcqInfo.push_back( ndcq );
	}
	//  Sort the array into topological sequence.
	TopSortNodeCliqueInfo();

#ifdef _DEBUG
	int iTop = -1;
#endif

	//  Establish the total ordering based upon topological level.
	for ( int i = 0; i < _vndcqInfo.size() ; i++ )
	{
		GNODEMBN * pgnd = _vndcqInfo[i]._pgnd;
		assert( pgnd );
#ifdef _DEBUG
		//  Check sequence.
		assert( iTop <= pgnd->ITopLevel() );
		iTop = pgnd->ITopLevel();
#endif
		pgnd->IMark() = i;
	}
}

void CLIQSETWORK :: PrepareForBuild ()
{
	//  Resize and initialize the work arrays
	int cCliques = _vvpgnd.size();

	_viParent.resize( cCliques );
	_viOrder.resize( cCliques );
	_viCNodesCommon.resize( cCliques );
	_viICliqCommon.resize( cCliques );
	_viOrdered.clear();

	for ( int iClique = 0; iClique < cCliques; iClique++ )
	{
		MarkSortNodePtrArray( _vvpgnd[iClique] );

		_viParent[iClique]			= INT_MIN;
		_viOrder[iClique]			= INT_MIN;
		_viCNodesCommon[iClique]	= INT_MIN;
		_viICliqCommon[iClique]		= INT_MIN;
	}
}

//	Return the number of nodes in common between the two cliques
int CLIQSETWORK :: CNodesCommon ( int iClique1, int iClique2 )
{
	assert( iClique1 < _vvpgnd.size() && iClique2 < _vvpgnd.size() );

	return CNodesCommon( _vvpgnd[iClique1], _vvpgnd[iClique2] );
}

//	Return the number of nodes in common between the two node lists
int CLIQSETWORK :: CNodesCommon ( const VPGNODEMBN & vpgnd1, const VPGNODEMBN & vpgnd2 )
{
	MARKSRTPGND marksorter;

#ifdef _DEBUG
	seqchkVpnodeByMark( vpgnd1 );
	seqchkVpnodeByMark( vpgnd2 );
#endif

	int cCommon = count_set_intersection( vpgnd1.begin(),
										   vpgnd1.end(),
										   vpgnd2.begin(),
										   vpgnd2.end(),
										   marksorter );
	return cCommon;
}


//  Return the ordered index of a clique or -1 if not in the tree yet.
inline
int CLIQSETWORK :: IOrdered ( int iClique )
{
	return ifind( _viOrdered, iClique );
}

//  Update the "most common clique" info of iClique1 based upon iClique2.  This is
//  used to count the number of nodes in common between a candidate clique and a
//	clique already in the tree.
void CLIQSETWORK :: SetCNodeMaxCommon ( int iClique1, int iCliqueOrdered2 )
{
	assert( iCliqueOrdered2 < _viOrdered.size() );

	int iClique2 = _viOrdered[iCliqueOrdered2];
	int cCommon = CNodesCommon( iClique1, iClique2 );
	if ( cCommon > _viCNodesCommon[iClique1] )
	{
		_viCNodesCommon[iClique1] = cCommon;
		_viICliqCommon[iClique1] = iCliqueOrdered2;
	}
}

//
//	Completely update the "most common clique" information for this clique.
//	This is necessary because cliques can change membership due to subsumption
//	during generation of the clique tree.
//	Return true if there is any overlap with a clique already in the tree.
//
bool CLIQSETWORK :: BUpdateCNodeMaxCommon ( int iClique )
{
	assert( _viOrder[iClique] == INT_MIN );
	int & cNodesCommon = _viCNodesCommon[iClique];
	int & iCliqCommon = _viICliqCommon[iClique];
	cNodesCommon = INT_MIN;
	iCliqCommon = INT_MIN;
	for ( int iord = 0; iord < _viOrdered.size(); iord++ )		
	{
		SetCNodeMaxCommon( iClique, iord );
	}
	return cNodesCommon > 0;
}

//  Return true if clique 1 has more nodes in common with a clique that is already in
//		the tree than clique2.  If they have the same number of nodes in common, return
//		true if clique 1 has fewer nodes than clique2.
bool CLIQSETWORK :: BBetter ( int iClique1, int iClique2 )
{
	assert( _viCNodesCommon[iClique1] >= 0 );
	assert( _viCNodesCommon[iClique2] >= 0 );

	if ( _viCNodesCommon[iClique1] != _viCNodesCommon[iClique2] )
		return _viCNodesCommon[iClique1] > _viCNodesCommon[iClique2];

	return _vvpgnd[iClique1].size() < _vvpgnd[iClique2].size();
}


//  After building the cliques, topologically sort them and anchor each node
//  to the highest clique in the tree to which it belongs.
void CLIQSETWORK :: SetTopologicalInfo ()
{
#ifdef DUMP
	DumpTree();
#endif

	//  First, set up the ordered parent information array
	int cCliqueOrdered = _viOrdered.size();
	assert( cCliqueOrdered > 0 );
	int cClique = _viOrder.size();

	_viParentOrdered.resize(cCliqueOrdered);
	for ( int icq = 0; icq < cCliqueOrdered; ++icq )
	{
		int iClique = _viOrdered[icq];
		assert( iClique < cClique && iClique >= 0 );
		int iCliqueParent = _viParent[iClique];
		assert( iCliqueParent < cClique && iCliqueParent >= 0 );
		assert( CNodesCommon( iClique, iCliqueParent ) > 0 );
		int iCliqueParentOrdered = IOrdered( iCliqueParent );
		assert( iCliqueParentOrdered < cCliqueOrdered && iCliqueParentOrdered >= 0 );
		_viParentOrdered[icq] = iCliqueParentOrdered;
	}

	//  Next, follow each ordered clique's parentage to compute its topological level
	_viTopLevelOrdered.resize(cCliqueOrdered);
	int cTrees = 0;
	for ( icq = 0; icq < cCliqueOrdered; ++icq )
	{
		int icqParent  = icq;
		//  Follow until we get to a (the) root clique
		for ( int itop = 0; icqParent != _viParentOrdered[icqParent]; ++itop )
		{
			assert( itop < cCliqueOrdered );
			icqParent = _viParentOrdered[icqParent];
		}
		if ( itop == 0 )
			cTrees++ ;
		_viTopLevelOrdered[icq] = itop;
	}
	assert( cTrees == _cTrees );

	//  Next, find each node's "family" clique.  This is the smallest clique containing
	//  it and its parents.

	VPGNODEMBN vpgnd;
	for ( int ind = 0 ; ind < _vndcqInfo.size(); ind++ )
	{
		NDCQINFO & ndcq = _vndcqInfo[ind];
		vpgnd.clear();
		//  Get the "family" set and sort it for matching other cliques.
		ndcq._pgnd->GetFamily( vpgnd );
		MarkSortNodePtrArray( vpgnd );

		int cFamily = vpgnd.size();
		int cCommonSize = INT_MAX;
		int iCqCommon = -1;

		//  Find the smallest clique containing the family
		for ( icq = 0; icq < cCliqueOrdered; ++icq )
		{
			const VPGNODEMBN & vpgndClique = _vvpgnd[ _viOrdered[icq] ];
			int cCqCommon = CNodesCommon( vpgnd, vpgndClique );
			//  See if this clique contains the family and is smaller than any other.
			if ( cCqCommon == cFamily && vpgndClique.size() < cCommonSize )
			{	
				iCqCommon = icq;
			}
		}
		assert( iCqCommon >= 0 );
		ndcq._iCliqOrdFamily = iCqCommon;
		
		//  Now, find the highest clique in the tree containing this node.
		int itop = INT_MAX;
		int iCqTop = -1;
		for ( icq = 0; icq < cCliqueOrdered; ++icq )
		{
			const VPGNODEMBN & vpgndClique = _vvpgnd[ _viOrdered[icq] ];
			int ind = ifind( vpgndClique, ndcq._pgnd );
			if ( ind >= 0 && _viTopLevelOrdered[icq] < itop )
			{	
				iCqTop = icq;
				itop = _viTopLevelOrdered[icq];
			}
		}
		assert( iCqTop >= 0 );
		ndcq._iCliqOrdSelf = iCqTop;
	}

#ifdef DUMP
	DumpTopInfo();
#endif
}

void CLIQSETWORK :: BuildCliques ()
{
	//  Prepare tables for junction tree construction
	PrepareForBuild() ;

	//  Choose the zeroth arbitrarily as a starting point; set it as its own parent.
	//  As we iterate over the array, we assign an ordering to cliques.  If the clique has
	//  already been ordered, its value in _viOrder will either >= 0 (order in clique tree)
	//	
	_cTrees = 1;

	_viParent[0] = 0;
	_viOrder[0] = 0;
	_viOrdered.clear();
	_viOrdered.push_back(0);

	for (;;)
	{
		int iCliqueBest = INT_MAX;			//  Best clique found so far

		// Find a new clique that has the largest overlap with any of the cliques already in the tree.
		for ( int iClique = 0; iClique < _vvpgnd.size(); iClique++ )
		{
			int iord = _viOrder[iClique];
			if ( iord != INT_MIN )
				continue;	// Clique has already been ordered or dealt with

			//  Update the "most common clique already in tree" info between this clique
			//		and all the cliques in the trees
			BUpdateCNodeMaxCommon( iClique );

			//MSRDEVBUG:  SetCNodeMaxCommon( iClique, _viOrdered.size() - 1 );

			if ( iCliqueBest == INT_MAX )
			{
				// first time through the loop
				iCliqueBest = iClique;
			}
			else
			if ( BBetter( iClique, iCliqueBest ) )
			{
				//  This clique has an overlap as large as any other yet found.
				iCliqueBest = iClique;
			}
		}
		//  See if we're done
		if ( iCliqueBest == INT_MAX )
			break;

		// Get the ordered index and absolute index of the most common clique
		int iCliqueCommonOrdered = _viICliqCommon[iCliqueBest];
		assert( iCliqueCommonOrdered >= 0 && iCliqueCommonOrdered < _viOrdered.size() );
		int iCliqueCommon = _viOrdered[ iCliqueCommonOrdered ];
		assert( iCliqueCommon >= 0 );
		assert( iCliqueBest != iCliqueCommon );
		int cNodesCommon = _viCNodesCommon[iCliqueBest];
		assert( cNodesCommon <= _vvpgnd[iCliqueCommon].size() );
		assert( cNodesCommon <= _vvpgnd[iCliqueBest].size() );
		assert( cNodesCommon == CNodesCommon( iCliqueCommon, iCliqueBest ) ) ;

		//  Index of clique to be added to ordered clique set
		int iCliqueNew = INT_MAX;

		//  If the candidate clique has the same number of nodes in common with its most
		//  common clique as that clique has members, then this clique is either identical
		//  to or a superset of that clique.

		if ( cNodesCommon == _vvpgnd[iCliqueCommon].size() )
		{
			//  New clique is superset of its most common clique.
			assert( cNodesCommon != 0 );
			assert( iCliqueCommon != iCliqueBest );
			assert( _vvpgnd[iCliqueCommon].size() < _vvpgnd[iCliqueBest].size() );

			//  Assign this clique's node set to the previously ordered subset clique
			_vvpgnd[iCliqueCommon] = _vvpgnd[iCliqueBest] ;
			assert ( _vvpgnd[iCliqueCommon].size() == _vvpgnd[iCliqueBest].size() );
			//  Leave the parent the same as it was
			iCliqueNew = iCliqueCommon;
		}
		else
		if ( cNodesCommon == 0 )
		{
			//  This is the start of a new tree
			_cTrees++;
			//  Self and parent are the same
			_viParent[iCliqueBest] = iCliqueNew = iCliqueBest;
			_viOrdered.push_back( iCliqueNew );
		}
		else
		if ( cNodesCommon != _vvpgnd[iCliqueBest].size() )
		{
			//  New clique is child of existing clique.
			iCliqueNew = iCliqueBest;
			_viParent[iCliqueBest] = iCliqueCommon ;
			//  Keep this clique by adding it to the ordered clique set.
			_viOrdered.push_back( iCliqueNew );
		}
		else
		{
			//  Child is subset of parent; ignore by marking as "subsumed"
			iCliqueNew = - iCliqueCommon;
		}

		//  Mark the clique as either ordered or subsumed.
		_viOrder[iCliqueBest] = iCliqueNew;
	}	

#ifdef DUMP
	cout << "\n\nBuild cliques;  generated " << _cTrees << " clique trees\n\n";
#endif
}

//  Verify that the Running Intersection Property holds for this clique tree.
bool CLIQSETWORK :: BCheckRIP ()
{
	// Check that topological information has been generated
	assert( _viOrdered.size() == _viParentOrdered.size() );

	for ( int iCliqueOrdered = 0; iCliqueOrdered < _viOrdered.size(); iCliqueOrdered++ )
	{
		if ( ! BCheckRIP( iCliqueOrdered ) )
			return false;
	}
	return true;
}

//  Verify that the Running Intersection Property holds for this clique.
bool CLIQSETWORK :: BCheckRIP ( int iCliqueOrdered )
{
	int iClique = _viOrdered[iCliqueOrdered];
	const VPGNODEMBN & vpgndClique = _vvpgnd[iClique];
	int iCliqueParent = _viParent[iClique];
	const VPGNODEMBN & vpgndCliqueParent = _vvpgnd[iCliqueParent];

	bool bRoot = iCliqueParent == iClique;

	// For every node in this clique, check that either:
	//
	//		1) this is a root clique, or
	//		2) the node is present in the parent clique.
	//
	// If this test fails, check that this is the "self" clique,
	//		which is the highest clique in the tree in which the
	//		node appears.
	//
	for ( int iNode = 0; iNode < vpgndClique.size(); iNode++ )
	{
		//  Access the node information for this node
		GNODEMBN * pgnd = vpgndClique[iNode];
		if ( bRoot || ifind( vpgndCliqueParent, pgnd ) < 0 )
		{
			NDCQINFO & ndcq = _vndcqInfo[ pgnd->IMark() ];
			if ( ndcq._iCliqOrdSelf != iCliqueOrdered )
			{			
#ifdef _DEBUG
				cout << "RIP FAILURE: node "
					 << ndcq._pgnd->ZsrefName().Szc()
					 << " is in clique "
					 << iCliqueOrdered
					 << " but absent from "
					 << _viParentOrdered[iCliqueOrdered]
					 << "("
					 << _viParent[iClique]
					 << ")"
					 ;
#endif
				return false;
			}
		}
	}
	return true;
}

//  Using the constructed tables, create the clique objects and
//  link them to each other and their member nodes.

void CLIQSETWORK :: CreateTopology ()
{
	_vpclq.resize( _viOrdered.size() ) ;
	for ( int i = 0; i < _vpclq.size(); )
		_vpclq[i++] = NULL;

	int iInferEngID = _cliqset._iInferEngID;

	int ccq = 0;	// Total cliques created

	//  Create all cliques.  Iterate in topological order, creating
	//		the cliques and linking them to their parents.
	for ( int itop = 0;; itop++)
	{
		int ccqLevel = 0;	// Number of cliques added at this topological level
		for ( int icq = 0; icq < _viOrdered.size(); icq++ )
		{
			if ( _viTopLevelOrdered[icq] != itop )
				continue;

			GOBJMBN_CLIQUE * pclqParent = NULL;
			GOBJMBN_CLIQUE * pclqThis = NULL;
			int iParentOrdered = _viParentOrdered[icq];
			if ( iParentOrdered != icq )
			{
				//  Get the parent clique pointer
				pclqParent = _vpclq[ iParentOrdered ];
				assert( pclqParent );
			}
			else
			{
				//  Root cliques have toplevel zero
				assert( itop == 0 );
			}
			//  Create the new clique and its edge to its parent clique (if any)
			pclqThis = _vpclq[icq] = new GOBJMBN_CLIQUE( icq, iInferEngID );
			Model().AddElem( pclqThis );
			if ( pclqParent )
			{
				//  This is not a root clique; link it to its parent.
				Model().AddElem( new GEDGEMBN_SEPSET( pclqParent, pclqThis ) );
			}
			else
			{
				//  This IS a root clique; mark it and link it to the clique set top.
				pclqThis->_bRoot = true;
				Model().AddElem( new GEDGEMBN_CLIQSET( & _cliqset, pclqThis ) );
			}

			++_cliqset._cCliques;

			if ( pclqParent )
			{
				++_cliqset._cSepsetArcs;
			}
			ccq++;
			ccqLevel++;
		}
		if ( ccqLevel == 0 )
			break; // No cliques added at this topological level: we're done
	}
	assert( ccq == _viOrdered.size() );

	//  For each of the new cliques, add all members
	for ( i = 0; i < _vpclq.size(); i++ )
	{
		const VPGNODEMBN & vpgndMembers = _vvpgnd[ _viOrdered[i] ];

		for ( int ind = 0; ind < vpgndMembers.size(); ind++)
		{
			//  Get the node pointer and the data pointer
			GNODEMBN * pgnd = vpgndMembers[ind];
			const NDCQINFO & ndcq = _vndcqInfo[ pgnd->IMark() ];
			assert( pgnd == ndcq._pgnd );
			int fRole = GEDGEMBN_CLIQ::NONE;
			if ( ndcq._iCliqOrdSelf == i )	
				fRole |= GEDGEMBN_CLIQ::SELF;
			if ( ndcq._iCliqOrdFamily == i )	
				fRole |= GEDGEMBN_CLIQ::FAMILY;

			Model().AddElem( new GEDGEMBN_CLIQ( _vpclq[i], pgnd, fRole ) );
			++_cliqset._cCliqueMemberArcs;
		}
	}

#ifdef _DEBUG
	for ( i = 0; i < _vpclq.size(); i++ )
	{
		const VPGNODEMBN & vpgndMembers = _vvpgnd[ _viOrdered[i] ];
		VPGNODEMBN vpgndMembers2;
		_vpclq[i]->GetMembers( vpgndMembers2 );
		assert( vpgndMembers2.size() == vpgndMembers.size() );
		MarkSortNodePtrArray( vpgndMembers2 );
		assert( vpgndMembers2 == vpgndMembers );

		//  Exercise the topology by locating the "self" and "family" cliques
		for ( int imbr = 0; imbr < vpgndMembers.size(); imbr++ )
		{
			GNODEMBN * pgnd = vpgndMembers[imbr];
			GOBJMBN_CLIQUE * pCliqueFamily = _cliqset.PCliqueFromNode( pgnd, false );
			GOBJMBN_CLIQUE * pCliqueSelf = _cliqset.PCliqueFromNode( pgnd, false );
			assert( pCliqueFamily );
			assert( pCliqueSelf );
		}
	}
#endif
}

void CLIQSETWORK :: DumpClique ( int iClique )
{
	cout << "\tClique "
		<< iClique
		<< ':'
		<< _vvpgnd[iClique]
		<< "\n";		
	cout.flush();
}

void CLIQSETWORK :: DumpCliques ()
{
	for ( int iClique = 0; iClique < _vvpgnd.size(); ++iClique )
	{
		DumpClique( iClique );
	}
}

void CLIQSETWORK :: DumpTree ()
{
	for ( int iCliqueOrd = 0; iCliqueOrd < _viOrdered.size(); ++iCliqueOrd )
	{
		int iClique = _viOrdered[iCliqueOrd];

		cout << "\tTree Clique "
			<< iCliqueOrd
			<< " ("
			<< iClique
			<< "), parent "
			<< IOrdered( _viParent[iClique] )
			<< " ("
			<< _viParent[iClique]
			<< "): "
			<< _vvpgnd[iClique]
			<< "\n";		
	}
	cout.flush();
}

void CLIQSETWORK :: DumpTopInfo()
{
	for ( int iCliqueOrd = 0; iCliqueOrd < _viOrdered.size(); ++iCliqueOrd )
	{
		cout << "\tTree Clique "
			 << iCliqueOrd
			 << " (" << _viOrdered[iCliqueOrd] << ")"
			 << ", parent is "
			 << _viParentOrdered[iCliqueOrd]
			 << " (" << _viOrdered[_viParentOrdered[iCliqueOrd]] << ")"
			 << ", top level is "
			 << _viTopLevelOrdered[iCliqueOrd]
			 << "\n";
	}

	for ( int ind = 0 ; ind < _vndcqInfo.size(); ind++ )
	{
		NDCQINFO & ndcq = _vndcqInfo[ind];
		cout << "\tNode ";
		cout.width( 20 );
		cout << ndcq._pgnd->ZsrefName().Szc()
			 << "\tfamily is clique "
			 << ndcq._iCliqOrdFamily
			 << ", self is clique "
			 << ndcq._iCliqOrdSelf
			 << "\n";
	}
	cout.flush();
}

//
//	Estimate the total size of the structures necessary to support the
//	compute clique trees.
//
REAL CLIQSETWORK :: REstimatedSize ()
{
	int cClique = 0;
	int cSepsetArc = 0;
	int cCliqsetArc = 0;
	size_t cMbrArc = 0;
	int cCliqueEntries = 0;
	int cFamEntries = 0;

	for ( int icq = 0; icq < _viOrdered.size(); icq++ )
	{
		cClique++;	
		if ( icq != _viParentOrdered[icq] )
		{
			// Clique has a parent
			cSepsetArc++;
		}
		else
		{	
			//  Clique is root
			cCliqsetArc++;
		}

		//  Account for clique membership arcs
		const VPGNODEMBN & vpgndMembers = _vvpgnd[ _viOrdered[icq] ];
		int cMbr = vpgndMembers.size();
		cMbrArc += vpgndMembers.size();

		//  Compute the size of the joint table for this clique
		VIMD vimd(cMbr);
		GNODEMBND * pgndd;
		for ( int ind = 0; ind < vpgndMembers.size(); ind++)
		{
			//  Get the discrete node pointer and the data pointer
			DynCastThrow( vpgndMembers[ind], pgndd );
			//  Add to the clique's dimensionality
			vimd[ind] = pgndd->CState();

			const NDCQINFO & ndcq = _vndcqInfo[ pgndd->IMark() ];
			assert( pgndd == ndcq._pgnd );

			//  If this is the edge to the "family" clique, it will
			//	contain the reordered discrete conditional probabilities
			//	for this node, so we must compute it size.
			if ( ndcq._iCliqOrdFamily == icq )	
			{
				//  This is the edge leading to this node's "family" clique
				VPGNODEMBN vpgndFamily;  // List of parents and self
				pgndd->GetParents( vpgndFamily, true );
				GNODEMBND * pgnddFamily;
				int cStates = 1;
				for ( int ifam = 0; ifam < vpgndFamily.size(); ifam++ )
				{
					DynCastThrow( vpgndFamily[ifam], pgnddFamily );
					cStates *= pgnddFamily->CState();
				}
				cFamEntries += cStates;
			}
		}
		MDVSLICE mdvs( vimd );
		cCliqueEntries += mdvs._Totlen();
	}

	REAL rcb = 0;
	rcb += cClique * sizeof(GOBJMBN_CLIQUE);
	rcb += cSepsetArc * sizeof(GEDGEMBN_SEPSET);
	rcb += cCliqsetArc * sizeof(GEDGEMBN_CLIQSET);
	rcb += cMbrArc * sizeof(GEDGEMBN_CLIQ);
	rcb += cCliqueEntries * sizeof(REAL);
	rcb += cFamEntries * sizeof(REAL);

#ifdef DUMP
	cout << "\nEstimated clique tree memory is " << rcb;
#endif

	return rcb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\enumstd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       enumstd.h
//
//--------------------------------------------------------------------------

//
//	enumstd.h:  Standard global enumerations
//

#ifndef _ENUMSTD_H_
#define _ENUMSTD_H_

////////////////////////////////////////////////////////////////////
//	Property flags
////////////////////////////////////////////////////////////////////
const UINT fPropString = 1;			//  Property is a string (!fPropString ==> real)
const UINT fPropArray = 2;			//	Property is an array (!fPropArray  ==> scalar)
const UINT fPropChoice = 4;			//	Property is an enumerated value
const UINT fPropStandard = 8;		//  Property is standard (stored in Registry)
const UINT fPropPersist = 16;		//  Property is persistent (stored in Registry)

////////////////////////////////////////////////////////////////////
//	Definitions to enable usage of "MS_" standard properties
////////////////////////////////////////////////////////////////////
enum ESTDPROP
{
	ESTDP_label,			//  Node troubleshooting label (choice)
	ESTDP_cost_fix,			//  Cost to fix	(real)
	ESTDP_cost_observe,		//  Cost to observe (real)
	ESTDP_category,			//  Category (string)
	ESTDP_normalState,		//  Index of troubleshooting "normal" state (int)
	ESTDP_max				//  End
};

enum ESTDLBL		//  VOI-relative node label
{
	ESTDLBL_other,
	ESTDLBL_hypo,
	ESTDLBL_info,
	ESTDLBL_problem,
	ESTDLBL_fixobs,
	ESTDLBL_fixunobs,
	ESTDLBL_unfix,
	ESTDLBL_config,
	ESTDLBL_max
};


#endif // _ENUMSTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\errordef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       errordef.h
//
//--------------------------------------------------------------------------

//	
//	errordef.h: definitions and strings for standard errors
//	

#if !defined(_ERRORDEF_H_) && !defined(GMERRORSTR)
#define _ERRORDEF_H_

#undef GMERRORDEF

#ifdef GMERRORSTR
	//  Generate string table declarations
	#define GMERRORDEF(sym,str)  { EC_##sym, str },
#else
	//  Generate enumeration declarations
	#define GMERRORDEF(sym,str)  EC_##sym,
#endif

GMERRORDEF(CREF,					"Reference counted object error")
GMERRORDEF(DYN_CAST,				"Dynamic cast failure")
GMERRORDEF(NULLP,					"NULL pointer error")
GMERRORDEF(LINK_OFFSET,				"Linkage offset error")
GMERRORDEF(PROP_MISUSE,				"Invalid use of a property item")
GMERRORDEF(DIST_MISUSE,				"Misuse of a distribution")
GMERRORDEF(MDVECT_MISUSE,			"Misuse of an m-d array")
GMERRORDEF(INVALID_CLONE,			"Attempt to clone in invalid state")
GMERRORDEF(DUPLICATE_NAME,			"Attempt to add a duplicate name")
GMERRORDEF(INAPPLICABLE,			"Operation is not applicable to object")
GMERRORDEF(CREATES_CYCLE,			"Addition of directed arc creates cycle")
GMERRORDEF(INV_PD,					"Invalid probability distribution")
GMERRORDEF(TOPOLOGY_MISMATCH,		"Topology doesn't match distribution")
GMERRORDEF(NYI,						"Function not implemented")
GMERRORDEF(INTERNAL_ERROR,			"Internal error")
GMERRORDEF(VOI_NO_INFO,				"No info nodes in VOI calculation")
GMERRORDEF(VOI_FIXABLE_PARENTS,		"A fixable node has parents")
GMERRORDEF(VOI_FIXABLE_ABNORMAL,	"A fixable node is abnormal")
GMERRORDEF(VOI_PROBDEF_ABNORMAL,	"Count of abnormal PD nodes != 1")
GMERRORDEF(VOI_MODEL_COST_FIX,		"Model repair cost not set")
GMERRORDEF(VOI_NO_HYPO,				"No hypothesis node in network")
GMERRORDEF(REGISTRY_ACCESS,			"Registry access failure")
GMERRORDEF(OVER_SIZE_ESTIMATE,		"Allowed size exceeded")

#undef GMERRORDEF

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\expand.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       expand.cpp
//
//--------------------------------------------------------------------------

//
//	expand.cpp: CI expansion
//

#include <basetsd.h>
#include "basics.h"
#include "algos.h"
#include "expand.h"

/*
	The Causal Independence model expansion.

	In all cases, the zeroth state is considered the "normal" state; all
	other states are "abnormal" in some sense.

	For each CI node, new "expansion" nodes and arcs are created.  All
	generated nodes have the same state space as the original CI node.

		1)  For each parent, a new intermediate node is created.

		2)  A "leak" node is created for the CI node, and one for each
			of the parents except the last.

		3)  The nodes are linked in a chain, such as:

			(A)  (B)							 (A)	 (B)
			 |	  |			becomes				  |		 |
			 \	  /								(Pca)	(Pcb)
			  \  /								  |		 |
			   (C)						(Lc) -- (La) -- (C')

		4)  In other words, the intermediate nodes are between the original
			parents and the CI leak nodes or the final, modified C node (labeled
			C').

		5)  Probabilities for C given abnormal states of each parent are moved
			to the intermediate parent nodes (labeled Pca and Pcb above).

		6)  Probabilities of the primary leak node (Lc) are set to the "leak"
			probabilties of the original node; namely, the pvector representing
			all parents in a normal state (0,0,...).

		7)  The replacement node for C (labeled C') is just another "leak" node
			for the original node given its final parent.  (This is a topological
			optimization.)

		8)  All of the leak nodes are deterministic; i.e., their ptables
			contain only 0 or 1.0 in every entry.

	Topological consistency is maintained as follows:

		1)	All newly generated nodes and arcs are marked with the "Expansion"
			bit flag.

		2)  The target node is marked as "Expanded". Its distribution reference
			is replaced with a reference to a distribution created to represent
			the expanded distribution.

		3)  New nodes are added for leak and expansion parents; they are marked
			accordingly as "Expansion" and "Leak".

		3)  New arcs are added between "Expanded" (modified) nodes and their new
			expansion parents, as well as between expansion nodes. These are marked
			as "Expansion" arcs.

	Note that the ordering of the parents of a node cannot change as a result of CI expansion.

	During cliquing and inference, if a node is marked as "Expanded", only its "Expansion"
	arcs are considered true parents.

	During expansion tear-down (in Destroy()), all "Expansion" by-products are deleted.
	"Expanded" flags are cleared from all remaining nodes and arcs.  This must be a
	complete "undo" of all that expansion accomplished.  Note that generated distributions
	(which are not recorded in the model's distribution map) will be automatically
	deleted
 */

GOBJMBN_MBNET_EXPANDER :: GOBJMBN_MBNET_EXPANDER ( MBNET & model )
	: MBNET_MODIFIER(model),
	_propmgr(model),
	_cNodesExpanded(0),
	_cNodesCreated(0),
	_cArcsCreated(0)
{
}

GOBJMBN_MBNET_EXPANDER :: ~ GOBJMBN_MBNET_EXPANDER ()
{
	Destroy();
}

	//	Return true if no modidfications were performed.
bool GOBJMBN_MBNET_EXPANDER :: BMoot ()
{
	return _cNodesExpanded == 0;
}

//  Perform any creation-time operations
void GOBJMBN_MBNET_EXPANDER :: Create ()
{
	// Test whether network has already been CI-expanded
	ASSERT_THROW( ! _model.BFlag( EIBF_Expanded ),
				  EC_INTERNAL_ERROR,
				  "network expansion called on expanded network" );

	//  Create the topology if necessary
	_model.CreateTopology();

	//  Connect the nodes to their distributions
	_model.BindDistributions();

	//  Collect the expandable nodes
	GOBJMBN * pgmobj;
	VPGNODEMBND vpgndd;
	MBNET::ITER mbnit( _model, GOBJMBN::EBNO_NODE );
	for ( ; pgmobj = *mbnit ; ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GNODEMBN * pbnode;
		DynCastThrow( pgmobj, pbnode );
		assert( zsrName == pbnode->ZsrefName() );
		assert( ! pbnode->BFlag( EIBF_Expanded ) );
		assert( ! pbnode->BFlag( EIBF_Expansion ) );

		//  For now, this routine only handles discrete nodes
		GNODEMBND * pbnoded;
		DynCastThrow( pbnode, pbnoded );
	
		//  Does this node have any parents?

		//  Is this a CI node?
		assert( pbnoded->BHasDist() );
		BNDIST::EDIST ed = pbnoded->Bndist().Edist() ;
		if ( ed <= BNDIST::ED_SPARSE )
			continue;
		ASSERT_THROW( ed == BNDIST::ED_CI_MAX,
					  EC_NYI,
					  "attempt to expand non-MAX CI node" );
		vpgndd.push_back( pbnoded );
	}

	//  Expand them
	for ( int ind = 0; ind < vpgndd.size(); )
	{
		Expand( *vpgndd[ind++] );		
		_cNodesExpanded++;
	}

	_model.BSetBFlag( EIBF_Expanded );
}

//  Perform any special destruction
void GOBJMBN_MBNET_EXPANDER :: Destroy ()
{
	ASSERT_THROW( _model.BFlag( EIBF_Expanded ),
				  EC_INTERNAL_ERROR,
				  "network expansion undo called on unexpanded network" );

	int cNodesExpanded = 0;
	int cNodesCreated = 0;
	int cArcsCreated = 0;

	VPGNODEMBN vpgnd;
	GELEMLNK * pgelm;
	MODEL::MODELENUM mdlenum( Model() );
	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		//  See if it's an expansion-generated edge
		if ( pgelm->BIsEType( GELEM::EGELM_EDGE ) )
		{
			GEDGEMBN * pgedge;
			DynCastThrow( pgelm , pgedge );
			if ( pgedge->EType() == GEDGEMBN::ETPROB )
			{					
				GNODEMBN * pgndSource = dynamic_cast<GNODEMBN *> ( pgedge->PobjSource() );
				GNODEMBN * pgndSink = dynamic_cast<GNODEMBN *> ( pgedge->PobjSink() );
				if ( pgndSource && pgndSink )
				{
					//  Count this edge if either end connects to an expansion by-product
					if ( pgndSource->BFlag( EIBF_Expansion ) || pgndSink->BFlag( EIBF_Expansion ) )
					{
						//  This arc was created during expansion; it will be deleted along with
						//		the expansion node(s) it connects to.
						cArcsCreated++;
					}
				}
			}
		}
		else
		if ( pgelm->BIsEType( GELEM::EGELM_NODE ) )
		{
			GNODEMBND * pgndd = dynamic_cast<GNODEMBND *>(pgelm);
			if ( pgndd )
			{
				if ( pgndd->BFlag( EIBF_Expansion ) )
				{
					// Expansion node; kill it
					vpgnd.push_back( pgndd );
					cNodesCreated++;
				}
				else
				if ( pgndd->BFlag( EIBF_Expanded ) )
				{
					// Expanded node; zap the generated distribution, clear all flags
					pgndd->ClearDist();
					pgndd->BSetBFlag( EIBF_Expanded, false );
					cNodesExpanded++;
				}
			}
		}
	}
		
	assert(    cNodesCreated  == _cNodesCreated
			&& cArcsCreated   == _cArcsCreated
			&& cNodesExpanded == _cNodesExpanded );

	for ( int i = 0; i < vpgnd.size(); )
	{
		_model.DeleteElem( vpgnd[i++] ) ;
	}

	//  Disconnect the nodes from their distributions.  Note that this destroys distributions
	//	generated during expansion, since their reference counts will go to zero.
	_model.ClearDistributions();

	//  Unmark the network
	_model.BSetBFlag( EIBF_Expanded, false );
}

//
//  Perform the expansion operation against a node.
//
//  This creates:
//
//			A parentless "leak" node for the ensemble, marked as "expansion"
//
//			A "causal" node for each original parent, marked as "expansion"
//
//			An "expand/leak" node for each original parent but the last.  The given
//			node is (reversably) modified for reuse as the last in the chain. These
//			nodes are marked as "expanded" and "expansion", so that expansion
//			arcs will be considered real parents by GNODEMBN::GetParents().
//
void GOBJMBN_MBNET_EXPANDER :: Expand ( GNODEMBND & gndd )
{
	//  Guarantee that the node to be expanded has a sparse distribution
	assert( ! gndd.BFlag( EIBF_Expanded ) );
	assert( gndd.BHasDist() );
	assert( gndd.Bndist().BSparse() );

	//  Get the array of parents
	VPGNODEMBN vpgndParents;
	gndd.GetParents( vpgndParents );
	int cParent = vpgndParents.size();

	VIMD vimd1Dim(1);	//  Useful 1-dimensional subscript vector

	//  Build a leak distribution to use either on the leak
	//	node or on this node if the node has no parents.
	BNDIST * pbndistLeak = new BNDIST();
	{
		//  Locate the leak vector
		const VLREAL * pvlrLeak = gndd.Bndist().PVlrLeak();
		ASSERT_THROW( pvlrLeak,
					  EC_INTERNAL_ERROR,
					  "node CI expansion cannot locate leak/default vector" );
		assert( pvlrLeak->size() == gndd.CState() );

		//  Build a leak distribution
		assert( pvlrLeak->size() == gndd.CState() );
		vimd1Dim[0] = gndd.CState();
		pbndistLeak->SetDense( vimd1Dim );
		MDVCPD & mdvLeak = pbndistLeak->Mdvcpd();
		mdvLeak = *pvlrLeak;
	}

	if ( cParent == 0 )
	{
		//  CI node has no parents; use leak distribution.
		gndd.SetDist( pbndistLeak );
	}

	//  Use the special "internal symbol" character
	char chMark = _model.ChInternal();
	SZC szcNode = gndd.ZsrefName().Szc();

	//  Start the CI expansion chain with a node representing the "leak" or
	//	background event.
	ZSTR zsName;
	//  Format the name "$Leak$Nodename"
	zsName.Format( "%cLeak%c%s",  chMark, chMark, szcNode );
	//  Create the node, initialize it and add it to the network
	GNODEMBND * pgnddLeak = new GNODEMBND;
	pgnddLeak->BSetBFlag( EIBF_Leak );
	pgnddLeak->BSetBFlag( EIBF_Expansion );
	pgnddLeak->SetStates( gndd.VzsrStates() );
	_model.AddElem( zsName, pgnddLeak );
	_cNodesCreated++;
	pgnddLeak->SetDist( pbndistLeak );

	//  Prepare to iterate over the parents
		//  Dense dimensioned subscript vector for causal parent
	VIMD vimdCausal(2);
		//  Dense dimensioned subscript vector for leak/expansion parent
	VIMD vimdLeak(3);
		//  Sparse dimensioned subscript vector for real parent
	VIMD vimdTarget( gndd.Bndist().VimdDim().size() - 1 );
		//  Set up a "normal" vector for causal parents
	VLREAL vlrNormal( gndd.CState() );
	vlrNormal = 0.0;
	vlrNormal[0] = 1.0;
	
	//  Sparse map for this node's distribution.  Note that the last cycle through
	//	the loop will replace the distribution on this node.  However, the
	//	reference object will increment the reference count on the
	//	distribution object, and all created distributions will disappear when
	//  the expansion is reversed.
	REFBNDIST refbndThis = gndd.RefBndist();
	const MPCPDD & dmap = refbndThis->Mpcpdd();

	for ( int iParent = 0; iParent < cParent; iParent++ )
	{
		//  Set to create a new node if this isn't the last parent
		bool bNew = iParent+1 < cParent;
		GNODEMBND * pgnddParent;
		DynCastThrow( vpgndParents[iParent], pgnddParent );
		SZC szcParent = pgnddParent->ZsrefName().Szc();
		//  Create a new leak node if this isn't last parent
		GNODEMBND * pgnddLeakNew = NULL;
		if ( bNew )
		{
			//  Format the name "$Expand$Child$Parent"
			zsName.Format( "%cExpand%c%s%c%s",
							chMark, chMark, szcNode, chMark, szcParent );
			_model.AddElem( zsName, pgnddLeakNew = new GNODEMBND );
			_cNodesCreated++;
			pgnddLeakNew->SetStates( gndd.VzsrStates() );
			pgnddLeakNew->BSetBFlag( EIBF_Expansion );
		}
		else
		{
			pgnddLeakNew = & gndd;
		}
		pgnddLeakNew->BSetBFlag( EIBF_Expanded );

		//	Create a "causal" node for each parent to contain the probabilities
		//	for that parent's abnormal states.
		GNODEMBND * pgnddCausal = new GNODEMBND;
		pgnddCausal->BSetBFlag( EIBF_Expansion );
		pgnddCausal->SetStates( gndd.VzsrStates() );
		//  Format the name "$Causal$Child$Parent"
		zsName.Format( "%cCausal%c%s%c%s",	
						chMark, chMark, szcNode, chMark, szcParent );
		_model.AddElem( zsName, pgnddCausal );
		_cNodesCreated++;

		//  Add the appropriate edges:
		//		from the original parent to the causal parent
		_model.AddElem( new GEDGEMBN_PROB( pgnddParent, pgnddCausal) ) ;
		//		from the old leak node to the new leak node
		_model.AddElem( new GEDGEMBN_PROB( pgnddLeak, pgnddLeakNew ) );
		//		from the causal to the new "leak" node
		_model.AddElem( new GEDGEMBN_PROB( pgnddCausal, pgnddLeakNew ) );
		_cArcsCreated += 3;

		//  Set the priors for the new "causal" pseudo-parent
		//		p( causal | originalParent )
		{
			BNDIST * pbndist = new BNDIST;
			vimdCausal[0] = pgnddParent->CState();
			vimdCausal[1] = gndd.CState();
			pbndist->SetDense( vimdCausal );
			MDVCPD & mdvCausal = pbndist->Mdvcpd();
			vclear( vimdCausal, 0);
			vclear( vimdTarget, 0);
			vimd1Dim[0] = 0;
			//  Zero vector is deterministic based on parent being in normal state
			mdvCausal.UpdatePartial( vimd1Dim, vlrNormal );
			for ( int iAbnorm = 0; ++iAbnorm < pgnddParent->CState(); )
			{
				//  Look up priors in original node for each abnormal state of parent
				vimd1Dim[0] = iAbnorm;
				assert( iParent < vimdTarget.size() );
				vimdTarget[iParent] = iAbnorm;
				MPCPDD::const_iterator itdm = dmap.find(vimdTarget);
				ASSERT_THROW( itdm != dmap.end(), EC_MDVECT_MISUSE, "cannot locate abnormal parent probs" );
				mdvCausal.UpdatePartial( vimd1Dim, (*itdm).second );
			}
			//  Bind the distribution to the causal node
			pgnddCausal->SetDist( pbndist );
		}
			
		//  Set the priors for the new "leak" node
		//		p( newLeakExpand | oldLeakExpand, causal )
		{
			BNDIST * pbndist = new BNDIST;
			int cValue = gndd.CState();
			assert( cValue == pgnddCausal->CState() && cValue == pgnddLeak->CState() );
			vclear( vimdLeak, cValue );
			pbndist->SetDense( vimdLeak );
			MDVCPD & mdvLeak = pbndist->Mdvcpd();
		
			for ( int il = 0; il < cValue; il++ )
			{
				vimdLeak[0] = il;
				for ( int ic = 0; ic < cValue; ic++ )
				{
					vimdLeak[1] = ic;
					for ( int iself = 0; iself < cValue; iself++ )
					{
						vimdLeak[2] = iself;
						int ivalue = il >= ic ? il : ic;
						assert( ivalue < cValue );
						REAL r = ivalue == iself ? 1.0 : 0.0;
						mdvLeak[vimdLeak] = r;
					}
				}
			}

			pgnddLeakNew->SetDist( pbndist );
		}

		//  Verify that the dimensions of the created nodes match their
		//		created dense distributions
		assert( pgnddCausal->BCheckDistDense() );
		assert( pgnddLeakNew->BCheckDistDense() );

		pgnddLeak = pgnddLeakNew;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\expand.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       expand.h
//
//--------------------------------------------------------------------------

//
//	expand.h:  Declarations for network CI expansion
//
#ifndef _EXPAND_H_
#define _EXPAND_H_

#include "gmobj.h"

////////////////////////////////////////////////////////////////////
//	class GOBJMBN_MBNET_EXPANDER:  
//		An MBNET modifier which performs CI expansion on a network
////////////////////////////////////////////////////////////////////
class GOBJMBN_MBNET_EXPANDER : public MBNET_MODIFIER
{
  public:
	GOBJMBN_MBNET_EXPANDER ( MBNET & model );
	virtual ~ GOBJMBN_MBNET_EXPANDER ();

	virtual INT EType () const
		{ return EBNO_MBNET_EXPANDER; }

	//  Perform any creation-time operations
	void Create ();
	//  Perform any special destruction
	void Destroy ();
	//	Return true if no modidfications were performed.
	bool BMoot ();

  protected:

	PROPMGR _propmgr;	

	int _cNodesExpanded;
	int _cNodesCreated;
	int _cArcsCreated;

  protected:
	void Expand ( GNODEMBND & gndd );

	static const VLREAL * PVlrLeak ( const BNDIST & bndist );
};

#endif // _EXPAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\gelmwalk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gelmwalk.h
//
//--------------------------------------------------------------------------

//
//  gelmwalk.h
//
#ifndef _GELMWALK_H_
#define _GELMWALK_H_

#include "gelem.h"


//  Control structure
struct EWALKCTL
{
	int _bBreadth : 1;				// Breath-first or Depth-first
	int _bAscend  : 1;				// Up or down
	int _bInvert  : 1;				// Normal order or backwards
};

////////////////////////////////////////////////////////////////////
//	class GRPHWALK: Generalize walk-a-graph class.  
//
//		Subclass and declare BSelect() and BMark().
//		BSelect() is called to decide if a node should be followed.
//		BMark() is called to perform unique work on the node.  If
//		it returns false, walk is terminated immediately.
//
////////////////////////////////////////////////////////////////////
class GRPHWALK
{
  public:
	GRPHWALK ( GNODE * pnodeStart, EWALKCTL ectl )
		: _pnodeStart(pnodeStart),
		  _ectl(ectl)
		{}

	~ GRPHWALK() {}

	void Walk ()
	{
		if ( _ectl._bBreadth )
			BBreadthFirst( _pnodeStart );
		else
			BDepthFirst( _pnodeStart );
	}
		
  protected:
	GNODE * _pnodeStart;			// Point of origin
	EWALKCTL _ectl;					// Type, ordering and direction flags

  protected:
	//  Return true if this node should be followed
	virtual bool BSelect ( GNODE * pnode ) = 0;
	//  Mark/fiddle with the node; return false if enumeration should end
	virtual bool BMark ( GNODE * pnode ) = 0;

	bool BDepthFirst ( GNODE * pnode );
	bool BBreadthFirst ( GNODE * pnode );
};

////////////////////////////////////////////////////////////////////
//	template GRPHWALKER:
//		Template for generating walk-a-graph routines
////////////////////////////////////////////////////////////////////
template <class GND> 
class GRPHWALKER : public GRPHWALK
{
  public:
	GRPHWALKER ( GND * pnodeStart, EWALKCTL ectl );

	//  You must write your own variants of these
	virtual bool BSelect ( GND * pnode );
	virtual bool BMark ( GND * pnode );

  protected:
	//  Type-safe redirectors for derived base types.
	virtual bool BSelect ( GNODE * pnode )
		{ return BSelect( (GND *) pnode ); }
	virtual bool BMark ( GNODE * pnode )
		{ return BMark( (GND *) pnode ); }

};

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//  Inline member functions
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
inline
bool GRPHWALK :: BDepthFirst ( GNODE * pnode )
{
	GNODENUM<GNODE> itnd( _ectl._bAscend, _ectl._bInvert );
	
	for ( ; itnd.PnodeCurrent(); itnd++ )
	{
		GNODE * pnode2 = *itnd;
		if ( BSelect( pnode2 ) )
		{
			if ( ! BMark( pnode2 ) )
				return false;
			BDepthFirst( pnode2 );
		}
	}
	return true;
}

inline
bool GRPHWALK :: BBreadthFirst ( GNODE * pnode )
{
	VPGNODE vpnodeA;
	VPGNODE vpnodeB;
	VPGNODE * pvThis = & vpnodeA;
	VPGNODE * pvNext = & vpnodeB;
	VPGNODE * pvTemp = NULL;

	//  Seed the arrays with the starting position
	pvNext->push_back(pnode);

	//  Create the reusable enumerator
	GNODENUM<GNODE> itnd( _ectl._bAscend, _ectl._bInvert );

	while ( pvNext->size() > 0)
	{	
		//  Swap the arrays from the last cycle and this cycle
		pvTemp = pvThis;
		pvThis = pvNext;
		pvNext = pvTemp;
		pvNext->clear();

		//  Walk all descendents at this level and expand the next level
		//	  into the secondary array
		for ( INT iThis = 0; iThis < pvThis->size(); iThis++ )
		{
			GNODE * pnode = (*pvThis)[iThis];

			for ( itnd.Set( pnode ); itnd.PnodeCurrent(); itnd++ )
			{
				GNODE * pnode2 = *itnd;
				if ( BSelect( pnode2 ) )
				{
					if ( ! BMark( pnode2 ) )
						return false;
					pvNext->push_back(pnode2);
				}
			}
		}
	}
	return true;
}

#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\glnkenum.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       glnkenum.h
//
//--------------------------------------------------------------------------

//
//	GLNKENUM.H
//
#if !defined(_GLNKENUM_H_)
#define _GLNKENUM_H_

	//  Base class for generic linkable object enumerators
class GLNKENUM_BASE
{
 public:
	//  Construct an enumerator.
	GLNKENUM_BASE ( const GLNKEL & lnkel, int iDir = 1 )
	{
		Reset( lnkel, iDir ) ;
	}

	//  Position to the next pointer
	GLNKEL * PlnkelNext () ;
	//  Return the current object pointer
	inline GLNKEL * PlnkelCurrent()
		{ return _plnkelNext ; }
	//  Set the enumerator to have a new base
	void Reset ( const GLNKEL & lnkel, int iDir = 0 ) 
	{
		_plnkelStart = const_cast<GLNKEL *>(& lnkel) ;
		_plnkelNext = NULL ;
		if ( iDir >= 0 )
			_iDir = iDir ;
	}

  protected:
	GLNKEL * _plnkelStart ;
	GLNKEL * _plnkelNext ;
	int _iDir ;    			// Enumeration direction
};


#define BOOL_CROSS_PRODUCT(a,b) (((a) > 0) + (((b) > 0) * 2))
inline 
GLNKEL * GLNKENUM_BASE :: PlnkelNext ()
{
	GLNKEL * plnkelResult = NULL ;

	switch ( BOOL_CROSS_PRODUCT( _plnkelNext != NULL, _iDir ) )
	{
		case BOOL_CROSS_PRODUCT( true, true ):
			if ( _plnkelNext->PlnkelNext() != _plnkelStart )
				plnkelResult =_plnkelNext = _plnkelNext->PlnkelNext() ;
			break ;

		case BOOL_CROSS_PRODUCT( true, false ):
			if ( _plnkelNext != _plnkelStart )
				plnkelResult = _plnkelNext = _plnkelNext->PlnkelPrev() ;
			break ;

		case BOOL_CROSS_PRODUCT( false, true ):
			plnkelResult = _plnkelNext = _plnkelStart ;
			break ;

		case BOOL_CROSS_PRODUCT( false, false ):
			plnkelResult = _plnkelNext = _plnkelStart->PlnkelPrev() ;
			break ;
	}
	return plnkelResult ;
}


template <class L, bool bAnchor> 
class GLNKENUM : public GLNKENUM_BASE
{
 public:
	//  Construct an enumerator.  If 'bAnchor', then the anchor object is
	//  skipped during enumeration.
	GLNKENUM ( const L & lnkel, bool bIsAnchor = bAnchor, int iDir = 1 )
		: GLNKENUM_BASE( lnkel, iDir )
		{
			if ( bIsAnchor )
				PlnkelNext() ;
		}
	//  Position to the next pointer
	L * PlnkelNext ()
		{ return (L *) GLNKENUM_BASE::PlnkelNext() ; }
	//  Return the current object pointer
	L * PlnkelCurrent()
		{ return (L *) _plnkelNext ; }
	//  Set the enumerator to have a new base
	void Reset ( const L & lnkel, int iDir = -1 )
		{ GLNKENUM_BASE::Reset( lnkel, iDir ) ; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\gelem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gelem.h
//
//--------------------------------------------------------------------------

//
//	GELEM.H
//

#ifndef _GELEM_H_
#define _GELEM_H_

//  Disable	warning about using 'bool'
#pragma warning ( disable : 4237 )


#include "glnk.h"
#include "leakchk.h"

class GNODE;
class GEDGE;

//  Classes for the type-safe links in arcs to nodes and links in nodes
//		to arcs.
class GEDGLNK : public XLSS<GEDGE> {};
class GNODLNK : public XLSS<GNODE> {};

////////////////////////////////////////////////////////////////////
//	class GNODE:  Base class for node in a graph or tree.  Subclassed
//		from GELEM to imbedded LNKs will know how to compute
//		proper offsets.
////////////////////////////////////////////////////////////////////
class GNODE : public GELEMLNK
{
	friend class GEDGE;

  public:
	GNODE ();
	virtual ~ GNODE ();

	//	Accessors (const and non-const)
	//		Return the source arc cursor (or NULL)
	//		Return the sink arc cursor (or NULL)
	virtual GEDGE * & PedgeSource ()
		{ return _glkArcs.PlnkSource() ; }
	virtual GEDGE * & PedgeSink ()
		{ return _glkArcs.PlnkSink() ; }
	virtual GEDGE * PedgeSource () const
		{ return _glkArcs.PlnkSource() ; }
	virtual GEDGE * PedgeSink () const
		{ return _glkArcs.PlnkSink() ; }

	//  Return counts of arcs in the given direction
	virtual UINT CSourceArc () const;
	virtual UINT CSinkArc () const;

	//  Return counts of arcs in the given direction filtering by type
	virtual UINT CSourceArcByEType ( int eType ) const;
	virtual UINT CSinkArcByEType ( int eType ) const;

	virtual INT EType () const
			{ return EGELM_NODE ; }

	LEAK_VAR_ACCESSOR

  protected:
	//  Return the correct insertion point for a new arc, source or sink.  
	//		Called whenever a new arc is created to maintain ordering of arcs.
	//		Default behavior is to add the new arc as the last.
	virtual GEDGE * PedgeOrdering ( GEDGE * pgedge, bool bSource );

	//  Notification routine called when an arc dies; used to adjust cursors
	virtual void ArcDeath ( GEDGE * pgedge, bool bSource );

  protected:
	// Arc cursors: pointers to one source and one sink arc
	GEDGLNK _glkArcs;

	LEAK_VAR_DECL

	HIDE_UNSAFE(GNODE);
};

DEFINEVP(GNODE);

////////////////////////////////////////////////////////////////////
//	class GEDGE:  Base class for an arc in a graph.
////////////////////////////////////////////////////////////////////
class GEDGE : public GELEMLNK
{
  public:
	//  Internal class for chains (doubly-linked lists) of arcs
	typedef XCHN<GEDGE> CHN;

	//  Constructor requires source and sink nodes
	GEDGE ( GNODE * pgnSource, GNODE * pgnSink );
	virtual ~ GEDGE ();

	//  Accessors:
	//		Return source and sink arc chains
	CHN & ChnSource ()		{ return _lkchnSource;		}
	CHN & ChnSink	()		{ return _lkchnSink;		}
	//		Return source and sink node
	GNODE * & PnodeSource()	{ return _glkNodes.PlnkSource();	}
	GNODE * & PnodeSink()	{ return _glkNodes.PlnkSink();		}

	virtual INT EType () const
			{ return EGELM_EDGE ; }

	LEAK_VAR_ACCESSOR

  protected:
	//  Chain of all arcs originating in the same source node
	CHN _lkchnSource;
	//  Chain of all arcs terminating in the same sink node
	CHN _lkchnSink;
	//  Source and sink node pointers
	GNODLNK _glkNodes;

	LEAK_VAR_DECL

	HIDE_UNSAFE(GEDGE);
};


////////////////////////////////////////////////////////////////////
//	class GNODENUM_BASE:
//
//			Base class for generic linkable object enumerators.
//			Each enumerator can enumerate up or down (source or sink)
//			and forward or reverse in the chain.
////////////////////////////////////////////////////////////////////
class GNODENUM_BASE
{
	//	typedefs for pointer-to-member-function pointer types
	typedef bool (*PFFOLLOW) (GEDGE *);
	typedef GEDGE::CHN & (GEDGE::*PARCCHN)();
	typedef GEDGE * (GEDGE::CHN::*PNX)();
	typedef GNODE * & (GEDGE::*PARCDGN)();

 public:
	//  Construct an enumerator.
	GNODENUM_BASE ( bool bSource,			// true ==> enumerate source (parent) arcs
				    bool bDir = true,		// true ==> follow arc ordering forwards
					bool bBoth = false ) ;	// true ==> enumerate other arcs also
	
	//  Set the enumerator to have a new base; iDir == -1 means don't
	//		change direction flag; otherwise, it's really a "bool".
	void Reset ( bool bSource, int iDir = 0, int bBoth = 0 ) ;

	//  Set the arc following test function pointer.  To use, declare
	//		a function like "bool BMyFollow (GEDGE * pge)", and pass its
	//		address to "SetPfFollow()".  It will be called during enumeration
	//		to see if an arc should be followed.  Alternatively, you can
	//		override "BFollow()" in your templated-derived subclass.
	void SetPfFollow ( PFFOLLOW pfFollow )
		{ _pfFollow = pfFollow ; }

  	//  Set the intrinsic type of arc to follow (i.e., "EType()"); -1 ==> all.
	void SetETypeFollow ( int iEgelmTypeMin = -1, int iEgelmTypeMax = -1 )
		{ _iETypeFollowMin = iEgelmTypeMin; 
		  _iETypeFollowMax = iEgelmTypeMax; }
	//  Set the user-definable type of arc to follow (i.e., "IType()"); -1 ==> all.
	void SetITypeFollow ( int iITypeFollowMin = -1,  int iITypeFollowMax = -1 )
		{ _iITypeFollowMin = iITypeFollowMin;
		  _iITypeFollowMax = iITypeFollowMax; }

	// Return the edge used for the current position
	GEDGE * PgedgeCurrent ()
		{ return _pedgeCurrent; }

protected:
	//  Position to the next pointer; return NULL when done.
	bool BNext () ;

	//  Assign the node being enumerated and the starting point
	void Set ( GNODE * pnode );

	//  Overrideable routine to check arc type
	virtual bool BFollow ( GEDGE * pedge );

	//  Call either the "follower" function or the virtualized follower.
	bool BFollowTest ( GEDGE * pedge )
	{
		return _pfFollow 
			 ? (*_pfFollow)(pedge)
			 : BFollow(pedge);
	}
	// Set the starting point for this mode of iteration
	void SetStartPoint ();

  protected:
	PARCCHN _pfChn;				// Pointer to member function to return chain
	PNX _pfNxPv;				// Ptr to mbr func to move forward or back
	PARCDGN _pfPgn;				// Ptr to member func to get node from arc
	GEDGE * _pedgeNext;			// Next arc
	GEDGE * _pedgeStart;		// Starting arc
	GEDGE * _pedgeCurrent;		// Arc used for recent answer
	GNODE * _pnodeCurrent;		// Recent answer
	GNODE * _pnodeBase;			// Node of origin
	PFFOLLOW _pfFollow;			// Follow override
	bool _bDir;					// Horizontal direction of enumeration
	bool _bSource;				// Vertical direction of enumeration
	bool _bBoth;				// Enumerate arcs in both directions
	bool _bPhase;				// Phase of the search (for _bBoth == true)

	//  These values determine which kinds of arcs are to be followed; 
	//  -1 implies not set.  Used by BFollow().
	int _iETypeFollowMin;		// Follow this canonical type of arc
	int _iETypeFollowMax;		
	int _iITypeFollowMin;		// Follow this user-defined type of arc
	int _iITypeFollowMax;		
};


////////////////////////////////////////////////////////////////////
//	template GNODENUM:
//
//	Generic enumeration class for nodes.  All conversions are type-safe;
//	exceptions will be thrown if accesses are made to objects which are
//	node subclasses of GNODE.
//
//	Each enumerator can enumerate up or down (source or sink)
//	and forward or reverse in the chain.
//
//	*	Use Set() to set the starting node point.
//
//	*	Use the post-increment operator to advance.
//
//	*	Use Pcurrent() or pointer-dereference operator to get the 
//		current node pointer.
//
//	*	Enumerators are reusable.  To restart, reissue "Set()"; to
//		change enumeration parameters, use Reset().
//
////////////////////////////////////////////////////////////////////
template <class GND> 
class GNODENUM : public GNODENUM_BASE
{
 public:
	GNODENUM ( bool bSrc, bool bDir = true, bool bBoth = false )
		: GNODENUM_BASE( bSrc, bDir, bBoth )
		{}

	void Set ( GND * pgnd )
		{ GNODENUM_BASE::Set( pgnd ); }
	bool operator++ (int i)
		{ return BNext() ; }
	bool operator++ ()
		{ return BNext() ; }

	GND * PnodeCurrent ()
	{ 
		GND * pnode = NULL;
		if ( _pnodeCurrent )
			DynCastThrow( _pnodeCurrent, pnode );
		return pnode; 
	}
	GND * operator -> () 
		{ return PnodeCurrent() ; }
	GND * operator * () 
		{ return PnodeCurrent() ; }
	void Reset ( bool bSrc, int iDir = -1, int iBoth = -1 )
		{ GNODENUM_BASE::Reset( bSrc, iDir, iBoth ) ; }

  protected:
 	bool BNext ()
		{ return GNODENUM_BASE::BNext() ; }

	HIDE_UNSAFE(GNODENUM);
};

////////////////////////////////////////////////////////////////////
//	class GRPH:  a generalized graph
//
//		This is a linkable object because it acts as the anchor
//		for its linked list, which connects all enumerable items
//		in this collection.
////////////////////////////////////////////////////////////////////

class GRPH : public GELEMLNK
{
  public:
	GRPH () {}
	virtual ~ GRPH ()
		{ Clear(); }
	
	virtual void AddElem ( GELEMLNK & gelemlnk )
		{ gelemlnk.ChnColl().Link( this );	}

	virtual INT EType () const
		{ return EGELM_GRAPH ; }		

	//  Remove all elements from the graph
	void Clear ()
	{
		GELEMLNK * pgelem; 
		while ( pgelem = ChnColl().PgelemNext() )
			delete pgelem;	
	}

	HIDE_UNSAFE(GRPH);
};

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//		Inline member functions
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
inline 
GNODE :: GNODE ()
{
	LEAK_VAR_UPD(1)
}

inline
GNODE :: ~ GNODE ()
{
	GEDGE * pedge = NULL;
	while ( pedge = PedgeSource() ) 
		delete pedge;
	while ( pedge = PedgeSink() ) 
		delete pedge;

	LEAK_VAR_UPD(-1)
}

inline
GEDGE :: GEDGE ( GNODE * pnodeSource, GNODE * pnodeSink )
	: _lkchnSource(this),
	  _lkchnSink(this)
{
	if ( pnodeSource == NULL || pnodeSink == NULL )
		throw GMException( EC_NULLP, 
						   "attempt to construct a GEDGE without linkage" );

	//  Bind to the pair of nodes
	PnodeSource() = pnodeSource;
	PnodeSink() = pnodeSink;

	//  Determine insertion point into source and sink chains, and
	//    inform nodes of our existence
	GEDGE * pedgeSource = pnodeSource->PedgeOrdering( this, false );
	GEDGE * pedgeSink = pnodeSink->PedgeOrdering( this, true );

	if ( pedgeSource )
	{
		ChnSource().Link( pedgeSource );
	}
	if ( pedgeSink )
	{
		ChnSink().Link( pedgeSink );
	}

	LEAK_VAR_UPD(1)
}

inline
GEDGE :: ~ GEDGE ()
{
	PnodeSource()->ArcDeath( this, false );
	PnodeSink()->ArcDeath( this, true );
	LEAK_VAR_UPD(-1)
}

inline
UINT GNODE :: CSourceArc () const
{
	return PedgeSource()
		 ? PedgeSource()->ChnSink().Count()
		 : 0;
}

inline
UINT GNODE :: CSinkArc () const
{
	return PedgeSink()
		 ? PedgeSink()->ChnSource().Count()
		 : 0;
}

//  Return counts of arcs in the given direction filtering by type
inline
UINT GNODE :: CSourceArcByEType ( int eType ) const
{
	UINT cArcs = 0;
	GEDGE * pgedgeStart = PedgeSource();
	GEDGE * pgedge = pgedgeStart;
	while ( pgedge )
	{
		if ( pgedge->EType() == eType )
			++cArcs;
		pgedge = pgedge->ChnSink().PgelemNext();
		if ( pgedge == pgedgeStart ) 
			break;
	}
	return cArcs;
}

inline
UINT GNODE :: CSinkArcByEType ( int eType ) const
{
	UINT cArcs = 0;
	GEDGE * pgedgeStart = PedgeSink();
	GEDGE * pgedge = pgedgeStart;
	while ( pgedge )
	{
		if ( pgedge->EType() == eType )
			++cArcs;
		pgedge = pgedge->ChnSource().PgelemNext();
		if ( pgedge == pgedgeStart ) 
			break;
	}
	return cArcs;
}

// Return the correct insertion point for a new edge, 
// source or sink.
inline
GEDGE * GNODE :: PedgeOrdering ( GEDGE * pedge, bool bSource )
{
	GEDGE * pedgeOrdering = NULL;

	if ( bSource )
	{
		pedgeOrdering = PedgeSource();
		if ( ! pedgeOrdering ) 
			PedgeSource() = pedge;
	}
	else
	{
		pedgeOrdering = PedgeSink();
		if ( ! pedgeOrdering ) 
			PedgeSink() = pedge;
	}
	return pedgeOrdering;
}

inline
void GNODE :: ArcDeath ( GEDGE * pedge, bool bSource )
{
	if ( bSource )
	{
		if ( pedge == PedgeSource() )
			PedgeSource() = pedge->ChnSink().PgelemNext();
		if ( pedge == PedgeSource() )
			PedgeSource() = NULL;
	}
	else
	{
		if ( pedge == PedgeSink() )
			PedgeSink() = pedge->ChnSource().PgelemNext();
		if ( pedge == PedgeSink() )
			PedgeSink() = NULL;
	}
}

inline
GNODENUM_BASE :: GNODENUM_BASE ( bool bSource, bool bDir, bool bBoth )
	: _pfChn(NULL),
	  _pfNxPv(NULL),
	  _pfPgn(NULL),
	  _pfFollow(NULL),
	  _iETypeFollowMin(-1),
	  _iETypeFollowMax(-1),
	  _iITypeFollowMin(-1),
	  _iITypeFollowMax(-1),
	  _pnodeBase(NULL)
{
	Reset( bSource, bDir, bBoth ) ;
}

	//  Set the base object for the enumeration
inline
void GNODENUM_BASE :: Reset ( bool bSource, int iDir, int iBoth )
{
	if ( iDir >= 0 )
		_bDir = iDir ;
	if ( iBoth >= 0 )
		_bBoth = iBoth;

	_bSource = bSource;

	_pfNxPv = _bDir
			? & GEDGE::CHN::PgelemNext
			: & GEDGE::CHN::PgelemPrev;

	if ( _bSource )
	{
		_pfChn = & GEDGE::ChnSink;
		_pfPgn = & GEDGE::PnodeSource;
	}
	else
	{
		_pfChn = & GEDGE::ChnSource;
		_pfPgn = & GEDGE::PnodeSink;
	}
	_pedgeStart = _pedgeNext = _pedgeCurrent = NULL;
	_pnodeCurrent = NULL;
	_bPhase = false;
}

//  Set the starting point of the iteration.  If 'pnode' is NULL,
//	use the original node.
inline
void GNODENUM_BASE :: Set ( GNODE * pnode )
{
	if ( pnode )
		_pnodeBase = pnode;
	SetStartPoint();
	BNext();
}

inline
void GNODENUM_BASE :: SetStartPoint ()
{
	_pedgeNext =  _bSource 
				  ? _pnodeBase->PedgeSource() 
				  : _pnodeBase->PedgeSink();
	_pedgeStart = _pedgeNext;
}

//  Follow the arc if the constraints are met, both inherent type (EType())
//	and user-definable type (IType().
inline
bool GNODENUM_BASE :: BFollow ( GEDGE * pedge )
{
	if ( _iETypeFollowMin >= 0 )
	{
		int etype = pedge->EType();
		if ( _iETypeFollowMax < 0 ) 
		{
			//  Just the "min" is set; compare equal
			if ( etype !=_iETypeFollowMin )
				return false;
		}
		else
		{
			if ( etype < _iETypeFollowMin || etype > _iETypeFollowMax )
				return false;
		}
	}
	if ( _iITypeFollowMin >= 0 )
	{
		int itype = pedge->IType();
		if ( _iITypeFollowMax < 0 ) 
		{
			//  Just the "min" is set; compare equal
			if ( itype !=_iITypeFollowMin )
				return false;
		}
		else
		{
			if ( itype < _iITypeFollowMin || itype > _iITypeFollowMax )
				return false;
		}
	}
	return true;
}

inline
bool GNODENUM_BASE :: BNext ()
{
	_pnodeCurrent = NULL;
	_pedgeCurrent = NULL;
	
	do
	{
		while ( _pedgeNext == NULL )
		{
			// If we're not iterating both directions, 
			//		or this is phase 2, exit.
			if ( _bPhase || ! _bBoth )		
				return false;
			// Set "2nd phase" flag, invert source/sink
			Reset( !_bSource );
			_bPhase = true;
			SetStartPoint();
		}

		if ( BFollowTest( _pedgeNext ) )
		{
			_pedgeCurrent = _pedgeNext;
			_pnodeCurrent = (_pedgeNext->*_pfPgn)();
		}
		GEDGE::CHN & chn = (_pedgeNext->*_pfChn)();
		_pedgeNext = (chn.*_pfNxPv)();
		if ( _pedgeStart == _pedgeNext )
			_pedgeNext = NULL;
	} while ( _pnodeCurrent == NULL );

	return _pnodeCurrent != NULL;
}
	



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\glnk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       glnk.h
//
//--------------------------------------------------------------------------

//
//   GLNK.H
//
//       This file defines base classes for smart linked lists.
//

#if !defined(_GLNK_H_)
#define _GLNK_H_

#include "basics.h"

//  Disable "warning C4355: 'this' : used in base member initializer list"
#pragma warning ( disable : 4355 )

//  Disable	warning about using 'bool'
#pragma warning ( disable : 4237 )

//      Forward declarations
class GLNK;   				//  Just a linked list anchor
class GELEM;				//	Base class for trees or dags
class GLNKEL;				//  A linked element
class GLNKCHN ;  			//  An imbeddable element
class GELEMLNK;				//	A containerizable element

////////////////////////////////////////////////////////////////////
//	class GLNKBASE:  just a pair of pointers.  Used as a basis for
//			linked lists and bidirectional pointers.
//
////////////////////////////////////////////////////////////////////
class GLNKBASE  				// A linked list anchor
{
  protected:
	GLNKBASE * _plnkNext ;     	// The next link in the chain
	GLNKBASE * _plnkPrev ;    	// The previous link in the chain
  public:

	GLNKBASE ()
		: _plnkNext(NULL),
		  _plnkPrev(NULL)
		{}
	~ GLNKBASE () {};

	GLNKBASE * & PlnkNext ()       	{ return _plnkNext ; }
	GLNKBASE * & PlnkPrev ()      	{ return _plnkPrev ; }

  private:
	//  Block compiler from generating invalid functions
	HIDE_UNSAFE(GLNKBASE);
};

//  Template to generate a pair of pointers to given subclass
template<class L>
class XLBASE
{
  protected:
	L * _plNext ;
	L * _plPrev ; 
  public:
	XLBASE ()	
		: _plNext(NULL),
		_plPrev(NULL)
		{}
	L * & PlnkNext ()       		{ return _plNext ;	}
	L * & PlnkPrev ()      		{ return _plPrev ; }
	const L * PlnkNext () const		{ return _plNext ;	}
	const L * PlnkPrev () const	{ return _plPrev ; }
  private:
	XLBASE(const XLBASE &);
	XLBASE & operator == (const XLBASE &);
};

////////////////////////////////////////////////////////////////////
//  template XLSS:  simple alias template using "source" and "sink"
//		terminology.
////////////////////////////////////////////////////////////////////
template<class L>
class XLSS : public XLBASE<L>
{
  public:
	L * & PlnkSink ()       	{ return _plNext ; }
	L * & PlnkSource ()      	{ return _plPrev ; }
	L * PlnkSink () const      	{ return _plNext ; }
	L * PlnkSource () const    	{ return _plPrev ; }
};

////////////////////////////////////////////////////////////////////
//	class GLNK:  basic doubly-linked list.  Linkage is always
//			done directly between LNKs, not their containing objects
//
////////////////////////////////////////////////////////////////////
class GLNK : public GLNKBASE	// A linked list anchor
{
  protected:
	void Empty () 
	{
	   PlnkPrev() = this ;
	   PlnkNext() = this ;
	}

	GLNK () 
	{
		Empty() ;
	}

	~ GLNK ()
	{
		Unlink() ;
	}

	void Link ( GLNK * plnkNext ) 
	{
	   Unlink() ;
	   PlnkPrev() = plnkNext->PlnkPrev() ;
	   PlnkNext() = plnkNext ;
	   plnkNext->PlnkPrev()->PlnkNext() = this ;
	   PlnkNext()->PlnkPrev() = this ;
	}

	void Unlink ()
	{
	   PlnkNext()->PlnkPrev() = PlnkPrev() ;
	   PlnkPrev()->PlnkNext() = PlnkNext() ;
	   Empty() ;
	}

	// Const and non-const accessor to base pointer pair
	GLNK * & PlnkNext ()       	{ return (GLNK *&) _plnkNext ; }
	GLNK * & PlnkPrev ()      	{ return (GLNK *&) _plnkPrev ; }
	const GLNK * PlnkNext ()  const   	{ return (GLNK *) _plnkNext ; }
	const GLNK * PlnkPrev () const   	{ return (GLNK *) _plnkPrev ; }

  public:
	//  Return count of elements on list, including self
	long Count () const
	{
		long cItem = 1 ;

		for ( GLNK * plnkNext = (CONST_CAST(GLNK *, this))->PlnkNext() ;
			  plnkNext != this ;
			  plnkNext = plnkNext->PlnkNext() )
		{
			cItem++ ;
		}
		return cItem ;
	}

	bool BIsEmpty () const   { return PlnkNext() == this ; }

  private:
	//  Block compiler from generating invalid functions
	HIDE_UNSAFE(GLNK);
};

////////////////////////////////////////////////////////////////////
//	class GELEM: Base class for linkable objects
////////////////////////////////////////////////////////////////////
const int g_IGelemTypeInc = 10000;

class GELEM 
{
	friend class GLNKCHN ;
  public:
	GELEM() {}
	virtual ~ GELEM () {}
	
	enum EGELMTYPE
	{ 
		EGELM_NONE	 = 0, 
		EGELM_NODE	 = EGELM_NONE	+ g_IGelemTypeInc, 
		EGELM_EDGE	 = EGELM_NODE	+ g_IGelemTypeInc,
		EGELM_BRANCH = EGELM_EDGE	+ g_IGelemTypeInc,
		EGELM_LEAF	 = EGELM_BRANCH + g_IGelemTypeInc, 
		EGELM_GRAPH	 = EGELM_LEAF	+ g_IGelemTypeInc,
		EGELM_TREE	 = EGELM_GRAPH	+ g_IGelemTypeInc,
		EGELM_CLIQUE = EGELM_GRAPH  + g_IGelemTypeInc
	};
	virtual INT EType () const
			{ return EGELM_NONE ; }

	bool BIsEType ( INT egelmType )
	{
		INT etype = egelmType / g_IGelemTypeInc;
		INT etypeThis = EType() / g_IGelemTypeInc;
		return etype == etypeThis;	
	}

  protected:
  	//  Return the offset of the given pointer pair from the element.
	int CbOffsetFrom ( const GLNKBASE * p ) const
		//  One could assert that the GLNKCHN really lies within object
		//  boundaries by using a virtualized "sizeof" accessor.  Also,
		//	check mod-4 and other validity conditions.
	   { return ((char*)p) - ((char*)this) ; }
};

////////////////////////////////////////////////////////////////////
//	class GLNKCHN: 
//		A GLNK which knows its offset within the containing object.
//
//	To perform doubly-linked list operations, two pieces of information
//	are necessary:  the location of the pointer pair and the location
//	of the containing object.  By giving the GLNKCHN its offset from
//	the start of the object during construction, it can perform all
//	necessary operations, including automatically unlinking during
//	destruction.
////////////////////////////////////////////////////////////////////
class GLNKCHN : public GLNK
{
  private:
	int _cbOffset ; 			// Number of bytes offset from
								//   start of owning structure
  public:
	GLNKCHN ( GELEM * pgelemOwner )
		: _cbOffset(0)
	{
		_cbOffset = pgelemOwner->CbOffsetFrom( this );
	}
	~ GLNKCHN () {}
	void Link ( GELEM * pgelemNext ) 
	{
		//  Assuming that the GLNKCHN onto which we're linking is at the
		//  same offset in the given GLNKEL as it is in *this, link it.
		GLNKCHN * plnkchn = PlnkchnPtr( pgelemNext );
		GLNK::Link( plnkchn ) ;
	}

	void Unlink () 
	{
	   GLNK::Unlink() ;
	}

	GELEM * PgelemNext () 
	{
		return BIsEmpty()
			? NULL
			: PlnkchnNext()->PgelemChainOwnerPtr() ;
	}

	GELEM * PgelemPrev () 
	{
		return BIsEmpty()
			? NULL
			: PlnkchnPrev()->PgelemChainOwnerPtr() ;
	}

  protected:
	//      Return a pointer to the base object. given a pointer to one of
	//      	its GLNKCHN member objects.
	GELEM * PgelemChainOwnerPtr () const
		{ return (GELEM *) (((SZC) this) - _cbOffset) ; }

	//  Given a pointer to a GELEM presumed to be of the same base
	//  type as this object's container, return a pointer to the
	//  corresponding GLNKCHN in it.
	GLNKCHN * PlnkchnPtr ( const GELEM * pgelem ) const
	{ 
#ifdef _DEBUG
		//  Debug version does error checking
		GLNKCHN * plnkchn = (GLNKCHN *) (((SZC) pgelem) + _cbOffset); 
		if ( _cbOffset != plnkchn->_cbOffset )
			throw GMException(EC_LINK_OFFSET,"invalid GLNKCHN offset");
		return plnkchn;
#else
		return (GLNKCHN *) (((SZC) pgelem) + _cbOffset);
#endif
	}

	//  Protected accessors to GLNK pointers cast to GLNKCHN pointers
	GLNKCHN * PlnkchnNext  () { return (GLNKCHN *) GLNK::PlnkNext()  ; }
	GLNKCHN * PlnkchnPrev () { return (GLNKCHN *) GLNK::PlnkPrev() ; }
  private:
	HIDE_UNSAFE(GLNKCHN);
};

////////////////////////////////////////////////////////////////////
//	template XCHN: 
//		for creating types of chains given a containing object
//		which is a subclass of GELEM
////////////////////////////////////////////////////////////////////
template<class XOBJ>
class XCHN : public GLNKCHN
{
  public:
	XCHN ( XOBJ * pgelemOwner ) 
		: GLNKCHN(pgelemOwner) 
		{}
	void Link ( XOBJ * pgelemNext ) 
		{ GLNKCHN::Link(pgelemNext); }
	void Unlink () 
		{ GLNKCHN::Unlink(); }
	XOBJ * PgelemNext () 
		{ return (XOBJ *) GLNKCHN::PgelemNext(); }
	XOBJ * PgelemPrev () 
		{ return (XOBJ *) GLNKCHN::PgelemPrev(); }
	XOBJ * PgelemThis () 
		{ return PgelemChainOwnerPtr(); }

  protected:
	XOBJ * PgelemChainOwnerPtr () const
		{ return (XOBJ *) GLNKCHN::PgelemChainOwnerPtr(); }

	XCHN * PlnkchnPtr ( const XOBJ * pgelem ) const
		{ return (XCHN *) GLNKCHN::PlnkchnPtr(pgelem); }

	XCHN * PlnkchnNext () { return (XCHN *) GLNKCHN::PlnkchnNext()  ; }
	XCHN * PlnkchnPrev () { return (XCHN *) GLNKCHN::PlnkchnPrev() ; }
  private:
	XCHN(const XCHN &);
	XCHN & operator == (const XCHN &);
};

////////////////////////////////////////////////////////////////////
//  Class GLNKEL:
//      Simple base class for things managed as members of linked lists.
//      One or more LNKCHNs or LNKs can be contained within subclass objects;
//      it contains one "implicit" GLNKCHN for linking siblings in the
//      	implicit tree created by NTREE.
//		Trees are based upon this type.
////////////////////////////////////////////////////////////////////
class GLNKEL : public GELEM
{
  public:
  	//  Internal class for chains (doubly-linked lists)
	typedef XCHN<GLNKEL> CHN;

	GLNKEL ()
		: _chn( this ),
		_iType(0),
		_iMark(0)
		{}

	virtual ~ GLNKEL () {}
	CHN & Chn ()
		{ return _chn ; }
	GLNKEL * PlnkelPrev ()
		{ return Chn().PgelemPrev() ; }
	GLNKEL * PlnkelNext ()
		{ return Chn().PgelemNext() ; }

	// Return the mutable (user-definable) object type
	INT & IType ()				{ return _iType;	}
	INT IType() const			{ return _iType;	}
	INT & IMark ()				{ return _iMark;	}
	INT IMark () const			{ return _iMark;	}

  protected:
	CHN _chn ;					// Primary association chain
	INT _iType;					// User-definable type
	INT _iMark;					// Network walking mark

  protected:
	//  Throw an exception when an invalid cloning operation occurs
	void ThrowInvalidClone ( const GLNKEL & t );

  	HIDE_UNSAFE(GLNKEL);
};

////////////////////////////////////////////////////////////////////
//  Class GELEMLNK:
//		Base class for linkable objects in a collection, such as 
//		graph.  Trees are NOT based upon this type, since trees
//		are not forests (they cannot have associated but disjoint 
//		sets of objects).
////////////////////////////////////////////////////////////////////
class GELEMLNK : public GLNKEL
{
  public:
  	//  Internal class for chains (doubly-linked lists)
	typedef XCHN<GELEMLNK> CHN;

	GELEMLNK () {}
	virtual ~ GELEMLNK () {}

	//  Locate an element (other than 'this') by type
	GELEMLNK * PglnkFind ( EGELMTYPE eType, bool bExact = false )
	{	
		for ( GELEMLNK * pg = this;
			  pg->ChnColl().PgelemThis() != this;
			  pg = pg->ChnColl().PgelemNext() ) 
		{
			if ( bExact ? pg->EType() == eType : pg->BIsEType(eType) ) 
				return pg;
		}
		return NULL;
	}
		
	// Element chain:  all items belonging to this collection
	CHN & ChnColl ()
		{ return (CHN &) _chn ; }

  private:
	HIDE_UNSAFE(GELEMLNK);
};

#endif // !defined(_GLNK_H_)

//  End of glnk.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\gmexcept.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gmexcept.h
//
//--------------------------------------------------------------------------

//
//	gmexcept.h:  Graphical Model Exception handling
//
#ifndef _GMEXCEPT_H_
#define _GMEXCEPT_H_

#include <assert.h>

////////////////////////////////////////////////////////////////
//	Exception Handling
//
//	Exception error code
////////////////////////////////////////////////////////////////
enum ECGM
{
	EC_OK,						//  No error
	EC_WARN_MIN = 100,			//  Lowest warning value
	EC_ERR_MIN = 10000,			//  Lowest error value

	// Include the standard translatable errors
	#include "errordef.h"

	EC_USER_MIN = 20000			//  Lowest user-definable error
};


//	Exception class, using STL class "exception".
//	An "__exString" is just a char *.
//  class "GMException": graphical model exception
class GMException : public exception
{
  public:
    GMException( ECGM ec)
		: _ec(ec)
		{}
    GMException(ECGM ec, const __exString& exs)
		: exception(exs),
		_ec(ec)
		{}
    GMException(ECGM ec, const exception& excp)
		: exception(excp),
		_ec(ec)
		{}
	ECGM Ec () const { return _ec ; }
  protected:
	ECGM _ec;	
};

//  Exception subclass for assertion operations, such as "not implemented"
//  or "internal error".  Can be used in place of any GMException.
//  If debug build, assertion will occur during exception processing.
class GMExceptionAssert : public GMException
{
  public:
    GMExceptionAssert(ECGM ec, const __exString& exs, SZC szcFile, unsigned iLine)
		: GMException(ec,exs)
		{
#if defined(_DEBUG)
			_assert((void*)exs, (void*)szcFile, iLine);
#endif
		}
};

#define ASSERT_THROW(expr,ec,exs)  { if ( !(expr) ) THROW_ASSERT(ec,exs) ; }
#define THROW_ASSERT(ec,exs)  throw GMExceptionAssert(ec,exs,__FILE__,__LINE__)

extern VOID NYI();

#endif  // _GMEXCEPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\gmobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gmobj.h
//
//--------------------------------------------------------------------------

//
//	GMOBJ.H: Grapical model objects declarations
//

#ifndef _GMOBJ_H_
#define _GMOBJ_H_

#include <list>				//  STL list template
#include <assert.h>

#include <iostream>
#include <fstream>

#include "model.h"			//  Graphical model
#include "gmprop.h"			//  Properties and proplists
#include "mbnflags.h"		//	Belief network marking flags static declarations

class CLAMP;				//  An instantiation for a node, discrete or continuous
class GOBJMBN;				//  A named object in a belief network
class GNODEMBN;				//	A node in a belief network
class GNODEMBND;			//  A discrete node
class GEDGEMBN;				//  An arc in a belief network
class MBNET;				//  A belief network
class MBNET_MODIFIER;		//	An object that alters a belief network
class GOBJMBN_INFER_ENGINE;	//  Abstract class for inference engine, based on MBNET_MODIFIER
class GOBJMBN_CLIQSET;		//  A group of junction trees, based on GOBJMBN_INFER_ENGINE
class GOBJMBN_CLIQUE;		//  A clique in a junction tree
class GEDGEMBN_SEPSET;		//  An edge in the junction tree (sepset)
class GOBJMBN_DOMAIN;		//  Named, sharable state space domain

//	Define VGNODEMBN, an array of nodes
DEFINEVP(GNODEMBN);
DEFINEVCP(GNODEMBN);

struct PTPOS
{
	PTPOS( long x = 0, long y = 0 )
		: _x(x),_y(y)
	{}
	long _x;
	long _y;
};


////////////////////////////////////////////////////////////////////
//	class GEDGEMBN:
//		An edge of any kind in belief network.
////////////////////////////////////////////////////////////////////
class GEDGEMBN : public GEDGE
{
  public:
 	enum ETYPE
	{
		ETNONE = GELEM::EGELM_EDGE,	// None
		ETPROB,						// Probabilistic
		ETCLIQUE,					// Clique membership
		ETJTREE,					// Junction tree linkage
		ETUNDIR,					// Undirected edge for topological operations
		ETDIR,						// Directed edge for topological operations
		ETCLIQSET,					// Link to a root clique in a jtree
		ETEXPAND					// Link from original to expanded node
	};

	GEDGEMBN ( GOBJMBN * pgnSource,
			   GOBJMBN * pgnSink )
		: GEDGE( pgnSource, pgnSink )
		{}

	GOBJMBN * PobjSource ()		{ return (GOBJMBN *) GEDGE::PnodeSource();	}
	GOBJMBN * PobjSink ()		{ return (GOBJMBN *) GEDGE::PnodeSink();	}

	virtual GEDGEMBN * CloneNew ( MODEL & modelSelf,				// the original network
								  MODEL & modelNew,					// the new network
								  GOBJMBN * pgobjmbnSource,			// the original source node
								  GOBJMBN * pgobjmbnSink,			// the original sink node
								  GEDGEMBN * pgdegeNew = NULL );	// the new edge or NULL

	virtual INT EType () const
		{ return ETNONE ; }

	virtual ~ GEDGEMBN () {}

	//  Accessors for the array of flag bits
	bool BFlag ( IBFLAG ibf ) const	
		{ return _vFlags.BFlag( ibf );	}
	bool BSetBFlag ( IBFLAG ibf, bool bValue = true )
		{ return _vFlags.BSetBFlag( ibf, bValue );	}

  protected:
	VFLAGS _vFlags;						//  Bit vector of flags

	HIDE_UNSAFE(GEDGEMBN);
};

////////////////////////////////////////////////////////////////////
//	class CLAMP:
//		A forced value (evidence) for a node, continuous or discrete.
//		Use assignment operator to update.
////////////////////////////////////////////////////////////////////
class CLAMP
{
  public:
	CLAMP ( bool bDiscrete = true, RST rst = 0.0, bool bActive = false )
		: _bDiscrete(bDiscrete),
		_bActive(bActive),
		_rst(rst)
	{
	}

	bool BActive () const			{ return _bActive;	}
	bool BDiscrete () const			{ return _bActive;  }

	const RST & Rst () const		
	{
		assert( BActive() && ! BDiscrete() );
		return _rst;
	}
	IST Ist () const
	{
		assert( BActive() && BDiscrete() );
		return IST(_rst);
	}

	bool operator == ( const CLAMP & clamp ) const
	{
		return _bDiscrete == clamp._bDiscrete
		    && _bActive == clamp._bActive
			&& (!_bActive || _rst == clamp._rst);
	}
	bool operator != ( const CLAMP & clamp ) const
	{
		return ! (self == clamp);
	}

  protected:
	bool _bActive;				//  Is this clamp active?
	bool _bDiscrete;			//  Is this discrete or continuous?
	RST _rst;					//  State (coerced to integer if discrete)
};

////////////////////////////////////////////////////////////////////
//	class GNODEMBN:
//		A  node in belief network, continuous or discrete.
//		Hungarian: "gndbn"
////////////////////////////////////////////////////////////////////
class GNODEMBN : public GOBJMBN
{
	friend class DSCPARSER;
	friend class MBNET;

  public:
	GNODEMBN ();
	virtual ~ GNODEMBN();

	virtual INT EType () const
		{ return EBNO_NODE ; }

	virtual GOBJMBN * CloneNew ( MODEL & modelSelf,
								 MODEL & modelNew,
								 GOBJMBN * pgobjNew = NULL );

	//  Node sub-type: use IType() to access.
	enum FNODETYPE
	{	//  Flag definitions (i.e., bits, not values)
		FND_Void		= 0,	//  Node is abstract base class
		FND_Valid		= 1,	//  Node is usable
		FND_Discrete	= 2		//	Node is discrete
	};

	UINT CParent () const		{ return CSourceArcByEType( GEDGEMBN::ETPROB );	}
	UINT CChild () const		{ return CSinkArcByEType( GEDGEMBN::ETPROB );	}

	INT & ITopLevel ()			{ return _iTopLevel;			}
	INT ITopLevel () const		{ return _iTopLevel;			}
	PTPOS & PtPos ()			{ return _ptPos;				}
	ZSTR & ZsFullName ()		{ return _zsFullName;			}
	LTBNPROP & LtProp ()		{ return _ltProp;				}

	virtual void Dump ();
	virtual void Visit ( bool bUpwards = true );

	//  Add topological elements to given array; if "include self", self is last.
	//		Fill array with parent pointers	(follow directed arcs)
	void GetParents ( VPGNODEMBN & vpgnode,					//  Result array
					  bool bIncludeSelf = false,			//  Place self as last entry in list
					  bool bUseExpansion = true );			//  If expanded, use expansion only
	void GetFamily ( VPGNODEMBN & vpgnode,
					  bool bUseExpansion = true )
		{ GetParents(vpgnode,true,bUseExpansion); }
	//		Fill array with child pointers (follow directed arcs)
	void GetChildren ( VPGNODEMBN & vpgnode, bool bIncludeSelf = false );
	//		Fill array with neighbors (follow undirected arcs)
	void GetNeighbors ( VPGNODEMBN & vpgnode, bool bIncludeSelf = false );
	//  Return true if a node is neighbor
	bool BIsNeighbor ( GNODEMBN * pgndmb );
	//  Return the index number of the parent or child or -1 if no relation.
	int IParent ( GNODEMBN * pgndmb, bool bReverse = false );
	int IChild ( GNODEMBN * pgndmb, bool bReverse = false );
	//  Build the probability descriptor describing the node and its parents
	void GetVtknpd ( VTKNPD & vtknpd, bool bUseExpansion = true );

	//  Query and access clamping information
	const CLAMP & ClampIface () const	{ return _clampIface;	}
	CLAMP & ClampIface ()				{ return _clampIface;	}

  protected:
	INT _iTopLevel;				// Topological level
	LTBNPROP _ltProp;			// The list of user-definable properties
	PTPOS _ptPos;				// Display position in graphical display
	ZSTR _zsFullName;			// Full name of node
	CLAMP _clampIface;			// User interface clamp

  protected:
	//  Compare the topology of this node to that of the given distribution
	//		token list to this.  If 'pvpgnode', fill it with pointers to
	//		the parent nodes
	bool BMatchTopology ( MBNET & mbnet,
						  const VTKNPD & vtknpd,
						  VPGNODEMBN * pvpgnode = NULL );

	HIDE_UNSAFE(GNODEMBN);
};

////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_U:  An undirected edge
////////////////////////////////////////////////////////////////////
class GEDGEMBN_U : public GEDGEMBN
{
  public:
	GEDGEMBN_U ( GNODEMBN * pgnSource,
			     GNODEMBN * pgnSink )
		: GEDGEMBN( pgnSource, pgnSink )
		{}
	virtual INT EType () const
		{ return ETUNDIR; }

	virtual ~ GEDGEMBN_U() {}
};

////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_D:  A directed edge
////////////////////////////////////////////////////////////////////
class GEDGEMBN_D : public GEDGEMBN
{
  public:
	GEDGEMBN_D ( GNODEMBN * pgnSource,
			     GNODEMBN * pgnSink )
		: GEDGEMBN( pgnSource, pgnSink )
		{}
	virtual INT EType () const
		{ return ETDIR; }

	virtual ~ GEDGEMBN_D() {}
};


////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_PROB:
//		A probabilistic arc in a belief network.
////////////////////////////////////////////////////////////////////
class GEDGEMBN_PROB : public GEDGEMBN_D
{
  public:
	GEDGEMBN_PROB ( GNODEMBN * pgndSource,
					GNODEMBN * pgndSink )
		: GEDGEMBN_D( pgndSource, pgndSink )
		{}

	virtual INT EType () const
		{ return ETPROB ; }

	virtual ~ GEDGEMBN_PROB () {}

	virtual GEDGEMBN * CloneNew ( MODEL & modelSelf,				// the original network
								  MODEL & modelNew,					// the new network
								  GOBJMBN * pgobjmbnSource,			// the original source node
								  GOBJMBN * pgobjmbnSink,			// the original sink node
								  GEDGEMBN * pgdegeNew = NULL );	// the new edge or NULL

	GNODEMBN * PgndSource ()	{ return (GNODEMBN *) GEDGE::PnodeSource();	}
	GNODEMBN * PgndSink ()		{ return (GNODEMBN *) GEDGE::PnodeSink();	}

	HIDE_UNSAFE(GEDGEMBN_PROB);
};


////////////////////////////////////////////////////////////////////
//	class GNODEMBND:
//		A discrete node in belief network.
////////////////////////////////////////////////////////////////////
class GNODEMBND : public GNODEMBN
{
	friend class DSCPARSER;

  public:
	GNODEMBND ();
	virtual ~ GNODEMBND ();
	virtual GOBJMBN * CloneNew ( MODEL & modelSelf,
								 MODEL & modelNew,
								 GOBJMBN * pgobjNew = NULL );

	UINT CState() const			
		{ return _vzsrState.size();	}
	const VZSREF & VzsrStates() const
		{ return _vzsrState; }
	void SetStates ( const VZSREF & vzsrState )
		{ _vzsrState = vzsrState; }
	//  Return true if there's an associated distribution
	bool BHasDist () const		
		{ return _refbndist.BRef();		}
	//	Set the distribution from the given net's distribution map
	void SetDist ( MBNET & mbnet );
	//  Bind the given distribution this node
	void SetDist ( BNDIST * pbndist );
	//  Return the distribution
	BNDIST & Bndist ()			
	{
		assert( BHasDist() );
		return *_refbndist;
	}
	const BNDIST & Bndist () const
	{
		assert( BHasDist() );
		return *_refbndist;
	}

	//  Return true if the distribution is dense (false ==> sparse)
	bool BDense () const		
	{
		assert( BHasDist() );
		return _refbndist->BDense() ;
	}
	
	//  Return the discrete dimension vector of this node if possible;
	//	return false if any parent is not discrete.
	bool BGetVimd ( VIMD & vimd,							//  Dimension array to fill
					bool bIncludeSelf = false,				//  Place self as last entry in list
					bool bUseExpansion = true );			//  If expanded, use expansion only

	void Dump ();

	void ClearDist()
	{
		_refbndist = NULL;
	}
	const REFBNDIST & RefBndist ()
		{ return _refbndist; }
	bool BCheckDistDense ();

	const ZSREF ZsrDomain() const
		{ return _zsrDomain; }
	void SetDomain ( const GOBJMBN_DOMAIN & gobjrdom );
	
  protected:
	VZSREF _vzsrState;			// Names of states
	ZSREF _zsrDomain;			// Domain of states, if any
	REFBNDIST _refbndist;		// Distribution object

	HIDE_UNSAFE(GNODEMBND);
};

DEFINEVP(GNODEMBND);			//  A vector containing pointers to nodes
DEFINEV(VPGNODEMBN);			//  A vector of vectors containing pointers to nodes
DEFINEV(VPGNODEMBND);			//  A vector of vectors containing pointers to discrete nodes

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//
//	MBNET_MODIFIER:  A generic superclass for active objects
//		which modify a belief network in a reversible fashion.
//		The belief network (MBNET) object maintains a stack of these
//		things and calls each object's Destroy() function as necessary
//		to "unstack".
//
//		These objects should be reusable; that is, the outer level
//		creator may call Create(), followed by Destroy(), followed by
//		Create() again.
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
class MBNET_MODIFIER : public GOBJMBN
{
  public:
	MBNET_MODIFIER ( MBNET & model )
		: _model(model)
		{}
	virtual ~ MBNET_MODIFIER () {}

	virtual INT EType () const
		{ return EBNO_MBNET_MODIFIER; }

	//  Perform any creation-time operations
	virtual void Create () = 0;
	//  Perform any special destruction
	virtual void Destroy () = 0;
	//  Return true if positions in modifier stack can be reversed;
	//		default is "no" (false).
	virtual bool BCommute ( const MBNET_MODIFIER & mbnmod )
		{ return false; }
	//  Return true if construction resulted in no modifications to network
	//		i.e., operation was moot; default is "no" (false).
	virtual bool BMoot ()
		{ return false;	}

	MBNET & Model ()					{ return _model;		}

  protected:
	MBNET & _model;						//  The model we're operating on

	HIDE_UNSAFE(MBNET_MODIFIER);
};

// Define an array of pointers to modifiers, "VPMBNET_MODIFIER".
DEFINEVP(MBNET_MODIFIER);

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//	MBNET_NODE_RANKER:  A generic superclass for external objects
//		which rank or order nodes by some criteria.  Operates as
//		a function object; i.e., it is activated by use of the
//		function call operator.
//
//	    Objects of subclasses of this class must be reusable.  
//		That is, the functin call operator must be callable
//		repeatedly.
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
class MBNET_NODE_RANKER : public GOBJMBN
{
  public:
	MBNET_NODE_RANKER ( MBNET & model )
		: _model(model)
		{}
	virtual ~ MBNET_NODE_RANKER () {}

	virtual INT EType () const
		{ return EBNO_NODE_RANKER; }

	MBNET & Model ()					{ return _model;			}

	//  The ranking function
	virtual void operator () () = 0;

	//  Return the number of items ranked
	INT CRanked () const				{ return _vzsrNodes.size(); }
	//  Return the nodes in rank order
	const VZSREF VzsrefNodes () const	{ return _vzsrNodes;		}
	//  Return the computed values in rank order
	const VLREAL VlrValues () const		{ return _vlrValues;		}

  protected:
	MBNET & _model;				//  The model we're operating on
	VZSREF _vzsrNodes;			//  The names of the nodes in rank order
	VLREAL _vlrValues;			//  THe values associated with the ranking (if any)

  protected:
	void Clear ()
	{
		_vzsrNodes.clear();
		_vlrValues.resize(0);
	}

	HIDE_UNSAFE(MBNET_NODE_RANKER);
};

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//	class MBNET:  a belief network
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
class MBNET : public MODEL
{
  public:
	MBNET ();
	virtual ~ MBNET ();

	//  Clone this belief network from another
	virtual void Clone ( MODEL & model );

	//  Accessor for map of distribution
	MPPD &	Mppd ()					{ return _mppd;			}
	//  Return true if an edge is allowed between these two nodes
	bool BAcyclicEdge ( GNODEMBN * pgndSource, GNODEMBN * pgndSink );
	//	Add a named object to the graph and symbol table
	virtual void AddElem ( SZC szcName, GOBJMBN * pgobj );
	//  Delete named objects
	virtual void DeleteElem ( GOBJMBN * pgelem );
	void AddElem ( GOBJMBN * pgobjUnnamed )
		{ MODEL::AddElem( pgobjUnnamed ); }

	void AddElem ( GEDGEMBN * pgedge )
		{ MODEL::AddElem( pgedge ); }

	//  Topology and distribution management
		//  Add arcs conforming to the defined distributions
	virtual void CreateTopology ();	
		//  Destroy arcs.
	virtual void DestroyTopology ( bool bDirectedOnly = true ) ;
		//  Connect distribution information in MPPD to nodes
	virtual void BindDistributions ( bool bBind = true );
	void ClearDistributions ()
		{ BindDistributions( false ); }

	//  Write debugging info out
	virtual void Dump ();

	//  Network walking/marking helpers
	void ClearNodeMarks ();
	void TopSortNodes ();

	//  Index-to-name mapping functions
		//  Find the named object by index
	GOBJMBN * PgobjFindByIndex ( int inm );
		//  Return the index of a name
	int INameIndex ( ZSREF zsr );
		//	Return the index of an object's name
	int INameIndex ( const GOBJMBN * pgobj );
		//  Return the highest+1 name index
	int CNameMax () const					{ return _vzsrNames.size(); }

	//  Causal Independence expansion operations (automatic during inference)
	virtual void ExpandCI ();
	virtual void UnexpandCI ();

	//  Inference operations
		//  Return the most recently created inference engine
	GOBJMBN_INFER_ENGINE * PInferEngine ();
		//  Create an inference engine
	void CreateInferEngine ( REAL rEstimatedMaximumSize = 10e6 );
		//  Destroy an inference engine
	void DestroyInferEngine ();

  protected:	
	MPPD	 _mppd;							//  Declared probability distributions
	VZSREF   _vzsrNames;					//	Array associating indicies to names
	int		 _inmFree;						//  First free entry in _vsrNodes
	INT		 _iInferEngID;					//  Next inference engine identifier
	VPMBNET_MODIFIER _vpModifiers;			//  The stack of active modifiers

  protected:
	int		CreateNameIndex ( const GOBJMBN * pgobj );
	void	DeleteNameIndex ( const GOBJMBN * pgobj );
	void	DeleteNameIndex ( int inm );

	void PopModifierStack ( bool bAll = false );
	void PushModifierStack ( MBNET_MODIFIER * pmodf );
	MBNET_MODIFIER * PModifierStackTop ();
	void VerifyTopology ();

	HIDE_UNSAFE(MBNET);
};


////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//	class MBNETDSC:
//		Subclass of MBNET that knows how to load and save DSC from
//		the DSC file format.
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
class MBNETDSC : public MBNET
{
  public:
	MBNETDSC ();
	virtual ~ MBNETDSC ();

	//  Parse the network from a DSC file
	virtual bool BParse ( SZC szcFn, FILE * pfErr = NULL );

	//  Print the network in DSC format
	virtual void Print ( FILE * pf = NULL );

	//  Token translation
		//  Map a string to a token
	static TOKEN TokenFind ( SZC szc );
		//  Map a distribution type to a token
	static SZC SzcDist ( BNDIST::EDIST edist );
		//  Map a token to a string
	static SZC SzcTokenMap ( TOKEN tkn );

  protected:
	//  DSC file printing functions
	FILE * _pfDsc;				//  Output print destination

  protected:
	void PrintHeaderBlock();
	void PrintPropertyDeclarations();
	void PrintNodes();
	void PrintDomains();
	void PrintTopologyAndDistributions();
	void PrintDistribution ( GNODEMBN & gnode, BNDIST & bndist );
	void PrintPropertyList ( LTBNPROP & ltprop );

	HIDE_UNSAFE(MBNETDSC);
};

class BNWALKER : public GRPHWALKER<GNODEMBN>
{
  protected:
	bool BSelect ( GNODEMBN * pgn );
	bool BMark ( GNODEMBN * pgn );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\gmprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gmprop.h
//
//--------------------------------------------------------------------------

//
//	gmprop.h: Graphical model property and property type declarations
//

#ifndef _GMPROP_H_
#define	_GMPROP_H_

/*
	A word about DYNAMICALLY EXTENSIBLE OBJECTS and their usage.

	These graphical model object classes are designed to require only very occasional
	addition of new variables.   Most add-on algorithms and functionality do, of course,
	require new variables, but there are several ways of meeting that need.

		1) The standard C++ method of subclassing.   This is a reasonable approach for
		some objects, but typically not for nodes in a belief network.  Cascaded types
		nodes render header files unreadable and cause severe memory bloat.  Also, most 
		variables apply to a phase of processing or only certain nodes.  These cases
		are better handled by the subsequence approaches.

		2) Dynamic property lists.  Every node in a belief network, as well as the network 
		itself, has a property list.  New GOBJPROPTYPEs can be easily created, then new PROPMBNs
		can be added to the appropriate nodes.

		3) Dynamic bit flags.  Every node and the network has a VFLAG vector, and member functions
		of the MPSYMTBL symbol table support conversion of names to indicies.

		4) New edge types.  An "edge" is a real C++ object, and the need for seriously complex
		and versatile data types can be met by creating a new edge type which connects
		pairs of other data structures.  Edges can even be created which connect a node
		to itself, thus creating an "add-on" data structure.

 */
#include <list>

#include "basics.h"
#include "symtmbn.h"
#include "enumstd.h"


class MODEL;
class MBNET;

////////////////////////////////////////////////////////////////////
//	class GOBJPROPTYPE:
//		A named property type descriptor living in a belief network.
//		The word "choice" connotes an enumerated value (i.e., and 
//		an integer property where each value from zero on is named).
////////////////////////////////////////////////////////////////////
class GOBJPROPTYPE : public GOBJMBN
{
	friend class DSCPARSER;		//  So the parser can create them
	friend class BNREG;			//  So they can be loaded from the Registry

  public:
	GOBJPROPTYPE () {}
	virtual ~ GOBJPROPTYPE() {}

	//  Return object type
	virtual INT EType () const
		{ return EBNO_PROP_TYPE ; }

	virtual GOBJMBN * CloneNew ( MODEL & modelSelf, 
								 MODEL & modelNew,
								 GOBJMBN * pgobjNew = NULL );
	//  Return property type descriptor
	UINT FPropType() const
		{ return _fType; }
	//  Return the list of enumerated choices
	const VZSREF VzsrChoice() const
		{ return _vzsrChoice; }
	const ZSREF ZsrComment () const
		{ return _zsrComment; }

  protected:
	UINT _fType;			//	Property type flags
	VZSREF _vzsrChoice;		//	Array of choice names
	ZSREF _zsrComment;		//  Comment

	HIDE_UNSAFE(GOBJPROPTYPE);
};

////////////////////////////////////////////////////////////////////
//	class PROPMBN:
//		A property item definition living in a GNODEMBN
////////////////////////////////////////////////////////////////////
class PROPMBN
{
	friend class LTBNPROP;  // for cloning 

  public:
	PROPMBN ();
	PROPMBN ( const PROPMBN & bnp );
	PROPMBN & operator = ( const PROPMBN & bnp );
	// declare standard operators ==, !=, <, >
	DECLARE_ORDERING_OPERATORS(PROPMBN);

	bool operator == ( ZSREF zsrProp ) const;
	bool operator == ( SZC szcProp ) const;

	void Init ( GOBJPROPTYPE & bnpt );
	UINT Count () const;
	UINT FPropType () const
		{ return _fType; }
	ZSREF ZsrPropType () const
		{ return _zsrPropType; }
	ZSREF Zsr ( UINT i = 0 ) const;
	REAL Real ( UINT i = 0 ) const;
	void Reset ();
	void Set ( ZSREF zsr );
	void Set ( REAL r );
	void Add ( ZSREF zsr );
	void Add ( REAL r );

  protected:	
	UINT _fType;				//	Property type flags
	ZSREF _zsrPropType;			//	Property name
	VZSREF _vzsrStrings;		//  Array of strings
	VREAL _vrValues;			//  Array of reals (or integers or choices)
};

////////////////////////////////////////////////////////////////////
//	class LTBNPROP:
//		A list of properties
////////////////////////////////////////////////////////////////////
class LTBNPROP : public list<PROPMBN> 
{
  public:
	//  Find an element
	PROPMBN * PFind ( ZSREF zsrProp );
	const PROPMBN * PFind ( ZSREF zsrProp ) const;
	//  Update or add and element; return true if element was already present
	bool Update ( const PROPMBN & bnp );
	//  Force the list to contain only unique elements
	bool Uniqify ();
	//  Clone from another list with another symbol table
	void Clone ( MODEL & model, const MODEL & modelOther, const LTBNPROP & ltbnOther );
};


////////////////////////////////////////////////////////////////////
//	class PROPMGR:
//		Facilitates translation between user declarations of standard
//		properties and internal usage.
//
//	N.B.:  Remember that all ZSREFs are symbiotic to the MODEL of
//			origin and are therefore useless in other networks.
////////////////////////////////////////////////////////////////////
class MODEL;				//  A belief network
class GNODEMBN;				//	A node in a belief network

class PROPMGR
{
  public:
	PROPMGR ( MODEL & model );
	//  Return a pointer to the requested standard property type
	GOBJPROPTYPE * PPropType ( ESTDPROP evp );
	//  Return the name of the standard property
	ZSREF ZsrPropType ( ESTDPROP evp );
	//	Return the user-defined value of the standard label or -1 if not defined
	int ILblToUser ( ESTDLBL elbl )
	{ 
		ASSERT_THROW( elbl < ESTDLBL_max, EC_INTERNAL_ERROR, "invalid standard label index" );
		return _vLblToUser[elbl]; 
	}
	//  Return the standard label for the user-defined label value or -1
	int IUserToLbl ( int iLbl )
	{		
		return iLbl >= 0 && iLbl < _vUserToLbl.size() 
			 ? _vUserToLbl[iLbl] 
			 : -1 ;
	}
	//  Find a standard property in a property list
	PROPMBN * PFind ( LTBNPROP & ltprop, ESTDPROP estd );
	//  Find a standard property in a node's property list
	PROPMBN * PFind ( GNODEMBN & gnd, ESTDPROP estd );
	//  Find a standard property in the associated model's property list
	PROPMBN * PFind ( ESTDPROP estd );
	//  Return a displayable name for a standard label
	static SZC SzcLbl ( int iLbl );

  protected:
	//  The model we're referring to
	MODEL & _model;
	//  Pointers to property types for currently used VOI types
	GOBJPROPTYPE * _vPropMap [ ESTDP_max ];
	//  Map from predefined label index to user label index 
	int _vLblToUser [ ESTDLBL_max ];
	//  Map from user label index to predefined label index 
	VINT _vUserToLbl;
	//  Array of ZSREFs as recorded in the network used during construction
	VZSREF _vzsrPropType;

	HIDE_UNSAFE(PROPMGR);
};


#endif	// _GMPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\gndleak.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       gndleak.cpp
//
//--------------------------------------------------------------------------

//
//	Leak checking variables for common classes
//

#include <basetsd.h>
#include "basics.h"
#include "gmobj.h"

LEAK_VAR_DEF(GNODE)
LEAK_VAR_DEF(GEDGE)

void GLNKEL :: ThrowInvalidClone ( const GLNKEL & t )
{
	SZC szcTypeName = typeid(t).name();
	ZSTR zsMsg;
	zsMsg.Format("objects of type \'%s\' do not support cloning", szcTypeName);
	THROW_ASSERT( EC_INVALID_CLONE, zsMsg.Szc() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\gnodembn.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       gnodembn.cpp
//
//--------------------------------------------------------------------------

//
//	GNODEMBN.CPP
//

#include <basetsd.h>
#include <typeinfo.h>

#include "gmobj.h"
#include "cliqset.h"
#include "clique.h"
#include "algos.h"
#include "domain.h"

/*****************************************************************************************
	Cloning and cloning functions.

		There are two types of cloning member functions:

				1) functions named "Clone", in which the new object is being
				asked to initialize itself from another existing object.
				This is not a copy constructor due to the complexity of timing
				chained construcions.

				2) functions named "CloneNew", in which an existing object is being
				asked to participate in the construction of a new object.

		Functions of type #1 are straightforward, such as

				virtual void MODEL :: Clone ( MODEL & model );

		Here, a MODEL is being asked to clone or copy information from an existing
		network into itself.  The object can place whatever restrictions it would like
		on such functions.  For example, the MODEL class requires that the new MODEL
		object be entirely empty.

		Functions of type #2 are more complex, such as

				virtual GOBJMBN * GOBJMBN :: CloneNew ( MBNET & mbnetSelf,
														MBNET & mbnetNew,
														GOBJMBN * pgobjNew = NULL );

		In this case, there are references to the original and clone networks (MBNETs),
		and a pointer to the newly constructed object, which may be NULL.  Consider a
		chain of inheritance such as:
					
				class OBJ;
				class SUB_OBJ : public OBJ;
				class SUB_SUB_OBJ : public SUB_OBJ;

		If a new SUB_SUB_OBJ is to be cloned from an existing one, an empty object must
		be constructed first. Then the CloneNew() function the original SUB_SUB_OBJ is
		called.  At this point, there's a choice: does the SUB_SUB_OBJ perform all the
		initialization for all base classes, or should it defer data member cloning
		to its base classes?  We use the latter approach, as C++ itself does for
		construction and destruction.

		So, at the top level of object cloning, the initial invocation of CloneNew() will
		usually have a NULL object pointer.  Each CloneNew() function must check for this,
		and either create a new object, if allowed, or throw an exception.   It will
		then call the CloneNew() function for its immediate ancestral base class using the
		new pointer.   The ancestral CloneNew() function will see that there already is a
		pointer and simply use it.
		
		In other words, the Clone() member functions are simple "build yourself from
		another" commands.  The CloneNew() functions collaborate with all ancestral base
		classes to correctly construct an object with interdependencies.  Note that
		the semantics (source vs. target) are reversed.

		The bulk of the complexity in cloning an MBNET or MODEL (or subclass) arises from
		the internal string symbol table and the storage of references to strings throughout
		the set of associated objects.
				
 *****************************************************************************************/

// MSRDEVBUG:  This should not be required since it's pure virtual, but VC++ 5.0 gets confused.
GOBJMBN :: ~ GOBJMBN ()
{
}

GOBJMBN * GOBJMBN :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjNew )
{
	// If we're expected to create the object, that's a no-no; throw an exception
	if ( pgobjNew == NULL )
	{
		ThrowInvalidClone( self );
	}

	//  Update class-specific member variables
	pgobjNew->IMark() = IMark();
	pgobjNew->IType() = IType();

	//  Convert and assign the name, if any
	if ( ZsrefName()->length() > 0 )
	{
		pgobjNew->SetName( modelNew.Mpsymtbl().intern( ZsrefName().Szc() ) ) ;
	}
	//  Handle other variables
	pgobjNew->_vFlags = _vFlags;
	return pgobjNew;
}

GNODEMBN :: GNODEMBN()
	:_iTopLevel(-1)
{
	IType() = 0;
}

GNODEMBN :: ~ GNODEMBN()
{
}

GOBJMBN * GNODEMBN :: CloneNew (	
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjNew )

{
	GNODEMBN * pgnd = NULL;
	if ( pgobjNew == NULL )
	{
		pgnd = new GNODEMBN;
	}
	else
	{
		DynCastThrow( pgobjNew, pgnd );
	}
	ASSERT_THROW( GOBJMBN::CloneNew( modelSelf, modelNew, pgnd ),
				  EC_INTERNAL_ERROR,
				  "cloning failed to returned object pointer" );

	//  Update class-specific member variables
	pgnd->_iTopLevel = _iTopLevel;
	pgnd->_ltProp.Clone( modelNew, modelSelf, _ltProp );
	pgnd->_ptPos = _ptPos;
	pgnd->_zsFullName = _zsFullName;
	pgnd->_clampIface = _clampIface;

	return pgnd;
}

GOBJMBN * GNODEMBND :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjNew )
{
	GNODEMBND * pgndd = NULL;
	if ( pgobjNew == NULL )
	{
		pgndd = new GNODEMBND;
	}
	else
	{
		DynCastThrow( pgobjNew, pgndd );
	}
	
	ASSERT_THROW( GNODEMBN::CloneNew( modelSelf, modelNew, pgndd ),
				  EC_INTERNAL_ERROR,
				  "cloning failed to returned object pointer" );

	//  Update class-specific member variables
	modelNew.Mpsymtbl().CloneVzsref( modelSelf.Mpsymtbl(), _vzsrState, pgndd->_vzsrState );
	return pgndd;
}

void GNODEMBN :: Visit ( bool bUpwards /* = true */ )
{
	if ( IMark() )
		return;

	INT iMarkMax = 0;
	GNODENUM<GNODEMBN> benum( bUpwards );
	benum.SetETypeFollow( GEDGEMBN::ETPROB );

	for ( benum.Set( this );
		  benum.PnodeCurrent();
		  benum++ )
	{
		GNODEMBN * pgndbn = *benum;
		pgndbn->Visit( bUpwards );
		if ( pgndbn->IMark() > iMarkMax )
			iMarkMax = pgndbn->IMark();
	}
	IMark() = iMarkMax + 1;
}

//
//  Fill array with parent pointers	(follow directed arcs)
//
//	About network "expansion".  When CI expansion occurs, nodes
//	affected are marked with the flag "EIBF_Expanded".  This routine
//	normally does one of two things:
//
//		If the node is expanded, only parents marked as "EIBF_Expansion"
//		are considered as real parents.
//
//		If the node is not marked, only parents which are not marked as
//		"expansion" are considered.
//
//  This can be overridden with the "bUseExpansion" flag, in which case
//	the original (pre-expansion) parents will be delivered.
//
void GNODEMBN :: GetParents (
	VPGNODEMBN & vpgnode,		//  Result array
	bool bIncludeSelf,			//  If true, place self as last entry in list
	bool bUseExpansion )		//  If true, consider expansion information
{
	//  If requested, and if this node is part of network expansion, only
	//	consider expansion parents.  Otherwise, ignore them and only use real
	//	parents.
	bool bOnlyUseExpansionParents =
			bUseExpansion && BFlag( EIBF_Expanded ) ;

	//  Prepare to iterate over the parents
	GNODENUM<GNODEMBN> benumparent(true);
	benumparent.SetETypeFollow( GEDGEMBN::ETPROB );
	for ( benumparent.Set( this );
		  benumparent.PnodeCurrent();
		  benumparent++ )
	{
		GNODEMBN * pgndParent = *benumparent;
		bool bExpansion = pgndParent->BFlag( EIBF_Expansion );
		if ( bOnlyUseExpansionParents ^ bExpansion )
			continue;
		vpgnode.push_back( pgndParent );
	}
	if ( bIncludeSelf )
		vpgnode.push_back( this );
}

//  Return the discrete dimension vector of this node if possible;
//	return false if any parent is not discrete.
bool GNODEMBND :: BGetVimd (
	VIMD & vimd,					//  Array to fill
	bool bIncludeSelf,				//  Place self as last entry in list
	bool bUseExpansion )			//  If expanded, use expansion only

{
	//  Get the parents according to the flags
	VPGNODEMBN vpgndParents;
	GetParents( vpgndParents, bIncludeSelf, bUseExpansion );
	//  Prepare the result array
	vimd.resize( vpgndParents.size() );
	for ( int i = 0; i < vimd.size(); i++ )
	{
		//  See if the next node is discrete; return false if not
		GNODEMBND * pgnddParent = dynamic_cast<GNODEMBND *> (vpgndParents[i]);
		if ( pgnddParent == NULL )
			return false;
		//  Add to the dimension array
		assert( pgnddParent->IType() & FND_Discrete );
		vimd[i] = pgnddParent->CState();
	}	
	return true;
}

//  Fill array with child pointers (follow directed arcs)
void GNODEMBN :: GetChildren ( VPGNODEMBN & vpgnode, bool bIncludeSelf )
{
	//  Prepare to iterate over the children
	GNODENUM<GNODEMBN> benumchild(false);
	benumchild.SetETypeFollow( GEDGEMBN::ETPROB );
	for ( benumchild.Set( this );
		  benumchild.PnodeCurrent();
		  benumchild++ )
	{
		vpgnode.push_back( *benumchild );
	}
	if ( bIncludeSelf )
		vpgnode.push_back( this );
}

//  Fill array with neighbors (follow undirected arcs)
void GNODEMBN :: GetNeighbors ( VPGNODEMBN & vpgnode, bool bIncludeSelf )
{
	//  Iterate over all connections to the source node.
	//	That is, arcs in either direction.
	GNODENUM_UNDIR gnenumUndir;
	//  Initialize the iterator	
	for ( gnenumUndir = this;
		  gnenumUndir.PnodeCurrent();
		  gnenumUndir++ )
	{
		vpgnode.push_back( *gnenumUndir );
	}
	if ( bIncludeSelf )
		vpgnode.push_back( this );
}

int GNODEMBN :: IParent ( GNODEMBN * pgndmb, bool bReverse )
{
	//  Prepare to iterate over the parents
	GNODENUM<GNODEMBN> benumparent( true, ! bReverse );
	benumparent.SetETypeFollow( GEDGEMBN::ETPROB );
	int iParent = 0;
	for ( benumparent.Set(this);
		  benumparent.PnodeCurrent();
		  benumparent++, iParent++ )
	{
		if ( *benumparent == pgndmb )
			return iParent;
	}
	return -1;
}

int GNODEMBN :: IChild ( GNODEMBN * pgndmb, bool bReverse )
{
	//  Prepare to iterate over the children
	GNODENUM<GNODEMBN> benumchild( false, ! bReverse );
	benumchild.SetETypeFollow( GEDGEMBN::ETPROB );
	int iChild = 0;
	for ( benumchild.Set(this);
		  benumchild.PnodeCurrent();
		  benumchild++ )
	{
		if ( *benumchild == pgndmb )
			return iChild;
	}
	return -1;
}

bool GNODEMBN :: BIsNeighbor ( GNODEMBN * pgndmb )
{
	GNODENUM_UNDIR gnenumUndir;
	for ( gnenumUndir = this;
		  gnenumUndir.PnodeCurrent();
		  gnenumUndir++ )
	{
		if ( *gnenumUndir == pgndmb )
			return true;
	}
	return false;
}

void GNODEMBN :: GetVtknpd ( VTKNPD & vtknpd, bool bUseExpansion )
{
	VPGNODEMBN vpgnodeParent;
	GetParents(vpgnodeParent, false, bUseExpansion);

	vtknpd.clear();
	vtknpd.push_back( TKNPD(DTKN_PD) );
	vtknpd.push_back( TKNPD( ZsrefName() ) );

	for ( int ip = 0; ip < vpgnodeParent.size(); ip++ )
	{
		if ( ip > 0 )			
			vtknpd.push_back( TKNPD(DTKN_AND) );
		else
			vtknpd.push_back( TKNPD(DTKN_COND) );
		vtknpd.push_back( TKNPD(vpgnodeParent[ip]->ZsrefName()) );	
	}
}

bool GNODEMBN :: BMatchTopology (
	MBNET & mbnet,
	const VTKNPD & vtknpd,
	VPGNODEMBN * pvpgnode )
{
	// Guarantee that the descriptor is of the form "p(X|...)"
	if (   vtknpd.size() < 2
		|| vtknpd[0] != TKNPD(DTKN_PD)
		|| ! vtknpd[1].BStr() )
		throw GMException( EC_INV_PD, "invalid token description on PD");

	VTKNPD vtknpdSelf;
	GetVtknpd( vtknpdSelf );

	if ( vtknpdSelf == vtknpd )
		return true;

#ifdef _DEBUG
	{
		ZSTR zs1 = vtknpd.ZstrSignature(0);
		ZSTR zs2 = vtknpdSelf.ZstrSignature(0);
		cout << "\nGNODEMBN::BMatchTopology mismatch: "
			 << "\n\tExpected "
			 << zs1
			 << "\n\tComputed "
			 << zs2
			 ;
	}
#endif
	return false;
}

void GNODEMBN :: Dump ()
{
	cout << "\t(toplev: "
		 << ITopLevel()
		 << "): "
		 << ZsrefName().Szc();

	int iParent = 0;
	GNODENUM<GNODEMBN> benumparent(true);
	benumparent.SetETypeFollow( GEDGEMBN::ETPROB );

	for ( benumparent.Set(this);
		  benumparent.PnodeCurrent();
		  benumparent++ )
	{
		GNODEMBN * pgndbnParent = *benumparent;
		if ( iParent++ == 0 )
			cout << ", parents: ";
		cout << pgndbnParent->ZsrefName().Szc()
			 << ',';
	}
}


GNODEMBND :: GNODEMBND ()
{
	IType() = FND_Valid | FND_Discrete ;
}

GNODEMBND :: ~ GNODEMBND ()
{
	ClearDist();
}

void GNODEMBND :: Dump ()
{
	GNODEMBN::Dump();
	if ( BHasDist() && Bndist().Edist() != BNDIST::ED_NONE )
	{
		cout << "\n\tprobability distribution of "
		     << ZsrefName().Szc()
			 << ": ";
		Bndist().Dump();
	}
}

//	Find the distribution for this node recorded in the belief network's
//		distribution map.
void GNODEMBND :: SetDist ( MBNET & mbnet )
{
	ClearDist();
	//  Construct the token array describing the distribution
	VTKNPD vtknpd;
	GetVtknpd( vtknpd );
	//  Locate that distribution in the belief network's map
	MPPD::iterator itmppd = mbnet.Mppd().find( vtknpd );
	ASSERT_THROW( itmppd != mbnet.Mppd().end(),
				  EC_INTERNAL_ERROR,
				  "missing distribution for node" );
	//  Set this node to use that distribution
	_refbndist = (*itmppd).second;
	assert( BHasDist() );
}

//  Bind the given distribution this node
void GNODEMBND :: SetDist ( BNDIST * pbndist )
{
#ifdef _DEBUG	
	if ( pbndist )
	{
		//  Check that the last dimension is the correct size.		
		int cDims = pbndist->VimdDim().size();
		assert( pbndist->VimdDim()[cDims-1] == CState() );
	}
#endif	
	_refbndist = pbndist;
}

//  Check that the dimensionality of the distribution matches that of
//	  the node itself according to the dag topology.
bool GNODEMBND :: BCheckDistDense ()
{
	//  Get the array of parents
	VPGNODEMBN vpgndParents;
	GetParents( vpgndParents );
	VIMD vimd( vpgndParents.size() + 1 );
	for ( int idim = 0; idim < vimd.size() - 1; idim++ )
	{
		GNODEMBND * pgndd;
		assert( vpgndParents[idim] );
		DynCastThrow( vpgndParents[idim], pgndd );
		vimd[idim] = pgndd->CState();
	}
	vimd[idim] = CState();
	MDVCPD & mdv = Bndist().Mdvcpd();
	return mdv.VimdDim() == vimd;
}

void GNODEMBND :: SetDomain ( const GOBJMBN_DOMAIN & gobjrdom )
{
	//  Copy the state names from the domain to the variable
	const RDOMAIN & rdom = gobjrdom.Domain();
	RDOMAIN::const_iterator itdm = rdom.begin();
	_vzsrState.resize( rdom.size() );
	for ( int i = 0; itdm != rdom.end(); itdm++ )
	{
		const RANGEDEF & rdef = *itdm;
		_vzsrState[i++] = rdef.ZsrName();
	}
	_zsrDomain = gobjrdom.ZsrefName();
}

//
//	Usage of this function without a new object implies that the
//	subclassed target object does not correctly support "CloneNew".
//	Throw a cloning exception in this case.
//
GEDGEMBN * GEDGEMBN :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjmbnSource,
	GOBJMBN * pgobjmbnSink,
	GEDGEMBN * pgedgeNew )
{
	if ( pgedgeNew == NULL )
	{
		ThrowInvalidClone( self );
	}
	pgedgeNew->_vFlags = _vFlags;
	return pgedgeNew;
}


GEDGEMBN * GEDGEMBN_PROB :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjmbnSource,
	GOBJMBN * pgobjmbnSink,
	GEDGEMBN * pgdegeNew  )
{
	assert( EType() == ETPROB );
	GNODEMBN * pgndSource;
	GNODEMBN * pgndSink;

	DynCastThrow( pgobjmbnSource, pgndSource );
	DynCastThrow( pgobjmbnSink,	  pgndSink );

	GEDGEMBN_PROB * pgedge = new GEDGEMBN_PROB( pgndSource, pgndSink );
	ASSERT_THROW( GEDGEMBN::CloneNew( modelSelf, modelNew, pgndSource, pgndSink, pgedge ),
				  EC_INTERNAL_ERROR,
				  "cloning failed to returned object pointer" );
	return pgedge;
}

bool BNWALKER :: BSelect ( GNODEMBN * pgn )
{
	return true;
}

bool BNWALKER :: BMark ( GNODEMBN * pgn )
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\infer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       infer.h
//
//--------------------------------------------------------------------------

//
//	infer.h: inference engine declarations
//

#ifndef _INFER_H_
#define _INFER_H_

#include "gmobj.h"

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//
//	GOBJMBN_INFER_ENGINE:  A generic superclass for inference engines
//		operating against a belief network.
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
class GOBJMBN_INFER_ENGINE: public MBNET_MODIFIER
{
  public:
	GOBJMBN_INFER_ENGINE ( 
		MBNET & model,						//  The model over which to infer
		REAL rEstimatedMaximumSize = -1.0,	//  Max size estimate; < 0 indicates "don't care"
		int iInferEngID = 0 )				//  Inference engine identifier
		: MBNET_MODIFIER(model),
		_iInferEngID( iInferEngID ),
		_rEstMaxSize(rEstimatedMaximumSize)
		{}

	virtual ~ GOBJMBN_INFER_ENGINE () {}
	
	virtual INT EType () const
		{ return EBNO_INFER_ENGINE; }

	//  Perform any creation-time operations
	virtual void Create () = 0;
	//  Perform any special destruction
	virtual void Destroy () = 0;
	//  Reload or reinitialize as necessary
	virtual void Reload () = 0;
	//  Accept evidence on a node
	virtual void EnterEvidence ( GNODEMBN * pgnd, const CLAMP & clamp ) = 0;
	//	Return stored evidence against a node
	virtual void GetEvidence ( GNODEMBN * pgnd, CLAMP & clamp ) = 0;
	//	Perform full inference
	virtual void Infer () = 0;
	//	Return the vector of beliefs for a node
	virtual void GetBelief ( GNODEMBN * pgnd, MDVCPD & mdvBel ) = 0;
	virtual void Dump () = 0;

	INT IInferEngId () const			{ return _iInferEngID;	}

  protected:	
	INT _iInferEngID;					//  This junction tree's identifier
	REAL _rEstMaxSize;					//	Maximum size estimate
};

#endif  // _INFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\leakchk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       leakchk.h
//
//--------------------------------------------------------------------------

//
//	leakchk.h:  simple macros to aid in checking for memory leaks in base classes
//
#ifndef _LEAKCHK_H_
#define _LEAKCHK_H_

#ifdef _DEBUG
	#define LEAK_VAR_DECL			static int _cNew;
	#define LEAK_VAR_UPD(i)				{ _cNew += i; }
	#define LEAK_VAR_DEF(CLS)		int CLS::_cNew = 0;
	#define LEAK_VAR_ACCESSOR		static int CNew () { return _cNew; }
#else 
	#define LEAK_VAR_DECL
	#define LEAK_VAR_UPD(i)
	#define LEAK_VAR_DEF(CLS)
	#define LEAK_VAR_ACCESSOR		static int CNew () { return -1; }
#endif

#endif // _LEAKCHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\gnodera.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gnodera.cxx
//
//--------------------------------------------------------------------------

#include "gnodera.hxx"

GNODERA::GNODERA()
{

}

GNODERA::~GNODERA()
{
	_vpnodeChild.erase(_vpnodeChild.begin(), _vpnodeChild.end());
	_vpnodeParent.erase(_vpnodeParent.begin(), _vpnodeParent.end());
}

// Override on most GNODE virtual accessors
// should throw an exception... for now, random
// access nodes do not handle linear access calls.
//
// To save some typing, I've defined the following
// macro to throw the appropriate exception for all
// of the calls.

#define THROW_RA_EXCEPTION() \
	throw GMException(EC_NYI, "Linear access accessor called on random access graph")



GEDGE*&	GNODERA::PedgeSource()
{
	THROW_RA_EXCEPTION();

	return _glkArcs.PlnkSource();
}

GEDGE*&	GNODERA::PedgeSink()
{
	THROW_RA_EXCEPTION();

	return _glkArcs.PlnkSink();
}

GEDGE*	GNODERA::PedgeSource() const
{
	THROW_RA_EXCEPTION();

	return _glkArcs.PlnkSource();
}

GEDGE*	GNODERA::PedgeSink() const
{
	THROW_RA_EXCEPTION();

	return _glkArcs.PlnkSink();
}

GEDGE*	GNODERA::PedgeOrdering(GEDGE* pgedge, BOOL bSource)
{
	THROW_RA_EXCEPTION();

	return pgedge;
}

VOID	GNODERA::ArcDeath(GEDGE* pgedge, BOOL bSource)
{
	THROW_RA_EXCEPTION();
}

UINT	GNODERA::CSourceArc() const
{
	THROW_RA_EXCEPTION();
	
	return 0;
}

UINT	GNODERA::CSinkArc() const
{
	THROW_RA_EXCEPTION();

	return 0;
}


UINT	GNODERA::CnodeChild()
{
	return _vpnodeChild.size();
}

UINT	GNODERA::CnodeParent()
{
	return _vpnodeParent.size();
}

VOID	GNODERA::InsertChild(GNODE* pnodeChild)
{
	_vpnodeChild.push_back(pnodeChild);
}

VOID	GNODERA::InsertParent(GNODE* pnodeParent)
{
	_vpnodeParent.push_back(pnodeParent);
}

VOID	GNODERA::InsertChild(UINT inodeChild, GNODE* pnodeChild)
{
	assert(inodeChild <= _vpnodeChild.size());

	_vpnodeChild.insert(&_vpnodeChild[inodeChild], pnodeChild);
}

VOID	GNODERA::InsertParent(UINT inodeParent, GNODE* pnodeParent)
{
	assert(inodeParent <= _vpnodeParent.size());

	_vpnodeParent.insert(&_vpnodeParent[inodeParent]);
}

VOID	GNODERA::DeleteChild(UINT inodeChild)
{

	assert(inodeChild < _vpnodeChild.size());

	_vpnodeChild.erase(&_vpnodeChild[inodeChild]);
}

VOID	GNODERA::DeleteParent(UINT inodeParent)
{
	assert(inodeParent < _vpnodeParent.size());

	_vpnodeParent.erase(&_vpnodeParent[inodeParent]);
}

BOOL	GNODERA::BParent(GNODE* pnode)
{
/*	for (UINT inodeParent = 0; inodeParent < CnodeParent(); inodeParent++)
	{
		if (PnodeParent(inodeParent) == pnode)
			return true;
	}

	return false;*/

	if (InodeParent(pnode) == (UINT) -1)
		return false;
	else
		return true;

}

UINT	GNODERA::InodeParent(GNODE* pnode)
{
	for (UINT inodeParent = 0; inodeParent < CnodeParent(); inodeParent++)
	{
		if (PnodeParent(inodeParent) == pnode)
			return inodeParent;
	}

	return (UINT) -1;
}


BOOL	GNODERA::BChild(GNODE* pnode)
{
	/*for (UINT inodeChild = 0; inodeChild < CnodeChild(); inodeChild++)
	{
		if (PnodeChild(inodeChild) == pnode)
			return true;
	}

	return false;*/

	if (InodeChild(pnode) == (UINT) -1)
		return false;
	else
		return true;

}

UINT	GNODERA::InodeChild(GNODE* pnode)
{
	for (UINT inodeChild = 0; inodeChild < CnodeChild(); inodeChild++)
	{
		if (PnodeChild(inodeChild) == pnode)
			return inodeChild;
	}

	return (UINT) -1;
}


GNODE*	GNODERA::PnodeParent(UINT inodeParent)
{
	assert(inodeParent < _vpnodeParent.size());

	return _vpnodeParent[inodeParent];
}

GNODERA*	GNODERA::PnoderaParent(UINT inodeParent)
{
	return (GNODERA*) PnodeParent(inodeParent);
}

GNODE*	GNODERA::PnodeChild(UINT inodeChild)
{
	assert(inodeChild < _vpnodeChild.size());

	return _vpnodeChild[inodeChild];
}

GNODERA*	GNODERA::PnoderaChild(UINT inodeChild)
{
	return (GNODERA*) PnodeChild(inodeChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\marginals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       marginals.h
//
//--------------------------------------------------------------------------

//
//	marginals.h: Definitions for marginals tables.
//
//		See marginals.cpp for documentation
//
#ifndef _MARGINALS_H_
#define _MARGINALS_H_

//  Class of multidimensional array capable of intelligent
//	marginalization.
class MARGINALS : public MDVCPD
{
	friend class MARGSUBITER;

  public:
	MARGINALS ( const VPGNODEMBN & vpgnd )
		{ Init( vpgnd ); }

	MARGINALS () {}

	//  Initialize from an array of node pointers
	//		(discrete only: GNODEMBND)
	void Init ( const VPGNODEMBN & vpgnd )
	{
		_vpgnd = vpgnd;
		Init( VimdFromVpgnd( _vpgnd ) );
	}

	//  Allow access to the table of dimensions
	const VIMD & Vimd () const
		{ return Slice().size();  }

	const VPGNODEMBN & Vpgnd () const
		{ return _vpgnd; }

	//  Marginalize down to a single node
	void Marginalize ( GNODEMBND * pgndd, MDVCPD & distd );
	//	Marginalize down to a subset of our node set using a table of nodes
	void Marginalize ( const VPGNODEMBN & vpgndSubset, MARGINALS & marg );
	//	Marginalize down to a subset of our node set using the other's table of nodes
	void Marginalize ( MARGINALS & marg );
	//  Marginalize to subset using pre-computed iterators
	void Marginalize ( MARGINALS & margSubset, Iterator & itSelf, Iterator & itSubset );

	//  For "absorption", update this sepset marginal from another
	void UpdateRatios ( const MARGINALS & marg );
	//  Multiply corresponding entries in this marginal by those in another
	void MultiplyBySubset ( const MARGINALS & margSubset );
	//  Multiply corresponding entries using precomputed iterators
	void MultiplyBySubset ( Iterator & itSelf, Iterator & itSubset );

	void Multiply ( REAL r );
	void Invert ();

	//  Construct the complete table of conditional probabilities for a given node
	//	given a reordering table.  Build _vpgnd accordingly.
	void CreateOrderedCPDFromNode ( GNODEMBND * pgndd,
									const VIMD & vimdFamilyReorder );

	void ClampNode ( GNODEMBND * pgndd, const CLAMP & clamp );

	//  Given a reorder table, return true if it's moot (no reordering present)
	static bool BOrdered ( const VIMD & vimdReorder );

	//  Convert a node table to a dimension array
	inline static VIMD VimdFromVpgnd ( const VPGNODEMBN & vpgnd )
	{
		VIMD vimd( vpgnd.size() );

		for ( int i = 0; i < vpgnd.size(); i++ )
		{
			const GNODEMBND * pgndd;
			DynCastThrow( vpgnd[i], pgndd );
			vimd[i] = pgndd->CState();
		}
		return vimd;
	}

	//  Return true if each entry in this marginal is equal the corresponding entry
	//		in a like-dimensioned other marginal within the stated tolerance
	bool BEquivalent ( const MARGINALS & marg, REAL rTolerance = 0.0 );

	void Dump();

	//  Return the signed table of dimensions used for marginalizing 
	VSIMD VsimdSubset ( const VPGNODEMBN & vpgndSubset );

  protected:
	//  Table of node pointers for each dimension of this marginal
	VPGNODEMBN _vpgnd;

  protected:
	MARGINALS ( const VIMD & vimd )
		: MDVCPD( vimd )
		{}

	//  Initialize from a table of dimensions
	void Init (  const VIMD & vimd, size_t start = 0 )
		{ MDVCPD::Init( vimd, start ); }

	//  Return the table of pseudo-dimensions for marginalizing to a single node
	VSIMD VsimdFromNode ( GNODEMBND * pgndd );
	
	void SetUniform	();

	void ThrowMisuse ( SZC szcMsg );

	//  Reorder a single m-d vector subscript array. 'vimdReorder' is the
	//  table in MARGINALS (topological) sequence of the original dimensions.	
	inline static
	void ReorderVimd ( const VIMD & vimdReorder, const VIMD & vimdIn, VIMD & vimdOut );
	//  Reorder an array containing a node's family based upon the reordering
	//		table given.
	inline static
	void ReorderVimdNodes ( const VIMD & vimdReorder, GNODEMBND * pgndd, VPGNODEMBN & vpgnd );
	//  Resize the MDVCPD for a UPD for the node
	inline static
	void ResizeDistribution ( GNODEMBND * pgndd, MDVCPD & distd );
};

//  Resize the MDVCPD for a UPD for the node
inline
void MARGINALS :: ResizeDistribution ( GNODEMBND * pgndd, MDVCPD & distd )
{
	distd.MDVDENSE::Init( 1, pgndd->CState() );
}

inline
static
ostream & operator << ( ostream & ostr, const VPGNODEMBN & vpgnd )
{
	ostr << '[';
	for ( int i = 0; i < vpgnd.size(); i++ )
	{
		const GNODEMBN * pgnd = vpgnd[i];
		ostr << pgnd->ZsrefName().Szc();
		if ( i + 1 < vpgnd.size() )
			ostr << ',';
	}
	return ostr << ']';
}

#endif   // _MARGINALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\marginals.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       marginals.cpp
//
//--------------------------------------------------------------------------

//
//	marginals.cpp: Definitions for marginals tables
//

#include <basetsd.h>
#include <math.h>

#include "gmobj.h"
#include "marginals.h"
#include "algos.h"
#include "parmio.h"
#include "bndist.h"

/*
	The marginalization story.   Each MARGINALS structure maintains an array of node
	pointers representing the nodes whose discrete probabilities it covers.  Since there
	was a total ordering over all nodes at clique time, any two node sets can be merged
	to determine which members are absent.  Given, of course, that one table is a (possibly
	improper) subset of the other, which is always in a clique tree.  There are three cases:

			*	A node and its "parent" or "family" clique (the smallest clique containing it
				and all its parents); the clique must be at least as large as the node's family.

			*	A sepset and its source (parent) clique; the sepset marginal must be a proper
				subset of the clique.

			*   A sepset and its sink (child) clique; same as the other sepset case above.

	So we always know which of the two sets is the superset.
	
	There's the question of node ordering.  When the edge between a node and its "family"
	clique is created, a reordering table is computed based upon the clique-time total ordering.
	This table gives the family indicies in clique order.  (Note that the node itself will
	always be the last member of its family.)  Use of this table allows full marginalization
	of the family clique.

	(Hereafter, "CMARG" is the clique MARGINALS table; "NDPROB" is the table of probabilities
	for the node in question.)

	The CMARG has a complete set of dimensions and node pointers.
	Marginalization of a node given its parent clique works as follows.

			1)  Make a copy of CMARG's table of dimensions (Vimd()).
			2)  Create a one-dimensional MDVCPD based on the state space of the
				target node.
			3)  Walk the MARGINALS VPGNODEMBN array.  Change the sign of each entry
				which IS NOT the target node.  For example, if the array is:

					Node Pointer	VIMD
					0x4030ab30		3
					0x4030ab52		2
					0x4030ac10		4

				and the node pointer is 0x4030ab52 (entry #2), the resulting
				VIMD should be
					
					-3
					2
					-4
				
			4)	Then set up an MDVSLICE for the new MDVCPD which uses the
				special "pseudo-dimension" VIMD created in the last step.

			5)	Create two iterators: one for the MARGINALS table in its entirety,
				the other for the temporary MDVCPD and MDVSLICE create in the last step.

			6)  Iterate over the two, adding elements from the MARGINALS into
				the MDVCPD.

			7)  Normalize if necessary.

 */		

//////////////////////////////////////////////////////////////////////
//
//	Helper functions
//
//////////////////////////////////////////////////////////////////////

//  Reorder a single m-d vector subscript array. 'vimdReorder' is the
//  table in MARGINALS (topological) sequence of the original dimensions.	
inline
void MARGINALS :: ReorderVimd (
	const VIMD & vimdReorder,	//	Reordering array
	const VIMD & vimdIn,		//	Original subscript vector
	VIMD & vimdOut )			//	Result: must be properly sized already!
{
	int cDim = vimdReorder.size();
	assert( vimdIn.size() == cDim && vimdOut.size() == cDim );

	for	( int iDim = 0; iDim < cDim; iDim++ )
	{
		int iDimReord = vimdReorder[iDim];
		assert( iDimReord >= 0 && iDimReord < cDim );
		vimdOut[iDim] = vimdIn[iDimReord];
	}	
}

//  Reorder an array containing a node's family based upon the reordering
//		table given.
inline
void MARGINALS :: ReorderVimdNodes (
	const VIMD & vimdReorder,	//	Reordering array
	GNODEMBND * pgndd,			//  Discrete node to provide reorder for
	VPGNODEMBN & vpgnd )		//	Result
{
	VPGNODEMBN vpgndUnord;
	pgndd->GetFamily( vpgndUnord );
	int cDim = vimdReorder.size();
	assert( cDim == vpgndUnord.size() );
	vpgnd.resize( cDim );
	
	for	( int iDim = 0; iDim < cDim; iDim++ )
	{
		int iDimReord = vimdReorder[iDim];
		assert( iDimReord >= 0 && iDimReord < cDim );
		vpgnd[iDim] = vpgndUnord[iDimReord];
	}	
}

inline
static
int vimdProd ( const VIMD & vimd )
{
	int iprod = 1;
	for ( int i = 0; i < vimd.size() ; )
	{
		iprod *= vimd[i++];
	}
	return iprod;
}

inline
static
bool bIsProb ( const REAL & r )
{
	return r >= 0.0 && r <= 1.0;
}


//  Centralized "throw serious error" point
void MARGINALS :: ThrowMisuse ( SZC szcMsg )
{
	THROW_ASSERT( EC_MDVECT_MISUSE, szcMsg );
}

//  Return the table of pseudo-dimensions for marginalizing to a single node
VSIMD MARGINALS :: VsimdFromNode ( GNODEMBND * pgndd )
{
	//  Build the pseudo-dimension descriptor
	VIMD vimdMarg = VimdDim();
	VSIMD vsimdMarg( vimdMarg.size() );
	bool bFound = false;
	for ( int idim = 0; idim < vimdMarg.size(); idim++ )
	{
		SIMD simd = vimdMarg[idim];
		if ( pgndd != _vpgnd[idim] )
			simd = -simd;		// Negate the missing dimension
		else
		{
			assert( ! bFound );	// Better not be in the list twice!
			bFound = true;
		}
		vsimdMarg[idim] = simd;
	}
	if ( ! bFound )
		ThrowMisuse( "attempt to marginalize non-member node");
	return vsimdMarg;
}

//  Marginalize down to a single node
void MARGINALS :: Marginalize ( GNODEMBND * pgndd, MDVCPD & distd )
{
	//  Initialize and clear the UPD
	ResizeDistribution( pgndd, distd );	
	distd.Clear();

	//  Get the pseudo-dimension descriptor for this node
	VSIMD vsimdMarg = VsimdFromNode( pgndd );
	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	Iterator itSelf( self );
	Iterator itSubset( distd, mdvs );

	while ( itSelf.BNext() )
	{
		itSubset.Next() += itSelf.Next();
	}
	distd.Normalize();
}

VSIMD MARGINALS :: VsimdSubset ( const VPGNODEMBN & vpgndSubset )
{
	//  Build the pseudo-dimension descriptor.  This means to walk
	//  a copy of self's dimension array, negating dimensions which
	//  are not present in the result.
	VIMD vimdMarg = VimdDim();
	int idimSubset = 0;
	VSIMD vsimdMarg(vimdMarg.size());
	//  Iterate over each node in the self set
	for ( int idimSelf = 0;
		  idimSelf < vimdMarg.size();
		  idimSelf++ )
	{
		SIMD simd = vimdMarg[idimSelf];
		if (   idimSubset < vpgndSubset.size()
			&& _vpgnd[idimSelf] == vpgndSubset[idimSubset] )
		{
			//  Found; leave dimension alone
			idimSubset++;
		}
		else
		{
			//  Missing; mark as "pseudo-dimension"
			simd = - simd;
		}
		vsimdMarg[idimSelf] = simd;
	}

	if ( idimSubset != vpgndSubset.size() )
		ThrowMisuse( "attempt to marginalize non-member node");
	return vsimdMarg;
}

//	Marginalize down to a subset of our node set.  Note that the
//  the nodes must be in the same order (with gaps, of course, in the
//	subset).
void MARGINALS :: Marginalize (
	const VPGNODEMBN & vpgndSubset,		//  Subset array of nodes
	MARGINALS & margSubset )			//  Marginalized result structure
{
	//  Initialize the result mdv
	margSubset.Init( vpgndSubset );
	//  Call the common code
	Marginalize( margSubset );
}

//	Marginalize down to a subset of our node set using the other
//	marginal's built-in table of nodes
void MARGINALS :: Marginalize ( MARGINALS & margSubset )
{
	//  Build the pseudo-dimension descriptor.
	VSIMD vsimdMarg = VsimdSubset( margSubset.Vpgnd() );

	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	Iterator itSelf( self );
	Iterator itSubset( margSubset, mdvs );
	Marginalize( margSubset, itSelf, itSubset );
}

void MARGINALS :: Marginalize (
	MARGINALS & margSubset,
	Iterator & itSelf,
	Iterator & itSubset )
{
	margSubset.Clear();

	itSelf.Reset();
	itSubset.Reset();

	while ( itSelf.BNext() )
	{
		itSubset.Next() += itSelf.Next();
	}
}

//  For "absorption", update one sepset marginal from another
void MARGINALS :: UpdateRatios ( const MARGINALS & marg )
{
	int cElem = size();
	if ( cElem != marg.size() )
		ThrowMisuse( "updating ratios requires same sized marginals" );

	for ( int i = 0; i < cElem; i++ )
	{
		REAL & rThis = self[i];
		if ( rThis != 0.0 )
			rThis = marg[i] / rThis;	
	}
}

//  Given a reorder table, return true if it's moot (no reordering present)
bool MARGINALS :: BOrdered ( const VIMD & vimdReorder )
{
	for ( int i = 0; i < vimdReorder.size(); i++ )
	{
		if ( vimdReorder[i] != i )
			return false;
	}
	return true;
}

//  Assuming that the fastest-changing (highest) dimension is the base
//  state space, set the probabilities of this table to uniform.
void MARGINALS :: SetUniform ()
{
	const VIMD & vimdDim = VimdDim();
	int cState = vimdDim[ vimdDim.size() - 1 ];
	REAL rUniform = 1.0 / cState;
	Clear( rUniform );
}


//  Construct the complete table of conditional probabilities for a given node
//	given a reordering table.  The reordering table is maintained as part of
//	the clique membership arc (GEDGEMBN_CLIQ) for a node if the clique is
//	the "family" clique (the smallest clique containing node and its parents).
//
//	At exit, the node pointer table of self is complete and in standard order.
//
//	The "family reorder" vector is in clique order and contains the index
//	of the node's parents which occurs in that position.  Note that the
//	node itself is always last in either ordering.  In its own p-table,
//	its states are the fastest varying subcript.  In the clique, it must
//  fall last in any marginalization containing only itself and its parents
//	due to the topological sorting employed in ordering nodes for clique
//	membership.
void MARGINALS :: CreateOrderedCPDFromNode (
	GNODEMBND * pgndd,
	const VIMD & vimdFamilyReorder )
{
	int cFam = vimdFamilyReorder.size();

	//  Access the distribution in the node
	BNDIST & bndist = pgndd->Bndist();
	const VIMD & vimdDist = bndist.VimdDim();
	assert( vimdDist.size() == cFam );

	//  Create this m-d vector's dimension table by reordering the
	//	  array of dimensions of the node's distribution and
	//	  initializing accordingly.
	VIMD vimd( cFam );
	ReorderVimd( vimdFamilyReorder, vimdDist, vimd );
	ReorderVimdNodes( vimdFamilyReorder, pgndd, _vpgnd );
	assert( _vpgnd.size() == cFam );
	assert( ifind( _vpgnd, pgndd ) >= 0 );	

	Init( vimd );
	assert( vimdProd( vimdDist ) == size() );

	if ( bndist.BDense() )
	{
		//  Dense distribution
		//  Create the reordering iterator
		Iterator itNode( bndist.Mdvcpd() );
		if ( ! BOrdered( vimdFamilyReorder ) )
			itNode.SetDimReorder( vimdFamilyReorder );
		Iterator itSelf( self );

		while ( itSelf.BNext() )
		{
			itSelf.Next() = itNode.Next();	
		}
	}
	else
	{
		//  Sparse distribution.  Iterate over all elements
		//	and plop them into their proper locations.  Since
		//  there may be missing elements, set everything to
		//  uniform first, and normalize as we go.
		SetUniform();

		VIMD vimdState( cFam );
		int cPar = cFam - 1;
		int cState = VimdDim()[cPar];
		//  Prepare a value to be used to replace any bogus (n/a) values in the nodes.
		REAL rUniform = 1.0 / cState;
		MPCPDD::const_iterator itdmEnd = bndist.Mpcpdd().end();
		for ( MPCPDD::const_iterator itdm = bndist.Mpcpdd().begin();
			  itdm != itdmEnd;
			  itdm++ )
		{
			const VIMD & vimdIndex = (*itdm).first;
			const VLREAL & vlr = (*itdm).second;

			//  Construct a complete subscript vector; first, the parents
			for ( int iDim = 0; iDim < cPar; iDim++ )
				vimdState[iDim] = vimdIndex[iDim];
			//  Then iterate over each element of the DPI state vector
			vimdState[cPar] = 0;
			ReorderVimd( vimdFamilyReorder, vimdState, vimd );
			for ( int iState = 0; iState < cState; iState++ )			
			{
				vimd[cPar] = iState;
				const REAL & r = vlr[iState];
				self[vimd] = bIsProb( r )	
						   ? r
						   : rUniform;
			}
		}
	}
}


//  Multiply corresponding entries in this marginal by those in another
void MARGINALS :: MultiplyBySubset ( const MARGINALS & marg )
{
	//MSRDEVBUG:  create a const version of MDVDENSE::Iterator
	MARGINALS & margSubset = const_cast<MARGINALS &> (marg);

	//  Build the pseudo-dimension descriptor.
	VSIMD vsimdMarg = VsimdSubset( margSubset.Vpgnd() );
	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	//  Construct the iterators for self and subset with missing dimensions
	Iterator itSelf( self );
	Iterator itSubset( margSubset, mdvs );
	MultiplyBySubset( itSelf, itSubset );
}

//  Multiply corresponding entries using precomputed iterators
void MARGINALS :: MultiplyBySubset (
	Iterator & itSelf,
	Iterator & itSubset )
{
	itSelf.Reset();
	itSubset.Reset();

	while ( itSelf.BNext() )
	{
		itSelf.Next() *= itSubset.Next();
	}
}

void MARGINALS :: Multiply ( REAL r )
{
	for ( int i = 0; i < size(); )
	{
		self[i++] *= r;
	}
}

void MARGINALS :: Invert ()
{
	for ( int i = 0; i < size(); i++ )
	{
		REAL & r  = self[i];
		if ( r != 0.0 )
			r = 1.0 / r;
	}
}

void MARGINALS :: ClampNode ( GNODEMBND * pgndd, const CLAMP & clamp )
{
	if (! clamp.BActive() )
		return ;
		
	//  Get the clamped state
	IST ist = clamp.Ist();
	//  Find which dimension is represented by this node
	int iDim = ifind( _vpgnd, pgndd );	

	if (   iDim < 0
		|| ist >= Vimd()[iDim] )
		ThrowMisuse("invalid clamp");

	//  Iterate over the entire table, zapping states which are inconsistent
	//		with the evidence.
	Iterator itSelf( self );

	for ( int i = 0; itSelf.BNext(); i++ )
	{	
		int iIst = itSelf.Vitmd()[iDim];
		if ( iIst != ist )
			itSelf.Next() = 0.0;
		else
			itSelf.IndxUpd();
	}
	assert( i == size() );
}


void MARGINALS :: Dump()
{
	cout << "\n\tMarginals members: "
		 << (const VPGNODEMBN &)_vpgnd	// MSRDEVBUG: cast unnecessary for VC++ 5.0
		 << "\n\t";

	Iterator itSelf(self);
	cout << itSelf;
}

//  Return true if each entry in this marginal is equal the corresponding entry
//		in a like-dimensioned other marginal within the stated tolerance

bool MARGINALS :: BEquivalent ( const MARGINALS & marg, REAL rTolerance )
{
	// Test dimensionality
	if ( VimdDim() != marg.VimdDim() )
		return false;

	const VLREAL & vrSelf = first;
	const VLREAL & vrOther = marg.first;
	REAL rTol = fabs(rTolerance);
	for ( int i = 0; i < vrSelf.size(); i++ )
	{
		const REAL & rSelf = vrSelf[i];
		const REAL & rOther = vrOther[i];
		REAL rdiff = fabs(rSelf) - fabs(rOther);
		if ( fabs(rdiff) > rTol )
			break;
	}
	return i == vrSelf.size() && i == vrOther.size();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\margiter.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       margiter.cpp
//
//--------------------------------------------------------------------------

//
//	margiter.cpp: compiled marginals iterators
//

#include <basetsd.h>
#include <math.h>
#include "basics.h"
#include "gmobj.h"
#include "marginals.h"
#include "margiter.h"
#include "algos.h"
#include "parmio.h"

LEAK_VAR_DEF(VMARGSUB)
LEAK_VAR_DEF(MARGSUBREF)

//
//  Construct a VMARGSUB from a marginals iterator
//
VMARGSUB :: VMARGSUB ( MARGINALS::Iterator & itMarg )
	: _iSearchPass(0)
{	
	itMarg.Reset();
	resize( itMarg.IEnd() );
	for ( int i = 0; itMarg.BNext() ; i++)
	{
		int ix = itMarg.IndxUpd();
		self[i] = ix;
	}
	LEAK_VAR_UPD(1)
}

VMARGSUB :: ~ VMARGSUB ()
{
	LEAK_VAR_UPD(-1)
}

void VMARGSUB :: NoRef ()
{
	delete this;
}

MARGSUBREF :: MARGSUBREF ( VMARGSUB * pvmsub, int cSize )
	: _pvmsub( NULL ),
	_cSize( -1 )
{
	SetVmsub( pvmsub, cSize );
	LEAK_VAR_UPD(1)
}

MARGSUBREF :: MARGSUBREF ( const MARGSUBREF & msubr )
	: _pvmsub( NULL ),
	_cSize( -1 )
{
	self = msubr;
	LEAK_VAR_UPD(1)
}

MARGSUBREF & MARGSUBREF :: operator = ( const MARGSUBREF & msubr )
{
	SetVmsub( msubr._pvmsub, msubr.CSize() );	
	return self;
}

void MARGSUBREF :: SetVmsub ( VMARGSUB * pvmsub, int cSize )
{
	if ( _pvmsub )
	{
		_pvmsub->Unbind();
		_pvmsub = NULL;
	}
	if ( pvmsub )
	{
		_cSize = cSize > 0 ? cSize : pvmsub->size();
		pvmsub->Bind();
		_pvmsub = pvmsub;
	}
	else
	{
		_cSize = 0;
	}
}

MARGSUBREF :: ~ MARGSUBREF ()
{
	SetVmsub( NULL );
	LEAK_VAR_UPD(-1)
}

bool MARGSUBREF :: operator == ( const MARGSUBREF & msr ) const
{
	return _pvmsub == msr._pvmsub && _cSize == msr._cSize;
}
bool MARGSUBREF :: operator != ( const MARGSUBREF & msr ) const
{
	return !(self == msr);
}

LTMARGSUBREF :: LTMARGSUBREF ()
	: _iSearchPass(0),
	_cArrays(0),
	_cArrayTotalSize(0),
	_cSubRefs(0)
{
}

void LTMARGSUBREF :: Dump ()
{
#ifdef DUMP
	cout << "\n\nLTMARGSUBREF::~ LTMARGSUBREF: "
		 << "\n\tTotal search passes to create marginals iterators = "
		 << _iSearchPass
		 << "\n\tTotal arrays = "
		 << _cArrays
		 << "\n\tTotal array size = "
		 << _cArrayTotalSize
		 << "\n\tTotal marg iterator references = "
		 << _cSubRefs
		 ;
	cout.flush();
#endif
}

//  Iterate over the list looking for a match
MARGSUBREF * LTMARGSUBREF :: PmsubrAdd ( MARGINALS::Iterator & itMarg )
{
	//  Bump the search pass
	_iSearchPass++;
	//  Get the minimum number of elements
	int cMin = itMarg.IEnd();

	MARGSUBREF * pmsubrBest = NULL;
	MARGSUBREF * pmsubrNew = NULL;

	//  Search the list for the longest matching subscript array
	//		in the pool.
	for ( LTMSUBR::iterator itlt = _ltmsubr.begin();
		  itlt != _ltmsubr.end();
		  itlt++ )
	{
		MARGSUBREF & msubr = (*itlt);
		VMARGSUB & vmsub = msubr.Vmsub();
		if ( vmsub.ISearchPass() == _iSearchPass )
			continue;   //  We've already looked at this one
		//  Mark this VMARGSUB as having been checked in this pass
		vmsub.ISearchPass() = _iSearchPass;

		//  Prepare to search it

		itMarg.Reset();
		for ( int i = 0; itMarg.BNext() && i < vmsub.size() ; i++ )
		{
			int ia = vmsub[i];
			int ib = itMarg.IndxUpd();

			if ( ia != ib )
				break;
		}
		//  If we made it to the end of the array, we found one.
		if ( i != cMin )
			continue;	// Mismatch somewhere
		//  See if it's the best (longest) found so far
		if ( pmsubrBest == NULL )
		{
			pmsubrBest = & msubr;
		}
		else
		if (  pmsubrBest->Vmsub().size() < vmsub.size()
			|| (	pmsubrBest->Vmsub().size() == vmsub.size()
				 && pmsubrBest->CSize() == cMin ) )
		{
			pmsubrBest = & msubr;
		}
	}

	//  If "pmsubrBest" != NULL, we found at least one matching array.
	//	Now see if we can find an exact match: a MARGSUBREF which has
	//  the same base array and the same length as what we want.
	if ( pmsubrBest )
	{
		//  If the "best" one doesn't match our size, find one that does
		if ( pmsubrBest->CSize() != cMin )
		{
			for ( itlt = _ltmsubr.begin();
				  itlt != _ltmsubr.end();
				  itlt++ )
			{
				MARGSUBREF & msubr = (*itlt);
				if ( msubr.Pvmsub() == pmsubrBest->Pvmsub()
					&& msubr.CSize() == cMin )
				{
					pmsubrBest = & msubr;
					break;
				}
			}
		}
		//  See if now have and exact match
		if ( pmsubrBest->CSize() == cMin )
		{
			//  Exact match: best array and same length
			pmsubrNew = pmsubrBest;
		}
		else
		{
			//  Well, we know which array to use, but we have
			//  to create a new MARGSUBREF for it
			_ltmsubr.push_back( MARGSUBREF( pmsubrBest->Pvmsub(), cMin ) );
			pmsubrNew = & _ltmsubr.back();
			_cSubRefs++;
		}
	}
	else
	{
		//  There does NOT appear to be a viable array in the ensemble,
		//  so we have to create a new one and a MARGSUBREF for it.
		VMARGSUB * pvmsub = new VMARGSUB( itMarg );
		_cArrays++;
		_cArrayTotalSize += cMin;
		_ltmsubr.push_back( MARGSUBREF( pvmsub, cMin ) );
		pmsubrNew = & _ltmsubr.back();
		_cSubRefs++;

		//  At this point we have a new array which may be a superset of
		//	some other array already in the pool.  Walk through the list
		//  of MARGSUBREFs and change any references whose base arrays
		//  are subsets of this new one to point to the new array.

		//  Bump the search pass
		_iSearchPass++;

		for ( itlt = _ltmsubr.begin();
			  itlt != _ltmsubr.end();
			  itlt++ )
		{
			MARGSUBREF & msubr = (*itlt);
			if ( & msubr == pmsubrNew )
				continue;
			VMARGSUB & vmsub = msubr.Vmsub();
			if ( vmsub.ISearchPass() == _iSearchPass )
				continue;   //  We've already looked at this one
			//  Mark this VMARGSUB as having been checked in this pass
			vmsub.ISearchPass() = _iSearchPass;
			if ( & vmsub == pvmsub || vmsub.size() > pvmsub->size() )
				continue;	//  Old array is larger; not a subset

			//  See if the old array is a subset
			for ( int i = 0; i < vmsub.size(); i++ )
			{
				int ia = vmsub[i];
				int ib = (*pvmsub)[i];

				if ( ia != ib )
					break;
			}
			if ( i == vmsub.size() )
			{	
				assert( vmsub.size() != pvmsub->size() );
				//  The subset is identical.  Change all refs that point to it.
				VMARGSUB * pvmsubDefunct = msubr.Pvmsub();
				for ( LTMSUBR::iterator itlt2 = _ltmsubr.begin();
					  itlt2 != _ltmsubr.end();
					  itlt2++ )
				{
					MARGSUBREF & msubr2 = (*itlt2);
					if ( msubr2.Pvmsub() == pvmsubDefunct )
					{
						//  If the array is about to disappear, do the bookkeepping
						if ( pvmsubDefunct->CRef() <= 1 )
						{
							_cArrays--;
							_cArrayTotalSize -= pvmsubDefunct->size();
						}
						//  Convert this reference to a reference to our new array
						msubr2.SetVmsub( pvmsub, msubr2.CSize() );
					}
				}
			}
		}
	}
	pmsubrNew->Bind();
	return pmsubrNew;
}

void LTMARGSUBREF :: Release ( MARGSUBREF * pmsubr )
{
	if ( pmsubr == NULL )
		return;
	pmsubr->Unbind();
	if ( pmsubr->CRef() > 0 )
		return;

	LTMSUBR::iterator itlt = find( _ltmsubr.begin(), _ltmsubr.end(), *pmsubr );
	assert( itlt != _ltmsubr.end() );
	_cSubRefs--;
	MARGSUBREF & msubr = (*itlt);
	if ( msubr.Vmsub().CRef() <= 1 )
	{
		_cArrays--;
		_cArrayTotalSize -= msubr.Vmsub().size();
	}
	_ltmsubr.erase(itlt);
}

//  The global subscript array reference list
LTMARGSUBREF MARGSUBITER :: _ltmargsubr;


MARGSUBITER :: MARGSUBITER ()
	:_pmsubr( NULL ),
	_pmargSelf( NULL )
{
}

MARGSUBITER :: ~ MARGSUBITER ()
{
	_ltmargsubr.Release( _pmsubr );
}

void MARGSUBITER :: Build ( MARGINALS & margSelf, MARGINALS & margSubset )
{
	assert( margSelf.size() >= margSubset.size() );
	assert( _pmsubr == NULL && _pmargSelf == NULL );

	_pmargSelf = & margSelf;

	//  Build the pseudo-dimension descriptor.
	VSIMD vsimdMarg = margSelf.VsimdSubset( margSubset.Vpgnd() );

	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	MARGINALS::Iterator itSubset( margSubset, mdvs );

	//  Find or construct a MARGSUBITER to match
	_pmsubr = _ltmargsubr.PmsubrAdd( itSubset );
}

//	Build the iterator for a clique and a node
void MARGSUBITER :: Build ( MARGINALS & margSelf, GNODEMBND * pgndd )
{
	assert( _pmsubr == NULL && _pmargSelf == NULL );
	_pmargSelf = & margSelf;

	//  Construct a dummy marginalization target
	MDVCPD distd;
	MARGINALS::ResizeDistribution( pgndd, distd );

	//  Get the pseudo-dimension descriptor for this node
	VSIMD vsimdMarg = margSelf.VsimdFromNode( pgndd );
	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	MARGINALS::Iterator itSelf( margSelf );
	MARGINALS::Iterator itSubset( distd, mdvs );
	//  Find or construct a MARGSUBITER to match
	_pmsubr = _ltmargsubr.PmsubrAdd( itSubset );
}

//  Verify subscripts
void MARGSUBITER :: Test ( MARGINALS & margSubset )
{
	assert( _pmsubr && _pmargSelf );
	assert( _pmargSelf->size() > margSubset.size() );

	//  Build the pseudo-dimension descriptor.
	VSIMD vsimdMarg = _pmargSelf->VsimdSubset( margSubset.Vpgnd() );

	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	MARGINALS::Iterator itSubset( margSubset, mdvs );
	MARGINALS::Iterator itSelf( *_pmargSelf );
	int isub = 0;
	VINT & vintSub = _pmsubr->VintSub();
	int cEnd = _pmsubr->CSize();
	for ( int iself = 0; itSelf.BNext(); iself++ )
	{
		int isubSelf = itSelf.IndxUpd();
		int isubSubset = itSubset.IndxUpd();
		assert( isubSelf == iself );
		int isubTest = vintSub[iself];
		assert( isubTest == isubSubset && iself < cEnd );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\mbnflags.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       mbnflags.h
//
//--------------------------------------------------------------------------

//
//  mbnflags.h:  
//
//		This inclusion generates names and constant strings
//		or a table of strings, depending upon the setting of
//		of the preprocessor manifest MBN_GENBFLAGS.
//
//		Botk belief networks (MBNET) and named belief network 
//		objects	(GOBJMBN) have arrays of bit flags in them.
//

#if (!defined(_MBNFLAGS_H_)) || defined(MBN_GEN_BFLAGS_TABLE)
#ifndef _MBNFLAGS_H_
	#define _MBNFLAGS_H_
#endif

/*******************************************************************
********************************************************************
	Belief network flag declarations.

	There is a set of predefined flag names which are recorded into 
	the symbol table of every constructed belief network.  These
	names are globally available as members of the enumeration EMBFLAGS;
	for example, "EIBF_Topology".

	Other flag definitions can be created at run-time and used in any 
	bit vector (type VFLAGS).

********************************************************************
********************************************************************/

#ifdef MBN_GEN_BFLAGS_TABLE
	//  Allow building of string name table in outer scope
	#define MBFLAGS_START	static SZC MBN_GEN_BFLAGS_TABLE [] = {
	#define MBFLAG(name)		#name,
	#define MBFLAGS_END			NULL };

#else
	//  Generate enumerated values
	#define MBFLAGS_START	enum EMBFLAGS {
	#define MBFLAG(name)		EIBF_##name,
	#define MBFLAGS_END			EIBF_max };
#endif

//
//	Statically predefined belief network bit flags.
//
	//  Open the declaration set
MBFLAGS_START
	//  Network has probabilistic topology arcs
MBFLAG(Topology)			//	EIBF_Topology
	//  Distributions have been bound
MBFLAG(Distributions)
	//  Network or node has been expanded
MBFLAG(Expanded)			//  EIBF_Expanded
	//  Node is an expansion by-product
MBFLAG(Expansion)			//  EIBF_Expansion
	//	Node is leak term
MBFLAG(Leak)				//  EIBF_Leak
	//  Terminate the declaration set
MBFLAGS_END

//  Rescind the declaration of the bidirectional macro
#undef MBFLAGS_START
#undef MBFLAG
#undef MBFLAGS_END
#undef MBN_GEN_BFLAGS_TABLE

#endif _MBNFLAGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\mbnetdsc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mbnetdsc.cpp
//
//--------------------------------------------------------------------------

//
//   MBNETDSC.CPP: MBNETDSC functions
//

#include <basetsd.h>
#include "gmobj.h"
#include "bnparse.h"

MBNETDSC :: MBNETDSC ()
	: _pfDsc(NULL)
{
}

MBNETDSC :: ~ MBNETDSC ()
{
}

static
struct TKNFUNCMAP
{
	BNDIST::EDIST ed;
	SZC szc;
}
rgTknFunc[] =
{
	{ BNDIST::ED_CI_MAX,	"max"	},
	{ BNDIST::ED_CI_PLUS,	"plus"	},
	{ BNDIST::ED_MAX,		NULL	}		// must be last
};

SZC MBNETDSC :: SzcDist ( BNDIST::EDIST edist )
{
	for ( int i = 0; rgTknFunc[i].szc; i++ )
	{
		if ( rgTknFunc[i].ed == edist )
			break;
	}
	return rgTknFunc[i].szc;
}


//
//	String-to-token translation.
//
struct TKNMAP
{
    SZC     _szc;
    TOKEN   _token;
};

static TKNMAP rgTknStr[] =
{	//  This table must be kept in alphabetic order
	"",					tokenNil,
	"..",				tokenRangeOp,
	"array",			tokenArray,
	"as",				tokenAs,
	"branch",			tokenBranch,
	"choice",			tokenWordChoice,
	"continuous",		tokenContinuous,
	"creator",          tokenCreator,
	"decisionGraph",	tokenDecisionGraph,
	"default",          tokenDefault,
	"discrete",         tokenDiscrete,
	"distribution",		tokenDistribution,
	"domain",			tokenDomain,
	"for",				tokenFor,
	"format",           tokenFormat,
	"function",			tokenFunction,
	"import",			tokenImport,
	"is",				tokenIs,
	"leaf",				tokenLeaf,
	"leak",             tokenLeak,
	"level",			tokenLevel,
	"merge",			tokenMerge,
	"multinoulli",		tokenMultinoulli,
	"na",				tokenNA,
	"name",             tokenName,
	"named",			tokenNamed,
	"network",          tokenNetwork,
	"node",             tokenNode,
	"of",				tokenOf,
	"on",				tokenOn,
	"parent",           tokenParent,
	"position",         tokenPosition,
	"probability",		tokenProbability,
	"properties",		tokenProperties,
	"property",			tokenProperty,
	"real",				tokenWordReal,
	"standard",			tokenStandard,
	"state",            tokenState,
	"string",			tokenWordString,
	"type",             tokenType,
	"version",          tokenVersion,
	"vertex",			tokenVertex,
	"with",				tokenWith,
	NULL,               tokenNil            //  must be last one
};

//
//	Map a string to a token (case-sensitive)
//
TOKEN MBNETDSC :: TokenFind ( SZC szc )
{
	static bool bFirstTime = true;
	assert( szc != NULL );

	TKNMAP * ptknmap;
	
	if ( bFirstTime )
	{
		//  Verify that the parser token table is in sequence
		bFirstTime = false;
		TKNMAP * ptknmapLast = NULL;
		for ( ptknmap = rgTknStr;
			  ptknmap->_szc;
			  ++ptknmap)
		{
			ASSERT_THROW(     ptknmapLast == NULL
						   || ::strcmp( ptknmapLast->_szc, ptknmap->_szc ) < 0,
						   EC_INTERNAL_ERROR,
						   "parser token table out of sequence" );
			ptknmapLast = ptknmap;
		}
	}

    for ( ptknmap = rgTknStr;
		  ptknmap->_szc;
		  ++ptknmap)
    {
		int i = ::strcmp(szc, ptknmap->_szc);
		if ( i > 0 )
			continue;
		if ( i == 0 )
			break;
		return tokenNil;
    }
    return ptknmap->_token;
}

//
//	Map a token to a string.
//
SZC MBNETDSC :: SzcTokenMap ( TOKEN tkn )
{
    for ( TKNMAP * ptknmap = rgTknStr;
		  ptknmap->_szc;
		  ++ptknmap)
    {
		if ( ptknmap->_token == tkn )
			break;
    }
    return ptknmap->_szc;
}

bool MBNETDSC :: BParse ( SZC szcFn, FILE * pfErr )
{
	if ( pfErr == NULL )
		pfErr = stderr;
	PARSIN_DSC flpIn;
	PARSOUT_STD flpOut(pfErr);

	DSCPARSER parser(self, flpIn, flpOut);

	UINT cError, cWarning;
	return parser.BInitOpen( szcFn )
		&& parser.BParse( cError, cWarning );
}

void MBNETDSC :: Print ( FILE * pf )
{
	if ( ! pf )
		pf = stdout;
	_pfDsc = pf;

	PrintHeaderBlock();
	PrintPropertyDeclarations();
	PrintDomains();
	PrintNodes();
	PrintTopologyAndDistributions();

	_pfDsc = NULL;
}

void MBNETDSC :: PrintDomains ()
{
	MBNET::ITER mbnit( self, GOBJMBN::EBNO_VARIABLE_DOMAIN );
	GOBJMBN * pgmobj;
	ZSTR zstrRange;
	for ( ; pgmobj = *mbnit ; ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GOBJMBN_DOMAIN * pgdom;
		DynCastThrow( pgmobj, pgdom );
		fprintf( _pfDsc, "\ndomain %s\n{", zsrName.Szc() );
		const RDOMAIN & rdom = pgdom->Domain();
		RDOMAIN::const_iterator itdm = rdom.begin();
		for ( int i = 0; itdm != rdom.end(); i++ )
		{
			const RANGEDEF & rdef = *itdm;
			zstrRange.Reset();
			//  If the range is a singleton and is the next integer,
			//		just print it as-is.
			if ( ! rdef.BDiscrete() || rdef.IDiscrete() != i )
			{
				//  Format the range operator and arguments
				if ( rdef.BDiscrete() )
				{
					zstrRange.Format( "%d", rdef.IDiscrete() );
				}
				else
				{
					if ( rdef.BLbound() )
						zstrRange.FormatAppend( "%g ", rdef.RLbound() );
					zstrRange.FormatAppend( "%s", SzcTokenMap(tokenRangeOp) );
					if ( rdef.BUbound() )
						zstrRange.FormatAppend( " %g", rdef.RUbound() );
				}
				zstrRange.FormatAppend(" : ");
			}

			fprintf( _pfDsc, "\n\t%s\"%s\"", zstrRange.Szc(), rdef.ZsrName().Szc() );			

			if ( ++itdm != rdom.end() )
				fprintf( _pfDsc, "," );
		}
		fprintf( _pfDsc, "\n}\n" );
	}
}

void MBNETDSC :: PrintHeaderBlock()
{
	fprintf(_pfDsc, "%s", SzcTokenMap(tokenNetwork) );
	if ( ZsNetworkID().length() > 0 )
	{
		fprintf(_pfDsc, " \"%s\"", ZsNetworkID().Szc() );
	}
	fprintf(_pfDsc, "\n{");
	if ( RVersion() >= 0.0 )
	{
		fprintf(_pfDsc, "\n\t%s is %g;",
				SzcTokenMap(tokenVersion),
				RVersion() );
	}
	if ( ZsCreator().length() > 0 )
	{
		fprintf(_pfDsc, "\n\t%s is \"%s\";",
			   SzcTokenMap(tokenCreator),
			   ZsCreator().Szc() );
	}
	if ( ZsFormat().length() > 0 )
	{
		fprintf(_pfDsc, "\n\t%s is \"%s\";",
			   SzcTokenMap(tokenFormat),
			   ZsFormat().Szc() );
	}
	fprintf( _pfDsc, "\n}\n\n" );
}

//
//	Regenerate the property type declarations.
//
//		If any are marked "standard", generate the "import standard" declaration.
//		Generate explicit "import" declarations for any marked "persistent".
//
void MBNETDSC :: PrintPropertyDeclarations()
{
	int cTypes = 0;
	MBNET::ITER mbnit( self, GOBJMBN::EBNO_PROP_TYPE );
	GOBJMBN * pgmobj;
	bool bImportStandard = false;
	for ( ; pgmobj = *mbnit ; ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GOBJPROPTYPE * pbnpt;
		DynCastThrow( pgmobj, pbnpt );
		if ( cTypes++ == 0 )
		{
			fprintf( _pfDsc, "%s\n{",
					SzcTokenMap(tokenProperties) );
		}
		assert( zsrName == pbnpt->ZsrefName() );

		//  If this is a standard persistent property,
		//		write the import declaration once
		if ( pbnpt->FPropType() & fPropStandard )
		{
			if ( ! bImportStandard )
			{	
				//  Write the "import" statement once
				fprintf( _pfDsc, "\n\timport standard;" );
				bImportStandard = true;
			}
			//  Skip further processing of standard imported types
			continue;
		}

		//  If this is a persistent property, write the import declaration
		if ( pbnpt->FPropType() & fPropPersist )
		{
			fprintf( _pfDsc, "\n\timport %s;", zsrName.Szc() );
			continue;
		}

		//  User-declared (private, non-persistent) property

		fprintf( _pfDsc, "\n\ttype %s = ", zsrName.Szc() );
		if ( pbnpt->FPropType() & fPropArray )
		{
			fprintf( _pfDsc, "%s %s ",
					SzcTokenMap(tokenArray),
					SzcTokenMap(tokenOf) );
		}
		if ( pbnpt->FPropType() & fPropChoice )
		{
			fprintf( _pfDsc, "%s %s \n\t\t[",
					SzcTokenMap(tokenWordChoice),
					SzcTokenMap(tokenOf) );
			int cc = pbnpt->VzsrChoice().size();
			for ( int ic = 0; ic < cc; ic++ )
			{
				fprintf( _pfDsc, "%s", pbnpt->VzsrChoice()[ic].Szc() );
				if ( ic+1 < cc )
					fprintf( _pfDsc, "," );
			}
			fprintf( _pfDsc, "]" );
		}
		else
		if ( pbnpt->FPropType() & fPropString )
		{
			fprintf( _pfDsc, "%s", SzcTokenMap(tokenWordString) );
		}
		else
		{
			fprintf( _pfDsc, "%s", SzcTokenMap(tokenWordReal) );
		}
		if ( pbnpt->ZsrComment().Zstr().length() > 0 )
		{
			fprintf( _pfDsc, ",\n\t\t\"%s\"",
					pbnpt->ZsrComment().Szc() );
		}
		fprintf( _pfDsc, ";" );
	}

	if ( cTypes )
	{
		PrintPropertyList( LtProp() );

		fprintf( _pfDsc, "\n}\n" );
	}
}


void MBNETDSC :: PrintNodes()
{
	MBNET::ITER mbnit( self, GOBJMBN::EBNO_NODE );
	GOBJMBN * pgmobj;
	GNODEMBN * pbnode;
	GNODEMBND * pbnoded;
	for ( ; pgmobj = *mbnit ; ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		DynCastThrow( pgmobj, pbnode );
		assert( zsrName == pbnode->ZsrefName() );

		fprintf( _pfDsc, "\n%s %s\n{",
				SzcTokenMap(tokenNode),
				pbnode->ZsrefName().Szc() );
		if ( pbnode->ZsFullName().length() > 0 )
		{
			fprintf( _pfDsc, "\n\t%s = \"%s\";",
					SzcTokenMap(tokenName),
					pbnode->ZsFullName().Szc() );
		}

		pbnoded = dynamic_cast<GNODEMBND *>(pbnode);
		ASSERT_THROW( pbnoded, EC_NYI, "only discrete nodes supported" )

		// Print the type and states using a domain, if given
		if ( pbnoded->ZsrDomain().Zstr().length() > 0 )
		{
			//  Explicit domain
			fprintf( _pfDsc, "\n\t%s = %s %s %s;",
					 SzcTokenMap(tokenType),
					 SzcTokenMap(tokenDiscrete),
					 SzcTokenMap(tokenDomain),
					 pbnoded->ZsrDomain().Szc() );
		}
		else
		{
			//  Variable-specific state enumeration
			int cState = pbnoded->CState();
			fprintf( _pfDsc, "\n\t%s = %s[%d]\n\t{",
					 SzcTokenMap(tokenType),
					 SzcTokenMap(tokenDiscrete),
					 cState );

			for ( int iState = 0; iState < cState; )
			{
				fprintf(_pfDsc, "\n\t\t\"%s\"",
						pbnoded->VzsrStates()[iState].Szc() );
				if ( ++iState < cState )
					fprintf( _pfDsc, "," );
			}
			fprintf( _pfDsc, "\n\t};\n" );
		}

		PTPOS pt = pbnode->PtPos();
		if ( pt._x != 0 || pt._y != 0 )
		{
			fprintf( _pfDsc, "\n\t%s = (%d, %d);",
					SzcTokenMap(tokenPosition),
					pt._x,
					pt._y );
		}

		PrintPropertyList( pbnode->LtProp() );

		fprintf( _pfDsc, "\n}\n");
	}
}

void MBNETDSC :: PrintPropertyList ( LTBNPROP & ltProp )
{
	for ( LTBNPROP::iterator ltit = ltProp.begin();
			ltit != ltProp.end();
			++ltit )
	{
		const PROPMBN & prop = *ltit;
		fprintf( _pfDsc, "\n\t%s = ",
				prop.ZsrPropType().Szc() );
		bool bArray = prop.FPropType() & fPropArray;
		if ( bArray )
			fprintf( _pfDsc, "[" );
		for ( int i = 0; i < prop.Count(); )
		{
			if ( prop.FPropType() & fPropChoice )
			{	
				GOBJMBN * pgmobj = Mpsymtbl().find( prop.ZsrPropType() );
				assert( pgmobj );
				GOBJPROPTYPE * pbnpt;
				DynCastThrow( pgmobj, pbnpt );
				fprintf( _pfDsc, "%s",
						 pbnpt->VzsrChoice()[(int) prop.Real(i)].Szc() );
			}
			else
			if ( prop.FPropType() & fPropString )
			{
				fprintf( _pfDsc, "\"%s\"",
						prop.Zsr(i).Szc() );
			}
			else
			{
				fprintf( _pfDsc, "%g",
						prop.Real(i) );
			}
			if ( ++i < prop.Count() )
				fprintf( _pfDsc, "," );
		}
		if ( bArray )
			fprintf( _pfDsc, "]" );
		fprintf( _pfDsc, ";" );
	}
}

//
//	Print network topology and probability distribution information for
//	all nodes.
//
//	Note that distributions are stored in the distribution map
//	most of the time.   However, during network expansion and inference
//	they are temporarly bound to their respective nodes (see 'BindDistributions').
//	For purposes of dumping the network at various stages, this logic
//	will print a bound distribution in preference to a mapped one.
//	If no distribution can be found, an error is generated as a comment into
//	the output file.
//
void MBNETDSC :: PrintTopologyAndDistributions()
{
	MBNET::ITER mbnit( self, GOBJMBN::EBNO_NODE );
	GOBJMBN * pgmobj;
	VTKNPD vtknpd;
	for ( ; pgmobj = *mbnit ; ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GNODEMBN * pbnode;
		DynCastThrow( pgmobj, pbnode );

		pbnode->GetVtknpd( vtknpd );

		GNODEMBND * pbnoded = dynamic_cast<GNODEMBND *>(pbnode);
		if ( pbnoded == NULL )
		{
			//  We don't have a clue as to how to print this node
			fprintf( _pfDsc,
					 "\n\n// Error: unable to print distribution for non-discrete node \'%s\'",
					 zsrName.Szc() );
			continue;
		}
		
		if ( pbnoded->BHasDist() )
		{
			//  This node already has a bound distribution
			//  Construct the token array describing the distribution
			ZSTR zsSig = vtknpd.ZstrSignature(1);
			fprintf( _pfDsc, "\n%s(%s)\t\n{",
					SzcTokenMap(tokenProbability),			
					zsSig.Szc() );
			PrintDistribution( *pbnoded, pbnoded->Bndist() );
			fprintf( _pfDsc,"\n}\n");
			continue;
		}

		//  Look the distribution up in the map
		//  Cons-up "p(<node>|"
		VTKNPD vtknpdNode;
		vtknpdNode.push_back( TKNPD(DTKN_PD) );
		vtknpdNode.push_back( TKNPD( pbnode->ZsrefName() ) );
		
		// Find the distribution(s) with that signature; print the first one
		int cFound = 0;
		for ( MPPD::iterator mppdit = Mppd().lower_bound( vtknpdNode );
			  mppdit != Mppd().end();
			  ++mppdit )
		{
			const VTKNPD & vtknpdMap = (*mppdit).first;
			if (   vtknpdMap.size() < 2
				|| vtknpdMap[0] != TKNPD(DTKN_PD)
				|| ! vtknpdMap[1].BStr() )
				break;
			SZC szcNode = vtknpdMap[1].Szc();
			if ( pbnode->ZsrefName().Szc() != szcNode )
				break;
			if ( cFound++ == 0 )
			{
				ZSTR zsTopol = vtknpdMap.ZstrSignature(1);
				fprintf( _pfDsc, "\n%s(%s)\t\n{",
						SzcTokenMap(tokenProbability),			
						zsTopol.Szc() );
				if ( vtknpd != vtknpdMap )
				{
					ZSTR zsSig = vtknpd.ZstrSignature();
					fprintf( _pfDsc,
							 "\n\n\t// Error: required distribution is %s",
							 zsSig.Szc() );
				}
				PrintDistribution( *pbnode, *(*mppdit).second );
				fprintf( _pfDsc,"\n}\n");
			}	
			else
			{
				ZSTR zsSig = vtknpd.ZstrSignature();
				fprintf( _pfDsc,
						 "\n\n// Warning: Superfluous distribution found for %s",
						 zsSig.Szc() );
			}
		}		

		if ( cFound > 0 )
			continue;

		//  Print a warning into the DSC output file
		ZSTR zsSigFull = vtknpd.ZstrSignature();
		fprintf( _pfDsc,
				 "\n\n// Error: Distribution missing for %s",
				 zsSigFull.Szc() );
		//  Construct the token array describing the distribution, but write
		//		it as empty.
		ZSTR zsSig = vtknpd.ZstrSignature(1);
		fprintf( _pfDsc, "\n%s(%s);",
				SzcTokenMap(tokenProbability),			
				zsSig.Szc() );
	}

	fflush( _pfDsc );
}

void MBNETDSC :: PrintDistribution ( GNODEMBN & gnode, BNDIST & bndist )
{
	BNDIST::EDIST edist = bndist.Edist();

	switch ( edist )
	{
		case BNDIST::ED_CI_MAX:
		case BNDIST::ED_CI_PLUS:
		{
			SZC szcFunc = SzcDist( edist );
			assert( szcFunc );
			fprintf( _pfDsc, "\n\tfunction = %s;", szcFunc );
			//  Fall through to handle as sparse
		}			
		case BNDIST::ED_SPARSE:
		{
			const MPCPDD & dmp = bndist.Mpcpdd();
			int cEntries = dmp.size();
			for ( MPCPDD::const_iterator dmit = dmp.begin();
				  dmit != dmp.end();
				  ++dmit)
			{
				const VIMD & vimd = (*dmit).first;
				const VLREAL & vr = (*dmit).second;
				fprintf( _pfDsc, "\n\t");
				if ( vimd.size() == 0 )
				{
					if ( cEntries > 1 )
						fprintf( _pfDsc, "%s = ", SzcTokenMap(tokenDefault) );
				}
				else
				{
					fprintf( _pfDsc, "(");
					for ( int i = 0; i < vimd.size() ; )
					{
						fprintf( _pfDsc, "%d", vimd[i] );
						if ( ++i < vimd.size() )
							fprintf( _pfDsc, ", " );
					}
					fprintf( _pfDsc, ") = ");
				}
				for ( int ir = 0; ir < vr.size(); )
				{					
					fprintf( _pfDsc, "%g", vr[ir] );
					if ( ++ir < vr.size() )
						fprintf( _pfDsc, ", " );
				}
				fprintf( _pfDsc, ";" );
			}
			break;
		}

		case BNDIST::ED_DENSE:
		{
			MDVCPD mdv = bndist.Mdvcpd();
			MDVCPD::Iterator itdd( mdv );
			int cDim = mdv.VimdDim().size();
			int cStates = mdv.VimdDim()[cDim -1];
			
			for ( int iState = 0; itdd.BNext(); iState++ )
			{
				const VIMD & vimd = itdd.Vitmd();
				if ( (iState % cStates) == 0 )
				{
					//  Start a new row
					fprintf( _pfDsc, "\n\t" );
					//  Prefix with parent instantations if necessary
					int cItems = vimd.size() - 1;
					if ( cItems )
					{
						fprintf( _pfDsc, "(" );
						for ( int i = 0; i < cItems ; )
						{
							fprintf( _pfDsc, "%d", vimd[i] );
							if ( ++i < cItems )
								fprintf( _pfDsc, ", " );
						}
						fprintf( _pfDsc, ") = ");
					}
				}
				REAL & r = itdd.Next();
				fprintf( _pfDsc, "%g%c ", r, ((iState+1) % cStates) ? ',' : ';'  );
			}

			break;
		}
		default:				
			THROW_ASSERT(EC_NYI, "PrintDistribution only implemented for sparse arrays");
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\margiter.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       margiter.h
//
//--------------------------------------------------------------------------

//
//	margiter.h: compiled marginals iterators
//

#ifndef _MARGITER_H_
#define _MARGITER_H_

/*
	This class is intended to be used in sepsets.  There will be two of them,
	one representing the parent clique and the sepset, the other representing
	the child clique and the sepset.  The sepset is the "subset" in both
	cases.

	A MARGSUBITER "compiles" the subscripts from the iteration of the subset
	marginal into an array of integers.  Iteration using this array is much
	faster than performing full array stride multiplication and summation.
	The cost is the additional memory to contain the offsets in each sepset,
	which is roughly:

		sizeof(int) * (	  (# of entries in child clique)
						+ (# of entries in parent clique))
*/

#include <list>

//  Class VMARGSUB: a reference counted array of subscripts
class VMARGSUB : public VINT, public REFCNT
{
  public:
	VMARGSUB ( MARGINALS::Iterator & itMarg );
	~ VMARGSUB ();
	void NoRef ();
	int ISearchPass () const
		{ return _iSearchPass; }
	int & ISearchPass ()
		{ return _iSearchPass; }

	LEAK_VAR_ACCESSOR

  protected:
	int _iSearchPass;

	LEAK_VAR_DECL

	HIDE_UNSAFE(VMARGSUB);
};

//  Class MARGSUBREF: a reference (via pointer) to a VMARGSUB
//		and an applicable length.  This class exists so that
//		when a new, longer, superset subscript array (VMARGSUB)
//		is added to the ensemble, all older references to smaller
//		VMARGSUBs can be converted to reference the new, larger
//		VMARGSUB and the older one discarded.
//
class MARGSUBREF : public REFCNT
{
  public:
	MARGSUBREF ( VMARGSUB * pvmsub = NULL, int cSize = -1 );
	~ MARGSUBREF ();
	MARGSUBREF ( const MARGSUBREF & msubr );
	MARGSUBREF & operator = ( const MARGSUBREF & msubr );

	//  Set the array
	void SetVmsub ( VMARGSUB * pvmsub, int cSize = -1 );

	//  Return iteration information
	VINT & VintSub ()
	{
		assert( _pvmsub );
		return *_pvmsub;
	}
	VMARGSUB & Vmsub ()
	{
		assert( _pvmsub );
		return *_pvmsub;
	}
	VMARGSUB * Pvmsub ()
	{
		assert( _pvmsub );
		return _pvmsub;
	}
	int CSize() const
		{ return _cSize ; }

	DECLARE_ORDERING_OPERATORS(MARGSUBREF);
	LEAK_VAR_ACCESSOR

  protected:
	VMARGSUB * _pvmsub;			//  Pointer to array of subscripts
	int _cSize;					//	Applicable length

	LEAK_VAR_DECL
};

typedef list<MARGSUBREF> LTMSUBR;

//  A wrapper for a linked list of MARGSUBREFs.
//	There is one global instance of this.
class LTMARGSUBREF
{
  public:
	LTMARGSUBREF ();
	MARGSUBREF * PmsubrAdd ( MARGINALS::Iterator & itMarg );
	void Release ( MARGSUBREF * pmsubr );
	void Dump ();

  protected:
	LTMSUBR _ltmsubr;

	int _iSearchPass;
	int _cArrays;
	size_t _cArrayTotalSize;
	int _cSubRefs;
};


class MARGSUBITER	//  Marginals Subset Iterator
{
  public:
	MARGSUBITER ();
	~ MARGSUBITER () ;
	bool BBuilt () const
		{ return _pmsubr != NULL; }
	//  Build the iterator for two cliques
	void Build ( MARGINALS & margSelf, MARGINALS & margSubset );
	//	Build the iterator for a clique and a node
	void Build ( MARGINALS & margSelf, GNODEMBND * pgndd );
	//  Marginalize the superset to the subset (subset changed)
	inline void MarginalizeInto ( MDVCPD & mdvSubset );
	//  Marginalize the superset to a node's UPD
	inline void MarginalizeBelief ( MDVCPD & mdvBel, GNODEMBND * pgndd );
	//  Multiply the superset by the subset (superset changed)
	inline void MultiplyBy ( MARGINALS & margSubset );
	//  Verify subscripts
	void Test ( MARGINALS & margSubset );
	
	static void Dump ()
		{ _ltmargsubr.Dump();  }

  protected:
	MARGINALS * _pmargSelf;
	MARGSUBREF * _pmsubr;

	static LTMARGSUBREF _ltmargsubr;
};

inline
void MARGSUBITER :: MarginalizeInto ( MDVCPD & mdvSubset )
{
	assert( _pmsubr && _pmargSelf );
	mdvSubset.Clear();

	VINT & visub = _pmsubr->VintSub();
	int cEnd = _pmsubr->CSize();
	const int * pisub = & visub[0];
	// Note: this funny reference is due to BoundsChecker complaining that I'm accessing memory
	//   beyond the end of the array.  I'm not, but it doesn't complain about this
	const int * pisubMax = & visub[0] + cEnd;
	double * pvlSubset = & mdvSubset.first[0];
	double * pvlSelf = & _pmargSelf->first[0];
	while ( pisub != pisubMax )
	{
		pvlSubset[*pisub++] += *pvlSelf++;
	}
}

inline
void MARGSUBITER :: MultiplyBy ( MARGINALS & margSubset )
{
	assert( _pmsubr && _pmargSelf );
	VINT & visub = _pmsubr->VintSub();
	int cEnd = _pmsubr->CSize();
	const int * pisub = & visub[0];
	// Note: See note above about funny subscripting
	const int * pisubMax = & visub[0] + cEnd;
	double * pvlSubset = & margSubset.first[0];
	double * pvlSelf = & _pmargSelf->first[0];
	while ( pisub != pisubMax )
	{
		*pvlSelf++ *= pvlSubset[*pisub++];
	}
}

//  Marginalize the superset to a node's UPD
inline
void MARGSUBITER :: MarginalizeBelief ( MDVCPD & mdvBel, GNODEMBND * pgndd )
{
	MARGINALS::ResizeDistribution( pgndd, mdvBel );

	MarginalizeInto( mdvBel );

	mdvBel.Normalize();
}

#endif  // _MARGITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\mbnet.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mbnet.cpp
//
//--------------------------------------------------------------------------

//
//	mbnet.cpp:  Belief network model member functions
//

#include <basetsd.h>
#include "basics.h"
#include "algos.h"
#include "gmprop.h"
#include "gmobj.h"
#include "cliqset.h"
#include "clique.h"
#include "expand.h"

MBNET :: MBNET ()
	:_inmFree(0),
	_iInferEngID(0)
{
}



MBNET :: ~ MBNET ()
{
	PopModifierStack( true );	//  Clear all modifiers from the network

	//  Clear the node-index-to-name information
	_inmFree = 0;
	_vzsrNames.clear();
}

//
//  Clone this belief network from another.  Note that the contents
//  of the modifier stack (inference engines, expanders, etc.) are
//	NOT cloned.
//
void MBNET :: Clone ( MODEL & model )
{
	//  This must be a truly empty structure
	ASSERT_THROW( _vpModifiers.size() == 0 && _vzsrNames.size() == 0,
				 EC_INVALID_CLONE,
				 "cannot clone into non-empty structure" );

	MODEL::Clone( model );
	MBNET * pmbnet;
	DynCastThrow( & model, pmbnet );
	MBNET & mbnet = *pmbnet;

	{
		// Build the name table by iterating over the contents and
		//		allocating a slot for each node
		GELEMLNK * pgelm;
		MODELENUM mdlenumNode( mbnet );
		while ( pgelm = mdlenumNode.PlnkelNext() )
		{	
			//  Check that it's a node (not an edge)
			if ( ! pgelm->BIsEType( GELEM::EGELM_NODE ) )
				continue;
			GOBJMBN * pgobjmbn;
			DynCastThrow( pgelm, pgobjmbn );
			_vzsrNames.push_back( pgobjmbn->ZsrefName() );
		}
		_inmFree = _vzsrNames.size();
	}

	//  Clone the distribution map
	_mppd.Clone( _mpsymtbl, mbnet._mppd ) ;

	//  Check the topology if it's supposed to be present
#ifdef _DEBUG
	if ( mbnet.BFlag( EIBF_Topology ) )
		VerifyTopology();
#endif
}

//
//	Iterate over the distributions, matching them to the nodes they belong to.
//
void MBNET :: VerifyTopology ()
{
	for ( MPPD::iterator itpd = Mppd().begin();
		  itpd != Mppd().end();
		  itpd++ )
	{
		const VTKNPD & vtknpd = (*itpd).first;
		const BNDIST * pbndist = (*itpd).second;

		// Guarantee that the descriptor is of the form "p(X|...)"
		if (   vtknpd.size() < 2
			|| vtknpd[0] != TKNPD(DTKN_PD)
			|| ! vtknpd[1].BStr() )
			throw GMException( EC_INV_PD, "invalid token descriptor on PD");

		// Get the name of the node whose distribution this is
		SZC szc = vtknpd[1].Szc();
		assert( szc ) ;
		// Find that named thing in the graph
		GOBJMBN * pbnobj = Mpsymtbl().find( szc );
		assert( pbnobj && pbnobj->EType() == GOBJMBN::EBNO_NODE );

		// Guarantee that it's a node
		GNODEMBN * pgndbn = dynamic_cast<GNODEMBN *> (pbnobj);
		ASSERT_THROW( pgndbn, EC_INV_PD, "token on PD references non-node");

		//  Verify the node's distribution
		if ( ! pgndbn->BMatchTopology( *this, vtknpd ) )
		{
			throw GMException( EC_TOPOLOGY_MISMATCH,
								"topology mismatch between PD and network");
		}
	}
}

MBNET_MODIFIER * MBNET :: PModifierStackTop ()
{
	return _vpModifiers.size() > 0
		 ? _vpModifiers[ _vpModifiers.size() - 1 ]
		 : NULL;
}

void MBNET :: PushModifierStack ( MBNET_MODIFIER * pmodf )
{
	assert( pmodf );
	pmodf->Create();
	_vpModifiers.push_back( pmodf );
}

void MBNET :: PopModifierStack ( bool bAll )
{
	int iPop = _vpModifiers.size();
	while ( iPop > 0 )
	{
		MBNET_MODIFIER * pmodf = _vpModifiers[ --iPop ];
		assert ( pmodf );
		//  NOTE:  Deleting the object should be all that's necessary;
		//		object's destructor should call its Destroy() function.
		delete pmodf;
		if ( ! bAll )
			break;
	}
	if ( iPop == 0 )
		_vpModifiers.clear();
	else
		_vpModifiers.resize(iPop);
}

//  Find the named object by index
GOBJMBN * MBNET :: PgobjFindByIndex ( int inm )
{
	ZSREF zsMt;
	if (   inm >= _vzsrNames.size()
		|| _vzsrNames[inm] == zsMt )
		return NULL;
	return Mpsymtbl().find( _vzsrNames[inm] );	
}

int MBNET :: INameIndex ( ZSREF zsr )
{
	return ifind( _vzsrNames, zsr );
}

int MBNET :: INameIndex ( const GOBJMBN * pgobj )
{
	return INameIndex( pgobj->ZsrefName() );
}

int MBNET :: CreateNameIndex ( const GOBJMBN * pgobj )
{
	int ind = -1;
	if ( _inmFree >= _vzsrNames.size() )
	{	
		// No free slots; grow the array
		ind = _vzsrNames.size();
		_vzsrNames.push_back( pgobj->ZsrefName() );		
		_inmFree = _vzsrNames.size();
	}
	else
	{
		// Use the given free slot, find the next
		_vzsrNames[ind = _inmFree] = pgobj->ZsrefName();
		ZSREF zsMt;
		for ( ; _inmFree < _vzsrNames.size() ; _inmFree++ )
		{
			if ( zsMt == _vzsrNames[_inmFree] )
				break;
		}
	}
	return ind;
}

void MBNET :: DeleteNameIndex ( int inm )
{
	ASSERT_THROW( inm < _vzsrNames.size(),
				  EC_INTERNAL_ERROR,
				  "MBNET name index out of range" );

	_vzsrNames[inm] = ZSREF();
	if ( inm < _inmFree )
		_inmFree = inm;
}

void MBNET :: DeleteNameIndex ( const GOBJMBN * pgobj )
{
	int inm = INameIndex( pgobj );
	if ( inm >= 0 )
		DeleteNameIndex(inm);
}


//	Add a named object to the graph and symbol table
void MBNET :: AddElem ( SZC szcName, GOBJMBN * pgelm )
{
	if ( szcName == NULL || ::strlen(szcName) == 0 )
	{
		MODEL::AddElem( pgelm );	// empty name
	}
	else
	{
		MODEL::AddElem( szcName, pgelm );
		assert( INameIndex( pgelm ) < 0 );	// guarantee no duplicates
		CreateNameIndex( pgelm );
	}
}

void MBNET :: DeleteElem ( GOBJMBN * pgobj )
{
	DeleteNameIndex( pgobj );
	MODEL::DeleteElem( pgobj );
}

/*

	Iterator has moved into the MODEL class... I've left the code here
	in case MBNET needs its own iterator. (Max, 05/12/97)

MBNET::ITER :: ITER ( MBNET & bnet, GOBJMBN::EBNOBJ eType )
	: _eType(eType),
	_bnet(bnet)
{
	Reset();
}

void MBNET::ITER :: Reset ()
{
	_pCurrent = NULL;
	_itsym = _bnet.Mpsymtbl().begin();
	BNext();
}

bool MBNET::ITER :: BNext ()
{
	while ( _itsym != _bnet.Mpsymtbl().end() )
	{
		_pCurrent = (*_itsym).second.Pobj();
		_zsrCurrent = (*_itsym).first;
		_itsym++;
		if ( _pCurrent->EType() == _eType )
			return true;
	}		
	_pCurrent = NULL;
	return false;
}

*/


void MBNET :: CreateTopology ()
{
	if ( BFlag( EIBF_Topology ) )
		return;

	//  Walk the map of distributions.  For each one, extract the node
	//  name and find it.  Then add arcs for each parent.

#ifdef _DEBUG
	UINT iCycleMax = 2;
#else
	UINT iCycleMax = 1;
#endif
	UINT iIter = 0;
	for ( UINT iCycle = 0 ; iCycle < iCycleMax ; iCycle++ )
	{
		for ( MPPD::iterator itpd = Mppd().begin();
			  itpd != Mppd().end();
			  itpd++, iIter++ )
		{
			const VTKNPD & vtknpd = (*itpd).first;
			const BNDIST * pbndist = (*itpd).second;
			// Guarantee that the descriptor is of the form "p(X|...)"
			if (   vtknpd.size() < 2
				|| vtknpd[0] != TKNPD(DTKN_PD)
				|| ! vtknpd[1].BStr() )
				throw GMException( EC_INV_PD, "invalid token descriptor on PD");

			// Get the name of the node whose distribution this is
			SZC szcChild = vtknpd[1].Szc();
			assert( szcChild ) ;
			// Find that named thing in the graph
			GOBJMBN * pbnobjChild = Mpsymtbl().find( szcChild );
			assert( pbnobjChild && pbnobjChild->EType() == GOBJMBN::EBNO_NODE );
			// Guarantee that it's a node
			GNODEMBN * pgndbnChild = dynamic_cast<GNODEMBN *> (pbnobjChild);
			ASSERT_THROW( pgndbnChild, EC_INV_PD, "token on PD references non-node");

			UINT cParents = 0;
			UINT cChildren = pgndbnChild->CChild();
			for ( int i = 2; i < vtknpd.size(); i++ )
			{
				if ( ! vtknpd[i].BStr() )
					continue;
				SZC szcParent = vtknpd[i].Szc();
				assert( szcParent) ;
				GOBJMBN * pbnobjParent = Mpsymtbl().find( szcParent );
				assert( pbnobjParent && pbnobjParent->EType() == GOBJMBN::EBNO_NODE );
				GNODEMBN * pgndbnParent = (GNODEMBN *) pbnobjParent;
				UINT cPrChildren = pgndbnParent->CChild();
				if ( iCycle == 0 )
				{
					AddElem( new GEDGEMBN_PROB( pgndbnParent, pgndbnChild ) );
				}

				cParents++;

				if ( iCycle == 0 )
				{
					UINT cChNew = pgndbnChild->CChild();
					UINT cPrNew = pgndbnChild->CParent();
					UINT cPrChNew = pgndbnParent->CChild();
					assert( cPrChNew = cPrChildren + 1 );
					assert( cChildren == cChNew );
				}
			}
			if ( iCycle )
			{
				UINT cPrNew = pgndbnChild->CParent();
				assert( cParents == cPrNew );
			}

			if ( iCycle == 0 )
			{
#ifdef _DEBUG
				if ( ! pgndbnChild->BMatchTopology( *this, vtknpd ) )
				{
					throw GMException( EC_TOPOLOGY_MISMATCH,
										"topology mismatch between PD and network");
				}
#endif
			}
		}
	}

	BSetBFlag( EIBF_Topology );
}

DEFINEVP(GEDGEMBN);

void MBNET :: DestroyTopology ( bool bDirectedOnly )
{
	// Size up an array to hold pointers to all the edges
	VPGEDGEMBN vpgedge;
	int cItem = Grph().Chn().Count();
	vpgedge.resize(cItem);

	//  Find all the arcs/edges
	int iItem = 0;
	GELEMLNK * pgelm;
	MODELENUM mdlenum( self );
	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		//  Check that it's an edge
		if ( ! pgelm->BIsEType( GELEM::EGELM_EDGE ) )
			continue;
			//  Check that it's a directed probabilistic arc
		if ( bDirectedOnly && pgelm->EType() != GEDGEMBN::ETPROB )
			continue;
		GEDGEMBN * pgedge;
		DynCastThrow( pgelm, pgedge );
		vpgedge[iItem++] = pgedge;				
	}

	//  Delete all the accumulated edges
	for ( int i = 0; i < iItem; )
	{
		GEDGEMBN * pgedge = vpgedge[i++];
		delete pgedge;
	}

	assert( Grph().Chn().Count() + iItem == cItem );

	BSetBFlag( EIBF_Topology, false );
}

//
//	Bind distributions to nodes.  If they're already bound, exit.
//	If the node has a distribution already, leave it.
//
void MBNET :: BindDistributions ( bool bBind )
{
	bool bDist = BFlag( EIBF_Distributions );
	if ( ! (bDist ^ bBind) )
		return;

	ITER itnd( self, GOBJMBN::EBNO_NODE );
	for ( ; *itnd ; itnd++ )
	{
		GNODEMBND * pgndd = dynamic_cast<GNODEMBND *>(*itnd);
		if ( pgndd == NULL )
			continue;

		if ( ! bBind )
		{
			pgndd->ClearDist();
		}
		else
		if ( ! pgndd->BHasDist() )
		{
			pgndd->SetDist( self );				
		}
	}
	BSetBFlag( EIBF_Distributions, bBind );
}

void MBNET :: ClearNodeMarks ()
{
	ITER itnd( self, GOBJMBN::EBNO_NODE );
	for ( ; *itnd ; itnd++ )
	{
		GNODEMBN * pgndbn = NULL;
		DynCastThrow( *itnd, pgndbn );
		pgndbn->IMark() = 0;
	}
}

void MBNET :: TopSortNodes ()
{
	ClearNodeMarks();

	ITER itnd( self, GOBJMBN::EBNO_NODE );
	for ( ; *itnd ; itnd++ )
	{
		GNODEMBN * pgndbn = NULL;
		DynCastThrow( *itnd, pgndbn );
		pgndbn->Visit();
	}

	itnd.Reset();
	for ( ; *itnd ; itnd++ )
	{
		GNODEMBN * pgndbn = NULL;
		DynCastThrow( *itnd, pgndbn );
		pgndbn->ITopLevel() = pgndbn->IMark();
	}
}

void MBNET :: Dump ()
{
	TopSortNodes();

	UINT iEntry = 0;
	for ( MPSYMTBL::iterator itsym = Mpsymtbl().begin();
		  itsym != Mpsymtbl().end();
		  itsym++ )
	{
		GOBJMBN * pbnobj = (*itsym).second.Pobj();
		if ( pbnobj->EType() != GOBJMBN::EBNO_NODE )
			continue;	// It's not a node

		GNODEMBN * pgndbn;
		DynCastThrow(pbnobj,pgndbn);
		int iNode = INameIndex( pbnobj );
		assert( iNode == INameIndex( pbnobj->ZsrefName() ) );
		cout << "\n\tEntry "
			  << iEntry++
			  << ", inode "
			  << iNode
			  << " ";
		pgndbn->Dump();
	}
}

GOBJMBN_INFER_ENGINE * MBNET :: PInferEngine ()
{
	GOBJMBN_INFER_ENGINE * pInferEng = NULL;
	for ( int iMod = _vpModifiers.size(); --iMod >= 0; )
	{
		MBNET_MODIFIER * pmodf = _vpModifiers[iMod];
		pInferEng = dynamic_cast<GOBJMBN_INFER_ENGINE *> ( pmodf );
		if ( pInferEng )	
			break;
	}	
	return pInferEng;
}

void MBNET :: ExpandCI ()
{
	PushModifierStack( new GOBJMBN_MBNET_EXPANDER( self ) );
}

void MBNET :: UnexpandCI ()
{
	MBNET_MODIFIER * pmodf = PModifierStackTop();
	if ( pmodf == NULL )
		return;
	if ( pmodf->EType() == GOBJMBN::EBNO_MBNET_EXPANDER )
		PopModifierStack();
}

//  Return true if an edge is allowed between these two nodes
bool MBNET :: BAcyclicEdge ( GNODEMBN * pgndSource, GNODEMBN * pgndSink )
{
	ClearNodeMarks();
	pgndSink->Visit( false );
	return pgndSource->IMark() == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\mddist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mddist.cpp
//
//--------------------------------------------------------------------------

//
//	MDDIST.CPP
//

#include <basetsd.h>
#include <iostream>
#include <fstream>

#include "symtmbn.h"

LEAK_VAR_DEF(BNDIST)

static void dumpVimd ( const VIMD & vimd )
{
	for ( int i = 0 ; i < vimd.size(); i++ )
	{
		cout << vimd[i];
		if ( i + 1 < vimd.size() )
			cout << ",";
	}	
}

static void dumpVlr ( const VLREAL & vlr )
{
	for ( int i = 0 ; i < vlr.size(); i++ )
	{
		cout << vlr[i];
		if ( i + 1 < vlr.size() )
			cout << ",";
	}	
}

static void dumpSlice ( const MDVSLICE & mslice, bool bStrides = true)
{
	VIMD vimdLengths = mslice.size();
	VIMD vimdStrides = mslice.stride();
	size_t iStart = mslice.start();

	cout << "\nslice start="
		 << iStart
		 << "\tlengths=";
	dumpVimd( vimdLengths );
	if ( bStrides )
	{
		cout << "\tstrides=" ;
		dumpVimd( vimdStrides );
	}
	cout << "\ttotlen="
		 << mslice._Totlen();
}

static void dumpMdv ( DISTDD & mdv, const MDVSLICE * pslice = NULL )
{	
	if ( pslice == NULL )
		pslice = & mdv.Slice();
	dumpSlice( *pslice );
	DISTDD::Iterator itmd(mdv, *pslice );
	while (itmd.BNext())
	{
		size_t icurr = itmd.ICurr();
		cout << "\n";
		dumpVimd( itmd.Vitmd() );
		REAL & r = itmd.Next();
		cout << "\t["
			<< icurr
			<< "] = "
			<< r ;
	}
	cout << "\n";
}

BNDIST :: BNDIST ()
	:_edist(ED_NONE),
	_pmvd(NULL),
	_pdrmap(NULL)
{
	LEAK_VAR_UPD(1)
}

BNDIST :: ~ BNDIST ()
{
	Clear();
	LEAK_VAR_UPD(-1)
}

void BNDIST :: NoRef ()
{
	delete this;
}

BNDIST & BNDIST :: operator = ( const BNDIST & bnd )
{
	Clear();
	switch ( _edist = bnd._edist )
	{
		default:
		case ED_NONE:
			break;
		case ED_DENSE:
			_pmvd = new DISTDD( bnd.Mvd() );
			assert( _pmvd->first.size() == bnd.Mvd().first.size() );
			break;
		case ED_CI_MAX:
		case ED_CI_PLUS:
		case ED_SPARSE:
			_pdrmap = new DISTMAP( bnd.Distmap() ) ;
			assert( _pdrmap->size() == bnd.Distmap().size() );
			break;			
	}
	return self;
}

BNDIST :: BNDIST ( const BNDIST & bnd )
	:_edist(ED_NONE),
	_pmvd(NULL),
	_pdrmap(NULL)
{
	(*this) = bnd;

	LEAK_VAR_UPD(1)
}

bool BNDIST :: BChangeSubtype ( EDIST edist )
{
	if ( BDenseType(edist) ^ BDense() )
		return false;
	_edist = edist;
	return true;
}

void BNDIST :: Dump ()
{
	if ( _pmvd )
	{
		cout << "\n\tDense version:";
		DumpDense();
	}
	if ( _pdrmap )
	{
		cout << "\n\tSparse version:";
		DumpSparse();
	}
	cout << "\n\n";
}

void BNDIST :: DumpSparse ()
{
	assert( _pdrmap );
	DISTMAP & dmap = *_pdrmap;
	int i = 0;
	for ( DISTMAP::iterator itdm = dmap.begin();
		  itdm != dmap.end();
		  ++itdm, ++i )
	{
		const VIMD & vimd = (*itdm).first;
		const VLREAL & vlr = (*itdm).second;
		cout << "\n["
			 << i
			 << "] (";
		dumpVimd(vimd);
		cout << ")\t";
		dumpVlr(vlr);
	}
}

void BNDIST :: DumpDense ()
{
	assert( _pmvd );
	dumpMdv( *_pmvd );
}

void BNDIST :: ConvertToDense ( const VIMD & vimd )
{
	assert( _edist == ED_NONE || _edist == ED_SPARSE );

	if ( _edist == ED_NONE )
	{
		assert( ! _pdrmap );
		return;
	}
	//  See if there is a sparse distribution to convert
	if ( ! _pdrmap )
		throw GMException( EC_DIST_MISUSE, "no prior sparse distribution to convert" );

	int cParent = vimd.size() - 1;
	int cState = vimd[cParent];
	DISTMAP & dmap = *_pdrmap;
	VIMD vimdMt;					//  Empty subscript array
	VLREAL vlrDefault(cState);		//	Default value array

	//  First, try to find the default entry; use -1 if not found
	DISTMAP::iterator itdm = dmap.find(vimdMt);
	if ( itdm != dmap.end() )
		vlrDefault = (*itdm).second;
	else
		vlrDefault = -1;	// fill the array with -1.

	assert( vlrDefault.size() == cState );

	//  Allocate the new dense m-d array
	delete _pmvd;
	_pmvd = new DISTDD( vimd );
	DISTDD & mdv = *_pmvd;
	//  Fill each DPI with the appropriate default value
	DISTDD::Iterator itmdv(mdv);
	for ( int iState = 0; itmdv.BNext() ; iState++ )
	{
		itmdv.Next() = vlrDefault[ iState % cState ];
	}
	
	//
	//  Now, iterate over the sparse array and store in the appropriate locations.
	//	Each entry in the sparse map is a complete state set for the target node.
	//  Since the child (target) node probabilities are the fastest varying subscript,
	//  each entry in sparse map is spread across "cState" entries in the dense map.
	//	
	//	Of course, this could be more efficient, but we're just testing for now.
	//
	VIMD vimdDense(vimd.size());
	for ( itdm = dmap.begin(); itdm != dmap.end() ; ++itdm )
	{
		const VIMD & vimdSub = (*itdm).first;
		VLREAL & vlrNext = (*itdm).second;
		for ( int ip = 0 ; ip < cParent; ip++ )
		{
			vimdDense[ip] = vimdSub[ip];
		}
		for ( int ist = 0 ; ist < cState; ++ist )
		{
			vimdDense[cParent] = ist;
			mdv[vimdDense] = vlrNext[ist];
		}
	}
	
	//  Finally, nuke the old sparse distribution
	delete _pdrmap;
	_pdrmap = NULL;
	//  Set distribution type
	_edist = ED_DENSE;
}

//  Set distribution to "dense"
void BNDIST :: SetDense ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_pmvd = new DISTDD( vimd );
	_edist = ED_DENSE;
}

//  Set distribution to sparse
void BNDIST :: SetSparse ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_pdrmap = new DISTMAP;
	_edist = ED_SPARSE;
}

//  Return the "leak" or "default" vector from a sparse distribution
VLREAL * BNDIST :: PVlrLeak ()
{
	assert( BSparse() );
	const DISTMAP & dmap = Distmap();
	const VIMD & vimdDim = VimdDim();
	VIMD vimdLeak;

	//  First try to find the dimensionless "default" vector.
	VLREAL * pvlrDefault = NULL;
	DISTMAP::iterator itdm = dmap.find( vimdLeak );
	if ( itdm != dmap.end() )
		pvlrDefault = & (*itdm).second;

	//  Now try to find a specific zeroth vector; note that valarray<T>::resize
	//		stores all zeroes into the valarray by default.  Also, skip the
	//		loweest dimension, since that's the size of each vector in the
	//		sparse map.
	vimdLeak.resize( vimdDim.size() - 1 );	
	VLREAL * pvlrLeak = NULL;
	itdm = dmap.find( vimdLeak );
	if ( itdm != dmap.end() )
		pvlrLeak = & (*itdm).second;

	return pvlrLeak
		 ? pvlrLeak
		 : pvlrDefault;
}

void BNDIST :: Clone ( const BNDIST & bndist )
{
	ASSERT_THROW( _edist == ED_NONE,
			EC_INVALID_CLONE,
			"cannot clone into non-empty structure" );
	self = bndist;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\mbnmod.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mbnmod.cpp
//
//--------------------------------------------------------------------------

#include <basetsd.h>
#include "gmobj.h"
#include "cliqset.h"


void MBNET :: CreateInferEngine ( REAL rEstimatedMaximumSize )
{
	DestroyInferEngine();

	ExpandCI();

	//  Create the clique tree set object, push it onto the modifier stack
	//		and activate it
	PushModifierStack( new GOBJMBN_CLIQSET( self, rEstimatedMaximumSize, _iInferEngID++ ) );
}

void MBNET :: DestroyInferEngine ()
{
	MBNET_MODIFIER * pmodf = PModifierStackTop();
	if ( pmodf == NULL )
		return;
	if ( pmodf->EType() != GOBJMBN::EBNO_CLIQUE_SET )	
		return;

	PopModifierStack();

	UnexpandCI();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\mdvect.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mdvect.h
//
//--------------------------------------------------------------------------

//
//  mdvect.h:  multi-dimensional array handling
//
#ifndef _MDVECT_H_
#define _MDVECT_H_

/*
	Multidimensional array classes and templates.

	Each array carries the dimensionality of each dimension as a short integer;
	the signed value is reinterpreted for projections and redimensioning.

	Note that giving a subscript array (VIMD) whose length is less than the
	dimensionality of the target array produces a subscript with lower dimensions
	assumed to be equal to zero.  This is useful for indexing to lowest-dimensioned
	rows for probability tables.


	Types used (see basics.h):

			REAL		is a double
			VLREAL		is valarray<REAL>
			IMD			is an unsigned index into a multi-dimensional array
			VIMD		is a vector of IMD
			SIMD		is a signed index into a multi-dimensional array;
							it's used for projecting dimensions out
			VSIMD		is a vector of SIMD

	An MDVSLICE is dimensionality and iteration information for an m-d vector or maxtrix.

	The template TMDVDENSE defines a generic multi-dimensional array which a pair of
	elements:
	
			'first'		is a flat (1-d) valarray of an unspecified type (e.g., REAL)
			'second'	is an MDVSLICE describing its dimensionality

	The nested class TMDVDENSE::Iterator (note the capital 'I') is the smart iterator
	for classes derived from TMDVDENSE<>.
	
*/

#include <stdarg.h>
#include "algos.h"

typedef valarray<REAL> VLREAL;

//  'valarray' comparison templates
template<class _V>
struct lessv : binary_function<_V, _V, bool>
{
	bool operator()(const _V & vra, const _V & vrb) const
	{
		int cmin = _cpp_min( vra.size(), vrb.size() );
		for ( int i = 0 ; i < cmin ; i++ )
		{
			if ( vra[i] < vrb[i] )
				return true;
			if ( vra[i] > vrb[i] )
				return false;
		}
		return vra.size() < vrb.size();
	}
};

/////////////////////////////////////////////////////////////////////////////////
//  Class MDVSLICE:
//		Similar to 'gslice'.  Has gslice converter (see 'valarray' header).
//		Contains integer array of lengths, array of strides
//		and starting point.
/////////////////////////////////////////////////////////////////////////////////
class MDVSLICE
{
  public:
	//  Construct a slice from complete data (like gslice)
	MDVSLICE ( size_t _S,
			   const VIMD & _L,
			   const VIMD & _D)
		: _Start(_S),
		_Len(_L),
		_Stride(_D)
		{}

	//  Construct a slice given only the dimensions
	MDVSLICE ( const VIMD & _L, size_t _S = 0 )
	{
		Init( _L, _S );
	}
	MDVSLICE ( int cdim, int ibound, ... )
		: _Start(0)
	{
		va_list vl;
		va_start( vl, cdim );
		Init( cdim, vl );
	}

	MDVSLICE ( const VSIMD & vsimd, size_t _S = 0 )
	{
		Init( vsimd, _S );
	}

	bool operator == ( const MDVSLICE & sl ) const
	{
		return _Start == sl._Start
			 && vequal(_Len,sl._Len)
			 && vequal(_Stride,sl._Stride);
	}
	bool operator != ( const MDVSLICE & sl ) const
	{
		return !(*this == sl);
	}

	//  Provided for compatibility with gslice
	MDVSLICE()
		: _Start(0) {}

	//  Return an equivalent gslice for use with other 'valarray' operations
	gslice Gslice () const;

	void Init ( const VIMD & _L, size_t _S = 0 )
	{
		_Start = _S;
		_Len = _L;
		StrideFromLength();
	}

	void Init ( const VSIMD & vsimd, size_t _S = 0 )
	{
		int cd = vsimd.size();
		vbool vboolMissing(cd);
		_Len.resize(cd);
		_Start = _S;
		for ( int i = 0; i < cd; i++ )
		{
			SIMD simd = vsimd[i];
			if ( vboolMissing[i] = simd < 0 )
				_Len[i] = - simd;
			else
				_Len[i] = simd;
		}
		StrideFromLength( & vboolMissing );
	}

	void Init ( int cdim, ... )
	{
		va_list vl;
		va_start( vl, cdim );
		Init( cdim, vl );
	}

	void Init ( int cdim, va_list & vl )
	{
		_Len.resize(cdim);
		for ( int idim = 0; idim < cdim; idim++ )
		{
			_Len[idim] = va_arg(vl,int);	
		}
		StrideFromLength();
	}

	/********************************************************
	*  Accessors to internal data
	*********************************************************/
	size_t start() const
		{return _Start; }
	const VIMD & size() const
		{return _Len; }
	const VIMD & stride() const
		{return _Stride; }
	//  Return the number of dimensions
	size_t _Nslice() const
		{ return _Len.size(); }

	//  Return the total number of elements according to this slice
	size_t _Totlen() const
	{
		size_t _L = _Len.size() > 0;
		if ( _L )			
		{
			for (size_t _I = 0; _I < _Len.size(); ++_I )
			{
				if ( _Len[_I] )
					_L *= _Len[_I];
			}
		}
		return _L;
	}

	/********************************************************
	*	Subscript handling.  There are two levels, one leaves
	*	the subscript array unchanged, the other updates it.
	*   There is a set of overloads for these which allow
	*	reordering of dimensions.
	*********************************************************/

	//  Return the index offset based upon the subscript array given
	size_t _IOff ( const VIMD& _Idx ) const
	{
		size_t _K = _Start;
		for (size_t _I = 0; _I < _Idx.size(); ++_I)
			_K += _Idx[_I] * _Stride[_I];
		return _K;
	}
	//  Return the index offset based upon the varargs array given
	size_t _IOff ( int i, ...  ) const
	{
		va_list vl;
		va_start( vl, i );
		return _IOff( i, vl );
	}
	size_t _IOff ( int i, va_list & vl ) const
	{
		size_t ioff = _Start;
		int j;
		for ( j = 0; j < _Len.size() && i >= 0 ; ++j )
		{
			ioff += i * _Stride[j];
			i = va_arg(vl,int);
		}
		return j == _Len.size() ? ioff : -1;
	}
	//  Bump the subscript array to its next valid index
	void _Upd (VIMD & _Idx) const
	{
		for (size_t _I = _Len.size(); 0 < _I--;)
		{
			if (++_Idx[_I] < _Len[_I])
				break;
			_Idx[_I] = 0;
		}
	}

	//  Iterate to the next subscript by computing its offset and updating
	//		THIS IS THE FUNCTION USED FOR NORMAL ITERATION
	size_t _Off (VIMD& _Idx) const
	{
		size_t _K = _IOff(_Idx);
		_Upd(_Idx);
		return _K;
	}

	//  Dimension reordering overloads; each behaves identically to its
	//  base function, but accepts a dimension reordering array
	size_t _IOff(const VIMD& _Idx, const VIMD& _Idim) const
	{
		size_t _K = _Start;
		for (size_t _I = 0; _I < _Idx.size(); ++_I)
		{
			size_t _II = _Idim[_I];
			_K += _Idx[_II] * _Stride[_II];
		}
		return _K;
	}
	void _Upd (VIMD & _Idx, const VIMD& _Idim) const
	{
		for (size_t _I = _Len.size(); 0 < _I--;)
		{
			size_t _II = _Idim[_I];
			if (++_Idx[_II] < _Len[_II])
				break;
			_Idx[_II] = 0;
		}
	}

	size_t _Off (VIMD& _Idx, const VIMD& _Idim) const
	{
		size_t _K = _IOff(_Idx,_Idim);
		_Upd(_Idx,_Idim);
		return _K;
	}

	//  Return an array like (0,1,2,3,...) for use with
	//  the dimension-reordering members above
	void InitDimReorder ( VIMD & vimdDim ) const
	{
		vimdDim.resize( _Nslice() );
		for ( size_t i = 0 ; i < vimdDim.size() ; ++i )
		{
			vimdDim[i] = i;
		}
	}
	
  protected:
	size_t _Start;			//  Absolute starting offset into array
	VIMD _Len;				//	Signed integer array of dimension lengths
	VIMD _Stride;			//	Signed integer array of strides

	//  Given the dimension lengths, compute the array of strides.
	inline void StrideFromLength ( const vbool * pvboolMissing = NULL );
};

/////////////////////////////////////////////////////////////////////////////////
//
//	Template TMDVDENSE:  Generalized multidimensional array handling.
//			Base class is 'valarray', so member elements must be available
//			(directly or through conversion) for mathematical operations.
//			For example, there's a "sum()" member for valarrays.
//
/////////////////////////////////////////////////////////////////////////////////
template<class T>
class TMDVDENSE : public pair<valarray<T>,MDVSLICE>
{
	typedef valarray<T> vr_base;
	typedef pair<valarray<T>,MDVSLICE> pair_base;

  public:
	TMDVDENSE ( const VIMD & vimd )
		: pair_base( vr_base(), vimd )
		{ SyncSize(); }
	TMDVDENSE () {}
	~ TMDVDENSE () {}
	
	void Init ( const VIMD & vimd, size_t start = 0 )
	{
		second.Init( vimd, start );
		SyncSize();
	}

	void Init ( const MDVSLICE & mdvs )
	{
		second = mdvs;
		SyncSize();
	}
	void Init ( int cdim, ... )
	{
		va_list vl;
		va_start( vl, cdim );
		Init( cdim, vl );
	}

	void Init ( int cdim, va_list & vl )
	{
		second.Init( cdim, vl );
		SyncSize();
	}

	void SyncSize ()
	{	
		size_t cElem = second._Totlen();
		if ( first.size() != cElem )
			first.resize( cElem );
	}

	//  Subscripting as flat array
	T & operator [] ( int i )
		{ return first.operator[](i); }
	T operator [] ( int i ) const
		{ return first.operator[](i); }

	//  Subscripting as m-d array
	T & operator [] ( const VIMD & vimd )
		{ return (*this)[ second._IOff(vimd) ]; }
	T operator [] ( const VIMD & vimd ) const
		{ return (*this)[ second._IOff(vimd) ]; }

	size_t size () const
		{ return first.size(); }

	const MDVSLICE & Slice () const
		{ return second ; }

	const VIMD & VimdDim () const
		{ return second.size(); }

	bool operator == ( const TMDVDENSE & mdv ) const
	{
		return vequal(first,mdv.first)
			&& second == mdv.second;
	}
	bool operator != ( const TMDVDENSE & mdv ) const
	{
		return !(*this == mdv);
	}

	class Iterator
	{
	  public:
		Iterator ( TMDVDENSE & mdv )
			: _mdv(mdv),
			_mdvSlice( mdv.Slice() ),
			_itcurr(0),
			_itend( mdv.size() ),
			_bDimReorder(false)
		{
			assert( _mdvSlice._Totlen() == _itend );
			_vimd.resize(_mdvSlice._Nslice());
		}

		Iterator ( TMDVDENSE & mdv, const MDVSLICE & mdvslice )
			: _mdv(mdv),
			_mdvSlice( mdvslice ),
			_itcurr(0),
			_itend( mdvslice._Totlen() ),
			_bDimReorder(false)
		{
			_vimd.resize(_mdvSlice._Nslice());
		}

		void Reset()
		{
			vclear( _vimd, 0 );
			_itcurr = 0;
		}

		// Return flat index given const subscript array
		size_t Indx ( const VIMD & vimd ) const
		{
			return _bDimReorder
				 ? _mdvSlice._IOff( vimd, _vimdDim )
				 : _mdvSlice._IOff( vimd );
		}
		// Return flat index given subscript array; update sub array
		size_t IndxUpd ( VIMD & vimd )
		{
			return _bDimReorder
				 ? _mdvSlice._Off( vimd, _vimdDim )
				 : _mdvSlice._Off( vimd );
		}
		//  Return current flat index, no update
		size_t Indx () const
			{ return Indx( _vimd ); }
		//  Return current flat index, with update
		size_t IndxUpd ()
		{
			if ( _itcurr < _itend )
				_itcurr++;
			return IndxUpd( _vimd );
		}
		//  Return current datum, no update
		T & operator[] ( VIMD & vimd )
			{ return _mdv[Indx()]; }
		//	Return current datum, update sub array
		T & Next ()
			{ return _mdv[IndxUpd()]; }

		size_t ICurr () const
			{ return _itcurr; }
		size_t IEnd () const
			{ return _itend; }
		bool BNext () const
			{ return _itcurr < _itend; }
		const VIMD & Vitmd () const
			{ return _vimd; }
		const MDVSLICE & Slice() const
			{ return _mdvSlice; }
		void SetDimReorder ( const VIMD & vimdDim )
		{
			_vimdDim = vimdDim;
			_bDimReorder = true;
			// MSRDEVBUG:  assert that the contents mention all dimensions correctly
		}
		TMDVDENSE & Mdv ()
			{ return _mdv; }
		bool BReorder () const
			{ return _bDimReorder; }
		const VIMD & VimdReorder () const
			{ return _vimdDim; }
	  protected:		
	    TMDVDENSE & _mdv;				// Flat valarray
		const MDVSLICE & _mdvSlice;		// Multidimensional slice
		VIMD _vimd;						// Iteration control
		VIMD _vimdDim;					// Dimension reordering (optional)
		size_t _itcurr;					// Current iteration point
		size_t _itend;					// Iteration terminus
		bool _bDimReorder;				// Dimension reordering?
	};

	friend class Iterator;

};


/////////////////////////////////////////////////////////////////////////////////
//   MDVSLICE member functions
/////////////////////////////////////////////////////////////////////////////////

inline
void MDVSLICE :: StrideFromLength ( const vbool * pvboolMissing )
{
	size_t cd = _Len.size();
	_Stride.resize(cd);
	size_t c = 1;
	size_t cmiss = pvboolMissing
				 ? pvboolMissing->size()
				 : 0;

	for ( int i = cd; --i >= 0 ; )
	{
		int l = _Len[i];
		if ( l == 0 )
			continue;
		if ( i < cmiss && (*pvboolMissing)[i] )
		{
			_Stride[i] = 0;
		}
		else
		{
			_Stride[i] = c;
			c *= l;
		}
	}
}

//  Construct a gslice from an MDVSLICE
inline
gslice MDVSLICE :: Gslice () const
{
	_Sizarray vszLength;
	_Sizarray vszStride;
	return gslice( _Start,
				   vdup( vszLength, _Len ),
				   vdup( vszStride, _Stride ) );
}



// End of mdvect.h

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\mscver.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       mscver.h
//
//--------------------------------------------------------------------------

#ifndef _MSCVER_H_
#define _MSCVER_H_

#if _MSC_VER >= 1100 
	#define USE_STD_NAMESPACE using namespace std
#else
	#define USE_STD_NAMESPACE 
#endif

// disable "'this' : used in base member initializer list"
#pragma warning ( disable : 4355 )
// disable "string too long - truncated to 255 characters in the debug information"
#pragma warning ( disable : 4786 )

//MSRDEVBUG: Caused by 'valarray': revisit these.
// disable "unsafe use of type 'bool' in operation"
#pragma warning ( disable : 4804 )	
// disable "forcing value to bool 'true' or 'false'"
#pragma warning ( disable : 4800 )	

// disable "identifier truncated"
#pragma warning ( disable : 4786 )	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\model.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       model.cpp
//
//--------------------------------------------------------------------------

//
//	MODEL.CPP
//

#include <basetsd.h>
#include <string.h>
#include "basics.h"
#include "algos.h"
#include "gmprop.h"
#include "model.h"
#include "gmobj.h"

struct EC_STR
{
	ECGM _ec;
	SZC _szc;
};
static EC_STR vEcToStr [] =
{
#define GMERRORSTR
#include "errordef.h"
	{ EC_OK, "no error" }
};

SZC MODEL :: SzcFromEc ( ECGM ec )
{
	int cEc = UBOUND(vEcToStr);
	for ( int i = 0; i < cEc; i++ )
	{
		if ( ec == vEcToStr[i]._ec )
			return vEcToStr[i]._szc;
	}
	return NULL;
}


// Iterator class for MODELs

MODEL::ITER::ITER(MODEL& model, GOBJMBN::EBNOBJ eType)
	:	_eType(eType),
		_model(model)
{
	Reset();
}


MODEL::ITER::ITER(MODEL& model) : _model(model)
{
	
}

void MODEL::ITER::CreateNodeIterator()
{
	_eType	=  GOBJMBN::EBNO_NODE;
	Reset();
}

void MODEL::ITER :: Reset ()
{
	_pCurrent	= NULL;
	_itsym		= _model.Mpsymtbl().begin();
	BNext();
}

bool MODEL::ITER :: BNext ()
{
	while ( _itsym != _model.Mpsymtbl().end() )
	{
		_pCurrent	= (*_itsym).second.Pobj();
		_zsrCurrent = (*_itsym).first;
		_itsym++;

		if ( _pCurrent->EType() == _eType )
			return true;
	}		
	_pCurrent = NULL;
	return false;
}



///////////////////////////////////////////////////////////////////////////
//	MODEL naming commentary.
//
//	Symbolic names in a belief network come in two types: names which users
//	can enter (or edit into a DSC file) and those which they cannot.
//
//	The basic (user-definable) symbolic name follows exactly the rules of
//	standard 'C', except that periods ('.') are allowed inside a name.
//
//	There is a need for generation of names which are clearly distinguishable
//	from user-definable names; these are called "internal" names.  The only
//	difference is that the legal character set is extended to include the '$'
//	(dollar sign) character as an alphabetic character (i.e., it can be the
//	first character in a name).
//
///////////////////////////////////////////////////////////////////////////
//  Return true if the character is legal in a name
bool MODEL :: BChLegal ( char ch, ECHNAME echnm, bool bInternal )
{	
	bool bOther = bInternal && ch == ChInternal();
	bool bOkForC = echnm == ECHNM_First
				? __iscsymf(ch)
				: __iscsym(ch) || (echnm == ECHNM_Middle && ch == '.');
	return bOther || bOkForC;
}

//  Return true if the name is legal
bool MODEL :: BSzLegal ( SZC szcName, bool bInternal )
{	
	for ( int i = 0; szcName[i]; i++ )
	{
		ECHNAME echnm = i == 0
					? ECHNM_First
					: (szcName[i+1] ? ECHNM_Middle : ECHNM_Last);
		if ( ! BChLegal( szcName[i], echnm, bInternal ) )
			return false;
	}
	return true;
}


MODEL :: MODEL ()
	: _pgrph(NULL),
	_rVersion(-1.0)
{
	//  Allocate the GRPH graph object
	SetPgraph(new GRPH);
	assert( _pgrph );
//
//	Define the table of known (early-defined) bit flags in this scope
//
#define MBN_GEN_BFLAGS_TABLE szcBitFlagNames
//	Include the header to generate the strings
#include "mbnflags.h"

	//  Define the table of known bit flags.
	for ( int i = 0; szcBitFlagNames[i]; i++ )
	{
		//  Note: this automatically interns the names into the symbol table
		IBFLAG ibf = Mpsymtbl().IAddBitFlag( szcBitFlagNames[i] );
	}
}

MODEL :: ~ MODEL ()
{
	//  We must clear the graph and symbol table at this point, because their
	//  elements interreference via the names (ZSREFs) and pointers (REFPOBJs).
	//  The symbol table is cleared first, so that no stray references to GOBJMBNs
	//  exist when the graph object is nuked.  Then the graph is cleared, so
	//  that embedded references to strings interned in the symbol table's string
	//	table will be removed.

	Mpsymtbl().clear();

	//  Delete the graph
	SetPgraph(NULL);
}

void MODEL :: SetPgraph ( GRPH * pgrph )
{
	delete _pgrph;
	_pgrph = pgrph;
}

//	Add an unnamed element to the graph
void MODEL :: AddElem ( GELEMLNK * pgelm )
{
	ASSERT_THROW( pgelm, EC_NULLP, "null ptr passed to MODEL::AddElem()" );
	Pgraph()->AddElem( *pgelm );
}


	//  Test the name for duplicate; add if not, otherwise return false
bool MODEL :: BAddElem ( SZC szcName, GOBJMBN * pgobj )
{
	if ( ::strlen( szcName ) == 0 )
		return false;	//  Name missing
	if ( Mpsymtbl().find( szcName ) )
		return false;  // duplicate name
	AddElem( szcName, pgobj );
	return true;
}

//	Add a (possibly) named object to the graph and symbol table
void MODEL :: AddElem ( SZC szcName, GOBJMBN * pgelm )
{
	if ( szcName != NULL && ::strlen(szcName) != 0 )
	{
		if ( Mpsymtbl().find( szcName ) )
			throw GMException( EC_DUPLICATE_NAME, "attempt to add duplicate name to MBNET" );

		Mpsymtbl().add( szcName, pgelm );
	}
	AddElem( pgelm );
}

void MODEL :: DeleteElem ( GOBJMBN * pgobj )
{
	if ( pgobj->ZsrefName().Zstr().length() > 0 )
		Mpsymtbl().remove( pgobj->ZsrefName() );
	else
		DeleteElem( (GELEMLNK *) pgobj );
}

void MODEL :: DeleteElem ( GELEMLNK * pgelem )
{
	delete pgelem;
}

void MODEL :: Clone ( MODEL & model )
{
	ASSERT_THROW( _pgrph->ChnColl().PgelemNext() == NULL,
				EC_INVALID_CLONE,
				"cannot clone into non-empty structure" );

	//  Clone the descriptive information
	_rVersion = model._rVersion;
	_zsFormat = model._zsFormat;
	_zsCreator = model._zsCreator;
	_zsNetworkID = model._zsNetworkID;

	//  Clone the symbol table
	_mpsymtbl.Clone( model._mpsymtbl );
	//  Copy the network bit flags array
	_vFlags = model._vFlags;

	//
	//  Clone the actual contents of the network, object by object
	//
	{
		//  Create a map to correlate old object pointers to new object pointers
		typedef map<GOBJMBN *, GOBJMBN *, less<GOBJMBN *> > MPPOBJPOBJ;
		MPPOBJPOBJ mppobjpobj;

		//  Add the property types first, then all the node-like things
		GELEMLNK * pgelm;
		MODELENUM mdlenumNode( model );
		for ( int icycle = 0; icycle < 2; icycle++ )
		{
			mdlenumNode.Reset(model.Grph());
			while ( pgelm = mdlenumNode.PlnkelNext() )
			{	
				//  Check that it's a node (not an edge)
				if ( ! pgelm->BIsEType( GELEM::EGELM_NODE ) )
					continue;

				GOBJMBN * pgobjmbn;
				GOBJMBN * pgobjmbnNew = NULL;
				DynCastThrow( pgelm, pgobjmbn );

				//  Clone property types on the first pass, all other nodeish things
				//		on the second.
				if ( (icycle == 0) ^ (pgelm->EType() == GOBJMBN::EBNO_PROP_TYPE) )
					continue;

				pgobjmbnNew = pgobjmbn->CloneNew( model, self );
				//  If the object was cloned or allowed itself to be cloned,
				//		add it
				if ( pgobjmbnNew )
				{
					assert( pgobjmbnNew->EType() == pgobjmbn->EType() );
					mppobjpobj[ pgobjmbn ] = pgobjmbnNew;
					//  Add the object as named or unnamed
					AddElem( pgobjmbnNew->ZsrefName(), pgobjmbnNew );
				}
			}
		}
		//  Add all the edge-like things
		MODELENUM mdlenumEdge( model );
		while ( pgelm = mdlenumEdge.PlnkelNext() )
		{	
			//  Check that it's a edge (not a node)
			if ( ! pgelm->BIsEType( GELEM::EGELM_EDGE ) )
				continue;
			GEDGEMBN * pgedge;
			DynCastThrow( pgelm, pgedge );

			GOBJMBN * pgobjmbnSource = pgedge->PobjSource();
			GOBJMBN * pgobjmbnSink = pgedge->PobjSink();
			assert( pgobjmbnSource && pgobjmbnSink );
			GOBJMBN * pgobjmbnSourceNew = mppobjpobj[  pgobjmbnSource ];
			GOBJMBN * pgobjmbnSinkNew = mppobjpobj[  pgobjmbnSink ];
			assert( pgobjmbnSourceNew && pgobjmbnSinkNew );
			GEDGEMBN * pgedgeNew = pgedge->CloneNew( model,
													 self,
													 pgobjmbnSourceNew,
													 pgobjmbnSinkNew );
			assert( pgedgeNew );
			AddElem( pgedgeNew );
		}
	}		

	//	Clone the network property list
	_ltProp.Clone( self, model, model._ltProp );
}

GOBJMBN * MODEL :: PgobjFind ( SZC szcName )
{
	return Mpsymtbl().find(szcName);
}



void MPSYMTBL :: Clone ( const MPSYMTBL & mpsymtbl )
{
	//  Clone all the interned strings
	_stszstr.Clone( mpsymtbl._stszstr );
	//  Clone the array of bit flag names
	CloneVzsref( mpsymtbl, mpsymtbl._mpzsrbit, _mpzsrbit );
	//  All other symbol entries must be created from above		
}

void MPSYMTBL :: CloneVzsref (
	const MPSYMTBL & mpsymtbl,
	const VZSREF & vzsrSource,
	VZSREF & vzsrTarget )
{
	vzsrTarget.resize( vzsrSource.size() );
	for ( int i = 0; i < vzsrTarget.size(); i++ )
	{
		SZC szc = vzsrSource[i].Szc();
		vzsrTarget[i] = intern(szc);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\ntree.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       ntree.cpp
//
//--------------------------------------------------------------------------

//
//  NTREE.CPP
//
#include <algorithm>
#include <functional>

#include "ntree.h"
#include "glnkenum.h"

NTELEM :: NTELEM ()
	: _pnteParent(NULL),
	_pnteChild(NULL)
{
}

NTELEM :: ~ NTELEM ()
{
	Orphan();
	NTELEM * pnteChild = NULL;
	while ( pnteChild = _pnteChild )
	{
		delete pnteChild;
	}
}

//  Adopt (link) a child
void NTELEM :: Adopt ( NTELEM * pnteChild, bool bSort )
{
	pnteChild->Orphan();

	NTELEM * pNextChild = _pnteChild ;
	bool bFoundHigher = true ;

	if ( pNextChild && bSort )
	{
		//  Position among the children based upon sort order.
		GLNKENUM<NTELEM,false> glnkEnum( *pNextChild );
		bFoundHigher = false;
		while ( pNextChild = glnkEnum.PlnkelNext() )
		{
			if ( pnteChild->ICompare( pNextChild ) < 0 )
				break ;
		}
		//  If we didn't find a higher child, link *this
		//  such that it points to the first child.
		if ( ! (bFoundHigher = pNextChild != NULL) )
			pNextChild = _pnteChild ;
	}

	//  If there is another child, insert this in front of it.
	if ( pNextChild )
		pnteChild->ChnSib().Link( pNextChild ) ;

	//  If this is the first child, or if this new child
	//      sorted low, use it as the anchor.
	if ( _pnteChild == NULL || pnteChild->ICompare( _pnteChild ) < 0 )
		_pnteChild = pnteChild;

	_pnteChild->_pnteParent = this ;
}

//  Disown (release) a child
void NTELEM :: Disown ( NTELEM * pnteChild ) 
{
	if ( _pnteChild == pnteChild )
	{
		_pnteChild = pnteChild->ChnSib().PgelemNext() ;
		if ( _pnteChild == pnteChild )
			_pnteChild = NULL ;	 // There goes the last child
	}
	pnteChild->ChnSib().Unlink() ;
	pnteChild->_pnteParent = NULL ;
}

//  Become an orphan
void NTELEM :: Orphan ()
{
	if ( _pnteParent )
		_pnteParent->Disown( this );
	_pnteParent = NULL;
}

INT NTELEM :: SiblingCount () 
{
	return ChnSib().Count();
}

INT NTELEM :: ChildCount () 
{
	if ( _pnteChild == NULL )
		return 0;
	return _pnteChild->ChnSib().Count();
}

NTELEM * NTELEM :: PnteChild ( INT index )
{
	if ( _pnteChild == NULL )
		return NULL ;

	GLNKENUM<NTELEM,false> glnkEnum( *_pnteChild );
	int i = 0 ;
	do
	{
		if ( i++ == index )
			return glnkEnum.PlnkelCurrent() ;
	} while ( glnkEnum.PlnkelNext() ) ;
	return NULL ;
}

bool NTELEM :: BIsChild ( NTELEM * pnte ) 
{
	if ( _pnteChild == NULL )
		return false ;

	GLNKENUM<NTELEM,false> glnkEnum( *_pnteChild );
	NTELEM * pnteCurr = NULL ;
	do
	{
		//  If this is it, we're done
		if ( (pnteCurr = glnkEnum.PlnkelCurrent()) == pnte )
			return true ;
		//  If current object has a child, search its siblings
		if ( pnteCurr->_pnteChild && pnteCurr->BIsChild( pnte) )
			return true ;
		//  On to the next object pointer
	}
	while ( glnkEnum.PlnkelNext() ) ;
	return false ;
}

DEFINEVP(NTELEM);

static NTELEM::SRTFNC srtpntelem;

void NTELEM :: ReorderChildren ( SRTFNC & fSortRoutine ) 
{
	INT cChildren = ChildCount() ;
	if ( cChildren == 0 )
		return;

	//  Enumerate the children into an array, disown them, sort the
	//  array and re-adopt them in the new order.

	VPNTELEM rgpnteChild;
	rgpnteChild.resize(cChildren);
	GLNKENUM<NTELEM,false> glnkEnum( *_pnteChild );

	for ( int iChild  = 0 ; rgpnteChild[iChild++] = glnkEnum.PlnkelNext() ; );

	while ( _pnteChild )
	{
		Disown( _pnteChild ) ;
	}

	sort( rgpnteChild.begin(), rgpnteChild.end(), fSortRoutine );

	//  Re-adopt the children in the given order
	for ( iChild = 0 ; iChild < rgpnteChild.size() ; )
	{
		Adopt( rgpnteChild[iChild++] );
	}
}

NTREE :: NTREE ()
{
}

NTREE :: ~ NTREE ()
{
}

// End of NTREE.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\model.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       model.h
//
//--------------------------------------------------------------------------

//
//	MODEL.H
//	
#ifndef _MODEL_H_
#define _MODEL_H_

#include "gelem.h"			//  Graph object classes
#include "glnkenum.h"
#include "symtmbn.h"		//	Symbol table and string declarations
#include "gelmwalk.h"		//	Graph search algorithms
#include "gmprop.h"

class MODEL
{
  public:

	// Nested iterator class based on symbol table iteration.
	class ITER
	{
	  public:

		ITER ( MODEL& model, GOBJMBN::EBNOBJ eType );
		ITER ( MODEL& model );

		void	CreateNodeIterator();
		
		bool operator++ (int i)
			{ return BNext() ; }
		bool operator++ ()
			{ return BNext() ; }
		GOBJMBN * operator -> ()
			{ return _pCurrent; }
		GOBJMBN * operator * ()
			{ return _pCurrent; }
		ZSREF ZsrCurrent ()
			{ return _zsrCurrent; }
		void Reset ();

	  protected:	

		MPSYMTBL::iterator	_itsym;
		GOBJMBN::EBNOBJ		_eType;
		GOBJMBN*			_pCurrent;
		ZSREF				_zsrCurrent;
	  protected:

		bool				BNext();
		MODEL&				_model;
	};


  public:
	MODEL ();
	virtual ~ MODEL ();

	GRPH * Pgraph () const
		{ return _pgrph;	}
	GRPH & Grph () const
	{ 
		assert( _pgrph );
		return *_pgrph; 
	}

	//  Object addition and deletion functions
		//	Add and delete generic unnamed elements
	virtual void AddElem ( GELEMLNK * pgelm );
	virtual void DeleteElem ( GELEMLNK * pgelem );
		//  Add and delete named elements
		//  Test the name for duplicate; add if not, else return false
	virtual bool BAddElem ( SZC szcName, GOBJMBN * pgobj );
		//	Add a named object to the graph and symbol table
	virtual void AddElem ( SZC szcName, GOBJMBN * pgobj );
		//  Delete objects and edges
	virtual void DeleteElem ( GOBJMBN * pgobj );

	//  Enumerator for contents of the graph (GRPH);
	//  enumeration omits the GRPH object itself
	class MODELENUM : public GLNKENUM<GELEMLNK,true>
	{
	  public:
		MODELENUM ( const MODEL & model )
			: GLNKENUM<GELEMLNK,true>( model.Grph() )
			{}
	};
	
 	//  Accessors to format/versioning info
	REAL & RVersion ()				{ return _rVersion ;	}
	ZSTR & ZsFormat ()				{ return _zsFormat;		}
	ZSTR & ZsCreator ()				{ return _zsCreator;	}
	ZSTR & ZsNetworkID ()			{ return _zsNetworkID;	}

	//  Accessor for symbol table
	MPSYMTBL & Mpsymtbl ()			{ return _mpsymtbl;		}
	const MPSYMTBL & Mpsymtbl () const
									{ return _mpsymtbl;		}
	GOBJMBN * PgobjFind ( SZC szcName );

	//	Accessor for list of network-level properties
	LTBNPROP & LtProp ()			{ return _ltProp;		}

	//  Accessors for the array of flag bits
	bool BFlag ( IBFLAG ibf ) const	
		{ return _vFlags.BFlag( ibf );	}
	bool BSetBFlag ( IBFLAG ibf, bool bValue = true )
		{ return _vFlags.BSetBFlag( ibf, bValue );	}
	
  	//  Name validation and parsing functions
		//	Return a character which is illegal in a DSC-file-based name;
		//		used for building up "hidden" but otherwise descriptive names
	static char ChInternal ()				{ return '$';				}
		//  Return true if the character is legal in a name
	enum ECHNAME { ECHNM_First, ECHNM_Middle, ECHNM_Last };
	static bool BChLegal ( char ch, ECHNAME echnm, bool bInternal = false );
		//  Return true if the name is legal
	static bool BSzLegal ( SZC szcName, bool bInternal = false );
	//	Return a displayable string associated with an error code; NULL if not found
	static SZC SzcFromEc ( ECGM ec );

 protected:	
	GRPH * _pgrph;					//  The graph

	//  Format and versioning info
	REAL _rVersion;					//  Version/revision value
	ZSTR _zsFormat;					//  Format type string
	ZSTR _zsCreator;				//  Creator name
	ZSTR _zsNetworkID;				//  Network identification string

  	MPSYMTBL _mpsymtbl;				//  The symbol table
	LTBNPROP _ltProp;				//  The list of user-definable properties
	VFLAGS	 _vFlags;				//  Bit vector of flags

  protected:
	//  Set or reset the graph object
	virtual void SetPgraph ( GRPH * pgrph );
	//  Protected clone-this-from-other operation
	virtual void Clone ( MODEL & model );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\nyi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       nyi.cpp
//
//--------------------------------------------------------------------------

//
//	NYI.cpp: throw generic "not yet implemented" exception
//	

#include "basics.h"

void NYI() 
{
	THROW_ASSERT(EC_NYI,"Attempt to call unimplemented function");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\mddist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mddist.h
//
//--------------------------------------------------------------------------

//
//  mddist.h: model distributions
//

#ifndef _MDDIST_H_
#define _MDDIST_H_

#include <map>

#include "mdvect.h"
#include "leakchk.h"

////////////////////////////////////////////////////////////////////
//	Probability table declarations
////////////////////////////////////////////////////////////////////

//  Dense multidimensional array.  Note that a null dimension set
//	produces a one entry array.
typedef TMDVDENSE<REAL> MDVDENSE;

class MDVCPD : public MDVDENSE
{
  public:
	MDVCPD ( const VIMD & vimd )
		: MDVDENSE ( vimd )
		{}
	MDVCPD () {}
	~ MDVCPD () {}

	void Init ( const VIMD & vimd, size_t start = 0 )
	{
		if ( vimd.size() > 0 )
		{
			MDVDENSE::Init( vimd, start );
		}
		else
		{
			assert( start == 0 );
			MDVDENSE::Init( 1, 1 );
		}
	}

	void Init ( int cdim, ... )
	{
		if ( cdim > 0 )
		{
			va_list vl;
			va_start( vl, cdim );
			MDVDENSE::Init( cdim, vl );
		}
		else
		{	
			MDVDENSE::Init( 1, 1 );
		}
	}

	void Clear ( REAL r = 0.0 )
	{
		size_t celem = size();
		for ( int i = 0; i < celem; )
			self[i++] = r;
	}
	REAL RSum () const
	{
		return first.sum();
	}
	void Normalize ()
	{
		REAL rSum = RSum();
		if ( rSum != 0.0 && rSum != 1.0 )
		{
			size_t celem = size();
			for ( int i = 0; i < celem; )
				self[i++] /= rSum;
		}
	}

	MDVCPD & operator = ( const MDVCPD & mdv )
	{
		MDVDENSE::Init( mdv.Slice() );
		first = mdv.first;
		return self;
	}
	//  Convert this MDVCPD to a single-dimension object
	MDVCPD & operator = ( const VLREAL & vlr )
	{
		Init( 1, vlr.size() );
		first = vlr;
		return self;
	}

	//  Given a partial dimension (incomplete) subscript, update the appropriate
	//		range of elements.  Note that providing an incomplete (i.e., short)
	//		subscript array to the "offset" functions  is valid; the results
	//		are the same as if the missing lower-order elements were zero.
	void UpdatePartial ( const VIMD & vimd, const VLREAL & vlr )
	{
		const VIMD vimdDim = VimdDim();
		//  Compute the appropriate number of elements
		size_t cElem = 1;
		assert( vimd.size() <= vimdDim.size() );
		for ( int idim = vimd.size(); idim < vimdDim.size(); idim++ )
		{
			cElem *= vimdDim[idim];
		}
		ASSERT_THROW( vlr.size() == cElem,
					  EC_MDVECT_MISUSE,
					  "m-d vector partial projection count invalid" );
		//  Index to the proper position and update from the source data
		assert( second._IOff(vimd) + cElem <= first.size() );
		REAL * prSelf = & self[vimd];
		for ( int iElem = 0; iElem < cElem; )
			*prSelf++ = vlr[iElem++];
	}

	void Clone ( const MDVCPD & mdv )
	{
		self = mdv;
	}
};

//  Class MPCPDD:  Distribution map by specific index
//		Hungarian: 'drmap'

class MPCPDD : public map<VIMD, VLREAL, lessv<VIMD> >
{
  public:
	MPCPDD () {}
	~ MPCPDD () {}
	void Clone ( const MPCPDD & dmap )
	{
		self = dmap;
	}

	//  Return a pointer to the dimensionless "default" vector or NULL
	const VLREAL * PVlrDefault () const
	{
		VIMD vimdDefault;
		const_iterator itdm = find( vimdDefault );
		return itdm == end()
			 ? NULL
			 : & (*itdm).second;
	}
	bool operator == ( const MPCPDD & mpcpdd ) const
	{
		if ( size() != mpcpdd.size() )
			return false;
		const_iterator itself = begin();
		const_iterator itmp = mpcpdd.begin();
		for ( ; itself != end(); itself++, itmp++ )
		{	
			if ( (*itself).first != (*itmp).first )
				return false;
			if ( ! vequal( (*itself).second, (*itmp).second ) )
				return false;				
		}
		return true;
	}
	bool operator != ( const MPCPDD & mpcpdd ) const
		{ return !(self == mpcpdd); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\ntree.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       ntree.h
//
//--------------------------------------------------------------------------

//
//  NTREE.H
//

#if !defined(_NTREE_H_)
#define _NTREE_H_

#include <functional>
#include "gelem.h"
#include "glnkenum.h"

class NTELEM;
class NTREE;

class NTELEM : public GLNKEL
{
  public:
	//  Internal class for chains (doubly-linked lists) of tree nodes
	typedef XCHN<NTELEM> CHN;
	//  Sort helper "less" binary function class
	class SRTFNC : public binary_function<const NTELEM *, const NTELEM *, bool>
	{	
	  public:
		virtual bool operator () (const NTELEM * pa, const NTELEM * pb) const
			{	return pa->ICompare( pb ) < 0;	}
	};
	static SRTFNC srtpntelem;

  public:
	NTELEM ();
	virtual ~ NTELEM ();

	//  Accessor for chain of siblings
	CHN & ChnSib ()
		{ return (CHN &) Chn() ; }

	virtual INT EType () const
		{ return _pnteChild ? EGELM_BRANCH : EGELM_LEAF ; }

	//  Adopt (link) a child
	void Adopt ( NTELEM * pnteChild, bool bSort = false ) ;
	//      Disown (release) a child
	void Disown ( NTELEM * pnteChild ) ;
	//      Become an orphan
	void Orphan () ;

	INT ChildCount () ;
	INT SiblingCount ();
	NTELEM * PnteChild ( INT index ) ;
	NTELEM * PnteParent () 
		{ return _pnteParent; }
	NTELEM * PnteChild () 
		{ return _pnteChild; }
	bool BIsChild ( NTELEM * pnte ) ;

	//  Return the sort value of *this versus another COBJ
	virtual INT ICompare ( const NTELEM * pnteOther ) const = 0;

	void ReorderChildren ( SRTFNC & fSortRoutine = srtpntelem ) ;

  protected:
	NTELEM * _pnteParent;	// Pointer to single parent (or NULL)
	NTELEM * _pnteChild;	// Pointer to one child (or NULL)

	HIDE_UNSAFE(NTELEM);
};


class NTREE : public NTELEM
{
  public:
	NTREE ();
	virtual ~ NTREE ();

	virtual INT EType () const
		{ return EGELM_TREE ; }

	HIDE_UNSAFE(NTREE);
};

template <class T, bool bAnchor> 
class NTENUM : public GLNKENUM<T,bAnchor>
{
 public:
	NTENUM (const T & ntel, bool bIsAnchor = bAnchor, bool iDir = true)
		: GLNKENUM<T,bAnchor>( ntel, bIsAnchor, iDir )
		{}
	//  Position to the next pointer
	T * PntelNext ()
		{ return (T *) GLNKENUM<T,bAnchor>::PlnkelNext() ; }
	//  Return the current object pointer
	T * PntelCurrent()
		{ return (T *) _plnkelNext ; }
	//  Set the enumerator to have a new base
	void Reset ( const T & ntel, int iDir = -1 )
		{ GLNKENUM<T,bAnchor>::Reset( ntel, iDir ) ; }
};

// Template for generating nested tree motion accessor class
template<class T>
class TWALKER
{
  public:
	TWALKER ( T & t )
		: _pt(&t) 
		{}
	void Reset ( T & t )
		{ _pt = &t; }
	T * PlnkchnPrev () 
  		{ return  PdynCast( _pt->Chn().PgelemPrev(), _pt ); }
	T * PlnkchnNext () 
  		{ return  PdynCast( _pt->Chn().PgelemNext(), _pt ); }
	T * Pparent ()
  		{ return  PdynCast( _pt->PnteParent(), _pt ); }
	T * Pchild ()
  		{ return  PdynCast( _pt->PnteChild(), _pt ); }
  protected:
	T * _pt;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\parser.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       parser.h
//
//--------------------------------------------------------------------------

# define tokenEOF 0
# define tokenNil 258
# define tokenError 259
# define tokenIdent 260
# define tokenString 261
# define tokenInteger 262
# define tokenReal 263
# define tokenArray 264
# define tokenContinuous 265
# define tokenCreator 266
# define tokenDefault 267
# define tokenDiscrete 268
# define tokenFormat 269
# define tokenFunction 270
# define tokenImport 271
# define tokenIs 272
# define tokenKeyword 273
# define tokenLeak 274
# define tokenNA 275
# define tokenName 276
# define tokenNamed 277
# define tokenNetwork 278
# define tokenNode 279
# define tokenOf 280
# define tokenParent 281
# define tokenPosition 282
# define tokenProbability 283
# define tokenProperties 284
# define tokenProperty 285
# define tokenPropIdent 286
# define tokenStandard 287
# define tokenState 288
# define tokenType 289
# define tokenUser 290
# define tokenVersion 291
# define tokenWordChoice 292
# define tokenWordReal 293
# define tokenWordString 294
# define tokenAs 295
# define tokenLevel 296
# define tokenDomain 297
# define tokenDistribution 298
# define tokenDecisionGraph 299
# define tokenBranch 300
# define tokenOn 301
# define tokenLeaf 302
# define tokenVertex 303
# define tokenMultinoulli 304
# define tokenMerge 305
# define tokenWith 306
# define tokenFor 307
# define tokenRangeOp 308
# define UNARY 309
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\parser.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       parser.cpp
//
//--------------------------------------------------------------------------

/*
 * Created by CSD YACC (IBM PC) from "parser.y" */

#include <basetsd.h>
#line 2 "parser.y"
    #include "bnparse.h"
	// disable warning C4102: unreferenced label
	#pragma warning (disable : 4102)
# define tokenEOF 0
# define tokenNil 258
# define tokenError 259
# define tokenIdent 260
# define tokenString 261
# define tokenInteger 262
# define tokenReal 263
# define tokenArray 264
# define tokenContinuous 265
# define tokenCreator 266
# define tokenDefault 267
# define tokenDiscrete 268
# define tokenFormat 269
# define tokenFunction 270
# define tokenImport 271
# define tokenIs 272
# define tokenKeyword 273
# define tokenLeak 274
# define tokenNA 275
# define tokenName 276
# define tokenNamed 277
# define tokenNetwork 278
# define tokenNode 279
# define tokenOf 280
# define tokenParent 281
# define tokenPosition 282
# define tokenProbability 283
# define tokenProperties 284
# define tokenProperty 285
# define tokenPropIdent 286
# define tokenStandard 287
# define tokenState 288
# define tokenType 289
# define tokenUser 290
# define tokenVersion 291
# define tokenWordChoice 292
# define tokenWordReal 293
# define tokenWordString 294
# define tokenAs 295
# define tokenLevel 296
# define tokenDomain 297
# define tokenDistribution 298
# define tokenDecisionGraph 299
# define tokenBranch 300
# define tokenOn 301
# define tokenLeaf 302
# define tokenVertex 303
# define tokenMultinoulli 304
# define tokenMerge 305
# define tokenWith 306
# define tokenFor 307
# define tokenRangeOp 308
# define UNARY 309
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
#ifndef YYFARDATA
#define	YYFARDATA	/*nothing*/
#endif
#if ! defined YYSTATIC
#define	YYSTATIC	/*nothing*/
#endif
#ifndef YYOPTTIME
#define	YYOPTTIME	0
#endif
#ifndef YYR_T
#define	YYR_T	int
#endif
typedef	YYR_T	yyr_t;
#ifndef YYEXIND_T
#define	YYEXIND_T	unsigned int
#endif
typedef	YYEXIND_T	yyexind_t;
#ifndef	YYACT
#define	YYACT	yyact
#endif
#ifndef	YYPACT
#define	YYPACT	yypact
#endif
#ifndef	YYPGO
#define	YYPGO	yypgo
#endif
#ifndef	YYR1
#define	YYR1	yyr1
#endif
#ifndef	YYR2
#define	YYR2	yyr2
#endif
#ifndef	YYCHK
#define	YYCHK	yychk
#endif
#ifndef	YYDEF
#define	YYDEF	yydef
#endif
#ifndef	YYV
#define	YYV	yyv
#endif
#ifndef	YYS
#define	YYS	yys
#endif
#ifndef	YYLOCAL
#define	YYLOCAL
#endif
# define YYERRCODE 256

#line 473 "parser.y"

YYSTATIC short yyexca[] ={
#if !(YYOPTTIME)
-1, 1,
#endif
	0, -1,
	-2, 0,
#if !(YYOPTTIME)
-1, 76,
#endif
	125, 168,
	44, 168,
	-2, 176,
#if !(YYOPTTIME)
-1, 260,
#endif
	125, 73,
	-2, 91,
	};
# define YYNPROD 200
#if YYOPTTIME
YYSTATIC yyexind_t yyexcaind[] = {
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
4,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
10,
	};
#endif
# define YYLAST 451
YYSTATIC short YYFARDATA YYACT[]={

 303,  24,  25,  80,  79, 120, 121,  89, 127, 295,
 128, 126, 158, 129, 160,  20,  31, 157, 239, 206,
  84, 306, 226, 225, 104, 133, 168,  54, 198, 178,
 221,  98, 197, 254,  16, 102,  98,   6,  17,  15,
 190, 185, 180,  62, 179,  80,  79, 238, 180,  78,
 179, 235,  18,  19, 171, 170, 169,  99,  96, 270,
 255, 101,  99, 180,  90, 179, 234,  91,  93,  94,
  77,  90, 213, 209,  91, 208, 304, 232, 103, 309,
 130, 308, 224, 119,  24,  25,  80,  79,  24,  25,
 174, 297, 298, 296, 184, 137, 135, 299, 282, 274,
 122, 261, 251, 216,  87, 148,  46,  28, 138, 139,
 140, 115, 207,  75, 175, 136, 191, 155,  86, 143,
 144, 145,  82, 278, 189, 264, 134, 173, 125, 118,
 277,  52,  50,  48,  45,  27, 214,  22, 319,  74,
  77, 264, 230, 152, 330, 317, 315, 317, 316, 247,
 318, 228, 318, 317, 315, 110, 316,  66, 318,  97,
 290, 289, 181, 181, 314, 272, 236, 166,  61, 165,
 311,  59, 164, 142,  95, 111, 286, 243, 242, 287,
 242, 113, 233, 240,  69,  70, 241, 196, 112,  67,
 265, 229, 188,  60, 181, 215, 181, 319, 313, 319,
 293, 202, 203,  69,  70, 319, 312,  68, 256, 124,
 117, 259, 146,  53,  77,  23, 181, 131, 292, 263,
 132, 192, 194, 186, 222, 205,  51,  37, 100, 109,
  33, 159,  83,   8,  81,  85,  49,  39, 218,  38,
  40,  26,  73, 116,  47,  30, 250, 161, 153, 200,
 141, 162, 181, 172,  65, 258,  64,  76, 149, 177,
 176,  80,  79,  77, 181, 177, 176,  80,  79, 183,
  63,  44, 253,  35, 182, 302, 301, 281,  92, 285,
 182, 294,  80,  79, 193,  92, 271, 123, 284, 201,
 283, 280, 210, 279, 269, 182, 305, 307,  80,  79,
 199, 310, 268, 181, 273, 320, 219, 262, 147, 321,
 322, 222, 291, 223, 267, 324, 325, 326, 327, 328,
 329, 323, 300, 260, 249, 275, 237,  76, 150, 151,
 212, 211, 187, 114,  72, 154,  29, 245, 227, 288,
 244, 276, 163, 266, 257, 246, 248, 204, 108, 107,
 105,  71,  36,  42,  88, 252,  41,  32, 156,  55,
  43,  34,  21,   5,  14,  13,  12,  11,  10,   9,
 195,   7,   4,   3,   2,   1,  57,  56, 106,  58,
 167,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0, 217,
   0, 220,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 231,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 220 };
YYSTATIC short YYFARDATA YYPACT[]={

-1000,-1000,-241,-1000,-245,  14,-172,-245,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,  12,-153,-1000,-1000,-283,
 190,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000, 187,
-172,-172,-1000,-1000,-1000,-1000,  11,-154,  10,   9,
 186,   8, 172, -98, -82,-1000,-1000,-1000,-259,-1000,
-276,-156,-1000,-1000,-1000,-1000,-1000,-1000,-1000,   6,
   6,   6,-1000, 115,-1000,-1000,-1000,-229,-224,-225,
   6,-101, -13,  85,-1000,   6,-303,-302,-176,-1000,
-1000,  84,-1000,-292,-182, 176,-1000,-270,   1,-165,
-1000,-1000,-1000,-217,-166,-1000,-1000,-1000,-1000,-1000,
   6,   6,   6,-1000,-1000, 114,-1000,-1000,-1000,-1000,
-1000,   6,   6,   6, 171,-155,-1000,-1000,-259,-172,
-172,-217,-1000,-1000,-1000,-276,-172,-289,-290,-289,
-1000,-1000,-156,-172,-1000, 113, 110, 108,-238,-1000,
  -1,  -1,-1000,-167,-227, 183,-1000, 148,-1000,-1000,
-1000,-1000,-1000,-1000,-237, 181,-1000,-1000,-1000,-237,
 182,-172,-1000,-1000,-1000,-1000,-1000, 143,-248,-1000,
-1000,-252,  -1,-1000,   5,-1000,-1000,-1000,-1000,-217,
-217,-1000,-1000,-1000,-1000, -72,  30,  13,-157,-1000,
-172,-1000,-259,-1000,  20,-289,-179,-271,  60,-1000,
  98,-1000,-1000,-1000,-1000,-172,-185, 138,-196,-211,
-1000,-1000, 107,-1000,-223,-280,-1000,-1000, 142,-1000,
-303, 136,-1000, 181,-1000,-1000,-1000,-1000,-1000,-1000,
   5,-1000,  56,  30,-1000,-1000,-1000,-1000,   6,-158,
-1000,-259,  20,-1000,-1000,-172,-1000,   6, 170,-1000,
-159, 179,-1000,-1000,  97,-1000,-1000,-1000,-1000,-1000,
  19, 106,-1000,-161,-172,-1000,   7,  -2,-1000,-162,
-1000,   6,-1000, 135,-1000,-1000,-1000,-1000,-1000, 102,
 101,  20, 178, 159,-169,-1000,-1000,-163,-172,-1000,
-1000, 134,  36,   6, 126,-1000,-1000,-1000,-1000,-1000,
  81, 157, 120, 111,  36,-1000,-1000,-1000,  36,  36,
-1000,-169,-1000,-1000,  36,  36,  36,  36,  36,  36,
 103,-1000,-1000,-1000, 111, 105, 105,  44,  44,  44,
-1000 };
YYSTATIC short YYFARDATA YYPGO[]={

   0, 380,   9, 112, 208, 159,  60, 379, 378, 377,
  21,  29, 376, 375, 374, 373, 372, 371, 233, 369,
 368, 367, 366, 365, 364, 363, 362, 361, 360, 359,
   7, 358, 117, 357, 356, 354, 353, 352, 351, 350,
 349, 348, 157, 347, 344, 343, 341, 339,  33, 338,
 337, 336, 334, 333, 332, 331, 330, 326, 324, 323,
 314, 308, 307, 304, 302, 294, 293, 291, 290, 288,
 281, 277,  30, 276, 275,   0, 273, 271, 270, 256,
 254, 253, 127, 250, 249, 114, 245, 244, 242, 139,
 113, 116, 238, 237, 236, 235, 118, 234, 122, 232,
 124, 231 };
YYSTATIC yyr_t YYFARDATA YYR1[]={

   0,  14,  13,  15,  17,  17,  18,  18,  18,  18,
  18,  18,  16,  25,  25,  27,  26,  28,  28,  29,
  29,  29,  30,  30,  30,  31,  31,  32,  32,   9,
  12,   7,  34,  35,  24,  33,  36,  33,  37,  20,
  38,  38,  39,  39,  39,  39,  39,   8,  40,  43,
  45,  43,  44,  44,  46,  47,  46,  48,  48,  48,
   6,   4,   4,  50,  49,  41,  51,  52,  54,  21,
  55,  55,  58,  60,  55,  53,  53,  53,  61,  61,
  56,  62,  62,  63,  63,  57,  57,  59,  59,  64,
  64,  65,  65,  65,  69,  68,  70,  70,  70,   2,
   2,   2,  71,  66,  67,  73,  73,  74,  74,  72,
  72,   3,   3,   3,  11,  11,  11,  11,  10,  10,
  75,  75,  75,  75,  75,  75,  75,  75,  75,  75,
  75,  76,  19,  77,  77,  78,  78,  78,  79,  79,
  80,  80,   1,   1,   1,   1,   1,   5,   5,  81,
  42,  42,  83,  42,  82,  82,  84,  84,  85,  85,
  85,  86,  22,  87,  88,  88,  88,  89,  89,  90,
  90,  90,  90,  90,  90,  90,  90,  91,  92,  92,
  92,  23,  93,  95,  95,  95,  96,  96,  94,  97,
  97,  97,  98,  98,  98,  98,  99, 101, 100, 100 };
YYSTATIC yyr_t YYFARDATA YYR2[]={

   0,   0,   2,   2,   1,   2,   1,   1,   1,   1,
   1,   1,   2,   2,   1,   0,   4,   0,   2,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   0,   4,
   4,   4,   0,   0,   6,   0,   0,   3,   0,   6,
   0,   3,   1,   1,   1,   1,   1,   3,   4,   2,
   0,   6,   0,   1,   0,   0,   4,   0,   1,   3,
   1,   1,   1,   0,   4,   7,   0,   0,   0,   9,
   2,   1,   0,   0,   6,   0,   2,   1,   1,   3,
   4,   0,   3,   1,   3,   0,   4,   0,   2,   3,
   3,   0,   4,   2,   0,   2,   0,   1,   3,   1,
   1,   1,   0,   2,   4,   0,   1,   1,   3,   1,
   3,   2,   2,   1,   2,   2,   1,   1,   1,   1,
   3,   3,   3,   3,   3,   3,   1,   1,   1,   2,
   2,   0,   5,   0,   3,   1,   1,   1,   2,   2,
   6,   4,   3,   3,   1,   1,   3,   1,   1,   0,
   5,   4,   0,   4,   3,   1,   1,   3,   1,   1,
   1,   0,   4,   3,   0,   1,   3,   3,   1,   3,
   3,   2,   2,   2,   2,   1,   1,   3,   0,   1,
   3,   4,   4,   0,   1,   3,   3,   1,   3,   0,
   1,   3,   4,   4,   4,   6,   2,   4,   0,   2 };
YYSTATIC short YYFARDATA YYCHK[]={

-1000, -13, -14, -15, -16, -25, 278, -17, -18, -19,
 -20, -21, -22, -23, -24, 284, 279, 283, 297, 298,
 260, -26, 123,  -4, 260, 261, -18, 123, 260, -51,
 -86, 299, -33,  40, -27, -76, -37,  40,  -4, -93,
  -4, -34, -36, -28, -77, 123, 260, -87, 123, -94,
 123,  40, 123,  41, 125, -29,  -9, -12,  -7, 269,
 291, 266, 125, -78, -79, -80, -42, 271, 289, 285,
 286, -38, -52, -88, -89, -90,  -4, -10, 308, 263,
 262, -97, -98, -99, 296, -95, -96, 260, -35, -30,
  58,  61, 272, -30, -30,  59, 287,  -5, 260, 286,
  -5, 286, 260, -30, 125, -39,  -8, -40, -41, -42,
 256, 276, 289, 282, -53, 124, 256, 125,  44, -30,
 308, 308, -10,  -4, 125,  44, 303, 300, 302, 305,
 262,  41,  44, 295, 125, 261, -10, 261, -30, -30,
 -30, -83,  59, -30, -30, -30,  41, -61, 260, -89,
  -4,  -4, -10, -98,  -4, -32, -31, 306, 301,-101,
 304, -32, -96,  -4,  59,  59,  59,  -1, 264, 294,
 293, 292, -81, -82,  91, -85, 261, 260, -11,  45,
  43, -10, 275, -82, 261, 268,  40, -54,  44,-100,
 277, -91,  40,-100,  40,  -4,  44, 280, 280, -82,
 -84, -85, -10, -10, -43, 297,  91,  -3,  45,  43,
 262, -55, -56,  59, 123, -30, 260,  -4, -92, -90,
  -4, -72, -11, -32, 261, 294, 293, -49,  91,  93,
  44,  -4, 262,  44, 262, 262,  59, -57, 270, 298,
  41,  44,  44,  41, -91, -50, -85,  93,  -3, -58,
 -30, 260, -90, -11, -48,  -6,  -4, -44, -30,  41,
 -59, 260, -62,  40,  44,  93, -45, -60, -64, -65,
  40, 267,  59, -63, 260,  -6, -46, 123, 125, -66,
 -67, -71, 260, -68, -69, -30,  41,  44, -47,  59,
  59, -72,  40,  41, -70,  -2, 262, 260, 261, 260,
 -48, -73, -74, -75,  40, 260, -10, 261,  45,  43,
 -30,  44, 125,  41,  44,  43,  45,  42,  47,  94,
 -75, -75, -75,  -2, -75, -75, -75, -75, -75, -75,
  41 };
YYSTATIC short YYFARDATA YYDEF[]={

   1,  -2,   0,   2,   0,   0,  14,   3,   4,   6,
   7,   8,   9,  10,  11,   0,   0,  66, 161,   0,
  35,  12,  15,  13,  61,  62,   5, 131,  38,   0,
   0,   0,  32,  36,  17, 133,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  40,  67, 162, 164, 181,
 189, 183,  33,  37,  16,  18,  19,  20,  21,   0,
   0,   0, 132,   0, 135, 136, 137,   0,   0,   0,
   0,   0,  75,   0, 165,   0,  -2, 175,   0, 118,
 119,   0, 190,   0,   0,   0, 184, 187,   0,   0,
  22,  23,  24,   0,   0, 134, 138, 139, 147, 148,
   0,   0,   0, 152,  39,   0,  42,  43,  44,  45,
  46,   0,   0,   0,   0,   0,  77, 163,   0,   0,
 174, 173, 171, 172, 188,   0,   0,  28,   0,  28,
 196, 182,   0,   0,  34,   0,   0,   0,   0, 149,
   0,   0,  41,   0,   0,   0,  68,  76,  78, 166,
 167, 170, 169, 191, 198,   0,  27,  25,  26, 198,
   0,   0, 185, 186,  29,  30,  31, 141,   0, 144,
 145,   0,   0, 151,   0, 155, 158, 159, 160,   0,
   0, 116, 117, 153,  47,   0,   0,   0,   0, 192,
   0, 193, 178, 194,   0,  28,   0,   0,   0, 150,
   0, 156, 114, 115,  48,   0,   0,   0,   0,   0,
 113,  69,   0,  71,  85,   0,  79, 199,   0, 179,
 176,   0, 109,   0, 140, 142, 143, 146,  63, 154,
   0,  49,   0,   0, 111, 112,  70,  72,   0,   0,
 177,   0,   0, 197, 195,  57, 157,  52,   0,  87,
   0,  81, 180, 110,   0,  58,  60,  50,  53,  65,
  -2,   0,  80,   0,   0,  64,  54,   0,  88, 102,
  94,   0,  86,   0,  83,  59,  51,  55,  74,   0,
   0,   0,   0,   0,  96,  93,  82,   0,  57,  89,
  90, 103, 105,   0,  95,  97,  99, 100, 101,  84,
   0,   0, 106, 107,   0, 126, 127, 128,   0,   0,
  92,   0,  56, 104,   0,   0,   0,   0,   0,   0,
   0, 129, 130,  98, 108, 121, 122, 123, 124, 125,
 120 };
#ifdef YYRECOVER
YYSTATIC short yyrecover[] = {
-1000	};
#endif
/* SCCSWHAT( "@(#)yypars.c	3.1 88/11/16 22:00:49	" ) */
#line 3 "yypars.c"
# define YYFLAG 	-1000
# define YYERROR 	goto yyerrlab
# define YYACCEPT 	return 0
# define YYABORT 	return 1

#ifdef YYDEBUG				/* RRR - 10/9/85 */
	#define yyprintf(a, b, c, d) 	printf(a, b, c, d)
#else
	#define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
	#define	YYPRINT		printf
#endif

/*	parser for yacc output	*/

#ifdef YYDUMP
int yydump = 1; /* 1 for dumping */
void yydumpinfo(void);
#endif
#ifdef YYDEBUG
YYSTATIC int 	yydebug = 0; 			/* 1 for debugging */
#endif

#ifndef YYVGLOBAL
YYSTATIC
#endif
		YYSTYPE 	yyv[YYMAXDEPTH];	/* where the values are stored */
YYSTATIC short		yys[YYMAXDEPTH];	/* the parse stack */

#if ! defined(YYRECURSIVE)
YYSTATIC int 	yychar    = -1;			/* current input token number */
YYSTATIC int 	yynerrs   =  0;			/* number of errors */
YYSTATIC short 	yyerrflag =  0;			/* error recovery flag */
#endif

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC
char	*yyscpy(register char* t, register char* f)
{
	while (*t = *f++)
		t++;

	return t;	/*  ptr to the null char  */
}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif

#if defined(YYRECURSIVE)

	YYSTATIC int yychar = -1;			/* current input token number */
	YYSTATIC int yynerrs = 0;			/* number of errors */
	YYSTATIC short yyerrflag = 0;		/* error recovery flag */

	YYSTATIC short	yyn;
	YYSTATIC short	yystate = 0;
	YYSTATIC short	*yyps= &yys[-1];
	YYSTATIC YYSTYPE	*yypv= &yyv[-1];
	YYSTATIC short	yyj;
	YYSTATIC short	yym;

#endif

YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
#if !defined(YYRECURSIVE)

	register	short	yyn;
	short		yystate = 0;
	short*		yyps    = &yys[-1];
	YYSTYPE*	yypv    = &yyv[-1];
	short		yyj, yym;
#endif

#ifdef YYDUMP
	yydumpinfo();
#endif
  yystack:	 /* put a state and value onto the stack */
	yyprintf("state %d, char %d\n", yystate, yychar, 0);

	if (++yyps > &yys[YYMAXDEPTH])
	{
		yyerror("yacc stack overflow");
		YYABORT;
	}

	*yyps = yystate;
	++yypv;

	*yypv = yyval;

yynewstate:

	yyn = YYPACT[yystate];

	if (yyn <= YYFLAG)		/*  simple state, no lookahead  */
		goto yydefault;

	if (yychar < 0) 		/*  need a lookahead */
		yychar = YYLEX();

	if (((yyn += (short)yychar) < 0) || (yyn >= YYLAST))
		goto yydefault;

	if (YYCHK[ yyn = YYACT[yyn]] == yychar)
	{		
		/* valid shift */
		yychar  = -1;
		yyval   = yylval;
		yystate = yyn;

		if (yyerrflag > 0)
			--yyerrflag;
		goto yystack;
	}

 yydefault:
	/* default state action */
	if ((yyn = YYDEF[yystate]) == -2)
	{
		register short*		yyxi;

		if (yychar < 0)
			yychar = YYLEX();

/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		for (yyxi = yyexca + yyexcaind[yystate]; *yyxi != yychar && *yyxi >= 0; yyxi += 2)
			;
#else
		for (yyxi = yyexca; *yyxi != -1 || yyxi[1] != yystate; yyxi += 2)
			;

		while (*(yyxi += 2) >= 0)
		{
			if (*yyxi == yychar)
				break;
		}
#endif

		if ((yyn = yyxi[1]) < 0)
		{
			YYACCEPT;		//	accept
		}
	}

	if (yyn == 0)		/* error */
	{
		/* error ... attempt to resume parsing */

		switch (yyerrflag)
		{
		  case 0:		/* brand new error */
#ifdef YYRECOVER
			{
				register	int		i,j;

				for (i = 0; yyrecover[i] != -1000 && yystate > yyrecover[i]; i += 3)
					;

				if (yystate == yyrecover[i])
				{
					yyprintf("recovered, from state %d to state %d on token %d\n",
										yystate, yyrecover[i + 2], yyrecover[i + 1]);

					j = yyrecover[i + 1];

					if (j < 0)
					{
						/*
						**  here we have one of the injection set, so we're not quite
						**  sure that the next valid thing will be a shift. so we'll
						**  count it as an error and continue.
						**  actually we're not absolutely sure that the next token
						**  we were supposed to get is the one when j > 0. for example,
						**  for(+) {;} error recovery with yyerrflag always set, stops
						**  after inserting one ; before the +. at the point of the +,
						**  we're pretty sure the guy wants a 'for' loop. without
						**  setting the flag, when we're almost absolutely sure, we'll
						**  give him one, since the only thing we can shift on this
						**  error is after finding an expression followed by a +
						*/
						yyerrflag++;
						j = -j;
					}

					if (yyerrflag <= 1)
					{	
						/*  only on first insertion  */
						yyrecerr(yychar, j);		/*  what was, what should be first */
					}

					yyval   = yyeval(j);
					yystate = yyrecover[i + 2];
					goto yystack;
				}
			}
#endif
			yyerror("syntax error");

		  yyerrlab:
			++yynerrs;

		  case 1:
	  	  case 2: /* incompletely recovered error ... try again */
			yyerrflag = 3;

			/* find a state where "error" is a legal shift action */
			while (yyps >= yys)
			{
			   yyn = YYPACT[*yyps] + YYERRCODE;

			   if (yyn>= 0 && yyn < YYLAST && YYCHK[YYACT[yyn]] == YYERRCODE)
			   {
			      yystate = YYACT[yyn];  /* simulate a shift of "error" */
			      goto yystack;
			   }
			   yyn = YYPACT[*yyps];

			   /* the current yyps has no shift onn "error", pop stack */
				yyprintf("error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1], 0);
			   --yyps;
			   --yypv;
			}

			/* there is no state on the stack with an error shift ... abort */
		  yyabort:
		  	YYABORT;

		  case 3:  /* no shift yet; clobber input char */
			yyprintf("error recovery discards char %d\n", yychar, 0, 0);

			if (yychar == 0)
				goto yyabort; /* don't discard EOF, quit */

			yychar = -1;
			goto yynewstate;   /* try again in the same state */
		}
	}

	/* reduction by production yyn */
  yyreduce:
	{
		register	YYSTYPE	*yypvt;
		yyprintf("reduce %d\n",yyn, 0, 0);
		yypvt = yypv;
		yyps -= YYR2[yyn];
		yypv -= YYR2[yyn];
		yyval = yypv[1];
		yym = yyn;
		yyn = (short)YYR1[yyn];	/* consult goto table to find next state */
		yyj = YYPGO[yyn] + *yyps + 1;

		if (yyj >= YYLAST || YYCHK[yystate = YYACT[yyj]] != -yyn)
		{
			yystate = YYACT[YYPGO[yyn]];
		}
#ifdef YYDUMP
		yydumpinfo();
#endif
		switch (yym)
		{
			
case 1:
#line 76 "parser.y"
{ yyclearin; } break;
case 13:
#line 97 "parser.y"
{ SetNetworkSymb(yypvt[-0].zsr); } break;
case 15:
#line 100 "parser.y"
{ _eBlk = EBLKNET;  } break;
case 16:
#line 102 "parser.y"
{ _eBlk = EBLKNONE; } break;
case 19:
#line 109 "parser.y"
{	SetFormat(yypvt[-0].zsr);	} break;
case 20:
#line 110 "parser.y"
{   SetVersion(yypvt[-0].real); } break;
case 21:
#line 111 "parser.y"
{   SetCreator(yypvt[-0].zsr); } break;
case 29:
#line 128 "parser.y"
{ yyval.zsr = yypvt[-1].zsr; } break;
case 30:
#line 131 "parser.y"
{ yyval.real = yypvt[-1].real; } break;
case 31:
#line 134 "parser.y"
{ yyval.zsr = yypvt[-1].zsr; } break;
case 32:
#line 138 "parser.y"
{ _eBlk = EBLKIGN; WarningSkip(yypvt[-1].zsr); } break;
case 33:
#line 140 "parser.y"
{ SkipUntil("}"); } break;
case 34:
#line 141 "parser.y"
{ _eBlk = EBLKNONE;	} break;
case 36:
#line 145 "parser.y"
{ SkipUntil(")"); } break;
case 38:
#line 150 "parser.y"
{ _eBlk = EBLKNODE; StartNodeDecl(yypvt[-0].zsr); } break;
case 39:
#line 153 "parser.y"
{ CheckNodeInfo(); _eBlk = EBLKNONE; } break;
case 47:
#line 167 "parser.y"
{ SetNodeFullName(yypvt[-0].zsr); } break;
case 49:
#line 173 "parser.y"
{ SetNodeDomain(yypvt[-0].zsr); } break;
case 50:
#line 174 "parser.y"
{ SetNodeCstate(yypvt[-2].ui); } break;
case 55:
#line 182 "parser.y"
{ ClearCstr(); } break;
case 56:
#line 182 "parser.y"
{ SetStates();		} break;
case 60:
#line 190 "parser.y"
{ AddStr(yypvt[-0].zsr); } break;
case 63:
#line 196 "parser.y"
{ ClearCstr(); } break;
case 65:
#line 199 "parser.y"
{ SetNodePosition(yypvt[-3].integer, yypvt[-1].integer); } break;
case 66:
#line 203 "parser.y"
{ _eBlk = EBLKPROB; ClearNodeInfo(); } break;
case 67:
#line 205 "parser.y"
{ SetNodeSymb(yypvt[-0].zsr, false); } break;
case 68:
#line 207 "parser.y"
{ CheckParentList(); } break;
case 69:
#line 208 "parser.y"
{ _eBlk = EBLKNONE;		} break;
case 71:
#line 212 "parser.y"
{ EmptyProbEntries(); } break;
case 72:
#line 215 "parser.y"
{ InitProbEntries(); } break;
case 73:
#line 217 "parser.y"
{ CheckProbEntries(); } break;
case 78:
#line 226 "parser.y"
{ AddSymb(yypvt[-0].zsr); } break;
case 79:
#line 227 "parser.y"
{ AddSymb(yypvt[-0].zsr); } break;
case 86:
#line 241 "parser.y"
{ CheckCIFunc(yypvt[-1].zsr);   } break;
case 91:
#line 252 "parser.y"
{ _vui.clear(); CheckDPI(false);	} break;
case 92:
#line 253 "parser.y"
{ CheckDPI(false);				} break;
case 93:
#line 254 "parser.y"
{ CheckDPI(true);				} break;
case 94:
#line 257 "parser.y"
{ _vui.clear(); } break;
case 97:
#line 261 "parser.y"
{ AddUi(yypvt[-0].ui); } break;
case 98:
#line 262 "parser.y"
{ AddUi(yypvt[-0].ui); } break;
case 99:
#line 265 "parser.y"
{ yyval.ui = UiDpi(yypvt[-0].ui);	} break;
case 100:
#line 266 "parser.y"
{ yyval.ui = UiDpi(yypvt[-0].zsr);	} break;
case 101:
#line 267 "parser.y"
{ yyval.ui = UiDpi(yypvt[-0].zsr);	} break;
case 102:
#line 270 "parser.y"
{ _vreal.clear(); } break;
case 103:
#line 270 "parser.y"
{ CheckProbVector(); } break;
case 104:
#line 273 "parser.y"
{ CheckPDF(yypvt[-3].zsr); } break;
case 109:
#line 284 "parser.y"
{ AddReal(yypvt[-0].real); } break;
case 110:
#line 285 "parser.y"
{ AddReal(yypvt[-0].real); } break;
case 111:
#line 289 "parser.y"
{ yyval.integer = -INT(yypvt[-0].ui); } break;
case 112:
#line 290 "parser.y"
{ yyval.integer = +INT(yypvt[-0].ui); } break;
case 113:
#line 291 "parser.y"
{ yyval.integer =  INT(yypvt[-0].ui); } break;
case 114:
#line 294 "parser.y"
{ yyval.real = -yypvt[-0].real; } break;
case 115:
#line 295 "parser.y"
{ yyval.real =  yypvt[-0].real; } break;
case 117:
#line 297 "parser.y"
{ yyval.real = -1;	} break;
case 118:
#line 300 "parser.y"
{ yyval.real =      yypvt[-0].real;  } break;
case 119:
#line 301 "parser.y"
{ yyval.real = REAL(yypvt[-0].ui); } break;
case 126:
#line 310 "parser.y"
{ CheckIdent(yypvt[-0].zsr); } break;
case 131:
#line 319 "parser.y"
{ StartProperties(); } break;
case 132:
#line 321 "parser.y"
{ EndProperties(); } break;
case 138:
#line 331 "parser.y"
{ ImportPropStandard(); } break;
case 139:
#line 332 "parser.y"
{ ImportProp(yypvt[-0].zsr);		} break;
case 140:
#line 335 "parser.y"
{ AddPropType(yypvt[-4].zsr, yypvt[-2].ui, yypvt[-0].zsr);			} break;
case 141:
#line 336 "parser.y"
{ AddPropType(yypvt[-2].zsr, yypvt[-0].ui, ZSREF());		} break;
case 142:
#line 339 "parser.y"
{ yyval.ui = fPropString | fPropArray;	} break;
case 143:
#line 340 "parser.y"
{ yyval.ui = fPropArray;					} break;
case 144:
#line 341 "parser.y"
{ yyval.ui = fPropString;					} break;
case 145:
#line 342 "parser.y"
{ yyval.ui = 0;							} break;
case 146:
#line 343 "parser.y"
{ yyval.ui = fPropChoice;					} break;
case 149:
#line 352 "parser.y"
{ ClearVpv(); } break;
case 150:
#line 352 "parser.y"
{ CheckProperty(yypvt[-3].zsr); } break;
case 152:
#line 354 "parser.y"
{ ClearVpv(); } break;
case 153:
#line 354 "parser.y"
{ CheckProperty(yypvt[-3].zsr); } break;
case 158:
#line 365 "parser.y"
{ AddPropVar( yypvt[-0].zsr ); } break;
case 159:
#line 366 "parser.y"
{ AddPropVar( yypvt[-0].zsr ); } break;
case 160:
#line 367 "parser.y"
{ AddPropVar( yypvt[-0].real ); } break;
case 161:
#line 371 "parser.y"
{ ClearDomain();	} break;
case 162:
#line 373 "parser.y"
{ CheckDomain( yypvt[-1].zsr ); } break;
case 167:
#line 385 "parser.y"
{  AddRange(yypvt[-0].zsr, false ); } break;
case 168:
#line 386 "parser.y"
{  AddRange(yypvt[-0].zsr, true ); } break;
case 169:
#line 393 "parser.y"
{  SetRanges( true, yypvt[-2].real, true, yypvt[-0].real );		} break;
case 170:
#line 395 "parser.y"
{  SetRanges( yypvt[-2].zsr, yypvt[-0].zsr );					} break;
case 171:
#line 397 "parser.y"
{  SetRanges( false, 0.0, true, yypvt[-0].real );	} break;
case 172:
#line 399 "parser.y"
{  SetRanges( ZSREF(), yypvt[-0].zsr );			} break;
case 173:
#line 401 "parser.y"
{  SetRanges( true, yypvt[-1].real, false, 0.0 );	} break;
case 174:
#line 403 "parser.y"
{  SetRanges( yypvt[-1].zsr, ZSREF() );			} break;
case 175:
#line 405 "parser.y"
{  SetRanges( true, yypvt[-0].real, true, yypvt[-0].real );		} break;
case 176:
#line 407 "parser.y"
{  SetRanges( yypvt[-0].zsr, yypvt[-0].zsr );					} break;/* End of actions */
		}
	}
	goto yystack;  	/* stack new state and value */
}



#ifdef YYDUMP
YYLOCAL
void YYNEAR YYPASCAL yydumpinfo(void)
{
	short stackindex;
	short valindex;

	//dump yys
	printf("short yys[%d] {\n", YYMAXDEPTH);
	for (stackindex = 0; stackindex < YYMAXDEPTH; stackindex++){
		if (stackindex)
			printf(", %s", stackindex % 10 ? "\0" : "\n");
		printf("%6d", yys[stackindex]);
		}
	printf("\n};\n");

	//dump yyv
	printf("YYSTYPE yyv[%d] {\n", YYMAXDEPTH);
	for (valindex = 0; valindex < YYMAXDEPTH; valindex++){
		if (valindex)
			printf(", %s", valindex % 5 ? "\0" : "\n");
		printf("%#*x", 3+sizeof(YYSTYPE), yyv[valindex]);
		}
	printf("\n};\n");
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\parsfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       parsfile.cpp
//
//--------------------------------------------------------------------------

//
//	parsfile.cpp
//
#include "basics.h"
#include "parsfile.h"

PARSIN :: ~ PARSIN ()
{
}

PARSOUT :: ~ PARSOUT ()
{
}

void PARSOUT :: Fprint ( SZC szcFmt, ... ) 
{
	va_list	valist;
	va_start( valist, szcFmt );
	
	Vsprint( szcFmt, valist ) ;
	
	va_end( valist );
}

PARSIN_DSC :: PARSIN_DSC ()
	:_pfile(NULL)
{
}

PARSIN_DSC :: ~ PARSIN_DSC ()
{
	Close();
}

void PARSIN_DSC :: Close ()
{
	if ( _pfile )
		::fclose(_pfile);
	_pfile = NULL;
}

bool PARSIN_DSC :: Open ( SZC szcFileName, SZC szcMode )
{
	Close();
	_pfile = ::fopen(szcFileName,szcMode);
	_zsFn = szcFileName;
	return _pfile != NULL;
}

int PARSIN_DSC :: Getch ()
{
	if ( ! _pfile )
		return EOF;
	return ::fgetc(_pfile);
}

bool PARSIN_DSC :: BEof ()
{
	return feof(_pfile);
}

bool PARSIN_DSC :: BOpen ()	
{
	return _pfile != NULL;
}

PARSOUT_STD :: PARSOUT_STD ( FILE * pfile )
	: _pfile(pfile)
{
}

PARSOUT_STD :: ~ PARSOUT_STD ()
{
	_pfile = NULL;
}

void PARSOUT_STD :: Vsprint ( SZC szcFmt, va_list valist ) 
{
	if ( _pfile == NULL )
		return;

	vfprintf( _pfile, szcFmt, valist );	
}

void PARSOUT_STD :: Flush ()
{
	if ( _pfile )
		fflush(_pfile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\parsfile.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       parsfile.h
//
//--------------------------------------------------------------------------

//
//	parsfile.h: abstract classes for parser I/O
//
//		This abstraction layer allows parser input and output to be
//		redirected as needed.
//
#ifndef _PARSFILE_H_
#define	_PARSFILE_H_

#include <stdio.h>
#include <stdarg.h>
#include "zstr.h"

typedef const char * SZC;

//
//	PARSIN: abstract base class for parser input file handling
//
class PARSIN 
{
  public:
	PARSIN () {}
	virtual ~ PARSIN ();
	virtual void Close () = 0;
	virtual bool Open ( SZC szcFileName, SZC szcMode = "r") = 0;
	virtual int Getch () = 0;
	virtual bool BEof () = 0;
	virtual bool BOpen () = 0;
	const ZSTR & ZsFn () const 
		{ return _zsFn; }
  protected:
	ZSTR _zsFn;
};

//
//	PARSOUT:  abstract base class for parser output file
//
class PARSOUT
{
  public:
    PARSOUT () {}
	virtual ~ PARSOUT ();
	//  Print generic formatted information
	virtual void Vsprint ( SZC szcFmt, va_list valist ) = 0;
	//  Notify about error and warning information
	virtual void ErrWarn ( bool bErr, int iLine ) {}
	virtual void Flush () {}
	//  Simple output 
	void Fprint ( SZC szcFmt, ... );
};


//
//	PARSIN_DSC:  parser DSC file input based on stdio.h
//	
class PARSIN_DSC : public PARSIN
{
  public:
	PARSIN_DSC ();
	~ PARSIN_DSC ();
	void Close ();
	bool Open ( SZC szcFileName, SZC szcMode = "r" );
	int Getch ();
	bool BEof ();
	bool BOpen ();

  protected:
	FILE * _pfile;
};

//
//	PARSOUT_STD: parser output data stream based on stdio.h
//
class PARSOUT_STD : public PARSOUT
{
  public:
    PARSOUT_STD ( FILE * pfile = NULL );
	virtual ~ PARSOUT_STD ();
	void Vsprint ( SZC szcFmt, va_list valist );
	void Flush ();

  protected:
	FILE * _pfile;
};

#endif // _PARSFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\parmio.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       parmio.cpp
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////////
//
//  PARMIO.CPP:  Parameter file I/O routines
//
//////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <ctype.h>

#include "parmio.h"


PARMOUTSTREAM :: PARMOUTSTREAM ()
{
}

PARMOUTSTREAM :: ~ PARMOUTSTREAM ()
{
	close();
}

void PARMOUTSTREAM :: close ()
{
	while ( BEndBlock() );
	ofstream::close();
}

void PARMOUTSTREAM :: StartChunk (
	PARMBLK::EPBLK eBlk,
	SZC szc,
	int indx )
{
	_stkblk.push_back( PARMBLK(eBlk,szc,indx) );
	const PARMBLK & prmblk = _stkblk.back();
	self.nl();
	if ( szc )
	{
		Stream() << szc;
		if ( indx >= 0 )
		{
			self << CH_INDEX_OPEN << indx << CH_INDEX_CLOSE;
		}
	}
	switch( prmblk._eBlk )
	{
		case PARMBLK::EPB_VAL:
			if ( szc )
				self << CH_EQ;
			break;
		case PARMBLK::EPB_BLK:
			self.nl();
			self << CH_BLOCK_OPEN;
			break;
	}
}

void PARMOUTSTREAM :: StartBlock (
	SZC szc,
	int indx )
{
	StartChunk( PARMBLK::EPB_BLK, szc, indx );
}

void PARMOUTSTREAM :: StartItem (
	SZC szc,
	int indx )
{
	StartChunk( PARMBLK::EPB_VAL, szc, indx );
}

bool PARMOUTSTREAM :: BEndBlock ()
{
	if ( _stkblk.size() == 0 )
		return false;
	const PARMBLK & prmblk = _stkblk.back();
	switch( prmblk._eBlk )
	{
		case PARMBLK::EPB_VAL:
			self << CH_DELM_ENTRY;
			break;
		case PARMBLK::EPB_BLK:
			nl();
			self << CH_BLOCK_CLOSE;
			break;
	}
	_stkblk.pop_back();
	return true;
}

void PARMOUTSTREAM :: nl ()
{
	self << '\n';
	for ( int i = 1 ; i < _stkblk.size(); ++i)
	{
		self << '\t';
	}
}


/*
	The general YACC-style form of a parameter file is:

	itemlist :	// empty
		     |  itemlist itemunit
			 ;

	itemunit :  itemdesc itembody
			 ;

	itemdesc :  itemname '[' itemindex ']'
			 |  itemname
			 ;

	itembody :  itemblock ';'
			 |  itemvalue ';'
			 ;
			
    itemblock : '{'  itemlist '}'
			  ;

	itemvalue :  '=' itemclump
			  ;
	

	An "itemclump" is a self-describing value, comprised of quoted
	strings and parenthetically nested blocks.

 */

static const char rgchWhite [] =
{
	' ',
	'\n',
	'\t',
	'\r',
	0
};

PARMINSTREAM :: PARMINSTREAM ()
	: _iline(0),
	_zsWhite(rgchWhite)
{
}

PARMINSTREAM :: ~ PARMINSTREAM ()
{
}

void PARMINSTREAM ::  close()
{
	_stkblk.clear();
	ifstream::close();
}

bool PARMINSTREAM :: BIswhite ( char ch )
{
	return _zsWhite.find(ch) < _zsWhite.length() ;	
}

int PARMINSTREAM :: IGetc ()
{
	char ich;
	self >> ich;
	if ( ich == '\n' )
		_iline++;

	return ich;
}

void PARMINSTREAM :: ScanQuote ( char ch )
{
	int imeta = 2;
	int iline = _iline;
	do
	{
		int chNext = IGetc();
		if ( rdstate() & ios::eofbit )
			ThrowParseError("EOF in quote", iline, ECPP_UNMATCHED_QUOTE);

		switch ( chNext )
		{
			case '\'':
			case '\"':
				if ( imeta != 1  && ch == chNext )
					imeta = -1;
				else
					ScanQuote((char)chNext);
				break;
			case '\\':
				imeta = 0;
				break;
			default:
				assert( chNext >= 0 );
				break;
		}
		if ( imeta++ < 0 )
			break;
	}
	while ( true );
}

void PARMINSTREAM :: ScanBlock ( char ch )
{
	int iline = _iline;
	do
	{
		int chNext = IGetc();
		if ( rdstate() & ios::eofbit )
			ThrowParseError("EOF in block", iline, ECPP_UNEXPECTED_EOF);

		switch ( chNext )
		{
			case CH_DELM_OPEN:
				ScanBlock((char)chNext);
				break;
			case CH_DELM_CLOSE:
				return;				
				break;
			case '\'':
			case '\"':
				ScanQuote((char)chNext);
				break;
			default:
				assert( chNext >= 0 );
				break;
		}
	}
	while ( true );
}

int PARMINSTREAM :: IScanUnwhite ( bool bEofOk )
{
	int chNext;
	do
	{
		chNext = IGetc();
		if ( rdstate() & ios::eofbit )
		{
			if ( bEofOk )
				return -1;
			ThrowParseError("Unexpected EOF", -1, ECPP_UNEXPECTED_EOF);
		}
	}
	while ( BIswhite((char)chNext) ) ;
	return chNext;
}

void PARMINSTREAM :: ScanClump ()
{
	int iline = _iline;
	char chNext;
	do
	{
		switch ( chNext = (char)IScanUnwhite() )
		{
			case CH_DELM_ENTRY:		// ';'
				putback(chNext);
				return;
				break;

			case CH_DELM_OPEN:		// '('
				ScanBlock( chNext );
				break;
			case '\'':
			case '\"':
				ScanQuote( chNext );
				break;
		}
	}
	while ( true );
}

void PARMINSTREAM :: ScanName ( ZSTR & zsName )
{
	zsName.empty();
	/*for ( char chNext = IScanUnwhite();
		  zsName.length() ? __iscsymf(chNext) : __iscsym(chNext) ;
		  chNext = IGetc() )
	{
		zsName += chNext;
	} */

	// This loop is giving me errors when there is a digit in a name...
	// I think that the ? and : are reversed. __iscsymf is false if
	// the character is a digit... I assume that the required behavior
	// is that a digit cannot be the first character in a name, as opposed
	// to a digit can ONLY be the first character:

	for ( char chNext = (char)IScanUnwhite();	; chNext = (char)IGetc() )
	{
		if (zsName.length() == 0)
		{
			if (__iscsymf(chNext) == false)
			{
				// Looking for the first character in a name, and
				// the next character is not a letter or an underscore:
				// stop parsing the name.

				break;
			}
		}
		else
		{
			// (Max) 2/1/97
			//
			// I'm using '?' in names to denote booleans... this seems
			// to be reasonable, but if someone has objections this
			// can change

			if (__iscsym(chNext) == false && chNext != '?')
			{
				// Reached the end of a string of alpha-numeric
				// characters: stop parsing the name.

				break;
			}
		}

		// The next character is a valid extension of the current
		// name: append to the name and continue

		zsName += chNext;
	}

	
	putback(chNext);
}

void PARMINSTREAM :: ScanItemDesc ( ZSTR & zsName, int & indx )
{
	zsName.empty();
	indx = -1;
	ScanName(zsName);
	if ( zsName.length() == 0 )
		ThrowParseError("Invalid item or block name", -1, ECPP_INVALID_NAME );
	int chNext = IScanUnwhite();
	if ( chNext == CH_INDEX_OPEN )
	{
		self >> indx;
		chNext = IScanUnwhite();
		if ( chNext != CH_INDEX_CLOSE )
			ThrowParseError("Invalid item or block name", -1, ECPP_INVALID_NAME );
	}
	else
		putback((char)chNext);
}

PARMBLK::EPBLK PARMINSTREAM :: EpblkScanItemBody ( streamoff & offsData )
{	
	int iline = _iline;
	int ch = IScanUnwhite();
	PARMBLK::EPBLK epblk = PARMBLK::EPB_NONE;
	offsData = tellg();
	switch ( ch )
	{
		case CH_EQ:
			//  'itemvalue'
			ScanClump();
			epblk = PARMBLK::EPB_VAL;
			ch = IScanUnwhite();
			if ( ch !=  CH_DELM_ENTRY )
				ThrowParseError("Invalid item or block body", iline, ECPP_INVALID_BODY );		
			break;
		case CH_BLOCK_OPEN:
			//  'itemblock'
			ScanItemList();
			epblk = PARMBLK::EPB_BLK;
			break;
		default:
			ThrowParseError("Invalid item or block body", iline, ECPP_INVALID_BODY );
			break;
	}
	return epblk;
}

void PARMINSTREAM :: ScanItemUnit ()
{
	//  Save the index of the current block	
	int iblk = _stkblk.size() - 1;
	{
		PARMBLKIN & blkin = _stkblk[iblk];
		blkin._iblkEnd = iblk;
		blkin._offsEnd  = blkin._offsBeg = tellg();
		ScanItemDesc( blkin._zsName, blkin._indx );
	}

	//  Because the block stack vector is reallocated within
	//		this recursively invoked routine, we must be careful
	//		to reestablish the address of the block.

	streamoff offsData;
	PARMBLK::EPBLK eblk = EpblkScanItemBody( offsData );

	{
		PARMBLKIN & blkin = _stkblk[iblk];
		blkin._eBlk = eblk ;
		blkin._offsEnd = tellg();
		--blkin._offsEnd;
		blkin._offsData = offsData;
		if ( eblk == PARMBLK::EPB_BLK )
			blkin._iblkEnd = _stkblk.size();
	}
}

void PARMINSTREAM :: ScanItemList ()
{
	for ( int ch = IScanUnwhite(true);
		  ch != CH_BLOCK_CLOSE ;
		  ch = IScanUnwhite(true) )
	{
		if ( rdstate() & ios::eofbit )
			return;
		putback((char)ch);
		_stkblk.resize( _stkblk.size() + 1 );	
		ScanItemUnit();
	}
}

void PARMINSTREAM :: ThrowParseError (
	SZC szcError,
	int iline,
	EC_PARM_PARSE ecpp )
{
	ZSTR zsErr;
	if ( iline < 0 )
		iline = _iline;
	zsErr.Format( "Parameter file parse error, line %d: %s",
				  szcError, iline );
	throw GMException( ECGM(ecpp), zsErr );
}

//  Build the rapid-access table
void PARMINSTREAM :: Scan ()
{
	_stkblk.clear();
	_iline = 0;
	seekg( 0 );
	ScanItemList();
	clear();
	seekg( 0 );
}

//  Find a block or item by name (and index).  'iblk' of -1
//	means "any block"; zero means at the outermost level.
//	Return subscript of block/item or -1 if not found.
int PARMINSTREAM :: IblkFind ( SZC szcName, int index, int iblkOuter )
{
	int iblk = 0;
	int iblkEnd = _stkblk.size();

	if ( iblkOuter >= 0 )
	{
		//  We have outer block scope, validate it
		if ( ! BBlkOk( iblkOuter ) )
			return -1;
		iblk = iblkOuter + 1;
		iblkEnd = _stkblk[iblkOuter]._iblkEnd;
	}

	ZSTR zsName(szcName);

	for ( ; iblk < iblkEnd; iblk++ )
	{
		PARMBLKIN & blkin = _stkblk[iblk];

		if ( blkin._zsName != zsName )
			continue;	// Not the correct name
		
		if ( index >= 0 && blkin._indx != index )
			continue;	// Not the correct index
		
		return iblk;	// This is it
	}
	return -1;
}

//	Return the name, index and type of the next block at this level or
//  false if there are no more items.
const PARMBLKIN * PARMINSTREAM :: Pparmblk ( int iblk, int iblkOuter )
{
	if ( ! BBlkOk( iblk ) )
		return NULL;
	
	int iblkEnd = _stkblk.size();

	if ( iblkOuter >= 0 )
	{
		//  We have outer block scope, validate it
		if ( ! BBlkOk( iblkOuter ) )
			return NULL;
		if ( iblk <= iblkOuter )
			return NULL;
		iblkEnd = _stkblk[iblkOuter]._iblkEnd;
	}
	if ( iblk >= iblkEnd )
		return NULL;
	return & _stkblk[iblk];
}

void PARMINSTREAM :: Dump ()
{
	int ilevel = 0;
	VINT viBlk;		//  The unclosed block stack

	for ( int i = 0 ; i < _stkblk.size(); i++ )
	{
		// close containing blocks
		int iblk = viBlk.size();
		while ( --iblk >= 0 )
		{
			if ( i < viBlk[iblk] )
				break;  // We're still within this block
		}
		if ( iblk+1 != viBlk.size() )
			viBlk.resize(iblk+1);

		PARMBLKIN & blkin = _stkblk[i];
		cout << '\n';
		for ( int t = 0; t < viBlk.size(); t++ )
		{
			cout << '\t';
		}
		cout << "(" << i << ":" << (UINT) viBlk.size() << ",";

		if ( blkin._eBlk == PARMBLK::EPB_BLK )
		{
			cout << "block:" << blkin._iblkEnd << ") " ;
			viBlk.push_back(blkin._iblkEnd);
		}
		else
		if ( blkin._eBlk == PARMBLK::EPB_VAL )
		{
			cout << "value) ";
		}
		else
		{
			cout << "?????) ";
		}
		cout << blkin._zsName;
		if ( blkin._indx >= 0 )
			cout << '[' << blkin._indx << ']';
		cout << "  (" << blkin._offsBeg << ',' << blkin._offsData << ',' << blkin._offsEnd << ')';

	}
}

bool PARMINSTREAM :: BSeekBlk ( int iblk )
{
	if ( iblk < 0 || iblk >= _stkblk.size() )
		return false;
	
	clear();
	seekg( _stkblk[iblk]._offsData, ios::beg );
	return true;
}

//  read the parameter into a string
bool PARMINSTREAM :: BSeekBlkString ( int iblk, ZSTR & zsParam )
{
	if ( ! BSeekBlk( iblk ) )
		return false;

	PARMBLKIN & blkin = _stkblk[iblk];
	streamsize cb = blkin._offsEnd - blkin._offsData;
	zsParam.resize(cb);
	read(zsParam.begin(),cb);
	return true;
}

PARMINSTREAM::Iterator::Iterator (
	PARMINSTREAM & fprm,
	SZC szcBlock,
	int index,
	int iblkOuter )
	: _fprm(fprm),
	_iblkOuter(iblkOuter),
	_iblk(0)
{
	if ( szcBlock )
	{
		_iblk = _fprm.IblkFind( szcBlock, index, _iblkOuter );
		if ( ! _fprm.BBlkOk( _iblk ) )
			_iblk = fprm.Cblk();
		else
			++_iblk;
	}
}

const PARMBLKIN * PARMINSTREAM :: Iterator :: PblkNext ()
{
	if ( ! _fprm.BBlkOk( _iblk ) )
		return NULL;
	const PARMBLKIN * presult = _fprm.Pparmblk(_iblk, _iblkOuter);
	if ( presult )
		++_iblk;
	return presult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\parmiox.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       parmiox.h
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////////
//
//  PARMIOX.H:  Parameter file I/O routines extended for older classes
//
//////////////////////////////////////////////////////////////////////////////////
#ifndef _PARMIOX_H_
#define _PARMIOX_H_

#include "parmio.h"

template<class _T> inline
PARMOUTSTREAM& operator << (PARMOUTSTREAM & ofs, const RG<_T> & rgt )
{
	UINT c = rgt.Celem();
	ofs << CH_DELM_OPEN;
	ofs << c;
	ofs << CH_PREAMBLE;
	for ( UINT i = 0; i < c; )
	{	
		ofs << rgt[i];
		if ( ++i != c )	
			ofs << ',' ;
	}
	ofs << CH_DELM_CLOSE;
	return ofs;
}

template<class _T> inline
PARMINSTREAM& operator >> (PARMINSTREAM & ifs, RG<_T> & rgt )
{
	char ch;
	ifs >> ch;
	if (ch != CH_DELM_OPEN)
		_THROW1(runtime_error("invalid block (1)"));
	UINT l;
	ifs >> l;
	ifs >> ch;
	if (ch != CH_PREAMBLE)
		_THROW1(runtime_error("invalid block (2)"));

	rgt.BxResize(l);
	for ( UINT i = 0 ; i < l; )
	{
		_T it;
		ifs >> it;
		rgt[i] = it;
		if ( ++i < l )
		{
			ifs >> ch;
			if (ch != CH_SEP)
				break;
		}
	}
	if ( i != l )
		_THROW1(runtime_error("invalid block (3)"));
	ifs >> ch;
	if (ch != CH_DELM_CLOSE)
		_THROW1(runtime_error("invalid block (4)"));
	return ifs;
}


#endif  // _PARMIOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\parmio.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       parmio.h
//
//--------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////////
//  PARMIO.H:  Parameter file I/O routines
//
//////////////////////////////////////////////////////////////////////////////////
#ifndef _PARMIO_H_
#define _PARMIO_H_

#include "stlstream.h"

//  Parameter defining a named, nestable and iteratable item in a 
//	parameter file.   There are currently two type: blocks and values.
//	A block is a grouping of values and other blocks.  A value is
//	a name = value pair.  Blocks are bounded by {}, values are terminated
//	by ';'.
struct PARMBLK
{
	enum EPBLK
	{
		EPB_NONE,		// nothing
		EPB_VAL,		// simple name = value syntax
		EPB_BLK,		// named block
		EPB_MAX
	};
	ZSTR _zsName;		// Name of value or block
	int _indx;			// index (-1 for "not present")
	EPBLK _eBlk;		// type of block

	PARMBLK ( EPBLK eBlk = EPB_NONE, SZC szc = NULL, int indx = -1 )
		: _eBlk( eBlk ),
		_indx(indx)
	{
		if ( szc )
			_zsName = szc;
	}
	bool operator == ( const PARMBLK & pblk ) const;
	bool operator != ( const PARMBLK & pblk ) const;
	bool operator > ( const PARMBLK & pblk ) const;
	bool operator < ( const PARMBLK & pblk ) const;
};

// Define a stack of PARMBLKs; used for output parameter file writing
class STKPARMBLK : public vector<PARMBLK> {};

//  Extended descriptor for a block read in from a parameter file.
//  Contains starting and ending offsets within the positionable stream.
struct PARMBLKIN : PARMBLK
{
	int _iblkEnd;			// index of last+1 item/block in scope of this block
    streamoff _offsBeg;		// Starting offset in the stream
	streamoff _offsEnd;		// Ending offset in the stream
	streamoff _offsData;	// Starting offset of the data in the block

	PARMBLKIN ( EPBLK eBlk = EPB_NONE, SZC szc = NULL, int indx = -1 )
		: PARMBLK(eBlk,szc,indx),
		_iblkEnd(-1),
		_offsBeg(-1),
		_offsEnd(-1),
		_offsData(-1)
	{
	}
	bool operator == ( const PARMBLKIN & pblkin ) const;
	bool operator != ( const PARMBLKIN & pblkin ) const;
	bool operator > ( const PARMBLKIN & pblkin ) const;
	bool operator < ( const PARMBLKIN & pblkin ) const;
};

//  Define a stack of input parameter blocks for parameter file reading
class STKPARMBLKIN : public vector<PARMBLKIN> {};

//////////////////////////////////////////////////////////////////////////////////
//
//	Class PARMOUTSTREAM.  An output stream of parameters.
//
//		Blocks and values are written out in sequence.  Blocks
//		are opened, filled and closed using member functions
//		and function templates.   All unclosed blocks are are
//		closed automatically during close().
//
//////////////////////////////////////////////////////////////////////////////////
class PARMOUTSTREAM : public ofstream
{
  public:
	PARMOUTSTREAM ();
	~ PARMOUTSTREAM ();

	void close ();
	void StartBlock ( SZC szc = NULL, int indx = -1 );
	void StartItem ( SZC szc = NULL, int indx = -1 );
	bool BEndBlock ();
	bool BEndItem () { return BEndBlock(); }
	void nl ();
	ofstream & Stream () 
		{ return (ofstream&) self; }

  protected:
	STKPARMBLK _stkblk;
	void StartChunk ( PARMBLK::EPBLK eBlk, SZC szc = NULL, int indx = -1 );
};


//////////////////////////////////////////////////////////////////////////////////
//
//	Class PARMINSTREAM.  An input stream of parameters.
//
//		The input text stream is read once during scan(), and a table of
//		all blocks and values is built.  The scan creates an outermost block
//		defining the entire file.  Then other blocks are added as discovered,
//		and their starting and ending points are recorded.  
//
//		To use, construct, open() and scan().  Then, find the named section
//		(or value) in question using ifind(), which returns the scoping level.
//		Then, either construct an Iterator (nested class) to walk through the 
//		values at that level or use ifind() to locate specific items by name.
//
//////////////////////////////////////////////////////////////////////////////////
enum EC_PARM_PARSE
{
	ECPP_PARSE_ERROR = EC_ERR_MIN,
	ECPP_UNMATCHED_QUOTE,
	ECPP_UNEXPECTED_EOF,
	ECPP_INVALID_CLUMP,
	ECPP_INVALID_NAME,
	ECPP_INVALID_BODY,
};

class PARMINSTREAM : public ifstream
{
  public:
    PARMINSTREAM ();
	~ PARMINSTREAM ();

	void close();
	//  Build the rapid-access table
	void Scan ();
	//  Find a block or item at the given level; -1 means "current level",
	//	zero means outermost level.  Returns index of block or -1 if 
	//	not found.
	int IblkFind ( SZC szcName, int index = -1, int iblkOuter = -1 );
	//	Return the next data block in the array or
	//  false if there are no more items.
	const PARMBLKIN *  Pparmblk ( int iblk, int iblkOuter = -1 );
	//  position the stream to process the parameter
	bool BSeekBlk ( int iblk );
	//  read the parameter into a string
	bool BSeekBlkString ( int iblk, ZSTR & zsParam );
	//  Pretty-print the block stack with nesting information
	void Dump ();
	//  Return true if the block index is legal
	bool BBlkOk ( int iblk ) const 
		{ return  iblk >= 0 || iblk < _stkblk.size(); }
	int Cblk () const
		{ return _stkblk.size() ; }

	ifstream & Stream () 
		{ return (ifstream&) self; }

	class Iterator
	{
	  public:
		Iterator( PARMINSTREAM & fprm, 
				  SZC szcBlock = NULL, 
				  int index = -1,
				  int iblkOuter = -1 );
		const PARMBLKIN *  PblkNext ();
		
	  protected:
		PARMINSTREAM & _fprm;
		int _iblkOuter;
		int _iblk;
	};

	friend class Iterator;

  protected:
	STKPARMBLKIN _stkblk;			// The block array
	int _iline;						// The current line number (parsing)
	ZSTR _zsWhite;					// White space character set

	void ThrowParseError ( SZC szcError, 
						   int iline = -1,
						   EC_PARM_PARSE ecpp = ECPP_PARSE_ERROR );
	int  IGetc ();
	bool BIswhite ( char ch );
	void ScanQuote ( char ch );
	void ScanClump ();
	void ScanBlock ( char ch );
	PARMBLK::EPBLK EpblkScanItemBody ( streamoff & offsData );
	int IScanUnwhite ( bool bEofOk = false );
	void ScanItemList ();
	void ScanItemUnit ();
	void ScanItemDesc ( ZSTR & zsName, int & indx ) ;
	void ScanName ( ZSTR & szName );
};

//////////////////////////////////////////////////////////////////////////////////
//  Inline functions
//////////////////////////////////////////////////////////////////////////////////
inline
PARMINSTREAM & operator >> (PARMINSTREAM & is, ZSTR & zs)
{
	ios_base::iostate _St = ios_base::goodbit;
	zs.erase();
	const ifstream::sentry _Ok(is);
	if (_Ok)
	{
		_TRY_IO_BEGIN
		size_t _N = 0 < is.width() && is.width() < zs.max_size()
						 ? is.width() 
						 : zs.max_size();
		int _C = is.rdbuf()->sgetc();
		bool bmeta = false;
		bool bfirst = true;
		for (; 0 < --_N; _C = is.rdbuf()->snextc())
		{
			if(char_traits<char>::eq_int_type(char_traits<char>::eof(), _C))
			{	
				_St |= ios_base::eofbit;
				break; 
			}
			else 
			if ( ! bmeta && _C == CH_DELM_STR )
			{
				if ( ! bfirst )
				{
					is.rdbuf()->snextc();
					break;
				}
			}
			else
			if ( _C == CH_META && ! bmeta )
			{
				bmeta = true;
			}
			else
			{
				bmeta = false;
				zs.append(1, char_traits<char>::to_char_type(_C));
			}
			bfirst = false;
		}
		_CATCH_IO_(is);
	}
	else
	{
		_THROW1(runtime_error("file exhausted extracting string"));
	}
	is.width(0);
	is.setstate(_St);
	return is; 
}

//////////////////////////////////////////////////////////////////////////////////
//	Template functions for parameter streams
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//	Write SZC: no corresponding read, since no buffer exists
//////////////////////////////////////////////////////////////////////////////////
inline
PARMOUTSTREAM & operator << (PARMOUTSTREAM & ofs, SZC szc)
{
	ofs << CH_DELM_STR;

	for ( ; *szc ; )
	{
		char ch = *szc++;
		if ( ch == CH_DELM_STR || ch == CH_META )
		{
			if (char_traits<char>::eq_int_type(char_traits<char>::eof(),
				ofs.rdbuf()->sputc(CH_META)))
				break;
		}
		if (char_traits<char>::eq_int_type(char_traits<char>::eof(),
			ofs.rdbuf()->sputc(ch)))
			break;
	}
	ofs << CH_DELM_STR;
	return ofs; 
}

//////////////////////////////////////////////////////////////////////////////////
//	Read and write ZSTRs
//////////////////////////////////////////////////////////////////////////////////
inline
PARMOUTSTREAM & operator << (PARMOUTSTREAM & ofs, const ZSTR & zs)
{
	ofs << CH_DELM_STR;

	for ( int ich = 0; ich < zs.size(); ++ich)
	{
		char ch = zs.at(ich);
		if ( ch == CH_DELM_STR || ch == CH_META )
		{
			if (char_traits<char>::eq_int_type(char_traits<char>::eof(),
				ofs.rdbuf()->sputc(CH_META)))
				break;
		}
		if (char_traits<char>::eq_int_type(char_traits<char>::eof(),
			ofs.rdbuf()->sputc(ch)))
			break;
	}
	if ( ich < zs.size() )
		_THROW1(runtime_error("file exhausted inserting string"));

	ofs << CH_DELM_STR;
	return ofs; 
}


//////////////////////////////////////////////////////////////////////////////////
//	Simple parameter output routines using insertion
//////////////////////////////////////////////////////////////////////////////////
template<class T> inline
PARMOUTSTREAM & AddParamValue ( PARMOUTSTREAM & fprm, const T & t, SZC szc, int indx = -1 )
{
	fprm.StartItem( szc, indx );
	fprm << (const T &) t;
	fprm.BEndItem();
	return fprm;
}

//////////////////////////////////////////////////////////////////////////////////
//	Simple parameter input routines using extraction
//////////////////////////////////////////////////////////////////////////////////
template<class T> inline
bool BGetParamValue ( PARMINSTREAM & fprm, T & t, SZC szc, int index = -1, int iblkOuter = -1 )
{
	int iblk = fprm.IblkFind(szc, index, iblkOuter);
	if ( iblk < 0 ) 
		return false;
	fprm.BSeekBlk(iblk);
	fprm >> t;
	return true;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\regkey.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       regkey.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "regkey.h"

LONG REGKEY::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

void REGKEY::Attach(HKEY hKey)
{
	assert(m_hKey == NULL);
	m_hKey = hKey;
}


LONG REGKEY::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	assert(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

LONG REGKEY::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	assert(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		assert(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

LONG REGKEY::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	assert((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	assert((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

LONG REGKEY::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
	assert(pdwCount != NULL);
	DWORD dwType = NULL;
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)szValue, pdwCount);
	assert((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
			 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
	return lRes;
}

LONG WINAPI REGKEY::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	assert(lpszValue != NULL);
	REGKEY key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG REGKEY::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	assert(lpszValue != NULL);
	REGKEY key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG REGKEY::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	assert(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
}

HRESULT REGKEY::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	assert(lpszValue != NULL);
	assert(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
LONG REGKEY::RecurseDeleteKey(LPCTSTR lpszKey)
{
	REGKEY key;
	LONG lRes = key.Open(m_hKey, lpszKey);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\refcnt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       refcnt.h
//
//--------------------------------------------------------------------------

//
//	refcnt.h:  base class for reference-counted objects
//
#ifndef _REFCNT_H_
#define _REFCNT_H_

class REFCNT
{
  public:
	//  Bind the object again
 	void Bind ()			{ IncRef(1) ;		}
	//  Release the object
	void Unbind ()			{ IncRef(-1) ;		}
	//  Return the reference count
	UINT CRef() const		{ return _cref;		}

  protected:
	REFCNT() : _cref(0) {}

	//	Virtual call-out when reference count goes to zero
	virtual void NoRef () {}

  private:
	UINT _cref;			// Number of references to this 

  protected:
	void IncRef ( int i = 1 )
	{
		 if ((_cref += i) > 0 )
			return;
		_cref = 0;
		NoRef();
	}
	// Hide the assignment operator
	HIDE_AS(REFCNT);		
};


////////////////////////////////////////////////////////////////////
//	template REFPOBJ:  Smart pointer wrapper template.  Knows
//		to destroy the pointed object when it itself is destroyed.
////////////////////////////////////////////////////////////////////
class ZSREF;

template<class T>
class REFPOBJ
{
	//  Friendship is required for manipulation by the symbol table
	friend pair<ZSREF, REFPOBJ<T> >;
	friend map<ZSREF, REFPOBJ<T>, less<ZSREF> >;

  public:
	~ REFPOBJ ()
		{ Deref(); }

	// Return the real object 
	T * Pobj () const
		{ return _pobj ; } 
	// Allow a REFPOBJ to be used wherever a T * is required
	operator T * () const
		{ return _pobj ; }
	// Operator == compares only pointers.
	bool operator == ( const REFPOBJ & pobj ) const
		{ return _pobj == pobj._pobj; }

	T * MoveTo (REFPOBJ & pobj)
	{
		pobj = Pobj();
		_pobj = NULL;
		return pobj;
	};


 	REFPOBJ & operator = ( T * pobj ) 
	{
		Deref();
		_pobj = pobj;
		return *this;
	}

 protected:
	REFPOBJ ()
		: _pobj(NULL)
		{}
  protected:
	T * _pobj;

  private:
	void Deref ()
	{
		delete _pobj;
		_pobj = NULL;
	}

	HIDE_AS(REFPOBJ);
};

////////////////////////////////////////////////////////////////////
//	template REFCWRAP:  Smart pointer wrapper template for objects
//		using REFCNT semantics.
////////////////////////////////////////////////////////////////////
template<class T>
class REFCWRAP
{
  public:
	REFCWRAP (T * pobj = NULL)	
		: _pobj(NULL) 
	{
		Ref( pobj );
	}
	~ REFCWRAP () 
	{ 
		Deref(); 
	}
	REFCWRAP ( const REFCWRAP & refp )
		: _pobj(NULL)
	{
		Ref( refp._pobj );
	}

	// Return true if there's a referenced object
	bool BRef () const
		{ return _pobj != NULL; }

	// Return the real object 
	T * Pobj () const
		{ return _pobj ; } 

	// Allow a REFPOBJ to be used wherever a T * is required
	operator T * () const
		{ return _pobj ; }
	// Operator == compares only pointers.
	bool operator == ( const REFCWRAP & pobj ) const
		{ return _pobj == pobj._pobj; }
	T * operator -> () const
	{ 
		assert( _pobj );
		return _pobj; 
	}
 	REFCWRAP & operator = ( T * pobj ) 
	{
		Ref(pobj);
		return *this;
	}
 	REFCWRAP & operator = ( const REFCWRAP & refp ) 
	{
		Ref(refp._pobj);
		return *this;
	}

	void Deref ()
	{
		if ( _pobj )
		{
			_pobj->Unbind();
			_pobj = NULL;
		}
	}

  protected:
	T * _pobj;

  private:
	void Ref ( T * pobj )
	{
		Deref();
		if ( pobj )
		{
			pobj->Bind();
			_pobj = pobj;
		}
	}
};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\propmbn.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       propmbn.cpp
//
//--------------------------------------------------------------------------

//
//	PROPMBN.CPP
//

#include <basetsd.h>
#include <assert.h>
#include <string.h>
#include "gmprop.h"
#include "gmobj.h"
#include "algos.h"

GOBJMBN * GOBJPROPTYPE :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjNew )
{
	GOBJPROPTYPE * pgproptype;
	if ( pgobjNew )
	{
		DynCastThrow( pgobjNew, pgproptype );
	}
	else
	{
		pgproptype = new GOBJPROPTYPE;
	}	
	ASSERT_THROW( GOBJMBN::CloneNew( modelSelf, modelNew, pgproptype ),
				  EC_INTERNAL_ERROR,
				  "cloning failed to returned object pointer" );

	pgproptype->_fType = _fType;
	pgproptype->_zsrComment = modelNew.Mpsymtbl().intern( _zsrComment );
	modelNew.Mpsymtbl().CloneVzsref( modelSelf.Mpsymtbl(),
									_vzsrChoice,
									pgproptype->_vzsrChoice );
	return pgproptype;
}

PROPMBN :: PROPMBN ()
	:_fType(0)
{
}

PROPMBN :: PROPMBN ( const PROPMBN & bnp )
{
	self = bnp;
}

PROPMBN & PROPMBN :: operator = ( const PROPMBN & bnp )
{
	_zsrPropType = bnp._zsrPropType;
	_fType = bnp._fType;
	_vzsrStrings = bnp._vzsrStrings;
	_vrValues = bnp._vrValues;
	return self;
}

void PROPMBN :: Init ( GOBJPROPTYPE & bnpt )
{
	_zsrPropType = bnpt.ZsrefName();
	_fType = bnpt.FPropType();
}

bool PROPMBN :: operator == ( const PROPMBN & bnp ) const
{
	return _zsrPropType == bnp._zsrPropType;
}	

bool PROPMBN :: operator < ( const PROPMBN & bnp ) const
{
	return _zsrPropType < bnp._zsrPropType;
}

bool PROPMBN :: operator == ( ZSREF zsrProp ) const
{
	return ZsrPropType() == zsrProp;
}

bool PROPMBN :: operator == ( SZC szcProp ) const
{
	return ::strcmp( szcProp, ZsrPropType().Szc() ) == 0;
}

UINT PROPMBN :: Count () const
{
	if ( _fType & fPropString )
		return _vzsrStrings.size();
	else
		return _vrValues.size();
}

ZSREF PROPMBN :: Zsr ( UINT i ) const
{
	if (  ((_fType & fPropArray) == 0 && i > 0)
		|| (_fType & fPropString) == 0)
		throw GMException(EC_PROP_MISUSE,"not a string property or not an array");
	if ( i >= _vzsrStrings.size() )
		throw GMException(EC_PROP_MISUSE,"property index out of range");
	return _vzsrStrings[i];
}

REAL PROPMBN :: Real ( UINT i ) const
{
	if (  ((_fType & fPropArray) == 0 && i > 0)
		|| (_fType & fPropString) )
		throw GMException(EC_PROP_MISUSE,"not a numeric property or not an array");
	if ( i >= _vrValues.size() )
		throw GMException(EC_PROP_MISUSE,"property index out of range");
	return _vrValues[i];
}

void PROPMBN :: Reset ()
{
	_vrValues.clear();
	_vzsrStrings.clear();
}

void PROPMBN :: Set ( ZSREF zsr )
{
	if ( (_fType & fPropString) == 0 )
		throw GMException(EC_PROP_MISUSE,"not a string property");
	Reset();
	_vzsrStrings.push_back(zsr);
}

void PROPMBN :: Set ( REAL r )
{
	if ( _fType & fPropString )
		throw GMException(EC_PROP_MISUSE,"not a numeric property");
	Reset();
	_vrValues.push_back(r);
}

void PROPMBN :: Add ( ZSREF zsr )
{
	if ( (_fType & (fPropArray | fPropString)) == 0 )
		throw GMException(EC_PROP_MISUSE,"not a string array property");
	_vzsrStrings.push_back(zsr);
}

void PROPMBN :: Add ( REAL r )
{
	if ( (_fType & fPropArray) == 0 )
		throw GMException(EC_PROP_MISUSE,"not a numeric array property");
	_vrValues.push_back(r);
}


PROPMBN * LTBNPROP :: PFind ( ZSREF zsrProp )
{	
	iterator itlt = find( begin(), end(), zsrProp );
	if ( itlt == end() )
		 return NULL;
	return & (*itlt);
}
const PROPMBN * LTBNPROP :: PFind ( ZSREF zsrProp ) const
{
	const_iterator itlt = find( begin(), end(), zsrProp );
	if ( itlt == end() )
		 return NULL;
	return & (*itlt);
}

bool LTBNPROP :: Update ( const PROPMBN & bnp )
{
	PROPMBN * pprop = PFind( bnp.ZsrPropType() );
	if ( pprop )
		*pprop = bnp;
	else
		push_back( bnp );
	return pprop != NULL;
}

//  Force the list to contain only unique elements.  Note that
//  the act of sorting and uniquing will discard duplicates randomly.
bool LTBNPROP :: Uniqify ()
{
	int cBefore = size();
	sort();
	unique();
	return size() == cBefore;
}

//  Clone from another list with another symbol table
void LTBNPROP :: Clone (
	MODEL & model,
	const MODEL & modelOther,
	const LTBNPROP & ltbnOther )
{
	for ( const_iterator itlt = ltbnOther.begin(); itlt != ltbnOther.end(); itlt++ )
	{
		const PROPMBN & prpOther = (*itlt);
		//  Note that the dynamic cast below will test for failure to
		//		find property type object
		GOBJMBN * pgobj = model.PgobjFind( prpOther.ZsrPropType() );
		ASSERT_THROW( pgobj != NULL,
					  EC_INTERNAL_ERROR,
					  "missing property type in target network during cloning" );
		GOBJPROPTYPE * pgobjPropType;
		DynCastThrow( pgobj, pgobjPropType );
		PROPMBN prp;
		prp.Init( *pgobjPropType );
		model.Mpsymtbl().CloneVzsref( modelOther.Mpsymtbl(),
									  prpOther._vzsrStrings,
									  prp._vzsrStrings );
		prp._vrValues = prpOther._vrValues;
		push_back( prp );
	}
}

static
struct MPVOIPROPSZC
{
	ESTDPROP _eProp;
	SZC _szcProp;
}
vVoiProp [] =
{
	{ ESTDP_label,			"MS_label"			},
	{ ESTDP_cost_fix,		"MS_cost_fix"		},
	{ ESTDP_cost_observe,	"MS_cost_observe"	},
	{ ESTDP_category,		"MS_category"		},
	{ ESTDP_normalState,	"MS_normalState"	},
	{ ESTDP_max,			NULL				}
};

static
struct MPLBLSZC
{
	ESTDLBL _eLbl;
	SZC _szcLbl;
}
vLblSzc [] =
{
	{ ESTDLBL_other,		"other"			},
	{ ESTDLBL_hypo,			"hypothesis"	},
	{ ESTDLBL_info,			"informational"	},
	{ ESTDLBL_problem,		"problem"		},
	{ ESTDLBL_fixobs,		"fixobs"		},
	{ ESTDLBL_fixunobs,		"fixunobs"		},
	{ ESTDLBL_unfix,		"unfixable"		},
	{ ESTDLBL_config,		"configuration"	},
	{ ESTDLBL_max,			NULL			}
};

SZC PROPMGR :: SzcLbl ( int iLbl )
{
	SZC szcOther = NULL;
	for ( int i = 0; vLblSzc[i]._szcLbl; i++ )
	{
		if ( vLblSzc[i]._eLbl == iLbl )
			return vLblSzc[i]._szcLbl;
		if ( vLblSzc[i]._eLbl == ESTDLBL_other )
			szcOther = vLblSzc[i]._szcLbl;
	}
	return szcOther;
}


PROPMGR :: PROPMGR ( MODEL & model )
	: _model(model)
{
	//  Locate all the standard property types; save their
	//	name references whether or not they've been declared.
	SZC szcProp;
	for ( int i = 0; szcProp = vVoiProp[i]._szcProp ; i++ )
	{	
		GOBJPROPTYPE * ppt = NULL;
		_vzsrPropType.push_back( _model.Mpsymtbl().intern( szcProp ) );
		GOBJMBN * pgobj = _model.PgobjFind( szcProp );
		if ( pgobj )
		{
			if ( pgobj->EType() == GOBJMBN::EBNO_PROP_TYPE )
			{	
				DynCastThrow( pgobj, ppt );
			}
		}
		_vPropMap[i] = ppt;
	}

	//  If we found "MS_label", prepare the correspondence table
	GOBJPROPTYPE * pptLabel = _vPropMap[ESTDP_label];

	if ( pptLabel && (pptLabel->FPropType() & fPropChoice) > 0 )
	{
		SZC szcChoice;
		const VZSREF & vzsr	= pptLabel->VzsrChoice();
		_vUserToLbl.resize( vzsr.size() );

		//  Clear the user-to-standard-label map
		for ( i = 0; i < _vUserToLbl.size(); )
			_vUserToLbl[i++] = -1;

		for ( i = 0; szcChoice = vLblSzc[i]._szcLbl; i++ )
		{
			int iLbl = -1;
			ZSREF zsrChoice = _model.Mpsymtbl().intern( szcChoice );
			for ( int j = 0; j < vzsr.size(); j++ )
			{
				if ( zsrChoice == vzsr[j] )
				{
					iLbl = j;
					//  Mark which standard label this user element corresponds to
					_vUserToLbl[iLbl] = i;
					break;
				}
			}
			//  Mark which user element this standard label corresponds to
			_vLblToUser[i] = iLbl;
		}
	}
	else
	{	// Clear the correspondence information
		for ( i = 0; i < ESTDLBL_max; i++ )
		{
			_vLblToUser[i] = -1;
		}
	}
}

GOBJPROPTYPE * PROPMGR :: PPropType ( ESTDPROP evp )
{
	return _vPropMap[evp];
}

//  Return the name of the standard property
ZSREF PROPMGR :: ZsrPropType ( ESTDPROP evp )
{	
	ASSERT_THROW( evp >= 0 && evp < ESTDP_max,
				  EC_INTERNAL_ERROR,
				  "invalid property type usage" );
	return _vzsrPropType[evp];
}


//  Find a standard property in a property list
PROPMBN * PROPMGR :: PFind ( LTBNPROP & ltprop, ESTDPROP estd )
{
	return ltprop.PFind( ZsrPropType(estd) ) ;
}

//  Find a standard property in the associated model's property list
PROPMBN * PROPMGR :: PFind ( ESTDPROP estd )
{
	return _model.LtProp().PFind( ZsrPropType(estd) ) ;
}

//  Find a standard property in a node's property list
PROPMBN * PROPMGR :: PFind ( GNODEMBN & gnd, ESTDPROP estd )
{
	return gnd.LtProp().PFind( ZsrPropType(estd) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\recomend.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       recomend.cpp
//
//--------------------------------------------------------------------------

//
//	recomend.cpp:  Fix-or-repair planning recommendations
//

#include <basetsd.h>
#include <math.h>
#include <float.h>
#include "algos.h"
#include "recomend.h"
#include "parmio.h"

#ifdef _DEBUG
  //#define DUMP  //  Uncomment for copious diagnostic output
#endif

const PROB probTiny = 1e-6;					//  General probability tolerance

static
ostream & operator << ( ostream & os, GPNDDDIST & gpnddist )
{
	os << "GPNDDDIST: ";
	if ( gpnddist.Pgnd() )
	{
		os << gpnddist.Pgnd()->ZsrefName().Szc()
		   << ", distribution: "
		   << gpnddist.Dist();
	}
	else
	{
		os << "<NULL>";
	}
	return os;
}

static
ostream & operator << ( ostream & os, GNODEREFP & gndref )
{
	assert( gndref.Pgndd() );
  	os << "GNODEREFP: "
	   << gndref.Gndd().ZsrefName().Szc()
	   << " (obs = "
	   << gndref.CostObserve()
	   << ", fix = "
	   << gndref.CostFix()
	   << ", util = "
	   << gndref.Util()
	   << ", lbl = "
	   << PROPMGR::SzcLbl( gndref.ELbl() )
	   << ")";
	return os;
}	

static
ostream & operator << ( ostream & os, GNODERECWORK & gnrw )
{
	os << "GNODERECWORK: "
	   << gnrw.Gndref()
	   << ", p/c = "
	   << gnrw.PbOverCost()
	   << ", p(fault) = "
	   << gnrw.PbFault();
	return os;
}

static
inline
bool BIsUnity( const REAL & r )
{
	return 1.0 - probTiny < r && r < 1.0 + probTiny;
}

static
inline
bool BEqual ( const REAL & ra, const REAL & rb )
{	
	//return fabs( ra - rb ) <= probTiny;
	return ra != 0.0
		 ? BIsUnity( rb / ra )
		 : rb == 0.0;
}

//
//	Ordering routines for arrays of GNODERECWORKs
//
typedef	binary_function<const GNODERECWORK &, const GNODERECWORK &, bool> SORTGNODERECWORK;

//  The greater the prob-over-cost, the lower the sort order
class SRTGNW_SgnProbOverCost : public SORTGNODERECWORK
{	
  public:
	bool operator () (const GNODERECWORK & gnwa, const GNODERECWORK & gnwb) const
	{	
		PROB pra = gnwa.PbOverCost();
		PROB prb = gnwb.PbOverCost();
		return pra > prb;
	}
};

//  The greater the prob fault, the lower the sort order
class SRTGNW_SgnProb : public SORTGNODERECWORK
{	
  public:
	bool operator () (const GNODERECWORK & gnwa, const GNODERECWORK & gnwb) const
	{	
		//  Force leak terms to sort high
		int iLeak = 0;
		if ( ! gnwa->BLeak() && gnwb->BLeak() )
			iLeak = -1;	// Unleak < leak
		else
		if ( gnwa->BLeak() && ! gnwb->BLeak() )
			iLeak = 1;	// Leak > Unleak
		if ( iLeak != 0 )
			return iLeak;

		PROB pra = gnwa.PbFault();
		PROB prb = gnwb.PbFault();
		return pra > prb;
	}
};

//  The lower the cost-to-observe, the lower the sort order
class SRTGNW_SgnNegCost : public SORTGNODERECWORK
{	
  public:
	bool operator () (const GNODERECWORK & gnwa, const GNODERECWORK & gnwb) const
	{	
		COST costa = gnwa.CostObsIfFixable();
		COST costb = gnwb.CostObsIfFixable();
		return costa < costb;
	}
};

//  The higher the utility, the lower the sort order
class SRTGNW_SgnUtil : public SORTGNODERECWORK
{	
  public:
	bool operator () (const GNODERECWORK & gnwa, const GNODERECWORK & gnwb) const
	{	
		COST utila = gnwa.Gndref().Util();
		COST utilb = gnwb.Gndref().Util();
		return utila > utilb;
	}
};


//
//  Construct a node reference object.  Extract properties, etc.
//
GNODEREFP :: GNODEREFP ( PROPMGR & propMgr, GNODEMBND * pgndd )
	:_pgndd(pgndd),
	_costObserve(0.0),
	_costFix(0.0),
	_costUtil(0.0),
	_eLbl(ESTDLBL_other)
{
	ASSERT_THROW( pgndd, EC_NULLP, "invalid GNOEREFP construction" );		

	PROPMBN * pprop = propMgr.PFind( *pgndd, ESTDP_cost_fix );
	if ( pprop )
		_costFix = pprop->Real();
	pprop = propMgr.PFind( *pgndd, ESTDP_cost_observe );
	if ( pprop )
		_costObserve = pprop->Real();
	pprop = propMgr.PFind( *pgndd, ESTDP_label );
	if ( pprop )
		_eLbl = (ESTDLBL) propMgr.IUserToLbl( pprop->Real() );
	_bLeak = pgndd->BFlag( EIBF_Leak );

	//  If it's unobservable, use cost-to-fix as cost-to-observe
	if ( _eLbl == ESTDLBL_fixunobs && _costObserve == 0.0 )
	{
		_costObserve = _costFix;
		_costFix = 0.0;
	}
}

//  Initialize a work record from a node reference object and its fault probability
void GNODERECWORK :: Init ( GNODEREFP * pgndref, PROB pbFault )
{
	_pgndref = pgndref;
	_pbFault = pbFault;
	_pbOverCost = 0.0;
	if ( BFixable() )
	{
		COST costObserve = _pgndref->CostObserve();
		if ( costObserve != 0.0 )
			_pbOverCost = _pbFault / costObserve;
		assert( _finite( _pbOverCost ) );
	}
}

//  Initialize a work record from a node reference object
void GNODERECWORK :: Init ( MBNET_RECOMMENDER & mbnRecom, GNODEREFP * pgndref )
{	
	MDVCPD mdv;
	_pgndref = pgndref;
	mbnRecom.InferGetBelief( _pgndref->Pgndd(), mdv );
	Init( pgndref, 1.0 - mdv[0] );
}

void VGNODERECWORK :: InitElem ( GNODEREFP * pgndref, int index /* = -1 */ )
{
	//  Grow the array as needed
	if ( index < 0 )
		index = size();
	if ( index >= size() )
		resize( index+1 );

	//  Initialize the element
	self[index].Init( MbnRec(), pgndref );
}

void VGNODERECWORK :: InitElem ( GNODEMBND * pgndd, int index )
{
	//  Find the node reference record in the recommendations object's array
	VPGNODEREFP & vpgndref = MbnRec().Vpgndref();
	int indref = vpgndref.ifind( pgndd );
	ASSERT_THROW( indref >= 0,
				  EC_INTERNAL_ERROR,
				  "node ref not found during recommendations" );

	//  Initialize using that reference
	InitElem( vpgndref[indref], index );
}


COST VGNODERECWORK :: CostService () const
{
	return MbnRec().CostService();
}

void VGNODERECWORK :: Sort ( ESORT esort )
{
	iterator ibeg = begin();
	iterator iend = end();

	switch ( esort )
	{
		case ESRT_ProbOverCost:
		{
			sort( ibeg, iend, SRTGNW_SgnProbOverCost() );
			break;
		}
		case ESRT_SgnProb:
		{
			sort( ibeg, iend, SRTGNW_SgnProb() );
			break;
		}
		case ESRT_NegCost:
		{
			sort( ibeg, iend, SRTGNW_SgnNegCost() );
			break;
		}
		case ESRT_SgnUtil:
		{
			sort( ibeg, iend, SRTGNW_SgnUtil() );
			break;
		}
		default:
		{
			THROW_ASSERT( EC_INTERNAL_ERROR, "invalid sort selector in recommendations" );
			break;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//  class INFOPLAN:
//		Encloses an array of VGNODERECWORKs, each of which is a fix-and-repair
//		sequence corresponding to a particular state of an informational node.		
//
/////////////////////////////////////////////////////////////////////////////////////////
class INFOPLAN
{
  public:
	INFOPLAN ( MBNET_RECOMMENDER & mbnRec,			//  The recommendations object
			   GNODEMBND & gndInfo,					//  The information node
			   VGNODERECWORK & vgndrwFixRepair );	//  The existing f-r sequence

	//  Compute the cost of the sequence
	COST Cost();
	//  Return true if all plans are equivalent
	bool BSameSequence()							{ return _bSameSequence; };

  protected:
	MBNET_RECOMMENDER & _mbnRec;					//  The recommendations object
	GNODEMBND & _gndInfo;							//  The info node represented
	MDVCPD _dd;										//  Unconditional probability distribution
	VVGNODERECWORK _vvgndrw;						//  Array of plan arrays
	bool _bSameSequence;							//  True if all plans are equivalent
};


INFOPLAN ::	INFOPLAN (
	MBNET_RECOMMENDER & mbnRec,
	GNODEMBND & gndInfo,		
	VGNODERECWORK & vgndrwFixRepair )
	: _mbnRec(mbnRec),
	_gndInfo(gndInfo),
	_bSameSequence(false)
{
#ifdef DUMP
	cout << "\nINFOPLAN::INFOPLAN: info node "
		 << gndInfo.ZsrefName().Szc();
#endif

	CLAMP clampInfo;	//  State of info node at call time
	_mbnRec.InferGetEvidence( & _gndInfo, clampInfo );
	assert( ! clampInfo.BActive() );
	assert( _mbnRec.ELbl( _gndInfo ) == ESTDLBL_info );

	//  Get setup information
	GNODEMBND * pgnddPDAbnormal = _mbnRec.PgnddProbDefAbnormal();
	assert( pgnddPDAbnormal );
	COST costService = _mbnRec.CostService();

	//  Get beliefs under this state of information
	_mbnRec.InferGetBelief( & _gndInfo, _dd );

	//  Resize and initialize the array of fix/repair sequences
	int cStates = _gndInfo.CState();
	_vvgndrw.resize( cStates );
	for ( int iplan = 0; iplan < cStates; iplan++ )
	{
		_vvgndrw[iplan].PmbnRec() = & _mbnRec;
	}
	_bSameSequence = true;
	
	VGPNDDDIST vgndddFixRelevant;	//  Array of relevant fixable nodes
	for ( iplan = 0; iplan < cStates; iplan++ )
	{
		//  If this state is impossible, ignore it
		PROB pbPlan = _dd[iplan];
		if ( pbPlan == 0.0 )
			continue;

#ifdef DUMP
		cout << "\nINFOPLAN clamp "
			 << gndInfo.ZsrefName().Szc()
			 << " to state = "
			 << iplan
			 << ", prob = "
			 << _dd[iplan];
#endif

		//  Clamp this info node to this state
		CLAMP clamp( true, iplan, true );
		_mbnRec.InferEnterEvidence( & _gndInfo, clamp );		

		//  Determine which nodes are relevant given this state of information
		_mbnRec.DetermineRelevantFixableNodes( vgndddFixRelevant, true, & _gndInfo );

		//  If there are no relevant fixables then the configuration is impossible
		if ( vgndddFixRelevant.size() == 0 )
			continue;

		//  Collect and sequence the relevant fixable nodes accordingly
		_mbnRec.ComputeFixSequence( vgndddFixRelevant, _vvgndrw[iplan] );

		//  See if this is a new sequence
		if ( _bSameSequence )
			_bSameSequence = vgndrwFixRepair.BSameSequence( _vvgndrw[iplan] );
	}

	//  Restore the info node to its entry state
	_mbnRec.InferEnterEvidence( & _gndInfo, clampInfo );

#ifdef DUMP
	cout << "\nINFOPLAN::INFOPLAN: END info node "
		 << gndInfo.ZsrefName().Szc();
#endif
}

COST INFOPLAN :: Cost ()
{
	VPGNODEREFP & vpgndref = _mbnRec.Vpgndref();
	int indref = vpgndref.ifind( & _gndInfo );
	assert( indref >= 0 );
	COST cost = vpgndref[indref]->CostObserve();
	ASSERT_THROW( cost != 0.0, EC_INTERNAL_ERROR, "missing observation cost for info node" );

	//  Rescale the probabilities of each planning state based upon removal of the
	//	impossible states and renormalization.
	PROB pbTotal = 0.0;
	for ( int iplan = 0; iplan < _gndInfo.CState(); iplan++ )
	{
		if ( _vvgndrw[iplan].size() > 0 )
			pbTotal += _dd[iplan];
	}

	assert( pbTotal > 0.0 );

	for ( iplan = 0; iplan < _gndInfo.CState(); iplan++ )
	{
		//  Get the rescaled probability of this state of the info node
		PROB pbPlan = _dd[iplan];
		VGNODERECWORK & vgndrw = _vvgndrw[iplan];
		if ( vgndrw.size() == 0 )
		{
			//  The plan is zero length; in other words, no fixables were relevant
			//	and the plan is impossible
			pbPlan = 0.0;
		}
		pbPlan /= pbTotal;
		COST costPlan = _vvgndrw[iplan].Cost();
		cost += costPlan * pbPlan;
	}
	return cost;
}

//  Rescale the probabilities for the fix list.   This routine sets the
//  array bounds to ignore everything from the first unfixable node and beyond.
//  Fault probabilities for the list are renormalized against the cumulative
//	probability of all the faults in the array.  Since there should be no fixable
//  nodes of significance after the first unfixable node, the "probLeak" value
//  should be very small.
void VGNODERECWORK :: Rescale ()
{
	// Accumulate totals of all fault probabilities
	PROB probTot = 0.0;
	for ( int ind = 0; ind < size(); ind++ )
	{
		probTot += self[ind].PbFault();
	}

	PROB probLeak = 1.0;		//  Renormalized leak (residual) probability
	int i1stUnfix = size();		//  Index of 1st unfixable node

	for ( ind = 0; ind < size(); ind++ )
	{	
		GNODERECWORK & gndrw = self[ind];

		if ( ! gndrw.BFixable()	)
		{
			i1stUnfix = ind;
			break;
		}

		//modified to fix the problem
		//gndrw.SetPbFault( gndrw.PbFault()/probTot);

		PROB pbTemp = gndrw.PbFault();
		if(probTot>0.0)
			pbTemp /= probTot;
		gndrw.SetPbFault( pbTemp );


		probLeak -= gndrw.PbFault();
	}

	ASSERT_THROW( probLeak >= - probTiny,
				  EC_INTERNAL_ERROR,
				  "fix/repair recommendations rescaling: residual probability too large" );

#ifdef _DEBUG
	//  Verify that there are no fixable nodes of signifcance beyond the new end point
	int cBeyond = 0;
	for ( ; ind < size(); ind++ )
	{
		GNODERECWORK & gndrw = self[ind];

		if ( gndrw.PbFault() < probTiny )
			continue;  //  highly unlikely to be significant
		if ( ! gndrw.BFixable() )
			continue;
	}
	assert( cBeyond == 0 );
#endif	

	//  Resize to discard unfixable nodes
	resize( i1stUnfix );
}

/////////////////////////////////////////////////////////////////////////////////////////
//	VGNODERECWORK::Cost()
//
//	purpose:
//		calculate cost of a fix sequence (aka ECR(E)), given by
//		Cost = Co1 + p1 * Cr1 + (1 - p1) * Co2 + p2 * Cr2 + ... + (1 - sum_i^N pi) Cservice
//
//	The 'ielemFirst' argument, if non-zero, is the index of the element to treat as first.
//	The 'piMinK' argument, if present, is set to the minimum K value computed.
/////////////////////////////////////////////////////////////////////////////////////////
COST VGNODERECWORK :: Cost (
	int ielemFirst,			//  Element to consider as first in array
	int * piMinK )			//  Location to store minimum k
{
	COST cost = 0.0;
	PROB prob = 1.0;
	const COST costService = MbnRec().CostService();
	COST costK = costService * prob;

	assert( _iFixedK == -1 || _iFixedK < size() );
	int ielem = 0;
	int iMinK = ielemFirst;
	const COST costObsProbDef = MbnRec().CostObsProbDef();
	int cSize = size();

#ifdef DUMP
	cout << "\n\nVGNODERECWORK::Cost("
		 << ielemFirst
		 << "), _iFixedK = "
		 << _iFixedK;
#endif

	for ( int iel = 0; iel < cSize; iel++ )
	{
		//  Select the array location, using ielemFirst (if present) as starting point,
		//		and skipping ielemFirst as necessary later.
		ielem = iel == 0
			? ielemFirst
			: (iel - (ielemFirst > 0 && iel <= ielemFirst));

		//  Access the next element in the array
		GNODERECWORK & gndrw = self[ielem];		
		GNODEREFP & gndref = gndrw.Gndref();
		//  If the node is unfixable, ignore it
		if ( ! gndrw.BFixable() )
			continue;

		const PROB probFault = gndrw.PbFault();
		COST costDelta = prob * gndref.CostObserve()
					   + probFault * (gndref.CostFix() + costObsProbDef);
#ifdef DUMP
		cout << "\n\t"
			 << gndrw;

		cout << "\n\t(iel="
			 << iel
			 << ",ielem="
			 << ielem
			 << ",size="
			 << cSize
			 << ")\n\t\tcostDelta("
			 << costDelta
			 << ") = prob("
			 << prob
			 << ") * costObs("
			 << gndref.CostObserve()
			 << ") + probFault("
			 << probFault
			 << ") * costFix("
			 << gndref.CostFix()
			 << ")"
			 ;
#endif

		cost += costDelta;
		prob -= probFault;
		//  Compute the cost of the sequence if service is inserted here
		COST costNow = cost + prob * costService;

#ifdef DUMP
		cout << "\n\t\tcostPrior("
			 << costK
			 << "), costNow("
			 << costNow
			 << ") = cost("
			 << cost
			 << ") + prob("
			 << prob
			 << ") * costService("
			 << costService
			 << "), (prob ="
			 << prob
			 << ")";

		cout.flush();
#endif

		// Were we better off at the last step?  Or is K fixed at this point?
		if ( costNow < costK || iel == _iFixedK )
		{
			costK = costNow;
			iMinK = ielem;
			if ( iel == _iFixedK )
				break;  //  We've reached the fixed point, so stop
		}

		ASSERT_THROW( prob >= - probTiny,
					  EC_INTERNAL_ERROR,
					  "fix/repair recommendations costing: probability underflow" );
	}

#ifdef DUMP	
	cout << "\n\t** ielem="
		 << ielem
		 << ", first element = "
		 << ielemFirst;
	if ( _iFixedK < 0 )
		cout << ", minimum k = " << iMinK;
	else
		cout << ", fixed k = " << _iFixedK;
	cout << ", cost = "
		 << costK
		 << " (residual prob = "
		 << prob
		 << ")";
#endif

	if ( _iFixedK < 0 )
	{
		if ( piMinK )
			*piMinK = iMinK;
	}

	return costK;
}

//  Set the cost of each node in the sequence
void VGNODERECWORK :: SetSequenceCost ()
{
	//  Reset any prior minimum fixed K
	_iFixedK = -1;
	//  If "fixPlan", compute the minimum K only on the first cycle,
	//		then enforce it thereafter.
	int iFixedK = -1;

	for ( int ind = 0; ind < size(); ind++ )
	{
		//  Compute the cost of the sequence with this node as first
		COST cost = Cost( ind, & iFixedK );

		//  If not "fixplan", reset K for complete search next cycle
		if ( MbnRec().ErcMethod() != MBNET_RECOMMENDER::ERCM_FixPlan )
			iFixedK = -1;
		else
		//  Else, if first cycle, fix K for remaining cycles.
		if ( ind == 0 )
			_iFixedK = iFixedK;
		self[ind].SetCost( cost );

#ifdef DUMP
		cout << "\nSetSequenceCost: "
			 << self[ind]->Gndd().ZsrefName().Szc()
			 << " = "
			 << cost;
#endif
	}

	_iFixedK = -1;
	_bSeqSet = true;
}

bool VGNODERECWORK :: BSameSequence ( const VGNODERECWORK & vgnw )
{
	if ( size() != vgnw.size() )
		return false;
	for ( int ind = 0; ind < size(); ind++ )
	{
		if ( self[ind].Gndref() != vgnw[ind].Gndref() )
			return false;
	}
	return true;
}


MBNET_RECOMMENDER :: MBNET_RECOMMENDER (
	GOBJMBN_CLIQSET & inferEng,
	ERCMETHOD ercm )
	: MBNET_NODE_RANKER( inferEng.Model() ),
	_inferEng( inferEng ),
	_propMgr( inferEng.Model() ),
	_ercm(ercm),
	_err(EC_OK),
	_pgnddPDAbnormal(NULL),
	_costService(0.0),
	_costObsProbDef(0.0),
	_bReady(false)
{
}

MBNET_RECOMMENDER :: ~ MBNET_RECOMMENDER ()
{
}


//
//  Return true if the network is in a proper state for recommendations
//  Note that we don't check whether the network has been expanded or not.
//	Since there must already be an inference engine, it's assumed that the
//	network is in its correct state.
//
bool MBNET_RECOMMENDER :: BReady ()
{
	MODEL::MODELENUM mdlenum( Model() );
	_err = EC_OK;

	_costService = CostServiceModel();
	if ( _costService == 0.0 )
	{
		_err = EC_VOI_MODEL_COST_FIX;
		return false;
	}

	//  Clear the structure
	_vpgnddFix.clear();			// Prepare to collect fixable nodes
	_vpgndref.clear();			// Clear node reference array

	//  Iterate over the nodes in the network, checking constraints.
	GELEMLNK * pgelm;
	GNODEMBND * pgndd;
	CLAMP clamp;
	int cProbDefSet = 0;		// # of instantiated PD nodes
	int cFixSetAbnorm = 0;		// # of fixables set to "abnormal"
	int cInfo = 0;				// # of info nodes	
	int cFixWithParents = 0;	// # of fixables with parents

	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		//  Check only nodes
		if ( pgelm->EType() != GOBJMBN::EBNO_NODE )
			continue;

		//  We only support discrete nodes for now
		DynCastThrow( pgelm, pgndd );

		//  See if it has a label		
		ESTDLBL eLbl = ELbl( *pgndd );
		bool bRef = false;
		switch ( eLbl )
		{
			case ESTDLBL_info:
				cInfo++;
				bRef = true;
				break;

			case ESTDLBL_problem:
				InferGetEvidence( pgndd, clamp );
				if ( clamp.BActive() && clamp.Ist() != istNormal )
				{
					cProbDefSet++;  //  Problem defining node set abnormal
					_pgnddPDAbnormal = pgndd;
					PROPMBN * ppropCostObs = _propMgr.PFind( *pgndd, ESTDP_cost_observe );
					if ( ppropCostObs )
						_costObsProbDef = ppropCostObs->Real();
				}
				break;

			case ESTDLBL_fixobs:
			case ESTDLBL_fixunobs:
			case ESTDLBL_unfix:
				//  Collect fixable nodes
				_vpgnddFix.push_back( pgndd );

				//  Check that it's not set abnormal
				InferGetEvidence( pgndd, clamp );
				if ( clamp.BActive() && clamp.Ist() != istNormal )
					cFixSetAbnorm++; //  Fixable node set abnormal
				bRef = true;
				if ( pgndd->CParent() > 0 )
					cFixWithParents++;	//  Fixable node with parents
				break;

			default:
				break;
		}

		//  If necessary, create a reference item for this node
		if ( bRef )
		{
			_vpgndref.push_back( new GNODEREFP( _propMgr, pgndd ) );
		}
	}
	

	if ( cProbDefSet != 1 )
		_err = EC_VOI_PROBDEF_ABNORMAL;		//	One and only one PD node must be abnormal
	else
	if ( cFixWithParents > 0 )
		_err = EC_VOI_FIXABLE_PARENTS;		//  Some fixable node(s) has parents
	else
	if ( cFixSetAbnorm > 0 )
		_err = EC_VOI_FIXABLE_ABNORMAL;		//  No fixable nodes can be abnormal

	return _bReady = (_err == EC_OK);				
}

//  Interface to inference engine
void MBNET_RECOMMENDER :: InferGetBelief ( GNODEMBND * pgndd, MDVCPD & mdvBel )
{
	InferEng().GetBelief( pgndd, mdvBel );
}

void MBNET_RECOMMENDER :: InferGetEvidence ( GNODEMBND * pgndd, CLAMP & clamp )
{
	InferEng().GetEvidence( pgndd, clamp );
}

void MBNET_RECOMMENDER :: InferEnterEvidence ( GNODEMBND * pgndd, const CLAMP & clamp )
{
	InferEng().EnterEvidence( pgndd, clamp );
}

bool MBNET_RECOMMENDER :: BInferImpossible ()
{
	return InferEng().BImpossible();
}

void MBNET_RECOMMENDER :: PrintInstantiations ()
{
#ifdef DUMP

	GELEMLNK * pgelm;
	GNODEMBND * pgndd;
	CLAMP clamp;

	cout << "\n\tInstantiations:";

	MODEL::MODELENUM mdlenum( Model() );
	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		//  Check only nodes
		if ( pgelm->EType() != GOBJMBN::EBNO_NODE )
			continue;

		//  We only support discrete nodes for now
		DynCastThrow( pgelm, pgndd );
		InferGetEvidence( pgndd, clamp );
		if ( clamp.BActive() )
		{
			cout << "\n\t\tnode "
				 << pgndd->ZsrefName().Szc()
				 << " is instantiated to state "
				 << clamp.Ist()
				 << ", "
				 << pgndd->VzsrStates()[clamp.Ist()].Szc();
		}
	}
	cout << "\n\tInstantiations end.";
#endif
}

COST MBNET_RECOMMENDER :: CostServiceModel ()
{
	//  Get the model's cost-to-fix as service cost.
	PROPMBN * ppropFixCost = _propMgr.PFind( ESTDP_cost_fix );
	COST costService = ppropFixCost
					 ? ppropFixCost->Real()
					 : 0.0;

	return costService;
}

//  Look up the label property of a node; convert to standard enumeration value.
ESTDLBL MBNET_RECOMMENDER :: ELbl ( GNODEMBN & gnd )
{
	PROPMBN * propLbl = PropMgr().PFind( gnd, ESTDP_label );
	if ( ! propLbl )
		return ESTDLBL_other;

	int iUserLbl = propLbl->Real();
	int iLbl = PropMgr().IUserToLbl( propLbl->Real() );
	return iLbl < 0
			? ESTDLBL_other
			: (ESTDLBL) iLbl;
}

//  Enter evidence for a troubleshooting model.
//
//  If the node is a fixable node being "set" to "normal", uninstantiate all
//  information nodes downstream from it.
//
void MBNET_RECOMMENDER :: EnterEvidence (
	GNODEMBND * pgndd,
	const CLAMP & clamp,
	bool bSet )
{
	if ( bSet )
	{
		ESTDLBL eLbl = ELbl( *pgndd );
		switch ( eLbl )
		{	
			case ESTDLBL_unfix:
			case ESTDLBL_fixobs:
			case ESTDLBL_fixunobs:
			{
				//  This is a fixable node
				if ( ! clamp.BActive() )
					break;	// Node is being unset
				if ( clamp.Ist() != istNormal )
					break;	// Node is not being fixed

				//  Find all downstream information nodes which are instantiated.		
				VPGNODEMBND vpgndd;
				vpgndd.push_back(pgndd);
				ExpandDownstream(vpgndd);
				CLAMP clampInfo;
				for ( int ind = 0; ind < vpgndd.size(); ind++ )
				{
					GNODEMBND * pgnddInfo = vpgndd[ind];
					ESTDLBL l = ELbl( *pgnddInfo );
					if ( l != ESTDLBL_info )
						continue;
					InferGetEvidence( pgnddInfo, clampInfo );
					if ( ! clampInfo.BActive() )
						continue;
					//  This is a clamped information node downstream from the fixable
					//  node being repaired.  Unset its instantiation.
					InferEnterEvidence( pgnddInfo, CLAMP() );
				}
				break;
			}
			default:
				break;
		}
	}
	InferEnterEvidence( pgndd, clamp );
}

//
//	Compute the probability distribution of the node and compare it to
//	the stored distribution.  Return true If it has changed.
//
bool MBNET_RECOMMENDER :: BProbsChange ( GPNDDDIST & gpndddist )
{
	MDVCPD mdv;
	//  The the distribution given the current state of evidence
	InferGetBelief( gpndddist.Pgnd(), mdv );
	//  Compare it to the other distribution
	MDVCPD & mdvo = gpndddist.Dist();
	int cprob = mdvo.first.size();
	assert( mdv.first.size() == cprob );

	for ( int i = 0; i < cprob; i++ )
	{
#ifdef DUMP	
		cout << "\n\t\tBProbsChange, state = "
			 << i
			 << ", old = "
			 << mdvo[i]
			 << ", new = "
			 << mdv[i];
#endif
		if ( ! BEqual( mdv[i], mdvo[i] ) )
		{
			return true;
		}
	}
	return false;
}

//  Add to the given array all nodes which are downstream from members
void MBNET_RECOMMENDER :: ExpandDownstream ( VPGNODEMBND & vpgndd )
{
	Model().ClearNodeMarks();
	//  Mark all nodes downstream of every given node
	for ( int i = 0; i < vpgndd.size(); i++ )
	{
		vpgndd[i]->Visit(false);	
	}

	//  Collect those nodes
	MODEL::MODELENUM mdlenum( Model() );
	GELEMLNK * pgelm;
	GNODEMBND * pgndd;
	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		if ( pgelm->EType() != GOBJMBN::EBNO_NODE )
			continue;

		//  We only support discrete nodes for now
		DynCastThrow( pgelm, pgndd );
		//  Add marked nodes which are not already present
		if ( pgndd->IMark() )
		{
			appendset( vpgndd, pgndd );
		}
	}
}

void MBNET_RECOMMENDER :: DetermineRelevantFixableNodes (
	VGPNDDDIST & vgndddFixRelevant,
	bool bUsePriorList,
	GNODEMBND * pgnddInfoPlan /* = NULL */ )
{
	assert( _vpgnddFix.size() > 0 );
	assert( _pgnddPDAbnormal != NULL );

#ifdef DUMP
	cout << "\nRecommendations, DetermineRelevantFixableNodes: abnormal PD node is "
		<< _pgnddPDAbnormal->ZsrefName().Szc();
	if ( bUsePriorList )
		cout << "  (secondary invocation)";
#endif

	/*
	    If 'bUsePriorList' is false:
		    Find all the relevant fixable nodes; i.e., those fixable nodes which
		  	linked to the Problem node and which are not clamped.  If unfixed,
		    (that is, not repaired and not "unfixable"), accumulate them for a
		  	search of relevant info nodes.
		    First, visit the problem defining node which is instantiated to an
		    abnormal state and mark all upstream links to it.
	    Else, if 'bUsePriorList' is true:
		    Use the relevant fixable list previously accumulated
	*/
	
	vgndddFixRelevant.clear();	//  clear the result array
	int cfix = 0;				//  count of fixables to search
	if ( bUsePriorList )
	{
		//  Use the original list of relevant fixables
		cfix = _vgndddFixRelevant.size();
	}
	else
	{	
		//  Fill in a new list of releveant fixables
		Model().ClearNodeMarks();
		_pgnddPDAbnormal->Visit();
		cfix = _vpgnddFix.size();
	}

	//  Accumulate the list of relevant, available (unfixed) fixable nodes, to
	//		which downstream info nodes will be added
	VPGNODEMBND vpgnddDownstreamFromRelevantFixable;
	int irel = 0;
	for ( int ifix = 0; ifix < cfix; ifix++ )
	{			
		GNODEMBND * pgnddFix;
		if ( bUsePriorList )
		{	// Use prior list element
			pgnddFix = _vgndddFixRelevant[ifix].Pgnd();
		}
		else
		{	//  See if this node was marked by "visit" above
			pgnddFix = _vpgnddFix[ifix];
			if ( pgnddFix->IMark() == 0 )
				continue;  // unconnected to current problem

			CLAMP clampFix;
			InferGetEvidence( pgnddFix, clampFix );
			if ( clampFix.BActive() )
				continue;	// Fixable node has been fixed; irrelevant
		}

		//  This is an unfixed, fixable node involved in the problem;
		//		append it to the list
		vgndddFixRelevant.resize(irel+1);
		GPNDDDIST & gpnddd = vgndddFixRelevant[irel++];
		gpnddd.Pgnd() = pgnddFix;
		//  Get its current PD and save it
		InferGetBelief( gpnddd.Pgnd(), gpnddd.Dist() );
		//  If fixable, add it to the list for accumulation of relevant info nodes
		ESTDLBL eLbl = ELbl( *pgnddFix );
		if ( eLbl == ESTDLBL_fixobs || eLbl == ESTDLBL_fixunobs )
		{
			vpgnddDownstreamFromRelevantFixable.push_back( pgnddFix );				
		}
	}

#ifdef DUMP
	cout << "\n\tInstantiations before relevance check";
	PrintInstantiations();
#endif

	//  Uninstantiate the info nodes which are downstream from any
	//	RELEVANT UNFIXED fixable nodes.  The first step, which is to gather such
	//  relevant fixable nodes, has been done above.
	//
	//	Note that this is NOT done for the info node being used for INFOPLAN (ECO)
	//	generation.  Since INFOPLAN::INFOPLAN precesses this node through its states,
	//	it's pointless to uninstantiate it here.
	//
	//  Next, find all info nodes downstream from the relevant unfixed fixables.
	//  Finally, temporarily rescind the instantiations of those info nodes.

	VPNDD_IST vpnddIstReset;	//  remember pairs of node pointers and ISTs to reset later

	//  Number of unfixed fixables so far
	int cUnfixedNodes = vpgnddDownstreamFromRelevantFixable.size();
	//  Expand the collection to include all downstream nodes
	ExpandDownstream( vpgnddDownstreamFromRelevantFixable );
	//	Get number of relevant info nodes
	int cInfoNodes = vpgnddDownstreamFromRelevantFixable.size() - cUnfixedNodes;
	CLAMP clampInfo;
	CLAMP clampReset;
	int ireset = 0;

#ifdef DUMP
	cout << "\n\t"
		 << cUnfixedNodes
		 << " fixable nodes are upstream of PD, "
		 << cInfoNodes
		 << " nodes are downstream from them";
#endif

	for ( int iinfo = cUnfixedNodes;
		  iinfo < vpgnddDownstreamFromRelevantFixable.size();
		  iinfo++ )
	{
		GNODEMBND * pgnddInfo = vpgnddDownstreamFromRelevantFixable[iinfo];
		if ( ELbl( *pgnddInfo ) != ESTDLBL_info )
			continue;	//  Not an info node
		if ( pgnddInfo == pgnddInfoPlan )
			continue;	//  The info node we're planning for
		InferGetEvidence( pgnddInfo, clampInfo );
		if ( ! clampInfo.BActive() )
			continue;	//  Not clamped
#ifdef DUMP
		cout << "\n\tinfo node "
			 << pgnddInfo->ZsrefName().Szc()
			 << " is being unclamped from state "
			 << clampInfo.Ist();
#endif
		//  Instantiated info node.  Save its ptr and current state for later.
		vpnddIstReset.push_back( PNDD_IST( pgnddInfo, clampInfo.Ist() ) );
		//  Unclamp it for relevance check
		InferEnterEvidence( pgnddInfo, clampReset );
	}

	//  Walk the list of relevant fixables accumulated so far and determine those
	//	which are probabilistically relevant.  Move those which are to the front
	//	of the relevance array, then chop the stragglers off the end.

	//  Get the current state of the PD node
	CLAMP clampProblem;
	InferGetEvidence( _pgnddPDAbnormal, clampProblem );
	IST istProblemSet = clampProblem.Ist();

#ifdef DUMP
	cout << "\n\tInstantiations during relevance check";
	PrintInstantiations();
#endif

	//  Iterate over all open (non-evidenced) states of the problem defining node.
	int cNodeFix = vgndddFixRelevant.size();
	int cRelevant = 0;
	for ( IST istProblem = 0; istProblem < _pgnddPDAbnormal->CState(); istProblem++ )
	{
		//  If we've already stored every possible relevant fixable node, quit
		if ( cRelevant == cUnfixedNodes )
			break;
		//  If this is the current problem state, skip it
		if ( istProblem == istProblemSet )
			continue;

		//  Temporarily instantiate the PD node to this alternative state
		InferEnterEvidence( _pgnddPDAbnormal, CLAMP(true, istProblem, true) );
		//  If state of evidence is impossible, continue
		if ( BInferImpossible() )
			continue;

		//  Iterate over the remaining relevant fixable nodes.  As they are found to be
		//	relevant, the nodes are moved to the front of the array and not checked again.
		for ( int inode = cRelevant; inode < cNodeFix; inode++ )
		{
			GPNDDDIST & gpndddist = vgndddFixRelevant[inode];
			GNODEMBND * pgnddFix = gpndddist.Pgnd();
			CLAMP clampFix;
			InferGetEvidence( pgnddFix, clampFix );
			if ( clampFix.BActive() && clampFix.Ist() == istNormal )
				continue;	//  This fixable node has been fixed and is irrelevant

			//  If the PD of this fixable node changes for this problem instantiation,
			//		it's relevant; move it to front of array.
			if ( BProbsChange( gpndddist ) )
			{
#ifdef DUMP
				cout << "\n\tfixable node "
					 << pgnddFix->ZsrefName().Szc()
					 << " is probabilistically relevant ";
#endif
				vswap( vgndddFixRelevant, cRelevant++, inode );
			}
#ifdef DUMP
			else
			{
				cout << "\n\tfixable node "
					 << pgnddFix->ZsrefName().Szc()
					 << " is NOT probabilistically relevant ";
			}
#endif
		}
	}

	//  Resize the computed array to chop off the irrelevant nodes
	vgndddFixRelevant.resize( cRelevant );

	//  Reset the probdef node back to its current instantiation
	InferEnterEvidence( _pgnddPDAbnormal, clampProblem );

	//  Reset the uninstantiated info nodes back to their prior states
	for ( ireset = 0; ireset < vpnddIstReset.size(); ireset++ )
	{
		IST ist = vpnddIstReset[ireset].second;
		GNODEMBND * pgndd = vpnddIstReset[ireset].first;
		CLAMP clampReset(true, ist, true);
		InferEnterEvidence( pgndd, clampReset );
	}

#ifdef DUMP	
	if ( cRelevant )
	{
		cout << "\nRecommendations, DetermineRelevantFixableNodes: relevant fixables are: " ;
		for ( int ifx = 0; ifx < vgndddFixRelevant.size(); ifx++ )
		{
			cout << "\n\tnode "
				 << vgndddFixRelevant[ifx].Pgnd()->ZsrefName().Szc()
				 << " is relevant fixable #"
				 << ifx;
		}
	}
	else
	{
		cout << "\nRecommendations, DetermineRelevantFixableNodes: there are NO relevant fixables " ;
	}
#endif

}

void MBNET_RECOMMENDER :: ComputeFixSequence (
	VGPNDDDIST & vgndddFixRelevant,		//  IN: Relevant fixable nodes
	VGNODERECWORK & vgnrwFix )			//  OUT: Ordered fix/repair sequence
{
	//  Using the array of node references and the array of relevant fixable nodes,
	//		initialize the fix/repair sequence array.
	vgnrwFix.resize( vgndddFixRelevant.size() ) ;
	for ( int ind = 0; ind < vgnrwFix.size(); ind++ )
	{
		GNODEMBND * pgndd = vgndddFixRelevant[ind].Pgnd();
		vgnrwFix.InitElem( pgndd, ind );
	}

	VGNODERECWORK::ESORT esort = VGNODERECWORK::ESRT_ProbOverCost;
	switch ( _ercm )
	{
		case ERCM_MostLikely:
			esort = VGNODERECWORK::ESRT_SgnProb;
			break;
		case ERCM_Cheap:
			esort = VGNODERECWORK::ESRT_NegCost;
			break;
	}
	vgnrwFix.Sort( esort );
	vgnrwFix.Rescale();

#ifdef DUMP
	cout << "\nRecommendations, ComputeFixSequence: fix/repair sequence is:";
	for ( ind = 0; ind < vgnrwFix.size(); ind++ )
	{	
		GNODEREFP & gndref = vgnrwFix[ind].Gndref();
		cout << "\n\tnode "
			 << ind
			 << " is "
			 << gndref.Gndd().ZsrefName().Szc()
			 << ", p/c = "
			 << vgnrwFix[ind].PbOverCost()
			 << ", utility = "
			 << gndref.Util();
	}
#endif
}


//  Identify the relevant info nodes and compute their costs.
//  Formerly "BxComputeCosts()"
void MBNET_RECOMMENDER :: DetermineRelevantInfoNodes (
	VGNODERECWORK & vgnrwFix,
	VGNODERECWORK & vgnrwInfo )
{
	assert( _pgnddPDAbnormal != NULL );
	CLAMP clampInfo;

	vgnrwInfo.clear();

#ifdef DUMP
	cout << "\nRecommendations, DetermineRelevantInfoNodes:";
#endif

	for ( int ind = 0; ind < _vpgndref.size(); ind++ )
	{
		GNODEREFP * pgndref = _vpgndref[ind];
		assert( pgndref );
		if ( pgndref->ELbl() != ESTDLBL_info )
			continue;
		InferGetEvidence( pgndref->Pgndd(), clampInfo );
		// Instantiated info nodes are irrelevant	
		if ( clampInfo.BActive() )
			continue;

		//  Create an array of fix/repair plans for all states of this info node
		INFOPLAN infoplan( self, pgndref->Gndd(), vgnrwFix );

		//  If all plans result in the same sequence, it's irrelevant
		if ( infoplan.BSameSequence() )
		{
#ifdef DUMP
			cout << "\n\tinfo node "
				 <<	pgndref->Gndd().ZsrefName().Szc()
				 << " is NOT relevant; all plans are the same";
#endif
		}
		else
		{
			//  Add this info node to the array
			vgnrwInfo.InitElem( pgndref->Pgndd() );

			//  Set the utility to be the negative of the plan cost
			COST cost = infoplan.Cost();
			pgndref->Util() = - cost;

#ifdef DUMP
			cout << "\n\tinfo node "
				 <<	pgndref->Gndd().ZsrefName().Szc()
				 << " is relevant, utility = "
				 << pgndref->Util();
#endif
		}
	}
}


void MBNET_RECOMMENDER :: operator () ()
{
	//  If BReady() has not been called yet, do it now.
	if ( ! _bReady )
	{
		if ( ! BReady() )
			throw GMException( _err, "network state invalid for recommendations" );
	}

#ifdef DUMP
	cout.precision(8);
#endif

	//  Clear the "ready" flag; i.e., force subsequent call to BReady().
	Unready();

	if ( _ercm != ERCM_FixPlan )
		throw GMException( EC_NYI, "only fix/plan recommendations supported" );

	assert( _pgnddPDAbnormal );

	//  Array of fixable nodes
	VGNODERECWORK vgnrwFix( this );
	//  Array of informational nodes
	VGNODERECWORK vgnrwInfo( this );

	//  Collect the relevant fixable nodes
	DetermineRelevantFixableNodes( _vgndddFixRelevant, false, NULL );

	//  Collect and order the relevant fixable node information,
	//		sorted according to planning method and rescaled.
	ComputeFixSequence( _vgndddFixRelevant, vgnrwFix );

	//  Compute ECR, the expected cost of repair.
	vgnrwFix.SetSequenceCost();

	//  If information nodes are relevant, determine the set of them.
	if ( _ercm == ERCM_FixPlan || _ercm == ERCM_FixPlanOnly )
	{
		//  Compute ECO, the expected cost of the Observation-Repair sequence.
		DetermineRelevantInfoNodes( vgnrwFix, vgnrwInfo );
	}

	//  Collect all relevant fixables and infos and sort them
	VGNODERECWORK vgnrwRecom( this );
	vgnrwRecom.resize( vgnrwFix.size() + vgnrwInfo.size() );

	//  Add fixables...
	for ( int ind = 0; ind < vgnrwFix.size(); ind++ )
	{
		vgnrwRecom[ind] = vgnrwFix[ind];
	}
	//  Add infos...
	int indStart = ind;
	for ( ind = 0; ind < vgnrwInfo.size(); ind++ )
	{
		vgnrwRecom[indStart + ind] = vgnrwInfo[ind];
	}
	
	//  Sort by negative utility
	vgnrwRecom.Sort( VGNODERECWORK::ESRT_SgnUtil );

	//  Copy information to the output areas, ordered by lowest cost.
	//  First, determine how many are more expensive than a service call
	//	since we discard those.
	int cRecom = vgnrwRecom.size();
	int iRecom = 0;
	if ( _costService != 0.0 )
	{
		for ( iRecom = 0; iRecom < cRecom; iRecom++ )
		{
			COST cost = vgnrwRecom[iRecom].Gndref().Util();
			if ( cost >= _costService )
				break;
		}
		cRecom = iRecom;
	}

	_vzsrNodes.resize(cRecom);
	_vlrValues.resize(cRecom);

	for ( iRecom = 0; iRecom < cRecom; iRecom++ )
	{
		GNODEREFP & gndref = vgnrwRecom[iRecom].Gndref();
		//  Add the node name to the list
		_vzsrNodes[iRecom] = gndref.Gndd().ZsrefName();
		//  and give its score (utility)
		_vlrValues[iRecom] = gndref.Util();

#ifdef DUMP
		cout << "\nRecommendation # "
			 << iRecom
			 << ", node "
			 << _vzsrNodes[iRecom].Szc()
			 << " = "
			 << _vlrValues[iRecom];
		cout.flush();
#endif
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\recomend.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       recomend.h
//
//--------------------------------------------------------------------------

//
//	recomend.h:  Recommendations computations
//

#ifndef _RECOMEND_H_
#define _RECOMEND_H_

#include "cliqset.h"

const IST istNormal = 0;	//  MSRDEVBUG!

class MBNET_RECOMMENDER;

class GPNDDDIST
{
  public:
	GPNDDDIST ( GNODEMBND * pgndd = NULL )
		:_pgndd(pgndd)
	{
	}
	GNODEMBND & Gnd()
	{
		assert( _pgndd != NULL );
		return *_pgndd;
	}
	GNODEMBND * & Pgnd()
	{
		return _pgndd;
	}
	MDVCPD & Dist ()
	{ 
		return _dd; 
	}
	DECLARE_ORDERING_OPERATORS(GPNDDDIST);

  protected:
	GNODEMBND * _pgndd;
	MDVCPD _dd;
};

inline bool GPNDDDIST :: operator < ( const GPNDDDIST & gpndist ) const
{
	return _pgndd < gpndist._pgndd;
}

//  Define VGPNDDDIST, an array of GPNDDDISTs
DEFINEV(GPNDDDIST);	

//  Define a pair of node pointer and state index
typedef pair<GNODEMBND *,IST> PNDD_IST;
//  Define VPNDD_IST
DEFINEV(PNDD_IST);


//
//	Helper class containing processed node information extracted from
//	the belief network.
//
class GNODEREFP
{
  public:
	GNODEREFP ( PROPMGR & propMgr, GNODEMBND * pgndd );

	const COST CostObserve () const			{ return _costObserve;	}
	const COST CostFix () const				{ return _costFix;		}
	COST & Util ()							{ return _costUtil;		}
	ESTDLBL ELbl () const					{ return _eLbl;			}
	GNODEMBND & Gndd ()						{ return *_pgndd;		}
	GNODEMBND * Pgndd ()					{ return _pgndd;		}
	bool BLeak () const						{ return _bLeak;		}

	bool operator == ( const GNODEREFP & gndref ) const
		{ return _pgndd == gndref._pgndd ; }
	bool operator < ( const GNODEREFP & gndref ) const
		{ return _pgndd < gndref._pgndd;  }
	bool operator != ( const GNODEREFP & gndref ) const
		{ return !(self == gndref); }

	bool operator == ( const GNODEMBND * pgndd ) const
		{ return _pgndd == pgndd ; }
	bool operator < ( const GNODEMBND * pgndd  ) const
		{ return _pgndd < pgndd;  }
	bool operator != ( const GNODEMBND * pgndd ) const
		{ return !(self == pgndd); }
	
  protected:
	GNODEMBND * _pgndd;			//  Node pointer
	ESTDLBL _eLbl;				//  Standard label
	COST _costObserve;			//  Cost to observe
	COST _costFix;				//	Cost to fix
	COST _costUtil;				//  Computed utility
	bool _bLeak;				//  Leak node from CI expansion?
};

class VPGNODEREFP : public vector<GNODEREFP *>
{
  public:
	~ VPGNODEREFP ()
	{
		clear();
	}

	int ifind ( const GNODEMBND * pgndd )
	{
		for ( int indref = 0; indref < size(); indref++ )
		{
			if ( self[indref]->Pgndd() == pgndd )
				return indref;
		}
		return -1;
	}
	void clear ()
	{
		for ( int i = 0; i < size(); i++ )
			delete self[i];

		vector<GNODEREFP *>::clear();
	}
};

//	
//	Recommendations work node structure.  (Formerly 'PROBNODE')
//
class GNODERECWORK
{
	friend class VGNODERECWORK;
  public:
    GNODERECWORK ()
		: _pgndref(NULL),
		_pbFault(0),
		_pbOverCost(0)
		{}
	GNODEREFP * operator -> ()
		{ return _pgndref; }
	GNODEREFP * operator -> () const
		{ return _pgndref; }

	COST CostObsIfFixable () const
	{
		return BFixable()
			? _pgndref->CostObserve()
			: 0.0;
	}

	GNODEREFP * Pgndref () const
		{ return _pgndref; }
	GNODEREFP & Gndref ()	const	
	{
		assert( _pgndref );
		return *_pgndref;
	}
	void SetCost ( COST cost )
	{
		assert( _pgndref );
		_pgndref->Util() = - cost;
	}
	bool BFixable () const	
	{
		ESTDLBL elbl = Pgndref()->ELbl();
		return elbl == ESTDLBL_fixunobs
			|| elbl == ESTDLBL_fixobs;
	}	
	PROB PbOverCost () const		{ return _pbOverCost; }
	PROB PbFault () const			{ return _pbFault;    }
	void SetPbFault ( PROB prob )
		{ _pbFault = prob ; }

    DECLARE_ORDERING_OPERATORS(GNODERECWORK);

  protected:
    GNODEREFP * _pgndref;
	PROB _pbFault;
	PROB _pbOverCost;	

  protected:
	void Init ( MBNET_RECOMMENDER & mbnRecom, GNODEREFP * pgndref );
	void Init ( GNODEREFP * pgndref, PROB pbFault );
};

//
//	Controlled array of recommendations node work structures (Formerly RGPROBNODE).
//
class VGNODERECWORK : public vector<GNODERECWORK>
{
  public:
	VGNODERECWORK ( MBNET_RECOMMENDER * pmbnRec = NULL )
		: _pmbnRec( pmbnRec ),
		_bSeqSet( false ),
		_iFixedK(-1)
		{}

	void InitElem ( GNODEMBND * pgndd, int index = -1 );
	void InitElem ( GNODEREFP * pgndref, int index = -1 );
	enum ESORT 
	{ 
		ESRT_ProbOverCost, 
		ESRT_SgnProb, 
		ESRT_NegCost, 
		ESRT_SgnUtil 
	};

	void Sort ( ESORT esort );
	void Rescale ();
	COST Cost ( int ielemFirst = 0, int * piMinK = NULL );
	bool BSameSequence ( const VGNODERECWORK & vgnw );
	void SetSequenceCost ();
	COST CostECRDefault () const
	{
		assert( _bSeqSet );
		return size()
			 ? self[0]->Util()
			 : CostService();
	}
	MBNET_RECOMMENDER & MbnRec ()
	{
		assert( _pmbnRec );
		return *_pmbnRec;
	}
	const MBNET_RECOMMENDER & MbnRec () const
	{
		assert( _pmbnRec );
		return *_pmbnRec;
	}
	MBNET_RECOMMENDER * & PmbnRec ()
		{ return _pmbnRec; }

	COST CostService () const;

  protected:
	MBNET_RECOMMENDER * _pmbnRec;			//  The controlling recommendations object
	bool _bSeqSet;							//	Has the sequence been set yet?
	int _iFixedK;							//  Fixed state point
};

DEFINEV(VGNODERECWORK);

///////////////////////////////////////////////////////////////////////////////////////
//
//	MBNET_RECOMMENDER: 
//	
//		The troubleshooting recommendations object.  It's a "node ranker",
//		so its results are a list of node pointers and real values stored in members
//		of the base class, MBNET_NODE_RANKER.
//
//		Since all evidence is relative to a particular inference engine, that engine
//		must be used during construction.
//	
//		To invoke, use operator().  To determine if network state is compatible with
//		troubleshooting recommendations, call BReady().  If successful, the information
//		collected is saved for the next recommendations call.  To force recollection
//		of troubleshooting information, call Unready().
//
///////////////////////////////////////////////////////////////////////////////////////
class MBNET_RECOMMENDER : public MBNET_NODE_RANKER
{
  public:
	//   Recommendations computation method
	enum ERCMETHOD 
	{ 
		ERCM_None,
		ERCM_FixPlan,
		ERCM_Cheap,
		ERCM_MostLikely,
		ERCM_Random,
		ERCM_FixPlanOnly,
		ERCM_Max
	};

	//  Construct using the appropriate inference engine
	MBNET_RECOMMENDER ( GOBJMBN_CLIQSET & inferEng, 
						ERCMETHOD ercm = ERCM_FixPlan );
	virtual ~ MBNET_RECOMMENDER ();

	INT EType () const
		{ return EBNO_RANKER_RECOMMENDATIONS; }
	
	//  The ranking function
	virtual void operator () ();

	//  Return true if the network is in a state compatible with
	//		troubleshooting recommendations or sets ErcError().  Can
	//		be called separately or will be called by ranking operator().
	bool BReady ();		
	//  Clear the "ready" condition of the object
	void Unready () 
		{ _bReady = false; }
	//  Check to see if the object is in the "ready" condition
	bool BIsReady() const
		{ return _bReady; }

	//  Enter evidence for a troubleshooting model
	void EnterEvidence ( GNODEMBND * pgndd,			//  Node to set/observe
						 const CLAMP & clamp,		//  Value to set/unset
						 bool bSet = true );		//  Set or observe?

	//  Return the cost-of-service from the model; it's stored as 
	//		the model's 'cost-to-fix'.
	COST CostServiceModel ();

	//  General accessors
	ECGM EcError () const
		{ return _err; }
	ERCMETHOD ErcMethod () const
		{ return _ercm; }
	COST CostService () const
		{ return _costService; }
	COST CostObsProbDef () const
		{ return _costObsProbDef; }
	PROPMGR & PropMgr() 
		{ return _propMgr; }
	GNODEMBND * PgnddProbDefAbnormal () const
		{ return _pgnddPDAbnormal; }
	VPGNODEMBND & VpgnddFix () 
		{ return _vpgnddFix; }
	VPGNODEREFP & Vpgndref ()
		{ return _vpgndref; }
	ESTDLBL ELbl ( GNODEMBN & gnd );

 	//  Result array of relevant fixables; if 'bUsePriorList'
	//		is true, member array is starting point.  'pgnddInfo'
	//		is optional pointer to info node used in INFOPLAN.
	void DetermineRelevantFixableNodes ( VGPNDDDIST & vgndddFixRelevant,	
										 bool bUsePriorList,
										 GNODEMBND * pgnddInfoPlan = NULL );		

	void ComputeFixSequence ( VGPNDDDIST & vgndddFixRelevant,		//  IN: Relevant fixable nodes
							  VGNODERECWORK & vgnrwFix );			//  OUT: Ordered fix/repair sequence

	//  Interface to inference engine
	void InferGetBelief ( GNODEMBND * pgndd, MDVCPD & mdvBel );
	void InferGetEvidence ( GNODEMBND * pgndd, CLAMP & clamp );
	void InferEnterEvidence ( GNODEMBND * pgndd, const CLAMP & clamp );
	bool BInferImpossible ();

  protected:
	GOBJMBN_CLIQSET & _inferEng;		//  Inference engine
	PROPMGR _propMgr;					//  Property handler
	ECGM _err;							//  Last error code
	ERCMETHOD _ercm;					//  Planning method
	GNODEMBND * _pgnddPDAbnormal;		//  Abnormal PD node
	COST _costService;					//  Service cost; cost-to-fix of network
	COST _costObsProbDef;				//  Cost to observe PD node
	VPGNODEMBND _vpgnddFix;				//  Fixable nodes
	VPGNODEREFP _vpgndref;				//  Array of references to all nodes
	bool _bReady;						//  BReady() has been successfully called
	VGPNDDDIST _vgndddFixRelevant;		//  Relevant fixable nodes with unconditional distributions

  protected:
	GOBJMBN_CLIQSET & InferEng ()  
		{ return _inferEng; }

	//  Formerly "ComputeCosts"
	void DetermineRelevantInfoNodes ( VGNODERECWORK & vgnrwFix,		// IN: relevant fixables
									  VGNODERECWORK & vgnrwInfo );	// OUT: relevant infos

	//  Add to the given array all nodes which are downstream
	void ExpandDownstream ( VPGNODEMBND & vpgndd );
	//  Return true if the current state of evidence gives a different probability
	//	distribution that the one stored 
	bool BProbsChange ( GPNDDDIST & gpndddist );

	void PrintInstantiations ();

	HIDE_UNSAFE(MBNET_RECOMMENDER);
};

#endif // _RECOMEND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\regkey.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       regkey.h
//
//--------------------------------------------------------------------------

#ifndef _REGKEY_H_
#define _REGKEY_H_

#include <assert.h>

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// REGKEY: Wrapper for a registry key
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class REGKEY
{
  public:
	REGKEY() : m_hKey(NULL) {}
	~ REGKEY()	{ Close(); }

	HKEY HKey () const { return m_hKey; }
 	operator HKEY() const { return m_hKey; }

	LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
	LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG SetKeyValue( LPCTSTR lpszKeyName, 
					  LPCTSTR lpszValue, 
					  LPCTSTR lpszValueName = NULL);

	static LONG WINAPI SetValue( HKEY hKeyParent, 
								 LPCTSTR lpszKeyName,
								 LPCTSTR lpszValue, 
								 LPCTSTR lpszValueName = NULL);

	LONG Create( HKEY hKeyParent, 
				 LPCTSTR lpszKeyName,
				 LPTSTR lpszClass = REG_NONE, 
				 DWORD dwOptions = REG_OPTION_NON_VOLATILE,
				 REGSAM samDesired = KEY_ALL_ACCESS,
				 LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
				 LPDWORD lpdwDisposition = NULL);

	LONG Open( HKEY hKeyParent, 
			   LPCTSTR lpszKeyName,
			   REGSAM samDesired = KEY_ALL_ACCESS);

	LONG Close();

	LONG RecurseDeleteKey(LPCTSTR lpszKey);

	void Attach(HKEY hKey);

	HKEY Detach()
	{
		HKEY hKey = m_hKey;
		m_hKey = NULL;
		return hKey;
	}
	LONG DeleteSubKey(LPCTSTR lpszSubKey)
	{
		assert(m_hKey != NULL);
		return RegDeleteKey(m_hKey, lpszSubKey);
	}
	LONG DeleteValue(LPCTSTR lpszValue)
	{
		assert(m_hKey != NULL);
		return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
	}

  protected:
	HKEY m_hKey;
};


#endif // _REGKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\stlstream.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stlstream.h
//
//--------------------------------------------------------------------------

//
//	stlstream.h:  Stream STL template classes.
//
//		Templates in this file typically generate functions which take a 
//		stream reference as an argument, along with a const reference to
//		the thing to be streamed; it returns a reference to the stream.
//
//		The reason that the stream parameter must be included in the 
//		template is generate a function which returns the correct stream type.
//		If the stream type were not a templated argument, then the 
//		template would be forced to return a single immutable type, such 
//		as "ostream".  This would cause cascaded stream insertion operators
//		to fail to compile, since type errors would occur in the middle of the
//		sequence.  In the following example, assume that there is a special
//		insertion operator defined between class MYSTREAM and class Y:
//
//			MYSTREAM myst;
//			extern MYSTREAM & operator << ( MYSTREAM & m, const Y & y );
//			X x;
//			Y y;
//
//			myst << x		// Template function generated and called
//				 << y;		// ERROR: return value of template function 
//							//    incorrect for special operator above.
//
#ifndef _STLSTREAM_H_
#define _STLSTREAM_H_

#include <iostream>			// C++ RTL/STL Streams inclusion
#include <fstream>

#include "mscver.h"			// Version-dependent stuff
#include "zstr.h"			// ZSTR handling
#include "mdvect.h"			// Multi-dimensional vector handling

//  Delimiters used in parameter files
#define	CH_EOS			((char)0)		// End of string
#define	CH_DELM_OPEN	((char)'(')		// Start of value group
#define	CH_DELM_CLOSE	((char)')')		// End of value group
#define	CH_BLOCK_OPEN	((char)'{')		// Start of value block
#define	CH_BLOCK_CLOSE	((char)'}')		// End of value block
#define CH_INDEX_OPEN   ((char)'[')		// Name index start
#define CH_INDEX_CLOSE  ((char)']')		// Name index end
#define	CH_PREAMBLE		((char)':')		// Delmiter for array size
#define	CH_FILL			((char)' ')		// Fill character
#define CH_SEP			((char)',')		// Value group separator
#define CH_DELM_STR		((char)'\"')	
#define CH_META			((char)'\\')
#define CH_DELM_ENTRY	((char)';')
#define CH_EQ			((char)'=')
#define CH_NAME_SEP     ((char)'.')

//////////////////////////////////////////////////////////////////////////////////
//	Read and write STL pairs from or to a stream
//////////////////////////////////////////////////////////////////////////////////

template<class _OS, class _First, class _Second> inline
_OS & operator << (_OS & os, const pair<_First,_Second> & pr)
{
	os << CH_DELM_OPEN;
	os << pr.first;
	os << pr.second;
	os << CH_DELM_CLOSE;
	return os;
}

template<class _IS, class _First, class _Second> inline
_IS & operator >> (_IS & is, pair<_First,_Second> & pr)
{
	char ch;
	is >> ch;
	if (ch != CH_DELM_OPEN)
		_THROW1(runtime_error("invalid block: pair >> (1)"));

	is >> pr.first;
	is >> pr.second;

	is >> ch;
	if (ch != CH_DELM_CLOSE)
		_THROW1(runtime_error("invalid block: pair >> (2)"));
	return is;
}  

//////////////////////////////////////////////////////////////////////////////////
//	Read and write STL vectors from or to a stream
//////////////////////////////////////////////////////////////////////////////////
template<class _OS, class _T> inline
_OS & operator << (_OS & os, const vector<_T>& vt )
{
	os << CH_DELM_OPEN;
	os << (UINT) vt.size();
	os << CH_PREAMBLE;
	for ( size_t i = 0; i < vt.size(); )
	{	
		os << vt[i];
		if ( ++i != vt.size() )	
			os << ',' ;
	}
	os << CH_DELM_CLOSE;
	return os;
}

template<class _IS, class _T> inline
_IS & operator >> (_IS & is, vector<_T>& vt )
{
	char ch;
	is >> ch;
	if (ch != CH_DELM_OPEN)
		_THROW1(runtime_error("invalid block: vector>> (1)"));
	size_t l;
	is >> l;
	is >> ch;
	if (ch != CH_PREAMBLE)
		_THROW1(runtime_error("invalid block: vector>> (2)"));

	vt.resize(l);
	for ( size_t i = 0 ; i < l; )
	{
		_T it;
		is >> it;
		vt[i] = it;
		if ( ++i < l )
		{
			is >> ch;
			if (ch != CH_SEP)
				break;
		}
	}
	if ( i != l )
		_THROW1(runtime_error("invalid block: vector>> (3)"));
	is >> ch;
	if (ch != CH_DELM_CLOSE)
		_THROW1(runtime_error("invalid block: vector>> (4)"));
	return is;
}

//////////////////////////////////////////////////////////////////////////////////
//	Read and write STL valarrays from or to a stream
//////////////////////////////////////////////////////////////////////////////////
template<class _OS, class _T> inline
_OS & operator << ( _OS & os, const valarray<_T>& vt )
{
	os << CH_DELM_OPEN;
	os << (UINT) vt.size();
	os << CH_PREAMBLE;
	for ( int i = 0;
		  i < vt.size() ; )
	{	
		os << vt[i];
		if ( ++i != vt.size() )	
			os << ',' ;
	}
	os << CH_DELM_CLOSE;
	return os;
}

template<class _IS, class _T> inline
_IS & operator >> (_IS & is, valarray<_T>& vt )
{
	char ch;
	is >> ch;
	if (ch != CH_DELM_OPEN)
		_THROW1(runtime_error("invalid block: valarray >> (1)"));
	size_t l;
	is >> l;
	is >> ch;
	if (ch != CH_PREAMBLE)
		_THROW1(runtime_error("invalid block: valarray >> (2)"));

	vt.resize(l);
	for ( size_t i = 0 ; i < l; )
	{
		_T it;
		is >> it;
		vt[i] = it;
		if ( ++i < l )
		{
			is >> ch;
			if (ch != CH_SEP)
				break;
		}
	}
	if ( i != l )
		_THROW1(runtime_error("invalid block: valarray >> (3)"));
	is >> ch;
	if (ch != CH_DELM_CLOSE)
		_THROW1(runtime_error("invalid block: valarray >> (4)"));
	return is;
}


//////////////////////////////////////////////////////////////////////////////////
//	Read and write MDVSLICEs from or to a stream
//////////////////////////////////////////////////////////////////////////////////
template<class _OS> inline
_OS & operator << (_OS & os, const MDVSLICE & mslice )
{	
	os << CH_DELM_OPEN;
	os << (UINT) mslice.start();
	os << mslice.size();
	os << mslice.stride();
	os << CH_DELM_CLOSE;
	return os;
}

template<class _IS> inline
_IS & operator >> ( _IS & is, MDVSLICE & mslice )
{	
	char ch;
	is >> ch;
	if (ch != CH_DELM_OPEN)
		_THROW1(runtime_error("invalid block: slice >> (1)"));
	VIMD vimdLen;
	VIMD vimdStride;
	size_t lStart;
	is >> lStart;
	is >> vimdLen;
	is >> vimdStride;
	mslice = MDVSLICE( lStart, vimdLen, vimdStride );
	
	is >> ch;
	if (ch != CH_DELM_CLOSE)
		_THROW1(runtime_error("invalid block: slice >> (2)"));
	return is;
}

//////////////////////////////////////////////////////////////////////////////////
//	Format (pretty-print) MDVDENSEs using an Iterator.
//
//  This is NOT the same as streaming out an MDVDENSE; it formats the array for
//	easy reading.  Note that it requires an Iterator.
//	
//	MSRDEVBUG: This, too, should be templatized, but there's a bug in template
//		expansion using nested class names.
//////////////////////////////////////////////////////////////////////////////////
inline 
ostream & operator << ( ostream & os, TMDVDENSE<double>::Iterator & itmdv )
{
	os << "\ndump of mdvect,\n\t\tslice = "
		<< itmdv.Slice();

	if ( itmdv.Slice() != itmdv.Mdv().Slice() )
	{
		os << ",\n\t\toriginal slice = "
		   << itmdv.Mdv().Slice();
	}
	if ( itmdv.BReorder() )
	{
		os << ",\n\t\treordered ";
		os << itmdv.VimdReorder();
	}
	os << '.';
	itmdv.Reset();
	for ( int ii = 0 ; itmdv.BNext() ; ii++ )
	{
		const VIMD & vimd = itmdv.Vitmd();
		cout << "\n\t[";
		for ( int i = 0 ; i < vimd.size(); i++ )
		{
			cout << vimd[i];
			if ( i + 1 < vimd.size() )
				cout << ",";
		}	
		size_t indx = itmdv.Indx();
		const double & t = itmdv.Next();
		cout << "] ("
			<< ii
			<< '='
			<< (UINT) indx
			<< ") = "
			<< t;
	}
	return os;
}

#endif //  _STLSTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\utility.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       utility.cpp
//
//--------------------------------------------------------------------------

//
//	utility.cpp: utility computation
//

#include <basetsd.h>
#include <math.h>
#include "utility.h"
#include "infer.h"

MBNET_ENTROPIC_UTILITY :: MBNET_ENTROPIC_UTILITY ( GOBJMBN_INFER_ENGINE & inferEng )
	: MBNET_NODE_RANKER( inferEng.Model() ),
	_inferEng( inferEng ),
	_propMgr( inferEng.Model() ),
	_cHypo(0),
	_cInfo(0)
{
	_iLblHypo = _propMgr.ILblToUser( ESTDLBL_hypo );		
	_iLblInfo = _propMgr.ILblToUser( ESTDLBL_info );		
	_iLblProblem = _propMgr.ILblToUser( ESTDLBL_problem );		

	BuildWorkItems();
}


//
//	Collect all informational, problem defining and hypothesis nodes
//	into a structure with additional working data.
//
void MBNET_ENTROPIC_UTILITY :: BuildWorkItems ()
{
	ZSREF zsrPropTypeLabel = _propMgr.ZsrPropType( ESTDP_label );
	MODEL::MODELENUM mdlenum( Model() );

	_dquwrk.clear();
	_cHypo = 0;
	_cInfo = 0;

	UTILWORK uwDummy;
	GELEMLNK * pgelm;

	//  Collect all the nodes into a pointer array.  Three node labels
	//	are collected: info and probdef nodes (considered as info)
	//	and hypo nodes (considered as hypo).

	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		if ( pgelm->EType() != GOBJMBN::EBNO_NODE )
			continue;

		//  We only support discrete nodes for now.
		DynCastThrow( pgelm, uwDummy._pgndd );

		//  See if this is an expansion (created) node
		if ( uwDummy._pgndd->BFlag( EIBF_Expansion ) )
			continue;	// not a user-identifiable artifact; skip it

		//  See if it has a label		
		PROPMBN * propLbl = uwDummy._pgndd->LtProp().PFind( zsrPropTypeLabel );		
		if ( ! propLbl )
			continue;	//  no label; skip it

		uwDummy._iLbl = propLbl->Real();
		if ( uwDummy._iLbl == _iLblHypo )
			_cHypo++;
		else
		if ( uwDummy._iLbl == _iLblInfo || uwDummy._iLbl == _iLblProblem )
			_cInfo++;
		else
			continue;	//  not a label of interest

		//  Initialize the other member variables
		uwDummy._rUtil = 0.0;
		uwDummy._iClamp = -1;
		//  Put the item on the work queue
		_dquwrk.push_back( uwDummy );
	}
	
}

REAL MBNET_ENTROPIC_UTILITY :: RComputeHypoGivenInfo (
	UTILWORK & uwHypo,
	UTILWORK & uwInfo )
{
	assert( uwHypo._iLbl == _iLblHypo );
	assert( uwInfo._iLbl != _iLblHypo );

	//  Clamped nodes are irrelevant
	if ( uwHypo._iClamp >= 0 || uwInfo._iClamp >= 0 )
		return 0.0;

	REAL rUtilOfInfoForHypo = 0.0;
	int cState = uwInfo._pgndd->CState();
	int cStateHypo = uwHypo._pgndd->CState();
	MDVCPD mdvhi;
	REAL rp_h0 = uwHypo._dd[0];	// Probability of hypo node being normal

	for ( int istInfo = 0; istInfo < cState; istInfo++ )
	{
		//  Get belief of hypo node given info state
		_inferEng.EnterEvidence( uwInfo._pgndd, CLAMP( true, istInfo, true ) );
		_inferEng.GetBelief( uwHypo._pgndd, mdvhi );
		REAL rp_h0xj = mdvhi[0];	//  p(h0|xj)
		REAL rLogSum = 0.0;
		for ( int istHypo = 1; istHypo < cStateHypo; istHypo++ )
		{
			REAL rp_hi = uwHypo._dd[istHypo];
			REAL rp_hixj = mdvhi[istHypo];
			rLogSum += fabs( log(rp_hixj) - log(rp_h0xj) - log(rp_hi) + log(rp_h0) );
		}
		rUtilOfInfoForHypo += rLogSum * uwInfo._dd[istInfo];
	}

	//  Clear evidence against info node
	_inferEng.EnterEvidence( uwInfo._pgndd, CLAMP() );

	return rUtilOfInfoForHypo;
}

DEFINEVP(UTILWORK);

void MBNET_ENTROPIC_UTILITY :: ComputeWorkItems()
{
	CLAMP clamp;
	VPUTILWORK vpuw; // Remember pointers to hypo items

	//  Get unconditional beliefs of all relevant (unclamped) nodes
	for ( DQUTILWORK::iterator itdq = _dquwrk.begin();
		  itdq != _dquwrk.end();
		  itdq++ )
	{
		UTILWORK & ut = *itdq;
		ut._rUtil = 0.0;
		ut._iClamp = -1;

		//  Remember the indicies of the hypo nodes
		if ( ut._iLbl == _iLblHypo )
			vpuw.push_back( & (*itdq) );

		//  Get the current evidence for the node
		_inferEng.GetEvidence( ut._pgndd, clamp );
		//  If node is unclamped,
		if ( ! clamp.BActive() )
		{
			//  get unconditional probs, else
			_inferEng.GetBelief( ut._pgndd, ut._dd );
		}
		else
		{
			//  remember clamped state (serves as marker)
			ut._iClamp = clamp.Ist();
		}
	}

	for ( itdq = _dquwrk.begin();
		  itdq != _dquwrk.end();
		  itdq++ )
	{
		UTILWORK & utInfo = *itdq;
		if ( utInfo._iLbl == _iLblHypo )
			continue;
		utInfo._rUtil = 0.0;
		for ( int ih = 0; ih < vpuw.size(); ih++ )
		{
			utInfo._rUtil += RComputeHypoGivenInfo( *vpuw[ih], utInfo );
		}				
	}
}


void MBNET_ENTROPIC_UTILITY :: operator () ()
{
	// Clear any old results
	Clear();

	if ( _cHypo == 0 || _cInfo == 0 )
		return;		//  Nothing to do

	//  Compute all utilities
	ComputeWorkItems();

	//  Sort the work queue by utility
	sort( _dquwrk.begin(), _dquwrk.end() );

	//  Pour the information into the output work areas
	_vzsrNodes.resize(_cInfo);
	_vlrValues.resize(_cInfo);
	int iInfo = 0;
	for ( DQUTILWORK::reverse_iterator ritdq = _dquwrk.rbegin();
		  ritdq != _dquwrk.rend();
		  ritdq++ )
	{
		UTILWORK & ut = *ritdq;
		if ( ut._iLbl == _iLblHypo )
			continue;		
		_vzsrNodes[iInfo] = ut._pgndd->ZsrefName();
		_vlrValues[iInfo++] = ut._rUtil;
	}
	assert( iInfo == _cInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\symt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       symt.cpp
//
//--------------------------------------------------------------------------

//
//  SYMT.CPP
//

#include <basetsd.h>
#include <iostream>
#include <fstream>
#include <string.h>
#include "model.h"
#include "symtmbn.h"

//
//	Create a duplicate of the given token array given a source token
//		array and the symbol table associated with this token array.
//
void VTKNPD :: Clone ( MPSYMTBL & mpsymtbl, const VTKNPD & vtknpd )
{
	ASSERT_THROW( size() == 0,
				EC_INVALID_CLONE,
				"cannot clone into non-empty structure" );
	resize( vtknpd.size() );
	for ( int i = 0; i < size(); i++ )
	{
		TKNPD & tk = self[i];
		const TKNPD & tkOther = vtknpd[i];
		//  Get the token's string pointer or NULL if it's not a string
		if ( tkOther.BStr() )
		{
			SZC szcOther = tkOther.Szc();
			assert( szcOther && strlen( szcOther ) > 0 );
			tk = mpsymtbl.intern(szcOther);
		}
		else
		{
			tk = tkOther.Dtkn();
		}
	}
}

ZSTR VTKNPD :: ZstrSignature ( int iStart ) const
{
	ZSTR zs;
	bool bPdSeen = false;
	for ( int i = iStart; i < size(); i++ )
	{
		const TKNPD & tknpd = self[i];
		switch ( tknpd.UiTkn() )
		{
			case DTKN_PD:
				zs += _T("p(");
				bPdSeen = true;
				break;
			case DTKN_COND:
				zs += _T("|");
				break;
			case DTKN_AND:
				zs += _T(",");
				break;
			case DTKN_EQ:
				zs += _T("=");
				break;
			case DTKN_DIST:
				zs += _T("d(");
				bPdSeen = true;
				break;
			case DTKN_QUAL:
				zs += _T(":");
				break;

			case DTKN_STRING:
			{
				// It's the name of a node
				SZC szcName = tknpd.Szc();
				assert( szcName );
				bool bLegal = MODEL::BSzLegal( szcName );
				if ( ! bLegal )
					zs += _T("\"") ;
				zs += szcName;
				if ( ! bLegal )
					zs += _T("\"") ;
				break;
			}
				
			default:
			{
				if ( tknpd.UiTkn() >= DTKN_STATE_BASE && tknpd.UiTkn() < DTKN_TOKEN_MIN )
					// It's a discrete state index
					zs.FormatAppend(_T("%d"), tknpd.UiTkn() - DTKN_STATE_BASE);
				else
					//  Huh?
					zs += _T("?ERR?");
				break;
			}
		}
	}
	if ( bPdSeen )
		zs += ")";
	return zs;
}

void MPPD :: Clone ( MPSYMTBL & mpsymtbl, const MPPD & mppd )
{
	for ( const_iterator it = mppd.begin(); it != mppd.end(); it++ )
	{
		//  Access the key and value from the old map
		const VTKNPD & vtknpdOld = (*it).first;
		const BNDIST * pbndistOld = (*it).second.Pobj();
		assert( pbndistOld );
		//  Construct the new key using the new symbol table
		VTKNPD vtknpd;
		vtknpd.Clone( mpsymtbl, vtknpdOld );
		//  Add to the current map
		self[vtknpd] = new BNDIST;
		//  Duplicate the old distribution
		self[vtknpd]->Clone( *pbndistOld );
	}
}


void MPPD :: Dump ()
{
	cout << "\n=======================================\nDump of distribution table map \n";
	UINT ipd = 0;
	for ( iterator it = begin(); it != end(); it++, ipd++ )
	{
		const VTKNPD & vtknpd = (*it).first;

		ZSTR zs = vtknpd.ZstrSignature();
		bool bCI = (*it).second->Edist() > BNDIST::ED_SPARSE;
		REFBNDIST & refbndist = (*it).second;

		cout << "\tPD ["
			 << ipd
			 << "]: "
			 << zs.Szc()
			 << (bCI ? "  (CI max/plus)" : "" )
			 << ", (refs="
			 << refbndist->CRef()
			 << ")"
			 << "\n" ;

		refbndist->Dump();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\symt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       symt.h
//
//--------------------------------------------------------------------------

//
//	SYMTMBN.H:  Symbol and symbol table handling declarations
//

#ifndef _SYMT_H_
#define _SYMT_H_

#include "zstrt.h"

////////////////////////////////////////////////////////////////////
//  template TMPSYMTBL: a symbol table
//
//		Names ares ZSREFs based upon strings interned into 
//		the internal string table using "intern()".  
//
//		Objects are smart pointers which destroy themselves
//		when assigned to or upon destruction of the symbol table.
//
//  Public functions:
//
//		add():		adds an association between an OBJ * and 
//					its name string
//		find():		returns an OBJ * or NULL
//		intern():	registers a string in the symbol table's 
//					string table.
////////////////////////////////////////////////////////////////////

class GOBJMBN;

template<class OBJ>
class TMPSYMTBL :
	public map<ZSREF, REFPOBJ<OBJ>, less<ZSREF> >
{
	typedef REFPOBJ<GOBJMBN> ROBJ;
	typedef map<ZSREF, REFPOBJ<OBJ>, less<ZSREF> > TSYMMAP;
  public:
	TMPSYMTBL () {};
	~ TMPSYMTBL () 
	{
		clear();
	};			

	void add ( SZC szc, OBJ * pobj )
	{
		ZSREF zsr = _stszstr.Zsref(szc);
		(*this)[zsr] = pobj;
		pobj->SetName(zsr);
	}

	OBJ * find ( SZC szc )
	{
		iterator it = TSYMMAP::find(_stszstr.Zsref(szc));

		return it == end() 
				? NULL 
				: (*it).second.Pobj();
	}

	ZSREF intern ( SZC szc )
	{
		return _stszstr.Zsref(szc);
	}	

	bool remove ( SZC szc )
	{
		iterator it = TSYMMAP::find(_stszstr.Zsref(szc));
		if ( it != end() )
		{
			erase(it);
			return true;
		}
		return false;
	}

  protected:
	//  The ensemble of strings
	STZSTR	_stszstr;
		
	HIDE_UNSAFE(TMPSYMTBL);
}; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\testinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       testinfo.cpp
//
//--------------------------------------------------------------------------

//
// testinfo.cpp: test file generation 
//

#include "testinfo.h"

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
/*
	Test inference and optionally Write an inference output file.  

	The format is the same as the program DXTEST, which	uses the older DXC32.DLL.  
	The format is:

	$COMPLETE						<< Indicates a complete pass without instantiations
	Alternator,0,0.99				<< One record for each state of each node, alphabetically,
	Alternator,1,0.01						with either the full or symbolic name (fSymName)
	Battery,0,0.9927
	Battery,1,0.0073
	Charge Delivered,0,0.95934
	Charge Delivered,1,0.0406603
	...								<<  Similar records for all other nodes
	...
	$INSTANTIATE,Alternator,0		<<  Indicates a node clamped to a state
	Alternator,0,1
	Alternator,1,0
	Battery,0,0.9927
	...
	...
	$PROBLEMINST,Engine Start,1		<<  Indicates a PD node instantiated

	$UTILITY,Node Name,3.14159		<<  Indicates an entropic utility record  (fUtil)
	...
	$RECOMEND,Node Name,-122.2222	<<  Indicates a troubleshooting recommendations record (fTSUtil)
	...

	This routine is used to compare both timings and numerical results with the older
	software.  The "fOutputFile" flag indicates whether an output file should be
	written.  The "fPassCountMask" indicates how many times the loop should be performed;
	this value is defaulted to 1.

	The logic works as follows:

		for each pass

			for 1 + each problem-defining (PD) node

				for each non-PD node

					if no non-PD node is instantiated
						print $COMPLETE
					else
						print $INSTANTIATE and data about instantiated node

					for each state of each non-PD node
						print the name, state and value (belief)
						print utilities if required
						print recommendations if required
					end for each state of each non-PD node

					advance to the next state of the next node
					unclamp previous node/sate
					clamp (next) node to next state

				end for eacn non-PD node

				advance to the next state of the next PD node				

			end for each problem-defining node

		end for each pass

	Note that each pass is set up so that all the uninstantiated values are printed first.

*/
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

inline
SZC TESTINFO :: SzcNdName ( GNODEMBN * pgnd )
{
	return FCtl() & fSymName
		? pgnd->ZsrefName().Szc()
		: pgnd->ZsFullName().Szc();
}

inline
SZC TESTINFO :: SzcNdName ( ZSREF zsSymName )
{
	if ( FCtl() & fSymName )
		return zsSymName.Szc();

	GNODEMBN * pgnd;
	DynCastThrow( Mbnet().PgobjFind( zsSymName ), pgnd );
	return SzcNdName( pgnd );
}


void TESTINFO :: GetUtilities ()
{
	//  Compute the utilities
	MbUtil()();

	if ( ! Postream() )
		return;

	const VZSREF & vzsrNodes = MbUtil().VzsrefNodes();
	const VLREAL & vlrUtil = MbUtil().VlrValues();

	for ( int ind = 0; ind < vzsrNodes.size(); ind++ )
	{
		SZC szcName = SzcNdName( vzsrNodes[ind] );
		Ostream() 
			<< "$UTILITY,"
			<< szcName
			<< ","
			<< vlrUtil[ind]
			<< "\n";	
		_clOut++;
	}
}

void TESTINFO :: GetTSUtilities ()
{
	if ( ! MbRecom().BReady() )
		return;		// Invalid state for recommendations

	//  Compute the utilities
	MbRecom()();

	if ( ! Postream() )
		return;

	const VZSREF & vzsrNodes = MbRecom().VzsrefNodes();
	const VLREAL & vlrUtil = MbRecom().VlrValues();

	for ( int ind = 0; ind < vzsrNodes.size(); ind++ )
	{
		SZC szcName = SzcNdName( vzsrNodes[ind] );
		Ostream() 
			<< "$RECOMMEND,"
			<< szcName
			<< ","
			<< vlrUtil[ind]
			<< "\n";	
		_clOut++;
	}
}

//  Get the beliefs for the nodes in the given map; write data records if stream given
void TESTINFO :: GetBeliefs ()
{
	MDVCPD mdvBel;

	//  Prepare to check for impossible states of information
	GOBJMBN_CLIQSET * pCliqueSet = NULL;
	if ( BFlag( fImpossible ) )
		pCliqueSet = dynamic_cast<GOBJMBN_CLIQSET *>(&InferEng());
	//   See if this state of information is impossible
	bool bIsImposs = pCliqueSet != NULL 
					&& pCliqueSet->BImpossible();

	for ( MPSTRPND::iterator mpit = Mpstrpnd().begin();
		  mpit != Mpstrpnd().end();
		  mpit++ )
	{
		GNODEMBND * pgndd = (*mpit).second;
		int cState = pgndd->CState();

		if ( ! bIsImposs )
		{
			InferEng().GetBelief( pgndd, mdvBel );
			assert( cState == mdvBel.size() );
		}

		if ( Postream() )
		{
			SZC szcName = SzcNdName( pgndd );
			for ( int ist = 0; ist < cState; ist++ )
			{
				Ostream() << szcName << "," << ist << ",";
				if ( bIsImposs )
					Ostream() << _rImposs;
				else
					Ostream() << mdvBel[ist];
				Ostream() << "\n";
				_clOut++;
			}
		}
	}

	if ( BFlag( fUtil ) )
	{
		GetUtilities();
	}
	else 
	if ( BFlag( fTSUtil ) )
	{
		GetTSUtilities();
	}

#ifdef _DEBUG
	if ( Postream() )
		Ostream().flush();
#endif
}


void TESTINFO :: InferTest ()
{
	bool bOutput = Postream() != NULL;
	int cPass = FCtl() & fPassCountMask;

	//  Is network expanded?
	bool bExpanded = Mbnet().BFlag( EIBF_Expanded );
	PROPMGR propmgr( Mbnet() );	//  Property manager
	int iLblProblem = propmgr.ILblToUser( ESTDLBL_problem );		
	ZSREF zsrPropTypeLabel = propmgr.ZsrPropType( ESTDP_label );

	MPSTRPND & mpstrpnd = Mpstrpnd();	//  Map of strings to node ptrs
	MPSTRPND mpstrpndProblem;			//  Map of PD nodes

	for ( int inode = 0; inode < Mbnet().CNameMax(); inode++ )
	{
		GOBJMBN * pgobj = Mbnet().PgobjFindByIndex( inode );
		if ( ! pgobj )
			continue;
		GNODEMBND * pgndd = dynamic_cast<GNODEMBND *>(pgobj);
		if ( ! pgndd )
			continue;

		SZC szcName = FCtl() & fSymName
					? pgndd->ZsrefName().Szc()
					: pgndd->ZsFullName().Szc();
		//  See if this is a problem-defining node
		PROPMBN * propLbl = pgndd->LtProp().PFind( zsrPropTypeLabel );
		if ( propLbl && propLbl->Real() == iLblProblem )
		{	
			//  Put PD nodes into separate map
			mpstrpndProblem[szcName] = pgndd;
		}
		//  If the network is expanded, use only regular nodes
		if ( (! bExpanded) || ! pgndd->BFlag( EIBF_Expansion ) )
		{
			mpstrpnd[szcName] = pgndd;
		}
	}

	for ( int iPass = 0; iPass < cPass; iPass++ )
	{
		int iProb = -1;
		int iProbState = 0;
		int cProbState = 0;
		GNODEMBND * pgnddProblem = NULL;
		MPSTRPND::iterator mpitPd    = mpstrpndProblem.begin();
		MPSTRPND::iterator mpitPdEnd = mpstrpndProblem.end();

		for (;;)
		{
			//  After 1st cycle, advance the problem state of the PD node
			if ( pgnddProblem )
			{
				ZSTR zsNamePD;
				CLAMP clampProblemState(true, iProbState, true);
				InferEng().EnterEvidence( pgnddProblem, clampProblemState );
				if ( FCtl() & fSymName )
					zsNamePD = pgnddProblem->ZsrefName();
				else
					zsNamePD = pgnddProblem->ZsFullName();
				if ( bOutput )
				{
					Ostream()  << "$PROBLEMINST,"
							<< zsNamePD.Szc()
							<< ","
							<< iProbState
							<< "\n";
					_clOut++;
				}
			}
			
			MPSTRPND::iterator mpit  = mpstrpnd.begin();
			MPSTRPND::iterator mpend = mpstrpnd.end();
			int cpnd = mpstrpnd.size();
			for ( int inid = -1; inid < cpnd; inid++ )
			{
				GNODEMBND * pgndd = NULL;
				ZSTR zsName;
				int cst = 0;  //  Cause inner loop to run once on first cycle
				if ( inid >= 0 )
				{
					pgndd = (*mpit++).second;
					if ( FCtl() & fSymName )
						zsName = pgndd->ZsrefName();
					else
						zsName = pgndd->ZsFullName();
					cst = pgndd->CState();
				}
					
				for ( int ist = -1; ist < cst; ist++ )
				{
					if ( ist < 0 )
					{
						//  The first time through, print all the beliefs
						//		with no instantiations; do nothing on later cycles.
						if ( pgndd != NULL )
							continue;
						if ( bOutput )
						{
							Ostream() << "$COMPLETE\n";
							_clOut++;
						}
					}
					else
					{
						CLAMP clampState(true, ist, true);
						InferEng().EnterEvidence( pgndd, clampState );
						if ( bOutput )
						{
							Ostream() << "$INSTANTIATE,"
									<< zsName.Szc()
									<< ","
									<< ist
									<< "\n";
							_clOut++;
						}
					}
					GetBeliefs();
				}
				
				if ( pgndd )
				{
					//  Clear the instantitation of this node.
					InferEng().EnterEvidence( pgndd, CLAMP() );
				}
			}
			//  If this is the last abnormal state for this problem node,
			//		advance to the next node.
			if ( ++iProbState >= cProbState )
			{
				//  Unclamp the last problem node, if any
				if ( pgnddProblem )
					InferEng().EnterEvidence( pgnddProblem, CLAMP() );
				//  Move on to the next PD node
				if ( mpitPd == mpitPdEnd )
					break;
				pgnddProblem = (*mpitPd++).second;
				cProbState = pgnddProblem->CState();
				//  Reset to 1st problem state
				iProbState = 1;
			}
		}
	}
}


	//  Return a displayable string of the current options settings
ZSTR TESTINFO :: ZsOptions ( ULONG fFlag )
{
	static
	struct 
	{
		ULONG _f;		//  Bit flag
		SZC _szc;		//  Option name
	}
	vOptMap [] =
	{
		{ fVerbose,			"verbose"	},
		{ fCliquing,		"clique"	},
		{ fInference,		"infer"		},
		{ fMulti,			"multipass"	},
		{ fOutputFile,		"outfile"	},
		{ fShowTime,		"times"		},
		{ fSaveDsc,			"dscout"	},
		{ fPause,			"pause"		},
		{ fSymName,			"symname"	},
		{ fExpand,			"expand"	},
		{ fClone,			"clone"		},
		{ fUtil,			"utilities"	},
		{ fReg,				"registry"	},
		{ fTSUtil,			"recommend"	},
		{ fInferStats,		"inferstats"},
		{ fImpossible,		"impossible"},
		{ 0,				""			}
	};

	ZSTR zs;
	ULONG cpass = fFlag & fPassCountMask;
	fFlag &= ~ fPassCountMask;
	for ( int i = 0; vOptMap[i]._f != 0; i++ )
	{
		if ( fFlag & vOptMap[i]._f )
		{
			if ( zs.length() > 0 )
				zs += ',';
			zs += vOptMap[i]._szc;
		}
	}
	if ( fFlag & fMulti )
	{
		if ( zs.length() > 0 )
			zs += ",";
		zs.FormatAppend("passes=%d", cpass);
	}
	return zs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\testinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       testinfo.h
//
//--------------------------------------------------------------------------

//
//	testinfo.h: test file generation 
//
#ifndef _TESTINFO_H_
#define _TESTINFO_H_


#include "cliqset.h"			// Exact clique-based inference
#include "clique.h"				// Clique structure details
#include "parmio.h"				// Text Parameter streaming I/O
#include "utility.h"			// Entropic utility
#include "recomend.h"			// Troubleshooting recommendations

typedef unsigned long ULONG;

//
//	Options flags; first 16 bits are the pass count; i.e., number of times to run
//		the inference testing code for timing purposes.
//
const ULONG fPassCountMask  = 0x0FFF;
const ULONG fDistributions	= 1<<15;
const ULONG fImpossible		= 1<<16;
const ULONG fVerbose		= 1<<17;
const ULONG fCliquing		= 1<<18;
const ULONG fInference		= 1<<19;
const ULONG fMulti			= 1<<20;
const ULONG fOutputFile		= 1<<21;
const ULONG fShowTime		= 1<<22;
const ULONG fSaveDsc		= 1<<23;
const ULONG fPause			= 1<<24;
const ULONG fSymName		= 1<<25;
const ULONG fExpand			= 1<<26;
const ULONG fClone			= 1<<27;
const ULONG fUtil			= 1<<28;
const ULONG fReg			= 1<<29;
const ULONG fTSUtil			= 1<<30;
const ULONG fInferStats		= 1<<31;

//  Declare a map from strings to pointers to nodes
typedef map<ZSTR, GNODEMBND *, less<ZSTR> > MPSTRPND;

class TESTINFO
{
  public:
	TESTINFO ( ULONG fCtl, MBNETDSC & mbnet, ostream * pos = NULL )
		:_fCtl(fCtl),
		_mbnet(mbnet),
		_pos(pos),
		_pInferEng(NULL),
		_pmbUtil(NULL),
		_pmbRecom(NULL),
		_rImposs(-1.0),
		_clOut(0)
	{
		_pInferEng = mbnet.PInferEngine();
		assert( _pInferEng );
		if ( fCtl & fUtil )
		{
			_pmbUtil = new MBNET_ENTROPIC_UTILITY( *_pInferEng );
		}
		if ( fCtl & fTSUtil )
		{
			GOBJMBN_CLIQSET * pCliqueSet;
			DynCastThrow(_pInferEng, pCliqueSet);
			_pmbRecom = new MBNET_RECOMMENDER( *pCliqueSet );
		}
	}

	~ TESTINFO ()
	{
		delete _pmbUtil;
		delete _pmbRecom;
	}

	void InferTest ();

	MBNET_ENTROPIC_UTILITY & MbUtil () 
	{
		assert( _pmbUtil );
		return *_pmbUtil;
	}
	MBNET_RECOMMENDER & MbRecom ()
	{
		assert( _pmbRecom );
		return *_pmbRecom;
	}
	MBNETDSC & Mbnet ()
		{ return _mbnet; }
	GOBJMBN_INFER_ENGINE & InferEng ()
	{
		assert( _pInferEng );
		return *_pInferEng;
	}
	ostream * Postream ()
		{ return _pos; }
	ostream & Ostream ()
	{
		assert( _pos );
		return *_pos;
	}
	MPSTRPND & Mpstrpnd ()
		{ return _mpstrpnd; }
	ULONG FCtl ()
		{ return _fCtl; }

	void GetUtilities ();
	void GetTSUtilities ();
	void GetBeliefs ();

	SZC SzcNdName ( GNODEMBN * pgnd );
	SZC SzcNdName ( ZSREF zsSymName );

	bool BFlag ( ULONG fFlag )
	{
		return (FCtl() & fFlag) > 0;
	}

	//  Return a displayable string of the current options settings
	static ZSTR ZsOptions ( ULONG fFlag );

  public:

	ULONG _fCtl;					//  Control flags
	MBNETDSC & _mbnet;				//  The model to test
	MPSTRPND _mpstrpnd;				//  The set of nodes to use
	ostream * _pos;					//  The output stream or NULL
	REAL _rImposs;					//  The value to report for impossible probs
	int _clOut;						//  Output line counter
  protected:
	GOBJMBN_INFER_ENGINE * _pInferEng;
	MBNET_ENTROPIC_UTILITY * _pmbUtil;
	MBNET_RECOMMENDER * _pmbRecom;
};


#endif // _TESTINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\utility.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       utility.h
//
//--------------------------------------------------------------------------

//
//	utility.h:  Algorithms for computation of utility
//	
#ifndef _UTILITY_H_
#define _UTILITY_H_

#include <deque>

#include "gmobj.h"

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//
//  class MBNET_ENTROPIC_UTILITY:
//
//		Ranking for entropic utility.  Uses function object
//		semantics.  Construct using an inference engine, since
//		utility calculations are computed w.r.t. a set of evidence.
//
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
struct UTILWORK
{
	GNODEMBND * _pgndd;			//  Pointer to node
	int _iLbl;					//  Label of node
	MDVCPD _dd;					//  Unconditional distribution given evidence
	REAL _rUtil;				//  Utility
	int _iClamp;				//  index of clamped state or -1
	bool operator < ( const UTILWORK & ut ) const
		{ return _rUtil < ut._rUtil ; }
};

typedef deque<UTILWORK> DQUTILWORK;

class MBNET_ENTROPIC_UTILITY : public MBNET_NODE_RANKER
{
  public:
	MBNET_ENTROPIC_UTILITY ( GOBJMBN_INFER_ENGINE & inferEng );
	virtual ~ MBNET_ENTROPIC_UTILITY () {}

	INT EType () const
		{ return EBNO_RANKER_ENTROPIC_UTIL; }

	//  The ranking function
	virtual void operator () ();

  protected:
	//  The inference engine we're operating against
	GOBJMBN_INFER_ENGINE & _inferEng;
	//  Property handler
	PROPMGR _propMgr;
	//  Queue of work items
	DQUTILWORK _dquwrk;
	//  Indicies of standard labels in this network
	int _iLblHypo;
	int _iLblInfo;
	int _iLblProblem;
	//  Counts of nodes by label
	int _cHypo;
	int _cInfo;

  protected:
	void BuildWorkItems ();
	void ComputeWorkItems ();

	REAL RComputeHypoGivenInfo ( UTILWORK & uwHypo, UTILWORK & uwInfo );
};

#endif	// _UTILITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\symtmbn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       symtmbn.h
//
//--------------------------------------------------------------------------

//
//	SYMTMBN.H:  Symbol table for belief networks
//

#ifndef _SYMTMBN_H_
#define _SYMTMBN_H_

#include "basics.h"
#include "algos.h"
#include "symt.h"
#include "gelem.h"
#include "bndist.h"

//  Forward declaration of MBNET
class MBNET;
class MODEL;

/*
	A word about BIT FLAG VECTORS:

		Each GOBJMBN (abstract belief network object) has a bit vector.
		These values are typically accesssed by name, and the names
		are interned in the symbol table of the outer network.  Therefore,
		the symbol table class can return the bit flag index given the name,
		and the node can return the value given the bit flag index.

		Since these values are completely scoped by the network, they
		may differ (both in existence and index) from network to network.
		However, once they are declared they do not change, so caching is
		supported.
 */

//  Base class for a vector of bit flags and its index variable type
typedef int IBFLAG;						//  Index into a bit flag vector
class VFLAGS : public _Bvector			//  A vector of bit flags
{
  public:
	bool BFlag ( IBFLAG ibf ) const
	{
		return size() > ibf
			&& self[ibf];
	}
	//	Set a bit flag; return the previous value
	bool BSetBFlag ( IBFLAG ibf, bool bValue = true )
	{
		bool bOldValue = false;
		if ( size() <= ibf )
			resize(ibf+1);
		else
			bOldValue = self[ibf];
		self[ibf] = bValue;
		return bOldValue;
	}
};

////////////////////////////////////////////////////////////////////
//	class GOBJMBN:  Abstract base class for belief network objects.
//
//		Generic "named thing that lives in a belief network" object.
//		All such objects are graph nodes and can be linked with arcs.
////////////////////////////////////////////////////////////////////
class GOBJMBN : public GNODE
{
	friend class TMPSYMTBL<GOBJMBN>;

  public:
	// Return the immutable object type
	virtual INT EType () const
		{ return EBNO_NONE ; }

	enum EBNOBJ
	{
		EBNO_NONE = GELEM::EGELM_NODE,	// No value
		EBNO_NODE,						// A probabilistic node
		EBNO_PROP_TYPE,					// A property type
		EBNO_MBNET_MODIFIER,			// A general network modifier
		EBNO_MBNET_EXPANDER,			// A network CI expander
		EBNO_INFER_ENGINE,				// A general inference engine
		EBNO_CLIQUE,					// A clique
		EBNO_CLIQUE_SET,				// A set of clique trees
		EBNO_NODE_RANKER,				// A ranking/ordering mechanism
		EBNO_RANKER_ENTROPIC_UTIL,		// A ranking by entropic utility
		EBNO_RANKER_RECOMMENDATIONS,	// A ranking by fixplan recommendations
		EBNO_VARIABLE_DOMAIN,			// A user-defined discretization or domain
		EBNO_USER,						// A user-defined type
		EBNO_MAX
	};

	GOBJMBN () {}
	virtual ~ GOBJMBN() = 0;

	//  Clone contents into a new object relative to another belief network;
	//		return NULL if operation not supported.
	virtual GOBJMBN * CloneNew ( MODEL & modelSelf,
								 MODEL & modelNew,
								 GOBJMBN * pgobjNew = NULL );

	const ZSREF & ZsrefName () const
		{ return _zsrName; }

	//  Accessors for the array of flag bits
	bool BFlag ( IBFLAG ibf ) const	
		{ return _vFlags.BFlag( ibf );	}
	bool BSetBFlag ( IBFLAG ibf, bool bValue = true )
		{ return _vFlags.BSetBFlag( ibf, bValue );	}

  protected:
	//  Only subclasses should be able to do this.
	void SetName ( ZSREF zsr )
		{ _zsrName = zsr; }

  protected:
	ZSREF _zsrName;						//  Symbolic (permanent) name
	VFLAGS _vFlags;						//  Bit vector of flags

	HIDE_UNSAFE(GOBJMBN);
};


////////////////////////////////////////////////////////////////////
//	class MPZSRBIT: a map between a name and a bit index in a
//		bool/bit array.
////////////////////////////////////////////////////////////////////
class MPZSRBIT : public VZSREF
{
  public:
	MPZSRBIT ()	{}
	~ MPZSRBIT() {}
	//  Return the index of a name or -1 if not found
	IBFLAG IFind ( ZSREF zsr )
	{
		return ifind( self, zsr );
	}
	//  Return the index of a name, adding it if necessary
	IBFLAG IAdd ( ZSREF zsr )
	{
		IBFLAG i = ifind( self, zsr );
		if ( i < 0 )
		{
			i = size();
			push_back(zsr);
		}
		return i;
	}
};

////////////////////////////////////////////////////////////////////
//	class MPSYMTBL:
//		An STL "map" which is used as a symbol table.
//		It also supports dynamically declared named bit flags,
//		which are supported by classes GOBJMBN and MBNET.
////////////////////////////////////////////////////////////////////
class MPSYMTBL : public TMPSYMTBL<GOBJMBN>
{
  public:
	MPSYMTBL () {}
	~ MPSYMTBL () {}

	//  Support for dynamically assigned bit flags
	//	  Create a bit flag index for a name
	IBFLAG IAddBitFlag ( SZC szcName )
	{	
		return _mpzsrbit.IAdd( intern( szcName ) );
	}
	//	  Return the bit flag index of name
	IBFLAG IFindBitFlag ( SZC szcName )
	{
		return _mpzsrbit.IFind( intern( szcName ) );
	}
	//	  Test the bit flag of a node
	bool BFlag ( const GOBJMBN & gobj, SZC szcName )
	{
		IBFLAG iBit = IFindBitFlag( szcName );
		if ( iBit < 0 )
			return false;
		return gobj.BFlag(iBit);
	}
	//	  Re/set the bit flag of a node; returns old setting
	bool BSetBFlag ( GOBJMBN & gobj, SZC szcName, bool bValue = true )
	{
		IBFLAG iBit = IAddBitFlag( szcName );
		assert( iBit >= 0 );
		return gobj.BSetBFlag( iBit, bValue );
	}

	void CloneVzsref ( const MPSYMTBL & mpsymtbl,
					   const VZSREF & vzsrSource,
					   VZSREF & vzsrTarget );

	//  Clone this table from another
	void Clone ( const MPSYMTBL & mpsymtbl );

  protected:
	MPZSRBIT _mpzsrbit;
};


/*
	Probability distributions.

	PDs are defined similarly to their notation.  Tokens in the notation
	are converted to descriptor tokens, and the PD data is stored in a
	map structure cataloged by the string of tokens.   For example:
		
		p(X|Y,Z)

	is stored under a key which is a list of tokens:

		token[0]	token representing 'p'
		token[1]	token referencing interned symbolic name of node X
		token[2]	token representing '|'  (conditioning bar)
		token[3]	token referencing interned symbolic name of node Y
		token[4]	token representing ','  (and)
		token[5]	token referencing interned symbolic name of node Z

	Special values can represent states, so that PDs such as

		p(X=x|Y=y)

	can be represented. Since 'x' and 'y' (lower case) are state indicies,
	they are represented as integers.
 */

//  Enumeration for token types.  Values from DTKN_STRING_MIN to
//		DTNK_STATE_BASE are string pointers (equivalent to ZSREFs)
//	
enum DISTTOKEN
{
	DTKN_EMPTY = 0,
	DTKN_STRING,								//  String pointers
	DTKN_BASE = DTKN_STRING+1,					//  Base value for tokens
	DTKN_STATE_BASE = DTKN_BASE,				//  First state value (0)
	DTKN_TOKEN_MIN = DTKN_STATE_BASE + 0x20000,	//	Allow for >100000 discrete states
	DTKN_PD = DTKN_TOKEN_MIN,					//  'p'  as in p(X|Y)
	DTKN_COND,									//  '|', conditioning bar
	DTKN_AND,									//  ','  'and' symbol
	DTKN_EQ, 									//  '='  'equals' symbol
	DTKN_QUAL,									//  token used as domain qualification specifier
	DTKN_DIST,									//  'distribution' token, followed by name token
	DTKN_MAX									//  First illegal value
};

//  Probability distribution descriptor token
class TKNPD
{
  public:
  public:
	//  Constructors
	TKNPD();						// Initialization
	TKNPD( const TKNPD & tp );		// Copy constructor
	TKNPD( const ZSREF & zsr );		// From a string ref
	TKNPD( DISTTOKEN dtkn );		// From an explicit token
	~TKNPD();
	//	Assignment operators: similar to constructors
	TKNPD & operator = ( const TKNPD & tp );
	TKNPD & operator = ( const ZSREF & zsr );
	TKNPD & operator = ( DISTTOKEN dtkn );
	//	Return true if token represents a string
	bool BStr () const
		{ return _uitkn == DTKN_STRING; }
	bool BState () const
		{ return _uitkn >= DTKN_STATE_BASE && _uitkn < DTKN_TOKEN_MIN; }
	bool BToken () const
		{ return _uitkn >= DTKN_TOKEN_MIN && _uitkn < DTKN_MAX; }

	//  Ordering for vector and map classes
	bool operator < ( const TKNPD & tp ) const;
	bool operator == ( const TKNPD & tp ) const;
	bool operator > ( const TKNPD & tp ) const;
	bool operator != ( const TKNPD & tp ) const;

	//	Return the token as an integer
	UINT UiTkn () const		{ return _uitkn; }
	//  Return the token as a DISTTOKEN
	DISTTOKEN Dtkn () const { return (DISTTOKEN) _uitkn; }
	//  Return the token as a discrete state index
	IST Ist () const		
	{ 
		return BState() ? _uitkn - DTKN_STATE_BASE 
					    : -1;
	}

	//  Return the string as an SZC; NULL if not a string
	SZC Szc () const
	{
		return BStr()
			 ? Pzst()->Szc()
			 : NULL;
	}
	const ZSTRT * Pzst () const
		{ return _pzst; }

  protected:
	UINT _uitkn;			//  Simple unsigned integer token
	ZSTRT * _pzst;			//  String pointer (optional)

	void Deref ();
	void Ref ( const ZSREF & zsr );
	void Ref ( const TKNPD & tknpd );
	void Ref ( DISTTOKEN dtkn );
};


// Define VTKNPD
class VTKNPD : public vector<TKNPD>
{
  public:
	//  Generate a string containing the original probability distribution
	//	descriptor (e.g., "p(X|Y,Z)").
	ZSTR ZstrSignature ( int iStart = 0 ) const;

	void Clone ( MPSYMTBL & mpsymtbl, const VTKNPD & vtknpd );

	//  Provide "operator <" for map<> template.	
	bool operator < ( const VTKNPD & vtknpd ) const
	{
		int cmin = _cpp_min( size(), vtknpd.size() );
		for ( int i = 0 ; i < cmin ; i++ )
		{
			if ( self[i] < vtknpd[i] )
				return true;
			if ( vtknpd[i] < self[i])
				return false;
		}
		return size() < vtknpd.size();
	}
};

typedef REFCWRAP<BNDIST> REFBNDIST;
////////////////////////////////////////////////////////////////////
//	class MPPD:  A map associating probability distributions with
//				their descriptors (token arrays).
////////////////////////////////////////////////////////////////////
class MPPD : public map<VTKNPD, REFBNDIST>
{
  public:
	MPPD () {}
	~ MPPD ()
	{
	#if defined(DUMP)
		Dump();
	#endif
	}

	void Clone ( MPSYMTBL & mpsymtbl, const MPPD & mppd );

  private:
	void Dump ();
};


////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//	Inline member functions
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
inline
TKNPD::TKNPD()
	: _uitkn(DTKN_EMPTY),
	_pzst(NULL)
{
}

inline
TKNPD::TKNPD( const TKNPD & tp )
	: _uitkn(DTKN_EMPTY),
	_pzst(NULL)
{
	Ref(tp);
}

inline
TKNPD::TKNPD( const ZSREF & zsr )
	: _uitkn(DTKN_EMPTY),
	_pzst(NULL)
{
	Ref(zsr);
}

inline
TKNPD::TKNPD( DISTTOKEN dtkn )
	: _uitkn(DTKN_EMPTY),
	_pzst(NULL)
{
	Ref(dtkn);
}

inline
TKNPD::~TKNPD()
{
	Deref();
}

inline
void TKNPD::Deref ()
{
	if ( BStr() )
	{
		_pzst->IncRef(-1);
		_pzst = NULL;
	}
	_uitkn = DTKN_EMPTY;
}

inline
void TKNPD::Ref ( const ZSREF & zsr )
{
	Deref();
	zsr.IncRef();
	_pzst = const_cast<ZSTRT *> (zsr.Pzst());
	_uitkn = DTKN_STRING;
}

inline
void TKNPD::Ref ( const TKNPD & tknpd )
{
	Deref();
	if ( tknpd.BStr() )
	{
		_pzst = tknpd._pzst;
		_pzst->IncRef();
	}
	_uitkn = tknpd._uitkn;
}

inline
void TKNPD::Ref ( DISTTOKEN dtkn )
{
	Deref();
	_uitkn = dtkn;
}

inline
TKNPD & TKNPD::operator = ( const TKNPD & tp )
{
	Ref(tp);
	return self;
}

inline
TKNPD & TKNPD::operator = ( const ZSREF & zsr )
{
	Ref(zsr);
	return self;
}

inline
TKNPD & TKNPD::operator = ( DISTTOKEN dtkn )
{
	Ref(dtkn);
	return self;
}

inline
bool TKNPD::operator < ( const TKNPD & tp ) const
{
	if ( _uitkn < tp._uitkn )
		return true;
	if ( _uitkn > tp._uitkn )
		return false;
	return _pzst < tp._pzst;
}

inline
bool TKNPD::operator > ( const TKNPD & tp ) const
{
	if ( _uitkn > tp._uitkn )
		return true;
	if ( _uitkn < tp._uitkn )
		return false;
	return _pzst > tp._pzst;
}

inline
bool TKNPD::operator == ( const TKNPD & tp ) const
{
	return _uitkn == tp._uitkn && _pzst == tp._pzst;
}

inline
bool TKNPD::operator != ( const TKNPD & tp ) const
{
	return _uitkn != tp._uitkn && _pzst != tp._pzst;	
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\zstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       zstr.h
//
//--------------------------------------------------------------------------

//
//	ZSTR.H:	String management
//

#ifndef _ZSTR_H_
#define _ZSTR_H_

#include <string>		//  STL string class
#include "basics.h"

////////////////////////////////////////////////////////////////////
//	class ZSTR
//
//		simple string providing normally expected function
////////////////////////////////////////////////////////////////////
class ZSTR : public string
{
  public:
	ZSTR ( SZC szc = NULL )
		: string(szc == NULL ? "" : szc)
		{}
	SZC Szc() const
		{ return c_str(); }
	inline operator SZC () const
		{ return Szc(); }
	void Reset ()
		{ resize(0); }
	ZSTR & operator = ( SZC szc )
	{ 
		Reset();
		string::operator=(szc);
		return *this;
	}
	void FormatAppend ( SZC szcFmt, ... );
	void Format ( SZC szcFmt, ... );
	void Vsprintf ( SZC szcFmt, va_list valist );
};

DEFINEV(ZSTR);
DEFINEV(VZSTR);


// end of ZSTR.H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\zstrt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       zstrt.cpp
//
//--------------------------------------------------------------------------

//
//	ZSTRT.CPP
//

#include <iostream>
#include <fstream>
#include <stdarg.h>
#include <stdio.h>
#include "zstrt.h"
	

ZSTRT ZSREF::Zsempty;


void STZSTR :: Dump () const
{
	STZSTR_BASE::const_iterator mpzi = IterBegin();
	STZSTR_BASE::const_iterator mpziend = IterEnd();
	
	for ( UINT i = 0; mpzi != mpziend ; mpzi++, i++ )
	{
		const ZSTRT & zsr = *mpzi;
		cout << "STZSTR #"
			 << i
			 << ": ";
		(*mpzi).Dump();
		cout << "\n";
	}
}

void ZSTRT :: Dump () const
{	
	cout << "("
		 << CRef()
		 << ") \""
		 << Szc()
		 << "\"";
}

//
//	Clone the contents of another string table into this one
//
void STZSTR :: Clone ( const STZSTR & stzstr )
{
	assert( & stzstr != this );	//  Guarantee source != target

	STZSTR_BASE::const_iterator mpzi = stzstr.IterBegin();
	STZSTR_BASE::const_iterator mpziend = stzstr.IterEnd();
	
	for ( UINT i = 0; mpzi != mpziend ; mpzi++, i++ )
	{
		const ZSTRT & zsr = *mpzi;
		Zsref( zsr.Szc() );
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\zstr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       zstr.cpp
//
//--------------------------------------------------------------------------

//
//	ZSTR.CPP
//

#include <iostream>
#include <fstream>
#include <stdarg.h>
#include <stdio.h>
#include "zstr.h"

void ZSTR :: Vsprintf ( SZC szcFmt, va_list valist )
{
	//  Attempt to "sprintf" the buffer. If it fails, reallocate
	//   a larger buffer and try again.	
	UINT cbMaxNew = 0;
	char * psz = NULL;
	INT cbOut;
	do {
		delete psz;
		if ( cbMaxNew == 0 )
			cbMaxNew = 256;
		else
			cbMaxNew += cbMaxNew / 2;
		psz = new char[cbMaxNew];
	} while (  (cbOut = ::_vsnprintf( psz, cbMaxNew-1, szcFmt, valist )) < 0 ) ; 
	psz[cbOut] = 0;
	self = psz;
	delete psz;
}

void ZSTR :: Format ( SZC szcFmt, ... )
{
	va_list	valist;
	va_start( valist, szcFmt );
	
	Vsprintf( szcFmt, valist ) ;
	
	va_end( valist );
}

void ZSTR :: FormatAppend ( SZC szcFmt, ... ) 
{
	ZSTR strTemp ;
	va_list	valist;
	va_start( valist, szcFmt );
	
	strTemp.Vsprintf( szcFmt, valist ) ;
	va_end( valist );
	
	self += strTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\vrmatrx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       vrmatrx.cpp
//
//--------------------------------------------------------------------------

#include <float.h>
#include <math.h>
#include <bitset>
#include "vrmatrx.h"

VRMATRIX VRMATRIX :: VrmatrixProject ( const VIMD & vimdRowColumnRetain ) const
{
	// Returns the projection of this matrix defined by the rows and columns
	// in vimdRowColumnRetain.

#define BSETSIZE 100
	
	size_t cDimMax = _cpp_max(CCol(),CRow());
	assert( cDimMax < BSETSIZE );

	// Build a bitset that keeps track of the rows and columns we're retaining

	bitset<BSETSIZE> bset;

	for ( int iRowCol = 0; iRowCol < vimdRowColumnRetain.size(); ++iRowCol)
	{
		bset[ vimdRowColumnRetain[iRowCol] ] = true;
	}

	int cCol = 0;
	int	cRow = 0;

	for ( iRowCol = 0; iRowCol < cDimMax; iRowCol++ )
	{	
		bool bKeep = bset[iRowCol];

		if ( cDimMax >= CCol() && bKeep )
			cCol++;
		if ( cDimMax >= CRow() && bKeep ) 
			cRow++;
	}

	// Make sure that a least one row and column are being retained
	if ( cCol == 0 || cRow == 0 )
		throw GMException(EC_MDVECT_MISUSE,"null matrix projection");

	// Construct the projection matrix
	VRMATRIX vrmatrix(cRow,cCol);
	
	int iRowProjection = 0;
	
	// Step through every element in this matrix, and insert into the
	// projection if the element is to be retained

	for ( int iRow = 0; iRow < CRow(); ++iRow )
	{
		if ( ! bset[iRow] )
		{
			// This row is excluded from the projection
			continue;
		}

		int iColProjection = 0;

		// This row is included... insert the members
		// of the row for every column in the projection

		for (int iCol = 0; iCol < CCol(); ++iCol )
		{
			if ( bset[iCol] ) 
			{
				vrmatrix(iRowProjection, iColProjection) = self(iRow,iCol);
				
				++iColProjection;
			}
		}

		++iRowProjection;
	}
	return vrmatrix;
}

VRMATRIXSQ VRMATRIXSQ :: VrmatrixProject ( const VIMD & vimdRowColumnRetain ) const
{
	// Returns the projection of this matrix defined by the rows and columns
	// in vimdRowColumnRetain.

#define BSETSIZE 100
	
	size_t cDimMax = _cpp_max(CCol(),CRow());
	assert( cDimMax < BSETSIZE );

	// Build a bitset that keeps track of the rows and columns we're retaining
	bitset<BSETSIZE> bset;

	for ( int iRowCol = 0; iRowCol < vimdRowColumnRetain.size(); ++iRowCol)
	{
		bset[ vimdRowColumnRetain[iRowCol] ] = true;
	}

	int cCol = 0;
	int	cRow = 0;

	for ( iRowCol = 0; iRowCol < cDimMax; iRowCol++ )
	{	
		bool bKeep = bset[iRowCol];

		if ( cDimMax >= CCol() && bKeep )
			cCol++;
		if ( cDimMax >= CRow() && bKeep ) 
			cRow++;
	}

	VRMATRIXSQ vrmatrix;

	// Make sure that a least one row and column are being retained
	if ( cCol > 0 && cRow > 0 )
	{
		// Initialize the projection matrix
		vrmatrix.Init(cRow,cCol);
		
		int iRowProjection = 0;
		
		// Step through every element in this matrix, and insert into the
		// projection if the element is to be retained

		for ( int iRow = 0; iRow < CRow(); ++iRow )
		{
			if ( ! bset[iRow] )
			{
				// This row is excluded from the projection
				continue;
			}

			int iColProjection = 0;

			// This row is included... insert the members
			// of the row for every column in the projection

			for (int iCol = 0; iCol < CCol(); ++iCol )
			{
				if ( bset[iCol] ) 
				{
					vrmatrix(iRowProjection, iColProjection) = self(iRow,iCol);
					
					++iColProjection;
				}
			}

			++iRowProjection;
		}
	}
	else
	{
		vrmatrix.Init(0,0);
	}
	return vrmatrix;
}

VLREAL VRMATRIX :: VectorRow ( int iRow ) const
{
	// Return a copy of the iRow'th row vector of the matrix

	if ( iRow >= CRow() ) 
		throw GMException(EC_MDVECT_MISUSE,"invalid matrix projection");

	VLREAL vectorRowReturn;

	int cCol = CCol();

	vectorRowReturn.resize(cCol);

	const REAL* rgrealRowMatrix = & self(iRow,0);
		
	for ( int iCol = 0; iCol < cCol; cCol++ )
	{
		vectorRowReturn[iCol] = rgrealRowMatrix[iCol];
	}
	//	*prv++ = *prm++;

	return vectorRowReturn;
}

VLREAL VRMATRIX :: VectorColumn ( int iCol ) const
{
	// Return a copy of the iCol'th column vector of the matrix

	if ( iCol >= CCol() ) 
		throw GMException(EC_MDVECT_MISUSE,"invalid matrix projection");

	VLREAL vectorColReturn;

	int cRow = CRow();

	vectorColReturn.resize(cRow);

	const REAL* rgrealColMatrix = & self(0, iCol);
		
	for ( int iRow = 0; iRow < cRow; iRow++ )
	{
		vectorColReturn[iRow] = rgrealColMatrix[iRow];
	}

	return vectorColReturn;
}

VRMATRIX VRMATRIX :: VrmatrixTranspose () const
{
	// Return the transpose of this matrix

	VRMATRIX vrmatrixTranspose( CCol(), CRow() );

	for ( int iRow = 0 ; iRow < CRow() ; iRow++ )
	{
		for ( int iCol = 0; iCol < CCol(); iCol++ )
		{
			vrmatrixTranspose(iCol,iRow) = self(iRow,iCol);
		}
	}
	return vrmatrixTranspose;
}

VRMATRIX VRMATRIX::operator * ( const VRMATRIX & matrix ) const
{
	if ( ! BCanMultiply( matrix ) ) 
		throw GMException(EC_MDVECT_MISUSE,"invalid matrix multiplication");
	
	//  Result matrix
	VRMATRIX mat( CRow(), matrix.CCol() );

	//  Compute distance in flat array between adjacent 
	//		column items in secondary
	int icolInc = matrix.second.stride()[0];

	const REAL * prrow = & self(0,0);
	REAL * prmat = & mat(0,0);
	for (int irow = 0; irow < CRow(); irow++)
	{
		const REAL * prrowt;
		for ( int icol = 0; icol < matrix.CCol(); icol++ )
		{
			prrowt = prrow;
			assert( prrowt == & self(irow,0) );

			// First column element in "matrix"
			const REAL * prcol = & matrix(0,icol);

			// Compute the new element
			REAL r = 0.0;
			for (int i = 0; i < CCol(); i++)
			{
				assert( prcol == & matrix(i,icol) );
				r += *prcol * *prrowt++;
				prcol += icolInc;
			}
			//  Store it
			*prmat++ = r;			
		}
		prrow = prrowt;
	}

	return mat;
}

VRMATRIX & VRMATRIX::operator += ( const VRMATRIX & vrmatrixAdd )
{
	// Add vrmatrixAdd to this matrix

	// Make sure the matrices are of the same dimension
	
	if (! BSameDimension(vrmatrixAdd) )
		throw GMException(EC_MDVECT_MISUSE,"inapplicable matrix operator");

	// Perform a flat add between all the elements in the matricies

	int crealTotal = second._Totlen();

	REAL*		rgrealSelf		= &self(0,0);
	const REAL*	rgrealMatrixAdd	= &vrmatrixAdd(0,0);

	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] += rgrealMatrixAdd[ireal];
	}

	return self;
}

VRMATRIX & VRMATRIX::operator -= ( const VRMATRIX & vrmatrixMatrixSubtract )
{
	// Subtract vrmatrixAdd from this matrix

	// Make sure the matrices are of the same dimension

	if ( ! BSameDimension( vrmatrixMatrixSubtract ) )
		throw GMException(EC_MDVECT_MISUSE,"inapplicable matrix operator");

	// Perform a flat subtration between all the elements in the matricies

	int crealTotal = second._Totlen();

	REAL*		rgrealSelf				= &self(0,0);
	const REAL*	rgrealMatrixSubtract	= &vrmatrixMatrixSubtract(0,0);

	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] -= rgrealMatrixSubtract[ireal];
	}

	return self;
}

VRMATRIX & VRMATRIX::operator *= ( REAL rScalar )
{
	// Multiply each element in the matrix by rScalar

	int crealTotal = second._Totlen();

	REAL*	rgrealSelf	= &self(0,0);
	
	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] *= rScalar;
	}

	return self;
}

VRMATRIX & VRMATRIX::operator += ( REAL rScalar )
{
	// Add rScalar to each element in the matrix 

	int crealTotal = second._Totlen();

	REAL*	rgrealSelf	= &self(0,0);
	
	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] += rScalar;
	}

	return self;
}

VRMATRIX & VRMATRIX::operator -= ( REAL rScalar )
{
	// Subtract rScalar from each element in the matrix 

	int crealTotal = second._Totlen();

	REAL*	rgrealSelf	= &self(0,0);
	
	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] -= rScalar;
	}

	return self;
}

VRMATRIX & VRMATRIX::operator /= ( REAL rScalar )
{
	// Divide each element in the matrix by rScalar

	int crealTotal = second._Totlen();

	REAL*	rgrealSelf	= &self(0,0);
	
	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] /= rScalar;
	}

	return self;
}

VRMATRIXSQ :: VRMATRIXSQ ( const VLREAL & vrColumn, const VLREAL & vrRow )
{	
	// Constructor for square matrices that takes a column and row vector.
	// The initial state of this matrix is the product of the input
	// vectors.

	// Make sure the vectors are of the same length

	if ( vrColumn.size() != vrRow.size() ) 
		throw GMException(EC_MDVECT_MISUSE,"invalid matrix multiplication");

	Init( vrColumn.size() );
	REAL * prm = & self(0,0);
	for ( int iRow = 0; iRow < CRow(); iRow++ )
	{
		for ( int iCol = 0; iCol < CCol(); iCol++ )
		{
			*prm++ = vrColumn[iCol] * vrRow[iRow];
		}
	}	
}	

VRMATRIXSQ & VRMATRIXSQ::operator *= (const VRMATRIXSQ& matrix)
{
	if (   matrix.CRow() != CRow() 
	    || matrix.CCol() != CRow() ) 
		throw GMException(EC_MDVECT_MISUSE,"invalid matrix multiplication");

	//  Temporary row for partial result
	VLREAL vrrow;
	vrrow.resize(CCol());
	
	//  Compute distance in flat array between rows
	int icolInc = matrix.second.stride()[0];

	REAL * prrow = & self(0,0);
	const REAL * prmat = & matrix(0,0);
	REAL * prtemp0 = & vrrow[0];
	for (int irow = 0; irow < CRow(); irow++)
	{
		REAL * prtemp = prtemp0;
		for ( int icol = 0; icol < matrix.CCol(); icol++ )
		{
			const REAL * prrowt = prrow;
			assert( prrowt == & self(irow,0) );

			// First column element in "matrix"
			const REAL * prcol = & matrix(0,icol);

			// Compute the new element
			REAL r = 0.0;
			for (int i = 0; i < CCol(); i++)
			{
				assert( prcol == & matrix(i,icol) );
				r += *prcol * *prrowt++;
				prcol += icolInc;
			}
			//  Store it temporary row vector
			*prtemp++ = r;			
		}

		//  Update row in self
		prtemp = prtemp0;
		for ( int icol2 = 0; icol2 < CCol(); icol2++ )
		{
			*prrow++ = *prtemp++;
		}
	}

	return self;
}

void VRMATRIXSQ::LUDBackSub (const VRMATRIXSQ& matrix)
{
	if ( ! matrix.BIsLUDecomposed() )
		throw GMException(EC_MDVECT_MISUSE,"matrix not in L-U decomposed form");

	for (int icol = 0; icol < CCol(); icol++)
	{
		int	irowNZ = -1;

		for (int irow = 0; irow < CRow(); irow++)
		{
			int	irowMax = matrix._vimdRow[irow];
			REAL	probSum = self(irowMax,icol);

			self(irowMax,icol) = self(irow,icol);

			if (irowNZ != -1)
			{
				for (int iMul = irowNZ; iMul < irow; iMul++)
					probSum -= matrix(irow,iMul) * self(iMul,icol);
			}
			else if (probSum != 0.0)
				irowNZ = irow;

			self(irow,icol) = probSum;
		}

		for (     irow = CRow(); irow-- > 0; )
		{
			REAL	probSum = self(irow,icol);

			for (int iMul = irow + 1; iMul < CRow(); iMul++)
				probSum -= matrix(irow,iMul) * self(iMul,icol);
			self(irow,icol) = probSum / matrix(irow,irow);
		}
	}
}

void VRMATRIXSQ::LUDecompose( bool bUseTinyIfSingular )
{
	// Perform L-U decomposition; throw exception if singular
	// If "use tiny" is set, pivots at zero are replaced with
	//	 RTINY value (1.0e-20)


	// Check that this matrix is not already LU decomposed
	if ( BIsLUDecomposed() )
		throw GMException(EC_MDVECT_MISUSE,"matrix is already in L-U decomposed form");

	if (CRow() == 0)
		return;	// trivial case

	int	cDim = CRow();

	_vimdRow.resize(cDim);

	VLREAL vlrealOverMax;
	vlrealOverMax.resize(cDim);

	_iSign = 1;

	for (int iRow = 0; iRow < cDim; iRow++)
	{
		REAL	realMax = 0.0;

		for (int iCol = 0; iCol < cDim; iCol++)
		{
			REAL	realAbs = fabs(self(iRow,iCol));

			if (realAbs > realMax)
				realMax = realAbs;
		}
		if (realMax == 0.0)
		{
			// Every element in the row is zero: this is a singular matrix

			throw GMException(EC_MDVECT_MISUSE,"matrix is singular");
		}

		vlrealOverMax[iRow] = 1.0 / realMax;
	}

	for (int iCol = 0; iCol < cDim; iCol++)
	{
		for (int iRow = 0;    iRow < iCol; iRow++)
		{
			REAL	realSum = self(iRow,iCol);
			
			for (int iMul = 0; iMul < iRow; iMul++)
				realSum -= self(iRow,iMul) * self(iMul,iCol);

			self(iRow,iCol) = realSum;
		}

		REAL realMax = 0.0;
		int	iRowMax = 0;

		for ( iRow = iCol; iRow < cDim; iRow++)
		{
			REAL	realSum = self(iRow,iCol);

			for (int iMul = 0; iMul < iCol; iMul++)
				realSum -= self(iRow,iMul) * self(iMul,iCol);

			self(iRow,iCol) = realSum;

			REAL	realAbs = vlrealOverMax[iRow] * fabs(realSum);

			if (realAbs >= realMax)
			{
				realMax = realAbs;
				iRowMax = iRow;
			}
		}

		if (iRowMax != iCol)
		{
			//	we need to interchange rows
			_iSign *= -1;
			vlrealOverMax[iRowMax] = vlrealOverMax[iCol];
			InterchangeRows(iRowMax,iCol);
		}

		_vimdRow[iCol] = iRowMax;

		REAL & rPivot = self(iCol,iCol);

		if ( rPivot == 0.0 )
		{
			if ( ! bUseTinyIfSingular )
			{
				// This is a singular matrix: throw exceptioin
				throw GMException(EC_MDVECT_MISUSE,"matrix is singular");
			}

			rPivot = RTINY;
		}

		REAL rScale = 1.0 / rPivot;

		for ( iRow = iCol + 1; iRow < cDim; iRow++)
			self(iRow,iCol) *= rScale;
	}
}

void VRMATRIXSQ::Invert( bool bUseTinyIfSingular )
{
	// Invert; throw exception if singular.  If not in L-U form,
	// L-U Decomp is called.

	if ( ! BIsLUDecomposed() )
	{
		LUDecompose( bUseTinyIfSingular );
	}

	VRMATRIXSQ	matrixOne(CRow());

	// Create the identity matrix

	for (int iDim1 = 0; iDim1 < CRow(); iDim1++)
	{
		for (int iDim2 = 0; iDim2 < CRow(); iDim2++)
			matrixOne(iDim1, iDim2) = iDim1 == iDim2 ? 1.0 : 0.0;
	}

	matrixOne.LUDBackSub(self);

	for ( iDim1 = 0; iDim1 < CRow(); iDim1++)
	{
		for (int iDim2 = 0; iDim2 < CRow(); iDim2++)
			self(iDim1, iDim2) = matrixOne(iDim1, iDim2);
	}

	//  Clear l-u decomp values
	_vimdRow.resize(0);
}

DBL VRMATRIXSQ::DblDeterminant()
{
	DBL	dblDet = _iSign;

	if ( CRow() > 0 && ! BIsLUDecomposed() )
		LUDecompose();			

	// Once the matrix has been LU decomposed, the determinant can be 
	// obtained by simply multiplying the elements of the diagonal

	for (int iRow = 0; iRow < CRow(); iRow++)
	{
		dblDet *= self(iRow,iRow);
	}

	return dblDet;
}

DBL VRMATRIXSQ :: DblAddLogDiagonal() const
// Adds the log of each element in the diagonal and returns the sum.
{
	DBL		dblLogDiag 	= 0;
//	bool	bPositive	= _iSign == 1;
	bool	bPositive	= 1;

	for (int iRow = 0; iRow < CRow(); iRow++)
	{
		if (self(iRow,iRow) < 0)
			bPositive = !bPositive;	

		// Assert that the element is not zero. We should probably 
		// throw an exception here instead.

		assert(self(iRow,iRow) != 0);

		dblLogDiag += log (fabs(self(iRow,iRow)));
	}

	if (!bPositive)	   
	{
		// Got a negative determinant, so we can't take the log... throw
		// an exception

		return false;
	}

	return dblLogDiag;
}


DBL	VRMATRIXSQ :: DblLogDeterminant()
{
	// Return the log of the determinant. If not in L-U form,
	// L-U Decomp is called. Throws exception if negative.

	if ( CRow() > 0 && ! BIsLUDecomposed() )
		LUDecompose();			

	DBL		dblLogDet 	= 0;
	bool	bPositive	= _iSign == 1;

	for (int iRow = 0; iRow < CRow(); iRow++)
	{
		if (self(iRow,iRow) < 0)
			bPositive = !bPositive;	

		// Assert that the deterninant is not zero. We should probably 
		// throw an exception here instead.

		assert(self(iRow,iRow) != 0);

		dblLogDet += log (fabs(self(iRow,iRow)));
	}

	if (!bPositive)	   
	{
		// Got a negative determinant, so we can't take the log... throw
		// an exception

		return false;
	}

	return dblLogDet;
}

void VRMATRIXSQ :: GetLUDecompose( VRMATRIXSQ & vmatrixResult, bool bUseTinyIfSingular ) const
{
	// Set vrmatResult to be the result of performing an L-U 
	// decomposition on the matrix. Will throw exception if 
	// the matrix is singular
	// If "use tiny" is set, pivots at zero are replaced with
	//	 RTINY value (1.0e-20)

	// Copy this matrix into vmatrixResult...
	vmatrixResult = self;

	// .. and perform the decomposition
	vmatrixResult.LUDecompose( bUseTinyIfSingular );
}

void VRMATRIXSQ :: GetInverse( VRMATRIXSQ & vmatrixResult, bool bUseTinyIfSingular ) const
{
	// Set vrmatResult to the inverse of the matrix.
	// Will throw an exception if the matrix is singular.

	// Copy this matrix into vmatrixResult...
	vmatrixResult = self;

	/// ...and invert
	vmatrixResult.Invert( bUseTinyIfSingular );
}

void VRMATRIXSQ :: GetDblDeterminant( DBL& dblDeterminant, VRMATRIXSQ & vmatrixResult ) const
{
	// Get the determinant without modifying (LU decomposing) the matrix.
	// vmatrixResult will contain the LU decomposed version of the matrix.
	
	// Copy this matrix into vmatrixResult...
	vmatrixResult	= self;
	dblDeterminant	=  vmatrixResult.DblDeterminant();
}

void VRMATRIXSQ :: GetDblLogDeterminant( DBL& dblLogDeterminant, VRMATRIXSQ & vmatrixResult ) const
{
	// Get the log of determinant without modifying (LU decomposing) the matrix.
	// vmatrixResult will contain the LU decomposed version of the matrix.
	
	vmatrixResult		= self;
	dblLogDeterminant	= vmatrixResult.DblLogDeterminant();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\zstrt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       zstrt.h
//
//--------------------------------------------------------------------------

//
//	ZSTRT.H:  String table management
//	
#ifndef _ZSTRT_H_
#define _ZSTRT_H_

#include <map>
#include <set>
#include <vector>
#include "basics.h"
#include "zstr.h"
#include "refcnt.h" 

//using namespace std;

//  Token used in probability distribution
class TKNPD;

////////////////////////////////////////////////////////////////////
//	class ZSTRT:
//		Class of reference-counted string maintained in string table
////////////////////////////////////////////////////////////////////
class ZSTRT : public ZSTR, public REFCNT
{
  friend class STZSTR;
  friend class ZSREF;
  friend class TKNPD;

  protected:
	ZSTRT( SZC szc = NULL )
		: ZSTR(szc)
		{}

  protected:
	void Dump () const;

  // Hide the assignment operator
  HIDE_AS(ZSTRT);		
};

////////////////////////////////////////////////////////////////////
//	class ZSREF:
//		Smart pointer acting as a reference to a string in a symbol
//		table (i.e., reference-counted).
//
//      ZSREF contains appropriate operators for const strings.
////////////////////////////////////////////////////////////////////
class ZSREF 
{
  friend class STZSTR;
  friend class TKNPD;

  protected:	
	ZSREF( ZSTRT & zstrt )
		: _pzstrt(& zstrt)
		{ IncRef();  }
	
  public:
	ZSREF ()
		: _pzstrt(& Zsempty)
		{}
	~ZSREF()
		{	IncRef(-1);	}
	ZSREF( const ZSREF & zsr )
		: _pzstrt(zsr._pzstrt)
		{	IncRef();	}

	ZSREF & operator = ( const ZSREF & zsr )
	{
		IncRef(-1);
		_pzstrt = zsr._pzstrt;
		IncRef(1);
		return *this;
	}
	const ZSTR & Zstr () const
		{ return *Pzst(); }
	SZC Szc () const
		{ return _pzstrt->c_str(); }
	operator SZC () const
		{ return Szc() ; }
	bool operator == ( const ZSREF & zsr ) const
	{ 
		return _pzstrt == zsr._pzstrt 
			|| ((Pzst()->length() + zsr.Pzst()->length()) == 0) ; 
	}
	bool operator < ( const ZSREF & zsr ) const
		{ return *_pzstrt < *zsr._pzstrt; }
	bool operator == ( const ZSTR & zst ) const
		{ return *_pzstrt == zst; }
	bool operator < ( const ZSTR & zst ) const
		{ return *_pzstrt < zst; }

	const ZSTRT * operator -> () const	
		{ return Pzst(); }	

	void Clear ()
	{  
		IncRef(-1);
		_pzstrt = & Zsempty;
	} 
	bool BEmpty () const
		{ return _pzstrt == & Zsempty; }

  protected:	
	ZSTRT * _pzstrt;

	void IncRef ( int i = 1 ) const
		{	_pzstrt->IncRef(i);	}
	const ZSTRT * Pzst () const
		{ return _pzstrt; }

	static ZSTRT Zsempty;
};

//  Define VZSREF
DEFINEV(ZSREF);

////////////////////////////////////////////////////////////////////
//	class STZSTR_BASE and STZSTR.  
//
//		STZSTR_BASE is an ensemble of strings.  STZSTR is a container
//		for a STZSTR_BASE.  The STL does not adequately hide 
//		implementations, so the string table had to be embedded into
//		a container to encapsulate it completely.
////////////////////////////////////////////////////////////////////
class STZSTR_BASE : public set<ZSTRT, less<ZSTRT> > {};

//  Container for a string table.  Returns only references to the string.
class STZSTR
{
  public:
	STZSTR() {}
	~ STZSTR()
	{
	#if defined(DUMP)
		Dump();
	#endif
	}

	//  The only public accessor: given a "const char *", return
	//		a ZSREF, whether by creation of a new string in the table
	//		or by returning a reference to an existing string.
	ZSREF Zsref (SZC szc)
	{
		ZSTRT zs(szc);
		STZSTR_BASE::_Pairib it = _stz.insert(zs);
		const ZSTRT & zst = *it.first;
		return ZSREF(const_cast<ZSTRT&>(zst));
	}
	void Clone ( const STZSTR & stzstr );

  protected:
	STZSTR_BASE _stz;		// The contained string table

  protected:
  	STZSTR_BASE & Stz ()
		{ return _stz; }
	//  Testing:  iterator accessors for hidden string set
	STZSTR_BASE::const_iterator IterBegin () const
		{  return _stz.begin(); }
	STZSTR_BASE::const_iterator IterEnd () const
		{  return _stz.end(); }
	void Dump () const;

	HIDE_UNSAFE(STZSTR);
};


// End of ZSTRT.H


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\vrmatrx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       vrmatrx.h
//
//--------------------------------------------------------------------------

#ifndef	_MATRIX_H_
#define _MATRIX_H_

#include <memory.h>

#include "basics.h"
#include "mdvect.h"

//
//	VRMATRIXSQ.H: Matrix handling
//

template<class T>
void fastMemMove(const T * ptfrom, T * ptto, int ct)
{
	::memmove( (void*) ptto, (void*) ptfrom, ct * sizeof(T) );
}

class VRMATRIX : public TMDVDENSE<REAL>
{
  public:
    VRMATRIX ( int cRow, int cCol = 0 )
	{
		Init( cRow, cCol );
	}
	VRMATRIX () {}

	void Init ( int cRow, int cCol = 0 )
	{
		second.Init( 2, cRow, cCol != 0 ? cCol : cRow );
		first.resize( second._Totlen() );
	}
	void Init ( const VRMATRIX & vrmat )
	{
		Init( vrmat.CRow(), vrmat.CCol() );
	}
	bool BCanMultiply( const VRMATRIX & mat ) const
	{
		return CCol() == mat.CRow();
	}

	bool BSameDimension( const VRMATRIX & mat ) const  
	{
		return CRow() == mat.CRow() && CCol() == mat.CCol() ;
	}
	
	int CDim ( int iDim ) const
	{ 
		return second.size().size() > iDim
		     ? second.size()[iDim]
			 : 0 ; 
	}
	int CRow () const
		{ return CDim(0); }
	int CCol () const
		{ return CDim(1); }

	bool BSquare() const
		{ return CRow() == CCol() ; }

	int IOffset ( int irow, int icol ) const
	{
		int cRow = CRow();
		int cCol = CCol();
		
		if (   irow >= CRow() 
			|| icol >= CCol() )
			throw GMException(EC_MDVECT_MISUSE,"subscript error on matrix");

		return second.stride()[0] * irow 
		     + second.stride()[1] * icol;
	}
	REAL & operator () ( int irow, int icol )
		{ return first[ IOffset(irow,icol) ]; }

	const REAL & operator () ( int irow, int icol ) const
	{ 
		VRMATRIX & vrmx = const_cast<VRMATRIX&>(self);
		return vrmx.first[ IOffset(irow,icol) ]; 
	}

	void InterchangeRows ( int irow1, int irow2 )
	{
		if (   irow1 >= CRow()
			&& irow2 >= CRow() )
			throw GMException(EC_MDVECT_MISUSE,"subscript error on matrix");			
		if ( irow1 == irow2 ) 
			return;		
		REAL * pr1 =  & self(irow1,0);
		REAL * pr2 =  & self(irow2,0);
		assert( & self(irow1,1) - pr1 == 1 );

		for ( int icol = 0; icol < CCol(); icol++ )
		{
			REAL r = *pr1;
			*pr1++ = *pr2;
			*pr2++ = r;			
		}
	}

	void InterchangeCols ( int icol1, int icol2 )
	{
		if (   icol1 >= CCol()
			&& icol2 >= CCol() )
			throw GMException(EC_MDVECT_MISUSE,"subscript error on matrix");
		if ( icol1 == icol2 ) 
			return;
		REAL * pr1 = & self(0,icol1);
		REAL * pr2 = & self(0,icol2);
		int icolInc = CCol();

		for ( int irow = 0; irow < CRow(); irow++ )
		{
			REAL r = *pr1;
			*pr1 = *pr2;
			*pr2 = r;			
			pr1 += icolInc;
			pr2 += icolInc;
		}
	}	

	//  Return the transpose of the matrix
	VRMATRIX VrmatrixTranspose () const;
	//	Return a row vector
	VLREAL VectorRow ( int irow ) const;
	//  Return a column vector
	VLREAL VectorColumn ( int icol ) const;
	//  Project a view of the matrix (see documentation below).
	VRMATRIX VrmatrixProject ( const VIMD & vimdRowColumnRetain ) const;
	VRMATRIX operator * ( const VRMATRIX & matrix ) const;
	VRMATRIX operator * ( const VLREAL & vreal ) const;

	VRMATRIX & operator += ( const VRMATRIX & matrix );
	VRMATRIX & operator -= ( const VRMATRIX & matrix );
	VRMATRIX & operator *= ( REAL rScalar );
	VRMATRIX & operator += ( REAL rScalar );
	VRMATRIX & operator -= ( REAL rScalar );
	VRMATRIX & operator /= ( REAL rScalar );
};

class VRMATRIXSQ : public VRMATRIX
{
  public:
  	VRMATRIXSQ(int cdim)
		: VRMATRIX(cdim,cdim),
		_iSign(1)
		{}
	VRMATRIXSQ () {}
	//  Construct a square matrix as the product of a column
	//    and a row vector.
	VRMATRIXSQ ( const VLREAL & vrColumn, const VLREAL & vrRow );

	~ VRMATRIXSQ() {}

	// Return true if matrix is in L-U decomposition form
	bool BIsLUDecomposed () const
		{ return _vimdRow.size() > 0 ; }

	//  Destructive computation routines
	VRMATRIXSQ & operator *= ( REAL rScalar )
	{
		VRMATRIX::operator*=(rScalar);
		return self;
	}
	VRMATRIXSQ & operator /= ( REAL rScalar )
	{
		VRMATRIX::operator/=(rScalar);
		return self;
	}
	VRMATRIXSQ & operator += ( REAL rScalar )
	{
		VRMATRIX::operator+=(rScalar);
		return self;
	}
	VRMATRIXSQ & operator -= ( REAL rScalar )
	{
		VRMATRIX::operator-=(rScalar);
		return self;
	}
	VRMATRIXSQ & operator += ( const VRMATRIXSQ & matrix )
	{
		VRMATRIX::operator+=(matrix);
		return self;
	}

	VRMATRIXSQ & operator -= ( const VRMATRIXSQ & matrix )
	{
		VRMATRIX::operator-=(matrix);
		return self;
	}

	VRMATRIXSQ & operator *= ( const VRMATRIXSQ & matrix );

		// Perform L-U decomposition; throw exception if singular
		// If "use tiny" is set, pivots at zero are replaced with
		//	 RTINY value (1.0e-20)
	void LUDecompose( bool bUseTinyIfSingular = false );
		
		// Invert; throw exception singular.  If not in L-U form,
		// L-U Decomp is called.
	void Invert( bool bUseTinyIfSingular = false );
		
		// Return the determinant.  If not in L-U form,
		// L-U Decomp is called.
	DBL DblDeterminant();

		// Return the log of the determinant. If not in L-U form,
		// L-U Decomp is called. Throws exception if negative.
	DBL DblLogDeterminant();


	//  ------------------------------------
	//  Non-destructive computation routines
	//  ------------------------------------
		
		// Adds the log of each element in the diagonal and returns the sum.
	DBL DblAddLogDiagonal() const;

		// Set vrmatResult to be the result of performing an L-U 
		// decomposition on the matrix. Will throw exception if 
		// the matrix is singular
		// If "use tiny" is set, pivots at zero are replaced with
		//	 RTINY value (1.0e-20)
	void GetLUDecompose( VRMATRIXSQ & vrmatResult, bool bUseTinyIfSingular = false ) const;
		
		// Set vrmatResult to the inverse of the matrix.
		// Will throw an exception if the matrix is singular.  
	void GetInverse( VRMATRIXSQ & vrmatResult, bool bUseTinyIfSingular = false ) const;
		
		// Get the determinant without modifying (LU decomposing) the matrix.
		// vrmatResult will contain the LU decomposed version of the matrix. 
	void GetDblDeterminant( DBL& dblDeterm, VRMATRIXSQ & vrmatResult ) const;

		 // Get the log of determinant without modifying (LU decomposing) the matrix.
		 // vrmatResult will contain the LU decomposed version of the matrix. 
	void GetDblLogDeterminant( DBL& dblLogDeterm, VRMATRIXSQ & vrmatResult) const;

	//  Project a view of the matrix (see documentation below).
	VRMATRIXSQ VrmatrixProject ( const VIMD & vimdRowColumnRetain ) const;

  protected:

	int		_iSign;
	VIMD	_vimdRow;

  	void LUDBackSub(const VRMATRIXSQ & matrix);
};


/*  
	How to use the VRMATRIX::Project() function.

	Original matrix:
	1 2 3
	4 5 6
	7 8 9

	The (0,2) projection is obtained by deleting the 2nd row and 2nd column:
	1 3
	7 9

	The (0,1) projection is obtained by deleting the 3rd row (and third column):
	1 2
	4 5

	The (1,2) projeciton is obtained by deleting the 1st row and 1st column:
	5 6
	8 9

	The (0) projection is obtained by deleting the 2nd and 3rd rows and columns:
	1
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bnts\bnstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bnstr.h
//
//--------------------------------------------------------------------------

//
//	BNSTR.HXX:  Generic string class.
//
#if !defined(_BNSTR_HXX_)
#define _BNSTR_HXX_

#include "basics.h"

class BNSTR
{
  public:
  	BNSTR ( const BNSTR & str ) ;
  	BNSTR ( SZC sz = NULL ) ;
  	~ BNSTR () ;
  	
 	SZC Szc () const 					{ return _sz ; }
 	
  	//  Allow use of a BNSTR anywhere an SZC is allowed
	operator const char * () const
		{ return _sz ; }

	//  Prefix or suffix the string with the given string or character
	SZC Prefix ( SZC szPrefix ) ;
	SZC Suffix ( SZC szSuffix ) ;
	SZC Suffix ( char chSuffix );
	
	//  Clear the string to empty	
  	void Reset () ;
  	//  Return the current length of the string
	UINT Length () const
		{ return _cchStr ; }	
	//  Return the maximum allowable length of the string
	UINT Max () const
		{ return _cchMax ; }
	//  Truncate the string to the given length.
	void Trunc ( UINT cchLen ) ;
  	//  Destructive assignment: release the current buffer and reset the BNSTR  	
  	SZ Transfer () ;
	void Transfer ( BNSTR & str ) ;
	
	//  Assignment operators
	BNSTR & operator = ( const BNSTR & str )
		{ Update( str ); return *this ; }
	BNSTR & operator = ( SZC szSource )
		{ Update( szSource ) ; return *this; }
		
	//  Assignment function (for error checking)
	bool Assign ( SZC szcSource ) 	
		{ return Update( szcSource ) ; }
	bool Assign ( SZC szcData, UINT cchLen ) ;

	//  Concatenation operators
	BNSTR & operator += ( SZC szSource )
		{ Suffix( szSource ) ; return *this ; }
	BNSTR & operator += ( char chSource )
		{ Suffix( chSource ) ; return *this ; }
	
	//  Comparison: functions and operators
	//  Standard low/eq/high plus case comparator.
	INT Compare ( SZC szSource, bool bIgnoreCase = false ) const ;
	bool operator == ( SZC szSource ) const ;
	bool operator != ( SZC szSource ) const ;
 	char operator [] ( UINT iChar ) const ;
	
	//  Formating	
	bool Vsprintf ( SZC szcFmt, va_list valist ) ;
	bool Sprintf ( SZC szcFmt, ... ) ;
	bool SprintfAppend ( SZC szcFmt, ... ) ;
	
	//  Cr/Lf expansion or contraction
	bool ExpandNl () ;
	bool ContractNl () ;
	bool ExpandEscaped ();
	bool ContractEscaped ();

	//  Expand the string to the given length; make it a blank, null terminated 
	//  string.
	bool Pad ( UINT cchLength ) ;
	
	//  Change all alphabetic characters to the given case
	void UpCase ( bool bToUpper = true ) ;
	
	bool ReplaceSymName ( SZC szcSymName, 
						  SZC szcSymNameNew, 
						  bool bCaseInsensitive = true );
	
	//  Find the next occurrence of the given character in the string;
	//  Return -1 if not found.
	INT Index ( char chFind, UINT uiOffset = 0 ) const ;						
	//  Convert the string to a floating-point number.
    double Atof ( UINT uiOffset = 0 ) const ;

	UINT CbyteCPT() const
		{ return _cchMax + 1 ; }
		
  protected:
  	bool Update ( SZC szc ) ;
  	bool Grow ( UINT cchNewSize = 0, SZ * ppszNew = NULL ) ;
  	
  	UINT _cchMax ;
  	UINT _cchStr ;
  	SZ _sz ;
  	
  private:
  	void DeleteSz () ;  	
  	static SZC _pmt ;  	
};

#endif   // !defined(_STR_HXX_)

//  End of BNSTR.HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bnts\bnstr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bnstr.cpp
//
//--------------------------------------------------------------------------

//
//	BNSTR.CPP
//

#include <stdarg.h>
#include <ctype.h>

#include "bnstr.h"


SZC BNSTR :: _pmt = "" ;

static SZ	SzCopy(SZC szc)
{
	SZ		szNew = szc ? new char[::strlen(szc) + 1] : NULL;

	return  szNew ? ::strcpy(szNew, szc) : NULL;
}

BNSTR :: BNSTR ( SZC sz )
	: _cchMax( 0 ),
	_cchStr( 0 ),
	_sz( const_cast<SZ>(_pmt) )
{
	if ( sz )
	{
		Update( sz ) ;
	}
}

BNSTR :: BNSTR ( const BNSTR & str )
	: _cchMax( str._cchStr ),
	_cchStr( str._cchStr ),
	_sz( const_cast<SZ>(_pmt) )
{
	if ( str._sz != _pmt )
	{ 
		_sz = ::SzCopy( str._sz ) ;
	}
}


BNSTR :: ~ BNSTR ()
{
	Reset() ;
}

void BNSTR :: Reset ()
{   
	DeleteSz() ;
	_sz = const_cast<SZ>(_pmt) ;
	_cchStr = 0 ;
	_cchMax = 0 ;		
}

	//  Protectively delete either the given string or the 
	//  private string.
void BNSTR :: DeleteSz ()
{
	if ( _sz != NULL && _sz != _pmt )
	{
		delete [] _sz ;
		_sz = NULL ;
	}	
}

 	//  Release the current buffer; reset the BNSTR.
SZ BNSTR::Transfer ()
{
	SZ sz = _sz ;
	_sz = NULL ;
	Reset() ;
	return sz = _pmt ? NULL : sz ;
}

	//  Give the current buffer to a new string, reset *this.
void BNSTR :: Transfer ( BNSTR & str ) 
{
    str.Reset() ;
	str._sz = _sz ;
	str._cchMax = _cchMax ;
	str._cchStr = _cchStr ;
	_sz = NULL ;
	Reset() ;
}

void BNSTR :: Trunc ( UINT cchLen )
{
	if ( _sz == _pmt ) 
		return ;
	if ( cchLen < _cchStr )
		_sz[cchLen] = 0 ;
}

	//  Update the pointed string.  Since this routine is 
	//  used by the assignment operator, it's written to allow
	//  for the new string being part of the old string.
bool BNSTR :: Update ( SZC sz )
{
	bool bResult = true ;
	
	UINT cch = sz ? ::strlen( sz ) : 0 ;
	
	if ( cch > _cchMax )
	{    
		SZ szNew = ::SzCopy( sz ) ;
		if ( bResult = szNew != NULL )
		{
			DeleteSz() ;
			_sz = szNew ;
			_cchMax = _cchStr = cch ;
		}
	}
	else
	if ( cch == 0 )
	{
		Reset() ;
	}
	else
	{   
		//  REVIEW: this assumes that ::strcpy() handles overlapping regions correctly.
		::strcpy( _sz, sz ) ;
		_cchStr = cch ;
	}
	return bResult ;
}

	//  Grow the string.  if 'cchNewSize' == 0, expand by 50%.
	//  If 'ppszNew' is given, store the new string there (for efficiency in
	//  Prefix); note that this requires that we reallocate.
bool BNSTR :: Grow ( UINT cchNewSize, SZ * ppszNew )
{
	UINT cchNew = cchNewSize == 0
				? (_cchMax + (_cchMax/2))
				: cchNewSize ;
				
    bool bResult = true ;
	if ( cchNew > _cchMax || ppszNew )
	{
		SZ sz = new char [cchNew+1] ;
		if ( bResult = sz != NULL )
		{	
			_cchMax = cchNew ;
			if ( ppszNew )
			{
				*ppszNew = sz ;
			}
			else
			{
				::strcpy( sz, _sz ) ;
				DeleteSz() ;
				_sz = sz ;
			}
		}
	}
	return bResult ;
}

	//  Expand the string to the given length; make it a blank, null terminated 
	//  string.
bool BNSTR :: Pad ( UINT cchLength )
{
	//  Expand as necessary
	if ( ! Grow( cchLength + 1 ) ) 
		return false ;
	//  If expanding, pad the string with spaces.
	while ( _cchStr < cchLength ) 
	{
		_sz[_cchStr++] = ' ' ;
	}
	//  Truncate to proper length
	_sz[_cchStr = cchLength] = 0 ;
	return true ;
}

bool BNSTR :: Assign ( SZC szcData, UINT cchLen ) 
{
	if ( ! Grow( cchLen + 1 ) ) 
		return false ;
	::memcpy( _sz, szcData, cchLen ) ;
	_sz[cchLen] = 0 ;
	_cchMax = _cchStr = cchLen ;
	return true ;
}

SZC BNSTR :: Prefix ( SZC szPrefix )
{
	assert( szPrefix != NULL ) ;
	UINT cch = ::strlen( szPrefix ) ;
	SZ sz ;
	if ( ! Grow( _cchStr + cch + 1, & sz ) )
		return NULL ;
	::strcpy( sz, szPrefix ) ;
	::strcpy( sz + cch, _sz ) ;
	DeleteSz();
	_cchStr += cch ;			
	return _sz = sz ;
}

SZC BNSTR :: Suffix ( SZC szSuffix )
{
	if ( szSuffix )
	{		
		UINT cch = ::strlen( szSuffix ) ;

		if ( ! Grow( _cchStr + cch + 1 ) )
			return NULL ;

		::strcpy( _sz + _cchStr, szSuffix ) ; 		
		_cchStr += cch ;
	}

	return *this ;
}

SZC BNSTR :: Suffix ( char chSuffix )
{
	char rgch[2] ;
	rgch[0] = chSuffix ;
	rgch[1] = 0 ;
	return Suffix( rgch );
}

INT BNSTR :: Compare ( SZC szSource, bool bIgnoreCase ) const 
{
	return bIgnoreCase 
		? ::stricmp( _sz, szSource ) 
		: ::strcmp( _sz, szSource );	
}

	//  Comparison
bool BNSTR :: operator == ( SZC szcSource ) const
{
	return Compare( szcSource ) == 0 ;	
}

bool BNSTR :: operator != ( SZC szSource ) const
{
	return ! ((*this) == szSource) ;
}

char BNSTR :: operator [] ( UINT iChar ) const 
{
	assert( iChar < Length() ) ;
	return _sz[iChar] ;
}
	
bool BNSTR :: Vsprintf ( SZC szcFmt, va_list valist )
{
	//  Attempt to "sprintf" the buffer. If it fails, reallocate
	//  a larger buffer and try again.	
	UINT cbMaxNew = ( _cchMax < 50 
				 ? 50
				 : _cchMax ) + 1 ;
	do {
		if ( ! Grow( cbMaxNew ) )
		{
			Reset() ;
			return false ; 
		}
		// Cause buffer to grow by 50% on the next cycle (if necessary)
		cbMaxNew = 0 ;
		
		// Problem: If the buffer is not big enough, _sz may not have a '\0', and Grow()
		// will subsequently barf on the ::strcpy(). Quick fix:

		_sz[_cchMax] = '\0';

	} while ( ::_vsnprintf( _sz, _cchMax, szcFmt, valist ) < 0 ) ; 

	_sz[ _cchMax ] = '\0' ;			//	'cause _vsnprintf, like _strncpy, doesn't always append this

	//  Update the string length member
	_cchStr = ::strlen( _sz ) ;
	return true ;
}

bool BNSTR :: Sprintf ( SZC szcFmt, ... )
{
	va_list	valist;
	va_start( valist, szcFmt );
	
	bool bOk = Vsprintf( szcFmt, valist ) ;
	
	va_end( valist );
	return bOk ;
}

bool BNSTR :: SprintfAppend ( SZC szcFmt, ... ) 
{
	BNSTR strTemp ;
	va_list	valist;
	va_start( valist, szcFmt );
	
	bool bOk = strTemp.Vsprintf( szcFmt, valist ) ;
	va_end( valist );
	
	if ( bOk ) 
		bOk = Suffix( strTemp ) != NULL ;	
	return bOk ;
}
	
	//  Cr/Lf expansion or contraction
bool BNSTR :: ExpandNl () 
{
	UINT iCh ;
	BNSTR str ;
	Transfer( str ) ;
	
	for ( iCh = 0 ; iCh < str.Length() ; iCh++ )
	{   
		char ch = str[iCh];
		if ( ch == '\n' ) 
		{
			if ( Suffix( '\r' ) == NULL ) 
				return false ;	
		}
		if ( Suffix( ch ) == NULL ) 
			return false ;
	}
	return true ;
}

bool BNSTR :: ContractNl ()
{
	UINT iCh ;
	BNSTR str ;
	Transfer( str ) ;
	
	for ( iCh = 0 ; iCh < str.Length() ; iCh++ )
	{
		char ch = str[iCh];
		if ( ch != '\r' ) 
		{
			if ( Suffix( ch ) == NULL ) 
				return false ;
		}
	}
	return true ;
}

static char rgchEsc [][2] = 
{
	{ '\a', 'a'  },
	{ '\b', 'b'  },
	{ '\f', 'f'  },
	{ '\n', 'n'  },
	{ '\r', 'r'  },
	{ '\t', 't'  },
	{ '\v', 'v'  },
	{ '\'', '\'' },
	{ '\"', '\"' },
	{ '\?', '\?' },
	{ '\\', '\\' },
	{ 0,	0	 }
};

bool BNSTR :: ContractEscaped ()
{
	UINT iCh ;
	BNSTR str ;
	Transfer( str ) ;
	
	for ( iCh = 0 ; iCh < str.Length() ; iCh++ )
	{
		char ch = str[iCh];
		if ( ch == '\\' && str.Length() - iCh > 1 )
		{
			char chEsc = 0;
			for ( UINT ie = 0 ; rgchEsc[ie][0] ; ie++ )
			{
				if ( rgchEsc[ie][1] == ch )
					break;
			}
			if ( chEsc = rgchEsc[ie][0] )
			{
				iCh++;
				ch = chEsc;
			}
		}
		if ( Suffix( ch ) == NULL ) 
			return false ;
	}
	return true ;
}

	//  Convert unprintable characters to their escaped versions
bool BNSTR :: ExpandEscaped ()
{
	UINT iCh ;
	BNSTR str ;
	Transfer( str ) ;
	
	for ( iCh = 0 ; iCh < str.Length() ; iCh++ )
	{
		char ch = str[iCh];
		if ( ! isalnum(ch) )
		{
			char chEsc = 0;
			for ( UINT ie = 0 ; rgchEsc[ie][0] ; ie++ )
			{
				if ( rgchEsc[ie][0] == ch )
					break;
			}
			if ( chEsc = rgchEsc[ie][1] )
			{
				if (  Suffix('\\') == NULL )
					return false;
				ch = chEsc;
			}
		}
		if ( Suffix( ch ) == NULL ) 
			return false ;
	}
	return true ;	
}
		
	//  Change all alphabetic characters to the given case
void BNSTR :: UpCase ( bool bToUpper )
{
	if ( bToUpper )
		::strupr( _sz );
	else
		::strlwr( _sz );
}

	//
	//	If the given expression string contains the symbolic name,
	//	reconstruct it with the replacement name.
bool BNSTR :: ReplaceSymName ( 
	SZC szcSymName,
	SZC szcSymNameNew,
	bool bCaseInsensitive )
{   
	SZC szcFound ;		
	int cFound = 0 ;
	UINT cchOffset = 0 ;
	//  Make a working copy of the sought symbolic name
	BNSTR strSym( szcSymName );	
	if ( bCaseInsensitive )
		strSym.UpCase();
	
	do 
	{	
		BNSTR strTemp( Szc() );
		if ( bCaseInsensitive )
			strTemp.UpCase() ;	
		//  Locate the symbolic name in the temporary copy.
		szcFound = ::strstr( strTemp.Szc()+cchOffset, strSym ) ;
		//  If not found, we're done
		if ( szcFound == NULL )
			break ; 
		//  Check to see if it's really a valid token; i.e., it's delimited.
		if (   (   szcFound == strTemp.Szc() 
				|| ! iscsym(*(szcFound-1)) )
			&& (   szcFound >= strTemp.Szc()+strTemp.Length()-strSym.Length()
				|| ! iscsym(*(szcFound+strSym.Length())) )
		   )
		{
			//  Build new string from preceding characters, the new sym name 
			//	  and trailing chars.
			BNSTR strExprNew ;
			UINT cchFound = szcFound - strTemp.Szc() ;
			strExprNew.Assign( Szc(), cchFound );
			strExprNew += szcSymNameNew ;
			cchOffset = strExprNew.Length();
			strExprNew += Szc() + cchFound + strSym.Length() ;
			Assign( strExprNew );
			cFound++ ;
		}
		else
		{
			//  It was imbedded in another token.  Skip over it.
			cchOffset = szcFound - strTemp.Szc() + strSym.Length() ;
		}
	} while ( true );
		
	return cFound > 0 ;
}

	//  Find the next occurrence of the given character in the string;
	//  Return -1 if not found.
INT BNSTR :: Index ( char chFind, UINT uiOffset ) const 
{
	if ( uiOffset >= _cchStr ) 
		return -1 ;
		
	SZC szcFound = ::strchr( _sz, chFind ); 
	return szcFound  
		 ? szcFound - _sz 
		 : -1 ;
}

	//  Convert the string to a floating-point number.
double BNSTR :: Atof ( UINT uiOffset ) const
{
	return uiOffset < _cchStr  
		 ? ::atof( _sz + uiOffset )
		 : -1 ;
}
		

// End of BNSTR.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bnts\bntsdata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bntsdata.cpp
//
//--------------------------------------------------------------------------

//
//	bntsdata.cpp:   Data for Belief Network Troubleshooting DLL
//
#include <windows.h>

#include "bnts.h"

extern "C"
{
	int APIENTRY DllMain( HINSTANCE hInstance, 
				  		  DWORD dwReason, 
						  LPVOID lpReserved ) ;						      								
}

static BOOL init ( HINSTANCE hModule ) 
{
	return TRUE;
}

static void term () 
{
}

int APIENTRY DllMain (
    HINSTANCE hModule,
    DWORD dwReason,
    LPVOID lpReserved )
{
    BOOL bResult = TRUE ;

    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            bResult = init( hModule ) ;
            break ;
        case DLL_PROCESS_DETACH:
            term() ;
            break ;
    }
    return bResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bnts\bnts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bnts.cpp
//
//--------------------------------------------------------------------------

//
//	BNTS.CPP: Belief Network Troubleshooting interface
//
#include <windows.h>

#include "bnts.h"
#include "gmobj.h"
#include "recomend.h"
#include "tchar.h"
/////////////////////////////////////////////////////////////////////////////////////
//	class MBNETDSCTS:  slightly extended version of MBNETDSC to simplify T/S interface
/////////////////////////////////////////////////////////////////////////////////////

class MBNETDSCTS : public MBNETDSC
{
	friend class BNTS;

  public:
	MBNETDSCTS ();
	virtual ~ MBNETDSCTS ();

	void PrepareForTS ();

	const VPGNODEMBND & Vpgndd ()
		{ return _vpgndd; }

	PROPMGR & PropMgr ()
		{ return _propMgr; }

	GOBJMBN_CLIQSET & InferEng ()
	{
		assert( _pCliqueSet );
		return *_pCliqueSet;
	}
	MBNET_RECOMMENDER & MbRecom ()
	{
		assert( _pmbRecom );
		return *_pmbRecom;
	}

	int INode ( int inodeSparse );
	int INode ( ZSREF zsr );

	bool BValid () const
	{
		return _pCliqueSet != NULL
			&& _pmbRecom != NULL;
	}
	bool BDirty () const
		{ return _bDirty; }
	void SetDirty ( bool bSet = true )
		{ _bDirty = bSet; }

  protected:
	void BuildNodeMap ();

  protected:
	VPGNODEMBND _vpgndd;					//  Map to node ptrs based on dense inode
	VINT _vimap;							//  Map to dense inodes based on real (sparse) inodes
	PROPMGR _propMgr;						//  Property management
	GOBJMBN_CLIQSET * _pCliqueSet;			//  The clique tree inference engine
	MBNET_RECOMMENDER * _pmbRecom;			//  The recommender
	bool _bDirty;							//  Do recommendations need to be recalced?

	//  Result fields for API
	ZSTR _zstr;			
	VREAL _vreal;
	VINT _vint;
};

MBNETDSCTS :: MBNETDSCTS ()
	: _propMgr(self),
	_pmbRecom(NULL),
	_pCliqueSet(NULL),
	_bDirty(true)
{
}

MBNETDSCTS :: ~ MBNETDSCTS ()
{
	delete _pmbRecom;
	if ( PInferEngine() )
		DestroyInferEngine();
}

//  Convert from the model's node index to the user's index
int MBNETDSCTS :: INode ( int inodeSparse )
{
	return _vimap[inodeSparse];
}

//  Convert from a string name to the user's node index
int MBNETDSCTS :: INode ( ZSREF zsr )
{
	int inode = INameIndex( zsr );
	if ( inode < 0 )
		return -1;
	return INode(inode);
}

//  Build the bi-directional maps
void MBNETDSCTS :: BuildNodeMap ()
{
	//  Allocate room to store pointers to all the named objects
	_vpgndd.resize( CNameMax() );
	_vimap.resize( CNameMax() );
	//  Find the discrete nodes
	GNODEMBND * pgndd;
	int igndd = 0;
	for ( int i = 0; i < CNameMax(); i++ )
	{
		_vimap[i] = -1;
		GOBJMBN * pgobj = PgobjFindByIndex( i );
		if ( pgobj == NULL )
			continue;
		pgndd = dynamic_cast<GNODEMBND *>( pgobj );
		if ( pgndd == NULL )
			continue;
		_vpgndd[igndd] = pgndd;
		_vimap[i] = igndd++;
	}
	_vpgndd.resize(igndd);
}

void MBNETDSCTS :: PrepareForTS ()
{
	BuildNodeMap();

	CreateInferEngine();

	DynCastThrow( PInferEngine(), _pCliqueSet);
	_pmbRecom = new MBNET_RECOMMENDER( *_pCliqueSet );
}

//  CTOR and DTOR
BNTS :: BNTS ()
	:_pmbnet(NULL),
	_inodeCurrent(-1)
{
}

BNTS :: ~ BNTS ()
{
	Clear();
}

void BNTS :: Clear ()
{
	delete _pmbnet;
	_pmbnet = NULL;
	_inodeCurrent = -1;
}

void BNTS :: ClearArrays ()
{
	if ( ! _pmbnet )
		return;
	Mbnet()._vreal.resize(0);
	Mbnet()._vint.resize(0);
}

ZSTR & BNTS :: ZstrResult ()
{
	return Mbnet()._zstr;
}

void BNTS :: ClearString ()
{
	ZstrResult() == "";
}

MBNETDSCTS & BNTS :: Mbnet()
{
	assert( _pmbnet );
	return *_pmbnet;
}

const MBNETDSCTS & BNTS :: Mbnet() const
{
	assert( _pmbnet );
	return *_pmbnet;
}

bool BNTS :: BValidNet () const
{
	return _pmbnet != NULL
		&& Mbnet().BValid();
}

bool BNTS :: BValidNode () const
{
	MBNETDSCTS & mbnts = const_cast<MBNETDSCTS &>(Mbnet());
	return BValidNet()
		&& _inodeCurrent >= 0
		&& _inodeCurrent < mbnts.Vpgndd().size();
}


////////////////////////////////////////////////////////////////////
//  Model-level queries and functions
////////////////////////////////////////////////////////////////////
	//  Load and process a DSC-based model
BOOL BNTS :: BReadModel ( SZC szcFn, SZC szcFnError )
{
	BOOL bResult = FALSE;;
	try
	{

		Clear();
		_pmbnet = new MBNETDSCTS;
		assert( _pmbnet );
		
		FILE * pfErr = szcFnError
					 ? fopen( szcFnError, "w" )
					 : NULL;

		if ( ! Mbnet().BParse( szcFn, pfErr ) )
		{
			Clear();
		}
		else
		{
			Mbnet().PrepareForTS();
			bResult = TRUE;
		}
	}
	catch ( GMException & )
	{
	}
	return bResult;
}

	//  Return the number of (pre-expansion) nodes in the model
int BNTS :: CNode ()
{
	if ( ! BValidNet() )
		return -1;
	return Mbnet().Vpgndd().size();
}

	//  Return our dense node index given a node name
int BNTS :: INode ( SZC szcNodeSymName )
{
	GOBJMBN * pgobj = Mbnet().Mpsymtbl().find( szcNodeSymName );
	if ( pgobj == NULL )
		return -1;
	ZSREF zsrNodeSymName = Mbnet().Mpsymtbl().intern( szcNodeSymName );
	return Mbnet().INode( zsrNodeSymName );
}
	//  Return TRUE if the state of information is impossible
BOOL BNTS :: BImpossible ()
{
	if ( ! BValidNet() )
		return FALSE;
	return Mbnet().InferEng().BImpossible();
}

	//  Return a property item string from the network
BOOL BNTS :: BGetPropItemStr (
	LTBNPROP & ltprop,
	SZC szcPropType,
	int index,
	ZSTR & zstr )
{
	ZSREF zsrPropName = Mbnet().Mpsymtbl().intern( szcPropType );
	PROPMBN * pprop = ltprop.PFind( zsrPropName );
	if ( pprop == NULL )
		return FALSE;		//  Not present in network property list
	if ( (pprop->FPropType() & fPropString) == 0 )
		return FALSE;		//  Not a string
	if ( index >= pprop->Count() )
		return FALSE;		//  Out of range
	zstr = pprop->Zsr( index );
	return true;
}

	//  Return a property item number from the network
BOOL BNTS :: BGetPropItemReal (
	LTBNPROP & ltprop,
	SZC szcPropType,
	int index,
	double & dbl )
{
	ZSREF zsrPropName = Mbnet().Mpsymtbl().intern( szcPropType );
	PROPMBN * pprop = ltprop.PFind( zsrPropName );
	if ( pprop == NULL )
		return FALSE;		//  Not present in network property list
	if ( (pprop->FPropType() & fPropString) != 0 )
		return FALSE;		// Not a number
	if ( index >= pprop->Count() )
		return FALSE;		//  Out of range
	dbl = pprop->Real(index);
	return true;
}

BOOL BNTS :: BNetPropItemStr ( SZC szcPropType, int index)
{
	return BGetPropItemStr( Mbnet().LtProp(),
							szcPropType,
							index,
							ZstrResult() );
}

BOOL BNTS :: BNetPropItemReal ( SZC szcPropType, int index, double & dbl )
{
	return BGetPropItemReal( Mbnet().LtProp(),
							 szcPropType, index,
							 dbl );
}

////////////////////////////////////////////////////////////////////
//  Operations involving the "Currrent Node": call NodeSetCurrent()
////////////////////////////////////////////////////////////////////
	//  Set the current node for other calls
BOOL BNTS :: BNodeSetCurrent( int inode )
{
	_inodeCurrent = inode;
	if ( ! BValidNode() )
	{
		_inodeCurrent = -1;
		return FALSE;
	}
	return TRUE;
}

	//	Get the current node
int BNTS :: INodeCurrent ()
{
	return _inodeCurrent;
}

	//	Return the label of the current node
ESTDLBL BNTS :: ELblNode ()
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return ESTDLBL_other;	
	return Mbnet().MbRecom().ELbl( *pgndd );
}

	//  Return the number of discrete states in the current node
int BNTS :: INodeCst ()
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return -1;	
	return pgndd->CState();
}

	//  Set the state of a node
BOOL BNTS :: BNodeSet ( int istate, bool bSet  )
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return FALSE;	
	Mbnet().SetDirty();
	int cst = pgndd->CState();
	if ( cst <= istate )
		return FALSE;

	CLAMP clamp( true, istate, istate >= 0 );

	Mbnet().MbRecom().EnterEvidence( pgndd, clamp, bSet ) ;
	return TRUE;
}

	//  Return the state of a node
int  BNTS :: INodeState ()
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return FALSE;	

	CLAMP clamp;

	Mbnet().InferEng().GetEvidence( pgndd, clamp ) ;
	return clamp.BActive()
		 ? clamp.Ist()
		 : -1;
}

	//	Return the name of a node's state
void BNTS :: NodeStateName ( int istate )
{
	ClearString();
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return;	
	if ( istate >= pgndd->CState() )
		return;
	ZstrResult() = pgndd->VzsrStates()[istate];	
}

	//  Return the symbolic name of the node
void BNTS :: NodeSymName ()
{
	ClearString();
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return;
	ZstrResult() = pgndd->ZsrefName();
}

	//  Return the full name of the node
void BNTS :: NodeFullName ()
{
	ClearString();
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return;	

	ZstrResult() = pgndd->ZsFullName();		
}

GNODEMBND * BNTS :: Pgndd ()
{
	if ( ! BValidNode() )
		return NULL;	
	GNODEMBND * pgndd = Mbnet().Vpgndd()[_inodeCurrent];
	assert( pgndd );
	return pgndd;
}

	//  Return a property item string from the node
BOOL BNTS :: BNodePropItemStr ( SZC szcPropType, int index )
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return FALSE;	

	return BGetPropItemStr( pgndd->LtProp(),
							szcPropType,
							index,
							ZstrResult() );
}

	//  Return a property item number from the node
BOOL BNTS :: BNodePropItemReal ( SZC szcPropType, int index, double & dbl )
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return FALSE;	
	return BGetPropItemReal( pgndd->LtProp(), szcPropType, index, dbl );
}

	//  Return the belief for a node
void BNTS :: NodeBelief ()
{
	ClearArrays();

	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return;	
	int cState = pgndd->CState();
	MDVCPD mdvBel;
	Mbnet().InferEng().GetBelief( pgndd, mdvBel );
	assert( cState == mdvBel.size() );
	VREAL & vr = Mbnet()._vreal;
	vr.resize( cState );
	for ( int i = 0; i < cState; i++ )
	{
		vr[i] = mdvBel[i];
	}
}

	//  Return the recommended nodes and, optionally, their values
BOOL BNTS :: BGetRecommendations ()
{
	ClearArrays();

	if ( ! BValidNet() )
		return FALSE;

	if ( Mbnet().BDirty() )
	{
		Mbnet().SetDirty( false );
		//  Compute the recommendations
		try
		{
			Mbnet().MbRecom()();	
		}
		catch ( GMException & ex )
		{
			BOOL bResult = FALSE;
			switch ( ex.Ec() )
			{
				case EC_VOI_PROBDEF_ABNORMAL:
					// This is an expected condition
					bResult = TRUE;
					break;
				default:
					break;
			}
			return bResult;
		}
	}
	const VZSREF & vzsrNodes = Mbnet().MbRecom().VzsrefNodes();
	const VLREAL & vlrUtil = Mbnet().MbRecom().VlrValues();

	VREAL & vr = Mbnet()._vreal;
	VINT & vi = Mbnet()._vint;
	vr.resize( vzsrNodes.size() );
	vi.resize( vzsrNodes.size() );

	for ( int i = 0; i < vzsrNodes.size(); i++ )
	{
		int inode = Mbnet().INode( vzsrNodes[i] );
		assert( inode >= 0 ) ;
		vi[i] = inode;
		vr[i] = vlrUtil[i];
	}	
	return TRUE;
}

SZC BNTS :: SzcResult () const
{
	return Mbnet()._zstr.Szc();
}

const REAL * BNTS :: RgReal () const
{
	return & Mbnet()._vreal[0];
}

const int * BNTS :: RgInt () const
{
	return & Mbnet()._vint[0];
}

int BNTS :: CReal () const
{
	return Mbnet()._vreal.size();
}

int BNTS :: CInt () const
{
	return Mbnet()._vint.size();
}

// End of BNTS.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bnts\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by bnts.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\bn\bnts\bnts.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bnts.h
//
//--------------------------------------------------------------------------

//
//	bnts.h:  Definitions for the Belief Network Troubleshooting object.
//
#ifndef _BNTS_H_
#define _BNTS_H_

//  BN system inclusions
#include "enumstd.h"		// Standard enumeration declarations for the BN system

// 'BNTS_EXPORT' should only be defined in the project that builds the DLL
#ifdef	BNTS_EXPORT
	//  We're building the DLL (exporting the class)
	#define	BNTS_RESIDENT __declspec(dllexport)
#else
	//  We're using the DLL (importing the class)
	#define	BNTS_RESIDENT __declspec(dllimport)
#endif

//  Forward declaration of internal belief network class
class MBNETDSCTS;										//  the encapsulated BN class
class GNODEMBND;										//  Discrete nodes
class LTBNPROP;											//  Property list
class ZSTR;

typedef const char * SZC;								//  simple alias
typedef char * SZ;
typedef double REAL;

////////////////////////////////////////////////////////////////////////////////////////////
//
//	class BNTS: the belief network troubleshooter
//
////////////////////////////////////////////////////////////////////////////////////////////
class BNTS_RESIDENT BNTS
{	
  public:
	//  CTOR and DTOR
	BNTS ();
	~ BNTS ();

	////////////////////////////////////////////////////////////////////
	//  Model-level queries and functions
	////////////////////////////////////////////////////////////////////
		//  Load and process a DSC-based model
	BOOL BReadModel ( SZC szcFn, SZC szcFnError = NULL );
		//  Return the number of (pre-expansion) nodes in the model
	int CNode ();
		//  Return the recommended nodes and, optionally, their values
	BOOL BGetRecommendations ();
		//  Return TRUE if the state of information is impossible
	BOOL BImpossible ();
		//  Return a property item string from the network
	BOOL BNetPropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the network
	BOOL BNetPropItemReal ( SZC szcPropType, int index, double & dbl );

	////////////////////////////////////////////////////////////////////
	//  Operations involving the "Currrent Node": call NodeSetCurrent()
	////////////////////////////////////////////////////////////////////
		//  Set the current node for other calls
	BOOL BNodeSetCurrent( int inode );
		//	Get the current node
	int INodeCurrent ();
		//  Return the index of a node given its symbolic name
	int INode ( SZC szcNodeSymName );	
		//	Return the label of the current node
	ESTDLBL ELblNode ();
		//  Return the number of discrete states in the current node
	int INodeCst ();
		//  Set the state of a node; use -1 to uninstatiate
	BOOL BNodeSet ( int istate, bool bSet = true );
		//  Return the state of a node
	int  INodeState ();
		//	Return the name of a node's state
	void NodeStateName ( int istate );
		//  Return the symbolic name of the node
	void NodeSymName ();
		//  Return the full name of the node
	void NodeFullName ();
		//  Return a property item string from the node
	BOOL BNodePropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the node
	BOOL BNodePropItemReal ( SZC szcPropType, int index, double & dbl );
		//  Return the belief for a node
	void NodeBelief ();
		//  Return true if the network is loaded and correct
	bool BValidNet () const;
		//  Return true if the current node is set
	bool BValidNode () const;
		//  Discard the model and all components
	void Clear();

	////////////////////////////////////////////////////////////////////
	//  Accessors to the function result information	
	////////////////////////////////////////////////////////////////////
	SZC SzcResult () const;					//  String answer		
	const REAL * RgReal () const;			//  Array of reals		
	const int * RgInt () const;				//  Array of Integers	
	int CReal () const;						//  Count of reals		
	int CInt () const;						//  Count of integers

  protected:
	MBNETDSCTS * _pmbnet;			//  The T/S DSC belief network
	int _inodeCurrent;				//  The current node

  protected:
	MBNETDSCTS & Mbnet();
	const MBNETDSCTS & Mbnet() const;
	GNODEMBND * Pgndd ();
	BOOL BGetPropItemStr ( LTBNPROP & ltprop, 
						   SZC szcPropType, 
						   int index, 
						   ZSTR & zstr );
	BOOL BGetPropItemReal ( LTBNPROP & ltprop, 
							SZC szcPropType, 
							int index, 
							double & dbl );
	void ClearArrays ();
	void ClearString ();
	ZSTR & ZstrResult ();
};

#endif // _BNTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgts.h ===
//
// MODULE: APGTS.H
//
// PURPOSE: Main header file for DLL
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//			further work by Richard Meadows (RWM), Joe Mabel, Oleg Kalosha
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM/OK+	Local Version for NT5
//

//#define __DEBUG_HTTPQUERY_ 1



//-----------------------
// !!! NOTE !!!
// THIS DEFINE IS USED TO CREATE "Single Thread" VERSION FOR DEVELOPMENT
// MAKE SURE THIS IS COMMENTED OUT FOR RELEASE VERSION!
//
// Purpose of Single Thread Version: To allow noncaching of DLL to allow easy
// update of dll w/o dealing with shutting down server/starting it up.
//
#define SINGLE_THREAD_VER
//-----------------------

// for belief networks
#define MAXBNCFG	1	// An allocation unit, not really relevant here in the Local Troubleshooter,
						// because (unlike the Online Troubleshooter) this is _not_ a server which 
						// handles multiple troubleshooting networks simultaneously.

//
#define MAXBUF	256 * 2	// length of text buffers used for filenames and other purposes
						// *2 is because we need a larger buffer for the MBCS strings.
#define STRBUFSIZE 258	// CString buffer size for calling BNTS functions.

#define CHOOSE_TS_PROBLEM_NODE	_T("TShootProblem")
#define TRY_TS_AT_MICROSOFT_SZ	_T("TShootGotoMicroSoft")
#define TRY_TS_AT_MICROSOFT_ID	2020

// Note: put no trailing slashes on this...
#define TSREGKEY_MAIN	_T("SOFTWARE\\Microsoft\\TShoot")
#define TSREGKEY_TL		_T("SOFTWARE\\Microsoft\\TShoot\\TroubleshooterList")
#define TSREGKEY_SFL	_T("SOFTWARE\\Microsoft\\TShoot\\SupportFileList")

#define FULLRESOURCE_STR	_T("FullPathToResource")
#define LOCALHOST_STR		_T("LocalHost")

#define TS_REG_CLASS		_T("Generic_Troubleshooter_DLL")

#define REG_EVT_PATH		_T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application")
#define REG_EVT_MF			_T("EventMessageFile")
#define REG_EVT_TS			_T("TypesSupported")

#define REGSZ_TSTYPES		_T("TroubleShooterList")
#define FRIENDLY_NAME		_T("FName")
#define FRIENDLY_PATH	    _T("Path")

// reg class (optional)
#define TSLCL_REG_CLASS			_T("LOCALTS")

// value names under file type
#define TSLCL_FVERSION			_T("Version")
#define TSLCL_FMAINEXT			_T("FExtension")

// DSC file extensions.
#define DSC_COMPRESSED		_T(".dsz")
#define DSC_UNCOMPRESSED	_T(".dsc")
#define DSC_DEFAULT			_T(".dsz")
#define CHM_DEFAULT			_T(".chm")
#define HTI_DEFAULT			_T(".hti")


// max search terms to send to index server
#define MAX_TERMS_PER_SEARCH		8

// maximum cache for belief networks
#define MAXCACHESIZE				200

#define evtype(e) ( 1 << (3 - ((e >> 30))))

//------------- Growable string object ---------------//

#define CSTRALLOCGRAN	4096

//------------- Log File ---------------

#define LOGFILEPREFACE			_T("gt")
#define MAXLOGSBEFOREFLUSH		5
#define MAXLOGSIZE				1000

//------------- Generic Object list ---------------
// This really should have been a template class, but when it was first written that
// technology was not available.  VOID *m_tlist should really be a pointer to the type
// specified in this use of the template.
class COBList {
public:
	COBList(UINT incsize);
	~COBList();
	DWORD GetStatus();
	VOID *AddItemSpace(UINT itemsize);	// caller must pass in token size in bytes,
										// because this class doesn't know.
	VOID *GetList();
	UINT GetCount();
	VOID IncrementCount();

protected:
	UINT m_tokencount;			// number of tokens actually used.  Mostly managed from outside
								// the class by calls to IncrementCount().  Grows monotonically.
	UINT m_tokenlistsize;		// number of "chunks" we've allocated to the list of tokens
	UINT m_incsize;				// size of a chunk (number of tokens)
	VOID *m_tlist,		// points to array of "tokens" (e.g. WORD_TOKEN).  Type here really
						// ought to be argument to a template.
		 *m_memerror;	// after a memory reallocation failure, this takes on the old value
						// of m_tlist so the caller, aware of what the underlying type is,
						// can clean it up.
	DWORD m_dwErr;		// NOTE: once this is set nonzero, it can never be cleared, effectively
						// disabling AddItemSpace.
};

//------------- Word List Manager ---------------
//	Not currently used in Local TS.  Commented-out code here from Online TS.
/*

typedef struct _WORD_TOKEN {
	TCHAR *token;		// pointer to the keyword (or other) text
						// >> what else besides keywords are typical uses?
	UINT state;			// >>> (a guess JM 10/24/97:)state number: small integer indicating 
						//	state of a node.  *token is the name of this state.
	BOOL bDiscard;		// >>> what does it mean to "discard" a token?
	BOOL bKeyword;		// keyword >>> vs. what?
} WORD_TOKEN;

//
class CWordList {
public:
	CWordList(BOOL bSorted, BOOL bAddDuplicates, BOOL bExceptCheck);
	~CWordList();
	DWORD GetStatus();

	VOID ReadWordsFromFile(TCHAR *filepath);

	WORD_TOKEN *FindWord(TCHAR *token, UINT state, BOOL bDiscard);
	WORD_TOKEN *FindWordContained(TCHAR *token, UINT *puStartOff);

	BOOL AddWord(TCHAR *token, UINT state, BOOL bDiscard, BOOL bKeyword);
	VOID ScanInString(CWordList *pWL, const TCHAR *txtptr, UINT state, BOOL bDiscard);
	VOID ScanInKeywordString(CWordList *pWL, const TCHAR *txtptr, UINT state, BOOL bDiscard);
	BOOL ProcessToken(CWordList *pWL, TCHAR *token, UINT state, BOOL bDiscard, BOOL bKeyword);
	
	VOID SetOffset(UINT uOff, BOOL bSkipDiscard);
	UINT GetOffset();
	WORD_TOKEN *GetAtCurrOffset();
	VOID IncCurrOffset(BOOL bSkipDiscard);
	
	BOOL IsValidChar(int ch);
	BOOL IsTokenChar(INT ch);

	UINT CountNonDiscard();
	VOID OrderContents(UINT uMaxCount);

	VOID DumpContents(UINT nodeid);

protected:
	void CleanStr(TCHAR *str);
	VOID SkipDiscards();

protected:
	// The text associated with an item (indexed by i) in the list is 
	// *((static_cast<WORD_TOKEN *>(m_list->m_tlist))[i].token)
	// For simplicity, the following comments refer to that as "TOKEN" 
	COBList *m_list;
	DWORD m_dwErr;			// NOTE: once this is set nonzero, it can never be cleared.
	UINT m_uOff;			// an index into m_list->m_tlist.  "Current Offset"
	BOOL m_bSorted,			// if true, m_list->m_tlist is sorted by alphabetical order on 
							// TOKEN
		 m_bAddDuplicates,	// TRUE ==> may have two or more identical TOKEN values.
		 m_bExceptCheck;	// (>>> conjecture JM 10/28/97) do not allow words from 
							// ARTICLES.TXT in this list
};

*/
//------------- Node-Word List Manager ---------------
//	Not currently used in Local TS.  Commented-out code here from Online TS.
/*
typedef struct _WNODE_ELEM {
	UINT nodeid;
	CWordList *words;		// a word-list associated with this node, >>>but just what is
							// in this word list?
} WNODE_ELEM;

//
class CWNodeList {
public:
	CWNodeList();
	~CWNodeList();
	DWORD GetStatus();

	WNODE_ELEM *FindNode(UINT nodeid);
	CWordList *AddNode(UINT nodeid);

	UINT GetNodeCount();
	WNODE_ELEM *GetNodeAt(UINT uOffset);

	VOID DumpContents();

protected:
	COBList *m_list;
	DWORD m_dwErr;		// NOTE: once this is set nonzero, it can never be cleared.

};
*/

//------- cache classes ------------
//

typedef struct _BN_CACHE_ITEM {
	UINT uNodeCount,	// number of items in array pointed to by uName (& also uValue)
		 uRecCount;		// number of items in array pointed to by uRec
	UINT *uName;		// array of Node IDs from a single belief network. Typically not all
						//	the nodes in the belief network, just the ones on which we
						//	have state data from the user.
	UINT *uValue;		// array of States.  These are in 1-1 correspondence to *uName.
						//	uValue is a state # within the states of the corresponding node.
	UINT *uRec;			// array of Node IDs. Only the first one really matters because we will
						//	only give one recommendation at a time.  This is effectively an 
						//	output we give on a perfect match to the network state expressed
						//	by arrays *uName and *uValue.
} BN_CACHE_ITEM;

//
//

class CBNCacheItem
{
public:
	CBNCacheItem(const BN_CACHE_ITEM *, CBNCacheItem*);
	~CBNCacheItem();

	BN_CACHE_ITEM m_CItem;

	CBNCacheItem*	m_pcitNext;
	
	DWORD GetStatus();

protected:
	DWORD m_dwErr;	// NOTE: once this is set nonzero, it can never be cleared.
};

//
//

class CBNCache
{
public:
	CBNCache();
	~CBNCache();
	BOOL AddCacheItem(const BN_CACHE_ITEM *);
	BOOL FindCacheItem(const BN_CACHE_ITEM *pList, UINT& count, UINT Name[]);
	UINT CountCacheItems() const;
	DWORD GetStatus();
	
protected:

protected:
	CBNCacheItem*	m_pcit;		// points to most recently used cache item, which is head
								// of a singly linked list
	DWORD m_dwErr;				// NOTE: once this is set nonzero, it can never be cleared.
};


//------- index server search file -----------
//	Not currently used in Local TS.  Commented-out code here from Online TS.
/*
class CSearchForm {
public:
	CSearchForm(TCHAR *filepath);
	~CSearchForm();

	DWORD Initialize();
	DWORD Reload();

	TCHAR *GetEncodedSearchString();
	TCHAR *GetHTMLSearchString();

	static void ToURLString(TCHAR *ptr, TCHAR *tostr);
	BOOL IsAND();

protected:
	VOID Destroy();

	DWORD HTMLFormToURLEncoded(TCHAR *szStr, CString *pCOutStr);  // Note arg type is our CString, not MFC - JM 10/97
	static DWORD DecodeInputAttrib(TCHAR *str, TCHAR **ptrtype, TCHAR **ptrname, TCHAR **ptrvalue);
	
protected:
	CString 	// Note this is our CString, not MFC - 10/97
		*m_pCOutStr,	// URL encoded string derived from contents of BES file indicated by 
						// m_filepath, and sufficient to reconstruct that BES file
		*m_pCFormStr;	// Raw copy of entire contents of BES file indicated by m_filepath
	TCHAR m_filepath[MAXBUF];  // fully qualified filename of a BES file
	BOOL m_bIsAND;		// Normally TRUE.  Set FALSE if we encounter " OR" in the search string
};
*/

//------- property types -----------
//

// Node Properties ---------------------------------------
#define H_ST_NORM_TXT_STR	_T("HStNormTxt")	// text for radio button for "normal" state
												// (state 0)
#define H_ST_AB_TXT_STR		_T("HStAbTxt")		// text for radio button for "abnormal" state
												// (state 1)
#define H_ST_UKN_TXT_STR	_T("HStUknTxt")		// text for radio button for "no state" (e.g.
												// "I don't want to answer this right now"
												// (pseudo state 102)
#define H_NODE_HD_STR		_T("HNodeHd")		// Header text for this node
#define H_NODE_TXT_STR		_T("HNodeTxt")		// Body text for this node
#define H_NODE_DCT_STR		_T("HNodeDct")		// Special text to indicate that this node
												//	was sniffed as being in an abnormal 
												//	state.  Only relevant for a fixable node
												//	that can be sniffed.
#define H_PROB_TXT_STR		_T("HProbTxt")		// Only relevant to problem nodes.  Problem 
												//	text (e.g. "Gazonk is broken.")
#define H_PROB_SPECIAL_STR	_T("HProbSpecial")	// If this contains the string "hide", then
												//	this problem is never actually shown on a 
												//	problem page

// Network Properties -------------------------------------
#define H_PROB_HD_STR		_T("HProbHd")		// Header text for problem page

#define	HTK_BACK_BTN		_T("HTKBackBtn")	// Text for "BACK" button
#define	HTK_NEXT_BTN		_T("HTKNextBtn")	// Text for "NEXT" button
#define	HTK_START_BTN		_T("HTKStartBtn")	// Text for "START OVER" button

#define HX_SER_HD_STR		_T("HXSERHd")		// Header text for server page
#define HX_SER_TXT_STR		_T("HXSERTxt")		// Body text for server page
#define HX_SER_MS_STR		_T("HXSERMs")		// NOT CURRENTLY USED 3/98.  For service page,
												//	offers option of downloading a TS from
												//	Microsoft's site.
#define HX_SKIP_HD_STR		_T("HXSKIPHd")		// Header for "skip" page (e.g. "This 
												//	troubleshooter was unable to solve your
												//	problem.")
#define HX_SKIP_TXT_STR		_T("HXSKIPTxt")		// Text for "skip" page (e.g."Some questions 
												//	were skipped.  Try providing answers..."
#define HX_SKIP_MS_STR		_T("HXSKIPMs")		// NOT CURRENTLY USED 3/98.  For skip page,
												//	offers option of downloading a TS from
												//	Microsoft's site.
#define HX_SKIP_SK_STR		_T("HXSKIPSk")		// for "skip" page (e.g. "I want to see the 
												//	questions that I skipped.")

#define HX_IMP_HD_STR		_T("HXIMPHd")		// Header text for "impossible" page
#define HX_IMP_TXT_STR		_T("HXIMPTxt")		// Body text for "impossible" page

#define HX_FAIL_HD_STR		_T("HXFAILHd")		// Header text for "fail" page
#define HX_FAIL_TXT_STR		_T("HXFAILTxt")		// Body text for "fail" page
#define HX_FAIL_NORM_STR	_T("HXFAILNorm")	// NOT CURRENTLY USED 3/98.
#define HX_BYE_HD_STR		_T("HXBYEHd")		// Header text for "Bye" (success) page
#define HX_BYE_TXT_STR		_T("HXBYETxt")		// Body text for "Bye" (success) page
#define HX_SNIFF_AOK_HD_STR		_T("HXSnOkHd")	// Header text for "Sniff AOK" page (page 
												//	you hit when there is nothing at all to 
												//	recommend for a problem because sniffing
												//	says every single node on the path is OK)
												// If missing, "fail" page header should be
												//	used
#define HX_SNIFF_AOK_TXT_STR	_T("HXSnOkTxt")	// Body text for "Sniff AOK" page 
												// If missing, "fail" page body should be
												//	used



//------------- Event Handling ---------------

// event name (goes under application)

#define REG_EVT_ITEM_STR	_T("APGTS")

// event prototypes
VOID ReportWFEvent(LPTSTR string1,LPTSTR string2,LPTSTR string3,LPTSTR string4,DWORD eventID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtscac.cpp ===
//
// MODULE: APGTSCAC.CPP
//
// PURPOSE: Belief network caching support classes
// Each CBNCacheItem object effectively corresponds to a possible state of the belief 
//	network, and provides a next recommended action. More specifically, data member 
//	m_CItem provides 
//	- an array of nodes and a corresponding array of their states.  Taken together, 
//		these represent a state of the network
//	- an array of nodes, which constitute the recommendations as to what to try next
//		based on this state of the network.  The first node in the list is the node we
//		will display; if the user says "don't want to try this now" we'd go on to the next, 
//		etc.
// These are collected into a CBNCache object, so if you get a hit on one of these network
//	states, you can get your recommendation without needing the overhead of hitting BNTS.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 10-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "apgts.h"
#include "ErrorEnums.h"
//
//
CBNCacheItem::CBNCacheItem(const BN_CACHE_ITEM *pItem, CBNCacheItem* pcitNext)
{
	m_dwErr = 0;

	memcpy(&m_CItem, pItem, sizeof (BN_CACHE_ITEM));
	
	m_CItem.uName = (UINT *)malloc(m_CItem.uNodeCount * sizeof (UINT));
	m_CItem.uValue = (UINT *)malloc(m_CItem.uNodeCount * sizeof (UINT));
	m_CItem.uRec = (UINT *)malloc(m_CItem.uRecCount * sizeof (UINT));

	if (m_CItem.uName && m_CItem.uValue && m_CItem.uRec) {
		memcpy(m_CItem.uName, pItem->uName, m_CItem.uNodeCount * sizeof (UINT));
		memcpy(m_CItem.uValue, pItem->uValue, m_CItem.uNodeCount * sizeof (UINT));
		memcpy(m_CItem.uRec, pItem->uRec, m_CItem.uRecCount * sizeof (UINT));
	}
	else
		m_dwErr = EV_GTS_ERROR_CAC_ALLOC_MEM;

	m_pcitNext = pcitNext;
};

//
//
CBNCacheItem::~CBNCacheItem()
{
	if (m_CItem.uName)
		free(m_CItem.uName);
		
	if (m_CItem.uValue)
		free(m_CItem.uValue);
	
	if (m_CItem.uRec) 
		free(m_CItem.uRec);
};

//
//
DWORD CBNCacheItem::GetStatus()
{
	return m_dwErr;
}

//
//
CBNCache::CBNCache()
{
	m_pcit = NULL;
	m_dwErr = 0;
}

//
//
CBNCache::~CBNCache()
{
	CBNCacheItem *pcit, *pti;

	pcit = m_pcit;
	while (pcit) {
		pti = pcit;
		pcit = pcit->m_pcitNext;
		delete pti;
	}
}

//
//
DWORD CBNCache::GetStatus()
{
	return m_dwErr;
}

// NOTE: Must call FindCacheItem first and not call this 
// function to prevent duplicate records from going into cache
//
BOOL CBNCache::AddCacheItem(const BN_CACHE_ITEM *pList)
{
	CBNCacheItem *pcit = new CBNCacheItem(pList, m_pcit);

	if (pcit == NULL)
		m_dwErr = EV_GTS_ERROR_CAC_ALLOC_ITEM;
	else if (!m_dwErr)
		m_dwErr = pcit->GetStatus();

	return (m_pcit = pcit) != NULL;
}

// Find match, return false if not found, otherwise true and fills 
// structure with found item
// Also move matched up to top and remove last item if too many
//
BOOL CBNCache::FindCacheItem(const BN_CACHE_ITEM *pList, UINT& count, UINT Name[])
{
	UINT uSize;
	CBNCacheItem *pcit, *pcitfirst, *pcitlp;

	uSize = pList->uNodeCount * sizeof (UINT);

	pcitlp = pcitfirst = pcit = m_pcit;

	for (; pcit; pcit = pcit->m_pcitNext) 
	{
		if (pList->uNodeCount == pcit->m_CItem.uNodeCount) 
		{
			if (!memcmp(pList->uName, pcit->m_CItem.uName, uSize) &&
				!memcmp(pList->uValue, pcit->m_CItem.uValue, uSize)) 
			{
				// check not at top already
				if (pcit != pcitfirst) 
				{
					// remove from list
					while (pcitlp) {
						if (pcitlp->m_pcitNext == pcit) 
						{
							pcitlp->m_pcitNext = pcitlp->m_pcitNext->m_pcitNext;
							break;
						}
						pcitlp = pcitlp->m_pcitNext;
					}

					// move to top
					m_pcit = pcit;
					pcit->m_pcitNext = pcitfirst;
				}
				break;
			}
		}
	}

	// count items
	if (CountCacheItems() > MAXCACHESIZE) 
	{	
		// remove last item
		
		if ((pcitlp = m_pcit) != NULL) 
		{
			if (pcitlp->m_pcitNext) 
			{
				while (pcitlp) 
				{
					if (pcitlp->m_pcitNext->m_pcitNext == NULL) 
					{
						delete pcitlp->m_pcitNext;
						pcitlp->m_pcitNext = NULL;
						break;
					}
					pcitlp = pcitlp->m_pcitNext;
				}
			}
		}
	}

	if (pcit == NULL)
		return FALSE;
	
	count = pcit->m_CItem.uRecCount;
	memcpy(Name, pcit->m_CItem.uRec, count * sizeof (UINT));

	return TRUE;
}

// Get count of items in cache
//
UINT CBNCache::CountCacheItems() const
{
	UINT uCount = 0;

	for (CBNCacheItem* pcit = m_pcit; pcit; pcit = pcit->m_pcitNext, uCount++)
	{ 
		// do nothing: action is all in condition of for-loop
	}
	
	return uCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtscfg.cpp ===
//
// MODULE: APGTSCFG.CPP
//
// PURPOSE: Old commment says "Reads in ini file configuration" but that's not what this does
//	>>> an up-to-date description would be nice.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

//#include "windows.h"
#include "stdafx.h"
#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include "TSHOOT.h"

#include <memory.h>

#include "chmread.h"
//
//
CDBLoadConfiguration::CDBLoadConfiguration()
{
	m_cfg.api.pAPI = NULL;
	m_cfg.api.pTemplate = NULL;

	InitializeToDefaults();

	return;
}

VOID CDBLoadConfiguration::ResetTemplate()
{
	delete m_cfg.api.pTemplate;
	m_cfg.api.pTemplate = new CHTMLInputTemplate(m_cfg.api.szFilepath[BNOFF_HTI]);
	m_cfg.api.pTemplate->Initialize(m_cfg.api.szResPath, m_cfg.api.strFile[BNOFF_HTI]);
	return;
}
//
//
CDBLoadConfiguration::CDBLoadConfiguration(HMODULE hModule, LPCTSTR szValue)
{
	Initialize(hModule, szValue);
	return;
}
//
//
void CDBLoadConfiguration::Initialize(HMODULE hModule, LPCTSTR szValue)
{
	DWORD dwRErr;
	TCHAR temp[MAXBUF];

	_tcscpy(temp,_T(""));

	// do all setting of variables in constructor!
	InitializeToDefaults();

	ProcessEventReg(hModule);

	CreatePaths(szValue);

	InitializeSingleResourceData(szValue);

	dwRErr = CreateApi(temp);
	if (dwRErr) {
		ReportWFEvent(	_T("[apgtscfg]"), //Module Name
						_T("[CDBLoadConfiguration]"), //event
						_T("(A)"),
						temp,
						dwRErr ); 
	}
}

void CDBLoadConfiguration::SetValues(CHttpQuery &httpQ)
{
	int value;
	BCache *pAPI = m_cfg.api.pAPI;
	if(pAPI)
		if (httpQ.GetValue1(value))
			pAPI->AddValue(value);
	return;
}

//
//
CDBLoadConfiguration::~CDBLoadConfiguration()
{
	DWORD j;
	if (m_dwFilecount > 0)
		DestroyApi();

	if (m_cfg.pHandles != NULL) {
		for (j = 0; j < m_cfg.dwHandleCnt; j++) 
			if (m_cfg.pHandles[j] != NULL)
				CloseHandle(m_cfg.pHandles[j]);
		
		delete [] m_cfg.pHandles;
	}
}

// Call in constructor only!
//
VOID CDBLoadConfiguration::InitializeToDefaults()
{
	m_dwErr = 0;
	m_bncfgsz = MAXBNCFG;

	_tcscpy(m_szResourcePath, DEF_FULLRESOURCE);

	ClearCfg(0);
	m_cfg.pHandles = NULL;
	m_cfg.dwHandleCnt = 0;

	_tcscpy(m_nullstr, _T(""));

	m_dwFilecount = 0;
}

VOID CDBLoadConfiguration::InitializeSingleResourceData(LPCTSTR szValue)
{
	LoadSingleTS(szValue);
	InitializeFileTimeList();	// I don't know that this is used.
	return;
}

//
//
VOID CDBLoadConfiguration::ProcessEventReg(HMODULE hModule)
{
	HKEY hk;
	DWORD dwDisposition, dwType, dwValue, dwSize;
	TCHAR path[MAXBUF];
	BOOL bFixit = FALSE;

	// 1. check if have valid event info
	// 2. if not, create it as appropriate

	// check presence of event log info...

	_stprintf(path, _T("%s\\%s"), REG_EVT_PATH, REG_EVT_ITEM_STR);

	if (RegCreateKeyEx(	HKEY_LOCAL_MACHINE, 
						path, 
						0, 
						TS_REG_CLASS, 
						REG_OPTION_NON_VOLATILE, 
						KEY_READ | KEY_WRITE,
						NULL, 
						&hk, 
						&dwDisposition) == ERROR_SUCCESS) {
			
		if (dwDisposition == REG_CREATED_NEW_KEY) {
			// create entire registry layout for events
			CreateEvtMF(hk, hModule);
			CreateEvtTS(hk);	
		}
		else {
			// now make sure all registry elements present
			dwSize = sizeof (path) - 1;
			if (RegQueryValueEx(hk,
								REG_EVT_MF,
								0,
								&dwType,
								(LPBYTE) path,
								&dwSize) != ERROR_SUCCESS) {
				CreateEvtMF(hk, hModule);
			}
			dwSize = sizeof (DWORD);
			if (RegQueryValueEx(hk,
								REG_EVT_TS,
								0,
								&dwType,
								(LPBYTE) &dwValue,
								&dwSize) != ERROR_SUCCESS) {
				CreateEvtTS(hk);
			}
		}

		RegCloseKey(hk);
	}
}

//
//
VOID CDBLoadConfiguration::CreateEvtMF(HKEY hk, HMODULE hModule)
{
	TCHAR path[MAXBUF];
	DWORD len;

	if (hModule) {
		if ((len = GetModuleFileName(hModule, path, MAXBUF-1))!=0) {
			path[len] = _T('\0');
			if (RegSetValueEx(	hk,
								REG_EVT_MF,
								0,
								REG_EXPAND_SZ,
								(LPBYTE) path,
								len + sizeof(TCHAR)) == ERROR_SUCCESS) {
			}
		}
	}
}

//
//
VOID CDBLoadConfiguration::CreateEvtTS(HKEY hk)
{
	DWORD dwData;

	dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
				EVENTLOG_INFORMATION_TYPE; 

	if (RegSetValueEx(	hk,
						REG_EVT_TS,
						0,
						REG_DWORD,
						(LPBYTE) &dwData,
						sizeof(DWORD)) == ERROR_SUCCESS) {
	}
}

//
// This may not actually be germane for Local Troubleshooter: probably
//	rather blindly carried over from Online TS.
// m_dir (which gives us a list of desired files) must already be filled in with file names
//	& paths before this is called.  this finishes initializing it.
VOID CDBLoadConfiguration::InitializeFileTimeList()
{
	HANDLE hSearch;
	DWORD j;

	// get a list of files we are interested in
	for (j=0;j<MAXBNFILES;j++) {
		m_dir.file[j].bExist = TRUE;
		m_dir.file[j].bChanged = FALSE;
		
		// only hti is independent
		if (j == BNOFF_HTI || j == BNOFF_BES)
			m_dir.file[j].bIndependent = TRUE;
		else
			m_dir.file[j].bIndependent = FALSE;
	
		hSearch = FindFirstFile(m_dir.file[j].szFilepath, &m_dir.file[j].FindData); 
		if (hSearch == INVALID_HANDLE_VALUE) {
			// file not found usually
			m_dir.file[j].bExist = FALSE;
		}
		else {
			FindClose(hSearch);
		}
	}
}

//
//
VOID CDBLoadConfiguration::ClearCfg(DWORD off)
{
	DWORD k;

	m_cfg.api.pAPI = NULL;
	m_cfg.api.pTemplate = NULL;
	m_cfg.api.waitcount = 0;

	for (k = 0; k < MAXBNFILES; k++) 
		_tcscpy(m_cfg.api.szFilepath[k], _T(""));
	_tcscpy(m_cfg.api.type, _T(""));
}

// Bring content of DSC/HTI files for one troubleshooter into internal memory structures
// OUTPUT *szErrInfo - info specific to error
// RETURN 0 on success
DWORD CDBLoadConfiguration::CreateApi(TCHAR *szErrInfo)
{
	DWORD j;
	DWORD dwRErr = 0, dwIErr = 0, dwTErr = 0;

	// get api count and create new objects
	m_cfg.dwApiCnt = m_dwFilecount;
	
	// (The following comment sure looks like its carried over from Online TS and has little
	//	relevance to Local TS.  This routine probably involves a lot of overkill JM 3/98)
	// create new api and other files
	// once these go live we can destroy the others
	// provided there are no users using them
	// copy over list file info
	for (j = 0; j < MAXBNFILES; j++)
	{
		_tcscpy(m_cfg.api.szFilepath[j], m_dir.file[j].szFilepath);
		m_cfg.api.strFile[j] = m_dir.file[j].strFile;
	}

	_tcscpy(m_cfg.api.szResPath, m_dir.szResPath);
	_tcscpy(m_cfg.api.type, m_dir.type);

	if (NULL != m_cfg.api.pAPI)
		delete m_cfg.api.pAPI;

	if ((m_cfg.api.pAPI = new BCache(	m_cfg.api.szFilepath[BNOFF_DSC],
										m_cfg.api.type,
										m_szResourcePath,
										m_cfg.api.strFile[BNOFF_DSC])) == NULL) {
		dwRErr = EV_GTS_ERROR_INFENGINE;
	}
	// 
	dwTErr = m_cfg.api.pAPI->Initialize(/*m_cfg.pWordExcept*/);
	if (dwTErr) {
		dwIErr = dwTErr;
		_tcscpy(szErrInfo, m_cfg.api.szFilepath[BNOFF_DSC]);
	}
	if (NULL != m_cfg.api.pTemplate)
		delete m_cfg.api.pTemplate;
	if ((m_cfg.api.pTemplate = new CHTMLInputTemplate(m_cfg.api.szFilepath[BNOFF_HTI])) == NULL) {
		dwRErr = EV_GTS_ERROR_TEMPLATE_CREATE;
	}

	dwTErr = m_cfg.api.pTemplate->Initialize(m_cfg.api.szResPath, m_cfg.api.strFile[BNOFF_HTI]);
	if (dwTErr) {
		dwIErr = dwTErr;
		_tcscpy(szErrInfo, m_cfg.api.szFilepath[BNOFF_HTI]);
	}

	if (!dwRErr)
		if (dwIErr)
			dwRErr = dwIErr;
		
	return dwRErr;
}

//
//
VOID CDBLoadConfiguration::DestroyApi()		
{
	DWORD i;

	for (i=0;i<m_cfg.dwApiCnt;i++) {

		if (m_cfg.api.pAPI)
			delete m_cfg.api.pAPI;
		
		m_cfg.api.pAPI = NULL;
		
		if (m_cfg.api.pTemplate)
			delete m_cfg.api.pTemplate;
		
		m_cfg.api.pTemplate = NULL;

	}
}	

//
//
BNCTL *CDBLoadConfiguration::GetAPI()
{
	return &m_cfg;
}

//
//
BOOL CDBLoadConfiguration::FindAPIFromValue(BNCTL *currcfg, 
											LPCTSTR type, 
											CHTMLInputTemplate **pIT, 
											/*CSearchForm **pBES,*/
											BCache **pAPI,
											DWORD *dwOff)
{
	*pIT = currcfg->api.pTemplate;
	*pAPI = currcfg->api.pAPI;
	*dwOff = 0;
	return TRUE;	
}

//
//
TCHAR *CDBLoadConfiguration::GetHtmFilePath(BNCTL *currcfg, DWORD i)
{
	if (i >= currcfg->dwApiCnt)
		return m_nullstr;
	
	return currcfg->api.szFilepath[BNOFF_HTM];
}

//
//
TCHAR *CDBLoadConfiguration::GetBinFilePath(BNCTL *currcfg, DWORD i)
{
	if (i >= currcfg->dwApiCnt)
		return m_nullstr;
	
	return currcfg->api.szFilepath[BNOFF_DSC];
}

//
//
TCHAR *CDBLoadConfiguration::GetHtiFilePath(BNCTL *currcfg, DWORD i)
{
	if (i >= currcfg->dwApiCnt)
		return m_nullstr;
	
	return currcfg->api.szFilepath[BNOFF_HTI];

}

//
//
//	RETURNS symbolic name of troubleshooter
TCHAR *CDBLoadConfiguration::GetTagStr(BNCTL *currcfg, DWORD i)
{
	if (i >= currcfg->dwApiCnt)
		return m_nullstr;
	
	return currcfg->api.type;
}

//
//
// RETURNS number of [instances of] troubleshooters.  Probably a dubious inheritance from 
//	Online TS: Local TS should have only one troubleshooting belief network.
DWORD CDBLoadConfiguration::GetFileCount(BNCTL *currcfg)
{
	return currcfg->dwApiCnt;
}

// Look in the registry for whether we are using DSC files or DSZ files.
void CDBLoadConfiguration::GetDSCExtension(CString &strDSCExtension, LPCTSTR szValue)
{
	HKEY hKey;
	CString strSubKey = TSREGKEY_TL;
	strSubKey += _T("\\");
	strSubKey += szValue;
	if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			strSubKey,
			NULL,
			KEY_READ,
			&hKey))
	{
		strDSCExtension = DSC_DEFAULT;	// Default to DSZ
		return;
	}
	DWORD dwSize;
	DWORD dwType = REG_SZ;
	long lRes = RegQueryValueEx(hKey,
			TSLCL_FMAINEXT,
			NULL,
			&dwType,
			(BYTE *) strDSCExtension.GetBufferSetLength(10),
			&dwSize);
	strDSCExtension.ReleaseBuffer();
	if (ERROR_MORE_DATA == lRes)
	{
		lRes = RegQueryValueEx(hKey,
			TSLCL_FMAINEXT,
			NULL,
			&dwType,
			(BYTE *) strDSCExtension.GetBufferSetLength(dwSize + 2),
			&dwSize);
		strDSCExtension.ReleaseBuffer();
		if (ERROR_SUCCESS != lRes ||
			strDSCExtension.GetLength() < 1)
		{
			RegCloseKey(hKey);
			strDSCExtension = DSC_DEFAULT;
			return;
		}
	}
	else	// ERROR_SUCCESS is true or false
		if (ERROR_SUCCESS != lRes || strDSCExtension.GetLength() < 1)
		{
			RegCloseKey(hKey);
			strDSCExtension = DSC_DEFAULT;
			return;
		}
	RegCloseKey(hKey);
	if (_T('.') != strDSCExtension.GetAt(0))
		strDSCExtension = _T('.') + strDSCExtension;
	return;
}

//
// LoadSingleTS replaces ProcessLstFile when apgts is used in an
// ActiveX or OLE control.
VOID CDBLoadConfiguration::LoadSingleTS(LPCTSTR szValue)
{
	CString strRefedDSCExtension = _T("");
	ASSERT(1 == MAXBNCFG);
	if (m_dwFilecount >= m_bncfgsz) {
		// need to reallocate space
		DWORD newdirsz = (m_bncfgsz + MAXBNCFG) * sizeof (BNDIRCFG);
		DWORD newcfgsz = (m_bncfgsz + MAXBNCFG) * sizeof (BNAPICFG);

		ASSERT(0 == m_bncfgsz);
		ClearCfg(m_bncfgsz);

		m_bncfgsz += MAXBNCFG;
	}

	GetDSCExtension(strRefedDSCExtension, szValue);

	// No matter if we are using CHM or not - 
	//  this path will be "..\..\network.htm".
	// We are not using it directly ANYWAY
	_stprintf(m_dir.file[BNOFF_HTM].szFilepath, _T("%s%s.htm"), m_szResourcePath,szValue);

	if (IsUsingCHM())
	{
		m_dir.file[BNOFF_DSC].strFile = CString(szValue) + strRefedDSCExtension;
		_stprintf(m_dir.file[BNOFF_DSC].szFilepath, _T("%s%s"), m_szResourcePath,(LPCTSTR)m_strCHM);
	}
	else
	{
		_stprintf(m_dir.file[BNOFF_DSC].szFilepath, _T("%s%s"), m_szResourcePath,szValue);
		_tcscat(m_dir.file[BNOFF_DSC].szFilepath, (LPCTSTR) strRefedDSCExtension);
	}
	
	if (IsUsingCHM())
	{
		m_dir.file[BNOFF_HTI].strFile = CString(szValue) + HTI_DEFAULT;
		_stprintf(m_dir.file[BNOFF_HTI].szFilepath, _T("%s%s"), m_szResourcePath,(LPCTSTR)m_strCHM);
	}
	else
	{
		_stprintf(m_dir.file[BNOFF_HTI].szFilepath, _T("%s%s.hti"), m_szResourcePath,szValue);
	}

	_stprintf(m_dir.file[BNOFF_BES].szFilepath, _T("%s%s.bes"), m_szResourcePath,szValue);

	_tcscpy(m_dir.szResPath, m_szResourcePath);

	_tcscpy(m_dir.type, szValue);
	m_dwFilecount++;
	ASSERT(1 == m_dwFilecount);
	return;
}


//
//
BOOL CDBLoadConfiguration::CreatePaths(LPCTSTR szNetwork)
{
	int len;
	BOOL bDirChanged;
	
	// if reg entry not present, we need to add it
	bDirChanged = GetResourceDirFromReg(szNetwork);

	// a this point we are guaranteed to have len > 0 for each below

	// do our own validation (add backshash if not present)
	len = _tcslen(m_szResourcePath);
	if (len) {
		if (m_szResourcePath[len - 1] == _T('/'))
			m_szResourcePath[len - 1] = _T('\\');
		else if (m_szResourcePath[len-1] != _T('\\')) {
			m_szResourcePath[len] = _T('\\');
			m_szResourcePath[len+1] = _T('\0');
		}
	}

	return bDirChanged;
}

//
//
TCHAR *CDBLoadConfiguration::GetFullResource()
{
	return (m_szResourcePath);
}

//
//
VOID CDBLoadConfiguration::GetVrootPath(TCHAR *tobuf)
{
	_tcscpy(tobuf, _T(""));
}

// Find (or if it doesn't exist, create) a registry key giving path to resource directory.
// if returns true, then directory is new or changed
// if returns false, directory entry is same as before
// Yet another case of something which maybe overkill, left over from Online TS.
BOOL CDBLoadConfiguration::GetResourceDirFromReg(LPCTSTR szNetwork)
{
	HKEY hknew;
	DWORD dwType, dwSize, dwDisposition, len;
	TCHAR buf1[MAXBUF], buf2[MAXBUF];
	BOOL bDirChanged = TRUE;
	LONG lErr;
	CString tmp;

	// search for "Path" value in SOFTWARE\Microsoft\TShoot\TroubleshooterList\Network
	if (::GetNetworkRelatedResourceDirFromReg(szNetwork, &tmp))
	{
		if (::IsNetworkRelatedResourceDirCHM(tmp))
		{
			m_strCHM = ::ExtractCHM(tmp);
			_tcscpy(m_szResourcePath, ::ExtractResourceDir(tmp));
		}
		else
		{
			_tcscpy(m_szResourcePath, tmp);
		}
	}
	else
	{
		// create key if not present
		if (RegCreateKeyEx(	HKEY_LOCAL_MACHINE, 
							TSREGKEY_MAIN, 
							0, 
							TS_REG_CLASS, 
							REG_OPTION_NON_VOLATILE, 
							KEY_READ | KEY_WRITE,
							NULL, 
							&hknew, 
							&dwDisposition) == ERROR_SUCCESS) 
		{
			if (dwDisposition == REG_OPENED_EXISTING_KEY) 
			{
				// Get the current key value.
				dwSize = MAXBUF - 1;
				dwType = REG_SZ;
				if ((lErr = RegQueryValueEx(hknew,
									FULLRESOURCE_STR,
									0,
									&dwType,
									(LPBYTE) buf1,
									&dwSize)) == ERROR_SUCCESS) 
				{
					if (dwType == REG_EXPAND_SZ || dwType == REG_SZ) 
					{
						if (ExpandEnvironmentStrings(buf1, buf2, MAXBUF-1)) 
						{
							len = _tcslen(buf2);
							if (len) 
							{
								if (buf2[len-1] != _T('\\')) 
								{
									buf2[len] = _T('\\');
									buf2[len+1] = _T('\0');
								}
							}

							if (!_tcscmp(m_szResourcePath, buf2)) 
								bDirChanged = FALSE;
							else 
								_tcscpy(m_szResourcePath, buf2);
						}
						else 
						{
							ReportWFEvent(	_T("[apgtscfg]"), //Module Name
							_T("[GetResourceDirFromReg]"), //event
							_T(""),
							_T(""),
							EV_GTS_ERROR_CANT_GET_RES_PATH ); 
						}
					}
					else 
					{
						ReportWFEvent(	_T("[apgtscfg]"), //Module Name
						_T("[GetResourceDirFromReg]"), //event
						_T(""),
						_T(""),
						EV_GTS_ERROR_CANT_GET_RES_PATH ); 
					}
				}
				else 
				{
					_stprintf(buf1, _T("%ld"),lErr);
					ReportWFEvent(	_T("[apgtscfg]"), //Module Name
									_T("[GetResourceDirFromReg]"), //event
									buf1,
									_T(""),
									EV_GTS_ERROR_CANT_OPEN_SFT_3 );
				}
			}
			else
			{	// Created new key.  Don't have any resources.
				_stprintf(buf1, _T("%ld"),ERROR_REGISTRY_IO_FAILED);
				ReportWFEvent(	_T("[apgtscfg]"), //Module Name
								_T("[GetResourceDirFromReg]"), //event
								buf1,
								_T(""),
								EV_GTS_ERROR_CANT_GET_RES_PATH);
			}
			RegCloseKey(hknew);
		}
		else 
		{
			ReportWFEvent(	_T("[apgtscfg]"), //Module Name
							_T("[GetResourceDirFromReg]"), //event
							_T(""),
							_T(""),
							EV_GTS_ERROR_CANT_OPEN_SFT_2 ); 
		}					
	}
	return bDirChanged;
}

//
//
VOID CDBLoadConfiguration::BackslashIt(TCHAR *str)
{
	while (*str) {
		if (*str==_T('/'))
			*str=_T('\\');
		str = _tcsinc(str);
	}
}

VOID CDBLoadConfiguration::ResetNodes()
{
	m_cfg.api.pAPI->ResetNodes();
	return;
}

bool CDBLoadConfiguration::IsUsingCHM()
{
	return 0 != m_strCHM.GetLength();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtscls.h ===
//
// MODULE: APGTSCLS.H
//
// PURPOSE: Class header file
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//			further work by Richard Meadows (RWM), Joe Mabel, Oleg Kalosha
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM/OK+	Local Version for NT5
//

// names as part of name/value pairs to pass in to queries
#define C_TYPE			_T("type")		// name of the troubleshooting belief network
#define C_FIRST			_T("first")		// show "first" page (a list of loaded troubleshooters)
										// although useful in the Online Troubleshooter, which
										// has lots of troubleshooting networks loaded at once,
										// this is probably useless in the Local TS, except maybe
										// to show VERSIONSTR.).
#define C_SELECT		_T("select")	// UNSUPPORTED 3/98: Returns a page that has all of the 
										// troubleshooting belief networks
#define C_PRELOAD		_T("preload")	// relates to a 1997 prototype way of doing sniffing
										// with a separate OCX.  Probably should not be 
										// supported for 3/98 onwards.
#define C_ASK_LIBRARY	_T("asklibrary")	// says, in effect, "establish contact with the 
										// launch server & query it for what to do.


#define VERSIONSTR		_T("V3.0")		// >>> Typically, should be changed for each major release.

// no registry parameter can be larger than this value
#define ABS_MAX_REG_PARAM_VAL		10000

// these are settable in registry, defaults
// resource directory (configuration/support files):
#define DEF_FULLRESOURCE	_T("c:\\inetsrv\\scripts\\apgts\\resource")

// offsets for file types
#define BNOFF_HTM	0
#define BNOFF_DSC	1	// Are replacing bin with dsc.
#define BNOFF_HTI	2
#define BNOFF_BES	3

#define MAXBNFILES	4


// track a file for file change purposes
// >>> I suspect this is not ultimately relevant to Local TS.  This comes from an Online TS
//	consideration of updating when a new version of a TS belief NW is loaded. - JM
typedef struct _FILECTL {
	WIN32_FIND_DATA FindData;	// we really use this just for ftLastWriteTime.  Using the
								//	whole WIN32_FIND_DATA here makes some code a bit obscure.
	TCHAR szFilename[MAXBUF];	// just the filename (no path)
	TCHAR szFilepath[MAXBUF];	// full path name of file
	BOOL bChanged;				// TRUE ==> File exists & its date/time differs from that 
								//	indicated by FindData.ftLastWriteTime
	BOOL bExist;				// normally TRUE, set FALSE if we try to access the file
								//	& it isn't there.
	BOOL bIndependent;			// TRUE ==> this file is able to be changed independently of 
								//	any other file.  As of 10/97, this is strictly historical,
								//	but DSC files are arbitrarily considered dependent.
	CString strFile;			// file name (for example, LAN.hti), if "szFilepath"
								// member contains *.chm file
} FILECTL;

// In Online TS there is one of these for each instance of a TS Belief Network and
//	there may be multiple instances of one troubleshooter.  Probably overkill to isolate
//	as a separate struct for Local TS, but we inherited it.
typedef struct _BNAPICFG {
	BCache *pAPI;	
	CHTMLInputTemplate *pTemplate;	// object corresponding to HTI file
	DWORD waitcount;			// really a use count, >>> almost certainly irrelevant to 
								// Local TS.
	TCHAR type[MAXBUF];			// symbolic name of the Belief Network
	TCHAR szFilepath[MAXBNFILES][MAXBUF];	// first dimension corresponds to different files 
								// (DSC, HTI, BES) in the directory. Full filepath of each 
								// of these files .Index should be a BNOFF constant.
	TCHAR szResPath[MAXBUF];	// path to the monitored directory which contains the support
								// files.  Who knows why this is replicated here!
	CString strFile[MAXBNFILES];// file name (for example, LAN.hti), if "szFilepath"
								// member contains *.chm file
} BNAPICFG;

// In Online TS, one of these for API_A_OFF, one for API_B_OFF. Again, probably overkill 
//	for local TS.
typedef struct _BNCTL {
	HANDLE *pHandles;			// array of handles to mutexes. certainly irrelevant to Local TS
	DWORD dwHandleCnt;			// dimension of *pHandles
	BNAPICFG api;				// Note contrast to Online TS, where this is an array.
	DWORD dwApiCnt;				// Must be meaningless for Local TS: dimension of what's not 
								//	even an array
} BNCTL;

// track a directory for file change purposes.  Again, probably overkill for local TS.
typedef struct _BNDIRCFG {
	FILECTL file[MAXBNFILES];	// dimension corresponds to different files in the directory.
								//  Index should be a BNOFF constant
	BOOL bDependChg;			// Historically, TRUE ==> files are interdependent on an update
	TCHAR type[MAXBUF];			// symbolic name of the Belief Network
	TCHAR szResPath[MAXBUF];	// path to this directory.  SAME FOR ALL TROUBLEHOOTERS as
								// of 10/97.  Who knows why this is replicated here!
} BNDIRCFG;

//
//
#include "Rsstack.h"

class APGTSContext;
interface ILaunchTS;

class CHttpQuery {
public:
	CHttpQuery();
	~CHttpQuery();

	void RemoveAll(){m_State.RemoveAll();};
	void Debug();
	
	void Initialize(const VARIANT FAR& varCmds, const VARIANT FAR& varVals, short size);
	void SetFirst(CString &strCmd, CString &strVal);
	void FinishInit(BCache *pApi, const VARIANT FAR& varCmds, const VARIANT FAR& varVals);
	void FinishInitFromServ(BCache *pApi, ILaunchTS *pLaunchTS);
	BOOL StrIsDigit(LPCTSTR pSz);

	BOOL GetFirst(CString &strPut, CString &strValue);
	void SetStackDirection();
	BOOL GetNext(int &refedCmd, int &refedVal /* TCHAR *pPut, TCHAR *pValue */  );
	CString GetTroubleShooter();	// Gets the first Vals BSTR.
	CString GetFirstCmd();

	BOOL GetValue(int &Value, int index);
	BOOL GetValue1(int &Value);
	BOOL BackUp(BCache *pApi, APGTSContext *pCtx);
	void RemoveNodes(BCache *pApi);
	void AddNodes(BCache *pApi);

	int StatesFromServ(){return m_nStatesFromServ;};
	void RestoreStatesFromServ();

	CString GetSubmitString(BCache *pApi);

	CString& GetMachine();
	CString& GetPNPDevice();
	CString& GetDeviceInstance();
	CString& GetGuidClass();

	void PushNodesLastSniffed(const CArray<int, int>& arr);

protected:

	// The next 2 members are arrays of strings. See CHttpQuery::Initialize() for details of
	// the many conditions they must meet. Taken together, they constitute name/value 
	// pairs to set initial conditions for the troubleshooter.  The first pair indicates what 
	// troubleshooting belief network to load, the second indicates the problem node,
	// additional pairs indicate other nodes to be set.  All but the first are optional.
	VARIANT *m_pvarCmds;
	VARIANT *m_pvarVals;

	// The next 2 members are copies of the first pair in the above arrays.
	CString m_strCmd1;	// should always be "type"
	CString m_strVal1;	// name of the current troubleshooting belief network 

	// The next 4 parameters are machine, device, device instance id and class GUID
	CString m_strMachineID;
	CString m_strPNPDeviceID;
	CString m_strDeviceInstanceID;
	CString m_strGuidClass;

	int m_CurrentUse;		// >>> needs to be documented.
	int m_Size;				// clearly correlated to the number of name/value pairs that come 
							//	in from TSLaunchServ or from an HTML "get"; once 
							//	initialization is complete, one more than the number of 
							// CNodes in stack m_State.  Sometimes this is incremented
							// in synch with pushing onto the stack, sometimes not.  
							// >>> Is there any clean characterization of this variable?
							// >>> If anyone understands this better, please document. JM
	bool m_bReverseStack;  /* Richard writes in a 3/14/98 email: "I had to add reverse 
						   stack to make the thing work when launched from the device 
						   manager.  The theory is that the order of instantiations is 
						   not important.  What happens is the recommendations we get 
						   are different if the nodes are instantiated in reverse order."
						   >>> If you understand more about this, please document further. */
	UINT m_nStatesFromServ;	// the number of nodes (including the problem node) whose states
							// were set by TSLaunchServ.  This allows us to avoid showing a
							// BACK button when that would take us farther back than where 
							// we started.

	class CNode
	{
	public: 
		CNode() {cmd=0;val=0;sniffed=false;};
		int cmd;	// An IDH-style node number.  If this is an actual node, it's the
					//	"raw" node number + idhFirst, and val is the state.  If it's 
					//	<the count of nodes> + idhFirst, then val is the problem node.
					//	There's also something about a special value for TRY_TS_AT_MICROSOFT
					//	I (JM 3/98) believe that's something to do with an incomplete
					//	plan of being able to dynamically download troubleshooters
					//	from the net, but I could be wrong.
					//	>>> Maybe type should be IDH?
		int val;	// see documentation of cmd.
		bool sniffed; // indicates that the node was set as result of sniffing
					  // really UGLY that we have to spread this flag all over the place
					  // but the fact that multiple classes and data containers support
					  // the simple process of navigation is not less UGLY!!!
	};

	// Despite being a stack, there are times we access members other than
	//	by push and pop.  According to Richard, stack was originally set up here
	//	in support of BACK button, but m_bReverseStack was introduced because of a 
	//	situation (launching with problem node + other node(s) set) where 
	//	we needed to juggle things to pop problem node first.
	//	(JM 4/1/98)
	RSStack<CNode> m_State;

	void ThrowBadParams(CString &str);

	CNode m_aStatesFromServ[55];	// Keep around a copy of the states set on instructions
									//	from TS Launcher.
									// size is arbitrary, way larger than needed.
};

//
//
class CDBLoadConfiguration
{
public:
	CDBLoadConfiguration();
	CDBLoadConfiguration(HMODULE hModule, LPCTSTR szValue);
	~CDBLoadConfiguration();

	void Initialize(HMODULE hModule, LPCTSTR szValue);
	void SetValues(CHttpQuery &httpQ);
	VOID ResetNodes();
	VOID ResetTemplate();
	TCHAR *GetFullResource();
	VOID GetVrootPath(TCHAR *tobuf);

	TCHAR *GetHtmFilePath(BNCTL *currcfg, DWORD i);
	TCHAR *GetBinFilePath(BNCTL *currcfg, DWORD i);
	TCHAR *GetHtiFilePath(BNCTL *currcfg, DWORD i);

	TCHAR *GetTagStr(BNCTL *currcfg, DWORD i);
	DWORD GetFileCount(BNCTL *currcfg);

	BNCTL *GetAPI();
	BOOL FindAPIFromValue(	BNCTL *currcfg, \
							LPCTSTR type, \
							CHTMLInputTemplate **pIT, \
							/*CSearchForm **pBES,*/ \
							BCache **pAPI, \
							DWORD *dwOff);

	BOOL RescanRegistry(BOOL bChangeAllow);

	bool IsUsingCHM();

protected:
	// variables corresponding to the registry; comments refer to initial values
	TCHAR m_szResourcePath[MAXBUF];		// DEF_FULLRESOURCE: resource directory 

	CString m_strCHM;		// name of CHM file if any
	
	BNCTL m_cfg;			// In local TS, the one and only BNCTL (there are 2 in Online TS
							// as part of the reload strategy)
	BNDIRCFG m_dir;			// Similarly, for the sole instance of the sole TS belief network
	DWORD m_bncfgsz;		// a rather useless "dimension" of what is not an array in Local TS
	DWORD m_dwFilecount;	// Badly named.  Total number of instances of troubleshooters 
							//	mandated by APGTS.LST.  Proabably totally irrelvant in Local TS
	
	TCHAR m_nullstr[2];		// null string, here so if we have to return a string pointer 
							//	which is not allocated, we can point them here instead.
	DWORD m_dwErr;
	
protected:
	VOID GetDSCExtension(CString &strDSCExtension, LPCTSTR szValue);
	VOID InitializeToDefaults();
	VOID InitializeFileTimeList();
	DWORD CreateApi(TCHAR *szErrInfo);
	VOID DestroyApi();
	
	VOID LoadSingleTS(LPCTSTR szValue);	// Replaces ProcessLstFile.
	BOOL CreatePaths(LPCTSTR szNetwork);
	VOID BackslashIt(TCHAR *str);
	BOOL GetResourceDirFromReg(LPCTSTR szNetwork);

	VOID ProcessEventReg(HMODULE hModule);
	VOID CreateEvtMF(HKEY hk, HMODULE hModule);
	VOID CreateEvtTS(HKEY hk);

	VOID ClearCfg(DWORD off);
	VOID InitializeSingleResourceData(LPCTSTR szValue);  // Replaces InitializeMainResourceData when apgts is in an OLE Control.
};

//
//
typedef struct _EVAL_WORD_METRIC {
	DWORD dwVal;
	DWORD dwApiIdx;
} EVAL_WORD_METRIC;

//
//
class APGTSContext
{
public:
	APGTSContext();
	APGTSContext(	BNCTL *currcfg,
					CDBLoadConfiguration *pConf,
					CHttpQuery *pHttpQuery);
	~APGTSContext();

	void Initialize(BNCTL *currcfg,
					CDBLoadConfiguration *pConf,
					CHttpQuery *pHttpQuery);

	void DoContent(CHttpQuery *pQry);
	void RenderNext(CString &strPage);
	void Empty();
	void RemoveSkips();
	void ResetService();
	void BackUp(int nid, int state) {m_infer->BackUp(nid, state);};
	void ClearBackup() {m_infer->ClearBackup();};

	CSniffedNodeContainer* GetSniffedNodeContainer() {return m_infer ? m_infer->GetSniffedNodeContainer() : NULL;}

protected:
	void StartContent();

	DWORD ProcessCommands(LPCTSTR pszCmd, LPCTSTR pszValue);
	DWORD DoInference(LPCTSTR pszCmd, LPCTSTR pszValue, CHTMLInputTemplate *pInputTemplate, BCache *pAPI, DWORD dwOff);

	TCHAR *GetCookieValue(CHAR *pszName, CHAR *pszNameValue);
	TCHAR *asctimeCookie(struct tm *gmt);

	void DisplayFirstPage();

protected:
	DWORD m_dwErr;
	TCHAR m_vroot[MAXBUF];		// Local URL to this OCX
	TCHAR m_resptype[MAXBUF];	// HTTP response type e.g. "200 OK", "302 Object Moved"
	CString *m_pszheader;		// In Online TS, header for response file (indicates whether
								// we're sending HTML, setting a cookie, etc.)
								// Not sure how this is relevant to Local TS.
	BNCTL *m_currcfg;			// pointer to the BNCTL which we will use for this query
	CString *m_pCtxt;			// this is where we build the string to pass back (the newly
								//	constructed page)
	CHttpQuery *m_pQry;			// takes in raw URL-encoded string, gives us
								//	functions to get back scanned pairs.
	CDBLoadConfiguration *m_pConf;	// contains support-file data structures
	CInfer *m_infer;			// belief-network handler, unique to this request
	time_t m_aclock;			// time we build this object
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtscmd.h ===
//
// MODULE: APGTSCMD.CPP
//
// PURPOSE: Template string memory manager/allocator
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Victor Moore
//			further work by Roman Mach (RM), Richard Meadows (RWM), Joe Mabel, Oleg Kalosha
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			VM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5//

class HTXCommand {
public:
	HTXCommand(UINT type, const TCHAR *idstr);
	virtual ~HTXCommand();
	Add( HTXCommand command);
	virtual HTXCommand *Execute(CString *cstr, CInfer *infer);
	virtual HTXCommand *GetElse();
	virtual HTXCommand *GetEndIf();
	virtual HTXCommand *GetEndFor();
	virtual void SetElse(HTXCommand *elseif);
	virtual void SetEndIf(HTXCommand *endif);
	virtual void SetEndFor(HTXCommand *endfor);
	virtual void GetResource(CString &str, const CString& chm);

	void SetStart(UINT pos);
	void SetEnd(UINT pos);
	UINT GetStart();
	UINT GetEnd();
	const TCHAR *GetIDStr();
	UINT ReadBeforeStr(UINT before, UINT after, LPCTSTR startstr);
	UINT ReadAfterStr(UINT before, UINT after, LPCTSTR startstr);
	TCHAR *GetBeforeStr();
	TCHAR *GetAfterStr();
	UINT GetBeforeLen();
	UINT GetAfterLen();
	UINT GetType();
	UINT GetStatus();
	HTXCommand *GetNext();
	void SetNext(HTXCommand *next);

protected:
	UINT m_type;			// ID which identifies this command (e.g. HTX_TYPEENDIF)
	BOOL m_error;			// can be set true on certain out-of-memory errors
							// once set, cannot be cleared
	const TCHAR *m_idstr;	// string which identifies this command (e.g. HTX_ENDIFSTR, "endif")
	// The next 2 are used in identical ways.  Might want to abstract an object here.
	TCHAR *m_beforehtmlstr;	// with m_beforelen, m_beforesize implements a "before" string,
	TCHAR *m_afterhtmlstr;	// with m_afterlen, m_aftersize implements an "after" string,

protected:
	UINT m_beforelen;	// Logical size in chars
	UINT m_afterlen;	// Logical size in chars
	UINT m_beforesize;	// Physical size in bytes
	UINT m_aftersize;	// Physical size in bytes
	UINT m_start;		// pointer into HTI file where the "after" text of this command begins
	UINT m_end;			// pointer into HTI file where the "after" text of this command ends
	HTXCommand *m_next; // link to next command (in textual sequence in file).
};

class HTXForCommand: public HTXCommand {
public:
	HTXForCommand(UINT type, TCHAR *idstr, UINT variable);
	~HTXForCommand();
	HTXCommand *Execute(CString *cstr, CInfer *infer);
	HTXCommand *GetEndFor();
	void SetEndFor(HTXCommand *endfor);


protected:
	UINT m_var_index;		// variable over whose range we iterate
	HTXCommand *m_endfor;	// associate the corresponding "endfor"
};

class HTXIfCommand: public HTXCommand {
public:
	HTXIfCommand(UINT type, TCHAR *idstr, UINT variable);
	~HTXIfCommand();
	HTXCommand *Execute(CString *cstr, CInfer *infer);
	HTXCommand *GetElse();
	HTXCommand *GetEndIf();
	void SetElse(HTXCommand *elseif);
	void SetEndIf(HTXCommand *endif);

protected:
	UINT m_var_index;		// conditional variable which determines whether "then" case
							// or "else" case appplies
	HTXCommand *m_endif;	// associate the corresponding "endif"
	HTXCommand *m_else;		// associate the corresponding "else", if any
};

class HTXDisplayCommand: public HTXCommand {
public:
	HTXDisplayCommand(UINT type, TCHAR *idstr, UINT variable);
	~HTXDisplayCommand();
	HTXCommand *Execute(CString *cstr, CInfer *infer);

protected:
	UINT m_var_index;		// ID of variable whose value will be displayed in the HTML
};

class HTXResourceCommand: public HTXCommand {
public:
	HTXResourceCommand(UINT type, TCHAR *idstr);
	virtual ~HTXResourceCommand();
	virtual HTXCommand *Execute(CString *cstr, CInfer *infer);
	virtual void GetResource(CString &str, const CString& chm);
	void GetResName(LPCTSTR var_name);

protected:
	UINT m_var_index;			// value to evaluate, e.g. PROBLEM_ASK_INDEX, 
								//	RECOMMENDATIONS_INDEX
	CString m_strFileName;		// file from which we will copy HTML
	CString m_strResource;		// in-memory copy of that file's contents
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtsevt.h ===
//
// MODULE: APGTSEVT.MC
//
// PURPOSE: Event Logging Text Support File
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach(RM)
//			further work by Richard Meadows (RWM)
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: EV_GTS_PROCESS_START
//
// MessageText:
//
//  %1 %2 Starting Generic Troubleshooter %3
//
#define EV_GTS_PROCESS_START             ((DWORD)0x40000001L)

//
// MessageId: EV_GTS_PROCESS_STOP
//
// MessageText:
//
//  %1 %2 Stopping Generic Troubleshooter %3
//
#define EV_GTS_PROCESS_STOP              ((DWORD)0x40000002L)

//
// MessageId: EV_GTS_SERVER_BUSY
//
// MessageText:
//
//  %1 %2 Server has reached maximum queue size for requests
//
#define EV_GTS_SERVER_BUSY               ((DWORD)0x40000003L)

//
// MessageId: EV_GTS_USER_NO_STRING
//
// MessageText:
//
//  %1 %2 User did not enter parameters, Remote IP Address: %3
//
#define EV_GTS_USER_NO_STRING            ((DWORD)0x40000004L)

//
// MessageId: EV_GTS_DEP_FILES_UPDATED
//
// MessageText:
//
//  %1 %2 Reloaded Dependent Files %3 (%4)
//
#define EV_GTS_DEP_FILES_UPDATED         ((DWORD)0x40000005L)

//
// MessageId: EV_GTS_INDEP_FILES_UPDATED
//
// MessageText:
//
//  %1 %2 Reloaded Independent File %3 (%4)
//
#define EV_GTS_INDEP_FILES_UPDATED       ((DWORD)0x40000006L)

//
// MessageId: EV_GTS_ALL_FILES_UPDATED
//
// MessageText:
//
//  %1 %2 Reloaded ALL Files %3 (%4)
//
#define EV_GTS_ALL_FILES_UPDATED         ((DWORD)0x40000007L)

//
// MessageId: EV_GTS_SERVER_REG_CHG_MT
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Max Threads Changed, NOTE: Will not take effect until Web Server restarted. (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_MT         ((DWORD)0x40000008L)

//
// MessageId: EV_GTS_SERVER_REG_CHG_TPP
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Threads PP Changed, NOTE: Will not take effect until Web Server restarted. (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_TPP        ((DWORD)0x40000009L)

//
// MessageId: EV_GTS_SERVER_REG_CHG_MWQ
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Max Work Queue Items Changed (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_MWQ        ((DWORD)0x4000000AL)

//
// MessageId: EV_GTS_SERVER_REG_CHG_CET
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, HTTP Cookie Expiration time Changed (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_CET        ((DWORD)0x4000000BL)

//
// MessageId: EV_GTS_INF_FIRSTACC
//
// MessageText:
//
//  %1 %2 User accessed the top level page, %3
//
#define EV_GTS_INF_FIRSTACC              ((DWORD)0x4000000CL)

//
// MessageId: EV_GTS_SERVER_REG_CHG_DIR
//
// MessageText:
//
//  %1 %2 Resource Directory Changed, %3
//
#define EV_GTS_SERVER_REG_CHG_DIR        ((DWORD)0x4000000DL)

//
// MessageId: EV_GTS_SERVER_REG_CHG_MWT
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Max Working Threads Changed (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_MWT        ((DWORD)0x4000000EL)

//
// MessageId: EV_GTS_CANT_PROC_REQ_MWTE
//
// MessageText:
//
//  %1 %2 Server has reached maximum thread count for requests, increase maximum working thread count
//
#define EV_GTS_CANT_PROC_REQ_MWTE        ((DWORD)0x4000000FL)

//
// MessageId: EV_GTS_SERVER_REG_CHG_VRP
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Vroot Changed, NOTE: Only used on first page. (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_VRP        ((DWORD)0x40000010L)

//
// MessageId: EV_GTS_SERVER_REG_CHG_RDT
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Reload Delay time Changed (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_RDT        ((DWORD)0x40000011L)

//
// MessageId: EV_GTS_USER_PAGE_MISSING
//
// MessageText:
//
//  %1 %2 Page missing in resource html file %3 %4
//
#define EV_GTS_USER_PAGE_MISSING         ((DWORD)0x800001F4L)

//
// MessageId: EV_GTS_USER_BAD_THRD_REQ
//
// MessageText:
//
//  %1 %2 Shutdown signal not processed by all threads
//
#define EV_GTS_USER_BAD_THRD_REQ         ((DWORD)0x800001F5L)

//
// MessageId: EV_GTS_USER_THRD_KILL
//
// MessageText:
//
//  %1 %2 At least one thread hard-terminated on signal timeout
//
#define EV_GTS_USER_THRD_KILL            ((DWORD)0x800001F6L)

//
// MessageId: EV_GTS_CANT_PROC_REQ_SS
//
// MessageText:
//
//  %1 %2 Can't process request, server shutting down
//
#define EV_GTS_CANT_PROC_REQ_SS          ((DWORD)0x800001F8L)

//
// MessageId: EV_GTS_USER_BAD_DATA
//
// MessageText:
//
//  %1 %2 Received non-html data, (Can be caused by reloading DLL with no data sent) Remote IP Address: %3
//
#define EV_GTS_USER_BAD_DATA             ((DWORD)0x800001F9L)

//
// MessageId: EV_GTS_ERROR_UNEXPECTED_WT
//
// MessageText:
//
//  %1 %2 An unexpected result occurred from waiting on semaphore: Result/GetLastError(): %3
//
#define EV_GTS_ERROR_UNEXPECTED_WT       ((DWORD)0x800001FAL)

//
// MessageId: EV_GTS_DEBUG
//
// MessageText:
//
//  %1 %2 %3 %4
//
#define EV_GTS_DEBUG                     ((DWORD)0x800003E7L)

//
// MessageId: EV_GTS_ERROR_EC
//
// MessageText:
//
//  %1 %2 Can't create extension object
//
#define EV_GTS_ERROR_EC                  ((DWORD)0xC00003E8L)

//
// MessageId: EV_GTS_ERROR_POOLQUEUE
//
// MessageText:
//
//  %1 %2 Can't create instance of pool queue object
//
#define EV_GTS_ERROR_POOLQUEUE           ((DWORD)0xC00003E9L)

//
// MessageId: EV_GTS_ERROR_INFENGINE
//
// MessageText:
//
//  %1 %2 Unable to create API, DX32 API object instance create failed %3
//
#define EV_GTS_ERROR_INFENGINE           ((DWORD)0xC00003EBL)

//
// MessageId: EV_GTS_ERROR_THREAD
//
// MessageText:
//
//  %1 %2 Can't create worker thread
//
#define EV_GTS_ERROR_THREAD              ((DWORD)0xC00003EDL)

//
// MessageId: EV_GTS_ERROR_TEMPLATE_CREATE
//
// MessageText:
//
//  %1 %2 Unable to create API, Input template object instance create failed %3
//
#define EV_GTS_ERROR_TEMPLATE_CREATE     ((DWORD)0xC00003EEL)

//
// MessageId: EV_GTS_ERROR_LOGS
//
// MessageText:
//
//  %1 %2 Can't create instance of log object
//
#define EV_GTS_ERROR_LOGS                ((DWORD)0xC00003EFL)

//
// MessageId: EV_GTS_ERROR_DIRNOTETHREAD
//
// MessageText:
//
//  %1 %2 Can't create directory notify thread
//
#define EV_GTS_ERROR_DIRNOTETHREAD       ((DWORD)0xC00003F0L)

//
// MessageId: EV_GTS_ERROR_MUTEX
//
// MessageText:
//
//  %1 %2 Can't create worker mutex
//
#define EV_GTS_ERROR_MUTEX               ((DWORD)0xC00003F2L)

//
// MessageId: EV_GTS_ERROR_WORK_ITEM
//
// MessageText:
//
//  %1 %2 Can't allocate memory for work queue item
//
#define EV_GTS_ERROR_WORK_ITEM           ((DWORD)0xC00003F3L)

//
// MessageId: EV_GTS_ERROR_CONFIG
//
// MessageText:
//
//  %1 %2 Can't create instance of configuration object
//
#define EV_GTS_ERROR_CONFIG              ((DWORD)0xC00003F4L)

//
// MessageId: EV_GTS_ERROR_NO_FILES
//
// MessageText:
//
//  %1 %2 Unable to create API, There are no files specified in the LST file %3
//
#define EV_GTS_ERROR_NO_FILES            ((DWORD)0xC00003F5L)

//
// MessageId: EV_GTS_ERROR_NO_THRD
//
// MessageText:
//
//  %1 %2 Internal Error: Thread Count is Zero
//
#define EV_GTS_ERROR_NO_THRD             ((DWORD)0xC00003F6L)

//
// MessageId: EV_GTS_ERROR_REG_NFT_CEVT
//
// MessageText:
//
//  %1 %2 Registry notification failed, Can't open key, Error: %3
//
#define EV_GTS_ERROR_REG_NFT_CEVT        ((DWORD)0xC00003F7L)

//
// MessageId: EV_GTS_ERROR_NO_QUEUE_ITEM
//
// MessageText:
//
//  %1 %2 Can't get queue item
//
#define EV_GTS_ERROR_NO_QUEUE_ITEM       ((DWORD)0xC00003F8L)

//
// MessageId: EV_GTS_ERROR_REG_NFT_OPKEY
//
// MessageText:
//
//  %1 %2 Registry notification failed, Can't open key to enable notification, Error: %3
//
#define EV_GTS_ERROR_REG_NFT_OPKEY       ((DWORD)0xC00003F9L)

//
// MessageId: EV_GTS_ERROR_REG_NFT_SETNTF
//
// MessageText:
//
//  %1 %2 Registry notification failed, Can't set notification on open key, Error: %3
//
#define EV_GTS_ERROR_REG_NFT_SETNTF      ((DWORD)0xC00003FAL)

//
// MessageId: EV_GTS_ERROR_WLIST_CREATE
//
// MessageText:
//
//  %1 %2 Can't create Word List object %3
//
#define EV_GTS_ERROR_WLIST_CREATE        ((DWORD)0xC00003FBL)

//
// MessageId: EV_GTS_ERROR_BESEARCH_CREATE
//
// MessageText:
//
//  %1 %2 Unable to create API, Backend search object instance create failed %3
//
#define EV_GTS_ERROR_BESEARCH_CREATE     ((DWORD)0xC00003FCL)

//
// MessageId: EV_GTS_ERROR_ITMPL_FILE
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing IF %3
//
#define EV_GTS_ERROR_ITMPL_FILE          ((DWORD)0xC000041AL)

//
// MessageId: EV_GTS_ERROR_ITMPL_MISTAG
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing TAG statement %3
//
#define EV_GTS_ERROR_ITMPL_MISTAG        ((DWORD)0xC000041BL)

//
// MessageId: EV_GTS_ERROR_ITMPL_BADSEEK
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File bad seek operation %3
//
#define EV_GTS_ERROR_ITMPL_BADSEEK       ((DWORD)0xC000041CL)

//
// MessageId: EV_GTS_ERROR_ITMPL_NOMEM
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File no memory for objects %3
//
#define EV_GTS_ERROR_ITMPL_NOMEM         ((DWORD)0xC000041FL)

//
// MessageId: EV_GTS_ERROR_ITMPL_IFMISTAG
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing IF tag %3
//
#define EV_GTS_ERROR_ITMPL_IFMISTAG      ((DWORD)0xC0000420L)

//
// MessageId: EV_GTS_ERROR_ITMPL_FORMISTAG
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing FOR tag %3
//
#define EV_GTS_ERROR_ITMPL_FORMISTAG     ((DWORD)0xC0000421L)

//
// MessageId: EV_GTS_ERROR_ITMPL_ENDMISTAG
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing END tag %3
//
#define EV_GTS_ERROR_ITMPL_ENDMISTAG     ((DWORD)0xC0000422L)

//
// MessageId: EV_GTS_ERROR_ITMPL_VARIABLE
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing display variable %3
//
#define EV_GTS_ERROR_ITMPL_VARIABLE      ((DWORD)0xC0000423L)

//
// MessageId: EV_GTS_ERROR_THREAD_TOKEN
//
// MessageText:
//
//  %1 %2 Can't open thread token
//
#define EV_GTS_ERROR_THREAD_TOKEN        ((DWORD)0xC000044CL)

//
// MessageId: EV_GTS_ERROR_NO_CONTEXT_OBJ
//
// MessageText:
//
//  %1 %2 Can't create context object
//
#define EV_GTS_ERROR_NO_CONTEXT_OBJ      ((DWORD)0xC000044DL)

//
// MessageId: EV_GTS_ERROR_IDX_FILE
//
// MessageText:
//
//  %1 %2 Unable to create API, Can't find/open HTM file %3
//
#define EV_GTS_ERROR_IDX_FILE            ((DWORD)0xC000047EL)

//
// MessageId: EV_GTS_ERROR_IDX_BUFMEM
//
// MessageText:
//
//  %1 %2 Unable to create API, Can't allocate space for HTM %3
//
#define EV_GTS_ERROR_IDX_BUFMEM          ((DWORD)0xC000047FL)

//
// MessageId: EV_GTS_ERROR_IDX_CORRUPT
//
// MessageText:
//
//  %1 %2 Unable to create API, Node number in HTM file is bad %3
//
#define EV_GTS_ERROR_IDX_CORRUPT         ((DWORD)0xC0000480L)

//
// MessageId: EV_GTS_ERROR_IDX_MISSING
//
// MessageText:
//
//  %1 %2 Unable to create API, Couldn't add node number from HTM file into list %3
//
#define EV_GTS_ERROR_IDX_MISSING         ((DWORD)0xC0000481L)

//
// MessageId: EV_GTS_ERROR_IDX_EXISTS
//
// MessageText:
//
//  %1 %2 Unable to create API, Internal error, node from HTM file already exists in list %3
//
#define EV_GTS_ERROR_IDX_EXISTS          ((DWORD)0xC0000482L)

//
// MessageId: EV_GTS_ERROR_IDX_NO_SEP
//
// MessageText:
//
//  %1 %2 Unable to create API, No initial separator in HTM file %3
//
#define EV_GTS_ERROR_IDX_NO_SEP          ((DWORD)0xC0000483L)

//
// MessageId: EV_GTS_ERROR_IDX_BAD_NUM
//
// MessageText:
//
//  %1 %2 Unable to create API, Bad initial node number in HTM file %3
//
#define EV_GTS_ERROR_IDX_BAD_NUM         ((DWORD)0xC0000484L)

//
// MessageId: EV_GTS_ERROR_IDX_NOT_PROB
//
// MessageText:
//
//  %1 %2 Unable to create API, Initial node number is not a problem list node in HTM file %3
//
#define EV_GTS_ERROR_IDX_NOT_PROB        ((DWORD)0xC0000485L)

//
// MessageId: EV_GTS_ERROR_IDX_BAD_PNUM
//
// MessageText:
//
//  %1 %2 Unable to create API, Bad problem number in problem list node in HTM file %3
//
#define EV_GTS_ERROR_IDX_BAD_PNUM        ((DWORD)0xC0000486L)

//
// MessageId: EV_GTS_ERROR_IDX_EXCEED_ARRAY
//
// MessageText:
//
//  %1 %2 Unable to create API, Exceeded maximum number of problem nodes for problem list in HTM file %3
//
#define EV_GTS_ERROR_IDX_EXCEED_ARRAY    ((DWORD)0xC0000487L)

//
// MessageId: EV_GTS_ERROR_IDX_READ_MODEL
//
// MessageText:
//
//  %1 %2 Unable to create API, API is unable to read model %3
//
#define EV_GTS_ERROR_IDX_READ_MODEL      ((DWORD)0xC0000488L)

//
// MessageId: EV_GTS_ERROR_IDX_ALLOC_LIST
//
// MessageText:
//
//  %1 %2 Unable to create API, API is unable to create list object (%3)
//
#define EV_GTS_ERROR_IDX_ALLOC_LIST      ((DWORD)0xC0000489L)

//
// MessageId: EV_GTS_ERROR_IDX_ALLOC_CACHE
//
// MessageText:
//
//  %1 %2 Unable to create API, API is unable to create cache object (%3)
//
#define EV_GTS_ERROR_IDX_ALLOC_CACHE     ((DWORD)0xC000048AL)

//
// MessageId: EV_GTS_ERROR_IDX_BAD_LIST_PTR
//
// MessageText:
//
//  %1 %2 Unable to create API, API received bad list pointer (%3)
//
#define EV_GTS_ERROR_IDX_BAD_LIST_PTR    ((DWORD)0xC000048BL)

//
// MessageId: EV_GTS_ERROR_NO_STRING
//
// MessageText:
//
//  %1 %2 Can't create string object, %3
//
#define EV_GTS_ERROR_NO_STRING           ((DWORD)0xC00004B0L)

//
// MessageId: EV_GTS_ERROR_NO_QUERY
//
// MessageText:
//
//  %1 %2 Can't create space for user query data, %3
//
#define EV_GTS_ERROR_NO_QUERY            ((DWORD)0xC00004B1L)

//
// MessageId: EV_GTS_ERROR_NO_CHAR
//
// MessageText:
//
//  %1 %2 Can't create query decoder object, %3
//
#define EV_GTS_ERROR_NO_CHAR             ((DWORD)0xC00004B2L)

//
// MessageId: EV_GTS_ERROR_NO_INFER
//
// MessageText:
//
//  %1 %2, Can't create inference object, %3
//
#define EV_GTS_ERROR_NO_INFER            ((DWORD)0xC00004B3L)

//
// MessageId: EV_GTS_ERROR_POOL_SEMA
//
// MessageText:
//
//  %1 %2 Can't create pool queue semaphore, %3
//
#define EV_GTS_ERROR_POOL_SEMA           ((DWORD)0xC00004E2L)

//
// MessageId: EV_GTS_ERROR_INF_BADPARAM
//
// MessageText:
//
//  %1 %2 User sent bad query string parameter, %3
//
#define EV_GTS_ERROR_INF_BADPARAM        ((DWORD)0xC0000514L)

//
// MessageId: EV_GTS_ERROR_INF_NODE_SET
//
// MessageText:
//
//  %1 %2 Can't Set Node, %3 Extended Error, (Inference Engine): %4
//
#define EV_GTS_ERROR_INF_NODE_SET        ((DWORD)0xC0000515L)

//
// MessageId: EV_GTS_ERROR_INF_NO_MEM
//
// MessageText:
//
//  %1 %2 Not enough memory for inference support objects, %3
//
#define EV_GTS_ERROR_INF_NO_MEM          ((DWORD)0xC0000516L)

//
// MessageId: EV_GTS_ERROR_INF_BADCMD
//
// MessageText:
//
//  %1 %2 User sent bad first command in query string, %3
//
#define EV_GTS_ERROR_INF_BADCMD          ((DWORD)0xC0000519L)

//
// MessageId: EV_GTS_ERROR_INF_BADTYPECMD
//
// MessageText:
//
//  %1 %2 User sent unknown type in query string, %3
//
#define EV_GTS_ERROR_INF_BADTYPECMD      ((DWORD)0xC000051AL)

//
// MessageId: EV_GTS_ERROR_LOG_FILE_MEM
//
// MessageText:
//
//  %1 %2 Can't create log file entry string object instance
//
#define EV_GTS_ERROR_LOG_FILE_MEM        ((DWORD)0xC0000546L)

//
// MessageId: EV_GTS_ERROR_LOG_FILE_OPEN
//
// MessageText:
//
//  %1 %2 Can't open log file for write/append
//
#define EV_GTS_ERROR_LOG_FILE_OPEN       ((DWORD)0xC0000547L)

//
// MessageId: EV_GTS_ERROR_WAIT_MULT_OBJ
//
// MessageText:
//
//  %1 %2 Error waiting for object, Return/GetLastError(): %3
//
#define EV_GTS_ERROR_WAIT_MULT_OBJ       ((DWORD)0xC0000578L)

//
// MessageId: EV_GTS_ERROR_WAIT_NEXT_NFT
//
// MessageText:
//
//  %1 %2 Error getting next file notification
//
#define EV_GTS_ERROR_WAIT_NEXT_NFT       ((DWORD)0xC0000579L)

//
// MessageId: EV_GTS_ERROR_DN_REL_MUTEX
//
// MessageText:
//
//  %1 %2 We don't own mutex, can't release
//
#define EV_GTS_ERROR_DN_REL_MUTEX        ((DWORD)0xC000057AL)

//
// MessageId: EV_GTS_ERROR_LST_FILE_MISSING
//
// MessageText:
//
//  %1 %2 Attempt to check LST file failed, it is not present in given directory %3
//
#define EV_GTS_ERROR_LST_FILE_MISSING    ((DWORD)0xC000057BL)

//
// MessageId: EV_GTS_ERROR_CANT_GET_RES_PATH
//
// MessageText:
//
//  %1 %2 Can't expand environment string for resource path
//
#define EV_GTS_ERROR_CANT_GET_RES_PATH   ((DWORD)0xC000057CL)

//
// MessageId: EV_GTS_ERROR_CANT_OPEN_SFT_1
//
// MessageText:
//
//  %1 %2 Can't open troubleshooter key
//
#define EV_GTS_ERROR_CANT_OPEN_SFT_1     ((DWORD)0xC000057DL)

//
// MessageId: EV_GTS_ERROR_CANT_OPEN_SFT_2
//
// MessageText:
//
//  %1 %2 Can't open generic troubleshooter key
//
#define EV_GTS_ERROR_CANT_OPEN_SFT_2     ((DWORD)0xC000057EL)

//
// MessageId: EV_GTS_ERROR_CANT_OPEN_SFT_3
//
// MessageText:
//
//  %1 %2 Can't query resource directory: Error = %3
//
#define EV_GTS_ERROR_CANT_OPEN_SFT_3     ((DWORD)0xC000057FL)

//
// MessageId: EV_GTS_ERROR_LST_FILE_OPEN
//
// MessageText:
//
//  %1 %2 Attempt to open LST file for reading failed: %3
//
#define EV_GTS_ERROR_LST_FILE_OPEN       ((DWORD)0xC0000580L)

//
// MessageId: EV_GTS_ERROR_CFG_OOMEM
//
// MessageText:
//
//  %1 %2 Fatal Error, can't allocate memory for config structure section %3
//
#define EV_GTS_ERROR_CFG_OOMEM           ((DWORD)0xC0000581L)

//
// MessageId: EV_GTS_ERROR_DIR_OOMEM
//
// MessageText:
//
//  %1 %2 Fatal Error, can't allocate memory for directory structure
//
#define EV_GTS_ERROR_DIR_OOMEM           ((DWORD)0xC0000582L)

//
// MessageId: EV_GTS_ERROR_LST_DIR_OOMEM
//
// MessageText:
//
//  %1 %2 Can't reallocate memory for list file %3 directory entries
//
#define EV_GTS_ERROR_LST_DIR_OOMEM       ((DWORD)0xC0000583L)

//
// MessageId: EV_GTS_ERROR_LST_CFG_OOMEM
//
// MessageText:
//
//  %1 %2 Can't reallocate memory for list file %3 config entries %4
//
#define EV_GTS_ERROR_LST_CFG_OOMEM       ((DWORD)0xC0000584L)

//
// MessageId: EV_GTS_ERROR_CANT_FILE_NOTIFY
//
// MessageText:
//
//  %1 %2 Can't perform file notification on directory, directory may not exist %3 (%4)
//
#define EV_GTS_ERROR_CANT_FILE_NOTIFY    ((DWORD)0xC0000585L)

//
// MessageId: EV_GTS_ERROR_BES_ALLOC_STR
//
// MessageText:
//
//  %1 %2 Can't allocate memory for backend search string objects %3 %4
//
#define EV_GTS_ERROR_BES_ALLOC_STR       ((DWORD)0xC00005DCL)

//
// MessageId: EV_GTS_ERROR_BES_GET_FSZ
//
// MessageText:
//
//  %1 %2 Can't get file size for backend search file %3 %4
//
#define EV_GTS_ERROR_BES_GET_FSZ         ((DWORD)0xC00005DDL)

//
// MessageId: EV_GTS_ERROR_BES_ALLOC_FILE
//
// MessageText:
//
//  %1 %2 Can't allocate memory for backend search file read %3 %4
//
#define EV_GTS_ERROR_BES_ALLOC_FILE      ((DWORD)0xC00005DEL)

//
// MessageId: EV_GTS_ERROR_BES_FILE_READ
//
// MessageText:
//
//  %1 %2 Can't read backend search file %3 %4
//
#define EV_GTS_ERROR_BES_FILE_READ       ((DWORD)0xC00005DFL)

//
// MessageId: EV_GTS_ERROR_BES_FILE_OPEN
//
// MessageText:
//
//  %1 %2 Can't open or find backend search file %3 %4
//
#define EV_GTS_ERROR_BES_FILE_OPEN       ((DWORD)0xC00005E0L)

//
// MessageId: EV_GTS_ERROR_BES_NO_STR
//
// MessageText:
//
//  %1 %2 Backend search file is empty (no content) %3 %4
//
#define EV_GTS_ERROR_BES_NO_STR          ((DWORD)0xC00005E1L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_FORM
//
// MessageText:
//
//  %1 %2 Backend search file does not have FORM tag (make sure tag is all caps in file): <FORM %3 %4
//
#define EV_GTS_ERROR_BES_MISS_FORM       ((DWORD)0xC00005E2L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_ACTION
//
// MessageText:
//
//  %1 %2 Backend search file does not have ACTION tag (make sure tag is all caps in file): ACTION=" %3 %4
//
#define EV_GTS_ERROR_BES_MISS_ACTION     ((DWORD)0xC00005E3L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_AEND_Q
//
// MessageText:
//
//  %1 %2 Backend search file does not have end quote for ACTION tag  %3 %4
//
#define EV_GTS_ERROR_BES_MISS_AEND_Q     ((DWORD)0xC00005E4L)

//
// MessageId: EV_GTS_ERROR_BES_CLS_TAG
//
// MessageText:
//
//  %1 %2 Backend search file has tag that doesn't close with '>' %3 %4
//
#define EV_GTS_ERROR_BES_CLS_TAG         ((DWORD)0xC00005E5L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_TYPE_TAG
//
// MessageText:
//
//  %1 %2 Backend search file does not have TYPE tag (make sure tag is all caps in file): TYPE= %3 %4
//
#define EV_GTS_ERROR_BES_MISS_TYPE_TAG   ((DWORD)0xC00005E6L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_CT_TAG
//
// MessageText:
//
//  %1 %2 Backend search file is missing close tag '>' for TYPE tag %3 %4
//
#define EV_GTS_ERROR_BES_MISS_CT_TAG     ((DWORD)0xC00005E7L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_CN_TAG
//
// MessageText:
//
//  %1 %2 Backend search file is missing close tag '>' for NAME tag %3 %4
//
#define EV_GTS_ERROR_BES_MISS_CN_TAG     ((DWORD)0xC00005E8L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_CV_TAG
//
// MessageText:
//
//  %1 %2 Backend search file is missing close tag '>' for VALUE tag %3 %4
//
#define EV_GTS_ERROR_BES_MISS_CV_TAG     ((DWORD)0xC00005E9L)

//
// MessageId: EV_GTS_ERROR_CAC_ALLOC_MEM
//
// MessageText:
//
//  %1 %2 Can't allocate space for cache item internal structure
//
#define EV_GTS_ERROR_CAC_ALLOC_MEM       ((DWORD)0xC000060EL)

//
// MessageId: EV_GTS_ERROR_CAC_ALLOC_ITEM
//
// MessageText:
//
//  %1 %2 Cache can't allocate space for cache item
//
#define EV_GTS_ERROR_CAC_ALLOC_ITEM      ((DWORD)0xC000060FL)

//
// MessageId: EV_GTS_ERROR_WL_ALLOC_LIST
//
// MessageText:
//
//  %1 %2 Word list can't create list object
//
#define EV_GTS_ERROR_WL_ALLOC_LIST       ((DWORD)0xC0000640L)

//
// MessageId: EV_GTS_ERROR_WL_ALLOC_ADD_LI
//
// MessageText:
//
//  %1 %2 Word list can't allocate space for additional list item
//
#define EV_GTS_ERROR_WL_ALLOC_ADD_LI     ((DWORD)0xC0000641L)

//
// MessageId: EV_GTS_ERROR_WL_ALLOC_TOK
//
// MessageText:
//
//  %1 %2 Word list can't allocate space for token string
//
#define EV_GTS_ERROR_WL_ALLOC_TOK        ((DWORD)0xC0000642L)

//
// MessageId: EV_GTS_ERROR_NL_ALLOC_LIST
//
// MessageText:
//
//  %1 %2 Node list can't create list object
//
#define EV_GTS_ERROR_NL_ALLOC_LIST       ((DWORD)0xC0000672L)

//
// MessageId: EV_GTS_ERROR_NL_ALLOC_ADD_LI
//
// MessageText:
//
//  %1 %2 Node list can't allocate space for additional list item
//
#define EV_GTS_ERROR_NL_ALLOC_ADD_LI     ((DWORD)0xC0000673L)

//
// MessageId: EV_GTS_ERROR_NL_ALLOC_WL
//
// MessageText:
//
//  %1 %2 Node list can't create word list object
//
#define EV_GTS_ERROR_NL_ALLOC_WL         ((DWORD)0xC0000674L)

//
// MessageId: EV_GTS_ERROR_LIST_ALLOC
//
// MessageText:
//
//  %1 %2 List can't allocate space for items
//
#define EV_GTS_ERROR_LIST_ALLOC          ((DWORD)0xC00006A4L)

//
// MessageId: EV_GTS_ERROR_LIST_SZ
//
// MessageText:
//
//  %1 %2 List new size too big
//
#define EV_GTS_ERROR_LIST_SZ             ((DWORD)0xC00006A5L)

//
// MessageId: EV_GTS_ERROR_LIST_REALLOC
//
// MessageText:
//
//  %1 %2 List can't reallocate space for items
//
#define EV_GTS_ERROR_LIST_REALLOC        ((DWORD)0xC00006A6L)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtsdtg.cpp ===
//
// MODULE: APGTSDTG.CPP
//
// PURPOSE: Wrapper for inference api
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//
// ORIGINAL DATE: 8-2-96
//
// NOTES:
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

//#include "windows.h"
#include "stdafx.h"

#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include <string.h>
#include <memory.h>

#include "CabUnCompress.h"
#include "crc.h"
#include "sniff.h"
#include "chmread.h"

BCache::BCache(TCHAR *binfile, TCHAR *tagstr, TCHAR *szResourcePath, const CString& strFile)
	  :	GTSAPI(binfile, tagstr, szResourcePath),
		CSniffedNodeContainer(),
		m_NodeState(30),
		m_strFile(strFile)
{
	SetBNTS(this);
		
	m_bNeedModel = TRUE;	// TRUE -> Need to read the model before querying the bnts library.
	m_bModelRead = FALSE;
	m_bDeleteModelFile = FALSE;
	m_strModelFile = _T("");

	m_CurNode = 0;

	m_pHttpQuery = NULL;

	m_strResult = _T("");

	m_NodeState.InitHashTable(47);

	m_bReverse = false;

	m_bRunWithKnownProblem = false;

	return;
}

BCache::~BCache()
{
	m_NodeState.RemoveAll();
	if (m_bDeleteModelFile)
	{
		DeleteFile((LPCTSTR) m_strModelFile);
		m_bDeleteModelFile = FALSE;
	}
	return;
}

//
//
GTSAPI::GTSAPI(TCHAR *binfile, TCHAR *tagstr, TCHAR *szResourcePath) :
m_CacheGen(TRUE, NULL, NULL)
{
//	InitializeCriticalSection( &m_csAPI );

	m_cnid = 0;
	m_dwErr = 0;
	m_pchHtml = NULL;
	m_currid = 0;
	m_pCache = NULL;

	_tcscpy(m_binfile,binfile);// full path
	_tcscpy(m_tagstr,tagstr);
	_tcscpy(m_szResourcePath,szResourcePath);
}

//
//
GTSAPI::~GTSAPI()
{
	Destroy();
}

void WideToMB(const WCHAR *szIn, CHAR *szOut)
{
	VERIFY(WideCharToMultiByte(CP_ACP,
						NULL,
						szIn,
						-1,
						szOut,
						MAXBUF,
						NULL, NULL));
	return;
}
#ifdef _UNICODE
// Temporary BNTS wrappers for unicode build with non unicode bnts.dll
BOOL GTSAPI::BMultiByteReadModel(LPCTSTR szcFn, LPCSTR szFnError)
{
	CHAR szFn[MAXBUF];
	WideToMB(szcFn, szFn);
	return BNTS::BReadModel(szFn, szFnError);
}

BOOL GTSAPI::BMultiByteNodePropItemStr(LPCTSTR szcPropType, int index)
{
	CHAR szPropType[MAXBUF];
	WideToMB(szcPropType, szPropType);
	return BNTS::BNodePropItemStr(szPropType, index);
}

BOOL GTSAPI::BMultiByteNetPropItemStr(LPCTSTR szcPropType, int index)
{
	CHAR szPropType[MAXBUF];
	WideToMB(szcPropType, szPropType);
	return BNTS::BNetPropItemStr(szPropType, index);
}

const WCHAR * GTSAPI::SzcMultiByteResult()
{
	int len = strlen(BNTS::SzcResult());
	int size = MultiByteToWideChar(CP_ACP,
						NULL,						
						BNTS::SzcResult(),
						len,
						NULL,
						0);
	MultiByteToWideChar(CP_ACP,
						NULL,
						BNTS::SzcResult(),
						len + 1,
						m_strResult.GetBufferSetLength(size),
						size);
	m_strResult.ReleaseBuffer();
	return (LPCTSTR) m_strResult;
}

int GTSAPI::IMultiByteNode(LPCTSTR szSymName)
{
	CHAR szMBSymName[MAXBUF];
	WideToMB(szSymName, szMBSymName);
	return BNTS::INode(szMBSymName);
}

#endif // _UNICODE

void BCache::ReadTheDscModel(int From)
{
	if (m_bNeedModel)
	{
			if (!BReadModel((LPCTSTR) m_strModelFile
		#ifdef _DEBUG
				, "BNTSError.log"
		#endif
				))
				ReportError((DLSTATTYPES) From);
		// Add the nodes that are already instantiated.
		if (m_pHttpQuery)
			m_pHttpQuery->AddNodes(this);
		m_bNeedModel = FALSE;

		if (m_bDeleteModelFile)
		{
			DeleteFile((LPCTSTR) m_strModelFile);
			m_bDeleteModelFile = FALSE;
		}
	}
}

VOID BCache::AddToCache(CString &strCacheFile, const CString& strCacheFileWithinCHM)
{
	if (m_CacheGen.ReadCacheFileHeader(strCacheFile, strCacheFileWithinCHM))
	{
		BOOL bErr;
		ASSERT(m_pCache);
		while (m_CacheGen.GetNextCacheEntryFromFile(bErr, m_pCache))
			;
		if (bErr)
		{
			delete m_pCache;
			m_pCache = new CBNCache();
			TRACE(_T("Errors occured while reading the cache file.\n"));
			ReadTheDscModel(TSERR_ENGINE_BNTS_READ_NCAB);
		}
	}
	return;
}

DWORD BCache::ReadModel()
{
	BOOL bDelete = FALSE;

	// this should be fixed eventually to not require a string compare
	// but maybe a flag check that gets passed in
	CString sFilename = m_binfile;
	CString strCacheFile;
	CString strCacheFileWithinCHM;

	if (m_strFile.GetLength())
	{
		// form Cache file path here assuming it is NOT in chm file
		strCacheFile = m_binfile;
		strCacheFileWithinCHM = m_strFile.Left(m_strFile.GetLength() - 4);
		strCacheFileWithinCHM += SZ_CACHE_NAME;
	}
	else
	{
		strCacheFile = sFilename.Left(sFilename.GetLength() - 4);
		strCacheFile += SZ_CACHE_NAME;
	}
	
	if (m_strFile.GetLength() || !sFilename.Right(4).CompareNoCase(DSC_COMPRESSED))
	{
		CCabUnCompress cab;
		CString strDirBuf;		
		if (!GetTempPath( MAX_PATH , strDirBuf.GetBufferSetLength(MAX_PATH + 1)))
		{
			strDirBuf.ReleaseBuffer();
			strDirBuf = m_szResourcePath;
		}
		else
		{
			strDirBuf.ReleaseBuffer();
		}
		if (!cab.ExtractCab(sFilename, strDirBuf, m_strFile))
		{
			if (NOT_A_CAB == cab.m_nError)
			{	// The file may be uncompressed already.
				bDelete = FALSE;
			}
			else
			{
				ReportError(TSERR_ENGINE_EXTRACT);
			}
		}
		else
		{	// Normal cab file expanded successfully.
			sFilename = strDirBuf;
			sFilename += cab.GetLastFile();
			DWORD dwAttribs = GetFileAttributes((LPCTSTR) sFilename);
			dwAttribs = dwAttribs & ~FILE_ATTRIBUTE_READONLY;
			SetFileAttributes((LPCTSTR) sFilename, dwAttribs);
			bDelete = TRUE;
		}
	}
/*
	if (!BReadModel(sFilename
#ifdef _DEBUG
		, "BNTSError.log"
#endif
		))
		ReportError(TSERR_ENGINE);
*/
	m_strModelFile = sFilename;
	m_bDeleteModelFile = bDelete;
	// Compare the crc value in the cache file with the crc of the dsc file.
	// If they match, fill the cache.	
	CCRC crc;
	try
	{
		if (crc.Decode(sFilename, strCacheFile, strCacheFileWithinCHM))	
			AddToCache(strCacheFile, strCacheFileWithinCHM);
		else
			ReadTheDscModel(TSERR_ENGINE_BNTS_READ_CACH);
	}
	catch(CGenException *p)
	{
		delete p;
		ReadTheDscModel(TSERR_ENGINE_BNTS_READ_GEN);
	}

//	if (bDelete)
//		DeleteFile(sFilename);


	m_probask = idhFirst + CNode();
	m_bModelRead = TRUE;
	return m_dwErr;
}

// Number of nodes whose states were set at program startup by TSLaunchServ.
UINT BCache::StatesFromServ()
{
	return m_pHttpQuery ? m_pHttpQuery->StatesFromServ() : 0;
}

// Number of nodes whose states are now set
UINT BCache::StatesNowSet()
{
	return (UINT)m_NodeState.GetCount();
}

//
//
DWORD BCache::Initialize(/*CWordList *pWXList*/)
{

	if (NULL != m_pCache)
		delete m_pCache;
	m_pCache = new CBNCache();
	if (!m_pCache)
		m_dwErr = EV_GTS_ERROR_IDX_ALLOC_CACHE;

	ResetNodes();

	if (!BValidNet())
		ReadModel();
	return m_dwErr;
}


// override the default function
//
// look for possible returns in the header file
//
int BCache::GTSGetRecommendations(CNID& cnid, NID rgnid[], bool bSniffed)
{
	BN_CACHE_ITEM SetupItem;
	SetupItem.uNodeCount = m_cnid;
	SetupItem.uName = m_rgnid;
	SetupItem.uValue = m_rgist;
	int state = SNIFF_INVALID_STATE;
	int label = SNIFF_INVALID_NODE_LABEL;

//AfxDebugBreak();

	// set initial non-sniffed value in array of sniffed states
	if (!bSniffed && !IsReverse())
		m_rgsniff[m_cnid-1] = 0;

	// flush array of sniffed nodes recently traversed
	if (!bSniffed)
		m_arrNidLastSniffed.RemoveAll();
	
	if (m_pCache->FindCacheItem(&SetupItem, cnid, rgnid))
	{
		if (GetState(*rgnid, &state))  // sniffer has this information and can answer what state this node has
		{
			if (NodeSet(*rgnid, state, false)) // set sniffed node current and set its state
			{
				SetAdditionalDataOnNodeSet(*rgnid);
				return GTSGetRecommendations(cnid, rgnid, true); // recursive call - hope BNTS will not recommend a node which is set
			}
		}
		else
		{
			return RECOMMEND_SUCCESS;
		}
	}
	
	if (m_bNeedModel)
	{
		ReadTheDscModel(TSERR_ENGINE_BNTS_REC);
	}

	if (BGetRecommendations())
	{	
		cnid = CInt();
		if (cnid > 0)
		{
			const int *pInt = RgInt();
			memcpy(rgnid, pInt, cnid * sizeof(pInt[0]));
				
			SetupItem.uNodeCount = m_cnid;
			SetupItem.uName = m_rgnid;
			SetupItem.uValue = m_rgist;			
			SetupItem.uRecCount = cnid;
			SetupItem.uRec = rgnid;			

			m_pCache->AddCacheItem(&SetupItem);			
			
			if (GetState(*rgnid, &state))  // sniffer has this information and can answer what state this node has
			{
				if (NodeSet(*rgnid, state, false)) // set sniffed node current and set its state
				{
					SetAdditionalDataOnNodeSet(*rgnid);
					return GTSGetRecommendations(cnid, rgnid, true); // recursive call - hope BNTS will not recommend a node which is set
				}
			}
			return RECOMMEND_SUCCESS;
		}
		else
		{
			rgnid[0] = nidService;
			cnid = 1;
			return RECOMMEND_NO_MORE_DATA;
		}
	}
	else
	{
		// the last node was sniffed and its state was set
		// after that we received FALSE from BGetRecommendation;
		// we unset this node (in order to be able to use BGetRecommendation later on);
		// we return value indicating that BNTS cannot give us any recommendations
		NodeSet(m_rgnid[m_cnid-1], -1, false);
		return RECOMMEND_NO_MORE_DATA;
	}

	return RECOMMEND_FAIL;
}

void BCache::SetAdditionalDataOnNodeSet(NID nid)
{
	m_rgsniff[m_cnid-1] = 1;
	m_arrNidLastSniffed.Add(nid);
}

BOOL InArray(UINT num, UINT aNums[], UINT max)
{
	UINT x = max;
	BOOL bRes = FALSE;
	for (UINT y = 0; y < x; y++)
	{
		if (aNums[y] == num)
		{
			bRes = TRUE;
			break;
		}
	}
	return bRes;
}

// RemoveRecommendations is called for nodes whos' state is less than 100.
void BCache::RemoveRecommendation(int Nid)
{
	VERIFY(BNodeSetCurrent(Nid));
	BNodeSet(-1, false);
	if (m_cnid)
		m_cnid--;
	return;
}

//
//
UINT GTSAPI::GetNodeList(NID **pNid, IST **pIst)
{
	*pNid = m_rgnid;
	*pIst = m_rgist;
	return m_cnid;
}

BOOL GTSAPI::BNodeSetCurrent(int node)
{
	return BNTS::BNodeSetCurrent(node);
}

//
//
BOOL BCache::NodeSet(NID nid, IST ist, bool bPrevious)
{
	BOOL bRes = FALSE;

	// shouldn't happen...but to be safe
	if (m_cnid >= MAX_NID)
		return FALSE;

	m_rgnid[m_cnid] = nid;
	m_rgist[m_cnid] = ist;

	if (false == bPrevious)
	{
		VERIFY(BNodeSetCurrent(nid));
		bRes = BNodeSet(ist, false);
		if (bRes &&	// bnts worked successfully
			-1 == GetIndexNodeInCache(nid) // this nid is not present in the cache
		   )
			m_cnid++;
	}
	else
	{
		bRes = TRUE;
	}
	return bRes;
}

//
//
int BCache::GetIndexNodeInCache(NID nid)
{
	for (unsigned int i = 0; i < m_cnid; i++)
		if (m_rgnid[i] == nid)
			return i;
	return -1;
}

//
//
VOID BCache::ResetNodes()
{
	for (UINT inid = 0; inid < m_cnid; inid++)
	{
		VERIFY(BNodeSetCurrent(m_rgnid[inid]));
		BNodeSet(-1, false);	// Nil value
	}
	m_cnid = 0;
}		

//
//
DWORD GTSAPI::GetStatus()
{
	return m_dwErr;
}

//
//
VOID GTSAPI::Destroy()
{
	if (m_pchHtml) {
		delete [] m_pchHtml;
		m_pchHtml = NULL;
	}

	/*
	if (m_pWNList) {
		
		if (!m_dwErr)
			m_dwErr = m_pWNList->GetStatus();
		
		delete m_pWNList;
		m_pWNList = NULL;
	}
	*/
	if (m_pCache) {
		if (!m_dwErr)
			m_dwErr = m_pCache->GetStatus();
		delete m_pCache;
		m_pCache = NULL;
	}
}

//
//
UINT GTSAPI::GetProblemArray(IDH **idh)
{
	*idh = m_idstore;
	return m_currid;
}

//
//
IDH GTSAPI::GetProblemAsk()
{
	return m_probask;
}

void GTSAPI::AddValue(int value)
{
	ASSERT(m_currid < MAXPROBID);
	m_idstore[m_currid++] = value;
	return;
}

BOOL BCache::CheckNode(int Node)
{
	BOOL bCached = m_CacheGen.IsNodePresent(Node);
	if (!bCached && m_bNeedModel)
	{
		ReadTheDscModel(TSERR_ENGINE_BNTS_CHECK);
	}	
	return bCached;
}

//-------------------------------------------------------------
// BNTS Overrides to replace the dsc file with our cache.
// Need to override everything but BReadModel and BGetRecommendations.

int BCache::CNode()
{
	int cNodes;
	if (FALSE == m_bNeedModel)
		cNodes = GTSAPI::CNode();
	else
		cNodes = m_CacheGen.GetNodeCount();
	return cNodes;
}

BOOL BCache::BImpossible()
{
	BOOL bImpossible = FALSE;
	if (FALSE == m_bNeedModel)
		bImpossible = GTSAPI::BImpossible();
	return bImpossible;
}

BOOL BCache::BNetPropItemStr(LPCTSTR szPropType, int index)
{
	BOOL bGoodIndex = FALSE;
	char sznPropType[MAX_SYM_NAME_BUF_LEN];
	int nPropLen = MAX_SYM_NAME_BUF_LEN;
	if (!GTSCacheGenerator::TcharToChar(sznPropType, szPropType, nPropLen))
		return FALSE;
	if (CheckNode(m_CurNode))
	{
		bGoodIndex = m_CacheGen.FindNetworkProperty(sznPropType, m_strResult, index);
		if (!bGoodIndex && !m_bNeedModel)
		{
			bGoodIndex = GTSAPI::BNetPropItemStr(szPropType, index);
			m_strResult = GTSAPI::SzcResult();
		}
	}
	else
	{
		bGoodIndex = GTSAPI::BNetPropItemStr(szPropType, index);
		m_strResult = GTSAPI::SzcResult();
	}
	return bGoodIndex;
}

BOOL BCache::BNodeSetCurrent(int node)
{
	BOOL bNodeSet = TRUE;
	if (CheckNode(node) && TRUE == m_bNeedModel)
	{
		m_CurNode = node;
	}
	else
	{
		bNodeSet = GTSAPI::BNodeSetCurrent(node);
		m_CurNode = node;
	}
	return bNodeSet;
}

int BCache::INode(LPCTSTR szNodeSymName)
{
	UINT index = 0;
	if (FALSE == m_bNeedModel)
		index = GTSAPI::INode(szNodeSymName);
	else
		if (!m_CacheGen.GetNodeIDFromSymName(szNodeSymName, index))
		{	// Have to have BNTS load the network and the the symbolic name.
			ReadTheDscModel(TSERR_ENGINE_CACHE_LOW);
			index = GTSAPI::INode(szNodeSymName);
		}
	return (signed int) index;
}

ESTDLBL BCache::ELblNode()
{
	UINT NodeLable;
	ESTDLBL Lable;
	if (FALSE == m_bNeedModel)
	{
		Lable = GTSAPI::ELblNode();
	}
	else
	{
		VERIFY(m_CacheGen.GetLabelOfNode(m_CurNode, NodeLable));
		Lable = (ESTDLBL) NodeLable;
	}
	return Lable;
}

int BCache::INodeCst()
{
	int cStates = 2;

	return cStates;
}

BOOL GTSAPI::BNodeSet(int state, bool bset)
{
	return BNTS::BNodeSet(state, bset);
}

BOOL BCache::BNodeSet(int istate, bool bSet)
{
	BOOL bNodeWasSet = TRUE;
	if (FALSE == m_bNeedModel)
		bNodeWasSet = GTSAPI::BNodeSet(istate, bSet);
	if (bNodeWasSet)
	{
		if (-1 != istate)
			m_NodeState.SetAt(m_CurNode, istate);
		else
			m_NodeState.RemoveKey(m_CurNode);
	}
	return bNodeWasSet;
}

int BCache::INodeState()
{	// This is ok.  See BNodeSet.
	int state;
	if (!m_NodeState.Lookup(m_CurNode, state))
		state = 0;
	return state;
}

void BCache::NodeStateName(int istate)
{
	if (FALSE == m_bNeedModel)
	{
		GTSAPI::NodeStateName(istate);
		m_strResult = GTSAPI::SzcResult();
	}
	else
	{
		BOOL bFound;
		switch(istate)
		{
		case 0:
			bFound = m_CacheGen.FindNodeProperty(m_CurNode, G_S0_NAME, m_strResult, 0);
			break;
		case 1:
			bFound = m_CacheGen.FindNodeProperty(m_CurNode, G_S1_NAME, m_strResult, 0);
			break;
		default:
			bFound = FALSE;
		}
		if (!bFound)
		{
			ASSERT(FALSE);
			m_strResult = _T("");
		}
	}
	return;
}

void BCache::NodeSymName()
{
	if (FALSE == m_bNeedModel)
	{
		GTSAPI::NodeSymName();
		m_strResult = GTSAPI::SzcResult();
	}
	else if (CheckNode(m_CurNode))
	{
		VERIFY(m_CacheGen.FindNodeProperty(m_CurNode, G_SYMBOLIC_NAME, m_strResult, 0));
	}
	return;
}

void BCache::NodeFullName()
{
	if (FALSE == m_bNeedModel)
	{
		GTSAPI::NodeFullName();
		m_strResult = GTSAPI::SzcResult();
	}
	else
	{
		VERIFY(m_CacheGen.FindNodeProperty(m_CurNode, G_FULL_NAME, m_strResult, 0));
	}
	return;
}

BOOL BCache::BNodePropItemStr(LPCTSTR szPropType, int index)
{
	BOOL bGoodIndex = FALSE;
	char sznPropType[MAX_SYM_NAME_BUF_LEN];
	int nPropTypeLen = MAX_SYM_NAME_BUF_LEN;
	if (!GTSCacheGenerator::TcharToChar(sznPropType, szPropType, nPropTypeLen))
		return FALSE;
	if (FALSE == m_bNeedModel)
	{
		bGoodIndex = GTSAPI::BNodePropItemStr(szPropType, index);
		m_strResult = GTSAPI::SzcResult();
	}
	else
	{
		bGoodIndex = m_CacheGen.FindNodeProperty(m_CurNode, sznPropType, m_strResult, index);
	}
	return bGoodIndex;
}

bool BCache::BValidNet()
{
	bool bValidNet;
	if (FALSE == m_bModelRead)	// Set to true in BCache::ReadModel.
		bValidNet = false;		// Causes the readmodel function to be called.
	else if (FALSE == m_bNeedModel)
		bValidNet = GTSAPI::BValidNet();
	else
		bValidNet = true;
	return bValidNet;
}

LPCTSTR BCache::SzcResult() const
{
	return (LPCTSTR) m_strResult;
}

const CArray<int, int>& BCache::GetArrLastSniffed()
{
	return m_arrNidLastSniffed;
}

int BCache::GetCountRecommendedNodes()
{
	return m_cnid;
}

int BCache::GetCountSniffedRecommendedNodes()
{
	for (unsigned int i = 0, j = 0; i < m_cnid; i++)
		if (m_rgsniff[i] == 1)
			j++;
	return j;
}

bool BCache::IsReverse()
{
	return m_bReverse;
}

void BCache::SetReverse(bool reverse)
{
	m_bReverse = reverse;
}

void BCache::SetRunWithKnownProblem(bool yes)
{
	m_bRunWithKnownProblem = yes;
}

bool BCache::IsRunWithKnownProblem()
{
	return m_bRunWithKnownProblem;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtsfst.h ===
//
// MODULE:  APGTSFST.H
//
// PURPOSE:  Creates a list of available trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __APGTSFST_H_
#define __APGTSFST_H_ 1

class CFirstPageException : public CBasicException
{
public:
	CFirstPageException(){m_strError=_T("");};
	~CFirstPageException(){};

	CString m_strError;
};

class CFirstPage
{
public:
	CFirstPage();
	~CFirstPage();

	void RenderFirst(CString &strOut, CString &strTS);

	CString m_strFpResourcePath;

protected:

	HKEY m_hKey;	// The key to the list of trouble shooters.
	BOOL m_bKeyOpen;

	void OpenRegKeys();
	void CloseRegKeys();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtsfst.cpp ===
//
// MODULE:  APGTSFST.H
//
// PURPOSE:  Creates a list of available trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "TSHOOT.h"

#include "ErrorEnums.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "BasicException.h"
#include "apgtsfst.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"

#include "apgtscls.h"

CFirstPage::CFirstPage()
{
	m_strFpResourcePath = _T("");
	m_bKeyOpen = FALSE;
	m_hKey = NULL;
	return;
}

CFirstPage::~CFirstPage()
{
	if (m_bKeyOpen)
		RegCloseKey(m_hKey);
	return;
}

void CFirstPage::OpenRegKeys()
{
	DWORD dwSize;
	DWORD dwType;
	long lErr;
	DWORD dwDisposition = 0;
	CString strRegKey;
	CString strBuf1;
	strRegKey.Format(_T("%s\\%s"), TSREGKEY_MAIN, REGSZ_TSTYPES);
	m_hKey = NULL;
	m_bKeyOpen = FALSE;
	// Find the resource directory.
	if (RegCreateKeyEx(	HKEY_LOCAL_MACHINE, 
						TSREGKEY_MAIN,
						0, 
						TS_REG_CLASS, 
						REG_OPTION_NON_VOLATILE, 
						KEY_READ | KEY_WRITE,
						NULL, 
						&m_hKey, 
						&dwDisposition) == ERROR_SUCCESS) 
	{
		m_bKeyOpen = TRUE;
		if (dwDisposition == REG_OPENED_EXISTING_KEY) 
		{
			dwSize = MAXBUF - 1;
			dwType = REG_SZ;
			
			if ((lErr = RegQueryValueEx(m_hKey,
								FULLRESOURCE_STR,
								0,
								&dwType,
								(LPBYTE) m_strFpResourcePath.GetBufferSetLength(MAXBUF),
								&dwSize)) == ERROR_SUCCESS)
			{
				int len;
				m_strFpResourcePath.ReleaseBuffer();
				if (0 < (len = m_strFpResourcePath.GetLength()))
				{
					if (m_strFpResourcePath.GetAt(len - 1) != _T('\\'))
						m_strFpResourcePath += _T('\\');
				}
				else
				{
					strBuf1.Format(_T("%ld"),lErr);
					ReportWFEvent(	_T("[apgtscfg]"), //Module Name
									_T("[GetResourceDirFromReg]"), //event
									(TCHAR*)(LPCTSTR) strBuf1,
									_T(""),
									EV_GTS_ERROR_CANT_OPEN_SFT_3 );
					CFirstPageException *pExc = new CFirstPageException;
					pExc->m_strError.LoadString(IDS_I_NO_TS1);
					throw pExc;
				}
			}
			else
			{
				strBuf1.Format(_T("%ld"),lErr);
				ReportWFEvent(	_T("[apgtscfg]"), //Module Name
								_T("[GetResourceDirFromReg]"), //event
								(TCHAR*)(LPCTSTR) strBuf1,
								_T(""),
								EV_GTS_ERROR_CANT_OPEN_SFT_3 );
				CFirstPageException *pExc = new CFirstPageException;
				pExc->m_strError.LoadString(IDS_I_NO_TS1);
				throw pExc;
			}
		}
		else
		{	// Created new key.  Don't have any resources.
			strBuf1.Format(_T("%ld"),ERROR_REGISTRY_IO_FAILED);
			ReportWFEvent(	_T("[apgtscfg]"), //Module Name
							_T("[GetResourceDirFromReg]"), //event
							(TCHAR*)(LPCTSTR) strBuf1,
							_T(""),
							EV_GTS_ERROR_CANT_GET_RES_PATH);
			CFirstPageException *pExc = new CFirstPageException;
			pExc->m_strError.LoadString(IDS_I_NO_TS1);
			throw pExc;
		}
	}
	else
	{
		ReportWFEvent(	_T("[apgtscfg]"), //Module Name
						_T("[GetResourceDirFromReg]"), //event
						_T(""),
						_T(""),
						EV_GTS_ERROR_CANT_OPEN_SFT_2 ); 
		CFirstPageException *pExc = new CFirstPageException;
		pExc->m_strError.LoadString(IDS_I_NO_TS1);
		throw pExc;
	}
	m_bKeyOpen = FALSE;
	// Open the key to the trouble shooter list.
	if (RegCreateKeyEx(	HKEY_LOCAL_MACHINE, 
						(LPCTSTR) strRegKey, 
						0, 
						TS_REG_CLASS, 
						REG_OPTION_NON_VOLATILE, 
						KEY_READ | KEY_WRITE,
						NULL, 
						&m_hKey, 
						&dwDisposition) == ERROR_SUCCESS) 
	{
		m_bKeyOpen = TRUE;
		if (dwDisposition == REG_OPENED_EXISTING_KEY) 
		{
		}
		else
		{	// Created new key.  Don't have any resources.
			strBuf1.Format(_T("%ld"),ERROR_REGISTRY_IO_FAILED);
			ReportWFEvent(	_T("[apgtscfg]"), //Module Name
							_T("[GetResourceDirFromReg]"), //event
							(TCHAR*)(LPCTSTR) strBuf1,
							_T(""),
							EV_GTS_ERROR_CANT_GET_RES_PATH);
			CFirstPageException *pExc = new CFirstPageException;
			pExc->m_strError.LoadString(IDS_I_NO_TS1);
			throw pExc;
		}
	}
	else
	{
		ReportWFEvent(	_T("[apgtscfg]"), //Module Name
						_T("[GetResourceDirFromReg]"), //event
						_T(""),
						_T(""),
						EV_GTS_ERROR_CANT_OPEN_SFT_2 ); 
		CFirstPageException *pExc = new CFirstPageException;
		pExc->m_strError.LoadString(IDS_I_NO_TS1);
		throw pExc;
	}
	return;
}

void CFirstPage::CloseRegKeys()
{
	RegCloseKey(m_hKey);
	m_hKey = NULL;
	return;
}

void CFirstPage::RenderFirst(CString &strOut, CString &strTShooter)
{
	CString strTemplate;
	OpenRegKeys();
	strOut = _T("");
	CInfer Infer(&strOut);
	strTemplate.Format(_T("%s%s.hti"), (LPCTSTR) m_strFpResourcePath, (LPCTSTR) strTShooter);
	CHTMLInputTemplate inputTemplate((LPCTSTR) strTemplate);
	Infer.LoadTShooters(m_hKey);
	CloseRegKeys();
	inputTemplate.Initialize(_T(""), _T(""));
	inputTemplate.SetType(_T("Unknown"));
	inputTemplate.SetInfer(&Infer, _T(""));
	inputTemplate.Print(1, &strOut);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtshtx.h ===
//
// MODULE: APGTSHTX.H
//
// PURPOSE: HTX File Support header
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//			further work by Roman Mach (RM), Richard Meadows (RWM), Joe Mabel, Oleg Kalosha
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		8/15/96		VM		New htx format
// V0.3		6/4/97		RWM		Local Version for Memphis
// V0.4		3/24/98		JM		Local Version for NT5
//


#define HTX_FILENAME		_T("gtstemp.hti")

#define HTX_MAXSTORE		4096

#define HTX_COMMAND_START	_T("<!GTS")
#define HTX_COMMAND_END		_T(">")
#define HTX_IFSTR			_T("if")
#define HTX_ELSESTR			_T("else")
#define HTX_ENDIFSTR		_T("endif")
#define HTX_FORANYSTR		_T("forany")
#define HTX_ENDFORSTR		_T("endfor")
#define HTX_DISPLAYSTR		_T("display")
#define HTX_RESOURCESTR		_T("resource")	// For adding include files from the resource directory.


// these are types detected
#define HTX_TYPEBEGIN		0		// apparently never used (12/97)
#define HTX_TYPEINSERT		1		// apparently never used (12/97)
#define HTX_TYPEREPEAT		2		// apparently never used (12/97)
#define HTX_TYPEEND			3		// apparently never used (12/97)

#define HTX_TYPEIF			4
#define HTX_TYPEELSE		5
#define HTX_TYPEENDIF		6
#define HTX_TYPEFORANY		7
#define HTX_TYPEENDFOR		8
#define HTX_TYPEDISPLAY		9
#define HTX_TYPESTART		10
#define HTX_TYPERESOURCE	11
// 
#define HTX_OFFSETMAX		10

#define DATA_PROBLEM_ASK		_T("$ProblemAsk")
#define DATA_RECOMMENDATIONS	_T("$Recommendations")
#define DATA_STATE				_T("$States")
#define DATA_QUESTIONS			_T("$Questions")
#define DATA_BACK				_T("$Back")
#define DATA_TROUBLE_SHOOTERS	_T("$TroubleShooters")		// Used to display the list of available trouble shooters.

// >>> code would be easier to follow if these related constants had a common prefix.
#define PROBLEM_ASK_INDEX		1
#define RECOMMENDATIONS_INDEX	2
#define STATE_INDEX				3
#define QUESTIONS_INDEX			4
#define BACK_INDEX				5
#define TROUBLE_SHOOTER_INDEX	6
#define RESOURCE_INDEX			7


// Gets data from htx file and builds html sections in memory
// This is only called once in dllmain
//
class CHTMLInputTemplate
{
public:
	CHTMLInputTemplate(const TCHAR *);
	~CHTMLInputTemplate();

	DWORD Reload();

	UINT GetCount();
	UINT GetStatus();
	Print(UINT nargs, CString *cstr);
	VOID SetInfer(CInfer *infer, TCHAR *vroot);
	HTXCommand *GetFirstCommand();
	void SetType(LPCTSTR type);
	void DumpContentsToStdout();
	DWORD Initialize(LPCTSTR szResPath, CString strFile);

protected:
	void ScanFile();
	UINT BuildInMem();
	UINT CheckVariable(TCHAR *var_name);
	VOID Destroy();
	HTXCommand *Pop();
	Push(HTXCommand *command);
	bool IsFileName(TCHAR *name);

protected:
	CString m_strResPath;	// path to HTI (CHM) file
	CString m_strFile;	    // filename of HTI file if m_filename is pointing to CHM file
	int m_cHeaderItems;		// (JM 10/25/97 not sure of this but looks like:) 
							// number of resource files we've copied into memory
							// & which we dump into the header of HTML file
	DWORD m_dwErr;

	TCHAR *m_startstr;		// pointer to the text of the whole HTI file
	TCHAR *m_chopstr;		// used only during initialization of this object.  Initially, 
							//	a copy of the whole HTI file, which gets chopped apart as we 
							//	look for various commands.
	DWORD m_dwSize;			// size of HTI file (so we know how big an array it needs in memory)

	HTXCommand *m_cur_command;	// as we build a singly linked list of commands (representing
								// a parse of the HTI file) this points
								// to the latest command added at the tail of the list.
	HTXCommand *m_command_start;	// points to first command in linked list of commands.
									// this basically corresponds to the first thing in the
									// HTI file.
	TCHAR m_filename[256];			// (path)name of HTI (or CHM) file
	// These next 2 members are for a stack which really ought to be an object 
	//	in its own right
	HTXCommand *m_command_stack[10];	// a stack to keep track of things like an
										// "if" waiting for an "else"/"endif" or a "for"
										// waiting for an "endfor"
	UINT m_cur_stack_count;				// top-of-stack index
	CInfer *m_infer;				// access to inference object so we can drive use of 
									//	inference object by this particular template.
	UINT m_problemAsk;				// apparently unused 10/97
	TCHAR m_tstype[30];				// This is the symbolic name XXX of the troubleshooter.
									//  In the FORM in the resulting HTML this is used
									//  in the context:
									// <INPUT TYPE=HIDDEN NAME="type" VALUE=XXX>
	TCHAR m_vroot[MAXBUF];			// >>> ??
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtshdt.cpp ===
//
// MODULE: APGTSHDT.CPP
//
// PURPOSE: Methods for the various commands (classes). Commands are
//			Resposable for executing themseleves.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.15	8/15/96		VM		New htx format
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//
#include "stdafx.h"
//#include <windows.h>

#include <stdio.h> 
#include <stdlib.h>
#include <string.h>  
#include <stdarg.h>
#include <search.h>
#include <dos.h>
#include <ctype.h>
#include <limits.h>
#include <time.h>

#include "apgts.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"

#include "ErrorEnums.h"

#include "chmread.h"
//
//
HTXCommand::HTXCommand(UINT type, const TCHAR *idstr)
{
	m_beforehtmlstr = NULL;
	m_afterhtmlstr = NULL;
	m_beforesize = 0;
	m_aftersize = 0;
	m_start = 0;
	m_end = 0;
	m_type = type;
	m_idstr = idstr;
	m_error = FALSE;
	m_next = NULL;
}

//
//
HTXCommand::~HTXCommand()
{
	if (m_beforehtmlstr != NULL) 
		free(m_beforehtmlstr);

	if (m_afterhtmlstr != NULL) 
		free(m_afterhtmlstr);	
}

//
//
void HTXCommand::SetStart(UINT pos)
{
	m_start = pos;
}

//
//
void HTXCommand::SetEnd(UINT pos)
{
	m_end = pos;
}

//
//
UINT HTXCommand::GetStart()
{
	return (m_start);
}

//
//
UINT HTXCommand::GetEnd()
{
	return (m_end);
}

//
//
UINT HTXCommand::GetType()
{
	return (m_type);
}

//
//
UINT HTXCommand::GetStatus()
{
	return (m_error);
}

//
//
const TCHAR *HTXCommand::GetIDStr()
{
	return (m_idstr);
}

//
//
UINT HTXCommand::GetBeforeLen()
{
	return (m_beforelen);
}

//
//
UINT HTXCommand::GetAfterLen()
{
	return (m_afterlen);
}

//
//
TCHAR *HTXCommand::GetBeforeStr()
{
	return (m_beforehtmlstr);
}

//
//
TCHAR *HTXCommand::GetAfterStr()
{
	return (m_afterhtmlstr);
}

//
//
UINT HTXCommand::ReadBeforeStr(UINT start, UINT end, LPCTSTR startstr)
{
	m_beforesize = (UINT) (end - start);
	
	ASSERT (m_beforesize >= 0);
	
	m_beforehtmlstr = (TCHAR *)malloc((m_beforesize + 1) * sizeof (TCHAR));
	if (m_beforehtmlstr == NULL) 
		return (m_error = TRUE);
	// copy data
	memcpy(m_beforehtmlstr, &startstr[start], m_beforesize * sizeof (TCHAR));

	m_beforehtmlstr[m_beforesize] = _T('\0');
	m_beforelen = _tcslen(m_beforehtmlstr);
	return (FALSE);
}

//
//
UINT HTXCommand::ReadAfterStr(UINT start, UINT end, LPCTSTR startstr)
{
	m_aftersize = (UINT) (end - start);
	
	ASSERT (m_aftersize >= 0);

	m_afterhtmlstr = (TCHAR *)malloc((m_aftersize + 1) * sizeof (TCHAR));
	if (m_afterhtmlstr == NULL) 
		return (m_error = TRUE);
	// copy data
	memcpy(m_afterhtmlstr, &startstr[start], m_aftersize * sizeof (TCHAR));

	m_afterhtmlstr[m_aftersize] = _T('\0');
	m_afterlen = _tcslen(m_afterhtmlstr);
	return (FALSE);
}

//
//
HTXCommand *HTXCommand::Execute(CString *cstr, CInfer *infer)
{
	*cstr += GetAfterStr();
	return( this);
}

HTXCommand *HTXCommand::GetNext()
{
	return(m_next);
}

void HTXCommand::SetNext(HTXCommand *next)
{
	m_next = next;
}


HTXIfCommand::HTXIfCommand(UINT type, TCHAR *idstr, UINT variable): HTXCommand(type, idstr)
{
	m_else = NULL;
	m_endif = NULL;
	m_var_index = variable;
}

HTXIfCommand::~HTXIfCommand()
{
	
}
//
// PURPOSE:		Will execute the 'if' command. When done it will return a pointer
//				to the 'endif' command.
//
HTXCommand *HTXIfCommand::Execute(CString *cstr, CInfer *infer)
{
	HTXCommand *cur_com;

	if ( infer->EvalData(m_var_index ) != NULL) {
		*cstr += GetAfterStr();
		//execute if commands
		cur_com = this->GetNext();
		while (cur_com->GetType() != HTX_TYPEELSE && 
			   cur_com->GetType() != HTX_TYPEENDIF) {
			cur_com = cur_com->Execute(cstr, infer);
			cur_com = cur_com->GetNext();
		}
	} else {
		if ((cur_com = this->GetElse()) != NULL) {
			while (cur_com->GetType() != HTX_TYPEENDIF) {
				cur_com = cur_com->Execute(cstr, infer);
				cur_com = cur_com->GetNext();
			}	
		}
	}
	cur_com = this->GetEndIf();
	cur_com->Execute(cstr, infer);
	return(cur_com);
}

HTXCommand *HTXCommand::GetElse()
{
	return(NULL);
}
HTXCommand *HTXCommand::GetEndIf()
{
	return(NULL);

}
HTXCommand *HTXCommand::GetEndFor()
{
	return(NULL);

}
void HTXCommand::SetElse(HTXCommand *elseif)
{
}

void HTXCommand::SetEndIf(HTXCommand *endifif)
{
}
void HTXCommand::SetEndFor(HTXCommand *endfor)
{
}
void HTXCommand::GetResource(CString &strResPath, const CString& strCHM)
{
}
//
//
HTXCommand *HTXIfCommand::GetEndIf()
{
	return(m_endif);
}

//
//
void HTXIfCommand::SetEndIf(HTXCommand *endif)
{
	m_endif = endif;
}

//
//
HTXCommand *HTXIfCommand::GetElse()
{
	return(m_else);
}

//
//
void HTXIfCommand::SetElse(HTXCommand *elseif)
{
	m_else = elseif;
}

HTXForCommand::HTXForCommand(UINT type, TCHAR *idstr, UINT variable): HTXCommand(type, idstr)
{
	m_endfor = NULL;
	m_var_index = variable;
}

HTXForCommand::~HTXForCommand()
{
}

//
// PURPOSE:		Executes the 'forany' command. when done it
//				will retrurn a pointer to the 'endfor' command.
//
HTXCommand *HTXForCommand::Execute(CString *cstr, CInfer *infer)
{
	HTXCommand *cur_com;
	
	if (!(infer->InitVar(m_var_index)) ){
		this->GetEndFor()->Execute(cstr,infer);
		return(this->GetEndFor());
	}

	cur_com = this;
	do  {
		*cstr += cur_com->GetAfterStr();
		cur_com = cur_com->GetNext();
		while (cur_com->GetType() != HTX_TYPEENDFOR) {
			cur_com = cur_com->Execute(cstr, infer);
			cur_com = cur_com->GetNext();
		}
		cur_com = this;
	} while (infer->NextVar(m_var_index));
	cur_com = this->GetEndFor();
	cur_com->Execute(cstr,infer);
	return(cur_com);
}

//
//
HTXCommand *HTXForCommand::GetEndFor()
{
	return(m_endfor);
}

//
//
void HTXForCommand::SetEndFor(HTXCommand *endfor)
{
	m_endfor = endfor;
}

HTXDisplayCommand::HTXDisplayCommand(UINT type, TCHAR *idstr, UINT variable): HTXCommand(type, idstr)
{
	m_var_index = variable;
}

HTXDisplayCommand::~HTXDisplayCommand()
{

}

HTXCommand *HTXDisplayCommand::Execute(CString *cstr, CInfer *infer)
{	
	TCHAR *pstr;

	if ((pstr=infer->EvalData(m_var_index))!= NULL)
		*cstr += pstr;
	*cstr += GetAfterStr();
	return(this);
}

HTXResourceCommand::HTXResourceCommand(UINT type, TCHAR *idstr)
: HTXCommand(type, idstr)
{
	m_strResource = _T("");
	m_strFileName = _T("");
	return;
}

HTXResourceCommand::~HTXResourceCommand()
{
	return;
}

void HTXResourceCommand::GetResName(LPCTSTR var_name)
{
	m_strFileName = &var_name[1];
	// Remove the > from the end.
	TCHAR EndChar[2];
	EndChar[0] = m_strFileName.GetAt(m_strFileName.GetLength() - 1);
	EndChar[1] = NULL;
	if (0 == _tcsncmp(_T(">") , EndChar, 1))
	{
		m_strFileName.GetBufferSetLength(m_strFileName.GetLength() - 1);
		m_strFileName.ReleaseBuffer();
	}
	return;
}

// strCHM contains CHM file name. Must be empty if resource file is not inside CHM.
void HTXResourceCommand::GetResource(CString& strResPath, const CString& strCHM)
{
	CString strFile;

	if (strCHM.GetLength())
	{
		char* tmp_buf =NULL;
		ULONG Bytes =0;

		strFile = strResPath + strCHM;
		// m_filename is CHM file path and name
		// and strFile - file name within CHM
		if (S_OK != ::ReadChmFile(strFile, m_strFileName, (void**)&tmp_buf, &Bytes))
		{
			// ERROR READING CHM
			return;
		}
		tmp_buf[Bytes] = NULL;
		m_strResource = tmp_buf;
	}
	else
	{
		FILE *pFile;
		CHAR szBuf[4097];
		size_t Bytes =0;

		strFile = strResPath + m_strFileName;
		if (NULL == (pFile = _tfopen((LPCTSTR) strFile, _T("rb"))))
			ReportError(TSERR_RES_MISSING);
		do
		{
			if((Bytes = fread(szBuf, 1, 4096, pFile)) > 0)
			{
				szBuf[Bytes] = NULL;
				m_strResource += szBuf;
			}
		} while (Bytes == 4096);
		if (!feof(pFile))
		{
			fclose(pFile);
			ReportError(TSERR_RES_MISSING);
		}
		fclose(pFile);
	}
	return;
}

HTXCommand *HTXResourceCommand::Execute(CString *cstr, CInfer *)
{	
	// Read the resource file into cstr.
	*cstr += m_strResource;
	*cstr += GetAfterStr();
	return(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtshtx.cpp ===
//
// MODULE: APGTSHTX.CPP
//
// PURPOSE: Template file decoder
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//
// ORIGINAL DATE: 8-2-96
//
// NOTES:
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.15	8/15/96		VM		New htx format
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//
#include "stdafx.h"
//#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <search.h>
#include <dos.h>
#include <ctype.h>
#include <limits.h>
#include <time.h>

#include "apgts.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"

#include "TSHOOT.h"

#include "chmread.h"
//
//
CHTMLInputTemplate::CHTMLInputTemplate(const TCHAR *filename)
{
	// initialize a few things
	m_dwErr = 0;
	m_cur_stack_count=0;
	m_command_start = NULL;
	_tcscpy(m_filename,filename);
	m_cHeaderItems = 0;
	m_infer = NULL;
	m_strResPath = _T("");
}

//
//
CHTMLInputTemplate::~CHTMLInputTemplate()
{
	Destroy();	
}

//
// must be locked to use
//
VOID CHTMLInputTemplate::SetInfer(CInfer *infer, TCHAR *vroot)
{
	m_infer = infer;
	_tcscpy(m_vroot, vroot);
}
//
//
DWORD CHTMLInputTemplate::Initialize(LPCTSTR szResPath, CString strFile)
{
	CHAR *filestr;

	m_dwErr = 0;
	m_strResPath = szResPath;
	m_strFile = strFile;

	if (strFile.GetLength())
	{
		// m_filename is CHM file path and name
		// and strFile - file name within CHM
		if (S_OK != ::ReadChmFile(m_filename, strFile, (void**)&filestr, &m_dwSize))
		{
			m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;//fix!
			return m_dwErr;
		}
	}
	else
	{
		// m_filename is a free standing file
		DWORD nBytesRead;
		HANDLE hFile;
		BOOL bResult;
		hFile = CreateFile(	m_filename,
							GENERIC_READ,
							FILE_SHARE_READ,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL );

		if (hFile == INVALID_HANDLE_VALUE)
		{
			//???
			//ReportError(TSERR_RESOURCE);

			m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;//fix!
			return m_dwErr;
		}

		m_dwSize = GetFileSize(hFile, NULL);
		filestr = (CHAR *)malloc(m_dwSize+1);
		
		if (!((m_dwSize != 0xFFFFFFFF) && (m_dwSize != 0)) || filestr == NULL)
		{
			CloseHandle(hFile);
			m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;//fix!
			return m_dwErr;
		}

		bResult = ReadFile(hFile, filestr, m_dwSize, &nBytesRead, NULL);
		
		if(!(bResult && nBytesRead == m_dwSize))
		{
			CloseHandle(hFile);
			free(filestr);
			m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;//fix!
			return m_dwErr;
		}

		CloseHandle(hFile);
		hFile = NULL;
	}

	filestr[m_dwSize] = '\0';

#ifdef _UNICODE
	WCHAR *wfilestr = (WCHAR *)malloc((m_dwSize + 1) * sizeof (WCHAR));
	WCHAR *wchopstr = (WCHAR *)malloc((m_dwSize + 1) * sizeof (WCHAR));
	MultiByteToWideChar( CP_ACP, 0, filestr, -1, wfilestr, m_dwSize );
	MultiByteToWideChar( CP_ACP, 0, filestr, -1, wchopstr, m_dwSize );
	m_startstr = wfilestr;
	m_chopstr = wchopstr;
#else
	m_startstr = filestr;
	m_chopstr = (CHAR *)malloc(m_dwSize+1);
	strcpy(m_chopstr, filestr);
#endif
	
	// get locations of start and end blocks
	ScanFile();

	// copy blocks into ram for speed
	BuildInMem();
	
	// free memory
	free(filestr);

#ifdef _UNICODE
	free(wfilestr);
#endif
	free(m_chopstr);

	return m_dwErr;
}

//
//
VOID CHTMLInputTemplate::Destroy()
{
	HTXCommand *command, *nextcommand;

	// free holders
	command = m_command_start;
	nextcommand = command;
	while (command != NULL) {
		nextcommand = command->GetNext();
		delete command;
		command = nextcommand;
	}
}

//
//
DWORD CHTMLInputTemplate::Reload()
{
	Destroy();
	return Initialize((LPCTSTR) m_strResPath, m_strFile);
}

//
//
void CHTMLInputTemplate::ScanFile()
{
	UINT start, end;
	TCHAR *ptr, *sptr, *eptr, var_name[30];
	HTXCommand *tmpCommand, *prevCommand;
	UINT var_index;

	sptr = m_chopstr;
	m_cur_command = new HTXCommand(HTX_TYPESTART,_T(""));
	end = start = 0;
	m_cur_command->SetStart(start);
	m_cur_command->SetEnd(end);
	
	m_command_start = m_cur_command;

	// this is bad: if the user does not terminate each command on a separate line
	// the file will misbehave, should at least write out a warning or something...

	sptr = _tcstok(sptr, _T("\r\n"));
	if (sptr)
	{
		do
		{
			if ((sptr = _tcsstr(sptr,HTX_COMMAND_START)) != NULL)
			{
				if ((ptr = _tcsstr(sptr,HTX_ENDIFSTR))!=NULL)
				{
					tmpCommand = new HTXCommand(HTX_TYPEENDIF,HTX_ENDIFSTR);
					prevCommand = Pop();
					if (prevCommand->GetType() != HTX_TYPEIF)
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_IFMISTAG;
						break;
					}
					prevCommand->SetEndIf(tmpCommand);
				}
				else if ((ptr = _tcsstr(sptr,HTX_ENDFORSTR))!=NULL)
				{
					tmpCommand = new HTXCommand(HTX_TYPEENDFOR,HTX_ENDFORSTR);
					prevCommand = Pop();
					if (prevCommand->GetType() != HTX_TYPEFORANY)
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_FORMISTAG;
						break;
					}
					prevCommand->SetEndFor(tmpCommand);
				}
				else if ((ptr = _tcsstr(sptr,HTX_ELSESTR))!=NULL)
				{
					tmpCommand = new HTXCommand(HTX_TYPEELSE,HTX_ELSESTR);
					prevCommand = Pop();
					if (prevCommand->GetType() != HTX_TYPEIF)
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_IFMISTAG;
						break;
					}
					prevCommand->SetElse(tmpCommand);
					Push(prevCommand);
				}
				else if ((ptr = _tcsstr(sptr,HTX_IFSTR))!=NULL)
				{
					// get the variable
					ptr = _tcsninc(ptr, _tcslen(HTX_IFSTR));
					if( _stscanf(ptr,_T("%s"),var_name) <= 0)
							m_dwErr = EV_GTS_ERROR_ITMPL_IFMISTAG;
					if ((var_index = CheckVariable(var_name)) == FALSE )
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_VARIABLE;
						break;
					}
					tmpCommand = new HTXIfCommand(HTX_TYPEIF,HTX_IFSTR,var_index);
					Push(tmpCommand);
				}
				else if ((ptr = _tcsstr(sptr,HTX_FORANYSTR))!=NULL)
				{
					// get variable
					ptr = _tcsninc(ptr, _tcslen(HTX_FORANYSTR));
					if( _stscanf(ptr,_T("%s"),var_name) <= 0)
							m_dwErr = EV_GTS_ERROR_ITMPL_FORMISTAG;
					if ((var_index = CheckVariable(var_name)) == FALSE )
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_VARIABLE;
						break;
					}
					tmpCommand = new HTXForCommand(HTX_TYPEFORANY,HTX_FORANYSTR, var_index);
					Push(tmpCommand);
				}
				else if ((ptr = _tcsstr(sptr,HTX_DISPLAYSTR))!=NULL)
				{
					// get variable
					ptr = _tcsninc(ptr, _tcslen(HTX_DISPLAYSTR));
					if( _stscanf(ptr,_T("%s"),var_name) <= 0)
							m_dwErr = EV_GTS_ERROR_ITMPL_FORMISTAG;
					if ((var_index = CheckVariable(var_name)) == FALSE )
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_VARIABLE;
						break;
					}
					tmpCommand = new HTXDisplayCommand(HTX_TYPEDISPLAY,HTX_DISPLAYSTR, var_index);
				}
				else if ((ptr = _tcsstr(sptr, HTX_RESOURCESTR)) != NULL)
				{
					ptr = _tcsninc(ptr, _tcslen(HTX_RESOURCESTR));
					if (_stscanf(ptr, _T("%s"), var_name) <= 0)
						m_dwErr = EV_GTS_ERROR_ITMPL_FORMISTAG;
					if ((var_index = CheckVariable(var_name)) == FALSE)
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_VARIABLE;
						break;
					}
					m_cHeaderItems++;
					tmpCommand = new HTXResourceCommand(HTX_TYPERESOURCE, HTX_RESOURCESTR);
					((HTXResourceCommand *) tmpCommand)->GetResName(var_name);
				}
				else
					continue;

				// get the command terminator
				if ((eptr = _tcsstr(ptr,HTX_COMMAND_END)) == NULL)
				{
					m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;
					eptr = ptr; // try to recover
				}
				eptr = _tcsninc(eptr, _tcslen(HTX_COMMAND_END));

				if (tmpCommand == NULL)
				{
					m_dwErr = EV_GTS_ERROR_ITMPL_NOMEM;
					return;
				}

				// Add command to command list
				if (m_command_start == NULL)
				{
					m_command_start = tmpCommand;
					m_cur_command = tmpCommand;
				}
				else
				{
					m_cur_command->SetNext(tmpCommand);
					m_cur_command = tmpCommand;
				}

				CString strCHM = ::ExtractCHM(m_filename);
				tmpCommand->GetResource(m_strResPath, strCHM);

				start = (UINT)(sptr - m_chopstr); // / sizeof (TCHAR);
				end = (UINT)(eptr - m_chopstr); // / sizeof (TCHAR);

				tmpCommand->SetStart(start);
				tmpCommand->SetEnd(end);
			}
		} while ((sptr = _tcstok(NULL, _T("\r\n"))) != NULL);
	}
	

	if (m_cur_stack_count > 0) // missing and endfor or an endif
		m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;
}

/*
 * METHOD:	BuildInMem
 *
 * PURPOSE:	This method will read the HTML between commands (after) and associate
 *			it with the command. As a command is executed the HTML after the
 *			command is printed
 *
 */
UINT CHTMLInputTemplate::BuildInMem()
{
	HTXCommand *cur_com, *last_command;

	if (m_dwErr)
		return (TRUE);

	// copy strings from file to
	// note duplication of effort (before and after strings may be same string)
	cur_com = m_command_start;
	last_command = cur_com;
	while (cur_com != NULL) {			
	    if (cur_com->GetNext() == NULL) {
			if (cur_com->ReadAfterStr(cur_com->GetEnd(), m_dwSize, m_startstr))
				return (m_dwErr = EV_GTS_ERROR_ITMPL_NOMEM);
		}
		else {
			if (cur_com->ReadAfterStr(cur_com->GetEnd(), cur_com->GetNext()->GetStart(), m_startstr))
				return (m_dwErr = EV_GTS_ERROR_ITMPL_NOMEM);
		}
		last_command = cur_com;
		cur_com = cur_com->GetNext();
	}
	return (FALSE);
}

//
//
bool CHTMLInputTemplate::IsFileName(TCHAR *name)
{
	bool bFileName;
	if (name[0] != _T('$'))
		bFileName = false;
	else if (NULL == _tcsstr(name, _T(".")))
		bFileName = false;
	else
		bFileName = true;
	return bFileName;
}
/*
 * METHOD:	CheckVariable
 *
 * PURPOSE:	This routine will check to see if the variable name is a valid one
 *			and if it is will return a UINT that represents that variable.
 *			Integers are used in other routines when refering to a variable (for
 *			speed).
 *
 */

UINT CHTMLInputTemplate::CheckVariable(TCHAR *var_name)
{
	if (!_tcsncmp(DATA_PROBLEM_ASK,var_name, _tcslen(var_name))) {
		return (PROBLEM_ASK_INDEX);
	}
	else if (!_tcsncmp(DATA_RECOMMENDATIONS,var_name, _tcslen(var_name))) {
		return (RECOMMENDATIONS_INDEX);
	}
	else if (!_tcsncmp(DATA_QUESTIONS,var_name, _tcslen(var_name))) {
		return (QUESTIONS_INDEX);
	}
	else if (!_tcsncmp(DATA_STATE,var_name, _tcslen(var_name))) {
		return (STATE_INDEX);
	}
	else if (!_tcsncmp(DATA_BACK,var_name, _tcslen(var_name))) {
		return (BACK_INDEX);
	}
	else if (!_tcsncmp(DATA_TROUBLE_SHOOTERS, var_name, _tcslen(var_name))) {		
		return (TROUBLE_SHOOTER_INDEX);
	}
	else if (IsFileName(var_name)) {
		return (RESOURCE_INDEX);
	}
	else return (FALSE);
}




//
//
UINT CHTMLInputTemplate::GetStatus()
{
	return (m_dwErr);
}

CHTMLInputTemplate::Push(HTXCommand *command)
{
	if (m_cur_stack_count >9)
		return(FALSE);
	m_command_stack[m_cur_stack_count] = command;
	m_cur_stack_count++;
	return(TRUE);
}

HTXCommand *CHTMLInputTemplate::Pop()
{
	if (m_cur_stack_count <= 0)
		return(NULL);
	return(m_command_stack[--m_cur_stack_count]);
}

//
//
HTXCommand *CHTMLInputTemplate::GetFirstCommand()
{
	return(m_command_start);
}

/*
 * ROUTINE:	SetType
 *
 * PURPOSE:	This set the TroubleShooter Type in the template
 *			The type field is printed after the header information
 *			
 */
void CHTMLInputTemplate::SetType(LPCTSTR type)
{
	_stprintf(m_tstype, _T("%s"),type);
}
/*
 * ROUTINE:	Print
 *
 * PURPOSE: Prints out the Template. This functions executes the
 *			commands in the template and generates the output page.
 *
 */
CHTMLInputTemplate::Print(UINT nargs, CString *cstr)
{
	HTXCommand *cur_com;
	CString strTxt;

	if (m_dwErr){
		strTxt.LoadString(IDS__ER_HTX_PARSE);
		*cstr += strTxt;
		return(FALSE);
	}

	cur_com = m_command_start;  // get the start command
	cur_com = cur_com->Execute(cstr,m_infer);  // This prints the header

	if (m_cHeaderItems)
	{	// The first command prints script.  Don't start the form.
		int count = m_cHeaderItems;
		do
		{
			cur_com = cur_com->GetNext();
			cur_com = cur_com->Execute(cstr, m_infer);
			count--;
		} while (count > 0);
		AfxFormatString1(strTxt, IDS_FORM_START, m_tstype);
		*cstr += strTxt;
		cur_com = cur_com->GetNext();
	}
	else
	{
		AfxFormatString1(strTxt, IDS_FORM_START, m_tstype);
		*cstr += strTxt;
		cur_com = cur_com->GetNext();
	}
	while (cur_com != NULL) {
		cur_com = cur_com->Execute(cstr, m_infer);
		cur_com = cur_com->GetNext();
	}
	return(TRUE);
}
		
// for testing
//

void CHTMLInputTemplate::DumpContentsToStdout()
{
	HTXCommand *cur_com;

	cur_com = GetFirstCommand();
	while( cur_com != NULL){
		_tprintf(_T("(%d) before: [%s]\n"), cur_com->GetType(), cur_com->GetBeforeStr());
		_tprintf(_T("(%d) after: [%s]\n"), cur_com->GetType(), cur_com->GetAfterStr());
		_tprintf(_T("\n"));
		cur_com = cur_com->GetNext();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtsinf.cpp ===
//
// MODULE: APGTSINF.CPP
//
// PURPOSE: Inference Engine Interface
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// Modified By: Richard Meadows
//
// ORIGINAL DATE: 8-2-96
// Modified Date: 6-3-97
//
// NOTES:
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5

//#include "windows.h"
#include "stdafx.h"
#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"

#include "apgtscls.h"

#include "TSHOOT.h"

//-----------------
//

#define CelemArray(rgtype)		(sizeof(rgtype) / sizeof(rgtype[0]))

CInfer::CInfer(	CString *pCtxt)
{
	m_bHttp = FALSE;
	m_pCtxt = pCtxt;
	m_bService = FALSE;
	m_nidPreloadCheck = 0;

	m_pResult = new CString();
	m_pCtmp = new CString();
	m_pSearchStr = new CString();

	m_ilineStat    = 0;
	m_cnidSkip     = 0;
	m_fDone        = FALSE;
	m_ishowService = 0;
	m_idhQuestion  = 0;

//	m_cnid = CelemArray(m_rgnid);
	
	m_problemAsk = FALSE;
	m_problem[0] = '\0';

	m_cShooters = 0;
	m_iShooter = 0;
	m_aShooters.RemoveAll();
	m_SkippedTwice.InitHashTable(7);

	m_api = NULL;
}

//
//m_bFirstShooter
CInfer::~CInfer()
{
	if (m_pResult)
		delete m_pResult;	
	if (m_pCtmp)
		delete m_pCtmp;	
	if (m_pSearchStr)
		delete m_pSearchStr;
	m_SkippedTwice.RemoveAll();
}

//
//
DWORD CInfer::Initialize(/*CSearchForm *pBESearch*/)
{
//	m_pBESearch = pBESearch;
	CString strTxt;	
	if (m_pResult == NULL)
		return (EV_GTS_ERROR_INF_NO_MEM);
	m_max_rec = 0;
	return (0);
}

//
//
VOID CInfer::SetBelief(BCache *pAPI)
{
	m_api = pAPI;
//	m_api->ResetNodes();

	// save count of nodes
	m_acnid = m_api->CNode();

	// reset preload check
	m_nidPreloadCheck = 0;
}

//
//
/*
EC CInfer::GetExtendedError()
{
	return m_uInfErr;
}
*/

//
//
VOID	CInfer::AssertFailed(TSZC szcFile, UINT iline, TSZC szcCond, BOOL fFatal)
{
	CString strTxt;
	strTxt.LoadString(IDS_ER_ASSERT_FAILED);
	PrintString(_T("%s(%u): %s %s\n"), szcFile, iline, (LPCTSTR) strTxt, szcCond);
	//exit(1);
}

//
//
void CInfer::SetProblemAsk()
{
	m_problemAsk = TRUE;
}

//
//
void CInfer::ClearProblemAsk()
{
	m_problemAsk = FALSE;
}

/*
 * METHOD:	EvalData
 *
 * PURPOSE:	This is used by the template execution unit when it needs to evaluate
 *			a variable within a template. Variables are usually evaluated by a
 *			<! display ' tag. Returns a string with the text of the variable
 *			evaluated
 *
 */
TCHAR *CInfer::EvalData(UINT var_index)
{
	BOOL bSkipped;
	int val;
	*m_pCtmp = _T("");
//AfxDebugBreak();
	switch (var_index) {
	case PROBLEM_ASK_INDEX:
		if (m_problemAsk)  // we want to show first set of questions
			return(NULL);
		else
			return(m_problem);
		break;	
	case RECOMMENDATIONS_INDEX:
		FxGetNode(m_rgnid[m_cur_rec],FALSE, m_pCtmp);
		break;
	case STATE_INDEX:
		FxGetState(m_pCtmp);
		break;	
	case QUESTIONS_INDEX:
		{	
			UINT inid;

			if ( GetForcedRecommendation() != SNIFF_INVALID_NODE_ID )
			{
				// we already have a recommendation from a sniffer
				GetIdhPage(GetForcedRecommendation() + idhFirst, m_pCtmp);
			}
			else
			{
				if (m_problemAsk) // show first page (radio-button list of possible problems)
				{
					GetIdhProblemPage(m_api->GetProblemAsk(), m_pCtmp);
				}
				else
				{
					int RecommendRes = Finish(m_pCtmp);
					if ( RECOMMEND_SUCCESS == RecommendRes ) // Normal
					{	// The first node is the most likely.
						// Skip 102 nodes.
						for (inid=0; inid< m_cnid; inid++)
						{
							if (!(bSkipped = FSkip(m_question_rgnid[inid])) || (m_ishowService != 0))
							{
								// Do not show skipped nodes more that once.
								// Will end up in a endless loop.
								if (!m_SkippedTwice.Lookup(m_question_rgnid[inid], val))
								{
									if (bSkipped)							
										m_SkippedTwice.SetAt(m_question_rgnid[inid], 1);
									if (!m_api->IsReverse()) // we're moving forward
									{
										//
										// Check if this node is sniffed
										//
										int state = SNIFF_INVALID_STATE;
										int nid = m_question_rgnid[inid];
										if (m_api->GetState(nid, &state))  // node that we're about to display turbed out to be sniffed
										{
											if (m_api->NodeSet(nid, state, false)) // set sniffed node current and set its state
											{
												m_api->SetAdditionalDataOnNodeSet(nid);

												RecommendRes = m_api->GTSGetRecommendations(m_cnid, m_question_rgnid, true);
												if ( RECOMMEND_SUCCESS == RecommendRes )
												{
													// re-execute loop again
													inid = 0;
													continue;
												}
												else
												{
													goto NO_SUCCESS;
												}
											}
										}
										//
									}
									GetIdhPage(m_question_rgnid[inid]+ idhFirst ,m_pCtmp);
									return(m_pCtmp->GetBuffer(m_pCtmp->GetLength()));
								}
							}
						}
						if (m_cnidSkip != 0)
						{
							/*
							// Going to show the skipped nodes message only one time.
							// Otherwise, they will get stuck on the skipped nodes message page.
							if (m_cnidSkip > (unsigned) m_SkippedTwice.GetCount())
								GetSkippedNodesMsg(_T("Skipped Node"), m_pCtmp);
							else
								GetIdhPage(nidService + idhFirst, m_pCtmp);
							*/
							// Leave them in a better loop.
							m_SkippedTwice.RemoveAll();
							GetSkippedNodesMsg(_T("Skipped Node"), m_pCtmp);
						}
						else
						{
							GetIdhPage(nidService + idhFirst, m_pCtmp);
						}
					}
NO_SUCCESS:
					// recommendation error handling
					//
					if (RECOMMEND_IMPOSSIBLE == RecommendRes)
						GetImpossibleNodesMsg(_T("Impossible"), m_pCtmp);

					if (RECOMMEND_NO_MORE_DATA == RecommendRes)
						GetIdhPage(IDH_FAIL, m_pCtmp);
				}
			}
		}
		break;
	case TROUBLE_SHOOTER_INDEX:
		GetTS(m_pCtmp);
		break;
	default:
		return(_T(""));
	}
	return(m_pCtmp->GetBuffer(m_pCtmp->GetLength()));

}
/*
	GetTS is used when all of the registered trouble shooters are displayed.
*/
void CInfer::GetTS(CString *pCtmp)
{
	TShooter tShooter;
	tShooter = m_aShooters.GetAt(m_iShooter);
	if (m_iShooter < m_cShooters)
		AfxFormatString2(*pCtmp, IDS_FPA_TS_BUTTON, tShooter.m_szName,
							tShooter.m_szDisplayName);
	else
		*pCtmp = _T("");
	m_iShooter++;
}

/*
* METHOD:	InitVar
 *
 * PURPOSE:	This is called to initialize a variable in the template. It
 *			is mainly called by a 'forany' command.
 *
 * RETURNS		- flag indicating if variable is initialized
 *
 */
BOOL CInfer::InitVar(UINT var_index)
{
	switch( var_index) {
	case PROBLEM_ASK_INDEX:
		break;
	case RECOMMENDATIONS_INDEX:			
		m_cur_rec = 0;
		if (m_max_rec == m_cur_rec)
			return FALSE;
		break;
	case STATE_INDEX:
		FxInitState(m_rgnid[m_cur_rec]);
		break;	
	case QUESTIONS_INDEX:
		return m_api->GTSGetRecommendations(m_cnid,m_question_rgnid);
		break;
	case BACK_INDEX:
		return FALSE;
	case TROUBLE_SHOOTER_INDEX:
		m_iShooter = 0;
		return TRUE;
		break;

	default:
		return FALSE;
	}
	return TRUE;
}
/*
* METHOD:	NextVar
 *
 * PURPOSE:	Used by the 'forany' command to increment to the next variable in a
 *			variable list. Returns FALSE when their are no more variable
 *
 *
 */
BOOL CInfer::NextVar(UINT var_index)
{
	switch (var_index) {
	case PROBLEM_ASK_INDEX:
		return FALSE;

	case RECOMMENDATIONS_INDEX:
		m_cur_rec++;
		if (m_cur_rec < m_max_rec)
			return TRUE;
		else
			return FALSE;
		
		break;

	case STATE_INDEX:
		m_cur_ist++;	
		if (m_cur_ist <= m_cur_cst)
			return TRUE;
		else{
			return FALSE;
		}
		break;

	case QUESTIONS_INDEX:
		return FALSE; // only one set

	case BACK_INDEX:
		return FALSE;

	case TROUBLE_SHOOTER_INDEX:
		if (m_cShooters > m_iShooter)
			return TRUE;
		else
			return FALSE;
	default:
		return FALSE;
	}
	return TRUE;
}

/*
* METHOD:	FxGetNode
 *
 * PURPOSE:	This is used to get the '$Recommendation'. A Recommendation is
 *			basically the name of the node in a belief network.
 *
 */
BOOL CInfer::FxGetNode(NID nid, BOOL fStatus, CString *cstr) const
{
	BOOL bRet;
	CString strTemp;
	bRet = m_api->BNodeSetCurrent(nid);
	if (bRet)	
	{
		m_api->NodeFullName();
		strTemp = m_api->SzcResult();
		*cstr += strTemp;
	}
	return bRet;
}

/*
* METHOD:	FxGetState
 *
 * PURPOSE:	This will print out the label of the state of a node. This label
 *			corresponds to the possible choices of that node. NOTE: This
 *			routine requires that an InitState be called sometime before to
 *			setup some variables.
 *
 */
void CInfer::FxGetState(CString *cstr)
{
	CString strTemp;
	if (m_cur_ist > m_cur_cst)
		return;
	if (FSkip(m_rgnid[m_cur_rec]) ) // a 102 was selected
		m_cur_state_set = m_cur_cst;
	if (m_cur_ist == m_cur_cst)
	{
		WriteResult(m_rgnid[m_cur_rec] +idhFirst, 102, m_cur_ist == m_cur_state_set, _T("Unknown"), cstr);
		return;
	}
	ESTDLBL lbl;
	m_api->BNodeSetCurrent(m_rgnid[m_cur_rec]);
	lbl = m_api->ELblNode();
	if (lbl == ESTDLBL_fixobs || lbl == ESTDLBL_fixunobs)
	{
		if (!FSkip(m_rgnid[m_cur_rec]) )
			m_cur_state_set = 0;			
		m_cur_ist = 0;
		m_api->NodeStateName(m_cur_ist);
		strTemp = m_api->SzcResult();
		WriteResult(m_rgnid[m_cur_rec] +idhFirst, m_cur_ist, m_cur_ist == m_cur_state_set, (LPCTSTR) strTemp, cstr);
		m_cur_ist = m_cur_cst -1;
		return;
	}
	m_api->NodeStateName(m_cur_ist);
	strTemp = m_api->SzcResult();
	WriteResult(m_rgnid[m_cur_rec] +idhFirst, m_cur_ist, m_cur_ist == m_cur_state_set, (LPCTSTR) strTemp, cstr);
	return;
}

//
//
void CInfer::FxInitState(NID nid)
{
	UINT	cst;
	UINT	istSet = -1;

	m_api->BNodeSetCurrent(nid);
	cst = m_api->INodeCst();
	m_api->BNodeSetCurrent(nid);
	m_cur_state_set = m_api->INodeState();	
	m_cur_cst = cst;
	m_cur_ist = 0;
}

#define SZ_WORKED	_T("101")
#define SZ_FAILED	_T("0")
#define SZ_YES		_T("0")
#define SZ_NO		_T("1")
#define SZ_UNKNOWN	_T("102")
#define SZ_ANY		_T("103")
#define SZ_MICRO	_T("104")

#define SZ_CHECKED _T("CHECKED")

void inline CInfer::GetNextButton(CString &strNext)
{
	if (m_api->BNetPropItemStr(HTK_NEXT_BTN, 0))
		strNext = m_api->SzcResult();
	else
		strNext = _T("Next");
	return;
}

void inline CInfer::GetBackButton(CString &strBack)
{
	if (m_api->BNetPropItemStr(HTK_BACK_BTN, 0))
		strBack = m_api->SzcResult();
	else
		strBack = _T("Back");
	return;
}

void inline CInfer::GetStartButton(CString &strStart)
{
	if (m_api->BNetPropItemStr(HTK_START_BTN, 0))
		strStart = m_api->SzcResult();
	else
		strStart = _T("Start Over");
	return;
}

void CInfer::GetStd3ButtonEnList(CString *cstr, bool bIncludeBackButton, bool bIncludeNextButton, bool bIncludeStartButton)
{
	CString strBtnPart1 = "<INPUT class=\"standard\" ";
	CString strBack;
	CString strNext;
	CString strStart;
	GetBackButton(strBack);
	GetNextButton(strNext);
	GetStartButton(strStart);

#if 0	
	// just for debugging whether BACK button will show.
	char buf[256];
	*cstr += "<br>DEBUG bIncludeBackButton = ";
	*cstr += bIncludeBackButton ? "true. " : "false. ";
	*cstr += "<br>DEBUG m_api->StatesNowSet() = ";
	sprintf(buf, "%d", m_api->StatesNowSet());
	*cstr += buf;
	*cstr += "<br>m_api->StatesFromServ() = ";
	sprintf(buf, "%d", m_api->StatesFromServ());
	*cstr += buf;
	*cstr += "<br>m_cnidSkip = ";
	sprintf(buf, "%d", m_cnidSkip);
	*cstr += buf;
	*cstr += "<br>END DEBUG<br>";
#endif		

	*cstr += "</TABLE>\n<P><NOBR>";

	if (bIncludeBackButton)
	{
		*cstr += strBtnPart1;
		*cstr += "TYPE=BUTTON VALUE=";
		*cstr += "\"<&nbsp;&nbsp;";
		*cstr += strBack;
		*cstr += "&nbsp;\" onclick=\"previous()\">";
	}

	if (bIncludeNextButton)
	{
		*cstr += strBtnPart1;
		*cstr += "TYPE=SUBMIT VALUE=";
		*cstr += "\"&nbsp;";
		*cstr += strNext;
		*cstr += "&nbsp;&nbsp;>&nbsp;\">";
	}

	if (bIncludeStartButton)
	{
		*cstr += strBtnPart1;
		*cstr += "TYPE=BUTTON VALUE=";
		*cstr += "\"";
		*cstr += strStart;
		*cstr += "\" OnClick=\"starter()\"></NOBR><BR>\n";
	}

	return;
}

bool CInfer::BelongsOnProblemPage(int index)
{
	VERIFY(m_api->BNodeSetCurrent(index));

	if (m_api->ELblNode() != ESTDLBL_problem)
		return false;

	// It's a problem node.  Belongs unless H_PROB_SPECIAL_STR property contains
	//	the string "hide"
	if (m_api->BNodePropItemStr(H_PROB_SPECIAL_STR, 0))
		return (_tcsstr(m_api->SzcResult(), _T("hide")) == NULL);
	else
		return true;	// Doesn't even have an H_PROB_SPECIAL_STR
}

VOID CInfer::GetIdhProblemPage(IDH idh, CString *cstr)
{
	CString strTxt;
	CString strIdh;
	CString strNext;
	strIdh.Format(_T("%d"), idhFirst + m_api->CNode());
	AfxFormatString2(strTxt, IDS_HTM_IDH1, (LPCTSTR) strIdh, _T("ProblemAsk"));
	*cstr += strTxt;

//AfxDebugBreak();

	m_api->BNetPropItemStr(H_PROB_HD_STR, 0);
	AfxFormatString1(strTxt, IDS_HTM_HEADER1, m_api->SzcResult());
	*cstr += strTxt;

	strTxt.LoadString(IDS_HTM_ST_LIST1);
	*cstr += strTxt;
	for(int index = 0; index < m_api->CNode(); index++)
	{
		VERIFY(m_api->BNodeSetCurrent(index));
		if (BelongsOnProblemPage(index))
		{
			m_api->NodeSymName();
			AfxFormatString2(strTxt, IDS_HTM_RADIO1A, (LPCTSTR) strIdh, m_api->SzcResult());
			*cstr += strTxt;
			// If going back and this state was selected, write "Checked"
			if (m_Backup.Check(index))
				*cstr += SZ_CHECKED;
			VERIFY(m_api->BNodePropItemStr(H_PROB_TXT_STR, 0));
			AfxFormatString1(strTxt, IDS_HTM_RADIO1B, m_api->SzcResult());
			*cstr += strTxt;
		}
	}
	GetNextButton(strNext);
	AfxFormatString1(strTxt, IDS_HTM_EN_LIST1, (LPCTSTR) strNext);
	*cstr += strTxt;

	return;
}

//
//
VOID CInfer::GetFixRadios(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_WORKED);
	if (m_api->BNodePropItemStr(H_ST_NORM_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(1))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_FAILED);
	if (m_api->BNodePropItemStr(H_ST_AB_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(0))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_UNKNOWN);
	if (m_api->BNodePropItemStr(H_ST_UKN_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(102))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	return;
}

VOID CInfer::GetInfoRadios(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_YES);
	if (m_api->BNodePropItemStr(H_ST_NORM_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(0))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}

	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_NO);
	if (m_api->BNodePropItemStr(H_ST_AB_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(1))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}

	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_UNKNOWN);
	if (m_api->BNodePropItemStr(H_ST_UKN_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(102))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	return;
}

// GetPropItemStrs can not be used with the radio buttons.
// GetPropItemStrs should be used every where.
bool CInfer::GetNetPropItemStrs(TSZC item, UINT Res, CString *cstr)
{
	bool ret = false;
	CString strTxt;
	int x = 0;
	while (m_api->BNetPropItemStr(item, x))
	{
		AfxFormatString1(strTxt, Res, m_api->SzcResult());
		*cstr += strTxt;
		ret = true;
		x++;
	}
	return ret;
}
bool CInfer::GetNodePropItemStrs(TSZC item, UINT Res, CString *cstr)
{
	bool ret = false;
	CString strTxt;
	int x = 0;
	while (m_api->BNodePropItemStr(item, x))
	{
		AfxFormatString1(strTxt, Res, m_api->SzcResult());
		*cstr += strTxt;
		ret = true;
		x++;
	}
	return ret;
}

VOID CInfer::GetByeMsg(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	CString strBack;
	CString strStart;
	AfxFormatString2(strTxt, IDS_HTM_IDH3, szIdh, _T("IDH_BYE"));
	*cstr += strTxt;
	GetNetPropItemStrs(HX_BYE_HD_STR, IDS_HTM_HEADER3, cstr);
	GetNetPropItemStrs(HX_BYE_TXT_STR, IDS_HTM_BODY1, cstr);
	GetBackButton(strBack);
	GetStartButton(strStart);
	AfxFormatString2(strTxt, IDS_HTM_EN_BYE_MSG, (LPCTSTR) strBack, (LPCTSTR) strStart);
	*cstr += strTxt;
	return;
}

VOID CInfer::GetFailMsg(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	CString strBack;
	CString strStart;

	bool bSniffedAOK = false;	// set true in the case where we got here directly by
								//	sniffing (showing nothing but the problem page, or
								//	not even that).  $BUG  Unfortunately, we haven't yet got
								//	an algorithm to set this.

	AfxFormatString2(strTxt, IDS_HTM_IDH4, szIdh, _T("IDH_FAIL"));
	*cstr += strTxt;

	if (bSniffedAOK)
	{
		if (!GetNetPropItemStrs(HX_SNIFF_AOK_HD_STR, IDS_HTM_HEADER4, cstr))
			GetNetPropItemStrs(HX_FAIL_HD_STR, IDS_HTM_HEADER4, cstr);
		if (!GetNetPropItemStrs(HX_SNIFF_AOK_TXT_STR, IDS_HTM_BODY2, cstr))
			GetNetPropItemStrs(HX_FAIL_TXT_STR, IDS_HTM_BODY2, cstr);
	}
	else
	{
		GetNetPropItemStrs(HX_FAIL_HD_STR, IDS_HTM_HEADER4, cstr);
		GetNetPropItemStrs(HX_FAIL_TXT_STR, IDS_HTM_BODY2, cstr);
	}

	GetBackButton(strBack);
	GetStartButton(strStart);
	AfxFormatString2(strTxt, IDS_HTM_BACK_START, (LPCTSTR) strBack, (LPCTSTR) strStart);
	*cstr += strTxt;
	return;
}

VOID CInfer::GetServiceMsg(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	CString strBack;
	CString strNext;
	CString strStart;
	AfxFormatString2(strTxt, IDS_HTM_IDH5, szIdh, _T("SERVICE"));
	*cstr += strTxt;
	GetNetPropItemStrs(HX_SER_HD_STR, IDS_HTM_HEADER5, cstr);
	GetNetPropItemStrs(HX_SER_TXT_STR, IDS_HTM_BODY3, cstr);
/*
	strTxt.LoadString(IDS_HTM_ST_LIST2);
	*cstr += strTxt;
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, TRY_TS_AT_MICROSOFT_SZ, SZ_MICRO);
	if (m_api->BNetPropItemStr(HX_SER_MS_STR, 0))
	{
		*cstr += strTxt;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	GetStd3ButtonEnList(cstr, true, true, true);
*/
	GetBackButton(strBack);
	GetStartButton(strStart);
	AfxFormatString2(strTxt, IDS_HTM_BACK_START, (LPCTSTR) strBack, (LPCTSTR) strStart);
	*cstr += strTxt;
	return;
}

VOID CInfer::GetSkippedNodesMsg(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	AfxFormatString2(strTxt, IDS_HTM_IDH5, szIdh, _T("SERVICE"));
	*cstr += strTxt;
	GetNetPropItemStrs(HX_SKIP_HD_STR, IDS_HTM_HEADER5, cstr);
	GetNetPropItemStrs(HX_SKIP_TXT_STR, IDS_HTM_BODY3, cstr);
	strTxt.LoadString(IDS_HTM_ST_LIST2);
	*cstr += strTxt;
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, TRY_TS_AT_MICROSOFT_SZ, SZ_ANY);
	if (m_api->BNetPropItemStr(HX_SKIP_SK_STR, 0))
	{	// Did I skip something?
		*cstr += strTxt;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	GetStd3ButtonEnList(cstr, true, true, true);
	return;
}

VOID CInfer::GetImpossibleNodesMsg(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	CString strBack;
	CString strStart;
	AfxFormatString2(strTxt, IDS_HTM_IDH5, szIdh, _T("SERVICE"));
	*cstr += strTxt;
	GetNetPropItemStrs(HX_IMP_HD_STR, IDS_HTM_HEADER5, cstr);
	GetNetPropItemStrs(HX_IMP_TXT_STR, IDS_HTM_BODY3, cstr);
	GetBackButton(strBack);
	GetStartButton(strStart);
	AfxFormatString2(strTxt, IDS_EN_IMP, (LPCTSTR) strBack, (LPCTSTR) strStart);
	*cstr += strTxt;
	return;
}

VOID	CInfer::GetIdhPage(IDH idh, CString *cstr)
{
	CString strTxt;
	CString strIdh;
	CString str;
	
	str.Format(_T("%d"), idh);
	if (m_api->BNodeSetCurrent(idh - idhFirst))
	{
		m_api->NodeSymName();
		strIdh = m_api->SzcResult();
	}
	else
		strIdh = _T("");
	if (IDH_BYE == idh)
	{
		strIdh.Format(_T("%d"), idh);
		GetByeMsg((LPCTSTR) strIdh, cstr);
	}
	else if (IDH_FAIL == idh)
	{
		strIdh.Format(_T("%d"), idh);
		GetFailMsg((LPCTSTR) strIdh, cstr);
	}
	else if ((nidService + idhFirst)== idh)
	{
		strIdh.Format(_T("%d"), idh);
		GetServiceMsg((LPCTSTR) strIdh, cstr);
	}
	else
	{
		// normal node
		AfxFormatString2(strTxt, IDS_HTM_IDH2, (LPCTSTR) strIdh, (LPCTSTR) str);
		*cstr += strTxt;

		if (GetForcedRecommendation() + idhFirst == idh)
			GetNodePropItemStrs(H_NODE_DCT_STR, IDS_HTM_HEADER2, cstr);
		else
			GetNodePropItemStrs(H_NODE_HD_STR, IDS_HTM_HEADER2, cstr);

		GetNodePropItemStrs(H_NODE_TXT_STR, IDS_HTM_TEXT1, cstr);
		strTxt.LoadString(IDS_HTM_ST_LIST2);
		*cstr += strTxt;

		if (GetForcedRecommendation() + idhFirst != idh)
		{
			ESTDLBL lbl = m_api->ELblNode();
			if (ESTDLBL_fixobs == lbl || ESTDLBL_fixunobs == lbl || ESTDLBL_unfix == lbl)
				GetFixRadios((LPCTSTR) strIdh, cstr);
			else if (ESTDLBL_info == lbl)
				GetInfoRadios((LPCTSTR) strIdh, cstr);
		}

		// We only want to show a BACK button if at least one node has been set or skipped.
		//	This does not include nodes initiallly set on instructions from TSLaunchServ:
		//	the whole point is to avoid stepping "back" into things that were set by
		//	the launch server rather than by the user.
		{
			//DEBUG
			//AfxDebugBreak();
			int testNowSet = m_api->StatesNowSet();
			int testStatesFromServ = m_api->StatesFromServ();
		}

		// Suppress back button if we launched to a network with a problem node and
		//	no further nodes have been set.  It's not the problem page, but (as far as user
		//	is concerned) it's the first page.
		bool bIncludeBackButton =
			m_api->StatesNowSet() > m_api->StatesFromServ() || m_cnidSkip > 0;

		// We would like to suppress the back button in the similar scenario where
		//	sniffing takes us past the first recommendation.  For example:
		//	Launcher specifies problem.
		//	First recommendation for that problem is sniffed as "normal" (state = 0)
		//	Now the first node we show is even deeper into the chain.
		 bIncludeBackButton = bIncludeBackButton &&
								(m_api->IsRunWithKnownProblem() ?
								   (m_api->GetCountRecommendedNodes() >
									m_api->GetCountSniffedRecommendedNodes() + 1/*this is for the problem we've started with*/) :
									1);

		// We supress back button ALWAYS when we have sniffed foxobs node that worked
		//  we can be either on the problem page where we do not need back button
		//  or on problem resolution page from where we never go back
		 bIncludeBackButton = bIncludeBackButton &&
								m_api->GetSniffedFixobsThatWorked() == SNIFF_INVALID_NODE_ID;
		
		// We do not want to have a NEXT button when we are on the problem resolution page
		bool bIncludeNextButton = (GetForcedRecommendation() + idhFirst) != idh;

		GetStd3ButtonEnList(cstr, bIncludeBackButton, bIncludeNextButton, true);
	}
	return;
}

//
//
BOOL	CInfer::FSkip(NID nid) const
{
	for (UINT inid = 0; inid < m_cnidSkip; inid++)
	{
		if (m_rgnidSkip[inid] == nid)
		{
			return TRUE;
		}
	}
		
	return FALSE;		
}

void	CInfer::BackUp(int nid, int state)
{
	m_Backup.SetState(nid, state);	// This sets the radio button.
	// Is nid in the skip list?
	for (UINT inid = 0; inid < m_cnidSkip; inid++)
	{
		if (m_rgnidSkip[inid] == (unsigned) nid)
		{
			// Remove nid from the skip list.
			while(inid < (m_cnidSkip - 1))
			{
				m_rgnidSkip[inid] = m_rgnidSkip[inid + 1];
				inid++;
			}
			m_rgnidSkip[inid] = NULL;
			m_cnidSkip--;
		}
	}
//	if (m_cnidSkip < 0)
//		m_cnidSkip = 0;
	return;
}

//
//
VOID	CInfer::AddSkip(NID nid)
{
	if (!FSkip(nid))
	{
		if (m_cnidSkip < cnidMacSkip)
		{
			m_rgnidSkip[m_cnidSkip++] = nid;
		}
	}
}

VOID CInfer::RemoveSkips()
{
	for(UINT x = 0; x < m_cnidSkip; x++)
		m_rgnidSkip[x] = NULL;
	m_cnidSkip = 0;
	return;
}

//
//
VOID	CInfer::PrintMessage(TSZC szcFormat, ...) const
{
	va_list ptr;
	TCHAR formatbuf[1024];

	if (szcFormat) {
		_tcscpy(formatbuf,_T("<H4>"));

		va_start(ptr,szcFormat);
		_vstprintf(&formatbuf[4],szcFormat,ptr);
		va_end(ptr);
		_tcscat(formatbuf,_T("</H4>"));

		*m_pCtxt += formatbuf;
	}
}

//
//
VOID	CInfer::PrintString(TSZC szcFormat, ...) const
{
	va_list ptr;
	TCHAR formatbuf[1024];

	if (szcFormat) {
		va_start(ptr,szcFormat);
		_vstprintf(formatbuf,szcFormat,ptr);
		va_end(ptr);

		*m_pCtxt += formatbuf;
	}
}

// this data is now in CSniffedInfoContainer
/*
// This allows a higher level to say "don't go to the belief network for a recommendation,
//	I already know what to recommend."  Used in conjunction with a sniffer.
VOID CInfer::ForceRecommendation(IDH idh)
{
	m_idhSniffedRecommendation= idh;
}
*/

// Associate a state with a node.
// INPUT idh -	either (node ID + 1000) or one
//	of the special values IDH_BYE, IDH_FAIL, (nidService + 1000)
// INPUT ist -	index of a state for that node
// RETURNS >>> document?.
BOOL	CInfer::FSetNodeOfIdh(IDH idh, IST	ist)
{
	if (ist == 101)
	{
		m_fDone = TRUE;
		return TRUE;
	}

	if (ist == 103)	
	{
		m_ishowService++;
		return TRUE;
	}

	if (idh < idhFirst)
		return TRUE;

	if (idh > m_acnid + idhFirst && idh != IDH_SERVICE)
		return TRUE;

	if (ist == 102)
	{	//	"don't want to do this now"
		AddSkip(idh - idhFirst);
		SaveNID(idh - idhFirst);
		return TRUE;
	}

	if (idh == m_api->GetProblemAsk()) {
		// get data for problem
		IDH *idarray = NULL;		
		NID	nidProblem = nidNil;
		UINT iproblem = 0;
		UINT inid;

		UINT count = m_api->GetProblemArray(&idarray);

		for (inid = 0; inid < count; inid++) {
			if (ist == idarray[inid]) {
				
				nidProblem = ist - idhFirst;
				iproblem = ist;

				if (!m_api->NodeSet(idarray[inid] - idhFirst, ist == idarray[inid] ? 1 : 0,
								m_Backup.InReverse()))
					return FALSE;
				break;
			}
		}

		if (nidProblem == nidNil) {
			m_idhQuestion = IDH_SERVICE;
			return TRUE;
		}
		m_api->BNodeSetCurrent(nidProblem);
		m_api->NodeFullName();
		
		_stprintf(m_problem, _T("%s<INPUT TYPE=HIDDEN NAME=%u VALUE=%u>"), m_api->SzcResult(), idh, iproblem);
		m_firstNid = idh - idhFirst;
		m_firstSet = iproblem;
		return TRUE;
	}

	NID		nid = idh - idhFirst;

	if (nid != nidService)
		if (!m_api->NodeSet(nid, ist, m_Backup.InReverse()))
			return FALSE;

	SaveNID(nid);  // save this node id so we can print it at the end

	return TRUE;
}

//
//
void CInfer::SaveNID(UINT nid)
{
	m_rgnid[m_max_rec] = nid;
	m_max_rec++;
}

//
//
void	CInfer::WriteResult(UINT name, UINT value, BOOL bSet, TSZC szctype, CString *cstr) const
{
	TCHAR	ctemp[1024];
	TCHAR*	szFmtInput =  _T("<INPUT TYPE=RADIO NAME=%u VALUE=%u%s>%-16s ");
		
	_stprintf(ctemp, szFmtInput,
		name, value, bSet ? _T(" CHECKED") : _T(""), szctype);
	*cstr += ctemp;
}

//
//
int	CInfer::Finish(CString *cstr)
{
	CString strTxt;
	if (m_fDone)
	{
		GetIdhPage(IDH_BYE, cstr);
		// Reset the done flag so that the Previous button will work correctly.
		m_fDone = FALSE;
		return FALSE;
	}
	if (m_idhQuestion != 0)
	{
		GetIdhPage(m_idhQuestion, cstr);
		return FALSE;
	}
	if (m_api->BImpossible())
	{
		GetImpossibleNodesMsg(_T("Impossible"), cstr);
		return FALSE;
	}
	//
	// we've come down to ask recommendations
	//	
	int iRecommendRes = m_api->GTSGetRecommendations(m_cnid, m_question_rgnid);

	return iRecommendRes;
}

// ResetSevice is called when the start button is pressed.  CTSHOOTCtrl::ProblemPage()
void CInfer::ResetService()
{
	m_ishowService = 0;
	m_cnidSkip = 0;
	m_cnid = 0;
	return;
}
//
//
void CInfer::SetType(LPCTSTR type)
{
	_stprintf(m_tstype, _T("%s"),type);
}

//
//
void CInfer::LoadTShooters(HKEY hRegKey)
{
	long lRet;
	int x;
	HKEY hkeyShooter;
	TShooter tShooter;
	TShooter tsTemp;
	CString strKeyName = _T("");
	CString strKeyPath = _T("");
	CString strTSPath = _T("");
	CString strData = _T("");
	DWORD dwIndex = 0;
	DWORD dwKeySize = MAXBUF;
	FILETIME fileTime;
	DWORD dwDataSize = MAXBUF;
	DWORD dwType = REG_SZ;
	m_cShooters = 0;
	m_iShooter = 0;
	strKeyPath.Format(_T("%s\\%s"), TSREGKEY_MAIN, REGSZ_TSTYPES);
	while (ERROR_SUCCESS ==
				(lRet = RegEnumKeyEx(hRegKey,
								dwIndex, strKeyName.GetBufferSetLength(MAXBUF),
								&dwKeySize, NULL,
								NULL, NULL,
								&fileTime)))
	{
		strKeyName.ReleaseBuffer();
		strTSPath.Format(_T("%s\\%s"),(LPCTSTR) strKeyPath, (LPCTSTR) strKeyName);
		if ((lRet = RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
									(LPCTSTR) strTSPath,
									NULL,
									KEY_READ,				
									&hkeyShooter)) == ERROR_SUCCESS)
		{
			if ((lRet = RegQueryValueEx(hkeyShooter,
								FRIENDLY_NAME,
								0,
								&dwType,
								(LPBYTE) strData.GetBufferSetLength(MAXBUF),
								&dwDataSize)) == ERROR_SUCCESS)
			{
				strData.ReleaseBuffer();
				m_cShooters++;
				_tcsncpy(tShooter.m_szName, (LPCTSTR) strKeyName, strKeyName.GetLength() + 1);
				_tcsncpy(tShooter.m_szDisplayName, (LPCTSTR) strData, strData.GetLength() + 1);
				x = (int)m_aShooters.GetSize();
				while (x > 0)
				{
					x--;
					tsTemp = m_aShooters.GetAt(x);
					if (_tcscmp(tsTemp.m_szDisplayName, tShooter.m_szDisplayName) < 0)
					{
						x++;
						break;
					}
				}
				m_aShooters.InsertAt(x, tShooter);
			}
			RegCloseKey(hkeyShooter);
		}
		dwIndex++;
		dwKeySize = MAXBUF;
		dwDataSize = MAXBUF;
		dwType = REG_SZ;
		strKeyName = _T("");
		strData = _T("");
	}
	ASSERT(ERROR_NO_MORE_ITEMS == lRet);
	return;
}

//
//
int	CInfer::GetForcedRecommendation()
{
	return m_api->GetSniffedFixobsThatWorked();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtsctx.cpp ===
//
// MODULE: APGTSCTX.CPP
//
// PURPOSE: Implementation file for Thread Context
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

//#include "windows.h"
#include "stdafx.h"
#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include "TSHOOT.h"

int idcomp(const void *elem1, const void *elem2);


//-----------------
//
APGTSContext::APGTSContext()
{
	m_pConf = NULL;
	m_dwErr = 0;
	m_infer = NULL;
	m_currcfg = NULL;
	_tcscpy(m_resptype, _T("200 OK"));

	m_pszheader = NULL;
	m_pCtxt = NULL;
	m_pQry = NULL;

	return;
}
//
//
APGTSContext::APGTSContext(	BNCTL *currcfg,
							CDBLoadConfiguration *pConf,
							CHttpQuery *pHttpQuery)
{
	m_infer = NULL;
	Initialize(currcfg, pConf, pHttpQuery);
	return;
}
//
//
void APGTSContext::Initialize(	BNCTL *currcfg,
								CDBLoadConfiguration *pConf,
								CHttpQuery *pHttpQuery)
{
	struct tm *newtime;
	TCHAR buf[MAXBUF+1];
	
	m_pConf = pConf;
	m_dwErr = 0;
	m_infer = NULL;
	m_currcfg = currcfg;
	_tcscpy(m_resptype, _T("200 OK"));

	if (m_pszheader)
		delete m_pszheader;
	m_pszheader = new CString();
	if (m_pCtxt)
		delete m_pCtxt;
	m_pCtxt = new CString();
	m_pQry = pHttpQuery;

	if (m_pszheader)
		*m_pszheader += _T("Content-Type: text/html\r\n");

	m_pConf->GetVrootPath(m_vroot);
		
	time( &m_aclock );
	newtime = localtime( &m_aclock );
	_tcscpy(buf,_tasctime(newtime));
	if (_tcslen(buf))
		buf[_tcslen(buf)-1] = _T('\0');// remove cr

	// get ip address to put into event log
	DWORD bufsize = MAXBUF - 1;

	if (!m_pCtxt || !m_pszheader) {
		m_dwErr = EV_GTS_ERROR_NO_STRING;
		return;
	}
	
	if (!m_pQry) {
		m_dwErr = EV_GTS_ERROR_NO_QUERY;
		return;
	}

	// create inference engine and related structures
	m_infer = new CInfer(m_pCtxt);

	if (!m_infer) {
		m_dwErr = EV_GTS_ERROR_NO_INFER;
		return;
	}

}

void APGTSContext::RemoveSkips()
{
	ASSERT(m_infer);
	if (m_infer)
		m_infer->RemoveSkips();
	return;
}

void APGTSContext::ResetService() 
{
	m_infer->ResetService();
	return;
}

void APGTSContext::RenderNext(CString &strPage)
{
	CString strTmp;
	strTmp.LoadString(IDS_ER_ERRORS_OCCURED);
	if (m_pszheader) {
		*m_pszheader += _T("\r\n");

	}

	if (m_pCtxt) {
		if (m_dwErr) 
			*m_pCtxt += strTmp;

		// write out CString here
		
		if (m_pCtxt->GetLength() > 0)
			strPage = m_pCtxt->GetBuffer(0);
	}
	else {
		strPage = strTmp;
	}
	return;
}

void APGTSContext::Empty()
{
	*m_pCtxt = _T("");
	return;
}
//
//
APGTSContext::~APGTSContext()
{
//	AfxMessageBox("Context");
	if (m_infer) 
		delete m_infer;
	if (m_pCtxt)
		delete m_pCtxt;	
	if (m_pszheader)
		delete m_pszheader;
}

// This must be called to process the data
//
//
//
void APGTSContext::DoContent(CHttpQuery *pQry)
{	
	CString strRefedCmd;
	CString strRefedValue;
	CString strTxt;
	ASSERT(NULL != pQry);
	m_pQry = pQry;

	if (m_pQry->GetFirst(strRefedCmd, strRefedValue)) {

		DWORD dwStat = ProcessCommands((LPCTSTR) strRefedCmd, (LPCTSTR) strRefedValue);

		if (dwStat != 0) {
			TCHAR temp[MAXCHAR];

			if (dwStat != EV_GTS_INF_FIRSTACC)
				m_dwErr = dwStat;

			_stprintf(temp, _T("%d"), 0); // used to put extended error here
			ReportWFEvent(	_T("[apgtscxt]"), //Module Name
							_T("[EndCommands]"), //event
							//m_pszQuery,
							NULL,
							temp,
							dwStat ); 
		}
	}
	else {
		strTxt.LoadString(IDS_ER_NO_INPUT_PARAMS);
		*m_pCtxt += strTxt;
		ReportWFEvent(	_T("[apgtscxt]"), //Module Name
						_T("[ProcessQuery]"), //event
						//m_ipstr,
						NULL,
						_T(""),
						EV_GTS_USER_NO_STRING ); 

	}
}

//
//
DWORD APGTSContext::ProcessCommands(LPCTSTR pszCmd, 
									LPCTSTR pszValue) 
{
	DWORD dwStat = 0;
	CString strTxt;

	// first command should be troubleshooter type
	if (!_tcscmp(pszCmd, C_TYPE) || !_tcscmp(pszCmd, C_PRELOAD)) {

		DWORD dwOff;
		CHTMLInputTemplate *pInputTemplate;
		//CSearchForm *pBESearch = NULL;
		BCache *pAPI;

		if (m_pConf->FindAPIFromValue(m_currcfg, pszValue, &pInputTemplate, /*&pBESearch, */ &pAPI, &dwOff)) {

			if ((dwStat = m_infer->Initialize(/*pBESearch*/)) != 0) {
				strTxt.LoadString(IDS_ER_MISSING_API);
				*m_pCtxt += strTxt;
			}
			else {
				dwStat = DoInference(pszCmd, pszValue, pInputTemplate, pAPI, dwOff);
			}
		}
		else {
			dwStat = EV_GTS_ERROR_INF_BADTYPECMD;
			strTxt.LoadString(IDS_ER_UNEXP_CMDA);
			*m_pCtxt += strTxt;
			*m_pCtxt += pszValue;
		}
	}
	else if (!_tcscmp(pszCmd, C_FIRST)) {

		DisplayFirstPage();

		dwStat = EV_GTS_INF_FIRSTACC;
	}
	else {
		dwStat = EV_GTS_ERROR_INF_BADCMD;
		strTxt.LoadString(IDS_ER_UNEXP_CMD);
		*m_pCtxt += strTxt;
		*m_pCtxt += pszCmd;
	}
	return (dwStat);
}

//
//
DWORD APGTSContext::DoInference(LPCTSTR pszCmd, 
								LPCTSTR pszValue, 
								CHTMLInputTemplate *pInputTemplate, 
								BCache *pAPI, 
								DWORD dwOff)
{
	DWORD dwCount = 0, dwStat = 0;
	BOOL bPreload = FALSE;
	CString strTxt;
	if (!_tcscmp(pszCmd, C_PRELOAD))
		bPreload = TRUE;
	pInputTemplate->SetInfer(m_infer, m_vroot);
	m_infer->SetBelief(pAPI);
	// set type troubleshooter type in template
	pInputTemplate->SetType(pszValue);
	m_infer->SetType(pszValue);
	int refedCmd, refedVal;
	BOOL bProbAsk = TRUE;
//	RSStack<CNode> InvertState;
	while (m_pQry->GetNext(refedCmd, refedVal)) 
	{
		dwCount++;	
		if (!m_infer->FSetNodeOfIdh(refedCmd, refedVal))
			dwStat = EV_GTS_ERROR_INF_NODE_SET;
	}
	// 
	if (0 == dwCount)
	{
		m_infer->SetProblemAsk();
		m_infer->ClearDoubleSkip();
	}
	else
	{
		m_infer->ClearProblemAsk();
	}

	if (!dwStat) {

		pInputTemplate->Print(dwCount, m_pCtxt);

		/*
		if (m_infer->IsService(m_pszheader))
		{
			strTxt.LoadString(IDS_I_OBJ_MOVED);
			_tcscpy(m_resptype, (LPCTSTR) strTxt);
		}
		*/
	}
	else {
		strTxt.LoadString(IDS_ER_SVR_BAD_DATA);
		*m_pCtxt += strTxt;
	}

	return dwStat;
}

//
//
void APGTSContext::DisplayFirstPage()
{
	DWORD i, apicount;
	CString strTxt;

	*m_pCtxt += _T("<html><head><title>");
	strTxt.LoadString(IDS_FP_TITLE);
	*m_pCtxt += strTxt;
	*m_pCtxt += _T("</title></head>\n");
	*m_pCtxt += _T("<body ");
	strTxt.LoadString(IDS_FP_BODY_ATTRIB);
	*m_pCtxt += strTxt;
	*m_pCtxt += _T(">\n<center><h1>");
	strTxt.LoadString(IDS_FP_HEADER);
	*m_pCtxt += strTxt;

	*m_pCtxt += VERSIONSTR;
		
	*m_pCtxt += _T("</h1></center>\n");

	*m_pCtxt = _T("<center>\n");

	apicount = m_pConf->GetFileCount(m_currcfg);

	if (!apicount) {
		strTxt.LoadString(IDS_ER_NO_API);
		*m_pCtxt += strTxt;
	}
	else {
		for (i=0;i<apicount;i++) {
			AfxFormatString1(strTxt, IDS_FORM_START, m_pConf->GetTagStr(m_currcfg, i));
			*m_pCtxt += strTxt;
			*m_pCtxt += _T("<INPUT TYPE=SUBMIT VALUE=\"");
			*m_pCtxt += m_pConf->GetTagStr(m_currcfg, i);
			*m_pCtxt += _T("\">\n");
			*m_pCtxt += _T("</FORM>\n");
		}
	}

	*m_pCtxt += _T("</center></body></html>\n");
}

// id compare in descending order
//
int idcomp(const void *elem1, const void *elem2)
{
	return(((EVAL_WORD_METRIC *)elem2)->dwVal - ((EVAL_WORD_METRIC *)elem1)->dwVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\basicexception.cpp ===
//
// MODULE:  BASICEXCEPTION.CPP
//
// PURPOSE:  Exception that will be caught in ApgtsX2Ctrl::RunQuery.
//           This exception is thrown from most of the Trouble 
//           shooter functions.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//
#include "stdafx.h"
#include "ErrorEnums.h"
#include "BasicException.h"

CBasicException::CBasicException()
{
	m_dwBErr = LTSC_OK;
	return;
}

CBasicException::~CBasicException()
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\backupinfo.cpp ===
//
// MODULE: BackupInfo.cpp
//
// PURPOSE: Contains infomation that is used when the previous button is selected.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 9/5/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		6/4/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//
#include "stdafx.h"
#include "BackupInfo.h"

CBackupInfo::CBackupInfo()
{
	Clear();
	return;
}

void CBackupInfo::Clear()
{
	m_bBackingUp = false;
	m_bProblemPage = true;
	m_State = 0;
	return;
}

bool CBackupInfo::Check(int State)
{
	bool bCheckIt;
	if (m_bBackingUp && m_State == State)
		bCheckIt = true;
	else
		bCheckIt = false;
	return bCheckIt;
}

void CBackupInfo::SetState(int Node, int State)
{
	m_bBackingUp = true;
	if (INVALID_BNTS_STATE == State)
	{
		m_bProblemPage = true;
		m_State = Node;
	}
	else
	{
		m_bProblemPage = false;
		m_State = State;
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\backupinfo.h ===
//
// MODULE: BackupInfo.cpp
//
// PURPOSE: Contains infomation that is used when the previous button is selected.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 9/5/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		6/4/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __BACKUPINFO_H_
#define __BACKUPINFO_H_ 1

class CBackupInfo
{
public:
	enum { INVALID_BNTS_STATE = 32000 };
public:
	CBackupInfo();

	bool Check(int State);
	void SetState(int Node, int State);
	bool InReverse() {return m_bBackingUp;};

	void Clear();

protected:

	bool m_bBackingUp;
	bool m_bProblemPage;

	int m_State;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtsinf.h ===
//
// MODULE: APGTSINF.H
//
// PURPOSE: Inference support header
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//			further work by Richard Meadows (RWM), Joe Mabel, Oleg Kalosha
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5

#include "ErrorEnums.h"
#include "sniff.h"

typedef unsigned int	   NID;	// numeric node ID in the form used by BNTS

//	Please Note: these values are mirrored in dtguiapi.bas, please keep in sync
const NID	nidNil     = 12346;
const NID	nidService = 12345;

#define	IDH_BYE        	  101	// success page
#define	IDH_FAIL       	  102	// "no more recommendations" page

typedef	UINT	IDH;		//	help index.  For values where a NID is defined,
							//	add idhFirst to get an IDH.  IDH_BYE & IDH_FAIL
							//	are also good IDHs.
const IDH	idhFirst = 1000;
#define IDH_FROM_NID(NID) (NID + idhFirst)

#define IDH_SERVICE IDH_FROM_NID(nidService)

#define MAXBUF	256 * 2

#define MAXPROBID		100		// allow for this many problem nodes in a network

enum { cnidMacSkip = 32 };		// max # of "skipped" nodes

typedef	TCHAR*			   TSZ;
typedef	const TCHAR*	   TSZC;// >>> why distinguished from TSZ?

typedef unsigned int	  CNID;	// a count of node IDs.								
typedef unsigned int	   IST;	// state number (associated with a node)
								//	0 - normal
								//	1 - abnormal
								//	102 - skipped

#define MAX_NID		64		// allow for this many nodes to be given states by user on the
							// way to solving the problem

void WideToMB(const WCHAR *szIn, CHAR *szOut);	// Converts Unicode chars to Multi Byte.

class GTSCacheGenerator;		// forward reference

class GTSAPI : public BNTS
{
#define SZ_CACHE_NAME _T(".tsc")
public:
	GTSAPI(TCHAR *binfile, TCHAR *tagstr, TCHAR *szResourcePath);
	virtual ~GTSAPI();
	BOOL BNodeSet(int state, bool bset);  // Old comment says "For debugging" but I doubt it.
										//	Maybe that's just why its public.  - JM 3/98
	void AddValue(int value);

	// Temporary BNTS wrappers for unicode build with non unicode bnts.dll
	CString m_strResult;
	BOOL BMultiByteReadModel(LPCTSTR szcFn, LPCSTR szcFnError);
	BOOL BReadModel (LPCTSTR szcFn, LPCSTR szcFnError = NULL)
	{
#ifndef _UNICODE
		return BNTS::BReadModel(szcFn, szcFnError);
#else
		return BMultiByteReadModel(szcFn, szcFnError);
#endif
	};
	BOOL BMultiByteNodePropItemStr(LPCTSTR szcPropType, int index);
	virtual BOOL BNodePropItemStr(TSZC szcPropType, int index)
	{
#ifndef _UNICODE
		return BNTS::BNodePropItemStr(szcPropType, index);
#else
		return BMultiByteNodePropItemStr(szcPropType, index);
#endif
	};
	BOOL BMultiByteNetPropItemStr(LPCTSTR szcPropType, int index);
	virtual BOOL BNetPropItemStr(TSZC szcPropType, int index)
	{
#ifndef _UNICODE
		return BNTS::BNetPropItemStr(szcPropType, index);
#else
		return BMultiByteNetPropItemStr(szcPropType, index);
#endif
	};
	LPCTSTR SzcMultiByteResult();
	virtual LPCTSTR SzcResult()
	{
#ifndef _UNICODE
		return BNTS::SzcResult();
#else
		return SzcMultiByteResult();
#endif
	};
	int IMultiByteNode(LPCTSTR szSymName);
	virtual int INode(LPCTSTR szSymName)
	{
#ifndef _UNICODE
		return BNTS::INode(szSymName);
#else
		return IMultiByteNode(szSymName);
#endif
	};


	// Temporary BNTS wrappers for debug build with release bnts.dll
	/*
	BOOL BNetPropItemStr(LPCTSTR szPropItem, int index, CString &str)
	{
		BOOL bRet;
		str.GetBuffer(STRBUFSIZE);
		bRet = BNTS::BNetPropItemStr(szPropItem, index, str);
		str.ReleaseBuffer();
		return bRet;
	};
	BOOL BNodePropItemStr(LPCTSTR szPropItem, int index, CString &str)
	{
		BOOL bRet;
		str.GetBuffer(STRBUFSIZE);
		bRet = BNTS::BNodePropItemStr(szPropItem, index, str);
		str.ReleaseBuffer();
		return bRet;
	};
	void NodeStateName(int index, CString &str)
	{		
		str.GetBuffer(STRBUFSIZE);
		BNTS::NodeStateName(index, str);
		str.ReleaseBuffer();
		return;
	};
	void NodeSymName(CString &str)
	{		
		str.GetBuffer(STRBUFSIZE);
		BNTS::NodeSymName(str);
		str.ReleaseBuffer();
		return;
	};
	void NodeFullName(CString &str)
	{		
		str.GetBuffer(STRBUFSIZE);
		BNTS::NodeFullName(str);
		str.ReleaseBuffer();
		return;
	};
		*/
	// Regular functions.

	//virtual BOOL	NodeSet(NID nid, IST ist);
	VOID	ResetNodes();

	DWORD	Reload(/*CWordList *pWXList*/);

	DWORD	GetStatus();
	
	UINT	GetProblemArray(IDH **idh);
	IDH		GetProblemAsk();

	UINT	GetNodeList(NID **pNid, IST **pIst);
	int		GTSGetRecommendations(CNID& cnid, NID rgnid[]);
	void	RemoveRecommendation(int Nid);

	VOID	GetSearchWords(/*CWordList *pWords*/);
	DWORD	EvalWord(TCHAR *token);

	//WNODE_ELEM *GetWNode(NID nid);

	BOOL BNodeSetCurrent(int node);


	VOID	ScanAPIKeyWords(/*CWordList *pWXList*/);

protected:
	VOID	Destroy();

protected:

	GTSCacheGenerator m_CacheGen;

	// These 2 arrays tie together nodes & their states
	NID		m_rgnid[MAX_NID];
	IST		m_rgist[MAX_NID];
	IST		m_rgsniff[MAX_NID]; // array of states, showing if the node was sniffed

	UINT	m_cnid;				// current size of m_rgnid, m_rgist; number of nodes to which
								// a state has been assigned.

	TCHAR	m_binfile[MAXBUF];	// name of DSC file (>>> full path or not?) 
								//	>>>should be renamed! DSC file replaced BIN file.
	TCHAR	m_tagstr[MAXBUF];
	TCHAR	m_szResourcePath[MAXBUF];	// full path of resource directory

	DWORD	m_dwErr;
	
	TCHAR*	m_pchHtml;
	
	IDH		m_idstore[MAXPROBID];	// problem node convenience array in the 
									// form of IDH values
	UINT	m_currid;				// Despite bad name, number of values in m_idstore
	IDH		m_probask;				// IDH value corresponding to ProblemAsk: number of nodes
									//	in the network + 1000
	
	CBNCache *m_pCache;				// cache for states of this network

};


////////////////////////////////////////////////////////////////////////////////////////
// BCache class declaration
//

// these are returns by GTSGetRecommendations member function
//
#define RECOMMEND_SUCCESS					1
#define RECOMMEND_FAIL						0
#define RECOMMEND_IMPOSSIBLE				99
#define RECOMMEND_NODE_WORKED				100
#define RECOMMEND_NO_MORE_DATA				101
//
#define NODE_ID_NONE				        -1  
//

class CHttpQuery;

class BCache : public GTSAPI, public CSniffedNodeContainer
{
public:
	BCache(TCHAR *binfile, TCHAR *tagstr, TCHAR *szResourcePath, const CString& strFile);
	~BCache();

	void SetHttpQuery(CHttpQuery *p) {m_pHttpQuery = p;return;};
	UINT StatesFromServ();
	UINT StatesNowSet();

	DWORD Initialize(/*CWordList *pWXList*/);
	DWORD ReadModel();
	void ReadCacheFile(LPCTSTR szCache);
																	   
	int GTSGetRecommendations(CNID& cnid, NID rgnid[], bool bSniffed =false);
	void RemoveRecommendation(int Nid);
	BOOL NodeSet(NID nid, IST ist, bool bPrevious);
	void ResetNodes();

	int CNode();
	BOOL BImpossible();
	BOOL BNetPropItemStr(LPCTSTR szPropType, int index);
	BOOL BNetPropItemReal(LPCTSTR szPropType, int index, double &dbl);

	BOOL BNodeSetCurrent(int node);
	int INode(LPCTSTR szNodeSymName);
	ESTDLBL ELblNode();
	int INodeCst();
	BOOL BNodeSet(int istate, bool bSet = true);
	int INodeState();
	void NodeStateName(int istate);
	void NodeSymName();
	void NodeFullName();
	BOOL BNodePropItemStr(LPCTSTR szPropType, int index);
	BOOL BNodePropItenReal(LPCTSTR szPropType, int index, double &dbl);
	void NodeBelief();
	bool BValidNet();
	bool BValidNode();
	void Clear();

	void RemoveStates() {m_NodeState.RemoveAll();};
	void RemoveNode(int Node) {VERIFY(m_NodeState.RemoveKey(Node));};

	LPCTSTR SzcResult() const;

	void ReadTheDscModel(int From = TSERR_ENGINE_BNTS_READ);

	const CArray<int, int>& GetArrLastSniffed();

	int GetCountRecommendedNodes();
	int GetCountSniffedRecommendedNodes();

	bool IsReverse();
	void SetReverse(bool);

	void SetRunWithKnownProblem(bool);
	bool IsRunWithKnownProblem();

	void SetAdditionalDataOnNodeSet(NID nid);

protected:
	int GetIndexNodeInCache(NID nid);


protected:
	CHttpQuery	*m_pHttpQuery;
	BOOL CheckNode(int Node);
	void AddToCache(CString &strCacheFile, const CString& strCacheFileWithinCHM);

	BOOL	m_bNeedModel;	// TRUE -> Need to read the model before querying the bnts library.
	BOOL	m_bModelRead;
	BOOL	m_bDeleteModelFile;
	CString	m_strModelFile;	// Filename of model file
	CString m_strFile;      // name of *.dsz or *.dsc file inside *.chm file 
							// (in this case network file is actually a *.chm file)
	int m_CurNode;
	CMap<int, int, int, int>m_NodeState;

	CString m_strResult;

	CArray<int, int> m_arrNidLastSniffed; // array in sniffed nodes traversed during last navigation

	bool m_bReverse; // indicated if the current movement is in the forward or reverse direction

	bool m_bRunWithKnownProblem; //indicates that the tshooter was started with known problem
};

typedef struct tag_TShooter
{
	TCHAR m_szName[MAXBUF];
	TCHAR m_szDisplayName[MAXBUF];
} TShooter;

//
//
class CInfer
{
	
  public:
	CInfer(	CString *pCtxt);
	~CInfer();

	void	ClearDoubleSkip() {m_SkippedTwice.RemoveAll();};
	VOID	AssertFailed(TSZC szcFile, UINT iline, TSZC szcCond, BOOL fFatal);
	DWORD	Initialize(/*CSearchForm *pBESearch*/);
	void	LoadTShooters(HKEY hRegKey);
	int		GetCount() {return m_acnid;};

	void	BackUp(int nid, int state);
	void	ClearBackup() {m_Backup.Clear();};

	void	WriteProblem();
	BOOL	FSetNodeOfIdh(IDH, IST);
	int		GetForcedRecommendation();
	int		Finish(CString *cstr);
	void	ResetService();
	VOID	PrintRecommendations();
	VOID	WriteOutLogs();
	VOID	SetBelief(BCache *pAPI);
	TCHAR	*EvalData(UINT var_index);
	BOOL	NextVar(UINT var_index);
	BOOL	InitVar(UINT var_index);
	void	SetProblemAsk();
	void	ClearProblemAsk();
	void	SetType(LPCTSTR type);
	BOOL	IsService(CString *cstr);

	VOID	RemoveSkips();

	CSniffedNodeContainer* GetSniffedNodeContainer() {return m_api;}
	
protected:

	void	GetBackButton(CString &strBack);
	void	GetNextButton(CString &strNext);
	void	GetStartButton(CString &strStart);
	void	GetStd3ButtonEnList(CString *cstr, bool bIncludeBackButton, bool bIncludeNextButton, bool bIncludeStartButton);

	bool	GetNetPropItemStrs(TSZC item, UINT Res, CString *cstr);
	bool	GetNodePropItemStrs(TSZC item, UINT Res, CString *cstr);
	VOID	GetByeMsg(LPCTSTR szIdh, CString *cstr);
	VOID	GetFailMsg(LPCTSTR szIdh, CString *cstr);
	VOID	GetServiceMsg(LPCTSTR szIdh, CString *cstr);
	VOID	GetSkippedNodesMsg(LPCTSTR szIdh, CString *cstr);
	VOID	GetImpossibleNodesMsg(LPCTSTR szIdh, CString *cstr);
	VOID	GetFixRadios(LPCTSTR szIdh, CString *cstr);
	VOID	GetInfoRadios(LPCTSTR szIdh, CString *cstr);
	VOID	PrintMessage(TSZC szcFormat, ...) const;
	VOID	PrintString(TSZC szcFormat, ...) const;
	void	WriteResult(UINT name, UINT value, BOOL bSet, TSZC szctype, CString *cstr) const;
	VOID	CloseTable();
	BOOL	FxGetNode(NID nid, BOOL fStatus, CString *cstr) const; 
	void	FxGetState(CString *cstr);
	void	FxInitState(NID nid);
	VOID	GetIdhPage(IDH idh, CString *cstr);	
	bool	BelongsOnProblemPage(int index);
	VOID	GetIdhProblemPage(IDH idh, CString *cstr);

	VOID	OutputBackend(CString *cstr) const;
	BOOL	DisplayTerms(/*CWordList *pWords, */CString *cstr, BOOL bText, BOOL bOr) const;

	VOID	AddBackendDebug(CString *cstr) const;

	void	GetTS(CString *pCtmp);

  private:
	VOID	AddSkip(NID nid);
	BOOL	FSkip(NID nid) const;
	void	SaveNID(UINT nid);
	
	
  private:
	CBackupInfo m_Backup;
	UINT	m_cnidSkip;					// count of elements in m_rgnidSkip
	NID		m_rgnidSkip[cnidMacSkip];	// nodes for which the user has been unable to give
										// a yes or no answer.
	UINT	m_ilineStat;
	BOOL	m_fDone;					// (>>> Not well-understood 11/04/97 JM)
										// Set TRUE when we write out service, fail, or 
										//	success page, but there's some scenario where 
										//	we clear it "so that the Previous button will work"
										//	on BYE page"

	UINT	m_ishowService;		// >>> (JM 12/97) I suspect this is the same as OnlineTS's
								//	BOOL	m_bAnythingElse;	which is documented as
										// Set TRUE if user wants to see if there is anything
										//  else they can try (obtained from a service node in the
										//  previous call to the DLL
	IDH		m_idhQuestion;		// >>> (JM 12/97) I suspect this is the same as OnlineTS's
								//	NID		m_nidAnythingElse;	which is documented as
										// Node to use if m_bAnythingElse is TRUE
	
  private:
	CString *m_pCtmp;			// (uses new) just a scratch buffer
	int m_cShooters;			// a count of troubleshooting belief networks.  JM strongly
								//	suspects 3/98 that in Local TS it never gets past 1.
								// >>> presumably count of m_aShooters, so why don't we just
								//	use GetCount(), anyway?.
	int m_iShooter;				// index of a troubleshooting belief network.    JM strongly
								//	suspects 3/98 that in Local TS it is always 0.
								// presumably index into m_aShooters.
	CMap<int, int, int, int>m_SkippedTwice;
	CArray<TShooter, TShooter &> m_aShooters;
	NID m_cnid;				// number of positions used in m_rgnid
	NID m_rgnid[64];		// node numbers of recommendations the user has visited
	NID m_question_rgnid[64]; // new recommendations.  We only care about the first 
							//	recommendation not already offered and skipped.
	UINT m_cur_rec;			// index into m_rgnid.  We use this to loop through as we write
							//	the "visited node table"
	UINT m_max_rec;			// number of defined values in m_question_rgnid
	UINT m_cur_rec_inid;

	// The next 3 variables deal with states of a single node N, typically m_rgnid[m_cur_rec]
	UINT m_cur_state_set;	// state value of node N
	UINT m_cur_cst;			// count of states of node N
	UINT m_cur_ist;			// index into states of node N, used to build a list of radio 
							//	buttons and log entries.

	UINT m_problemAsk;		// >>> A thinly disguised Boolean. >>>(I think) something to do with
							// whether we return data on the problem node (vs. state-dependent
							// data) JM 10/30//97
	TCHAR m_problem[200];	// once a problem is chosen, this is where we put the associated
							//	text description of the problem. Full text description plus
							//	a hidden data field.
	NID  m_firstNid;
	UINT m_firstSet;
	TCHAR m_tstype[30];		// symbolic name of troubleshooter
	//
	// now in the CSniffedContainer object
	/*
	IDH m_idhSniffedRecommendation;	// if a recommendation from a sniffer overrides normal
							// method of getting a recommendation, here's where we store it.
							// Otherwise, nidNil+idhFirst.
	*/
	
  protected:
   	TSZ		m_szFile;
	FILE*	m_pfile;
	BOOL	m_bHttp;
	CHAR	m_szTemp1[MAXBUF];
	CString *m_pCtxt;			// points to a buffer passed in to constructor.  This is where
								// we build the HTML to pass back to the user
	TCHAR	m_currdir[MAXBUF];
	CString	*m_pResult;			// A string to indicate (in the log) a FINAL result of a
								// Troubleshoot session.  e.g. ">Success", ">Nothing Else",
								//	">Anything Else?", ">Help Elsewhere"
	CString *m_pSearchStr;		// a string consisting of the search words implied by our node 
								//	choices, separated by "and" or "or" (depending on the 
								//	value of m_pBESearch->IsAND).  Used as part of Back End 
								//	Search redirection.  >>> Probably irrelevant to Local TS, 
								//	which doesn't use BES
	BCache	*m_api;				// cache for associated belief network
	BOOL	m_bService;
	NID		m_nidPreloadCheck;
	CNID	m_acnid;			// count of nodes at *m_api
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\cabuncompress.cpp ===
//
// MODULE: CABUNCOMPRESS.CPP
//
// PURPOSE: CAB File Support Class
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		6/4/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <dos.h>
#include <sys/stat.h>

#include "CabUnCompress.h"

#include "chmread.h"
#include "apgts.h"

#ifdef _DEBUG
	#ifndef _UNICODE
	#define PRINT_OUT ::AfxTrace
	//#define PRINT_OUT 1 ? (void)0 : ::AfxTrace
	#else
	#define PRINT_OUT 1 ? (void)0 : ::AfxTrace
	#endif
#else
#define PRINT_OUT 1 ? (void)0 : ::AfxTrace
#endif

// Need this to compile unicode builds.
bool TcharToChar(char szOut[], LPCTSTR szIn, int &OutLen)
{
	int x = 0;
	while(NULL != szIn[x] && x < OutLen)
	{
		szOut[x] = (char) szIn[x];
		x++;
	}
	if (x < OutLen)
		szOut[x] = NULL;
	return x < OutLen;
}


// Call back functions needed to use the fdi library.

/*
 * Memory allocation function
 */
FNALLOC(mem_alloc)
{
	return malloc(cb);
}


/*
 * Memory free function
 */
FNFREE(mem_free)
{
	free(pv);
}


FNOPEN(file_open)
{
	return _open(pszFile, oflag, pmode);
}


FNREAD(file_read)
{
	return _read(hf, pv, cb);
}


FNWRITE(file_write)
{
	return _write(hf, pv, cb);
}


FNCLOSE(file_close)
{
	return _close(hf);
}


FNSEEK(file_seek)
{
	return _lseek(hf, dist, seektype);
}

/*
 * Function prototypes 
 */
BOOL	test_fdi(TCHAR *cabinet_file);
int		get_percentage(unsigned long a, unsigned long b);
TCHAR   *return_fdi_error_string(FDIERROR err);


/*
 * Destination directory for extracted files
 */
char	dest_dir[MAX_PATH];

// Last file to be extracted.
char	last_extracted[MAX_PATH];

FNFDINOTIFY(notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
			PRINT_OUT(
				_T("fdintCABINET_INFO\n")
				_T("  next cabinet     = %s\n")
				_T("  next disk        = %s\n")
				_T("  cabinet path     = %s\n")
				_T("  cabinet set ID   = %d\n")
				_T("  cabinet # in set = %d (zero based)\n")
				_T("\n"),
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3,
				pfdin->setID,
				pfdin->iCabinet);

			return 0;

		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			PRINT_OUT(
				_T("fdintPARTIAL_FILE\n")
				_T("   name of continued file            = %s\n")
				_T("   name of cabinet where file starts = %s\n")
				_T("   name of disk where file starts    = %s\n"),
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3);
			return 0;

		case fdintCOPY_FILE:	// file to be copied
		{
			int	handle;
			char destination[MAX_PATH];

			PRINT_OUT(
				_T("fdintCOPY_FILE\n")
				_T("  file name in cabinet = %s\n")
				_T("  uncompressed file size = %d\n")
				_T("  copy this file? (y/n): y"),
				pfdin->psz1,
				pfdin->cb);

			strcpy(last_extracted, pfdin->psz1);

			PRINT_OUT(_T("\n"));

			sprintf(
				destination, 
				"%s%s",
				dest_dir,
				pfdin->psz1
			);

			handle = file_open(
				destination,
				_O_BINARY | _O_CREAT | _O_TRUNC | _O_WRONLY | _O_SEQUENTIAL,
				_S_IREAD | _S_IWRITE 
			);

			return handle;
		}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info
		{
			HANDLE handle;
			DWORD attrs;
			char destination[MAX_PATH];

 			PRINT_OUT(
				_T("fdintCLOSE_FILE_INFO\n")
				_T("   file name in cabinet = %s\n")
				_T("\n"),
				pfdin->psz1);

			sprintf(
				destination, 
				"%s%s",
				dest_dir,
				pfdin->psz1);

			file_close(pfdin->hf);

            /*
             * Set date/time
             *
             * Need Win32 type handle for to set date/time
             */
			handle = CreateFileA(
				destination,
				GENERIC_READ | GENERIC_WRITE,
				FILE_SHARE_READ,
				NULL,
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL,
				NULL);

			if (handle != INVALID_HANDLE_VALUE)
			{
				FILETIME    datetime;

				if (TRUE == DosDateTimeToFileTime(
					pfdin->date,
					pfdin->time,
					&datetime))
				{
					FILETIME    local_filetime;

					if (TRUE == LocalFileTimeToFileTime(
						&datetime,
						&local_filetime))
					{
						(void) SetFileTime(
							handle,
							&local_filetime,
							NULL,
							&local_filetime);
					}
				}

				CloseHandle(handle);
			}

            /*
             * Mask out attribute bits other than readonly,
             * hidden, system, and archive, since the other
             * attribute bits are reserved for use by
             * the cabinet format.
             */
			attrs = pfdin->attribs;

			attrs &= (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);

			(void) SetFileAttributesA(
				destination,
				attrs);

			return TRUE;
		}

		case fdintNEXT_CABINET:	// file continued to next cabinet
			PRINT_OUT(
				_T("fdintNEXT_CABINET\n")
				_T("   name of next cabinet where file continued = %s\n")
                _T("   name of next disk where file continued    = %s\n")
				_T("   cabinet path name                         = %s\n")
				_T("\n"),
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3);
			return 0;
	}

	return 0;
}

TCHAR *return_fdi_error_string(FDIERROR err)
{
	switch (err)
	{
		case FDIERROR_NONE:
			return _T("No error");

		case FDIERROR_CABINET_NOT_FOUND:
			return _T("Cabinet not found");
			
		case FDIERROR_NOT_A_CABINET:
			return _T("Not a cabinet");
			
		case FDIERROR_UNKNOWN_CABINET_VERSION:
			return _T("Unknown cabinet version");
			
		case FDIERROR_CORRUPT_CABINET:
			return _T("Corrupt cabinet");
			
		case FDIERROR_ALLOC_FAIL:
			return _T("Memory allocation failed");
			
		case FDIERROR_BAD_COMPR_TYPE:
			return _T("Unknown compression type");
			
		case FDIERROR_MDI_FAIL:
			return _T("Failure decompressing data");
			
		case FDIERROR_TARGET_FILE:
			return _T("Failure writing to target file");
			
		case FDIERROR_RESERVE_MISMATCH:
			return _T("Cabinets in set have different RESERVE sizes");
			
		case FDIERROR_WRONG_CABINET:
			return _T("Cabinet returned on fdintNEXT_CABINET is incorrect");
			
		case FDIERROR_USER_ABORT:
			return _T("User aborted");
			
		default:
			return _T("Unknown error");
	}
}

CCabUnCompress::CCabUnCompress()
{
	m_strError = _T("");
	m_nError = NO_ERROR;
	return;
}

BOOL CCabUnCompress::ExtractCab(CString &strCabFile, CString &strDestDir, const CString& strFile)
{
	HFDI			hfdi;
	ERF				erf;
	FDICABINETINFO	fdici;
	int				hf;
	char			*p;
	char			cabinet_name[MAX_PATH];
	char			cabinet_path[MAX_PATH];
	bool            bUseCHM = strFile.GetLength() != 0;
	BOOL            bRet = FALSE;
	BOOL            bWasRenamed = FALSE;

	char sznCabFile[MAX_PATH];
	char sznDestDir[MAX_PATH * 3];
	int Len = MAX_PATH;
	TcharToChar(sznCabFile, (LPCTSTR) strCabFile, Len);
	Len = MAX_PATH * 3;
	TcharToChar(sznDestDir, (LPCTSTR) strDestDir, Len);


	ASSERT(strDestDir.GetLength() < MAX_PATH);
	strcpy(dest_dir, sznDestDir);

	hfdi = FDICreate(
		mem_alloc,
		mem_free,
		file_open,
		file_read,
		file_write,
		file_close,
		file_seek,
		cpu80386,
		&erf
	);

	if (hfdi == NULL)
	{
		m_strError.Format(_T("FDICreate() failed: code %d [%s]\n"),
			erf.erfOper, return_fdi_error_string(erf.erfOper));

		return FALSE;
	}

	if (bUseCHM)
	{
		/*
		 * If strCabFile is CHM file - extract data from *.dsz file inside CHM
		 *  and save this data in strDestDir directory as temperary file
		 * It means that we are copying *.dsz file in temp directory, then 
		 *  decode it to *.dsc file. 
		 * *.dsz file fill be removed in this function, *.dsc file will be renoved
		 *  later.
		 */

		// modify sznCabFile from path\*.chm to temp_path\network.dsz
		strcpy(sznCabFile, strDestDir);
		strcat(sznCabFile, strFile);

		hf = file_open(
			sznCabFile,
			_O_CREAT | _O_TRUNC | /*_O_TEMPORARY |*/
			_O_BINARY | _O_RDWR | _O_SEQUENTIAL ,
			_S_IREAD | _S_IWRITE 
		);
				
		if (hf != -1)
		{
			// write in temp file now
			void* buf =NULL;
			DWORD size =0;

			if (S_OK == ::ReadChmFile(strCabFile, strFile, &buf, &size))
			{
				int ret = _write(hf, buf, size);
				delete [] buf;
				if (-1 == ret)
				{
					FDIDestroy(hfdi);
					_close(hf);
					return FALSE;
				}
			}
			else
			{
				FDIDestroy(hfdi);
				_close(hf);
				return FALSE;
			}
		}
		else
		{
			FDIDestroy(hfdi);
			return FALSE;
		}

		_close(hf);
	}
	
	/*
	 * Is this file really a cabinet?
	 */
	hf = file_open(
		sznCabFile,
		_O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
		0
	);

	if (hf == -1)
	{
		(void) FDIDestroy(hfdi);

		m_strError.Format(_T("Unable to open '%s' for input\n"), (LPCTSTR) strCabFile);
		return FALSE;
	}

	bRet = FDIIsCabinet(hfdi,
						hf,
						&fdici);

	_close(hf);
	
	if (FALSE == bRet)
	{
		/*
		 * No, it's not a cabinet!
		 */
		if (bUseCHM)
		{
			// But if we were using CHM -
			//  we have extracted this *.dsz (that has *.dsc format)
			//  in TEMP directory and all we heed - just rename it to
			//  *.dsc.
			// This would EMULATE case where we have *.dsz compressed.
			CString strUncompressedFile, strCabFile(sznCabFile);
			strUncompressedFile = strCabFile.Left(strCabFile.GetLength() - 4);
			strUncompressedFile += DSC_UNCOMPRESSED;
			remove(strUncompressedFile); // remove if exists
			if (0 != rename(strCabFile, strUncompressedFile))
			{
				FDIDestroy(hfdi);
				goto AWAY;
			}
			CString strJustUncompressedFileName = ::ExtractFileName(strUncompressedFile);
			strcpy(last_extracted, strJustUncompressedFileName);
			bWasRenamed = TRUE;
			bRet = TRUE;
		}
		else
		{
			m_strError.Format(
				_T("FDIIsCabinet() failed: '%s' is not a cabinet\n"),
				(LPCTSTR) strCabFile);
			m_nError = NOT_A_CAB;
		}
		(void) FDIDestroy(hfdi);
		goto AWAY;
	}
	else
	{
		PRINT_OUT(
			_T("Information on cabinet file '%s'\n")
			_T("   Total length of cabinet file : %d\n")
			_T("   Number of folders in cabinet : %d\n")
			_T("   Number of files in cabinet   : %d\n")
			_T("   Cabinet set ID               : %d\n")
			_T("   Cabinet number in set        : %d\n")
			_T("   RESERVE area in cabinet?     : %s\n")
			_T("   Chained to prev cabinet?     : %s\n")
			_T("   Chained to next cabinet?     : %s\n")
			_T("\n"),
			(LPCTSTR) strCabFile,
			fdici.cbCabinet,
			fdici.cFolders,
			fdici.cFiles,
			fdici.setID,
			fdici.iCabinet,
			fdici.fReserve == TRUE ? _T("yes") : _T("no"),
			fdici.hasprev == TRUE ? _T("yes") : _T("no"),
			fdici.hasnext == TRUE ? _T("yes") : _T("no")
		);
	}

	p = strchr(sznCabFile, '\\');

	if (p == NULL)
	{
		strcpy(cabinet_name, sznCabFile);
		strcpy(cabinet_path, "");
	}
	else
	{
		strcpy(cabinet_name, p+1);

		char *pCab = sznCabFile;

		strncpy(cabinet_path, sznCabFile, (int) (p-pCab)+1);
		cabinet_path[ (int) (p-pCab)+1 ] = 0;
	}

	if (TRUE != FDICopy(
		hfdi,
		cabinet_name,
		cabinet_path,
		0,
		notification_function,
		NULL,
		NULL))
	{
		m_strError.Format(
			_T("FDICopy() failed: code %d [%s]\n"),
			erf.erfOper, return_fdi_error_string(erf.erfOper));

		(void) FDIDestroy(hfdi);
		bRet = FALSE;
		goto AWAY;
	}

	if (FDIDestroy(hfdi) != TRUE)
	{
		m_strError.Format(
			_T("FDIDestroy() failed: code %d [%s]\n"),
			erf.erfOper, return_fdi_error_string(erf.erfOper));

		bRet = FALSE;
		goto AWAY;
	}

AWAY:
	if (bUseCHM && !bWasRenamed)
		remove(sznCabFile);

	return bRet;
}

CString CCabUnCompress::GetLastFile()
{
	CString str = last_extracted;
	return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\basicexception.h ===
//
// MODULE: BASICEXCEPTION.H
//
// PURPOSE:  Exception that will be caught in ApgtsX2Ctrl::RunQuery.
//           This exception is thrown from most of the Trouble 
//           shooter functions.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5

#ifndef __BASICEXCEPTION_H_
#define __BASICEXCEPTION_H_ 1

class CBasicException
{
public:
	CBasicException();
	~CBasicException();

	DLSTATTYPES m_dwBErr;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\bnts.h ===
//
// MODULE:  BNTS.H
//
// PURPOSE: "read only" belief network API for Troubleshooters
//	bnts.h:  Definitions for the Belief Network Troubleshooting object.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Apparently originated at MSR
// 
// ORIGINAL DATE: unknown
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.3		3/24/98		JM		Local Version for NT5

#ifndef _BNTS_H_
#define _BNTS_H_

//  BN system inclusions
#include "enumstd.h"		// Standard enumeration declarations for the BN system

// 'BNTS_EXPORT' should only be defined in the project that builds the DLL
#ifdef	BNTS_EXPORT
	//  We're building the DLL (exporting the class)
	#define	BNTS_RESIDENT __declspec(dllexport)
#else
	//  We're using the DLL (importing the class)
	#define	BNTS_RESIDENT __declspec(dllimport)
#endif

//  Forward declaration of internal belief network class
class MBNETDSCTS;										//  the encapsulated BN class
class GNODEMBND;										//  Discrete nodes
class LTBNPROP;											//  Property list
class ZSTR;

typedef const char * SZC;								//  simple alias
typedef char * SZ;
typedef double REAL;

////////////////////////////////////////////////////////////////////////////////////////////
//
//	class BNTS: the belief network troubleshooter
//
////////////////////////////////////////////////////////////////////////////////////////////
class BNTS_RESIDENT BNTS
{	
  public:
	//  CTOR and DTOR
	BNTS ();
	~ BNTS ();

	////////////////////////////////////////////////////////////////////
	//  Model-level queries and functions
	////////////////////////////////////////////////////////////////////
		//  Load and process a DSC-based model
	BOOL BReadModel ( SZC szcFn, SZC szcFnError = NULL );
		//  Return the number of (pre-expansion) nodes in the model
	int CNode ();
		//  Return the recommended nodes and, optionally, their values
	BOOL BGetRecommendations ();
		//  Return TRUE if the state of information is impossible
	BOOL BImpossible ();
		//  Return a property item string from the network
	BOOL BNetPropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the network
	BOOL BNetPropItemReal ( SZC szcPropType, int index, double & dbl );

	////////////////////////////////////////////////////////////////////
	//  Operations involving the "Currrent Node": call NodeSetCurrent()
	////////////////////////////////////////////////////////////////////
		//  Set the current node for other calls
	BOOL BNodeSetCurrent( int inode );
		//	Get the current node
	int INodeCurrent ();
		//  Return the index of a node given its symbolic name
	int INode ( SZC szcNodeSymName );	
		//	Return the label of the current node
	ESTDLBL ELblNode ();
		//  Return the number of discrete states in the current node
	int INodeCst ();
		//  Set the state of a node; use -1 to uninstatiate
	BOOL BNodeSet ( int istate, bool bSet = true );
		//  Return the state of a node
	int  INodeState ();
		//	Return the name of a node's state
	void NodeStateName ( int istate );
		//  Return the symbolic name of the node
	void NodeSymName ();
		//  Return the full name of the node
	void NodeFullName ();
		//  Return a property item string from the node
	BOOL BNodePropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the node
	BOOL BNodePropItemReal ( SZC szcPropType, int index, double & dbl );
		//  Return the belief for a node
	void NodeBelief ();
		//  Return true if the network is loaded and correct
	bool BValidNet () const;
		//  Return true if the current node is set
	bool BValidNode () const;
		//  Discard the model and all components
	void Clear();

	////////////////////////////////////////////////////////////////////
	//  Accessors to the function result information	
	////////////////////////////////////////////////////////////////////
	SZC SzcResult () const;					//  String answer		
	const REAL * RgReal () const;			//  Array of reals		
	const int * RgInt () const;				//  Array of Integers	
	int CReal () const;						//  Count of reals		
	int CInt () const;						//  Count of integers

  protected:
	MBNETDSCTS * _pmbnet;			//  The T/S DSC belief network
	int _inodeCurrent;				//  The current node

  protected:
	MBNETDSCTS & Mbnet();
	const MBNETDSCTS & Mbnet() const;
	GNODEMBND * Pgndd ();
	BOOL BGetPropItemStr ( LTBNPROP & ltprop, 
						   SZC szcPropType, 
						   int index, 
						   ZSTR & zstr );
	BOOL BGetPropItemReal ( LTBNPROP & ltprop, 
							SZC szcPropType, 
							int index, 
							double & dbl );
	void ClearArrays ();
	void ClearString ();
	ZSTR & ZstrResult ();
};

#endif // _BNTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\apgtsqry.cpp ===
//
// MODULE: APGTSQRY.CPP
//
// PURPOSE: Implementation file for PTS Query Parser
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
//
// NOTES:
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

//#include "windows.h"
#include "stdafx.h"

#include "time.h"

#include "apgts.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include "ErrorEnums.h"
#include "BasicException.h"
#include "HttpQueryException.h"
#include "Functions.h"

#include "BackupInfo.h"

#include <string.h>
#include <stdlib.h>

#include "LaunchServ.h"

//
//
CHttpQuery::CHttpQuery()
{
	m_pvarCmds = NULL;
	m_pvarVals = NULL;
	m_strCmd1 = _T("");
	m_strVal1 = _T("");
	m_CurrentUse = 0;
	m_Size = 0;
	m_bReverseStack = false;
	m_nStatesFromServ = 0;
}

//
//
CHttpQuery::~CHttpQuery()
{
}

void CHttpQuery::ThrowBadParams(CString &str)
{
	CHttpQueryException *pExc = new CHttpQueryException;
#ifndef __DEBUG_HTTPQUERY_
	pExc->m_strError = _T("Script Error");
#else
	pExc->m_strError = str;
#endif
	throw pExc;
	return;
}

void CHttpQuery::Initialize(const VARIANT FAR& varCmds, const VARIANT FAR& varVals, short size)
{
#ifdef __DEBUG_HTTPQUERY_
	AfxMessageBox(_T("Cmd Variant Types:\n\n") + DecodeVariantTypes(varCmds.vt), MB_ICONINFORMATION);
	AfxMessageBox(_T("Value Variant Types:\n\n") + DecodeVariantTypes(varVals.vt), MB_ICONINFORMATION);
#endif
	const VARIANT FAR *pVarCmds;
	const VARIANT FAR *pVarVals;
	if (VT_BYREF  == (VT_BYREF & varCmds.vt) &&
			VT_VARIANT == (VT_VARIANT & varCmds.vt))
	{
		if (VT_ARRAY == (VT_ARRAY & varCmds.vt))
			pVarCmds = &varCmds;
		else
			pVarCmds = varCmds.pvarVal;
	}
	else
	{
		pVarCmds = NULL;
		CString str = _T("Cmd parameters from VB were not a variant or not by ref.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
	if (VT_BYREF  == (VT_BYREF & varVals.vt) &&
			VT_VARIANT == (VT_VARIANT & varVals.vt))
	{
		if (VT_ARRAY == (VT_ARRAY & varVals.vt))
			pVarVals = &varVals;
		else
			pVarVals = varVals.pvarVal;
	}
	else
	{
		pVarVals = NULL;
		CString str = _T("Cmd parameters from VB were not a variant or not by ref.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
	if (VT_BYREF  != (VT_BYREF & pVarCmds->vt) ||
			VT_ARRAY != (VT_ARRAY & pVarCmds->vt) ||
			VT_VARIANT != (0xFFF & pVarCmds->vt))
	{
		CString str = _T("Wrong Cmd parameters passed from VB.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
	if (VT_BYREF  != (VT_BYREF & pVarVals->vt) ||
			VT_ARRAY != (VT_ARRAY & pVarVals->vt) ||
			VT_VARIANT != (0xFFF & pVarVals->vt))
	{
		CString str = _T("Wrong Cmd parameters passed from VB.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
#ifdef __DEBUG_HTTPQUERY_
	AfxMessageBox(_T("Cmd Variant Types:\n\n") + DecodeVariantTypes(pVarCmds->vt), MB_ICONINFORMATION);
	AfxMessageBox(_T("Value Variant Types:\n\n") + DecodeVariantTypes(pVarVals->vt), MB_ICONINFORMATION);
#endif
	SAFEARRAY *pArrCmds = *(pVarCmds->pparray);
	SAFEARRAY *pArrVals = *(pVarVals->pparray);
#ifdef __DEBUG_HTTPQUERY_
	CString strSafe;
	strSafe.Format("Cmd Safe Array\n\nDim: %d\nfeatures:\n%s\nSize of the Elements: %ld",
		pArrCmds->cDims, (LPCTSTR) DecodeSafeArray(pArrCmds->fFeatures),
		pArrCmds->cbElements);
	AfxMessageBox(strSafe, MB_ICONINFORMATION);
	strSafe.Format("Val Safe Array\n\nDim: %d\nfeatures:\n%s\nSize of the Elements: %ld",
		pArrVals->cDims, (LPCTSTR) DecodeSafeArray(pArrVals->fFeatures),
		pArrVals->cbElements);
	AfxMessageBox(strSafe, MB_ICONINFORMATION);
#endif	
	if (0 != pArrCmds->rgsabound[0].lLbound || 0 != pArrVals->rgsabound[0].lLbound)
	{
		CString str = _T("Wrong Cmd parameters passed from VB.  Lower bounds are wrong.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
	if (pArrCmds->rgsabound[0].cElements != pArrVals->rgsabound[0].cElements)
	{
		CString str = _T("Wrong Cmd parameters passed from VB.  Cmds upperbound != Vals upperbound.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
	m_Size = size;
#ifdef __DEBUG_HTTPQUERY_
	CString str;
	str.Format("Size:  %d", m_Size);
	AfxMessageBox(str, MB_ICONINFORMATION);
#endif
	m_pvarCmds = (VARIANT *) pArrCmds->pvData;
	m_pvarVals = (VARIANT *) pArrVals->pvData;
	if (0 != m_Size)
	{
		if (m_pvarCmds->vt != VT_BSTR || m_pvarVals->vt != VT_BSTR)
		{
			CString str;
			str.Format(_T("Wrong Cmd parameters passed from VB.  Array of unexpected type.\n\n")
				_T("Cmd Type: %s\nVal Type: %s"),
				(LPCTSTR) DecodeVariantTypes(m_pvarCmds->vt),
				(LPCTSTR) DecodeVariantTypes(m_pvarVals->vt));
			ASSERT(FALSE);
			TRACE(_T("%s\n"), str);
			ThrowBadParams(str);
		}
	}	
	CString strC = m_pvarCmds[0].bstrVal;
	CString strD = m_pvarVals[0].bstrVal;
	if (strC != m_strCmd1 || strD != m_strVal1)
		m_State.RemoveAll();
	m_strCmd1 = strC;
	m_strVal1 = strD;
	return;
}

BOOL CHttpQuery::StrIsDigit(LPCTSTR pSz)
{
	BOOL bRet = TRUE;
	while (*pSz)
	{
		if (!_istdigit(*pSz))
		{
			bRet = FALSE;
			break;
		}
		pSz = _tcsinc(pSz);
	}
	return bRet;
}

void CHttpQuery::FinishInit(BCache *pApi, const VARIANT FAR& varCmds, const VARIANT FAR& varVals)
{
	ASSERT(pApi);
	ASSERT(m_Size > 0);
	CNode node;
	CString str;
	if (!pApi)
		return;
	if (!pApi->BValidNet())
		pApi->ReadModel();
	m_bReverseStack = false;
	for (int x = 1; x < m_Size; x++)
	{		
		// Read the command.
		str = m_pvarCmds[x].bstrVal;
		if (StrIsDigit((LPCTSTR) str))
			node.cmd = _ttoi(str);
		else if (0 == _tcscmp(CHOOSE_TS_PROBLEM_NODE, (LPCTSTR) str))
			node.cmd = pApi->CNode() + idhFirst;
		else if (0 == _tcscmp(TRY_TS_AT_MICROSOFT_SZ, (LPCTSTR) str))
			node.cmd = TRY_TS_AT_MICROSOFT_ID;
		else
		{
			NID nid = pApi->INode((LPCTSTR) str);
			if (nid == -1)
			{
				// Invalid node name.  This also throws suspicion on anything further
				//	down the line.  Just break out of the loop.
				break;
			}
			node.cmd = nid + idhFirst;
		}
		// Read the value.
		str = m_pvarVals[x].bstrVal;
		if (StrIsDigit((LPCTSTR) str))
			node.val = _ttoi(str);
		else
		{
			NID nid = pApi->INode((LPCTSTR) str);
			if (nid == -1)
			{
				// Invalid node name.  This also throws suspicion on anything further
				//	down the line.  Just break out of the loop.
				break;
			}
			node.val = nid + idhFirst;
		}
		m_State.Push(node);
	}
	return;
}

void CHttpQuery::PushNodesLastSniffed(const CArray<int, int>& arr)
{
	for (int i = 0; i < arr.GetSize(); i++)
	{
		CNode node;
		node.cmd = idhFirst + arr[i];
		node.val = 0;
		node.sniffed = true;
		m_State.Push(node);
	}
}

void CHttpQuery::FinishInitFromServ(BCache *pApi, ILaunchTS *pLaunchTS)
{
	ASSERT(pApi);
	CNode node;
	CString str;
	HRESULT hRes;
	HRESULT hResNode;
	HRESULT hResState;
	OLECHAR *poleProblem;
	OLECHAR *poleNode;
	OLECHAR *poleState;
	OLECHAR *poleMachine;
	OLECHAR *polePNPDevice;
	OLECHAR *poleGuidClass;
	OLECHAR *poleDeviceInstance;

	///////////////////////////////////////////////////////////
	// obtaining Machine, PNPDevice, GuidClass, DeviceInstance
	//
	hRes = pLaunchTS->GetMachine(&poleMachine);

	if (S_FALSE == hRes || FAILED(hRes))
		return;
	m_strMachineID = poleMachine;
	::SysFreeString(poleMachine);
	
	hRes = pLaunchTS->GetPNPDevice(&polePNPDevice);
	if (S_FALSE == hRes || FAILED(hRes))
		return;
	m_strPNPDeviceID = polePNPDevice;
	::SysFreeString(polePNPDevice);

	hRes = pLaunchTS->GetGuidClass(&poleGuidClass);
	if (S_FALSE == hRes || FAILED(hRes))
		return;
	m_strGuidClass = poleGuidClass;
	::SysFreeString(poleGuidClass);
	
	hRes = pLaunchTS->GetDeviceInstance(&poleDeviceInstance);
	if (S_FALSE == hRes || FAILED(hRes))
		return;
	m_strDeviceInstanceID = poleDeviceInstance;
	::SysFreeString(poleDeviceInstance);
	//
	////////////////////////////////////////////////////////////

	if (!pApi)
		return;
	if (!pApi->BValidNet())
		pApi->ReadModel();
	m_Size = 1;	// I believe this accounts for the troubleshooting network name (JM 3/98)
	m_nStatesFromServ = 0;
	
	// The order that the nodes are set in the inference engine is important.
	// >>> I (JM 3/14/98) don't understand the rest of this comment:
	// Need the rest of the nodes inverted on the stack.
	// The buttons can not be inverted here.  When they are the back button
	// stops working.
	hRes = pLaunchTS->GetProblem(&poleProblem);
	if (S_FALSE == hRes || FAILED(hRes))
		return;
	str = poleProblem;
	SysFreeString(poleProblem);
	node.cmd = pApi->CNode() + idhFirst;	// Sets the problem state.
	if (StrIsDigit((LPCTSTR) str))
		node.val = _ttoi(str);
	else
	{
		NID nidProblem = pApi->INode((LPCTSTR) str);
		if (nidProblem == static_cast<NID>(-1))
		{
			// The specified problem node doesn't exist. Ignore it and any other nodes
			//	that follow.
			return;
		}

		pApi->SetRunWithKnownProblem(true);
		pApi->BNodeSetCurrent( nidProblem );
		if (pApi->ELblNode() != ESTDLBL_problem )
		{
			// The specified problem node exists, but it's not a problem node.
			//	Ignore it and any other nodes that follow.
			return;
		}

		IDH idhProblem = nidProblem + idhFirst;
		node.val = idhProblem;
	}
	m_State.Push(node);
	m_Size++;
	m_aStatesFromServ[m_nStatesFromServ] = node;
	m_nStatesFromServ++;

	int iAnyNode = 0;
	do
	{
		hResNode = pLaunchTS->GetNode((short)iAnyNode, &poleNode);
		if (FAILED(hResNode) || S_FALSE == hResNode)
			break;
		str = poleNode;
		SysFreeString(poleNode);
		if (StrIsDigit((LPCTSTR) str))
			node.cmd = _ttoi(str);
		else
			node.cmd = pApi->INode((LPCTSTR) str) + idhFirst;

		hResState = pLaunchTS->GetState((short)iAnyNode, &poleState);
		if (FAILED(hResState) || S_FALSE == hResState)
			break;;
		str = poleState;
		SysFreeString(poleNode);
		if (StrIsDigit((LPCTSTR) str))
			node.val = _ttoi(str);
		else
			node.val = pApi->INode((LPCTSTR) str) + idhFirst;
		m_State.Push(node);
		m_Size++;
		m_aStatesFromServ[m_nStatesFromServ] = node;
		m_nStatesFromServ++;
		iAnyNode++;
	} while (true);

	return;
}

// Restore states to where CHttpQuery::FinishInitFromServ() left them
void CHttpQuery::RestoreStatesFromServ()
{
	UINT i;

	for (i=0; i < m_nStatesFromServ; i++)
		m_State.Push(m_aStatesFromServ[i]);
}

//
//
BOOL CHttpQuery::GetFirst(CString &strPut, CString &strValue)
{
	BOOL bStatus = FALSE;	
	if (0 < m_Size)
	{
		bStatus = TRUE;
		strPut = m_strCmd1;
		strValue = m_strVal1;
		m_CurrentUse = 0;
	}
	m_CurrentUse++;
	return bStatus;
}

void CHttpQuery::SetFirst(CString &strCmd, CString &strVal)
{
	m_Size = 1;
	m_strCmd1 = strCmd;
	m_strVal1 = strVal;
	return;
}

//
//
BOOL CHttpQuery::GetNext(int &refedCmd, int &refedValue /*TCHAR *pCmd, TCHAR *pValue*/ )
{
	BOOL bStatus;
	CNode node;
	// The stack direction was made to be reversable
	// to support setting many nodes by an NT5 application using the TS Launcher.
	if (false == m_bReverseStack)	
		bStatus = m_State.GetAt(m_CurrentUse, node);
	else
		bStatus = m_State.GetAt(m_Size - m_CurrentUse, node);
	refedCmd = node.cmd;
	refedValue = node.val;
	m_CurrentUse++;
	return bStatus;
}

void CHttpQuery::SetStackDirection()
{
	if ((m_Size - m_CurrentUse) > 1)
		m_bReverseStack = true;
	else
		m_bReverseStack = false;
}
/*
BOOL CHttpQuery::GetValue(int &Value, int index)
{
	BOOL bRet = TRUE;
	CNode node;
	if (m_State.GetAt(index, node))
		Value = node.val;
	else
	{
		Value = NULL;
		bRet = FALSE;
	}
	return bRet;
}
*/
BOOL CHttpQuery::GetValue1(int &Value)
{
	BOOL bRet = TRUE;
	CNode node;
	if (false == m_bReverseStack)
	{
		if (m_State.GetAt(1, node))
		{
			Value = node.val;
		}
		else
		{
			Value = NULL;
			bRet = FALSE;
		}
	}
	else
	{
		if (m_State.GetAt(m_Size - 1, node))
		{
			Value = node.val;
		}
		else
		{
			Value = NULL;
			bRet = FALSE;
		}
	}
	return bRet;
}

CString CHttpQuery::GetTroubleShooter()
{
	CString str = m_pvarVals[0].bstrVal;
	return str;
}

CString CHttpQuery::GetFirstCmd()
{
	CString str = m_pvarCmds[0].bstrVal;
	return str;
}

BOOL CHttpQuery::BackUp(BCache *pApi, APGTSContext *pCtx)
{
	ASSERT(pApi);
	CNode node;
	BOOL bBack = FALSE;
	if (!m_State.Empty())
	{
		bBack = TRUE;
		node = m_State.Pop();
		if (!m_State.Empty())
		{	// Can not uninstantiate the problem page, it is not a real node.
			// Remove the node from the bnts network.
			if (node.val < 100)		
				pApi->RemoveRecommendation(node.cmd - idhFirst);
			if (node.sniffed) // skip all sniffed nodes by recursive call of the function
				return BackUp(pApi, pCtx);
			pCtx->BackUp(node.cmd - idhFirst, node.val);
		}
		else
		{
			pApi->RemoveRecommendation(node.val - idhFirst);
			pCtx->BackUp(node.val - idhFirst, CBackupInfo::INVALID_BNTS_STATE);
		}
	}
	return bBack;
}

void CHttpQuery::RemoveNodes(BCache *pApi)
{
	CNode node;
	while (!m_State.Empty())
	{
		node = m_State.Pop();
		if (!m_State.Empty())
		{
			//VERIFY(pApi->BNodeSetCurrent(node.cmd - idhFirst));
			//pApi->BNodeSet(-1, false);
			pApi->RemoveRecommendation(node.cmd - idhFirst);  // we need remove all data assosiated with previous path
		}
		else
		{
			//VERIFY(pApi->BNodeSetCurrent(node.val - idhFirst));
			//pApi->BNodeSet(-1, false);
			pApi->RemoveRecommendation(node.val - idhFirst);  // we need remove all data assosiated with previous path
		}
		
	}
	pApi->RemoveStates();
	return;
}

void CHttpQuery::AddNodes(BCache *pApi)
{
	CNode node;
	RSStack<CNode>state;
	if (m_State.PeakFirst(node))
	{
		do
		{
			state.Push(node);
		} while (m_State.PeakNext(node));
	}
	if (!state.Empty())
	{
		node = state.Pop();
		VERIFY(pApi->GTSAPI::BNodeSetCurrent(node.val - idhFirst));
		pApi->GTSAPI::BNodeSet(1, false);
	}
	while (!state.Empty())
	{
		node = state.Pop();
		if (node.val < 100)	// We never instantiate the I don't know nodes.
		{
			VERIFY(pApi->GTSAPI::BNodeSetCurrent(node.cmd - idhFirst));
			pApi->GTSAPI::BNodeSet(node.val, false);
		}
	}
	return;
}

CString CHttpQuery::GetSubmitString(BCache *pApi)
{
	ASSERT(NULL != pApi);
	CNode node;
	RSStack<CNode> stack;
	CString str;
	CString strGet = _T("");
	if (m_State.PeakFirst(node))
	{
		do
		{
			stack.Push(node);
		} while (m_State.PeakNext(node));
	}
	if (!stack.Empty())
	{
		node = stack.Pop();
		if (pApi->BNodeSetCurrent(node.val - idhFirst))
		{
			strGet += _T("&");
			strGet += CHOOSE_TS_PROBLEM_NODE;
			strGet += _T("=");
			pApi->NodeSymName();
			strGet += pApi->SzcResult();
		}
		while (!stack.Empty())
		{
			node = stack.Pop();
			if (pApi->BNodeSetCurrent(node.cmd - idhFirst))
			{
				strGet += _T("&");
				pApi->NodeSymName();
				strGet += pApi->SzcResult();				
				str.Format(_T("%d"), node.val);
				strGet += _T("=") + str;
			}
		}
	}
	return strGet;
}

void CHttpQuery::Debug()
{
	CNode node;
	RSStack<CNode>state;
	CString str;
	if (m_State.PeakFirst(node))
	{
		do
		{
			str.Format(_T("Cmd %d Val %d"), node.cmd, node.val);
			AfxMessageBox(str);
		} while (m_State.PeakNext(node));
	}
}

CString& CHttpQuery::GetMachine()
{
	return m_strMachineID;
}

CString& CHttpQuery::GetPNPDevice()
{
	return m_strPNPDeviceID;
}

CString& CHttpQuery::GetDeviceInstance()
{
	return m_strDeviceInstanceID;
}

CString& CHttpQuery::GetGuidClass()
{
	return m_strGuidClass;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\cabuncompress.h ===
//
// MODULE: CABUNCOMPRESS.H
//
// PURPOSE: Header for CAB support
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __CABUNCOMPRESS_H_
#define __CABUNCOMPRESS_H_ 1

#include "fdi.h"

class CCabUnCompress
{
public:
#define NO_CAB_ERROR 0
#define NOT_A_CAB 1

public:
	CCabUnCompress();

	BOOL ExtractCab(CString &strCabFile, CString &strDestDir, const CString& strFile);
	CString GetLastFile();

	void ThrowGen();

	CString m_strError;
	int m_nError;

protected:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\cachegen.cpp ===
//
// MODULE: CACHEGEN.CPP
//
// PURPOSE: Cache File Generator and Reader for BN Networks
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
//
// ORIGINAL DATE: 8/7/97
//
// NOTES:
// 1.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include <afxwin.h>
#include <afxtempl.h>

#include "apgts.h"
#include "bnts.h"
#include "cachegen.h"

#include "BackupInfo.h"
#include "apgtsinf.h"
#include "ChmRead.h"


int nodecomp(const void *elem1, const void *elem2);

//
//
GTSCacheGenerator::GTSCacheGenerator(BOOL bScanAll, const char *szLogFile, const char *szBNTSLogFile)
{
	m_fp = NULL;
	m_bScanAll = bScanAll;
	m_szBNTSLogFile = szBNTSLogFile;
	if (szLogFile != NULL)
		m_fp = fopen(szLogFile, "w");
	m_nCount = 0;
	m_nItemCount = 0;
	m_headposition = 0;
	m_filedata = NULL;
	m_netstartoffset = 0;
	m_nodeorder = NULL;
}

//
//
GTSCacheGenerator::~GTSCacheGenerator()
{
	if (m_fp)
		fclose(m_fp);
	if (m_filedata)
		free(m_filedata);
	if (m_nodeorder)
		free(m_nodeorder);

}

bool GTSCacheGenerator::TcharToChar(char szOut[], LPCTSTR szIn, int &OutLen)
{
	int x = 0;
	while(NULL != szIn[x] && x < OutLen)
	{
		szOut[x] = (char) szIn[x];
		x++;
	}
	if (x < OutLen)
		szOut[x] = NULL;
	return x < OutLen;
}
//
//
/*
void GTSCacheGenerator::LogOut(TCHAR *szcFormat, ...)
{
	va_list ptr;
	
	if (!m_fp)
		return;

	if (!szcFormat)
		return;

	va_start(ptr, szcFormat);
	vfprintf(m_fp, szcFormat, ptr);
	va_end(ptr);
}
*/

#ifdef _DEBUG
#define LogOut ::AfxTrace
//#define LogOut 1 ? (void)0 : ::AfxTrace
#else
#define LogOut 1 ? (void)0 : ::AfxTrace
#endif

//
//
int nodecomp(const void *elem1, const void *elem2)
{
	return (((GTS_NODE_ORDER *)elem1)->depth - ((GTS_NODE_ORDER *)elem2)->depth);
}

//
//
void GTSCacheGenerator::SaveNetItem(CPtrList *nsp, BNTS *bp, FILE *fp, LPCSTR name)
{
	GTS_NODE_ITEM *ni;

	if (!bp->BNetPropItemStr( name, 0 ))
		return;

	ni = new GTS_NODE_ITEM(name);

	int j = 0;
	while (bp->BNetPropItemStr( name, j++ ))
	{
		CString sTemp = bp->SzcResult();
		ni->sStringArr.Add(sTemp);
	}
	
	nsp->AddTail(ni);
}

//
//
BOOL GTSCacheGenerator::NodeTraverse(	FILE *fp,
										BNTS *bp,
										int depth,
										CArray<int,int> &newnodes,
										CArray<int,int> &newstates,
										int currnode,
										int currstate)
{
	BOOL bEnd = FALSE;
	int i, j;

	if (depth > 30)
	{
		LogOut(_T("Depth Exceeded\n"));
		return FALSE;
	}

	// uninstantiate
	UninstantiateAll(bp);

	newnodes.Add(currnode);
	newstates.Add(currstate);
	
	depth++;

	for (i=0;i<newnodes.GetSize();i++)
	{
		if (bp->BNodeSetCurrent(newnodes[i]))
		{
			bp->NodeSymName();

			CString sTemp = bp->SzcResult();

			LogOut(_T("%s"), sTemp);

			ESTDLBL albl = bp->ELblNode();

			if (albl == ESTDLBL_problem)
			{
				LogOut(_T("(prob)"));
			}
			else if (albl == ESTDLBL_info)
			{
				LogOut(_T("(info)"));
			}
			else if (albl == ESTDLBL_fixobs ||
					albl == ESTDLBL_fixunobs ||
					albl == ESTDLBL_unfix)
			{
				LogOut(_T("(fix)"));
			}
			else
			{
				LogOut(_T("(?)"));
			}
		}

		LogOut(_T("(%d=%d) "), newnodes[i], newstates[i]);
	}

	SetNodes( bp, newnodes, newstates );

	BOOL bRec = FALSE;

	if (!bp->BGetRecommendations())
	{
		bRec = TRUE;
	}
	else
	{
	}

	const int *rg = bp->RgInt();

	i = 0;

	if (bRec)
	{
		if (bp->BImpossible())
		{
			LogOut(_T("IMPOSSIBLE\n"));
		}
		else
		{
			LogOut(_T("RECOMMENDATION ERROR\n"));
		}
	}
	else
	{
		if (bp->BImpossible())
		{
			LogOut(_T("IMPOSSIBLE (Have Rec)\n"));
		}
		else
		{
			int reccount = bp->CInt();

			if (reccount)
			{
				int nodecount = (int)newstates.GetSize();

				if (nodecount)
				{
					
					BOOL bFound = FALSE;

					for (i=0;i<reccount;i++)
					{
						bFound = FALSE;

						for (j=0;j<nodecount;j++)
						{
							if (newnodes[j] == rg[i])
							{
								bFound = TRUE;
								break;
							}
						}

						if (!bFound)
							break;
					}
					
					if (!bFound)
					{
						LogOut(_T("RECOMMENDATION: "));

						if (bp->BNodeSetCurrent(rg[i]))
						{
							CString sTemp1 = "Error";
							CString sTemp2 = "Error";
							
							if (bp->BNodePropItemStr( "HNodeHd", 0 ))
								sTemp1 = bp->SzcResult();

							bp->NodeSymName();
							
							sTemp2 = bp->SzcResult();
							
							LogOut(_T("%s (%s) (Node: %d)"), sTemp1, sTemp2, rg[i]);

							if (m_nodeorder)
							{
								if (m_nodeorder[rg[i]].depth > depth)
									m_nodeorder[rg[i]].depth = depth;
							}

							UINT realcount = 0;
							for (j=0;j<nodecount;j++)
								if (newstates[j] != STATE_UNKNOWN)
									realcount++;

							fwrite(&realcount, sizeof (UINT), 1, fp);

							for (j=0;j<nodecount;j++)
								if (newstates[j] != STATE_UNKNOWN)
								{
									GTS_CACHE_NODE cnode;
									cnode.node = newnodes[j];
									cnode.state = newstates[j];

									fwrit