  if(!m_bInit)
    {
        return FALSE;
    }

    return (NULL!=CreateIoCompletionPort(
                       (HANDLE)(pIoContext->m_hAsyncIO),
                       m_hIOCompPort,
                       (ULONG_PTR)pIoContext,
                       m_dwTdCount));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\uuencode.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		uuencode.h
//
//	Abstract:
//		Declarations.
//
//	Implementation File:
//		uuencode.cpp
//
//	Author:
//		
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __uuencode_h
#define __uuencode_h

/////////////////////////////////////////////////////////////////////////////
typedef struct _BUFFER {
    PBYTE pBuf;
    DWORD cLen;
} BUFFER ;


BOOL
uuencode(
    BYTE *   bufin,
    DWORD    nbytes,
    BUFFER * pbuffEncoded );


BOOL
uudecode(
    char   * bufcoded,
    BUFFER * pbuffdecoded,
    DWORD  * pcbDecoded );

PBYTE BufferQueryPtr( BUFFER * pB );

BOOL BufferResize( BUFFER *pB, DWORD cNewL );

#endif // __uuencode_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\oc\pop3regkeysutil.h ===
// Pop3RegKeysUtil.h: interface for the CPop3RegKeysUtil class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_Pop3RegKeysUTIL_H__DA56425C_95C0_478B_A193_34C4758AAD23__INCLUDED_)
#define AFX_Pop3RegKeysUTIL_H__DA56425C_95C0_478B_A193_34C4758AAD23__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPop3RegKeysUtil
{
public:
    CPop3RegKeysUtil();
    virtual ~CPop3RegKeysUtil();

// Implementation
public:
    HRESULT Save();
    HRESULT Restore();
        
// Attributes
protected:
    DWORD m_dwAuthType;
    DWORD m_dwCreateUser;
    DWORD m_dwPort;
    DWORD m_dwLoggingLevel;
    DWORD m_dwSocketBacklog;
    DWORD m_dwSocketMin;
    DWORD m_dwSocketMax;
    DWORD m_dwSocketThreshold;
    DWORD m_dwSPARequired;
    DWORD m_dwThreadcount;
    TCHAR m_sAuthGuid[MAX_PATH];
    TCHAR m_sGreeting[MAX_PATH];
    TCHAR m_sMailRoot[MAX_PATH];
    
    
};

#endif // !defined(AFX_Pop3RegKeysUTIL_H__DA56425C_95C0_478B_A193_34C4758AAD23__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\uuencode.cpp ===
/************************************************************
 *    uuencode/decode functions
 ************************************************************/

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//
#include "stdafx.h"
#include "uuencode.h"


// general purpose dynamic buffer structure
const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};


PBYTE BufferQueryPtr( BUFFER * pB )
{
    if(pB)
    {
        return pB->pBuf;
    }
    else
    {
        return NULL;
    }
}


BOOL CheckBufferSize( BUFFER *pB, DWORD cNewL )
{
    PBYTE pN;
    if (!pB)
    {
        return FALSE;
    }
    if ( cNewL > pB->cLen )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
uudecode(
    char   * bufcoded,
    BUFFER * pbuffdecoded,
    DWORD  * pcbDecoded )
/*++

 Routine Description:

    uudecode a string of data

 Arguments:

    bufcoded            pointer to uuencoded data
    pbuffdecoded        pointer to output BUFFER structure
    pcbDecoded          number of decode bytes

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout;
    int nprbytes;

    if(NULL == bufcoded ||
       NULL == pbuffdecoded ||
       NULL == pcbDecoded)
    {
        return FALSE;
    }
    
    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    
	while(pr2six[*(bufin++)] <= 63);

    nprbytes = bufin - bufcoded - 1;
    
	nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( !CheckBufferSize( pbuffdecoded, nbytesdecoded + 4 ))
        return FALSE;


    bufout = (unsigned char *) BufferQueryPtr(pbuffdecoded);
    
    if( NULL == bufout )
        return FALSE;

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    ((CHAR *)BufferQueryPtr(pbuffdecoded))[nbytesdecoded] = '\0';

    return TRUE;
}


BOOL
uuencode(
    BYTE *   bufin,
    DWORD    nbytes,
    BUFFER * pbuffEncoded )
/*++

 Routine Description:

    uuencode a string of data

  NOTE: bufin must be either a multiple of three, or be padded at the end to a multiple of three!

 Arguments:

    bufin           pointer to data to encode
    nbytes          number of bytes to encode
    pbuffEncoded    pointer to output BUFFER structure

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
   unsigned char *outptr;
   unsigned int i;

   if(NULL == bufin ||
      NULL == pbuffEncoded)
   {
       return FALSE;
   }

   //
   //  Check size the buffer to 133% of the incoming data
   //

   if ( !CheckBufferSize( pbuffEncoded, nbytes + ((nbytes + 3) / 3) + 4))
        return FALSE;

   outptr = (unsigned char *) BufferQueryPtr(pbuffEncoded);
   if( NULL == outptr )
        return FALSE;
 

   for (i = 0; i < nbytes; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   /* If nbytes was not a multiple of 3, then we have encoded too
    * many characters.  Adjust appropriately.
    */
   if(i == nbytes+1) {
      /* There were only 2 bytes in that last group */
      outptr[-1] = '=';
   } else if(i == nbytes+2) {
      /* There was only 1 byte in that last group */
      outptr[-1] = '=';
      outptr[-2] = '=';
   }

   *outptr = '\0';

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\oc\pop3regkeysutil.cpp ===
// Pop3RegKeysUtil.cpp: implementation of the CPop3RegKeysUtil class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include "Pop3RegKeysUtil.h"
#include <pop3regkeys.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPop3RegKeysUtil::CPop3RegKeysUtil() :    
    m_dwAuthType(-1), m_dwCreateUser(-1), m_dwPort(-1), m_dwLoggingLevel(-1), m_dwSocketBacklog(-1), m_dwSocketMin(-1), m_dwSocketMax(-1), m_dwSocketThreshold(-1), m_dwSPARequired(-1), m_dwThreadcount(-1)
{
    ZeroMemory( m_sAuthGuid, sizeof(m_sAuthGuid)/sizeof(TCHAR) );
    ZeroMemory( m_sGreeting, sizeof(m_sGreeting)/sizeof(TCHAR) );
    ZeroMemory( m_sMailRoot, sizeof(m_sMailRoot)/sizeof(TCHAR) );
}

CPop3RegKeysUtil::~CPop3RegKeysUtil()
{
}

//////////////////////////////////////////////////////////////////////
// Implementation: public
//////////////////////////////////////////////////////////////////////

long CPop3RegKeysUtil::Restore()
{
    long l, lRC = ERROR_SUCCESS;

    if ( -1 != m_dwAuthType )
    {
        l = RegSetAuthMethod( m_dwAuthType );                         
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( -1 != m_dwCreateUser )
    {
        l = RegSetCreateUser( m_dwCreateUser );                         
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( -1 != m_dwPort )
    {
        l = RegSetPort( m_dwPort );                         
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( -1 != m_dwLoggingLevel )
    {
        l = RegSetLoggingLevel( m_dwLoggingLevel );         
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( -1 != m_dwSocketBacklog )
    {
        l = RegSetSocketBacklog( m_dwSocketBacklog );       
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( -1 != m_dwSocketMin )
    {
        l = RegSetSocketMin( m_dwSocketMin );               
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( -1 != m_dwSocketMax )
    {
        l = RegSetSocketMax( m_dwSocketMax );               
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( -1 != m_dwSocketThreshold )
    {
        l = RegSetSocketThreshold( m_dwSocketThreshold );   
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( -1 != m_dwSPARequired )
    {
        l = RegSetSPARequired( m_dwSPARequired );           
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( -1 != m_dwThreadcount )
    {
        l = RegSetThreadCount( m_dwThreadcount );           
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( 0 < _tcslen( m_sAuthGuid ))
    {
        l = RegSetAuthGuid( m_sAuthGuid );                  
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( 0 < _tcslen( m_sGreeting ))
    {
        l = RegSetGreeting( m_sGreeting );                  
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }
    if ( 0 < _tcslen( m_sMailRoot ))
    {
        l = RegSetMailRoot( m_sMailRoot );                  
        if ( ERROR_SUCCESS == lRC ) lRC = l;
    }

    return lRC;
}

long CPop3RegKeysUtil::Save()
{
    long l, lRC = ERROR_SUCCESS;

    l = RegQueryAuthMethod( m_dwAuthType );             if ( ERROR_SUCCESS == lRC ) lRC = l;
    l = RegQueryCreateUser( m_dwCreateUser );           if ( ERROR_SUCCESS == lRC ) lRC = l;
    l = RegQueryPort( m_dwPort );                       if ( ERROR_SUCCESS == lRC ) lRC = l;
    l = RegQueryLoggingLevel( m_dwLoggingLevel );       if ( ERROR_SUCCESS == lRC ) lRC = l;
    l = RegQuerySocketBacklog( m_dwSocketBacklog );     if ( ERROR_SUCCESS == lRC ) lRC = l;
    l = RegQuerySocketMin( m_dwSocketMin );             if ( ERROR_SUCCESS == lRC ) lRC = l;
    l = RegQuerySocketMax( m_dwSocketMax );             if ( ERROR_SUCCESS == lRC ) lRC = l;
    l = RegQuerySocketThreshold( m_dwSocketThreshold ); if ( ERROR_SUCCESS == lRC ) lRC = l;
    l = RegQuerySPARequired( m_dwSPARequired );         if ( ERROR_SUCCESS == lRC ) lRC = l;
    l = RegQueryThreadCountPerCPU( m_dwThreadcount );   if ( ERROR_SUCCESS == lRC ) lRC = l;
    DWORD dwSize = sizeof(m_sAuthGuid)/sizeof(TCHAR);
    l = RegQueryAuthGuid( m_sAuthGuid, &dwSize ); if ( ERROR_SUCCESS == lRC ) lRC = l;
    l = RegQueryGreeting( m_sGreeting, sizeof(m_sGreeting)/sizeof(TCHAR) ); if ( ERROR_SUCCESS == lRC ) lRC = l;
    l = RegQueryMailRoot( m_sMailRoot, sizeof(m_sMailRoot)/sizeof(TCHAR) ); if ( ERROR_SUCCESS == lRC ) lRC = l;

    return lRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\oc\pop3oc.h ===
/*
 *  Copyright (c) 2001  Microsoft Corporation
 *
 *  Module Name:
 *
 *      POP3oc.h
 *
 *  Abstract:
 *
 *      This file defines oc manager generic component
 *
 *  Author:
 *
 *      Paolo Raden (paolora) Nov-20-2001
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _POP3OC_H_
 #error "pop3oc.h already included!"
#else
 #define _OCGEN_H_
#endif

#ifndef _WINDOWS_H_
 #include <windows.h>
#endif

#ifndef _TCHAR_H_
 #include <tchar.h>
#endif

#ifndef _SETUPAPI_H_
 #include <setupapi.h>
#endif

#ifndef _OCMANAGE_H_
 #include "ocmanage.h"
#endif

#ifndef _PRSHT_H_
 #include <prsht.h>
#endif

#ifndef _RESOURCE_H_
 #include "resource.h"
#endif

/*-[ types and defines ]-----------------------------------*/

// unicode version is for NT only.

#ifdef UNICODE
 #define NT
#endif
#ifdef ANSI
 #define WIN95
#endif

// just my preference

#define true    TRUE
#define false   FALSE

// to help root out hard coded strings that don't belong

#define FMT     TEXT

#define NullString(a)   *(a) = TCHAR('\0')

// standard buffer sizes

#define S_SIZE           1024
#define SBUF_SIZE        (S_SIZE * sizeof(TCHAR))

// per component data

typedef struct _PER_COMPONENT_DATA {
    struct _PER_COMPONENT_DATA *Next;
    LPCTSTR ComponentId;
    HINF hinf;
    DWORDLONG Flags;
    LANGID LanguageId;
    TCHAR *SourcePath;
    OCMANAGER_ROUTINES HelperRoutines;
    EXTRA_ROUTINES ExtraRoutines;
    HSPFILEQ queue;
    LONG UnattendedOverride;
} PER_COMPONENT_DATA, *PPER_COMPONENT_DATA;

/*-[ functions ]-------------------------------------------*/

// just for utility

#ifdef UNICODE
 #define tsscanf swscanf
 #define tvsprintf vswprintf
#else
 #define tsscanf sscanf
 #define tvsprintf vsprintf
#endif

// from util.cpp

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... );
DWORD MsgBox(HWND hwnd, LPCTSTR fmt, LPCTSTR caption, UINT type, ... );
DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... );
DWORD TMBox(LPCTSTR fmt, ... );
#define mbox MBox
#define tmbox TMBox
void logOCNotification(DWORD msg, const TCHAR *component);
void logOCNotificationCompletion();
void loginit();
void log(TCHAR *fmt, ...);
void AssureTrailingBackslash(TCHAR *path);
BOOL IsNT();

#if defined(__cplusplus)
  extern "C" {
#endif

// from pop3oc.cpp

BOOL  ToBeInstalled(TCHAR *component);
BOOL  WasInstalled(TCHAR *component);
DWORD SetupCurrentUser();
DWORD GetMyVersion(DWORD *major, DWORD *minor);
VOID  ReplaceExplorerStartMenuBitmap(VOID);
DWORD OcLog(LPCTSTR ComponentId, UINT level, LPCTSTR sz);

DWORD SysGetDebugLevel();

// from util.cpp

void DebugTraceNL(DWORD level, const TCHAR *text);
void DebugTrace(DWORD level, const TCHAR *text);
void DebugTraceOCNotification(DWORD msg, const TCHAR *component);
void DebugTraceFileCopy(const TCHAR *file);
void DebugTraceFileCopyError();
void DebugTraceDirCopy(const TCHAR *dir);

#if defined(__cplusplus)
  }
#endif

/*-[ global data ]-----------------------------------------*/

#ifndef _POP3OC_CPP_
#define EXTERN extern
#else
 #define EXTERN
#endif

// general stuff

EXTERN HINSTANCE  ghinst;  // app instance handle
EXTERN HWND       ghwnd;   // wizard window handle

// per-component info storage

EXTERN PPER_COMPONENT_DATA gcd;     // array of all components we are installing
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\oc\pop3oc.cpp ===
/*
 *  Copyright (c) 2001  Microsoft Corporation
 *
 *  Module Name:
 *
 *      POP3oc.cpp
 *
 *  Abstract:
 *
 *      This file handles all messages passed by the OC Manager
 *
 *  Author:
 *
 *      Paolo Raden (paolora) Nov-20-2001
 *
 *  Environment:
 *
 *    User Mode
 */

#define _POP3OC_CPP_
#include <windows.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <shlobj.h>
#include <objbase.h>
#include <shlwapi.h>
#include <lm.h>
#include <objidl.h>
#include <psapi.h>
#include "pop3oc.h"
#include "ServiceUtil.h"
#include "Pop3RegKeysUtil.h"
#include <isexchng.h>
#include <p3admin.h>
#include <Pop3Server.h>
#define _ASSERT(x) {}
#include <ServUtil.h>

#include <smtpinet.h>
#pragma hdrstop


// also referred to in pop3oc.h        // forward reference

DWORD OnPreinitialize();
DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc);
DWORD OnSetLanguage();
DWORD_PTR OnQueryImage();
DWORD OnSetupRequestPages(UINT type, PVOID srp);
DWORD OnQuerySelStateChange(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state, UINT flags);
DWORD OnCalcDiskSpace(LPCTSTR ComponentId, LPCTSTR SubcomponentId, DWORD addComponent, HDSKSPC dspace);
DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue);
DWORD OnNotificationFromQueue();
DWORD OnQueryStepCount();
DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnCleanup();
DWORD OnQueryState(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state);
DWORD OnNeedMedia();
DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnQuerySkipPage();
DWORD OnWizardCreated();
DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per);

PPER_COMPONENT_DATA AddNewComponent(LPCTSTR ComponentId);
PPER_COMPONENT_DATA LocateComponent(LPCTSTR ComponentId);
VOID  RemoveComponent(LPCTSTR ComponentId);
BOOL  StateInfo(PPER_COMPONENT_DATA cd, LPCTSTR SubcomponentId, BOOL *state);
DWORD RegisterServers(HINF hinf, LPCTSTR component, DWORD state);
DWORD EnumSections(HINF hinf, const TCHAR *component, const TCHAR *key, DWORD index, INFCONTEXT *pic, TCHAR *name);
DWORD RegisterServices(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD CleanupNetShares(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD RunExternalProgram(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
HRESULT CreateLink( const TCHAR *sourcePath, const TCHAR *linkPath, const TCHAR *args, const TCHAR *sDesc );

// POP 3 custom
DWORD KillPop3Snapins();

// for registering dlls

typedef HRESULT (__stdcall *pfn)(void);

#define KEYWORD_REGSVR       TEXT("RegSvr")
#define KEYWORD_UNREGSVR     TEXT("UnregSvr")
#define KEYWORD_UNINSTALL    TEXT("Uninstall")
#define KEYWORD_SOURCEPATH   TEXT("SourcePath")
#define KEYWORD_DELSHARE     TEXT("DelShare")
#define KEYWORD_ADDSERVICE   TEXT("AddService")
#define KEYWORD_DELSERVICE   TEXT("DelService")
#define KEYWORD_SHARENAME    TEXT("Share")
#define KEYWORD_RUN          TEXT("Run")
#define KEYVAL_SYSTEMSRC     TEXT("SystemSrc")
#define KEYWORD_COMMANDLINE  TEXT("CommandLine")
#define KEYWORD_TICKCOUNT    TEXT("TickCount")

// Services keywords/options
#define KEYWORD_SERVICENAME  TEXT("ServiceName")
#define KEYWORD_DISPLAYNAME  TEXT("DisplayName")
#define KEYWORD_SERVICETYPE  TEXT("ServiceType")
#define KEYWORD_STARTTYPE    TEXT("StartType")
#define KEYWORD_ERRORCONTROL TEXT("ErrorControl")
#define KEYWORD_IMAGEPATH    TEXT("BinaryPathName")
#define KEYWORD_LOADORDER    TEXT("LoadOrderGroup")
#define KEYWORD_DEPENDENCIES TEXT("Dependencies")
#define KEYWORD_STARTNAME    TEXT("ServiceStartName")
#define KEYWORD_PASSWORD     TEXT("Password")

#define KEYVAL_ON            TEXT("on")
#define KEYVAL_OFF           TEXT("off")
#define KEYVAL_DEFAULT       TEXT("default")

const char gszRegisterSvrRoutine[]   = "DllRegisterServer";
const char gszUnregisterSvrRoutine[] = "DllUnregisterServer";
BOOL g_fRebootNeed = FALSE;
BOOL g_fExchange = FALSE;
CServiceUtil *g_pServiceUtil = NULL;
CServiceUtil *g_pServiceUtilWMI = NULL;
CPop3RegKeysUtil *g_pPopRegKeys = NULL;

PPER_COMPONENT_DATA _cd=NULL;


/*
 * called by CRT when _DllMainCRTStartup is the DLL entry point
 */

BOOL
WINAPI
DllMain(
    IN HINSTANCE hinstance,
    IN DWORD     reason,
    IN LPVOID    reserved
    )
{
    BOOL b;

    UNREFERENCED_PARAMETER(reserved);

    b = true;

    switch(reason)
    {
    case DLL_PROCESS_ATTACH:
        ghinst = hinstance;
        loginit();

        // Fall through to process first thread

    case DLL_THREAD_ATTACH:
        b = true;
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return(b);
}


DWORD_PTR
OcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD_PTR rc;

    DebugTraceOCNotification(Function, ComponentId);
    logOCNotification(Function, ComponentId);

    switch(Function)
    {
    case OC_PREINITIALIZE:
        rc = OnPreinitialize();
        break;

    case OC_INIT_COMPONENT:
        rc = OnInitComponent(ComponentId, (PSETUP_INIT_COMPONENT)Param2);
        break;

    case OC_EXTRA_ROUTINES:
        rc = OnExtraRoutines(ComponentId, (PEXTRA_ROUTINES)Param2);
        break;

    case OC_SET_LANGUAGE:
        rc = OnSetLanguage();
        break;

    case OC_QUERY_IMAGE:
        rc = OnQueryImage();
        break;

    case OC_REQUEST_PAGES:
        rc = OnSetupRequestPages(Param1, Param2);
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        rc = OnQuerySelStateChange(ComponentId, SubcomponentId, Param1, (UINT)((UINT_PTR)Param2));
        break;

    case OC_CALC_DISK_SPACE:
        rc = OnCalcDiskSpace(ComponentId, SubcomponentId, Param1, Param2);
        break;

    case OC_QUEUE_FILE_OPS:
        rc = OnQueueFileOps(ComponentId, SubcomponentId, (HSPFILEQ)Param2);
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        rc = OnNotificationFromQueue();
        break;

    case OC_QUERY_STEP_COUNT:
        rc = OnQueryStepCount();
        break;

    case OC_COMPLETE_INSTALLATION:
        rc = OnCompleteInstallation(ComponentId, SubcomponentId);
        break;

    case OC_CLEANUP:
        rc = OnCleanup();
        break;

    case OC_QUERY_STATE:
        rc = OnQueryState(ComponentId, SubcomponentId, Param1);
        break;

    case OC_NEED_MEDIA:
        rc = OnNeedMedia();
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        rc = OnAboutToCommitQueue(ComponentId,SubcomponentId);
        break;

    case OC_QUERY_SKIP_PAGE:
        rc = OnQuerySkipPage();
        break;

    case OC_WIZARD_CREATED:
        rc = OnWizardCreated();
        break;

    default:
        rc = NO_ERROR;
        break;
    }

    DebugTrace(1, TEXT("processing completed"));
    logOCNotificationCompletion();

    return rc;
}

/*-------------------------------------------------------*/
/*
 * OC Manager message handlers
 *
 *-------------------------------------------------------*/


/* OnPreinitialize()
 *
 * handler for OC_PREINITIALIZE
 */

DWORD
OnPreinitialize(
    VOID
    )
{
#ifdef ANSI
    return OCFLAG_ANSI;
#else
    return OCFLAG_UNICODE;
#endif
}

/*
 * OnInitComponent()
 *
 * handler for OC_INIT_COMPONENT
 */

DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc)
{
    PPER_COMPONENT_DATA cd;
    INFCONTEXT context;
    TCHAR buf[256];
    HINF hinf;
    BOOL rc;

	// We should only uninstall if exchange is on the box
	g_fExchange = _IsExchangeInstalled();

    // add component to linked list
    if (!(cd = AddNewComponent(ComponentId)))
        return ERROR_NOT_ENOUGH_MEMORY;

    // store component inf handle
    cd->hinf = (psc->ComponentInfHandle == INVALID_HANDLE_VALUE)
                                           ? NULL
                                           : psc->ComponentInfHandle;

    // open the inf
    if (cd->hinf)
        SetupOpenAppendInfFile(NULL, cd->hinf,NULL);

    // copy helper routines and flags
    cd->HelperRoutines = psc->HelperRoutines;
    cd->Flags = psc->SetupData.OperationFlags;
    cd->SourcePath = NULL;


    // play
    srand(GetTickCount());

    return NO_ERROR;
}

/*
 * OnExtraRoutines()
 *
 * handler for OC_EXTRA_ROUTINES
 */

DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per)
{
    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    memcpy(&cd->ExtraRoutines, per, per->size);

    return NO_ERROR;
}

/*
 * OnSetLanguage()
 *
 * handler for OC_SET_LANGUAGE
 */

DWORD OnSetLanguage()
{
    return false;
}

/*
 * OnSetLanguage()
 *
 * handler for OC_SET_LANGUAGE
 */

DWORD_PTR OnQueryImage()
{
    return (DWORD_PTR)LoadBitmap(NULL,MAKEINTRESOURCE(32754));     // OBM_CLOSE
}

/*
 * OnSetupRequestPages
 *
 * Prepares wizard pages and returns them to the OC Manager
 */

DWORD OnSetupRequestPages(UINT type, PVOID srp)
{
    return 0;
}

/*
 * OnWizardCreated()
 */

DWORD OnWizardCreated()
{
    return NO_ERROR;
}

/*
 * OnQuerySkipPage()
 *
 * don't let the user deselect the sam component
 */

DWORD OnQuerySkipPage()
{
    return false;
}

/*
 * OnQuerySelStateChange()
 *
 * don't let the user deselect the sam component
 */

DWORD OnQuerySelStateChange(LPCTSTR ComponentId,
                            LPCTSTR SubcomponentId,
                            UINT    state,
                            UINT    flags)
{
	if (g_fExchange && (flags & OCQ_ACTUAL_SELECTION) && state)
	{
		log( TEXT("POP3OC: user tried to install %s while exchange is installed.  Not supported."), SubcomponentId);
        MsgBox(NULL, IDS_ERR_EXCHANGE_INSTALLED, MB_OK);
		return FALSE;
	}
	
	return TRUE;
}

/*
 * OnCalcDiskSpace()
 *
 * handler for OC_ON_CALC_DISK_SPACE
 */

DWORD OnCalcDiskSpace(LPCTSTR ComponentId,
                      LPCTSTR SubcomponentId,
                      DWORD addComponent,
                      HDSKSPC dspace)
{
    DWORD rc = NO_ERROR;
    TCHAR section[S_SIZE];
    PPER_COMPONENT_DATA cd;

    //
    // Param1 = 0 if for removing component or non-0 if for adding component
    // Param2 = HDSKSPC to operate on
    //
    // Return value is Win32 error code indicating outcome.
    //
    // In our case the private section for this component/subcomponent pair
    // is a simple standard inf install section, so we can use the high-level
    // disk space list api to do what we want.
    //

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    _tcscpy(section, SubcomponentId);

    if (addComponent)
    {
        rc = SetupAddInstallSectionToDiskSpaceList(dspace,
                                                   cd->hinf,
                                                   NULL,
                                                   section,
                                                   0,
                                                   0);
    }
    else
    {
        rc = SetupRemoveInstallSectionFromDiskSpaceList(dspace,
                                                        cd->hinf,
                                                        NULL,
                                                        section,
                                                        0,
                                                        0);
    }

    if (!rc)
        rc = GetLastError();
    else
        rc = NO_ERROR;

    return rc;
}

/*
 * OnQueueFileOps()
 *
 * handler for OC_QUEUE_FILE_OPS
 */

DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue)
{
    PPER_COMPONENT_DATA cd;
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    cd->queue = queue;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    wsprintf(section, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(cd->hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }

        // POP3 Server Custom code goes here
        if (!_wcsicmp( SubcomponentId, L"Pop3Service"))
        {
            // Winpop Init 0
            TCHAR szSource[MAX_PATH+1];
            if (0 != GetSystemDirectory( szSource, MAX_PATH+1 ))
            {
                TCHAR szAppName[MAX_PATH+30];
                TCHAR szCommandLine[MAX_PATH+50];                
                _tcscpy( szAppName, szSource );
                _tcscat( szAppName, _T("\\winpop.exe") );
                _tcscpy( szCommandLine, szAppName );
                _tcscat( szCommandLine, _T(" INIT 0") );

                STARTUPINFO si;
                PROCESS_INFORMATION pi;
                ZeroMemory( &si, sizeof(si) );
                ZeroMemory( &pi, sizeof(pi) );

                DWORD dwRet;
                if (CreateProcess( szAppName, szCommandLine, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi ))
                do
                {
                    dwRet = MsgWaitForMultipleObjects( 1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT );

                    if( dwRet == WAIT_OBJECT_0 + 1 )
                    {
                        MSG msg;
                        while( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
                        {
                            TranslateMessage( &msg );
                            DispatchMessage( &msg );
                        }
                    }
                }
                while( dwRet != WAIT_OBJECT_0 && dwRet != WAIT_FAILED );

                CloseHandle( pi.hProcess );
                CloseHandle( pi.hThread );
            }
        }
        
        // Kill all Pop3 snapins
        KillPop3Snapins();
        // also, unregister the dlls and kill services before deletion

        SetupInstallServicesFromInfSection(cd->hinf, section, 0);
        SetupInstallFromInfSection(NULL,cd->hinf,section,SPINST_UNREGSVR,NULL,NULL,0,NULL,NULL,NULL,NULL);
    }

    if (rc) {
        // if uninstalling, don't use version checks
        rc = SetupInstallFilesFromInfSection(cd->hinf,
                                             NULL,
                                             queue,
                                             section,
                                             cd->SourcePath,
                                             state ? SP_COPY_NEWER : 0);
    }

    if (!rc)
        return GetLastError();

    return NO_ERROR;
}

/*
 * OnNotificationFromQueue()
 *
 * handler for OC_NOTIFICATION_FROM_QUEUE
 *
 * NOTE: although this notification is defined,
 * it is currently unimplemented in oc manager
 */

DWORD OnNotificationFromQueue()
{
    return NO_ERROR;
}

/*
 * OnQueryStepCount
 *
 * handler forOC_QUERY_STEP_COUNT
 */

DWORD OnQueryStepCount()
{
    return 2;
}

/*
 * OnCompleteInstallation
 *
 * handler for OC_COMPLETE_INSTALLATION
 */

DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    PPER_COMPONENT_DATA cd;
    INFCONTEXT          context;
    TCHAR               section[256];
    BOOL                state;
    BOOL                rc;
    DWORD               Error = NO_ERROR;

    // Do post-installation processing in the cleanup section.
    // This way we know all compoents queued for installation
    // have beein installed before we do our stuff.

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    wsprintf(section, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(cd->hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }
    }

    if (state) {
        //
        // installation
        //

        if (rc) {
            if ( NULL == g_pPopRegKeys )
            {
                g_pPopRegKeys = new CPop3RegKeysUtil();
                g_pPopRegKeys->Save();
            }
            // process the inf file
            rc = SetupInstallFromInfSection(NULL,                                // hwndOwner
                                            cd->hinf,                            // inf handle
                                            section,                             // name of component
                                            SPINST_ALL & ~SPINST_FILES,
                                            NULL,                                // relative key root
                                            NULL,                                // source root path
                                            0,                                   // copy flags
                                            NULL,                                // callback routine
                                            NULL,                                // callback routine context
                                            NULL,                                // device info set
                                            NULL);                               // device info struct

            if (rc) {
                rc = SetupInstallServicesFromInfSection(cd->hinf, section, 0);
                Error = GetLastError();

                if (!rc && Error == ERROR_SECTION_NOT_FOUND) {
                    rc = TRUE;
                    Error = NO_ERROR;
                }

                if (rc) {
                    if (Error == ERROR_SUCCESS_REBOOT_REQUIRED) {
                        cd->HelperRoutines.SetReboot(cd->HelperRoutines.OcManagerContext,TRUE);
                    }
                    Error = NO_ERROR;
                    rc = RunExternalProgram(cd, section, state);
                }
            }
        }

    } else {

        //
        // uninstallation
        //

        if (rc)
        {

            rc = RunExternalProgram(cd, section, state);

        }
        if (rc) {

            rc = CleanupNetShares(cd, section, state);

        }
    }

    HRESULT hr = CoInitialize( NULL );
    // POP3 Server Custom code goes here
    if (!_wcsicmp( SubcomponentId, L"Pop3Service"))
    {
        // installing
        TCHAR szSnapinName[64];
        int iLen=LoadString(ghinst, IDS_SNAPIN_NAME, szSnapinName, sizeof(szSnapinName)/sizeof(TCHAR));
        if(0==iLen)
        {
            _tcscpy(szSnapinName, _T("POP3 Service"));
        }

        if (state)
        {
            // Tooltip
            TCHAR szTooltip[INFOTIPSIZE];
            ZeroMemory( szTooltip, sizeof(szTooltip)/sizeof(TCHAR) );
            LoadString(ghinst, IDS_SHORTCUT_TOOLTIP, szTooltip, sizeof(szTooltip)/sizeof(TCHAR) );
            
            // Create the shortcut
            TCHAR szDest[MAX_PATH+70];
            if (TRUE == SHGetSpecialFolderPath( 0, szDest, CSIDL_COMMON_ADMINTOOLS, FALSE ))
            {
                TCHAR szSource[MAX_PATH+1];
                if (0 != GetSystemDirectory( szSource, MAX_PATH+1 ))
                {
                    _tcscat( szSource, _T("\\p3server.msc") );
                    _tcscat( szDest, _T("\\") );
                    _tcscat( szDest, szSnapinName);
                    _tcscat( szDest, _T(".lnk") );
                    CreateLink( szSource, szDest, 0, szTooltip );
                }
            }

            // Winpop Init 1
            TCHAR szSource[MAX_PATH+1];
            if (0 != GetSystemDirectory( szSource, MAX_PATH+1 ))
            {
                TCHAR szAppName[MAX_PATH+30];
                TCHAR szCommandLine[MAX_PATH+50];
                _tcscpy( szAppName, szSource );
                _tcscat( szAppName, _T("\\winpop.exe") );
                _tcscpy( szCommandLine, szAppName );
                _tcscat( szCommandLine, _T(" INIT 1") );

                STARTUPINFO si;
                PROCESS_INFORMATION pi;
                ZeroMemory( &si, sizeof(si) );
                ZeroMemory( &pi, sizeof(pi) );

                DWORD dwRet;
                if (CreateProcess( szAppName, szCommandLine, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi ))
                do
                {
                    dwRet = MsgWaitForMultipleObjects( 1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT );

                    if( dwRet == WAIT_OBJECT_0 + 1 )
                    {
                        MSG msg;
                        while( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
                        {
                            TranslateMessage( &msg );
                            DispatchMessage( &msg );
                        }
                    }
                }
                while( dwRet != WAIT_OBJECT_0 && dwRet != WAIT_FAILED );

                CloseHandle( pi.hProcess );
                CloseHandle( pi.hThread );
            }

            // Add perf counters
            if (0 != GetSystemDirectory( szSource, MAX_PATH+1 ))
            {
                TCHAR szAppName[MAX_PATH+30];
                TCHAR szCommandLine[MAX_PATH*2+50];
                _tcscpy( szAppName, szSource );
                _tcscat( szAppName, _T("\\lodctr.exe") );
                _tcscpy( szCommandLine, szAppName );
                _tcscat( szCommandLine, _T(" ") );
                _tcscat( szCommandLine, szSource );
                _tcscat( szCommandLine, _T("\\POP3Server\\pop3perf.ini") );

                STARTUPINFO si;
                PROCESS_INFORMATION pi;
                ZeroMemory( &si, sizeof(si) );
                ZeroMemory( &pi, sizeof(pi) );

                DWORD dwRet;
                if (CreateProcess( szAppName, szCommandLine, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi ))
                do
                {
                    dwRet = MsgWaitForMultipleObjects( 1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT );

                    if( dwRet == WAIT_OBJECT_0 + 1 )
                    {
                        MSG msg;
                        while( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
                        {
                            TranslateMessage( &msg );
                            DispatchMessage( &msg );
                        }
                    }
                }
                while( dwRet != WAIT_OBJECT_0 && dwRet != WAIT_FAILED );

                CloseHandle( pi.hProcess );
                CloseHandle( pi.hThread );
            }
            
            // Restore the regkeys to their original state for uninstall
            if ( NULL != g_pPopRegKeys )
            {
                g_pPopRegKeys->Restore();
                g_pPopRegKeys = NULL;
            }
		}
		// removing
		else
		{
			// delete the shortcut
			TCHAR szPath[MAX_PATH+70];
			if (TRUE == SHGetSpecialFolderPath( 0, szPath, CSIDL_COMMON_ADMINTOOLS, FALSE ))
			{
                _tcscat( szPath, _T("\\") );
                _tcscat( szPath, szSnapinName);
                _tcscat( szPath, _T(".lnk") );
				DeleteFile( szPath );
			}

            TCHAR szSource[MAX_PATH+1];
            TCHAR szStoreDllName[MAX_PATH+30];
            // Remove perf counters
            if (0 != GetSystemDirectory( szSource, MAX_PATH+1 ))
            {
                TCHAR szAppName[MAX_PATH+30];
                TCHAR szCommandLine[MAX_PATH*2+50];
                _tcscpy( szAppName, szSource );
                _tcscat( szAppName, _T("\\unlodctr.exe") );
                _tcscpy( szCommandLine, szAppName );
                _tcscat( szCommandLine, _T(" pop3svc") );
                _tcscpy( szStoreDllName, szSource);
                _tcscat( szStoreDllName, _T("\\POP3Server\\P3Store.dll"));

                STARTUPINFO si;
                PROCESS_INFORMATION pi;
                ZeroMemory( &si, sizeof(si) );
                ZeroMemory( &pi, sizeof(pi) );

                DWORD dwRet;
                if (CreateProcess( szAppName, szCommandLine, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi ))
                do
                {
                    dwRet = MsgWaitForMultipleObjects( 1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT );

                    if( dwRet == WAIT_OBJECT_0 + 1 )
                    {
                        MSG msg;
                        while( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
                        {
                            TranslateMessage( &msg );
                            DispatchMessage( &msg );
                        }
                    }
                }
                while( dwRet != WAIT_OBJECT_0 && dwRet != WAIT_FAILED );

                CloseHandle( pi.hProcess );
                CloseHandle( pi.hThread );
            }
            //Before we restore the service, wait max of 30 seconds for p3store.dll to be deleted
            int iCountDown=15;
            while( ( INVALID_FILE_ATTRIBUTES != GetFileAttributes(szStoreDllName) ) && 
                   ( iCountDown >0 ) )
            {
                Sleep(2000);
                iCountDown--;
            }
                
            if ( NULL != g_pServiceUtil )
            {
                g_pServiceUtil->RestoreServiceState( IISADMIN_SERVICE_NAME );
                delete g_pServiceUtil;
                g_pServiceUtil = NULL;
            }
            if ( NULL != g_pServiceUtilWMI )
            {
                g_pServiceUtilWMI->RestoreServiceState( WMI_SERVICE_NAME );
                delete g_pServiceUtilWMI;
                g_pServiceUtilWMI = NULL;
            }
			// Remove Dirs for files
			if (0 != GetSystemDirectory( szPath, MAX_PATH+1 ))
			{
				_tcscat( szPath, _T("\\POP3Server") );
				RemoveDirectory( szPath );
			}
		}
	}
	// POP3 Admin
	else if (!_wcsicmp( SubcomponentId, L"Pop3Admin" ))
	{
        // installing
        if (state)
        {
        }
        // removing
        else
        {
            TCHAR szPath[MAX_PATH+1];
            if (0 != GetSystemDirectory( szPath, MAX_PATH+1 ))
            {
                _tcscat( szPath, _T("\\ServerAppliance\\Web\\Mail") );
                RemoveDirectory( szPath );
            }

        }
        // stop the elementmgr service
        if ( _IsServiceRunning( _T("elementmgr")))
        {
            hr = _StopService( _T("elementmgr"), FALSE );
            if ( S_OK != hr )
                log( _T("POP3OC:OnCompleteInstallation: Unable to stop elementmgr.\r\n") );
        }
	}
	
	CoUninitialize();
	
    if (!rc && (Error == NO_ERROR) ) {
        Error = GetLastError( );
    }

    return Error;
}

/*
 * OnCleanup()
 *
 * handler for OC_CLEANUP
 */

DWORD OnCleanup()
{
    return NO_ERROR;
}

/*
 * OnQueryState()
 *
 * handler for OC_QUERY_STATE
 */

DWORD OnQueryState(LPCTSTR ComponentId,
                   LPCTSTR SubcomponentId,
                   UINT    state)
{
    return SubcompUseOcManagerDefault;
}

/*
 * OnNeedMedia()
 *
 * handler for OC_NEED_MEDIA
 */

DWORD OnNeedMedia()
{
    return false;
}

/*
 * OnAboutToCommitQueue()
 *
 * handler for OC_ABOUT_TO_COMMIT_QUEUE
 */

DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    PPER_COMPONENT_DATA cd;
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    //
    // only do stuff on uninstall
    //
    if (state) {
        return NO_ERROR;
    }

    // Fetch uninstall section name.
    rc = SetupFindFirstLine(
                    cd->hinf,
                    SubcomponentId,
                    KEYWORD_UNINSTALL,
                    &context);

    if (rc) {
        rc = SetupGetStringField(
                     &context,
                     1,
                     section,
                     sizeof(section) / sizeof(TCHAR),
                     NULL);
    }

    // POP3 Server Custom code goes here
    if (rc)
    {
        if (!_wcsicmp( SubcomponentId, L"Pop3Service"))
        {   // Stop IISAdmin so that we can complete uninstall
            if ( NULL == g_pServiceUtil )
            {
                g_pServiceUtil = new CServiceUtil();
                if ( NULL != g_pServiceUtil )
                {
                    g_pServiceUtil->StopService( IISADMIN_SERVICE_NAME );
                }
            }
        }        
        // Stop WMI  so that we can complete uninstall
        if ( NULL == g_pServiceUtilWMI )
        {
            g_pServiceUtilWMI = new CServiceUtil();
            if ( NULL != g_pServiceUtilWMI )
            {
                g_pServiceUtilWMI->StopService( WMI_SERVICE_NAME );
            }
        }
    }
    // Move Migration stuff to Mailroot
    // We will not fail uninstall if something fails in this section
    HKEY    hKey;
    DWORD   dwType = REG_SZ, dwSize;
    UINT    uiRC;
    long    lRC;
    TCHAR   sCopyFrom[MAX_PATH+1], sCopyTo[MAX_PATH+1];

    // Get the mail root
    lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, POP3SERVER_SOFTWARE_SUBKEY, 0, KEY_QUERY_VALUE, &hKey );
    if ( ERROR_SUCCESS == lRC )
    {
        dwSize = sizeof( sCopyTo )/sizeof(TCHAR);
        lRC = RegQueryValueEx( hKey, VALUENAME_MAILROOT, 0, &dwType, reinterpret_cast<LPBYTE>( sCopyTo ), &dwSize );
        RegCloseKey( hKey );
    }
    // Get the current location
    if ( ERROR_SUCCESS == lRC )
    {
        dwSize = sizeof( sCopyFrom )/sizeof(TCHAR);
        uiRC = GetSystemDirectory( sCopyFrom, dwSize );
        if ( 0 != uiRC && dwSize > uiRC )
            lRC = ERROR_SUCCESS;
        else
            lRC = GetLastError();
    }
        
    if (rc)
        rc = SetupInstallServicesFromInfSection(cd->hinf, section, 0);

    if (rc) {
        rc = SetupInstallFromInfSection(
                    NULL,
                    cd->hinf,
                    section,
                    SPINST_ALL & ~SPINST_FILES,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
    }

    if (rc) {
       SetLastError(NO_ERROR);
    }
    return GetLastError();

}

/*
 * AddNewComponent()
 *
 * add new compononent to the top of the component list
 */

PPER_COMPONENT_DATA AddNewComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA data;

    data = (PPER_COMPONENT_DATA)LocalAlloc(LPTR,sizeof(PER_COMPONENT_DATA));
    if (!data)
        return data;

    data->ComponentId = (TCHAR *)LocalAlloc(LMEM_FIXED,
            (_tcslen(ComponentId) + 1) * sizeof(TCHAR));

    if(data->ComponentId)
    {
        _tcscpy((TCHAR *)data->ComponentId, ComponentId);

        // Stick at head of list
        data->Next = gcd;
        gcd = data;
    }
    else
    {
        LocalFree((HLOCAL)data);
        data = NULL;
    }

    return(data);
}

/*
 * LocateComponent()
 *
 * returns a compoent struct that matches the
 * passed component id.
 */

PPER_COMPONENT_DATA LocateComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA p;

    for (p = gcd; p; p=p->Next)
    {
        if (!_tcsicmp(p->ComponentId, ComponentId))
            return p;
    }

    return NULL;
}

/*
 * RemoveComponent()
 *
 * yanks a component from our linked list of components
 */

VOID RemoveComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA p, prev;

    for (prev = NULL, p = gcd; p; prev = p, p = p->Next)
    {
        if (!_tcsicmp(p->ComponentId, ComponentId))
        {
            LocalFree((HLOCAL)p->ComponentId);

            if (p->SourcePath)
                LocalFree((HLOCAL)p->SourcePath);

            if (prev)
                prev->Next = p->Next;
            else
                gcd = p->Next;

            LocalFree((HLOCAL)p);

            return;
        }
    }
}

// loads current selection state info into "state" and
// returns whether the selection state was changed

BOOL
StateInfo(
    PPER_COMPONENT_DATA cd,
    LPCTSTR             SubcomponentId,
    BOOL               *state
    )
{
    BOOL rc = TRUE;

    assert(state);

	// otherwise, check for a change in installation state
		
    *state = cd->HelperRoutines.QuerySelectionState(cd->HelperRoutines.OcManagerContext,
                                                    SubcomponentId,
                                                    OCSELSTATETYPE_CURRENT);

    if (*state == cd->HelperRoutines.QuerySelectionState(cd->HelperRoutines.OcManagerContext,
                                                         SubcomponentId,
                                                         OCSELSTATETYPE_ORIGINAL))
    {
        // no change
        rc = FALSE;
    }

	// if this is gui mode setup, presume the state has changed to force
	// an installation (or uninstallation)

	if (!(cd->Flags & SETUPOP_STANDALONE) && *state)
		rc = TRUE;

    return rc;
}

/*
 * EnumSections()
 *
 * finds the name of a section for a specified keyword
 */

DWORD
EnumSections(
    HINF hinf,
    const TCHAR *component,
    const TCHAR *key,
    DWORD index,
    INFCONTEXT *pic,
    TCHAR *name
    )
{
    TCHAR section[S_SIZE];

    if (!SetupFindFirstLine(hinf, component, NULL, pic))
        return 0;

    if (!SetupFindNextMatchLine(pic, key, pic))
        return 0;

    if (index > SetupGetFieldCount(pic))
        return 0;

    if (!SetupGetStringField(pic, index, section, sizeof(section)/sizeof(TCHAR), NULL))
        return 0;

    if (name)
        _tcscpy(name, section);

    return SetupFindFirstLine(hinf, section, NULL, pic);
}


DWORD
OcLog(
      LPCTSTR ComponentId,
      UINT level,
      LPCTSTR sz
      )
{
    TCHAR fmt[5000];
    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    assert(cd->ExtraRoutines.LogError);
    assert(level);
    assert(sz);

    _tcscpy(fmt, TEXT("%s: %s"));

    return cd->ExtraRoutines.LogError(cd->HelperRoutines.OcManagerContext,
                                      level,
                                      fmt,
                                      ComponentId,
                                      sz);
}

DWORD
CleanupNetShares(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    if (state) {
        return NO_ERROR;
    } else {
        keyword = KEYWORD_DELSHARE;
    }

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        NET_API_STATUS netStat;

        CHAR Temp[SBUF_SIZE];
        TCHAR ShareName[ SBUF_SIZE ];

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_SHARENAME, &sic))
        {
            log( TEXT("POP3OC: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, ShareName, SBUF_SIZE, NULL))
        {
            log( TEXT("POP3OC: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

#ifdef UNICODE
        netStat = NetShareDel( NULL, ShareName, 0 );
#else // UNICODE
        WCHAR ShareNameW[ SBUF_SIZE ];
        mbstowcs( ShareNameW, ShareName, lstrlen(ShareName));
        netStat = NetShareDel( NULL, ShareNameW, 0 );
#endif // UNICODE
        if ( netStat != NERR_Success )
        {
            log( TEXT("POP3OC: Failed to remove %s share. Error 0x%08x\r\n"), ShareName, netStat );
            continue;
        }

        log( TEXT("POP3OC: %s share removed successfully.\r\n"), ShareName );
    }

    return TRUE;
}

DWORD
RunExternalProgram(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    keyword = KEYWORD_RUN;

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        TCHAR CommandLine[ SBUF_SIZE ];
        CHAR szTickCount[ SBUF_SIZE ];
        ULONG TickCount;
        BOOL b;
        STARTUPINFO startupinfo;
        PROCESS_INFORMATION process_information;
        DWORD dwErr;

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_COMMANDLINE , &sic))
        {
            log( TEXT("POP3OC: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, CommandLine, SBUF_SIZE, NULL))
        {
            log( TEXT("POP3OC: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_TICKCOUNT, &sic))
        {
            log( TEXT("POP3OC: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        if (!SetupGetStringFieldA(&sic, 1, szTickCount, SBUF_SIZE, NULL))
        {
            log( TEXT("POP3OC: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        TickCount = atoi( szTickCount );

        ZeroMemory( &startupinfo, sizeof(startupinfo) );
        startupinfo.cb = sizeof(startupinfo);
        startupinfo.dwFlags = STARTF_USESHOWWINDOW;
        startupinfo.wShowWindow = SW_HIDE | SW_SHOWMINNOACTIVE;

        b = CreateProcess( NULL,
                           CommandLine,
                           NULL,
                           NULL,
                           FALSE,
                           CREATE_DEFAULT_ERROR_MODE,
                           NULL,
                           NULL,
                           &startupinfo,
                           &process_information );
        if ( !b )
        {
            log( TEXT("POP3OC: failed to spawn %s process.\r\n"), CommandLine );
            continue;
        }

        dwErr = WaitForSingleObject( process_information.hProcess, TickCount * 1000 );
        if ( dwErr != NO_ERROR )
        {
            log( TEXT("POP3OC: WaitForSingleObject() failed. Error 0x%08x\r\n"), dwErr );
            TerminateProcess( process_information.hProcess, -1 );
            CloseHandle( process_information.hProcess );
            CloseHandle( process_information.hThread );
            continue;
        }

        CloseHandle( process_information.hProcess );
        CloseHandle( process_information.hThread );

        log( TEXT("POP3OC: %s successfully completed within %u seconds.\r\n"), CommandLine, TickCount );
    }

    return TRUE;
}

HRESULT CreateLink( const TCHAR *sourcePath, const TCHAR *linkPath, const TCHAR *args, const TCHAR *sDesc )
{
	CoInitialize( NULL );
	IShellLink* pShellLink = NULL;
	HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
		IID_IShellLink, reinterpret_cast<void**>(&pShellLink));
	if (FAILED(hr))
		return hr;

	hr = pShellLink->SetPath(sourcePath);
	if (FAILED(hr))
		return hr;

	hr = pShellLink->SetArguments(args);
	if (FAILED(hr))
		return hr;

	hr = pShellLink->SetDescription(sDesc);
	if (FAILED(hr))
		return hr;

	IPersistFile* pPersistFile = NULL;
	hr = pShellLink->QueryInterface(IID_IPersistFile, reinterpret_cast<void**>(&pPersistFile));
	if (FAILED(hr))
		return hr;

	TCHAR* szTemp = new TCHAR[(sizeof(TCHAR) * _tcslen(linkPath)) + sizeof(TCHAR)];
	if (!szTemp)
		return E_OUTOFMEMORY;
		
	_tcscpy( szTemp, linkPath );
	hr = pPersistFile->Save(szTemp, TRUE);
	if (FAILED(hr))
		return hr;

	
	pPersistFile->Release();
	pShellLink->Release();
	
	CoUninitialize();
	delete [] szTemp;
	return S_OK;
}

//Get a complete  
int GetProcesses (DWORD ** lplp)
{
    *lplp = NULL;

    // according to docs (and other places), there's no scheme to tell,
    // a priori, how many procs there are.  So use loop below:

    DWORD * lpids = NULL;
    DWORD dwcb = sizeof(DWORD), dwcbNeeded;
    do {
        // alloc based on current dwcb.
        lpids = (DWORD *)malloc (dwcb);
        if (!lpids)
            return 0;

        dwcbNeeded = 0;
        BOOL b = EnumProcesses (lpids, dwcb, &dwcbNeeded);
        if ((b == FALSE) || (dwcbNeeded == 0)) {
            // error!
            free (lpids);
            return 0;
        }
        if (dwcbNeeded == dwcb) {
            free (lpids);
            dwcb *= 2;
            continue;
        }

        // if we got here, we have a complete list of procs
        break;
    } while (1);

    *lplp = lpids;
    return dwcbNeeded/sizeof(DWORD);
}

int GetModules (HANDLE hProcess, HMODULE ** lplp)
{
    *lplp = NULL;

    HMODULE * lpMods = NULL;
    DWORD dwcb = sizeof(HMODULE), dwcbNeeded;
    do {
        // alloc based on current dwcb.
        lpMods = (HMODULE *)malloc (dwcb);
        if (!lpMods)
            return 0;

        dwcbNeeded = 0;
        BOOL b = EnumProcessModules (hProcess, lpMods, dwcb, &dwcbNeeded);
        if ((b == FALSE) || (dwcbNeeded == 0)) {
            // error!
            free (lpMods);
            return 0;
        }
        // unlike calls to EnumProcesses, the last param of EnumProcessModules
        // is actually useful:  so, use it.
        if (dwcbNeeded > dwcb) {
            free (lpMods);
            dwcb = dwcbNeeded;
            continue;
        }

        // if we got here, we have a complete list of modules
        break;
    } while (1);

    *lplp = lpMods;
    return dwcbNeeded/sizeof(HMODULE);
}
DWORD KillPop3Snapins()
{
    DWORD * lpProcs = NULL;
    int iProcs = GetProcesses (&lpProcs);
    if (!lpProcs)
        return false;

    bool    b = false;
    HANDLE  hProcess;
    HMODULE hModule;
    DWORD   cbReturned;
    TCHAR   szName[MAX_PATH];
    HMODULE *lpMods;
    int     iMods;

    // for each proc, get its name, and see if it's MMC
    for (int i=0; i<iProcs; i++) 
    {
        hProcess = OpenProcess (PROCESS_ALL_ACCESS, FALSE, lpProcs[i]);
        if (hProcess != NULL)
        {   // first module is the .exe....
            hModule = NULL;
            cbReturned = 0;
            if ( EnumProcessModules (hProcess, &hModule, sizeof(hModule), &cbReturned ))
            {   // get .exe name
                szName[0] = 0;
                GetModuleBaseName (hProcess, hModule, szName, MAX_PATH);
                if ( 0 == _tcsicmp (szName, _T("mmc.exe")))
                {   // get all modules (.dlls)
                    lpMods = NULL;
                    iMods = GetModules (hProcess, &lpMods);
                    if (lpMods != NULL)
                    {
                        for (int j=1; !b && j<iMods; j++) 
                        {
                            GetModuleBaseName (hProcess, lpMods[j], szName, MAX_PATH);
                            if (!_tcsicmp( szName, _T("Pop3Snap.dll") ) ) 
                            {
                                b = true;
                            }
                        }
                    }
                    free (lpMods);
                }
            }
            if(b)
            {
                //This is mmc.exe with pop3snap.dll
                TerminateProcess(hProcess, 0 );
                b=FALSE;
            }
            CloseHandle( hProcess);
        }
    }
    free (lpProcs);

    return b;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\oc\serviceutil.h ===
// ServiceUtil.h: interface for the CServiceUtil class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SERVICEUTIL_H__DA56425C_95C0_478B_A193_34C4758AAD23__INCLUDED_)
#define AFX_SERVICEUTIL_H__DA56425C_95C0_478B_A193_34C4758AAD23__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CServiceUtil  
{
public:
    CServiceUtil();
    virtual ~CServiceUtil();

// Implementation
public:
    HRESULT StopService( LPCTSTR szServiceName );
    HRESULT RestoreServiceState( LPCTSTR szServiceName );
        
// Attributes
protected:
    ENUM_SERVICE_STATUS *m_pstServiceStatus;
    DWORD   m_dwNumServices;
    DWORD   m_dwCurrentState;
    
};

#endif // !defined(AFX_SERVICEUTIL_H__DA56425C_95C0_478B_A193_34C4758AAD23__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\oc\resource.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      resource.h
 *
 *  Abstract:
 *
 *      This file contains all resources defines for ocgen.dll
 *
 *  Author:
 *
 *      Pat Styles (patst) 21-Nov-1996
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _RESOURCE_H_
 #error "resource.h already included!"
#else
 #define _RESOURCE_H_
#endif

#define IDS_DIALOG_CAPTION      1
#define IDS_SHORTCUT_TOOLTIP    2
#define IDS_ERR_EXCHANGE_INSTALLED   3
#define IDS_SNAPIN_NAME         4

// !!! WARNING !!! Don't change the resource ID, unless you
// also change the corresponding ID in the affected INF files.
// 
#define IDB_ROOT_AUTO_UPDATE                  1001      // DSIE: Bitmap ID for RootAU.INF
#define IDB_ROOT_IE                           1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\oc\util.cpp ===
/*
 *  Copyright (c) 2001  Microsoft Corporation
 *
 *  Module Name:
 *
 *      util.cpp
 *
 *  Abstract:
 *
 *      This file communicates with  exchange
 *
 *  Author:
 *
 *      Paolo Raden (paolora) Nov-20-2001
 *
 *  Environment:
 *
 *    User Mode
 */

#define _UTIL_CPP_
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <tchar.h>
#include <time.h>
#include "pop3oc.h"
#pragma hdrstop

TCHAR glabel[] = TEXT("\n[POP3OC] ");

// for logging

#define gsLogFile           TEXT("%windir%\\pop3oc.log")
#define gsLogCompletionMsg  TEXT(" - complete\r\n")
#define gsLogInitMsg        TEXT("\r\n\r\nInitialize setup: POP3oc.DLL %s %s\r\n")

// for trace statements

#define gsTrace             TEXT("OCGEN.DLL: Trace")

typedef enum {

    nPreInit,               // OC_PREINITIALIZE
    nInit,                  // OC_INIT_COMPONENT
    nSetLang,               // OC_SET_LANGUAGE
    nQueryImage,            // OC_QUERY_IMAGE
    nRequestPages,          // OC_REQUEST_PAGES
    nQueryChangeSel,        // OC_QUERY_CHANGE_SEL_STATE
    nCalcSpace,             // OC_CALC_DISK_SPACE
    nQueueFile,             // OC_QUEUE_FILE_OPS
    nQueueNot,              // OC_NOTIFICATION_FROM_QUEUE
    nQueryStep,             // OC_QUERY_STEP_COUNT
    nComplete,              // OC_COMPLETE_INSTALLATION
    nCleanup,               // OC_CLEANUP
    nQueryState,            // OC_QUERY_STATE
    nNeedMedia,             // OC_NEED_MEDIA
    nAboutToCommit,         // OC_ABOUT_TO_COMMIT_QUEUE
    nQuerySkip,             // OC_QUERY_SKIP_PAGE  
    nWizardCreated,         // OC_WIZARD_CREATED
    nExtraRoutines,         // OC_EXTRA_ROUTINES
    nMaximum
} notifications;

typedef struct _OcMsgs {
    DWORD  msg;
    TCHAR *desc;
} OcMsgs;

OcMsgs gMsgs[nMaximum] = {
    {OC_PREINITIALIZE,          TEXT("OC_PREINITIALIZE")},
    {OC_INIT_COMPONENT,         TEXT("OC_INIT_COMPONENT")},
    {OC_SET_LANGUAGE,           TEXT("OC_SET_LANGUAGE")},
    {OC_QUERY_IMAGE,            TEXT("OC_QUERY_IMAGE")},
    {OC_REQUEST_PAGES,          TEXT("OC_REQUEST_PAGES")},
    {OC_QUERY_CHANGE_SEL_STATE, TEXT("OC_QUERY_CHANGE_SEL_STATE")},
    {OC_CALC_DISK_SPACE,        TEXT("OC_CALC_DISK_SPACE")},
    {OC_QUEUE_FILE_OPS,         TEXT("OC_QUEUE_FILE_OPS")},
    {OC_NOTIFICATION_FROM_QUEUE,TEXT("OC_NOTIFICATION_FROM_QUEUE")},
    {OC_QUERY_STEP_COUNT,       TEXT("OC_QUERY_STEP_COUNT")},
    {OC_COMPLETE_INSTALLATION,  TEXT("OC_COMPLETE_INSTALLATION")},
    {OC_CLEANUP,                TEXT("OC_CLEANUP")},
    {OC_QUERY_STATE,            TEXT("OC_QUERY_STATE")},
    {OC_NEED_MEDIA,             TEXT("OC_NEED_MEDIA")},
    {OC_ABOUT_TO_COMMIT_QUEUE,  TEXT("OC_ABOUT_TO_COMMIT_QUEUE")},
    {OC_QUERY_SKIP_PAGE,        TEXT("OC_QUERY_SKIP_PAGE")},
    {OC_WIZARD_CREATED,         TEXT("OC_WIZARD_CREATED")},
    {OC_EXTRA_ROUTINES,         TEXT("OC_EXTRA_ROUTINES")}
};

TCHAR gUnknown[] = TEXT("Unknown Notification: ");

// determines whether or not to display debug info

DWORD gDebugLevel = (DWORD)-1;

// forward reference

TCHAR *NotificationText(DWORD msg);
BOOL  CheckLevel(DWORD level);

/*
 * DebugTrace()
 */

void DebugTrace(DWORD level, const TCHAR *text)
{
    if (!CheckLevel(level))
        return;

    OutputDebugString(text);
}

/*
 * DebugTraceNL()
 *
 * precedes a trace statement with a newline and id prefix
 */

void DebugTraceNL(DWORD level, const TCHAR *text)
{
    DebugTrace(level, glabel);
    DebugTrace(level, text);
}

/*
 * NotificationText()
 */

TCHAR *NotificationText(DWORD msg)
{
    int i;
    static TCHAR desc[S_SIZE];

    for (i = 0; i < nMaximum; i++)
    {
        if (gMsgs[i].msg == msg)
            return gMsgs[i].desc;
    }

    wsprintf(desc, TEXT("OC_%d: "), msg);
    return desc;
}

/*
 * DebugTraceOCNotification()
 */

void DebugTraceOCNotification(DWORD msg, const TCHAR *component)
{
    DebugTraceNL(1, NotificationText(msg));
    DebugTrace(1, TEXT(": "));
    DebugTrace(1, component);
    DebugTrace(1, TEXT(" - "));
}

/*
 * DebugTraceFileCopy()
 */

void DebugTraceFileCopy(const TCHAR *file)
{
    DebugTraceNL(5, TEXT("TreeCopy: FILE="));
    DebugTrace(5, file);
}

/*
 * DebugTraceFileCopyError()
 */

void DebugTraceFileCopyError()
{
    TCHAR buf[S_SIZE];
    
    _stprintf(buf, FMT(" FAILURE CODE:[%d] "), GetLastError());
    DebugTrace(5, buf);
}

/*
 * DebugTraceDirCopy()
 */

void DebugTraceDirCopy(const TCHAR *dir)
{
    DebugTraceNL(3, TEXT("TreeCopy: DIR="));
    DebugTrace(3, dir);
}


/*
 * CheckLevel()
 */

BOOL CheckLevel(DWORD level)
{
    if (gDebugLevel == (DWORD)-1)
        gDebugLevel = SysGetDebugLevel();

    return (gDebugLevel >= level);
}

/*
 * MsgBox
 *
 */

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... )
{
    static BOOL initialize = true;
    static TCHAR caption[S_SIZE];
    TCHAR  text[S_SIZE];
    TCHAR  format[S_SIZE];
    int    len;

    va_list vaList;

    assert(textID && type);

    if (initialize)
    {
        len = LoadString(ghinst, IDS_DIALOG_CAPTION, caption, S_SIZE);
        assert(len);
        if (!len) {
            _tcscpy( caption, TEXT("Setup"));
        }
        initialize = false;
    }

    len = LoadString(ghinst, textID, format, S_SIZE);
    assert(len);
    if (!len) {
        _tcscpy( format, TEXT("Unknown Error"));
    }

    va_start(vaList, type);
    tvsprintf(text, format, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MsgBox(HWND hwnd, TCHAR *fmt, TCHAR *caption, UINT type, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(text && caption && type);

    va_start(vaList, type);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt && caption);

    va_start(vaList, caption);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, caption, MB_ICONINFORMATION | MB_OK);
}

DWORD TMBox(LPCTSTR fmt, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt);

    va_start(vaList, fmt);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, gsTrace, MB_ICONINFORMATION | MB_OK);
}

/*
 * SysGetDebugLevel()
 */

DWORD SysGetDebugLevel()
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    err = RegOpenKey(HKEY_LOCAL_MACHINE, 
                     TEXT("SOFTWARE\\microsoft\\windows\\currentversion\\setup"), 
                     &hkey);

    if (err != ERROR_SUCCESS)
        return 0;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          TEXT("OCGen Debug Level"),
                          0,
                          &type,
                          (LPBYTE)&rc,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
        rc = 0;

    RegCloseKey(hkey);

    return rc;
}

/*
 * TCharStringToAnsiString
 */

DWORD TCharStringToAnsiString(TCHAR *tsz ,char *asz)
{
    DWORD count;

    assert(tsz && asz);

#ifdef UNICODE
    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > S_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}

void logOCNotification(DWORD msg, const TCHAR *component)
{
    log(FMT("[%s - %s]"), component, NotificationText(msg));
}

void logOCNotificationCompletion()
{
    log(gsLogCompletionMsg);
}

void loginit()
{
    HANDLE hfile;
    TCHAR  logfile[MAX_PATH];
    char   fmt[S_SIZE];
    char   output[S_SIZE];
    char   time[S_SIZE];
    char   date[S_SIZE];
    DWORD  bytes;

//#ifdef DEBUG
    TCharStringToAnsiString(gsLogInitMsg, fmt);
    _strdate(date);
    _strtime(time);
    sprintf(output, fmt, date, time);

    // open the log file

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    hfile = CreateFile(logfile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(logfile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

void log(TCHAR *fmt, ...)
{
    TCHAR  logfile[MAX_PATH]=_T("");
    TCHAR  text[S_SIZE]=_T("");
    char   output[S_SIZE]="";
    DWORD  bytes;
    HANDLE hfile=INVALID_HANDLE_VALUE;

    va_list vaList;

//#ifdef DEBUG
    assert(fmt);

    // create the output string

    va_start(vaList, fmt);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    TCharStringToAnsiString(text, output);

    // create the log file name in the root directory

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    // open the log file
    if(logfile[0]!=0)
    {
        hfile = CreateFile(logfile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);
    }
    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

void AssureTrailingBackslash(TCHAR *path)
{
    TCHAR *p;
    
    assert(path && *path);

    p = path + _tcslen(path) - 1;
    if (*p != TEXT('\\'))
        _tcscat(path, TEXT("\\"));
}

BOOL IsNT()
{
    DWORD dwver;

    dwver = GetVersion();

    if (dwver < 0x8000000)
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\oc\serviceutil.cpp ===
// ServiceUtil.cpp: implementation of the CServiceUtil class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include "ServiceUtil.h"

#ifndef _ASSERT
#define _ASSERT assert  // servutil.h uses _ASSERT
#endif
#include <servutil.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServiceUtil::CServiceUtil() :
    m_pstServiceStatus(NULL), m_dwNumServices(0), m_dwCurrentState(SERVICE_STOPPED)
{

}

CServiceUtil::~CServiceUtil()
{
    if ( NULL != m_pstServiceStatus )
        free (m_pstServiceStatus);
}

//////////////////////////////////////////////////////////////////////
// Implementation: public
//////////////////////////////////////////////////////////////////////

HRESULT CServiceUtil::RestoreServiceState( LPCTSTR szServiceName )
{
    HRESULT hr = S_OK;
    
    if ( SERVICE_STOP_PENDING != m_dwCurrentState && SERVICE_STOPPED != m_dwCurrentState )
    {
        // Let's leave the machine how we found it, restart service
        // and the dependent services
        hr = _StartService( const_cast<LPTSTR>( szServiceName ));   // Start the Service first
        if ( NULL != m_pstServiceStatus )
        {
            for ( DWORD i = 0; i < m_dwNumServices && S_OK == hr; i++ ) 
            {
                if ( SERVICE_RUNNING == m_pstServiceStatus[i].ServiceStatus.dwCurrentState || SERVICE_START_PENDING == m_pstServiceStatus[i].ServiceStatus.dwCurrentState || SERVICE_CONTINUE_PENDING == m_pstServiceStatus[i].ServiceStatus.dwCurrentState )
                    hr = _StartService ( m_pstServiceStatus[i].lpServiceName );
                if ( S_OK != hr )
                {
                    if ( SERVICE_RUNNING == _GetServiceStatus ( m_pstServiceStatus[i].lpServiceName ))
                        hr = S_OK;
                }
            }
            free ( m_pstServiceStatus );
            m_pstServiceStatus = NULL;
            m_dwCurrentState = SERVICE_STOPPED;
            m_dwNumServices = 0;
        }
    }
    return hr;
}

HRESULT CServiceUtil::StopService( LPCTSTR szServiceName )
{
    HRESULT hr = S_OK;
    DWORD   dwBufSize = 1;
    SC_HANDLE hManager, hService;
    m_dwCurrentState = _GetServiceStatus( const_cast<LPTSTR>( szServiceName ));
    if ( SERVICE_STOP_PENDING != m_dwCurrentState && SERVICE_STOPPED != m_dwCurrentState )
    {   // Need to stop the service
        // Build a list of dependent services first
        hManager = OpenSCManager( NULL, NULL, STANDARD_RIGHTS_REQUIRED );
        if ( NULL != hManager )
        {
            hService = OpenService (hManager, szServiceName, SERVICE_ALL_ACCESS);
            if (!EnumDependentServices (hService, SERVICE_ACTIVE, (LPENUM_SERVICE_STATUS)&dwBufSize, dwBufSize, &dwBufSize, &m_dwNumServices)) 
            {   // this should fail with ERROR_MORE_DATA, unless there are no dependent services
                hr = GetLastError ();
                if (hr == ERROR_MORE_DATA) 
                {
                    m_pstServiceStatus = (ENUM_SERVICE_STATUS *) malloc (dwBufSize);
                    if ( NULL == m_pstServiceStatus )
                        hr = E_OUTOFMEMORY;
                    else {
                        if (!EnumDependentServices (hService, SERVICE_ACTIVE, m_pstServiceStatus, dwBufSize, &dwBufSize, &m_dwNumServices))
                            hr = GetLastError();  // shouldn't happen!!!
                        else 
                            hr = S_OK;
                    }
                }
                CloseServiceHandle( hService );
            }
            CloseServiceHandle( hManager );
        }
        if ( S_OK == hr )
            hr = _StopService( const_cast<LPTSTR>( szServiceName ), TRUE );   // Stop the Service first
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\pop2exch.cpp ===
// Pop2Exch.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "P2EWorker.h"

#include <atlbase.h>
#include <checkuser.h>  //IsUserInGroup

int _cdecl wmain(int argc, wchar_t* argv[])
{
    HRESULT hr = S_OK;
    CP2EWorker oWorker;
    CHAR szConsoleCP[8];

    setlocale( LC_ALL, "" );
    if ( 0 < _snprintf( szConsoleCP, 7, ".%d", GetConsoleOutputCP() ))
        setlocale( LC_CTYPE, szConsoleCP );
    // Command check
    if ( S_OK != IsUserInGroup(DOMAIN_ALIAS_RID_ADMINS)) // Admin check
        hr = E_ACCESSDENIED;
    if ( S_OK == hr )
    {   // Check for /?
        if ( 1 < argc )
        {
            for ( int i = 1; i < argc; i++ )
            {
                if (( 0 == _wcsicmp( L"/?", argv[i] )) || ( 0 == _wcsicmp( L"-?", argv[i] )))
                    hr = -1;
            }
        }
        else
            hr = -1;
    }
        
    if ( S_OK == hr )
    {
        hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
        if ( S_OK == hr )
        {
            if ( 0 == _wcsicmp( L"CREATEUSER", argv[1] ))
            {   
                hr = oWorker.CreateUser( argc, argv, true, false );
            }
            else if ( 0 == _wcsicmp( L"CREATEMAILBOX", argv[1] ))
            {   
                hr = oWorker.CreateUser( argc, argv, false, true );
            }
            else if ( 0 == _wcsicmp( L"SENDMAIL", argv[1] ))
            {   
                hr = oWorker.Mail( argc, argv );
            }
            else
                hr = -1;
            CoUninitialize();
        }
    }

    if ( -1 == hr )
    {
        oWorker.PrintUsage();
    }
    else if ( 0 != hr )
    {
        oWorker.PrintError( hr );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\p2eworker.cpp ===
// P2EWorker.cpp: implementation of the CP2EWorker class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "P2EWorker.h"
#include "resource.h"
#include "resource2.h"
#include <sbs6base.h>
#include <P3Admin.h>
#include <pop3server.h>
#include <logutil.h>
#include <mailbox.h>
#include "UserInfo.h"
#include <AuthID.h>
#include <FormatMessage.h>

#include <atlbase.h>
#include <comdef.h>
#include <dsgetdc.h>
#include <lm.h>
#include <tchar.h>
#include <stdio.h>
#include <ws2tcpip.h>
//#include <mswsock.h>
#include <AuthUtil.h>

#ifndef ASSERT
#define ASSERT assert
#endif

LOGFILE(L"Pop2ExchLog.txt");
#define SMTP_BUFFERSIZE     2048
#define SMTP_QUIT           "QUIT\r\n"
#define SMTP_DATA           "DATA\r\n"
#define SMTP_DATA_END       "\r\n.\r\n"
#define SMTP_RSET           "RSET\r\n"
#define SMTP_MSG220         "220"   // 220 <domain> Service ready
#define SMTP_MSG221         "221"   // 221 <domain> Service ready
#define SMTP_MSG250         "250"   // 250 Requested mail action okay, completed
#define SMTP_MSG354         "354"   // 354 Start mail input; end with <CRLF>.<CRLF>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CP2EWorker::CP2EWorker() :
    m_bSuppressPrintError( false )
{

}

CP2EWorker::~CP2EWorker()
{

}

//////////////////////////////////////////////////////////////////////
// Implementation : public
//////////////////////////////////////////////////////////////////////

int CP2EWorker::CreateUser(int argc, wchar_t *argv[], const bool bCreateUser, const bool bCreateMailbox)
{
    USES_CONVERSION;
    HRESULT hr;
    VARIANT v;
    BSTR    bstrName, bstrEmailName;
    _bstr_t _bstrDomainName;
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Domains> spIDomains;
    IP3Domain *pIDomain = NULL;
    CComPtr<IEnumVARIANT> spIEnumVARIANT;
    bool    bErrors = false, bIgnoreErrors = false, bUnregisterDependencies = false;
    char    sPassword[MAX_PATH];
    CUserInfo userInfoX;

    if ( 4 != argc && 3 != argc )
        return -1;
    if ( 2 < argc ) // Since domain name is now required this is no longer a valid option
    {               // But I'm going to leave the code in case we ever reverse this decision
        if ( 0 == wcscmp( L"/i", argv[2] ) || ( 0 == wcscmp( L"-i", argv[2] )))
            bIgnoreErrors = true;
        else
            _bstrDomainName = argv[2];
    }
    if ( 4 == argc )
    {
        if ( bIgnoreErrors )
            _bstrDomainName = argv[3];
        else if ( 0 == wcscmp( L"/i", argv[3] ) || ( 0 == wcscmp( L"-i", argv[3] )))
            bIgnoreErrors = true;
        else
            return -1;
    }
    if ( 0 == _bstrDomainName.length() )
        return -1;

    {   // Log the command
        LPWSTR ps2 = argv[2], ps3 = argv[3];

        if ( NULL == ps2 )
        {
            ps2 = L"";
            ps3 = NULL;
        }
        if ( NULL == ps3 )
        {
            ps3 = L"";
        }
        LOG( L"%s %s %s %s", argv[0], argv[1], ps2, ps3 );
    }
    
    VariantInit( &v );
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( REGDB_E_CLASSNOTREG == hr )
    {
        hr = RegisterDependencies();
        if ( S_OK == hr )
            hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
        bUnregisterDependencies = true;
    }
    if ( S_OK == hr )
    {
        if ( bCreateUser )  // Only valid for the MD5 Authentication method
        {
            CComPtr<IAuthMethods> spIAuthMethods;
            CComPtr<IAuthMethod> spIAuthMethod;
            BSTR    bstrID;
            _variant_t _v;
            long     lValue;
            WCHAR   sBuffer[MAX_PATH];

            hr = spIConfig->get_Authentication( &spIAuthMethods );
            if ( REGDB_E_CLASSNOTREG == hr )
            {
                PrintMessage( IDS_ERROR_POP3REQUIRED );                
                m_bSuppressPrintError = true;
            }
            if ( S_OK == hr )
                hr = spIAuthMethods->get_CurrentAuthMethod( &_v );
            if ( S_OK == hr )
                hr = spIAuthMethods->get_Item( _v, &spIAuthMethod );
            if ( S_OK == hr )
                hr = spIAuthMethod->get_ID( &bstrID );
            if ( S_OK == hr )
            {
                if ( 0 != _wcsicmp( bstrID, SZ_AUTH_ID_MD5_HASH ))
                    hr = HRESULT_FROM_WIN32( ERROR_DS_INAPPROPRIATE_AUTH );
                SysFreeString( bstrID );
            }
         }
    }
    
    if ( S_OK == hr )
        hr = spIConfig->get_Domains( &spIDomains );
    if ( S_OK == hr )
    {
        CComPtr<IP3Users> spIUsers;
        CComPtr<IP3User> spIUser;
        
        if ( 0 == _bstrDomainName.length() )
        {   // For each domain 
            hr = spIDomains->get__NewEnum( &spIEnumVARIANT );
            if ( S_OK == hr )
            {
                hr = spIEnumVARIANT->Next( 1, &v, NULL );
            }
        }
        else
        {   // Just for this domain
            _variant_t _v( _bstrDomainName );
            
            hr = spIDomains->get_Item( _v, &pIDomain );
        }
        while ( S_OK == hr )
        {
            if ( NULL != spIEnumVARIANT.p )
            {
                if ( VT_DISPATCH != V_VT( &v ))
                    hr = E_UNEXPECTED;
                if ( S_OK == hr )
                    hr = V_DISPATCH( &v )->QueryInterface( __uuidof( IP3Domain ), reinterpret_cast<void**>( &pIDomain ));
                VariantClear( &v );
            }
            if ( S_OK == hr )
                hr = pIDomain->get_Name( &bstrName );
            if ( S_OK == hr )
            {
                LOG( L"Domain: %s ", bstrName );
                SysFreeString( bstrName );
            }
            // Enumerate the users
            if ( S_OK == hr )
            {
                hr = pIDomain->get_Users( &spIUsers );
                if ( S_OK == hr )
                {   // List users
                    CComPtr<IEnumVARIANT> spIEnumVARIANT2;
                    
                    hr = spIUsers->get__NewEnum( &spIEnumVARIANT2 );
                    if ( S_OK == hr )
                        hr = spIEnumVARIANT2->Next( 1, &v, NULL );
                    while ( S_OK == hr )
                    {
                        if ( VT_DISPATCH != V_VT( &v ))
                            hr = E_UNEXPECTED;
                        if ( S_OK == hr )
                            hr = V_DISPATCH( &v )->QueryInterface( __uuidof( IP3User ), reinterpret_cast<void**>( &spIUser ));
                        VariantClear( &v );
                        hr = spIUser->get_Name( &bstrName );
                        if ( S_OK == hr )
                        {
                            if ( S_OK == hr )
                                hr = userInfoX.SetUserName( bstrName );
                            if ( S_OK == hr )
                            {
                                hr = spIUser->get_EmailName( &bstrEmailName );
                                if ( S_OK == hr )
                                {
                                    hr = GetMD5Password( bstrEmailName, sPassword );
                                    if ( S_OK == hr )
                                        hr = userInfoX.SetPassword( A2W( sPassword ));
                                }
                            }
                            if ( S_OK == hr )
                            {
                                if ( bCreateUser )
                                {   // Create the user
                                    hr = userInfoX.CreateAccount();
                                    if ( S_OK == hr )
                                        LOG( L"Create user: %s succeeded.", bstrName );
                                    else
                                    {
                                        LOG( L"ERROR!: Create user %s failed. %s", bstrName, CFormatMessage(hr).c_str() );
                                        if ( bIgnoreErrors ) 
                                        {
                                            hr = S_OK;
                                            bErrors = true;
                                        }
                                    }
                                }
                                if ( bCreateMailbox )
                                {   // Create the mailbox
                                    hr = userInfoX.CreateMailbox();
                                    if ( S_OK == hr )
                                        LOG( L"Create mailbox: %s succeeded.", bstrName );
                                    else
                                    {
                                        LOG( L"ERROR!: Create mailbox %s failed. %s", bstrName, CFormatMessage(hr).c_str() );
                                        if ( bIgnoreErrors ) 
                                        {
                                            hr = S_OK;
                                            bErrors = true;
                                        }
                                    }
                                }
                            }
                            SysFreeString( bstrName );
                        }
                        if ( S_OK == hr )
                            hr = spIEnumVARIANT2->Next( 1, &v, NULL );
                    }
                    if ( S_FALSE == hr )
                        hr = S_OK;  // Reached end of user enumeration
                }
            }
            if ( S_OK == hr )
            {
                if ( NULL != spIEnumVARIANT.p )
                {
                    hr = spIEnumVARIANT->Next( 1, &v, NULL );
                    if ( S_OK == hr )
                        pIDomain->Release();
                }
                else
                    hr = S_FALSE;   // Were done.
            }
        }
        if ( S_FALSE == hr )
            hr = S_OK;  // Reached end of domain enumeration
    }
    if ( NULL != pIDomain )
        pIDomain->Release();
    if ( bCreateUser )
    {
        if ( S_OK == hr )
        {
            PrintMessage( IDS_SUCCESS_CREATEUSER );
            if ( bErrors )
                PrintMessage( IDS_WARNING_ERRORSIGNORED );
        }
        else
            PrintMessage( IDS_ERROR_CREATEUSER_FAILED );
    }
    if ( bCreateMailbox )
    {
        if ( S_OK == hr )
        {
            PrintMessage( IDS_SUCCESS_CREATEMAILBOX );
            if ( bErrors )
                PrintMessage( IDS_WARNING_ERRORSIGNORED );
        }
        else
            PrintMessage( IDS_ERROR_CREATEMAILBOX_FAILED );
    }
    if ( bUnregisterDependencies )
        UnRegisterDependencies();

    return hr;
}

#define LOCALHOST L"localhost"
int CP2EWorker::Mail(int argc, wchar_t *argv[], bool bDelete /*= FALSE*/ )
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    VARIANT v;
    DWORD   dwCount, dwIndex;
    BSTR    bstrName, bstrEmailName;
    WSTRING sEmailDomain;
    ASTRING sASCFROM;
    _bstr_t _bstrDomainName;
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Domains> spIDomains;
    IP3Domain *pIDomain = NULL;
    CComPtr<IEnumVARIANT> spIEnumVARIANT;
    bool    bErrors = false, bIgnoreErrors = false, bLocked = false, bUnregisterDependencies = false;
    CMailBox mailboxX;
    WCHAR   sFilename[MAX_PATH];
    ASTRING sASCComputerName;
    WSTRING sComputerName;
    DWORD   dwFileNameSize = MAX_PATH;
    LPWSTR  psArgv;
    LPSTR   pszComputerName;

    if ( 5 < argc || 3 > argc )
        return -1;
    for ( int i = 2; i < argc; i++ )
    {
        psArgv = argv[i];
        if ( 0 == wcscmp( L"/i", psArgv ) || ( 0 == wcscmp( L"-i", psArgv )))
        {
            if ( bIgnoreErrors )
                return -1;
            bIgnoreErrors = true;
        }
        else if ( 0 == _wcsnicmp( L"/S:", psArgv, 3 ) || 0 == _wcsnicmp( L"-S:", psArgv, 3 ))
        {
            if ( 3 < wcslen( psArgv ))
            {
                if ( sComputerName.empty() )
                    sComputerName = psArgv + 3;
                else
                    return -1;
            }
            else
                return -1;
        }
        else
        {
            if ( 0 == _bstrDomainName.length() )
                _bstrDomainName = psArgv;
            else
                return -1;
        }
    }
    if ( 0 == _bstrDomainName.length() )
        return -1;
    if ( sComputerName.empty() )
        sComputerName = LOCALHOST;
    sASCComputerName = W2A(sComputerName.c_str());

    {
        LPWSTR ps2 = argv[2], ps3 = argv[3], ps4 = argv[4];

        if ( NULL == ps2 )
        {
            ps2 = L"";
            ps3 = L"";
            ps4 = L"";
        }
        if ( NULL == ps3 )
        {
            ps3 = L"";
            ps4 = L"";
        }
        if ( NULL == ps4 )
            ps4 = L"";
        LOG( L"%s %s %s %s %s", argv[0], argv[1], ps2, ps3, ps4 );
    }
    VariantInit( &v );
    
    // Socket Initialization
    WSADATA wsaData;
    SOCKET  socket = INVALID_SOCKET;
    int     iErr, iSize;
    LPSTR  psSendBuffer = new CHAR[SMTP_BUFFERSIZE];

    if ( NULL == psSendBuffer )
        return E_OUTOFMEMORY;

    iErr = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
    if( 0 != iErr ) 
    {
        wsaData.wVersion = 0;
        hr = HRESULT_FROM_WIN32( iErr );
        LOG( L"ERROR!: WSAStartup. %s", CFormatMessage(iErr).c_str() );
    }
    else
    {   // Confirm that the WinSock DLL supports 2.2.
        // Note that if the DLL supports versions greater than 2.2 in addition to 2.2, it will still return
        // 2.2 in wVersion since that is the version we requested.
        if ( LOBYTE( wsaData.wVersion ) != 2 || HIBYTE( wsaData.wVersion ) != 2 ) 
        {   /* Tell the user that we could not find a usable WinSock DLL. */
            LOG( L"ERROR!: WSAStartup.  Unexpected version returned" );
            hr = E_UNEXPECTED; 
        }
    }
    // Connect to port 25
    if ( S_OK == hr )
    {
        socket = WSASocket( AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0 );
        if( INVALID_SOCKET == socket ) 
        {
            iErr = WSAGetLastError();
            hr = HRESULT_FROM_WIN32( iErr );
            LOG( L"ERROR!: WSASocket. %s", CFormatMessage(iErr).c_str() );
        }
        else
        {
            addrinfo stHints;
            addrinfo *pstAIHead = NULL, *pstAINext;
            sockaddr_in stSAInServer;

            ZeroMemory( &stSAInServer, sizeof( stSAInServer ));
            ZeroMemory( &stHints, sizeof( stHints ));
            stHints.ai_family = PF_INET;
            stHints.ai_flags = AI_CANONNAME;
            iErr = getaddrinfo( sASCComputerName.c_str(), "SMTP", &stHints, &pstAIHead );
            if( 0 != iErr ) 
            {
                iErr = WSAGetLastError();
                hr = HRESULT_FROM_WIN32( iErr );
                LOG( L"ERROR!: getaddrinfo. %s", CFormatMessage(iErr).c_str() );
            }
            else
            {
                memcpy( &stSAInServer, pstAIHead->ai_addr, sizeof( stSAInServer ));
                pstAINext = pstAIHead;
                while ( NULL != pstAINext )
                {
                    pstAINext = pstAIHead->ai_next;
                    freeaddrinfo( pstAIHead );
                    pstAIHead = pstAINext;
                }
                iErr = connect( socket, reinterpret_cast<sockaddr*>( &stSAInServer ), sizeof( stSAInServer ));
                if( 0 != iErr ) 
                {
                    iErr = WSAGetLastError();
                    hr = HRESULT_FROM_WIN32( iErr );
                    LOG( L"ERROR!: connect. %s", CFormatMessage(iErr).c_str() );
                }
                hr = RecvResp( socket, SMTP_MSG220 );
            }
        }
    }
    // Get the domain name we are sending to
    if ( S_OK == hr )
    {   // Get domain controller name
        PDOMAIN_CONTROLLER_INFO pstDomainControllerInfo = NULL;
        LPCWSTR psComputerName = ( sComputerName == LOCALHOST ) ? NULL:sComputerName.c_str();
        DWORD dwRC = DsGetDcName( psComputerName, NULL, NULL, NULL, DS_RETURN_DNS_NAME, &pstDomainControllerInfo );

        if ( NO_ERROR != dwRC )
        {
            hr = HRESULT_FROM_WIN32( dwRC );
            LOG( L"ERROR!: DsGetDcName. %s", CFormatMessage(dwRC).c_str() );
        }
        ASSERT(hr == S_OK && "DsGetDcName failed");

        // cache the domain
        if ( pstDomainControllerInfo )
        {
            sEmailDomain = pstDomainControllerInfo->DomainName;
            // free memory
            NetApiBufferFree( pstDomainControllerInfo );
        }
    }
    // SMTP:HELO
    if ( S_OK == hr )
    {
        iSize = _snprintf( psSendBuffer, 2048, "HELO %s\r\n", W2A( sEmailDomain.c_str() ));
        if ( 0 < iSize )
            hr = SendRecv( socket, psSendBuffer, iSize, SMTP_MSG250 ); 
        else
            hr = E_UNEXPECTED;
    }

    // Process domains and mailboxes
    if ( S_OK == hr )
        hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( REGDB_E_CLASSNOTREG == hr )
    {
        hr = RegisterDependencies();
        if ( S_OK == hr )
            hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
        bUnregisterDependencies = true;
    }
    if ( S_OK == hr )
        hr = spIConfig->get_Domains( &spIDomains );
    if ( S_OK == hr )
    {
        CComPtr<IP3Users> spIUsers;
        CComPtr<IP3User> spIUser;
        
        if ( 0 == _bstrDomainName.length() )
        {   // For each domain 
            hr = spIDomains->get__NewEnum( &spIEnumVARIANT );
            if ( S_OK == hr )
            {
                hr = spIEnumVARIANT->Next( 1, &v, NULL );
            }
        }
        else
        {   // Just for this domain
            _variant_t _v( _bstrDomainName );
            
            hr = spIDomains->get_Item( _v, &pIDomain );
        }
        while ( S_OK == hr )
        {
            if ( NULL != spIEnumVARIANT.p )
            {
                if ( VT_DISPATCH != V_VT( &v ))
                    hr = E_UNEXPECTED;
                if ( S_OK == hr )
                    hr = V_DISPATCH( &v )->QueryInterface( __uuidof( IP3Domain ), reinterpret_cast<void**>( &pIDomain ));
                VariantClear( &v );
            }
            if ( S_OK == hr )
                hr = pIDomain->get_Name( &bstrName );
            if ( S_OK == hr )
            {
                LOG( L"Domain: %s ", bstrName );
                SysFreeString( bstrName );
            }
            // Enumerate the users
            if ( S_OK == hr )
            {
                hr = pIDomain->get_Users( &spIUsers );
                if ( S_OK == hr )
                {   // List users
                    CComPtr<IEnumVARIANT> spIEnumVARIANT2;
                    
                    hr = spIUsers->get__NewEnum( &spIEnumVARIANT2 );
                    if ( S_OK == hr )
                        hr = spIEnumVARIANT2->Next( 1, &v, NULL );
                    while ( S_OK == hr )
                    {
                        if ( VT_DISPATCH != V_VT( &v ))
                            hr = E_UNEXPECTED;
                        if ( S_OK == hr )
                            hr = V_DISPATCH( &v )->QueryInterface( __uuidof( IP3User ), reinterpret_cast<void**>( &spIUser ));
                        VariantClear( &v );
                        if ( S_OK == hr )
                            hr = spIUser->get_Name( &bstrName );
                        if ( S_OK == hr )
                        {   
                            hr = spIUser->get_EmailName( &bstrEmailName );
                            if ( S_OK == hr )
                            {
                                hr = mailboxX.OpenMailBox(  bstrEmailName ) ? S_OK : E_UNEXPECTED;
                                if ( S_OK == hr )
                                {
                                    bLocked = mailboxX.LockMailBox() ? true : false;
                                    hr = mailboxX.EnumerateMailBox() ? S_OK : E_UNEXPECTED;
                                }
                                if ( S_OK == hr )
                                    dwCount = mailboxX.GetMailCount();
                                for ( dwIndex = 0; (S_OK == hr) && (dwIndex < dwCount); dwIndex++ )
                                {
                                    if ( !mailboxX.GetMailFileName( dwIndex, sFilename, dwFileNameSize ))
                                        hr = E_UNEXPECTED;
                                    if ( S_OK == hr )
                                    {
                                        hr = GetMailFROM( sFilename, sASCFROM );
                                        if ( S_OK != hr )
                                            sASCFROM.erase();
                                    }
                                    if ( S_OK == hr )
                                    {   // SMTP:MAIL
                                        iSize = _snprintf( psSendBuffer, SMTP_BUFFERSIZE, "MAIL FROM:<%s>\r\n", sASCFROM.c_str() );
                                        if ( 0 < iSize )
                                            hr = SendRecv( socket, psSendBuffer, iSize, SMTP_MSG250 ); 
                                        else
                                            hr = E_UNEXPECTED;
                                    }
                                    if ( S_OK == hr )
                                    {   // SMTP:RCPT
                                        iSize = _snprintf( psSendBuffer, SMTP_BUFFERSIZE, "RCPT TO:%s@%s\r\n", W2A( bstrName ), W2A( sEmailDomain.c_str() ));
                                        if ( 0 < iSize )
                                            hr = SendRecv( socket, psSendBuffer, iSize, SMTP_MSG250 ); 
                                        else
                                            hr = E_UNEXPECTED;
                                    }
                                    if ( S_OK == hr )
                                    {   // SMTP:DATA
                                        hr = SendRecv( socket, SMTP_DATA, iSize, SMTP_MSG354 ); 
                                    }
                                    if ( S_OK == hr )
                                    {
                                        iErr = mailboxX.TransmitMail( socket, dwIndex );
                                        if ( ERROR_SUCCESS != iErr )
                                        {
                                            hr = HRESULT_FROM_WIN32( iErr );
                                            LOG( L"ERROR!: TransmitMail failed. %s", CFormatMessage(iErr).c_str() );
                                            // Data probably wasn't terminated since TransmitMail failed.
                                            SendRecv( socket, SMTP_DATA_END, iSize, SMTP_MSG250 ); 
                                        }
                                        else
                                        {   // There should be a 250 OK reply waiting.
                                            hr = RecvResp( socket, SMTP_MSG250 );
                                        }
                                    }
                                    if ( S_OK != hr && bIgnoreErrors )
                                    {
                                        SendRecv( socket, SMTP_RSET, strlen( SMTP_RSET ), SMTP_MSG250 ); 
                                        hr = S_OK;
                                        bErrors = true;
                                    }
                                }
                                if ( bLocked )
                                {
                                    mailboxX.UnlockMailBox();
                                    bLocked = false;
                                }
                                SysFreeString( bstrEmailName );
                                mailboxX.QuitAndClose();
                            }
                            SysFreeString( bstrName );
                        }
                        if ( S_OK == hr )
                            hr = spIEnumVARIANT2->Next( 1, &v, NULL );
                    }
                    if ( S_FALSE == hr )
                        hr = S_OK;  // Reached end of user enumeration
                }
            }
            if ( S_OK == hr )
            {
                if ( NULL != spIEnumVARIANT.p )
                {
                    hr = spIEnumVARIANT->Next( 1, &v, NULL );
                    if ( S_OK == hr )
                        pIDomain->Release();
                }
                else
                    hr = S_FALSE;   // Were done.
            }
        }
        if ( S_FALSE == hr )
            hr = S_OK;  // Reached end of domain enumeration
    }
    if ( NULL != pIDomain )
        pIDomain->Release();

    // Cleanup
    if( INVALID_SOCKET != socket )
    {
        // SMTP:QUIT
        HRESULT hr2 = SendRecv( socket, SMTP_QUIT, strlen( SMTP_QUIT ), SMTP_MSG221 ); 
        if ( S_OK == hr ) hr = hr2;
        iErr = closesocket( socket );
        if ( 0 != iErr ) LOG( L"ERROR!: closesocket. %s", CFormatMessage(iErr).c_str() );
        assert( 0 == iErr );
    }
    if ( 0 != wsaData.wVersion )
    {
        iErr = WSACleanup( );
        if ( 0 != iErr ) LOG( L"ERROR!: WSACleanup. %s", CFormatMessage(iErr).c_str() );
        assert( 0 == iErr );
    }
    
    if ( S_OK == hr )
    {
        PrintMessage( IDS_SUCCESS_SENDMAIL );
        if ( bErrors )
            PrintMessage( IDS_WARNING_ERRORSIGNORED );
    }
    else
        PrintMessage( IDS_ERROR_SENDMAIL_FAILED );
    
    if ( bUnregisterDependencies )
        UnRegisterDependencies();

    return hr;
}

#define FROMFIELD       "\r\nfrom:"
#define FROMFIELDEND    "\r\n"
#define EOH             "\r\n\r\n"

HRESULT CP2EWorker::GetMailFROM( LPCWSTR sFileName, ASTRING &sFrom )
{
    HRESULT hr = S_OK;
    bool isThereMoreToRead = true, isFromComplete = false;
    char sBuffer[LOCAL_FILE_BUFFER_SIZE+1];
    DWORD dwBytesToRead, dwBytesRead;
    LPSTR ps, psEOH, psFrom;
    DWORD dwStart;
    ASTRING sFromFULL;
    
    HANDLE hFile = CreateFile( sFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL );
    if ( INVALID_HANDLE_VALUE == hFile )
        hr = HRESULT_FROM_WIN32( GetLastError() );
    
    // Read till we find the "\r\nFrom:"
    dwStart = strlen( FROMFIELD );
    dwBytesToRead = LOCAL_FILE_BUFFER_SIZE - dwStart;
    if( ReadFile( hFile, sBuffer, LOCAL_FILE_BUFFER_SIZE, &dwBytesRead, NULL) )
        sBuffer[dwBytesRead] = 0;
    else
        hr = HRESULT_FROM_WIN32( GetLastError() );
    while( isThereMoreToRead && S_OK == hr )
    {
        if( dwBytesRead < dwBytesToRead )
            isThereMoreToRead = false;
        _strlwr( sBuffer );
        ps = sBuffer;
        psEOH = strstr( ps, EOH );
        if ( NULL != psEOH )
        {
            *psEOH = 0;
            isThereMoreToRead = false;
        }
        psFrom = strstr( ps, FROMFIELD );
        if ( NULL != psFrom )
        {   // Found the From Field, do we have it all?
            psFrom += strlen( FROMFIELD );
            ps = strstr( psFrom, FROMFIELDEND );
            if ( NULL != ps )
            {
                *ps = 0;
                isFromComplete = true;
            }
            sFromFULL = psFrom;
            isThereMoreToRead = false;
        }
        if ( isThereMoreToRead )
        {   // Copy end of buffer to beginning (to handle wrap around) then continue
            memcpy( sBuffer, &(sBuffer[dwBytesToRead]), dwStart );
            if( ReadFile( hFile, &(sBuffer[dwStart]), dwBytesToRead, &dwBytesRead, NULL) )
                sBuffer[dwBytesRead + dwStart] = 0;
            else
                hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    if ( !isFromComplete && NULL != psFrom )
    {   // Should be able to get rest of FROM with next read
        // Copy end of buffer to beginning (to handle wrap around) then continue
        memcpy( sBuffer, &(sBuffer[dwBytesToRead]), dwStart );
        if( ReadFile( hFile, &(sBuffer[dwStart]), dwBytesToRead, &dwBytesRead, NULL) )
        {
            sBuffer[dwBytesRead + dwStart] = 0;
            ps = strstr( sBuffer, FROMFIELDEND );
            if ( NULL != ps )
            {
                *ps = 0;
                if ( ps > &(sBuffer[dwStart]) )
                    sFromFULL += sBuffer[dwStart];
                else
                {   // cleanup sFrom
                    ASTRING::size_type iPos = sFromFULL.find( '\r' );
                    if ( ASTRING::npos != iPos )
                        sFromFULL.resize( iPos );
                }
            }
        }
        else
            hr = HRESULT_FROM_WIN32( GetLastError() );
    }  
    if ( !sFromFULL.empty() && S_OK == hr ) 
    {   // Look for the open bracket
        ASTRING::size_type iStart = sFromFULL.find( '<' );
        ASTRING::size_type iEnd = sFromFULL.find( '>' );
        if ( WSTRING::npos != iStart ) 
        {
            if ( ASTRING::npos != iEnd )
                sFrom = sFromFULL.substr( iStart + 1, iEnd - iStart - 1 );
        }        
        else
            sFrom = sFromFULL;
    }
    if ( INVALID_HANDLE_VALUE != hFile )
        CloseHandle( hFile );
    
    return hr;
}

void CP2EWorker::PrintError( int iRC )
{
    if ( m_bSuppressPrintError || (E_FAIL == iRC) )
    {
        m_bSuppressPrintError = false;
        return;
    }
    LPVOID lpMsgBuf;

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, iRC, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), reinterpret_cast<LPWSTR>( &lpMsgBuf ), 0, NULL ))
    {
        wprintf( reinterpret_cast<LPWSTR>( lpMsgBuf ) ); 
        LocalFree( lpMsgBuf );
    }
    else
    {
        WCHAR sBuffer[32];
        
        PrintMessage( IDS_ERROR_UNKNOWN );
        wsprintf( sBuffer, L"%x", iRC );
        PrintMessage( sBuffer );
    }
}

void CP2EWorker::PrintMessage( LPWSTR psMessage, bool bCRLF /*= true*/ )
{
    wprintf( psMessage ); 
    if ( bCRLF )
        wprintf( L"\r\n" ); 
}

void CP2EWorker::PrintMessage( int iID, bool bCRLF /*= true*/ )
{
    WCHAR sBuffer[512];
    
    if ( LoadString( NULL, iID, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) ))
        PrintMessage( sBuffer, bCRLF );
    else
        assert( false );
}
    
void CP2EWorker::PrintUsage()
{
    WCHAR sBuffer[512];

    for ( int i = IDS_POP2EXCH_USAGE1; i < IDS_POP2EXCH_USAGEEND; i++ )
    {
        if ( LoadString( NULL, i, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) ))
        {
            if ( IDS_POP2EXCH_USAGE2 == i )
            {
                WCHAR sBuffer2[512];
                
                if ( 0 > _snwprintf( sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR), sBuffer, POP3_SERVER_NAME_L ))
                    sBuffer2[(sizeof( sBuffer2 )/sizeof(WCHAR))-1] = 0;
                wcscpy( sBuffer, sBuffer2 );
            }
            wprintf( sBuffer );
        }
    }
}

LPWSTR CP2EWorker::FormatLogString( LPWSTR psLogString )
{
    if ( NULL == psLogString )
        return psLogString;

    LPWSTR psCRLF = wcsstr( psLogString, L"\r\n" );
    
    while ( NULL != psCRLF )
    {
        *psCRLF = L' ';
        *(psCRLF+1) = L' ';
        psCRLF = wcsstr( psLogString, L"\r\n" );
    }

    return psLogString;
}

HRESULT CP2EWorker::RecvResp( SOCKET socket, LPCSTR psExpectedResp )
{
    if ( NULL == psExpectedResp )
        return E_INVALIDARG;
    if ( 3 > strlen( psExpectedResp ))
        return E_INVALIDARG;
    
    CHAR sRecvBuffer[SMTP_BUFFERSIZE + 1];
    
    USES_CONVERSION;
    HRESULT hr = S_OK;
    int     iErr;
    
    iErr = recv( socket, sRecvBuffer, SMTP_BUFFERSIZE, 0 );
    if ( SOCKET_ERROR != iErr )
    {
        sRecvBuffer[iErr] = 0;
        if ( (3 > iErr) || (0 != strncmp( sRecvBuffer, psExpectedResp, 3 )))
            hr = E_UNEXPECTED;
        LPWSTR ps = FormatLogString( A2W( sRecvBuffer ));
        LOG( L"recv [%s].", ps );
    }
    else
    {
        iErr = WSAGetLastError();
        hr = HRESULT_FROM_WIN32( iErr );
        LOG( L"ERROR!: recv failed. %s", CFormatMessage(iErr).c_str() );
    }
    
    return hr;
}

HRESULT CP2EWorker::RegisterDependencies()
{
    HRESULT hr = S_OK;
    HMODULE hDLL;
    HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
    tstring strPath = _T("") ;

    strPath = GetModulePath () ;
    if ( strPath != _T("") )
        strPath = strPath + _T("P3Admin.dll") ;
    else
        hr = E_FAIL ;

    if ( S_OK == hr )
    {
        hDLL = LoadLibrary( strPath.c_str() );
        if ( hDLL )
        {
            (FARPROC&)lpDllEntryPoint = GetProcAddress(hDLL,"DllRegisterServer");
            if (lpDllEntryPoint != NULL) 
                hr = (*lpDllEntryPoint)();
            else
                hr = HRESULT_FROM_WIN32(GetLastError());
            FreeLibrary( hDLL );
        }
        else
        {
            PrintMessage( IDS_ERROR_MUSTBERUNFROMCURDIR );
            hr = HRESULT_FROM_WIN32(GetLastError());
            m_bSuppressPrintError = true;
        }
    }
    if ( S_OK == hr )
    {
        CComPtr<IP3Config> spIConfig;
        WCHAR sBuffer[MAX_PATH+1];
        
        hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
        if ( S_OK == hr )
        {
            DWORD dwRC = GetCurrentDirectoryW( sizeof(sBuffer)/sizeof(WCHAR), sBuffer );
            if (( 0 != dwRC ) && ( (sizeof(sBuffer)/sizeof(WCHAR)) > dwRC ))
            {
                HKEY hKey;

                long lRC = RegCreateKey( HKEY_LOCAL_MACHINE, POP3SERVER_SOFTWARE_SUBKEY, &hKey );
                if ( ERROR_SUCCESS == lRC )
                {
                    lRC = RegSetDWORD( POP3SERVER_SOFTWARE_SUBKEY, VALUENAME_VERSION, 0 );
                    if ( ERROR_SUCCESS != lRC )
                        hr = HRESULT_FROM_WIN32( lRC );
                    RegCloseKey( hKey );
                }
                else
                    hr = HRESULT_FROM_WIN32( lRC );
                if ( S_OK == hr )
                {
                    _bstr_t _bstrMailRoot = sBuffer;
                    hr = spIConfig->put_MailRoot( _bstrMailRoot );
                }
            }
            else
                hr = E_FAIL;
        }
    }
    if ( S_OK != hr )
    {
        UnRegisterDependencies () ;
    }
    
    return hr;
}

HRESULT CP2EWorker::SendRecv( SOCKET socket, LPCSTR psSendBuffer, const int iSize, LPCSTR psExpectedResp  )
{
    if ( NULL == psSendBuffer )
        return E_INVALIDARG;

    USES_CONVERSION;
    HRESULT hr = S_OK;
    int     iErr;
    LPWSTR ps = FormatLogString( A2W( psSendBuffer ));
    
    iErr = send( socket, psSendBuffer, iSize, 0 );
    if ( SOCKET_ERROR != iErr )
    {
        LOG( L"send [%s].", ps );
    }
    else
    {
        iErr = WSAGetLastError();
        hr = HRESULT_FROM_WIN32( iErr );
        LOG( L"ERROR!: send [%s] failed. %s", ps, CFormatMessage(iErr).c_str() );
    }
    if ( S_OK == hr )
    {
        hr = RecvResp( socket, psExpectedResp );
    }
    
    return hr;
}

HRESULT CP2EWorker::UnRegisterDependencies()
{
    HRESULT hr = S_OK;
    HMODULE hDLL;
    HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
    tstring strPath = _T("") ;

    strPath = GetModulePath () ;
    if ( strPath != _T("") )
        strPath = strPath + _T("P3Admin.dll") ;
    else
        hr = E_FAIL ;

    if ( S_OK == hr )
    {
        hDLL = LoadLibrary( strPath.c_str() );
        if ( hDLL )
        {
            (FARPROC&)lpDllEntryPoint = GetProcAddress(hDLL,"DllUnregisterServer");
            if (lpDllEntryPoint != NULL) 
                hr = (*lpDllEntryPoint)();
            else
                hr = HRESULT_FROM_WIN32(GetLastError());
            FreeLibrary( hDLL );
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    if ( S_OK == hr )
    {
        long lRC = RegDeleteKey( HKEY_LOCAL_MACHINE, POP3SERVER_SOFTWARE_SUBKEY );
        if ( ERROR_SUCCESS != lRC )
            hr = HRESULT_FROM_WIN32( lRC );
    }
    
    return hr;
}

tstring CP2EWorker::GetModulePath ()
{
    tstring strDir = _T("");
    TCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT] ;
    DWORD dwSize = MAX_PATH;
    TCHAR *szPath = new TCHAR[dwSize+1];
    if (!szPath)
        return strDir;

    // Allocate more space if necessary
    while( dwSize == GetModuleFileName( NULL, szPath, dwSize ) )
    {
        delete [] szPath;
        dwSize *= 2;
        szPath = new TCHAR[dwSize+1];
        if (!szPath)
            return strDir;
    }

    _tsplitpath ( szPath, szDrive, szDir, szFName, szExt ) ;
    _tmakepath ( szPath, szDrive, szDir, _T(""), _T("") ) ;	// Make the path without filename and extension.

    if (_tcslen( szPath ))
        strDir = szPath;

    if ( szPath[_tcslen(szPath)-1] != '\\' )
        strDir = strDir + _T("\\") ;

    delete [] szPath;
    return strDir;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Pop2Exch.rc
//
#define IDS_POP2EXCH_USAGE1               201
#define IDS_POP2EXCH_USAGE2               202
#define IDS_POP2EXCH_USAGE3               203
#define IDS_POP2EXCH_USAGE4               204
#define IDS_POP2EXCH_USAGE5               205
#define IDS_POP2EXCH_USAGE6               206
#define IDS_POP2EXCH_USAGE7               207
#define IDS_POP2EXCH_USAGE8               208
#define IDS_POP2EXCH_USAGE9               209
#define IDS_POP2EXCH_USAGE10              210
#define IDS_POP2EXCH_USAGE11              211
#define IDS_POP2EXCH_USAGE12              212
#define IDS_POP2EXCH_USAGE13              213
#define IDS_POP2EXCH_USAGE14              214
#define IDS_POP2EXCH_USAGE15              215
#define IDS_POP2EXCH_USAGEEND             213

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\p2eworker.h ===
// P2EWorker.h: interface for the CP2EWorker class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_P2EWORKER_H__E31CD929_FC30_413D_9944_E6991AFB61DE__INCLUDED_)
#define AFX_P2EWORKER_H__E31CD929_FC30_413D_9944_E6991AFB61DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <winsock2.h>
#include <sbs6base.h>

class CP2EWorker  
{
public:
    CP2EWorker();
    virtual ~CP2EWorker();

// Implementation
public: 
    int CreateUser( int argc, wchar_t *argv[], const bool bCreateUser, const bool bCreateMailbox );
    int Mail( int argc, wchar_t *argv[], const bool bDelete = false );
    
    void PrintError( int iRC );
    void PrintMessage( LPWSTR psMessage, bool bCRLF = true );
    void PrintMessage( int iID, bool bCRLF = true );
    void PrintUsage();

protected:
    LPWSTR FormatLogString( LPWSTR psLogString );
    HRESULT GetMailFROM( LPCWSTR sFilename, ASTRING &sFrom );
    HRESULT RecvResp( SOCKET socket, LPCSTR psExpectedResp );
    HRESULT RegisterDependencies();
    HRESULT SendRecv( SOCKET socket, LPCSTR psSendBuffer, const int iSize, LPCSTR psExpectedResp );
    HRESULT UnRegisterDependencies();
	tstring GetModulePath ();
    
// Attributes
protected:
    bool m_bSuppressPrintError;
};

#endif // !defined(AFX_P2EWORKER_H__E31CD929_FC30_413D_9944_E6991AFB61DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  Pop2Exch.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\resource2.h ===
#define IDS_SUCCESS_CREATEUSER                  5000
#define IDS_SUCCESS_CREATEMAILBOX               5001
#define IDS_SUCCESS_SENDMAIL                    5002
#define IDS_WARNING_ERRORSIGNORED               5100

#define IDS_ERROR_UNKNOWN                       5200
#define IDS_ERROR_CREATEUSER_FAILED             5201
#define IDS_ERROR_CREATEMAILBOX_FAILED          5202
#define IDS_ERROR_SENDMAIL_FAILED               5203
#define IDS_ERROR_MUSTBERUNFROMCURDIR           5250
#define IDS_ERROR_POP3REQUIRED                  5251
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1F9875FD_4BBB_4DAC_B762_24FB8A5718E1__INCLUDED_)
#define AFX_STDAFX_H__1F9875FD_4BBB_4DAC_B762_24FB8A5718E1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400 // DKB
#endif
#include <windows.h>

#include <assert.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1F9875FD_4BBB_4DAC_B762_24FB8A5718E1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\userinfo.h ===
// UserInfo.h: interface for the CUserInfo class.
// Adapted from the CUserInfo class in the SBS Add User wizard
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_USERINFO_H__E31CD929_FC30_413D_9944_E6991AFB61DE__INCLUDED_)
#define AFX_USERINFO_H__E31CD929_FC30_413D_9944_E6991AFB61DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CUserInfo
{
    public:
        CUserInfo();
        virtual ~CUserInfo();

        HRESULT CreateAccount();
        HRESULT CreateMailbox();
        HRESULT SetPasswd();
        HRESULT SetPassword( LPCTSTR szPassword );
        TSTRING GetUserName() { return m_csUserName; }
        HRESULT SetUserName( LPCTSTR szUserName );
        
    private:

        HRESULT CreateLoginScript();
        HRESULT SetUserLoginScript();
        HRESULT UpdateUserLoginScript(LPCTSTR pszScript);


        TSTRING m_csUserOU;
        TSTRING m_csUserName;
        TSTRING m_csUserCN;
        TSTRING m_csPasswd;
        TSTRING m_csUserNamePre2k;
        TSTRING m_csFirstName;
        TSTRING m_csLastName;
        TSTRING m_csFullName;
        TSTRING m_csTelephone;
        TSTRING m_csOffice;
        TSTRING m_csDesc;
        TSTRING m_csHomePath;
        TSTRING m_csHomeDrive;
        DWORD   m_dwAccountOptions;
        
        TSTRING m_csLogonDns;

        TSTRING m_csSBSServer;
        TSTRING m_csDomainName;
        TSTRING m_csFQDomainName;
        
        BOOL    m_bCreateMB;
        TSTRING m_csEXAlias;
        TSTRING m_csEXServer;
        TSTRING m_csEXHomeServer;
        TSTRING m_csEXHomeMDB;
        
        TSTRING EmailAddr;
};

#endif // !defined(AFX_USERINFO_H__E31CD929_FC30_413D_9944_E6991AFB61DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\userinfo.cpp ===
// UserInfo.cpp: implementation of the CUserInfo class.
// Adapted from the CUserInfo class in the SBS Add User wizard
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <sbs6base.h>
#include "UserInfo.h"

#include <atlbase.h>
#include <comdef.h>
#include <dsgetdc.h>
#include <iads.h>   // Must come before adshlp.h
#include <adshlp.h>
#include <lm.h>
#include <emolib.h>

#include <AUsrUtil.h>

#ifndef ASSERT
#define ASSERT assert
#endif
#ifndef WSTRING
typedef std::wstring WSTRING;   // Move to sbs6base.h
#endif

#ifndef CHECK_HR
#define CHECK_HR( x ) CHECK_HR_RET( x, _hr );
#define CHECK_HR_RET( x, y ) \
{ \
    HRESULT _hr = x; \
    if( FAILED(_hr) ) \
    { \
        ASSERT( !_T("CHECK_HR_RET() failed.  calling TRACE() with HRESULT and statement") ); \
        /*::AfxTrace( _T("CHECK_HR_RET() failed, hr == [%d], statement = [%s], returning [%s]"), _hr, #x, #y );*/ \
        return y; \
    } \
}
#endif	// CHECK_HR

// Defines for account flags.
#define PASSWD_NOCHANGE     0x01
#define PASSWD_CANCHANGE    0x02
#define PASSWD_MUSTCHANGE   0x04
#define ACCOUNT_DISABLED    0x10

// ****************************************************************************                                                        
// CUserInfo
// ****************************************************************************                                                        

// ----------------------------------------------------------------------------
// CUserInfo()
// 
// Constructor.
// ----------------------------------------------------------------------------
CUserInfo::CUserInfo() 
{
    m_dwAccountOptions  = 0;
    m_bCreateMB         = TRUE;

    // Store the SBS Server Name
    TCHAR szServer[MAX_PATH+1] = {0};
    DWORD dwLen = MAX_PATH;
    GetComputerName(szServer, &dwLen);
    m_csSBSServer = szServer;

    // Get domain controller name
    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    HRESULT hr = DsGetDcName (NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED, &DomainControllerInfo);
    ASSERT(hr == S_OK && "DsGetDcName failed");

    // cache the domain
    if ( DomainControllerInfo )
    {
        m_csDomainName = DomainControllerInfo->DomainName;

        // free memory
        NetApiBufferFree (DomainControllerInfo);
    }

    // convert from '.' separated names to Dc=xxx,DC=yyy,... format
    WSTRING tmpDomain = m_csDomainName;
    while ( !tmpDomain.empty() )
    {
        int nPos = tmpDomain.find(_T("."));
        if ( nPos == WSTRING::npos )
        {
            nPos = tmpDomain.length();
        }

        if ( !m_csFQDomainName.empty() )
        {
            m_csFQDomainName += _T(",");
        }

        m_csFQDomainName += _T("DC=");
        m_csFQDomainName += tmpDomain.substr( 0, nPos );

        tmpDomain.erase( 0, nPos + 1 );
    } 
}

CUserInfo::~CUserInfo() 
{
    for ( int i = 0 ; i < m_csPasswd.length() ; i++ )
        m_csPasswd[i] = '\0' ;
    if ( 0 < m_csPasswd.length()) m_csPasswd[0] = NULL ;
           // Make sure that the last operation on the string isn't the origonal assignment.
           // The compiler will optimize the last statement out 
           //  if it is an assignment that doesn't get used.
}

// ----------------------------------------------------------------------------
// CreateAccount()
// 
// Makes a new user account in the Active Directory.
// ----------------------------------------------------------------------------
HRESULT CUserInfo::CreateAccount()
{
    HRESULT hr  = S_OK;
    BOOL    bRO = TRUE;
    _bstr_t _bstr;
    _bstr_t _bstrClass;
    _bstr_t _bstrProperty;

    _variant_t _vTmpVal;
    CComPtr<IADsContainer> spADsContainer = NULL;

    // Bind to the container.
    WSTRING csLdapUserOU;
    if ( _tcsstr( m_csUserOU.c_str(), L"LDAP://") )
        csLdapUserOU = m_csUserOU.c_str();
    else
    {
        if ( m_csUserOU.empty() )
        {
            csLdapUserOU = L"LDAP://CN=Users," + m_csFQDomainName;
            m_csUserOU = csLdapUserOU;
        }
        else
            csLdapUserOU = L"LDAP://" + m_csUserOU;
    }
    hr = ::ADsGetObject( csLdapUserOU.c_str(), IID_IADsContainer, (VOID**) &spADsContainer );
    if ( FAILED(hr) )
        return(hr);

    // Create the user account.
    CComPtr<IDispatch> spDisp = NULL;
    _bstr = m_csUserCN.c_str();
    _bstrClass = L"user";
    hr = spADsContainer->Create( _bstrClass, _bstr, &spDisp );
    if ( FAILED(hr) )
    {
        ASSERT(FALSE);
        return(hr);
    }

//    m_pCmt->m_csADName = L"LDAP://";
//    m_pCmt->m_csADName += m_csUserCN;
//    m_pCmt->m_csADName += L",";
//    m_pCmt->m_csADName += (LPCTSTR)csLdapUserOU+7;

    // Use this new account and set it's properties (e.g. first name, home folder, etc.).
    CComQIPtr<IADsUser, &IID_IADsUser> spADsUserObj(spDisp);
    if ( !spADsUserObj )
    {
        ASSERT(FALSE);
        return(E_FAIL);
    }

    TCHAR   szTmp[MAX_PATH*4] = {0};
    LdapToDCName( csLdapUserOU.c_str(), szTmp, (MAX_PATH*4));
    WSTRING csUserPrincName = m_csUserName;
    csUserPrincName += L"@";
    csUserPrincName += szTmp;
    EmailAddr = csUserPrincName;

    // Username:    
    _vTmpVal.Clear();
    _vTmpVal = ( csUserPrincName.c_str() );
    _bstrProperty = L"userPrincipalName";
    if ( FAILED(spADsUserObj->Put( _bstrProperty, _vTmpVal )) )
    {
        ASSERT(FALSE);
        return(E_FAIL);
    }

    // Pre-Win2000 username:    
    _vTmpVal.Clear();
    _vTmpVal = ( _tcslen( m_csUserNamePre2k.c_str() ) ? m_csUserNamePre2k.c_str() : m_csUserName.c_str() );
    _bstrProperty = L"sAMAccountName";
    if ( FAILED(spADsUserObj->Put( _bstrProperty, _vTmpVal )) )
    {
        ASSERT(FALSE);
        return(E_FAIL);
    }

    // Use UserName instead
    _bstr = m_csUserName.c_str();
    if ( FAILED( spADsUserObj->put_FullName( _bstr )))
    {
        ASSERT(FALSE);
        return(E_FAIL);
    }

    // Display Name     
    _vTmpVal.Clear();
    _vTmpVal = m_csUserName.c_str();
    _bstrProperty = L"displayName";
    if ( FAILED(spADsUserObj->Put( _bstrProperty, _vTmpVal )) )
    {
        ASSERT(FALSE);
        return(E_FAIL);
    }

    // Commit this information to the AD.
    CHECK_HR( spADsUserObj->SetInfo() );
    
    // Password expired?
    _vTmpVal.Clear();
    V_VT( &_vTmpVal ) = VT_I4;
    V_I4( &_vTmpVal ) = (m_dwAccountOptions & PASSWD_MUSTCHANGE) ? 0 : -1;
    _bstrProperty = L"pwdLastSet";
    if ( FAILED(spADsUserObj->Put( _bstrProperty, _vTmpVal )) )
    {
        ASSERT(FALSE);
    }

    // Account disabled?
    _vTmpVal.Clear();
    _bstrProperty = L"userAccountControl";
    if ( FAILED(spADsUserObj->Get( _bstrProperty, &_vTmpVal )) )
    {
        ASSERT(FALSE);
    }
    else
    {
        _vTmpVal.lVal &= ~UF_PASSWD_NOTREQD;            // Make passwd required.
        if ( m_dwAccountOptions & ACCOUNT_DISABLED )    // Do we want to disable the account?
            _vTmpVal.lVal |= UF_ACCOUNTDISABLE;
        else
            _vTmpVal.lVal &= ~UF_ACCOUNTDISABLE;       // ..not disable the account.
        if ( FAILED(spADsUserObj->Put( _bstrProperty, _vTmpVal )) )
        {
            ASSERT(FALSE);
        }
    }

    // Set the password.
    hr = SetPasswd();
    if ( FAILED( hr ))
    {
//        m_pCmt->SetErrorResults(ERROR_PASSWORD);

        _vTmpVal.Clear();
        _bstrProperty = L"userAccountControl";
        if ( FAILED(spADsUserObj->Get( _bstrProperty, &_vTmpVal )) )
        {
            ASSERT(FALSE);
        }
        else
        {
            _vTmpVal.lVal &= ~UF_PASSWD_NOTREQD;            // Make passwd required.
            _vTmpVal.lVal |= UF_ACCOUNTDISABLE;             // Disable the account.
    
            if ( FAILED(spADsUserObj->Put( _bstrProperty, _vTmpVal )) )
            {
                ASSERT(FALSE);
            }
        }

        // Commit this information to the AD.
        if ( FAILED( spADsUserObj->SetInfo() ))
        {
            ASSERT(FALSE);
        }

        return hr;
    }

    // Commit this information to the AD.
    hr = spADsUserObj->SetInfo();
    if ( FAILED( hr ))
    {
        ASSERT(FALSE);
    }

    return hr;
}

// ----------------------------------------------------------------------------
// CreateMailbox()
// 
// Makes a new exchange mailbox for the user.
// ----------------------------------------------------------------------------
HRESULT CUserInfo::CreateMailbox()
{
    HRESULT hr = S_OK;

    CComVariant _vTmpVal;
    CComPtr<IADsContainer> spADsContainer = NULL;
    _bstr_t _bstr;
    _bstr_t _bstrClass;

    if ( 0 == m_csEXHomeMDB.length() )
    {
        hr = GetMDBPath( m_csEXHomeMDB );
        if FAILED( hr )
            return hr;
    }

    // Do we even need to run?
    if ( 0 == m_csEXHomeMDB.length() || 0 == m_csEXAlias.length() )
        return(hr);

    // Bind to the container.
    WSTRING csLdapUserOU = L"LDAP://";
    if ( _tcsstr( m_csUserOU.c_str(), L"LDAP://") )
        csLdapUserOU = m_csUserOU.c_str();
    else
    {
        if ( m_csUserOU.empty() )
        {
            csLdapUserOU = L"LDAP://CN=Users," + m_csFQDomainName;
            m_csUserOU = csLdapUserOU;
        }
        else
            csLdapUserOU = L"LDAP://" + m_csUserOU;
    }
    hr = ::ADsGetObject( csLdapUserOU.c_str(), IID_IADsContainer, (VOID**) &spADsContainer );
    if ( FAILED(hr) || !spADsContainer )
    {
        ASSERT(FALSE);
        return(hr);
    }

    // Open the user account.
    CComPtr<IDispatch> spDisp = NULL;
    _bstr = m_csUserCN.c_str();
    _bstrClass = L"user";
    hr = spADsContainer->GetObject( _bstrClass, _bstr, &spDisp );
    //    if ( !spDisp )              // If the user doesn't exist, create it.
    //        hr = spADsContainer->Create( L"user", (LPWSTR)(LPCWSTR)m_csUserCN, &spDisp );
    //        return(hr);     // Let's just return..   maybe we'll want to change to create later?
    if ( !spDisp )              // Was there a problem getting the account (either existing or new)?
    {
        ASSERT(FALSE);
        return(hr);
    }

    // Get a handle on the user.
    CComPtr<IADsUser> spADsUserObj;
    hr = spDisp->QueryInterface ( __uuidof(IADsUser), (void**)&spADsUserObj );

    if ( FAILED(hr) || !spADsUserObj )        // Was there a problem getting the user object?
    {
        ASSERT(FALSE);
        return(hr);
    }

    // Get the interface needed to deal with the mailbox.
    CComPtr<IMailboxStore> spMailboxStore;
    hr = spADsUserObj->QueryInterface ( __uuidof(IMailboxStore), (void**)&spMailboxStore );

    if ( FAILED(hr) || !spMailboxStore )      // Was there a problem getting the mailbox store interface?
    {
        ASSERT(FALSE);
        return(hr);
    }

//    if ( SUCCEEDED( hr ) )
//    {   // Need to set the mailNickname first otherwise the alias will always be manufactured from the name.
//        m_csEXAlias = CreateEmailName( m_csEXAlias );
//        m_csEXAlias.TrimLeft();
//        m_csEXAlias.TrimRight();
//        if ( 0 == m_csEXAlias.length( ) )
//        {
//            m_csEXAlias.LoadString( IDS_NOLOC_USEREMAILALIAS );
//        }
//
//        CComBSTR  bszTmp = (LPCTSTR) m_csEXAlias;
//        VARIANT  v;
//
//        VariantInit( &v );
//        V_VT( &v ) = VT_BSTR;
//        V_BSTR( &v ) = bszTmp;
//        hr = spADsUserObj->Put( L"mailNickname", v );
//    }

    if ( SUCCEEDED( hr ) )
    {   // Create the mailbox.
        WSTRING csLdapHomeMDB = L"LDAP://";
        csLdapHomeMDB += m_csEXHomeMDB;
        _bstr = csLdapHomeMDB.c_str();
        hr = spMailboxStore->CreateMailbox( _bstr );

        if ( hr == S_OK )                                       // If it's a new mailbox, set the info.
        {
            hr = spADsUserObj->SetInfo();
        }

        if ( HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS )  // If it already exists, just move on.
        {
            hr = S_OK;
        }
    }

    if ( FAILED(hr) )                                   // Was there a problem?
    {
        ASSERT(FALSE);
        return(hr);
    }

    return(hr);
}

// ----------------------------------------------------------------------------
// SetPasswd()
// ----------------------------------------------------------------------------
HRESULT CUserInfo::SetPasswd()
{
    HRESULT  hr     = S_OK;    
    WSTRING  csUser = _T("LDAP://");
    
    if ( _tcsstr( m_csUserOU.c_str(), _T("LDAP://")) )
    {                
        csUser += m_csUserCN;
        csUser += _T(",");
        csUser += m_csUserOU.c_str() + 7;
    }
    else
    {        
        csUser += m_csUserCN;
        csUser += _T(",");
        csUser += m_csUserOU.c_str();
    }    
           
    // Now csUser is something like "LDAP://CN=JohnDoe,DC=Blah"
    CComPtr<IADsUser> spDS = NULL;
    hr = ::ADsGetObject( csUser.c_str(), IID_IADsUser, (void**)&spDS );
    CHECK_HR(hr);
        
    // Set the password.
    if ( m_csPasswd.length() )                 // Only if there IS a passwd!
    {
        CComBSTR bszPasswd = m_csPasswd.c_str();

        hr = spDS->SetPassword(bszPasswd);
        CHECK_HR(hr);
    }

    // Allow change?
    if ( m_dwAccountOptions & PASSWD_NOCHANGE )
    {
        CComVariant vaTmpVal;
        CComBSTR    bstrProp = _T("UserFlags");

        vaTmpVal.Clear();        
        hr = spDS->Get( bstrProp, &vaTmpVal );
        CHECK_HR(hr);
            
        vaTmpVal.lVal |= UF_PASSWD_CANT_CHANGE;        
        
        hr = spDS->Put( bstrProp, vaTmpVal );
        CHECK_HR(hr);
    }
    
    // SetInfo only if we actually changed anything.
    if ( ( m_csPasswd.length()) ||            // Did we mess with the passwd?
         ( m_dwAccountOptions & PASSWD_NOCHANGE ) )     // Did we make it unable to change?
    {
        hr = spDS->SetInfo();                           // If either, then set the new info.
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////
// SetUserName
// Set the user name and dependant member variables (m_csUserCN, m_csEXAlias)
/////////////////////////////////////////////////////////////////////////////////////
HRESULT CUserInfo::SetUserName( LPCTSTR szUserName ) 
{ 
    m_csUserName = szUserName;
    m_csUserCN = L"CN=" + m_csUserName;
    m_csEXAlias = szUserName;

    return S_OK; 
}

/////////////////////////////////////////////////////////////////////////////////////
// SetPassword
// Set the Password 
/////////////////////////////////////////////////////////////////////////////////////
HRESULT CUserInfo::SetPassword( LPCTSTR szPassword ) 
{ 
    m_csPasswd = szPassword;

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\inc\emolib.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Mon Nov 01 11:51:36 1999
 */
/* Compiler settings for emolib.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __emolib_h__
#define __emolib_h__

/* Forward Declarations */ 

#ifndef __IMailRecipient_FWD_DEFINED__
#define __IMailRecipient_FWD_DEFINED__
typedef interface IMailRecipient IMailRecipient;
#endif 	/* __IMailRecipient_FWD_DEFINED__ */


#ifndef __IMailboxStore_FWD_DEFINED__
#define __IMailboxStore_FWD_DEFINED__
typedef interface IMailboxStore IMailboxStore;
#endif 	/* __IMailboxStore_FWD_DEFINED__ */


#ifndef __IServer_FWD_DEFINED__
#define __IServer_FWD_DEFINED__
typedef interface IServer IServer;
#endif 	/* __IServer_FWD_DEFINED__ */


#ifndef __IStorageGroup_FWD_DEFINED__
#define __IStorageGroup_FWD_DEFINED__
typedef interface IStorageGroup IStorageGroup;
#endif 	/* __IStorageGroup_FWD_DEFINED__ */


#ifndef __IPublicStoreDB_FWD_DEFINED__
#define __IPublicStoreDB_FWD_DEFINED__
typedef interface IPublicStoreDB IPublicStoreDB;
#endif 	/* __IPublicStoreDB_FWD_DEFINED__ */


#ifndef __IMailboxStoreDB_FWD_DEFINED__
#define __IMailboxStoreDB_FWD_DEFINED__
typedef interface IMailboxStoreDB IMailboxStoreDB;
#endif 	/* __IMailboxStoreDB_FWD_DEFINED__ */


#ifndef __IFolderTree_FWD_DEFINED__
#define __IFolderTree_FWD_DEFINED__
typedef interface IFolderTree IFolderTree;
#endif 	/* __IFolderTree_FWD_DEFINED__ */


#ifndef __MailRecipient_FWD_DEFINED__
#define __MailRecipient_FWD_DEFINED__

#ifdef __cplusplus
typedef class MailRecipient MailRecipient;
#else
typedef struct MailRecipient MailRecipient;
#endif /* __cplusplus */

#endif 	/* __MailRecipient_FWD_DEFINED__ */


#ifndef __Mailbox_FWD_DEFINED__
#define __Mailbox_FWD_DEFINED__

#ifdef __cplusplus
typedef class Mailbox Mailbox;
#else
typedef struct Mailbox Mailbox;
#endif /* __cplusplus */

#endif 	/* __Mailbox_FWD_DEFINED__ */


#ifndef __FolderAdmin_FWD_DEFINED__
#define __FolderAdmin_FWD_DEFINED__

#ifdef __cplusplus
typedef class FolderAdmin FolderAdmin;
#else
typedef struct FolderAdmin FolderAdmin;
#endif /* __cplusplus */

#endif 	/* __FolderAdmin_FWD_DEFINED__ */


#ifndef __Server_FWD_DEFINED__
#define __Server_FWD_DEFINED__

#ifdef __cplusplus
typedef class Server Server;
#else
typedef struct Server Server;
#endif /* __cplusplus */

#endif 	/* __Server_FWD_DEFINED__ */


#ifndef __FolderTree_FWD_DEFINED__
#define __FolderTree_FWD_DEFINED__

#ifdef __cplusplus
typedef class FolderTree FolderTree;
#else
typedef struct FolderTree FolderTree;
#endif /* __cplusplus */

#endif 	/* __FolderTree_FWD_DEFINED__ */


#ifndef __PublicStoreDB_FWD_DEFINED__
#define __PublicStoreDB_FWD_DEFINED__

#ifdef __cplusplus
typedef class PublicStoreDB PublicStoreDB;
#else
typedef struct PublicStoreDB PublicStoreDB;
#endif /* __cplusplus */

#endif 	/* __PublicStoreDB_FWD_DEFINED__ */


#ifndef __MailboxStoreDB_FWD_DEFINED__
#define __MailboxStoreDB_FWD_DEFINED__

#ifdef __cplusplus
typedef class MailboxStoreDB MailboxStoreDB;
#else
typedef struct MailboxStoreDB MailboxStoreDB;
#endif /* __cplusplus */

#endif 	/* __MailboxStoreDB_FWD_DEFINED__ */


#ifndef __StorageGroup_FWD_DEFINED__
#define __StorageGroup_FWD_DEFINED__

#ifdef __cplusplus
typedef class StorageGroup StorageGroup;
#else
typedef struct StorageGroup StorageGroup;
#endif /* __cplusplus */

#endif 	/* __StorageGroup_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_emolib_0000 */
/* [local] */ 

#ifndef NO_CDOEX_H
#define CDO_NO_NAMESPACE
#include "cdoex.h"
#endif


typedef 
enum CDORestrictedAddressType
    {	cdoAccept	= 0,
	cdoReject	= 0x1
    }	CDORestrictedAddressType;

typedef 
enum CDODeliverAndRedirect
    {	cdoRecipientOrForward	= 0,
	cdoDeliverToBoth	= 0x1
    }	CDODeliverAndRedirect;

typedef 
enum CDOStoreDBStatus
    {	cdoOnline	= 0,
	cdoOffline	= 0x1,
	cdoMounting	= 0x2,
	cdoDismounting	= 0x3
    }	CDOStoreDBStatus;

typedef 
enum CDOFolderTreeType
    {	cdoGeneralPurpose	= 0,
	cdoMAPI	= 0x1,
	cdoNNTPOnly	= 0x2
    }	CDOFolderTreeType;

typedef 
enum CDOPriority
    {	cdoLowPriority	= 0,
	cdoNormalPriority	= 0x1,
	cdoHighPriority	= 0x2
    }	CDOPriority;

typedef 
enum CDOServerType
    {	cdoBackEnd	= 0,
	cdoFrontEnd	= 0x1
    }	CDOServerType;



extern RPC_IF_HANDLE __MIDL_itf_emolib_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emolib_0000_v0_0_s_ifspec;


#ifndef __CDOEXM_LIBRARY_DEFINED__
#define __CDOEXM_LIBRARY_DEFINED__

/* library CDOEXM */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CDOEXM;

#ifndef __IMailRecipient_INTERFACE_DEFINED__
#define __IMailRecipient_INTERFACE_DEFINED__

/* interface IMailRecipient */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IMailRecipient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F40-5734-11d2-A593-00C04F990D8A")
    IMailRecipient : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IncomingLimit( 
            /* [retval][out] */ long __RPC_FAR *pIncomingLimit) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_IncomingLimit( 
            /* [in] */ long varIncomingLimit) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OutgoingLimit( 
            /* [retval][out] */ long __RPC_FAR *pOutgoingLimit) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OutgoingLimit( 
            /* [in] */ long varOutgoingLimit) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RestrictedAddressList( 
            /* [retval][out] */ VARIANT __RPC_FAR *pRestrictedAddressList) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_RestrictedAddressList( 
            /* [in] */ VARIANT varRestrictedAddressList) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RestrictedAddresses( 
            /* [retval][out] */ CDORestrictedAddressType __RPC_FAR *pRestrictedAddresses) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_RestrictedAddresses( 
            /* [in] */ CDORestrictedAddressType varRestrictedAddresses) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForwardTo( 
            /* [retval][out] */ BSTR __RPC_FAR *pForwardTo) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ForwardTo( 
            /* [in] */ BSTR varForwardTo) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForwardingStyle( 
            /* [retval][out] */ CDODeliverAndRedirect __RPC_FAR *pForwardingStyle) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ForwardingStyle( 
            /* [in] */ CDODeliverAndRedirect varForwardingStyle) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HideFromAddressBook( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHideFromAddressBook) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HideFromAddressBook( 
            /* [in] */ VARIANT_BOOL varHideFromAddressBook) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_X400Email( 
            /* [retval][out] */ BSTR __RPC_FAR *pX400Email) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_X400Email( 
            /* [in] */ BSTR varX400Email) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SMTPEmail( 
            /* [retval][out] */ BSTR __RPC_FAR *pSMTPEmail) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SMTPEmail( 
            /* [in] */ BSTR varSMTPEmail) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ProxyAddresses( 
            /* [retval][out] */ VARIANT __RPC_FAR *pProxyAddresses) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ProxyAddresses( 
            /* [in] */ VARIANT varProxyAddresses) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Alias( 
            /* [retval][out] */ BSTR __RPC_FAR *pAlias) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Alias( 
            /* [in] */ BSTR varAlias) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TargetAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *varTargetAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MailEnable( 
            /* [optional][in] */ BSTR TargetMailAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MailDisable( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMailRecipientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMailRecipient __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMailRecipient __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMailRecipient __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IncomingLimit )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pIncomingLimit);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IncomingLimit )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ long varIncomingLimit);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OutgoingLimit )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pOutgoingLimit);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OutgoingLimit )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ long varOutgoingLimit);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RestrictedAddressList )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pRestrictedAddressList);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RestrictedAddressList )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ VARIANT varRestrictedAddressList);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RestrictedAddresses )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ CDORestrictedAddressType __RPC_FAR *pRestrictedAddresses);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RestrictedAddresses )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ CDORestrictedAddressType varRestrictedAddresses);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ForwardTo )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pForwardTo);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ForwardTo )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ BSTR varForwardTo);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ForwardingStyle )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ CDODeliverAndRedirect __RPC_FAR *pForwardingStyle);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ForwardingStyle )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ CDODeliverAndRedirect varForwardingStyle);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HideFromAddressBook )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHideFromAddressBook);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HideFromAddressBook )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varHideFromAddressBook);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_X400Email )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pX400Email);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_X400Email )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ BSTR varX400Email);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SMTPEmail )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pSMTPEmail);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SMTPEmail )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ BSTR varSMTPEmail);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProxyAddresses )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pProxyAddresses);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProxyAddresses )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ VARIANT varProxyAddresses);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Alias )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pAlias);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Alias )( 
            IMailRecipient __RPC_FAR * This,
            /* [in] */ BSTR varAlias);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TargetAddress )( 
            IMailRecipient __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varTargetAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MailEnable )( 
            IMailRecipient __RPC_FAR * This,
            /* [optional][in] */ BSTR TargetMailAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MailDisable )( 
            IMailRecipient __RPC_FAR * This);
        
        END_INTERFACE
    } IMailRecipientVtbl;

    interface IMailRecipient
    {
        CONST_VTBL struct IMailRecipientVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMailRecipient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMailRecipient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMailRecipient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMailRecipient_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMailRecipient_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMailRecipient_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMailRecipient_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMailRecipient_get_IncomingLimit(This,pIncomingLimit)	\
    (This)->lpVtbl -> get_IncomingLimit(This,pIncomingLimit)

#define IMailRecipient_put_IncomingLimit(This,varIncomingLimit)	\
    (This)->lpVtbl -> put_IncomingLimit(This,varIncomingLimit)

#define IMailRecipient_get_OutgoingLimit(This,pOutgoingLimit)	\
    (This)->lpVtbl -> get_OutgoingLimit(This,pOutgoingLimit)

#define IMailRecipient_put_OutgoingLimit(This,varOutgoingLimit)	\
    (This)->lpVtbl -> put_OutgoingLimit(This,varOutgoingLimit)

#define IMailRecipient_get_RestrictedAddressList(This,pRestrictedAddressList)	\
    (This)->lpVtbl -> get_RestrictedAddressList(This,pRestrictedAddressList)

#define IMailRecipient_put_RestrictedAddressList(This,varRestrictedAddressList)	\
    (This)->lpVtbl -> put_RestrictedAddressList(This,varRestrictedAddressList)

#define IMailRecipient_get_RestrictedAddresses(This,pRestrictedAddresses)	\
    (This)->lpVtbl -> get_RestrictedAddresses(This,pRestrictedAddresses)

#define IMailRecipient_put_RestrictedAddresses(This,varRestrictedAddresses)	\
    (This)->lpVtbl -> put_RestrictedAddresses(This,varRestrictedAddresses)

#define IMailRecipient_get_ForwardTo(This,pForwardTo)	\
    (This)->lpVtbl -> get_ForwardTo(This,pForwardTo)

#define IMailRecipient_put_ForwardTo(This,varForwardTo)	\
    (This)->lpVtbl -> put_ForwardTo(This,varForwardTo)

#define IMailRecipient_get_ForwardingStyle(This,pForwardingStyle)	\
    (This)->lpVtbl -> get_ForwardingStyle(This,pForwardingStyle)

#define IMailRecipient_put_ForwardingStyle(This,varForwardingStyle)	\
    (This)->lpVtbl -> put_ForwardingStyle(This,varForwardingStyle)

#define IMailRecipient_get_HideFromAddressBook(This,pHideFromAddressBook)	\
    (This)->lpVtbl -> get_HideFromAddressBook(This,pHideFromAddressBook)

#define IMailRecipient_put_HideFromAddressBook(This,varHideFromAddressBook)	\
    (This)->lpVtbl -> put_HideFromAddressBook(This,varHideFromAddressBook)

#define IMailRecipient_get_X400Email(This,pX400Email)	\
    (This)->lpVtbl -> get_X400Email(This,pX400Email)

#define IMailRecipient_put_X400Email(This,varX400Email)	\
    (This)->lpVtbl -> put_X400Email(This,varX400Email)

#define IMailRecipient_get_SMTPEmail(This,pSMTPEmail)	\
    (This)->lpVtbl -> get_SMTPEmail(This,pSMTPEmail)

#define IMailRecipient_put_SMTPEmail(This,varSMTPEmail)	\
    (This)->lpVtbl -> put_SMTPEmail(This,varSMTPEmail)

#define IMailRecipient_get_ProxyAddresses(This,pProxyAddresses)	\
    (This)->lpVtbl -> get_ProxyAddresses(This,pProxyAddresses)

#define IMailRecipient_put_ProxyAddresses(This,varProxyAddresses)	\
    (This)->lpVtbl -> put_ProxyAddresses(This,varProxyAddresses)

#define IMailRecipient_get_Alias(This,pAlias)	\
    (This)->lpVtbl -> get_Alias(This,pAlias)

#define IMailRecipient_put_Alias(This,varAlias)	\
    (This)->lpVtbl -> put_Alias(This,varAlias)

#define IMailRecipient_get_TargetAddress(This,varTargetAddress)	\
    (This)->lpVtbl -> get_TargetAddress(This,varTargetAddress)

#define IMailRecipient_MailEnable(This,TargetMailAddress)	\
    (This)->lpVtbl -> MailEnable(This,TargetMailAddress)

#define IMailRecipient_MailDisable(This)	\
    (This)->lpVtbl -> MailDisable(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_IncomingLimit_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pIncomingLimit);


void __RPC_STUB IMailRecipient_get_IncomingLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_put_IncomingLimit_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [in] */ long varIncomingLimit);


void __RPC_STUB IMailRecipient_put_IncomingLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_OutgoingLimit_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pOutgoingLimit);


void __RPC_STUB IMailRecipient_get_OutgoingLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_put_OutgoingLimit_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [in] */ long varOutgoingLimit);


void __RPC_STUB IMailRecipient_put_OutgoingLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_RestrictedAddressList_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pRestrictedAddressList);


void __RPC_STUB IMailRecipient_get_RestrictedAddressList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_put_RestrictedAddressList_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [in] */ VARIANT varRestrictedAddressList);


void __RPC_STUB IMailRecipient_put_RestrictedAddressList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_RestrictedAddresses_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ CDORestrictedAddressType __RPC_FAR *pRestrictedAddresses);


void __RPC_STUB IMailRecipient_get_RestrictedAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_put_RestrictedAddresses_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [in] */ CDORestrictedAddressType varRestrictedAddresses);


void __RPC_STUB IMailRecipient_put_RestrictedAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_ForwardTo_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pForwardTo);


void __RPC_STUB IMailRecipient_get_ForwardTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_put_ForwardTo_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [in] */ BSTR varForwardTo);


void __RPC_STUB IMailRecipient_put_ForwardTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_ForwardingStyle_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ CDODeliverAndRedirect __RPC_FAR *pForwardingStyle);


void __RPC_STUB IMailRecipient_get_ForwardingStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_put_ForwardingStyle_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [in] */ CDODeliverAndRedirect varForwardingStyle);


void __RPC_STUB IMailRecipient_put_ForwardingStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_HideFromAddressBook_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHideFromAddressBook);


void __RPC_STUB IMailRecipient_get_HideFromAddressBook_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_put_HideFromAddressBook_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varHideFromAddressBook);


void __RPC_STUB IMailRecipient_put_HideFromAddressBook_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_X400Email_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pX400Email);


void __RPC_STUB IMailRecipient_get_X400Email_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_put_X400Email_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [in] */ BSTR varX400Email);


void __RPC_STUB IMailRecipient_put_X400Email_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_SMTPEmail_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pSMTPEmail);


void __RPC_STUB IMailRecipient_get_SMTPEmail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_put_SMTPEmail_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [in] */ BSTR varSMTPEmail);


void __RPC_STUB IMailRecipient_put_SMTPEmail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_ProxyAddresses_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pProxyAddresses);


void __RPC_STUB IMailRecipient_get_ProxyAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_put_ProxyAddresses_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [in] */ VARIANT varProxyAddresses);


void __RPC_STUB IMailRecipient_put_ProxyAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_Alias_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pAlias);


void __RPC_STUB IMailRecipient_get_Alias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_put_Alias_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [in] */ BSTR varAlias);


void __RPC_STUB IMailRecipient_put_Alias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_get_TargetAddress_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varTargetAddress);


void __RPC_STUB IMailRecipient_get_TargetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_MailEnable_Proxy( 
    IMailRecipient __RPC_FAR * This,
    /* [optional][in] */ BSTR TargetMailAddress);


void __RPC_STUB IMailRecipient_MailEnable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailRecipient_MailDisable_Proxy( 
    IMailRecipient __RPC_FAR * This);


void __RPC_STUB IMailRecipient_MailDisable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMailRecipient_INTERFACE_DEFINED__ */


#ifndef __IMailboxStore_INTERFACE_DEFINED__
#define __IMailboxStore_INTERFACE_DEFINED__

/* interface IMailboxStore */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IMailboxStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F41-5734-11d2-A593-00C04F990D8A")
    IMailboxStore : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableStoreDefaults( 
            /* [retval][out] */ VARIANT __RPC_FAR *pEnableStoreDefaults) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableStoreDefaults( 
            /* [in] */ VARIANT varEnableStoreDefaults) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StoreQuota( 
            /* [retval][out] */ long __RPC_FAR *pStoreQuota) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_StoreQuota( 
            /* [in] */ long varStoreQuota) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OverQuotaLimit( 
            /* [retval][out] */ long __RPC_FAR *pOverQuotaLimit) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OverQuotaLimit( 
            /* [in] */ long varOverQuotaLimit) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HardLimit( 
            /* [retval][out] */ long __RPC_FAR *pHardLimit) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HardLimit( 
            /* [in] */ long varHardLimit) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OverrideStoreGarbageCollection( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pOverrideStoreGarbageCollection) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OverrideStoreGarbageCollection( 
            /* [in] */ VARIANT_BOOL varOverrideStoreGarbageCollection) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DaysBeforeGarbageCollection( 
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeGarbageCollection) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DaysBeforeGarbageCollection( 
            /* [in] */ long varDaysBeforeGarbageCollection) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_GarbageCollectOnlyAfterBackup( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pGarbageCollectOnlyAfterBackup) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_GarbageCollectOnlyAfterBackup( 
            /* [in] */ VARIANT_BOOL varGarbageCollectOnlyAfterBackup) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Delegates( 
            /* [retval][out] */ VARIANT __RPC_FAR *pDelegates) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Delegates( 
            /* [in] */ VARIANT varDelegates) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HomeMDB( 
            /* [retval][out] */ BSTR __RPC_FAR *varHomeMDB) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RecipientLimit( 
            /* [retval][out] */ long __RPC_FAR *pRecipientLimit) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_RecipientLimit( 
            /* [in] */ long varRecipientLimit) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateMailbox( 
            /* [in] */ BSTR HomeMDBURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteMailbox( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveMailbox( 
            /* [in] */ BSTR HomeMDBURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMailboxStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMailboxStore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMailboxStore __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMailboxStore __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableStoreDefaults )( 
            IMailboxStore __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pEnableStoreDefaults);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableStoreDefaults )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ VARIANT varEnableStoreDefaults);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StoreQuota )( 
            IMailboxStore __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pStoreQuota);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StoreQuota )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ long varStoreQuota);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OverQuotaLimit )( 
            IMailboxStore __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pOverQuotaLimit);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OverQuotaLimit )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ long varOverQuotaLimit);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HardLimit )( 
            IMailboxStore __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pHardLimit);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HardLimit )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ long varHardLimit);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OverrideStoreGarbageCollection )( 
            IMailboxStore __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pOverrideStoreGarbageCollection);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OverrideStoreGarbageCollection )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varOverrideStoreGarbageCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DaysBeforeGarbageCollection )( 
            IMailboxStore __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeGarbageCollection);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DaysBeforeGarbageCollection )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ long varDaysBeforeGarbageCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GarbageCollectOnlyAfterBackup )( 
            IMailboxStore __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pGarbageCollectOnlyAfterBackup);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GarbageCollectOnlyAfterBackup )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varGarbageCollectOnlyAfterBackup);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Delegates )( 
            IMailboxStore __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pDelegates);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Delegates )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ VARIANT varDelegates);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HomeMDB )( 
            IMailboxStore __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varHomeMDB);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientLimit )( 
            IMailboxStore __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pRecipientLimit);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientLimit )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ long varRecipientLimit);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateMailbox )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ BSTR HomeMDBURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMailbox )( 
            IMailboxStore __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveMailbox )( 
            IMailboxStore __RPC_FAR * This,
            /* [in] */ BSTR HomeMDBURL);
        
        END_INTERFACE
    } IMailboxStoreVtbl;

    interface IMailboxStore
    {
        CONST_VTBL struct IMailboxStoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMailboxStore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMailboxStore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMailboxStore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMailboxStore_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMailboxStore_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMailboxStore_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMailboxStore_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMailboxStore_get_EnableStoreDefaults(This,pEnableStoreDefaults)	\
    (This)->lpVtbl -> get_EnableStoreDefaults(This,pEnableStoreDefaults)

#define IMailboxStore_put_EnableStoreDefaults(This,varEnableStoreDefaults)	\
    (This)->lpVtbl -> put_EnableStoreDefaults(This,varEnableStoreDefaults)

#define IMailboxStore_get_StoreQuota(This,pStoreQuota)	\
    (This)->lpVtbl -> get_StoreQuota(This,pStoreQuota)

#define IMailboxStore_put_StoreQuota(This,varStoreQuota)	\
    (This)->lpVtbl -> put_StoreQuota(This,varStoreQuota)

#define IMailboxStore_get_OverQuotaLimit(This,pOverQuotaLimit)	\
    (This)->lpVtbl -> get_OverQuotaLimit(This,pOverQuotaLimit)

#define IMailboxStore_put_OverQuotaLimit(This,varOverQuotaLimit)	\
    (This)->lpVtbl -> put_OverQuotaLimit(This,varOverQuotaLimit)

#define IMailboxStore_get_HardLimit(This,pHardLimit)	\
    (This)->lpVtbl -> get_HardLimit(This,pHardLimit)

#define IMailboxStore_put_HardLimit(This,varHardLimit)	\
    (This)->lpVtbl -> put_HardLimit(This,varHardLimit)

#define IMailboxStore_get_OverrideStoreGarbageCollection(This,pOverrideStoreGarbageCollection)	\
    (This)->lpVtbl -> get_OverrideStoreGarbageCollection(This,pOverrideStoreGarbageCollection)

#define IMailboxStore_put_OverrideStoreGarbageCollection(This,varOverrideStoreGarbageCollection)	\
    (This)->lpVtbl -> put_OverrideStoreGarbageCollection(This,varOverrideStoreGarbageCollection)

#define IMailboxStore_get_DaysBeforeGarbageCollection(This,pDaysBeforeGarbageCollection)	\
    (This)->lpVtbl -> get_DaysBeforeGarbageCollection(This,pDaysBeforeGarbageCollection)

#define IMailboxStore_put_DaysBeforeGarbageCollection(This,varDaysBeforeGarbageCollection)	\
    (This)->lpVtbl -> put_DaysBeforeGarbageCollection(This,varDaysBeforeGarbageCollection)

#define IMailboxStore_get_GarbageCollectOnlyAfterBackup(This,pGarbageCollectOnlyAfterBackup)	\
    (This)->lpVtbl -> get_GarbageCollectOnlyAfterBackup(This,pGarbageCollectOnlyAfterBackup)

#define IMailboxStore_put_GarbageCollectOnlyAfterBackup(This,varGarbageCollectOnlyAfterBackup)	\
    (This)->lpVtbl -> put_GarbageCollectOnlyAfterBackup(This,varGarbageCollectOnlyAfterBackup)

#define IMailboxStore_get_Delegates(This,pDelegates)	\
    (This)->lpVtbl -> get_Delegates(This,pDelegates)

#define IMailboxStore_put_Delegates(This,varDelegates)	\
    (This)->lpVtbl -> put_Delegates(This,varDelegates)

#define IMailboxStore_get_HomeMDB(This,varHomeMDB)	\
    (This)->lpVtbl -> get_HomeMDB(This,varHomeMDB)

#define IMailboxStore_get_RecipientLimit(This,pRecipientLimit)	\
    (This)->lpVtbl -> get_RecipientLimit(This,pRecipientLimit)

#define IMailboxStore_put_RecipientLimit(This,varRecipientLimit)	\
    (This)->lpVtbl -> put_RecipientLimit(This,varRecipientLimit)

#define IMailboxStore_CreateMailbox(This,HomeMDBURL)	\
    (This)->lpVtbl -> CreateMailbox(This,HomeMDBURL)

#define IMailboxStore_DeleteMailbox(This)	\
    (This)->lpVtbl -> DeleteMailbox(This)

#define IMailboxStore_MoveMailbox(This,HomeMDBURL)	\
    (This)->lpVtbl -> MoveMailbox(This,HomeMDBURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_get_EnableStoreDefaults_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pEnableStoreDefaults);


void __RPC_STUB IMailboxStore_get_EnableStoreDefaults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_put_EnableStoreDefaults_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [in] */ VARIANT varEnableStoreDefaults);


void __RPC_STUB IMailboxStore_put_EnableStoreDefaults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_get_StoreQuota_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pStoreQuota);


void __RPC_STUB IMailboxStore_get_StoreQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_put_StoreQuota_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [in] */ long varStoreQuota);


void __RPC_STUB IMailboxStore_put_StoreQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_get_OverQuotaLimit_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pOverQuotaLimit);


void __RPC_STUB IMailboxStore_get_OverQuotaLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_put_OverQuotaLimit_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [in] */ long varOverQuotaLimit);


void __RPC_STUB IMailboxStore_put_OverQuotaLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_get_HardLimit_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pHardLimit);


void __RPC_STUB IMailboxStore_get_HardLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_put_HardLimit_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [in] */ long varHardLimit);


void __RPC_STUB IMailboxStore_put_HardLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_get_OverrideStoreGarbageCollection_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pOverrideStoreGarbageCollection);


void __RPC_STUB IMailboxStore_get_OverrideStoreGarbageCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_put_OverrideStoreGarbageCollection_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varOverrideStoreGarbageCollection);


void __RPC_STUB IMailboxStore_put_OverrideStoreGarbageCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_get_DaysBeforeGarbageCollection_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pDaysBeforeGarbageCollection);


void __RPC_STUB IMailboxStore_get_DaysBeforeGarbageCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_put_DaysBeforeGarbageCollection_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [in] */ long varDaysBeforeGarbageCollection);


void __RPC_STUB IMailboxStore_put_DaysBeforeGarbageCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_get_GarbageCollectOnlyAfterBackup_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pGarbageCollectOnlyAfterBackup);


void __RPC_STUB IMailboxStore_get_GarbageCollectOnlyAfterBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_put_GarbageCollectOnlyAfterBackup_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varGarbageCollectOnlyAfterBackup);


void __RPC_STUB IMailboxStore_put_GarbageCollectOnlyAfterBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_get_Delegates_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pDelegates);


void __RPC_STUB IMailboxStore_get_Delegates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_put_Delegates_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [in] */ VARIANT varDelegates);


void __RPC_STUB IMailboxStore_put_Delegates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_get_HomeMDB_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varHomeMDB);


void __RPC_STUB IMailboxStore_get_HomeMDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_get_RecipientLimit_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pRecipientLimit);


void __RPC_STUB IMailboxStore_get_RecipientLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_put_RecipientLimit_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [in] */ long varRecipientLimit);


void __RPC_STUB IMailboxStore_put_RecipientLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_CreateMailbox_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [in] */ BSTR HomeMDBURL);


void __RPC_STUB IMailboxStore_CreateMailbox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_DeleteMailbox_Proxy( 
    IMailboxStore __RPC_FAR * This);


void __RPC_STUB IMailboxStore_DeleteMailbox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailboxStore_MoveMailbox_Proxy( 
    IMailboxStore __RPC_FAR * This,
    /* [in] */ BSTR HomeMDBURL);


void __RPC_STUB IMailboxStore_MoveMailbox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMailboxStore_INTERFACE_DEFINED__ */


#ifndef __IServer_INTERFACE_DEFINED__
#define __IServer_INTERFACE_DEFINED__

/* interface IServer */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F47-5734-11d2-A593-00C04F990D8A")
    IServer : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *varName) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ExchangeVersion( 
            /* [retval][out] */ BSTR __RPC_FAR *varExchangeVersion) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StorageGroups( 
            /* [retval][out] */ VARIANT __RPC_FAR *varStorageGroups) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MessageTrackingEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMessageTrackingEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MessageTrackingEnabled( 
            /* [in] */ VARIANT_BOOL varMessageTrackingEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DaysBeforeLogFileRemoval( 
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeLogFileRemoval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DaysBeforeLogFileRemoval( 
            /* [in] */ long varDaysBeforeLogFileRemoval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerType( 
            /* [retval][out] */ CDOServerType __RPC_FAR *pServerType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ServerType( 
            /* [in] */ CDOServerType varServerType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varName);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExchangeVersion )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varExchangeVersion);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StorageGroups )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varStorageGroups);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MessageTrackingEnabled )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMessageTrackingEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessageTrackingEnabled )( 
            IServer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varMessageTrackingEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DaysBeforeLogFileRemoval )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeLogFileRemoval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DaysBeforeLogFileRemoval )( 
            IServer __RPC_FAR * This,
            /* [in] */ long varDaysBeforeLogFileRemoval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerType )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ CDOServerType __RPC_FAR *pServerType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ServerType )( 
            IServer __RPC_FAR * This,
            /* [in] */ CDOServerType varServerType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IServerVtbl;

    interface IServer
    {
        CONST_VTBL struct IServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServer_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IServer_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IServer_get_Name(This,varName)	\
    (This)->lpVtbl -> get_Name(This,varName)

#define IServer_get_ExchangeVersion(This,varExchangeVersion)	\
    (This)->lpVtbl -> get_ExchangeVersion(This,varExchangeVersion)

#define IServer_get_StorageGroups(This,varStorageGroups)	\
    (This)->lpVtbl -> get_StorageGroups(This,varStorageGroups)

#define IServer_get_MessageTrackingEnabled(This,pMessageTrackingEnabled)	\
    (This)->lpVtbl -> get_MessageTrackingEnabled(This,pMessageTrackingEnabled)

#define IServer_put_MessageTrackingEnabled(This,varMessageTrackingEnabled)	\
    (This)->lpVtbl -> put_MessageTrackingEnabled(This,varMessageTrackingEnabled)

#define IServer_get_DaysBeforeLogFileRemoval(This,pDaysBeforeLogFileRemoval)	\
    (This)->lpVtbl -> get_DaysBeforeLogFileRemoval(This,pDaysBeforeLogFileRemoval)

#define IServer_put_DaysBeforeLogFileRemoval(This,varDaysBeforeLogFileRemoval)	\
    (This)->lpVtbl -> put_DaysBeforeLogFileRemoval(This,varDaysBeforeLogFileRemoval)

#define IServer_get_ServerType(This,pServerType)	\
    (This)->lpVtbl -> get_ServerType(This,pServerType)

#define IServer_put_ServerType(This,varServerType)	\
    (This)->lpVtbl -> put_ServerType(This,varServerType)

#define IServer_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IServer_get_DataSource_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IServer_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IServer_get_Fields_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IServer_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IServer_get_Name_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varName);


void __RPC_STUB IServer_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IServer_get_ExchangeVersion_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varExchangeVersion);


void __RPC_STUB IServer_get_ExchangeVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IServer_get_StorageGroups_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varStorageGroups);


void __RPC_STUB IServer_get_StorageGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IServer_get_MessageTrackingEnabled_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMessageTrackingEnabled);


void __RPC_STUB IServer_get_MessageTrackingEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IServer_put_MessageTrackingEnabled_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varMessageTrackingEnabled);


void __RPC_STUB IServer_put_MessageTrackingEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IServer_get_DaysBeforeLogFileRemoval_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pDaysBeforeLogFileRemoval);


void __RPC_STUB IServer_get_DaysBeforeLogFileRemoval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IServer_put_DaysBeforeLogFileRemoval_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ long varDaysBeforeLogFileRemoval);


void __RPC_STUB IServer_put_DaysBeforeLogFileRemoval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IServer_get_ServerType_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ CDOServerType __RPC_FAR *pServerType);


void __RPC_STUB IServer_get_ServerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IServer_put_ServerType_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ CDOServerType varServerType);


void __RPC_STUB IServer_put_ServerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IServer_GetInterface_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IServer_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServer_INTERFACE_DEFINED__ */


#ifndef __IStorageGroup_INTERFACE_DEFINED__
#define __IStorageGroup_INTERFACE_DEFINED__

/* interface IStorageGroup */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IStorageGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F46-5734-11d2-A593-00C04F990D8A")
    IStorageGroup : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR varName) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PublicStoreDBs( 
            /* [retval][out] */ VARIANT __RPC_FAR *varPublicStoreDBs) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MailboxStoreDBs( 
            /* [retval][out] */ VARIANT __RPC_FAR *varMailboxStoreDBs) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LogFilePath( 
            /* [retval][out] */ BSTR __RPC_FAR *varLogFilePath) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SystemFilePath( 
            /* [retval][out] */ BSTR __RPC_FAR *varSystemFilePath) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ZeroDatabase( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pZeroDatabase) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ZeroDatabase( 
            /* [in] */ VARIANT_BOOL varZeroDatabase) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveLogFiles( 
            /* [in] */ BSTR LogFilePath,
            /* [optional][in] */ long Flags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveSystemFiles( 
            /* [in] */ BSTR SystemFilePath,
            /* [optional][in] */ long Flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStorageGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStorageGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStorageGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStorageGroup __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ BSTR varName);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PublicStoreDBs )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varPublicStoreDBs);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MailboxStoreDBs )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varMailboxStoreDBs);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LogFilePath )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varLogFilePath);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SystemFilePath )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varSystemFilePath);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ZeroDatabase )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pZeroDatabase);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ZeroDatabase )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varZeroDatabase);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveLogFiles )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ BSTR LogFilePath,
            /* [optional][in] */ long Flags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveSystemFiles )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ BSTR SystemFilePath,
            /* [optional][in] */ long Flags);
        
        END_INTERFACE
    } IStorageGroupVtbl;

    interface IStorageGroup
    {
        CONST_VTBL struct IStorageGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStorageGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStorageGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStorageGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStorageGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStorageGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStorageGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStorageGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStorageGroup_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IStorageGroup_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IStorageGroup_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IStorageGroup_put_Name(This,varName)	\
    (This)->lpVtbl -> put_Name(This,varName)

#define IStorageGroup_get_PublicStoreDBs(This,varPublicStoreDBs)	\
    (This)->lpVtbl -> get_PublicStoreDBs(This,varPublicStoreDBs)

#define IStorageGroup_get_MailboxStoreDBs(This,varMailboxStoreDBs)	\
    (This)->lpVtbl -> get_MailboxStoreDBs(This,varMailboxStoreDBs)

#define IStorageGroup_get_LogFilePath(This,varLogFilePath)	\
    (This)->lpVtbl -> get_LogFilePath(This,varLogFilePath)

#define IStorageGroup_get_SystemFilePath(This,varSystemFilePath)	\
    (This)->lpVtbl -> get_SystemFilePath(This,varSystemFilePath)

#define IStorageGroup_get_ZeroDatabase(This,pZeroDatabase)	\
    (This)->lpVtbl -> get_ZeroDatabase(This,pZeroDatabase)

#define IStorageGroup_put_ZeroDatabase(This,varZeroDatabase)	\
    (This)->lpVtbl -> put_ZeroDatabase(This,varZeroDatabase)

#define IStorageGroup_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define IStorageGroup_MoveLogFiles(This,LogFilePath,Flags)	\
    (This)->lpVtbl -> MoveLogFiles(This,LogFilePath,Flags)

#define IStorageGroup_MoveSystemFiles(This,SystemFilePath,Flags)	\
    (This)->lpVtbl -> MoveSystemFiles(This,SystemFilePath,Flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_DataSource_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IStorageGroup_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_Fields_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IStorageGroup_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_Name_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IStorageGroup_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_put_Name_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [in] */ BSTR varName);


void __RPC_STUB IStorageGroup_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_PublicStoreDBs_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varPublicStoreDBs);


void __RPC_STUB IStorageGroup_get_PublicStoreDBs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_MailboxStoreDBs_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varMailboxStoreDBs);


void __RPC_STUB IStorageGroup_get_MailboxStoreDBs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_LogFilePath_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varLogFilePath);


void __RPC_STUB IStorageGroup_get_LogFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_SystemFilePath_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varSystemFilePath);


void __RPC_STUB IStorageGroup_get_SystemFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_ZeroDatabase_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pZeroDatabase);


void __RPC_STUB IStorageGroup_get_ZeroDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_put_ZeroDatabase_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varZeroDatabase);


void __RPC_STUB IStorageGroup_put_ZeroDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_GetInterface_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IStorageGroup_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_MoveLogFiles_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [in] */ BSTR LogFilePath,
    /* [optional][in] */ long Flags);


void __RPC_STUB IStorageGroup_MoveLogFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_MoveSystemFiles_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [in] */ BSTR SystemFilePath,
    /* [optional][in] */ long Flags);


void __RPC_STUB IStorageGroup_MoveSystemFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStorageGroup_INTERFACE_DEFINED__ */


#ifndef __IPublicStoreDB_INTERFACE_DEFINED__
#define __IPublicStoreDB_INTERFACE_DEFINED__

/* interface IPublicStoreDB */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IPublicStoreDB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F44-5734-11d2-A593-00C04F990D8A")
    IPublicStoreDB : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR varName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FolderTree( 
            /* [retval][out] */ BSTR __RPC_FAR *pFolderTree) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FolderTree( 
            /* [in] */ BSTR varFolderTree) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DBPath( 
            /* [retval][out] */ BSTR __RPC_FAR *varDBPath) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SLVPath( 
            /* [retval][out] */ BSTR __RPC_FAR *varSLVPath) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ CDOStoreDBStatus __RPC_FAR *varStatus) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveDataFiles( 
            /* [in] */ BSTR DBPath,
            /* [in] */ BSTR SLVPath,
            /* [optional][in] */ long Flags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Mount( 
            /* [optional][in] */ long Timeout) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Dismount( 
            /* [optional][in] */ long Timeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPublicStoreDBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPublicStoreDB __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPublicStoreDB __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ BSTR varName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FolderTree )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pFolderTree);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FolderTree )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ BSTR varFolderTree);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBPath )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDBPath);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SLVPath )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varSLVPath);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ CDOStoreDBStatus __RPC_FAR *varStatus);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveDataFiles )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ BSTR DBPath,
            /* [in] */ BSTR SLVPath,
            /* [optional][in] */ long Flags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Mount )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [optional][in] */ long Timeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Dismount )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [optional][in] */ long Timeout);
        
        END_INTERFACE
    } IPublicStoreDBVtbl;

    interface IPublicStoreDB
    {
        CONST_VTBL struct IPublicStoreDBVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPublicStoreDB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPublicStoreDB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPublicStoreDB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPublicStoreDB_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPublicStoreDB_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPublicStoreDB_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPublicStoreDB_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPublicStoreDB_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IPublicStoreDB_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IPublicStoreDB_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IPublicStoreDB_put_Name(This,varName)	\
    (This)->lpVtbl -> put_Name(This,varName)

#define IPublicStoreDB_get_FolderTree(This,pFolderTree)	\
    (This)->lpVtbl -> get_FolderTree(This,pFolderTree)

#define IPublicStoreDB_put_FolderTree(This,varFolderTree)	\
    (This)->lpVtbl -> put_FolderTree(This,varFolderTree)

#define IPublicStoreDB_get_DBPath(This,varDBPath)	\
    (This)->lpVtbl -> get_DBPath(This,varDBPath)

#define IPublicStoreDB_get_SLVPath(This,varSLVPath)	\
    (This)->lpVtbl -> get_SLVPath(This,varSLVPath)

#define IPublicStoreDB_get_Status(This,varStatus)	\
    (This)->lpVtbl -> get_Status(This,varStatus)

#define IPublicStoreDB_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define IPublicStoreDB_MoveDataFiles(This,DBPath,SLVPath,Flags)	\
    (This)->lpVtbl -> MoveDataFiles(This,DBPath,SLVPath,Flags)

#define IPublicStoreDB_Mount(This,Timeout)	\
    (This)->lpVtbl -> Mount(This,Timeout)

#define IPublicStoreDB_Dismount(This,Timeout)	\
    (This)->lpVtbl -> Dismount(This,Timeout)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_DataSource_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IPublicStoreDB_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_Fields_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IPublicStoreDB_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_Name_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IPublicStoreDB_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_put_Name_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ BSTR varName);


void __RPC_STUB IPublicStoreDB_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_FolderTree_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pFolderTree);


void __RPC_STUB IPublicStoreDB_get_FolderTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_put_FolderTree_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ BSTR varFolderTree);


void __RPC_STUB IPublicStoreDB_put_FolderTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_DBPath_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDBPath);


void __RPC_STUB IPublicStoreDB_get_DBPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_SLVPath_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varSLVPath);


void __RPC_STUB IPublicStoreDB_get_SLVPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_Status_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ CDOStoreDBStatus __RPC_FAR *varStatus);


void __RPC_STUB IPublicStoreDB_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_GetInterface_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IPublicStoreDB_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_MoveDataFiles_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ BSTR DBPath,
    /* [in] */ BSTR SLVPath,
    /* [optional][in] */ long Flags);


void __RPC_STUB IPublicStoreDB_MoveDataFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_Mount_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [optional][in] */ long Timeout);


void __RPC_STUB IPublicStoreDB_Mount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_Dismount_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [optional][in] */ long Timeout);


void __RPC_STUB IPublicStoreDB_Dismount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPublicStoreDB_INTERFACE_DEFINED__ */


#ifndef __IMailboxStoreDB_INTERFACE_DEFINED__
#define __IMailboxStoreDB_INTERFACE_DEFINED__

/* interface IMailboxStoreDB */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IMailboxStoreDB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F45-5734-11d2-A593-00C04F990D8A")
    IMailboxStoreDB : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR varName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PublicStoreDB( 
            /* [retval][out] */ BSTR __RPC_FAR *pPublicStoreDB) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_PublicStoreDB( 
            /* [in] */ BSTR varPublicStoreDB) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DBPath( 
            /* [retval][out] */ BSTR __RPC_FAR *varDBPath) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SLVPath( 
            /* [retval][out] */ BSTR __RPC_FAR *varSLVPath) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ CDOStoreDBStatus __RPC_FAR *varStatus) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveDataFiles( 
            /* [in] */ BSTR DBPath,
            /* [in] */ BSTR SLVPath,
            /* [optional][in] */ long Flags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Mount( 
            /* [optional][in] */ long Timeout) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Dismount( 
            /* [optional][in] */ long Timeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMailboxStoreDBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMailboxStoreDB __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMailboxStoreDB __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ BSTR varName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PublicStoreDB )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pPublicStoreDB);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PublicStoreDB )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ BSTR varPublicStoreDB);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBPath )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDBPath);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SLVPath )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varSLVPath);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ CDOStoreDBStatus __RPC_FAR *varStatus);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveDataFiles )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ BSTR DBPath,
            /* [in] */ BSTR SLVPath,
            /* [optional][in] */ long Flags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Mount )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [optional][in] */ long Timeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Dismount )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [optional][in] */ long Timeout);
        
        END_INTERFACE
    } IMailboxStoreDBVtbl;

    interface IMailboxStoreDB
    {
        CONST_VTBL struct IMailboxStoreDBVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMailboxStoreDB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMailboxStoreDB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMailboxStoreDB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMailboxStoreDB_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMailboxStoreDB_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMailboxStoreDB_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMailboxStoreDB_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMailboxStoreDB_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IMailboxStoreDB_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IMailboxStoreDB_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IMailboxStoreDB_put_Name(This,varName)	\
    (This)->lpVtbl -> put_Name(This,varName)

#define IMailboxStoreDB_get_PublicStoreDB(This,pPublicStoreDB)	\
    (This)->lpVtbl -> get_PublicStoreDB(This,pPublicStoreDB)

#define IMailboxStoreDB_put_PublicStoreDB(This,varPublicStoreDB)	\
    (This)->lpVtbl -> put_PublicStoreDB(This,varPublicStoreDB)

#define IMailboxStoreDB_get_DBPath(This,varDBPath)	\
    (This)->lpVtbl -> get_DBPath(This,varDBPath)

#define IMailboxStoreDB_get_SLVPath(This,varSLVPath)	\
    (This)->lpVtbl -> get_SLVPath(This,varSLVPath)

#define IMailboxStoreDB_get_Status(This,varStatus)	\
    (This)->lpVtbl -> get_Status(This,varStatus)

#define IMailboxStoreDB_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define IMailboxStoreDB_MoveDataFiles(This,DBPath,SLVPath,Flags)	\
    (This)->lpVtbl -> MoveDataFiles(This,DBPath,SLVPath,Flags)

#define IMailboxStoreDB_Mount(This,Timeout)	\
    (This)->lpVtbl -> Mount(This,Timeout)

#define IMailboxStoreDB_Dismount(This,Timeout)	\
    (This)->lpVtbl -> Dismount(This,Timeout)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_DataSource_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IMailboxStoreDB_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_Fields_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IMailboxStoreDB_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_Name_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IMailboxStoreDB_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_Name_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ BSTR varName);


void __RPC_STUB IMailboxStoreDB_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_PublicStoreDB_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pPublicStoreDB);


void __RPC_STUB IMailboxStoreDB_get_PublicStoreDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_PublicStoreDB_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ BSTR varPublicStoreDB);


void __RPC_STUB IMailboxStoreDB_put_PublicStoreDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_DBPath_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDBPath);


void __RPC_STUB IMailboxStoreDB_get_DBPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_SLVPath_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varSLVPath);


void __RPC_STUB IMailboxStoreDB_get_SLVPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_Status_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ CDOStoreDBStatus __RPC_FAR *varStatus);


void __RPC_STUB IMailboxStoreDB_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_GetInterface_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IMailboxStoreDB_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_MoveDataFiles_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ BSTR DBPath,
    /* [in] */ BSTR SLVPath,
    /* [optional][in] */ long Flags);


void __RPC_STUB IMailboxStoreDB_MoveDataFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_Mount_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [optional][in] */ long Timeout);


void __RPC_STUB IMailboxStoreDB_Mount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_Dismount_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [optional][in] */ long Timeout);


void __RPC_STUB IMailboxStoreDB_Dismount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMailboxStoreDB_INTERFACE_DEFINED__ */


#ifndef __IFolderTree_INTERFACE_DEFINED__
#define __IFolderTree_INTERFACE_DEFINED__

/* interface IFolderTree */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IFolderTree;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F43-5734-11d2-A593-00C04F990D8A")
    IFolderTree : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR varName) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StoreDBs( 
            /* [retval][out] */ VARIANT __RPC_FAR *varStoreDBs) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MailEanbledConainer( 
            /* [retval][out] */ BSTR __RPC_FAR *pMailEanbledConainer) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MailEanbledConainer( 
            /* [in] */ BSTR varMailEanbledConainer) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TreeType( 
            /* [retval][out] */ CDOFolderTreeType __RPC_FAR *pTreeType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TreeType( 
            /* [in] */ CDOFolderTreeType varTreeType) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RootFolderURL( 
            /* [retval][out] */ BSTR __RPC_FAR *varRootFolderURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderTreeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFolderTree __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFolderTree __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFolderTree __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ BSTR varName);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StoreDBs )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varStoreDBs);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MailEanbledConainer )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pMailEanbledConainer);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MailEanbledConainer )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ BSTR varMailEanbledConainer);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TreeType )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ CDOFolderTreeType __RPC_FAR *pTreeType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TreeType )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ CDOFolderTreeType varTreeType);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RootFolderURL )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varRootFolderURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IFolderTreeVtbl;

    interface IFolderTree
    {
        CONST_VTBL struct IFolderTreeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderTree_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFolderTree_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFolderTree_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFolderTree_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFolderTree_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFolderTree_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFolderTree_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFolderTree_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IFolderTree_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IFolderTree_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IFolderTree_put_Name(This,varName)	\
    (This)->lpVtbl -> put_Name(This,varName)

#define IFolderTree_get_StoreDBs(This,varStoreDBs)	\
    (This)->lpVtbl -> get_StoreDBs(This,varStoreDBs)

#define IFolderTree_get_MailEanbledConainer(This,pMailEanbledConainer)	\
    (This)->lpVtbl -> get_MailEanbledConainer(This,pMailEanbledConainer)

#define IFolderTree_put_MailEanbledConainer(This,varMailEanbledConainer)	\
    (This)->lpVtbl -> put_MailEanbledConainer(This,varMailEanbledConainer)

#define IFolderTree_get_TreeType(This,pTreeType)	\
    (This)->lpVtbl -> get_TreeType(This,pTreeType)

#define IFolderTree_put_TreeType(This,varTreeType)	\
    (This)->lpVtbl -> put_TreeType(This,varTreeType)

#define IFolderTree_get_RootFolderURL(This,varRootFolderURL)	\
    (This)->lpVtbl -> get_RootFolderURL(This,varRootFolderURL)

#define IFolderTree_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_DataSource_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IFolderTree_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_Fields_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IFolderTree_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_Name_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IFolderTree_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_put_Name_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [in] */ BSTR varName);


void __RPC_STUB IFolderTree_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_StoreDBs_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varStoreDBs);


void __RPC_STUB IFolderTree_get_StoreDBs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_MailEanbledConainer_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pMailEanbledConainer);


void __RPC_STUB IFolderTree_get_MailEanbledConainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_put_MailEanbledConainer_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [in] */ BSTR varMailEanbledConainer);


void __RPC_STUB IFolderTree_put_MailEanbledConainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_TreeType_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ CDOFolderTreeType __RPC_FAR *pTreeType);


void __RPC_STUB IFolderTree_get_TreeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_put_TreeType_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [in] */ CDOFolderTreeType varTreeType);


void __RPC_STUB IFolderTree_put_TreeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_RootFolderURL_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varRootFolderURL);


void __RPC_STUB IFolderTree_get_RootFolderURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_GetInterface_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IFolderTree_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFolderTree_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MailRecipient;

#ifdef __cplusplus

class DECLSPEC_UUID("25150F20-5734-11d2-A593-00C04F990D8A")
MailRecipient;
#endif

EXTERN_C const CLSID CLSID_Mailbox;

#ifdef __cplusplus

class DECLSPEC_UUID("25150F21-5734-11d2-A593-00C04F990D8A")
Mailbox;
#endif

EXTERN_C const CLSID CLSID_FolderAdmin;

#ifdef __cplusplus

class DECLSPEC_UUID("25150F22-5734-11d2-A593-00C04F990D8A")
FolderAdmin;
#endif

EXTERN_C const CLSID CLSID_Server;

#ifdef __cplusplus

class DECLSPEC_UUID("25150F27-5734-11d2-A593-00C04F990D8A")
Server;
#endif

EXTERN_C const CLSID CLSID_FolderTree;

#ifdef __cplusplus

class DECLSPEC_UUID("25150F23-5734-11d2-A593-00C04F990D8A")
FolderTree;
#endif

EXTERN_C const CLSID CLSID_PublicStoreDB;

#ifdef __cplusplus

class DECLSPEC_UUID("25150F24-5734-11d2-A593-00C04F990D8A")
PublicStoreDB;
#endif

EXTERN_C const CLSID CLSID_MailboxStoreDB;

#ifdef __cplusplus

class DECLSPEC_UUID("25150F25-5734-11d2-A593-00C04F990D8A")
MailboxStoreDB;
#endif

EXTERN_C const CLSID CLSID_StorageGroup;

#ifdef __cplusplus

class DECLSPEC_UUID("25150F26-5734-11d2-A593-00C04F990D8A")
StorageGroup;
#endif


#ifndef __CdoexmInterfaces_MODULE_DEFINED__
#define __CdoexmInterfaces_MODULE_DEFINED__


/* module CdoexmInterfaces */
/* [helpstring][uuid] */ 

const BSTR cdoIMailRecipient	=	L"IMailRecipient";

const BSTR cdoIMailboxStore	=	L"IMailboxStore";

const BSTR cdoIServer	=	L"IServer";

const BSTR cdoIFolderTree	=	L"IFolderTree";

const BSTR cdoIPublicStoreDB	=	L"IPublicStoreDB";

const BSTR cdoIMailboxStoreDB	=	L"IMailboxStoreDB";

const BSTR cdoIStorageGroup	=	L"IStorageGroup";

const BSTR cdoIFolderAdmin	=	L"IFolderAdmin";

const BSTR cdoIADs	=	L"IADs";

#endif /* __CdoexmInterfaces_MODULE_DEFINED__ */
#endif /* __CDOEXM_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\eventlog\eventlogger.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  File Name 
//      EventLogger.CPP
//
//  Description
//
//  Revision: 2.01
//
//  Copyright (c) 1996-1999 Acotec, Inc.
//  All rights reserved.
//
//
//  Portions Copyright (c) 1999 Microsoft Corporation.  All rights reserved.
//
#include "EventLogger.h"

///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::CEventLogger()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
CEventLogger::CEventLogger()
{
    InitializeCriticalSection (&m_csObj);
    m_hEventLog = NULL;
    m_wServiceCategory = 0;
    m_LoggingLevel = LOGGING_LEVEL_1;
    m_hLogMutex = NULL;
	m_fLogEvent = TRUE;
    m_hMsgSource = NULL;
    ZeroMemory (m_szCat, sizeof(m_szCat));
}

///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::CEventLogger()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
CEventLogger::CEventLogger(LPTSTR szEventSource, WORD wEventsCategory)
{
    CEventLogger();
    InitEventLog (szEventSource, wEventsCategory);
}

///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::~CEventLogger()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
CEventLogger::~CEventLogger()
{
    if (m_hLogMutex)
    {
        CloseHandle (m_hLogMutex);
    }
    if (m_hEventLog)
    {
        DeregisterEventSource (m_hEventLog);
    }
    DeleteCriticalSection (&m_csObj);
}


///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::InitEventLog()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
DWORD WINAPI CEventLogger::InitEventLog (LPTSTR szEventSource,
                                         WORD  wEventsCategory,
                                         LPTSTR szRegKey)
{
    EnterCriticalSection (&m_csObj);
    if (m_hEventLog)
    {
        DeregisterEventSource (m_hEventLog);
        m_hEventLog = NULL;
    }
    m_wServiceCategory = wEventsCategory;
    m_LoggingLevel = LOGGING_LEVEL_1;
    
    HKEY hKey;
    DWORD dwValue=LOGGING_LEVEL_1, dwError = 0, dwSize = sizeof(DWORD);

    m_hEventLog = RegisterEventSource (NULL, szEventSource);
    if (!m_hEventLog)
    {
        dwError = GetLastError();
        m_LoggingLevel = LOGGING_LEVEL_0;
    }
    else 
    if (szRegKey && 
        ERROR_SUCCESS == (dwError=RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                                   szRegKey,
                                                   0,
                                                   KEY_READ,
                                                   &hKey)))
    {
        dwError=RegQueryValueEx (hKey,
                         REGVAL_LOGGING_LEVEL,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize);
        if(ERROR_SUCCESS == dwError )
        {
            if (dwValue > (DWORD)LOGGING_LEVEL_3)
            {
                dwValue = (DWORD)LOGGING_LEVEL_3;
            }
            m_LoggingLevel = (LOGLEVEL)dwValue;
        }
        RegCloseKey (hKey);
	}
    
    LeaveCriticalSection (&m_csObj);
    return dwError;
}

///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::SetLoggingLevel()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
void WINAPI CEventLogger::SetLoggingLevel (LOGLEVEL NewLoggingLevel)
{
    EnterCriticalSection (&m_csObj);
    m_LoggingLevel = NewLoggingLevel;
    LeaveCriticalSection (&m_csObj);
}

///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::LogEvent()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
void WINAPI CEventLogger::LogEvent (LOGTYPE Type,
                                    DWORD   dwEventID,
                                    DWORD   dwData,
                                    LPCTSTR  rgszMsgs[],
                                    WORD    wCount,
                                    DWORD   cbData,
                                    LPVOID  pvData)
{
    if (LOGGING_LEVEL_0 == m_LoggingLevel &&
        LOGTYPE_FORCE_ERROR != Type &&
        LOGTYPE_FORCE_WARNING != Type &&
        LOGTYPE_FORCE_INFORMATION != Type)
    {
        return;
    }
	if (!m_fLogEvent)
		return;


    TCHAR szBuffer[64];
    LPCTSTR rgszError[] =
    {
        szBuffer
    };

    LPTSTR pszType;
    WORD wEventType;
    switch (Type)
    {
        case LOGTYPE_ERR_CRITICAL :
        case LOGTYPE_FORCE_ERROR :
            pszType = _T("ERROR");
            wEventType = EVENTLOG_ERROR_TYPE;
            if (NULL == rgszMsgs)
            {
                _stprintf (szBuffer, _T("%d"), dwData);
                rgszMsgs = rgszError;
                wCount = 1;
            }
            break;
        case LOGTYPE_ERR_WARNING :
            if (m_LoggingLevel < LOGGING_LEVEL_2) { return; }
        case LOGTYPE_FORCE_WARNING :
            pszType = _T("WARNING");
            wEventType = EVENTLOG_WARNING_TYPE;
            if (dwData && NULL == rgszMsgs)
            {
                _stprintf (szBuffer, _T("%d"), dwData);
                rgszMsgs = rgszError;
                wCount = 1;
            }
            break;
        case LOGTYPE_AUDIT_SECURITY_ACCESS :
        case LOGTYPE_AUDIT_SECURITY_DENIED :
            pszType = _T("SECURITY");
        case LOGTYPE_INFORMATION :
            if (m_LoggingLevel < LOGGING_LEVEL_3) { return; }
        case LOGTYPE_FORCE_INFORMATION :
            switch (Type)
            {
                case LOGTYPE_AUDIT_SECURITY_ACCESS : wEventType = EVENTLOG_AUDIT_SUCCESS; break;
                case LOGTYPE_AUDIT_SECURITY_DENIED : wEventType = EVENTLOG_AUDIT_FAILURE; break;
                case LOGTYPE_FORCE_INFORMATION :
                case LOGTYPE_INFORMATION :
                    wEventType = EVENTLOG_INFORMATION_TYPE;
                    pszType = _T("INFORMATION");
                    break;
            }
            break;
        case LOGTYPE_VERBOSE :
        case LOGTYPE_VERBOSE_ERROR :
        case LOGTYPE_VERBOSE_WARNING :
            if (m_LoggingLevel < LOGGING_LEVEL_3) { return; }
            if ((LOGTYPE_VERBOSE_ERROR == Type || LOGTYPE_VERBOSE_WARNING == Type) &&
                dwData && NULL == rgszMsgs)
            {
                _stprintf (szBuffer, _T("%d"), dwData);
                rgszMsgs = rgszError;
                wCount = 1;
            }
            switch (Type)
            {
                case LOGTYPE_VERBOSE :
                    wEventType = EVENTLOG_INFORMATION_TYPE;
                    pszType = _T("V_INFORMATION");
                    break;
                case LOGTYPE_VERBOSE_ERROR :
                    wEventType = EVENTLOG_ERROR_TYPE;
                    pszType = _T("V_ERROR");
                    break;
                case LOGTYPE_VERBOSE_WARNING :
                    wEventType = EVENTLOG_WARNING_TYPE;
                    pszType = _T("V_WARNING");
                    break;
            }
            break;
        default :
            return;
    }

    if (m_hEventLog)
    {
         ReportEvent (m_hEventLog,
		              wEventType, 
		              m_wServiceCategory,
		              dwEventID,
		              NULL,
		              wCount,
		              cbData,
		              rgszMsgs,
		              pvData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\eventlog\eventlogger.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File Name 
//      EventLogger.h
//
//
//  Portions Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
//
#ifndef _CEVENTLOGGER_H
#define _CEVENTLOGGER_H

#pragma warning (disable : 4100)
#pragma warning (disable : 4127)
#pragma warning (disable : 4201)
#pragma warning (disable : 4237)
#pragma warning (disable : 4245)
#pragma warning (disable : 4514)

#ifndef STRICT
#define STRICT
#endif //!STRICT
#include <WINDOWS.H>
#include <TCHAR.H>
#include <stdio.h>
#include <stdlib.h>

#define REGVAL_LOGGING_LEVEL        _T("Logging")

#define COUNTOF(a) (sizeof(a)/sizeof(a[0]))
#define STR_BYTE_SIZE(a)  ((_tcslen (a) + 1)*sizeof(TCHAR))

// Level of logging in the event registry

typedef enum LOGLEVEL
{
    LOGGING_LEVEL_0    =  0, // None: No event log traces at all.
    LOGGING_LEVEL_1,         // Minimal: No audit or information traces. Only critical and warning errors
    LOGGING_LEVEL_2,         // Normal: Security audit traces plus previous level
    LOGGING_LEVEL_3          // Verbose: All transactions are traced out plus previous level
} LOGLEVEL;

typedef enum LOGTYPE
{
    LOGTYPE_FORCE_ERROR,            // Logged in any Level regardless.
    LOGTYPE_FORCE_WARNING,          // Logged in any Level regardless.
    LOGTYPE_FORCE_INFORMATION,      // Logged in any Level regardless.
    LOGTYPE_ERR_CRITICAL,           // Logged in level 1 or above
    LOGTYPE_ERR_WARNING,            // Logged in level 1 or above
    LOGTYPE_AUDIT_SECURITY_ACCESS,  // Logged in level 2 or above
    LOGTYPE_AUDIT_SECURITY_DENIED,  // Logged in level 2 or above
    LOGTYPE_INFORMATION,            // Logged in level 3 or above
    LOGTYPE_VERBOSE,                // Logged in level 4
    LOGTYPE_VERBOSE_ERROR,          // Logged in level 4
    LOGTYPE_VERBOSE_WARNING         // Logged in level 4
} LOGTYPE;



class CEventLogger
{
public :
    DWORD WINAPI InitEventLog
                    (LPTSTR                     szEventSource,
                     WORD                       wEventsCategory,
                     LPTSTR                     szRegKey = NULL);
    DWORD WINAPI InitEventLog
                    (LPTSTR                     szEventSource,
                     WORD                       wEventsCategory,
                     LOGLEVEL                   NewLoggingLevel)
                    {
                        LPTSTR szKey = NULL;
                        DWORD dwError = InitEventLog (szEventSource, wEventsCategory, szKey);
                        if (!dwError)
                        {
                            SetLoggingLevel (NewLoggingLevel);
                        }
                        return dwError;
                    }
    void WINAPI SetLoggingLevel
                    (DWORD                      dwNewLoggingLevel)
                    {
                        if (dwNewLoggingLevel > (DWORD)LOGGING_LEVEL_3)
                        {
                            dwNewLoggingLevel = (DWORD)LOGGING_LEVEL_3;
                        }
                        SetLoggingLevel ((LOGLEVEL)dwNewLoggingLevel);
                    }
    void WINAPI SetLoggingLevel
                    (LOGLEVEL                   NewLoggingLevel);
    DWORD WINAPI GetLoggingLevel
                    ()
                    {
                        EnterCriticalSection (&m_csObj);
                        DWORD dwLevel = (DWORD)m_LoggingLevel;
                        LeaveCriticalSection (&m_csObj);
                        return dwLevel;
                    }
    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     DWORD                      dwData,
                     LPCTSTR                     rgszMsgs[],
                     WORD                       wCount,
                     DWORD                      cbData = 0,
                     LPVOID                     pvData = NULL);
    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     DWORD                      dwError = 0)
                    { LogEvent (Type, dwEventID, dwError, NULL, 0); }
    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     int                        iError )
                    { LogEvent (Type, dwEventID, iError, NULL, 0); }
    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     LPCTSTR                    rgszMsgs[],
                     WORD                       wCount)
                    { LogEvent (Type, dwEventID, 0, rgszMsgs, wCount); };

    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     HRESULT                    hResult)
                    { TCHAR szBuffer[32];
                      LPCTSTR rgText[] = { szBuffer };
                      _stprintf (szBuffer, _T("%#08x"), hResult);
                      LogEvent (Type, dwEventID, 0, rgText, 1); };
    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     LPCTSTR                    szString,
                     HRESULT                    hResult)
                    { TCHAR szBuffer[32];
                      LPCTSTR rgText[] = { szString, szBuffer };
                      _stprintf (szBuffer, _T("%#08x"), hResult);
                      LogEvent (Type, dwEventID, 0, rgText, 2); };

public :
    CEventLogger();
    CEventLogger(LPTSTR                          szEventSource,
                 WORD                           wEventsCategory);
    ~CEventLogger();

private :
    CRITICAL_SECTION    m_csObj;
    WORD                m_wServiceCategory;
    LOGLEVEL            m_LoggingLevel;
    HANDLE              m_hEventLog;
    HANDLE              m_hLogMutex;
    HMODULE             m_hMsgSource;
    TCHAR               m_szCat[32];
	BOOL				m_fLogEvent;
};

#endif // _CEVENTLOGGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\inc\cdoex.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Sun Sep 19 05:55:03 1999
 */
/* Compiler settings for R:\cdopt\src\cdo\cdo.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, app_config, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cdo_h__
#define __cdo_h__
#include "cdoexstr.h"
#if defined __cplusplus && !defined CDO_NO_NAMESPACE
namespace CDO {
#else
#undef IDataSource
#endif

/* Forward Declarations */ 

#ifndef __IDataSource_FWD_DEFINED__
#define __IDataSource_FWD_DEFINED__
typedef interface IDataSource IDataSource;
#endif 	/* __IDataSource_FWD_DEFINED__ */


#ifndef __IMessage_FWD_DEFINED__
#define __IMessage_FWD_DEFINED__
typedef interface IMessage IMessage;
#endif 	/* __IMessage_FWD_DEFINED__ */


#ifndef __IBodyPart_FWD_DEFINED__
#define __IBodyPart_FWD_DEFINED__
typedef interface IBodyPart IBodyPart;
#endif 	/* __IBodyPart_FWD_DEFINED__ */


#ifndef __IConfiguration_FWD_DEFINED__
#define __IConfiguration_FWD_DEFINED__
typedef interface IConfiguration IConfiguration;
#endif 	/* __IConfiguration_FWD_DEFINED__ */


#ifndef __IMessages_FWD_DEFINED__
#define __IMessages_FWD_DEFINED__
typedef interface IMessages IMessages;
#endif 	/* __IMessages_FWD_DEFINED__ */


#ifndef __IDropDirectory_FWD_DEFINED__
#define __IDropDirectory_FWD_DEFINED__
typedef interface IDropDirectory IDropDirectory;
#endif 	/* __IDropDirectory_FWD_DEFINED__ */


#ifndef __IBodyParts_FWD_DEFINED__
#define __IBodyParts_FWD_DEFINED__
typedef interface IBodyParts IBodyParts;
#endif 	/* __IBodyParts_FWD_DEFINED__ */


#ifndef __ISMTPScriptConnector_FWD_DEFINED__
#define __ISMTPScriptConnector_FWD_DEFINED__
typedef interface ISMTPScriptConnector ISMTPScriptConnector;
#endif 	/* __ISMTPScriptConnector_FWD_DEFINED__ */


#ifndef __INNTPEarlyScriptConnector_FWD_DEFINED__
#define __INNTPEarlyScriptConnector_FWD_DEFINED__
typedef interface INNTPEarlyScriptConnector INNTPEarlyScriptConnector;
#endif 	/* __INNTPEarlyScriptConnector_FWD_DEFINED__ */


#ifndef __INNTPPostScriptConnector_FWD_DEFINED__
#define __INNTPPostScriptConnector_FWD_DEFINED__
typedef interface INNTPPostScriptConnector INNTPPostScriptConnector;
#endif 	/* __INNTPPostScriptConnector_FWD_DEFINED__ */


#ifndef __INNTPFinalScriptConnector_FWD_DEFINED__
#define __INNTPFinalScriptConnector_FWD_DEFINED__
typedef interface INNTPFinalScriptConnector INNTPFinalScriptConnector;
#endif 	/* __INNTPFinalScriptConnector_FWD_DEFINED__ */


#ifndef __ISMTPOnArrival_FWD_DEFINED__
#define __ISMTPOnArrival_FWD_DEFINED__
typedef interface ISMTPOnArrival ISMTPOnArrival;
#endif 	/* __ISMTPOnArrival_FWD_DEFINED__ */


#ifndef __INNTPOnPostEarly_FWD_DEFINED__
#define __INNTPOnPostEarly_FWD_DEFINED__
typedef interface INNTPOnPostEarly INNTPOnPostEarly;
#endif 	/* __INNTPOnPostEarly_FWD_DEFINED__ */


#ifndef __INNTPOnPost_FWD_DEFINED__
#define __INNTPOnPost_FWD_DEFINED__
typedef interface INNTPOnPost INNTPOnPost;
#endif 	/* __INNTPOnPost_FWD_DEFINED__ */


#ifndef __INNTPOnPostFinal_FWD_DEFINED__
#define __INNTPOnPostFinal_FWD_DEFINED__
typedef interface INNTPOnPostFinal INNTPOnPostFinal;
#endif 	/* __INNTPOnPostFinal_FWD_DEFINED__ */


#ifndef __IItem_FWD_DEFINED__
#define __IItem_FWD_DEFINED__
typedef interface IItem IItem;
#endif 	/* __IItem_FWD_DEFINED__ */


#ifndef __IAppointment_FWD_DEFINED__
#define __IAppointment_FWD_DEFINED__
typedef interface IAppointment IAppointment;
#endif 	/* __IAppointment_FWD_DEFINED__ */


#ifndef __ICalendarMessage_FWD_DEFINED__
#define __ICalendarMessage_FWD_DEFINED__
typedef interface ICalendarMessage ICalendarMessage;
#endif 	/* __ICalendarMessage_FWD_DEFINED__ */


#ifndef __IIntegers_FWD_DEFINED__
#define __IIntegers_FWD_DEFINED__
typedef interface IIntegers IIntegers;
#endif 	/* __IIntegers_FWD_DEFINED__ */


#ifndef __IVariants_FWD_DEFINED__
#define __IVariants_FWD_DEFINED__
typedef interface IVariants IVariants;
#endif 	/* __IVariants_FWD_DEFINED__ */


#ifndef __IRecurrencePattern_FWD_DEFINED__
#define __IRecurrencePattern_FWD_DEFINED__
typedef interface IRecurrencePattern IRecurrencePattern;
#endif 	/* __IRecurrencePattern_FWD_DEFINED__ */


#ifndef __IException_FWD_DEFINED__
#define __IException_FWD_DEFINED__
typedef interface IException IException;
#endif 	/* __IException_FWD_DEFINED__ */


#ifndef __IRecurrencePatterns_FWD_DEFINED__
#define __IRecurrencePatterns_FWD_DEFINED__
typedef interface IRecurrencePatterns IRecurrencePatterns;
#endif 	/* __IRecurrencePatterns_FWD_DEFINED__ */


#ifndef __IExceptions_FWD_DEFINED__
#define __IExceptions_FWD_DEFINED__
typedef interface IExceptions IExceptions;
#endif 	/* __IExceptions_FWD_DEFINED__ */


#ifndef __ICalendarPart_FWD_DEFINED__
#define __ICalendarPart_FWD_DEFINED__
typedef interface ICalendarPart ICalendarPart;
#endif 	/* __ICalendarPart_FWD_DEFINED__ */


#ifndef __ICalendarParts_FWD_DEFINED__
#define __ICalendarParts_FWD_DEFINED__
typedef interface ICalendarParts ICalendarParts;
#endif 	/* __ICalendarParts_FWD_DEFINED__ */


#ifndef __IAttendee_FWD_DEFINED__
#define __IAttendee_FWD_DEFINED__
typedef interface IAttendee IAttendee;
#endif 	/* __IAttendee_FWD_DEFINED__ */


#ifndef __IAttendees_FWD_DEFINED__
#define __IAttendees_FWD_DEFINED__
typedef interface IAttendees IAttendees;
#endif 	/* __IAttendees_FWD_DEFINED__ */


#ifndef __IMailbox_FWD_DEFINED__
#define __IMailbox_FWD_DEFINED__
typedef interface IMailbox IMailbox;
#endif 	/* __IMailbox_FWD_DEFINED__ */


#ifndef __IFolder_FWD_DEFINED__
#define __IFolder_FWD_DEFINED__
typedef interface IFolder IFolder;
#endif 	/* __IFolder_FWD_DEFINED__ */


#ifndef __IContactGroupMembers_FWD_DEFINED__
#define __IContactGroupMembers_FWD_DEFINED__
typedef interface IContactGroupMembers IContactGroupMembers;
#endif 	/* __IContactGroupMembers_FWD_DEFINED__ */


#ifndef __IPerson_FWD_DEFINED__
#define __IPerson_FWD_DEFINED__
typedef interface IPerson IPerson;
#endif 	/* __IPerson_FWD_DEFINED__ */


#ifndef __IAddressee_FWD_DEFINED__
#define __IAddressee_FWD_DEFINED__
typedef interface IAddressee IAddressee;
#endif 	/* __IAddressee_FWD_DEFINED__ */


#ifndef __IAddressees_FWD_DEFINED__
#define __IAddressees_FWD_DEFINED__
typedef interface IAddressees IAddressees;
#endif 	/* __IAddressees_FWD_DEFINED__ */


#ifndef __IBodyParts_FWD_DEFINED__
#define __IBodyParts_FWD_DEFINED__
typedef interface IBodyParts IBodyParts;
#endif 	/* __IBodyParts_FWD_DEFINED__ */


#ifndef __IMessages_FWD_DEFINED__
#define __IMessages_FWD_DEFINED__
typedef interface IMessages IMessages;
#endif 	/* __IMessages_FWD_DEFINED__ */


#ifndef __Message_FWD_DEFINED__
#define __Message_FWD_DEFINED__

#ifdef __cplusplus
typedef class Message Message;
#else
typedef struct Message Message;
#endif /* __cplusplus */

#endif 	/* __Message_FWD_DEFINED__ */


#ifndef __Configuration_FWD_DEFINED__
#define __Configuration_FWD_DEFINED__

#ifdef __cplusplus
typedef class Configuration Configuration;
#else
typedef struct Configuration Configuration;
#endif /* __cplusplus */

#endif 	/* __Configuration_FWD_DEFINED__ */


#ifndef __DropDirectory_FWD_DEFINED__
#define __DropDirectory_FWD_DEFINED__

#ifdef __cplusplus
typedef class DropDirectory DropDirectory;
#else
typedef struct DropDirectory DropDirectory;
#endif /* __cplusplus */

#endif 	/* __DropDirectory_FWD_DEFINED__ */


#ifndef __SMTPConnector_FWD_DEFINED__
#define __SMTPConnector_FWD_DEFINED__

#ifdef __cplusplus
typedef class SMTPConnector SMTPConnector;
#else
typedef struct SMTPConnector SMTPConnector;
#endif /* __cplusplus */

#endif 	/* __SMTPConnector_FWD_DEFINED__ */


#ifndef __NNTPEarlyConnector_FWD_DEFINED__
#define __NNTPEarlyConnector_FWD_DEFINED__

#ifdef __cplusplus
typedef class NNTPEarlyConnector NNTPEarlyConnector;
#else
typedef struct NNTPEarlyConnector NNTPEarlyConnector;
#endif /* __cplusplus */

#endif 	/* __NNTPEarlyConnector_FWD_DEFINED__ */


#ifndef __NNTPPostConnector_FWD_DEFINED__
#define __NNTPPostConnector_FWD_DEFINED__

#ifdef __cplusplus
typedef class NNTPPostConnector NNTPPostConnector;
#else
typedef struct NNTPPostConnector NNTPPostConnector;
#endif /* __cplusplus */

#endif 	/* __NNTPPostConnector_FWD_DEFINED__ */


#ifndef __NNTPFinalConnector_FWD_DEFINED__
#define __NNTPFinalConnector_FWD_DEFINED__

#ifdef __cplusplus
typedef class NNTPFinalConnector NNTPFinalConnector;
#else
typedef struct NNTPFinalConnector NNTPFinalConnector;
#endif /* __cplusplus */

#endif 	/* __NNTPFinalConnector_FWD_DEFINED__ */


#ifndef __Item_FWD_DEFINED__
#define __Item_FWD_DEFINED__

#ifdef __cplusplus
typedef class Item Item;
#else
typedef struct Item Item;
#endif /* __cplusplus */

#endif 	/* __Item_FWD_DEFINED__ */


#ifndef __Appointment_FWD_DEFINED__
#define __Appointment_FWD_DEFINED__

#ifdef __cplusplus
typedef class Appointment Appointment;
#else
typedef struct Appointment Appointment;
#endif /* __cplusplus */

#endif 	/* __Appointment_FWD_DEFINED__ */


#ifndef __CalendarMessage_FWD_DEFINED__
#define __CalendarMessage_FWD_DEFINED__

#ifdef __cplusplus
typedef class CalendarMessage CalendarMessage;
#else
typedef struct CalendarMessage CalendarMessage;
#endif /* __cplusplus */

#endif 	/* __CalendarMessage_FWD_DEFINED__ */


#ifndef __Folder_FWD_DEFINED__
#define __Folder_FWD_DEFINED__

#ifdef __cplusplus
typedef class Folder Folder;
#else
typedef struct Folder Folder;
#endif /* __cplusplus */

#endif 	/* __Folder_FWD_DEFINED__ */


#ifndef __Person_FWD_DEFINED__
#define __Person_FWD_DEFINED__

#ifdef __cplusplus
typedef class Person Person;
#else
typedef struct Person Person;
#endif /* __cplusplus */

#endif 	/* __Person_FWD_DEFINED__ */


#ifndef __Attendee_FWD_DEFINED__
#define __Attendee_FWD_DEFINED__

#ifdef __cplusplus
typedef class Attendee Attendee;
#else
typedef struct Attendee Attendee;
#endif /* __cplusplus */

#endif 	/* __Attendee_FWD_DEFINED__ */


#ifndef __Addressee_FWD_DEFINED__
#define __Addressee_FWD_DEFINED__

#ifdef __cplusplus
typedef class Addressee Addressee;
#else
typedef struct Addressee Addressee;
#endif /* __cplusplus */

#endif 	/* __Addressee_FWD_DEFINED__ */


#ifndef __IGetInterface_FWD_DEFINED__
#define __IGetInterface_FWD_DEFINED__
typedef interface IGetInterface IGetInterface;
#endif 	/* __IGetInterface_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#ifndef __cplusplus // X5-101346
typedef interface ADOError ADOError;
typedef interface ADOErrors ADOErrors;
typedef interface _ADOCommand _ADOCommand;
typedef interface _ADOConnection _ADOConnection;
typedef interface _ADORecord _ADORecord;
typedef interface IRecADOFields IRecADOFields;
typedef interface _ADOStream _ADOStream;
typedef interface _ADORecordset _ADORecordset;
typedef interface ADOField ADOField;
typedef interface _ADOField _ADOField;
typedef interface ADOFields ADOFields;
typedef interface _ADOParameter _ADOParameter;
typedef interface ADOParameters ADOParameters;
typedef interface ADOProperty ADOProperty;
typedef interface ADOProperties ADOProperties;
#endif // __cplusplus
#include "adoint.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_cdo_0000 */
/* [local] */ 







typedef /* [helpstring] */ 
enum CdoAttendeeRoleValues
    {	cdoRequiredParticipant	= 0,
	cdoOptionalParticipant	= 1,
	cdoNonParticipant	= 2,
	cdoChair	= 3
    }	CdoAttendeeRoleValues;

typedef /* [helpstring] */ 
enum CdoAttendeeStatusValues
    {	cdoAccepted	= 0,
	cdoDeclined	= 1,
	cdoAttendeeStatusTentative	= 2,
	cdoNeedsAction	= 3,
	cdoDelegated	= 4,
	cdoCompleted	= 5,
	cdoInProgress	= 6
    }	CdoAttendeeStatusValues;

typedef /* [helpstring] */ 
enum CdoComponentType
    {	cdoComponentTypeUnknown	= 0,
	cdoComponentTypeAppointment	= 1
    }	CdoComponentType;

typedef /* [helpstring] */ 
enum CdoConfigSource
    {	cdoDefaults	= -1,
	cdoIIS	= 1,
	cdoOutlookExpress	= 2,
	cdoDirectory	= 3
    }	CdoConfigSource;

typedef /* [helpstring] */ 
enum CdoDayOfWeek
    {	cdoSunday	= 0,
	cdoMonday	= 1,
	cdoTuesday	= 2,
	cdoWednesday	= 3,
	cdoThursday	= 4,
	cdoFriday	= 5,
	cdoSaturday	= 6
    }	CdoDayOfWeek;

typedef /* [helpstring] */ 
enum CdoDSNOptions
    {	cdoDSNDefault	= 0,
	cdoDSNNever	= 1,
	cdoDSNFailure	= 2,
	cdoDSNSuccess	= 4,
	cdoDSNDelay	= 8,
	cdoDSNSuccessFailOrDelay	= 14
    }	CdoDSNOptions;

typedef /* [helpstring] */ 
enum CdoEventStatus
    {	cdoRunNextSink	= 0,
	cdoSkipRemainingSinks	= 1
    }	CdoEventStatus;

typedef 
enum CdoEventType
    {	cdoSMTPOnArrival	= 1,
	cdoNNTPOnPostEarly	= 2,
	cdoNNTPOnPost	= 3,
	cdoNNTPOnPostFinal	= 4
    }	CdoEventType;

typedef /* [helpstring] */ 
enum CdoFileAsMappingId
    {	cdoMapToNone	= 0,
	cdoMapToLastFirst	= 1,
	cdoMapToFirstLast	= 2,
	cdoMapToOrg	= 3,
	cdoMapToLastFirstOrg	= 4,
	cdoMapToOrgLastFirst	= 5
    }	CdoFileAsMappingId;

typedef /* [helpstring] */ 
enum CdoFrequency
    {	cdoSecondly	= 1,
	cdoMinutely	= 2,
	cdoHourly	= 3,
	cdoDaily	= 4,
	cdoWeekly	= 5,
	cdoMonthly	= 6,
	cdoYearly	= 7
    }	CdoFrequency;

typedef /* [helpstring] */ 
enum CdoGenderValues
    {	cdoGenderUnspecified	= 0,
	cdoFemale	= 1,
	cdoMale	= 2
    }	CdoGenderValues;

typedef 
enum cdoImportanceValues
    {	cdoLow	= 0,
	cdoNormal	= 1,
	cdoHigh	= 2
    }	cdoImportanceValues;

typedef 
enum CdoInstanceTypes
    {	cdoSingle	= 0,
	cdoMaster	= 1,
	cdoInstance	= 2,
	cdoException	= 3
    }	CdoInstanceTypes;

typedef /* [helpstring] */ 
enum CdoMailingAddressIdValues
    {	cdoNoAddress	= 0,
	cdoHomeAddress	= 1,
	cdoBusinessAddress	= 2,
	cdoOtherAddress	= 3
    }	CdoMailingAddressIdValues;

typedef /* [helpstring] */ 
enum CdoMessageStat
    {	cdoStatSuccess	= 0,
	cdoStatAbortDelivery	= 2,
	cdoStatBadMail	= 3
    }	CdoMessageStat;

typedef /* [helpstring] */ 
enum CdoMHTMLFlags
    {	cdoSuppressNone	= 0,
	cdoSuppressImages	= 1,
	cdoSuppressBGSounds	= 2,
	cdoSuppressFrames	= 4,
	cdoSuppressObjects	= 8,
	cdoSuppressStyleSheets	= 16,
	cdoSuppressAll	= 31
    }	CdoMHTMLFlags;

typedef /* [helpstring] */ 
enum CdoNNTPProcessingField
    {	cdoPostMessage	= 1,
	cdoProcessControl	= 2,
	cdoProcessModerator	= 4
    }	CdoNNTPProcessingField;

typedef /* [helpstring] */ 
enum CdoPostUsing
    {	cdoPostUsingPickup	= 1,
	cdoPostUsingPort	= 2,
	cdoPostUsingExchange	= 3
    }	CdoPostUsing;

typedef 
enum cdoPriorityValues
    {	cdoPriorityNonUrgent	= -1,
	cdoPriorityNormal	= 0,
	cdoPriorityUrgent	= 1
    }	cdoPriorityValues;

typedef /* [helpstring] */ 
enum CdoProtocolsAuthentication
    {	cdoAnonymous	= 0,
	cdoBasic	= 1,
	cdoNTLM	= 2
    }	CdoProtocolsAuthentication;

typedef /* [helpstring] */ 
enum CdoReferenceType
    {	cdoRefTypeId	= 0,
	cdoRefTypeLocation	= 1
    }	CdoReferenceType;

typedef 
enum CdoResolvedStatus
    {	cdoUnresolved	= 0,
	cdoResolved	= 1,
	cdoAmbiguous	= 2
    }	CdoResolvedStatus;

typedef /* [helpstring] */ 
enum CdoSendUsing
    {	cdoSendUsingPickup	= 1,
	cdoSendUsingPort	= 2,
	cdoSendUsingExchange	= 3
    }	CdoSendUsing;

typedef 
enum cdoSensitivityValues
    {	cdoSensitivityNone	= 0,
	cdoPersonal	= 1,
	cdoPrivate	= 2,
	cdoCompanyConfidential	= 3
    }	cdoSensitivityValues;

typedef /* [helpstring] */ 
enum CdoTimeZoneId
    {	cdoUTC	= 0,
	cdoGMT	= 1,
	cdoLisbon	= 2,
	cdoParis	= 3,
	cdoBerlin	= 4,
	cdoEasternEurope	= 5,
	cdoPrague	= 6,
	cdoAthens	= 7,
	cdoBrasilia	= 8,
	cdoAtlanticCanada	= 9,
	cdoEastern	= 10,
	cdoCentral	= 11,
	cdoMountain	= 12,
	cdoPacific	= 13,
	cdoAlaska	= 14,
	cdoHawaii	= 15,
	cdoMidwayIsland	= 16,
	cdoWellington	= 17,
	cdoBrisbane	= 18,
	cdoAdelaide	= 19,
	cdoTokyo	= 20,
	cdoHongKong	= 21,
	cdoBangkok	= 22,
	cdoBombay	= 23,
	cdoAbuDhabi	= 24,
	cdoTehran	= 25,
	cdoBaghdad	= 26,
	cdoIsrael	= 27,
	cdoNewfoundland	= 28,
	cdoAzores	= 29,
	cdoMidAtlantic	= 30,
	cdoMonrovia	= 31,
	cdoBuenosAires	= 32,
	cdoCaracas	= 33,
	cdoIndiana	= 34,
	cdoBogota	= 35,
	cdoSaskatchewan	= 36,
	cdoMexicoCity	= 37,
	cdoArizona	= 38,
	cdoEniwetok	= 39,
	cdoFiji	= 40,
	cdoMagadan	= 41,
	cdoHobart	= 42,
	cdoGuam	= 43,
	cdoDarwin	= 44,
	cdoBeijing	= 45,
	cdoAlmaty	= 46,
	cdoIslamabad	= 47,
	cdoKabul	= 48,
	cdoCairo	= 49,
	cdoHarare	= 50,
	cdoMoscow	= 51,
	cdoInvalidTimeZone	= 52
    }	CdoTimeZoneId;



extern RPC_IF_HANDLE __MIDL_itf_cdo_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cdo_0000_v0_0_s_ifspec;

#ifndef __IDataSource_INTERFACE_DEFINED__
#define __IDataSource_INTERFACE_DEFINED__

/* interface IDataSource */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IDataSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000029-8B95-11D1-82DB-00C04FB1625D")
    IDataSource : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceClass( 
            /* [retval][out] */ BSTR __RPC_FAR *varSourceClass) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *varSource) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDirty( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsDirty) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_IsDirty( 
            /* [in] */ VARIANT_BOOL varIsDirty) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceURL( 
            /* [retval][out] */ BSTR __RPC_FAR *varSourceURL) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ActiveConnection( 
            /* [retval][out] */ _Connection __RPC_FAR *__RPC_FAR *varActiveConnection) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveToObject( 
            /* [in] */ IUnknown __RPC_FAR *Source,
            /* [in] */ BSTR InterfaceName) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenObject( 
            /* [in] */ IUnknown __RPC_FAR *Source,
            /* [in] */ BSTR InterfaceName) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveTo( 
            /* [in] */ BSTR SourceURL,
            /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
            /* [optional][in] */ ConnectModeEnum Mode,
            /* [optional][in] */ RecordCreateOptionsEnum CreateOptions,
            /* [optional][in] */ RecordOpenOptionsEnum Options,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ BSTR SourceURL,
            /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
            /* [optional][in] */ ConnectModeEnum Mode,
            /* [defaultvalue][in] */ RecordCreateOptionsEnum CreateOptions,
            /* [optional][in] */ RecordOpenOptionsEnum Options,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveToContainer( 
            /* [in] */ BSTR ContainerURL,
            /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
            /* [optional][in] */ ConnectModeEnum Mode,
            /* [optional][in] */ RecordCreateOptionsEnum CreateOptions,
            /* [optional][in] */ RecordOpenOptionsEnum Options,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDataSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDataSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDataSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDataSource __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDataSource __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDataSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDataSource __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceClass )( 
            IDataSource __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varSourceClass);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            IDataSource __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *varSource);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsDirty )( 
            IDataSource __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsDirty);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsDirty )( 
            IDataSource __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varIsDirty);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceURL )( 
            IDataSource __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varSourceURL);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveConnection )( 
            IDataSource __RPC_FAR * This,
            /* [retval][out] */ _Connection __RPC_FAR *__RPC_FAR *varActiveConnection);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToObject )( 
            IDataSource __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *Source,
            /* [in] */ BSTR InterfaceName);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenObject )( 
            IDataSource __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *Source,
            /* [in] */ BSTR InterfaceName);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveTo )( 
            IDataSource __RPC_FAR * This,
            /* [in] */ BSTR SourceURL,
            /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
            /* [optional][in] */ ConnectModeEnum Mode,
            /* [optional][in] */ RecordCreateOptionsEnum CreateOptions,
            /* [optional][in] */ RecordOpenOptionsEnum Options,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IDataSource __RPC_FAR * This,
            /* [in] */ BSTR SourceURL,
            /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
            /* [optional][in] */ ConnectModeEnum Mode,
            /* [defaultvalue][in] */ RecordCreateOptionsEnum CreateOptions,
            /* [optional][in] */ RecordOpenOptionsEnum Options,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IDataSource __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToContainer )( 
            IDataSource __RPC_FAR * This,
            /* [in] */ BSTR ContainerURL,
            /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
            /* [optional][in] */ ConnectModeEnum Mode,
            /* [optional][in] */ RecordCreateOptionsEnum CreateOptions,
            /* [optional][in] */ RecordOpenOptionsEnum Options,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password);
        
        END_INTERFACE
    } IDataSourceVtbl;

    interface IDataSource
    {
        CONST_VTBL struct IDataSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataSource_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDataSource_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDataSource_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDataSource_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDataSource_get_SourceClass(This,varSourceClass)	\
    (This)->lpVtbl -> get_SourceClass(This,varSourceClass)

#define IDataSource_get_Source(This,varSource)	\
    (This)->lpVtbl -> get_Source(This,varSource)

#define IDataSource_get_IsDirty(This,pIsDirty)	\
    (This)->lpVtbl -> get_IsDirty(This,pIsDirty)

#define IDataSource_put_IsDirty(This,varIsDirty)	\
    (This)->lpVtbl -> put_IsDirty(This,varIsDirty)

#define IDataSource_get_SourceURL(This,varSourceURL)	\
    (This)->lpVtbl -> get_SourceURL(This,varSourceURL)

#define IDataSource_get_ActiveConnection(This,varActiveConnection)	\
    (This)->lpVtbl -> get_ActiveConnection(This,varActiveConnection)

#define IDataSource_SaveToObject(This,Source,InterfaceName)	\
    (This)->lpVtbl -> SaveToObject(This,Source,InterfaceName)

#define IDataSource_OpenObject(This,Source,InterfaceName)	\
    (This)->lpVtbl -> OpenObject(This,Source,InterfaceName)

#define IDataSource_SaveTo(This,SourceURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)	\
    (This)->lpVtbl -> SaveTo(This,SourceURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)

#define IDataSource_Open(This,SourceURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)	\
    (This)->lpVtbl -> Open(This,SourceURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)

#define IDataSource_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IDataSource_SaveToContainer(This,ContainerURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)	\
    (This)->lpVtbl -> SaveToContainer(This,ContainerURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IDataSource_get_SourceClass_Proxy( 
    IDataSource __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varSourceClass);


void __RPC_STUB IDataSource_get_SourceClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IDataSource_get_Source_Proxy( 
    IDataSource __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *varSource);


void __RPC_STUB IDataSource_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IDataSource_get_IsDirty_Proxy( 
    IDataSource __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsDirty);


void __RPC_STUB IDataSource_get_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IDataSource_put_IsDirty_Proxy( 
    IDataSource __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varIsDirty);


void __RPC_STUB IDataSource_put_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IDataSource_get_SourceURL_Proxy( 
    IDataSource __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varSourceURL);


void __RPC_STUB IDataSource_get_SourceURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IDataSource_get_ActiveConnection_Proxy( 
    IDataSource __RPC_FAR * This,
    /* [retval][out] */ _Connection __RPC_FAR *__RPC_FAR *varActiveConnection);


void __RPC_STUB IDataSource_get_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataSource_SaveToObject_Proxy( 
    IDataSource __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *Source,
    /* [in] */ BSTR InterfaceName);


void __RPC_STUB IDataSource_SaveToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataSource_OpenObject_Proxy( 
    IDataSource __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *Source,
    /* [in] */ BSTR InterfaceName);


void __RPC_STUB IDataSource_OpenObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataSource_SaveTo_Proxy( 
    IDataSource __RPC_FAR * This,
    /* [in] */ BSTR SourceURL,
    /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
    /* [optional][in] */ ConnectModeEnum Mode,
    /* [optional][in] */ RecordCreateOptionsEnum CreateOptions,
    /* [optional][in] */ RecordOpenOptionsEnum Options,
    /* [optional][in] */ BSTR UserName,
    /* [optional][in] */ BSTR Password);


void __RPC_STUB IDataSource_SaveTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataSource_Open_Proxy( 
    IDataSource __RPC_FAR * This,
    /* [in] */ BSTR SourceURL,
    /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
    /* [optional][in] */ ConnectModeEnum Mode,
    /* [defaultvalue][in] */ RecordCreateOptionsEnum CreateOptions,
    /* [optional][in] */ RecordOpenOptionsEnum Options,
    /* [optional][in] */ BSTR UserName,
    /* [optional][in] */ BSTR Password);


void __RPC_STUB IDataSource_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataSource_Save_Proxy( 
    IDataSource __RPC_FAR * This);


void __RPC_STUB IDataSource_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataSource_SaveToContainer_Proxy( 
    IDataSource __RPC_FAR * This,
    /* [in] */ BSTR ContainerURL,
    /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
    /* [optional][in] */ ConnectModeEnum Mode,
    /* [optional][in] */ RecordCreateOptionsEnum CreateOptions,
    /* [optional][in] */ RecordOpenOptionsEnum Options,
    /* [optional][in] */ BSTR UserName,
    /* [optional][in] */ BSTR Password);


void __RPC_STUB IDataSource_SaveToContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataSource_INTERFACE_DEFINED__ */


#ifndef __IMessage_INTERFACE_DEFINED__
#define __IMessage_INTERFACE_DEFINED__

/* interface IMessage */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IMessage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000020-8B95-11D1-82DB-00C04FB1625D")
    IMessage : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BCC( 
            /* [retval][out] */ BSTR __RPC_FAR *pBCC) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BCC( 
            /* [in] */ BSTR varBCC) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CC( 
            /* [retval][out] */ BSTR __RPC_FAR *pCC) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_CC( 
            /* [in] */ BSTR varCC) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FollowUpTo( 
            /* [retval][out] */ BSTR __RPC_FAR *pFollowUpTo) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FollowUpTo( 
            /* [in] */ BSTR varFollowUpTo) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_From( 
            /* [retval][out] */ BSTR __RPC_FAR *pFrom) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_From( 
            /* [in] */ BSTR varFrom) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Keywords( 
            /* [retval][out] */ BSTR __RPC_FAR *pKeywords) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Keywords( 
            /* [in] */ BSTR varKeywords) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MimeFormatted( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMimeFormatted) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MimeFormatted( 
            /* [in] */ VARIANT_BOOL varMimeFormatted) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Newsgroups( 
            /* [retval][out] */ BSTR __RPC_FAR *pNewsgroups) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Newsgroups( 
            /* [in] */ BSTR varNewsgroups) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Organization( 
            /* [retval][out] */ BSTR __RPC_FAR *pOrganization) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Organization( 
            /* [in] */ BSTR varOrganization) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReceivedTime( 
            /* [retval][out] */ DATE __RPC_FAR *varReceivedTime) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReplyTo( 
            /* [retval][out] */ BSTR __RPC_FAR *pReplyTo) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReplyTo( 
            /* [in] */ BSTR varReplyTo) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DSNOptions( 
            /* [retval][out] */ CdoDSNOptions __RPC_FAR *pDSNOptions) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DSNOptions( 
            /* [in] */ CdoDSNOptions varDSNOptions) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SentOn( 
            /* [retval][out] */ DATE __RPC_FAR *varSentOn) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Subject( 
            /* [retval][out] */ BSTR __RPC_FAR *pSubject) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Subject( 
            /* [in] */ BSTR varSubject) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_To( 
            /* [retval][out] */ BSTR __RPC_FAR *pTo) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_To( 
            /* [in] */ BSTR varTo) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TextBody( 
            /* [retval][out] */ BSTR __RPC_FAR *pTextBody) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TextBody( 
            /* [in] */ BSTR varTextBody) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HTMLBody( 
            /* [retval][out] */ BSTR __RPC_FAR *pHTMLBody) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HTMLBody( 
            /* [in] */ BSTR varHTMLBody) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Attachments( 
            /* [retval][out] */ IBodyParts __RPC_FAR *__RPC_FAR *varAttachments) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Sender( 
            /* [retval][out] */ BSTR __RPC_FAR *pSender) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Sender( 
            /* [in] */ BSTR varSender) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Configuration( 
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoGenerateTextBody( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoGenerateTextBody) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoGenerateTextBody( 
            /* [in] */ VARIANT_BOOL varAutoGenerateTextBody) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EnvelopeFields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varEnvelopeFields) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TextBodyPart( 
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varTextBodyPart) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HTMLBodyPart( 
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varHTMLBodyPart) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BodyPart( 
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varBodyPart) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MDNRequested( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMDNRequested) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MDNRequested( 
            /* [in] */ VARIANT_BOOL varMDNRequested) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE AddRelatedBodyPart( 
            /* [in] */ BSTR URL,
            /* [in] */ BSTR Reference,
            /* [in] */ CdoReferenceType ReferenceType,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppBody) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE AddAttachment( 
            /* [in] */ BSTR URL,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppBody) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateMHTMLBody( 
            /* [in] */ BSTR URL,
            /* [defaultvalue][in] */ CdoMHTMLFlags Flags,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Forward( 
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Post( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE PostReply( 
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Reply( 
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ReplyAll( 
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Send( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMessageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMessage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMessage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMessage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMessage __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMessage __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMessage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMessage __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BCC )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pBCC);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BCC )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varBCC);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CC )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pCC);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CC )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varCC);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FollowUpTo )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pFollowUpTo);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FollowUpTo )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varFollowUpTo);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_From )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pFrom);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_From )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varFrom);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Keywords )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pKeywords);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Keywords )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varKeywords);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MimeFormatted )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMimeFormatted);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MimeFormatted )( 
            IMessage __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varMimeFormatted);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Newsgroups )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pNewsgroups);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Newsgroups )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varNewsgroups);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Organization )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pOrganization);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Organization )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varOrganization);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReceivedTime )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *varReceivedTime);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReplyTo )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pReplyTo);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReplyTo )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varReplyTo);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DSNOptions )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ CdoDSNOptions __RPC_FAR *pDSNOptions);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DSNOptions )( 
            IMessage __RPC_FAR * This,
            /* [in] */ CdoDSNOptions varDSNOptions);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SentOn )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *varSentOn);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Subject )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pSubject);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Subject )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varSubject);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_To )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pTo);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_To )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varTo);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TextBody )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pTextBody);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TextBody )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varTextBody);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HTMLBody )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pHTMLBody);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HTMLBody )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varHTMLBody);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attachments )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ IBodyParts __RPC_FAR *__RPC_FAR *varAttachments);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Sender )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pSender);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Sender )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR varSender);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Configuration )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Configuration )( 
            IMessage __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Configuration )( 
            IMessage __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoGenerateTextBody )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoGenerateTextBody);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoGenerateTextBody )( 
            IMessage __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varAutoGenerateTextBody);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnvelopeFields )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varEnvelopeFields);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TextBodyPart )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varTextBodyPart);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HTMLBodyPart )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varHTMLBodyPart);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BodyPart )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varBodyPart);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MDNRequested )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMDNRequested);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MDNRequested )( 
            IMessage __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varMDNRequested);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRelatedBodyPart )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in] */ BSTR Reference,
            /* [in] */ CdoReferenceType ReferenceType,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppBody);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddAttachment )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppBody);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateMHTMLBody )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [defaultvalue][in] */ CdoMHTMLFlags Flags,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Forward )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Post )( 
            IMessage __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PostReply )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reply )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReplyAll )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Send )( 
            IMessage __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IMessage __RPC_FAR * This,
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IMessage __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IMessageVtbl;

    interface IMessage
    {
        CONST_VTBL struct IMessageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMessage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMessage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMessage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMessage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMessage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMessage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMessage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMessage_get_BCC(This,pBCC)	\
    (This)->lpVtbl -> get_BCC(This,pBCC)

#define IMessage_put_BCC(This,varBCC)	\
    (This)->lpVtbl -> put_BCC(This,varBCC)

#define IMessage_get_CC(This,pCC)	\
    (This)->lpVtbl -> get_CC(This,pCC)

#define IMessage_put_CC(This,varCC)	\
    (This)->lpVtbl -> put_CC(This,varCC)

#define IMessage_get_FollowUpTo(This,pFollowUpTo)	\
    (This)->lpVtbl -> get_FollowUpTo(This,pFollowUpTo)

#define IMessage_put_FollowUpTo(This,varFollowUpTo)	\
    (This)->lpVtbl -> put_FollowUpTo(This,varFollowUpTo)

#define IMessage_get_From(This,pFrom)	\
    (This)->lpVtbl -> get_From(This,pFrom)

#define IMessage_put_From(This,varFrom)	\
    (This)->lpVtbl -> put_From(This,varFrom)

#define IMessage_get_Keywords(This,pKeywords)	\
    (This)->lpVtbl -> get_Keywords(This,pKeywords)

#define IMessage_put_Keywords(This,varKeywords)	\
    (This)->lpVtbl -> put_Keywords(This,varKeywords)

#define IMessage_get_MimeFormatted(This,pMimeFormatted)	\
    (This)->lpVtbl -> get_MimeFormatted(This,pMimeFormatted)

#define IMessage_put_MimeFormatted(This,varMimeFormatted)	\
    (This)->lpVtbl -> put_MimeFormatted(This,varMimeFormatted)

#define IMessage_get_Newsgroups(This,pNewsgroups)	\
    (This)->lpVtbl -> get_Newsgroups(This,pNewsgroups)

#define IMessage_put_Newsgroups(This,varNewsgroups)	\
    (This)->lpVtbl -> put_Newsgroups(This,varNewsgroups)

#define IMessage_get_Organization(This,pOrganization)	\
    (This)->lpVtbl -> get_Organization(This,pOrganization)

#define IMessage_put_Organization(This,varOrganization)	\
    (This)->lpVtbl -> put_Organization(This,varOrganization)

#define IMessage_get_ReceivedTime(This,varReceivedTime)	\
    (This)->lpVtbl -> get_ReceivedTime(This,varReceivedTime)

#define IMessage_get_ReplyTo(This,pReplyTo)	\
    (This)->lpVtbl -> get_ReplyTo(This,pReplyTo)

#define IMessage_put_ReplyTo(This,varReplyTo)	\
    (This)->lpVtbl -> put_ReplyTo(This,varReplyTo)

#define IMessage_get_DSNOptions(This,pDSNOptions)	\
    (This)->lpVtbl -> get_DSNOptions(This,pDSNOptions)

#define IMessage_put_DSNOptions(This,varDSNOptions)	\
    (This)->lpVtbl -> put_DSNOptions(This,varDSNOptions)

#define IMessage_get_SentOn(This,varSentOn)	\
    (This)->lpVtbl -> get_SentOn(This,varSentOn)

#define IMessage_get_Subject(This,pSubject)	\
    (This)->lpVtbl -> get_Subject(This,pSubject)

#define IMessage_put_Subject(This,varSubject)	\
    (This)->lpVtbl -> put_Subject(This,varSubject)

#define IMessage_get_To(This,pTo)	\
    (This)->lpVtbl -> get_To(This,pTo)

#define IMessage_put_To(This,varTo)	\
    (This)->lpVtbl -> put_To(This,varTo)

#define IMessage_get_TextBody(This,pTextBody)	\
    (This)->lpVtbl -> get_TextBody(This,pTextBody)

#define IMessage_put_TextBody(This,varTextBody)	\
    (This)->lpVtbl -> put_TextBody(This,varTextBody)

#define IMessage_get_HTMLBody(This,pHTMLBody)	\
    (This)->lpVtbl -> get_HTMLBody(This,pHTMLBody)

#define IMessage_put_HTMLBody(This,varHTMLBody)	\
    (This)->lpVtbl -> put_HTMLBody(This,varHTMLBody)

#define IMessage_get_Attachments(This,varAttachments)	\
    (This)->lpVtbl -> get_Attachments(This,varAttachments)

#define IMessage_get_Sender(This,pSender)	\
    (This)->lpVtbl -> get_Sender(This,pSender)

#define IMessage_put_Sender(This,varSender)	\
    (This)->lpVtbl -> put_Sender(This,varSender)

#define IMessage_get_Configuration(This,pConfiguration)	\
    (This)->lpVtbl -> get_Configuration(This,pConfiguration)

#define IMessage_put_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> put_Configuration(This,varConfiguration)

#define IMessage_putref_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> putref_Configuration(This,varConfiguration)

#define IMessage_get_AutoGenerateTextBody(This,pAutoGenerateTextBody)	\
    (This)->lpVtbl -> get_AutoGenerateTextBody(This,pAutoGenerateTextBody)

#define IMessage_put_AutoGenerateTextBody(This,varAutoGenerateTextBody)	\
    (This)->lpVtbl -> put_AutoGenerateTextBody(This,varAutoGenerateTextBody)

#define IMessage_get_EnvelopeFields(This,varEnvelopeFields)	\
    (This)->lpVtbl -> get_EnvelopeFields(This,varEnvelopeFields)

#define IMessage_get_TextBodyPart(This,varTextBodyPart)	\
    (This)->lpVtbl -> get_TextBodyPart(This,varTextBodyPart)

#define IMessage_get_HTMLBodyPart(This,varHTMLBodyPart)	\
    (This)->lpVtbl -> get_HTMLBodyPart(This,varHTMLBodyPart)

#define IMessage_get_BodyPart(This,varBodyPart)	\
    (This)->lpVtbl -> get_BodyPart(This,varBodyPart)

#define IMessage_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IMessage_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IMessage_get_MDNRequested(This,pMDNRequested)	\
    (This)->lpVtbl -> get_MDNRequested(This,pMDNRequested)

#define IMessage_put_MDNRequested(This,varMDNRequested)	\
    (This)->lpVtbl -> put_MDNRequested(This,varMDNRequested)

#define IMessage_AddRelatedBodyPart(This,URL,Reference,ReferenceType,UserName,Password,ppBody)	\
    (This)->lpVtbl -> AddRelatedBodyPart(This,URL,Reference,ReferenceType,UserName,Password,ppBody)

#define IMessage_AddAttachment(This,URL,UserName,Password,ppBody)	\
    (This)->lpVtbl -> AddAttachment(This,URL,UserName,Password,ppBody)

#define IMessage_CreateMHTMLBody(This,URL,Flags,UserName,Password)	\
    (This)->lpVtbl -> CreateMHTMLBody(This,URL,Flags,UserName,Password)

#define IMessage_Forward(This,ppMsg)	\
    (This)->lpVtbl -> Forward(This,ppMsg)

#define IMessage_Post(This)	\
    (This)->lpVtbl -> Post(This)

#define IMessage_PostReply(This,ppMsg)	\
    (This)->lpVtbl -> PostReply(This,ppMsg)

#define IMessage_Reply(This,ppMsg)	\
    (This)->lpVtbl -> Reply(This,ppMsg)

#define IMessage_ReplyAll(This,ppMsg)	\
    (This)->lpVtbl -> ReplyAll(This,ppMsg)

#define IMessage_Send(This)	\
    (This)->lpVtbl -> Send(This)

#define IMessage_GetStream(This,ppStream)	\
    (This)->lpVtbl -> GetStream(This,ppStream)

#define IMessage_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_BCC_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pBCC);


void __RPC_STUB IMessage_get_BCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_BCC_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varBCC);


void __RPC_STUB IMessage_put_BCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_CC_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pCC);


void __RPC_STUB IMessage_get_CC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_CC_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varCC);


void __RPC_STUB IMessage_put_CC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_FollowUpTo_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pFollowUpTo);


void __RPC_STUB IMessage_get_FollowUpTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_FollowUpTo_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varFollowUpTo);


void __RPC_STUB IMessage_put_FollowUpTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_From_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pFrom);


void __RPC_STUB IMessage_get_From_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_From_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varFrom);


void __RPC_STUB IMessage_put_From_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_Keywords_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pKeywords);


void __RPC_STUB IMessage_get_Keywords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_Keywords_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varKeywords);


void __RPC_STUB IMessage_put_Keywords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_MimeFormatted_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMimeFormatted);


void __RPC_STUB IMessage_get_MimeFormatted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_MimeFormatted_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varMimeFormatted);


void __RPC_STUB IMessage_put_MimeFormatted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_Newsgroups_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pNewsgroups);


void __RPC_STUB IMessage_get_Newsgroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_Newsgroups_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varNewsgroups);


void __RPC_STUB IMessage_put_Newsgroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_Organization_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pOrganization);


void __RPC_STUB IMessage_get_Organization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_Organization_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varOrganization);


void __RPC_STUB IMessage_put_Organization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_ReceivedTime_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *varReceivedTime);


void __RPC_STUB IMessage_get_ReceivedTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_ReplyTo_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pReplyTo);


void __RPC_STUB IMessage_get_ReplyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_ReplyTo_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varReplyTo);


void __RPC_STUB IMessage_put_ReplyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_DSNOptions_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ CdoDSNOptions __RPC_FAR *pDSNOptions);


void __RPC_STUB IMessage_get_DSNOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_DSNOptions_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ CdoDSNOptions varDSNOptions);


void __RPC_STUB IMessage_put_DSNOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_SentOn_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *varSentOn);


void __RPC_STUB IMessage_get_SentOn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_Subject_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pSubject);


void __RPC_STUB IMessage_get_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_Subject_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varSubject);


void __RPC_STUB IMessage_put_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_To_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pTo);


void __RPC_STUB IMessage_get_To_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_To_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varTo);


void __RPC_STUB IMessage_put_To_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_TextBody_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pTextBody);


void __RPC_STUB IMessage_get_TextBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_TextBody_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varTextBody);


void __RPC_STUB IMessage_put_TextBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_HTMLBody_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pHTMLBody);


void __RPC_STUB IMessage_get_HTMLBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_HTMLBody_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varHTMLBody);


void __RPC_STUB IMessage_put_HTMLBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_Attachments_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ IBodyParts __RPC_FAR *__RPC_FAR *varAttachments);


void __RPC_STUB IMessage_get_Attachments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_Sender_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pSender);


void __RPC_STUB IMessage_get_Sender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_Sender_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR varSender);


void __RPC_STUB IMessage_put_Sender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_Configuration_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);


void __RPC_STUB IMessage_get_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_Configuration_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IMessage_put_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IMessage_putref_Configuration_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IMessage_putref_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_AutoGenerateTextBody_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoGenerateTextBody);


void __RPC_STUB IMessage_get_AutoGenerateTextBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_AutoGenerateTextBody_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varAutoGenerateTextBody);


void __RPC_STUB IMessage_put_AutoGenerateTextBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_EnvelopeFields_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varEnvelopeFields);


void __RPC_STUB IMessage_get_EnvelopeFields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_TextBodyPart_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varTextBodyPart);


void __RPC_STUB IMessage_get_TextBodyPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_HTMLBodyPart_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varHTMLBodyPart);


void __RPC_STUB IMessage_get_HTMLBodyPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_BodyPart_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varBodyPart);


void __RPC_STUB IMessage_get_BodyPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_DataSource_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IMessage_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_Fields_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IMessage_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessage_get_MDNRequested_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMDNRequested);


void __RPC_STUB IMessage_get_MDNRequested_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMessage_put_MDNRequested_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varMDNRequested);


void __RPC_STUB IMessage_put_MDNRequested_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessage_AddRelatedBodyPart_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [in] */ BSTR Reference,
    /* [in] */ CdoReferenceType ReferenceType,
    /* [optional][in] */ BSTR UserName,
    /* [optional][in] */ BSTR Password,
    /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppBody);


void __RPC_STUB IMessage_AddRelatedBodyPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessage_AddAttachment_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [optional][in] */ BSTR UserName,
    /* [optional][in] */ BSTR Password,
    /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppBody);


void __RPC_STUB IMessage_AddAttachment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessage_CreateMHTMLBody_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [defaultvalue][in] */ CdoMHTMLFlags Flags,
    /* [optional][in] */ BSTR UserName,
    /* [optional][in] */ BSTR Password);


void __RPC_STUB IMessage_CreateMHTMLBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessage_Forward_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg);


void __RPC_STUB IMessage_Forward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessage_Post_Proxy( 
    IMessage __RPC_FAR * This);


void __RPC_STUB IMessage_Post_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessage_PostReply_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg);


void __RPC_STUB IMessage_PostReply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessage_Reply_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg);


void __RPC_STUB IMessage_Reply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessage_ReplyAll_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMsg);


void __RPC_STUB IMessage_ReplyAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessage_Send_Proxy( 
    IMessage __RPC_FAR * This);


void __RPC_STUB IMessage_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessage_GetStream_Proxy( 
    IMessage __RPC_FAR * This,
    /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IMessage_GetStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessage_GetInterface_Proxy( 
    IMessage __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IMessage_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMessage_INTERFACE_DEFINED__ */


#ifndef __IBodyPart_INTERFACE_DEFINED__
#define __IBodyPart_INTERFACE_DEFINED__

/* interface IBodyPart */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IBodyPart;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000021-8B95-11D1-82DB-00C04FB1625D")
    IBodyPart : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BodyParts( 
            /* [retval][out] */ IBodyParts __RPC_FAR *__RPC_FAR *varBodyParts) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentTransferEncoding( 
            /* [retval][out] */ BSTR __RPC_FAR *pContentTransferEncoding) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ContentTransferEncoding( 
            /* [in] */ BSTR varContentTransferEncoding) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentMediaType( 
            /* [retval][out] */ BSTR __RPC_FAR *pContentMediaType) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ContentMediaType( 
            /* [in] */ BSTR varContentMediaType) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Charset( 
            /* [retval][out] */ BSTR __RPC_FAR *pCharset) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Charset( 
            /* [in] */ BSTR varCharset) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR __RPC_FAR *varFileName) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentClass( 
            /* [retval][out] */ BSTR __RPC_FAR *pContentClass) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ContentClass( 
            /* [in] */ BSTR varContentClass) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *pContentClassName) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ContentClassName( 
            /* [in] */ BSTR varContentClassName) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varParent) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE AddBodyPart( 
            /* [defaultvalue][in] */ long Index,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppPart) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveToFile( 
            /* [in] */ BSTR FileName) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEncodedContentStream( 
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDecodedContentStream( 
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFieldParameter( 
            /* [in] */ BSTR FieldName,
            /* [in] */ BSTR Parameter,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBodyPartVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBodyPart __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBodyPart __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBodyPart __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BodyParts )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ IBodyParts __RPC_FAR *__RPC_FAR *varBodyParts);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentTransferEncoding )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pContentTransferEncoding);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentTransferEncoding )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ BSTR varContentTransferEncoding);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentMediaType )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pContentMediaType);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentMediaType )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ BSTR varContentMediaType);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Charset )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pCharset);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Charset )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ BSTR varCharset);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FileName )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varFileName);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentClass )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pContentClass);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentClass )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ BSTR varContentClass);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentClassName )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pContentClassName);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentClassName )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ BSTR varContentClassName);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varParent);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddBodyPart )( 
            IBodyPart __RPC_FAR * This,
            /* [defaultvalue][in] */ long Index,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppPart);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToFile )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ BSTR FileName);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEncodedContentStream )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDecodedContentStream )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IBodyPart __RPC_FAR * This,
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFieldParameter )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ BSTR FieldName,
            /* [in] */ BSTR Parameter,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IBodyPart __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IBodyPartVtbl;

    interface IBodyPart
    {
        CONST_VTBL struct IBodyPartVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBodyPart_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBodyPart_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBodyPart_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBodyPart_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBodyPart_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBodyPart_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBodyPart_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBodyPart_get_BodyParts(This,varBodyParts)	\
    (This)->lpVtbl -> get_BodyParts(This,varBodyParts)

#define IBodyPart_get_ContentTransferEncoding(This,pContentTransferEncoding)	\
    (This)->lpVtbl -> get_ContentTransferEncoding(This,pContentTransferEncoding)

#define IBodyPart_put_ContentTransferEncoding(This,varContentTransferEncoding)	\
    (This)->lpVtbl -> put_ContentTransferEncoding(This,varContentTransferEncoding)

#define IBodyPart_get_ContentMediaType(This,pContentMediaType)	\
    (This)->lpVtbl -> get_ContentMediaType(This,pContentMediaType)

#define IBodyPart_put_ContentMediaType(This,varContentMediaType)	\
    (This)->lpVtbl -> put_ContentMediaType(This,varContentMediaType)

#define IBodyPart_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IBodyPart_get_Charset(This,pCharset)	\
    (This)->lpVtbl -> get_Charset(This,pCharset)

#define IBodyPart_put_Charset(This,varCharset)	\
    (This)->lpVtbl -> put_Charset(This,varCharset)

#define IBodyPart_get_FileName(This,varFileName)	\
    (This)->lpVtbl -> get_FileName(This,varFileName)

#define IBodyPart_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IBodyPart_get_ContentClass(This,pContentClass)	\
    (This)->lpVtbl -> get_ContentClass(This,pContentClass)

#define IBodyPart_put_ContentClass(This,varContentClass)	\
    (This)->lpVtbl -> put_ContentClass(This,varContentClass)

#define IBodyPart_get_ContentClassName(This,pContentClassName)	\
    (This)->lpVtbl -> get_ContentClassName(This,pContentClassName)

#define IBodyPart_put_ContentClassName(This,varContentClassName)	\
    (This)->lpVtbl -> put_ContentClassName(This,varContentClassName)

#define IBodyPart_get_Parent(This,varParent)	\
    (This)->lpVtbl -> get_Parent(This,varParent)

#define IBodyPart_AddBodyPart(This,Index,ppPart)	\
    (This)->lpVtbl -> AddBodyPart(This,Index,ppPart)

#define IBodyPart_SaveToFile(This,FileName)	\
    (This)->lpVtbl -> SaveToFile(This,FileName)

#define IBodyPart_GetEncodedContentStream(This,ppStream)	\
    (This)->lpVtbl -> GetEncodedContentStream(This,ppStream)

#define IBodyPart_GetDecodedContentStream(This,ppStream)	\
    (This)->lpVtbl -> GetDecodedContentStream(This,ppStream)

#define IBodyPart_GetStream(This,ppStream)	\
    (This)->lpVtbl -> GetStream(This,ppStream)

#define IBodyPart_GetFieldParameter(This,FieldName,Parameter,pbstrValue)	\
    (This)->lpVtbl -> GetFieldParameter(This,FieldName,Parameter,pbstrValue)

#define IBodyPart_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_get_BodyParts_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ IBodyParts __RPC_FAR *__RPC_FAR *varBodyParts);


void __RPC_STUB IBodyPart_get_BodyParts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_get_ContentTransferEncoding_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pContentTransferEncoding);


void __RPC_STUB IBodyPart_get_ContentTransferEncoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_put_ContentTransferEncoding_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [in] */ BSTR varContentTransferEncoding);


void __RPC_STUB IBodyPart_put_ContentTransferEncoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_get_ContentMediaType_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pContentMediaType);


void __RPC_STUB IBodyPart_get_ContentMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_put_ContentMediaType_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [in] */ BSTR varContentMediaType);


void __RPC_STUB IBodyPart_put_ContentMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_get_Fields_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IBodyPart_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_get_Charset_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pCharset);


void __RPC_STUB IBodyPart_get_Charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_put_Charset_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [in] */ BSTR varCharset);


void __RPC_STUB IBodyPart_put_Charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_get_FileName_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varFileName);


void __RPC_STUB IBodyPart_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_get_DataSource_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IBodyPart_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_get_ContentClass_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pContentClass);


void __RPC_STUB IBodyPart_get_ContentClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_put_ContentClass_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [in] */ BSTR varContentClass);


void __RPC_STUB IBodyPart_put_ContentClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_get_ContentClassName_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pContentClassName);


void __RPC_STUB IBodyPart_get_ContentClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_put_ContentClassName_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [in] */ BSTR varContentClassName);


void __RPC_STUB IBodyPart_put_ContentClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_get_Parent_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varParent);


void __RPC_STUB IBodyPart_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_AddBodyPart_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [defaultvalue][in] */ long Index,
    /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppPart);


void __RPC_STUB IBodyPart_AddBodyPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_SaveToFile_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [in] */ BSTR FileName);


void __RPC_STUB IBodyPart_SaveToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_GetEncodedContentStream_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IBodyPart_GetEncodedContentStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_GetDecodedContentStream_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IBodyPart_GetDecodedContentStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_GetStream_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IBodyPart_GetStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_GetFieldParameter_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [in] */ BSTR FieldName,
    /* [in] */ BSTR Parameter,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);


void __RPC_STUB IBodyPart_GetFieldParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IBodyPart_GetInterface_Proxy( 
    IBodyPart __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IBodyPart_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBodyPart_INTERFACE_DEFINED__ */


#ifndef __IConfiguration_INTERFACE_DEFINED__
#define __IConfiguration_INTERFACE_DEFINED__

/* interface IConfiguration */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IConfiguration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000022-8B95-11D1-82DB-00C04FB1625D")
    IConfiguration : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ CdoConfigSource LoadFrom,
            /* [optional][in] */ BSTR URL) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigurationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConfiguration __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConfiguration __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConfiguration __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IConfiguration __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IConfiguration __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IConfiguration __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IConfiguration __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IConfiguration __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IConfiguration __RPC_FAR * This,
            /* [in] */ CdoConfigSource LoadFrom,
            /* [optional][in] */ BSTR URL);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IConfiguration __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IConfigurationVtbl;

    interface IConfiguration
    {
        CONST_VTBL struct IConfigurationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfiguration_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConfiguration_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConfiguration_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConfiguration_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IConfiguration_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IConfiguration_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IConfiguration_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IConfiguration_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IConfiguration_Load(This,LoadFrom,URL)	\
    (This)->lpVtbl -> Load(This,LoadFrom,URL)

#define IConfiguration_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IConfiguration_get_Fields_Proxy( 
    IConfiguration __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IConfiguration_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IConfiguration_Load_Proxy( 
    IConfiguration __RPC_FAR * This,
    /* [in] */ CdoConfigSource LoadFrom,
    /* [optional][in] */ BSTR URL);


void __RPC_STUB IConfiguration_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IConfiguration_GetInterface_Proxy( 
    IConfiguration __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IConfiguration_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConfiguration_INTERFACE_DEFINED__ */


#ifndef __IMessages_INTERFACE_DEFINED__
#define __IMessages_INTERFACE_DEFINED__

/* interface IMessages */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IMessages;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000025-8B95-11D1-82DB-00C04FB1625D")
    IMessages : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMessage) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *varCount) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ long Index) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Filename( 
            VARIANT var,
            /* [retval][out] */ BSTR __RPC_FAR *Filename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMessagesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMessages __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMessages __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMessages __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMessages __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMessages __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMessages __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMessages __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IMessages __RPC_FAR * This,
            long Index,
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMessage);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMessages __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varCount);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IMessages __RPC_FAR * This,
            /* [in] */ long Index);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAll )( 
            IMessages __RPC_FAR * This);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMessages __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Filename )( 
            IMessages __RPC_FAR * This,
            VARIANT var,
            /* [retval][out] */ BSTR __RPC_FAR *Filename);
        
        END_INTERFACE
    } IMessagesVtbl;

    interface IMessages
    {
        CONST_VTBL struct IMessagesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMessages_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMessages_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMessages_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMessages_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMessages_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMessages_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMessages_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMessages_get_Item(This,Index,ppMessage)	\
    (This)->lpVtbl -> get_Item(This,Index,ppMessage)

#define IMessages_get_Count(This,varCount)	\
    (This)->lpVtbl -> get_Count(This,varCount)

#define IMessages_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)

#define IMessages_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#define IMessages_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#define IMessages_get_Filename(This,var,Filename)	\
    (This)->lpVtbl -> get_Filename(This,var,Filename)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessages_get_Item_Proxy( 
    IMessages __RPC_FAR * This,
    long Index,
    /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *ppMessage);


void __RPC_STUB IMessages_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessages_get_Count_Proxy( 
    IMessages __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varCount);


void __RPC_STUB IMessages_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessages_Delete_Proxy( 
    IMessages __RPC_FAR * This,
    /* [in] */ long Index);


void __RPC_STUB IMessages_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessages_DeleteAll_Proxy( 
    IMessages __RPC_FAR * This);


void __RPC_STUB IMessages_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IMessages_get__NewEnum_Proxy( 
    IMessages __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IMessages_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessages_get_Filename_Proxy( 
    IMessages __RPC_FAR * This,
    VARIANT var,
    /* [retval][out] */ BSTR __RPC_FAR *Filename);


void __RPC_STUB IMessages_get_Filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMessages_INTERFACE_DEFINED__ */


#ifndef __IDropDirectory_INTERFACE_DEFINED__
#define __IDropDirectory_INTERFACE_DEFINED__

/* interface IDropDirectory */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IDropDirectory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000024-8B95-11D1-82DB-00C04FB1625D")
    IDropDirectory : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessages( 
            /* [optional][in] */ BSTR DirName,
            /* [retval][out] */ IMessages __RPC_FAR *__RPC_FAR *Msgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDropDirectoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDropDirectory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDropDirectory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDropDirectory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDropDirectory __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDropDirectory __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDropDirectory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDropDirectory __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessages )( 
            IDropDirectory __RPC_FAR * This,
            /* [optional][in] */ BSTR DirName,
            /* [retval][out] */ IMessages __RPC_FAR *__RPC_FAR *Msgs);
        
        END_INTERFACE
    } IDropDirectoryVtbl;

    interface IDropDirectory
    {
        CONST_VTBL struct IDropDirectoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDropDirectory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDropDirectory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDropDirectory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDropDirectory_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDropDirectory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDropDirectory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDropDirectory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDropDirectory_GetMessages(This,DirName,Msgs)	\
    (This)->lpVtbl -> GetMessages(This,DirName,Msgs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDropDirectory_GetMessages_Proxy( 
    IDropDirectory __RPC_FAR * This,
    /* [optional][in] */ BSTR DirName,
    /* [retval][out] */ IMessages __RPC_FAR *__RPC_FAR *Msgs);


void __RPC_STUB IDropDirectory_GetMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDropDirectory_INTERFACE_DEFINED__ */


#ifndef __IBodyParts_INTERFACE_DEFINED__
#define __IBodyParts_INTERFACE_DEFINED__

/* interface IBodyParts */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IBodyParts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000023-8B95-11D1-82DB-00C04FB1625D")
    IBodyParts : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *varCount) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Index,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppBody) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ VARIANT varBP) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [defaultvalue][in] */ long Index,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppPart) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBodyPartsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBodyParts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBodyParts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBodyParts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBodyParts __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBodyParts __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBodyParts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBodyParts __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IBodyParts __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varCount);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IBodyParts __RPC_FAR * This,
            /* [in] */ long Index,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppBody);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IBodyParts __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IBodyParts __RPC_FAR * This,
            /* [in] */ VARIANT varBP);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAll )( 
            IBodyParts __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IBodyParts __RPC_FAR * This,
            /* [defaultvalue][in] */ long Index,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppPart);
        
        END_INTERFACE
    } IBodyPartsVtbl;

    interface IBodyParts
    {
        CONST_VTBL struct IBodyPartsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBodyParts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBodyParts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBodyParts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBodyParts_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBodyParts_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBodyParts_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBodyParts_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBodyParts_get_Count(This,varCount)	\
    (This)->lpVtbl -> get_Count(This,varCount)

#define IBodyParts_get_Item(This,Index,ppBody)	\
    (This)->lpVtbl -> get_Item(This,Index,ppBody)

#define IBodyParts_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#define IBodyParts_Delete(This,varBP)	\
    (This)->lpVtbl -> Delete(This,varBP)

#define IBodyParts_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#define IBodyParts_Add(This,Index,ppPart)	\
    (This)->lpVtbl -> Add(This,Index,ppPart)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyParts_get_Count_Proxy( 
    IBodyParts __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varCount);


void __RPC_STUB IBodyParts_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IBodyParts_get_Item_Proxy( 
    IBodyParts __RPC_FAR * This,
    /* [in] */ long Index,
    /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppBody);


void __RPC_STUB IBodyParts_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IBodyParts_get__NewEnum_Proxy( 
    IBodyParts __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IBodyParts_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IBodyParts_Delete_Proxy( 
    IBodyParts __RPC_FAR * This,
    /* [in] */ VARIANT varBP);


void __RPC_STUB IBodyParts_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IBodyParts_DeleteAll_Proxy( 
    IBodyParts __RPC_FAR * This);


void __RPC_STUB IBodyParts_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IBodyParts_Add_Proxy( 
    IBodyParts __RPC_FAR * This,
    /* [defaultvalue][in] */ long Index,
    /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *ppPart);


void __RPC_STUB IBodyParts_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBodyParts_INTERFACE_DEFINED__ */


#ifndef __ISMTPScriptConnector_INTERFACE_DEFINED__
#define __ISMTPScriptConnector_INTERFACE_DEFINED__

/* interface ISMTPScriptConnector */
/* [hidden][unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ISMTPScriptConnector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000030-8B95-11D1-82DB-00C04FB1625D")
    ISMTPScriptConnector : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ISMTPScriptConnectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISMTPScriptConnector __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISMTPScriptConnector __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISMTPScriptConnector __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISMTPScriptConnector __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISMTPScriptConnector __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISMTPScriptConnector __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISMTPScriptConnector __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } ISMTPScriptConnectorVtbl;

    interface ISMTPScriptConnector
    {
        CONST_VTBL struct ISMTPScriptConnectorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISMTPScriptConnector_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISMTPScriptConnector_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISMTPScriptConnector_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISMTPScriptConnector_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISMTPScriptConnector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISMTPScriptConnector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISMTPScriptConnector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISMTPScriptConnector_INTERFACE_DEFINED__ */


#ifndef __INNTPEarlyScriptConnector_INTERFACE_DEFINED__
#define __INNTPEarlyScriptConnector_INTERFACE_DEFINED__

/* interface INNTPEarlyScriptConnector */
/* [hidden][unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_INNTPEarlyScriptConnector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000034-8B95-11D1-82DB-00C04FB1625D")
    INNTPEarlyScriptConnector : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct INNTPEarlyScriptConnectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INNTPEarlyScriptConnector __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INNTPEarlyScriptConnector __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INNTPEarlyScriptConnector __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            INNTPEarlyScriptConnector __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            INNTPEarlyScriptConnector __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            INNTPEarlyScriptConnector __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            INNTPEarlyScriptConnector __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } INNTPEarlyScriptConnectorVtbl;

    interface INNTPEarlyScriptConnector
    {
        CONST_VTBL struct INNTPEarlyScriptConnectorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INNTPEarlyScriptConnector_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INNTPEarlyScriptConnector_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INNTPEarlyScriptConnector_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INNTPEarlyScriptConnector_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INNTPEarlyScriptConnector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INNTPEarlyScriptConnector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INNTPEarlyScriptConnector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INNTPEarlyScriptConnector_INTERFACE_DEFINED__ */


#ifndef __INNTPPostScriptConnector_INTERFACE_DEFINED__
#define __INNTPPostScriptConnector_INTERFACE_DEFINED__

/* interface INNTPPostScriptConnector */
/* [hidden][unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_INNTPPostScriptConnector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000031-8B95-11D1-82DB-00C04FB1625D")
    INNTPPostScriptConnector : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct INNTPPostScriptConnectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INNTPPostScriptConnector __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INNTPPostScriptConnector __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INNTPPostScriptConnector __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            INNTPPostScriptConnector __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            INNTPPostScriptConnector __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            INNTPPostScriptConnector __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            INNTPPostScriptConnector __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } INNTPPostScriptConnectorVtbl;

    interface INNTPPostScriptConnector
    {
        CONST_VTBL struct INNTPPostScriptConnectorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INNTPPostScriptConnector_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INNTPPostScriptConnector_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INNTPPostScriptConnector_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INNTPPostScriptConnector_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INNTPPostScriptConnector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INNTPPostScriptConnector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INNTPPostScriptConnector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INNTPPostScriptConnector_INTERFACE_DEFINED__ */


#ifndef __INNTPFinalScriptConnector_INTERFACE_DEFINED__
#define __INNTPFinalScriptConnector_INTERFACE_DEFINED__

/* interface INNTPFinalScriptConnector */
/* [hidden][unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_INNTPFinalScriptConnector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000032-8B95-11D1-82DB-00C04FB1625D")
    INNTPFinalScriptConnector : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct INNTPFinalScriptConnectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INNTPFinalScriptConnector __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INNTPFinalScriptConnector __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INNTPFinalScriptConnector __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            INNTPFinalScriptConnector __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            INNTPFinalScriptConnector __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            INNTPFinalScriptConnector __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            INNTPFinalScriptConnector __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } INNTPFinalScriptConnectorVtbl;

    interface INNTPFinalScriptConnector
    {
        CONST_VTBL struct INNTPFinalScriptConnectorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INNTPFinalScriptConnector_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INNTPFinalScriptConnector_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INNTPFinalScriptConnector_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INNTPFinalScriptConnector_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INNTPFinalScriptConnector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INNTPFinalScriptConnector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INNTPFinalScriptConnector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INNTPFinalScriptConnector_INTERFACE_DEFINED__ */


#ifndef __ISMTPOnArrival_INTERFACE_DEFINED__
#define __ISMTPOnArrival_INTERFACE_DEFINED__

/* interface ISMTPOnArrival */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ISMTPOnArrival;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000026-8B95-11D1-82DB-00C04FB1625D")
    ISMTPOnArrival : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OnArrival( 
            /* [in] */ IMessage __RPC_FAR *Msg,
            /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISMTPOnArrivalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISMTPOnArrival __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISMTPOnArrival __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISMTPOnArrival __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISMTPOnArrival __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISMTPOnArrival __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISMTPOnArrival __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISMTPOnArrival __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnArrival )( 
            ISMTPOnArrival __RPC_FAR * This,
            /* [in] */ IMessage __RPC_FAR *Msg,
            /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus);
        
        END_INTERFACE
    } ISMTPOnArrivalVtbl;

    interface ISMTPOnArrival
    {
        CONST_VTBL struct ISMTPOnArrivalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISMTPOnArrival_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISMTPOnArrival_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISMTPOnArrival_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISMTPOnArrival_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISMTPOnArrival_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISMTPOnArrival_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISMTPOnArrival_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISMTPOnArrival_OnArrival(This,Msg,EventStatus)	\
    (This)->lpVtbl -> OnArrival(This,Msg,EventStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ISMTPOnArrival_OnArrival_Proxy( 
    ISMTPOnArrival __RPC_FAR * This,
    /* [in] */ IMessage __RPC_FAR *Msg,
    /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus);


void __RPC_STUB ISMTPOnArrival_OnArrival_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISMTPOnArrival_INTERFACE_DEFINED__ */


#ifndef __INNTPOnPostEarly_INTERFACE_DEFINED__
#define __INNTPOnPostEarly_INTERFACE_DEFINED__

/* interface INNTPOnPostEarly */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_INNTPOnPostEarly;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000033-8B95-11D1-82DB-00C04FB1625D")
    INNTPOnPostEarly : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OnPostEarly( 
            /* [in] */ IMessage __RPC_FAR *Msg,
            /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INNTPOnPostEarlyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INNTPOnPostEarly __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INNTPOnPostEarly __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INNTPOnPostEarly __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            INNTPOnPostEarly __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            INNTPOnPostEarly __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            INNTPOnPostEarly __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            INNTPOnPostEarly __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnPostEarly )( 
            INNTPOnPostEarly __RPC_FAR * This,
            /* [in] */ IMessage __RPC_FAR *Msg,
            /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus);
        
        END_INTERFACE
    } INNTPOnPostEarlyVtbl;

    interface INNTPOnPostEarly
    {
        CONST_VTBL struct INNTPOnPostEarlyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INNTPOnPostEarly_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INNTPOnPostEarly_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INNTPOnPostEarly_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INNTPOnPostEarly_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INNTPOnPostEarly_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INNTPOnPostEarly_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INNTPOnPostEarly_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define INNTPOnPostEarly_OnPostEarly(This,Msg,EventStatus)	\
    (This)->lpVtbl -> OnPostEarly(This,Msg,EventStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE INNTPOnPostEarly_OnPostEarly_Proxy( 
    INNTPOnPostEarly __RPC_FAR * This,
    /* [in] */ IMessage __RPC_FAR *Msg,
    /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus);


void __RPC_STUB INNTPOnPostEarly_OnPostEarly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INNTPOnPostEarly_INTERFACE_DEFINED__ */


#ifndef __INNTPOnPost_INTERFACE_DEFINED__
#define __INNTPOnPost_INTERFACE_DEFINED__

/* interface INNTPOnPost */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_INNTPOnPost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000027-8B95-11D1-82DB-00C04FB1625D")
    INNTPOnPost : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OnPost( 
            /* [in] */ IMessage __RPC_FAR *Msg,
            /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INNTPOnPostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INNTPOnPost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INNTPOnPost __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INNTPOnPost __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            INNTPOnPost __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            INNTPOnPost __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            INNTPOnPost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            INNTPOnPost __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnPost )( 
            INNTPOnPost __RPC_FAR * This,
            /* [in] */ IMessage __RPC_FAR *Msg,
            /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus);
        
        END_INTERFACE
    } INNTPOnPostVtbl;

    interface INNTPOnPost
    {
        CONST_VTBL struct INNTPOnPostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INNTPOnPost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INNTPOnPost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INNTPOnPost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INNTPOnPost_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INNTPOnPost_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INNTPOnPost_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INNTPOnPost_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define INNTPOnPost_OnPost(This,Msg,EventStatus)	\
    (This)->lpVtbl -> OnPost(This,Msg,EventStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE INNTPOnPost_OnPost_Proxy( 
    INNTPOnPost __RPC_FAR * This,
    /* [in] */ IMessage __RPC_FAR *Msg,
    /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus);


void __RPC_STUB INNTPOnPost_OnPost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INNTPOnPost_INTERFACE_DEFINED__ */


#ifndef __INNTPOnPostFinal_INTERFACE_DEFINED__
#define __INNTPOnPostFinal_INTERFACE_DEFINED__

/* interface INNTPOnPostFinal */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_INNTPOnPostFinal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000028-8B95-11D1-82DB-00C04FB1625D")
    INNTPOnPostFinal : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OnPostFinal( 
            /* [in] */ IMessage __RPC_FAR *Msg,
            /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INNTPOnPostFinalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INNTPOnPostFinal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INNTPOnPostFinal __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INNTPOnPostFinal __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            INNTPOnPostFinal __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            INNTPOnPostFinal __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            INNTPOnPostFinal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            INNTPOnPostFinal __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnPostFinal )( 
            INNTPOnPostFinal __RPC_FAR * This,
            /* [in] */ IMessage __RPC_FAR *Msg,
            /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus);
        
        END_INTERFACE
    } INNTPOnPostFinalVtbl;

    interface INNTPOnPostFinal
    {
        CONST_VTBL struct INNTPOnPostFinalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INNTPOnPostFinal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INNTPOnPostFinal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INNTPOnPostFinal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INNTPOnPostFinal_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INNTPOnPostFinal_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INNTPOnPostFinal_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INNTPOnPostFinal_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define INNTPOnPostFinal_OnPostFinal(This,Msg,EventStatus)	\
    (This)->lpVtbl -> OnPostFinal(This,Msg,EventStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE INNTPOnPostFinal_OnPostFinal_Proxy( 
    INNTPOnPostFinal __RPC_FAR * This,
    /* [in] */ IMessage __RPC_FAR *Msg,
    /* [out][in] */ CdoEventStatus __RPC_FAR *EventStatus);


void __RPC_STUB INNTPOnPostFinal_OnPostFinal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INNTPOnPostFinal_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cdo_0294 */
/* [local] */ 














extern RPC_IF_HANDLE __MIDL_itf_cdo_0294_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cdo_0294_v0_0_s_ifspec;

#ifndef __IItem_INTERFACE_DEFINED__
#define __IItem_INTERFACE_DEFINED__

/* interface IItem */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000126-8B95-11D1-82DB-00C04FB1625D")
    IItem : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ChildCount( 
            /* [retval][out] */ long __RPC_FAR *varChildCount) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Configuration( 
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentClass( 
            /* [retval][out] */ BSTR __RPC_FAR *pContentClass) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ContentClass( 
            /* [in] */ BSTR varContentClass) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CreationDate( 
            /* [retval][out] */ DATE __RPC_FAR *varCreationDate) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *varDisplayName) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsCollection( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varIsCollection) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsHidden( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsHidden) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_IsHidden( 
            /* [in] */ VARIANT_BOOL varIsHidden) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsStructuredDocument( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varIsStructuredDocument) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LastModified( 
            /* [retval][out] */ DATE __RPC_FAR *varLastModified) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ObjectCount( 
            /* [retval][out] */ long __RPC_FAR *varObjectCount) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ParentURL( 
            /* [retval][out] */ BSTR __RPC_FAR *varParentURL) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_VisibleCount( 
            /* [retval][out] */ long __RPC_FAR *varVisibleCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IItem __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IItem __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IItem __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IItem __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ChildCount )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varChildCount);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Configuration )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Configuration )( 
            IItem __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Configuration )( 
            IItem __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentClass )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pContentClass);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentClass )( 
            IItem __RPC_FAR * This,
            /* [in] */ BSTR varContentClass);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CreationDate )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *varCreationDate);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayName )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDisplayName);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsCollection )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varIsCollection);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsHidden )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsHidden);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsHidden )( 
            IItem __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varIsHidden);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsStructuredDocument )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varIsStructuredDocument);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LastModified )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *varLastModified);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ObjectCount )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varObjectCount);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ParentURL )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varParentURL);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VisibleCount )( 
            IItem __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varVisibleCount);
        
        END_INTERFACE
    } IItemVtbl;

    interface IItem
    {
        CONST_VTBL struct IItemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IItem_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define IItem_GetStream(This,ppStream)	\
    (This)->lpVtbl -> GetStream(This,ppStream)

#define IItem_get_ChildCount(This,varChildCount)	\
    (This)->lpVtbl -> get_ChildCount(This,varChildCount)

#define IItem_get_Configuration(This,pConfiguration)	\
    (This)->lpVtbl -> get_Configuration(This,pConfiguration)

#define IItem_put_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> put_Configuration(This,varConfiguration)

#define IItem_putref_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> putref_Configuration(This,varConfiguration)

#define IItem_get_ContentClass(This,pContentClass)	\
    (This)->lpVtbl -> get_ContentClass(This,pContentClass)

#define IItem_put_ContentClass(This,varContentClass)	\
    (This)->lpVtbl -> put_ContentClass(This,varContentClass)

#define IItem_get_CreationDate(This,varCreationDate)	\
    (This)->lpVtbl -> get_CreationDate(This,varCreationDate)

#define IItem_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IItem_get_DisplayName(This,varDisplayName)	\
    (This)->lpVtbl -> get_DisplayName(This,varDisplayName)

#define IItem_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IItem_get_IsCollection(This,varIsCollection)	\
    (This)->lpVtbl -> get_IsCollection(This,varIsCollection)

#define IItem_get_IsHidden(This,pIsHidden)	\
    (This)->lpVtbl -> get_IsHidden(This,pIsHidden)

#define IItem_put_IsHidden(This,varIsHidden)	\
    (This)->lpVtbl -> put_IsHidden(This,varIsHidden)

#define IItem_get_IsStructuredDocument(This,varIsStructuredDocument)	\
    (This)->lpVtbl -> get_IsStructuredDocument(This,varIsStructuredDocument)

#define IItem_get_LastModified(This,varLastModified)	\
    (This)->lpVtbl -> get_LastModified(This,varLastModified)

#define IItem_get_ObjectCount(This,varObjectCount)	\
    (This)->lpVtbl -> get_ObjectCount(This,varObjectCount)

#define IItem_get_ParentURL(This,varParentURL)	\
    (This)->lpVtbl -> get_ParentURL(This,varParentURL)

#define IItem_get_VisibleCount(This,varVisibleCount)	\
    (This)->lpVtbl -> get_VisibleCount(This,varVisibleCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IItem_GetInterface_Proxy( 
    IItem __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IItem_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IItem_GetStream_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IItem_GetStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_ChildCount_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varChildCount);


void __RPC_STUB IItem_get_ChildCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_Configuration_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);


void __RPC_STUB IItem_get_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IItem_put_Configuration_Proxy( 
    IItem __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IItem_put_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IItem_putref_Configuration_Proxy( 
    IItem __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IItem_putref_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_ContentClass_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pContentClass);


void __RPC_STUB IItem_get_ContentClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IItem_put_ContentClass_Proxy( 
    IItem __RPC_FAR * This,
    /* [in] */ BSTR varContentClass);


void __RPC_STUB IItem_put_ContentClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_CreationDate_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *varCreationDate);


void __RPC_STUB IItem_get_CreationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_DataSource_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IItem_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_DisplayName_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDisplayName);


void __RPC_STUB IItem_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_Fields_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IItem_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_IsCollection_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varIsCollection);


void __RPC_STUB IItem_get_IsCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_IsHidden_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsHidden);


void __RPC_STUB IItem_get_IsHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IItem_put_IsHidden_Proxy( 
    IItem __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varIsHidden);


void __RPC_STUB IItem_put_IsHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_IsStructuredDocument_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varIsStructuredDocument);


void __RPC_STUB IItem_get_IsStructuredDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_LastModified_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *varLastModified);


void __RPC_STUB IItem_get_LastModified_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_ObjectCount_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varObjectCount);


void __RPC_STUB IItem_get_ObjectCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_ParentURL_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varParentURL);


void __RPC_STUB IItem_get_ParentURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IItem_get_VisibleCount_Proxy( 
    IItem __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varVisibleCount);


void __RPC_STUB IItem_get_VisibleCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IItem_INTERFACE_DEFINED__ */


#ifndef __IAppointment_INTERFACE_DEFINED__
#define __IAppointment_INTERFACE_DEFINED__

/* interface IAppointment */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IAppointment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000120-8B95-11D1-82DB-00C04FB1625D")
    IAppointment : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Attachments( 
            /* [retval][out] */ IBodyParts __RPC_FAR *__RPC_FAR *varAttachments) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Attendees( 
            /* [retval][out] */ IAttendees __RPC_FAR *__RPC_FAR *varAttendees) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BusyStatus( 
            /* [retval][out] */ BSTR __RPC_FAR *pBusyStatus) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BusyStatus( 
            /* [in] */ BSTR varBusyStatus) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Keywords( 
            /* [retval][out] */ BSTR __RPC_FAR *pKeywords) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Keywords( 
            /* [in] */ BSTR varKeywords) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Configuration( 
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Contact( 
            /* [retval][out] */ BSTR __RPC_FAR *pContact) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Contact( 
            /* [in] */ BSTR varContact) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pContactURL) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ContactURL( 
            /* [in] */ BSTR varContactURL) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EndTime( 
            /* [retval][out] */ DATE __RPC_FAR *pEndTime) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EndTime( 
            /* [in] */ DATE varEndTime) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Exceptions( 
            /* [retval][out] */ IExceptions __RPC_FAR *__RPC_FAR *varExceptions) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ long __RPC_FAR *pDuration) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Duration( 
            /* [in] */ long varDuration) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Location( 
            /* [retval][out] */ BSTR __RPC_FAR *pLocation) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Location( 
            /* [in] */ BSTR varLocation) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LocationURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pLocationURL) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LocationURL( 
            /* [in] */ BSTR varLocationURL) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ BSTR __RPC_FAR *pPriority) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ BSTR varPriority) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReplyTime( 
            /* [retval][out] */ DATE __RPC_FAR *varReplyTime) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Resources( 
            /* [retval][out] */ BSTR __RPC_FAR *pResources) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Resources( 
            /* [in] */ BSTR varResources) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ResponseRequested( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pResponseRequested) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ResponseRequested( 
            /* [in] */ VARIANT_BOOL varResponseRequested) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RecurrencePatterns( 
            /* [retval][out] */ IRecurrencePatterns __RPC_FAR *__RPC_FAR *varRecurrencePatterns) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Sensitivity( 
            /* [retval][out] */ BSTR __RPC_FAR *pSensitivity) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Sensitivity( 
            /* [in] */ BSTR varSensitivity) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DATE __RPC_FAR *pStartTime) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ DATE varStartTime) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MeetingStatus( 
            /* [retval][out] */ BSTR __RPC_FAR *pMeetingStatus) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MeetingStatus( 
            /* [in] */ BSTR varMeetingStatus) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Subject( 
            /* [retval][out] */ BSTR __RPC_FAR *pSubject) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Subject( 
            /* [in] */ BSTR varSubject) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Transparent( 
            /* [retval][out] */ BSTR __RPC_FAR *pTransparent) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Transparent( 
            /* [in] */ BSTR varTransparent) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BodyPart( 
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varBodyPart) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_GEOLatitude( 
            /* [retval][out] */ double __RPC_FAR *pGEOLatitude) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_GEOLatitude( 
            /* [in] */ double varGEOLatitude) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_GEOLongitude( 
            /* [retval][out] */ double __RPC_FAR *pGEOLongitude) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_GEOLongitude( 
            /* [in] */ double varGEOLongitude) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AllDayEvent( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllDayEvent) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AllDayEvent( 
            /* [in] */ VARIANT_BOOL varAllDayEvent) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TextBody( 
            /* [retval][out] */ BSTR __RPC_FAR *pTextBody) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TextBody( 
            /* [in] */ BSTR varTextBody) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Accept( 
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Response) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptTentative( 
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Response) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Cancel( 
            /* [optional][in] */ BSTR EmailList,
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateRequest( 
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Decline( 
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Response) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Invite( 
            /* [in] */ BSTR EmailList,
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Publish( 
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFirstInstance( 
            /* [in] */ DATE MinDate,
            /* [in] */ DATE MaxDate,
            /* [retval][out] */ IAppointment __RPC_FAR *__RPC_FAR *Appointment) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNextInstance( 
            /* [retval][out] */ IAppointment __RPC_FAR *__RPC_FAR *Appointment) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRecurringMaster( 
            /* [retval][out] */ IAppointment __RPC_FAR *__RPC_FAR *Appointment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppointmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAppointment __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAppointment __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAppointment __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attachments )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ IBodyParts __RPC_FAR *__RPC_FAR *varAttachments);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attendees )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ IAttendees __RPC_FAR *__RPC_FAR *varAttendees);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BusyStatus )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pBusyStatus);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BusyStatus )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varBusyStatus);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Keywords )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pKeywords);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Keywords )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varKeywords);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Configuration )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Configuration )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Configuration )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contact )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pContact);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Contact )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varContact);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContactURL )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pContactURL);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContactURL )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varContactURL);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EndTime )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pEndTime);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EndTime )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ DATE varEndTime);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Exceptions )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ IExceptions __RPC_FAR *__RPC_FAR *varExceptions);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pDuration);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ long varDuration);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Location )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pLocation);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Location )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varLocation);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationURL )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pLocationURL);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocationURL )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varLocationURL);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Priority )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pPriority);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Priority )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varPriority);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReplyTime )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *varReplyTime);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Resources )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pResources);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Resources )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varResources);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ResponseRequested )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pResponseRequested);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ResponseRequested )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varResponseRequested);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecurrencePatterns )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ IRecurrencePatterns __RPC_FAR *__RPC_FAR *varRecurrencePatterns);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Sensitivity )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pSensitivity);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Sensitivity )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varSensitivity);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartTime )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pStartTime);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StartTime )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ DATE varStartTime);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MeetingStatus )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pMeetingStatus);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MeetingStatus )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varMeetingStatus);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Subject )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pSubject);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Subject )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varSubject);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Transparent )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pTransparent);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Transparent )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varTransparent);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BodyPart )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varBodyPart);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GEOLatitude )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pGEOLatitude);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GEOLatitude )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ double varGEOLatitude);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GEOLongitude )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pGEOLongitude);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GEOLongitude )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ double varGEOLongitude);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllDayEvent )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllDayEvent);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllDayEvent )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varAllDayEvent);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TextBody )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pTextBody);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TextBody )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR varTextBody);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Accept )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Response);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcceptTentative )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Response);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            IAppointment __RPC_FAR * This,
            /* [optional][in] */ BSTR EmailList,
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateRequest )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Decline )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Response);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invite )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR EmailList,
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Publish )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstInstance )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ DATE MinDate,
            /* [in] */ DATE MaxDate,
            /* [retval][out] */ IAppointment __RPC_FAR *__RPC_FAR *Appointment);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextInstance )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ IAppointment __RPC_FAR *__RPC_FAR *Appointment);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IAppointment __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecurringMaster )( 
            IAppointment __RPC_FAR * This,
            /* [retval][out] */ IAppointment __RPC_FAR *__RPC_FAR *Appointment);
        
        END_INTERFACE
    } IAppointmentVtbl;

    interface IAppointment
    {
        CONST_VTBL struct IAppointmentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppointment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppointment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppointment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppointment_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAppointment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAppointment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAppointment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAppointment_get_Attachments(This,varAttachments)	\
    (This)->lpVtbl -> get_Attachments(This,varAttachments)

#define IAppointment_get_Attendees(This,varAttendees)	\
    (This)->lpVtbl -> get_Attendees(This,varAttendees)

#define IAppointment_get_BusyStatus(This,pBusyStatus)	\
    (This)->lpVtbl -> get_BusyStatus(This,pBusyStatus)

#define IAppointment_put_BusyStatus(This,varBusyStatus)	\
    (This)->lpVtbl -> put_BusyStatus(This,varBusyStatus)

#define IAppointment_get_Keywords(This,pKeywords)	\
    (This)->lpVtbl -> get_Keywords(This,pKeywords)

#define IAppointment_put_Keywords(This,varKeywords)	\
    (This)->lpVtbl -> put_Keywords(This,varKeywords)

#define IAppointment_get_Configuration(This,pConfiguration)	\
    (This)->lpVtbl -> get_Configuration(This,pConfiguration)

#define IAppointment_put_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> put_Configuration(This,varConfiguration)

#define IAppointment_putref_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> putref_Configuration(This,varConfiguration)

#define IAppointment_get_Contact(This,pContact)	\
    (This)->lpVtbl -> get_Contact(This,pContact)

#define IAppointment_put_Contact(This,varContact)	\
    (This)->lpVtbl -> put_Contact(This,varContact)

#define IAppointment_get_ContactURL(This,pContactURL)	\
    (This)->lpVtbl -> get_ContactURL(This,pContactURL)

#define IAppointment_put_ContactURL(This,varContactURL)	\
    (This)->lpVtbl -> put_ContactURL(This,varContactURL)

#define IAppointment_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IAppointment_get_EndTime(This,pEndTime)	\
    (This)->lpVtbl -> get_EndTime(This,pEndTime)

#define IAppointment_put_EndTime(This,varEndTime)	\
    (This)->lpVtbl -> put_EndTime(This,varEndTime)

#define IAppointment_get_Exceptions(This,varExceptions)	\
    (This)->lpVtbl -> get_Exceptions(This,varExceptions)

#define IAppointment_get_Duration(This,pDuration)	\
    (This)->lpVtbl -> get_Duration(This,pDuration)

#define IAppointment_put_Duration(This,varDuration)	\
    (This)->lpVtbl -> put_Duration(This,varDuration)

#define IAppointment_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IAppointment_get_Location(This,pLocation)	\
    (This)->lpVtbl -> get_Location(This,pLocation)

#define IAppointment_put_Location(This,varLocation)	\
    (This)->lpVtbl -> put_Location(This,varLocation)

#define IAppointment_get_LocationURL(This,pLocationURL)	\
    (This)->lpVtbl -> get_LocationURL(This,pLocationURL)

#define IAppointment_put_LocationURL(This,varLocationURL)	\
    (This)->lpVtbl -> put_LocationURL(This,varLocationURL)

#define IAppointment_get_Priority(This,pPriority)	\
    (This)->lpVtbl -> get_Priority(This,pPriority)

#define IAppointment_put_Priority(This,varPriority)	\
    (This)->lpVtbl -> put_Priority(This,varPriority)

#define IAppointment_get_ReplyTime(This,varReplyTime)	\
    (This)->lpVtbl -> get_ReplyTime(This,varReplyTime)

#define IAppointment_get_Resources(This,pResources)	\
    (This)->lpVtbl -> get_Resources(This,pResources)

#define IAppointment_put_Resources(This,varResources)	\
    (This)->lpVtbl -> put_Resources(This,varResources)

#define IAppointment_get_ResponseRequested(This,pResponseRequested)	\
    (This)->lpVtbl -> get_ResponseRequested(This,pResponseRequested)

#define IAppointment_put_ResponseRequested(This,varResponseRequested)	\
    (This)->lpVtbl -> put_ResponseRequested(This,varResponseRequested)

#define IAppointment_get_RecurrencePatterns(This,varRecurrencePatterns)	\
    (This)->lpVtbl -> get_RecurrencePatterns(This,varRecurrencePatterns)

#define IAppointment_get_Sensitivity(This,pSensitivity)	\
    (This)->lpVtbl -> get_Sensitivity(This,pSensitivity)

#define IAppointment_put_Sensitivity(This,varSensitivity)	\
    (This)->lpVtbl -> put_Sensitivity(This,varSensitivity)

#define IAppointment_get_StartTime(This,pStartTime)	\
    (This)->lpVtbl -> get_StartTime(This,pStartTime)

#define IAppointment_put_StartTime(This,varStartTime)	\
    (This)->lpVtbl -> put_StartTime(This,varStartTime)

#define IAppointment_get_MeetingStatus(This,pMeetingStatus)	\
    (This)->lpVtbl -> get_MeetingStatus(This,pMeetingStatus)

#define IAppointment_put_MeetingStatus(This,varMeetingStatus)	\
    (This)->lpVtbl -> put_MeetingStatus(This,varMeetingStatus)

#define IAppointment_get_Subject(This,pSubject)	\
    (This)->lpVtbl -> get_Subject(This,pSubject)

#define IAppointment_put_Subject(This,varSubject)	\
    (This)->lpVtbl -> put_Subject(This,varSubject)

#define IAppointment_get_Transparent(This,pTransparent)	\
    (This)->lpVtbl -> get_Transparent(This,pTransparent)

#define IAppointment_put_Transparent(This,varTransparent)	\
    (This)->lpVtbl -> put_Transparent(This,varTransparent)

#define IAppointment_get_BodyPart(This,varBodyPart)	\
    (This)->lpVtbl -> get_BodyPart(This,varBodyPart)

#define IAppointment_get_GEOLatitude(This,pGEOLatitude)	\
    (This)->lpVtbl -> get_GEOLatitude(This,pGEOLatitude)

#define IAppointment_put_GEOLatitude(This,varGEOLatitude)	\
    (This)->lpVtbl -> put_GEOLatitude(This,varGEOLatitude)

#define IAppointment_get_GEOLongitude(This,pGEOLongitude)	\
    (This)->lpVtbl -> get_GEOLongitude(This,pGEOLongitude)

#define IAppointment_put_GEOLongitude(This,varGEOLongitude)	\
    (This)->lpVtbl -> put_GEOLongitude(This,varGEOLongitude)

#define IAppointment_get_AllDayEvent(This,pAllDayEvent)	\
    (This)->lpVtbl -> get_AllDayEvent(This,pAllDayEvent)

#define IAppointment_put_AllDayEvent(This,varAllDayEvent)	\
    (This)->lpVtbl -> put_AllDayEvent(This,varAllDayEvent)

#define IAppointment_get_TextBody(This,pTextBody)	\
    (This)->lpVtbl -> get_TextBody(This,pTextBody)

#define IAppointment_put_TextBody(This,varTextBody)	\
    (This)->lpVtbl -> put_TextBody(This,varTextBody)

#define IAppointment_Accept(This,Response)	\
    (This)->lpVtbl -> Accept(This,Response)

#define IAppointment_AcceptTentative(This,Response)	\
    (This)->lpVtbl -> AcceptTentative(This,Response)

#define IAppointment_Cancel(This,EmailList,Request)	\
    (This)->lpVtbl -> Cancel(This,EmailList,Request)

#define IAppointment_CreateRequest(This,Request)	\
    (This)->lpVtbl -> CreateRequest(This,Request)

#define IAppointment_Decline(This,Response)	\
    (This)->lpVtbl -> Decline(This,Response)

#define IAppointment_Invite(This,EmailList,Request)	\
    (This)->lpVtbl -> Invite(This,EmailList,Request)

#define IAppointment_Publish(This,Request)	\
    (This)->lpVtbl -> Publish(This,Request)

#define IAppointment_GetFirstInstance(This,MinDate,MaxDate,Appointment)	\
    (This)->lpVtbl -> GetFirstInstance(This,MinDate,MaxDate,Appointment)

#define IAppointment_GetNextInstance(This,Appointment)	\
    (This)->lpVtbl -> GetNextInstance(This,Appointment)

#define IAppointment_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define IAppointment_GetRecurringMaster(This,Appointment)	\
    (This)->lpVtbl -> GetRecurringMaster(This,Appointment)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Attachments_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ IBodyParts __RPC_FAR *__RPC_FAR *varAttachments);


void __RPC_STUB IAppointment_get_Attachments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Attendees_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ IAttendees __RPC_FAR *__RPC_FAR *varAttendees);


void __RPC_STUB IAppointment_get_Attendees_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_BusyStatus_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pBusyStatus);


void __RPC_STUB IAppointment_get_BusyStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_BusyStatus_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varBusyStatus);


void __RPC_STUB IAppointment_put_BusyStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Keywords_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pKeywords);


void __RPC_STUB IAppointment_get_Keywords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_Keywords_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varKeywords);


void __RPC_STUB IAppointment_put_Keywords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Configuration_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);


void __RPC_STUB IAppointment_get_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_Configuration_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IAppointment_put_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IAppointment_putref_Configuration_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IAppointment_putref_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Contact_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pContact);


void __RPC_STUB IAppointment_get_Contact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_Contact_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varContact);


void __RPC_STUB IAppointment_put_Contact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_ContactURL_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pContactURL);


void __RPC_STUB IAppointment_get_ContactURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_ContactURL_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varContactURL);


void __RPC_STUB IAppointment_put_ContactURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_DataSource_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IAppointment_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_EndTime_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pEndTime);


void __RPC_STUB IAppointment_get_EndTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_EndTime_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ DATE varEndTime);


void __RPC_STUB IAppointment_put_EndTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Exceptions_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ IExceptions __RPC_FAR *__RPC_FAR *varExceptions);


void __RPC_STUB IAppointment_get_Exceptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Duration_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pDuration);


void __RPC_STUB IAppointment_get_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_Duration_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ long varDuration);


void __RPC_STUB IAppointment_put_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Fields_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IAppointment_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Location_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pLocation);


void __RPC_STUB IAppointment_get_Location_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_Location_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varLocation);


void __RPC_STUB IAppointment_put_Location_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_LocationURL_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pLocationURL);


void __RPC_STUB IAppointment_get_LocationURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_LocationURL_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varLocationURL);


void __RPC_STUB IAppointment_put_LocationURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Priority_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pPriority);


void __RPC_STUB IAppointment_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_Priority_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varPriority);


void __RPC_STUB IAppointment_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_ReplyTime_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *varReplyTime);


void __RPC_STUB IAppointment_get_ReplyTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Resources_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pResources);


void __RPC_STUB IAppointment_get_Resources_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_Resources_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varResources);


void __RPC_STUB IAppointment_put_Resources_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_ResponseRequested_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pResponseRequested);


void __RPC_STUB IAppointment_get_ResponseRequested_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_ResponseRequested_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varResponseRequested);


void __RPC_STUB IAppointment_put_ResponseRequested_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_RecurrencePatterns_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ IRecurrencePatterns __RPC_FAR *__RPC_FAR *varRecurrencePatterns);


void __RPC_STUB IAppointment_get_RecurrencePatterns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Sensitivity_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pSensitivity);


void __RPC_STUB IAppointment_get_Sensitivity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_Sensitivity_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varSensitivity);


void __RPC_STUB IAppointment_put_Sensitivity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_StartTime_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pStartTime);


void __RPC_STUB IAppointment_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_StartTime_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ DATE varStartTime);


void __RPC_STUB IAppointment_put_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_MeetingStatus_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pMeetingStatus);


void __RPC_STUB IAppointment_get_MeetingStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_MeetingStatus_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varMeetingStatus);


void __RPC_STUB IAppointment_put_MeetingStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Subject_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pSubject);


void __RPC_STUB IAppointment_get_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_Subject_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varSubject);


void __RPC_STUB IAppointment_put_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_Transparent_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pTransparent);


void __RPC_STUB IAppointment_get_Transparent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_Transparent_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varTransparent);


void __RPC_STUB IAppointment_put_Transparent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_BodyPart_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ IBodyPart __RPC_FAR *__RPC_FAR *varBodyPart);


void __RPC_STUB IAppointment_get_BodyPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_GEOLatitude_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pGEOLatitude);


void __RPC_STUB IAppointment_get_GEOLatitude_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_GEOLatitude_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ double varGEOLatitude);


void __RPC_STUB IAppointment_put_GEOLatitude_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_GEOLongitude_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pGEOLongitude);


void __RPC_STUB IAppointment_get_GEOLongitude_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_GEOLongitude_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ double varGEOLongitude);


void __RPC_STUB IAppointment_put_GEOLongitude_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_AllDayEvent_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllDayEvent);


void __RPC_STUB IAppointment_get_AllDayEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_AllDayEvent_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varAllDayEvent);


void __RPC_STUB IAppointment_put_AllDayEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAppointment_get_TextBody_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pTextBody);


void __RPC_STUB IAppointment_get_TextBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAppointment_put_TextBody_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR varTextBody);


void __RPC_STUB IAppointment_put_TextBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppointment_Accept_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Response);


void __RPC_STUB IAppointment_Accept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppointment_AcceptTentative_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Response);


void __RPC_STUB IAppointment_AcceptTentative_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppointment_Cancel_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [optional][in] */ BSTR EmailList,
    /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request);


void __RPC_STUB IAppointment_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppointment_CreateRequest_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request);


void __RPC_STUB IAppointment_CreateRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppointment_Decline_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Response);


void __RPC_STUB IAppointment_Decline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppointment_Invite_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR EmailList,
    /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request);


void __RPC_STUB IAppointment_Invite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppointment_Publish_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ ICalendarMessage __RPC_FAR *__RPC_FAR *Request);


void __RPC_STUB IAppointment_Publish_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppointment_GetFirstInstance_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ DATE MinDate,
    /* [in] */ DATE MaxDate,
    /* [retval][out] */ IAppointment __RPC_FAR *__RPC_FAR *Appointment);


void __RPC_STUB IAppointment_GetFirstInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppointment_GetNextInstance_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ IAppointment __RPC_FAR *__RPC_FAR *Appointment);


void __RPC_STUB IAppointment_GetNextInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppointment_GetInterface_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IAppointment_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppointment_GetRecurringMaster_Proxy( 
    IAppointment __RPC_FAR * This,
    /* [retval][out] */ IAppointment __RPC_FAR *__RPC_FAR *Appointment);


void __RPC_STUB IAppointment_GetRecurringMaster_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppointment_INTERFACE_DEFINED__ */


#ifndef __ICalendarMessage_INTERFACE_DEFINED__
#define __ICalendarMessage_INTERFACE_DEFINED__

/* interface ICalendarMessage */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ICalendarMessage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000122-8B95-11D1-82DB-00C04FB1625D")
    ICalendarMessage : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CalendarParts( 
            /* [retval][out] */ ICalendarParts __RPC_FAR *__RPC_FAR *varCalendarParts) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Message( 
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *varMessage) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Configuration( 
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICalendarMessageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICalendarMessage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICalendarMessage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICalendarMessage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICalendarMessage __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICalendarMessage __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICalendarMessage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICalendarMessage __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            ICalendarMessage __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CalendarParts )( 
            ICalendarMessage __RPC_FAR * This,
            /* [retval][out] */ ICalendarParts __RPC_FAR *__RPC_FAR *varCalendarParts);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Message )( 
            ICalendarMessage __RPC_FAR * This,
            /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *varMessage);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            ICalendarMessage __RPC_FAR * This,
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Configuration )( 
            ICalendarMessage __RPC_FAR * This,
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Configuration )( 
            ICalendarMessage __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Configuration )( 
            ICalendarMessage __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        END_INTERFACE
    } ICalendarMessageVtbl;

    interface ICalendarMessage
    {
        CONST_VTBL struct ICalendarMessageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICalendarMessage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICalendarMessage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICalendarMessage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICalendarMessage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICalendarMessage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICalendarMessage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICalendarMessage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICalendarMessage_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define ICalendarMessage_get_CalendarParts(This,varCalendarParts)	\
    (This)->lpVtbl -> get_CalendarParts(This,varCalendarParts)

#define ICalendarMessage_get_Message(This,varMessage)	\
    (This)->lpVtbl -> get_Message(This,varMessage)

#define ICalendarMessage_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define ICalendarMessage_get_Configuration(This,pConfiguration)	\
    (This)->lpVtbl -> get_Configuration(This,pConfiguration)

#define ICalendarMessage_put_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> put_Configuration(This,varConfiguration)

#define ICalendarMessage_putref_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> putref_Configuration(This,varConfiguration)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ICalendarMessage_GetInterface_Proxy( 
    ICalendarMessage __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB ICalendarMessage_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ICalendarMessage_get_CalendarParts_Proxy( 
    ICalendarMessage __RPC_FAR * This,
    /* [retval][out] */ ICalendarParts __RPC_FAR *__RPC_FAR *varCalendarParts);


void __RPC_STUB ICalendarMessage_get_CalendarParts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ICalendarMessage_get_Message_Proxy( 
    ICalendarMessage __RPC_FAR * This,
    /* [retval][out] */ IMessage __RPC_FAR *__RPC_FAR *varMessage);


void __RPC_STUB ICalendarMessage_get_Message_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ICalendarMessage_get_DataSource_Proxy( 
    ICalendarMessage __RPC_FAR * This,
    /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB ICalendarMessage_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ICalendarMessage_get_Configuration_Proxy( 
    ICalendarMessage __RPC_FAR * This,
    /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);


void __RPC_STUB ICalendarMessage_get_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ICalendarMessage_put_Configuration_Proxy( 
    ICalendarMessage __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB ICalendarMessage_put_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ICalendarMessage_putref_Configuration_Proxy( 
    ICalendarMessage __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB ICalendarMessage_putref_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICalendarMessage_INTERFACE_DEFINED__ */


#ifndef __IIntegers_INTERFACE_DEFINED__
#define __IIntegers_INTERFACE_DEFINED__

/* interface IIntegers */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IIntegers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD00012E-8B95-11D1-82DB-00C04FB1625D")
    IIntegers : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ long __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ long __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ long NewValue) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIntegersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIntegers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIntegers __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIntegers __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IIntegers __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IIntegers __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IIntegers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IIntegers __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IIntegers __RPC_FAR * This,
            long Index,
            /* [retval][out] */ long __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IIntegers __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IIntegers __RPC_FAR * This,
            /* [in] */ long __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IIntegers __RPC_FAR * This,
            /* [in] */ long NewValue);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IIntegers __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);
        
        END_INTERFACE
    } IIntegersVtbl;

    interface IIntegers
    {
        CONST_VTBL struct IIntegersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIntegers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIntegers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIntegers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIntegers_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IIntegers_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IIntegers_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IIntegers_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IIntegers_get_Item(This,Index,Value)	\
    (This)->lpVtbl -> get_Item(This,Index,Value)

#define IIntegers_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IIntegers_Delete(This,Value)	\
    (This)->lpVtbl -> Delete(This,Value)

#define IIntegers_Add(This,NewValue)	\
    (This)->lpVtbl -> Add(This,NewValue)

#define IIntegers_get__NewEnum(This,Unknown)	\
    (This)->lpVtbl -> get__NewEnum(This,Unknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIntegers_get_Item_Proxy( 
    IIntegers __RPC_FAR * This,
    long Index,
    /* [retval][out] */ long __RPC_FAR *Value);


void __RPC_STUB IIntegers_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIntegers_get_Count_Proxy( 
    IIntegers __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IIntegers_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IIntegers_Delete_Proxy( 
    IIntegers __RPC_FAR * This,
    /* [in] */ long __RPC_FAR *Value);


void __RPC_STUB IIntegers_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IIntegers_Add_Proxy( 
    IIntegers __RPC_FAR * This,
    /* [in] */ long NewValue);


void __RPC_STUB IIntegers_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IIntegers_get__NewEnum_Proxy( 
    IIntegers __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);


void __RPC_STUB IIntegers_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIntegers_INTERFACE_DEFINED__ */


#ifndef __IVariants_INTERFACE_DEFINED__
#define __IVariants_INTERFACE_DEFINED__

/* interface IVariants */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IVariants;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD00012F-8B95-11D1-82DB-00C04FB1625D")
    IVariants : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ VARIANT __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ VARIANT __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ VARIANT NewValue) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVariants __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVariants __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVariants __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVariants __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVariants __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVariants __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVariants __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IVariants __RPC_FAR * This,
            long Index,
            /* [retval][out] */ VARIANT __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IVariants __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IVariants __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IVariants __RPC_FAR * This,
            /* [in] */ VARIANT NewValue);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IVariants __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);
        
        END_INTERFACE
    } IVariantsVtbl;

    interface IVariants
    {
        CONST_VTBL struct IVariantsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariants_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVariants_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVariants_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVariants_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVariants_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVariants_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVariants_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVariants_get_Item(This,Index,Value)	\
    (This)->lpVtbl -> get_Item(This,Index,Value)

#define IVariants_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IVariants_Delete(This,Value)	\
    (This)->lpVtbl -> Delete(This,Value)

#define IVariants_Add(This,NewValue)	\
    (This)->lpVtbl -> Add(This,NewValue)

#define IVariants_get__NewEnum(This,Unknown)	\
    (This)->lpVtbl -> get__NewEnum(This,Unknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVariants_get_Item_Proxy( 
    IVariants __RPC_FAR * This,
    long Index,
    /* [retval][out] */ VARIANT __RPC_FAR *Value);


void __RPC_STUB IVariants_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVariants_get_Count_Proxy( 
    IVariants __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IVariants_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IVariants_Delete_Proxy( 
    IVariants __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Value);


void __RPC_STUB IVariants_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IVariants_Add_Proxy( 
    IVariants __RPC_FAR * This,
    /* [in] */ VARIANT NewValue);


void __RPC_STUB IVariants_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IVariants_get__NewEnum_Proxy( 
    IVariants __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);


void __RPC_STUB IVariants_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVariants_INTERFACE_DEFINED__ */


#ifndef __IRecurrencePattern_INTERFACE_DEFINED__
#define __IRecurrencePattern_INTERFACE_DEFINED__

/* interface IRecurrencePattern */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IRecurrencePattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000123-8B95-11D1-82DB-00C04FB1625D")
    IRecurrencePattern : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Interval( 
            /* [retval][out] */ long __RPC_FAR *pInterval) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Interval( 
            /* [in] */ long varInterval) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Instances( 
            /* [retval][out] */ long __RPC_FAR *pInstances) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Instances( 
            /* [in] */ long varInstances) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Frequency( 
            /* [retval][out] */ CdoFrequency __RPC_FAR *pFrequency) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Frequency( 
            /* [in] */ CdoFrequency varFrequency) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PatternEndDate( 
            /* [retval][out] */ DATE __RPC_FAR *pPatternEndDate) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_PatternEndDate( 
            /* [in] */ DATE varPatternEndDate) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *varType) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_NoEndDate( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varNoEndDate) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FirstDayOfWeek( 
            /* [retval][out] */ CdoDayOfWeek __RPC_FAR *pFirstDayOfWeek) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FirstDayOfWeek( 
            /* [in] */ CdoDayOfWeek varFirstDayOfWeek) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DaysOfMonth( 
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varDaysOfMonth) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DaysOfWeek( 
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varDaysOfWeek) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DaysOfYear( 
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varDaysOfYear) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SecondsOfMinute( 
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varSecondsOfMinute) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MinutesOfHour( 
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varMinutesOfHour) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HoursOfDay( 
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varHoursOfDay) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WeekDays( 
            /* [retval][out] */ IVariants __RPC_FAR *__RPC_FAR *varWeekDays) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WeeksOfYear( 
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varWeeksOfYear) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MonthsOfYear( 
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varMonthsOfYear) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecurrencePatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRecurrencePattern __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRecurrencePattern __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Interval )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pInterval);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Interval )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [in] */ long varInterval);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Instances )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pInstances);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Instances )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [in] */ long varInstances);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Frequency )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ CdoFrequency __RPC_FAR *pFrequency);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Frequency )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [in] */ CdoFrequency varFrequency);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PatternEndDate )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pPatternEndDate);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PatternEndDate )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [in] */ DATE varPatternEndDate);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varType);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NoEndDate )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varNoEndDate);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FirstDayOfWeek )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ CdoDayOfWeek __RPC_FAR *pFirstDayOfWeek);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FirstDayOfWeek )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [in] */ CdoDayOfWeek varFirstDayOfWeek);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DaysOfMonth )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varDaysOfMonth);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DaysOfWeek )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varDaysOfWeek);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DaysOfYear )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varDaysOfYear);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SecondsOfMinute )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varSecondsOfMinute);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinutesOfHour )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varMinutesOfHour);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HoursOfDay )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varHoursOfDay);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WeekDays )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ IVariants __RPC_FAR *__RPC_FAR *varWeekDays);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WeeksOfYear )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varWeeksOfYear);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MonthsOfYear )( 
            IRecurrencePattern __RPC_FAR * This,
            /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varMonthsOfYear);
        
        END_INTERFACE
    } IRecurrencePatternVtbl;

    interface IRecurrencePattern
    {
        CONST_VTBL struct IRecurrencePatternVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecurrencePattern_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecurrencePattern_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRecurrencePattern_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRecurrencePattern_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRecurrencePattern_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRecurrencePattern_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRecurrencePattern_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRecurrencePattern_get_Interval(This,pInterval)	\
    (This)->lpVtbl -> get_Interval(This,pInterval)

#define IRecurrencePattern_put_Interval(This,varInterval)	\
    (This)->lpVtbl -> put_Interval(This,varInterval)

#define IRecurrencePattern_get_Instances(This,pInstances)	\
    (This)->lpVtbl -> get_Instances(This,pInstances)

#define IRecurrencePattern_put_Instances(This,varInstances)	\
    (This)->lpVtbl -> put_Instances(This,varInstances)

#define IRecurrencePattern_get_Frequency(This,pFrequency)	\
    (This)->lpVtbl -> get_Frequency(This,pFrequency)

#define IRecurrencePattern_put_Frequency(This,varFrequency)	\
    (This)->lpVtbl -> put_Frequency(This,varFrequency)

#define IRecurrencePattern_get_PatternEndDate(This,pPatternEndDate)	\
    (This)->lpVtbl -> get_PatternEndDate(This,pPatternEndDate)

#define IRecurrencePattern_put_PatternEndDate(This,varPatternEndDate)	\
    (This)->lpVtbl -> put_PatternEndDate(This,varPatternEndDate)

#define IRecurrencePattern_get_Type(This,varType)	\
    (This)->lpVtbl -> get_Type(This,varType)

#define IRecurrencePattern_get_NoEndDate(This,varNoEndDate)	\
    (This)->lpVtbl -> get_NoEndDate(This,varNoEndDate)

#define IRecurrencePattern_get_FirstDayOfWeek(This,pFirstDayOfWeek)	\
    (This)->lpVtbl -> get_FirstDayOfWeek(This,pFirstDayOfWeek)

#define IRecurrencePattern_put_FirstDayOfWeek(This,varFirstDayOfWeek)	\
    (This)->lpVtbl -> put_FirstDayOfWeek(This,varFirstDayOfWeek)

#define IRecurrencePattern_get_DaysOfMonth(This,varDaysOfMonth)	\
    (This)->lpVtbl -> get_DaysOfMonth(This,varDaysOfMonth)

#define IRecurrencePattern_get_DaysOfWeek(This,varDaysOfWeek)	\
    (This)->lpVtbl -> get_DaysOfWeek(This,varDaysOfWeek)

#define IRecurrencePattern_get_DaysOfYear(This,varDaysOfYear)	\
    (This)->lpVtbl -> get_DaysOfYear(This,varDaysOfYear)

#define IRecurrencePattern_get_SecondsOfMinute(This,varSecondsOfMinute)	\
    (This)->lpVtbl -> get_SecondsOfMinute(This,varSecondsOfMinute)

#define IRecurrencePattern_get_MinutesOfHour(This,varMinutesOfHour)	\
    (This)->lpVtbl -> get_MinutesOfHour(This,varMinutesOfHour)

#define IRecurrencePattern_get_HoursOfDay(This,varHoursOfDay)	\
    (This)->lpVtbl -> get_HoursOfDay(This,varHoursOfDay)

#define IRecurrencePattern_get_WeekDays(This,varWeekDays)	\
    (This)->lpVtbl -> get_WeekDays(This,varWeekDays)

#define IRecurrencePattern_get_WeeksOfYear(This,varWeeksOfYear)	\
    (This)->lpVtbl -> get_WeeksOfYear(This,varWeeksOfYear)

#define IRecurrencePattern_get_MonthsOfYear(This,varMonthsOfYear)	\
    (This)->lpVtbl -> get_MonthsOfYear(This,varMonthsOfYear)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_Interval_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pInterval);


void __RPC_STUB IRecurrencePattern_get_Interval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_put_Interval_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [in] */ long varInterval);


void __RPC_STUB IRecurrencePattern_put_Interval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_Instances_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pInstances);


void __RPC_STUB IRecurrencePattern_get_Instances_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_put_Instances_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [in] */ long varInstances);


void __RPC_STUB IRecurrencePattern_put_Instances_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_Frequency_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ CdoFrequency __RPC_FAR *pFrequency);


void __RPC_STUB IRecurrencePattern_get_Frequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_put_Frequency_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [in] */ CdoFrequency varFrequency);


void __RPC_STUB IRecurrencePattern_put_Frequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_PatternEndDate_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pPatternEndDate);


void __RPC_STUB IRecurrencePattern_get_PatternEndDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_put_PatternEndDate_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [in] */ DATE varPatternEndDate);


void __RPC_STUB IRecurrencePattern_put_PatternEndDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_Type_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varType);


void __RPC_STUB IRecurrencePattern_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_NoEndDate_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varNoEndDate);


void __RPC_STUB IRecurrencePattern_get_NoEndDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_FirstDayOfWeek_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ CdoDayOfWeek __RPC_FAR *pFirstDayOfWeek);


void __RPC_STUB IRecurrencePattern_get_FirstDayOfWeek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_put_FirstDayOfWeek_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [in] */ CdoDayOfWeek varFirstDayOfWeek);


void __RPC_STUB IRecurrencePattern_put_FirstDayOfWeek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_DaysOfMonth_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varDaysOfMonth);


void __RPC_STUB IRecurrencePattern_get_DaysOfMonth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_DaysOfWeek_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varDaysOfWeek);


void __RPC_STUB IRecurrencePattern_get_DaysOfWeek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_DaysOfYear_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varDaysOfYear);


void __RPC_STUB IRecurrencePattern_get_DaysOfYear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_SecondsOfMinute_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varSecondsOfMinute);


void __RPC_STUB IRecurrencePattern_get_SecondsOfMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_MinutesOfHour_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varMinutesOfHour);


void __RPC_STUB IRecurrencePattern_get_MinutesOfHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_HoursOfDay_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varHoursOfDay);


void __RPC_STUB IRecurrencePattern_get_HoursOfDay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_WeekDays_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ IVariants __RPC_FAR *__RPC_FAR *varWeekDays);


void __RPC_STUB IRecurrencePattern_get_WeekDays_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_WeeksOfYear_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varWeeksOfYear);


void __RPC_STUB IRecurrencePattern_get_WeeksOfYear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePattern_get_MonthsOfYear_Proxy( 
    IRecurrencePattern __RPC_FAR * This,
    /* [retval][out] */ IIntegers __RPC_FAR *__RPC_FAR *varMonthsOfYear);


void __RPC_STUB IRecurrencePattern_get_MonthsOfYear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRecurrencePattern_INTERFACE_DEFINED__ */


#ifndef __IException_INTERFACE_DEFINED__
#define __IException_INTERFACE_DEFINED__

/* interface IException */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IException;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000124-8B95-11D1-82DB-00C04FB1625D")
    IException : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *varType) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RecurrenceIDRange( 
            /* [retval][out] */ BSTR __RPC_FAR *pRecurrenceIDRange) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_RecurrenceIDRange( 
            /* [in] */ BSTR varRecurrenceIDRange) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RecurrenceID( 
            /* [retval][out] */ DATE __RPC_FAR *pRecurrenceID) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_RecurrenceID( 
            /* [in] */ DATE varRecurrenceID) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DATE __RPC_FAR *pStartTime) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ DATE varStartTime) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EndTime( 
            /* [retval][out] */ DATE __RPC_FAR *pEndTime) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EndTime( 
            /* [in] */ DATE varEndTime) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExceptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IException __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IException __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IException __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IException __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IException __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IException __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IException __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IException __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varType);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecurrenceIDRange )( 
            IException __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pRecurrenceIDRange);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecurrenceIDRange )( 
            IException __RPC_FAR * This,
            /* [in] */ BSTR varRecurrenceIDRange);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecurrenceID )( 
            IException __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pRecurrenceID);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecurrenceID )( 
            IException __RPC_FAR * This,
            /* [in] */ DATE varRecurrenceID);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartTime )( 
            IException __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pStartTime);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StartTime )( 
            IException __RPC_FAR * This,
            /* [in] */ DATE varStartTime);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EndTime )( 
            IException __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pEndTime);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EndTime )( 
            IException __RPC_FAR * This,
            /* [in] */ DATE varEndTime);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IException __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        END_INTERFACE
    } IExceptionVtbl;

    interface IException
    {
        CONST_VTBL struct IExceptionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IException_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IException_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IException_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IException_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IException_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IException_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IException_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IException_get_Type(This,varType)	\
    (This)->lpVtbl -> get_Type(This,varType)

#define IException_get_RecurrenceIDRange(This,pRecurrenceIDRange)	\
    (This)->lpVtbl -> get_RecurrenceIDRange(This,pRecurrenceIDRange)

#define IException_put_RecurrenceIDRange(This,varRecurrenceIDRange)	\
    (This)->lpVtbl -> put_RecurrenceIDRange(This,varRecurrenceIDRange)

#define IException_get_RecurrenceID(This,pRecurrenceID)	\
    (This)->lpVtbl -> get_RecurrenceID(This,pRecurrenceID)

#define IException_put_RecurrenceID(This,varRecurrenceID)	\
    (This)->lpVtbl -> put_RecurrenceID(This,varRecurrenceID)

#define IException_get_StartTime(This,pStartTime)	\
    (This)->lpVtbl -> get_StartTime(This,pStartTime)

#define IException_put_StartTime(This,varStartTime)	\
    (This)->lpVtbl -> put_StartTime(This,varStartTime)

#define IException_get_EndTime(This,pEndTime)	\
    (This)->lpVtbl -> get_EndTime(This,pEndTime)

#define IException_put_EndTime(This,varEndTime)	\
    (This)->lpVtbl -> put_EndTime(This,varEndTime)

#define IException_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IException_get_Type_Proxy( 
    IException __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varType);


void __RPC_STUB IException_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IException_get_RecurrenceIDRange_Proxy( 
    IException __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pRecurrenceIDRange);


void __RPC_STUB IException_get_RecurrenceIDRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IException_put_RecurrenceIDRange_Proxy( 
    IException __RPC_FAR * This,
    /* [in] */ BSTR varRecurrenceIDRange);


void __RPC_STUB IException_put_RecurrenceIDRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IException_get_RecurrenceID_Proxy( 
    IException __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pRecurrenceID);


void __RPC_STUB IException_get_RecurrenceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IException_put_RecurrenceID_Proxy( 
    IException __RPC_FAR * This,
    /* [in] */ DATE varRecurrenceID);


void __RPC_STUB IException_put_RecurrenceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IException_get_StartTime_Proxy( 
    IException __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pStartTime);


void __RPC_STUB IException_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IException_put_StartTime_Proxy( 
    IException __RPC_FAR * This,
    /* [in] */ DATE varStartTime);


void __RPC_STUB IException_put_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IException_get_EndTime_Proxy( 
    IException __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pEndTime);


void __RPC_STUB IException_get_EndTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IException_put_EndTime_Proxy( 
    IException __RPC_FAR * This,
    /* [in] */ DATE varEndTime);


void __RPC_STUB IException_put_EndTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IException_get_Fields_Proxy( 
    IException __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IException_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IException_INTERFACE_DEFINED__ */


#ifndef __IRecurrencePatterns_INTERFACE_DEFINED__
#define __IRecurrencePatterns_INTERFACE_DEFINED__

/* interface IRecurrencePatterns */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IRecurrencePatterns;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD00012C-8B95-11D1-82DB-00C04FB1625D")
    IRecurrencePatterns : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ IRecurrencePattern __RPC_FAR *__RPC_FAR *RecurrencePattern) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ long Index) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR Type,
            /* [retval][out] */ IRecurrencePattern __RPC_FAR *__RPC_FAR *RecurrencePattern) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecurrencePatternsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRecurrencePatterns __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRecurrencePatterns __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRecurrencePatterns __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRecurrencePatterns __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRecurrencePatterns __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRecurrencePatterns __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRecurrencePatterns __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRecurrencePatterns __RPC_FAR * This,
            long Index,
            /* [retval][out] */ IRecurrencePattern __RPC_FAR *__RPC_FAR *RecurrencePattern);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IRecurrencePatterns __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IRecurrencePatterns __RPC_FAR * This,
            /* [in] */ long Index);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IRecurrencePatterns __RPC_FAR * This,
            /* [in] */ BSTR Type,
            /* [retval][out] */ IRecurrencePattern __RPC_FAR *__RPC_FAR *RecurrencePattern);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IRecurrencePatterns __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);
        
        END_INTERFACE
    } IRecurrencePatternsVtbl;

    interface IRecurrencePatterns
    {
        CONST_VTBL struct IRecurrencePatternsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecurrencePatterns_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecurrencePatterns_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRecurrencePatterns_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRecurrencePatterns_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRecurrencePatterns_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRecurrencePatterns_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRecurrencePatterns_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRecurrencePatterns_get_Item(This,Index,RecurrencePattern)	\
    (This)->lpVtbl -> get_Item(This,Index,RecurrencePattern)

#define IRecurrencePatterns_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IRecurrencePatterns_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)

#define IRecurrencePatterns_Add(This,Type,RecurrencePattern)	\
    (This)->lpVtbl -> Add(This,Type,RecurrencePattern)

#define IRecurrencePatterns_get__NewEnum(This,Unknown)	\
    (This)->lpVtbl -> get__NewEnum(This,Unknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRecurrencePatterns_get_Item_Proxy( 
    IRecurrencePatterns __RPC_FAR * This,
    long Index,
    /* [retval][out] */ IRecurrencePattern __RPC_FAR *__RPC_FAR *RecurrencePattern);


void __RPC_STUB IRecurrencePatterns_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRecurrencePatterns_get_Count_Proxy( 
    IRecurrencePatterns __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IRecurrencePatterns_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePatterns_Delete_Proxy( 
    IRecurrencePatterns __RPC_FAR * This,
    /* [in] */ long Index);


void __RPC_STUB IRecurrencePatterns_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IRecurrencePatterns_Add_Proxy( 
    IRecurrencePatterns __RPC_FAR * This,
    /* [in] */ BSTR Type,
    /* [retval][out] */ IRecurrencePattern __RPC_FAR *__RPC_FAR *RecurrencePattern);


void __RPC_STUB IRecurrencePatterns_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IRecurrencePatterns_get__NewEnum_Proxy( 
    IRecurrencePatterns __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);


void __RPC_STUB IRecurrencePatterns_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRecurrencePatterns_INTERFACE_DEFINED__ */


#ifndef __IExceptions_INTERFACE_DEFINED__
#define __IExceptions_INTERFACE_DEFINED__

/* interface IExceptions */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IExceptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD00012D-8B95-11D1-82DB-00C04FB1625D")
    IExceptions : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ IException __RPC_FAR *__RPC_FAR *Exception) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ long Index) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR Type,
            /* [retval][out] */ IException __RPC_FAR *__RPC_FAR *Exception) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExceptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExceptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExceptions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExceptions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IExceptions __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IExceptions __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IExceptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IExceptions __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IExceptions __RPC_FAR * This,
            long Index,
            /* [retval][out] */ IException __RPC_FAR *__RPC_FAR *Exception);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IExceptions __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IExceptions __RPC_FAR * This,
            /* [in] */ long Index);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IExceptions __RPC_FAR * This,
            /* [in] */ BSTR Type,
            /* [retval][out] */ IException __RPC_FAR *__RPC_FAR *Exception);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IExceptions __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);
        
        END_INTERFACE
    } IExceptionsVtbl;

    interface IExceptions
    {
        CONST_VTBL struct IExceptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExceptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExceptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExceptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExceptions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IExceptions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IExceptions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IExceptions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IExceptions_get_Item(This,Index,Exception)	\
    (This)->lpVtbl -> get_Item(This,Index,Exception)

#define IExceptions_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IExceptions_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)

#define IExceptions_Add(This,Type,Exception)	\
    (This)->lpVtbl -> Add(This,Type,Exception)

#define IExceptions_get__NewEnum(This,Unknown)	\
    (This)->lpVtbl -> get__NewEnum(This,Unknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExceptions_get_Item_Proxy( 
    IExceptions __RPC_FAR * This,
    long Index,
    /* [retval][out] */ IException __RPC_FAR *__RPC_FAR *Exception);


void __RPC_STUB IExceptions_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExceptions_get_Count_Proxy( 
    IExceptions __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IExceptions_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IExceptions_Delete_Proxy( 
    IExceptions __RPC_FAR * This,
    /* [in] */ long Index);


void __RPC_STUB IExceptions_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IExceptions_Add_Proxy( 
    IExceptions __RPC_FAR * This,
    /* [in] */ BSTR Type,
    /* [retval][out] */ IException __RPC_FAR *__RPC_FAR *Exception);


void __RPC_STUB IExceptions_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IExceptions_get__NewEnum_Proxy( 
    IExceptions __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);


void __RPC_STUB IExceptions_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExceptions_INTERFACE_DEFINED__ */


#ifndef __ICalendarPart_INTERFACE_DEFINED__
#define __ICalendarPart_INTERFACE_DEFINED__

/* interface ICalendarPart */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ICalendarPart;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000133-8B95-11D1-82DB-00C04FB1625D")
    ICalendarPart : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAssociatedItem( 
            /* [optional][in] */ BSTR CalendarLocation,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Item) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ComponentType( 
            /* [retval][out] */ CdoComponentType __RPC_FAR *varComponentType) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ProdID( 
            /* [retval][out] */ BSTR __RPC_FAR *varProdID) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CalendarVersion( 
            /* [retval][out] */ BSTR __RPC_FAR *varCalendarVersion) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CalendarMethod( 
            /* [retval][out] */ BSTR __RPC_FAR *varCalendarMethod) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUpdatedItem( 
            /* [optional][in] */ BSTR CalendarLocation,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Item) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICalendarPartVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICalendarPart __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICalendarPart __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICalendarPart __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICalendarPart __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICalendarPart __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICalendarPart __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICalendarPart __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAssociatedItem )( 
            ICalendarPart __RPC_FAR * This,
            /* [optional][in] */ BSTR CalendarLocation,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Item);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            ICalendarPart __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ComponentType )( 
            ICalendarPart __RPC_FAR * This,
            /* [retval][out] */ CdoComponentType __RPC_FAR *varComponentType);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProdID )( 
            ICalendarPart __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varProdID);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CalendarVersion )( 
            ICalendarPart __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varCalendarVersion);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CalendarMethod )( 
            ICalendarPart __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varCalendarMethod);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUpdatedItem )( 
            ICalendarPart __RPC_FAR * This,
            /* [optional][in] */ BSTR CalendarLocation,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Item);
        
        END_INTERFACE
    } ICalendarPartVtbl;

    interface ICalendarPart
    {
        CONST_VTBL struct ICalendarPartVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICalendarPart_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICalendarPart_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICalendarPart_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICalendarPart_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICalendarPart_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICalendarPart_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICalendarPart_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICalendarPart_GetAssociatedItem(This,CalendarLocation,Item)	\
    (This)->lpVtbl -> GetAssociatedItem(This,CalendarLocation,Item)

#define ICalendarPart_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define ICalendarPart_get_ComponentType(This,varComponentType)	\
    (This)->lpVtbl -> get_ComponentType(This,varComponentType)

#define ICalendarPart_get_ProdID(This,varProdID)	\
    (This)->lpVtbl -> get_ProdID(This,varProdID)

#define ICalendarPart_get_CalendarVersion(This,varCalendarVersion)	\
    (This)->lpVtbl -> get_CalendarVersion(This,varCalendarVersion)

#define ICalendarPart_get_CalendarMethod(This,varCalendarMethod)	\
    (This)->lpVtbl -> get_CalendarMethod(This,varCalendarMethod)

#define ICalendarPart_GetUpdatedItem(This,CalendarLocation,Item)	\
    (This)->lpVtbl -> GetUpdatedItem(This,CalendarLocation,Item)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ICalendarPart_GetAssociatedItem_Proxy( 
    ICalendarPart __RPC_FAR * This,
    /* [optional][in] */ BSTR CalendarLocation,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Item);


void __RPC_STUB ICalendarPart_GetAssociatedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ICalendarPart_GetInterface_Proxy( 
    ICalendarPart __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB ICalendarPart_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ICalendarPart_get_ComponentType_Proxy( 
    ICalendarPart __RPC_FAR * This,
    /* [retval][out] */ CdoComponentType __RPC_FAR *varComponentType);


void __RPC_STUB ICalendarPart_get_ComponentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ICalendarPart_get_ProdID_Proxy( 
    ICalendarPart __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varProdID);


void __RPC_STUB ICalendarPart_get_ProdID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ICalendarPart_get_CalendarVersion_Proxy( 
    ICalendarPart __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varCalendarVersion);


void __RPC_STUB ICalendarPart_get_CalendarVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ICalendarPart_get_CalendarMethod_Proxy( 
    ICalendarPart __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varCalendarMethod);


void __RPC_STUB ICalendarPart_get_CalendarMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ICalendarPart_GetUpdatedItem_Proxy( 
    ICalendarPart __RPC_FAR * This,
    /* [optional][in] */ BSTR CalendarLocation,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Item);


void __RPC_STUB ICalendarPart_GetUpdatedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICalendarPart_INTERFACE_DEFINED__ */


#ifndef __ICalendarParts_INTERFACE_DEFINED__
#define __ICalendarParts_INTERFACE_DEFINED__

/* interface ICalendarParts */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ICalendarParts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000130-8B95-11D1-82DB-00C04FB1625D")
    ICalendarParts : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ ICalendarPart __RPC_FAR *__RPC_FAR *CalendarPart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ long Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IUnknown __RPC_FAR *CalendarPart,
            /* [in] */ CdoComponentType ComponentType) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICalendarPartsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICalendarParts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICalendarParts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICalendarParts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICalendarParts __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICalendarParts __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICalendarParts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICalendarParts __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ICalendarParts __RPC_FAR * This,
            long Index,
            /* [retval][out] */ ICalendarPart __RPC_FAR *__RPC_FAR *CalendarPart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ICalendarParts __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ICalendarParts __RPC_FAR * This,
            /* [in] */ long Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            ICalendarParts __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *CalendarPart,
            /* [in] */ CdoComponentType ComponentType);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ICalendarParts __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);
        
        END_INTERFACE
    } ICalendarPartsVtbl;

    interface ICalendarParts
    {
        CONST_VTBL struct ICalendarPartsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICalendarParts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICalendarParts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICalendarParts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICalendarParts_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICalendarParts_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICalendarParts_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICalendarParts_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICalendarParts_get_Item(This,Index,CalendarPart)	\
    (This)->lpVtbl -> get_Item(This,Index,CalendarPart)

#define ICalendarParts_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define ICalendarParts_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)

#define ICalendarParts_Add(This,CalendarPart,ComponentType)	\
    (This)->lpVtbl -> Add(This,CalendarPart,ComponentType)

#define ICalendarParts_get__NewEnum(This,Unknown)	\
    (This)->lpVtbl -> get__NewEnum(This,Unknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICalendarParts_get_Item_Proxy( 
    ICalendarParts __RPC_FAR * This,
    long Index,
    /* [retval][out] */ ICalendarPart __RPC_FAR *__RPC_FAR *CalendarPart);


void __RPC_STUB ICalendarParts_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICalendarParts_get_Count_Proxy( 
    ICalendarParts __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB ICalendarParts_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICalendarParts_Delete_Proxy( 
    ICalendarParts __RPC_FAR * This,
    /* [in] */ long Index);


void __RPC_STUB ICalendarParts_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICalendarParts_Add_Proxy( 
    ICalendarParts __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *CalendarPart,
    /* [in] */ CdoComponentType ComponentType);


void __RPC_STUB ICalendarParts_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ICalendarParts_get__NewEnum_Proxy( 
    ICalendarParts __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);


void __RPC_STUB ICalendarParts_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICalendarParts_INTERFACE_DEFINED__ */


#ifndef __IAttendee_INTERFACE_DEFINED__
#define __IAttendee_INTERFACE_DEFINED__

/* interface IAttendee */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IAttendee;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000135-8B95-11D1-82DB-00C04FB1625D")
    IAttendee : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *pDisplayName) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ BSTR varDisplayName) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pType) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ BSTR varType) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ BSTR __RPC_FAR *pAddress) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Address( 
            /* [in] */ BSTR varAddress) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsOrganizer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsOrganizer) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_IsOrganizer( 
            /* [in] */ VARIANT_BOOL varIsOrganizer) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Role( 
            /* [retval][out] */ CdoAttendeeRoleValues __RPC_FAR *pRole) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Role( 
            /* [in] */ CdoAttendeeRoleValues varRole) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ CdoAttendeeStatusValues __RPC_FAR *pStatus) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Status( 
            /* [in] */ CdoAttendeeStatusValues varStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAttendeeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAttendee __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAttendee __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAttendee __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAttendee __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAttendee __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAttendee __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAttendee __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayName )( 
            IAttendee __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pDisplayName);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplayName )( 
            IAttendee __RPC_FAR * This,
            /* [in] */ BSTR varDisplayName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IAttendee __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Type )( 
            IAttendee __RPC_FAR * This,
            /* [in] */ BSTR varType);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address )( 
            IAttendee __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pAddress);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Address )( 
            IAttendee __RPC_FAR * This,
            /* [in] */ BSTR varAddress);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsOrganizer )( 
            IAttendee __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsOrganizer);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsOrganizer )( 
            IAttendee __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varIsOrganizer);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Role )( 
            IAttendee __RPC_FAR * This,
            /* [retval][out] */ CdoAttendeeRoleValues __RPC_FAR *pRole);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Role )( 
            IAttendee __RPC_FAR * This,
            /* [in] */ CdoAttendeeRoleValues varRole);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IAttendee __RPC_FAR * This,
            /* [retval][out] */ CdoAttendeeStatusValues __RPC_FAR *pStatus);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Status )( 
            IAttendee __RPC_FAR * This,
            /* [in] */ CdoAttendeeStatusValues varStatus);
        
        END_INTERFACE
    } IAttendeeVtbl;

    interface IAttendee
    {
        CONST_VTBL struct IAttendeeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAttendee_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAttendee_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAttendee_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAttendee_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAttendee_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAttendee_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAttendee_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAttendee_get_DisplayName(This,pDisplayName)	\
    (This)->lpVtbl -> get_DisplayName(This,pDisplayName)

#define IAttendee_put_DisplayName(This,varDisplayName)	\
    (This)->lpVtbl -> put_DisplayName(This,varDisplayName)

#define IAttendee_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IAttendee_put_Type(This,varType)	\
    (This)->lpVtbl -> put_Type(This,varType)

#define IAttendee_get_Address(This,pAddress)	\
    (This)->lpVtbl -> get_Address(This,pAddress)

#define IAttendee_put_Address(This,varAddress)	\
    (This)->lpVtbl -> put_Address(This,varAddress)

#define IAttendee_get_IsOrganizer(This,pIsOrganizer)	\
    (This)->lpVtbl -> get_IsOrganizer(This,pIsOrganizer)

#define IAttendee_put_IsOrganizer(This,varIsOrganizer)	\
    (This)->lpVtbl -> put_IsOrganizer(This,varIsOrganizer)

#define IAttendee_get_Role(This,pRole)	\
    (This)->lpVtbl -> get_Role(This,pRole)

#define IAttendee_put_Role(This,varRole)	\
    (This)->lpVtbl -> put_Role(This,varRole)

#define IAttendee_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IAttendee_put_Status(This,varStatus)	\
    (This)->lpVtbl -> put_Status(This,varStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAttendee_get_DisplayName_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pDisplayName);


void __RPC_STUB IAttendee_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAttendee_put_DisplayName_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [in] */ BSTR varDisplayName);


void __RPC_STUB IAttendee_put_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAttendee_get_Type_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pType);


void __RPC_STUB IAttendee_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAttendee_put_Type_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [in] */ BSTR varType);


void __RPC_STUB IAttendee_put_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAttendee_get_Address_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pAddress);


void __RPC_STUB IAttendee_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAttendee_put_Address_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [in] */ BSTR varAddress);


void __RPC_STUB IAttendee_put_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAttendee_get_IsOrganizer_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsOrganizer);


void __RPC_STUB IAttendee_get_IsOrganizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAttendee_put_IsOrganizer_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varIsOrganizer);


void __RPC_STUB IAttendee_put_IsOrganizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAttendee_get_Role_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [retval][out] */ CdoAttendeeRoleValues __RPC_FAR *pRole);


void __RPC_STUB IAttendee_get_Role_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAttendee_put_Role_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [in] */ CdoAttendeeRoleValues varRole);


void __RPC_STUB IAttendee_put_Role_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAttendee_get_Status_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [retval][out] */ CdoAttendeeStatusValues __RPC_FAR *pStatus);


void __RPC_STUB IAttendee_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAttendee_put_Status_Proxy( 
    IAttendee __RPC_FAR * This,
    /* [in] */ CdoAttendeeStatusValues varStatus);


void __RPC_STUB IAttendee_put_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAttendee_INTERFACE_DEFINED__ */


#ifndef __IAttendees_INTERFACE_DEFINED__
#define __IAttendees_INTERFACE_DEFINED__

/* interface IAttendees */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IAttendees;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000136-8B95-11D1-82DB-00C04FB1625D")
    IAttendees : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ IAttendee __RPC_FAR *__RPC_FAR *Attendee) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ long Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ BSTR Address,
            /* [retval][out] */ IAttendee __RPC_FAR *__RPC_FAR *Attendee) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAttendeesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAttendees __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAttendees __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAttendees __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAttendees __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAttendees __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAttendees __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAttendees __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IAttendees __RPC_FAR * This,
            long Index,
            /* [retval][out] */ IAttendee __RPC_FAR *__RPC_FAR *Attendee);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IAttendees __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IAttendees __RPC_FAR * This,
            /* [in] */ long Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IAttendees __RPC_FAR * This,
            /* [optional][in] */ BSTR Address,
            /* [retval][out] */ IAttendee __RPC_FAR *__RPC_FAR *Attendee);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IAttendees __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);
        
        END_INTERFACE
    } IAttendeesVtbl;

    interface IAttendees
    {
        CONST_VTBL struct IAttendeesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAttendees_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAttendees_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAttendees_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAttendees_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAttendees_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAttendees_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAttendees_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAttendees_get_Item(This,Index,Attendee)	\
    (This)->lpVtbl -> get_Item(This,Index,Attendee)

#define IAttendees_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IAttendees_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)

#define IAttendees_Add(This,Address,Attendee)	\
    (This)->lpVtbl -> Add(This,Address,Attendee)

#define IAttendees_get__NewEnum(This,Unknown)	\
    (This)->lpVtbl -> get__NewEnum(This,Unknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAttendees_get_Item_Proxy( 
    IAttendees __RPC_FAR * This,
    long Index,
    /* [retval][out] */ IAttendee __RPC_FAR *__RPC_FAR *Attendee);


void __RPC_STUB IAttendees_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAttendees_get_Count_Proxy( 
    IAttendees __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IAttendees_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAttendees_Delete_Proxy( 
    IAttendees __RPC_FAR * This,
    /* [in] */ long Index);


void __RPC_STUB IAttendees_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAttendees_Add_Proxy( 
    IAttendees __RPC_FAR * This,
    /* [optional][in] */ BSTR Address,
    /* [retval][out] */ IAttendee __RPC_FAR *__RPC_FAR *Attendee);


void __RPC_STUB IAttendees_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IAttendees_get__NewEnum_Proxy( 
    IAttendees __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);


void __RPC_STUB IAttendees_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAttendees_INTERFACE_DEFINED__ */


#ifndef __IMailbox_INTERFACE_DEFINED__
#define __IMailbox_INTERFACE_DEFINED__

/* interface IMailbox */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IMailbox;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000125-8B95-11D1-82DB-00C04FB1625D")
    IMailbox : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BaseFolder( 
            /* [retval][out] */ BSTR __RPC_FAR *varBaseFolder) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RootFolder( 
            /* [retval][out] */ BSTR __RPC_FAR *varRootFolder) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Inbox( 
            /* [retval][out] */ BSTR __RPC_FAR *varInbox) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Outbox( 
            /* [retval][out] */ BSTR __RPC_FAR *varOutbox) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SentItems( 
            /* [retval][out] */ BSTR __RPC_FAR *varSentItems) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Drafts( 
            /* [retval][out] */ BSTR __RPC_FAR *varDrafts) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DeletedItems( 
            /* [retval][out] */ BSTR __RPC_FAR *varDeletedItems) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Calendar( 
            /* [retval][out] */ BSTR __RPC_FAR *varCalendar) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tasks( 
            /* [retval][out] */ BSTR __RPC_FAR *varTasks) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Contacts( 
            /* [retval][out] */ BSTR __RPC_FAR *varContacts) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Notes( 
            /* [retval][out] */ BSTR __RPC_FAR *varNotes) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Journal( 
            /* [retval][out] */ BSTR __RPC_FAR *varJournal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMailboxVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMailbox __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMailbox __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMailbox __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMailbox __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMailbox __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMailbox __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMailbox __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BaseFolder )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varBaseFolder);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RootFolder )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varRootFolder);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Inbox )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varInbox);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Outbox )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varOutbox);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SentItems )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varSentItems);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Drafts )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDrafts);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DeletedItems )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDeletedItems);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Calendar )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varCalendar);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Tasks )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varTasks);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contacts )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varContacts);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Notes )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varNotes);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Journal )( 
            IMailbox __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varJournal);
        
        END_INTERFACE
    } IMailboxVtbl;

    interface IMailbox
    {
        CONST_VTBL struct IMailboxVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMailbox_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMailbox_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMailbox_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMailbox_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMailbox_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMailbox_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMailbox_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMailbox_get_BaseFolder(This,varBaseFolder)	\
    (This)->lpVtbl -> get_BaseFolder(This,varBaseFolder)

#define IMailbox_get_RootFolder(This,varRootFolder)	\
    (This)->lpVtbl -> get_RootFolder(This,varRootFolder)

#define IMailbox_get_Inbox(This,varInbox)	\
    (This)->lpVtbl -> get_Inbox(This,varInbox)

#define IMailbox_get_Outbox(This,varOutbox)	\
    (This)->lpVtbl -> get_Outbox(This,varOutbox)

#define IMailbox_get_SentItems(This,varSentItems)	\
    (This)->lpVtbl -> get_SentItems(This,varSentItems)

#define IMailbox_get_Drafts(This,varDrafts)	\
    (This)->lpVtbl -> get_Drafts(This,varDrafts)

#define IMailbox_get_DeletedItems(This,varDeletedItems)	\
    (This)->lpVtbl -> get_DeletedItems(This,varDeletedItems)

#define IMailbox_get_Calendar(This,varCalendar)	\
    (This)->lpVtbl -> get_Calendar(This,varCalendar)

#define IMailbox_get_Tasks(This,varTasks)	\
    (This)->lpVtbl -> get_Tasks(This,varTasks)

#define IMailbox_get_Contacts(This,varContacts)	\
    (This)->lpVtbl -> get_Contacts(This,varContacts)

#define IMailbox_get_Notes(This,varNotes)	\
    (This)->lpVtbl -> get_Notes(This,varNotes)

#define IMailbox_get_Journal(This,varJournal)	\
    (This)->lpVtbl -> get_Journal(This,varJournal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_BaseFolder_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varBaseFolder);


void __RPC_STUB IMailbox_get_BaseFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_RootFolder_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varRootFolder);


void __RPC_STUB IMailbox_get_RootFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_Inbox_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varInbox);


void __RPC_STUB IMailbox_get_Inbox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_Outbox_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varOutbox);


void __RPC_STUB IMailbox_get_Outbox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_SentItems_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varSentItems);


void __RPC_STUB IMailbox_get_SentItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_Drafts_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDrafts);


void __RPC_STUB IMailbox_get_Drafts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_DeletedItems_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDeletedItems);


void __RPC_STUB IMailbox_get_DeletedItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_Calendar_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varCalendar);


void __RPC_STUB IMailbox_get_Calendar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_Tasks_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varTasks);


void __RPC_STUB IMailbox_get_Tasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_Contacts_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varContacts);


void __RPC_STUB IMailbox_get_Contacts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_Notes_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varNotes);


void __RPC_STUB IMailbox_get_Notes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailbox_get_Journal_Proxy( 
    IMailbox __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varJournal);


void __RPC_STUB IMailbox_get_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMailbox_INTERFACE_DEFINED__ */


#ifndef __IFolder_INTERFACE_DEFINED__
#define __IFolder_INTERFACE_DEFINED__

/* interface IFolder */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000132-8B95-11D1-82DB-00C04FB1625D")
    IFolder : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *varDisplayName) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Configuration( 
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FolderAdmin( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *varFolderAdmin) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EmailAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *varEmailAddress) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UnreadItemCount( 
            /* [retval][out] */ LONG __RPC_FAR *varUnreadItemCount) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_VisibleCount( 
            /* [retval][out] */ LONG __RPC_FAR *varVisibleCount) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ItemCount( 
            /* [retval][out] */ LONG __RPC_FAR *varItemCount) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HasSubFolders( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varHasSubFolders) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DeletedItems( 
            /* [retval][out] */ BSTR __RPC_FAR *varDeletedItems) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DefaultItemType( 
            /* [retval][out] */ BSTR __RPC_FAR *varDefaultItemType) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pDescription) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR varDescription) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentClass( 
            /* [retval][out] */ BSTR __RPC_FAR *pContentClass) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ContentClass( 
            /* [in] */ BSTR varContentClass) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFolder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFolder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFolder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFolder __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFolder __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFolder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFolder __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayName )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDisplayName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Configuration )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Configuration )( 
            IFolder __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Configuration )( 
            IFolder __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FolderAdmin )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *varFolderAdmin);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EmailAddress )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varEmailAddress);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UnreadItemCount )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *varUnreadItemCount);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VisibleCount )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *varVisibleCount);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ItemCount )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *varItemCount);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasSubFolders )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varHasSubFolders);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DeletedItems )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDeletedItems);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultItemType )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDefaultItemType);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pDescription);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IFolder __RPC_FAR * This,
            /* [in] */ BSTR varDescription);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentClass )( 
            IFolder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pContentClass);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentClass )( 
            IFolder __RPC_FAR * This,
            /* [in] */ BSTR varContentClass);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IFolder __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IFolderVtbl;

    interface IFolder
    {
        CONST_VTBL struct IFolderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFolder_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFolder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFolder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFolder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFolder_get_DisplayName(This,varDisplayName)	\
    (This)->lpVtbl -> get_DisplayName(This,varDisplayName)

#define IFolder_get_Configuration(This,pConfiguration)	\
    (This)->lpVtbl -> get_Configuration(This,pConfiguration)

#define IFolder_put_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> put_Configuration(This,varConfiguration)

#define IFolder_putref_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> putref_Configuration(This,varConfiguration)

#define IFolder_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IFolder_get_FolderAdmin(This,varFolderAdmin)	\
    (This)->lpVtbl -> get_FolderAdmin(This,varFolderAdmin)

#define IFolder_get_EmailAddress(This,varEmailAddress)	\
    (This)->lpVtbl -> get_EmailAddress(This,varEmailAddress)

#define IFolder_get_UnreadItemCount(This,varUnreadItemCount)	\
    (This)->lpVtbl -> get_UnreadItemCount(This,varUnreadItemCount)

#define IFolder_get_VisibleCount(This,varVisibleCount)	\
    (This)->lpVtbl -> get_VisibleCount(This,varVisibleCount)

#define IFolder_get_ItemCount(This,varItemCount)	\
    (This)->lpVtbl -> get_ItemCount(This,varItemCount)

#define IFolder_get_HasSubFolders(This,varHasSubFolders)	\
    (This)->lpVtbl -> get_HasSubFolders(This,varHasSubFolders)

#define IFolder_get_DeletedItems(This,varDeletedItems)	\
    (This)->lpVtbl -> get_DeletedItems(This,varDeletedItems)

#define IFolder_get_DefaultItemType(This,varDefaultItemType)	\
    (This)->lpVtbl -> get_DefaultItemType(This,varDefaultItemType)

#define IFolder_get_Description(This,pDescription)	\
    (This)->lpVtbl -> get_Description(This,pDescription)

#define IFolder_put_Description(This,varDescription)	\
    (This)->lpVtbl -> put_Description(This,varDescription)

#define IFolder_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IFolder_get_ContentClass(This,pContentClass)	\
    (This)->lpVtbl -> get_ContentClass(This,pContentClass)

#define IFolder_put_ContentClass(This,varContentClass)	\
    (This)->lpVtbl -> put_ContentClass(This,varContentClass)

#define IFolder_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_DisplayName_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDisplayName);


void __RPC_STUB IFolder_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_Configuration_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);


void __RPC_STUB IFolder_get_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IFolder_put_Configuration_Proxy( 
    IFolder __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IFolder_put_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IFolder_putref_Configuration_Proxy( 
    IFolder __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IFolder_putref_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_DataSource_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IFolder_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_FolderAdmin_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *varFolderAdmin);


void __RPC_STUB IFolder_get_FolderAdmin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_EmailAddress_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varEmailAddress);


void __RPC_STUB IFolder_get_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_UnreadItemCount_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *varUnreadItemCount);


void __RPC_STUB IFolder_get_UnreadItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_VisibleCount_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *varVisibleCount);


void __RPC_STUB IFolder_get_VisibleCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_ItemCount_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *varItemCount);


void __RPC_STUB IFolder_get_ItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_HasSubFolders_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *varHasSubFolders);


void __RPC_STUB IFolder_get_HasSubFolders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_DeletedItems_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDeletedItems);


void __RPC_STUB IFolder_get_DeletedItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_DefaultItemType_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDefaultItemType);


void __RPC_STUB IFolder_get_DefaultItemType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_Description_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pDescription);


void __RPC_STUB IFolder_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IFolder_put_Description_Proxy( 
    IFolder __RPC_FAR * This,
    /* [in] */ BSTR varDescription);


void __RPC_STUB IFolder_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_Fields_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IFolder_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolder_get_ContentClass_Proxy( 
    IFolder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pContentClass);


void __RPC_STUB IFolder_get_ContentClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IFolder_put_ContentClass_Proxy( 
    IFolder __RPC_FAR * This,
    /* [in] */ BSTR varContentClass);


void __RPC_STUB IFolder_put_ContentClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IFolder_GetInterface_Proxy( 
    IFolder __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IFolder_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFolder_INTERFACE_DEFINED__ */


#ifndef __IContactGroupMembers_INTERFACE_DEFINED__
#define __IContactGroupMembers_INTERFACE_DEFINED__

/* interface IContactGroupMembers */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IContactGroupMembers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000138-8B95-11D1-82DB-00C04FB1625D")
    IContactGroupMembers : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BSTR __RPC_FAR *Member) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR val) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContactGroupMembersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContactGroupMembers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContactGroupMembers __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContactGroupMembers __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IContactGroupMembers __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IContactGroupMembers __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IContactGroupMembers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IContactGroupMembers __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IContactGroupMembers __RPC_FAR * This,
            long Index,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IContactGroupMembers __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IContactGroupMembers __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *Member);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IContactGroupMembers __RPC_FAR * This,
            /* [in] */ BSTR val);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IContactGroupMembers __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);
        
        END_INTERFACE
    } IContactGroupMembersVtbl;

    interface IContactGroupMembers
    {
        CONST_VTBL struct IContactGroupMembersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContactGroupMembers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContactGroupMembers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContactGroupMembers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContactGroupMembers_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IContactGroupMembers_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IContactGroupMembers_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IContactGroupMembers_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IContactGroupMembers_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define IContactGroupMembers_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IContactGroupMembers_Delete(This,Member)	\
    (This)->lpVtbl -> Delete(This,Member)

#define IContactGroupMembers_Add(This,val)	\
    (This)->lpVtbl -> Add(This,val)

#define IContactGroupMembers_get__NewEnum(This,Unknown)	\
    (This)->lpVtbl -> get__NewEnum(This,Unknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IContactGroupMembers_get_Item_Proxy( 
    IContactGroupMembers __RPC_FAR * This,
    long Index,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IContactGroupMembers_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IContactGroupMembers_get_Count_Proxy( 
    IContactGroupMembers __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IContactGroupMembers_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IContactGroupMembers_Delete_Proxy( 
    IContactGroupMembers __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *Member);


void __RPC_STUB IContactGroupMembers_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IContactGroupMembers_Add_Proxy( 
    IContactGroupMembers __RPC_FAR * This,
    /* [in] */ BSTR val);


void __RPC_STUB IContactGroupMembers_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IContactGroupMembers_get__NewEnum_Proxy( 
    IContactGroupMembers __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);


void __RPC_STUB IContactGroupMembers_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContactGroupMembers_INTERFACE_DEFINED__ */


#ifndef __IPerson_INTERFACE_DEFINED__
#define __IPerson_INTERFACE_DEFINED__

/* interface IPerson */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IPerson;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000127-8B95-11D1-82DB-00C04FB1625D")
    IPerson : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Configuration( 
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MailingAddressID( 
            /* [retval][out] */ CdoMailingAddressIdValues __RPC_FAR *pMailingAddressID) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MailingAddressID( 
            /* [in] */ CdoMailingAddressIdValues varMailingAddressID) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MailingAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *varMailingAddress) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FileAsMapping( 
            /* [retval][out] */ CdoFileAsMappingId __RPC_FAR *pFileAsMapping) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FileAsMapping( 
            /* [in] */ CdoFileAsMappingId varFileAsMapping) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FileAs( 
            /* [retval][out] */ BSTR __RPC_FAR *pFileAs) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FileAs( 
            /* [in] */ BSTR varFileAs) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WorkPhone( 
            /* [retval][out] */ BSTR __RPC_FAR *pWorkPhone) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_WorkPhone( 
            /* [in] */ BSTR varWorkPhone) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WorkFax( 
            /* [retval][out] */ BSTR __RPC_FAR *pWorkFax) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_WorkFax( 
            /* [in] */ BSTR varWorkFax) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HomePhone( 
            /* [retval][out] */ BSTR __RPC_FAR *pHomePhone) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HomePhone( 
            /* [in] */ BSTR varHomePhone) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MobilePhone( 
            /* [retval][out] */ BSTR __RPC_FAR *pMobilePhone) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MobilePhone( 
            /* [in] */ BSTR varMobilePhone) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FirstName( 
            /* [retval][out] */ BSTR __RPC_FAR *pFirstName) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FirstName( 
            /* [in] */ BSTR varFirstName) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LastName( 
            /* [retval][out] */ BSTR __RPC_FAR *pLastName) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LastName( 
            /* [in] */ BSTR varLastName) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_NamePrefix( 
            /* [retval][out] */ BSTR __RPC_FAR *pNamePrefix) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_NamePrefix( 
            /* [in] */ BSTR varNamePrefix) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_NameSuffix( 
            /* [retval][out] */ BSTR __RPC_FAR *pNameSuffix) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_NameSuffix( 
            /* [in] */ BSTR varNameSuffix) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Email( 
            /* [retval][out] */ BSTR __RPC_FAR *pEmail) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Email( 
            /* [in] */ BSTR varEmail) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Email2( 
            /* [retval][out] */ BSTR __RPC_FAR *pEmail2) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Email2( 
            /* [in] */ BSTR varEmail2) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Email3( 
            /* [retval][out] */ BSTR __RPC_FAR *pEmail3) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Email3( 
            /* [in] */ BSTR varEmail3) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetVCardStream( 
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *Stream) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WorkStreet( 
            /* [retval][out] */ BSTR __RPC_FAR *pWorkStreet) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_WorkStreet( 
            /* [in] */ BSTR varWorkStreet) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WorkCity( 
            /* [retval][out] */ BSTR __RPC_FAR *pWorkCity) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_WorkCity( 
            /* [in] */ BSTR varWorkCity) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WorkCountry( 
            /* [retval][out] */ BSTR __RPC_FAR *pWorkCountry) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_WorkCountry( 
            /* [in] */ BSTR varWorkCountry) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WorkPostalCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pWorkPostalCode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_WorkPostalCode( 
            /* [in] */ BSTR varWorkPostalCode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WorkPostOfficeBox( 
            /* [retval][out] */ BSTR __RPC_FAR *pWorkPostOfficeBox) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_WorkPostOfficeBox( 
            /* [in] */ BSTR varWorkPostOfficeBox) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WorkPostalAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *varWorkPostalAddress) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WorkState( 
            /* [retval][out] */ BSTR __RPC_FAR *pWorkState) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_WorkState( 
            /* [in] */ BSTR varWorkState) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WorkPager( 
            /* [retval][out] */ BSTR __RPC_FAR *pWorkPager) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_WorkPager( 
            /* [in] */ BSTR varWorkPager) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HomeStreet( 
            /* [retval][out] */ BSTR __RPC_FAR *pHomeStreet) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HomeStreet( 
            /* [in] */ BSTR varHomeStreet) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HomeCity( 
            /* [retval][out] */ BSTR __RPC_FAR *pHomeCity) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HomeCity( 
            /* [in] */ BSTR varHomeCity) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HomeCountry( 
            /* [retval][out] */ BSTR __RPC_FAR *pHomeCountry) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HomeCountry( 
            /* [in] */ BSTR varHomeCountry) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HomePostalCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pHomePostalCode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HomePostalCode( 
            /* [in] */ BSTR varHomePostalCode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HomePostOfficeBox( 
            /* [retval][out] */ BSTR __RPC_FAR *pHomePostOfficeBox) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HomePostOfficeBox( 
            /* [in] */ BSTR varHomePostOfficeBox) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HomePostalAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *varHomePostalAddress) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HomeState( 
            /* [retval][out] */ BSTR __RPC_FAR *pHomeState) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HomeState( 
            /* [in] */ BSTR varHomeState) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HomeFax( 
            /* [retval][out] */ BSTR __RPC_FAR *pHomeFax) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HomeFax( 
            /* [in] */ BSTR varHomeFax) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MiddleName( 
            /* [retval][out] */ BSTR __RPC_FAR *pMiddleName) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MiddleName( 
            /* [in] */ BSTR varMiddleName) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Initials( 
            /* [retval][out] */ BSTR __RPC_FAR *pInitials) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Initials( 
            /* [in] */ BSTR varInitials) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EmailAddresses( 
            /* [retval][out] */ VARIANT __RPC_FAR *pEmailAddresses) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EmailAddresses( 
            /* [in] */ VARIANT varEmailAddresses) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Company( 
            /* [retval][out] */ BSTR __RPC_FAR *pCompany) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Company( 
            /* [in] */ BSTR varCompany) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ BSTR __RPC_FAR *pTitle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Title( 
            /* [in] */ BSTR varTitle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPerson __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPerson __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPerson __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPerson __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPerson __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPerson __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPerson __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Configuration )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Configuration )( 
            IPerson __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Configuration )( 
            IPerson __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MailingAddressID )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ CdoMailingAddressIdValues __RPC_FAR *pMailingAddressID);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MailingAddressID )( 
            IPerson __RPC_FAR * This,
            /* [in] */ CdoMailingAddressIdValues varMailingAddressID);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MailingAddress )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varMailingAddress);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FileAsMapping )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ CdoFileAsMappingId __RPC_FAR *pFileAsMapping);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FileAsMapping )( 
            IPerson __RPC_FAR * This,
            /* [in] */ CdoFileAsMappingId varFileAsMapping);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FileAs )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pFileAs);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FileAs )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varFileAs);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkPhone )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pWorkPhone);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkPhone )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varWorkPhone);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkFax )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pWorkFax);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkFax )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varWorkFax);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HomePhone )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pHomePhone);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HomePhone )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varHomePhone);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MobilePhone )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pMobilePhone);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MobilePhone )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varMobilePhone);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FirstName )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pFirstName);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FirstName )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varFirstName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LastName )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pLastName);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LastName )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varLastName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NamePrefix )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pNamePrefix);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NamePrefix )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varNamePrefix);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NameSuffix )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pNameSuffix);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NameSuffix )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varNameSuffix);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Email )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pEmail);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Email )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varEmail);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Email2 )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pEmail2);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Email2 )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varEmail2);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Email3 )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pEmail3);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Email3 )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varEmail3);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVCardStream )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *Stream);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkStreet )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pWorkStreet);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkStreet )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varWorkStreet);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkCity )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pWorkCity);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkCity )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varWorkCity);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkCountry )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pWorkCountry);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkCountry )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varWorkCountry);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkPostalCode )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pWorkPostalCode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkPostalCode )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varWorkPostalCode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkPostOfficeBox )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pWorkPostOfficeBox);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkPostOfficeBox )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varWorkPostOfficeBox);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkPostalAddress )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varWorkPostalAddress);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkState )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pWorkState);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkState )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varWorkState);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkPager )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pWorkPager);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkPager )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varWorkPager);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HomeStreet )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pHomeStreet);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HomeStreet )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varHomeStreet);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HomeCity )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pHomeCity);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HomeCity )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varHomeCity);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HomeCountry )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pHomeCountry);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HomeCountry )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varHomeCountry);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HomePostalCode )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pHomePostalCode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HomePostalCode )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varHomePostalCode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HomePostOfficeBox )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pHomePostOfficeBox);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HomePostOfficeBox )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varHomePostOfficeBox);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HomePostalAddress )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varHomePostalAddress);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HomeState )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pHomeState);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HomeState )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varHomeState);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HomeFax )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pHomeFax);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HomeFax )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varHomeFax);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MiddleName )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pMiddleName);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MiddleName )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varMiddleName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Initials )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pInitials);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Initials )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varInitials);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EmailAddresses )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pEmailAddresses);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EmailAddresses )( 
            IPerson __RPC_FAR * This,
            /* [in] */ VARIANT varEmailAddresses);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Company )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pCompany);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Company )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varCompany);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Title )( 
            IPerson __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pTitle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Title )( 
            IPerson __RPC_FAR * This,
            /* [in] */ BSTR varTitle);
        
        END_INTERFACE
    } IPersonVtbl;

    interface IPerson
    {
        CONST_VTBL struct IPersonVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerson_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPerson_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPerson_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPerson_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPerson_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPerson_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPerson_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPerson_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IPerson_get_Configuration(This,pConfiguration)	\
    (This)->lpVtbl -> get_Configuration(This,pConfiguration)

#define IPerson_put_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> put_Configuration(This,varConfiguration)

#define IPerson_putref_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> putref_Configuration(This,varConfiguration)

#define IPerson_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IPerson_get_MailingAddressID(This,pMailingAddressID)	\
    (This)->lpVtbl -> get_MailingAddressID(This,pMailingAddressID)

#define IPerson_put_MailingAddressID(This,varMailingAddressID)	\
    (This)->lpVtbl -> put_MailingAddressID(This,varMailingAddressID)

#define IPerson_get_MailingAddress(This,varMailingAddress)	\
    (This)->lpVtbl -> get_MailingAddress(This,varMailingAddress)

#define IPerson_get_FileAsMapping(This,pFileAsMapping)	\
    (This)->lpVtbl -> get_FileAsMapping(This,pFileAsMapping)

#define IPerson_put_FileAsMapping(This,varFileAsMapping)	\
    (This)->lpVtbl -> put_FileAsMapping(This,varFileAsMapping)

#define IPerson_get_FileAs(This,pFileAs)	\
    (This)->lpVtbl -> get_FileAs(This,pFileAs)

#define IPerson_put_FileAs(This,varFileAs)	\
    (This)->lpVtbl -> put_FileAs(This,varFileAs)

#define IPerson_get_WorkPhone(This,pWorkPhone)	\
    (This)->lpVtbl -> get_WorkPhone(This,pWorkPhone)

#define IPerson_put_WorkPhone(This,varWorkPhone)	\
    (This)->lpVtbl -> put_WorkPhone(This,varWorkPhone)

#define IPerson_get_WorkFax(This,pWorkFax)	\
    (This)->lpVtbl -> get_WorkFax(This,pWorkFax)

#define IPerson_put_WorkFax(This,varWorkFax)	\
    (This)->lpVtbl -> put_WorkFax(This,varWorkFax)

#define IPerson_get_HomePhone(This,pHomePhone)	\
    (This)->lpVtbl -> get_HomePhone(This,pHomePhone)

#define IPerson_put_HomePhone(This,varHomePhone)	\
    (This)->lpVtbl -> put_HomePhone(This,varHomePhone)

#define IPerson_get_MobilePhone(This,pMobilePhone)	\
    (This)->lpVtbl -> get_MobilePhone(This,pMobilePhone)

#define IPerson_put_MobilePhone(This,varMobilePhone)	\
    (This)->lpVtbl -> put_MobilePhone(This,varMobilePhone)

#define IPerson_get_FirstName(This,pFirstName)	\
    (This)->lpVtbl -> get_FirstName(This,pFirstName)

#define IPerson_put_FirstName(This,varFirstName)	\
    (This)->lpVtbl -> put_FirstName(This,varFirstName)

#define IPerson_get_LastName(This,pLastName)	\
    (This)->lpVtbl -> get_LastName(This,pLastName)

#define IPerson_put_LastName(This,varLastName)	\
    (This)->lpVtbl -> put_LastName(This,varLastName)

#define IPerson_get_NamePrefix(This,pNamePrefix)	\
    (This)->lpVtbl -> get_NamePrefix(This,pNamePrefix)

#define IPerson_put_NamePrefix(This,varNamePrefix)	\
    (This)->lpVtbl -> put_NamePrefix(This,varNamePrefix)

#define IPerson_get_NameSuffix(This,pNameSuffix)	\
    (This)->lpVtbl -> get_NameSuffix(This,pNameSuffix)

#define IPerson_put_NameSuffix(This,varNameSuffix)	\
    (This)->lpVtbl -> put_NameSuffix(This,varNameSuffix)

#define IPerson_get_Email(This,pEmail)	\
    (This)->lpVtbl -> get_Email(This,pEmail)

#define IPerson_put_Email(This,varEmail)	\
    (This)->lpVtbl -> put_Email(This,varEmail)

#define IPerson_get_Email2(This,pEmail2)	\
    (This)->lpVtbl -> get_Email2(This,pEmail2)

#define IPerson_put_Email2(This,varEmail2)	\
    (This)->lpVtbl -> put_Email2(This,varEmail2)

#define IPerson_get_Email3(This,pEmail3)	\
    (This)->lpVtbl -> get_Email3(This,pEmail3)

#define IPerson_put_Email3(This,varEmail3)	\
    (This)->lpVtbl -> put_Email3(This,varEmail3)

#define IPerson_GetVCardStream(This,Stream)	\
    (This)->lpVtbl -> GetVCardStream(This,Stream)

#define IPerson_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define IPerson_get_WorkStreet(This,pWorkStreet)	\
    (This)->lpVtbl -> get_WorkStreet(This,pWorkStreet)

#define IPerson_put_WorkStreet(This,varWorkStreet)	\
    (This)->lpVtbl -> put_WorkStreet(This,varWorkStreet)

#define IPerson_get_WorkCity(This,pWorkCity)	\
    (This)->lpVtbl -> get_WorkCity(This,pWorkCity)

#define IPerson_put_WorkCity(This,varWorkCity)	\
    (This)->lpVtbl -> put_WorkCity(This,varWorkCity)

#define IPerson_get_WorkCountry(This,pWorkCountry)	\
    (This)->lpVtbl -> get_WorkCountry(This,pWorkCountry)

#define IPerson_put_WorkCountry(This,varWorkCountry)	\
    (This)->lpVtbl -> put_WorkCountry(This,varWorkCountry)

#define IPerson_get_WorkPostalCode(This,pWorkPostalCode)	\
    (This)->lpVtbl -> get_WorkPostalCode(This,pWorkPostalCode)

#define IPerson_put_WorkPostalCode(This,varWorkPostalCode)	\
    (This)->lpVtbl -> put_WorkPostalCode(This,varWorkPostalCode)

#define IPerson_get_WorkPostOfficeBox(This,pWorkPostOfficeBox)	\
    (This)->lpVtbl -> get_WorkPostOfficeBox(This,pWorkPostOfficeBox)

#define IPerson_put_WorkPostOfficeBox(This,varWorkPostOfficeBox)	\
    (This)->lpVtbl -> put_WorkPostOfficeBox(This,varWorkPostOfficeBox)

#define IPerson_get_WorkPostalAddress(This,varWorkPostalAddress)	\
    (This)->lpVtbl -> get_WorkPostalAddress(This,varWorkPostalAddress)

#define IPerson_get_WorkState(This,pWorkState)	\
    (This)->lpVtbl -> get_WorkState(This,pWorkState)

#define IPerson_put_WorkState(This,varWorkState)	\
    (This)->lpVtbl -> put_WorkState(This,varWorkState)

#define IPerson_get_WorkPager(This,pWorkPager)	\
    (This)->lpVtbl -> get_WorkPager(This,pWorkPager)

#define IPerson_put_WorkPager(This,varWorkPager)	\
    (This)->lpVtbl -> put_WorkPager(This,varWorkPager)

#define IPerson_get_HomeStreet(This,pHomeStreet)	\
    (This)->lpVtbl -> get_HomeStreet(This,pHomeStreet)

#define IPerson_put_HomeStreet(This,varHomeStreet)	\
    (This)->lpVtbl -> put_HomeStreet(This,varHomeStreet)

#define IPerson_get_HomeCity(This,pHomeCity)	\
    (This)->lpVtbl -> get_HomeCity(This,pHomeCity)

#define IPerson_put_HomeCity(This,varHomeCity)	\
    (This)->lpVtbl -> put_HomeCity(This,varHomeCity)

#define IPerson_get_HomeCountry(This,pHomeCountry)	\
    (This)->lpVtbl -> get_HomeCountry(This,pHomeCountry)

#define IPerson_put_HomeCountry(This,varHomeCountry)	\
    (This)->lpVtbl -> put_HomeCountry(This,varHomeCountry)

#define IPerson_get_HomePostalCode(This,pHomePostalCode)	\
    (This)->lpVtbl -> get_HomePostalCode(This,pHomePostalCode)

#define IPerson_put_HomePostalCode(This,varHomePostalCode)	\
    (This)->lpVtbl -> put_HomePostalCode(This,varHomePostalCode)

#define IPerson_get_HomePostOfficeBox(This,pHomePostOfficeBox)	\
    (This)->lpVtbl -> get_HomePostOfficeBox(This,pHomePostOfficeBox)

#define IPerson_put_HomePostOfficeBox(This,varHomePostOfficeBox)	\
    (This)->lpVtbl -> put_HomePostOfficeBox(This,varHomePostOfficeBox)

#define IPerson_get_HomePostalAddress(This,varHomePostalAddress)	\
    (This)->lpVtbl -> get_HomePostalAddress(This,varHomePostalAddress)

#define IPerson_get_HomeState(This,pHomeState)	\
    (This)->lpVtbl -> get_HomeState(This,pHomeState)

#define IPerson_put_HomeState(This,varHomeState)	\
    (This)->lpVtbl -> put_HomeState(This,varHomeState)

#define IPerson_get_HomeFax(This,pHomeFax)	\
    (This)->lpVtbl -> get_HomeFax(This,pHomeFax)

#define IPerson_put_HomeFax(This,varHomeFax)	\
    (This)->lpVtbl -> put_HomeFax(This,varHomeFax)

#define IPerson_get_MiddleName(This,pMiddleName)	\
    (This)->lpVtbl -> get_MiddleName(This,pMiddleName)

#define IPerson_put_MiddleName(This,varMiddleName)	\
    (This)->lpVtbl -> put_MiddleName(This,varMiddleName)

#define IPerson_get_Initials(This,pInitials)	\
    (This)->lpVtbl -> get_Initials(This,pInitials)

#define IPerson_put_Initials(This,varInitials)	\
    (This)->lpVtbl -> put_Initials(This,varInitials)

#define IPerson_get_EmailAddresses(This,pEmailAddresses)	\
    (This)->lpVtbl -> get_EmailAddresses(This,pEmailAddresses)

#define IPerson_put_EmailAddresses(This,varEmailAddresses)	\
    (This)->lpVtbl -> put_EmailAddresses(This,varEmailAddresses)

#define IPerson_get_Company(This,pCompany)	\
    (This)->lpVtbl -> get_Company(This,pCompany)

#define IPerson_put_Company(This,varCompany)	\
    (This)->lpVtbl -> put_Company(This,varCompany)

#define IPerson_get_Title(This,pTitle)	\
    (This)->lpVtbl -> get_Title(This,pTitle)

#define IPerson_put_Title(This,varTitle)	\
    (This)->lpVtbl -> put_Title(This,varTitle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_DataSource_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IPerson_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_Configuration_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);


void __RPC_STUB IPerson_get_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_Configuration_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IPerson_put_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IPerson_putref_Configuration_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IPerson_putref_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_Fields_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IPerson_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_MailingAddressID_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ CdoMailingAddressIdValues __RPC_FAR *pMailingAddressID);


void __RPC_STUB IPerson_get_MailingAddressID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_MailingAddressID_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ CdoMailingAddressIdValues varMailingAddressID);


void __RPC_STUB IPerson_put_MailingAddressID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_MailingAddress_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varMailingAddress);


void __RPC_STUB IPerson_get_MailingAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_FileAsMapping_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ CdoFileAsMappingId __RPC_FAR *pFileAsMapping);


void __RPC_STUB IPerson_get_FileAsMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_FileAsMapping_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ CdoFileAsMappingId varFileAsMapping);


void __RPC_STUB IPerson_put_FileAsMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_FileAs_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pFileAs);


void __RPC_STUB IPerson_get_FileAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_FileAs_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varFileAs);


void __RPC_STUB IPerson_put_FileAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_WorkPhone_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pWorkPhone);


void __RPC_STUB IPerson_get_WorkPhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_WorkPhone_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varWorkPhone);


void __RPC_STUB IPerson_put_WorkPhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_WorkFax_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pWorkFax);


void __RPC_STUB IPerson_get_WorkFax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_WorkFax_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varWorkFax);


void __RPC_STUB IPerson_put_WorkFax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_HomePhone_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pHomePhone);


void __RPC_STUB IPerson_get_HomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_HomePhone_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varHomePhone);


void __RPC_STUB IPerson_put_HomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_MobilePhone_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pMobilePhone);


void __RPC_STUB IPerson_get_MobilePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_MobilePhone_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varMobilePhone);


void __RPC_STUB IPerson_put_MobilePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_FirstName_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pFirstName);


void __RPC_STUB IPerson_get_FirstName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_FirstName_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varFirstName);


void __RPC_STUB IPerson_put_FirstName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_LastName_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pLastName);


void __RPC_STUB IPerson_get_LastName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_LastName_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varLastName);


void __RPC_STUB IPerson_put_LastName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_NamePrefix_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pNamePrefix);


void __RPC_STUB IPerson_get_NamePrefix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_NamePrefix_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varNamePrefix);


void __RPC_STUB IPerson_put_NamePrefix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_NameSuffix_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pNameSuffix);


void __RPC_STUB IPerson_get_NameSuffix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_NameSuffix_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varNameSuffix);


void __RPC_STUB IPerson_put_NameSuffix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_Email_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pEmail);


void __RPC_STUB IPerson_get_Email_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_Email_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varEmail);


void __RPC_STUB IPerson_put_Email_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_Email2_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pEmail2);


void __RPC_STUB IPerson_get_Email2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_Email2_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varEmail2);


void __RPC_STUB IPerson_put_Email2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_Email3_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pEmail3);


void __RPC_STUB IPerson_get_Email3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_Email3_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varEmail3);


void __RPC_STUB IPerson_put_Email3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IPerson_GetVCardStream_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ _Stream __RPC_FAR *__RPC_FAR *Stream);


void __RPC_STUB IPerson_GetVCardStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IPerson_GetInterface_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IPerson_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_WorkStreet_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pWorkStreet);


void __RPC_STUB IPerson_get_WorkStreet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_WorkStreet_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varWorkStreet);


void __RPC_STUB IPerson_put_WorkStreet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_WorkCity_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pWorkCity);


void __RPC_STUB IPerson_get_WorkCity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_WorkCity_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varWorkCity);


void __RPC_STUB IPerson_put_WorkCity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_WorkCountry_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pWorkCountry);


void __RPC_STUB IPerson_get_WorkCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_WorkCountry_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varWorkCountry);


void __RPC_STUB IPerson_put_WorkCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_WorkPostalCode_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pWorkPostalCode);


void __RPC_STUB IPerson_get_WorkPostalCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_WorkPostalCode_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varWorkPostalCode);


void __RPC_STUB IPerson_put_WorkPostalCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_WorkPostOfficeBox_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pWorkPostOfficeBox);


void __RPC_STUB IPerson_get_WorkPostOfficeBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_WorkPostOfficeBox_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varWorkPostOfficeBox);


void __RPC_STUB IPerson_put_WorkPostOfficeBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_WorkPostalAddress_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varWorkPostalAddress);


void __RPC_STUB IPerson_get_WorkPostalAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_WorkState_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pWorkState);


void __RPC_STUB IPerson_get_WorkState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_WorkState_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varWorkState);


void __RPC_STUB IPerson_put_WorkState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_WorkPager_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pWorkPager);


void __RPC_STUB IPerson_get_WorkPager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_WorkPager_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varWorkPager);


void __RPC_STUB IPerson_put_WorkPager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_HomeStreet_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pHomeStreet);


void __RPC_STUB IPerson_get_HomeStreet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_HomeStreet_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varHomeStreet);


void __RPC_STUB IPerson_put_HomeStreet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_HomeCity_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pHomeCity);


void __RPC_STUB IPerson_get_HomeCity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_HomeCity_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varHomeCity);


void __RPC_STUB IPerson_put_HomeCity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_HomeCountry_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pHomeCountry);


void __RPC_STUB IPerson_get_HomeCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_HomeCountry_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varHomeCountry);


void __RPC_STUB IPerson_put_HomeCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_HomePostalCode_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pHomePostalCode);


void __RPC_STUB IPerson_get_HomePostalCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_HomePostalCode_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varHomePostalCode);


void __RPC_STUB IPerson_put_HomePostalCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_HomePostOfficeBox_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pHomePostOfficeBox);


void __RPC_STUB IPerson_get_HomePostOfficeBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_HomePostOfficeBox_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varHomePostOfficeBox);


void __RPC_STUB IPerson_put_HomePostOfficeBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_HomePostalAddress_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varHomePostalAddress);


void __RPC_STUB IPerson_get_HomePostalAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_HomeState_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pHomeState);


void __RPC_STUB IPerson_get_HomeState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_HomeState_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varHomeState);


void __RPC_STUB IPerson_put_HomeState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_HomeFax_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pHomeFax);


void __RPC_STUB IPerson_get_HomeFax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_HomeFax_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varHomeFax);


void __RPC_STUB IPerson_put_HomeFax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_MiddleName_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pMiddleName);


void __RPC_STUB IPerson_get_MiddleName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_MiddleName_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varMiddleName);


void __RPC_STUB IPerson_put_MiddleName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_Initials_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pInitials);


void __RPC_STUB IPerson_get_Initials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_Initials_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varInitials);


void __RPC_STUB IPerson_put_Initials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_EmailAddresses_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pEmailAddresses);


void __RPC_STUB IPerson_get_EmailAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_EmailAddresses_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ VARIANT varEmailAddresses);


void __RPC_STUB IPerson_put_EmailAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_Company_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pCompany);


void __RPC_STUB IPerson_get_Company_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_Company_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varCompany);


void __RPC_STUB IPerson_put_Company_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPerson_get_Title_Proxy( 
    IPerson __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pTitle);


void __RPC_STUB IPerson_get_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPerson_put_Title_Proxy( 
    IPerson __RPC_FAR * This,
    /* [in] */ BSTR varTitle);


void __RPC_STUB IPerson_put_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPerson_INTERFACE_DEFINED__ */


#ifndef __IAddressee_INTERFACE_DEFINED__
#define __IAddressee_INTERFACE_DEFINED__

/* interface IAddressee */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IAddressee;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000139-8B95-11D1-82DB-00C04FB1625D")
    IAddressee : public IDispatch
    {
    public:
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Configuration( 
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Configuration( 
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *pDisplayName) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ BSTR varDisplayName) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EmailAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pEmailAddress) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EmailAddress( 
            /* [in] */ BSTR varEmailAddress) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DirURL( 
            /* [retval][out] */ BSTR __RPC_FAR *varDirURL) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ResolvedStatus( 
            /* [retval][out] */ CdoResolvedStatus __RPC_FAR *pResolvedStatus) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ResolvedStatus( 
            /* [in] */ CdoResolvedStatus varResolvedStatus) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentClass( 
            /* [retval][out] */ BSTR __RPC_FAR *varContentClass) = 0;
        
        virtual /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AmbiguousNames( 
            /* [retval][out] */ IAddressees __RPC_FAR *__RPC_FAR *varAmbiguousNames) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFreeBusy( 
            /* [in] */ DATE StartTime,
            /* [in] */ DATE EndTime,
            /* [in] */ long Interval,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckName( 
            /* [in] */ BSTR Directory,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBRet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAddresseeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAddressee __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAddressee __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAddressee __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IAddressee __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Configuration )( 
            IAddressee __RPC_FAR * This,
            /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Configuration )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Configuration )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ IConfiguration __RPC_FAR *varConfiguration);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayName )( 
            IAddressee __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pDisplayName);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplayName )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ BSTR varDisplayName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EmailAddress )( 
            IAddressee __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pEmailAddress);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EmailAddress )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ BSTR varEmailAddress);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IAddressee __RPC_FAR * This,
            /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DirURL )( 
            IAddressee __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDirURL);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ResolvedStatus )( 
            IAddressee __RPC_FAR * This,
            /* [retval][out] */ CdoResolvedStatus __RPC_FAR *pResolvedStatus);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ResolvedStatus )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ CdoResolvedStatus varResolvedStatus);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentClass )( 
            IAddressee __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varContentClass);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AmbiguousNames )( 
            IAddressee __RPC_FAR * This,
            /* [retval][out] */ IAddressees __RPC_FAR *__RPC_FAR *varAmbiguousNames);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFreeBusy )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ DATE StartTime,
            /* [in] */ DATE EndTime,
            /* [in] */ long Interval,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckName )( 
            IAddressee __RPC_FAR * This,
            /* [in] */ BSTR Directory,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBRet);
        
        END_INTERFACE
    } IAddresseeVtbl;

    interface IAddressee
    {
        CONST_VTBL struct IAddresseeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAddressee_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAddressee_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAddressee_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAddressee_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAddressee_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAddressee_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAddressee_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAddressee_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IAddressee_get_Configuration(This,pConfiguration)	\
    (This)->lpVtbl -> get_Configuration(This,pConfiguration)

#define IAddressee_put_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> put_Configuration(This,varConfiguration)

#define IAddressee_putref_Configuration(This,varConfiguration)	\
    (This)->lpVtbl -> putref_Configuration(This,varConfiguration)

#define IAddressee_get_DisplayName(This,pDisplayName)	\
    (This)->lpVtbl -> get_DisplayName(This,pDisplayName)

#define IAddressee_put_DisplayName(This,varDisplayName)	\
    (This)->lpVtbl -> put_DisplayName(This,varDisplayName)

#define IAddressee_get_EmailAddress(This,pEmailAddress)	\
    (This)->lpVtbl -> get_EmailAddress(This,pEmailAddress)

#define IAddressee_put_EmailAddress(This,varEmailAddress)	\
    (This)->lpVtbl -> put_EmailAddress(This,varEmailAddress)

#define IAddressee_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IAddressee_get_DirURL(This,varDirURL)	\
    (This)->lpVtbl -> get_DirURL(This,varDirURL)

#define IAddressee_get_ResolvedStatus(This,pResolvedStatus)	\
    (This)->lpVtbl -> get_ResolvedStatus(This,pResolvedStatus)

#define IAddressee_put_ResolvedStatus(This,varResolvedStatus)	\
    (This)->lpVtbl -> put_ResolvedStatus(This,varResolvedStatus)

#define IAddressee_get_ContentClass(This,varContentClass)	\
    (This)->lpVtbl -> get_ContentClass(This,varContentClass)

#define IAddressee_get_AmbiguousNames(This,varAmbiguousNames)	\
    (This)->lpVtbl -> get_AmbiguousNames(This,varAmbiguousNames)

#define IAddressee_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define IAddressee_GetFreeBusy(This,StartTime,EndTime,Interval,pbstrRet)	\
    (This)->lpVtbl -> GetFreeBusy(This,StartTime,EndTime,Interval,pbstrRet)

#define IAddressee_CheckName(This,Directory,UserName,Password,pBRet)	\
    (This)->lpVtbl -> CheckName(This,Directory,UserName,Password,pBRet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAddressee_get_Fields_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IAddressee_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAddressee_get_Configuration_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [retval][out] */ IConfiguration __RPC_FAR *__RPC_FAR *pConfiguration);


void __RPC_STUB IAddressee_get_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAddressee_put_Configuration_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IAddressee_put_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IAddressee_putref_Configuration_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [in] */ IConfiguration __RPC_FAR *varConfiguration);


void __RPC_STUB IAddressee_putref_Configuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAddressee_get_DisplayName_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pDisplayName);


void __RPC_STUB IAddressee_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAddressee_put_DisplayName_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [in] */ BSTR varDisplayName);


void __RPC_STUB IAddressee_put_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAddressee_get_EmailAddress_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pEmailAddress);


void __RPC_STUB IAddressee_get_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAddressee_put_EmailAddress_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [in] */ BSTR varEmailAddress);


void __RPC_STUB IAddressee_put_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAddressee_get_DataSource_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [retval][out] */ IDataSource __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IAddressee_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAddressee_get_DirURL_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDirURL);


void __RPC_STUB IAddressee_get_DirURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAddressee_get_ResolvedStatus_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [retval][out] */ CdoResolvedStatus __RPC_FAR *pResolvedStatus);


void __RPC_STUB IAddressee_get_ResolvedStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IAddressee_put_ResolvedStatus_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [in] */ CdoResolvedStatus varResolvedStatus);


void __RPC_STUB IAddressee_put_ResolvedStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAddressee_get_ContentClass_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varContentClass);


void __RPC_STUB IAddressee_get_ContentClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAddressee_get_AmbiguousNames_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [retval][out] */ IAddressees __RPC_FAR *__RPC_FAR *varAmbiguousNames);


void __RPC_STUB IAddressee_get_AmbiguousNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAddressee_GetInterface_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IAddressee_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAddressee_GetFreeBusy_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [in] */ DATE StartTime,
    /* [in] */ DATE EndTime,
    /* [in] */ long Interval,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);


void __RPC_STUB IAddressee_GetFreeBusy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAddressee_CheckName_Proxy( 
    IAddressee __RPC_FAR * This,
    /* [in] */ BSTR Directory,
    /* [optional][in] */ BSTR UserName,
    /* [optional][in] */ BSTR Password,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBRet);


void __RPC_STUB IAddressee_CheckName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAddressee_INTERFACE_DEFINED__ */


#ifndef __IAddressees_INTERFACE_DEFINED__
#define __IAddressees_INTERFACE_DEFINED__

/* interface IAddressees */
/* [unique][helpcontext][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IAddressees;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD000142-8B95-11D1-82DB-00C04FB1625D")
    IAddressees : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ IAddressee __RPC_FAR *__RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAddresseesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAddressees __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAddressees __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAddressees __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAddressees __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAddressees __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAddressees __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAddressees __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IAddressees __RPC_FAR * This,
            long Index,
            /* [retval][out] */ IAddressee __RPC_FAR *__RPC_FAR *Value);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IAddressees __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IAddressees __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);
        
        END_INTERFACE
    } IAddresseesVtbl;

    interface IAddressees
    {
        CONST_VTBL struct IAddresseesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAddressees_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAddressees_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAddressees_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAddressees_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAddressees_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAddressees_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAddressees_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAddressees_get_Item(This,Index,Value)	\
    (This)->lpVtbl -> get_Item(This,Index,Value)

#define IAddressees_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IAddressees_get__NewEnum(This,Unknown)	\
    (This)->lpVtbl -> get__NewEnum(This,Unknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAddressees_get_Item_Proxy( 
    IAddressees __RPC_FAR * This,
    long Index,
    /* [retval][out] */ IAddressee __RPC_FAR *__RPC_FAR *Value);


void __RPC_STUB IAddressees_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAddressees_get_Count_Proxy( 
    IAddressees __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IAddressees_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IAddressees_get__NewEnum_Proxy( 
    IAddressees __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *Unknown);


void __RPC_STUB IAddressees_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAddressees_INTERFACE_DEFINED__ */



#ifndef __CDO_LIBRARY_DEFINED__
#define __CDO_LIBRARY_DEFINED__

/* library CDO */
/* [helpstring][helpfile][version][uuid] */ 




























EXTERN_C const IID LIBID_CDO;




/* module CdoBusyStatusValues */
/* [dllname] */ 









/* module CdoCalendar */
/* [dllname] */ 

















































/* module CdoCharset */
/* [dllname] */ 

























/* module CdoConfiguration */
/* [dllname] */ 






































/* module CdoContacts */
/* [dllname] */ 


































































































/* module CdoContentTypeValues */
/* [dllname] */ 
















/* module CdoDAV */
/* [dllname] */ 







/* [helpstring] */ const BSTR cdoGetContentLanguage	=	L"DAV:getcontentlanguage";




























/* module CdoEncodingType */
/* [dllname] */ 












/* module CdoExchange */
/* [dllname] */ 










/* module CdoHTTPMail */
/* [dllname] */ 







































/* module CdoInterfaces */
/* [dllname] */ 


























/* module CdoMailHeader */
/* [dllname] */ 








































/* module CdoMeetingStatusValues */
/* [dllname] */ 








/* module CdoMethodValues */
/* [dllname] */ 













/* module CdoNamespace */
/* [dllname] */ 














/* module CdoNNTPEnvelope */
/* [dllname] */ 







/* module CdoOffice */
/* [dllname] */ 






/* module CdoRecurrenceIdRangeValues */
/* [dllname] */ 








/* module CdoSMTPEnvelope */
/* [dllname] */ 











/* module CdoTransparentValues */
/* [dllname] */ 





#ifndef __CdoErrors_MODULE_DEFINED__
#define __CdoErrors_MODULE_DEFINED__


/* module CdoErrors */
/* [dllname] */ 

const LONG CDO_E_UNCAUGHT_EXCEPTION	=	0x80040201L;

const LONG CDO_E_NOT_OPENED	=	0x80040202L;

const LONG CDO_E_UNSUPPORTED_DATASOURCE	=	0x80040203L;

const LONG CDO_E_INVALID_PROPERTYNAME	=	0x80040204L;

const LONG CDO_E_PROP_UNSUPPORTED	=	0x80040205L;

const LONG CDO_E_INACTIVE	=	0x80040206L;

const LONG CDO_E_NO_SUPPORT_FOR_OBJECTS	=	0x80040207L;

const LONG CDO_E_NOT_AVAILABLE	=	0x80040208L;

const LONG CDO_E_NO_DEFAULT_DROP_DIR	=	0x80040209L;

const LONG CDO_E_SMTP_SERVER_REQUIRED	=	0x8004020aL;

const LONG CDO_E_NNTP_SERVER_REQUIRED	=	0x8004020bL;

const LONG CDO_E_RECIPIENT_MISSING	=	0x8004020cL;

const LONG CDO_E_FROM_MISSING	=	0x8004020dL;

const LONG CDO_E_SENDER_REJECTED	=	0x8004020eL;

const LONG CDO_E_RECIPIENTS_REJECTED	=	0x8004020fL;

const LONG CDO_E_NNTP_POST_FAILED	=	0x80040210L;

const LONG CDO_E_SMTP_SEND_FAILED	=	0x80040211L;

const LONG CDO_E_CONNECTION_DROPPED	=	0x80040212L;

const LONG CDO_E_FAILED_TO_CONNECT	=	0x80040213L;

const LONG CDO_E_INVALID_POST	=	0x80040214L;

const LONG CDO_E_AUTHENTICATION_FAILURE	=	0x80040215L;

const LONG CDO_E_INVALID_CONTENT_TYPE	=	0x80040216L;

const LONG CDO_E_LOGON_FAILURE	=	0x80040217L;

const LONG CDO_E_HTTP_NOT_FOUND	=	0x80040218L;

const LONG CDO_E_HTTP_FORBIDDEN	=	0x80040219L;

const LONG CDO_E_HTTP_FAILED	=	0x8004021aL;

const LONG CDO_E_MULTIPART_NO_DATA	=	0x8004021bL;

const LONG CDO_E_INVALID_ENCODING_FOR_MULTIPART	=	0x8004021cL;

const LONG CDO_E_PROP_NOT_FOUND	=	0x8004021eL;

const LONG CDO_E_INVALID_SEND_OPTION	=	0x80040220L;

const LONG CDO_E_INVALID_POST_OPTION	=	0x80040221L;

const LONG CDO_E_NO_PICKUP_DIR	=	0x80040222L;

const LONG CDO_E_NOT_ALL_DELETED	=	0x80040223L;

const LONG CDO_E_PROP_READONLY	=	0x80040227L;

const LONG CDO_E_PROP_CANNOT_DELETE	=	0x80040228L;

const LONG CDO_E_BAD_DATA	=	0x80040229L;

const LONG CDO_E_PROP_NONHEADER	=	0x8004022aL;

const LONG CDO_E_INVALID_CHARSET	=	0x8004022bL;

const LONG CDO_E_ADOSTREAM_NOT_BOUND	=	0x8004022cL;

const LONG CDO_E_CONTENTPROPXML_NOT_FOUND	=	0x8004022dL;

const LONG CDO_E_CONTENTPROPXML_WRONG_CHARSET	=	0x8004022eL;

const LONG CDO_E_CONTENTPROPXML_PARSE_FAILED	=	0x8004022fL;

const LONG CDO_E_CONTENTPROPXML_CONVERT_FAILED	=	0x80040230L;

const LONG CDO_E_NO_DIRECTORIES_SPECIFIED	=	0x80040231L;

const LONG CDO_E_DIRECTORIES_UNREACHABLE	=	0x80040232L;

const LONG CDO_E_BAD_SENDER	=	0x80040233L;

const LONG CDO_E_SELF_BINDING	=	0x80040234L;

const LONG CDO_E_BAD_ATTENDEE_DATA	=	0x80040235L;

const LONG CDO_E_ARGUMENT1	=	0x80044000L;

const LONG CDO_E_ARGUMENT2	=	0x80044001L;

const LONG CDO_E_ARGUMENT3	=	0x80044002L;

const LONG CDO_E_ARGUMENT4	=	0x80044003L;

const LONG CDO_E_ARGUMENT5	=	0x80044004L;

const LONG CDO_E_NOT_FOUND	=	0x800cce05L;

const LONG CDO_E_INVALID_ENCODING_TYPE	=	0x800cce1dL;

#endif /* __CdoErrors_MODULE_DEFINED__ */

EXTERN_C const CLSID CLSID_Message;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000001-8B95-11D1-82DB-00C04FB1625D")
Message;
#endif

EXTERN_C const CLSID CLSID_Configuration;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000002-8B95-11D1-82DB-00C04FB1625D")
Configuration;
#endif

EXTERN_C const CLSID CLSID_DropDirectory;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000004-8B95-11D1-82DB-00C04FB1625D")
DropDirectory;
#endif

EXTERN_C const CLSID CLSID_SMTPConnector;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000008-8B95-11D1-82DB-00C04FB1625D")
SMTPConnector;
#endif

EXTERN_C const CLSID CLSID_NNTPEarlyConnector;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000011-8B95-11D1-82DB-00C04FB1625D")
NNTPEarlyConnector;
#endif

EXTERN_C const CLSID CLSID_NNTPPostConnector;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000009-8B95-11D1-82DB-00C04FB1625D")
NNTPPostConnector;
#endif

EXTERN_C const CLSID CLSID_NNTPFinalConnector;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000010-8B95-11D1-82DB-00C04FB1625D")
NNTPFinalConnector;
#endif

EXTERN_C const CLSID CLSID_Item;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000112-8B95-11D1-82DB-00C04FB1625D")
Item;
#endif

EXTERN_C const CLSID CLSID_Appointment;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000100-8B95-11D1-82DB-00C04FB1625D")
Appointment;
#endif

EXTERN_C const CLSID CLSID_CalendarMessage;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000102-8B95-11D1-82DB-00C04FB1625D")
CalendarMessage;
#endif

EXTERN_C const CLSID CLSID_Folder;

#ifdef __cplusplus

class DECLSPEC_UUID("CD00010E-8B95-11D1-82DB-00C04FB1625D")
Folder;
#endif

EXTERN_C const CLSID CLSID_Person;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000107-8B95-11D1-82DB-00C04FB1625D")
Person;
#endif

EXTERN_C const CLSID CLSID_Attendee;

#ifdef __cplusplus

class DECLSPEC_UUID("CD00010D-8B95-11D1-82DB-00C04FB1625D")
Attendee;
#endif

EXTERN_C const CLSID CLSID_Addressee;

#ifdef __cplusplus

class DECLSPEC_UUID("CD000110-8B95-11D1-82DB-00C04FB1625D")
Addressee;
#endif

#ifndef __IGetInterface_INTERFACE_DEFINED__
#define __IGetInterface_INTERFACE_DEFINED__

/* interface IGetInterface */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IGetInterface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD0ff000-8B95-11D1-82DB-00C04FB1625D")
    IGetInterface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaceInner( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetInterfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetInterface __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetInterface __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetInterface __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IGetInterface __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfaceInner )( 
            IGetInterface __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IGetInterfaceVtbl;

    interface IGetInterface
    {
        CONST_VTBL struct IGetInterfaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetInterface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetInterface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetInterface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetInterface_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define IGetInterface_GetInterfaceInner(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterfaceInner(This,Interface,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetInterface_GetInterface_Proxy( 
    IGetInterface __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IGetInterface_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGetInterface_GetInterfaceInner_Proxy( 
    IGetInterface __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IGetInterface_GetInterfaceInner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetInterface_INTERFACE_DEFINED__ */

#endif /* __CDO_LIBRARY_DEFINED__ */
#if defined __cplusplus && !defined CDO_NO_NAMESPACE
} // namespace CDO
#endif

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\formatmessage\formatmessage.cpp ===
// FormatMessage.cpp: implementation of the CFormatMessage class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <tchar.h>
#include "FormatMessage.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFormatMessage::CFormatMessage( long lError )
{
    if ( !FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, lError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), reinterpret_cast<LPWSTR>( &m_psFormattedMessage ), 0, NULL ))
    {
        m_psFormattedMessage = NULL;        
        _sntprintf( m_sBuffer, sizeof(m_sBuffer)/sizeof(TCHAR), _T("%x" ), lError );
        m_sBuffer[sizeof(m_sBuffer)/sizeof(TCHAR)-1] = 0;
    }
}

CFormatMessage::~CFormatMessage()
{
    if ( NULL != m_psFormattedMessage ) 
        LocalFree( m_psFormattedMessage );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\inc\ausrutil.h ===
#ifndef _AUSRUTIL_H
#define _AUSRUTIL_H

#include <activeds.h>

#include <lm.h>
#include <lmapibuf.h>
#include <lmshare.h>

#ifndef ASSERT
#define ASSERT assert
#endif
#ifndef WSTRING
typedef std::wstring WSTRING;   // Move to sbs6base.h
#endif

enum NameContextType
{
    NAMECTX_SCHEMA = 0,
    NAMECTX_CONFIG = 1,
    NAMECTX_COUNT
};

// ----------------------------------------------------------------------------
// GetADNamingContext()
// ----------------------------------------------------------------------------
inline HRESULT GetADNamingContext(NameContextType ctx, LPCWSTR* ppszContextDN)
{
    const static LPCWSTR pszContextName[NAMECTX_COUNT] = { L"schemaNamingContext", L"configurationNamingContext"};
    static WSTRING strContextDN[NAMECTX_COUNT];

    HRESULT hr = S_OK;

    if (strContextDN[ctx].empty())
    {
        CComVariant var;
        CComPtr<IADs> pObj;
    
        hr = ADsGetObject(L"LDAP://rootDSE", IID_IADs, (void**)&pObj);
        if (SUCCEEDED(hr))
        {
            hr = pObj->Get(const_cast<LPWSTR>(pszContextName[ctx]), &var);
            if (SUCCEEDED(hr))
            {
                strContextDN[ctx] = var.bstrVal;
                *ppszContextDN = strContextDN[ctx].c_str();
            }
        }
    }
    else
    {
        *ppszContextDN = strContextDN[ctx].c_str();
        hr = S_OK;
    }

    return hr;
}

//--------------------------------------------------------------------------
// EnableButton
//
// Enables or disables a dialog control. If the control has the focus when
// it is disabled, the focus is moved to the next control
//--------------------------------------------------------------------------
inline void EnableButton(HWND hwndDialog, int iCtrlID, BOOL bEnable)
{
    HWND hWndCtrl = ::GetDlgItem(hwndDialog, iCtrlID);
    ATLASSERT(::IsWindow(hWndCtrl));

    if (!bEnable && ::GetFocus() == hWndCtrl)
    {
        HWND hWndNextCtrl = ::GetNextDlgTabItem(hwndDialog, hWndCtrl, FALSE);
        if (hWndNextCtrl != NULL && hWndNextCtrl != hWndCtrl)
        {
            ::SetFocus(hWndNextCtrl);
        }
    }

    ::EnableWindow(hWndCtrl, bEnable);
}

// ----------------------------------------------------------------------------
// UserExists()
// ----------------------------------------------------------------------------
inline BOOL UserExists( const TCHAR *szUser )
{
    _ASSERT(szUser);
    if ( !szUser )
        return FALSE;
        
    CComPtr<IADsUser> spADs = NULL;
    
    if ( FAILED(ADsGetObject(szUser, IID_IADsUser, (void**)&spADs)) )
    {
        return FALSE;
    }

    return TRUE;
}

// ----------------------------------------------------------------------------
// BDirExists()
// ----------------------------------------------------------------------------
inline BOOL BDirExists( const TCHAR *szDir )
{
	if (!szDir || !_tcslen( szDir ))
		return FALSE;

	DWORD dw = GetFileAttributes( szDir );
	if (dw != -1)
	{
		if (dw & FILE_ATTRIBUTE_DIRECTORY)
			return TRUE;
	}
	return FALSE;
}

// ----------------------------------------------------------------------------
// IsValidNetHF()
// 
// Checks to make sure that the path specified by szPath is a valid network 
// path (a return of 0 == success).
//
//  1 = IDS_ERROR_HF_INVALID
//  2 = IDS_ERROR_HF_BADSRV
//  4 = IDS_ERROR_HF_BADSHARE
//  8 = IDS_ERROR_HF_PERMS
//
// ----------------------------------------------------------------------------
inline INT IsValidNetHF( LPCTSTR szPath )
{
    INT     iRetVal     = 0;    
    DWORD   dwError     = 0;
    TCHAR   szNetPath[MAX_PATH*5];
    TCHAR   *pszServer  = NULL;
    TCHAR   *pszShare   = NULL;
    WCHAR   *pch        = NULL;     // Making this WCHAR instead of TCHAR because
                                    //  with the pointer stepping below, it wouldn't
                                    //  work as a regular CHAR (because of DBCS).
    TCHAR   szCurrDir[MAX_PATH*2];
    INT     iDirLen = MAX_PATH*2;

    _tcsncpy(szNetPath, szPath, (MAX_PATH*5)-1);

    // Make sure it at least starts off okay.
    if ( (_tcslen(szNetPath) < 6)   || 
         (szNetPath[0] != _T('\\')) || 
         (szNetPath[1] != _T('\\')) ||
         (szNetPath[2] == _T('\\')) )
         return(1);
    
    // Make sure there's a server and share at least.
    pszServer = &szNetPath[2];
    if ( (pch = _tcschr(pszServer, _T('\\'))) == NULL )
        return 1;
    *pch++ = 0;
    
    pszShare = pch;
    if ( pch = _tcschr(pszShare, _T('\\')) )
        *pch = 0;
        
    if ( !_tcslen(pszServer) || !_tcslen(pszShare) )
        return 1;
        
    PSHARE_INFO_2   pShrInfo2 = NULL;
    NET_API_STATUS  nApi      = ERROR_SUCCESS;
    
    nApi = ::NetShareGetInfo( pszServer, pszShare, 2, (LPBYTE*)&pShrInfo2 );
    if ( pShrInfo2 )
        NetApiBufferFree(pShrInfo2);
    
    if ( nApi == ERROR_ACCESS_DENIED )
        return 8;
    else if ( nApi == NERR_NetNameNotFound )
        return 4;
    else if ( nApi != NERR_Success )
        return 2;

/*
    // Let's try the szPath as is...
    if ( !::GetCurrentDirectory(iDirLen, szCurrDir) )
        return 0;

    if ( ::SetCurrentDirectory(szPath) )
    {
        ::SetCurrentDirectory(szCurrDir);
    }
    else
    {
        dwError = GetLastError();
        ::SetCurrentDirectory(szCurrDir);
        
        if ( (dwError == ERROR_FILE_NOT_FOUND) ||
             (dwError == ERROR_PATH_NOT_FOUND) )
        {
            return 4;
        }
        else if ( dwError == ERROR_ACCESS_DENIED )
        {
            return 8;
        }
        else
        {
            return 2;
        }
    }
*/
    
    _tcsncpy(szNetPath, szPath, (MAX_PATH*5)-1);    // Take the passed in string.
    if ( szNetPath[_tcslen(szNetPath)] != _T('\\') )
        _tcscat(szNetPath, _T("\\"));
    _tcscat(szNetPath, _T("tedrtest"));           // add a random path onto it.
    
    if ( ::SetCurrentDirectory(szNetPath) )         // Try setting to this new path.
    {
        ::SetCurrentDirectory(szCurrDir);
        return 0;
    }
    else
    {
        dwError = GetLastError();
        ::SetCurrentDirectory(szCurrDir);
        
        if ( dwError == ERROR_ACCESS_DENIED )       // Did we get access denied?  Then we don't have
        {                                           //  access to the original share.
            return 8;
        }
    }
    
    return(iRetVal);
}

inline BOOL StrContainsDBCS(LPCTSTR szIn)
{
    BOOL    bFound  = FALSE;
    TCHAR   *pch    = NULL;

    for ( pch=(LPTSTR)szIn; *pch && !bFound; pch=_tcsinc(pch) )
    {
        if ( IsDBCSLeadByte((BYTE)*pch) )
            bFound = TRUE;
    }
    
    return(bFound);
}

inline BOOL LdapToDCName(LPCTSTR pszPath, LPTSTR pszOutBuf, int nOutBufSize)
{
    _ASSERT(pszPath != NULL && pszOutBuf != NULL && nOutBufSize != NULL);

    int nPathLen = _tcslen(pszPath);

    // alloc temp buffer that is guaranteed to be big enough (worst case = all chars must be escaped)
    LPTSTR pszLocBuf = (LPTSTR)alloca(_tcslen(pszPath) * sizeof(TCHAR) * 2);
    LPTSTR pszOut = pszLocBuf;

    LPCTSTR pszFirstDC = NULL;
    LPCTSTR psz;

    // Copy All DCs to buffer separated by periods
    if (nPathLen > 3)
    {
        // start search two chars from the start, so DC test doesn't go beyond start
        psz = pszPath + 2;

        while (psz = _tcschr(psz, L'='))
        {
            // if this is a DC name
            if (_tcsnicmp(psz - 2, L"DC", 2) == 0)
            {
                // Save pointer to first one
                if (pszFirstDC == NULL)
                    pszFirstDC = psz - 2;

                // Copy name to ouput buffer
                psz++;

                while (*psz != TEXT(',') && *psz != 0)  
                    *pszOut++ = *psz++;

                // if not last one, add a '.'
                if (*psz != 0)
                    *pszOut++ = TEXT('.');
            }
            else
            {
                // move past the current '='
                psz++;
            }
        }
    }
    
    // Add terminator
    *pszOut = 0;
    
    // Transfer converted path to real output buffer
    if (pszOut - pszLocBuf < nOutBufSize)
    {
        _tcscpy(pszOutBuf, pszLocBuf);
        return TRUE;
    }
    else
    {
        _tcsncpy(pszOutBuf, pszLocBuf, nOutBufSize - 1);
        pszOutBuf[nOutBufSize - 1] = 0;
        return FALSE;
    }
}    

inline VARIANT GetDomainPath(LPCTSTR lpServer)
{
// get the domain information
    TCHAR pString[MAX_PATH*2];
    _stprintf(pString, L"LDAP://%s/rootDSE", lpServer);

    VARIANT vDomain;
    ::VariantInit(&vDomain);

    CComPtr<IADs> pDS = NULL;
    HRESULT hr = ::ADsGetObject(pString,
            IID_IADs,
            (void**)&pDS);

    ATLASSERT(hr == ERROR_SUCCESS);
    if (hr != ERROR_SUCCESS)
    {
        return vDomain;
    }

    hr = pDS->Get(L"defaultNamingContext", &vDomain);
    ATLASSERT(hr == ERROR_SUCCESS);
    if (hr != ERROR_SUCCESS)
    {
        return vDomain;
    }

    return vDomain;
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveTrailingWhitespace
//
//  Synopsis:   Trailing white space is replaced by NULLs.
//
//-----------------------------------------------------------------------------
inline void RemoveTrailingWhitespace(PTSTR ptz)
{
    int nLen = _tcslen(ptz);

    while (nLen)
    {
        if (!iswspace(ptz[nLen - 1]))
        {
            return;
        }
        ptz[nLen - 1] = L'\0';
        nLen--;
    }
}

HRESULT GetMDBPath( WSTRING& csMailbox )
{
    // Get Configuration context of directory
    LPCWSTR pszContextDN = NULL;
    HRESULT hr = GetADNamingContext(NAMECTX_CONFIG, &pszContextDN);
    if ( FAILED(hr) )
        return hr;

    // Reduce the scope of the search to beneath the Exchange object
    WSTRING strExchScope = L"LDAP://CN=Microsoft Exchange,CN=Services,";
    strExchScope += pszContextDN;

    CComPtr<IDirectorySearch>pDirSearch = NULL;
    hr = ::ADsOpenObject(strExchScope.c_str(), NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (void**)&pDirSearch);
    if ( FAILED(hr) )
        return hr;


    // Search for Exchange MDB's. There should only be one in an SBS installation.   
    ADS_SEARCH_HANDLE hSearch;
    LPWSTR pszAttr = L"distinguishedName";

    hr = pDirSearch->ExecuteSearch(L"(objectClass=msExchPrivateMDB)", &pszAttr, 1, &hSearch);
    if ( FAILED(hr) )
        return hr;

    // Get first found object and return its distinguished name
    hr = pDirSearch->GetNextRow(hSearch);
    if ( hr == S_OK )
    {
        ADS_SEARCH_COLUMN col;
        hr = pDirSearch->GetColumn(hSearch, pszAttr, &col);

        if ( SUCCEEDED(hr) )
        {
            ASSERT(col.dwADsType == ADSTYPE_DN_STRING);
            csMailbox = col.pADsValues->CaseIgnoreString;

            pDirSearch->FreeColumn(&col);
        }
    }

    pDirSearch->CloseSearchHandle(hSearch);

    return hr;
}

#endif  // _AUSRUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\formatmessage\formatmessage.h ===
// FormatMessage.h: interface for the CFormatMessage class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FormatMessage_H__032C8A47_665B_46A2_89BC_0818BB3AB1E0__INCLUDED_)
#define AFX_FormatMessage_H__032C8A47_665B_46A2_89BC_0818BB3AB1E0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFormatMessage
{
public:
    CFormatMessage( long lError );
    virtual ~CFormatMessage();

private:
    CFormatMessage(){;}

// Implementation
public:
    LPTSTR c_str() { return ( NULL != m_psFormattedMessage ) ? m_psFormattedMessage : m_sBuffer; }
    
// Attributes
protected:
    TCHAR   m_sBuffer[32]; // Big enough for any HRESULT (in case there is no system message
    LPTSTR  m_psFormattedMessage;

};

#endif // !defined(AFX_FormatMessage_H__032C8A47_665B_46A2_89BC_0818BB3AB1E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\logutil\logutil.h ===
// LOGUTIL.h

#ifndef _LOGUTIL_H__INCLUDED_
#define _LOGUTIL_H__INCLUDED_

#include <windows.h>

class CLogging;
extern CLogging g_log;

#define LOG g_log.Log
#define LOGINIT g_log.Init
#define LOGFILE( _file ) CLogging g_log( _file )
#define LOGFILEEX( _file, _path ) CLogging g_log( _file, _path )
#define LOGSIZE( _FileSizeLow ) g_log.Size( _FileSizeLow )

class CLogging
{
private:

	LPTSTR  m_psLogFile;
	LPTSTR  m_psDefaultPath;
    HINSTANCE m_hInstance;
    bool    m_bInitialized;
	bool	m_bSkipDefaultPath;

    void LogPrivate( LPCTSTR szBuffer );

public:

	CLogging( LPCTSTR ps );
	CLogging( LPCTSTR ps, LPCTSTR psPath );
	~CLogging( void );
	void Init( HINSTANCE hinst );
    void Initialize( void );
	void SetFile( LPCTSTR psLogFile );
    void __cdecl Log( int iMessageId, ... );
    void __cdecl Log( LPCTSTR lpszFormat, ... );
    void Size( DWORD _FileSizeLow );
	void SkipDefaultPath( void );
};

#endif // _LOGUTIL_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\setup\pop2exch\inc\cdoexstr.h ===
#ifndef __cdostr_h_
#define __cdostr_h_
//	__CdoBusyStatusValues_MODULE_DEFINED__
#define cdoBusy	L"Busy"
#define cdoFree	L"Free"
#define cdoOOF	L"OOF"
#define cdoTentative	L"Tentative"

//	__CdoCalendar_MODULE_DEFINED__
#define cdoAllDayEvent	L"urn:schemas:calendar:alldayevent"
#define cdoAttendeeRole	L"urn:schemas:calendar:attendeerole"
#define cdoAttendeeStatus	L"urn:schemas:calendar:attendeestatus"
#define cdoBusyStatus	L"urn:schemas:calendar:busystatus"
#define cdoCalendarLastModified	L"urn:schemas:calendar:lastmodified"
#define cdoCalendarUID	L"urn:schemas:calendar:uid"
#define cdoContact	L"urn:schemas:calendar:contact"
#define cdoContactURL	L"urn:schemas:calendar:contacturl"
#define cdoCreated	L"urn:schemas:calendar:created"
#define cdoDelegatedFrom	L"urn:schemas:calendar:delegated-from"
#define cdoDelegatedTo	L"urn:schemas:calendar:delegated-to"
#define cdoDescriptionURL	L"urn:schemas:calendar:descriptionurl"
#define cdoDTEnd	L"urn:schemas:calendar:dtend"
#define cdoDTStamp	L"urn:schemas:calendar:dtstamp"
#define cdoDTStart	L"urn:schemas:calendar:dtstart"
#define cdoDuration	L"urn:schemas:calendar:duration"
#define cdoExDate	L"urn:schemas:calendar:exdate"
#define cdoExRule	L"urn:schemas:calendar:exrule"
#define cdoFburl	L"urn:schemas:calendar:fburl"
#define cdoGEOLatitude	L"urn:schemas:calendar:geolatitude"
#define cdoGEOLongitude	L"urn:schemas:calendar:geolongitude"
#define cdoInstanceType	L"urn:schemas:calendar:instancetype"
#define cdoIsOrganizer	L"urn:schemas:calendar:isorganizer"
#define cdoLastModifiedTime	L"urn:schemas:calendar:lastmodifiedtime"
#define cdoLocation	L"urn:schemas:calendar:location"
#define cdoLocationURL	L"urn:schemas:calendar:locationurl"
#define cdoMeetingStatus	L"urn:schemas:calendar:meetingstatus"
#define cdoMethod	L"urn:schemas:calendar:method"
#define cdoProdId	L"urn:schemas:calendar:prodid"
#define cdoRDate	L"urn:schemas:calendar:rdate"
#define cdoRecurrenceId	L"urn:schemas:calendar:recurrenceid"
#define cdoRecurrenceIdRange	L"urn:schemas:calendar:recurrenceidrange"
#define cdoReminderOffset	L"urn:schemas:calendar:reminderoffset"
#define cdoReplyTime	L"urn:schemas:calendar:replytime"
#define cdoResources	L"urn:schemas:calendar:resources"
#define cdoResponseRequested	L"urn:schemas:calendar:responserequested"
#define cdoRRule	L"urn:schemas:calendar:rrule"
#define cdoRSVP	L"urn:schemas:calendar:rsvp"
#define cdoSentBy	L"urn:schemas:calendar:sent-by"
#define cdoSequence	L"urn:schemas:calendar:sequence"
#define cdoTimeZoneIDURN	L"urn:schemas:calendar:timezoneid"
#define cdoTimeZoneURN	L"urn:schemas:calendar:timezone"
#define cdoTransparency	L"urn:schemas:calendar:transparent"
#define cdoVersion	L"urn:schemas:calendar:version"

//	__CdoCharset_MODULE_DEFINED__
#define cdoBIG5	L"big5"
#define cdoEUC_JP	L"euc-jp"
#define cdoEUC_KR	L"euc-kr"
#define cdoGB2312	L"gb2312"
#define cdoISO_2022_JP	L"iso-2022-jp"
#define cdoISO_2022_KR	L"iso-2022-kr"
#define cdoISO_8859_1	L"iso-8859-1"
#define cdoISO_8859_2	L"iso-8859-2"
#define cdoISO_8859_3	L"iso-8859-3"
#define cdoISO_8859_4	L"iso-8859-4"
#define cdoISO_8859_5	L"iso-8859-5"
#define cdoISO_8859_6	L"iso-8859-6"
#define cdoISO_8859_7	L"iso-8859-7"
#define cdoISO_8859_8	L"iso-8859-8"
#define cdoISO_8859_9	L"iso-8859-9"
#define cdoKOI8_R	L"koi8-r"
#define cdoShift_JIS	L"shift-jis"
#define cdoUS_ASCII	L"us-ascii"
#define cdoUTF_7	L"utf-7"
#define cdoUTF_8	L"utf-8"

//	__CdoConfiguration_MODULE_DEFINED__
#define cdoAutoPromoteBodyParts	L"http://schemas.microsoft.com/cdo/configuration/autopromotebodyparts"
#define cdoFlushBuffersOnWrite	L"http://schemas.microsoft.com/cdo/configuration/flushbuffersonwrite"
#define cdoHTTPCookies	L"http://schemas.microsoft.com/cdo/configuration/httpcookies"
#define cdoLanguageCode	L"http://schemas.microsoft.com/cdo/configuration/languagecode"
#define cdoNNTPAccountName	L"http://schemas.microsoft.com/cdo/configuration/nntpaccountname"
#define cdoNNTPAuthenticate	L"http://schemas.microsoft.com/cdo/configuration/nntpauthenticate"
#define cdoNNTPConnectionTimeout	L"http://schemas.microsoft.com/cdo/configuration/nntpconnectiontimeout"
#define cdoNNTPServer	L"http://schemas.microsoft.com/cdo/configuration/nntpserver"
#define cdoNNTPServerPickupDirectory	L"http://schemas.microsoft.com/cdo/configuration/nntpserverpickupdirectory"
#define cdoNNTPServerPort	L"http://schemas.microsoft.com/cdo/configuration/nntpserverport"
#define cdoNNTPUseSSL	L"http://schemas.microsoft.com/cdo/configuration/nntpusessl"
#define cdoPostEmailAddress	L"http://schemas.microsoft.com/cdo/configuration/postemailaddress"
#define cdoPostPassword	L"http://schemas.microsoft.com/cdo/configuration/postpassword"
#define cdoPostUserName	L"http://schemas.microsoft.com/cdo/configuration/postusername"
#define cdoPostUserReplyEmailAddress	L"http://schemas.microsoft.com/cdo/configuration/postuserreplyemailaddress"
#define cdoPostUsingMethod	L"http://schemas.microsoft.com/cdo/configuration/postusing"
#define cdoSaveSentItems	L"http://schemas.microsoft.com/cdo/configuration/savesentitems"
#define cdoSendEmailAddress	L"http://schemas.microsoft.com/cdo/configuration/sendemailaddress"
#define cdoSendPassword	L"http://schemas.microsoft.com/cdo/configuration/sendpassword"
#define cdoSendUserName	L"http://schemas.microsoft.com/cdo/configuration/sendusername"
#define cdoSendUserReplyEmailAddress	L"http://schemas.microsoft.com/cdo/configuration/senduserreplyemailaddress"
#define cdoSendUsingMethod	L"http://schemas.microsoft.com/cdo/configuration/sendusing"
#define cdoSMTPAccountName	L"http://schemas.microsoft.com/cdo/configuration/smtpaccountname"
#define cdoSMTPAuthenticate	L"http://schemas.microsoft.com/cdo/configuration/smtpauthenticate"
#define cdoSMTPConnectionTimeout	L"http://schemas.microsoft.com/cdo/configuration/smtpconnectiontimeout"
#define cdoSMTPServer	L"http://schemas.microsoft.com/cdo/configuration/smtpserver"
#define cdoSMTPServerPickupDirectory	L"http://schemas.microsoft.com/cdo/configuration/smtpserverpickupdirectory"
#define cdoSMTPServerPort	L"http://schemas.microsoft.com/cdo/configuration/smtpserverport"
#define cdoSMTPUseSSL	L"http://schemas.microsoft.com/cdo/configuration/smtpusessl"
#define cdoURLGetLatestVersion	L"http://schemas.microsoft.com/cdo/configuration/urlgetlatestversion"
#define cdoURLProxyBypass	L"http://schemas.microsoft.com/cdo/configuration/urlproxybypass"
#define cdoURLProxyServer	L"http://schemas.microsoft.com/cdo/configuration/urlproxyserver"
#define cdoUseMessageResponseText	L"http://schemas.microsoft.com/cdo/configuration/usemessageresponsetext"

//	__CdoContacts_MODULE_DEFINED__
#define cdoAccount	L"urn:schemas:contacts:account"
#define cdoBirthday	L"urn:schemas:contacts:bday"
#define cdoCallbackPhone	L"urn:schemas:contacts:callbackphone"
#define cdoChildrensNames	L"urn:schemas:contacts:childrensnames"
#define cdoCommonName	L"urn:schemas:contacts:cn"
#define cdoComputerNetworkName	L"urn:schemas:contacts:computernetworkname"
#define cdoCustomerId	L"urn:schemas:contacts:customerid"
#define cdoDepartment	L"urn:schemas:contacts:department"
#define cdoDistinguishedName	L"urn:schemas:contacts:dn"
#define cdoEmail1Address	L"urn:schemas:contacts:email1"
#define cdoEmail2Address	L"urn:schemas:contacts:email2"
#define cdoEmail3Address	L"urn:schemas:contacts:email3"
#define cdoEmployeeNumber	L"urn:schemas:contacts:employeenumber"
#define cdoFileAs	L"urn:schemas:contacts:fileas"
#define cdoFileAsId	L"urn:schemas:contacts:fileasid"
#define cdoFirstName	L"urn:schemas:contacts:givenName"
#define cdoFtpSite	L"urn:schemas:contacts:ftpsite"
#define cdoGender	L"urn:schemas:contacts:gender"
#define cdoGovernmentId	L"urn:schemas:contacts:governmentid"
#define cdoHobbies	L"urn:schemas:contacts:hobbies"
#define cdoHomeCity	L"urn:schemas:contacts:homeCity"
#define cdoHomeCountry	L"urn:schemas:contacts:homeCountry"
#define cdoHomeFax	L"urn:schemas:contacts:homefax"
#define cdoHomeLatitude	L"urn:schemas:contacts:homelatitude"
#define cdoHomeLongitude	L"urn:schemas:contacts:homelongitude"
#define cdoHomePhone	L"urn:schemas:contacts:homePhone"
#define cdoHomePhone2	L"urn:schemas:contacts:homephone2"
#define cdoHomePostalAddress	L"urn:schemas:contacts:homepostaladdress"
#define cdoHomePostalCode	L"urn:schemas:contacts:homePostalCode"
#define cdoHomePostOfficeBox	L"urn:schemas:contacts:homepostofficebox"
#define cdoHomeState	L"urn:schemas:contacts:homeState"
#define cdoHomeStreet	L"urn:schemas:contacts:homeStreet"
#define cdoHomeTimeZone	L"urn:schemas:contacts:hometimezone"
#define cdoInitials	L"urn:schemas:contacts:initials"
#define cdoInternationalISDNNumber	L"urn:schemas:contacts:internationalisdnnumber"
#define cdoLanguage	L"urn:schemas:contacts:language"
#define cdoLastName	L"urn:schemas:contacts:sn"
#define cdoMailingAddressId	L"urn:schemas:contacts:mailingaddressid"
#define cdoMailingCity	L"urn:schemas:contacts:mailingcity"
#define cdoMailingCountry	L"urn:schemas:contacts:mailingcountry"
#define cdoMailingPostalAddress	L"urn:schemas:contacts:mailingpostaladdress"
#define cdoMailingPostalCode	L"urn:schemas:contacts:mailingpostalcode"
#define cdoMailingPostOfficeBox	L"urn:schemas:contacts:mailingpostofficebox"
#define cdoMailingState	L"urn:schemas:contacts:mailingstate"
#define cdoMailingStreet	L"urn:schemas:contacts:mailingstreet"
#define cdoManager	L"urn:schemas:contacts:manager"
#define cdoMapURL	L"urn:schemas:contacts:mapurl"
#define cdoMiddleName	L"urn:schemas:contacts:middlename"
#define cdoNamePrefix	L"urn:schemas:contacts:personaltitle"
#define cdoNameSuffix	L"urn:schemas:contacts:namesuffix"
#define cdoNickname	L"urn:schemas:contacts:nickname"
#define cdoOrganizationName	L"urn:schemas:contacts:o"
#define cdoOriginalAuthor	L"urn:schemas:contacts:authorig"
#define cdoOtherCity	L"urn:schemas:contacts:othercity"
#define cdoOtherCountry	L"urn:schemas:contacts:othercountry"
#define cdoOtherCountryCode	L"urn:schemas:contacts:othercountrycode"
#define cdoOtherFax	L"urn:schemas:contacts:otherfax"
#define cdoOtherMobile	L"urn:schemas:contacts:othermobile"
#define cdoOtherPager	L"urn:schemas:contacts:otherpager"
#define cdoOtherPostalAddress	L"urn:schemas:contacts:otherpostaladdress"
#define cdoOtherPostalCode	L"urn:schemas:contacts:otherpostalcode"
#define cdoOtherPostOfficeBox	L"urn:schemas:contacts:otherpostofficebox"
#define cdoOtherState	L"urn:schemas:contacts:otherstate"
#define cdoOtherStreet	L"urn:schemas:contacts:otherstreet"
#define cdoOtherTimeZone	L"urn:schemas:contacts:othertimezone"
#define cdoOtherWorkPhone	L"urn:schemas:contacts:otherTelephone"
#define cdoPersonalURL	L"urn:schemas:contacts:personalHomePage"
#define cdoProfession	L"urn:schemas:contacts:profession"
#define cdoProxyAddresses	L"urn:schemas:contacts:proxyaddresses"
#define cdoRoomNumber	L"urn:schemas:contacts:roomnumber"
#define cdoSecretary	L"urn:schemas:contacts:secretary"
#define cdoSecretaryCommonName	L"urn:schemas:contacts:secretarycn"
#define cdoSecretaryURL	L"urn:schemas:contacts:secretaryurl"
#define cdoSourceURL	L"urn:schemas:contacts:sourceurl"
#define cdoSpouseCommonName	L"urn:schemas:contacts:spousecn"
#define cdoSubmissionContLength	L"urn:schemas:contacts:submissioncontlength"
#define cdoTelexNumber	L"urn:schemas:contacts:telexnumber"
#define cdoTitle	L"urn:schemas:contacts:title"
#define cdoUserCertificate	L"urn:schemas:contacts:usercertificate"
#define cdoWeddingAnniversary	L"urn:schemas:contacts:weddinganniversary"
#define cdoWorkAddress	L"urn:schemas:contacts:workaddress"
#define cdoWorkCity	L"urn:schemas:contacts:l"
#define cdoWorkCountry	L"urn:schemas:contacts:co"
#define cdoWorkCountryAbbreviation	L"urn:schemas:contacts:c"
#define cdoWorkFax	L"urn:schemas:contacts:facsimiletelephonenumber"
#define cdoWorkMobilePhone	L"urn:schemas:contacts:mobile"
#define cdoWorkPager	L"urn:schemas:contacts:pager"
#define cdoWorkPhone	L"urn:schemas:contacts:telephoneNumber"
#define cdoWorkPhone2	L"urn:schemas:contacts:telephonenumber2"
#define cdoWorkPostalCode	L"urn:schemas:contacts:postalcode"
#define cdoWorkPostOfficeBox	L"urn:schemas:contacts:postofficebox"
#define cdoWorkState	L"urn:schemas:contacts:st"
#define cdoWorkStreet	L"urn:schemas:contacts:street"

//	__CdoContentTypeValues_MODULE_DEFINED__
#define cdoGif	L"image/gif"
#define cdoJpeg	L"image/jpeg"
#define cdoMessageExternalBody	L"message/external-body"
#define cdoMessagePartial	L"message/partial"
#define cdoMessageRFC822	L"message/rfc822"
#define cdoMultipartAlternative	L"multipart/alternative"
#define cdoMultipartDigest	L"multipart/digest"
#define cdoMultipartMixed	L"multipart/mixed"
#define cdoMultipartRelated	L"multipart/related"
#define cdoTextHTML	L"text/html"
#define cdoTextPlain	L"text/plain"

//	__CdoDAV_MODULE_DEFINED__
#define cdoAbstract	L"DAV:abstract"
#define cdoChildCount	L"DAV:childcount"
#define cdoContentClass	L"DAV:contentclass"
#define cdoCreationDate	L"DAV:creationdate"
#define cdoDefaultDocument	L"DAV:defaultdocument"
#define cdoDisplayName	L"DAV:displayname"
#define cdoGetContentLength	L"DAV:getcontentlength"
#define cdoGetContentType	L"DAV:getcontenttype"
#define cdoGetEtag	L"DAV:getetag"
#define cdoGetLastModified	L"DAV:getlastmodified"
#define cdoHasChildren	L"DAV:haschildren"
#define cdoHasSubs	L"DAV:hassubs"
#define cdoHref	L"DAV:href"
#define cdoId	L"DAV:id"
#define cdoIsCollection	L"DAV:iscollection"
#define cdoIsFolder	L"DAV:isfolder"
#define cdoIsHidden	L"DAV:ishidden"
#define cdoIsRoot	L"DAV:isroot"
#define cdoIsStructuredDocument	L"DAV:isstructureddocument"
#define cdoLastAccessed	L"DAV:lastaccessed"
#define cdoLastModified	L"DAV:lastmodified"
#define cdoLockDiscovery	L"DAV:lockdiscovery"
#define cdoNoSubs	L"DAV:nosubs"
#define cdoObjectCount	L"DAV:objectcount"
#define cdoParentName	L"DAV:parentname"
#define cdoResourceType	L"DAV:resourcetype"
#define cdoSupportedLock	L"DAV:supportedlock"
#define cdoUID	L"DAV:uid"
#define cdoVisibleCount	L"DAV:visiblecount"

//	__CdoEncodingType_MODULE_DEFINED__
#define cdo7bit	L"7bit"
#define cdo8bit	L"8bit"
#define cdoBase64	L"base64"
#define cdoBinary	L"binary"
#define cdoMacBinHex40	L"mac-binhex40"
#define cdoQuotedPrintable	L"quoted-printable"
#define cdoUuencode	L"uuencode"

//	__CdoExchange_MODULE_DEFINED__
#define cdoAltRecipient	L"http://schemas.microsoft.com/exchange/altrecipient"
#define cdoCompanies	L"http://schemas.microsoft.com/exchange/companies"
#define cdoFolderSize	L"http://schemas.microsoft.com/exchange/foldersize"
#define cdoHardLinkList	L"http://schemas.microsoft.com/exchange/hardlinklist"
#define cdoSensitivity	L"http://schemas.microsoft.com/exchange/sensitivity"

//	__CdoHTTPMail_MODULE_DEFINED__
#define cdoAttachmentFilename	L"urn:schemas:httpmail:attachmentfilename"
#define cdoBcc	L"urn:schemas:httpmail:bcc"
#define cdoCc	L"urn:schemas:httpmail:cc"
#define cdoContentDispositionType	L"urn:schemas:httpmail:content-disposition-type"
#define cdoContentMediaType	L"urn:schemas:httpmail:content-media-type"
#define cdoDate	L"urn:schemas:httpmail:date"
#define cdoDateReceived	L"urn:schemas:httpmail:datereceived"
#define cdoDeletedItems	L"urn:schemas:httpmail:deleteditems"
#define cdoFrom	L"urn:schemas:httpmail:from"
#define cdoHasAttachment	L"urn:schemas:httpmail:hasattachment"
#define cdoHTMLDescription	L"urn:schemas:httpmail:htmldescription"
#define cdoHTTPMailCalendar	L"urn:schemas:httpmail:calendar"
#define cdoHTTPMailContacts	L"urn:schemas:httpmail:contacts"
#define cdoImportance	L"urn:schemas:httpmail:importance"
#define cdoInbox	L"urn:schemas:httpmail:inbox"
#define cdoJournal	L"urn:schemas:httpmail:journal"
#define cdoMsgFolderRoot	L"urn:schemas:httpmail:msgfolderroot"
#define cdoNormalizedSubject	L"urn:schemas:httpmail:normalizedsubject"
#define cdoNotes	L"urn:schemas:httpmail:notes"
#define cdoOutbox	L"urn:schemas:httpmail:outbox"
#define cdoPriority	L"urn:schemas:httpmail:priority"
#define cdoRead	L"urn:schemas:httpmail:read"
#define cdoReplyTo	L"urn:schemas:httpmail:reply-to"
#define cdoSender	L"urn:schemas:httpmail:sender"
#define cdoSendMsg	L"urn:schemas:httpmail:sendmsg"
#define cdoSentItems	L"urn:schemas:httpmail:sentitems"
#define cdoSpecial	L"urn:schemas:httpmail:special"
#define cdoSubject	L"urn:schemas:httpmail:subject"
#define cdoSubmitted	L"urn:schemas:httpmail:submitted"
#define cdoTasks	L"urn:schemas:httpmail:tasks"
#define cdoTextDescription	L"urn:schemas:httpmail:textdescription"
#define cdoThreadTopic	L"urn:schemas:httpmail:thread-topic"
#define cdoTo	L"urn:schemas:httpmail:to"
#define cdoUnreadCount	L"urn:schemas:httpmail:unreadcount"

//	__CdoInterfaces_MODULE_DEFINED__
#define cdoAdoRecord	L"_Record"
#define cdoAdoRecordset	L"_Recordset"
#define cdoAdoStream	L"_Stream"
#define cdoIAddressee	L"IAddressee"
#define cdoIAppointment	L"IAppointment"
#define cdoIBodyPart	L"IBodyPart"
#define cdoICalendarMessage	L"ICalendarMessage"
#define cdoICalendarPart	L"ICalendarPart"
#define cdoICalendarParts	L"ICalendarParts"
#define cdoIConfiguration	L"IConfiguration"
#define cdoIDataSource	L"IDataSource"
#define cdoIFolder	L"IFolder"
#define cdoIGroup	L"IGroup"
#define cdoIItem	L"IItem"
#define cdoIMailbox	L"IMailbox"
#define cdoIMessage	L"IMessage"
#define cdoIOrganization	L"IOrganization"
#define cdoIPerson	L"IPerson"
#define cdoIRow	L"IRow"
#define cdoIRowset	L"IRowset"
#define cdoIStream	L"IStream"

//	__CdoMailHeader_MODULE_DEFINED__
#define cdoApproved	L"urn:schemas:mailheader:approved"
#define cdoComment	L"urn:schemas:mailheader:comment"
#define cdoContentBase	L"urn:schemas:mailheader:content-base"
#define cdoContentDescription	L"urn:schemas:mailheader:content-description"
#define cdoContentDisposition	L"urn:schemas:mailheader:content-disposition"
#define cdoContentId	L"urn:schemas:mailheader:content-id"
#define cdoContentLanguage	L"urn:schemas:mailheader:content-language"
#define cdoContentLocation	L"urn:schemas:mailheader:content-location"
#define cdoContentTransferEncoding	L"urn:schemas:mailheader:content-transfer-encoding"
#define cdoContentType	L"urn:schemas:mailheader:content-type"
#define cdoControl	L"urn:schemas:mailheader:control"
#define cdoDisposition	L"urn:schemas:mailheader:disposition"
#define cdoDispositionNotificationTo	L"urn:schemas:mailheader:disposition-notification-to"
#define cdoDistribution	L"urn:schemas:mailheader:distribution"
#define cdoExpires	L"urn:schemas:mailheader:expires"
#define cdoFollowupTo	L"urn:schemas:mailheader:followup-to"
#define cdoInReplyTo	L"urn:schemas:mailheader:in-reply-to"
#define cdoLines	L"urn:schemas:mailheader:lines"
#define cdoMessageId	L"urn:schemas:mailheader:message-id"
#define cdoMIMEVersion	L"urn:schemas:mailheader:mime-version"
#define cdoNewsgroups	L"urn:schemas:mailheader:newsgroups"
#define cdoOrganization	L"urn:schemas:mailheader:organization"
#define cdoOriginalRecipient	L"urn:schemas:mailheader:original-recipient"
#define cdoPath	L"urn:schemas:mailheader:path"
#define cdoPostingVersion	L"urn:schemas:mailheader:posting-version"
#define cdoReceived	L"urn:schemas:mailheader:received"
#define cdoReferences	L"urn:schemas:mailheader:references"
#define cdoRelayVersion	L"urn:schemas:mailheader:relay-version"
#define cdoReturnPath	L"urn:schemas:mailheader:return-path"
#define cdoReturnReceiptTo	L"urn:schemas:mailheader:return-receipt-to"
#define cdoSummary	L"urn:schemas:mailheader:summary"
#define cdoThreadIndex	L"urn:schemas:mailheader:thread-index"
#define cdoXMailer	L"urn:schemas:mailheader:x-mailer"
#define cdoXref	L"urn:schemas:mailheader:xref"
#define cdoXUnsent	L"urn:schemas:mailheader:x-unsent"

//	__CdoMeetingStatusValues_MODULE_DEFINED__
#define cdoMeetingStatusCancelled	L"Cancelled"
#define cdoMeetingStatusConfirmed	L"Confirmed"
#define cdoMeetingStatusTentative	L"Tentative"

//	__CdoMethodValues_MODULE_DEFINED__
#define cdoAdd	L"Add"
#define cdoCancel	L"Cancel"
#define cdoCounter	L"Counter"
#define cdoDeclineCounter	L"DeclineCounter"
#define cdoPublish	L"Publish"
#define cdoRefresh	L"Refresh"
#define cdoReply	L"Reply"
#define cdoRequest	L"Request"

//	__CdoNamespace_MODULE_DEFINED__
#define cdoNSCalendar	L"urn:schemas:calendar:"
#define cdoNSConfiguration	L"http://schemas.microsoft.com/cdo/configuration/"
#define cdoNSContacts	L"urn:schemas:contacts:"
#define cdoNSDAV	L"DAV:"
#define cdoNSHTTPMail	L"urn:schemas:httpmail:"
#define cdoNSMailHeader	L"urn:schemas:mailheader:"
#define cdoNSNNTPEnvelope	L"http://schemas.microsoft.com/cdo/nntpenvelope/"
#define cdoNSSMTPEnvelope	L"http://schemas.microsoft.com/cdo/smtpenvelope/"
#define cdoNSVCAL	L"urn:schemas:vcal:"

//	__CdoNNTPEnvelope_MODULE_DEFINED__
#define cdoNewsgroupList	L"http://schemas.microsoft.com/cdo/nntpenvelope/newsgrouplist"
#define cdoNNTPProcessing	L"http://schemas.microsoft.com/cdo/nntpenvelope/nntpprocessing"

//	__CdoOffice_MODULE_DEFINED__
#define cdoKeywords	L"urn:schemas-microsoft-com:office:office#Keywords"

//	__CdoRecurrenceIdRangeValues_MODULE_DEFINED__
#define cdoNone	L"None"
#define cdoThisAndFuture	L"ThisAndFuture"
#define cdoThisAndPrior	L"ThisAndPrior"

//	__CdoSMTPEnvelope_MODULE_DEFINED__
#define cdoArrivalTime	L"http://schemas.microsoft.com/cdo/smtpenvelope/arrivaltime"
#define cdoClientIPAddress	L"http://schemas.microsoft.com/cdo/smtpenvelope/clientipaddress"
#define cdoMessageStatus	L"http://schemas.microsoft.com/cdo/smtpenvelope/messagestatus"
#define cdoPickupFileName	L"http://schemas.microsoft.com/cdo/smtpenvelope/pickupfilename"
#define cdoRecipientList	L"http://schemas.microsoft.com/cdo/smtpenvelope/recipientlist"
#define cdoSenderEmailAddress	L"http://schemas.microsoft.com/cdo/smtpenvelope/senderemailaddress"

//	__CdoTransparentValues_MODULE_DEFINED__
#define cdoOpaque	L"Opaque"
#define cdoTransparent	L"Transparent"

//	__CdoErrors_MODULE_DEFINED__

#endif // __cdostr_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\logutil\makefile.inc ===
postprocess:
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\logutil\logutil.cpp ===
//-----------------------------------------------------------------------------
// Util.cpp
//-----------------------------------------------------------------------------

#include <logutil.h>
#include <tchar.h>
#include <winerror.h>
#include <shlwapi.h>
#include <assert.h>
#include <stdio.h>

CLogging::CLogging( LPCTSTR ps ) : 
    m_psLogFile(NULL), m_psDefaultPath(NULL), m_bInitialized(false), m_hInstance(NULL), m_bSkipDefaultPath(false)
{
    assert( ps );
    if ( NULL != ps )
    {
        m_psLogFile = new TCHAR[ _tcslen( ps ) + 1 ]; 
        if( NULL != m_psLogFile )
        {
            _tcscpy( m_psLogFile, ps );
        }
    }
}

CLogging::CLogging( LPCTSTR ps, LPCTSTR psPath ) :
    m_psLogFile(NULL), m_psDefaultPath(NULL), m_bInitialized(false), m_hInstance(NULL), m_bSkipDefaultPath(false)
{
    assert( ps );
    if ( NULL != ps )
    {
        m_psLogFile = new TCHAR[ _tcslen( ps ) + 1 ]; 
        if(NULL != m_psLogFile)
        {
            _tcscpy( m_psLogFile, ps );
        }
    }

    assert( psPath );
    if ( NULL != psPath )
    {
        //try to substitute any embedded environment variables
        DWORD dwRC = 0;
        DWORD dwSize = ExpandEnvironmentStrings( psPath, m_psDefaultPath, 0 );
        if ( 0 != dwSize )
        {
            m_psDefaultPath = new TCHAR[dwSize + 1];
            dwRC = ExpandEnvironmentStrings( psPath, m_psDefaultPath, dwSize );
        }
        if ( 0 == dwRC )
        {
            dwSize = _tcslen( psPath ) + 1;
            m_psDefaultPath = new TCHAR[ dwSize ]; 
            if(NULL != m_psDefaultPath)
            {
                _tcsncpy( m_psDefaultPath, psPath, dwSize );
            }
        }
    }
}

CLogging::~CLogging () 
{
    if ( NULL != m_psLogFile )
        delete m_psLogFile;
    if ( NULL != m_psDefaultPath )
        delete m_psDefaultPath;
}

void CLogging::Init( HINSTANCE hinst )
{
    m_hInstance = hinst;
}

void CLogging::LogPrivate( LPCTSTR szBuffer )
{
    if (!m_bInitialized)
    	Initialize();
    if (!m_bInitialized)
        return;

    // always create/open the log file and close it after each write
    HANDLE hf = CreateFile( m_psLogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    if (hf != INVALID_HANDLE_VALUE)
    {
        // io
        DWORD dwWritten = 0;
        if (!SetFilePointer( hf, 0, NULL, FILE_END ))
        {
#ifdef UNICODE
            // write UNICODE signature (only first time)
            unsigned char sig[2] = { 0xFF, 0xFE };
            WriteFile (hf, (LPVOID)sig, 2, &dwWritten, NULL);
#endif
        }

        // write data
        dwWritten = 0;
        WriteFile( hf, (LPVOID)szBuffer, sizeof(TCHAR)*_tcslen( szBuffer ), &dwWritten, NULL );
        assert( dwWritten != 0 );

        // write crlf (if nec)
        // add a new line if not present
        int nLen = _tcslen( szBuffer );
        if ( nLen >=2 )
        {
            if (szBuffer[nLen - 2] != _T('\r') || szBuffer[nLen - 1] != _T('\n'))
                WriteFile( hf, (LPVOID)_T("\r\n"), 2 * sizeof(TCHAR), &dwWritten, NULL );
        }
        // close up (every time)
        CloseHandle( hf );
    }
}



void CLogging::Initialize()
{
    HRESULT hr = S_OK;

    // use default log file name if necessary
    if ( NULL == m_psLogFile )
    {
        m_psLogFile = new TCHAR[32];
        if ( NULL == m_psLogFile )
            hr = E_OUTOFMEMORY;
        else
            _tcscpy( m_psLogFile, _T("LOGFILE.log"));
    }

    // skip default path for non-server running apps
    if( !m_bSkipDefaultPath )
    {
        // create dir if not there already
        if ( NULL == m_psDefaultPath )
        {
            DWORD dwSize = MAX_PATH;

            m_psDefaultPath = new TCHAR[MAX_PATH];
            if ( NULL == m_psDefaultPath )
                hr = E_OUTOFMEMORY;
            else
            {
                if ( 0 == GetModuleFileName( NULL, m_psDefaultPath, dwSize ) )
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                else
                {
                    LPTSTR ps = _tcsrchr( m_psDefaultPath, _T( '\\' ));
                    if ( NULL != ps )
                        *ps = NULL;
                }
            }
        }
        else
        {
            if ( 0 == CreateDirectory( m_psDefaultPath, NULL ))
            {
                DWORD dwRC = GetLastError();
                if ( ERROR_ALREADY_EXISTS == dwRC )
                    hr = S_OK;
                else
                    hr = HRESULT_FROM_WIN32(hr);
            }

            if ( !PathAppend( m_psDefaultPath, m_psLogFile ))
                hr = E_FAIL;

            delete [] m_psLogFile;

            //m_psLogFile = m_psDefaultPath; This causes double free in the destructor...

            m_psLogFile = new TCHAR[ _tcslen( m_psDefaultPath ) + 1 ];
            if( NULL != m_psLogFile )
            {
                _tcscpy( m_psLogFile, m_psDefaultPath );
            }
        }
    }


    if SUCCEEDED( hr )
    {
        m_bInitialized = TRUE;
        // write initial messages to file
        TCHAR szTime[50];
        TCHAR szDate[50];
        GetTimeFormat( LOCALE_USER_DEFAULT, TIME_NOSECONDS, NULL, NULL, szTime, 50 );
        GetDateFormat( LOCALE_USER_DEFAULT, DATE_SHORTDATE, NULL, NULL, szDate, 50 );
        Log( _T("\r\n%s %s"), szDate, szTime );
    }
}

void __cdecl CLogging::Log( int iMessageId, ... )
{
	va_list ArgList;    // to turn ellipses into va_list
	va_start( ArgList, iMessageId );

	LPTSTR lpBuffer = NULL;
	FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, m_hInstance, iMessageId, 0, (LPTSTR)&lpBuffer, 0, &ArgList );
	assert( lpBuffer );
	if( lpBuffer )
	{
		LogPrivate (lpBuffer);
		LocalFree (lpBuffer);
	}

	va_end(ArgList);
}

void __cdecl CLogging::Log( LPCTSTR lpszFormat, ... )
{
	// form the log string
	va_list args;
	va_start( args, lpszFormat );
	TCHAR szBuffer[2048];
	// 2KB max log string with room for new line and null termination
	_vsntprintf( szBuffer, 2047, lpszFormat, args );
    szBuffer[2047]=0;
	va_end( args );

	LogPrivate( szBuffer );
}

void CLogging::Size( DWORD _FileSizeLow )
{
    if ( 0 != _FileSizeLow % 2 )
    {
        assert( false );    // Even numbers required in case this is a UNICODE file
        return;
    }
    if ( 1 > static_cast<long>( _FileSizeLow ))
    {
        assert( false );    // Need a positive number
        return;
    }
    if (m_bInitialized == FALSE)
        Initialize();
	if (!m_bInitialized)
        return;

    WIN32_FIND_DATA stWfd;
    HANDLE  hSearch;
    DWORD   dwRC;
    PBYTE   pbBuffer, pbBlankLine;
    DWORD   dwRead = 0, dwWrite, dwWritten;
    BOOL    bRC;

    pbBuffer = new BYTE[_FileSizeLow];
    if ( pbBuffer == NULL )
    {
        return;
    }
    ZeroMemory( pbBuffer, _FileSizeLow );
    hSearch = FindFirstFile( m_psLogFile, &stWfd );
    if ( hSearch != INVALID_HANDLE_VALUE )
    {
        FindClose( hSearch );
        if ( 0 < stWfd.nFileSizeHigh || _FileSizeLow < stWfd.nFileSizeLow )
        {   // Need to resize the file
            HANDLE hf = CreateFile( m_psLogFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
            if (hf != INVALID_HANDLE_VALUE) 
            {   // Move the pointer to the end of the file - the size we want to truncate to
                dwRC = SetFilePointer( hf, _FileSizeLow * -1, NULL, FILE_END );
                if ( INVALID_SET_FILE_POINTER != dwRC )
                {
                    bRC = ReadFile( hf, reinterpret_cast<LPVOID>( pbBuffer ), _FileSizeLow, &dwRead, NULL );
                    CloseHandle( hf );
                    if ( bRC && 0 < dwRead )
                    {   // Find the first blank line
                        pbBlankLine = reinterpret_cast<PBYTE>( _tcsstr( reinterpret_cast<LPTSTR>( pbBuffer ), _T( "\r\n\r\n" )));
                        if ( NULL != pbBlankLine )
                            pbBlankLine += 4 * sizeof( TCHAR );
                        else
                        {   // Let's just find the next crlf and write out the rest of the file
                            pbBlankLine = reinterpret_cast<PBYTE>( _tcsstr( reinterpret_cast<LPTSTR>( pbBuffer ), _T( "\r\n" )));
                            if ( NULL != pbBlankLine )
                                pbBlankLine += 2 * sizeof( TCHAR );
                        }
                        if ( NULL == pbBlankLine )
                        {   // I guess we should just write out the rest of the file
                            pbBlankLine = pbBuffer;
                        }
                        HANDLE hf1 = CreateFile( m_psLogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
                        if (hf1 != INVALID_HANDLE_VALUE) 
                        {
#ifdef UNICODE
                            // write UNICODE signature (only first time)
                            unsigned char sig[2] = { 0xFF, 0xFE };
                            WriteFile (hf1, (LPVOID)sig, 2, &dwWritten, NULL);
#endif
                            // write data
                            dwWritten = 0;
                            dwWrite = dwRead - static_cast<DWORD>(pbBlankLine - pbBuffer);
                            WriteFile (hf1, pbBlankLine, dwWrite, &dwWritten, NULL);
                            assert (dwWritten != 0);
                            // close up (every time)
                            CloseHandle (hf1);
                        }
                    }
                }
                CloseHandle(hf);
            }
        }
    }
    delete [] pbBuffer;
}

void CLogging::SetFile( LPCTSTR psLogFile )
{
    assert( !(NULL == psLogFile ));
    if ( NULL == psLogFile )
        return;
    if ( NULL != m_psLogFile )
        delete m_psLogFile;

    m_psLogFile = new TCHAR[ _tcslen( psLogFile ) + 1 ];
    if ( NULL == m_psLogFile )
        return;
	_tcscpy( m_psLogFile, psLogFile );
}

void CLogging::SkipDefaultPath( void )
{
	m_bSkipDefaultPath = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\mailbox\mailbox.cpp ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      MailBox.cpp
Abstract:       Implementation of the CMailBox class, abstraction of mailbox storage 
Notes:          
History:        08/01/2001 Created by Hao Yu (haoyu)

************************************************************************************************/

#include <windows.h>
#include <assert.h>
#include <tchar.h>
#include <process.h>
#include <stdlib.h>
#include <stdio.h>
#include <atlbase.h>

#include "Mailbox.h"
#include "Ntioapi.hxx"

#include <POP3Regkeys.h>

long CMailBox::m_lMailRootGuard=1;
WCHAR CMailBox::m_wszMailRoot[POP3_MAX_MAILROOT_LENGTH]=L"";

CMailBox::CMailBox()
{
    m_cMailCount=0;
    m_dwShowMailCount=0; 
    m_dwTotalSize=0;
    m_dwSizeOfMailVector=0;
    m_MailVector=NULL;
    m_hMailBoxLock=NULL;
    m_bMailBoxOpened=FALSE;
    ZeroMemory(m_wszMailBoxPath, sizeof(m_wszMailBoxPath));
}

CMailBox::~CMailBox()
{

}

/////////////////////////////////////////////////////////////////////////////
// BuildFilePath, public
//
// Purpose: 
//    common routine for building file paths
//
// Arguments:
//    LPSTR *ppFilePath : allocates buffer and returns the file path here, caller must free this buffer
//    LPSTR psFileName  : file name to create path for
//
// Returns: true on success, false otherwise.  Buffer must be freed by caller on success
bool CMailBox::BuildFilePath( LPWSTR psFilePathBuffer, LPWSTR psFileName, DWORD dwSizeOfFilePathBuffer )
{
    if ( NULL == psFilePathBuffer )
        return false;
    if ( NULL == psFileName )
        return false;
                                
    if ( dwSizeOfFilePathBuffer > 1 + wcslen( m_wszMailBoxPath ) + wcslen( psFileName ) )
    {
        wcscpy( psFilePathBuffer, m_wszMailBoxPath );
        wcscat( psFilePathBuffer, L"\\" );
        wcscat( psFilePathBuffer, psFileName );
        return true;
    }
    
    return false;
}

/////////////////////////////////////////////////////////////////////////////
// CreateMailBox, public
//
// Purpose: 
//    Create a mail box in our store
//    This involves:
//         create the mailbox directory
//         create a lock file in the mailbox
//
// Arguments:
//    char *szEmailAddr : mailbox to add
//
// Returns: TRUE on success, FALSE otherwise
bool CMailBox::CreateMailBox(WCHAR *wszEmailAddr)
{
    bool bRC;
    WCHAR wszLockFilePath[POP3_MAX_PATH];

    bRC = SetMailBoxPath( wszEmailAddr );
    if ( bRC )
        bRC = (CreateDirectory( m_wszMailBoxPath, NULL ) ? true:false);
    if ( bRC )
    {
        wszLockFilePath[sizeof(wszLockFilePath)/sizeof(WCHAR)-1] = 0;
        if ( 0 > _snwprintf( wszLockFilePath, sizeof(wszLockFilePath)/sizeof(WCHAR) - 1, L"%s\\%s", m_wszMailBoxPath, LOCK_FILENAME_W ))
            bRC = false;
        if ( bRC )
        {
            m_hMailBoxLock = CreateFile( wszLockFilePath, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_HIDDEN, NULL );
            if ( INVALID_HANDLE_VALUE != m_hMailBoxLock )
            {
                CloseHandle(m_hMailBoxLock);
                m_hMailBoxLock=NULL;
            }
            else
                bRC = false;
        }
        if ( !bRC )
            RemoveDirectory( m_wszMailBoxPath );    // Don't care about return
    }

    return bRC;
}

/////////////////////////////////////////////////////////////////////////////
// RepairMailBox, public
//
// Purpose: 
//    Repair a mail box in our store
//    This involves:
//         create a lock file in the mailbox if it does not exist
//
// Returns: TRUE on success, FALSE otherwise
BOOL CMailBox::RepairMailBox()
{
    bool bRC = true;
    WCHAR wszLockFilePath[POP3_MAX_PATH];

    wszLockFilePath[sizeof(wszLockFilePath)/sizeof(WCHAR)-1] = 0;
    if ( 0 > _snwprintf( wszLockFilePath, sizeof(wszLockFilePath)/sizeof(WCHAR)-1, L"%s\\%s", m_wszMailBoxPath, LOCK_FILENAME_W ))
        bRC = false;
    if ( bRC )
    {
        m_hMailBoxLock = CreateFile( wszLockFilePath, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_HIDDEN, NULL );
        if ( INVALID_HANDLE_VALUE != m_hMailBoxLock )
        {
            CloseHandle(m_hMailBoxLock);
            m_hMailBoxLock=NULL;
        }
        else
            bRC = false;
    }

    return bRC;
}

BOOL CMailBox::OpenMailBox(WCHAR *wszEmailAddr)
{
    if ( !SetMailBoxPath( wszEmailAddr ))
        return FALSE;

    if(ERROR_NO_FILE_ATTR == GetFileAttributes(m_wszMailBoxPath))
    {   // Mailbox does not exist!
        return FALSE;
    }

    m_bMailBoxOpened=TRUE;
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// isMailboxInUse, public
//
// Purpose: 
//    Determine if someone is already logged on to the mailbox
//    This involves:
//         checking if the Lock file has been opened for WRITE access
//
// Returns: true if we determine it is in use, false otherwise
bool CMailBox::isMailboxInUse()
{
    bool bRC = true;
    
    if ( LockMailBox() )
    {
        UnlockMailBox();
        bRC = false;
    }
    return bRC;
}
            
BOOL CMailBox::LockMailBox()
{
    WCHAR wszLockFilePath[POP3_MAX_PATH];
    assert(m_bMailBoxOpened);
    assert(m_wszMailRoot[0]!=L'\0');
    
    wszLockFilePath[sizeof(wszLockFilePath)/sizeof(WCHAR)-1] = 0;
    if ( 0 > _snwprintf(wszLockFilePath, 
                        sizeof(wszLockFilePath)/sizeof(WCHAR)-1, 
                        L"%s\\%s", 
                        m_wszMailBoxPath, 
                        LOCK_FILENAME_W ))
        return FALSE;
    m_hMailBoxLock=CreateFile(wszLockFilePath,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_DELETE, // Only one writer (only one Locker via this method of locking)
                          0,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_HIDDEN,
                          NULL);
    if(INVALID_HANDLE_VALUE == m_hMailBoxLock)
    {
        //Can not open mail box
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

/////////////////////////////////////////////////////////////////////////////
// UnlockMailBox, public
//
// Purpose: 
//    Unlock a mail box in our store
//
// Returns: TRUE on success, FALSE otherwise
void CMailBox::UnlockMailBox()
{
    if(NULL != m_hMailBoxLock)
    {
        CloseHandle(m_hMailBoxLock);
        m_hMailBoxLock=NULL;
    }
}

BOOL CMailBox::EnumerateMailBox(DWORD dwMaxMsg)
{
    PMAIL_ITEM pMail=NULL;
    WCHAR wszMailFilter[POP3_MAX_PATH+6];
    HANDLE hFind;
    DWORD dwLastErr;
    WIN32_FIND_DATA FileInfo;
    assert(m_bMailBoxOpened);
    assert(m_wszMailRoot[0]!=L'\0');

    wsprintf(wszMailFilter, 
             L"%s\\*.eml",
             m_wszMailBoxPath);

    hFind=FindFirstFile(wszMailFilter, 
                        &(FileInfo));
    if(INVALID_HANDLE_VALUE == hFind)
    {
        dwLastErr= GetLastError();
        if(ERROR_FILE_NOT_FOUND == dwLastErr ||
           ERROR_SUCCESS == dwLastErr)
        {
            // No mail in the mail box
            m_cMailCount=0;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    BOOL bMoreFile=TRUE;
    while(bMoreFile)
    {
        // To exclude hidden files 
        // which are mails being delivered
        if( ! (FileInfo.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) )
        {
            pMail = new (MAIL_ITEM);
            if(NULL == pMail)
            {
                //Log mem err
                return FALSE;
            }
            pMail->hFile=NULL;
            pMail->dwStatus=NO_PENDING_OP;
            pMail->bstrFileName=SysAllocString(FileInfo.cFileName);
            if(NULL == pMail->bstrFileName )
            {
                FindClose(hFind);
                delete pMail;
                return FALSE;
            }
            pMail->dwFileSize=FileInfo.nFileSizeLow;
            if(!PushMailToVector(pMail))
            {
                assert(NULL != pMail->bstrFileName);
                SysFreeString(pMail->bstrFileName);
                delete pMail;
                return FALSE;
            }
            m_cMailCount++;
            m_dwTotalSize+=FileInfo.nFileSizeLow;
        }
        if( (!dwMaxMsg) || (m_cMailCount != dwMaxMsg) )
        {
            bMoreFile=FindNextFile(hFind,&FileInfo);
        }
        else
        {
            bMoreFile=FALSE;
            SetLastError(ERROR_NO_MORE_FILES);
        }
    }      
    m_dwShowMailCount=m_cMailCount;
    dwLastErr= GetLastError();
    FindClose(hFind);
    if(ERROR_NO_MORE_FILES == dwLastErr)
    {
        return TRUE;
    }
    else
    {
        // Unexpected Error
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
// GetMailboxFromStoreNameW, public
//
// Purpose: 
//    Convert the Store Name to the Mailbox name
//
// Arguments:
//    LPWSTR psStoreName: The Store name for the mailbox, this string will be modified
//
// Returns: Mailbox name on success, NULL otherwise.
LPWSTR CMailBox::GetMailboxFromStoreNameW( LPWSTR psStoreName )
{
    if ( NULL == psStoreName )
        return NULL;
    if ( wcslen( psStoreName ) <= (wcslen( MAILBOX_PREFIX_W ) + wcslen( MAILBOX_EXTENSION_W )) )
        return NULL;

    // Validate psStoreName
    if ( 0 != _wcsnicmp( psStoreName, MAILBOX_PREFIX_W, wcslen( MAILBOX_PREFIX_W ) ))
        return NULL;
    if ( 0 != _wcsnicmp( psStoreName + wcslen( psStoreName ) - wcslen( MAILBOX_EXTENSION_W ), MAILBOX_EXTENSION_W, wcslen( MAILBOX_EXTENSION_W )))
        return NULL;
    psStoreName[wcslen( psStoreName ) - wcslen( MAILBOX_EXTENSION_W )] = 0;
    return psStoreName + wcslen( MAILBOX_PREFIX_W );
}

bool CMailBox::GetMailFileName( int iIndex, LPWSTR psFilename, DWORD dwSize )
{
    bool bRC = false;
    
    if ( iIndex < 0 || iIndex >= m_cMailCount )
        return false;
    if ( DEL_PENDING == m_MailVector[iIndex]->dwStatus )
        return false;
    
    if ( 0 < _snwprintf( psFilename, dwSize, L"%s\\%s", 
         m_wszMailBoxPath , m_MailVector[iIndex]->bstrFileName ))
        bRC = true;

    return bRC;
}

bool CMailBox::GetEncyptedPassword( LPBYTE pbBuffer, const DWORD dwBufferSize, LPDWORD pdwBytesRead )
{
    if ( NULL == pbBuffer ) 
        return false;
    if ( NULL == pdwBytesRead ) 
        return false;
    if ( NULL == m_hMailBoxLock )
        return false;
    
    if ( !ReadFile( m_hMailBoxLock, pbBuffer, dwBufferSize, pdwBytesRead, NULL ) || (dwBufferSize == *pdwBytesRead) )
        return false;
    return true;
}

bool CMailBox::SetEncyptedPassword( LPBYTE pbBuffer, DWORD dwBytesToWrite, LPDWORD pdwBytesWritten )
{
    if ( NULL == pbBuffer ) 
        return false;
    if ( NULL == pdwBytesWritten ) 
        return false;
    if ( NULL == m_hMailBoxLock )
        return false;
    
    if ( !WriteFile( m_hMailBoxLock, pbBuffer, dwBytesToWrite, pdwBytesWritten, NULL ))
        return false;
    // In case the file is shorter
    if ( !SetEndOfFile(m_hMailBoxLock) )
        return false;
    return true;
}

void CMailBox::Reset()
{

    for(int i=0;i<m_cMailCount; i++)
    {
        if(m_MailVector[i]->dwStatus==DEL_PENDING)
        {
            m_MailVector[i]->dwStatus=NO_PENDING_OP;
            m_dwTotalSize+=m_MailVector[i]->dwFileSize;
        }
    }
    m_dwShowMailCount=m_cMailCount;
}

DWORD CMailBox::DeleteMail(int iIndex)
{
    if(iIndex<0 || iIndex >= m_cMailCount)
    {
        return ERR_NO_SUCH_MSG;
    }
    if(m_MailVector[iIndex]->dwStatus==DEL_PENDING)
    {
        return ERR_MSG_ALREADY_DELETED;
    }
    else
    {
        ( m_MailVector[iIndex] )->dwStatus=DEL_PENDING;
        m_dwShowMailCount--;
        m_dwTotalSize-=m_MailVector[iIndex]->dwFileSize;
        return ERROR_SUCCESS;
    }
}


DWORD CMailBox::TransmitMail(PIO_CONTEXT pIoContext, int iIndex,int iLines)
{
    assert(NULL!=pIoContext);
    WCHAR wszFileName[POP3_MAX_PATH];
    char szRespBuf[MAX_PATH];
    DWORD dwTotalBytesToSend=0;
    TRANSMIT_FILE_BUFFERS TransmitBuf;
    int iErr;
    if( iIndex < 0   || 
        iIndex >= m_cMailCount )
    {
        return ERR_NO_SUCH_MSG;
    }
    if( m_MailVector[iIndex]->dwStatus==DEL_PENDING)
    {
        return ERR_MSG_ALREADY_DELETED;
    }
    else
    {
        sprintf(szRespBuf, 
                "+OK %d octects\r\n",
                m_MailVector[iIndex]->dwFileSize); 
        TransmitBuf.Head = szRespBuf;
        TransmitBuf.HeadLength = strlen(szRespBuf);
        TransmitBuf.Tail = RESP_END_OF_MULTILINE;
        TransmitBuf.TailLength = strlen(RESP_END_OF_MULTILINE);
        //Send the mail through the network
        if(m_MailVector[iIndex]->hFile == NULL)
        {
            if(0>_snwprintf(wszFileName, 
                            sizeof(wszFileName)/sizeof(WCHAR)-1,
                            L"%s\\%s",
                            m_wszMailBoxPath,
                            m_MailVector[iIndex]->bstrFileName))
            {
                return E_UNEXPECTED;
            }
            wszFileName[sizeof(wszFileName)/sizeof(WCHAR)-1]=0;
            m_MailVector[iIndex]->hFile=
                  CreateFile( wszFileName,
                              GENERIC_READ,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);
            if(INVALID_HANDLE_VALUE == m_MailVector[iIndex]->hFile  )
            {
                //Error
                m_MailVector[iIndex]->hFile=NULL;
                return GetLastError();
            }
    
        }
        else
        {
               if( INVALID_SET_FILE_POINTER ==
                   SetFilePointer(m_MailVector[iIndex]->hFile,
                                  0,NULL, FILE_BEGIN))
               {
                   //Error
                   return GetLastError();
               }
        }

        if(iLines>=0)
        {
            //For TOP command, calculate bytes to send
            if(!ReadTopLines(iLines, m_MailVector[iIndex]->hFile, &dwTotalBytesToSend))
            {
                return GetLastError();
            }
            if( INVALID_SET_FILE_POINTER ==
                SetFilePointer(m_MailVector[iIndex]->hFile,
                              0,NULL, FILE_BEGIN))
            {
                //Error
                return GetLastError();
            }
        }

        if(!TransmitFile(pIoContext->m_hAsyncIO,
                         m_MailVector[iIndex]->hFile,
                         dwTotalBytesToSend,
                         0,
                         &(pIoContext->m_Overlapped),
                         &TransmitBuf,
                         TF_USE_KERNEL_APC ) )
        {
            
            int iErr = WSAGetLastError();
            if(WSA_IO_PENDING!=iErr)
            {
                //Error
                return iErr;
            }
        }

        return ERROR_SUCCESS; 
    
    }
}

DWORD CMailBox::TransmitMail(SOCKET hSocket, int iIndex)
{
    WCHAR wszFileName[POP3_MAX_PATH];
    char szRespBuf[MAX_PATH];
    DWORD dwTotalBytesToSend=0;
    TRANSMIT_FILE_BUFFERS TransmitBuf;
    int iErr;
    if( iIndex < 0   || 
        iIndex >= m_cMailCount )
    {
        return ERR_NO_SUCH_MSG;
    }
    if( m_MailVector[iIndex]->dwStatus==DEL_PENDING)
    {
        return ERR_MSG_ALREADY_DELETED;
    }
    else
    {
        sprintf(szRespBuf, 
                "+OK %d octects\r\n",
                m_MailVector[iIndex]->dwFileSize); 
        TransmitBuf.Head = szRespBuf;
        TransmitBuf.HeadLength = strlen(szRespBuf);
        TransmitBuf.Tail = RESP_END_OF_MULTILINE;
        TransmitBuf.TailLength = strlen(RESP_END_OF_MULTILINE);
        //Send the mail through the network
        if(m_MailVector[iIndex]->hFile == NULL)
        {
            if(0>_snwprintf(wszFileName, 
                       sizeof(wszFileName)/sizeof(WCHAR)-1,
                     L"%s\\%s\0",
                     m_wszMailBoxPath,
                     m_MailVector[iIndex]->bstrFileName))
            {
                return E_UNEXPECTED;
            }
            wszFileName[sizeof(wszFileName)/sizeof(WCHAR)-1]=0;
            m_MailVector[iIndex]->hFile=
                  CreateFile( wszFileName,
                              GENERIC_READ,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_FLAG_OVERLAPPED |
                              FILE_FLAG_NO_BUFFERING ,
                              NULL);
            if(INVALID_HANDLE_VALUE == m_MailVector[iIndex]->hFile  )
            {
                //Error
                m_MailVector[iIndex]->hFile=NULL;
                return GetLastError();
            }
    
        }
        else
        {
               if( INVALID_SET_FILE_POINTER ==
                   SetFilePointer(m_MailVector[iIndex]->hFile,
                                  0,NULL, FILE_BEGIN))
               {
                   //Error
                   return GetLastError();
               }
        }

        if(!TransmitFile( hSocket,
                         m_MailVector[iIndex]->hFile,
                         dwTotalBytesToSend,
                         0,
                         NULL,
                         &TransmitBuf,
                         TF_USE_KERNEL_APC ) )
        {
            
            int iErr = WSAGetLastError();
            if(WSA_IO_PENDING!=iErr)
            {
                //Error
                return iErr;
            }
        }

        return ERROR_SUCCESS; 
    
    }
}

BOOL CMailBox::CommitAndClose()
{
    BOOL bRetVal=TRUE;
    WCHAR wszFileName[POP3_MAX_PATH];
    for(int i=0; i<m_cMailCount; i++)
    {
        if(NULL != m_MailVector[i])
        {
            if(NULL != m_MailVector[i]->hFile)
            {
                CloseHandle( m_MailVector[i]->hFile );
            }
            if( m_MailVector[i]->dwStatus == DEL_PENDING )
            {
               wszFileName[sizeof(wszFileName)/sizeof(WCHAR)-1]=0;
               if(0> _snwprintf ( wszFileName, 
                                  sizeof(wszFileName)/sizeof(WCHAR)-1,
                                  L"%s\\%s\0",
                                  m_wszMailBoxPath,
                                  m_MailVector[i]->bstrFileName))
               {
                   bRetVal=FALSE;
               }
               else if(FALSE==DeleteFile( wszFileName ) )
               {
                   //Error log
                   bRetVal=FALSE;
               }
            }
            if(NULL != m_MailVector[i]->bstrFileName)
            {
                SysFreeString(m_MailVector[i]->bstrFileName);
            }
            delete (m_MailVector[i]);
            m_MailVector[i]=NULL;
        }
    }

    delete[] m_MailVector;
    m_MailVector=NULL;
    m_dwSizeOfMailVector=0;
    if(NULL != m_hMailBoxLock)
    {
        CloseHandle(m_hMailBoxLock);
        m_hMailBoxLock=NULL;
    }
    m_cMailCount=0;
    m_dwShowMailCount=0; 
    m_dwTotalSize=0;
    ZeroMemory(m_wszMailBoxPath, sizeof(m_wszMailBoxPath));
    return bRetVal;
}


void CMailBox::CloseMailBox()
{
    m_bMailBoxOpened=FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CreateMail, public
//
// Purpose: 
//    Create a new empty mail file and return the handle.  The returned file handle 
//    should be closed using CloseMail, unless special options are being used as documented
//    in the CloseMail function below.
//
// Arguments:
//    LPSTR *szTargetFileName: File name (just the file name path will be prepended)
//    DWORD dwFlagsAndAttributes: [in] Specifies the file attributes and flags for the CreateFile api.
//
// Returns: file handle on success, INVALID_HANDLE_VALUE otherwise
HANDLE CMailBox::CreateMail( LPWSTR wszTargetFileName, DWORD dwFlagsAndAttributes /*= 0*/ )
{
    if ( NULL == wszTargetFileName )
        return INVALID_HANDLE_VALUE;
    assert(TRUE == m_bMailBoxOpened);

    HANDLE  hNewMail = INVALID_HANDLE_VALUE;
    HANDLE  hf;
    DWORD   dwBytes, dwSize;
    WCHAR wszFileNameBuffer[POP3_MAX_PATH];
    LPBYTE  pSIDOwner = NULL;
    PSECURITY_ATTRIBUTES psa = NULL;
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;

    // Set the Security Attributes to set the owner to the quota owner
    if ( BuildFilePath( wszFileNameBuffer, QUOTA_FILENAME, sizeof(wszFileNameBuffer)/sizeof(WCHAR) ))
    {
        hf = CreateFile( wszFileNameBuffer, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_HIDDEN, NULL );
        if ( INVALID_HANDLE_VALUE != hf )
        {
            dwSize = GetFileSize( hf, NULL );
            if ( INVALID_FILE_SIZE != dwSize )
            {
                pSIDOwner = new BYTE[dwSize];
                if ( NULL != pSIDOwner )
                {
                    SetLastError( ERROR_SUCCESS );
                    ReadFile( hf, pSIDOwner, dwSize, &dwBytes, NULL );  // No need to check return code here, the GetLastError check below covers it!
                }                                                       //  |
                else                                                    //  |
                    SetLastError( ERROR_OUTOFMEMORY );                  //  |
            }                                                           //  |
            CloseHandle( hf );                                          //  |
            if ( ERROR_SUCCESS == GetLastError() )  // <--------------------+
            {
                if ( InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION ))
                {   // Set the ownership for a new file
                    if ( SetSecurityDescriptorOwner( &sd, pSIDOwner, FALSE ))
                    {
                        sa.nLength = sizeof( sa );
                        sa.lpSecurityDescriptor = &sd;
                        sa.bInheritHandle = FALSE;
                        psa = &sa;
                    }
                }
            }
        }
    }
    if ( BuildFilePath( wszFileNameBuffer, wszTargetFileName, sizeof(wszFileNameBuffer)/sizeof(WCHAR) ))
        hNewMail = CreateFile( wszFileNameBuffer, GENERIC_ALL, 0, psa, CREATE_NEW, dwFlagsAndAttributes|FILE_ATTRIBUTE_HIDDEN, NULL );
    if ( NULL != pSIDOwner )
        delete [] pSIDOwner;
    
    return hNewMail;                                            
}

/////////////////////////////////////////////////////////////////////////////
// CloseMail, public
//
// Purpose: 
//    Close the mail file created using CreateMail.  
//
// Arguments:
//    LPSTR *szTargetFileName: File name (just the file name path will be prepended)
//    DWORD dwFlagsAndAttributes: If the FILE_FLAG_OVERLAPPED bit is set the file handle will not be closed.
//          In this case it is the responsibility of the calling process to ReleaseContext( PFIO_CONTEXT* )
//          which also closes the file handle.
//
// Returns: ERROR_SUCCESS on success, the applicable error otherwise.
DWORD CMailBox::CloseMail(HANDLE hMailFile,DWORD dwFlagsAndAttributes /*= 0*/)
{
    assert( !(INVALID_HANDLE_VALUE == hMailFile));
    if (INVALID_HANDLE_VALUE == hMailFile)
    {
        return ERROR_INVALID_HANDLE;
    }

    DWORD   dwRC;    
    IO_STATUS_BLOCK IoStatusBlock;
    
    dwRC = NtFlushBuffersFile( hMailFile, &IoStatusBlock );
    if ( ERROR_SUCCESS == dwRC )
    {   // Remove the FILE_ATTRIBUTE_HIDDEN
        FILE_BASIC_INFORMATION BasicInfo;
        
        ZeroMemory( &BasicInfo, sizeof(BasicInfo) );
        BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        dwRC = NtSetInformationFile( hMailFile, &IoStatusBlock, &BasicInfo, sizeof(BasicInfo), FileBasicInformation );
    }
    
    // Now close the handle, if appropriate
    if (!(FILE_FLAG_OVERLAPPED & dwFlagsAndAttributes))
    {
        if( !CloseHandle(hMailFile) ) 
            dwRC = GetLastError();
    }
    
    return dwRC;
}

/////////////////////////////////////////////////////////////////////////////
// DeleteMail, public
//
// Purpose: 
//    Delete a mail file.  This method is really meant for deleting files that were 
//    created but not successfully delivered.
//
// Arguments:
//    LPSTR *szTargetFileName: File name (just the file name path will be prepended)
//
// Returns: true on success, false otherwise
bool CMailBox::DeleteMail( LPWSTR wszTargetFileName )
{
    if ( NULL == wszTargetFileName )
        return false;
    if ( 0 == wcslen( wszTargetFileName ))
        return false;
    if ( !m_bMailBoxOpened )
        return false;

    bool    bRC = false;
    WCHAR wszFileNameBuffer[POP3_MAX_PATH];    
    if ( BuildFilePath( wszFileNameBuffer, wszTargetFileName, sizeof(wszFileNameBuffer)/sizeof(WCHAR) ))
    {
        bRC = DeleteFile( wszFileNameBuffer ) ? true : false;
    }
    
    return bRC;                                            
}

void CMailBox::QuitAndClose()
{
    for(int i=0; i<m_cMailCount; i++ )
    {
        if(NULL != m_MailVector[i])
        {
            if(NULL != m_MailVector[i]->hFile)
            {
                CloseHandle( m_MailVector[i]->hFile );
                m_MailVector[i]->hFile=NULL;
            }
            if(NULL != m_MailVector[i]->bstrFileName )
            {
                SysFreeString(m_MailVector[i]->bstrFileName);
            }
            delete (m_MailVector[i]);
            m_MailVector[i]=NULL;
        }
    }
    if(NULL != m_hMailBoxLock)
    {
        CloseHandle(m_hMailBoxLock);
        m_hMailBoxLock=NULL;
    }
    delete[] m_MailVector;
    m_MailVector=NULL;
    m_dwSizeOfMailVector=0;
    m_cMailCount=0;
    m_dwShowMailCount=0; 
    m_dwTotalSize=0;
    ZeroMemory(m_wszMailBoxPath, sizeof(m_wszMailBoxPath));

}



DWORD CMailBox::ListMail(int iIndex, char *szBuf, DWORD dwSize)
{
    assert(NULL!=szBuf);
    if( iIndex<0 || 
        iIndex >= m_cMailCount)
    {
        return ERR_NO_SUCH_MSG;
    }
    if(m_MailVector[iIndex]->dwStatus==DEL_PENDING)
    {
        return ERR_MSG_ALREADY_DELETED;
    }
    else
    {
        if(0> _snprintf(szBuf, 
                dwSize-1,
                "%d %d\r\n",
                iIndex+1, 
                m_MailVector[iIndex]->dwFileSize))
        {
            return ERROR_INVALID_DATA;
        }
		szBuf[dwSize-1]=0;
        return ERROR_SUCCESS;
    }
}

DWORD CMailBox::UidlMail(int iIndex, char *szBuf, DWORD dwSize)
{
    assert(NULL!=szBuf);
    if( iIndex<0 || 
        iIndex >= m_cMailCount)
    {
        return ERR_NO_SUCH_MSG;
    }
    if(m_MailVector[iIndex]->dwStatus==DEL_PENDING)
    {
        return ERR_MSG_ALREADY_DELETED;
    }
    else
    {
        if( 0>_snprintf(szBuf, 
                    dwSize-1, 
                    "%d %S",
                    iIndex+1, 
                    (m_MailVector[iIndex]->bstrFileName)+3))
        {
            return ERROR_INVALID_DATA;
        }
		szBuf[dwSize-1]=0;
		//To cut the .eml file extention
        int iFileExt=strlen(szBuf)-4;
        szBuf[iFileExt++]='\r';
        szBuf[iFileExt++]='\n';
        szBuf[iFileExt]='\0';
        return ERROR_SUCCESS;
    }
}


BOOL CMailBox::SetMailRoot(const WCHAR *wszMailRoot)
{
    BOOL  bRtVal=FALSE;

    if(1==InterlockedExchange(&m_lMailRootGuard, 0))
    {
        WCHAR sMailRoot[POP3_MAX_PATH];
        
        if ( wszMailRoot )
        {
            if ( sizeof(sMailRoot)/sizeof(WCHAR) > wcslen( wszMailRoot ))
            {
                wcscpy( sMailRoot, wszMailRoot );
                bRtVal=TRUE;
            }
        }
        else
        {   // Read the mailroot from the registry
            if ( ERROR_SUCCESS == RegQueryMailRoot( sMailRoot, sizeof( sMailRoot )/sizeof(WCHAR) ) )
            {
                bRtVal=TRUE;
            }
        }
        if ( bRtVal )
        {
            if ( 0 == wcsncmp( sMailRoot, L"\\\\", 2 ))
            {
                if ( sizeof( m_wszMailRoot )/sizeof(WCHAR) > wcslen( sMailRoot ) + 7 )
                {
                    wcscpy( m_wszMailRoot, L"\\\\?\\UNC" );
                    wcscat( m_wszMailRoot, &( sMailRoot[1] ));
                }
                else
                    bRtVal = FALSE;
            }
            else
            {
                if ( sizeof( m_wszMailRoot )/sizeof(WCHAR) > wcslen( sMailRoot ) + 5 )
                {
                    wcscpy( m_wszMailRoot, L"\\\\?\\" );
                    wcscat( m_wszMailRoot, sMailRoot );
                }
                else
                    bRtVal = FALSE;
            }
        }
        InterlockedExchange(&m_lMailRootGuard, 1);
    }
    else
    {
        //Some other thread is doing the job
        while(0==m_lMailRootGuard)
        {
            Sleep(100);
        }
        if(L'\0'!=m_wszMailRoot[0])
        {
            bRtVal=TRUE;
        }
    }
    return bRtVal;
}

///////////////////////////////////////////////////////////////
// Implementation: private
///////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// SetMailBoxPath, private
//
// Purpose: 
//    Build the Mailbox Path, validate the EmailAddr.
//
// Arguments:
//    char *szEmailAddr : mailbox to build path for
//
// Returns: true on success, false otherwise

bool CMailBox::SetMailBoxPath(WCHAR *wszEmailAddr)
{
    WCHAR *wszDomain=NULL;
    WCHAR *wszAccount=NULL;
    WCHAR wszNotAllowedSet[]=L"\\/:*?\",>|";
	WCHAR wszMailBox[POP3_MAX_ADDRESS_LENGTH];
	WCHAR wszMailDomain[POP3_MAX_DOMAIN_LENGTH];
    int iLen;

    while(iswspace(*wszEmailAddr))
    {
        wszEmailAddr++;
    }
    wszDomain=wcschr(wszEmailAddr, '@');
    if(wszDomain==NULL)
    {   //Error
        return false;
    }
    iLen=wcslen(wszDomain);
    if( 1 == iLen || iLen>=POP3_MAX_DOMAIN_LENGTH ) // Is there anything after the @?
    {   //Error
        return false;
    }
    wcscpy(wszMailDomain, wszDomain+1);
    wszMailDomain[iLen]='\0';
    iLen=(int)(wszDomain-wszEmailAddr);
    wcsncpy(wszMailBox, wszEmailAddr,iLen);
    wszMailBox[iLen]='\0';
    if(L'\0'==m_wszMailRoot[0])
    {
        if(!SetMailRoot())
        {
            return false;
        }
    }
    //Check if the mail domain and account is valid
    if( (NULL != wcspbrk(wszMailDomain, wszNotAllowedSet))
        || (NULL != wcspbrk(wszMailBox, wszNotAllowedSet)) 
        || (sizeof(m_wszMailBoxPath)/sizeof(WCHAR) <= wcslen(m_wszMailRoot) + 
                        wcslen(wszMailDomain) + 
                        wcslen(wszMailBox) + 
                        wcslen(MAILBOX_PREFIX_W) + 
                        wcslen(MAILBOX_EXTENSION_W) + 3 /*2 \\ and \0 */ ) )
    {
        return false;
    }  
    
    //build the path to the mail dir
    m_bMailBoxOpened = FALSE;
    m_wszMailBoxPath[sizeof(m_wszMailBoxPath)/sizeof(WCHAR)-1] = 0;
    if ( 0 > _snwprintf(m_wszMailBoxPath, 
                        sizeof(m_wszMailBoxPath)/sizeof(WCHAR) - 1, 
                        L"%s\\%s\\%s%s%s", 
                        m_wszMailRoot, 
                        wszMailDomain, 
                        MAILBOX_PREFIX_W, 
                        wszMailBox, 
                        MAILBOX_EXTENSION_W ))
        return false;

    return true;
}


bool CMailBox::ReadTopLines(int iLines, HANDLE hFile, DWORD *pdwBytesToRead)
{   
    assert(INVALID_HANDLE_VALUE!=hFile);
    assert(NULL != pdwBytesToRead);
    assert(NULL != hFile);
    assert(iLines>=0);
    
    BOOL bHeadersDone=FALSE;
    (*pdwBytesToRead)=0;
    BOOL bMoreToRead=TRUE;
    char szBuffer[LOCAL_FILE_BUFFER_SIZE+1];
    char *pLastNewLine=NULL;
    char chLastChr[3];
    DWORD dwBytesRead;
    DWORD dwIndex=0;
    char szEmpLine[5];
    chLastChr[0]='\0';
    chLastChr[1]='\0';
    chLastChr[2]='\0';
    szEmpLine[4]='\0';
    while(bMoreToRead)
    {
        
       if( !ReadFile(hFile, 
                    szBuffer,
                    LOCAL_FILE_BUFFER_SIZE,
                    &dwBytesRead,
                    NULL) )
       {
           return FALSE;           
       }
       szBuffer[dwBytesRead]='\0';
       if(dwBytesRead < LOCAL_FILE_BUFFER_SIZE)
       {
           bMoreToRead=FALSE;
       }
       for( dwIndex=0;dwIndex<dwBytesRead && (!bHeadersDone || iLines >0); dwIndex++)
       {
            if('\n'==szBuffer[dwIndex])
            {
                if(bHeadersDone)
                {
                   //The headers are done
                   //Count the lines now
                   if(dwIndex>0)
                   {
                       if('\r'==szBuffer[dwIndex-1])
                       {
                           iLines--;
                       }
                   }
                   else
                   {
                       if('\r'==chLastChr[2])
                       {
                           iLines--;
                           chLastChr[2]='\0';
                       }
                   }
                }
                else
                {
                    int i=4;
                    do
                    {
                        i--;
                        szEmpLine[i]=szBuffer[dwIndex+i-3];
                    }while((dwIndex+i-3>0) && i>0 );
                    if(i>0)
                    {
                        i--;
                        for(int j=2; i>=0 && j>=0; j--,i--)
                        {
                            szEmpLine[i]=chLastChr[j];
                        }
                    }
                    if(0==strcmp(szEmpLine, "\r\n\r\n"))
                    {
                       bHeadersDone=TRUE;
                    }
                }

            }
       }
       if(iLines==0)
       {
           (*pdwBytesToRead)+=dwIndex;
           bMoreToRead=FALSE;
       }
       else
       {
           (*pdwBytesToRead)+=dwBytesRead;
           chLastChr[2]=szBuffer[dwIndex-1];
           if(!bHeadersDone)
           {
               chLastChr[1]=szBuffer[dwIndex-2];
               chLastChr[0]=szBuffer[dwIndex-3];
           }
       }
    }
       
    if(iLines>0)
    {
        (*pdwBytesToRead)=0;
    }
    return TRUE;
}

bool CMailBox::PushMailToVector(PMAIL_ITEM pMail)
{
    PMAIL_ITEM *pTemp;
    DWORD dwNewMailVectorSize=0;
    if(pMail==NULL)
    {
        return false;
    }
    if(m_cMailCount>=m_dwSizeOfMailVector)
    {
        if(m_MailVector)
        {
            dwNewMailVectorSize=m_dwSizeOfMailVector*2;
            pTemp=new PMAIL_ITEM[dwNewMailVectorSize];
            if(pTemp)
            {
                memset(pTemp, 0, dwNewMailVectorSize*sizeof(PMAIL_ITEM));
                memcpy(pTemp, m_MailVector, m_dwSizeOfMailVector*sizeof(PMAIL_ITEM));
                delete[] m_MailVector;
                m_MailVector=pTemp;
                m_dwSizeOfMailVector=dwNewMailVectorSize;
                m_MailVector[m_cMailCount]=pMail;
            }
            else
            {
                return false;
            }
        }
        else
        {
            m_MailVector=new PMAIL_ITEM[DEFAULT_MAIL_VECTOR_SIZE];
            if(m_MailVector)
            {
                memset(m_MailVector, 0, DEFAULT_MAIL_VECTOR_SIZE*sizeof(PMAIL_ITEM));
                m_MailVector[m_cMailCount]=pMail;
                m_dwSizeOfMailVector=DEFAULT_MAIL_VECTOR_SIZE;
            }
            else
            {
                return false;
            }
        }
        return true;
    }
    else
    {
        m_MailVector[m_cMailCount]=pMail;
        return true;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\perfcnt\pfappdll\perfapp.cpp ===
/*
 -  PERFAPP.CPP
 -
 *  Purpose:
 *      Implements the GLOBCNTR object used by Apps to initialize, update,
 *      and deinitialize the PerfMon counters.
 *
 *
 *  References:
 *

 */
#include <windows.h>
#include <winperf.h>
#include <winerror.h>

#include <perfutil.h>
#include <perfapp.h>
#include <tchar.h>


static const DWORD g_cMaxInst = 128;

// ---------------------------------------------------------------------------
// Prototypes
// ---------------------------------------------------------------------------
static HRESULT HrLogEvent(HANDLE hEventLog, WORD wType, DWORD msgid);


//-----------------------------------------------------------------------------
//  GLOBCNTR methods
//-----------------------------------------------------------------------------

HRESULT
GLOBCNTR::HrInit(GLOBAL_CNTR cCounters, LPWSTR szGlobalSMName, LPWSTR szSvcName)
{
    HRESULT         hr = S_OK;
    HANDLE          hEventLog = NULL;
    BOOL            fExist;

    if (0 == cCounters || 
        NULL == szGlobalSMName || 
        NULL == szSvcName ||
        128 < cCounters ) //We should not have more than 128 counters
    {
        return E_INVALIDARG;
    }

    if (m_fInit)
    {
        return E_FAIL;
    }

    
    m_cCounters = cCounters;

    hEventLog = RegisterEventSource(NULL, szSvcName);

    // This must be called before any calls to HrOpenSharedMemory()

    hr = HrInitializeSecurityAttribute(&m_sa);

    if (FAILED(hr))
    {
        goto ret;
    }

    // Open shared memory to the process wide Perf Counters.  Our member
    // variable m_ppc will be mapped onto this address space and counters are
    // simply indexes into this address space.

    hr = HrOpenSharedMemory(szGlobalSMName,
                            (sizeof(DWORD) * m_cCounters),
                            &m_sa,
                            &m_hsm,
                            (LPVOID *) &m_rgdwPerfData,
                            &fExist);

    if (FAILED(hr))
    {
        goto ret;
    }

	ZeroMemory(m_rgdwPerfData, (sizeof(DWORD) * m_cCounters));

    // Open for business!
    m_fInit = TRUE;

ret:
    if (hEventLog)
        DeregisterEventSource(hEventLog);


    return hr;
}

/*
 -  Shutdown
 -
 *  Purpose:
 *      Cleanup and shutdown the GLOBCNTR object
 */

void
GLOBCNTR::Shutdown(void)
{
    if (m_fInit)
    {
        m_fInit = FALSE;

        if (m_rgdwPerfData)
        {
			// Set all counters to zero at shutdown time 

			ZeroMemory(m_rgdwPerfData, (sizeof(DWORD) * m_cCounters));

            UnmapViewOfFile(m_rgdwPerfData);
            m_rgdwPerfData = NULL;
        }

        if (m_hsm)
        {
            CloseHandle(m_hsm);
            m_hsm = NULL;
        }
    }
}


//-----------------------------------------------------------------------------
//  INSTCNTR methods
//-----------------------------------------------------------------------------

/*
 -  Destructor
 -
 *  Purpose:
 *      Object cleanup & verify consistency
 */

INSTCNTR::~INSTCNTR()
{
    if(m_sa.lpSecurityDescriptor)
        LocalFree(m_sa.lpSecurityDescriptor);
}

/*
 -  HrInit
 -
 *  Purpose:
 *      Setup shared memory blocks
 *      Prep Admin & Counter blocks for use
 */

HRESULT
INSTCNTR::HrInit(INST_CNTR cCounters,
                 LPWSTR szInstSMName,
                 LPWSTR szInstMutexName,
                 LPWSTR szSvcName)
{
    HRESULT     hr      = S_OK;
    DWORD       cbAdm   = 0;
    DWORD       cbCntr  = 0;
    WCHAR       szAdmName[MAX_PATH];    // Admin SM Name
    WCHAR       szCntrName[MAX_PATH];   // Counter SM Name
    LPVOID      pv;
    HANDLE      hEventLog;
    BOOL        fExist;
    BOOL        fInMutex = FALSE;

    // Validate args
    if (0 == cCounters || !szInstSMName || !szInstMutexName || !szSvcName)
        return E_INVALIDARG;

    // Save Number of Counters
    m_cCounters = cCounters;

    if (m_fInit)
    {
        return E_FAIL;
    }

    // Open Application Event Log
    hEventLog = RegisterEventSource(NULL, szSvcName);

    // This must be called before any calls to HrOpenSharedMemory() and
    // HrCreatePerfMutex() and must only be called once!!!

    hr = HrInitializeSecurityAttribute(&m_sa);

    if (FAILED(hr))
    {
        goto ret;
    }

    // Obtain Mutex.  If call returns okay, we hold the mutex.
    hr = HrCreatePerfMutex(&m_sa, szInstMutexName, &m_hmtx);
    if (FAILED(hr))
    {
        goto ret;
    }

    fInMutex = TRUE;

    // Calc required memory sizes
    cbAdm  = sizeof(INSTCNTR_DATA) + (sizeof(INSTREC) * g_cMaxInst);
    cbCntr = ((sizeof(DWORD) * cCounters) * g_cMaxInst);

    // Build names for the two shared memory blocks
    if(wcslen(szInstSMName) >= (MAX_PATH - 6))  // Enough space to wsprintf.
    {
        hr=E_FAIL;
        goto ret;
    }
    wsprintf(szAdmName, L"%s_ADM", szInstSMName);
    wsprintf(szCntrName,L"%s_CNTR", szInstSMName);

    // Open Admin Shared Memory Block
    hr = HrOpenSharedMemory(szAdmName,
                            cbAdm,
                            &m_sa,
                            &m_hsmAdm,
                            (LPVOID *) &pv,
                            &fExist);
    if (FAILED(hr))
    {
        goto ret;
    }


    // Fixup Pointers
    m_picd = (INSTCNTR_DATA *) pv;
    m_rgInstRec = (INSTREC *) ((char *) pv + sizeof(INSTCNTR_DATA));


	if (!fExist)
	{
		ZeroMemory(pv, cbAdm);
		m_picd->cMaxInstRec = g_cMaxInst;
		m_picd->cInstRecInUse = 0;
	}

    // Open Counters Shared Memory Block
    hr = HrOpenSharedMemory(szCntrName,
                            cbCntr,
                            &m_sa,
                            &m_hsmCntr,
                            (LPVOID *) &m_rgdwCntr,
                            &fExist);

    if (FAILED(hr))
    {
        goto ret;
    }


	if ( !fExist)
	{
		ZeroMemory(m_rgdwCntr, cbCntr);
	}

    // Open for business!
    m_fInit = TRUE;

ret:

    if (hEventLog)
        DeregisterEventSource(hEventLog);


    if (m_hmtx && fInMutex)
        ReleaseMutex(m_hmtx);

    return hr;
}

/*
 -  Shutdown
 -
 *  Purpose:
 *      Cleanup and shutdown the INSTCNTR object
 */

void
INSTCNTR::Shutdown(BOOL fWipeOut)
{
    if (m_fInit)
    {
        m_fInit = FALSE;

        if (m_rgdwCntr)
        {
			// Zero out this shared memory block too.  All counters should
			// start at zero.
			if ( fWipeOut )
			{
				ZeroMemory(m_rgdwCntr, (sizeof(DWORD) * m_cCounters) * g_cMaxInst);
			}
            UnmapViewOfFile(m_rgdwCntr);
            m_rgdwCntr = NULL;
        }

        // NOTE: m_picd points at the head of the
        // Admin shared memory block.  Do not UnmapViewOfFile on
        // the m_rgInstRec pointer!
        if (m_picd)
        {
			// Zero out the shared memory block 
			if ( fWipeOut )
			{
				ZeroMemory(m_picd, sizeof(INSTCNTR_DATA) + (sizeof(INSTREC) * g_cMaxInst));
				m_picd->cMaxInstRec = g_cMaxInst;
				m_picd->cInstRecInUse = 0;
			}
            UnmapViewOfFile(m_picd);
            m_picd = NULL;
            m_rgInstRec = NULL;
        }

        if (m_hsmAdm)
        {
            CloseHandle(m_hsmAdm);
            m_hsmAdm = NULL;
        }

        if (m_hsmCntr)
        {

            CloseHandle(m_hsmCntr);
            m_hsmCntr = NULL;
        }

        if (m_hmtx)
        {
            CloseHandle(m_hmtx);
            m_hmtx = NULL;
        }
    }

}



/*
 -  HrCreateOrGetInstance
 -
 *  Purpose:
 *      Return a token corresponding to an Instance Counter Block
 *  Returns:
 *      S_OK                    ID Found; picid contains a valid INSTCNTR_ID
 *      E_FAIL                  Object not initialized *OR* ID not found
 *      E_INVALIDARG            Bad parameter/NULL pointer
 */

HRESULT
INSTCNTR::HrCreateOrGetInstance(LPCWSTR wszInstName, INSTCNTR_ID *picid)
{
    HRESULT     hr = S_OK;

    if (!m_fInit)
        return E_FAIL;

    // Validate args
    if (!picid || !wszInstName)
        return E_INVALIDARG;

    *picid = INVALID_INST_ID;

    // Obtain exclusive access to SM blocks
    DWORD dwWait = WaitForSingleObject(m_hmtx, INFINITE);
    if (WAIT_OBJECT_0 != dwWait)
    {
        // No simple way to translate the return into an HRESULT
        return E_FAIL;
    }

    // We have the mutex; we must release before leaving

    // Linear probe through list looking for a matching or open slot
    for (unsigned int i = 0; i < m_picd->cMaxInstRec; i++)
    {
        if ( m_rgInstRec[i].fInUse && (0 == wcscmp(m_rgInstRec[i].szInstName, wszInstName)) )
        {
            // Found first instance with matching name.
            *picid = (INSTCNTR_ID) i;
            break;
        }
        else if (!m_rgInstRec[i].fInUse && (INVALID_INST_ID == *picid))
        {
            // Found the first free slot -- remember its number
            *picid = (INSTCNTR_ID) i;
        }
    }

    if (INVALID_INST_ID == *picid)
    {
        // No matching or free slots found
        hr = E_FAIL;
        goto Cleanup;
    }
    else if (!m_rgInstRec[*picid].fInUse)
    {
        // Found no matching slot, but found a free slot -- mark as
        // in use and set instance name
        wcsncpy(m_rgInstRec[*picid].szInstName, wszInstName, min((wcslen(wszInstName) + 1),MAX_PATH));
        m_rgInstRec[*picid].fInUse = TRUE;
        m_picd->cInstRecInUse++;

        // Zero out corresponding counter block
        ZeroMemory(&m_rgdwCntr[(m_cCounters * (*picid))], (sizeof(DWORD) * m_cCounters));
    }

Cleanup:
    ReleaseMutex(m_hmtx);

    return hr;
}

/*
 -  HrDestroyInstance
 -
 *  Purpose:
 *      Release Instance Counter Block associated with the token icid.
 */

HRESULT
INSTCNTR::HrDestroyInstance(INSTCNTR_ID icid)
{
    HRESULT     hr = S_OK;

    if (!m_fInit)
        return E_FAIL;

    // Get exclusive access to SM blocks
    DWORD dwWait = WaitForSingleObject(m_hmtx, INFINITE);
    if (WAIT_OBJECT_0 != dwWait)
    {
        // No simple way to translate the return into an HRESULT
        return E_FAIL;
    }


    if (m_rgInstRec[icid].fInUse)
    {
        // Mark the block as Not In Use
        m_rgInstRec[icid].fInUse = FALSE;

		// Zero out corresponding counter block
        ZeroMemory(&m_rgdwCntr[(m_cCounters * (icid))], (sizeof(DWORD) * m_cCounters));

        //Assert(m_picd->cInstRecInUse != 0);
        m_picd->cInstRecInUse--;
    } else
    {
        hr = E_FAIL;
    }

    ReleaseMutex(m_hmtx);

    return hr;
}


/*
 -  HrLogEvent
 -
 *  Purpose:
 *      Wrap up the call to ReportEvent to make things look nicer.
 */
HRESULT
HrLogEvent(HANDLE hEventLog, WORD wType, DWORD msgid)
{
    if (hEventLog)
        return ReportEvent(hEventLog,
                       wType,
                       (WORD)0,//facPerfMonDll,
                       msgid,
                       NULL,
                       0,
                       0,
                       NULL,
                       NULL);

    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\perfcnt\pfappdll\perfcommon.h ===
/*
 -	perfcommon.h
 -
 *	Purpose:
 *		Declare data structures common to both perfapp.hpp and perfdll.h
 *
 *	Notes:
 *		These structs control the layout of shared memory blocks shared
 *		between an application and its related PerfMon Extenstion DLL.
 *
 */

#pragma once

//
// INSTREC is key portion of INSTCNTR (below)
typedef struct _instrec
{
	BOOL		  fInUse;					// In-Use flag
	TCHAR		  szInstName[MAX_PATH];	// Instance Name
	
} INSTREC;

//
// INSTCNTR is in the Instance Counter Shared Memory Block
typedef struct _instcntr
{
	DWORD		  cMaxInstRec;		// Maximum # of Instances (can grow)
	DWORD		  cInstRecInUse;	// Count of Instances in Use
	
} INSTCNTR_DATA;

//
// INSTCNTR_ID is the index of the INSTREC in INSTCNTR_DATA
typedef DWORD INSTCNTR_ID;

#define INVALID_INST_ID (INSTCNTR_ID) -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\perfcnt\pfmndll\perfdll.cpp ===
/*
 -	perfdll.cpp
 -
 *	Purpose:
 *		Provide mechanism for user configuring of Perfmon Counters
 *		Implement Open, Collect and Close for Perfmon DLL Extension
 *
 */



#include <windows.h>
#include <winperf.h>
#include <winerror.h>

#include <Pop3RegKeys.h>
#include <perfUtil.h>
#include <perfdll.h>
#include <loadperf.h> // for unlodctr
#include <shlwapi.h>  // for SHDeleteKey
#include <string>
#include <cstring>
// ----------------------------------------------------------------------
// Declarations & Typedefs
// ----------------------------------------------------------------------

//
// Performance Counter Data Structures

typedef struct _perfdata
{
	PERF_OBJECT_TYPE			potGlobal;
	PERF_COUNTER_DEFINITION	  *	rgCntrDef;
	PERF_COUNTER_BLOCK			CntrBlk;

} PERFDATA;


typedef struct _instdata
{
	PERF_INSTANCE_DEFINITION	InstDef;
	WCHAR						szInstName[MAX_PATH];
	PERF_COUNTER_BLOCK			CntrBlk;

} INSTDATA;


typedef struct _perfinst
{
	PERF_OBJECT_TYPE			potInst;
	PERF_COUNTER_DEFINITION	  * rgCntrDef;

} PERFINST;


//
// Constants and other stuff required by PerfMon

static WCHAR	szGlobal[]		= L"Global";
static WCHAR	szForeign[]		= L"Foreign";
static WCHAR	szCostly[]		= L"Costly";
static WCHAR	szNull[]		= L"\0";

#define DIGIT			1
#define DELIMITER		2
#define INVALID			3

#define QUERY_GLOBAL	1
#define QUERY_ITEMS		2
#define QUERY_FOREIGN	3
#define QUERY_COSTLY	4

static DWORD GetQueryType(LPWSTR lpValue);
static BOOL  IsNumberInUnicodeList(DWORD dwNumber, LPWSTR pszUnicodeList);

#define EvalThisChar(c,d)   ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

// Perfmon likes things to be aligned on 8 byte boundaries
#define ROUND_TO_8_BYTE(x) (((x)+7) & (~7))


// PerfMon counter layout required for CollectData calls

static PERFDATA		g_perfdata;


static PERFINST		g_perfinst;
static INSTDATA		g_instdata;

// perf data as layed out in shared memory

// Global Counters
static HANDLE			g_hsmGlobalCntr	 = NULL;
static DWORD	  	  * g_rgdwGlobalCntr = NULL;

// Instance Counters
static HANDLE			g_hsmInstAdm 	 = NULL;
static HANDLE			g_hsmInstCntr 	 = NULL;
static INSTCNTR_DATA  * g_pic 			 = NULL;
static INSTREC		  * g_rgInstRec		 = NULL;
static DWORD		  * g_rgdwInstCntr   = NULL;


// Accounting and protection stuff

static DWORD		g_cRef 		= 0;
static HANDLE		g_hmtxInst 	= NULL;
static BOOL			g_fInit 	= FALSE;

// Parameter Info
static PERF_DATA_INFO	g_PDI;
static BOOL			  	g_fInitCalled = FALSE;


//Max instance to be 128
static const DWORD g_cMaxInst = 128;


// Function prototypes from winperf.h

PM_OPEN_PROC		OpenPerformanceData;
PM_COLLECT_PROC		CollectPerformanceData;
PM_CLOSE_PROC		ClosePerformanceData;

// Helper functions

static HRESULT HrLogEvent(HANDLE hEventLog, WORD wType, DWORD msgid);
static HRESULT HrOpenSharedMemoryBlocks(HANDLE hEventLog, SECURITY_ATTRIBUTES * psa);
static HRESULT HrGetCounterIDsFromReg(HANDLE hEventLog, DWORD * pdwFirstCntr, DWORD * pdwFirstHelp);
static HRESULT HrAllocPerfCounterMem(HANDLE hEventLog);
static HRESULT HrFreePerfCounterMem(void);


// ----------------------------------------------------------------------
// Implementation
// ----------------------------------------------------------------------


// Register constants
static wchar_t szServiceRegKeyPrefix[] = L"SYSTEM\\CurrentControlSet\\Services\\" ;
static wchar_t szServiceRegKeySuffix[] = L"\\Performance" ;

static wchar_t szEventLogRegKeyPrefix[] = L"System\\CurrentControlSet\\Services\\EventLog\\Application\\" ;


// ----------------------------------------------------------------------
// RegisterPerfDll -
//   Create the registry keys we need.
// ----------------------------------------------------------------------
HRESULT RegisterPerfDll(LPCWSTR szService,
					 LPCWSTR szOpenFnName,
					 LPCWSTR szCollectFnName,
					 LPCWSTR szCloseFnName)
{
	HRESULT			hr = S_OK;
	wchar_t 		szFileName[_MAX_PATH+1] ;
	DWORD			dwRet;

	// Use WIN32 API's to get the path to the module name
	// DEVNOTE - JMW - Since we need to make sure we have the instance handle of the DLL
	//   and not the executable, we will use VirtualQuery.
	MEMORY_BASIC_INFORMATION mbi;
	VirtualQuery(RegisterPerfDll, &mbi, sizeof(mbi));
	dwRet = GetModuleFileName( reinterpret_cast<HINSTANCE>(mbi.AllocationBase), szFileName, sizeof(szFileName)/sizeof(wchar_t) -1) ;
	if (dwRet == 0)
	{
		goto Failed;
	}
    szFileName[_MAX_PATH]=0;
	wchar_t szDrive[_MAX_DRIVE] ;
	wchar_t szDir[_MAX_DIR ]  ;
	wchar_t szPerfFilename[ _MAX_FNAME ] ;
	wchar_t szExt[_MAX_EXT ] ;
	_wsplitpath( szFileName, szDrive, szDir, szPerfFilename, szExt ) ;

	// Now that I have split it, put it back together with the Pop3Perf.dll in
	//  place of my module name
	_wmakepath( szFileName, szDrive, szDir, L"Pop3Perf", L".dll" ) ;

	hr = RegisterPerfDllEx(szService,
						   szPerfFilename,
						   szFileName,
						   szOpenFnName,
						   szCollectFnName,
						   szCloseFnName );

 Cleanup:
	return hr;

 Failed:
	if (!FAILED(hr))
	{
		hr = GetLastError();
	}
	goto Cleanup;

}

// ----------------------------------------------------------------------
// RegisterPerfDllEx -
//   Create the registry keys we need, checking to see if they're already
//   there.
//
// Parameters:
//   szService		Service Name
//	 szOpenFnName	Name of the "Open" function
//	 szCollectFnName "   "   "  "Collect" "
//	 szCloseFnName   "   "   "  "Close"   "
//
// Returns:
//	 S_OK
//	 E_INVALIDARG
//	 ERROR_ALREADY_EXISTS
//   <downstream error>
// ----------------------------------------------------------------------
HRESULT RegisterPerfDllEx(
	IN	LPCWSTR szService,
	IN	LPCWSTR szPerfSvc,
	IN  LPCWSTR szPerfMsgFile,
	IN	LPCWSTR szOpenFnName,
	IN	LPCWSTR szCollectFnName,
	IN	LPCWSTR szCloseFnName )
{
	HRESULT			hr = S_OK;
	wchar_t 		szFileName[_MAX_PATH+1] ;
	DWORD			cbExistingPath = (_MAX_PATH+1);
	wchar_t 		szExistingPath[_MAX_PATH+1];
    std::wstring	wszRegKey ;
	DWORD			dwRet;

	// Verify all the args and do the correct thing if they are NULL or zero length
	if ( !szService ||
		 !szPerfSvc ||
		 !szOpenFnName ||
		 !szCollectFnName ||
		 !szCloseFnName )
	{
		hr = E_INVALIDARG ;
		goto Cleanup;
	}

	if ( !szService[0] ||
		 !szPerfSvc[0] ||
		 !szOpenFnName[0] ||
		 !szCollectFnName[0] ||
		 !szCloseFnName[0] )
	{
		hr = E_INVALIDARG ;
		goto Cleanup;
	}

	// Use WIN32 API's to get the path to the module name
	// NOTE: We will assume that this DLL is also the EventMessageFile.
	MEMORY_BASIC_INFORMATION mbi;
	VirtualQuery(RegisterPerfDllEx, &mbi, sizeof(mbi));
	dwRet = GetModuleFileName( reinterpret_cast<HINSTANCE>(mbi.AllocationBase), szFileName, sizeof(szFileName)/sizeof(wchar_t)-1) ;
	if (dwRet == 0)
	{
		// Wow, don't know what happened,
		goto Failed;
	}
    szFileName[_MAX_PATH]=0;
	// If the user passed in NULL for the Event Log Message File for this Perfmon DLL,
	// use this DLL as the Event Log Message File.
	if (!szPerfMsgFile)
	{
		szPerfMsgFile = szFileName;
	}

	// Register the perfmon counter DLL under the
	// provided service.
	wszRegKey = szServiceRegKeyPrefix ;
	wszRegKey += szService ;
	wszRegKey += szServiceRegKeySuffix ;

	// Check to see if the library has already been registered.
	if (ERROR_SUCCESS==RegQueryString(
				       wszRegKey.c_str(),
				       L"Library",
				       szExistingPath,
				       &cbExistingPath ))
	{
		if (_wcsicmp(szExistingPath, szFileName))
		{
			// EventLog
            //  "RegisterPerfDllEx: Error: Attempt to replace Perfmon Library %s with %s. Failing. \n",
			//		   szExistingPath,
			//		   szFileName);

			hr = E_FAIL;
			goto Cleanup;
		}
        //Otherwise, the dll is already registered!
	}
	
	// Continue registering 
	if (ERROR_SUCCESS!=RegSetString(
			  wszRegKey.c_str(),
			  L"Library",
			  (LPWSTR)szFileName ))
	{
		goto Failed;
	}

	if (ERROR_SUCCESS!=RegSetString(
			  wszRegKey.c_str(),
			  L"Open",
			  (LPWSTR)szOpenFnName) )
	{
		goto Failed;
	}

	if (ERROR_SUCCESS!=RegSetString(
			  wszRegKey.c_str(),
			  L"Collect",
			  (LPWSTR)szCollectFnName) )
	{
		goto Failed;
	}

	if (ERROR_SUCCESS!=RegSetString(
			  wszRegKey.c_str(),
			  L"Close",
			  (LPWSTR)szCloseFnName) )
	{
		goto Failed;
	}

	// Set up the Event Message File
	wszRegKey = szEventLogRegKeyPrefix ;
	wszRegKey += szPerfSvc ;

	// See if the EventMessageFile value is already set for this service
	if (ERROR_SUCCESS==RegQueryString(
				   wszRegKey.c_str(),
				   L"EventMessageFile",
				   szExistingPath,
				   &cbExistingPath ))
	{
		if (_wcsicmp(szExistingPath, szPerfMsgFile))
		{

			hr = E_FAIL;
			goto Cleanup;
		}
	}
					 

	// Set the EventMessageFile value
	if ( ERROR_SUCCESS!=RegSetString( 
                        wszRegKey.c_str(),
					    L"EventMessageFile",
					    (LPWSTR)szPerfMsgFile ) )
	{
		goto Failed;
	}

	if (ERROR_SUCCESS!=RegSetDWORD(
					  wszRegKey.c_str(),
					  L"TypesSupported",
					  0x07) )	// Error + Waring + Informational == 0x07
	{
		goto Failed;
	}

	// Assume that the CategoryMessageFile is the same as
	// the EventMessageFile.
	if (ERROR_SUCCESS!=RegSetString(
					 wszRegKey.c_str(),
					 L"CategoryMessageFile",
					 (LPWSTR)szPerfMsgFile ) )
	{
		goto Failed;
	}

	// NOTE: since we don't know what the count of categories is for the
	// NOTE: CategoryMessageFile, do not set the CategoryCount value.

	
 Cleanup:
	if (FAILED(hr))
	{
		//EventLog ?? (L"RegisterPerfDllEx: Failed : (0x%08X)\n", hr);
	}

	return hr;

 Failed:
	if (!FAILED(hr))
	{
		hr = GetLastError();
	}
	goto Cleanup;
}


/*
 -	HrInitPerf
 -
 *	Purpose:
 *		Init data structure used to parameterize perfmon dll.  Must be called
 *		in DllMain for reason DLL_PROCESS_ATTACH.
 */

HRESULT
HrInitPerf(PERF_DATA_INFO * pPDI)
{
	HRESULT		hr = S_OK;

	if (!pPDI)
		return E_INVALIDARG;

	if (g_fInitCalled)
	{
		return S_OK;
	}

	CopyMemory(&g_PDI, pPDI, sizeof(PERF_DATA_INFO));

	// Find the Service Name for using Event Logging on this Perfmon DLL
	if (!(pPDI->wszPerfSvcName[0]))
	{
		wchar_t 		szFileName[_MAX_PATH+1] ;
		DWORD			dwRet;

		// Use WIN32 API's to get the path to the module name
		// DEVNOTE - JMW - Since we need to make sure we have the instance handle of the DLL
		//   and not the executable, we will use VirtualQuery.
		MEMORY_BASIC_INFORMATION mbi;
		VirtualQuery(HrInitPerf, &mbi, sizeof(mbi));
		dwRet = GetModuleFileName( reinterpret_cast<HINSTANCE>(mbi.AllocationBase), szFileName, sizeof(szFileName)/sizeof(wchar_t)) ;
		if (dwRet == 0)
		{
			// Wow, don't know what happened
			goto err;
		}

		wchar_t szDrive[_MAX_DRIVE] ;
		wchar_t szDir[_MAX_DIR ]  ;
		wchar_t szPerfFilename[ _MAX_FNAME ] ;
		wchar_t szExt[_MAX_EXT ] ;
		_wsplitpath( szFileName, szDrive, szDir, szPerfFilename, szExt ) ;

		wcscpy(g_PDI.wszPerfSvcName, szPerfFilename);
		
	}
	
	// Safety: Need to alloc our own CounterTypes arrays
	g_PDI.rgdwGlobalCounterTypes = NULL;
	g_PDI.rgdwInstCounterTypes   = NULL;

	DWORD 	cb;
	// Alloc & Copy Global Counter Types
	if (g_PDI.cGlobalCounters)
	{
		cb = sizeof(DWORD) * g_PDI.cGlobalCounters;

		g_PDI.rgdwGlobalCounterTypes = (DWORD *) malloc(cb);
            
        if(NULL == g_PDI.rgdwGlobalCounterTypes)
        {
            hr=E_OUTOFMEMORY;
            goto err;
        }

		CopyMemory(g_PDI.rgdwGlobalCounterTypes,
				   pPDI->rgdwGlobalCounterTypes,
				   cb);
		g_PDI.rgdwGlobalCntrScale = (DWORD *) malloc(cb);
            
        if(NULL == g_PDI.rgdwGlobalCntrScale)
        {
            hr=E_OUTOFMEMORY;
            goto err;
        }
		CopyMemory(g_PDI.rgdwGlobalCntrScale,
				   pPDI->rgdwGlobalCntrScale,
				   cb);
	}

	// Alloc & Copy Inst Counter Types
	if (g_PDI.cInstCounters)
	{
		cb = sizeof(DWORD) * g_PDI.cInstCounters;

		g_PDI.rgdwInstCounterTypes = (DWORD *) malloc(cb);
        if(NULL == g_PDI.rgdwInstCounterTypes)
        {
            hr=E_OUTOFMEMORY;
            goto err;
        }

		CopyMemory(g_PDI.rgdwInstCounterTypes,
				   pPDI->rgdwInstCounterTypes,
				   cb);
	}

	// Done!
	g_fInitCalled = TRUE;

	return S_OK;

err:
	if (g_PDI.rgdwGlobalCounterTypes)
    {
		free(g_PDI.rgdwGlobalCounterTypes);
        g_PDI.rgdwGlobalCounterTypes=NULL;
    }
	if (g_PDI.rgdwGlobalCntrScale)
    {
		free(g_PDI.rgdwGlobalCntrScale);
        g_PDI.rgdwGlobalCntrScale=NULL;
    }

	if (g_PDI.rgdwInstCounterTypes)
    {
		free(g_PDI.rgdwInstCounterTypes);
        g_PDI.rgdwInstCounterTypes=NULL;
    }

	return hr;
}


/*
 -	HrShutdownPerf
 -
 *	Purpose:
 *		Release memory blocks allocated in HrInitPerf
 *
 */

HRESULT HrShutdownPerf(void)
{
	HRESULT		hr = S_OK;

	if (g_cRef)
	{
		//EventLog ??(L"Warning: PERFDLL is being shut down with non-zero refcount!");
		hr = E_UNEXPECTED;
	}

	if (g_fInitCalled)
	{
		// We must invalidate the DLL if we release the memory in the g_PDI
		g_fInitCalled = FALSE;

		if (g_PDI.rgdwGlobalCounterTypes)
        {
			free(g_PDI.rgdwGlobalCounterTypes);
            g_PDI.rgdwGlobalCounterTypes=NULL;
        }
		if (g_PDI.rgdwGlobalCntrScale)
        {
			free(g_PDI.rgdwGlobalCntrScale);
            g_PDI.rgdwGlobalCntrScale=NULL;
        }

		if (g_PDI.rgdwInstCounterTypes)
        {
            free(g_PDI.rgdwInstCounterTypes);
            g_PDI.rgdwInstCounterTypes=NULL;

        }
	}

	return hr;
}

/*
 -	OpenPerformanceData
 -
 *	Purpose:
 *		Called by PerfMon to init the counters and this DLL.
 *
 *	Parameters:
 *		pszDeviceNames		Ignored.
 *
 *	Errors:
 *		dwStat				Indicates various errors that can occur during init
 */

DWORD
APIENTRY
OpenPerformanceData(LPWSTR pszDeviceNames)
{
	DWORD		dwStat = ERROR_SUCCESS;
	HANDLE		hEventLog = NULL;
	BOOL		fInMutex = FALSE;
	DWORD	  * rgdw;
	SECURITY_ATTRIBUTES	sa;
    sa.lpSecurityDescriptor=NULL;

	if (!g_fInitCalled)
		return E_FAIL;

	// REVIEW: Assumes Open will be single-threaded.  Verify?
	if (g_cRef == 0)
	{
		DWORD   idx;
		DWORD   dwFirstCntr;
		DWORD   dwFirstHelp;
		HRESULT hr = NOERROR;

		// PERF_DATA_INFO wszSvcName is mandatory.
		hEventLog = RegisterEventSource(NULL, g_PDI.wszPerfSvcName);

		hr = HrInitializeSecurityAttribute(&sa);

		if (FAILED(hr))
		{
			//HrLogEvent(hEventLog, EVENTLOG_ERROR_TYPE, msgidCntrInitSA);
			dwStat = (DWORD)hr;
			goto err;
		}

		if (g_PDI.cInstCounters)
		{
			// Create Controling Mutex
			hr = HrCreatePerfMutex(&sa,
								   g_PDI.wszInstMutexName,
								   &g_hmtxInst);

			if (FAILED(hr))
			{
				//HrLogEvent(hEventLog, EVENTLOG_ERROR_TYPE, msgidCntrInitSA);
				dwStat = (DWORD)hr;
				goto err;
			}

			fInMutex = TRUE;
		}

		// Open shared memory blocks

		dwStat = (DWORD) HrOpenSharedMemoryBlocks(hEventLog, &sa);
		if (FAILED(dwStat))
			goto err;

		// Allocate PERF_COUNTER_DEFINITION arrays for both g_perfdata

		dwStat = (DWORD) HrAllocPerfCounterMem(hEventLog);
		if (FAILED(dwStat))
			goto err;

		// Get First Counter and First Help string offsets from Registry

		dwStat = (DWORD) HrGetCounterIDsFromReg(hEventLog,
												&dwFirstCntr,
												&dwFirstHelp);
		if (FAILED(dwStat))
			goto err;

		//
		// Fill in PerfMon structures to make Collect() faster

		// Global Counters
		if (g_PDI.cGlobalCounters)
		{
			PERF_COUNTER_DEFINITION     * ppcd;
			DWORD						  cb;

			PERF_OBJECT_TYPE * ppot		= &g_perfdata.potGlobal;

			cb = sizeof(PERF_OBJECT_TYPE) +
				(sizeof(PERF_COUNTER_DEFINITION) * g_PDI.cGlobalCounters) +
				 sizeof(PERF_COUNTER_BLOCK) +
				(sizeof(DWORD) * g_PDI.cGlobalCounters);

			ppot->TotalByteLength		= ROUND_TO_8_BYTE(cb);
			ppot->DefinitionLength		= sizeof(PERF_OBJECT_TYPE) +
				                          (g_PDI.cGlobalCounters * sizeof(PERF_COUNTER_DEFINITION));

			ppot->HeaderLength			= sizeof(PERF_OBJECT_TYPE);
			ppot->ObjectNameTitleIndex	= dwFirstCntr;
			ppot->ObjectNameTitle		= NULL;
			ppot->ObjectHelpTitleIndex	= dwFirstHelp;
			ppot->ObjectHelpTitle		= NULL;
			ppot->DetailLevel			= PERF_DETAIL_NOVICE;
			ppot->NumCounters			= g_PDI.cGlobalCounters;
			ppot->DefaultCounter		= -1;
			ppot->NumInstances			= PERF_NO_INSTANCES;
			ppot->CodePage				= 0;

			dwFirstCntr += 2;
			dwFirstHelp += 2;

			rgdw = g_PDI.rgdwGlobalCounterTypes;

			for (ppcd = g_perfdata.rgCntrDef, idx = 0;
				 idx < g_PDI.cGlobalCounters; ppcd++, idx++)
			{
				ppcd->ByteLength			= sizeof(PERF_COUNTER_DEFINITION);
				ppcd->CounterNameTitleIndex	= dwFirstCntr;
				ppcd->CounterNameTitle		= NULL;
				ppcd->CounterHelpTitleIndex	= dwFirstHelp;
				ppcd->CounterHelpTitle		= NULL;
				ppcd->DefaultScale			= g_PDI.rgdwGlobalCntrScale[idx];
				ppcd->DetailLevel			= PERF_DETAIL_NOVICE;
				ppcd->CounterType			= g_PDI.rgdwGlobalCounterTypes[idx];
				ppcd->CounterSize			= sizeof(DWORD);
				ppcd->CounterOffset			= sizeof(PERF_COUNTER_BLOCK) +
					                          (idx * sizeof(DWORD));
				dwFirstCntr += 2;
				dwFirstHelp += 2;
			}

			// Last step: set the size of the counter block and data for this object

			g_perfdata.CntrBlk.ByteLength		= sizeof(PERF_COUNTER_BLOCK) +
				                                  (g_PDI.cGlobalCounters * sizeof(DWORD));

		} // Global Counters

		// Instance Counters
		if (g_PDI.cInstCounters)
		{
			PERF_COUNTER_DEFINITION     * ppcd;
			PERF_OBJECT_TYPE * ppot		= &g_perfinst.potInst;

			// TotalByteLength will be overridden on each call to CollectPerfData().

			ppot->DefinitionLength		= sizeof(PERF_OBJECT_TYPE) +
				                          (g_PDI.cInstCounters * sizeof(PERF_COUNTER_DEFINITION));
			ppot->HeaderLength			= sizeof(PERF_OBJECT_TYPE);
			ppot->ObjectNameTitleIndex	= dwFirstCntr;
			ppot->ObjectNameTitle		= NULL;
			ppot->ObjectHelpTitleIndex	= dwFirstHelp;
			ppot->ObjectHelpTitle		= NULL;
			ppot->DetailLevel			= PERF_DETAIL_NOVICE;
			ppot->NumCounters			= g_PDI.cInstCounters;
			ppot->DefaultCounter		= -1;
			ppot->NumInstances			= 0;
			ppot->CodePage				= 0;

			dwFirstCntr += 2;
			dwFirstHelp += 2;

			for (ppcd = g_perfinst.rgCntrDef, idx = 0;
				 idx < g_PDI.cInstCounters; ppcd++, idx++)
			{
				ppcd->ByteLength			= sizeof(PERF_COUNTER_DEFINITION);
				ppcd->CounterNameTitleIndex	= dwFirstCntr;
				ppcd->CounterNameTitle		= NULL;
				ppcd->CounterHelpTitleIndex	= dwFirstHelp;
				ppcd->CounterHelpTitle		= NULL;
				ppcd->DefaultScale			= 0;
				ppcd->DetailLevel			= PERF_DETAIL_NOVICE;
				ppcd->CounterType			= g_PDI.rgdwInstCounterTypes[idx];
				ppcd->CounterSize			= sizeof(DWORD);
				ppcd->CounterOffset			= sizeof(PERF_COUNTER_BLOCK) +
                 	                          (idx	* sizeof(DWORD));
				dwFirstCntr += 2;
				dwFirstHelp += 2;
			}

			// Initialize generic INSTDATA for future use
			g_instdata.InstDef.ByteLength				= sizeof(PERF_INSTANCE_DEFINITION) +
				                                          (MAX_PATH * sizeof(WCHAR)) ;
			g_instdata.InstDef.ParentObjectTitleIndex	= 0; // No parent object
			g_instdata.InstDef.ParentObjectInstance		= 0;
			g_instdata.InstDef.UniqueID					= PERF_NO_UNIQUE_ID;
			g_instdata.InstDef.NameOffset				= sizeof(PERF_INSTANCE_DEFINITION);
			g_instdata.InstDef.NameLength				= 0; // To be overriden in Collect
			g_instdata.CntrBlk.ByteLength				= (sizeof(PERF_COUNTER_BLOCK) +
													      (g_PDI.cInstCounters * sizeof(DWORD)));

		} // Instance Counters

		// Done! Ready for business....
		g_fInit = TRUE;
	}

	// If we got here, we're okay!
	dwStat = ERROR_SUCCESS;
	g_cRef++;

ret:
	if (fInMutex)
		ReleaseMutex(g_hmtxInst);

	if (hEventLog)
		DeregisterEventSource(hEventLog);

    if (sa.lpSecurityDescriptor)
        LocalFree(sa.lpSecurityDescriptor);

	return dwStat;

err:

	if (g_hsmGlobalCntr)
	{
		UnmapViewOfFile(g_rgdwGlobalCntr);
		CloseHandle(g_hsmGlobalCntr);
	}

	if (g_hsmInstAdm)
	{
		UnmapViewOfFile(g_pic);
		CloseHandle(g_hsmInstAdm);
	}

	if (g_hsmInstCntr)
	{
		UnmapViewOfFile(g_rgdwInstCntr);
		CloseHandle(g_hsmInstCntr);
	}

	if (g_hmtxInst)
		CloseHandle(g_hmtxInst);

	// TODO: release all that memory we Alloc'd
	HrFreePerfCounterMem();

	goto ret;
}



/*
 -	CollectPerformanceData
 -
 *	Purpose:
 *		Called by PerfMon to collect performance counter data
 *
 *	Parameters:
 *		pszValueName
 *		ppvData
 *		pcbTotal
 *		pcObjTypes
 *
 *	Errors:
 *		ERROR_SUCCESS
 *		ERROR_MORE_DATA
 */

DWORD
APIENTRY
CollectPerformanceData(
	LPWSTR  pszValueName,
	LPVOID *ppvData,
	LPDWORD pcbTotal,
	LPDWORD pcObjTypes)
{
	BOOL		fCollectGlobalData;
	BOOL		fCollectInstData;
	DWORD		dwQueryType;
	ULONG		cbBuff = *pcbTotal;
	char	  * pcT;

	// In case we have to bail out
	*pcbTotal = 0;
	*pcObjTypes = 0;

	if (!g_fInit)
		return ERROR_SUCCESS;

	// Determine Query Type; we only support QUERY_ITEMS

	dwQueryType = GetQueryType(pszValueName);

	if (dwQueryType == QUERY_FOREIGN)
		return ERROR_SUCCESS;

	// Assume PerfMon is collecting both until we prove otherwise

	fCollectGlobalData = TRUE;
	fCollectInstData = TRUE;

	if (dwQueryType == QUERY_ITEMS)
	{
		if (!IsNumberInUnicodeList(g_perfdata.potGlobal.ObjectNameTitleIndex, pszValueName))
			fCollectGlobalData = FALSE;
		if (!IsNumberInUnicodeList(g_perfinst.potInst.ObjectNameTitleIndex, pszValueName))
			fCollectInstData = FALSE;

		if (!fCollectGlobalData  && !fCollectInstData)
			return ERROR_SUCCESS;
	}

	// Get a temporary pointer to the returned data buffer.  If all goes well
	// then we update ppvData before leaving, else we leave it unchanged and
	// set *pcbTotal and pcObjTypes to zero and return ERROR_MORE_DATA.

	pcT = (char *) *ppvData;

	// Copy the data from the shared memory block for the system-wide
	// counters into the buffer provided and update our OUT params.

	if (g_rgdwGlobalCntr && fCollectGlobalData && g_PDI.cGlobalCounters)
	{
		DWORD		cb;
		DWORD		cbTotal;

		// Estimate total size, and see if we can fit.

		if (g_perfdata.potGlobal.TotalByteLength > cbBuff)
			return ERROR_MORE_DATA;

		// Copy data in chunks.
		cbTotal = 0;

		// PERF_OBJECT_TYPE
		cb = sizeof(PERF_OBJECT_TYPE);
		cbTotal += cb;
		CopyMemory((LPVOID) pcT, &g_perfdata.potGlobal, cb);
		pcT += cb;

		// PERF_COUNTER_DEFINITION []
		cb = g_PDI.cGlobalCounters * sizeof(PERF_COUNTER_DEFINITION);
		cbTotal += cb;
		CopyMemory((LPVOID) pcT, g_perfdata.rgCntrDef, cb);
		pcT += cb;

		// PERF_COUNTER_BLOCK
		cb = sizeof(PERF_COUNTER_BLOCK);
		cbTotal += cb;
		CopyMemory((LPVOID) pcT, &g_perfdata.CntrBlk , cb);
		pcT += cb;

		// (counters) DWORD []
		cb = g_PDI.cGlobalCounters * sizeof(DWORD);
		cbTotal += cb;
		CopyMemory((LPVOID) pcT, g_rgdwGlobalCntr, cb);
		pcT += cb;

		// If we've done our math right, This assert should be valid.
		//assert((DWORD)(pcT - (char *)*ppvData) == cbTotal);

		if (g_perfdata.potGlobal.TotalByteLength > cbTotal)
		{
			cb = g_perfdata.potGlobal.TotalByteLength - cbTotal;
			pcT += cb;
		}

		*pcbTotal += g_perfdata.potGlobal.TotalByteLength;
		(*pcObjTypes)++;
	}

	// Copy the data from the shared memory block for the per-instance
	// counters into the buffer provided and update our OUT params.  We
	// must enter the mutex here to prevent connection instances from
	// being added to or removed from the list while we are copying data.

	if (g_pic && fCollectInstData && g_PDI.cInstCounters)
	{
		DWORD	cb;
		DWORD	cbTotal;
		DWORD	ism;
		DWORD	ipd;
		DWORD	cInst;
		PERF_OBJECT_TYPE * pPOT;
		INSTDATA		 * pInstData;

		if (WaitForSingleObject(g_hmtxInst, INFINITE) != WAIT_OBJECT_0)
		{
			*pcbTotal = 0;
			*pcObjTypes = 0;

			// BUGBUG: wrong return code for the problem.  We timed out waiting for
			// BUGBUG: the mutex; However, we may not return anything other than
			// BUGBUG: ERROR_SUCCESS or ERROR_MORE_DATA without disabling the DLL.
			return ERROR_SUCCESS;
		}

		// Find out how many instances exist.
		// NOTE: Zero instances is valid.  We must still copy the "core" perf data.
		cInst = g_pic->cInstRecInUse;

		// Estimate total size, and see if we can fit.

		cbTotal = sizeof(PERF_OBJECT_TYPE) +
			      (g_PDI.cInstCounters * sizeof(PERF_COUNTER_DEFINITION)) +
			      (cInst * sizeof(INSTDATA)) +
			      (cInst * (g_PDI.cInstCounters * sizeof(DWORD)));
		// Must return data aligned on 8-byte boundaries.
		cbTotal = ROUND_TO_8_BYTE(cbTotal);

		if (cbTotal > (cbBuff - *pcbTotal))
		{
			ReleaseMutex(g_hmtxInst);

			*pcbTotal = 0;
			*pcObjTypes = 0;

			return ERROR_MORE_DATA;
		}

		// Keep a pointer to beginig so we can update the "total bytes" value at the end.
		pPOT = (PERF_OBJECT_TYPE *) pcT;

		// PERF_OBJECT_TYPE
		CopyMemory(pPOT,
				   &(g_perfinst.potInst),
				   sizeof(PERF_OBJECT_TYPE));

		pcT += sizeof(PERF_OBJECT_TYPE);

		// PERF_COUNTER_DEFINITION []
		cb = g_PDI.cInstCounters * sizeof(PERF_COUNTER_DEFINITION);
		CopyMemory(pcT, g_perfinst.rgCntrDef, cb);
		pcT += cb;

		// Find instances and copy their counter data blocks
		for (ism = 0, ipd = 0; (ism < g_pic->cMaxInstRec) && (ipd < cInst); ism++)
		{
			if (g_rgInstRec[ism].fInUse)
			{
				pInstData = (INSTDATA *) pcT;

				// PERF_INSTANCE_DATA
				cb = sizeof(INSTDATA);
				CopyMemory(pcT,
						   &g_instdata,
						   cb);
				pcT += cb;

				// (inst name) WCHAR [] (inside INSTDATA block)
				cb = (wcslen(g_rgInstRec[ism].szInstName) + 1) * sizeof(WCHAR);

				//Assert( cb > 0 );
				//Assert( cb < (MAX_PATH * sizeof(WCHAR)) );

				CopyMemory(pInstData->szInstName,
						   g_rgInstRec[ism].szInstName,
						   cb);

				// Update PERF_INSTANCE_DEFINITION with correct name length.
				pInstData->InstDef.NameLength = cb;

				// (counters) DWORD []
				cb = g_PDI.cInstCounters * sizeof(DWORD);
				CopyMemory(pcT,
						   &g_rgdwInstCntr[(ism * g_PDI.cInstCounters)],
						   cb);
				pcT += cb;

				ipd++;
			}
		}

		// NOTE: we are deliberately ignoring the condition of
		// (ipd < cInst), even though that may indicate corruption
		// of the Shared Memory Block.  Further note that this code
		// will never trap the condition of (ipd > cInst).

		// Done looking at Shared Memory Block.
		ReleaseMutex(g_hmtxInst);

		// Align data on 8-byte boundary
		cb = (DWORD)((char *) pcT - (char *) pPOT);
		cbTotal = ROUND_TO_8_BYTE(cb);
		if (cbTotal > cb)
			pcT += (cbTotal - cb);

		// Update PERF_OBJECT_TYPE with correct numbers
		pPOT->TotalByteLength = cbTotal;
		pPOT->NumInstances    = ipd; // Use the count of instances we actually *found*

		*pcbTotal += cbTotal;
		(*pcObjTypes)++;
	}

	// We only get here if nothing failed.  It is now safe
	// to update *ppvData and return a success indication.

	*ppvData = (LPVOID) pcT;

	return ERROR_SUCCESS;
}


/*
 -	ClosePerformanceData
 -
 *	Purpose:
 *		Called by PerfMon to uninit the counter DLL.
 *
 *	Parameters:
 *		void
 *
 *	Errors:
 *		ERROR_SUCCESS		Always!
 */

DWORD
APIENTRY
ClosePerformanceData(void)
{

	if (g_cRef > 0)
	{
		if (--g_cRef == 0)
		{
			// We're going to free stuff; make sure later calls
			// don't de-ref bad pointers.
			g_fInit = FALSE;

			// Close down Global Counters
			if (g_rgdwGlobalCntr)
				UnmapViewOfFile(g_rgdwGlobalCntr);

			if (g_hsmGlobalCntr)
				CloseHandle(g_hsmGlobalCntr);

			// Close down Instance Counters
			// NOTE: g_pic is the starting offset of the SM block.
			// NOTE: DO NOT Unmap on g_rgInstRec!
			if (g_pic)
				UnmapViewOfFile(g_pic);

			if (g_hsmInstAdm)
				CloseHandle(g_hsmInstAdm);

			if (g_rgdwInstCntr)
				UnmapViewOfFile(g_rgdwInstCntr);

			if (g_hsmInstCntr)
				CloseHandle(g_hsmInstCntr);

			if (g_hmtxInst)
				CloseHandle(g_hmtxInst);

			// Free all that memory we've alloc'd
			HrFreePerfCounterMem();


			g_rgdwGlobalCntr	= NULL;
			g_hsmGlobalCntr	 	= NULL;
			g_pic         		= NULL;
			g_rgInstRec			= NULL;
			g_rgdwInstCntr		= NULL;
			g_hsmInstAdm 		= NULL;
			g_hsmInstCntr		= NULL;
			g_hmtxInst    		= NULL;

		}
	}
	return ERROR_SUCCESS;
}

/*
 -	GetQueryType
 -
 *	Purpose:
 *		Returns the type of query described in the lpValue string so that
 *		the appropriate processing method may be used.
 *
 *	Parameters:
 *		lpValue				String passed to PerfRegQuery Value for processing
 *
 *	Returns:
 *		QUERY_GLOBAL | QUERY_FOREIGN | QUERY_COSTLY | QUERY_ITEMS
 *
 */

static
DWORD
GetQueryType(LPWSTR lpValue)
{
	WCHAR *	pwcArgChar, *pwcTypeChar;
	BOOL	bFound;

	if (lpValue == 0)
		return QUERY_GLOBAL;

	if (*lpValue == 0)
		return QUERY_GLOBAL;

	// check for "Global" request

	pwcArgChar = lpValue;
	pwcTypeChar = szGlobal;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0))
	{
		if (*pwcArgChar++ != *pwcTypeChar++)
		{
			bFound = FALSE; // no match
			break;          // bail out now
		}
	}

	if (bFound)
		return QUERY_GLOBAL;

	// check for "Foreign" request

	pwcArgChar = lpValue;
	pwcTypeChar = szForeign;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0))
	{
		if (*pwcArgChar++ != *pwcTypeChar++)
		{
			bFound = FALSE; // no match
			break;          // bail out now
		}
	}

	if (bFound)
		return QUERY_FOREIGN;

	// check for "Costly" request

	pwcArgChar = lpValue;
	pwcTypeChar = szCostly;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0))
	{
		if (*pwcArgChar++ != *pwcTypeChar++)
		{
			bFound = FALSE; // no match
			break;          // bail out now
		}
	}

	if (bFound)
		return QUERY_COSTLY;

	// if not Global and not Foreign and not Costly,
	// then it must be an item list

	return QUERY_ITEMS;
}


/*
 -	IsNumberInUnicodeList
 -
 *	Purpose:
 *		Determines if dwNumber is in the pszUnicodeList.
 *
 *	Parameters:
 *		dwNumber			Number to find in list
 *		pszUnicodeList		Space delimited list of decimal numbers
 *
 *	Errors:
 *		TRUE/FALSE			If found/not found respectively
 *
 */

static
BOOL
IsNumberInUnicodeList(DWORD dwNumber, LPWSTR pszUnicodeList)
{
	DWORD   dwThisNumber = 0;
	BOOL    bValidNumber = FALSE;
	BOOL    bNewItem     = TRUE;
	WCHAR   wcDelimiter  = (WCHAR)' ';
	WCHAR   *pwcThisChar;

	if (pszUnicodeList == NULL)
		return FALSE;

	pwcThisChar = pszUnicodeList;

	while (TRUE)	/*lint !e774*/
	{
		switch (EvalThisChar(*pwcThisChar, wcDelimiter))
		{
		case DIGIT:
			// if this is the first digit after a delimiter, then
			// set flags to start computing the new number

			if (bNewItem)
			{
				bNewItem = FALSE;
				bValidNumber = TRUE;
			}

			if (bValidNumber)
			{
				dwThisNumber *= 10;
				dwThisNumber += (*pwcThisChar - (WCHAR)'0');
			}
			break;

		case DELIMITER:
			// a delimter is either the delimiter character or the
			// end of the string ('\0') if when the delimiter has been
			// reached a valid number was found, then compare it to the
			// number from the argument list. if this is the end of the
			// string and no match was found, then return.

			if (bValidNumber)
			{
				if (dwThisNumber == dwNumber)
					return TRUE;

				bValidNumber = FALSE;
			}

			if (*pwcThisChar == 0)
			{
				return FALSE;
			}
			else
			{
				bNewItem = TRUE;
				dwThisNumber = 0;
			}
			break;

		case INVALID:
			// if an invalid character was encountered, ignore all
			// characters up to the next delimiter and then start fresh.
			// the invalid number is not compared.

			bValidNumber = FALSE;
			break;

		default:
			break;
		}
		pwcThisChar++;
	}
}

/*
 -	HrLogEvent
 -
 *	Purpose:
 *		Wrap up the call to ReportEvent to make things look nicer.
 */
HRESULT
HrLogEvent(HANDLE hEventLog, WORD wType, DWORD msgid)
{
	if (g_fInitCalled)
	{
		DWORD	cb = sizeof(WCHAR) * wcslen(g_PDI.wszSvcName);
		if (hEventLog)
			return ReportEvent(hEventLog,
							   wType,				// Event Type
							   (WORD)0,	            // Category
							   msgid,				// Event ID
							   NULL,				// User SID
							   0,					// # strings to merge
							   cb,					// size of binary data (bytes)
							   NULL,				// array of strings to merge
							   g_PDI.wszSvcName);	// binary data
		else
		   return E_FAIL;
	}
	else
		return E_FAIL;
}


/*
 -	HrOpenSharedMemoryBlocks
 -
 *	Purpose:
 *		Encapsulate the grossness of opening the shared memory blocks.
 */

HRESULT
HrOpenSharedMemoryBlocks(HANDLE hEventLog, SECURITY_ATTRIBUTES * psa)
{
	HRESULT	hr=S_OK;
	BOOL    fExist;

	if (!g_fInitCalled)
		return E_FAIL;

	if (!psa)
		return E_INVALIDARG;

	// Shared Memory for Global Counters
	if (g_PDI.cGlobalCounters)
	{

		hr = HrOpenSharedMemory(g_PDI.wszGlobalSMName,
								(sizeof(DWORD) * g_PDI.cGlobalCounters),
								psa,
								&g_hsmGlobalCntr,
								(LPVOID *) &g_rgdwGlobalCntr,
								&fExist);

		if (FAILED(hr))
		{
			//HrLogEvent(hEventLog, EVENTLOG_ERROR_TYPE, msgidCntrInitSharedMemory1);
			goto ret;
		}

		if (!fExist)
			ZeroMemory(g_rgdwGlobalCntr, (g_PDI.cGlobalCounters * sizeof(DWORD)));
	}

	// Shared Memory for Instance Counters
	if (g_PDI.cInstCounters)
	{
		DWORD		cbAdm;
		DWORD		cbCntr;
		WCHAR		szAdmName[MAX_PATH];		// Admin SM Name
		WCHAR		szCntrName[MAX_PATH];	// Counter SM Name

		// Calc required memory sizes
		// BUGBUG: Since we're puntin on dynamic instances, we use g_cMaxInst
		cbAdm  = sizeof(INSTCNTR_DATA) + (sizeof(INSTREC) * g_cMaxInst);
		cbCntr = ((sizeof(DWORD) * g_PDI.cInstCounters) * g_cMaxInst);

		// Build SM names for Admin and Counters
		wsprintf(szAdmName, L"%s_ADM", g_PDI.wszInstSMName);
		wsprintf(szCntrName,L"%s_CNTR", g_PDI.wszInstSMName);

		// Open Instance Admin Memory
		hr = HrOpenSharedMemory(szAdmName,
								cbAdm,
								psa,
								&g_hsmInstAdm,
								(LPVOID *)&g_pic,
								&fExist);

		if (FAILED(hr))
		{
			//HrLogEvent(hEventLog, EVENTLOG_ERROR_TYPE, msgidCntrInitSharedMemory2);
			goto ret;
		}

		// Fixup Pointers
		g_rgInstRec = (INSTREC *) ((LPBYTE) g_pic + sizeof(INSTCNTR_DATA));

		if (!fExist)
		{
			ZeroMemory(g_pic, cbAdm);
			g_pic->cMaxInstRec = g_cMaxInst;
			g_pic->cInstRecInUse = 0;
		}

		// Because we don't support dynamic instances, We should *always*
		// have a MaxInstRec of g_cMaxInst
		//Assert(g_cMaxInst == g_pic->cMaxInstRec);

		// Open Instance Counter Memory
		hr = HrOpenSharedMemory(szCntrName,
								cbCntr,
								psa,
								&g_hsmInstCntr,
								(LPVOID *)&g_rgdwInstCntr,
								&fExist);

		if (FAILED(hr))
		{
			//HrLogEvent(hEventLog, EVENTLOG_ERROR_TYPE, msgidCntrInitSharedMemory2);
			goto ret;
		}

		if (!fExist)
			ZeroMemory(g_rgdwInstCntr, cbCntr);
	}

ret:

	return hr;

}


/*
 -	HrGetCounterIDsFromReg
 -
 *	Purpose:
 *		Get the "First Name" and "First Help" inicies from the Registry in the
 *		special place for the configured service.
 */

HRESULT
HrGetCounterIDsFromReg(HANDLE hEventLog, DWORD * pdwFirstCntr, DWORD * pdwFirstHelp)
{
	HRESULT		hr;
	HKEY		hKey = NULL;
	WCHAR		wszServicePerfKey[MAX_PATH];
	DWORD		dwSize;
	DWORD		dwType;

	if (!g_fInitCalled)
		return E_FAIL;

	if (!pdwFirstCntr || !pdwFirstHelp)
		return E_INVALIDARG;

	// Get the First Counter and First Help from the registry
	wsprintf(wszServicePerfKey, L"SYSTEM\\CurrentControlSet\\Services\\%s\\Performance", g_PDI.wszSvcName);

	hr = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
					  wszServicePerfKey,
					  0L,
					  KEY_READ,
					  &hKey);

	if (hr != ERROR_SUCCESS)
	{
		//HrLogEvent(hEventLog, EVENTLOG_ERROR_TYPE, msgidCntrOpenRegistry);
		goto ret;
	}

	dwSize = sizeof(DWORD);

	hr = RegQueryValueExW(hKey,
						 L"First Counter",
						 0L,
						 &dwType,
						 (LPBYTE)pdwFirstCntr,
						 &dwSize);

	if (hr != ERROR_SUCCESS)
	{
		//HrLogEvent(hEventLog, EVENTLOG_ERROR_TYPE, msgidCntrQueryRegistry1);
		goto ret;
	}

	dwSize = sizeof(DWORD);

	hr = RegQueryValueExW(hKey,
						 L"First Help",
						 0L,
						 &dwType,
						 (LPBYTE)pdwFirstHelp,
						 &dwSize);

	if (hr != ERROR_SUCCESS)
	{
		//HrLogEvent(hEventLog, EVENTLOG_ERROR_TYPE, msgidCntrQueryRegistry2);
		goto ret;
	}

ret:

	if (hKey)
		RegCloseKey(hKey);

	return hr;

}


/*
 -	HrAllocPerfCounterMem
 -
 *	Purpose:
 *		Allocates memory for PERF_COUNTER_DEFINITION arrays for both
 *		g_perfdata and g_perfinst.
 *
 *	Notes:
 *		Uses ProcessHeap handle obtained in HrInit.
 */

HRESULT
HrAllocPerfCounterMem(HANDLE hEventLog)
{
	HRESULT	hr;
	DWORD	cb;

	if (!g_fInitCalled)
		return E_FAIL;

	// Global Counters
	if (g_PDI.cGlobalCounters)
	{
		// Alloc Global PERF_COUNTER_DEFINITION array

		cb = (sizeof(PERF_COUNTER_DEFINITION) * g_PDI.cGlobalCounters);

		g_perfdata.rgCntrDef = (PERF_COUNTER_DEFINITION *) malloc(cb);
        
        if(NULL == g_perfdata.rgCntrDef)
        {
        	hr = E_OUTOFMEMORY;
		    goto err;
        }

	}

	// Instance Counters
	if (g_PDI.cInstCounters)
	{
		// Alloc Inst PERF_COUNTER_DEFINITION array

		cb = (sizeof(PERF_COUNTER_DEFINITION) * g_PDI.cInstCounters);

		g_perfinst.rgCntrDef = (PERF_COUNTER_DEFINITION *) malloc(cb);
        if(NULL == g_perfinst.rgCntrDef )
        {
        	hr = E_OUTOFMEMORY;
		    goto err;
        }
	}


	return S_OK;

err:

	//HrLogEvent(hEventLog, EVENTLOG_ERROR_TYPE, msgidCntrAlloc);

	HrFreePerfCounterMem();

	return hr;
}


/*
 -	HrFreePerfCounterMem
 -
 *	Purpose:
 *		Companion to HrAllocPerfCounterMem
 *
 *	Note:
 *		Uses ProcessHeap handle obtained in HrInit.
 */

HRESULT
HrFreePerfCounterMem(void)
{
	if (!g_fInitCalled)
		return E_FAIL;

	// We must invalidate the DLL if we release the memory in the g_PDI
	g_fInitCalled = FALSE;

	if (g_perfdata.rgCntrDef)
	{
		free(g_perfdata.rgCntrDef);
		g_perfdata.rgCntrDef = NULL;
	}

	if (g_perfinst.rgCntrDef)
	{
		free(g_perfinst.rgCntrDef);
		g_perfinst.rgCntrDef = NULL;
	}

	return S_OK;
}


HRESULT
HrUninstallPerfDll( 
   IN LPCWSTR szService )
{
   // Make sure we've valid input
   if( !szService ) return E_INVALIDARG;

      
   // First, do unlodctr since removing the Performance key without removing
   // counter names and descriptions may toast the perfmon system
   std::wstring wszService = L"x ";  // KB Article Q188769
   wszService += szService;
   DWORD dwErr = UnloadPerfCounterTextStringsW(const_cast<LPWSTR>(wszService.c_str()), TRUE);
   if( dwErr != ERROR_SUCCESS ) 
   {
      // Continue without error if unlodctr has already been called
      if( (dwErr != ERROR_FILE_NOT_FOUND) && (dwErr != ERROR_BADKEY) )
      {
         return HRESULT_FROM_WIN32(dwErr);
      }
   }

   // Now that unlodctr has succeeded, we can start deleting registry keys
   // Start with the Performance key of the service
   std::wstring wszRegKey;
   wszRegKey = szServiceRegKeyPrefix;
   wszRegKey += szService;
   dwErr = SHDeleteKey(HKEY_LOCAL_MACHINE, wszRegKey.c_str());
   if( (dwErr != ERROR_SUCCESS) && (dwErr != ERROR_FILE_NOT_FOUND) ) 
   {
      return HRESULT_FROM_WIN32(dwErr);
   }


	// Use WIN32 API's to get the path to the module name
   wchar_t 	szFileName[_MAX_PATH+1] ;
   MEMORY_BASIC_INFORMATION mbi;
   VirtualQuery(HrUninstallPerfDll, &mbi, sizeof(mbi));
   DWORD dwRet = GetModuleFileName( reinterpret_cast<HINSTANCE>(mbi.AllocationBase), szFileName, sizeof(szFileName)/sizeof(wchar_t)-1) ;
   if (dwRet == 0)
   {
      // Wow, don't know what happened,
      return HRESULT_FROM_WIN32(::GetLastError());
   }

   szFileName[_MAX_PATH]=0;
   // Split the module path to get the filename
   wchar_t szDrive[_MAX_DRIVE] ;
   wchar_t szDir[_MAX_DIR ]  ;
   wchar_t szPerfFilename[ _MAX_FNAME ] ;
   wchar_t szExt[_MAX_EXT ] ;
   _wsplitpath( szFileName, szDrive, szDir, szPerfFilename, szExt ) ;


   // Delete the Event Log key for the service
   wszRegKey = szEventLogRegKeyPrefix;
   wszRegKey += szPerfFilename;
   dwErr = SHDeleteKey(HKEY_LOCAL_MACHINE, wszRegKey.c_str());
   if( ERROR_FILE_NOT_FOUND == dwErr ) dwErr = ERROR_SUCCESS;
   
   
   return HRESULT_FROM_WIN32(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\perfcnt\pfappdll\perfapp.h ===
/*
 -  perfapp.hpp
 -
 *  Purpose:
 *      Declare Perfmon Classes
 *
 *  Notes:
 *      User must define two zero-based enums representing the PerfMon counters:
 *          GLOBAL_CNTR Global Perfmon Counters
 *          INST_CNTR       Instance Perfmon Counters
 *      They must be defined before including this header.
 *
 *  Copyright:
 *
 *
 */
#if !defined(_PERFAPP_HPP_)
#define _PERFAPP_HPP_

#pragma once

#include <perfcommon.h>


// Forward Reference for Lib
enum GLOBAL_CNTR;
enum INST_CNTR;

/*
 -  class GLOBCNTR
 -
 *  Purpose:
 *      Object that encapsulates the global perfmon counter for DMI.
 *
 */

class GLOBCNTR 
{
private:
    //

    // Data Members
    HANDLE            m_hsm;            // Shared Memory
    DWORD             m_cCounters;      // # of counters
    DWORD           * m_rgdwPerfData;   // Counters
    BOOL              m_fInit;          // Init test flag

    // For Shared Memory
    SECURITY_ATTRIBUTES m_sa;

public:
    //  Constructor
    //
    //  Declared private to ensure that arbitrary instances
    //  of this class cannot be created.  The Singleton
    //  template (declared as a friend above) controls
    //  the sole instance of this class.
    //
    GLOBCNTR() :
        m_hsm(NULL),
        m_cCounters(0),
        m_rgdwPerfData(NULL),
        m_fInit(FALSE) 
        {
            m_sa.lpSecurityDescriptor=NULL;
        };
    ~GLOBCNTR()
    {
        if(m_sa.lpSecurityDescriptor)
            LocalFree(m_sa.lpSecurityDescriptor);
    };

    // Parameters:
    //      cCounters       Total number of global counters. ("special" last element in GLOB_CNTR)
    //      wszGlobalSMName Name of the shared memory block (shared with DLL)
    //      wszSvcName      Service Name (for event logging)
    HRESULT     HrInit(GLOBAL_CNTR cCounters,
                       LPWSTR szGlobalSMName,
                       LPWSTR szSvcName);
    void        Shutdown(void);

    void        IncPerfCntr(GLOBAL_CNTR cntr);
    void        DecPerfCntr(GLOBAL_CNTR cntr);
    void        SetPerfCntr(GLOBAL_CNTR cntr, DWORD dw);
    void        AddPerfCntr(GLOBAL_CNTR cntr, DWORD dw);
    void        SubPerfCntr(GLOBAL_CNTR cntr, DWORD dw);
    LONG        LGetPerfCntr(GLOBAL_CNTR cntr);

private:
    // Not Implemented to prevent compiler from auto-generating
    //
    GLOBCNTR(const GLOBCNTR& x);
    GLOBCNTR& operator=(const GLOBCNTR& x);
};

/*
 -  class INSTCNTR
 -
 *  Purpose:
 *      Class used to manipulate the per instance PerfMon counters for DMI.
 *
 *  Notes:
 *      This manages two shared memory blocks: The first manages the per instance
 *  info, and whether or not that instance record is in use.  The second is an array
 *  of counter blocks; each counter block is an array of however many Instance Counters
 *  the user says there are (passed in to HrInit()).  These blocks correspond to
 *  m_hsmAdm and m_hsmCntr, respectively.
 *
 */


class INSTCNTR 
{

    //  Constructor
    //
    //  Declared private to ensure that arbitrary instances
    //  of this class cannot be created.  The Singleton
    //  template (declared as a friend above) controls
    //  the sole instance of this class.
    INSTCNTR() :
        m_hsmAdm(NULL),
        m_hsmCntr(NULL),
        m_hmtx(NULL),
        m_rgInstRec(NULL),
        m_rgdwCntr(NULL),
        m_cCounters(0),
        m_fInit(FALSE) 
        {
            m_sa.lpSecurityDescriptor=NULL;
        };
    ~INSTCNTR();

    //  Private Data Members
    HANDLE          m_hsmAdm;   // Admin Shared Memory
    HANDLE          m_hsmCntr; // Counters Shared Memory
    HANDLE          m_hmtx;     // Mutex controlling Shared Memory
    INSTCNTR_DATA * m_picd;     // Perf Counter Data
    INSTREC       * m_rgInstRec; // Array of Instance Records
    DWORD         * m_rgdwCntr; // Array of Instance Counter Blocks
    DWORD           m_cCounters; // # Counters
    BOOL            m_fInit;    // Init test flag

    // For Shared Memory
    SECURITY_ATTRIBUTES m_sa;


public:
    // NOTE: Use the Singleton mechanisms for Creating, Destroying and
    //       obtaining an instance of this object


    // Parameters:
    //      cCounters       Total number of global counters. ("special" last element in INST_CNTR)
    //      wszInstSMName   Name of the shared memory block (shared with DLL)
    //      wszInstMutexName Name of the Mutex controlling the instance memory blocks
    //      wszSvcName      Service Name (for event logging)
    HRESULT     HrInit(INST_CNTR cCounters,
                       LPWSTR szInstSMName,
                       LPWSTR szInstMutexName,
                       LPWSTR szSvcName);
    void        Shutdown(BOOL fWipeOut=TRUE);

    HRESULT     HrCreateOrGetInstance(IN LPCWSTR wszInstName,
                                      OUT INSTCNTR_ID *picid);
    HRESULT     HrDestroyInstance(INSTCNTR_ID icid);

    void        IncPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr);
    void        DecPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr);
    void        SetPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr, DWORD dw);
    void        AddPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr, DWORD dw);
    void        SubPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr, DWORD dw);
    LONG        LGetPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr);


private:
    // Not Implemented to prevent compiler from auto-generating
    //
    INSTCNTR(const INSTCNTR& x);
    INSTCNTR& operator=(const INSTCNTR& x);
};

//#endif // INSTANCE_DATA_DEFINED

//-----------------------------------------------------------------------------
//  GLOBCNTR inline functions
//-----------------------------------------------------------------------------

inline
void
GLOBCNTR::IncPerfCntr(GLOBAL_CNTR cntr)
{
    if (m_fInit)
        InterlockedIncrement((LONG *)&m_rgdwPerfData[cntr]);
}


inline
void
GLOBCNTR::DecPerfCntr(GLOBAL_CNTR cntr)
{
    if (m_fInit)
        InterlockedDecrement((LONG *)&m_rgdwPerfData[cntr]);
}


inline
void
GLOBCNTR::SetPerfCntr(GLOBAL_CNTR cntr, DWORD dw)
{
    if (m_fInit)
        InterlockedExchange((LONG *)&m_rgdwPerfData[cntr], (LONG)dw);
}


inline
void
GLOBCNTR::AddPerfCntr(GLOBAL_CNTR cntr, DWORD dw)
{
    if (m_fInit)
        InterlockedExchangeAdd((LONG *)&m_rgdwPerfData[cntr], (LONG)dw);
}


inline
void
GLOBCNTR::SubPerfCntr(GLOBAL_CNTR cntr, DWORD dw)
{
    if (m_fInit)
        InterlockedExchangeAdd((LONG *)&m_rgdwPerfData[cntr], -((LONG)dw));
}

inline
LONG
GLOBCNTR::LGetPerfCntr(GLOBAL_CNTR cntr)
{
    return m_fInit ? m_rgdwPerfData[cntr] : 0;
}

// #ifdef INSTANCE_DATA_DEFINED

//-----------------------------------------------------------------------------
//  INSTCNTR inline functions
//-----------------------------------------------------------------------------

inline
void
INSTCNTR::IncPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr)
{
    if (m_fInit)
    {
        if ((icid != INVALID_INST_ID) && m_rgInstRec[icid].fInUse)
            InterlockedIncrement((LONG *)&m_rgdwCntr[((icid * m_cCounters)+ cntr)]);
    }
}


inline
void
INSTCNTR::DecPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr)
{
    if (m_fInit)
    {
        if ((icid != INVALID_INST_ID) && m_rgInstRec[icid].fInUse)
            InterlockedDecrement((LONG *)&m_rgdwCntr[((icid * m_cCounters) + cntr)]);
    }
}


inline
void
INSTCNTR::SetPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr, DWORD dw)
{
    if (m_fInit)
    {
        if ((icid != INVALID_INST_ID) && m_rgInstRec[icid].fInUse)
            InterlockedExchange((LONG *)&m_rgdwCntr[((icid * m_cCounters) + cntr)], (LONG)dw);
    }
}


inline
void
INSTCNTR::AddPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr, DWORD dw)
{
    if (m_fInit)
    {
        if ((icid != INVALID_INST_ID) && m_rgInstRec[icid].fInUse)
            InterlockedExchangeAdd((LONG *)&m_rgdwCntr[((icid * m_cCounters) + cntr)], (LONG)dw);
    }
}


inline
void
INSTCNTR::SubPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr, DWORD dw)
{
    if (m_fInit)
    {
        if ((icid != INVALID_INST_ID) && m_rgInstRec[icid].fInUse)
            InterlockedExchangeAdd((LONG *)&m_rgdwCntr[((icid * m_cCounters) + cntr)], -((LONG)dw));
    }
}

inline
LONG
INSTCNTR::LGetPerfCntr(INSTCNTR_ID icid, INST_CNTR cntr)
{
    return m_fInit ? m_rgdwCntr[((icid * m_cCounters) + cntr)] : 0;
}

// #endif // INSTANCE_DATA_DEFINED

#endif //!defined(_PERFAPP_HPP_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\mailbox\mailbox.h ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      MailBox.h
Abstract:       Defines the CMailBox class, as abstraction of mailbox storage 
Notes:          
History:        08/01/2001 Created by Hao Yu (haoyu)

************************************************************************************************/

#ifndef __POP3_MAILBOX_H__
#define __POP3_MAILBOX_H__

#include <POP3Server.h>
#include <IOContext.h>
#include <vector>

#define INIT_MAIL_COUNT 256

#define MAIL_STATUS_NONE 0
#define MAIL_STATUS_DEL  1

#define NO_PENDING_OP 0
#define DEL_PENDING   1
#define MAX_MAIL_PER_DOWNLOAD 1024
#define LOCAL_FILE_BUFFER_SIZE 4096
#define ERROR_NO_FILE_ATTR          0xffffffff
#define ERR_NO_SUCH_MSG             0xf0000001
#define ERR_MSG_ALREADY_DELETED     0xf0000002
#define ERR_CAN_NOT_OPEN_FILE       0xf0000003
#define ERR_CAN_NOT_SET_FILE_CURSOR 0xf0000004
#define RESP_END_OF_MULTILINE       "\r\n.\r\n"
#define DEFAULT_MAIL_VECTOR_SIZE    512

#define LOCK_FILENAME_A             "Lock"
#define LOCK_FILENAME_W             L"Lock"
#define QUOTA_FILENAME_A            "Quota"
#define QUOTA_FILENAME_W            L"Quota"
#define MAILBOX_PREFIX_A            "P3_"
#define MAILBOX_PREFIX_W            L"P3_"
#define MAILBOX_EXTENSION_A         ".mbx"
#define MAILBOX_EXTENSION_W         L".mbx"
#define MAILBOX_EXTENSION2_A        ".tmp"
#define MAILBOX_EXTENSION2_W        L".tmp"
#ifdef UNICODE
#define LOCK_FILENAME               LOCK_FILENAME_W
#define QUOTA_FILENAME              QUOTA_FILENAME_W
#define MAILBOX_PREFIX              MAILBOX_PREFIX_W
#define MAILBOX_EXTENSION           MAILBOX_EXTENSION_W
#define MAILBOX_EXTENSION2          MAILBOX_EXTENSION2_W
#else
#define LOCK_FILENAME               LOCK_FILENAME_A
#define QUOTA_FILENAME              QUOTA_FILENAME_A
#define MAILBOX_PREFIX              MAILBOX_PREFIX_A
#define MAILBOX_EXTENSION           MAILBOX_EXTENSION_A
#define MAILBOX_EXTENSION2          MAILBOX_EXTENSION2_A
#endif // !UNICODE

template<class _Ty>
class RockallAllocator:public std::allocator<_Ty>
{
public:
    pointer allocate(size_type _N, const void *)
    {  
        return (pointer) _Charalloc(_N * sizeof(_Ty));
    }
    char * _Charalloc(size_type _N)
    {
        return (new char[_N]);
    }
    void deallocate(void * _P, size_type)
    {
        delete[] _P;
    }
};
struct MAIL_ITEM
{
    DWORD dwStatus;
    HANDLE hFile;
    DWORD dwFileSize;
    BSTR bstrFileName;
};

typedef MAIL_ITEM *PMAIL_ITEM;



class CMailBox
{
    DWORD m_dwSizeOfMailVector;
    PMAIL_ITEM *m_MailVector;
    DWORD m_cMailCount;      // Mail acturally stored in the box
    DWORD m_dwShowMailCount; // Mail that not marked as to be deleted
    DWORD m_dwTotalSize;
    HANDLE m_hMailBoxLock;
    WCHAR  m_wszMailBoxPath[POP3_MAX_PATH];
    BOOL  m_bMailBoxOpened;
    static long m_lMailRootGuard;
    static WCHAR m_wszMailRoot[POP3_MAX_MAILROOT_LENGTH];
public:
    CMailBox();
    ~CMailBox();

// Mailbox 
    DWORD GetTotalSize()
    {
        return m_dwTotalSize;
    }
    DWORD GetCurrentMailCount()
    {
        return m_dwShowMailCount;
    }
    DWORD GetMailCount()
    {
        return m_cMailCount;
    }
     
    void CloseMailBox();
    bool CreateMailBox(WCHAR *wszEmailAddr); 
    LPWSTR GetMailboxFromStoreNameW( LPWSTR psStoreName );
    bool GetEncyptedPassword( LPBYTE pbBuffer, const DWORD dwBufferSize, LPDWORD pdwBytesRead );
    bool SetEncyptedPassword( LPBYTE pbBuffer, const DWORD dwBytesToWrite, LPDWORD pdwBytesWritten );
    //Check the number of mails in the mailbox
    BOOL EnumerateMailBox(DWORD dwMaxMsg=0);
    BOOL LockMailBox();
    bool isMailboxInUse();
    // Check existance of mailbox
    BOOL OpenMailBox(WCHAR *wszEmailAddr); 
    BOOL RepairMailBox();
    void UnlockMailBox();

// Mail
    //Close a newly create mail file and rename it
    //so the pop3 service and find it
    DWORD CloseMail(HANDLE hMailFile, DWORD dwFlagsAndAttributes = 0);
    //Create a new emplty mail file and return the name
    HANDLE CreateMail(LPWSTR wszTargetFileName, DWORD dwFlagsAndAttributes = 0 );
    DWORD DeleteMail(int iIndex);
    bool DeleteMail(LPWSTR wszTargetFileName);    // Used to delete a file that was created by CreateMail but then was not successfully delivered
    bool GetMailFileName( int iIndex, LPWSTR psFilename, DWORD dwSize );
    DWORD ListMail(int iIndex, char *szBuf, DWORD dwSize);
    DWORD TransmitMail(IO_CONTEXT *pIoContext, int iIndex, int iLines=-1);
    DWORD TransmitMail(SOCKET hSocket, int iIndex);
    DWORD UidlMail(int iIndex, char *szBuf, DWORD dwSize);
    bool BuildFilePath( LPWSTR psFilePathBuffer, LPWSTR psFileName, DWORD dwSizeOfFilePathBuffer );    
 
// Other
    BOOL CommitAndClose();
    DWORD GetHashedPassword(char *strPswdBuf, DWORD *pcbBufSize);
    DWORD SetHashedPassword(char *strPswd, DWORD *pcbPswdSize);
    void QuitAndClose();
    void Reset();

    //Set the MailRoot dir, if szMailRoot is NULL,
    //the function searches the registry,
    //if the registry is empty, it returns FALSE
    static LPCWSTR GetMailRoot(){ if ( 0x0 == m_wszMailRoot[0] ) { SetMailRoot(); } return m_wszMailRoot; }
    static BOOL SetMailRoot(const WCHAR *wszMailRoot=NULL);

protected:
    bool SetMailBoxPath(WCHAR *wszEmailAddr);
    bool ReadTopLines(int iLines, HANDLE hFile, DWORD *pdwBytesToRead);
    bool PushMailToVector(PMAIL_ITEM pMail);

};


#endif //__POP3_MAILBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\perfcnt\pfmndll\perfdll.h ===
/*
 -	perfdll.h
 -
 *	Purpose:
 *		Declare Perfmon Init function.
 *		To be included in the Perfmon Extension DLL portion
 *		of an App's Perfmon Counter code.
 *
 *
 */

#pragma once

#include <perfcommon.h>


//
// PERF_DATA_INFO Tells the PerfMon DLL lib how to read & manage
// the shared memory blocks which contain PerfMon Counter Data
//
typedef struct _PERF_DATA_INFO {
	WCHAR		  wszSvcName		[MAX_PATH];	// Service Name of App
	WCHAR		  wszPerfSvcName	[MAX_PATH];	// Service Name of Perfmon DLL 
	WCHAR		  wszGlobalSMName	[MAX_PATH];	// Shared Memory Block Name for Global Counters
	DWORD		  cGlobalCounters;				// Count of Global Counters
	DWORD		* rgdwGlobalCounterTypes;		// Array of counter types for Global Counters
	WCHAR	  	  wszInstSMName		[MAX_PATH];	// Shared Memory Name for Instance Counters
	WCHAR		  wszInstMutexName	[MAX_PATH];	// Mutex Name for Instance Counters
	DWORD		  cInstCounters;				// Count of Instance Counters
	DWORD		* rgdwInstCounterTypes;			// Array of counter types for Instance Counters
	DWORD		* rgdwGlobalCntrScale;          // Array of counter scales for global Counters

} PERF_DATA_INFO;


//
// HrInitPerf should be called only once during the DllMain
// function for your PerfMon DLL for (DLL_PROCESS_ATTACH)

HRESULT HrInitPerf(PERF_DATA_INFO *pPDI);

//
// HrShutdownPerf should be called only once during the
// DllMain function for your PerfMon DLL (DLL_PROCESS_DETACH)

HRESULT HrShutdownPerf();

// Function prototypes from winperf.h

PM_OPEN_PROC		OpenPerformanceData;
PM_COLLECT_PROC		CollectPerformanceData;
PM_CLOSE_PROC		ClosePerformanceData;

HRESULT RegisterPerfDll(LPCWSTR szService,
					 LPCWSTR szOpenFnName,
					 LPCWSTR szCollectFnName,
					 LPCWSTR szCloseFnName) ;

// ----------------------------------------------------------------------
// RegisterPerfDllEx -
//   Create the registry keys we need, checking to see if they're already
//   there.
//
// Parameters:
//   szService			Service Name
//   szPerfSvc			Service Name of Performance DLL (for Event Logging)
//	 szPerfMsgFile		Event Log Message File for the Perfmon DLL
//	 szOpenFnName		Name of the "Open" function
//	 szCollectFnName	 "   "   "  "Collect" "
//	 szCloseFnName 		 "   "   "  "Close"   "
//
// Returns:
//	 S_OK						
//	 E_INVALIDARG				
//	 PERF_W_ALREADY_EXISTS		Register Succeeded
//	 PERF_E_ALREADY_EXISTS		Register Failed
//   <downstream error>
// ----------------------------------------------------------------------
HRESULT RegisterPerfDllEx(
	IN	LPCWSTR szService,
	IN	LPCWSTR szPerfSvc,
	IN	LPCWSTR	szPerfMsgFile,
	IN	LPCWSTR szOpenFnName,
	IN	LPCWSTR szCollectFnName,
	IN	LPCWSTR szCloseFnName ) ;



// ----------------------------------------------------------------------
// RegisterPerfDllEx -
//   Calls unlodctr to remove perf counter names and descriptions then
//   deletes the registry keys created by RegisterPerfDllEx.
//
// Parameters:
//   szService			Service Name
//
// Returns:
//	 S_OK						
//	 E_INVALIDARG				
//  <downstream error>
// ----------------------------------------------------------------------
HRESULT
HrUninstallPerfDll( 
   IN LPCWSTR szService ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\perfcnt\pfutil\perfutil.h ===
/*
 *	perfutil.hpp
 *
 *
 *	Author: haoyu
 */

#ifndef __POP3_PERFUTIL_H__
#define __POP3_PERFUTIL_H__
#include <windows.h>
// PerfMon support functions implemented in perfutil.cpp
#ifdef __cplusplus
extern "C"
{
#endif

HRESULT
HrOpenSharedMemory(LPWSTR	szName, 
				   DWORD	dwSize, 
				   SECURITY_ATTRIBUTES * psa,
				   HANDLE *	ph, 
				   LPVOID *	ppv, 
				   BOOL   *	pfExist);


HRESULT
HrInitializeSecurityAttribute(SECURITY_ATTRIBUTES * psa);

HRESULT
HrCreatePerfMutex(SECURITY_ATTRIBUTES * psa,
				  LPWSTR 				wszMutexName,
				  HANDLE 			  * phmtx);

#ifdef __cplusplus
}
#endif

#endif //__POP3_PERFUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\perfcnt\pfutil\perfutil.c ===
/*
 -	PERFUTIL.C
 -
 *	Purpose:
 *		Contain utility functions used by both the CNTR objects and the
 *		DMI PerfMon DLL.  Mainly the shared memory routines used to 
 *		convey the perf data across the process boundry.
 *
 *
 */



#include "perfutil.h"
#include <winerror.h>
#include <sddl.h>
#include <Aclapi.h>

#ifdef __cplusplus
extern "C"
{
#endif

/*
 -	HrOpenSharedMemory
 -
 *	Purpose:
 *		Opens the shared memory data block that is used by the PerfMon 
 *		counter.  To be called by either the App or PerfDll to initialize
 *		the data block.
 *
 *	Parameters:
 *		szName				Name of the shared file mapping
 *		dwSize				Size of shared memory block requested
 *		psz					Pointer to SECURITY_ATTRIBUTES for Shared Memory
 *		ph					Pointer to the returned shared memory handle
 *		ppv					Pointer to the returned shared memory pointer
 *		pfExist				Pointer to a BOOL indicating this named shared
 *							block has already been opened.
 *
 *	Errors:
 *		hr					Indicating success or failure
 *
 */

#define Align4K(cb)		((cb + (4 << 10) - 1) & ~((4 << 10) - 1))

HRESULT 
HrOpenSharedMemory(LPWSTR		szName, 
				   DWORD		dwSize,
				   SECURITY_ATTRIBUTES * psa,
				   HANDLE	  *	ph, 
				   LPVOID	  *	ppv, 
				   BOOL		  *	pfExist)
{
	HRESULT hr = NOERROR;

	// Validate params
	if (!szName || !ph || !ppv || !pfExist || !psa)
		return E_INVALIDARG;

	// Do we really need to create a mapping?
	if (0 == dwSize)
		return E_INVALIDARG;

	*ppv = NULL;

	*ph = CreateFileMapping(INVALID_HANDLE_VALUE, 
							psa, 
							PAGE_READWRITE, 
							0, 
							Align4K(dwSize),
							szName);

	if (*ph)
	{
		*pfExist = !!(GetLastError() == ERROR_ALREADY_EXISTS);

		*ppv = MapViewOfFile(*ph, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	}

	if (*ppv == NULL)
		hr = E_OUTOFMEMORY;

	return hr;
}


/*
 -	HrInitializeSecurityAttribute
 -
 *	Purpose:
 *		Initalize the SECURITY_ATTRIBUTES data structure for later use.
 *
 *	Parameters:
 *		psa			pointer to caller allocated SECURITY_ATTRIBUTES struct
 *		psd			pointer to caller allocated SECURITY_DESCRIPTOR struct
 *
 *	Errors:
 *		hr					Indicates success or failure
 */

HRESULT
HrInitializeSecurityAttribute(SECURITY_ATTRIBUTES * psa)
{
	HRESULT hr = S_OK;
    WCHAR wszSDL[MAX_PATH]=L"D:(A;OICI;GA;;;BA)(A;OICIIO;GA;;;CO)(A;OICI;GA;;;NS)(A;OICI;GA;;;SY)";
    SECURITY_DESCRIPTOR *pSD=NULL;
    ULONG lSize=0;
	if (!psa )
	{
		hr = E_INVALIDARG;
		goto ret;
	}

    if(!ConvertStringSecurityDescriptorToSecurityDescriptorW(
          wszSDL,
          SDDL_REVISION_1,
          &pSD,
          &lSize))
    {

        return HRESULT_FROM_WIN32(GetLastError());
    }
	psa->nLength = sizeof(SECURITY_ATTRIBUTES);
	psa->lpSecurityDescriptor = pSD;
	psa->bInheritHandle = TRUE;

ret:
	return hr;
}


/*
 -	HrCreatePerfMutex
 -
 *	Purpose:
 *		Initializes the mutex object used to protect access to the per-instance
 *		PerfMon data.  This is used by methods of the INSTCNTR class and the
 *		_perfapp.lib.  Upon successful return from the function, the caller owns
 *		the mutex and must release it as appropriate.
 *
 *	Parameters:
 *		phmtx				Pointer to a handle to the returned mutex
 *
 *	Errors:
 *		hr					Indicating success or failure
 */

HRESULT
HrCreatePerfMutex(SECURITY_ATTRIBUTES * psa,
				  LPWSTR szMutexName,
				  HANDLE * phmtx)
{
	HRESULT hr = S_OK;

	if (!psa || !szMutexName || !phmtx)
	{
		return E_INVALIDARG;
	}

	*phmtx = CreateMutex(psa, TRUE, szMutexName);

	if (*phmtx == NULL)
	{
		hr = E_FAIL;
	}

	return hr;
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\authmd5hash.h ===
#ifndef __POP3_AUTH_MD5_HASH_H__
#define __POP3_AUTH_MD5_HASH_H__

#include "resource.h"
#define UnicodeToAnsi(A, cA, U, cU) WideCharToMultiByte(CP_ACP,0,(U),(cU),(A),(cA),NULL,NULL)
#define AnsiToUnicode(A, cA, U, cU) MultiByteToWideChar(CP_ACP,0,(A),(cA),(U),(cU))

#define HASH_BUFFER_SIZE 1024
#define MD5_HASH_SIZE 32


class ATL_NO_VTABLE CAuthMD5Hash : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAuthMD5Hash, &CLSID_AuthMD5Hash>,
	public IDispatchImpl<IAuthMethod, &IID_IAuthMethod, &LIBID_Pop3Auth>
{

public:
    CAuthMD5Hash();
    virtual ~CAuthMD5Hash();

DECLARE_REGISTRY_RESOURCEID(IDR_AUTHMD5HASH)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAuthMD5Hash)
	COM_INTERFACE_ENTRY(IAuthMethod)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


public:
    STDMETHOD(Authenticate)(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword);
    STDMETHOD(get_Name)(/*[out]*/BSTR *pVal);
    STDMETHOD(get_ID)(/*[out]*/BSTR *pVal);
    STDMETHOD(Get)(/*[in]*/BSTR bstrName, /*[out]*/VARIANT *pVal);
    STDMETHOD(Put)(/*[in]*/BSTR bstrName, /*[in]*/VARIANT vVal);
    STDMETHOD(CreateUser)(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword);
    STDMETHOD(DeleteUser)(/*[in]*/BSTR bstrUserName);
    STDMETHOD(ChangePassword)(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vNewPassword,/*[in]*/VARIANT vOldPassword);
    STDMETHOD(AssociateEmailWithUser)(/*[in]*/BSTR bstrEmailAddr);
    STDMETHOD(UnassociateEmailWithUser)(/*[in]*/BSTR bstrEmailAddr);

private:
    CRITICAL_SECTION m_csConfig;
    WCHAR m_wszMailRoot[POP3_MAX_MAILROOT_LENGTH];
    BSTR m_bstrServerName;
    BOOL MD5Hash(const unsigned char *pOriginal, WCHAR wszResult[MD5_HASH_SIZE+1]);
    HRESULT GetPassword(BSTR bstrUserName, char szPassword[MAX_PATH]);
    HRESULT SetPassword(BSTR bstrUserName, VARIANT vPassword);


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\authdomainaccount.cpp ===
#include "stdafx.h"
#include "Pop3Auth.h"
#include "AuthDomainAccount.h"

void CAuthDomainAccount::CleanDS()
{
    if(m_hDS!=NULL)
    {
        DsUnBind(&m_hDS);
        m_hDS=NULL;
    }
    if(m_pDCInfo!=NULL)
    {
        NetApiBufferFree(m_pDCInfo);
        m_pDCInfo=NULL;
    }
}

HRESULT CAuthDomainAccount::ConnectDS()
{
    HRESULT hr=S_OK;
    DWORD dwRt;
    if(NULL==m_pDCInfo)
    {
        dwRt=DsGetDcName(m_bstrServerName, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED, &m_pDCInfo);
        if(NO_ERROR != dwRt)
        {
            hr= HRESULT_FROM_WIN32(dwRt );
            goto EXIT;
        }
    }
    dwRt=DsBind(m_pDCInfo->DomainControllerName,
                NULL,
                &m_hDS);
    if(NO_ERROR != dwRt)
    {
        hr= HRESULT_FROM_WIN32(dwRt );
        goto EXIT;
    }

    
EXIT:
    if(FAILED(hr))
    {
        CleanDS();
    }
    return  hr;
}


HRESULT CAuthDomainAccount::ADGetUserObject(LPWSTR wszUserName, IADs **ppUserObj,DS_NAME_FORMAT formatUserName)
{
    HRESULT hr=S_OK;
    PDS_NAME_RESULT pDSNR=NULL;
    BSTR bstrDN=NULL;
    IADsPathname *pADPath=NULL;
    if(NULL==wszUserName ||
       NULL == ppUserObj )
    {
        return E_POINTER;
    }
    if(FAILED(hr=CheckDS(FALSE)))
    {
        goto EXIT;
    }

    if(DS_NAME_NO_ERROR!=DsCrackNames(m_hDS, 
                              DS_NAME_NO_FLAGS,
                              formatUserName,
                              DS_FQDN_1779_NAME,
                              1,
                              &wszUserName,
                              &pDSNR) )
    {
        hr=HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        //Re-connect to DS and try again
        if(SUCCEEDED(CheckDS(TRUE)))
        {
            if(DS_NAME_NO_ERROR!=DsCrackNames(m_hDS, 
                                      DS_NAME_NO_FLAGS,
                                      formatUserName,
                                      DS_FQDN_1779_NAME,
                                      1,
                                      &wszUserName,
                                      &pDSNR) )
            {
                goto EXIT;
            }
            else
            {
                hr=S_OK;
            }
         }
         else
         {
             goto EXIT;
         }
    }
    if( NULL == pDSNR )
    {
        hr=HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto EXIT;
    }
    else 
    {
        if((pDSNR->cItems != 1 ) ||
           (pDSNR->rItems->status != DS_NAME_NO_ERROR))
        {
            if(pDSNR->rItems->status != DS_NAME_NO_ERROR)
		    {
                if(ERROR_FILE_NOT_FOUND == pDSNR->rItems->status)
                {
			        hr=HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
                }
                else
                {
			        hr=HRESULT_FROM_WIN32(pDSNR->rItems->status);
                }
		    }
		    else
		    {
			    hr=E_FAIL;
		    }
            goto EXIT;
        }
    }
    // Escaped Mode of the DN
    hr = CoCreateInstance(CLSID_Pathname,
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     IID_IADsPathname,
                     (void**)&pADPath);
    if(SUCCEEDED(hr))
    {
        hr=pADPath->Set(pDSNR->rItems->pName, ADS_SETTYPE_DN);
        if(SUCCEEDED(hr))
        {
            hr=pADPath->put_EscapedMode(ADS_ESCAPEDMODE_ON);
            if(SUCCEEDED(hr))
            {
                hr=pADPath->Retrieve(ADS_FORMAT_X500_NO_SERVER, &bstrDN);
                if(SUCCEEDED(hr))
                {
                    hr=ADsGetObject(bstrDN, IID_IADs, (void **)ppUserObj);    
                }
           }
        }
        pADPath->Release();
    }


EXIT: 
    if(pDSNR)
    {
        DsFreeNameResult(pDSNR);
    }
    if(bstrDN)
    {
        SysFreeString(bstrDN);
    }
    return hr;
}
        


HRESULT CAuthDomainAccount::ADSetUserProp(LPWSTR wszValue, LPWSTR wszLdapPropName)
{
    HRESULT hr=S_OK;
    IADs *pUserObj=NULL;
    WCHAR wszUserName[POP3_MAX_ADDRESS_LENGTH]; 
    WCHAR *pAt;
    VARIANT var;
    if(NULL == wszValue || NULL == wszLdapPropName) 
    {
        return E_INVALIDARG;
    }
    var.vt=VT_BSTR;
    var.bstrVal=SysAllocString(wszValue);
    if(NULL == var.bstrVal)
    {
        return E_OUTOFMEMORY;
    }
    int iNameLen=0;
    pAt=wcschr(wszValue, L'@');
    if( (NULL == pAt ) ||
        ((iNameLen =(int)(pAt - wszValue)) >= (sizeof(wszUserName)/sizeof(WCHAR)-1))  )
    {
        return E_INVALIDARG;
    }

    if( SUCCEEDED(hr=CheckDS(FALSE)) && 
        (NULL != m_pDCInfo) )
    {    
        memset(wszUserName, 0, sizeof(wszUserName));
        // Copy username@ to the buffer
        memcpy(wszUserName, wszValue, (iNameLen+1)*sizeof(WCHAR));
        if(wcslen(m_pDCInfo->DomainName)+iNameLen+1 >= sizeof(wszUserName)/sizeof(WCHAR)-1 )
        {
            hr=E_FAIL;
        }
        else
        {
            //This size is already calculated to fit in the buffer
            //Create the User's principal name username@domainname
            wcscat(wszUserName, m_pDCInfo->DomainName );
            hr=ADGetUserObject(wszUserName, &pUserObj,DS_USER_PRINCIPAL_NAME);
            if(SUCCEEDED(hr))
            {
                hr=pUserObj->Put(wszLdapPropName, var);
                if(SUCCEEDED(hr))
                {
                    hr=pUserObj->SetInfo();
                }
            }
            if(pUserObj)
            {
                pUserObj->Release();
            }
        }
    }
    VariantClear(&var);
    return hr;

}

// wszUserName must be in the UPN format
HRESULT CAuthDomainAccount::ADGetUserProp(LPWSTR wszUserName,LPWSTR wszPropName, VARIANT *pVar)
{
    HRESULT hr=S_OK;
    if( NULL==pVar ||
        wszUserName==NULL )
    {
        return E_POINTER;
    }

    IADs *pUserObj=NULL;
    VariantInit(pVar);
    if(NULL == wcschr(wszUserName, L'@'))
    {
		hr=ADGetUserObject(wszUserName, &pUserObj, DS_NT4_ACCOUNT_NAME);             
    }
	else
	{
		hr=ADGetUserObject(wszUserName, &pUserObj, DS_USER_PRINCIPAL_NAME);
	}
    if(SUCCEEDED(hr))
    {
        hr=pUserObj->Get(wszPropName, pVar);        
        pUserObj->Release();
    }
    
    return hr;

}



HRESULT CAuthDomainAccount::CheckDS(BOOL bForceReconnect)
{
    HRESULT hr=S_OK;
    EnterCriticalSection(&m_DSLock);
    if(bForceReconnect)
    {
        CleanDS();
    }
    if(NULL == m_hDS)
    {
        hr=ConnectDS();           
    }
    LeaveCriticalSection(&m_DSLock);
    return hr;
}





CAuthDomainAccount::CAuthDomainAccount()
{

    m_bstrServerName=NULL;
    m_hDS=NULL;
    m_pDCInfo=NULL;
    InitializeCriticalSection(&m_DSLock);
}


CAuthDomainAccount::~CAuthDomainAccount()
{
    if(m_bstrServerName!=NULL)
    {
        SysFreeString(m_bstrServerName);
        m_bstrServerName=NULL;
    }
    CleanDS();
    DeleteCriticalSection(&m_DSLock);
}



STDMETHODIMP CAuthDomainAccount::Authenticate(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword)
{
    WCHAR *pDomain=NULL;
    if(vPassword.vt != VT_BSTR)
    {
        return E_INVALIDARG;
    }
    if(NULL==bstrUserName)
    {
        return E_POINTER;
    }
    HANDLE hToken;
    //UPN name logon
    if( LogonUser(bstrUserName,
                  NULL,
                  vPassword.bstrVal,
                  LOGON32_LOGON_NETWORK,
                  LOGON32_PROVIDER_DEFAULT,
                  &hToken))
    {
        CloseHandle(hToken);
        return S_OK;
    }

    return E_FAIL;    
}


STDMETHODIMP CAuthDomainAccount::get_Name(/*[out]*/BSTR *pVal)
{
    WCHAR wszBuffer[MAX_PATH+1];
    if(NULL==pVal)
    {
        return E_POINTER;
    }
    if(LoadString(_Module.GetResourceInstance(), IDS_AUTH_DOMAIN_ACCOUNT, wszBuffer, sizeof(wszBuffer)/sizeof(WCHAR)-1))
    {
        *pVal=SysAllocString(wszBuffer);
        if(NULL==*pVal)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_FAIL;
    }

}

STDMETHODIMP CAuthDomainAccount::get_ID(/*[out]*/BSTR *pVal)
{
    if(NULL==pVal)
    {
        return E_POINTER;
    }
    *pVal=SysAllocString(SZ_AUTH_ID_DOMAIN_AD);
    if(NULL==*pVal)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        return S_OK;
    }
}

    
STDMETHODIMP CAuthDomainAccount::Get(/*[in]*/BSTR bstrName, /*[in, out]*/VARIANT *pVal)
{
    BSTR bstrUserName=NULL;
    HRESULT hr;
    if(NULL == bstrName ||
       NULL == pVal)
    {
        return E_INVALIDARG;
    }
    if( 0 == wcscmp(bstrName, SZ_EMAILADDR ))
    {
        if(pVal->vt!=VT_BSTR)
        {
            return E_INVALIDARG;
        }
        bstrUserName=SysAllocString(pVal->bstrVal);
        if(NULL == bstrUserName)
        {
            return E_OUTOFMEMORY;
        }
        VariantClear(pVal);
       
        hr=ADGetUserProp(bstrUserName,SZ_LDAP_EMAIL, pVal);
        SysFreeString(bstrUserName);
        return hr;
        
    }
    else if( 0== wcscmp(bstrName, SZ_SAMACCOUNT_NAME ) )
    {
        if(pVal->vt!=VT_BSTR)
        {
            return E_INVALIDARG;
        }
        bstrUserName=SysAllocString(pVal->bstrVal);
        if(NULL == bstrUserName)
        {
            return E_OUTOFMEMORY;
        }
        VariantClear(pVal);
        hr=ADGetUserProp(bstrUserName,SZ_LDAP_SAM_NAME, pVal);
        SysFreeString(bstrUserName);
        return hr;
    }

    return S_FALSE;
}
    
STDMETHODIMP CAuthDomainAccount::Put(/*[in]*/BSTR bstrName, /*[in]*/VARIANT vVal)
{
    if(NULL == bstrName)
    {
        return E_INVALIDARG;
    }
    if(0==wcscmp(bstrName,SZ_SERVER_NAME )) 
    {
        if( (vVal.vt!=VT_BSTR) ||
            (vVal.bstrVal==NULL ) )
        {
            return E_INVALIDARG;
        }
        else
        {
            if(m_bstrServerName!=NULL)
            {
                SysFreeString(m_bstrServerName);
                m_bstrServerName=NULL;
            }
            m_bstrServerName = SysAllocString(vVal.bstrVal);
            if(NULL == m_bstrServerName)
            {
                return E_OUTOFMEMORY;
            }
            // If AD verify both machine are members of the same domain
            HRESULT hr = E_ACCESSDENIED;
            NET_API_STATUS netStatus;
            LPWSTR psNameBufferRemote, psNameBufferLocal;
            NETSETUP_JOIN_STATUS enumJoinStatus;
            
            netStatus = NetGetJoinInformation( m_bstrServerName, &psNameBufferRemote, &enumJoinStatus );
            if ( NERR_Success == netStatus && NetSetupDomainName == enumJoinStatus )
            {
                netStatus = NetGetJoinInformation( NULL, &psNameBufferLocal, &enumJoinStatus );
                if ( NERR_Success == netStatus && NetSetupDomainName == enumJoinStatus )
                {
                    if ( 0 == wcscmp( psNameBufferLocal, psNameBufferRemote ))
                        hr = S_OK;
                    NetApiBufferFree( psNameBufferLocal );
                }
                NetApiBufferFree( psNameBufferRemote );
            }
            return hr;
        }
    }
    else if( 0==wcscmp(bstrName,SZ_EMAILADDR))
    {
        //Set the email address to the user object in AD
        //vVal must be of array of 2 bstr Variants
        if(vVal.vt!=VT_BSTR)
        {
            return E_INVALIDARG;
        }
        return ADSetUserProp(vVal.bstrVal, SZ_LDAP_EMAIL);
    }
    else if( 0==wcscmp(bstrName, SZ_USERPRICIPALNAME))
    {
        if(vVal.vt!=VT_BSTR)
        {
            return E_INVALIDARG;
        }
        return ADSetUserProp(vVal.bstrVal, SZ_LDAP_UPN_NAME);
    }
    return S_FALSE;

}

STDMETHODIMP CAuthDomainAccount::CreateUser(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword)
{
    WCHAR wszUserSAMName[MAX_USER_NAME_LENGTH+MAX_PATH+1];
    WCHAR wszUserName[MAX_USER_NAME_LENGTH+1];
    DWORD dwRt;
    BOOL bServerName=FALSE;
    VARIANT var;
    VariantInit(&var);
    IADs *pUserObj=NULL;
    HRESULT hr=E_FAIL;
    if( NULL == bstrUserName )
    {
        return E_POINTER;
    }
    if( vPassword.vt!= VT_BSTR )
    {
        return E_INVALIDARG;
    }
    if(NULL==m_pDCInfo)
    {
        dwRt=DsGetDcName(m_bstrServerName, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED, &m_pDCInfo);
        if(NO_ERROR != dwRt)
        {
            return HRESULT_FROM_WIN32(dwRt);
        }
        if(wcslen(m_pDCInfo->DomainName) >= MAX_PATH)
        {
            return E_FAIL;
        }
    }

    //First find out if the UPN name / Email address is in use 
    hr=ADGetUserObject(bstrUserName, &pUserObj,DS_USER_PRINCIPAL_NAME);
    if(SUCCEEDED(hr))
    {
        pUserObj->Release();
        hr=HRESULT_FROM_WIN32(ERROR_USER_EXISTS);
    }
    else
    {
        hr=S_OK;
    }
        
    if( (S_OK==hr) &&
        (FindSAMName(bstrUserName, wszUserName)) )
    {

        USER_INFO_1 UserInfoBuf;
        UserInfoBuf.usri1_name=wszUserName;
        UserInfoBuf.usri1_password=vPassword.bstrVal;
        UserInfoBuf.usri1_priv=USER_PRIV_USER;
        UserInfoBuf.usri1_home_dir=NULL;
        UserInfoBuf.usri1_comment=NULL;
        UserInfoBuf.usri1_flags=UF_NORMAL_ACCOUNT;
        UserInfoBuf.usri1_script_path=NULL;
        dwRt=NetUserAdd(m_pDCInfo->DomainControllerName,
                        1,
                        (LPBYTE)(&UserInfoBuf),
                        NULL);
        if(NERR_Success==dwRt)
        {
            //The lengh of m_pDCInfo->DomainName is at most MAX_PATH-1
            //and SAM account name is at most MAX_USER_NAME_LENGTH
            wcscpy(wszUserSAMName,wszUserName );
            wcscat(wszUserSAMName,L"@");
            wcscat(wszUserSAMName,m_pDCInfo->DomainName);
            hr=ADGetUserObject(wszUserSAMName, &pUserObj, DS_USER_PRINCIPAL_NAME);

            //Set the email address and UPN name to the AD account
            if(SUCCEEDED(hr))
            {
                var.vt=VT_BSTR;
                var.bstrVal=bstrUserName;
                hr=pUserObj->Put(SZ_LDAP_EMAIL, var);
                if(SUCCEEDED(hr))
                {
                    hr=pUserObj->Put(SZ_LDAP_UPN_NAME, var);
                    if(SUCCEEDED(hr))
                    {
                        hr=pUserObj->SetInfo();
                    }

                }
                pUserObj->Release();
            }
            if(FAILED(hr)) //In this case, delete the user just created
            {
                dwRt=NetUserDel(m_pDCInfo->DomainControllerName, wszUserName);
                //Don't care about the return value dwRt
            }

        }
        else
        {
	        hr=HRESULT_FROM_WIN32(dwRt);
        }
         
    }

    return hr;

}

STDMETHODIMP CAuthDomainAccount::DeleteUser(/*[in]*/BSTR bstrUserName)
{
    DWORD dwRt;
    HRESULT hr=E_FAIL;
    if( NULL == bstrUserName)
    {
        return E_POINTER;
    }
    if(NULL==m_pDCInfo)
    {
        dwRt=DsGetDcName(m_bstrServerName, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED, &m_pDCInfo);
        if(NO_ERROR != dwRt)
        {
            return HRESULT_FROM_WIN32(dwRt);
        }
    }

    VARIANT var;
    VariantInit(&var);
        
    hr=ADGetUserProp(bstrUserName,SZ_LDAP_SAM_NAME, &var);

    if(SUCCEEDED(hr))
    {

        dwRt=NetUserDel(m_pDCInfo->DomainControllerName, 
                        var.bstrVal);
        if(NERR_Success==dwRt)
        {
            hr= S_OK;
        }
        else
        {
            hr=HRESULT_FROM_WIN32(dwRt);
        }
        VariantClear(&var);
    }
    return hr;

}


STDMETHODIMP CAuthDomainAccount::ChangePassword(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vNewPassword,/*[in]*/VARIANT vOldPassword)
{
    HRESULT hr=E_FAIL;
    DWORD dwRt;
    if( NULL == bstrUserName)
    {
        return E_POINTER;
    }
    if( vNewPassword.vt!= VT_BSTR )
    {
        return E_INVALIDARG;
    }
 
    if(NULL==m_pDCInfo)
    {
        dwRt=DsGetDcName(m_bstrServerName, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED, &m_pDCInfo);
        if(NO_ERROR != dwRt)
        {
            return HRESULT_FROM_WIN32(dwRt);
        }
    }

    VARIANT var;
    VariantInit(&var);
        
    hr=ADGetUserProp(bstrUserName,SZ_LDAP_SAM_NAME, &var);

    if(SUCCEEDED(hr))
    {
        USER_INFO_1 * pUserInfo=NULL;
        dwRt=NetUserGetInfo(m_pDCInfo->DomainControllerName,
                           var.bstrVal,
                           1,
                           (LPBYTE *)&pUserInfo);
        if(NERR_Success==dwRt)
        {
            pUserInfo->usri1_password=vNewPassword.bstrVal;

            dwRt=NetUserSetInfo(m_pDCInfo->DomainControllerName,
                                var.bstrVal,
                                1,
                                (LPBYTE)pUserInfo,
                                NULL);
            pUserInfo->usri1_password=NULL;
            NetApiBufferFree(pUserInfo);
        }
        if(NERR_Success==dwRt)
        {
            hr = S_OK;
        }
        hr = HRESULT_FROM_WIN32(dwRt);
    }
    
    return hr;

}

STDMETHODIMP CAuthDomainAccount::AssociateEmailWithUser(/*[in]*/BSTR bstrEmailAddr)
{
    IADs *pUserObj=NULL;
    HRESULT hr=E_FAIL;
    WCHAR *pAt=NULL;
    WCHAR wszUserName[POP3_MAX_ADDRESS_LENGTH];     
    VARIANT var;
    VariantInit(&var);
    DWORD dwRt=0;
    if( NULL == bstrEmailAddr)
    {
        return E_POINTER;
    }

    //First check if the email address is already used
    hr=ADGetUserObject(bstrEmailAddr, &pUserObj,DS_USER_PRINCIPAL_NAME);
    
    if(SUCCEEDED(hr))
    {
        //Now set the UPN name and the Email address
        var.vt=VT_BSTR;
        var.bstrVal=bstrEmailAddr;
        hr=pUserObj->Put(SZ_LDAP_EMAIL, var);
        if(SUCCEEDED(hr))
        {
            hr=pUserObj->SetInfo();
        }


        pUserObj->Release();
        return hr;
    }

    if(NULL==m_pDCInfo)
    {
        dwRt=DsGetDcName(m_bstrServerName, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED, &m_pDCInfo);
        if(NO_ERROR != dwRt)
        {
            return HRESULT_FROM_WIN32(dwRt );
        }
    }

    int iNameLen=0;
    //Check if the AD account exists
    pAt=wcschr(bstrEmailAddr, L'@');
    if( (NULL == pAt ) ||
        ((iNameLen =(int)(pAt - bstrEmailAddr)) >= sizeof(wszUserName)/sizeof(WCHAR)-1) )
    {
        return E_FAIL;
    }
    

    if(wcslen(m_pDCInfo->DomainName)+iNameLen+1 >= sizeof(wszUserName)/sizeof(WCHAR)-1 )
    {
        hr=E_FAIL;
    }
    else
    {
        //This size is already calculated to fit in the buffer
        //Create the User's principal name username@domainname
        memset(wszUserName, 0, sizeof(wszUserName));
        // Copy username@ to the buffer
        memcpy(wszUserName, bstrEmailAddr, (iNameLen+1)*sizeof(WCHAR));
        wcscat(wszUserName, m_pDCInfo->DomainName );
        hr=ADGetUserObject(wszUserName, &pUserObj, DS_USER_PRINCIPAL_NAME);

        //Set the email address and UPN name to the AD account
        if(SUCCEEDED(hr))
        {
            var.vt=VT_BSTR;
            var.bstrVal=bstrEmailAddr;
            hr=pUserObj->Put(SZ_LDAP_EMAIL, var);
            if(SUCCEEDED(hr))
            {
                hr=pUserObj->Put(SZ_LDAP_UPN_NAME, var);
                if(SUCCEEDED(hr))
                {
                    hr=pUserObj->SetInfo();
                }

            }
            pUserObj->Release();
        }
    }

    return hr;
}


STDMETHODIMP CAuthDomainAccount::UnassociateEmailWithUser(/*[in]*/BSTR bstrEmailAddr)
{
    IADs *pUserObj=NULL;
    HRESULT hr=E_FAIL;
    BSTR bstrSAMAccountName=NULL;
    VARIANT var;
    VariantInit(&var);
    if( NULL == bstrEmailAddr)
    {
        return E_POINTER;
    }
    //Find the user account with the email address
    hr=ADGetUserObject(bstrEmailAddr, &pUserObj, DS_USER_PRINCIPAL_NAME);
    
    if(SUCCEEDED(hr))
    {
       //Remove the email address and UPN name from the account
        hr=pUserObj->PutEx(ADS_PROPERTY_CLEAR,SZ_LDAP_EMAIL, var);
        if(SUCCEEDED(hr))
        {
            hr=pUserObj->PutEx(ADS_PROPERTY_CLEAR, SZ_LDAP_UPN_NAME, var);
            if(SUCCEEDED(hr))
            {
                hr=pUserObj->SetInfo();
            }

        }
           

        pUserObj->Release();
    }

    return hr;
}

BOOL CAuthDomainAccount::FindSAMName(/*[in]*/LPWSTR wszEmailAddr,/*[out]*/ LPWSTR wszSAMName)
{
    WCHAR *pAt=NULL;
    USER_INFO_1 * pUserInfo=NULL;
    DWORD dwRt=0;
    int iLen=0;
    if(wszEmailAddr == NULL || wszSAMName == NULL) 
    {
       return FALSE;
    }

    wcsncpy(wszSAMName, wszEmailAddr, MAX_USER_NAME_LENGTH);
    wszSAMName[MAX_USER_NAME_LENGTH]=0;
    pAt=wcschr(wszSAMName, L'@');
    if(pAt)
    {
        *pAt=0;
    }
    dwRt=NetUserGetInfo(m_pDCInfo->DomainControllerName,
                       wszSAMName,
                       1,
                       (LPBYTE *)&pUserInfo);
    if(NERR_UserNotFound==dwRt)
    {
        return TRUE; //Found the available SAM name
    }
    else
    {
            NetApiBufferFree(pUserInfo);
    }
    
    iLen=wcslen(wszSAMName);
    if(iLen>MAX_USER_NAME_LENGTH-3)
    {
        iLen=MAX_USER_NAME_LENGTH-3;
    }
    while(iLen && L'.'==wszSAMName[iLen-1] )
    {
        iLen--;
    }
    if(0==iLen)
    {
        return FALSE;
    }

    for(WCHAR chD1=L'0'; chD1<=L'9'; chD1++)
    {
        wszSAMName[iLen]=chD1;
        for(WCHAR chD2=L'0'; chD2<=L'9'; chD2++)
        {
            wszSAMName[iLen+1]=chD2;
            for(WCHAR chD3=L'0'; chD3<=L'9'; chD3++)
            {   
                wszSAMName[iLen+2]=chD3;
                wszSAMName[iLen+3]=0;
                dwRt=NetUserGetInfo(m_pDCInfo->DomainControllerName,
                                   wszSAMName,
                                   1,
                                   (LPBYTE *)&pUserInfo);
                if(NERR_UserNotFound==dwRt)
                {
                    return TRUE; //Found the available SAM name
                }
                else
                {
                    NetApiBufferFree(pUserInfo);
                }

            }
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\authdomainaccount.h ===
#ifndef __POP3_AUTH_DOMAIN_ACCOUNT_H__
#define __POP3_AUTH_DOMAIN_ACCOUNT_H__

#include "resource.h"
#include <Dsgetdc.h>
#include <IADs.h>
#include <Adshlp.h>
#include <NTLDAP.h>
#include <ntdsapi.h>

#define SZ_LDAP_UPN_NAME L"userPrincipalName"
#define SZ_LDAP_EMAIL    L"mail"
#define SZ_LDAP_SAM_NAME L"sAMAccountName"

class ATL_NO_VTABLE CAuthDomainAccount : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAuthDomainAccount, &CLSID_AuthDomainAccount>,
	public IDispatchImpl<IAuthMethod, &IID_IAuthMethod, &LIBID_Pop3Auth>
{

public:
    CAuthDomainAccount();
    virtual ~CAuthDomainAccount();

DECLARE_REGISTRY_RESOURCEID(IDR_AUTHDOMAINACCOUNT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAuthDomainAccount)
	COM_INTERFACE_ENTRY(IAuthMethod)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


public:
    STDMETHOD(Authenticate)(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword);
    STDMETHOD(get_Name)(/*[out]*/BSTR *pVal);
    STDMETHOD(get_ID)(/*[out]*/BSTR *pVal);
    STDMETHOD(Get)(/*[in]*/BSTR bstrName, /*[out]*/VARIANT *pVal);
    STDMETHOD(Put)(/*[in]*/BSTR bstrName, /*[in]*/VARIANT vVal);
    STDMETHOD(CreateUser)(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword);
    STDMETHOD(DeleteUser)(/*[in]*/BSTR bstrUserName);
    STDMETHOD(ChangePassword)(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vNewPassword,/*[in]*/VARIANT vOldPassword);
    STDMETHOD(AssociateEmailWithUser)(/*[in]*/BSTR bstrEmailAddr);
    STDMETHOD(UnassociateEmailWithUser)(/*[in]*/BSTR bstrEmailAddr);

private:
    HRESULT ADGetUserObject(/*[in]*/LPWSTR wszUserName,/*[in, out]*/ IADs **ppUserObj, DS_NAME_FORMAT formatUserName=DS_UNKNOWN_NAME);
    HRESULT ADSetUserProp(/*[in]*/LPWSTR wszValue, /*[in]*/LPWSTR wszLdapPropName);
    HRESULT ADGetUserProp(/*[in]*/LPWSTR wszUserName, /*[in]*/LPWSTR wszPropName, /*[in, out]*/ VARIANT *pVar);
    HRESULT CheckDS(BOOL bForceReconnect);
    HRESULT ConnectDS();
    void CleanDS();
    BOOL FindSAMName(/*[in]*/LPWSTR wszEmailAddr,/*[out]*/ LPWSTR wszSAMName);
    BSTR m_bstrServerName;
    HANDLE m_hDS;
    PDOMAIN_CONTROLLER_INFO m_pDCInfo;
    CRITICAL_SECTION m_DSLock;
};

#endif //__POP3_AUTH_DOMAIN_ACCOUNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\authlocalaccount.h ===
#ifndef __POP3_AUTH_LOCAL_ACCOUNT_H__
#define __POP3_AUTH_LOCAL_ACCOUNT_H__

#include "resource.h"
#include <ntsecapi.h>
#define LOCAL_DOMAIN _T(".")
#define WSZ_POP3_USERS_GROUP L"POP3 Users"
#define LSA_WIN_STANDARD_BUFFER_SIZE  0x000000200L

class ATL_NO_VTABLE CAuthLocalAccount : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAuthLocalAccount, &CLSID_AuthLocalAccount>,
	public IDispatchImpl<IAuthMethod, &IID_IAuthMethod, &LIBID_Pop3Auth>
{

public:
    CAuthLocalAccount();
    virtual ~CAuthLocalAccount();

DECLARE_REGISTRY_RESOURCEID(IDR_AUTHLOCALACCOUNT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAuthLocalAccount)
	COM_INTERFACE_ENTRY(IAuthMethod)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


public:
    STDMETHOD(Authenticate)(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword);
    STDMETHOD(get_Name)(/*[out]*/BSTR *pVal);
    STDMETHOD(get_ID)(/*[out]*/BSTR *pVal);
    STDMETHOD(Get)(/*[in]*/BSTR bstrName, /*[out]*/VARIANT *pVal);
    STDMETHOD(Put)(/*[in]*/BSTR bstrName, /*[in]*/VARIANT vVal);
    STDMETHOD(CreateUser)(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword);
    STDMETHOD(DeleteUser)(/*[in]*/BSTR bstrUserName);
    STDMETHOD(ChangePassword)(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vNewPassword,/*[in]*/VARIANT vOldPassword);
    STDMETHOD(AssociateEmailWithUser)(/*[in]*/BSTR bstrEmailAddr);
    STDMETHOD(UnassociateEmailWithUser)(/*[in]*/BSTR bstrEmailAddr);

private:
    BSTR m_bstrServerName;
    DWORD CheckPop3UserGroup();
    DWORD SetLogonPolicy();

};

#endif //__POP3_AUTH_LOCAL_ACCOUNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\authmd5hash.cpp ===
#include "stdafx.h"
#include <stdio.h>
#include <WinCrypt.h>
#include <mailbox.h>
#include <Pop3RegKeys.h>
#include "Pop3Auth.h"
#include "AuthMD5Hash.h"
#include <MD5.h>
#include "authutil.h"

CAuthMD5Hash::CAuthMD5Hash()
{
    m_wszMailRoot[0]=0;
    m_bstrServerName=NULL;
    InitializeCriticalSection(&m_csConfig);
}


CAuthMD5Hash::~CAuthMD5Hash()
{
    if(m_bstrServerName!=NULL)
    {
        SysFreeString(m_bstrServerName);
        m_bstrServerName=NULL;
    }
    DeleteCriticalSection(&m_csConfig);
}

STDMETHODIMP CAuthMD5Hash::Authenticate(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword)
{
    //Either the password is clear text or it is the MD5 hash
    //the user will be authenticated. 
    HRESULT hr=S_OK;
    char szPassword[MAX_PATH];
    WCHAR wszResult[MD5_HASH_SIZE+1];
    char szHashBuffer[HASH_BUFFER_SIZE];
    BSTR bstrPwd;
    if(vPassword.vt != VT_BSTR )
    {
        return E_INVALIDARG;
    }
    if(vPassword.bstrVal==NULL )
    {
        bstrPwd=L"";
    }
    else
    {
        bstrPwd=vPassword.bstrVal;
    }
    hr=GetPassword(bstrUserName, szPassword);
    if(S_OK==hr)
    { 
        
        //Not a hash
        // Compare the with the stored password
        UnicodeToAnsi(szHashBuffer, HASH_BUFFER_SIZE,bstrPwd, -1);
        if(0!=strcmp(szHashBuffer, szPassword))
        {
           
            if(wcslen(bstrPwd)>MD5_HASH_SIZE) //Can be a hash        
            {
                if(HASH_BUFFER_SIZE <= wcslen(vPassword.bstrVal) + strlen(szPassword) - MD5_HASH_SIZE )
                {
                    //Error!
                    hr=E_INVALIDARG;
                }
                else
                {
                    if( 0>_snprintf(szHashBuffer,
                                    HASH_BUFFER_SIZE, 
                                    "%S%s", 
                                    vPassword.bstrVal+MD5_HASH_SIZE, //The time stamp
                                    szPassword) )
                    {
                        //The hashed password is too long to be correct
                        return E_FAIL;
                    }
                    if(MD5Hash((const unsigned char*)szHashBuffer, wszResult))
                    {
                        if(0!=wcsncmp(wszResult, vPassword.bstrVal, MD5_HASH_SIZE))
                        {
                            hr=E_FAIL;
                        }
                    }
                    else
                    {
                        hr=E_FAIL;
                    }
                }
            }
            else
            {
                hr=E_FAIL;
            }
        }
    }
    
	//Clean the password in memory
    SecureZeroMemory(szPassword,sizeof(szPassword));
	SecureZeroMemory(szHashBuffer, sizeof(szHashBuffer));
	SecureZeroMemory(wszResult, sizeof(wszResult));

    return hr;
}


STDMETHODIMP CAuthMD5Hash::get_Name(/*[out]*/BSTR *pVal)
{
    WCHAR wszBuffer[MAX_PATH+1];
    if(NULL==pVal)
    {
        return E_POINTER;
    }
    if(LoadString(_Module.GetResourceInstance(), IDS_AUTH_MD5_HASH, wszBuffer, MAX_PATH))
    {
        *pVal=SysAllocString(wszBuffer);
        if(NULL==*pVal)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_FAIL;
    }
}

STDMETHODIMP CAuthMD5Hash::get_ID(/*[out]*/BSTR *pVal)
{
    if(NULL==pVal)
    {
        return E_POINTER;
    }
    *pVal=SysAllocString(SZ_AUTH_ID_MD5_HASH);
    if(NULL==*pVal)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        return S_OK;
    }
}

    
STDMETHODIMP CAuthMD5Hash::Get(/*[in]*/BSTR bstrName, /*[out]*/VARIANT *pVal)
{
    return E_NOTIMPL;
}
    
STDMETHODIMP CAuthMD5Hash::Put(/*[in]*/BSTR bstrName, /*[in]*/VARIANT vVal)
{
    
    if( NULL == bstrName )   
    {
        return E_INVALIDARG;
    }
    if(0==wcscmp(bstrName,SZ_SERVER_NAME )) 
    {
        if( (vVal.vt!=VT_BSTR) ||
            (vVal.bstrVal==NULL ) )
        {
            return E_INVALIDARG;
        }
        else
        {
            if(m_bstrServerName!=NULL)
            {
                SysFreeString(m_bstrServerName);
                m_bstrServerName=NULL;
            }
            m_bstrServerName = SysAllocString(vVal.bstrVal);
            if(NULL == m_bstrServerName)
            {
                return E_OUTOFMEMORY;
            }
            return S_OK;
        }
    }
    else if(0==wcscmp(bstrName, SZ_PROPNAME_MAIL_ROOT))
    {
        if( (vVal.vt!=VT_BSTR) ||
            (vVal.bstrVal==NULL ) )
        {
            return E_INVALIDARG;
        }
        else if(0==m_wszMailRoot[0])
        {
            EnterCriticalSection(&m_csConfig);
            if(0==m_wszMailRoot[0])
            {
                if(wcslen(vVal.bstrVal)>=sizeof(m_wszMailRoot)/sizeof(WCHAR))
                {
                    return E_INVALIDARG;
                }
                wcsncpy(m_wszMailRoot, vVal.bstrVal, sizeof(m_wszMailRoot)/sizeof(WCHAR));
            }
            LeaveCriticalSection(&m_csConfig);
        }       
    }
    else
    {
        return S_FALSE;
    }
 
    return S_OK;
}

BOOL CAuthMD5Hash::MD5Hash(const unsigned char *pOriginal, WCHAR wszResult[MD5_HASH_SIZE+1])
{


    MD5_CTX md5;
    unsigned char hash[16];
    WCHAR *p;
    int i;
	BOOL bRtVal=FALSE;
    if(NULL == pOriginal)
    {
        return bRtVal;
    }

    /*
     * Take the MD5 hash of the string argument.
     */

	MD5Init(&md5);
    MD5Update(&md5, pOriginal, strlen((char*)pOriginal));
    MD5Final(&md5);
    bRtVal=TRUE;
    if(bRtVal)
    {
        for (i=0, p=wszResult; i<16; i++, p+=2)
            wsprintf(p, L"%02x", md5.digest[i]);
        *p = L'\0';
    }

    return bRtVal;
}


HRESULT CAuthMD5Hash::GetPassword(BSTR bstrUserName, char szPassword[MAX_PATH])
{ 
    return GetMD5Password( bstrUserName,  szPassword ); 
}

HRESULT CAuthMD5Hash::SetPassword(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword)
{
    // The mailbox should already been created
    WCHAR wszAuthGuid[MAX_PATH];
	WCHAR wszMailRoot[POP3_MAX_MAILROOT_LENGTH];
    DWORD dwAuthDataLen=sizeof(wszAuthGuid)/sizeof(WCHAR);
    DWORD dwBytes=0;
    DWORD dwCryptDataLen;
	DWORD dwRt;
    BYTE szEncryptedPswd[MAX_PATH];
    HRESULT hr = E_FAIL;
	CMailBox mailboxX;
    HCRYPTPROV hProv=NULL;
    HCRYPTHASH hHash=NULL;
    HCRYPTKEY hKey=NULL;
    if( ( NULL == bstrUserName ) ||
        ( vPassword.vt != VT_BSTR ) || 
        ( vPassword.bstrVal==NULL) )
    {
        return E_INVALIDARG;
    }

    if( L'\0'== *(vPassword.bstrVal))
    {
        return E_INVALIDARG;
    }  
    
	if(m_bstrServerName)
	{
		dwRt=RegQueryMailRoot(wszMailRoot, sizeof(wszMailRoot)/sizeof(WCHAR) , m_bstrServerName );
		if( ERROR_SUCCESS == dwRt )
		{
			// Replace drive: with drive$
			if ( L':' == wszMailRoot[1] )
			{
				wszMailRoot[1] = L'$';
				if ( sizeof(m_wszMailRoot)/sizeof(WCHAR) > (wcslen( wszMailRoot ) + wcslen( m_bstrServerName ) + 3) )
				{
					wcscpy( m_wszMailRoot, L"\\\\" );
					wcscat( m_wszMailRoot, m_bstrServerName );
					wcscat( m_wszMailRoot, L"\\" );
					wcscat( m_wszMailRoot, wszMailRoot );

					if( ! mailboxX.SetMailRoot(m_wszMailRoot) )
					{
						dwRt= GetLastError();
					}
				}
				else
					dwRt = ERROR_INSUFFICIENT_BUFFER;
			}
			else
				dwRt = ERROR_INVALID_DATA;
		}
		
		if( ERROR_SUCCESS == dwRt)
		{
			hr = HRESULT_FROM_WIN32( dwRt );
			goto EXIT;
		}
	}


	if ( mailboxX.OpenMailBox( bstrUserName ))
	{
		if ( mailboxX.LockMailBox())
		{
			//Set the password
			if(ERROR_SUCCESS == RegQueryAuthGuid(wszAuthGuid, &dwAuthDataLen, m_bstrServerName) )
			{
                if(!CryptAcquireContext(&hProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
                {
                    goto EXIT;
                }
                if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
                {
                    goto EXIT;
                }
                if(!CryptHashData(hHash, (LPBYTE)wszAuthGuid, dwAuthDataLen, 0))
                {
                    goto EXIT;
                }
                if(!CryptDeriveKey(hProv, CALG_RC4, hHash, (128<<16),&hKey))
                {
                    goto EXIT;
                }
                dwCryptDataLen=( wcslen(vPassword.bstrVal) +1 ) * sizeof(WCHAR);
                if(dwCryptDataLen > MAX_PATH )
                {
                    //Exceed buffer size
                    goto EXIT;
                }
                wcscpy((LPWSTR)szEncryptedPswd, vPassword.bstrVal);
                if(CryptEncrypt(hKey, 0, FALSE, 0, szEncryptedPswd, &dwCryptDataLen, dwCryptDataLen))
                {
					if ( mailboxX.SetEncyptedPassword( szEncryptedPswd, dwCryptDataLen, &dwBytes ))
                    {
						hr = S_OK;
                    }
				}
			}
			mailboxX.UnlockMailBox();
		}
	}
EXIT:
    if(hKey)
    {
        CryptDestroyKey(hKey);
    }
    if(hHash)
    {
        CryptDestroyHash(hHash);
    }
    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    
    return hr;
}


STDMETHODIMP CAuthMD5Hash::CreateUser(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword)
{
    return SetPassword(bstrUserName, vPassword);
}


STDMETHODIMP CAuthMD5Hash::DeleteUser(/*[in]*/BSTR bstrUserName)
{
    // Nothing to do in this.
    return S_FALSE;
}


STDMETHODIMP CAuthMD5Hash::ChangePassword(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vNewPassword,/*[in]*/VARIANT vOldPassword)
{
    //This function does not verify old password
    return SetPassword(bstrUserName, vNewPassword);
}

STDMETHODIMP CAuthMD5Hash::AssociateEmailWithUser(/*[in]*/BSTR bstrEmailAddr)
{
    CMailBox mailboxX;
	DWORD dwRt=ERROR_SUCCESS;
	WCHAR wszMailRoot[POP3_MAX_MAILROOT_LENGTH];
	
	
	if(m_bstrServerName)
	{
	
		dwRt=RegQueryMailRoot(wszMailRoot,sizeof(wszMailRoot)/sizeof(WCHAR) , m_bstrServerName );
		if( ERROR_SUCCESS == dwRt )
		{
			// Replace drive: with drive$
			if ( L':' == wszMailRoot[1] )
			{
				wszMailRoot[1] = L'$';
				if ( sizeof(m_wszMailRoot)/sizeof(WCHAR) > (wcslen( wszMailRoot ) + wcslen( m_bstrServerName ) + 3) )
				{
					wcscpy( m_wszMailRoot, L"\\\\" );
					wcscat( m_wszMailRoot, m_bstrServerName );
					wcscat( m_wszMailRoot, L"\\" );
					wcscat( m_wszMailRoot, wszMailRoot );

					if( ! mailboxX.SetMailRoot(m_wszMailRoot) )
					{
						dwRt= GetLastError();
					}
				}
				else
					dwRt = ERROR_INSUFFICIENT_BUFFER;
			}
			else
				dwRt = ERROR_INVALID_DATA;
		}	
	}
	
	if (ERROR_SUCCESS == dwRt)
	{
		if ( mailboxX.OpenMailBox( bstrEmailAddr ))
		{
			return S_OK;
		}
		else
		{
			dwRt=GetLastError();
		}
	}
 	

   return HRESULT_FROM_WIN32( dwRt);
}

STDMETHODIMP CAuthMD5Hash::UnassociateEmailWithUser(/*[in]*/BSTR bstrEmailAddr)
{
    return AssociateEmailWithUser( bstrEmailAddr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\authmethods.cpp ===
//Implementation of CAuthMethods class

#include "stdafx.h"
#include "Pop3Auth.h"
#include "AuthMethodsEnum.h"
#include <pop3regkeys.h>
#include <p3admin.h>
#include <DSRole.h>

#include <POP3Server.h>
#include <servutil.h>

CAuthMethods::CAuthMethods()
{
    m_bIsInitialized=FALSE;
    m_lCurrentMethodIndex=-1;
    m_bstrServerName=NULL;
    m_lMachineRole=0;
    InitializeCriticalSection(&m_csVectorGuard);
}

CAuthMethods::~CAuthMethods()
{
    CleanUp();
    DeleteCriticalSection(&m_csVectorGuard);
}

STDMETHODIMP CAuthMethods::get_Count(LONG *pVal)
{
    if(NULL == pVal)
    {
        return E_POINTER;
    }
    if(!m_bIsInitialized)
    {
        if(!Initialize())
        {
            return E_FAIL;
        }
    }

    *pVal=m_Index.size();

    return S_OK;
}


STDMETHODIMP CAuthMethods::get_Item(VARIANT vID, IAuthMethod **ppVal)
{
    HRESULT hr=E_INVALIDARG;
    if(NULL == ppVal)
    {
        return E_POINTER;
    }
    if(! m_bIsInitialized)
    {
        if(!Initialize())
        {
            return E_FAIL;
        }
    }
    if(VT_I4 == vID.vt)
    {	
		vID.lVal--;	// Collections should be 1-based
        if(vID.lVal>=0 && vID.lVal<m_Index.size())
        {
            hr=m_AuthVector[m_Index[vID.lVal]]->pIAuthMethod
                ->QueryInterface(IID_IAuthMethod, (void **)ppVal);
        }
    }
    else if(VT_BSTR==vID.vt)
    {
        for(long i=0; i< m_Index.size(); i++)
        {
            if( 0==wcscmp(m_AuthVector[m_Index[i]]->bstrName, vID.bstrVal) )
            {
               hr=m_AuthVector[m_Index[i]]->pIAuthMethod
                  ->QueryInterface(IID_IAuthMethod, (void **)ppVal);
               break;
            }
        }
    }
    if(S_OK==hr)
    {
        VARIANT vServer;
        vServer.vt=VT_BSTR;
        vServer.bstrVal=m_bstrServerName;
        if(m_bstrServerName!=NULL)
        {
            hr = (*ppVal)->Put(SZ_SERVER_NAME, vServer);
        }
    }
    
    return hr;
}

STDMETHODIMP CAuthMethods::get__NewEnum(IEnumVARIANT **ppVal)
{
    if(ppVal==NULL) 
    {
        return E_POINTER;
    }
    HRESULT     hr=S_OK;
    CComObject<CAuthMethodsEnum> *pAuthEnum;
    *ppVal=NULL;
    if(!m_bIsInitialized)
    {
        if(!Initialize())
        {
            return E_FAIL;
        }
    }

    hr = CComObject<CAuthMethodsEnum>::CreateInstance(&pAuthEnum); // Reference count still 0
    if(SUCCEEDED(hr))
    {
        hr=pAuthEnum->Init(&m_AuthVector);
        if(SUCCEEDED(hr))
        {
            hr=pAuthEnum->QueryInterface(IID_IEnumVARIANT,(void **)(ppVal)  );
        }
        if(FAILED(hr))
        {
            delete(pAuthEnum);
        }
    }
        
    return hr;
}


STDMETHODIMP CAuthMethods::Add(BSTR bstrName, BSTR bstrGUID)
{
    HRESULT hr=S_OK;;
    PAUTH_METHOD_INFO pAuthMethodInfo=NULL;
    if(NULL==bstrName || NULL==bstrGUID)
    {
        return E_INVALIDARG;
    }

    pAuthMethodInfo=new(AUTH_METHOD_INFO);
    if(pAuthMethodInfo == NULL)
    {
        return E_OUTOFMEMORY;
    }
    pAuthMethodInfo->bstrGuid=SysAllocString(bstrGUID);
    pAuthMethodInfo->bstrName=SysAllocString(bstrName);
    if( (NULL==pAuthMethodInfo->bstrGuid)
        ||(NULL==pAuthMethodInfo->bstrName))
    {
        delete pAuthMethodInfo;
        hr=E_OUTOFMEMORY;
    }
    EnterCriticalSection(&m_csVectorGuard);
    m_AuthVector.push_back(pAuthMethodInfo);
    m_Index.push_back(m_AuthVector.size()-1);    
    LeaveCriticalSection(&m_csVectorGuard);
    return hr;
}

STDMETHODIMP CAuthMethods::Remove(VARIANT vID)
{
    HRESULT hr=E_INVALIDARG;
    AUTHINDEX::iterator itor=m_Index.begin();
    if(!m_bIsInitialized)
    {
        if(!Initialize())
        {
            return E_FAIL;
        }
    }
    if(m_Index.size()==1)
    {
        //Can not remove the last Auth method
        return E_FAIL;
    }
    if(VT_I4 == vID.vt)
    {
		vID.lVal--;	// Collections should be 1-based
        if(vID.lVal>=0 && vID.lVal<m_Index.size())
        {
            itor+=vID.lVal;
            m_Index.erase(itor);
            if(vID.lVal==m_lCurrentMethodIndex)
            {
                m_lCurrentMethodIndex=0;
            }
            else if (vID.lVal<m_lCurrentMethodIndex)
            {
                m_lCurrentMethodIndex--;
            }                            
        }
    }
    else if(VT_BSTR==vID.vt)
    {
        for(int i=0; i< m_Index.size(); i++)
        {
            if(0==wcscmp(m_AuthVector[m_Index[i]]->bstrName, vID.bstrVal))
            {
                itor+=i;
                m_Index.erase(itor);
                if(i==m_lCurrentMethodIndex)
                {
                    m_lCurrentMethodIndex=0;
                }
                else if (i<m_lCurrentMethodIndex)
                {
                    m_lCurrentMethodIndex--;
                }                            
                break;
            }
        }
    }

    return hr;

}

STDMETHODIMP CAuthMethods::Save(void)
{
    int i=0;
    int iBufferSize=0;
    WCHAR *pBuffer=NULL, *pCurrent;
    HRESULT hr=E_FAIL;
    HKEY  hPop3Key;
    if( !m_bIsInitialized )
    {
        //No change needed for this save
        return S_OK;
    }
    EnterCriticalSection(&m_csVectorGuard);

    for(i=0;i<m_AuthVector.size();i++)
    {
        iBufferSize+=wcslen(m_AuthVector[i]->bstrGuid)+1;
    }
	if ( 0 != iBufferSize )
	{
		iBufferSize++;
		pBuffer=(WCHAR *)malloc(iBufferSize*sizeof(WCHAR));
		if(NULL != pBuffer)
		{
			pCurrent=pBuffer;
			for(i=0;i<m_AuthVector.size();i++)
			{
				wcscpy(pCurrent,m_AuthVector[i]->bstrGuid);  
				pCurrent+=wcslen(m_AuthVector[i]->bstrGuid)+1;
			}      
			*pCurrent=0; //Double NULL to terminate 

			if( ERROR_SUCCESS== RegHKLMOpenKey(
                           POP3SERVER_AUTH_SUBKEY,
                           KEY_SET_VALUE, 
                           &hPop3Key,
                           m_bstrServerName) )
				             
			{
        
				if(ERROR_SUCCESS ==
					 RegSetValueEx(hPop3Key,
								  VALUENAME_AUTHMETHODS,
								  NULL,
								  REG_MULTI_SZ,
								  (LPBYTE)pBuffer,
								  iBufferSize*sizeof(WCHAR)))
				{
					if( ERROR_SUCCESS ==
							 RegSetValueEx(hPop3Key,
										  VALUENAME_DEFAULTAUTH,
										  NULL,
										  REG_DWORD,
										  (LPBYTE)&(m_Index[m_lCurrentMethodIndex]),
										  sizeof(DWORD)))
					{   // Need to restart the service (if the Auth method is being changed, which means # domains = 0
                        long    lCount;
                        CComPtr<IP3Config> spIConfig;
                        CComPtr<IP3Domains> spIDomains;
                        
                        hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
                        if ( S_OK == hr )
                        {
                        
                            hr = spIConfig->put_MachineName( m_bstrServerName );
                            if ( S_OK == hr)
                            {
                                hr = spIConfig->get_Domains( &spIDomains );
                            }
                        }
                        if( S_OK == hr )
                        {
                            hr = spIDomains->get_Count( &lCount );
                            if ( S_OK == hr && 0 == lCount && _IsServiceRunning( POP3_SERVICE_NAME ))
                                hr = _RestartService( POP3_SERVICE_NAME );
                        }
                        
					}
				}
				RegCloseKey(hPop3Key);
			}
			free(pBuffer);
		}
		else //pBuffer == NULL
		{
			hr=E_OUTOFMEMORY;
		}
	}

    LeaveCriticalSection(&m_csVectorGuard);
    return hr;
}

STDMETHODIMP CAuthMethods::put_MachineName(BSTR newVal)
{
    if(NULL!=m_bstrServerName)
    {
        SysFreeString(m_bstrServerName);
        m_bstrServerName=NULL;
    }
    if ( (NULL != newVal) && (0 < wcslen( newVal )))
    {
        CleanUp();
        m_bstrServerName=SysAllocString(newVal);
        if(NULL==m_bstrServerName)
        {
            return E_OUTOFMEMORY;
        }
    }

    // Actually verify we can get the current auth method of the remote machine.
    // This enforces that we can only administer remote AD machine's if we are in the same domain.

    HRESULT hr;    
    VARIANT v;
    CComPtr<IAuthMethod> spIAuthMethod;

    VariantInit( &v );
    hr = get_CurrentAuthMethod( &v );
    if ( S_OK == hr )
        hr = get_Item( v, &spIAuthMethod );
    if ( S_OK != hr )
        CleanUp();
    
    return hr;
}

STDMETHODIMP CAuthMethods::get_MachineName(BSTR *pVal)
{
    if(NULL == pVal)
    {
        return E_POINTER;
    }
    if(NULL!=m_bstrServerName)
    {
        *pVal=SysAllocString(m_bstrServerName);
        if(NULL == *pVal)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        *pVal=NULL;
    }

    return S_OK;
}

STDMETHODIMP CAuthMethods::get_CurrentAuthMethod(VARIANT *pVal)
{
    if(NULL == pVal)
    {
        return E_POINTER;
    }
    if( !m_bIsInitialized)
    {
        if(!Initialize())
        {
            return E_FAIL;
        }
    }
    if(pVal->vt != VT_EMPTY )
    {
        return E_INVALIDARG;
    }
    
    if(m_lCurrentMethodIndex <0 )
    {
        //The current authmethod is not valid
        return  HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED);
    }

    pVal->vt=VT_I4;
    pVal->lVal=m_lCurrentMethodIndex + 1;	// Collections should be 1-based
    return S_OK;

}


STDMETHODIMP CAuthMethods::put_CurrentAuthMethod(VARIANT vID)
{
    HRESULT hr=E_INVALIDARG;
    if(!m_bIsInitialized)
    {
        if(!Initialize())
        {
            return E_FAIL;
        }
    }

    EnterCriticalSection(&m_csVectorGuard);

    if(VT_I4 == vID.vt)
    {
		vID.lVal--;	// Collections should be 1-based
        if(vID.lVal>=0 && vID.lVal<m_Index.size())
        {
            hr=VerifyCurrentAuthMethod(vID.lVal);
            if(S_OK == hr )
            {
                m_lCurrentMethodIndex=vID.lVal;
            }
        }
    }
    else if(VT_BSTR==vID.vt)
    {
        for(int i=0; i< m_Index.size(); i++)
        {
            if( 0 == wcscmp(m_AuthVector[m_Index[i]]->bstrName, vID.bstrVal) )
            {   
                hr=VerifyCurrentAuthMethod(i);
                if(S_OK == hr)
                {
                    m_lCurrentMethodIndex=i;
                }
                break;
            }
        }
    }

    LeaveCriticalSection(&m_csVectorGuard);
    return hr;

}

void CAuthMethods::CleanUp()
{
    for(int i=0; i< m_AuthVector.size(); i++)
    {
        if(NULL != m_AuthVector[i]->pIAuthMethod)
        {
            m_AuthVector[i]->pIAuthMethod->Release();
        }
        SysFreeString(m_AuthVector[i]->bstrGuid);
        SysFreeString(m_AuthVector[i]->bstrName);
        delete m_AuthVector[i];
    }

    m_AuthVector.clear();
    m_Index.clear();
    if(NULL!=m_bstrServerName)
    {
        SysFreeString(m_bstrServerName);
        m_bstrServerName=NULL;
    }
    m_bIsInitialized=FALSE;
}


BOOL CAuthMethods::Initialize()
{
    HKEY  hPop3Key;
    BOOL  bRtVal=FALSE;
    DWORD cbSize=sizeof(DWORD);
    DWORD dwType;
    LONG  lErr;
    LONG  lCurrentMethodIndex=0;
    WCHAR *wBuffer=NULL;

    EnterCriticalSection(&m_csVectorGuard);

    if( !m_bIsInitialized )
    {
        
        SetMachineRole();
        //Load data from the registry
        if( ERROR_SUCCESS==RegHKLMOpenKey(
                           POP3SERVER_AUTH_SUBKEY,
                           KEY_QUERY_VALUE, 
                           &hPop3Key,
                           m_bstrServerName) )
        {

            if(ERROR_SUCCESS==
                RegQueryValueEx(hPop3Key,
                                VALUENAME_DEFAULTAUTH,
                                NULL,
                                &dwType,
                                (LPBYTE)&(lCurrentMethodIndex),
                                &cbSize))
            {

                cbSize=0;
                if(ERROR_SUCCESS==
                    RegQueryValueEx(hPop3Key,
                                    VALUENAME_AUTHMETHODS,
                                    NULL,
                                    &dwType,
                                    NULL,
                                    &cbSize))
                {
                    wBuffer=(WCHAR *)malloc(cbSize);
                    if(NULL!=wBuffer)
                    {
                        ZeroMemory(wBuffer, cbSize);
                        if(ERROR_SUCCESS==
                            RegQueryValueEx(hPop3Key,
                                            VALUENAME_AUTHMETHODS,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)wBuffer,
                                            &cbSize))
                        {
                            if(PopulateAuthMethods(wBuffer, cbSize))
                            {
                                for(int i=0;i<m_Index.size();i++)
                                {
                                    if(m_Index[i]==lCurrentMethodIndex)
                                    {
                                        m_lCurrentMethodIndex=i;
                                        break;
                                    }
                                }
                                m_bIsInitialized=TRUE;
                                bRtVal=TRUE;
                            }
                        }
                        free(wBuffer);
                    }
                } 
            }            
            RegCloseKey(hPop3Key);
        }

    }
    LeaveCriticalSection(&m_csVectorGuard);
    return bRtVal;
}


BOOL CAuthMethods::PopulateAuthMethods(WCHAR *wBuffer, DWORD cbSize)
{
    //Parse the multi-string buffer
    DWORD dwSize=cbSize/sizeof(WCHAR);
    WCHAR *pStart, *pEnd;
    PAUTH_METHOD_INFO pAuthInfo=NULL;
    BOOL bRetVal=TRUE;
    if(NULL == wBuffer)
    {
        return FALSE;
    }
    if(0!=wBuffer[dwSize-1])
    {
        //Wrong format
        return FALSE; 
    }
    pStart=wBuffer;
    pEnd=pStart+wcslen(pStart);
    while(pEnd<wBuffer+dwSize-1)
    {
        pAuthInfo=new(AUTH_METHOD_INFO);
        if(NULL == pAuthInfo)
        {
            bRetVal=FALSE;
            break;
        }
        ZeroMemory(pAuthInfo, sizeof(pAuthInfo));
        pAuthInfo->bstrGuid=SysAllocString(pStart);
        if(NULL == pAuthInfo->bstrGuid)
        {
            bRetVal=FALSE;
            break;
        }
        if(S_OK != CreateObj(pAuthInfo, &(pAuthInfo->pIAuthMethod)))
        {
            bRetVal=FALSE;
            break;
        }
        if(S_OK != pAuthInfo->pIAuthMethod->get_Name(&(pAuthInfo->bstrName)) )
        {
            bRetVal=FALSE;
            break;
        }
        m_AuthVector.push_back(pAuthInfo);
        if(SUCCEEDED(VerifyAuthMethod(pAuthInfo->bstrGuid)))
        {
            //Only show valid auth methods
            m_Index.push_back(m_AuthVector.size()-1);
            pAuthInfo->bIsValid=TRUE;
        }
        else
        {
            pAuthInfo->bIsValid=FALSE;
        }
        pStart=pEnd+1;
        pEnd=pStart+wcslen(pStart);
    }
    if(!bRetVal)
    {
        if(NULL !=pAuthInfo)
        {
            if(NULL!=pAuthInfo->pIAuthMethod)
            {
                pAuthInfo->pIAuthMethod->Release();
            }
            SysFreeString(pAuthInfo->bstrGuid);
            SysFreeString(pAuthInfo->bstrName);
            delete pAuthInfo;
        }
        CleanUp();
    }
    return  bRetVal;


}

HRESULT CAuthMethods::CreateObj(PAUTH_METHOD_INFO pAuthInfo, IAuthMethod **ppVal)
{
    HRESULT hr=S_OK;
    UUID uuid;
    if( ( NULL == pAuthInfo ) ||
        ( NULL == ppVal ) )
    {
        return E_POINTER;
    }
    if(pAuthInfo->bstrGuid == NULL)
    {
        return E_INVALIDARG;
    }
    if(RPC_S_OK != UuidFromString(pAuthInfo->bstrGuid, &uuid))
    {
        return E_INVALIDARG;
    }

    hr=CoCreateInstance(uuid,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IAuthMethod,
                        (LPVOID *)ppVal);

    return hr;                        
        
}


//The index here is the relative index exposed through public interface
STDMETHODIMP CAuthMethods::VerifyCurrentAuthMethod(int iIndex)
{
    HRESULT hr=E_FAIL;
    long lCount=0;
    if(! m_bIsInitialized)
    {
        if(!Initialize())
        {
            return E_FAIL;
        }
    }
    if( iIndex < 0 )
    {
        if(m_lCurrentMethodIndex < 0 )
        {
            return  HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED);
        }             
        iIndex=m_lCurrentMethodIndex;	
    }
	
    	

    if( (NO_DOMAIN==m_lMachineRole) &&
        (0==_wcsicmp(m_AuthVector[m_Index[iIndex]]->bstrGuid, SZ_AUTH_ID_DOMAIN_AD)) )
    {
        return E_INVALIDARG;
    }
    if( (DOMAIN_CONTROLLER==m_lMachineRole) &&
        (0==_wcsicmp(m_AuthVector[m_Index[iIndex]]->bstrGuid, SZ_AUTH_ID_LOCAL_SAM)) )
    {
        return E_INVALIDARG;
    }
    if( 0 ==_wcsicmp(m_AuthVector[m_Index[iIndex]]->bstrGuid, SZ_AUTH_ID_MD5_HASH) )
    {
        // Set the SPA required reg key to 0
        RegSetSPARequired(0); //Don't care if the key does not exist
    }

    if( iIndex != m_lCurrentMethodIndex)
    {
        // Can not change Auth Method if there is a email domain
        
        CComPtr<IP3Config> spIConfig;
        CComPtr<IP3Domains> spIDomains;
        hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
        if( S_OK == hr )
        {
        
            hr = spIConfig->put_MachineName( m_bstrServerName );
            if( S_OK== hr)
            {
                hr = spIConfig->get_Domains( &spIDomains );
            }
        }
        if( S_OK == hr )
        {
            hr = spIDomains->get_Count( &lCount );
            if ( S_OK == hr )
            {
                if(0==lCount)
                {
                    return S_OK;
                }
            }
        }
    
        return STG_E_ACCESSDENIED;
    }

    return S_OK;
}


HRESULT CAuthMethods::SetMachineRole()
{
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pMachineRole=NULL;
    //Check the Role of the machine
    if( ERROR_SUCCESS==
        DsRoleGetPrimaryDomainInformation(
                        m_bstrServerName,
                        DsRolePrimaryDomainInfoBasic,
                        (PBYTE *)(&pMachineRole)) )
    {
        switch(pMachineRole->MachineRole)
        {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer: m_lMachineRole=NO_DOMAIN;
                                          break;
        case DsRole_RoleMemberWorkstation:
        case DsRole_RoleMemberServer:m_lMachineRole=DOMAIN_NONE_DC;
                                     break;
        case DsRole_RoleBackupDomainController: 
        case DsRole_RolePrimaryDomainController:m_lMachineRole=DOMAIN_CONTROLLER;
                                                break;
        }
        DsRoleFreeMemory(pMachineRole);  
        pMachineRole=NULL;
        return S_OK;

    }
    return E_FAIL;


}


HRESULT CAuthMethods::VerifyAuthMethod(BSTR bstrGuid)
{

    if(bstrGuid == NULL)
    {
        return E_POINTER;
    }
    if( (NO_DOMAIN==m_lMachineRole) &&
        (0==_wcsicmp(bstrGuid, SZ_AUTH_ID_DOMAIN_AD)) )
    {
        return E_FAIL;
    }
    if( (DOMAIN_CONTROLLER==m_lMachineRole) &&
        (0==_wcsicmp(bstrGuid, SZ_AUTH_ID_LOCAL_SAM)) )
    {
        return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <..\..\..\public\sdk\inc\atl30\statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\authlocalaccount.cpp ===
#include "stdafx.h"
#include "Pop3Auth.h"
#include "AuthLocalAccount.h"


CAuthLocalAccount::CAuthLocalAccount()
{
    m_bstrServerName=NULL;

}


CAuthLocalAccount::~CAuthLocalAccount()
{
    if(m_bstrServerName!=NULL)
    {
        SysFreeString(m_bstrServerName);
        m_bstrServerName=NULL;
    }

}

STDMETHODIMP CAuthLocalAccount::Authenticate(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword)
{
    WCHAR *pAt=NULL;
    if(vPassword.vt != VT_BSTR)
    {
        return E_INVALIDARG;
    }
    if(NULL==bstrUserName)
    {
        return E_POINTER;
    }
    HANDLE hToken;
    pAt=wcschr(bstrUserName, L'@');
    if(NULL!=pAt)
    {
        *pAt=0;
    }
    
    if( LogonUser(bstrUserName,
                  LOCAL_DOMAIN,
                  vPassword.bstrVal,
                  LOGON32_LOGON_NETWORK,
                  LOGON32_PROVIDER_DEFAULT,
                  &hToken))
    {
        CloseHandle(hToken);
        return S_OK;
    }
    return E_FAIL;
}


STDMETHODIMP CAuthLocalAccount::get_Name(/*[out]*/BSTR *pVal)
{
    WCHAR wszBuffer[MAX_PATH+1];
    if(NULL==pVal)
    {
        return E_POINTER;
    }
    if(LoadString(_Module.GetResourceInstance(), IDS_AUTH_LOCAL_ACCOUNT, wszBuffer, MAX_PATH))
    {
        *pVal=SysAllocString(wszBuffer);
        if(NULL==*pVal)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_FAIL;
    }
}

STDMETHODIMP CAuthLocalAccount::get_ID(/*[out]*/BSTR *pVal)
{
    if(NULL==pVal)
    {
        return E_POINTER;
    }
    *pVal=SysAllocString(SZ_AUTH_ID_LOCAL_SAM);
    if(NULL==*pVal)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        return S_OK;
    }
}

    
STDMETHODIMP CAuthLocalAccount::Get(/*[in]*/BSTR bstrName, /*[out]*/VARIANT *pVal)
{
    return E_NOTIMPL;
}
    
STDMETHODIMP CAuthLocalAccount::Put(/*[in]*/BSTR bstrName, /*[in]*/VARIANT vVal)
{
    if(NULL == bstrName)
    {
        return E_INVALIDARG;
    }
    if(0==wcscmp(bstrName,SZ_SERVER_NAME )) 
    {
        if( (vVal.vt!=VT_BSTR) ||
            (vVal.bstrVal==NULL ) )
        {
            return E_INVALIDARG;
        }
        else
        {
            if(m_bstrServerName!=NULL)
            {
                SysFreeString(m_bstrServerName);
                m_bstrServerName=NULL;
            }
            m_bstrServerName = SysAllocString(vVal.bstrVal);
            if(NULL == m_bstrServerName)
            {
                return E_OUTOFMEMORY;
            }
            return S_OK;
        }
    }
    
    return S_FALSE;
}


STDMETHODIMP CAuthLocalAccount::CreateUser(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vPassword)
{
    DWORD dwRt;
    WCHAR *pAt=NULL;
    HRESULT hr=S_OK;
    if( NULL == bstrUserName )
    {
        return E_POINTER;
    }
    if( vPassword.vt!= VT_BSTR )
    {
        return E_INVALIDARG;
    }

    dwRt=CheckPop3UserGroup();
    if( NERR_Success != dwRt )
    {
        return HRESULT_FROM_WIN32(dwRt);
    }

    pAt=wcschr(bstrUserName, L'@');
    if(pAt)
    {
        *pAt=NULL;
    }    
    if(wcslen(bstrUserName) > MAX_USER_NAME_LENGTH)
    {
        hr=HRESULT_FROM_WIN32(WSAENAMETOOLONG);
    }
    else
    {
        USER_INFO_1 UserInfoBuf;
        UserInfoBuf.usri1_name=bstrUserName;
        UserInfoBuf.usri1_password=vPassword.bstrVal;
        UserInfoBuf.usri1_priv=USER_PRIV_USER;
        UserInfoBuf.usri1_home_dir=NULL;
        UserInfoBuf.usri1_comment=NULL;
        UserInfoBuf.usri1_flags=UF_NORMAL_ACCOUNT;
        UserInfoBuf.usri1_script_path=NULL;
        dwRt=NetUserAdd(m_bstrServerName,
                        1,
                        (LPBYTE)(&UserInfoBuf),
                        NULL);
        if(NERR_Success==dwRt)
        {
            LOCALGROUP_MEMBERS_INFO_3 lgmInfo;
            lgmInfo.lgrmi3_domainandname=bstrUserName;
            dwRt=NetLocalGroupAddMembers(m_bstrServerName, WSZ_POP3_USERS_GROUP, 3, (LPBYTE)(&lgmInfo), 1);
            if(NERR_Success!=dwRt)
            {   //Delete the account just created if can not add to the group
                NetUserDel(m_bstrServerName, bstrUserName); 
            }
        }
        else
        {
            hr=HRESULT_FROM_WIN32(dwRt);
        }
    }    
    if(pAt)
    {
        *pAt=L'@';
    }

    return hr;

}

STDMETHODIMP CAuthLocalAccount::DeleteUser(/*[in]*/BSTR bstrUserName)
{
    DWORD dwRt;
    WCHAR *pAt=NULL;
    if( NULL == bstrUserName)
    {
        return E_POINTER;
    }

    pAt=wcschr(bstrUserName, L'@');
    if(pAt)
    {
        *pAt=NULL;
    }    
            
    dwRt=NetUserDel(m_bstrServerName, bstrUserName);
    if(NERR_Success==dwRt)
    {
        return S_OK;
    }
    if(pAt)
    {
        *pAt=L'@';
    }

    return HRESULT_FROM_WIN32(dwRt);

}


STDMETHODIMP CAuthLocalAccount::ChangePassword(/*[in]*/BSTR bstrUserName,/*[in]*/VARIANT vNewPassword,/*[in]*/VARIANT vOldPassword)
{
    DWORD dwRt;
    WCHAR *pAt=NULL;
    BOOL bServerName=FALSE;
    if( NULL == bstrUserName)
    {
        return E_POINTER;
    }
    if( vNewPassword.vt!= VT_BSTR )
    {
        return E_INVALIDARG;
    }

    USER_INFO_1 * pUserInfo=NULL;

    pAt=wcschr(bstrUserName, L'@');
    if(pAt)
    {
        *pAt=0;
    }    
    dwRt=NetUserGetInfo(m_bstrServerName,
                        bstrUserName,
                        1,
                       ( LPBYTE *)&pUserInfo);
    if(NERR_Success==dwRt)
    {
        pUserInfo->usri1_password=vNewPassword.bstrVal;

        dwRt=NetUserSetInfo(m_bstrServerName,
                            bstrUserName,
                            1,
                            (LPBYTE)pUserInfo,
                            NULL);
        pUserInfo->usri1_password=NULL;
        NetApiBufferFree(pUserInfo);
    }
        
    if(pAt)
    {
        *pAt=L'@';
    }
    if(NERR_Success==dwRt)
    {
        return S_OK;
    }
    return HRESULT_FROM_WIN32(dwRt);

}

//To check if the POP3 Users group exists
//if not, create the group.
//Return 0 if the group exists or is created
//Return error code if failed to create the group
DWORD CAuthLocalAccount::CheckPop3UserGroup()
{
    LPBYTE pBuffer=NULL;
    DWORD dwRt;
    WCHAR wszBuffer[MAXCOMMENTSZ];
    dwRt=NetLocalGroupGetInfo(m_bstrServerName,
                         WSZ_POP3_USERS_GROUP,
                         1, 
                         &pBuffer);
    if(NERR_Success == dwRt )
    {
        NetApiBufferFree(pBuffer);
        return NO_ERROR;
    }
    if(NERR_GroupNotFound == dwRt)
    {
        //Create the group

        //Load the comments to the group
        if(LoadString(_Module.GetResourceInstance(), IDS_AUTH_POP3_GROUP, wszBuffer, MAXCOMMENTSZ))
        {
            GROUP_INFO_1 GroupInfo={WSZ_POP3_USERS_GROUP, wszBuffer};
            dwRt=NetLocalGroupAdd(m_bstrServerName, 
                         1,
                         (LPBYTE)(&GroupInfo),
                         NULL);
            if(NERR_Success != dwRt )
            {
                return dwRt;
            }
            //Now the group is created, set the local logon policy
            //So that members of the group can not log on interactively
            dwRt=SetLogonPolicy();
            if(0!=dwRt)
            {
                NetLocalGroupDel(m_bstrServerName, WSZ_POP3_USERS_GROUP );
                return dwRt;
            }
        }
        else
        {
            dwRt=GetLastError();
        }
    }
    return dwRt;
}

DWORD CAuthLocalAccount::SetLogonPolicy()
{
    //First get the sid of the POP3 Users group
    char pSid[LSA_WIN_STANDARD_BUFFER_SIZE];
    DWORD dwSizeSid=LSA_WIN_STANDARD_BUFFER_SIZE;
    WCHAR wszDomainName[MAX_PATH];
    DWORD cbDomainName=sizeof(wszDomainName);
    SID_NAME_USE sidType=SidTypeGroup;
    if(!LookupAccountName(NULL, 
                         WSZ_POP3_USERS_GROUP,
                         (PSID)pSid,
                         &dwSizeSid,
                         wszDomainName,
                         &cbDomainName,
                         &sidType))
    {
        return GetLastError();
    }


    //Then set the logon policy
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle = NULL;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );
    Status = LsaOpenPolicy(NULL, &ObjectAttributes ,POLICY_WRITE|POLICY_LOOKUP_NAMES,&PolicyHandle);
    if ( ERROR_SUCCESS !=Status )
    {
        return Status;
    }

    LSA_UNICODE_STRING PrivilegeString;
    
    PrivilegeString.Length=wcslen(SE_DENY_INTERACTIVE_LOGON_NAME)*sizeof(WCHAR);//Count in bytes
    PrivilegeString.MaximumLength=PrivilegeString.Length+sizeof(WCHAR);//Plus the last \0
    PrivilegeString.Buffer=SE_DENY_INTERACTIVE_LOGON_NAME;

    Status=LsaAddAccountRights( PolicyHandle,       // open policy handle
                                (PSID)pSid,         // target SID
                                &PrivilegeString,   // privileges
                                1);                 // privilege count

    LsaClose(PolicyHandle);

    return Status;
}


STDMETHODIMP CAuthLocalAccount::AssociateEmailWithUser(/*[in]*/BSTR bstrEmailAddr)
{
    //Make sure the user account exist
    DWORD dwRt;
    WCHAR *pAt=NULL;
    if( NULL == bstrEmailAddr)
    {
        return E_POINTER;
    }

    USER_INFO_1 * pUserInfo=NULL;

    pAt=wcschr(bstrEmailAddr, L'@');
    if(pAt)
    {
        *pAt=0;
    }    
    dwRt=NetUserGetInfo(m_bstrServerName,
                        bstrEmailAddr,
                        1,
                       ( LPBYTE *)&pUserInfo);
    if(pAt)
    {
        *pAt=L'@';
    }
    if(NERR_Success==dwRt)
    {
        NetApiBufferFree(pUserInfo);
        return S_OK;
    }
        
    return HRESULT_FROM_WIN32(dwRt);
}

STDMETHODIMP CAuthLocalAccount::UnassociateEmailWithUser(/*[in]*/BSTR bstrEmailAddr)
{
    // Do the same as Associate: Make sure the account exists
    return AssociateEmailWithUser( bstrEmailAddr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\authmethods.h ===
#ifndef __POP3_AUTH_METHODS_H__
#define __POP3_AUTH_METHODS_H__

#include "resource.h"
#include <vector>


struct AUTH_METHOD_INFO
{
    IAuthMethod *pIAuthMethod;
    BSTR  bstrGuid;
    BSTR  bstrName;
    BOOL  bIsValid;
};

typedef AUTH_METHOD_INFO *PAUTH_METHOD_INFO ;
typedef std::vector<PAUTH_METHOD_INFO> AUTHVECTOR;
typedef std::vector<long> AUTHINDEX;

class ATL_NO_VTABLE CAuthMethods : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAuthMethods, &CLSID_AuthMethods>,
    public IDispatchImpl<IAuthMethods, &IID_IAuthMethods, &LIBID_Pop3Auth>
{

public:
    CAuthMethods();
    virtual ~CAuthMethods();

DECLARE_REGISTRY_RESOURCEID(IDR_AUTHMETHODS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAuthMethods)
    COM_INTERFACE_ENTRY(IAuthMethods)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAuthMethods
public:
    STDMETHOD(get_Count)(/*[out]*/ LONG *pVal);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vID, /*[out, retval]*/ IAuthMethod **ppVal);
    STDMETHOD(get__NewEnum)(/*[out, retval]*/ IEnumVARIANT **ppVal);
    STDMETHOD(Add)(/*[in]*/BSTR bstrName, /*[in]*/BSTR bstrGUID);
    STDMETHOD(Remove)(/*[in]*/ VARIANT vID);
    STDMETHOD(Save)(void);
    STDMETHOD(get_CurrentAuthMethod)(/*[out, retval]*/VARIANT *pVal);
    STDMETHOD(put_CurrentAuthMethod)(/*[in]*/ VARIANT vID);
    STDMETHOD(get_MachineName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_MachineName)(/*[in]*/ BSTR newVal);
    STDMETHOD(VerifyCurrentAuthMethod)(int iIndex);


private:
    BOOL Initialize();
    void CleanUp();
    HRESULT CreateObj(PAUTH_METHOD_INFO pAuthInfo, IAuthMethod **ppVal);
    HRESULT VerifyAuthMethod(BSTR bstrGuid);
    BOOL PopulateAuthMethods(WCHAR *wBuffer, DWORD cbSize);
    HRESULT SetMachineRole();
    CRITICAL_SECTION m_csVectorGuard;
    BOOL m_bIsInitialized;
    long m_lCurrentMethodIndex;
    BSTR m_bstrServerName;
    AUTHVECTOR m_AuthVector;
    AUTHINDEX m_Index;
    long m_lMachineRole;
};


#endif//__POP3_AUTH_METHODS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\authmethodsenum.h ===
#ifndef __POP3_AUTH_METHODS_ENUM_H__
#define __POP3_AUTH_METHODS_ENUM_H__

#include "resource.h"
#include "Authmethods.h"


class ATL_NO_VTABLE CAuthMethodsEnum : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAuthMethodsEnum, &CLSID_AuthMethodsEnum>,
    public IEnumVARIANT
{

public:
    CAuthMethodsEnum();
    virtual ~CAuthMethodsEnum();

DECLARE_REGISTRY_RESOURCEID(IDR_AUTHMETHODSENUM)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAuthMethodsEnum)
    COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

//IAuthMethods
public:
    HRESULT STDMETHODCALLTYPE Next( /* [in] */ ULONG celt, /* [length_is][size_is][out] */ VARIANT __RPC_FAR *rgVar, /* [out] */ ULONG __RPC_FAR *pCeltFetched);
    HRESULT STDMETHODCALLTYPE Skip( /* [in] */ ULONG celt);
    HRESULT STDMETHODCALLTYPE Reset( void);
    HRESULT STDMETHODCALLTYPE Clone( /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppEnum);
    
    HRESULT Init( AUTHVECTOR *pAuthVector );

private:
    AUTHVECTOR *m_pAuthVector;
    ULONG m_ulCurrentMethod;

};


#endif//__POP3_AUTH_METHODS_ENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\pop3auth.cpp ===
// Pop3Auth.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f mbconfigps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h> 
#include "Pop3Auth.h"

#include "Pop3Auth_i.c"
#include "AuthMethods.h"
#include "AuthMD5Hash.h"
#include "AuthLocalAccount.h"
#include "AuthDomainAccount.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_AuthMethods, CAuthMethods)
OBJECT_ENTRY(CLSID_AuthLocalAccount, CAuthLocalAccount)
OBJECT_ENTRY(CLSID_AuthDomainAccount, CAuthDomainAccount)
OBJECT_ENTRY(CLSID_AuthMD5Hash, CAuthMD5Hash)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_Pop3Auth);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\authmethodsenum.cpp ===
//Implementation of CAuthMethods class

#include "stdafx.h"
#include "Pop3Auth.h"
#include "AuthMethodsEnum.h"
#include <pop3regkeys.h>

CAuthMethodsEnum::CAuthMethodsEnum()
{
    m_pAuthVector=NULL;
    m_ulCurrentMethod=0;
}

CAuthMethodsEnum::~CAuthMethodsEnum()
{
}

/////////////////////////////////////////////////////////////////////////////
// IEnumVARIANT

STDMETHODIMP CAuthMethodsEnum::Next( /* [in] */ ULONG celt, /* [length_is][size_is][out] */ VARIANT __RPC_FAR *rgVar, /* [out] */ ULONG __RPC_FAR *pCeltFetched)
{
    if ( NULL == rgVar || ( 1 != celt && NULL == pCeltFetched ))
        return E_POINTER;
    if ( NULL == m_pAuthVector )
    {
        return E_FAIL;
    }
    if( celt == 0 )
    {
        return E_INVALIDARG;
    }
    VARIANT vResult;
    VariantInit(&vResult);
    HRESULT hr=E_FAIL;
    while(m_ulCurrentMethod < m_pAuthVector->size() )
    {
        if( ! ((*m_pAuthVector)[m_ulCurrentMethod]->bIsValid) )
        {
            m_ulCurrentMethod++;
        }
    }
    if(m_ulCurrentMethod < m_pAuthVector->size())
    {
        V_VT( &vResult ) = VT_DISPATCH;
        hr=((*m_pAuthVector)[m_ulCurrentMethod])->pIAuthMethod->
               QueryInterface(IID_IDispatch,reinterpret_cast<void**>( &V_DISPATCH( &vResult ) ) );
        if(SUCCEEDED(hr))
        {
            hr=VariantCopy(rgVar, &vResult);
            if(SUCCEEDED(hr))
            {
                if(pCeltFetched)
                {
                    *pCeltFetched=1;
                }
                if(celt > 1)
                {
                    hr=S_FALSE;
                }
                m_ulCurrentMethod++;
            }
            else
            {
                VariantClear(&vResult);
            }
        }

    }
    
    return hr;
}

STDMETHODIMP CAuthMethodsEnum::Skip(ULONG celt)
{
    HRESULT hr = S_OK;
    ULONG ulSize;
    if(m_pAuthVector != NULL)
    {
        ulSize=m_pAuthVector->size();
        if(ulSize < celt + m_ulCurrentMethod )
        {
            m_ulCurrentMethod+=celt;
        }
        else
        {
            m_ulCurrentMethod=ulSize;
        }
    }

    return hr;

}

STDMETHODIMP CAuthMethodsEnum::Reset(void)
{
    m_ulCurrentMethod=0;
    return S_OK;
}

STDMETHODIMP CAuthMethodsEnum::Clone( /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppEnum)
{

    if ( NULL == ppEnum )
    {
        return E_POINTER;
    }
    if ( NULL == m_pAuthVector)
    {
        return E_FAIL;
    }
        
    HRESULT     hr=S_OK;
    CComObject<CAuthMethodsEnum> *pAuthEnum;
    *ppEnum=NULL;
    hr = CComObject<CAuthMethodsEnum>::CreateInstance(&pAuthEnum); // Reference count still 0
    if(SUCCEEDED(hr))
    {
        hr=pAuthEnum->Init(m_pAuthVector);
        if(SUCCEEDED(hr))
        {
            hr=pAuthEnum->QueryInterface(IID_IEnumVARIANT,(void **)(ppEnum)  );
            if(FAILED(hr))
            {
                delete(pAuthEnum);
            }
        }
        if(FAILED(hr))
        {
            delete(pAuthEnum);
        }
    }
        
    return hr;
}


HRESULT CAuthMethodsEnum::Init( AUTHVECTOR *pAuthVector )
{
    if(NULL==pAuthVector)
    {
        return E_INVALIDARG;
    }

    m_ulCurrentMethod=0;
    m_pAuthVector=pAuthVector;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\authutil.h ===
#ifndef __POP3_AUTH_MD5_UTIL_H__
#define __POP3_AUTH_MD5_UTIL_H__

#define UnicodeToAnsi(A, cA, U, cU) WideCharToMultiByte(CP_ACP,0,(U),(cU),(A),(cA),NULL,NULL)
#define AnsiToUnicode(A, cA, U, cU) MultiByteToWideChar(CP_ACP,0,(A),(cA),(U),(cU))

#include <mailbox.h>
#include <Pop3RegKeys.h>
#include <WinCrypt.h>

HRESULT GetMD5Password(BSTR bstrUserName, char szPassword[MAX_PATH])
{
    if(NULL == bstrUserName)
    {
        return E_POINTER;
    }
    WCHAR wszAuthGuid[MAX_PATH];
    BYTE szEncryptedPswd[MAX_PATH];
    DWORD dwEncryptedPswd;
    DWORD dwAuthDataLen=MAX_PATH;
    DWORD dwCryptDataLen;
    HRESULT hr = E_FAIL;
    CMailBox mailboxX;
    HCRYPTPROV hProv=NULL;
    HCRYPTHASH hHash=NULL;
    HCRYPTKEY hKey=NULL;
    

    if ( mailboxX.OpenMailBox( bstrUserName ) )
    {
        if ( mailboxX.LockMailBox())
        {
            if ( mailboxX.GetEncyptedPassword( szEncryptedPswd, MAX_PATH, &dwEncryptedPswd ))
            {
                if(ERROR_SUCCESS == RegQueryAuthGuid(wszAuthGuid, &(dwAuthDataLen)) )
                {
                    
                    if(!CryptAcquireContext(&hProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
                    {
                        goto EXIT;
                    }
                    if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
                    {
                        goto EXIT;
                    }
                    if(!CryptHashData(hHash, (LPBYTE)wszAuthGuid, dwAuthDataLen, 0))
                    {
                        goto EXIT;
                    }
                    if(!CryptDeriveKey(hProv, CALG_RC4, hHash, (128<<16),&hKey))
                    {
                        goto EXIT;
                    }
                    dwCryptDataLen=dwEncryptedPswd;

                    if(CryptDecrypt(hKey, NULL, TRUE, 0, szEncryptedPswd, &dwCryptDataLen))
                    {
                        if(dwCryptDataLen < MAX_PATH -1)
                        {
                           
                            UnicodeToAnsi(szPassword, dwCryptDataLen, (LPCWSTR)szEncryptedPswd, -1);
                            szPassword[dwCryptDataLen]=0;
                            hr=S_OK;
                        }
                    }
                    
                }
            }
            mailboxX.UnlockMailBox();
        }
    }
    else if( GetLastError()==ERROR_ACCESS_DENIED)
    {
        hr=E_ACCESSDENIED;
    }
EXIT:
    if(hKey)
    {
        CryptDestroyKey(hKey);
    }
    if(hHash)
    {
        CryptDestroyHash(hHash);
    }
    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    

    return hr;
}

#endif //__POP3_AUTH_MD5_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Pop3Auth.rc
//
#define IDS_PROJNAME                    100
#define IDS_AUTH_DOMAIN_ACCOUNT         101
#define IDS_AUTH_LOCAL_ACCOUNT          102
#define IDS_AUTH_MD5_HASH               103
#define IDR_AUTHMETHODS                 201
#define IDR_AUTHLOCALACCOUNT            202
#define IDR_AUTHDOMAINACCOUNT           203
#define IDR_AUTHMD5HASH                 204
#define IDS_AUTH_POP3_GROUP             205
#define IDR_AUTHMETHODSENUM		        206

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        301
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         301
#define _APS_NEXT_SYMED_VALUE           301
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3reg\pop3regkeys.cpp ===
/************************************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:    POP3RegKeys.c
Notes:          
History:        
************************************************************************************************/


#include "rpc.h"
#include "rpcndr.h"
#include <assert.h>
#include <rpcdce.h>
#include <windows.h>
#include <tchar.h>
#include "Pop3RegKeys.h"
#include <DSRole.h>
#include <sddl.h>
#include <Aclapi.h>

long RegHKLMOpenKey( LPCTSTR psSubKey, REGSAM samDesired, PHKEY phKey, LPTSTR psMachineName )
{
    long lRC; 
    
    if ( NULL == psMachineName )
        lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, psSubKey, 0, samDesired, phKey );
    else
    {
        HKEY    hKey;
        WCHAR   sBuffer[MAX_PATH];

        if ( 0 < _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L"\\\\%s", psMachineName ))
        {
            lRC = RegConnectRegistry( sBuffer, HKEY_LOCAL_MACHINE, &hKey );
            if ( ERROR_SUCCESS == lRC )
            {
                lRC = RegOpenKeyEx( hKey, psSubKey, 0, samDesired, phKey );
                RegCloseKey( hKey );
            }
        }
        else
            lRC = ERROR_INSUFFICIENT_BUFFER;
    }

    return lRC;
}

long RegQueryDWORD( LPCTSTR lpSubKey, LPCTSTR lpValueName, DWORD *pdwValue, LPTSTR psMachineName /*= NULL*/, bool bDefault /*=false*/, DWORD dwDefault /*=0*/ )
{
    HKEY    hKey;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(DWORD);
    long    lRC;

    
    lRC = RegHKLMOpenKey( lpSubKey, KEY_QUERY_VALUE, &hKey, psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        lRC = RegQueryValueEx( hKey, lpValueName, NULL, &dwType, reinterpret_cast<LPBYTE>( pdwValue ), &dwSize );
        if ( ERROR_FILE_NOT_FOUND == lRC && bDefault )
        {
            *pdwValue = dwDefault;
            lRC = ERROR_SUCCESS;
        }
        RegCloseKey( hKey );
    }
    return lRC;
}

long RegQueryString( LPCTSTR lpSubKey, LPCTSTR lpValueName, LPTSTR psStrBuf, DWORD *pdwSize, LPTSTR psMachineName /*= NULL*/ )
{
    HKEY    hKey;
    DWORD   dwType = REG_SZ;
    long    lRC;
    if(  (NULL == psStrBuf) ||
         (NULL == pdwSize ) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    lRC = RegHKLMOpenKey( lpSubKey, KEY_QUERY_VALUE, &hKey, psMachineName );
    if(ERROR_SUCCESS == lRC )
    {
        lRC = RegQueryValueEx( hKey, lpValueName, 0, &dwType, reinterpret_cast<LPBYTE>( psStrBuf ), pdwSize );
        RegCloseKey( hKey );
    }
    return lRC;
}

long RegSetString( LPCTSTR lpSubKey, LPCTSTR lpValueName, LPTSTR psStrBuf, LPTSTR psMachineName /*= NULL*/ )
{
    HKEY    hKey;
    DWORD   dwType = REG_SZ;
    long    lRC;
    if( NULL == psStrBuf )
    {
        return ERROR_INVALID_PARAMETER;
    }

    lRC = RegHKLMOpenKey( lpSubKey, KEY_QUERY_VALUE, &hKey, psMachineName );
    if(ERROR_SUCCESS == lRC )
    {
        lRC = RegSetValueEx( hKey, lpValueName, 0, dwType, reinterpret_cast<LPBYTE>( psStrBuf ), sizeof(WCHAR)*(wcslen(psStrBuf)+1) );
        RegCloseKey( hKey );
    }
    return lRC;
}

long RegQueryMailRoot( LPTSTR psMailRoot, DWORD dwSize, LPTSTR psMachineName /*= NULL*/ )
{
    assert(!( NULL == psMailRoot ));
    if ( NULL == psMailRoot )
        return ERROR_INVALID_PARAMETER;

    HKEY    hKey;
    DWORD   dwType = REG_SZ;
    long    lRC;

    dwSize *= sizeof( TCHAR );  // dwSize in characters we need bytes for RegQueryValueEx
    lRC = RegHKLMOpenKey( POP3SERVER_SOFTWARE_SUBKEY, KEY_QUERY_VALUE, &hKey, psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        lRC = RegQueryValueEx( hKey, VALUENAME_MAILROOT, 0, &dwType, reinterpret_cast<LPBYTE>( psMailRoot ), &dwSize );
        if ( ERROR_SUCCESS == lRC )
        {
            dwSize = _tcslen( psMailRoot );
            if ( 0 < dwSize && _T('\\') == *( psMailRoot + dwSize - 1 ))
                *( psMailRoot + dwSize - 1 ) = 0x0;
        }   
        RegCloseKey( hKey );
    }
    return lRC;
}

long RegQueryGreeting( LPTSTR psGreeting, DWORD dwSize, LPTSTR psMachineName /*= NULL*/ )
{
    assert(!( NULL == psGreeting ));
    if ( NULL == psGreeting )
        return ERROR_INVALID_PARAMETER;

    HKEY    hKey;
    DWORD   dwType = REG_SZ;
    long    lRC;

    lRC = RegHKLMOpenKey( POP3SERVER_SOFTWARE_SUBKEY, KEY_QUERY_VALUE, &hKey, psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        lRC = RegQueryValueEx( hKey, VALUENAME_GREETING, 0, &dwType, reinterpret_cast<LPBYTE>( psGreeting ), &dwSize );
        RegCloseKey( hKey );
    }
    return lRC;
}


long RegQueryAuthGuid( LPTSTR psAuthGuid, DWORD *pdwSize, LPTSTR psMachineName /*= NULL*/ )
{
    assert(!( NULL == psAuthGuid ));
    assert(!( NULL == pdwSize ));
    if ( NULL == psAuthGuid )
        return ERROR_INVALID_PARAMETER;

    HKEY    hKey;
    DWORD   dwType = REG_SZ;
    long    lRC;

    lRC = RegHKLMOpenKey( POP3SERVER_AUTH_SUBKEY, KEY_QUERY_VALUE, &hKey, psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        lRC = RegQueryValueEx( hKey, VALUENAME_AUTHGUID, 0, &dwType, reinterpret_cast<LPBYTE>( psAuthGuid ), pdwSize );
        RegCloseKey( hKey );
    }
    return lRC;
}

long RegQueryAuthMethod( DWORD& dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVER_AUTH_SUBKEY, VALUENAME_DEFAULTAUTH, &dwValue, psMachineName );
}
    
long RegQueryConfirmAddUser( DWORD& dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVER_SOFTWARE_SUBKEY, VALUENAME_CONFIRM_ADDUSER, &dwValue, psMachineName, true, 1 );
}

long RegQuerySPARequired( DWORD& dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVER_SOFTWARE_SUBKEY, VALUENAME_SPA_REQUIRED, &dwValue, psMachineName, true, 0 );
}

long RegQueryLoggingLevel( DWORD& dwLoggingLevel, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVER_SOFTWARE_SUBKEY, VALUENAME_LOGGINGLEVEL, &dwLoggingLevel, psMachineName );
}

long RegQueryPort( DWORD& dwPort, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_PORT, &dwPort, psMachineName );
}

long RegQuerySocketBacklog( DWORD& dwBacklog, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_BACKLOG, &dwBacklog, psMachineName );
}

long RegQuerySocketMax( DWORD& dwMax, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_MAX, &dwMax, psMachineName );
}

long RegQuerySocketMin( DWORD& dwMin, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_MIN, &dwMin, psMachineName );
}

long RegQuerySocketThreshold( DWORD& dwThreshold, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_THRESHOLD, &dwThreshold, psMachineName );
}

long RegQueryThreadCountPerCPU( DWORD& dwCount, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_THREADCOUNT, &dwCount, psMachineName );
}

long RegQueryCreateUser( DWORD& dwCreateUser, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVER_SOFTWARE_SUBKEY, VALUENAME_CREATE_USER, &dwCreateUser, psMachineName );
}

long RegQueryVersion( DWORD& dwVersion, LPTSTR psMachineName /*= NULL*/ )
{
    return RegQueryDWORD( POP3SERVER_SOFTWARE_SUBKEY, VALUENAME_VERSION, &dwVersion, psMachineName );
}

long RegSetDWORD( LPCTSTR lpSubKey, LPCTSTR lpValueName, DWORD dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    HKEY    hKey;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(DWORD);
    long    lRC;

    lRC = RegHKLMOpenKey( lpSubKey, KEY_SET_VALUE, &hKey, psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        lRC = RegSetValueEx( hKey, lpValueName, 0, dwType, reinterpret_cast<LPBYTE>( &dwValue ), dwSize );
        RegCloseKey( hKey );
    }
    return lRC;
}

long RegSetAuthGuid( LPTSTR psAuthGuid, LPTSTR psMachineName /*= NULL*/ )
{
    assert(!( NULL == psAuthGuid ));
    if ( NULL == psAuthGuid )
        return ERROR_INVALID_PARAMETER;

    HKEY    hKey;
    DWORD   dwType = REG_SZ;
    DWORD   dwSize = (wcslen( psAuthGuid ) +1) * sizeof( WCHAR );
    long    lRC;

    lRC = RegHKLMOpenKey( POP3SERVER_AUTH_SUBKEY, KEY_SET_VALUE, &hKey, psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        lRC = RegSetValueEx( hKey, VALUENAME_AUTHGUID, 0, dwType, reinterpret_cast<LPBYTE>( psAuthGuid ), dwSize );
        RegCloseKey( hKey );
    }
    return lRC;
}

long RegSetMailRoot( LPTSTR psMailRoot, LPTSTR psMachineName /*= NULL*/ )
{
    assert(!( NULL == psMailRoot ));
    if ( NULL == psMailRoot )
        return ERROR_INVALID_PARAMETER;

    HKEY    hKey;
    DWORD   dwType = REG_SZ;
    DWORD   dwSize = (wcslen( psMailRoot ) +1) * sizeof( WCHAR );
    long    lRC;

    lRC = RegHKLMOpenKey( POP3SERVER_SOFTWARE_SUBKEY, KEY_SET_VALUE, &hKey, psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        lRC = RegSetValueEx( hKey, VALUENAME_MAILROOT, 0, dwType, reinterpret_cast<LPBYTE>( psMailRoot ), dwSize );
        RegCloseKey( hKey );
    }
    return lRC;
}


long RegSetGreeting( LPTSTR psGreeting, LPTSTR psMachineName /*= NULL*/ )
{
    assert(!( NULL == psGreeting ));
    if ( NULL == psGreeting )
        return ERROR_INVALID_PARAMETER;

    HKEY    hKey;
    DWORD   dwType = REG_SZ;
    DWORD   dwSize = ( wcslen( psGreeting ) +1 ) * sizeof( WCHAR );
    long    lRC;

    lRC = RegHKLMOpenKey( POP3SERVER_SOFTWARE_SUBKEY, KEY_SET_VALUE, &hKey, psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        lRC = RegSetValueEx( hKey, VALUENAME_GREETING, 0, dwType, reinterpret_cast<LPBYTE>( psGreeting ), dwSize );
        RegCloseKey( hKey );
    }
    return lRC;
}

long RegSetAuthMethod( DWORD dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegSetDWORD( POP3SERVER_AUTH_SUBKEY, VALUENAME_DEFAULTAUTH, dwValue, psMachineName );
}

long RegSetConfirmAddUser( DWORD dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegSetDWORD( POP3SERVER_SOFTWARE_SUBKEY, VALUENAME_CONFIRM_ADDUSER, dwValue, psMachineName );
}

long RegSetSPARequired( DWORD dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegSetDWORD( POP3SERVER_SOFTWARE_SUBKEY, VALUENAME_SPA_REQUIRED , dwValue, psMachineName );
}

long RegSetLoggingLevel( DWORD dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegSetDWORD( POP3SERVER_SOFTWARE_SUBKEY, VALUENAME_LOGGINGLEVEL, dwValue, psMachineName );
}

long RegSetPort( DWORD dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegSetDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_PORT, dwValue, psMachineName );
}

long RegSetSocketBacklog( DWORD dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegSetDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_BACKLOG, dwValue, psMachineName );
}

long RegSetSocketMax( DWORD dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegSetDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_MAX, dwValue, psMachineName );
}

long RegSetSocketMin( DWORD dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegSetDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_MIN, dwValue, psMachineName );
}

long RegSetSocketThreshold( DWORD dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegSetDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_THRESHOLD, dwValue, psMachineName );
}

long RegSetThreadCount( DWORD dwValue, LPTSTR psMachineName /*= NULL*/ )
{
    return RegSetDWORD( POP3SERVICE_SERVICES_SUBKEY, VALUENAME_THREADCOUNT, dwValue, psMachineName );
}

long RegSetCreateUser( DWORD dwCreateUser, LPTSTR psMachineName /*= NULL*/ )
{
    return RegSetDWORD( POP3SERVER_SOFTWARE_SUBKEY, VALUENAME_CREATE_USER, dwCreateUser, psMachineName );
}


long RegSetAuthValues()
{

    HKEY    hKey, hKeyAuth;
    long    lRC;
    DWORD   dwDefaultAuth=0;
    WCHAR   wBuffer[]=_T("14f1665c-e3d3-46aa-884f-ed4cf19d7ad5\0")
                      _T("ef9d811e-36c5-497f-ade7-2b36df172824\0")
                      _T("c395e20c-2236-4af7-b736-54fad07dc526\0")
                      _T("7c295e55-aab1-466d-b589-526fa0ebc397\0");
    DWORD   cbBufSize=sizeof(wBuffer);

    lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, POP3SERVER_SOFTWARE_SUBKEY, 0, KEY_WRITE, &hKey );
    if( ERROR_SUCCESS == lRC )
    {
            lRC = RegCreateKeyEx( hKey, POP3AUTH_SUBKEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyAuth, NULL );
            if( ERROR_SUCCESS == lRC )
            {
                lRC = RegSetValueEx( hKeyAuth, 
                                     VALUENAME_AUTHMETHODS,
                                     NULL,
                                     REG_MULTI_SZ,
                                     (LPBYTE)wBuffer,
                                     cbBufSize );
                if(ERROR_SUCCESS == lRC)
                {
                    lRC = RegSetValueEx( hKeyAuth, 
                                     VALUENAME_DEFAULTAUTH,
                                     NULL,
                                     REG_DWORD,
                                     (LPBYTE)&dwDefaultAuth,
                                     sizeof(DWORD) );
                }
                if(ERROR_SUCCESS == lRC )
                {
                    UUID uuid;
                    WCHAR *wszUuid=NULL;
                    lRC=UuidCreate(&uuid);
                    if(RPC_S_OK == lRC )
                    {
                        lRC=UuidToStringW(&uuid, &wszUuid);
                        if(RPC_S_OK== lRC )
                        {
                            lRC = RegSetValueEx(hKeyAuth,
                                                VALUENAME_AUTHGUID,
                                                NULL,
                                                REG_SZ,
                                                (LPBYTE)wszUuid,
                                                sizeof(WCHAR)*(wcslen(wszUuid)+1) );
                            RpcStringFreeW(&wszUuid);
                        }
                    }
                }
                                         
                RegCloseKey( hKeyAuth);
            }
            RegCloseKey( hKey );
    }

    return lRC;
}


long RegSetEventLogKeys()
{
    long lRC;
    WCHAR wszPath[MAX_PATH]=L"";
    HKEY  hKey, hKey2;
    DWORD dwTypes=7;
    DWORD cbPathSize=0;
    
    if(GetCurrentDirectory(MAX_PATH, wszPath))
    {
        wcscat(wszPath, WSZ_EVENTLOG_FILE_NAME);
        cbPathSize= (wcslen(wszPath)+1)*sizeof(WCHAR);
        lRC=ERROR_SUCCESS;
    }
    else
    {
        lRC=GetLastError();
    }

    if( ERROR_SUCCESS == lRC )
    {
        lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, EVENTLOG_KEY, 0, KEY_WRITE, &hKey );
        if( ERROR_SUCCESS == lRC )
        {
            lRC = RegCreateKeyEx( hKey, POP3SERVICE_SUBKEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey2, NULL );
            if( ERROR_SUCCESS == lRC )
            {
                lRC = RegSetValueEx( hKey2, 
                                     VALUENAME_EVENTMSGFILE,
                                     NULL,
                                     REG_SZ,
                                     (LPBYTE)wszPath,
                                     cbPathSize );
                if(ERROR_SUCCESS == lRC)
                {
                    lRC = RegSetValueEx(hKey2, 
                                        VALUENAME_TYPESSUPPORTED,
                                        NULL,
                                        REG_DWORD,
                                        (LPBYTE)&dwTypes,
                                        sizeof(DWORD) );
                }
                RegCloseKey( hKey2);
            }
            RegCloseKey( hKey );
        }
    }
    return lRC;
}

long RegSetup()
{
    HKEY    hKey, hKeyPOP3;
    long    lRC;

    // Create POP3SERVER_SOFTWARE_SUBKEY
    lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, _T("Software\\Microsoft"), 0, KEY_WRITE, &hKey );
    if( ERROR_SUCCESS == lRC )
    {
        lRC = RegCreateKeyEx( hKey, POP3SERVER_SUBKEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyPOP3, NULL );
        if( ERROR_SUCCESS == lRC )
            RegCloseKey( hKeyPOP3 );
        RegCloseKey( hKey );
    }
    // Create POP3SERVICE_SERVICES_SUBKEY
    if( ERROR_SUCCESS == lRC )
    {
        lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services"), 0, KEY_WRITE, &hKey );
        if( ERROR_SUCCESS == lRC )
        {
            lRC = RegCreateKeyEx( hKey, POP3SERVICE_SUBKEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyPOP3, NULL );
            if( ERROR_SUCCESS == lRC )
                RegCloseKey( hKeyPOP3 );
            RegCloseKey( hKey );
        }
    }

    // Create the Auth key and values
    if( ERROR_SUCCESS == lRC )
    {
        lRC = RegSetAuthValues();
    }
    
    if( ERROR_SUCCESS == lRC )
    {
        lRC = RegSetEventLogKeys();
    }
    
    return lRC;
}

long RegSetupOCM()
{
    HKEY    hKey;
    long    lRC;
    TCHAR   sBuffer[MAX_PATH];
    DWORD   dwPathSize;
    WCHAR wszSDL[MAX_PATH]=L"O:BAG:BAD:PAI(A;OICI;GA;;;BA)(A;OICIIO;GA;;;CO)(A;OICI;KR;;;NS)(A;OICI;KR;;;SY)";
    PSECURITY_DESCRIPTOR pSD=NULL;
    ULONG lSize=0;
    if(!ConvertStringSecurityDescriptorToSecurityDescriptorW(
          wszSDL,
          SDDL_REVISION_1,
          &pSD,
          &lSize))
    {
        lRC = GetLastError();
    }

    // EventLogKeys
    ZeroMemory(sBuffer, sizeof(sBuffer));
    lRC = GetModuleFileName( GetModuleHandle( P3ADMIN_MODULENAME ), sBuffer, sizeof(sBuffer)/sizeof(TCHAR) -1 );
    if ( 0 < lRC )
    {
        // Strip off the module file name and replace with pop3evt.dll
        LPTSTR ps = _tcsrchr( sBuffer, _T( '\\' ));
        if ( NULL != ps )
        {
            _tcscpy( ps, WSZ_EVENTLOG_FILE_NAME );
            dwPathSize = ( _tcslen( sBuffer ) + 1 ) * sizeof(TCHAR);
            lRC = ERROR_SUCCESS;
        }
        else
            lRC = ERROR_PATH_NOT_FOUND;
        if( ERROR_SUCCESS == lRC )
        {   // Pop3Svc
            lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, POP3SERVICE_EVENTLOG_KEY, 0, KEY_WRITE, &hKey );
            if( ERROR_SUCCESS == lRC )
            {
                lRC = RegSetValueEx( hKey, VALUENAME_EVENTMSGFILE, NULL, REG_SZ, reinterpret_cast<LPBYTE>( sBuffer ), dwPathSize );
                if( ERROR_SUCCESS == lRC )
                    lRC = RegSetValueEx( hKey, VALUENAME_CATEGORYMSGFILE, NULL, REG_SZ, reinterpret_cast<LPBYTE>( sBuffer ), dwPathSize );
                RegCloseKey( hKey );
            }
        }
        if( ERROR_SUCCESS == lRC )
        {   // POP3 Server
            lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, POP3SERVER_EVENTLOG_KEY, 0, KEY_WRITE, &hKey );
            if( ERROR_SUCCESS == lRC )
            {
                lRC = RegSetValueEx( hKey, VALUENAME_EVENTMSGFILE, NULL, REG_SZ, reinterpret_cast<LPBYTE>( sBuffer ), dwPathSize );
                if( ERROR_SUCCESS == lRC )
                    lRC = RegSetValueEx( hKey, VALUENAME_CATEGORYMSGFILE, NULL, REG_SZ, reinterpret_cast<LPBYTE>( sBuffer ), dwPathSize );
                RegCloseKey( hKey );
            }
        }
        if( ERROR_SUCCESS == lRC )
        {   // POP3 Server
            _tcscpy( ps, WSZ_PERFDLL_FILE_NAME );
            dwPathSize = ( _tcslen( sBuffer ) + 1 ) * sizeof(TCHAR);
            lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, POP3SERVICE_SERVICES_PERF_SUBKEY, 0, KEY_WRITE, &hKey );
            if( ERROR_SUCCESS == lRC )
            {
                lRC = RegSetValueEx( hKey, VALUENAME_PERF_LIBRARY, NULL, REG_SZ, reinterpret_cast<LPBYTE>( sBuffer ), dwPathSize );
                RegCloseKey( hKey );
            }
        }
    }
    else
        lRC = ERROR_PATH_NOT_FOUND;

    // Auth GUID
    if ( ERROR_SUCCESS == lRC )
        lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, POP3SERVER_AUTH_SUBKEY, 0, KEY_ALL_ACCESS, &hKey );
    if ( ERROR_SUCCESS == lRC )
    {
        UUID uuid;
        TCHAR *szUuid=NULL;
        
        lRC = UuidCreate(&uuid);
        if(RPC_S_OK == lRC )
        {
            lRC = UuidToString(&uuid, &szUuid);
            if( RPC_S_OK == lRC )
            {
                lRC = RegSetValueEx( hKey, VALUENAME_AUTHGUID, NULL, REG_SZ, (LPBYTE)szUuid, sizeof(TCHAR)*(_tcslen(szUuid)+1) );
                RpcStringFree(&szUuid);
            }
            if(ERROR_SUCCESS == lRC)
            {   //Set the ACLs for the AUTH key
                lRC = RegSetKeySecurity( hKey, DACL_SECURITY_INFORMATION, pSD );
            }
            RegCloseKey( hKey );
        }
    }

    if( ERROR_SUCCESS == lRC )
    {
        lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, POP3SERVICE_SERVICES_SUBKEY, 0, KEY_ALL_ACCESS, &hKey );
        if( ERROR_SUCCESS == lRC )
        {
            // Set ACLs for pop3 service key
            lRC = RegSetKeySecurity( hKey, DACL_SECURITY_INFORMATION, pSD );
        }
        RegCloseKey(hKey);
    }


    if( ERROR_SUCCESS == lRC )
    {
        //Set default auth method to AD if the box is a DC
        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pMachineRole=NULL;
        //Check the Role of the machine
        if( ERROR_SUCCESS== (lRC=
            DsRoleGetPrimaryDomainInformation(
                            NULL,
                            DsRolePrimaryDomainInfoBasic,
                            (PBYTE *)(&pMachineRole))) )
        {
            if(pMachineRole->MachineRole == DsRole_RoleBackupDomainController ||
               pMachineRole->MachineRole == DsRole_RolePrimaryDomainController||
               pMachineRole->MachineRole == DsRole_RoleMemberServer )
            {
                //This is DC or a member server, set default auth to AD (1)
                // 0:SAM  1:AD  2:Encrypted Password
                lRC = RegSetDWORD(POP3SERVER_AUTH_SUBKEY, VALUENAME_DEFAULTAUTH, 1 );
            }                                   
            DsRoleFreeMemory(pMachineRole);  
            
        }
    }
    if( ERROR_SUCCESS == lRC )
    {
        lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, POP3SERVER_SOFTWARE_SUBKEY, 0, KEY_ALL_ACCESS, &hKey );
        if( ERROR_SUCCESS == lRC )
        {
            // Set ACLs for pop3 server key
            lRC = RegSetKeySecurity( hKey, DACL_SECURITY_INFORMATION, pSD );
            // Create InstallDir and ConsoleFile values
            if( ERROR_SUCCESS == lRC )
            {
                TCHAR sBuffer[MAX_PATH+1]=_T("");
                if( 0==GetSystemDirectory(sBuffer, sizeof(sBuffer)/sizeof(TCHAR)) )
                {
                    lRC = GetLastError();
                }
                if( ERROR_SUCCESS == lRC )
                {
                    lRC = RegSetValueEx( hKey, VALUENAME_CONSOLE_FILE, NULL, REG_SZ, (LPBYTE)sBuffer, sizeof(TCHAR)*(_tcslen(sBuffer)+1) );
                }
                if( ERROR_SUCCESS == lRC )
                {
                    if(_tcslen(sBuffer)+_tcslen(WSZ_POP3_SERVER_DIR) <= MAX_PATH)
                    {
                        _tcscat(sBuffer, WSZ_POP3_SERVER_DIR);
                        lRC = RegSetValueEx( hKey, VALUENAME_INSTALL_DIR, NULL, REG_SZ, (LPBYTE)sBuffer, sizeof(TCHAR)*(_tcslen(sBuffer)+1) );
                    }
                    else
                    {
                        lRC = ERROR_BAD_ENVIRONMENT;
                    }
                }
                
            }
    
            RegCloseKey(hKey);
        }
    }
    if(pSD)
    {
        LocalFree(pSD);
    }
    
    return lRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3auth\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__122FFAC7_F1D2_429A_9F62_8DDE9547E3DA__INCLUDED_)
#define AFX_STDAFX_H__122FFAC7_F1D2_429A_9F62_8DDE9547E3DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <windows.h>
#include <atlbase.h>
#include <lm.h>
#include <AuthID.h>
#include <pop3server.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__122FFAC7_F1D2_429A_9F62_8DDE9547E3DA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\pop3reg\pop3regkeys.h ===
/************************************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:    POP3RegKeys.h
Notes:          
History:        
************************************************************************************************/

#ifndef __POP3REGKEYS_H_
#define __POP3REGKEYS_H_

#define POP3SERVER_SUBKEY                   _T("POP3 Service")
#define POP3SERVICE_SUBKEY                  _T("Pop3svc")
#define EVENTLOG_KEY                        _T("System\\CurrentControlSet\\Services\\Eventlog\\Application\\")
#define POP3SERVER_EVENTLOG_KEY             _T("System\\CurrentControlSet\\Services\\Eventlog\\Application\\") POP3SERVER_SUBKEY
#define POP3SERVICE_EVENTLOG_KEY            _T("System\\CurrentControlSet\\Services\\Eventlog\\Application\\") POP3SERVICE_SUBKEY
#define POP3SERVICE_SERVICES_SUBKEY         _T("System\\CurrentControlSet\\Services\\") POP3SERVICE_SUBKEY
#define POP3SERVICE_SERVICES_PERF_SUBKEY    _T("System\\CurrentControlSet\\Services\\") POP3SERVICE_SUBKEY _T("\\Performance")
#define POP3SERVER_SOFTWARE_SUBKEY          _T("Software\\Microsoft\\") POP3SERVER_SUBKEY
#define POP3AUTH_SUBKEY                     _T("Auth")
#define POP3SERVER_AUTH_SUBKEY              POP3SERVER_SOFTWARE_SUBKEY _T("\\") POP3AUTH_SUBKEY

#define VALUENAME_LOGGINGLEVEL              _T("Logging Level")
#define VALUENAME_MAILROOT                  _T("MailRoot")
#define VALUENAME_PORT                      _T("POP3Port")
#define VALUENAME_BACKLOG                   _T("SocketBacklog")
#define VALUENAME_MIN                       _T("MinNumberOfSockets")
#define VALUENAME_MAX                       _T("MaxNumberOfSockets")
#define VALUENAME_THRESHOLD                 _T("SocketsThreshold")
#define VALUENAME_THREADCOUNT               _T("ThreadCountPerCPU")
#define VALUENAME_AUTHMETHODS               _T("AuthMethods")
#define VALUENAME_DEFAULTAUTH               _T("DefaultAuthMethod")
#define VALUENAME_AUTHGUID                  _T("AuthGUID")
#define VALUENAME_EVENTMSGFILE              _T("EventMessageFile")
#define VALUENAME_CATEGORYMSGFILE           _T("CategoryMessageFile")
#define VALUENAME_TYPESSUPPORTED            _T("TypesSupported")
#define VALUENAME_MAXMSG_PERDOWNLOAD        _T("MaxMessagesPerDownload")
#define VALUENAME_PERF_LIBRARY              _T("Library")
#define VALUENAME_CREATE_USER               _T("CreateUser")
#define VALUENAME_GREETING                  _T("Greeting")
#define VALUENAME_VERSION                   _T("Version")
#define VALUENAME_SOCK_VERSION              _T("IPVersion")
#define VALUENAME_SPA_REQUIRED              _T("RequireSPA")
#define VALUENAME_CONFIRM_ADDUSER           _T("ConfirmAddUser")
#define VALUENAME_INSTALL_DIR               _T("InstallDir")
#define VALUENAME_CONSOLE_FILE              _T("ConsoleFile")
#define WSZ_POP3_SERVER_DIR                 _T("\\Pop3Server")
#define WSZ_EVENTLOG_FILE_NAME              _T("\\Pop3Evt.dll")
#define WSZ_PERFDLL_FILE_NAME               _T("\\Pop3Perf.dll")
#define P3ADMIN_MODULENAME                  _T( "P3Admin.dll" )

long RegQueryAuthGuid( LPTSTR psAuthGuid, DWORD *pdwSize, LPTSTR psMachineName = NULL );
long RegQueryAuthMethod( DWORD& dwAuthMethod, LPTSTR psMachineName = NULL );
long RegQueryMailRoot( LPTSTR psMailRoot, DWORD dwSize, LPTSTR psMachineName = NULL );
long RegQueryLoggingLevel( DWORD& dwLoggingLevel, LPTSTR psMachineName = NULL );
long RegQueryPort( DWORD& dwPort, LPTSTR psMachineName = NULL );
long RegQuerySocketBacklog( DWORD& dwBacklog, LPTSTR psMachineName = NULL );
long RegQuerySocketMax( DWORD& dwMax, LPTSTR psMachineName = NULL );
long RegQuerySocketMin( DWORD& dwMin, LPTSTR psMachineName = NULL );
long RegQuerySocketThreshold( DWORD& dwThreshold, LPTSTR psMachineName = NULL );
long RegQueryThreadCountPerCPU( DWORD& dwCount, LPTSTR psMachineName = NULL );
long RegQueryCreateUser( DWORD& dwCreateUser, LPTSTR psMachineName = NULL );
long RegQueryGreeting( LPTSTR psGreeting, DWORD dwSize, LPTSTR psMachineName = NULL );
long RegQueryVersion( DWORD& dwVersion, LPTSTR psMachineName = NULL );
long RegQuerySPARequired( DWORD& dwValue, LPTSTR psMachineName = NULL );
long RegQueryConfirmAddUser( DWORD& dwValue, LPTSTR psMachineName = NULL );

long RegSetAuthGuid( LPTSTR psAuthGuid, LPTSTR psMachineName = NULL );
long RegSetAuthMethod( DWORD dwValue, LPTSTR psMachineName = NULL );
long RegSetLoggingLevel( DWORD dwValue, LPTSTR psMachineName = NULL );
long RegSetMailRoot( LPTSTR psMailRoot, LPTSTR psMachineName = NULL );
long RegSetPort( DWORD dwValue, LPTSTR psMachineName = NULL );
long RegSetSocketBacklog( DWORD dwValue, LPTSTR psMachineName = NULL );
long RegSetSocketMax( DWORD dwValue, LPTSTR psMachineName = NULL );
long RegSetSocketMin( DWORD dwValue, LPTSTR psMachineName = NULL );
long RegSetSocketThreshold( DWORD dwValue, LPTSTR psMachineName = NULL );
long RegSetThreadCount( DWORD dwValue, LPTSTR psMachineName = NULL );
long RegSetCreateUser( DWORD dwCreateUser, LPTSTR psMachineName = NULL );
long RegSetGreeting( LPTSTR psGreeting, LPTSTR psMachineName = NULL );
long RegSetSPARequired( DWORD dwValue, LPTSTR psMachineName = NULL );
long RegSetConfirmAddUser( DWORD dwValue, LPTSTR psMachineName = NULL );

long RegSetup();
long RegSetupOCM();
    
long RegQueryDWORD( LPCTSTR lpSubKey, LPCTSTR lpValueName, DWORD *pdwValue, LPTSTR psMachineName = NULL, bool bDefault = false, DWORD dwDefault = 0 );
long RegSetDWORD( LPCTSTR lpSubKey, LPCTSTR lpValueName, DWORD dwValue, LPTSTR psMachineName = NULL );
long RegQueryString( LPCTSTR lpSubKey, LPCTSTR lpValueName, LPTSTR psStrBuf, DWORD *pdwSize, LPTSTR psMachineName = NULL );
long RegSetString( LPCTSTR lpSubKey, LPCTSTR lpValueName, LPTSTR psStrBuf, LPTSTR psMachineName = NULL );

long RegHKLMOpenKey( LPCTSTR psSubKey, REGSAM samDesired, PHKEY phKey, LPTSTR psMachinName );
    
#endif //__POP3REGKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\util\util.h ===
//-----------------------------------------------------------------------------
// util.h
//-----------------------------------------------------------------------------

#ifndef _UTIL_H
#define _UTIL_H

//-----------------------------------------------------------------------------
// includes
//-----------------------------------------------------------------------------
#include <sbs6base.h>
#include <shlobj.h>
#include <tchar.h>

//-----------------------------------------------------------------------------
// file/directory/machine
//-----------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE BDeleteDirTree( const TCHAR *szDir, BOOL bDeleteInputDir=TRUE );

#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\util\makefile.inc ===
postprocess:
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\smtp\storedriver\adjusttokenprivileges.h ===
// AdjustTokenPrivileges.h: interface for the CAdjustTokenPrivileges class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ADJUSTTOKENPRIVILEGES_H__032C8A47_665B_46A2_89BC_0818BB3AB1E0__INCLUDED_)
#define AFX_ADJUSTTOKENPRIVILEGES_H__032C8A47_665B_46A2_89BC_0818BB3AB1E0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CAdjustTokenPrivileges  
{
public:
    CAdjustTokenPrivileges( );
    virtual ~CAdjustTokenPrivileges();

// Implementation
public:
    DWORD AdjustPrivileges( LPCTSTR lpPrivelegeName, DWORD dwAttributes );
    DWORD DuplicateProcessToken( LPCTSTR lpPrivelegeName, DWORD dwAttributes );
    DWORD ResetToken();
    DWORD SetToken();
    
// Attributes
protected:
    DWORD   m_dwAttributesPrev;
    bool    m_bImpersonation;
    LUID    m_luid;
    HANDLE  m_hToken;
    HANDLE  m_hTokenDuplicate;

};

#endif // !defined(AFX_ADJUSTTOKENPRIVILEGES_H__032C8A47_665B_46A2_89BC_0818BB3AB1E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\smtp\storedriver\csimpledriver.h ===
// CSimpleDriver.h : Declaration of the CSimpleDriver

#ifndef __CSIMPLEDRIVER_H_
#define __CSIMPLEDRIVER_H_

#include "resource.h"       // main symbols
#include <mailmsg.h>
#include <seo.h>

#include "AdjustTokenPrivileges.h"
#include <eventlogger.h>

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);

class CEventLogger; // forward declaration
class CPOP3DropDir; // forward declaration

/////////////////////////////////////////////////////////////////////////////
// CStoreDriverCriticalSection
class CStoreDriverCriticalSection
{
public:
    CStoreDriverCriticalSection()
    {
        InitializeCriticalSection(&s_csStoreDriver);     // returns void
    }
    virtual ~CStoreDriverCriticalSection()
    {
        DeleteCriticalSection(&s_csStoreDriver);     // returns void
    }

// Attributes
public:
    CRITICAL_SECTION s_csStoreDriver;
};

/////////////////////////////////////////////////////////////////////////////
// CSimpleDriver
class ATL_NO_VTABLE CSimpleDriver : 
    public ISMTPStoreDriver,
    public IEventIsCacheable,
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComCoClass<CSimpleDriver, &CLSID_CPOP3SMTPStoreDriver>
{
    friend CPOP3DropDir;
    
public:
    CSimpleDriver();
    virtual ~CSimpleDriver();
    
DECLARE_REGISTRY_RESOURCEID(IDR_CSIMPLEDRIVER)

    HRESULT FinalConstruct() {
        return S_OK;
    }

    HRESULT InternalAddRef() {
        return CComObjectRootEx<CComMultiThreadModelNoCS>::InternalAddRef();
    }

    HRESULT InternalRelease() {
        return CComObjectRootEx<CComMultiThreadModelNoCS>::InternalRelease();
    }

public:

    //
    // ISMTPStoreDriver
    //
    HRESULT STDMETHODCALLTYPE Init( DWORD dwInstance, IUnknown *pBinding, IUnknown *pServer, DWORD dwReason, IUnknown **ppStoreDriver );
    HRESULT STDMETHODCALLTYPE PrepareForShutdown( DWORD dwReason );
    HRESULT STDMETHODCALLTYPE Shutdown( DWORD dwReason );
    HRESULT STDMETHODCALLTYPE LocalDelivery( IMailMsgProperties *pMsg, DWORD dwRecipCount, DWORD *pdwRecipIndexes, IMailMsgNotify *pNotify );
    HRESULT STDMETHODCALLTYPE EnumerateAndSubmitMessages( IMailMsgNotify *pNotify );
    // do the actual work for a local delivery
    HRESULT DoLocalDelivery( IMailMsgProperties *pMsg, DWORD dwRecipCount, DWORD *pdwRecipIndexes );

    //
    // IEventIsCacheable
    //
    // This lets SEO know that they can hold onto our object when
    // it is not actively in use
    //
    HRESULT STDMETHODCALLTYPE IsCacheable() { return S_OK; }

BEGIN_COM_MAP(CSimpleDriver)
    COM_INTERFACE_ENTRY(ISMTPStoreDriver)
    COM_INTERFACE_ENTRY(IEventIsCacheable)
END_COM_MAP()

// Implementation
public:
    void LogEvent( LOGTYPE Type, DWORD dwEventID ) { m_EventLoggerX.LogEvent( Type, dwEventID );}
    void LogEvent( LOGTYPE Type, DWORD dwEventID, DWORD dwError ) { m_EventLoggerX.LogEvent( Type, dwEventID, 0, NULL, 0, sizeof( dwError ), &dwError );}
        
//Attributes
protected:
    char                    m_szComputerName[MAX_PATH];
    BOOL                    m_fInit;
    long                    m_lPrepareForShutdown;
    CEventLogger            m_EventLoggerX;
    CAdjustTokenPrivileges  m_AdjustTokenPrivilegesX;

    static DWORD            s_dwCounter;        // Used to create unique mail file names
    static CSimpleDriver    *s_pStoreDriver;
};

#endif //__CSIMPLEDRIVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\smtp\storedriver\csimpledriver.cpp ===
// CSimpleDriver.cpp : Implementation of CCSimpleDriver
#include "stdafx.h"
#include "SimpleDriver.h"
#include "CSimpleDriver.h"

#include "POP3DropDir.h"
#include <stdio.h>
#include "mailmsgprops.h"

#include <IMFUtil.h>
#include <MailBox.h>
#include <POP3Events.h>
#include <POP3Server.h>
#include <POP3RegKeys.h>
//#include <winerror.h>

/////////////////////////////////////////////////////////////////////////////
// CCSimpleDriver

CStoreDriverCriticalSection g_oSDCS;
CSimpleDriver *CSimpleDriver::s_pStoreDriver = NULL;
DWORD CSimpleDriver::s_dwCounter = 0;

/////////////////////////////////////////////////////////////////////////////
// constructor/destructor

CSimpleDriver::CSimpleDriver() :
    m_fInit(FALSE), m_lPrepareForShutdown(0)
{
    m_szComputerName[0] = 0x0;
}

CSimpleDriver::~CSimpleDriver() 
{
    EnterCriticalSection(&g_oSDCS.s_csStoreDriver);
    if (s_pStoreDriver == this) 
        s_pStoreDriver = NULL;
    LeaveCriticalSection(&g_oSDCS.s_csStoreDriver);
}

/////////////////////////////////////////////////////////////////////////////
// ISMTPStoreDriver

HRESULT CSimpleDriver::Init( DWORD /*dwInstance*/, IUnknown* /*pBinding*/, IUnknown* /*pServer*/, DWORD /*dwReason*/, IUnknown **ppStoreDriver )
{
    if (m_fInit) return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    if ( 0 != m_lPrepareForShutdown ) return HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);

#if DBG == 1
    TCHAR   buf[255];

    _stprintf(buf, _T( "new CSimpleDriver 0x%x, refcount = %x\n" ), this);
    OutputDebugString(buf);
#endif

    EnterCriticalSection(&g_oSDCS.s_csStoreDriver);                         // returns void

    // smtpsvc may call the Init function on a store driver multiple
    // times for the same instance.  It expects an initialized
    // store driver to be returned via ppStoreDriver.  To prevent
    // multiple store drivers from being created for the same instance
    // we use s_pStoreDriver to hold a pointer to the one valid 
    // store driver.  If this variable is currently NULL then we create
    // a store driver which we can return.
    //
    // If a store driver needs to support being used by multiple 
    // SMTP instances then you need to maintain a list of store drivers,
    // one per instance.  
    if (!s_pStoreDriver) 
    {
        DWORD   dwSize, dwRC;
        DWORD   dwLoggingLevel = 3;
        CMailBox mailboxX;

        mailboxX.SetMailRoot(); // Do this to refresh the static CMailBox::m_szMailRoot

        assert( NULL == s_pStoreDriver );

        dwSize = sizeof( m_szComputerName );
        GetComputerNameA( m_szComputerName, &dwSize );
        m_fInit = TRUE;
        s_pStoreDriver = this;
        m_EventLoggerX.InitEventLog( POP3_SERVER_NAME, EVENTCAT_POP3STOREDRIVER );
        if ( ERROR_SUCCESS == RegQueryLoggingLevel( dwLoggingLevel ))
            m_EventLoggerX.SetLoggingLevel( dwLoggingLevel );
        m_EventLoggerX.LogEvent( LOGTYPE_INFORMATION, POP3_SMTPSINK_STARTED );
        // Duplicate the Process token we'll need it to ENABLE SE_RESTORE_NAME privileges when creating mail
        dwRC = m_AdjustTokenPrivilegesX.DuplicateProcessToken( SE_RESTORE_NAME, SE_PRIVILEGE_ENABLED );
        if ( ERROR_SUCCESS != dwRC )
            m_EventLoggerX.LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_DUPLICATEPROCESSTOKEN_FAILED, dwRC );
    }

    // tell it about the one good store driver
    s_pStoreDriver->AddRef();
    *ppStoreDriver = (IUnknown *) (ISMTPStoreDriver*) s_pStoreDriver;
    // in failure case handles are cleaned up in destructor
    LeaveCriticalSection(&g_oSDCS.s_csStoreDriver);

    return S_OK;
}

HRESULT CSimpleDriver::PrepareForShutdown( DWORD /*dwReason*/ )
{
    InterlockedExchange( &m_lPrepareForShutdown, 1 );
    return S_OK;
}

HRESULT CSimpleDriver::Shutdown( DWORD /*dwReason*/ )
{
    if (m_fInit) 
        m_fInit = FALSE;
    m_EventLoggerX.LogEvent( LOGTYPE_INFORMATION, POP3_SMTPSINK_STOPPED );

    return S_OK;
}

// 
// This function directly called DoLocalDelivery in the simple case, or 
// adds the local delivery request to the queue if we support async
// requests
//
HRESULT CSimpleDriver::LocalDelivery(
                IMailMsgProperties *pIMailMsgProperties,
                DWORD dwRecipCount,
                DWORD *pdwRecipIndexes,
                IMailMsgNotify *pNotify
                )
{
    if ( NULL == pIMailMsgProperties || NULL == pdwRecipIndexes ) return E_INVALIDARG;

    HRESULT hr;
    
    if ( NULL == pNotify )
    {   // do the local delivery - synchronously
        hr = DoLocalDelivery(pIMailMsgProperties, dwRecipCount, pdwRecipIndexes);
    }
    else
    {   // do the local delivery - asynchronously
        CPOP3DropDir *pDropDirX = new CPOP3DropDir( pIMailMsgProperties, dwRecipCount, pdwRecipIndexes, pNotify );
        
        if ( NULL != pDropDirX )
        {
            hr  = pDropDirX->DoLocalDelivery();
            if ( MAILMSG_S_PENDING != hr )
                delete pDropDirX;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

HRESULT CSimpleDriver::DoLocalDelivery(
                IMailMsgProperties *pIMailMsgProperties,
                DWORD dwRecipCount,
                DWORD *pdwRecipIndexes
                )
{
    HRESULT hr = S_OK;  //STOREDRV_E_RETRY;
    HRESULT hr2;
    DWORD   i;
    WCHAR   wszAddress[MAX_PATH];
    char    szAddress[MAX_PATH];
    DWORD   dwRecipFlags;
    WCHAR   wszStoreFileName[MAX_PATH * 2];
    HANDLE  hf;
    PFIO_CONTEXT pfio;
    CMailBox mailboxX;
    IMailMsgRecipients *pIMailMsgRecipients;
    SYSTEMTIME st;

    GetLocalTime( &st );
    if (SUCCEEDED(hr))
    {
        hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients, (void **) &pIMailMsgRecipients);
        if (SUCCEEDED(hr))
        {
            for (i = 0; (SUCCEEDED(hr)) && (i < dwRecipCount); i++) 
            {
                hr = pIMailMsgRecipients->GetStringA(pdwRecipIndexes[i], IMMPID_RP_ADDRESS_SMTP, sizeof(szAddress), szAddress);
                if (SUCCEEDED(hr)) 
                {

                    if(0 == MultiByteToWideChar(CP_ACP,0, szAddress, -1, wszAddress, sizeof(wszAddress)/sizeof(WCHAR)))
                    {
                        hr=HRESULT_FROM_WIN32( GetLastError() );
                    } 
                    else if ( mailboxX.OpenMailBox( wszAddress ))
                    {
                        swprintf( wszStoreFileName, L"%s%04u%02u%02u%02u%02u%02u%04u%08x", 
                            MAILBOX_PREFIX_W, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, InterlockedIncrement( reinterpret_cast<PLONG>( &s_dwCounter )) );
                        hf = mailboxX.CreateMail( wszStoreFileName, FILE_FLAG_OVERLAPPED|FILE_FLAG_WRITE_THROUGH|FILE_FLAG_SEQUENTIAL_SCAN );
                        if ( INVALID_HANDLE_VALUE != hf )
                        {
                            pfio = AssociateFile( hf );
                            if ( NULL != pfio )
                            {
                                hr = pIMailMsgProperties->CopyContentToFileEx( pfio, TRUE, NULL );
                                if FAILED( hr )
                                    m_EventLoggerX.LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_COPYCONTENTTOFILE_FAILED, hr );
                                ReleaseContext( pfio );
                            }
                            else
                            {
                                m_EventLoggerX.LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_ASSOCIATEFILE_FAILED, GetLastError() );
                                CloseHandle( hf );
                            }
                            if ( ERROR_SUCCESS != mailboxX.CloseMail( NULL, FILE_FLAG_OVERLAPPED ))
                            {
                                m_EventLoggerX.LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_CLOSEMAIL_FAILED );
                                hr = (SUCCEEDED(hr)) ? E_FAIL : hr;
                            }
                        }
                        else
                            m_EventLoggerX.LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_CREATEMAIL_FAILED, GetLastError() );
                        mailboxX.CloseMailBox();
                        if (SUCCEEDED(hr)) 
                        {
                            hr2 = pIMailMsgRecipients->GetDWORD( pdwRecipIndexes[i], IMMPID_RP_RECIPIENT_FLAGS, &dwRecipFlags );
                            if SUCCEEDED( hr2 )
                            {
                                dwRecipFlags |= RP_DELIVERED;   // mark the recipient as delivered
                                hr2 = pIMailMsgRecipients->PutDWORD( pdwRecipIndexes[i], IMMPID_RP_RECIPIENT_FLAGS, dwRecipFlags );
                                if FAILED( hr2 )
                                    m_EventLoggerX.LogEvent( LOGTYPE_ERR_WARNING, POP3_SMTPSINK_PUT_IMMPID_RP_RECIPIENT_FLAGS_FAILED, hr2 );
                            }
                            else
                                m_EventLoggerX.LogEvent( LOGTYPE_ERR_WARNING, POP3_SMTPSINK_GET_IMMPID_RP_RECIPIENT_FLAGS_FAILED, hr2 );
                        }
                    }
                    else
                    {
                        hr2 = pIMailMsgRecipients->GetDWORD( pdwRecipIndexes[i], IMMPID_RP_RECIPIENT_FLAGS, &dwRecipFlags );
                        if SUCCEEDED( hr2 )
                        {
                            dwRecipFlags |= RP_FAILED;   // mark the recipient as failed
                            hr2 = pIMailMsgRecipients->PutDWORD( pdwRecipIndexes[i], IMMPID_RP_RECIPIENT_FLAGS, dwRecipFlags );
                            if FAILED( hr2 )
                                m_EventLoggerX.LogEvent( LOGTYPE_ERR_WARNING, POP3_SMTPSINK_PUT_IMMPID_RP_RECIPIENT_FLAGS_FAILED, hr2 );
                        }
                        else
                            m_EventLoggerX.LogEvent( LOGTYPE_ERR_WARNING, POP3_SMTPSINK_GET_IMMPID_RP_RECIPIENT_FLAGS_FAILED, hr2 );
                    }
                }
                else
                    m_EventLoggerX.LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_GET_IMMPID_RP_ADDRESS_SMTP_FAILED, hr );
            }
            pIMailMsgRecipients->Release();
        }
        else
            m_EventLoggerX.LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_QI_MAILMSGRECIPIENTS_FAILED, hr );
    }

    return hr;
}

HRESULT CSimpleDriver::EnumerateAndSubmitMessages( IMailMsgNotify* /*pNotify*/ )
{
    return S_OK;
}

#include "mailmsg_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\smtp\storedriver\pop3dropdir.cpp ===
// POP3DropDir.cpp: implementation of the POP3DropDir class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "POP3DropDir.h"

#include "SimpleDriver.h"
#include "CSimpleDriver.h"
#include "mailmsgprops.h"

#include <POP3Events.h>
#include <POP3Server.h>
#include <POP3RegKeys.h>

VOID POP3DropDirReadCompletion( PFIO_CONTEXT pContext, PFH_OVERLAPPED lpo, DWORD cbRead, DWORD dwCompletionStatus );
VOID POP3DropDirWriteCompletion( PFIO_CONTEXT pContext, PFH_OVERLAPPED lpo, DWORD cbWritten, DWORD dwCompletionStatus );

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPOP3DropDir::CPOP3DropDir( IMailMsgProperties *pIMailMsgProperties, DWORD dwRecipCount, DWORD *pdwRecipIndexes, IMailMsgNotify *pIMailMsgNotify ) :
    m_pIMailMsgProperties(pIMailMsgProperties), m_pIMailMsgNotify(pIMailMsgNotify), m_pIMailMsgBind(NULL), m_pIMailMsgRecipients(NULL),
    m_pdwRecipIndexes(NULL), m_dwRecipCount(dwRecipCount), m_dwRecipCurrent(0), m_hr( S_OK ), m_enumBWS( NA )
{
    ZeroMemory( &m_OverlappedRead, sizeof( m_OverlappedRead ));
    ZeroMemory( &m_OverlappedWrite, sizeof( m_OverlappedWrite ));
    m_sStoreFileName[0] = 0;
    m_PFIOContextWrite = NULL;
    if ( NULL != m_pIMailMsgProperties )
        m_pIMailMsgProperties->AddRef();
    if ( NULL != m_pIMailMsgNotify )
        m_pIMailMsgNotify->AddRef();
    if ( 0 != dwRecipCount )
    {
        m_pdwRecipIndexes = new DWORD[dwRecipCount];
        if ( NULL != m_pdwRecipIndexes )
            memcpy( m_pdwRecipIndexes, pdwRecipIndexes, sizeof( DWORD ) * dwRecipCount );
        else
            m_hr = E_OUTOFMEMORY;
    }
    else
        m_hr = E_UNEXPECTED;
    if ( NULL == CSimpleDriver::s_pStoreDriver )
        m_hr = E_POINTER;
}

CPOP3DropDir::~CPOP3DropDir()
{
    if ( SUCCEEDED( m_hr ))
        MailboxAndContextCleanup( false ); // No value in checking return codes
    else
    {
        MailboxAndContextCleanup( true ); // No value in checking return codes
        CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_WARNING, POP3_SMTPSINK_MESSAGEDELIVERY_FAILED, m_hr );
    }

    if ( NULL != m_pdwRecipIndexes )
        delete [] m_pdwRecipIndexes;
    if ( NULL != m_pIMailMsgRecipients )
        m_pIMailMsgRecipients->Release();
    if ( NULL != m_pIMailMsgBind )
    {
        m_pIMailMsgBind->ReleaseContext();
        m_pIMailMsgBind->Release();
    }
    if ( NULL != m_pIMailMsgProperties )
        m_pIMailMsgProperties->Release();
    if ( NULL != m_pIMailMsgNotify )
    {
        m_pIMailMsgNotify->Notify( m_hr );
        m_pIMailMsgNotify->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// Implementation - public
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// DoLocalDelivery, public
//
// Purpose: 
//    Initiate the asynchronous delivery of the current recipient
//
// Returns: MAILMSG_S_PENDING on success, an appropriate HRESULT otherwise
HRESULT CPOP3DropDir::DoLocalDelivery()
{
    HRESULT hr = m_hr;
    
    // May contain error from constructor
    if ( S_OK == hr )   // Get the FIO_CONTEXT for the mail message
    {
        hr = m_pIMailMsgProperties->QueryInterface( IID_IMailMsgBind, reinterpret_cast<LPVOID*>( &m_pIMailMsgBind ));
        if ( S_OK == hr )
            hr = m_pIMailMsgBind->GetBinding( &m_PFIOContextRead, NULL );
    }
    
    if ( S_OK == hr )
    {
        hr = m_pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients, reinterpret_cast<LPVOID*>( &m_pIMailMsgRecipients));
        if ( S_OK == hr ) // About to go Async (CopyMailToDropDir), don't use member variables anymore
        {
            do
            {
                hr = CopyMailToDropDir();
            }
            while ( ERROR_INVALID_MESSAGEDEST == hr );
        }
        else
            CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_QI_MAILMSGRECIPIENTS_FAILED, hr );
    }
    if ( S_OK == hr )
        return MAILMSG_S_PENDING;
    else if ( FAILED( hr ))
        SetHr( hr );

    // There was an error so we don't need the Notify interface, release it right now so we don't do it incorrectly in the destrustructor
    if ( NULL != m_pIMailMsgNotify )
    {
        m_pIMailMsgNotify->Release();
        m_pIMailMsgNotify = NULL;
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// Implementation - private
//////////////////////////////////////////////////////////////////////

HRESULT CPOP3DropDir::CopyMailToDropDir()
{
    HRESULT hr = E_FAIL;
    HANDLE  hf = INVALID_HANDLE_VALUE;
    DWORD   dwRecipFlags, dwRC;
    IMailMsgRecipients *pIMailMsgRecipients;
    SYSTEMTIME st;
    char szRecpEmailName[sizeof(m_sRecipEmailName)/sizeof(WCHAR)];
    GetLocalTime( &st );
    if ( m_dwRecipCurrent < m_dwRecipCount )
    {
        hr = m_pIMailMsgRecipients->GetStringA(m_pdwRecipIndexes[m_dwRecipCurrent], IMMPID_RP_ADDRESS_SMTP, sizeof(szRecpEmailName), szRecpEmailName);
        if ( S_OK == hr ) 
        {
            if ( 0 == MultiByteToWideChar( CP_ACP, 0, szRecpEmailName, -1, m_sRecipEmailName, sizeof(m_sRecipEmailName)/sizeof(WCHAR) ))
                hr = HRESULT_FROM_WIN32( GetLastError() );
            else if ( m_mailboxX.OpenMailBox( m_sRecipEmailName ))
            {
                swprintf( m_sStoreFileName, L"%s%04u%02u%02u%02u%02u%02u%04u%08x.eml", 
                    MAILBOX_PREFIX_W, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, InterlockedIncrement( reinterpret_cast<PLONG>( &CSimpleDriver::s_dwCounter )) );
                dwRC = CSimpleDriver::s_pStoreDriver->m_AdjustTokenPrivilegesX.SetToken();
                if ( ERROR_SUCCESS != dwRC )
                {
                    CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_SETTHREADTOKEN_FAILED, dwRC );
                    hr = HRESULT_FROM_WIN32( dwRC );
                }
                hf = m_mailboxX.CreateMail( m_sStoreFileName, FILE_FLAG_OVERLAPPED|FILE_FLAG_SEQUENTIAL_SCAN );
                dwRC = CSimpleDriver::s_pStoreDriver->m_AdjustTokenPrivilegesX.ResetToken();    // Safe to call even if SetToken failed
                if ( ERROR_SUCCESS != dwRC )
                {
                    CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_RESETTHREADTOKEN_FAILED, dwRC );
                    m_hr = HRESULT_FROM_WIN32( dwRC );
                }
                if ( INVALID_HANDLE_VALUE != hf )
                {   
                    m_PFIOContextWrite = AssociateFile( hf );
                    if ( NULL != m_PFIOContextWrite )
                    {   // Okay let's start the Asynchronous operations - Read first
                        m_i64ReadOffset = m_i64WriteOffset = 0;
                        hr = ReadFile( m_sBuffer, PRIVATE_OPTIMAL_BUFFER_SIZE );
                    }
                    else
                    {
                        CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_ASSOCIATEFILE_FAILED );
                        CloseHandle( hf );  // Will get deleted in desstructor
                        hr = E_FAIL;
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    if ( HRESULT_FROM_WIN32( ERROR_DISK_FULL ) == hr )
                    {
                        CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_INFORMATION, POP3_SMTPSINK_MESSAGEDELIERY_FAILED_OUTOFDISK, ERROR_DISK_FULL );
                        hr = ERROR_INVALID_MESSAGEDEST;  // Quota (or really a disk) failure continue with next recipient
                    }
                    else
                    {
                        if ( S_OK == hr ) hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                        CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_CREATEMAIL_FAILED, hr );
                    }
                }
            }
            else
                hr = ERROR_INVALID_MESSAGEDEST;   // Continue with next recipient!

            if ( S_OK != hr )
            {
                MarkRecipient( RP_FAILED );    // No value in checking return codes
                MailboxAndContextCleanup( true ); // No value in checking return codes
                m_dwRecipCurrent++; // Completion routine will re-initiate process for next recipient.
                if ( ERROR_INVALID_MESSAGEDEST == hr )
                {
                    if ( isAllRecipientsProcessed() )
                        hr = S_FALSE;
                }
            }
        }
        else
            CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_GET_IMMPID_RP_ADDRESS_SMTP_FAILED, hr );
    }
    
    return hr;
}

BYTE g_Matrix[256] = { 0,0,0,0,0,0,0,0,0,0,2,0,0,3,0,0, // 00-0F
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 10-1F
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0, // 20-2F
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 30-3F
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 40-4F
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 50-5F
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 60-6F
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 70-7F
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 80-8F
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 90-9F
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // A0-AF
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // B0-BF
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // C0-CF
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // D0-DF
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // E0-EF
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  // F0-FF
                     };  

HRESULT CPOP3DropDir::DotStuffBuffer( LPVOID *ppbBuffer, LPDWORD pdwSize )
{
    if ( NULL == ppbBuffer || NULL == pdwSize )
        return E_INVALIDARG;
    if ( 0 == *pdwSize )
        return E_INVALIDARG;
    
    DWORD   dwSize = *pdwSize;
    bool    bStuff = false;
    CHAR    *pbBuffer = static_cast<CHAR*>( *ppbBuffer );
    CHAR    *pToEnd = m_sBuffer + sizeof( m_sBuffer );
    CHAR    *pFromEnd = pbBuffer + dwSize;
    CHAR    *pToStart, *pFromStart = NULL;
    CHAR    *pChar;

    for ( pChar = pbBuffer + dwSize - 3; pChar > pbBuffer + 2; pChar -= 3 )
    {
        if ( g_Matrix[static_cast<BYTE>(*pChar)] )
        {   // Found a '\r' '\n' or '.'
            pChar += g_Matrix[static_cast<BYTE>(*pChar)] - 1;  // Start at the Dot
            if ( (0xd == *(pChar-2)) && (0xa == *(pChar-1)) && (0x2e == *(pChar)) )
            {   // Stuff Required
                pFromStart = pChar;         // Start copy at the Dot
                pToStart = pToEnd - ( pFromEnd - pFromStart );
                memmove( pToStart, pFromStart, pFromEnd - pFromStart );
                pToStart--;
                *pToStart = 0x2e;           // Dot stuff
                dwSize++;
                // Reset the pointers
                pFromEnd = pFromStart;
                pToEnd = pToStart;
            }
        }
    }
    if ( NULL != pFromStart )   // Have we Dot stuffed anything yet?
        *pFromStart = 0x0;      // yes.
    pChar = pbBuffer;
    if ( g_Matrix[static_cast<BYTE>(*pChar)] )
    {
        if ( (BufferWrapSequence::CR == m_enumBWS) && (0xa == *pChar) && (0x2e == *(pChar+1)) )
            pFromStart = pChar + 1; // Start at the Dot
        else if ( (BufferWrapSequence::CRLF == m_enumBWS) && (0x2e == *pChar) )
            pFromStart = pChar;     // Start at the Dot
        else if ( (0xd == *pChar) && (0xa == *(pChar+1)) && (0x2e == *(pChar+2)) )
            pFromStart = pChar+2;   // Start at the Dot
    }
    if ( NULL != pFromStart && 0x0 != *pFromStart )
    {   // 1 more stuff required
        pToStart = pToEnd - ( pFromEnd - pFromStart );
        memmove( pToStart, pFromStart, pFromEnd - pFromStart );
        pToStart--;
        *pToStart = 0x2e;       // Dot stuff
        dwSize++;
        // Reset the pointers
        pFromEnd = pFromStart;
        pToEnd = pToStart;
    }
    if ( NULL != pFromStart )
    {   // Need to move the beginning of the buffer
        pFromEnd = pFromStart;
        pFromStart = pbBuffer;
        if ( pFromStart != pFromEnd )
        {
            pToStart = pToEnd - ( pFromEnd - pFromStart );
            memmove( pToStart, pFromStart, pFromEnd - pFromStart );
        }
        *ppbBuffer = pToStart;
        *pdwSize = dwSize;
    }
    // Update the Buffer Wrap Sequence
    if ( 0x0d == *( static_cast<CHAR*>(*ppbBuffer) + dwSize - 1))
        m_enumBWS = BufferWrapSequence::CR;
    else if ( 0x0d == *( static_cast<CHAR*>(*ppbBuffer) + dwSize - 2) && 0x0a == *( static_cast<CHAR*>(*ppbBuffer) + dwSize - 1) )
        m_enumBWS = BufferWrapSequence::CRLF;
    else
        m_enumBWS = BufferWrapSequence::NA;

    return S_OK;
}

HRESULT CPOP3DropDir::MailboxAndContextCleanup( bool bDeleteMailFile )
{
    HRESULT hr = S_OK;
    
    if ( NULL != m_PFIOContextWrite )
    {
        if ( ERROR_SUCCESS != m_mailboxX.CloseMail( m_PFIOContextWrite->m_hFile,FILE_FLAG_OVERLAPPED ))
        {
            CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_CLOSEMAIL_FAILED );
            hr = E_FAIL;
        }
        ReleaseContext( m_PFIOContextWrite );   // no return void!
        m_PFIOContextWrite = NULL;
    }
    if ( bDeleteMailFile && 0 != m_sStoreFileName[0] )
        m_mailboxX.DeleteMail( m_sStoreFileName );
    m_mailboxX.CloseMailBox();              // no return void!

    return hr;
}

HRESULT CPOP3DropDir::MarkRecipient( DWORD dwMark )
{
    HRESULT hr;
    DWORD   dwRecipFlags;
    
    hr = m_pIMailMsgRecipients->GetDWORD( m_pdwRecipIndexes[m_dwRecipCurrent], IMMPID_RP_RECIPIENT_FLAGS, &dwRecipFlags );
    if ( S_OK == hr )
    {
        dwRecipFlags |= dwMark;   // mark the recipient as failed
        hr = m_pIMailMsgRecipients->PutDWORD( m_pdwRecipIndexes[m_dwRecipCurrent], IMMPID_RP_RECIPIENT_FLAGS, dwRecipFlags );
        if ( S_OK != hr )
            CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_WARNING, POP3_SMTPSINK_PUT_IMMPID_RP_RECIPIENT_FLAGS_FAILED, hr );
    }
    else
        CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_WARNING, POP3_SMTPSINK_GET_IMMPID_RP_RECIPIENT_FLAGS_FAILED, hr );

    return hr;
}

HRESULT CPOP3DropDir::ReadFile( IN LPVOID pBuffer, IN DWORD cbSize )
{
    if ( NULL == pBuffer || 0 == cbSize )
        return E_INVALIDARG;
    
    HRESULT hr = S_OK;

    m_OverlappedRead.Overlapped.Offset = LODWORD( m_i64ReadOffset );
    m_OverlappedRead.Overlapped.OffsetHigh = HIDWORD( m_i64ReadOffset );
    m_OverlappedRead.Overlapped.pfnCompletion = POP3DropDirReadCompletion;
    m_OverlappedRead.ThisPtr = (PVOID)this;

    BOOL bRC = FIOReadFile( m_PFIOContextRead, pBuffer, cbSize, &m_OverlappedRead.Overlapped);
    if( !bRC )
    {
        DWORD dwErr = GetLastError();
        
        if ( ERROR_IO_PENDING != dwErr )
        {
            hr = HRESULT_FROM_WIN32( dwErr );
            if ( dwErr == ERROR_HANDLE_EOF )
            {   // Cleanup            
                HRESULT hr2;
                
                hr2 = MarkRecipient( RP_DELIVERED );
                if ( S_OK != hr2 )
                    hr = hr2;
                hr2 = MailboxAndContextCleanup( false );
                if ( S_OK != hr2 )
                    hr = hr2;
                m_dwRecipCurrent++; // Completion routine will re-initiate process for next recipient.
            }
            else
            {
                CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_READFILE_FAILED, dwErr );
                // Cleanup            
                MarkRecipient( RP_FAILED );    // No value in checking return codes
                MailboxAndContextCleanup( true ); // No value in checking return codes
                m_dwRecipCurrent++; // Completion routine will re-initiate process for next recipient.
            }
        }
    }

    return hr;
}

HRESULT CPOP3DropDir::ReadFileCompletion( DWORD cbSize, DWORD dwErr, PFH_OVERLAPPED lpo )
{
    HRESULT hr = S_OK;

    if (( NO_ERROR != dwErr ) && ( ERROR_HANDLE_EOF != dwErr ))
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_WARNING, POP3_SMTPSINK_READFILE_FAILED, dwErr );
        // Cleanup            
        MarkRecipient( RP_FAILED );    // No value in checking return codes
        MailboxAndContextCleanup( true ); // No value in checking return codes
        m_dwRecipCurrent++; // Completion routine will re-initiate process for next recipient.
    }
    else
    {
        if ( ERROR_HANDLE_EOF == dwErr && 0 == cbSize )
        {   // Cleanup            
            HRESULT hr2;
            
            hr2 = MarkRecipient( RP_DELIVERED );
            if ( S_OK != hr2 )
                hr = hr2;
            hr2 = MailboxAndContextCleanup( (S_OK == hr) ? false : true );
            if ( S_OK != hr2 )
                hr = hr2;
            m_dwRecipCurrent++; // Completion routine will re-initiate process for next recipient.
            if ( S_OK == hr )
                hr = HRESULT_FROM_WIN32( ERROR_HANDLE_EOF ); // Already done reading the file, nothing else to write
        }
        else
        {
            m_i64ReadOffset += cbSize;
            // Asynchronous operation - Write
            hr = WriteFile( m_sBuffer, cbSize );
        }
    }

    return hr;
}

HRESULT CPOP3DropDir::WriteFile( IN LPVOID pBuffer, IN DWORD cbSize )
{
    if ( NULL == pBuffer || 0 == cbSize )
        return E_INVALIDARG;
    
    HRESULT hr = S_OK;

    hr = DotStuffBuffer( &pBuffer, &cbSize );
    if ( S_OK == hr )
    {
        m_OverlappedWrite.Overlapped.Offset = LODWORD( m_i64WriteOffset );
        m_OverlappedWrite.Overlapped.OffsetHigh = HIDWORD( m_i64WriteOffset );
        m_OverlappedWrite.Overlapped.pfnCompletion = POP3DropDirWriteCompletion;
        m_OverlappedWrite.ThisPtr = (PVOID)this;
        
        BOOL bRC = FIOWriteFile( m_PFIOContextWrite, pBuffer, cbSize, &m_OverlappedWrite.Overlapped);
        if( !bRC )
        {
            DWORD dwErr = GetLastError();
            
            if( dwErr != ERROR_IO_PENDING )
            {
                hr = HRESULT_FROM_WIN32( dwErr );
                if ( ERROR_DISK_FULL == dwErr )
                    CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_INFORMATION, POP3_SMTPSINK_MESSAGEDELIERY_FAILED_OUTOFDISK, dwErr );
                else
                    CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_WRITEFILE_FAILED, dwErr );
                // Cleanup            
                MarkRecipient( RP_FAILED );    // No value in checking return codes
                MailboxAndContextCleanup( true ); // No value in checking return codes
                m_dwRecipCurrent++; // Completion routine will re-initiate process for next recipient.
            }
        }
    }

    return hr;
}

HRESULT CPOP3DropDir::WriteFileCompletion( DWORD cbSize, DWORD dwErr, PFH_OVERLAPPED lpo )
{
    HRESULT hr = S_OK;

    if (( dwErr != NO_ERROR ))
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        if ( ERROR_DISK_FULL == dwErr )
            CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_INFORMATION, POP3_SMTPSINK_MESSAGEDELIERY_FAILED_OUTOFDISK, dwErr );
        else
            CSimpleDriver::s_pStoreDriver->LogEvent( LOGTYPE_ERR_CRITICAL, POP3_SMTPSINK_WRITEFILE_FAILED, dwErr );
        // Cleanup            
        MarkRecipient( RP_FAILED );    // No value in checking return codes
        MailboxAndContextCleanup( true ); // No value in checking return codes
        m_dwRecipCurrent++; // Completion routine will re-initiate process for next recipient.
    }
    else
    {
        m_i64WriteOffset += cbSize;
        // Asynchronous operation - Read
        hr = ReadFile( m_sBuffer, PRIVATE_OPTIMAL_BUFFER_SIZE );
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////
// Other
//////////////////////////////////////////////////////////////////////

VOID POP3DropDirReadCompletion( PFIO_CONTEXT pContext, PFH_OVERLAPPED lpo, DWORD cbRead, DWORD dwCompletionStatus )
{
    if ( NULL == lpo ) return;
    POP3DROPDIR_OVERLAPPED *p = reinterpret_cast<POP3DROPDIR_OVERLAPPED*>( lpo );
    CPOP3DropDir *pThis = static_cast<CPOP3DropDir*>( p->ThisPtr );

    HRESULT hr = pThis->ReadFileCompletion( cbRead, dwCompletionStatus, lpo );
    if ( S_OK != hr )
    {
        if ( HRESULT_FROM_WIN32( ERROR_HANDLE_EOF ) == hr )
        {
            if ( pThis->isAllRecipientsProcessed( ))    // More recipients to process?
            {
                hr = S_OK;
                delete pThis;   // Were done!
            }
            else
                hr = pThis->NextRecipientCopyMailToDropDir();
        }
        if ( S_OK != hr )
        {
            pThis->SetHr( hr ); // Unexpected completion, set the error
            delete pThis;   // Were done!
        }
    }
}

VOID POP3DropDirWriteCompletion( PFIO_CONTEXT pContext, PFH_OVERLAPPED lpo, DWORD cbWritten, DWORD dwCompletionStatus )
{
    if ( NULL == lpo ) return;
    POP3DROPDIR_OVERLAPPED *p = reinterpret_cast<POP3DROPDIR_OVERLAPPED*>( lpo );
    CPOP3DropDir *pThis = static_cast<CPOP3DropDir*>( p->ThisPtr );

    HRESULT hr = pThis->WriteFileCompletion( cbWritten, dwCompletionStatus, lpo );
    if ( S_OK != hr )
    {
        if ( pThis->isAllRecipientsProcessed( ))    // More recipients to process?
        {
            hr = S_OK;
            delete pThis;   // Were done!
        }
        else
            hr = pThis->NextRecipientCopyMailToDropDir();
        if ( S_OK != hr )
        {
            pThis->SetHr( hr ); // Unexpected completion, set the error
            delete pThis;   // Were done!
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\smtp\storedriver\adjusttokenprivileges.cpp ===
// AdjustTokenPrivileges.cpp: implementation of the CAdjustTokenPrivileges class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AdjustTokenPrivileges.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAdjustTokenPrivileges::CAdjustTokenPrivileges() :
    m_dwAttributesPrev(0), m_bImpersonation(false), m_hToken(INVALID_HANDLE_VALUE), m_hTokenDuplicate(INVALID_HANDLE_VALUE)
{
}
    
CAdjustTokenPrivileges::~CAdjustTokenPrivileges()
{
    if ( m_bImpersonation )
        RevertToSelf(); // Deletes the thread token so there is no need to reset the TokenPrivilege
    else if ( INVALID_HANDLE_VALUE != m_hToken )
    {
        TOKEN_PRIVILEGES TokenPrivileges;
        DWORD   dwRC = GetLastError();

        TokenPrivileges.PrivilegeCount = 1;
        TokenPrivileges.Privileges[0].Luid = m_luid;
        TokenPrivileges.Privileges[0].Attributes = m_dwAttributesPrev;
        //adjust the privlige to this new privilege
        AdjustTokenPrivileges( m_hToken, FALSE, &TokenPrivileges, sizeof( TOKEN_PRIVILEGES ), NULL, NULL );
        CloseHandle( m_hToken );
        if ( ERROR_SUCCESS != dwRC )    // Preserve any error code
            SetLastError( dwRC );
    }
    if ( INVALID_HANDLE_VALUE != m_hTokenDuplicate )
        CloseHandle( m_hTokenDuplicate );
}

//////////////////////////////////////////////////////////////////////
// Implementation : public
//////////////////////////////////////////////////////////////////////

DWORD CAdjustTokenPrivileges::AdjustPrivileges( LPCTSTR lpPrivelegeName, DWORD dwAttributes )
{
    //local variables
    TOKEN_PRIVILEGES TokenPrivileges, TokenPrivilegesOld;
    DWORD   dwRC = ERROR_SUCCESS, dwSize = sizeof( TokenPrivilegesOld );

    if ( !LookupPrivilegeValue( NULL, lpPrivelegeName, &m_luid ))
        dwRC  = GetLastError();
    if ( ERROR_SUCCESS == dwRC )
    {   // open the token of the current process
        if ( !OpenThreadToken( GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &m_hToken ))
        {   
            dwRC = GetLastError();
            if ( ERROR_NO_TOKEN == dwRC )
            {// There's no impersonation let's impersonate self so we can make this work
                if ( ImpersonateSelf( SecurityImpersonation ))
                {
                    if ( OpenThreadToken( GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &m_hToken ))
                    {
                        dwRC = ERROR_SUCCESS;
                        m_bImpersonation = true;
                    }
                    else
                    {
                        dwRC = GetLastError();
                        RevertToSelf(); // Already have an error, don't want to overwrite if this fails
                    }
                }
                else
                    dwRC = GetLastError();
            }
        }
    }
    if ( ERROR_SUCCESS == dwRC )
    {    // Set up the privilege set we will need
        TokenPrivileges.PrivilegeCount = 1;
        TokenPrivileges.Privileges[0].Luid = m_luid;
        TokenPrivileges.Privileges[0].Attributes = dwAttributes;
        //adjust the privlige to this new privilege
        if ( AdjustTokenPrivileges( m_hToken, FALSE, &TokenPrivileges, sizeof( TOKEN_PRIVILEGES ), &TokenPrivilegesOld, &dwSize ))
            m_dwAttributesPrev = TokenPrivilegesOld.Privileges[0].Attributes;
        dwRC  = GetLastError(); // We need to check the return code regardless of what AdjustTokenPrivileges returns
        // AdjustTokenPrivileges set last error to ERROR_SUCCESS if it set all specified privileges!
    }
    if ( dwRC != ERROR_SUCCESS )
    {
        CloseHandle( m_hToken );
        m_hToken = INVALID_HANDLE_VALUE;
    }
    
    return dwRC;
}


DWORD CAdjustTokenPrivileges::DuplicateProcessToken( LPCTSTR lpPrivelegeName, DWORD dwAttributes )
{
    DWORD dwRC = ERROR_SUCCESS;
    HANDLE hToken;
    HANDLE hTokenThread = INVALID_HANDLE_VALUE;
    
    if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_DUPLICATE, &hToken ))
        dwRC = GetLastError();
    if ( ERROR_SUCCESS == dwRC )
    {
        if ( !DuplicateToken( hToken, SecurityImpersonation, &m_hTokenDuplicate ))
            dwRC = GetLastError();
        CloseHandle( hToken );
    }
    if ( ERROR_SUCCESS == dwRC )
    {
        if ( !OpenThreadToken( GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &hTokenThread ))
        {   
            dwRC = GetLastError();
            if ( ERROR_NO_TOKEN == dwRC )
            {
                dwRC = ERROR_SUCCESS;
                hTokenThread = INVALID_HANDLE_VALUE;
            }
        }
    }
    if ( ERROR_SUCCESS == dwRC )
    {
        if ( SetThreadToken( NULL, m_hTokenDuplicate ))
        {
            dwRC = AdjustPrivileges( SE_RESTORE_NAME, SE_PRIVILEGE_ENABLED );
            m_hToken = INVALID_HANDLE_VALUE;    // This is really the m_hTokenDuplicate, don't want to Close in the destructor
            if ( !SetThreadToken( NULL, NULL ))
            {
                if ( ERROR_SUCCESS == dwRC )    // Don't overwrite existing error code
                    dwRC = GetLastError();
            }
        }
        else
            dwRC = GetLastError();
    }
    if ( INVALID_HANDLE_VALUE != hTokenThread )
    {
        if ( !SetThreadToken( NULL, hTokenThread ))
            dwRC = GetLastError();
        CloseHandle( hTokenThread );
    }
        
    return dwRC;
}

/////////////////////////////////////////////////////////////////////////////
// ResetThreadToken, public
//
// Purpose: 
//    Use the Duplicate process token to enable privileges for the thread.
//    If the Thread already has a token (unexpected) then adjust the privileges.
//
// Arguments:
//
// Returns: TRUE on success, FALSE otherwise
DWORD CAdjustTokenPrivileges::ResetToken()
{
    DWORD dwRC = ERROR_SUCCESS;
    HANDLE hToken;
    
    if ( INVALID_HANDLE_VALUE != m_hTokenDuplicate && INVALID_HANDLE_VALUE == m_hToken )
    {
        if ( !SetThreadToken( NULL, NULL ))
            dwRC = GetLastError();
    }
    else
        dwRC = ERROR_NO_TOKEN;
        
    return dwRC;
}


/////////////////////////////////////////////////////////////////////////////
// SetThreadToken, public
//
// Purpose: 
//    Use the Duplicated process token to enable privileges for the thread.
//    If the Thread already has a token (unexpected) then adjust the privileges.
//
// Arguments:
//
// Returns: TRUE on success, FALSE otherwise
DWORD CAdjustTokenPrivileges::SetToken()
{
    DWORD dwRC = ERROR_SUCCESS;
    HANDLE hToken;
    
    if ( INVALID_HANDLE_VALUE != m_hTokenDuplicate )
    {
        if ( OpenThreadToken( GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &hToken ))
        {   // The thread already has a token, let's work with it
            CloseHandle( hToken );
            dwRC = AdjustPrivileges( SE_RESTORE_NAME, SE_PRIVILEGE_ENABLED );
        }
        else
        {   // Let's use are duplicate token
            if ( ERROR_NO_TOKEN == GetLastError() )
            {
                if ( !SetThreadToken( NULL, m_hTokenDuplicate ))
                    dwRC = GetLastError();
            }
            else
                dwRC = GetLastError();
        }
    }
    else
        dwRC = ERROR_NO_TOKEN;
        
    return dwRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\shared\util\util.cpp ===
//-----------------------------------------------------------------------------
// Util.cpp
//-----------------------------------------------------------------------------

#include "util.h"
#include "assert.h"

#define ASSERT assert

//-----------------------------------------------------------------------------
// Takes a const TCHAR * adds a BS if necessary and converts
// it to a TSTRING
//
// 1/11/2000    paolora     added to new util.cpp
//-----------------------------------------------------------------------------
TSTRING StrAddBS( const TCHAR *szDirIn )
{
    ASSERT( szDirIn );
    if (!szDirIn || !_tcslen( szDirIn ))
        return _T("");

    TSTRING str = szDirIn;

    // Do another MBCS ANSI safe comparison
    const TCHAR *szTemp = szDirIn;
    const UINT iSize = _tcsclen( szDirIn ) - 1;
    for( UINT ui = 0; ui < iSize; ui++ )
        szTemp = CharNext( szTemp );

    if (_tcsncmp( szTemp, _T("\\"), 1))
        str += _T("\\");

    return str;
}


//-----------------------------------------------------------------------------
// Takes a const TSTRING and adds a BS if necessary
//
// 1/13/2000    paolora     added to new util.cpp
//-----------------------------------------------------------------------------
void AddBS( TSTRING *strDir )
{
    ASSERT( strDir );
    if (!strDir || !strDir->length())
        return;

    *strDir = StrAddBS( strDir->c_str() );
    return;
}


//-----------------------------------------------------------------------------
// Takes a const TCHAR * and deletes all the dirs and files below and
// including the input directory
//
// 12/11/2000   paolora     added to new util.cpp
//-----------------------------------------------------------------------------
BOOL BDeleteDirTree( const TCHAR *szDir, BOOL bDeleteInputDir /*=TRUE*/ )
{
    ASSERT( szDir );
    if (!szDir || !_tcslen( szDir ))
        return FALSE;

    // Create the findfirstfile path
    TSTRING strDir = szDir;
    AddBS( &strDir );
    strDir += (TSTRING)_T("*");
    
    // Find the first file
    BOOL bFileFound;
    TSTRING strItem = szDir;
    WIN32_FIND_DATA ffd;
    HANDLE hItem = FindFirstFile( strDir.c_str(), &ffd );
    if(hItem && (INVALID_HANDLE_VALUE != hItem))
        bFileFound = TRUE;
    
    // While files and dirs exist
    while( bFileFound )
    {
        if (_tcscmp( ffd.cFileName, _T(".")) && _tcscmp( ffd.cFileName, _T("..") ))
        {
            // Create item name
            strItem = szDir;
            AddBS( &strItem );
            strItem += (TSTRING)ffd.cFileName;
            
            // If a Dir, recurse
            if (FILE_ATTRIBUTE_DIRECTORY & ffd.dwFileAttributes)
            {
                if (!BDeleteDirTree( strItem.c_str(), TRUE ))
                {
                    FindClose( hItem );
                    return FALSE;
                }
            }
            // Then a file, delete it
            else if (!DeleteFile( strItem.c_str() ))
            {
                FindClose( hItem );
                return FALSE;
            }
        }
        bFileFound = FindNextFile( hItem, &ffd );
    }

    // Close the find handle
    if(hItem && (INVALID_HANDLE_VALUE != hItem))
        FindClose( hItem );

    // Remove the present directory
    if (bDeleteInputDir)
    {
        if (!RemoveDirectory( szDir ))
            return FALSE;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\smtp\storedriver\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\smtp\storedriver\pop3dropdir.h ===
// POP3DropDir.h: interface for the POP3DropDir class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __POP3DROPDIR_H_
#define __POP3DROPDIR_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <mailbox.h>
#include <mailmsg.h>
#include <seo.h>
#include <eventlogger.h>

#define LODWORD(i64) (DWORD)(0xffffffff&(i64))
#define HIDWORD(i64) (DWORD)(((unsigned __int64)(i64))>>32)
#define PRIVATE_OPTIMAL_BUFFER_SIZE             64 * 1024   // From smtp\server\dropdir.h
#define OPTIMAL_BUFFER_W_DOTSTUFFING_PAD        PRIVATE_OPTIMAL_BUFFER_SIZE * 4/3 + 1 // worst case every \r\n. sequence would be expanded to \r\n..

typedef struct _POP3DROPDIR_OVERLAPPED
{
    FH_OVERLAPPED       Overlapped;
    PVOID               ThisPtr;
}   POP3DROPDIR_OVERLAPPED, *PPOP3DROPDIR_OVERLAPPED;


class CPOP3DropDir  
{
public:
    CPOP3DropDir( IMailMsgProperties *pIMailMsgProperties, DWORD dwRecipCount, DWORD *pdwRecipIndexes, IMailMsgNotify *pIMailMsgNotify );
    virtual ~CPOP3DropDir();
private:
    CPOP3DropDir(){;}  // Hide default constructor

// Implementation
public:
    HRESULT DoLocalDelivery();
    bool isAllRecipientsProcessed( ){ return (m_dwRecipCurrent < m_dwRecipCount ) ? false : true; }
    HRESULT NextRecipientCopyMailToDropDir(){ HRESULT hr;  do{ hr = CopyMailToDropDir(); } while ( ERROR_INVALID_MESSAGEDEST == hr );  return hr; }
    HRESULT ReadFileCompletion( DWORD cbSize, DWORD dwErr, PFH_OVERLAPPED lpo );
    HRESULT SetHr( HRESULT hr ){ return m_hr = FAILED(hr) ? hr : m_hr; }
    HRESULT WriteFileCompletion( DWORD cbSize, DWORD dwErr, PFH_OVERLAPPED lpo );
    
protected:
    HRESULT CopyMailToDropDir();
    HRESULT DotStuffBuffer( LPVOID *ppBuffer, LPDWORD pdwSize );
    HRESULT MailboxAndContextCleanup( bool bDeleteMailFile );
    HRESULT MarkRecipient( DWORD dwMark );
    HRESULT ReadFile( IN LPVOID pBuffer, IN DWORD cbSize );
    HRESULT WriteFile( IN LPVOID pBuffer, IN DWORD cbSize );

// Attributes
protected:
    HRESULT m_hr;
    unsigned __int64 m_i64ReadOffset;
    unsigned __int64 m_i64WriteOffset;
    DWORD   m_dwRecipCount;
    DWORD   m_dwRecipCurrent; // Recipient currently delivering for
    DWORD   *m_pdwRecipIndexes;
    WCHAR   m_sRecipEmailName[POP3_MAX_ADDRESS_LENGTH];    // Domain name length + mailbox name length + @ + NULL
    WCHAR   m_sStoreFileName[64];
    char    m_sBuffer[OPTIMAL_BUFFER_W_DOTSTUFFING_PAD];
    
    enum BufferWrapSequence{
        NA = 0,
        CR = 1,
        CRLF = 2
    };
    BufferWrapSequence m_enumBWS;
    
    PFIO_CONTEXT m_PFIOContextRead;
    PFIO_CONTEXT m_PFIOContextWrite;
    POP3DROPDIR_OVERLAPPED m_OverlappedRead;
    POP3DROPDIR_OVERLAPPED m_OverlappedWrite;
    CMailBox m_mailboxX;

    IMailMsgBind *m_pIMailMsgBind;
    IMailMsgProperties *m_pIMailMsgProperties;
    IMailMsgNotify *m_pIMailMsgNotify;
    IMailMsgRecipients *m_pIMailMsgRecipients;
    
};

#endif // __POP3DROPDIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\smtp\storedriver\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SimpleDriver.rc
//
#define IDS_PROJNAME                    100
#define IDR_CSIMPLEDRIVER               101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\published\dload\inetsrvpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\smtp\storedriver\simpledriver.cpp ===
// SimpleDriver.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SimpleDriverps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SimpleDriver.h"

#include "SimpleDriver_i.c"
#include "CSimpleDriver.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CPOP3SMTPStoreDriver, CSimpleDriver)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\smtp\storedriver\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8C15A629_EB59_4C11_AC7F_881A44324589__INCLUDED_)
#define AFX_STDAFX_H__8C15A629_EB59_4C11_AC7F_881A44324589__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#define _WINSOCKAPI_   /* Prevent inclusion of winsock.h in windows.h */
#include <atlbase.h>
#include <winsock2.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <assert.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8C15A629_EB59_4C11_AC7F_881A44324589__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\published\dload\mqrt.c ===
#include "inetsrvpch.h"
#pragma hdrstop

#include <comsvcs.h>
#include <mq.h>


static
HRESULT
APIENTRY
MQBeginTransaction(
    OUT ITransaction **ppTransaction
    )
{
    if (ppTransaction)
        *ppTransaction = NULL;

    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQCloseCursor(
    IN HANDLE hCursor
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQCloseQueue(
    IN QUEUEHANDLE hQueue
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQCreateCursor(
    IN QUEUEHANDLE hQueue,
    OUT PHANDLE phCursor
    )
{
    if (phCursor)
        *phCursor = NULL;

    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQCreateQueue(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT MQQUEUEPROPS* pQueueProps,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQDeleteQueue(
    IN LPCWSTR lpwcsFormatName
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
VOID
APIENTRY
MQFreeSecurityContext(
    IN HANDLE hSecurityContext
    )
{
    // Not much we can do here...
}

static
HRESULT
APIENTRY
MQGetPrivateComputerInformation(
    IN LPCWSTR lpwcsComputerName,
    IN OUT MQPRIVATEPROPS* pPrivateProps
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQGetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    OUT MQQUEUEPROPS* pQueueProps
    )
{
    if (pQueueProps)
        ZeroMemory (pQueueProps, sizeof (MQQUEUEPROPS));

    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQGetSecurityContextEx(
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength,
    OUT HANDLE* phSecurityContext
    )
{
    if (phSecurityContext)
        *phSecurityContext = NULL;
    
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwAccess,
    IN DWORD dwShareMode,
    OUT QUEUEHANDLE* phQueue
    )
{
    if (phQueue)
        *phQueue = NULL;

    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQPathNameToFormatName(
    IN LPCWSTR lpwcsPathName,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQReceiveMessage(
    IN QUEUEHANDLE hSource,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN OUT MQMSGPROPS* pMessageProps,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction* pTransaction
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQSendMessage(
    IN QUEUEHANDLE hDestinationQueue,
    IN MQMSGPROPS* pMessageProps,
    IN ITransaction *pTransaction
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
APIENTRY
MQSetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mqrt)
{
    DLPENTRY(MQBeginTransaction)
    DLPENTRY(MQCloseCursor)
    DLPENTRY(MQCloseQueue)
    DLPENTRY(MQCreateCursor)
    DLPENTRY(MQCreateQueue)
    DLPENTRY(MQDeleteQueue)
    DLPENTRY(MQFreeSecurityContext)
    DLPENTRY(MQGetPrivateComputerInformation)
    DLPENTRY(MQGetQueueProperties)
    DLPENTRY(MQGetSecurityContextEx)
    DLPENTRY(MQOpenQueue)
    DLPENTRY(MQPathNameToFormatName)
    DLPENTRY(MQReceiveMessage)
    DLPENTRY(MQSendMessage)
    DLPENTRY(MQSetQueueSecurity)
};

DEFINE_PROCNAME_MAP(mqrt)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\published\query\idlmulti.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       idlmulti.h
//
//  Contents:   preprocessor trickery to make our .idl/.tdl files compile
//              with MIDL or APBU Mktyplib.
//
//  History:    27-May-94   DonCl     Created
//              20-Jul-94   ErikGav   Remove SDKTOOLS support
//
//----------------------------------------------------------------------------

#ifndef __IDLMULTI_H__
#define __IDLMULTI_H__


#ifndef __MKTYPLIB__

#define LOCAL_INTERFACE(guid)       \
[                                   \
    local,                          \
    object,                         \
    uuid(guid),                     \
    pointer_default(unique)         \
]


#define REMOTED_INTERFACE(guid)     \
[                                   \
    object,                         \
    uuid(guid),                     \
    pointer_default(unique)         \
]



#else // __MKTYPLIB__

//#define cpp_quote(string)

//#define const

#define LOCAL_INTERFACE(guid)    \
[                           \
    uuid(guid),             \
    odl                     \
]

#define REMOTED_INTERFACE(guid)   \
[                           \
    uuid(guid),             \
    odl                     \
]

#endif  /// MKTYPLIB

#endif  // __IDLMULTI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\published\dload\query.c ===
#include "inetsrvpch.h"
#pragma hdrstop

#include <unknwn.h>
#include <cmdtree.h>
#include <ntquery.h>

static
HRESULT
WINAPI
LoadIFilter(
    WCHAR const * pwcsPath,
    IUnknown *    pUnkOuter,
    void **       ppIUnk
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
LoadIFilterEx(
    WCHAR const * pwcsPath,
    DWORD         dwFlags,
    REFIID        riid,
    void **       ppIUnk
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
LocateCatalogsW(
    WCHAR const * pwszScope,
    ULONG         iBmk,
    WCHAR *       pwszMachine,
    ULONG *       pccMachine,
    WCHAR *       pwszCat,
    ULONG *       pccCat
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CIState(
    WCHAR const * pwcsCat,
    WCHAR const * pwcsMachine,
    CI_STATE *    pCiState
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CITextToFullTreeEx(
    WCHAR const *     pwszRestriction,
    ULONG             ulDialect,
    WCHAR const *     pwszColumns,
    WCHAR const *     pwszSortColumns, // may be NULL
    WCHAR const *     pwszGroupings,   // may be NULL
    DBCOMMANDTREE * * ppTree,
    ULONG             cProperties,
    CIPROPERTYDEF *   pProperties,
    LCID              LocaleID
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CIMakeICommand(
    ICommand **           ppCommand,
    ULONG                 cScope,
    DWORD const *         aDepths,
    WCHAR const * const * awcsScope,
    WCHAR const * const * awcsCatalogs,
    WCHAR const * const * awcsMachine
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(query)
{
    DLPENTRY(CIMakeICommand)
    DLPENTRY(CIState)
    DLPENTRY(CITextToFullTreeEx)
    DLPENTRY(LoadIFilter)
    DLPENTRY(LoadIFilterEx)
    DLPENTRY(LocateCatalogsW)
};

DEFINE_PROCNAME_MAP(query)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\catalog.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000.
//
//  File:       Catalog.cxx
//
//  Contents:   Used to manage catalog(s) state
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <params.hxx>
#include <ciregkey.hxx>

#include <snapin.hxx>
#include <catalog.hxx>
#include <catadmin.hxx>
#include <CIARes.h>
#include <callback.hxx>

#include <fsciexps.hxx>

CDynArrayInPlace<CCatalogs *> gapCats;
CDynArrayInPlace<UINT_PTR> gaTimerIds;
UINT gsIndex = 0;
UINT gcMaxCats = 0;
CStaticMutexSem gmtxTimer;
const cRefreshDelay = 5000;

//
// Global data
//

SCatalogColumn coldefCatalog[] = { { CCatalog::GetCat,           MSG_COL_CATNAME },
                                   { CCatalog::GetDrive,         MSG_COL_DRIVE },
                                   { CCatalog::GetSize,          MSG_COL_SIZE },
                                   { CCatalog::GetDocs,          MSG_COL_DOCTOTAL },
                                   { CCatalog::GetDocsToFilter,  MSG_COL_DOCFILTER },
                                   { CCatalog::GetSecQDocuments, MSG_COL_SECQDOCUMENTS },
                                   { CCatalog::GetWordlists,     MSG_COL_WORDLISTS },
                                   { CCatalog::GetPersIndex,     MSG_COL_PERSINDEX },
                                   { CCatalog::GetStatus,        MSG_COL_STATUS }
                                 };

const unsigned cColDefCatalog = sizeof(coldefCatalog) / sizeof(coldefCatalog[0]);

//
// Static command tree to fetch property metadata.
//
// NOTE: There are some funny casts below, because of the requirement to
//       statically initialize a union.
//

const DBID dbcolGuid = { { 0x624c9360, 0x93d0, 0x11cf, 0xa7, 0x87, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x52 },
                         DBKIND_GUID_PROPID,
                         (LPWSTR)5 };

const DBID dbcolPropDispid = { { 0x624c9360, 0x93d0, 0x11cf, 0xa7, 0x87, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x52 },
                               DBKIND_GUID_PROPID,
                               (LPWSTR)6 };

const DBID dbcolPropName = { { 0x624c9360, 0x93d0, 0x11cf, 0xa7, 0x87, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x52 },
                             DBKIND_GUID_PROPID,
                             (LPWSTR)7 };

const DBID dbcolPropLevel = { { 0x624c9360, 0x93d0, 0x11cf, 0xa7, 0x87, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x52 },
                             DBKIND_GUID_PROPID,
                             (LPWSTR)8 };

const DBID dbcolPropDataModifiable = { { 0x624c9360, 0x93d0, 0x11cf, 0xa7, 0x87, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x52 },
                             DBKIND_GUID_PROPID,
                             (LPWSTR)9 };

const DBID dbcolPropType = { { 0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac },
                             DBKIND_GUID_PROPID,
                             (LPWSTR)4 };

const DBID dbcolSize = { { 0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac },
                         DBKIND_GUID_PROPID,
                         (LPWSTR)12 };

const DBID dbcolPath = { { 0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac },
                         DBKIND_GUID_PROPID,
                         (LPWSTR)11 };

//
// This is just like PROPVARIANT, but w/o all the arms.  Lets you statically
// assign a VT_CLSID.
//

struct tag_Kyle_PROPVARIANT
{
    VARTYPE vt;
    PROPVAR_PAD1 wReserved1;
    PROPVAR_PAD2 wReserved2;
    PROPVAR_PAD3 wReserved3;
    CLSID __RPC_FAR *puuid;
};

GUID psguidStorage = PSGUID_STORAGE;
tag_Kyle_PROPVARIANT stVar = { VT_CLSID, 0, 0, 0, &psguidStorage };
//CStorageVariant stVar((CLSID *)&psguidStorage);

//
// Columns
//

DBCOMMANDTREE dbcmdColumnPath = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPath, S_OK };
DBCOMMANDTREE dbcmdColumnGuid = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolGuid, S_OK };
DBCOMMANDTREE dbcmdColumnPropDispid = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPropDispid, S_OK };
DBCOMMANDTREE dbcmdColumnPropName = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPropName, S_OK };
DBCOMMANDTREE dbcmdColumnPropType = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPropType, S_OK };
DBCOMMANDTREE dbcmdColumnSize = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolSize, S_OK };
DBCOMMANDTREE dbcmdColumnStoreLevel = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPropLevel, S_OK };
DBCOMMANDTREE dbcmdColumnModifiable = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPropDataModifiable, S_OK };

//
// Forward declare a few nodes to make linking easy
//

extern DBCOMMANDTREE dbcmdSortListAnchor;
extern DBCOMMANDTREE dbcmdProjectListAnchor;

//
// Select NOT (guid == PSGUID_STORAGE AND dispid == 19)  ; everything but CONTENTS property
//

// the guid == psguid_storage clause

DBCOMMANDTREE dbcmdGuidStorage = { DBOP_scalar_constant,
                                   DBVALUEKIND_VARIANT,
                                   0,
                                   0,
                                   (ULONG_PTR)&stVar,
                                   S_OK };

DBCOMMANDTREE dbcmdColumnGuid2 = { DBOP_column_name,
                                   DBVALUEKIND_ID,
                                   0,
                                   &dbcmdGuidStorage,
                                   (ULONG_PTR)&dbcolGuid,
                                   S_OK };

DBCOMMANDTREE dbcmdEqual = { DBOP_equal,
                            DBVALUEKIND_I4,
                            &dbcmdColumnGuid2,
                            0,
                            0,
                            S_OK };

// the dispid == 19 clause

DBCOMMANDTREE dbcmdContentsId = { DBOP_scalar_constant,
                                   DBVALUEKIND_UI4,
                                   0,
                                   0,
                                   19,
                                   S_OK };

DBCOMMANDTREE dbcmdColumnDispid = { DBOP_column_name,
                                   DBVALUEKIND_ID,
                                   0,
                                   &dbcmdContentsId,
                                   (ULONG_PTR)&dbcolPropDispid,
                                   S_OK };

DBCOMMANDTREE dbcmdEqual2 = { DBOP_equal,
                            DBVALUEKIND_I4,
                            &dbcmdColumnDispid,
                            &dbcmdEqual,
                            0,
                            S_OK };

// the and node between the above two clauses

DBCOMMANDTREE dbcmdAnd =   { DBOP_and,
                            DBVALUEKIND_I4,
                            &dbcmdEqual2,
                            0,
                            0,
                            S_OK };

// the not in front of the above node
DBCOMMANDTREE dbcmdNot =   { DBOP_not,
                            DBVALUEKIND_I4,
                            &dbcmdAnd,
                            0,
                            0,
                            S_OK };

WCHAR wszTable[] = L"Table";

DBCOMMANDTREE dbcmdTable = { DBOP_table_name,
                             DBVALUEKIND_WSTR,
                             0,
                             &dbcmdNot,
                             (ULONG_PTR)&wszTable[0],
                             S_OK };

DBCOMMANDTREE dbcmdSelect = { DBOP_select,
                              DBVALUEKIND_EMPTY,
                              &dbcmdTable,
                              &dbcmdProjectListAnchor,
                              0,
                              S_OK };

//
// Project (Path, GUID, ...)
//
// NOTE: The order here defines the ordinals of columns.
//       The first one here is the last entry in the
//       column list, as it is the last child in the
//       projection list command tree.
//


DBCOMMANDTREE dbcmdProjectModifiable = { DBOP_project_list_element,
                                       DBVALUEKIND_EMPTY,
                                       &dbcmdColumnModifiable,
                                       0,
                                       0,
                                       S_OK };

DBCOMMANDTREE dbcmdProjectStoreLevel = { DBOP_project_list_element,
                                       DBVALUEKIND_EMPTY,
                                       &dbcmdColumnStoreLevel,
                                       &dbcmdProjectModifiable,
                                       0,
                                       S_OK };

DBCOMMANDTREE dbcmdProjectSize = { DBOP_project_list_element,
                                   DBVALUEKIND_EMPTY,
                                   &dbcmdColumnSize,
                                   &dbcmdProjectStoreLevel,
                                   0,
                                   S_OK };

DBCOMMANDTREE dbcmdProjectPropType = { DBOP_project_list_element,
                                       DBVALUEKIND_EMPTY,
                                       &dbcmdColumnPropType,
                                       &dbcmdProjectSize,
                                       0,
                                       S_OK };

DBCOMMANDTREE dbcmdProjectPropName = { DBOP_project_list_element,
                                       DBVALUEKIND_EMPTY,
                                       &dbcmdColumnPropName,
                                       &dbcmdProjectPropType,
                                       0,
                                       S_OK };


DBCOMMANDTREE dbcmdProjectPropDispid = { DBOP_project_list_element,
                                         DBVALUEKIND_EMPTY,
                                         &dbcmdColumnPropDispid,
                                         &dbcmdProjectPropName,
                                         0,
                                         S_OK };

DBCOMMANDTREE dbcmdProjectGuid = { DBOP_project_list_element,
                                   DBVALUEKIND_EMPTY,
                                   &dbcmdColumnGuid,
                                   &dbcmdProjectPropDispid,
                                   0,
                                   S_OK };

DBCOMMANDTREE dbcmdProjectListAnchor = { DBOP_project_list_anchor,
                                         DBVALUEKIND_EMPTY,
                                         &dbcmdProjectGuid,
                                         0,
                                         0,
                                         S_OK };

DBCOMMANDTREE dbcmdProject = { DBOP_project,
                               DBVALUEKIND_EMPTY,
                               &dbcmdSelect,
                               &dbcmdSortListAnchor,
                               0,
                               S_OK };

//
// Sort (Ascending by GUID)
//

DBSORTINFO dbsortAscending = { FALSE, LOCALE_NEUTRAL };

DBCOMMANDTREE dbcmdSortByGuid = { DBOP_sort_list_element,
                                  DBVALUEKIND_SORTINFO,
                                  &dbcmdColumnGuid,
                                  0,
                                  (ULONG_PTR)&dbsortAscending,
                                  S_OK };

DBCOMMANDTREE dbcmdSortListAnchor = { DBOP_sort_list_anchor,
                                      DBVALUEKIND_EMPTY,
                                      &dbcmdSortByGuid,
                                      0,
                                      0,
                                      S_OK };

DBCOMMANDTREE dbcmdSort =    { DBOP_sort,
                               DBVALUEKIND_EMPTY,
                               &dbcmdProject,
                               0,
                               0,
                               S_OK };

//
// Static set of bindings for fetching property info.
//

struct SPropInfo
{
    GUID      guidPropertySet;
    PROPID    propid;
    ULONG     statusPropid;
    WCHAR *   pwcsName;
    ULONG     statusName;
    ULONG     type;
    ULONGLONG size;
    DWORD     level;
    VARIANT_BOOL fModifiable;
};

DBBINDING abindPropInfo[] = { { 1,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->guidPropertySet, // Value offset
                                0,                                          // Length offset
                                0,                                          // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE,                               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->guidPropertySet ),// Value length
                                0,                                          // Flags
                                VT_CLSID,                                   // Datatype expected
                                0,                                          // Precision (unused)
                                0 },                                        // Scale (unused)

                              { 2,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->propid,          // Value offset
                                0,                                          // Length offset
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->statusPropid,    // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE | DBPART_STATUS,               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->propid ),         // Value length
                                0,                                          // Flags
                                DBTYPE_I4,                                  // Datatype expected
                                0,                                          // Precision (unused)
                                0 },                                        // Scale (unused)

                              { 3,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->pwcsName,        // Value offset
                                0,                                          // Length offset
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->statusName,      // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE | DBPART_STATUS,               // Fetch value
                                DBMEMOWNER_PROVIDEROWNED,                   // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->pwcsName ),       // Value length
                                0,                                          // Flags
                                DBTYPE_WSTR | DBTYPE_BYREF,                 // Datatype expected
                                0,                                          // Precision (unused)
                                0 },                                        // Scale (unused)

                              { 4,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->type,            // Value offset
                                0,                                          // Length offset
                                0,                                          // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE,                               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->type ),           // Value length
                                0,                                          // Flags
                                DBTYPE_UI4,                                 // Datatype expected
                                0,                                          // Precision (unused)
                                0 },                                        // Scale (unused)

                              { 5,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->size,            // Value offset
                                0,                                          // Length offset
                                0,                                          // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE,                               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->size ),           // Value length
                                0,                                          // Flags
                                DBTYPE_I8,                                  // Datatype expected
                                0,                                          // Precision (unused)
                                0 },                                        // Scale (unused)

                              { 6,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->level,           // Value offset
                                0,                                          // Length offset
                                0,                                          // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE,                               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->level ),          // Value length
                                0,                                          // Flags
                                DBTYPE_UI4,                                 // Datatype expected
                                0,                                          // Precision (unused)
                                0 },

                              { 7,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->fModifiable,     // Value offset
                                0,                                          // Length offset
                                0,                                          // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE,                               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->fModifiable ),    // Value length
                                0,                                          // Flags
                                DBTYPE_BOOL,                                // Datatype expected
                                0,                                          // Precision (unused)
                                0 }};

BOOL CCatalogs::_fFirstTime = TRUE;

CCatalog::CCatalog( CCatalogs & parent, WCHAR const * pwcsCat )
        : _idScope( 0 ),
          _idResult( 0 ),
          _pwcsDrive( 0 ),
          _pwcsCat( 0 ),
          _parent( parent ),
          _fZombie( FALSE ),
#pragma warning( disable : 4355 )       // this used in base initialization
          _interScopes( *this, Intermediate_Scope ),
          _interProperties( *this, Intermediate_Properties ),
          _interUnfiltered( *this, Intermediate_UnfilteredURL )
#pragma warning( default : 4355 )
{
    //
    // Hack Alert!  This will fake ::Update into thinking all the values need to be
    // changed.
    //

    RtlFillMemory( &_state, sizeof(_state), 0xAA );
    _state.cbStruct = sizeof(_state);

    TRY
    {
        //
        // Initialize string(s)
        //

        CMachineAdmin MachineAdmin( _parent.GetMachine() );

        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( pwcsCat ) );

        Set( xCatalogAdmin->GetLocation(), _pwcsDrive );
        Set( pwcsCat, _pwcsCat );
        _fInactive = xCatalogAdmin->IsCatalogInactive();

        Update();

        //
        // Make sure we think the orignal value is new
        //

        _fSizeChanged = TRUE;
        _fPropCacheSizeChanged = TRUE;
        _fDocsChanged = TRUE;
        _fDocsToFilterChanged = TRUE;
        _fWordlistsChanged = TRUE;
        _fPersIndexChanged = TRUE;
        _fStatusChanged = TRUE;
        _fSecQDocumentsChanged = TRUE;

    }
    CATCH( CException, e )
    {
        delete [] _pwcsDrive;
        delete [] _pwcsCat;

        RETHROW();
    }
    END_CATCH
}


void CCatalog::InitScopeHeader( CListViewHeader & Header )
{
    CScope::InitHeader( Header );
}

void CCatalog::InitPropertyHeader( CListViewHeader & Header )
{
    CCachedProperty::InitHeader( Header );
}

CCatalog::~CCatalog()
{
    delete [] _pwcsDrive;
    delete [] _pwcsCat;
}

SCODE CCatalog::AddScope( WCHAR const * pwszScope,
                          WCHAR const * pwszAlias,
                          BOOL fExclude,
                          WCHAR const * pwszLogon,
                          WCHAR const * pwszPassword )
{
    ciaDebugOut(( DEB_ITRACE,
                  "CCatalog::AddScope( %ws, %ws, %s, %ws, %ws )\n",
                  pwszScope,
                  (0 == pwszAlias) ? L"" : pwszAlias,
                  fExclude ? "TRUE" : "FALSE",
                  (0 == pwszLogon) ? L"n/a" : pwszLogon,
                  (0 == pwszPassword) ? L"n/a" : pwszPassword ));

    SCODE sc = S_OK;
    TRY
    {
        //
        // First, add to CI.
        //
   
        CMachineAdmin MachineAdmin( _parent.GetMachine() );
        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
        xCatalogAdmin->AddScope( pwszScope,
                                 pwszAlias, 
                                 fExclude,
                                 pwszLogon,
                                 pwszPassword );
    }
    CATCH (CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return (FAILED(sc) ? sc : S_OK);
}

void CCatalog::RemoveScope( CScope * pScope )
{
    SCODE sc = S_OK;

    TRY
    {
        //
        // First, remove from CI.
        //

        CMachineAdmin MachineAdmin( _parent.GetMachine() );
        
        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

        xCatalogAdmin->RemoveScope( pScope->GetPath() );
    }
    CATCH (CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    if (FAILED(sc))
    {
        // At this point nothing was removed from the registry, so we shouldn't zombify the scope.
        return;
    }

    //
    // Then, from display.
    //

    pScope->Zombify();
}

SCODE CCatalog::ModifyScope( CScope & rScope,
                             WCHAR const * pwszScope,
                             WCHAR const * pwszAlias,
                             BOOL fExclude,
                             WCHAR const * pwszLogon,
                             WCHAR const * pwszPassword )
{
    ciaDebugOut(( DEB_ITRACE,
                  "CCatalog::ModifyScope( %ws, %ws, %s, %ws, %ws )\n",
                  pwszScope,
                  (0 == pwszAlias) ? L"" : pwszAlias,
                  fExclude ? "TRUE" : "FALSE",
                  (0 == pwszLogon) ? L"n/a" : pwszLogon,
                  (0 == pwszPassword) ? L"n/a" : pwszPassword ));

    SCODE sc = S_OK;

    TRY
    {
        //
        // First, remove from CI.
        //

        CMachineAdmin MachineAdmin( _parent.GetMachine() );
        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

        //
        // If the path hasn't changed, we should only change properties that have
        // changed. If the path has changed, it will cause the value to be deleted
        // anyway, so we can remove the scope and add the replacement in one shot.
        //
        if (0 == _wcsicmp(rScope.GetPath(), pwszScope))
        {
            XPtr<CScopeAdmin> xScopeAdmin( 
                                 xCatalogAdmin->QueryScopeAdmin(rScope.GetPath()) );

            xScopeAdmin->SetAlias(pwszAlias);

            xScopeAdmin->SetExclude(fExclude);

            xScopeAdmin->SetLogonInfo(pwszLogon, 
                                      pwszPassword, 
                                      xCatalogAdmin.GetReference());
        }
        else
        {
            xCatalogAdmin->RemoveScope( rScope.GetPath() );
   
            // Then add the entry to CI
            xCatalogAdmin->AddScope( pwszScope,
                                     pwszAlias,
                                     fExclude,
                                     pwszLogon,
                                     pwszPassword );
        }

        // Then modify the display entry in place
        rScope.Modify( pwszScope, pwszAlias, fExclude );
    }
    CATCH (CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

void CCatalog::RescanScope( WCHAR const * pwszScope, BOOL fFull )
{
    SCODE sc = UpdateContentIndex ( pwszScope,
                                    _pwcsCat,
                                    _parent.GetMachine(),
                                    fFull );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "UpdateContentIndex( %ws ) returned 0x%x\n",
                      pwszScope, sc ));

        THROW( CException( sc ) );
    }
}

void CCatalog::Merge()
{
    SCODE sc = ForceMasterMerge ( L"\\",
                                  _pwcsCat,
                                  _parent.GetMachine() );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "ForceMasterMerge( %ws ) returned 0x%x\n",
                      _pwcsCat, sc ));

        THROW( CException( sc ) );
    }
}

void CCatalog::DisplayIntermediate( IConsoleNameSpace * pScopePane )
{
    //
    // Now, insert the intermediate nodes.
    //

    SCOPEDATAITEM item;

    RtlZeroMemory( &item, sizeof(item) );

    //
    // 'Scope'
    //

    item.mask |= SDI_STR | SDI_IMAGE | SDI_CHILDREN;
    item.nImage = ICON_FOLDER;
    //item.displayname = (WCHAR *)pCat->GetCat( TRUE );  
    item.displayname = MMC_CALLBACK;
    item.cChildren = 0;

    item.mask |= SDI_PARAM;
    item.lParam = (LPARAM)GetIntermediateScopeNode();

    item.relativeID = ScopeHandle();

    ciaDebugOut(( DEB_ITRACE, "Inserting (intermediate) scope item (lParam = 0x%x)\n", item.lParam ));

    pScopePane->InsertItem( &item );

    //
    // 'Properties'
    //

    item.mask |= SDI_STR | SDI_IMAGE | SDI_CHILDREN;
    item.nImage = ICON_FOLDER;
    //item.displayname = (WCHAR *)pCat->GetCat( TRUE );  
    item.displayname = MMC_CALLBACK;
    item.cChildren = 0;

    item.mask |= SDI_PARAM;
    item.lParam = (LPARAM)GetIntermediatePropNode();

    item.relativeID = ScopeHandle();

    ciaDebugOut(( DEB_ITRACE, "Inserting (intermediate) property item (lParam = 0x%x)\n", item.lParam ));

    pScopePane->InsertItem( &item );

    //
    // Unfiltered query URL
    //

    item.mask |= SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_CHILDREN;
    item.nImage = item.nOpenImage = ICON_URL;
    item.displayname = MMC_CALLBACK;
    item.cChildren = 0;

    item.mask |= SDI_PARAM;
    item.lParam = (LPARAM)GetIntermediateUnfilteredNode();

    item.relativeID = ScopeHandle();

    ciaDebugOut(( DEB_ITRACE, "Inserting (intermediate) URL item (lParam = 0x%x)\n", item.lParam ));

    pScopePane->InsertItem( &item );
}

void CCatalog::DisplayScopes( BOOL fFirstTime, IResultData * pResultPane )
{
    ciaDebugOut(( DEB_ITRACE, "CCatalog::DisplayScopes (fFirstTime = %d)\n", fFirstTime ));

    ClearScopes(pResultPane);
    PopulateScopes();

    for ( unsigned i = 0; i < _aScope.Count(); i++ )
    {
        CScope * pScope = _aScope.Get( i );

        Win4Assert(!pScope->IsZombie());

         //
         // All items were freshly enumerated. add them all
         //

         RESULTDATAITEM item;
         RtlZeroMemory( &item, sizeof(item) );

         item.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
         item.nCol = 0;

         // item.nImage will be set by ::GetDisplayInfo
         pScope->GetDisplayInfo( &item );

         item.str = MMC_CALLBACK;
         item.lParam = (LPARAM)pScope;

         ciaDebugOut(( DEB_ITRACE, "Inserting result item %ws (lParam = 0x%x)\n",
                       pScope->GetPath(), item.lParam ));

         pResultPane->InsertItem( &item );

         pScope->SetResultHandle( item.itemID );
    }
}

void CCatalog::ClearProperties(IResultData * pResultPane)
{
    // Clear out the display list
    pResultPane->DeleteAllRsltItems();

    // Delete the entries from the property list
    _aProperty.Clear();
}

void CCatalog::DisplayProperties( BOOL fFirstTime, IResultData * pResultPane )
{
    ciaDebugOut(( DEB_ITRACE, "CCatalog::DisplayProperties (fFirstTime = %d)\n", fFirstTime ));

    // If catalog is stopped OR service is stopped, clear the list.
    BOOL fStopped = FALSE;
    TRY
    {
        CMachineAdmin   MachineAdmin( _parent.IsLocalMachine() ? 0 : _parent.GetMachine() );

        XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

        fStopped = xCat->IsStopped() || MachineAdmin.IsCIStopped();

        if (fStopped)
           ClearProperties(pResultPane);
    }
    CATCH( CException, e)
    {
       // nothing to do
    }
    END_CATCH

    if (fStopped)
        return;

    if ( fFirstTime )
        UpdateProps();

    for ( unsigned i = 0; i < _aProperty.Count(); i++ )
    {
        CCachedProperty * pProperty = _aProperty.Get( i );

        if ( pProperty->IsZombie() )
        {
            pResultPane->DeleteItem( pProperty->ResultHandle(), 0 );

            //
            // Delete scope and move highest entry down.
            //

            pProperty = _aProperty.Acquire( i );
            delete pProperty;

            if ( _aProperty.Count() > 0 && _aProperty.Count() != i )
            {
                pProperty = _aProperty.Acquire( _aProperty.Count() - 1 );
                _aProperty.Add( pProperty, i );
            }

            continue;
        }

        if ( fFirstTime || pProperty->IsNew() )
        {
            //
            // Add item
            //

            RESULTDATAITEM item;
            RtlZeroMemory( &item, sizeof(item) );

            item.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
            item.nCol = 0;

            pProperty->GetDisplayInfo( &item );
            // item.nImage is set from ::GetDisplayInfo

            item.str = MMC_CALLBACK;
            item.lParam = (LPARAM)pProperty;

            ciaDebugOut(( DEB_ITRACE, "Inserting result item %ws (lParam = 0x%x)\n",
                          pProperty->GetProperty(), item.lParam ));

            pResultPane->InsertItem( &item );

            pProperty->SetResultHandle( item.itemID );
            pProperty->MakeOld();
        }


        if ( !fFirstTime && !pProperty->IsNew() )
        {
            if ( !pProperty->IsUnappliedChange() )
            {
                //
                // Set the icon back to normal.
                //

                RESULTDATAITEM rdi;
                RtlZeroMemory(&rdi, sizeof(rdi));

                rdi.mask   = RDI_IMAGE;
                rdi.itemID = pProperty->ResultHandle();

                // item.nImage is set from ::GetDisplayInfo
                pProperty->GetDisplayInfo( &rdi );

                SCODE sc = pResultPane->SetItem( &rdi );
            }
        }
    }
}

void CCatalog::GetGeneration( BOOL  & fFilterUnknown,
                              BOOL  & fGenerateCharacterization,
                              ULONG & ccCharacterization )
{
    // Caller will deal with exceptions.

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    DWORD dw;

    //
    // Filter Unknown
    //

    if ( !xCatalogAdmin->GetDWORDParam( wcsFilterFilesWithUnknownExtensions, dw ) &&
         !MachineAdmin.GetDWORDParam( wcsFilterFilesWithUnknownExtensions, dw ) )
        dw = CI_FILTER_FILES_WITH_UNKNOWN_EXTENSIONS_DEFAULT;

    fFilterUnknown = (0 != dw);

    //
    // Characterization. We should check if generatecharacterization flag is set to
    // TRUE and also check the characterization size. Only when the flag is set to TRUE
    // and size > 0, should we generate characterization.
    //

    DWORD dwGenCharacterization = 0;

    if ( !xCatalogAdmin->GetDWORDParam( wcsGenerateCharacterization, dwGenCharacterization ) &&
         !MachineAdmin.GetDWORDParam( wcsGenerateCharacterization, dwGenCharacterization ) )
        dwGenCharacterization = 1;

    if ( !xCatalogAdmin->GetDWORDParam( wcsMaxCharacterization, ccCharacterization ) &&
         !MachineAdmin.GetDWORDParam( wcsMaxCharacterization, ccCharacterization ) )
        ccCharacterization = CI_MAX_CHARACTERIZATION_DEFAULT;

    fGenerateCharacterization = (ccCharacterization > 0) && (0 != dwGenCharacterization);
}

void CCatalog::SetGeneration( BOOL  fFilterUnknown,
                              BOOL  fGenerateCharacterization,
                              ULONG ccCharacterization )
{
    //
    // fGenerateCharacterization is obsolete.
    //

    if ( !fGenerateCharacterization )
        ccCharacterization = 0;

    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    xCatalogAdmin->SetDWORDParam( wcsFilterFilesWithUnknownExtensions, fFilterUnknown );
    xCatalogAdmin->SetDWORDParam( wcsGenerateCharacterization, fGenerateCharacterization );
    xCatalogAdmin->SetDWORDParam( wcsMaxCharacterization, ccCharacterization );
}

void CCatalog::GetTracking( BOOL  & fAutoAlias )
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    DWORD dw;

    if ( !xCatalogAdmin->GetDWORDParam( wcsIsAutoAlias, dw ) &&
         !MachineAdmin.GetDWORDParam( wcsIsAutoAlias, dw ) )
        dw = CI_IS_AUTO_ALIAS_DEFAULT;

    fAutoAlias = (0 != dw);
}

void CCatalog::SetTracking( BOOL  fAutoAlias )
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    xCatalogAdmin->SetDWORDParam( wcsIsAutoAlias, fAutoAlias );
}

void CCatalog::GetWeb( BOOL &  fVirtualRoots,
                       BOOL &  fNNTPRoots,
                       ULONG & iVirtualServer,
                       ULONG & iNNTPServer )
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    DWORD dw;

    //
    // Filter Virtual Roots
    //

    if ( !xCatalogAdmin->GetDWORDParam( wcsIsIndexingW3Roots, dw ) &&
         !MachineAdmin.GetDWORDParam( wcsIsIndexingW3Roots, dw ) )
        dw = CI_IS_INDEXING_W3_ROOTS_DEFAULT;

    fVirtualRoots = (0 != dw);

    //
    // Filter NNTP Roots
    //

    if ( !xCatalogAdmin->GetDWORDParam( wcsIsIndexingNNTPRoots, dw ) &&
         !MachineAdmin.GetDWORDParam( wcsIsIndexingNNTPRoots, dw ) )
        dw = CI_IS_INDEXING_NNTP_ROOTS_DEFAULT;

    fNNTPRoots = (0 != dw);

    //
    // Virtual server
    //

    if ( !xCatalogAdmin->GetDWORDParam( wcsW3SvcInstance, iVirtualServer ) &&
         !MachineAdmin.GetDWORDParam( wcsW3SvcInstance, iVirtualServer ) )
        iVirtualServer = CI_W3SVC_INSTANCE_DEFAULT;

    //
    // NNTP Virtual server
    //

    if ( !xCatalogAdmin->GetDWORDParam( wcsNNTPSvcInstance, iNNTPServer ) &&
         !MachineAdmin.GetDWORDParam( wcsNNTPSvcInstance, iNNTPServer ) )
        iNNTPServer = CI_NNTPSVC_INSTANCE_DEFAULT;
}

void CCatalog::SetWeb( BOOL  fVirtualRoots,
                       BOOL  fNNTPRoots,
                       ULONG iVirtualServer,
                       ULONG iNNTPServer )
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    xCatalogAdmin->SetDWORDParam( wcsIsIndexingW3Roots, fVirtualRoots );
    xCatalogAdmin->SetDWORDParam( wcsIsIndexingNNTPRoots, fNNTPRoots );
    xCatalogAdmin->SetDWORDParam( wcsW3SvcInstance, iVirtualServer );
    xCatalogAdmin->SetDWORDParam( wcsNNTPSvcInstance, iNNTPServer );
}

void CCatalog::UpdateCachedProperty(CCachedProperty *pProperty)
{
    TRY
    {
        CMachineAdmin MachineAdmin( _parent.GetMachine() );

        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin(GetCat(TRUE)) );

        Win4Assert(pProperty->IsUnappliedChange() );

        xCatalogAdmin->AddCachedProperty( *((CFullPropSpec const *)pProperty->GetFullPropspec()),
                                          pProperty->GetVT(),
                                          pProperty->Allocation(),
                                          pProperty->StoreLevel(),
                                          pProperty->IsModifiable());

        pProperty->ClearUnappliedChange();
    }
    CATCH(CException, e)
    {
        ULONG cc = wcslen(pProperty->GetPropSet());
        cc++;
        cc += wcslen(pProperty->GetProperty());
        cc++;

        XGrowable<WCHAR> xPropDescription(cc);

        wcscpy(xPropDescription.Get(), pProperty->GetPropSet());
        wcscat(xPropDescription.Get(), L" ");
        wcscat(xPropDescription.Get(), pProperty->GetProperty());

        MessageBox(GetFocus(), xPropDescription.Get(),
                   STRINGRESOURCE( srPropCommitErrorT ), MB_ICONWARNING);

    }
    END_CATCH
}

void CCatalog::Set( WCHAR const * pwcsSrc, WCHAR * & pwcsDst )
{
    if ( 0 == pwcsSrc )
    {
        pwcsDst = new WCHAR[2];
        RtlCopyMemory( pwcsDst, L" ", 2*sizeof(WCHAR) );
    }
    else
    {
        unsigned cc = wcslen( pwcsSrc ) + 1;

        pwcsDst = new WCHAR [cc];

        RtlCopyMemory( pwcsDst, pwcsSrc, cc * sizeof(WCHAR) );
    }
}

void CCatalog::Stringize( DWORD dwValue, WCHAR * pwcsDst, unsigned ccDst )
{
    //
    // GetNumberFormat places additional decimals at the end...
    //
#if 0
    WCHAR wcTemp[100];

    _ultow( dwValue, wcTemp, 10 );
    GetNumberFormat( LOCALE_USER_DEFAULT,    // Default locale
                     0,                      // Flags
                     wcTemp,                 // Input
                     0,                      // More formatting info
                     pwcsDst,                // Output buffer
                     ccDst );                // Size
#else
    _ultow( dwValue, pwcsDst, 10 );
#endif
}

BOOL CCatalog::Update()
{
    //
    // Get state
    //

    CI_STATE state;
    ULONG ulCacheSizeInKB;

    state.cbStruct = sizeof(state);

    SCODE sc = CIState( _pwcsCat,
                        _parent.GetMachine(),
                        &state );

    if ( FAILED(sc) )
    {
        Null( _awcWordlists );
        Null( _awcPersIndex );
        Null( _awcSize );
        Null( _awcPropCacheSize );
        Null( _awcDocsToFilter );
        Null( _awcSecQDocuments );
        Null( _awcDocs );
        Null( _awcStatus );

        //
        // Make sure when we come back to life we will update values.
        //

        RtlFillMemory( &_state, sizeof(_state), 0xAA );
        _state.cbStruct = sizeof(_state);

        _fSizeChanged = TRUE;
        _fPropCacheSizeChanged = TRUE;
        _fDocsChanged = TRUE;
        _fDocsToFilterChanged = TRUE;
        _fWordlistsChanged = TRUE;
        _fPersIndexChanged = TRUE;
        _fStatusChanged = TRUE;
        _fSecQDocumentsChanged = TRUE;

        TRY
        {
            CMachineAdmin   MachineAdmin( _parent.IsLocalMachine() ? 0 : _parent.GetMachine() );

            XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

            if (xCat->IsStopped())
            {
                wcscpy( _awcStatus, STRINGRESOURCE(srStopped) );
            }
        }
        CATCH( CException, e)
        {
           // nothing to do
        }
        END_CATCH
    }
    else
    {
        //
        // String-ize
        //

        //
        // Could put more of this in a method, but it seems like overkill.  A table based
        // solution will be necessary if this list grows.
        //

        if ( _state.cWordList != state.cWordList )
        {
            Stringize( state.cWordList, _awcWordlists, sizeof(_awcWordlists)/sizeof(WCHAR) );
            _fWordlistsChanged = TRUE;
        }
        else
            _fWordlistsChanged = FALSE;

        if ( _state.cPersistentIndex != state.cPersistentIndex )
        {
            Stringize( state.cPersistentIndex, _awcPersIndex, sizeof(_awcPersIndex)/sizeof(WCHAR) );
            _fPersIndexChanged = TRUE;
        }
        else
            _fPersIndexChanged = FALSE;

        if ( _state.dwIndexSize != state.dwIndexSize )
        {
            Stringize( state.dwIndexSize, _awcSize, sizeof(_awcSize)/sizeof(WCHAR) );
            _fSizeChanged = TRUE;
        }
        else
            _fSizeChanged = FALSE;

        if (_state.dwPropCacheSize != state.dwPropCacheSize)
        {
            Stringize(state.dwPropCacheSize/1024, _awcPropCacheSize, sizeof(_awcPropCacheSize)/sizeof(WCHAR));
            _fPropCacheSizeChanged = TRUE;
        }
        else
            _fPropCacheSizeChanged = FALSE;

        if ( _state.cDocuments != state.cDocuments )
        {
            Stringize( state.cDocuments, _awcDocsToFilter, sizeof(_awcDocsToFilter)/sizeof(WCHAR) );
            _fDocsToFilterChanged = TRUE;
        }
        else
            _fDocsToFilterChanged = FALSE;

        if ( _state.cSecQDocuments != state.cSecQDocuments )
        {
            Stringize( state.cSecQDocuments, _awcSecQDocuments, sizeof(_awcSecQDocuments)/sizeof(WCHAR) );
            _fSecQDocumentsChanged = TRUE;
        }
        else
            _fSecQDocumentsChanged = FALSE;

        if ( _state.cTotalDocuments != state.cTotalDocuments )
        {
            Stringize( state.cTotalDocuments, _awcDocs, sizeof(_awcDocs)/sizeof(WCHAR) );
            _fDocsChanged = TRUE;
        }
        else
            _fDocsChanged = FALSE;

        if ( _state.eState != state.eState || _state.dwMergeProgress != state.dwMergeProgress )
        {
            FormatStatus( state );
            _fStatusChanged = TRUE;
        }
        else
            _fStatusChanged = FALSE;

        RtlCopyMemory( &_state, &state, sizeof(state) );
    }

    return ChangesPending();
}

BOOL CCatalog::UpdateProps()
{
    if ( 0 != _aProperty.Count() )
        return FALSE;

    //
    // Look for cached properties
    //
    IUnknown * pIUnknown;
    XInterface<ICommand> xCmd;

    SCODE sc = MakeMetadataICommand( &pIUnknown,
                                     CiProperties,
                                     _pwcsCat,
                                     _parent.GetMachine() );
    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x creating metadata ICommand\n", sc ));

        //THROW( CException(sc) );
        return FALSE;
    }

    XInterface<IUnknown> xUnk( pIUnknown );
    sc = pIUnknown->QueryInterface(IID_ICommand, xCmd.GetQIPointer());

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x on QueryInterface IID_ICommand\n", sc ));

        //THROW( CException(sc) );
        return FALSE;
    }

    XInterface<ICommandTree> xCmdTree;

    sc = xCmd->QueryInterface( IID_ICommandTree, xCmdTree.GetQIPointer() );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x binding to ICommandTree\n", sc ));

        //THROW( CException(sc) );
        return FALSE;
    }

    DBCOMMANDTREE * pTree = &dbcmdSort;

    sc = xCmdTree->SetCommandTree( &pTree, DBCOMMANDREUSE_NONE, TRUE );

    Win4Assert( 0 != pTree );  // Make sure it wasn't taken from us!

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x setting command tree\n", sc ));

        //THROW( CException(sc) );
        return FALSE;
    }

    XInterface<IRowset> xRowset;

    sc = xCmd->Execute( 0, IID_IRowset, 0, 0, (IUnknown **)xRowset.GetQIPointer() );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x creating metadata rowset.\n", sc ));

        //THROW( CException(sc) );
        return FALSE;
    }

    //
    // Now, we have a cursor.  Create some bindings.  Below this point, we shouldn't
    // expect any errors.
    //

    XInterface<IAccessor> xAccessor;

    sc = xRowset->QueryInterface( IID_IAccessor, xAccessor.GetQIPointer() );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x binding to IAccessor\n", sc ));
        THROW( CException(sc) );
    }

    HACCESSOR hacc;

    sc = xAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                    sizeof(abindPropInfo) / sizeof(abindPropInfo[0]),
                                    abindPropInfo,
                                    0,
                                    &hacc,
                                    0 );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x binding to IAccessor\n", sc ));
        THROW( CException(sc) );
    }

    //
    // Now we have a cursor and bindings.  Iterate over the data.
    //

    while ( SUCCEEDED(sc) && sc != DB_S_ENDOFROWSET )
    {
        HROW  ahrow[10];
        DBCOUNTITEM cRow;
        HROW* phrow = ahrow;

        sc = xRowset->GetNextRows( 0,                               // Chapter
                                   0,                               // Skip
                                   sizeof(ahrow)/sizeof(ahrow[0]),  // Count requested
                                   &cRow,                           // Count fetched
                                   &phrow );

        if ( SUCCEEDED(sc) )
        {
            for ( ULONG i = 0; SUCCEEDED(sc) && i < cRow; i++ )
            {
                SPropInfo sprop;

                sc = xRowset->GetData( ahrow[i], hacc, &sprop );

                Win4Assert( DBSTATUS_S_OK == sprop.statusPropid ||
                            DBSTATUS_S_OK == sprop.statusName );

                if ( SUCCEEDED(sc) &&
                     ( DBSTATUS_S_OK == sprop.statusPropid ||
                       DBSTATUS_S_OK == sprop.statusName ) )
                {
                    PROPSPEC ps = { PRSPEC_PROPID, 1 };

                    if ( DBSTATUS_S_OK == sprop.statusName )
                    {
                        ps.ulKind = PRSPEC_LPWSTR;
                        ps.lpwstr = sprop.pwcsName;
                    }
                    else
                        ps.propid = sprop.propid;

                    CCachedProperty * pProp = new CCachedProperty( *this,
                                                                   sprop.guidPropertySet,
                                                                   ps,
                                                                   sprop.type,
                                                                   sprop.size,
                                                                   sprop.level,
                                                                   sprop.fModifiable );

                    _aProperty.Add( pProp, _aProperty.Count() );
                }
            }

            if ( FAILED(sc) || sc == DB_S_ENDOFROWSET )
                xRowset->ReleaseRows( cRow, ahrow, 0, 0, 0 );
            else
                sc = xRowset->ReleaseRows( cRow, ahrow, 0, 0, 0 );
        }
    }

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Something bad during row fetch (0x%x)\n", sc ));
        THROW( CException(sc) );
    }

    xAccessor->ReleaseAccessor( hacc, 0 );

    return TRUE;
}

void CCatalog::FormatStatus( CI_STATE & state )
{
    //
    // One-shot initialization
    //

    static unsigned       ccScanReq;
    static unsigned       ccScanning;
    static unsigned       ccRecovering;
    static unsigned       ccMMPaused;
    static unsigned       ccHighIo;
    static unsigned       ccLowMemory;
    static unsigned       ccReadOnly;
    static unsigned       ccBattery;
    static unsigned       ccUserActive;
    static unsigned       ccStarting;
    static unsigned       ccReadingUsns;
    static unsigned       ccStarted;

    if ( 0 == ccScanReq )
    {
        ccScanReq = wcslen( STRINGRESOURCE( srScanReq ) );
        ccScanning = wcslen( STRINGRESOURCE( srScanning ) );
        ccRecovering = wcslen( STRINGRESOURCE( srRecovering ) );
        ccMMPaused = wcslen( STRINGRESOURCE( srMMPaused ) );
        ccHighIo = wcslen( STRINGRESOURCE( srHighIo ) );
        ccLowMemory = wcslen( STRINGRESOURCE( srLowMemory ) );
        ccReadOnly = wcslen( STRINGRESOURCE( srReadOnly ) );
        ccBattery = wcslen( STRINGRESOURCE( srBattery ) );
        ccUserActive = wcslen( STRINGRESOURCE( srUserActive ) );
        ccStarting = wcslen( STRINGRESOURCE( srStarting ) );
        ccReadingUsns = wcslen( STRINGRESOURCE( srReadingUsns ) );
        ccStarted = wcslen( STRINGRESOURCE( srStarted ) );
    }

    _awcStatus[0] = 0;

    WCHAR * pwcsStatus = _awcStatus;
    unsigned ccLeft = sizeof(_awcStatus) / sizeof(WCHAR) - 1;

    // Changed srShadow and srAnnealing to just be "Merge" so the end user won't have
    // to be told what shadow and annealing merges are. KISS
    if ( state.eState & CI_STATE_SHADOW_MERGE )
    {
        wsprintf( _awcStatus, STRINGRESOURCE( srShadow ), state.dwMergeProgress );
        ccLeft -= wcslen( _awcStatus );
    }
    else if ( state.eState & CI_STATE_ANNEALING_MERGE )
    {
        wsprintf( _awcStatus, STRINGRESOURCE( srAnnealing ), state.dwMergeProgress );
        ccLeft -= wcslen( _awcStatus );
    }
    else if ( state.eState & CI_STATE_MASTER_MERGE )
    {
        wsprintf( _awcStatus, STRINGRESOURCE( srMaster ), state.dwMergeProgress );
        ccLeft -= wcslen( _awcStatus );
    }
    else if ( state.eState & CI_STATE_MASTER_MERGE_PAUSED )
    {
        RtlCopyMemory( _awcStatus, STRINGRESOURCE( srMMPaused ), (ccMMPaused + 1) * sizeof(WCHAR) );
        ccLeft -= ccMMPaused;
    }

    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_SCANNING, srScanning, ccScanning );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_HIGH_IO, srHighIo, ccHighIo );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_LOW_MEMORY, srLowMemory, ccLowMemory );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_BATTERY_POWER, srBattery, ccBattery );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_USER_ACTIVE, srUserActive, ccUserActive );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_STARTING, srStarting, ccStarting );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_READING_USNS, srReadingUsns, ccReadingUsns );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_RECOVERING, srRecovering, ccRecovering );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_CONTENT_SCAN_REQUIRED, srScanReq, ccScanReq );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_READ_ONLY, srReadOnly, ccReadOnly );

    // If the status is not "Starting", then it should be "Started" so we don't have
    // an empty status field

    if ( (!(state.eState & CI_STATE_STARTING)) && ccLeft >= ccStarted+2)
    {
        if ( _awcStatus[0] == 0 )
        {
            RtlCopyMemory( _awcStatus, STRINGRESOURCE(srStarted), (ccStarted+1) * sizeof(WCHAR) );
            ccLeft -= ccStarted;
        }
        else
        {
            wcscat( _awcStatus, L", " );
            wcscat( _awcStatus, STRINGRESOURCE(srStarted) );
            ccLeft -= ccStarted + 2;
        }
    }
}

unsigned CCatalog::AppendToStatus( unsigned ccLeft,
                                   CI_STATE & state,
                                   DWORD dwFlag,
                                   StringResource & srFlag,
                                   unsigned ccFlag )
{
    if ( state.eState & dwFlag && ccLeft >= ccFlag + 2 )
    {
        if ( _awcStatus[0] == 0 )
        {
            RtlCopyMemory( _awcStatus, STRINGRESOURCE(srFlag), (ccFlag+1) * sizeof(WCHAR) );
            ccLeft -= ccFlag;
        }
        else
        {
            wcscat( _awcStatus, L", " );
            wcscat( _awcStatus, STRINGRESOURCE(srFlag) );
            ccLeft -= ccFlag + 2;
        }
    }

    return ccLeft;
}

void CCatalog::ClearScopes(IResultData * pResultPane)
{
    // Clear out the display list
    pResultPane->DeleteAllRsltItems();

    // Delete the entries from the property list
    _aScope.Clear();
}

void CCatalog::PopulateScopes()
{
    if ( 0 != _aScope.Count() )
        return;

    TRY
    {
        CMachineAdmin MachineAdmin( _parent.GetMachine() );

        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
        XPtr<CScopeEnum>    xScopeEnum( xCatalogAdmin->QueryScopeEnum() );

        for ( ; xScopeEnum->Next(); )
        {
            XPtr<CScopeAdmin> xScopeAdmin( xScopeEnum->QueryScopeAdmin() );

            CScope * pScope = new CScope( *this,
                                         xScopeAdmin->GetPath(),
                                         xScopeAdmin->GetAlias(),
                                         xScopeAdmin->IsExclude(),
                                         xScopeAdmin->IsVirtual(),
                                         xScopeAdmin->IsShadowAlias() );

            _aScope.Add( pScope, _aScope.Count() );
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_WARN, "Error enumerating scopes for %ws.\n", _pwcsCat ));
    }
    END_CATCH
}

// Delete registry values for grouped settings. Deletion ensures that those
// registry parameters are inherited from the service.

// Group1 settings are wcsGenerateCharacterization and 
// wcsFilterFilesWithUnknownExtensions

// Group2 settings are wcsIsAutoAlias
// Check to see if parameter groups are available

BOOL CCatalog::DoGroup1SettingsExist()
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );
    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
  
    DWORD dwVal;
    BOOL fParamsExist = xCatalogAdmin->GetDWORDParam( wcsGenerateCharacterization, dwVal ) 
                     || xCatalogAdmin->GetDWORDParam( wcsFilterFilesWithUnknownExtensions, dwVal )
                     || xCatalogAdmin->GetDWORDParam( wcsMaxCharacterization, dwVal );

    return fParamsExist;
}


BOOL CCatalog::DoGroup2SettingsExist()
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );
    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
    
    DWORD dwVal;
    BOOL fParamsExist = xCatalogAdmin->GetDWORDParam( wcsIsAutoAlias, dwVal );

    return fParamsExist;
}

void CCatalog::FillGroup1Settings()
{
    BOOL  fFilterUnknown, fGenerateCharacterization;
    ULONG ccCharacterization;

    // GetGeneration gets registry params from catalog or 
    // service (if they don't exist at catalog level)
    GetGeneration(fFilterUnknown, fGenerateCharacterization, ccCharacterization);
    SetGeneration(fFilterUnknown, fGenerateCharacterization, ccCharacterization);
}

void CCatalog::FillGroup2Settings()
{
   BOOL fTracking;
   GetTracking(fTracking);
   SetTracking(fTracking);
}

void CCatalog::DeleteGroup1Settings()
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );
    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
  
    xCatalogAdmin->DeleteRegistryParamNoThrow( wcsGenerateCharacterization );
    xCatalogAdmin->DeleteRegistryParamNoThrow( wcsFilterFilesWithUnknownExtensions );
    xCatalogAdmin->DeleteRegistryParamNoThrow( wcsMaxCharacterization );
}

// Group2 settings are wcsIsAutoAlias
void CCatalog::DeleteGroup2Settings()
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );
    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
  
    xCatalogAdmin->DeleteRegistryParamNoThrow( wcsIsAutoAlias );
}

CCatalogs::CCatalogs()
        : _fFirstScopeExpansion( TRUE ),
          _fAbort( FALSE ),
          _pScopePane( 0 ),
          _uiTimerIndex( 0xFFFFFFFF ),
          _wIndexingPos( -1 ),
          _wQueryingPos( -1 ),
          _pSnapinData( 0 )
{
    //
    // By default, point at local machine.
    //

    _xwcsMachine[0] = L'.';
    _xwcsMachine[1] = 0;
}

CCatalogs::~CCatalogs()
{
    _fAbort = TRUE;

    if (0xFFFFFFFF != _uiTimerIndex && gaTimerIds[_uiTimerIndex])
    {
        CLock lock(gmtxTimer);

        KillTimer(NULL, gaTimerIds[_uiTimerIndex]);
        gapCats[_uiTimerIndex] = 0;
    }

    if ( 0 != _pScopePane )
        _pScopePane->Release();
}

void CCatalogs::SetMachine( WCHAR const * pwcsMachine )
{
    unsigned cc = wcslen( pwcsMachine ) + 1;

    // Remove leading '\' characters. We don't need them, although they 
    // are commonly included as part of server names
    WCHAR const *pwcsStart = pwcsMachine;
    while ( *pwcsStart == L'\\' )
    {
        cc--;
        pwcsStart++;
    }

    _xwcsMachine.SetSize( cc );

    RtlCopyMemory( _xwcsMachine.Get(), pwcsStart, cc * sizeof(WCHAR) );

    ciaDebugOut((DEB_ITRACE, "Input machine name %ws is converted to %ws\n",
                 pwcsMachine, pwcsStart));
}

void CCatalogs::Init( IConsoleNameSpace * pScopePane )
{
    Win4Assert( 0 == _pScopePane );

    _pScopePane = pScopePane;
    _pScopePane->AddRef();

    // timer stuff
    CLock lock(gmtxTimer);

    gsIndex++;
    gapCats[gsIndex-1] = this;
    _uiTimerIndex = gcMaxCats;
    gaTimerIds[_uiTimerIndex] = SetTimer(NULL, 0, cRefreshDelay, (TIMERPROC)DisplayTimerProc);
    gcMaxCats++;
}

void CCatalogs::InitHeader( CListViewHeader & Header )
{
    //
    // Initialize header
    //

    for ( unsigned i = 0; i < sizeof(coldefCatalog)/sizeof(coldefCatalog[0]); i++ )
    {
        if ( _fFirstTime )
            coldefCatalog[i].srTitle.Init( ghInstance );

        Header.Add( i, STRINGRESOURCE( coldefCatalog[i].srTitle ), LVCFMT_LEFT, MMCLV_AUTO );
    }

    _fFirstTime = FALSE;
}

void CCatalogs::DisplayScope( HSCOPEITEM hScopeItem )
{
    ciaDebugOut(( DEB_ITRACE, "CCatalogs::DisplayScope (hScopeItem = 0x%x)\n", hScopeItem ));

    Populate();

    Win4Assert( 0 != _pScopePane );

    //
    // Squirrel away the parent pointer.
    //

    if ( 0xFFFFFFFF != hScopeItem )
        _hRootScopeItem = hScopeItem;

    if ( _hRootScopeItem == 0xFFFFFFFF )
        return;

    for ( unsigned i = 0; i < _aCatalog.Count(); i++ )
    {
        CCatalog * pCat = _aCatalog.Get( i );

        if ( pCat->IsZombie() )
        {
            _pScopePane->DeleteItem( pCat->ScopeHandle(), TRUE );

            //
            // Delete catalog and move highest entry down.
            //

            pCat = _aCatalog.Acquire( i );
            delete pCat;

            if ( _aCatalog.Count() > 0  && _aCatalog.Count() != i )
            {
                pCat = _aCatalog.Acquire( _aCatalog.Count() - 1 );
                _aCatalog.Add( pCat, i );
                i--;
            }

            continue;
        }

        if (pCat->IsInactive())
        {
            RemoveCatalogFromScope(pCat);
            continue;
        }

        if ( pCat->IsAddedToScope())
            continue;

        AddCatalogToScope(pCat);
    }
}

void CCatalogs::AddCatalogToScope(CCatalog *pCat)
{

    SCOPEDATAITEM item;

    RtlZeroMemory( &item, sizeof(item) );

    item.mask |= SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
    item.nImage = item.nOpenImage = ICON_CATALOG;
    //item.displayname = (WCHAR *)pCat->GetCat( TRUE );  
    item.displayname = MMC_CALLBACK;

    item.mask |= SDI_PARAM;
    item.lParam = (LPARAM)pCat;

    item.relativeID = _hRootScopeItem;

    ciaDebugOut(( DEB_ITRACE, "Inserting scope item %ws (lParam = 0x%x)\n",
                  pCat->GetCat( TRUE ), item.lParam ));

    _pScopePane->InsertItem( &item );

    pCat->SetScopeHandle( item.ID );
}


void CCatalogs::RemoveCatalogFromScope(CCatalog *pCat)
{
    if (pCat->ScopeHandle())
    {
        _pScopePane->DeleteItem( pCat->ScopeHandle(), TRUE );
        pCat->SetScopeHandle(0);
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CCatalogs::ReInit, public
//
//  Synopsis:   Re-Initialize catalogs node to default state
//
//  History:    27-Jul-1998   KyleP   Created
//
//  Notes:      Used when MMCN_REMOVE_CHILDREN is sent to snapin, and we
//              need to blast away all state.
//
//--------------------------------------------------------------------------

SCODE CCatalogs::ReInit()
{
    SCODE sc = S_OK;

    Win4Assert( 0 != _pScopePane );

    _fAbort = TRUE;

    //
    // Get rid of the old timer.
    //

    if ( 0xFFFFFFFF != _uiTimerIndex && gaTimerIds[_uiTimerIndex] )
    {
        CLock lock(gmtxTimer);

        KillTimer(NULL, gaTimerIds[_uiTimerIndex]);
        gapCats[_uiTimerIndex] = 0;
    }

    //
    // And the old catalogs...
    //

    while ( _aCatalog.Count() > 0 )
    {
        RemoveCatalogFromScope( _aCatalog.Get( _aCatalog.Count()-1 ) );
        delete _aCatalog.AcquireAndShrink( _aCatalog.Count()-1 );
    }

    _fAbort = FALSE;

    //
    // Now, a new timer.
    //

    CLock lock2(gmtxTimer);

    gsIndex++;
    gapCats[gsIndex-1] = this;
    _uiTimerIndex = gcMaxCats;
    gaTimerIds[_uiTimerIndex] = SetTimer(NULL, 0, cRefreshDelay, (TIMERPROC)DisplayTimerProc);
    gcMaxCats++;

    return sc;
}

void CCatalogs::Display( BOOL fFirstTime )
{
    ciaDebugOut(( DEB_ITRACE, "CCatalogs::Display (fFirstTime = %d)\n", fFirstTime ));

    for ( unsigned i = 0; i < _aCatalog.Count(); i++ )
    {
        CCatalog * pCat = _aCatalog.Get( i );

        if ( pCat->IsZombie() || !pCat->IsAddedToScope() || pCat->IsInactive() )
            continue;

        if ( pCat->Update() )
        {
            // Ping scope pane...

            SCOPEDATAITEM item;

            RtlZeroMemory( &item, sizeof(item) );

            item.mask |= SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
            item.nImage = item.nOpenImage = ICON_CATALOG;

            //item.displayname = (WCHAR *)pCat->GetCat( TRUE ); 
            item.displayname = MMC_CALLBACK;

            item.mask |= SDI_PARAM;
            item.lParam = (LPARAM)pCat;

            item.ID = pCat->ScopeHandle();

            ciaDebugOut(( DEB_ITRACE, "Ping-ing scope item %ws (lParam = 0x%x)\n",
                          pCat->GetCat( TRUE ), item.lParam ));

            _pScopePane->SetItem( &item );
        }
    }
}

SCODE CCatalogs::AddCatalog( WCHAR const * pwszCatName,
                            WCHAR const * pwszLocation )
{
    SCODE sc = S_OK;

    ciaDebugOut(( DEB_ITRACE,
                  "CCatalogs::AddCatalog( %ws, %ws )\n",
                  pwszCatName, pwszLocation ));
    //
    // First, check to see if the catalog name and location are already used
    //
    for (ULONG i = 0; i < _aCatalog.Count(); i++)
    {
        if (0 == _wcsicmp(_aCatalog[i]->GetCat(TRUE), pwszCatName) ||
            0 == _wcsicmp(_aCatalog[i]->GetDrive(TRUE), pwszLocation))
        {
            return E_INVALIDARG;
        }
    }

    TRY
    {
        //
        // First, add to CI.
        //

        CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

        MachineAdmin.AddCatalog( pwszCatName, pwszLocation );

        //
        // Then, to display.
        //

        XPtr<CCatalog> xCat(new CCatalog( *this, pwszCatName ));

        _aCatalog.Add( xCat.GetPointer(), _aCatalog.Count() );
        xCat.Acquire();
    }
    CATCH(CException, e)
    {
        ciaDebugOut(( DEB_WARN, "AddCatalog( %ws, %ws ) caught exception 0x%x\n",
                      pwszCatName, pwszLocation, sc ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

SCODE CCatalogs::RemoveCatalog( CCatalog * pCat )
{
    ciaDebugOut(( DEB_ITRACE, "CCatalogs::RemoveCatalog( %ws )\n", pCat->GetCat(TRUE) ));

    SCODE sc = S_OK;

    TRY
    {
        //
        // First, remove from CI.
        //

        CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

        MachineAdmin.RemoveCatalog( pCat->GetCat(TRUE), TRUE );
    }
    CATCH (CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    //
    // Then, from display. Go ahead and Zombify even if catalog wasn't successfully
    // removed. Parts of it may have been removed, so it is probably unusable anyway.
    //

    pCat->Zombify();

    return sc;
}

void CCatalogs::Quiesce()
{

    //_Header.Update();
}



void CCatalogs::GetGeneration( BOOL  & fFilterUnknown,
                               BOOL  & fGenerateCharacterization,
                               ULONG & ccCharacterization )
{
    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    DWORD dw;

    //
    // Filter Unknown
    //

    if ( !MachineAdmin.GetDWORDParam( wcsFilterFilesWithUnknownExtensions, dw ) )
        dw = CI_FILTER_FILES_WITH_UNKNOWN_EXTENSIONS_DEFAULT;

    fFilterUnknown = (0 != dw);

    //
    // Characterization. We should check if generatecharacterization flag is set to
    // TRUE and also check the characterization size. Only when the flag is set to TRUE
    // and size > 0, should we generate characterization.
    //

    DWORD dwGenCharacterization = 0;

    if ( !MachineAdmin.GetDWORDParam( wcsGenerateCharacterization, dwGenCharacterization ) )
        dwGenCharacterization = 1;

    if ( !MachineAdmin.GetDWORDParam( wcsMaxCharacterization, ccCharacterization ) )
        ccCharacterization = CI_MAX_CHARACTERIZATION_DEFAULT;

    fGenerateCharacterization = (ccCharacterization > 0) && (0 != dwGenCharacterization);
}

void CCatalogs::SetGeneration( BOOL  fFilterUnknown,
                               BOOL  fGenerateCharacterization,
                               ULONG ccCharacterization )
{
    //
    // fGenerateCharacterization is obsolete.
    //

    if ( !fGenerateCharacterization )
        ccCharacterization = 0;

    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    MachineAdmin.SetDWORDParam( wcsFilterFilesWithUnknownExtensions, fFilterUnknown );
    MachineAdmin.SetDWORDParam( wcsGenerateCharacterization, fGenerateCharacterization );
    MachineAdmin.SetDWORDParam( wcsMaxCharacterization, ccCharacterization );
}

void CCatalogs::GetTracking( BOOL  & fAutoAlias )
{
    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    DWORD dw;

    if ( !MachineAdmin.GetDWORDParam( wcsIsAutoAlias, dw ) )
        dw = CI_IS_AUTO_ALIAS_DEFAULT;

    fAutoAlias = (0 != dw);
}

void CCatalogs::SetTracking( BOOL  fAutoAlias )
{
    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    MachineAdmin.SetDWORDParam( wcsIsAutoAlias, fAutoAlias );
}

void CCatalogs::Populate()
{
    if ( 0 != _aCatalog.Count() )
        return;

    //
    // Populate catalog array.
    //

    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    XPtr<CCatalogEnum> xCatEnum( MachineAdmin.QueryCatalogEnum() );

    while ( 0 != xCatEnum->Next() )
    {
        TRY
        {
            XPtr<CCatalog> xCat(new CCatalog( *this, xCatEnum->Name() ));

            _aCatalog.Add( xCat.GetPointer(), _aCatalog.Count() );
            xCat.Acquire();
        }
        CATCH(CException, e)
        {
            ciaDebugOut((DEB_WARN,
                         "Unable to populate admin's display with catalog %ws on machine %ws\n",
                         xCatEnum->Name(), _xwcsMachine.Get() ));
        }
        END_CATCH
    }
}

// Differs from Populate in that this only adds newly added catalogs to the
// admin's catalog array.

void CCatalogs::PickupNewCatalogs()
{
    //
    // Populate catalog array. Add only newer catalogs
    //

    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    XPtr<CCatalogEnum> xCatEnum( MachineAdmin.QueryCatalogEnum() );

    while ( 0 != xCatEnum->Next() )
    {
        for (ULONG i = 0; i < _aCatalog.Count(); i++)
        {
            if ( 0 == _wcsicmp(xCatEnum->Name(), _aCatalog[i]->GetCat(TRUE)) )
                break;
        }

        // Have we found the catalog? If so, continue with the next one.
        if (i < _aCatalog.Count())
            continue;

        // We haven't found the catalog in the list. Add it.

        TRY
        {
            XPtr<CCatalog> xCat(new CCatalog( *this, xCatEnum->Name() ));

            _aCatalog.Add( xCat.GetPointer(), _aCatalog.Count() );
            xCat.Acquire();
        }
        CATCH(CException, e)
        {
            ciaDebugOut((DEB_WARN,
                         "Unable to populate admin's display with catalog %ws on machine %ws\n",
                         xCatEnum->Name(), _xwcsMachine.Get() ));
        }
        END_CATCH
    }
}

void CCatalogs::UpdateActiveState()
{
    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    // Enumerate all the catalogs and add new additions
    PickupNewCatalogs();

    // Identify what stays and what goes
    for (ULONG i = 0; i < _aCatalog.Count(); i++)
    {
        TRY
        {
            XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _aCatalog[i]->GetCat(TRUE) ) );
            _aCatalog[i]->SetInactive(xCatalogAdmin->IsCatalogInactive());
            if (!_aCatalog[i]->IsInactive() && !_aCatalog[i]->IsAddedToScope())
                AddCatalogToScope(_aCatalog[i]);
        }
        CATCH (CException, e)
        {
            // We have an exception attempting to access a catalog, it is either
            // deleted or has its registry messed up. Remove it from list of displayed scopes.
            RemoveCatalogFromScope(_aCatalog[i]);
            _aCatalog[i]->Zombify();
        }
        END_CATCH
    }

    // Cleanup...
    for ( i = 0; i < _aCatalog.Count(); i++ )
    {
        CCatalog * pCat = _aCatalog.Get( i );

        if ( pCat->IsZombie() )
        {
            _pScopePane->DeleteItem( pCat->ScopeHandle(), TRUE );

            //
            // Delete catalog and move highest entry down.
            //

            pCat = _aCatalog.Acquire( i );
            delete pCat;

            if ( _aCatalog.Count() > 0  && _aCatalog.Count() != i )
            {
                pCat = _aCatalog.Acquire( _aCatalog.Count() - 1 );
                _aCatalog.Add( pCat, i );
                i--;
            }

            continue;
        }

        if ( pCat->IsInactive() )
        {
            if ( pCat->IsAddedToScope() )
                RemoveCatalogFromScope(pCat);

            continue;
        }

        if ( pCat->IsAddedToScope() )
            continue;

        AddCatalogToScope(pCat);
    }
}


//
// Implementation of TuneServicePerformance
// wIndexingPos is on a scale of 1 to 3, where 1 is least aggressive
// and 3 is most aggressive. wQueryingPos is on the same scale.
//

SCODE CCatalogs::TuneServicePerformance()
{
    BOOL fServer = IsNTServer();
    SCODE sc = S_OK;

    // Ensure that these settings were made.
    Win4Assert(_wIndexingPos != -1 && _wQueryingPos != -1);

    TRY
    {
        CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

        MachineAdmin.TunePerformance(fServer, _wIndexingPos, _wQueryingPos);
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        ciDebugOut((DEB_WARN,
                    "Caught exception %d (0x%x) attempting to tune performance.",
                    sc, sc));
    }
    END_CATCH

    return sc;
}


void CCatalogs::SaveServicePerformanceSettings(WORD wIndexingPos, WORD wQueryingPos)
{
   _wIndexingPos = wIndexingPos;
   _wQueryingPos = wQueryingPos;
}


void  CCatalogs::GetServicePerformanceSettings(WORD &wIndexingPos, WORD &wQueryingPos)
{
   wIndexingPos = _wIndexingPos;
   wQueryingPos = _wQueryingPos;
}

SCODE CCatalogs::DisableService()
{
    SCODE sc = S_OK;

    TRY
    {
        CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

        MachineAdmin.StopCI();

        sc = MachineAdmin.DisableCI() ? S_OK : E_FAIL;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        ciDebugOut((DEB_WARN,
                    "Caught exception %d (0x%x) attempting to tune performance.",
                    sc, sc));
    }
    END_CATCH

    return sc;
}

SCODE CCatalogs::EnableService()
{
    SCODE sc = S_OK;

    TRY
    {
        CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

        if ( !MachineAdmin.IsCIEnabled() )
            sc = MachineAdmin.EnableCI() ? S_OK : E_FAIL;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        ciDebugOut((DEB_WARN,
                    "Caught exception %d (0x%x) attempting to enable service",
                    sc, sc));
    }
    END_CATCH

    return sc;
}

SCODE CCatalogs::GetSavedServiceUsage(DWORD &dwUsage,
                                      DWORD &dwIdxPos,
                                      DWORD &dwQryPos)
{
   SCODE sc = S_OK;

   TRY
   {
       CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

       if (!MachineAdmin.GetDWORDParam(wcsServiceUsage, dwUsage))
       {
           // plug in a default value
           dwUsage = wUsedOften;
       }

       if (!MachineAdmin.GetDWORDParam(wcsDesiredIndexingPerf, dwIdxPos))
       {
           // plug in a default value
           dwIdxPos = wMidPos;
       }

       if (!MachineAdmin.GetDWORDParam(wcsDesiredQueryingPerf, dwQryPos))
       {
           // plug in a default value
           dwQryPos = wMidPos;
       }
   }
   CATCH( CException, e )
   {
       sc = e.GetErrorCode();
       ciDebugOut((DEB_WARN,
                   "Caught exception %d (0x%x) attempting to retrieve service usage.",
                   sc, sc));
   }
   END_CATCH

   return sc;
}

SCODE CCatalogs::SaveServiceUsage(DWORD dwUsage,
                                  DWORD dwIdxPos,
                                  DWORD dwQryPos)
{
   SCODE sc = S_OK;

   TRY
   {
       CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

       MachineAdmin.SetDWORDParam(wcsServiceUsage, dwUsage);
       MachineAdmin.SetDWORDParam(wcsDesiredIndexingPerf, dwIdxPos);
       MachineAdmin.SetDWORDParam(wcsDesiredQueryingPerf, dwQryPos);
   }
   CATCH( CException, e )
   {
       sc = e.GetErrorCode();
       ciDebugOut((DEB_WARN,
                   "Caught exception %d (0x%x) attempting to save service usage.",
                   sc, sc));
   }
   END_CATCH

   return sc;
}

void CALLBACK DisplayTimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    CLock lock(gmtxTimer);

    // seek the index of the catalog associated with this timer event
    for (UINT i = 0; i < gcMaxCats; i++)
        if (gaTimerIds[i] == idEvent)
            break;

    if (i >= gcMaxCats)
    {
        Win4Assert(!"How did this happen?");
        return;
    }

    // Fix for bug 150471
    // If the snapin went away just as the timer triggered a timer proc,
    // and the destructor in CCatalogs gets to the lock before this
    // function, then gapCats[i] will be 0. That is what happened in
    CCatalogs *pCats = gapCats[i];

    if (0 == pCats || pCats->_fAbort)
        return;

    // Cause display
    pCats->Display( FALSE );

    // Special case: Update the status of the iconbar. This is only needed for
    // the case where the service was started. Service startup could take a while,
    // and we don't know how long it could take. So we cannot wait to update the
    // display when the service is actually started. Instead, we will check frequently
    // and update the status.



    TRY
    {
        CMachineAdmin   MachineAdmin( pCats->IsLocalMachine() ? 0 : pCats->GetMachine() );

        if ( MachineAdmin.IsCIStarted() && 0 != pCats->SnapinData() )
        {
            pCats->SnapinData()->SetButtonState(comidStartCITop, ENABLED, FALSE);
            pCats->SnapinData()->SetButtonState(comidStopCITop,  ENABLED, TRUE);
            pCats->SnapinData()->SetButtonState(comidPauseCITop, ENABLED, TRUE);

            // We only want to update once after the service has started. If the service
            // is stopped and restarted, the pointer will be set to an appropriate value
            // at a later time, so we can go ahead and get rid of the snapindata ptr for now.

            pCats->SetSnapinData( 0 );
        }
    }
    CATCH(CException, e)
    {
        // Nothing specific to do in this case
    }
    END_CATCH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\cmddlg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       CmdDlg.cxx
//
//  Contents:   Dialogs for all context menu commands
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <CIARes.h>
#include <CmdDlg.hxx>
#include <Catalog.hxx>
#include <cierror.h>
#include <catadmin.hxx>
#include <shlobj.h>

extern "C"
{
    #include <lmcons.h>
}

//
// Local prototypes
//

BOOL GetDlgItemXArrayText( HWND hwndDlg, USHORT idCtrl, XArray<WCHAR> & xawcText );

BOOL BrowseForDirectory( HWND hwndParent,
                         LPCTSTR pszInitialDir,
                         LPTSTR pszBuf,
                         int cchBuf,
                         LPCTSTR pszDialogTitle,
                         BOOL bRemoveTrailingBackslash );

void SetSliderPositions(HWND hwndDlg, WORD wIndexingPos, WORD wQueryingPos);

INT_PTR APIENTRY AddScopeDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    BOOL fRet = FALSE;

    switch ( message )
    {
    case WM_HELP:
    {
        HELPINFO *phi = (HELPINFO *) lParam;

        ciaDebugOut(( DEB_ITRACE, "AddScopeDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                      phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                      phi->iCtrlId, phi->dwContextId ));

        if ( HELPINFO_WINDOW == phi->iContextType )
        {
            switch ( phi->iCtrlId )
            {
                case IDDI_STATIC:
                    break;

                default :
                    DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                    break;
            }
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
        break;
    }

    case WM_INITDIALOG:

        SetWindowLongPtr( hwndDlg, DWLP_USER, lParam );

        SendDlgItemMessage( hwndDlg, IDDI_INCLUDE, BM_SETCHECK, BST_CHECKED, 0 );

        EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), FALSE );
        EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), FALSE );
        EnableWindow( GetDlgItem( hwndDlg, IDOK ), FALSE );

        ciaDebugOut(( DEB_TRACE, "AddScope (WM_INITDIALOG) - 0x%x\n", lParam ));
        fRet = TRUE;
        break;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {

        case IDDI_USER_NAME:
        case IDDI_PASSWORD:
        {
            if ( EN_CHANGE == HIWORD(wParam) )
            {
                XArray<WCHAR> xawcTemp;

                //
                // Only user name needs to be filled. Password can be empty.
                //

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_USER_NAME, xawcTemp ) )
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), xawcTemp.Count() > 0 );
            }

            break;
        }

        case IDDI_DIRPATH:
        {
            if ( EN_CHANGE == HIWORD(wParam) )
            {
                XArray<WCHAR> xawcPath;

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) &&
                     xawcPath.Count() >= 2 &&
                     xawcPath[0] == L'\\' && xawcPath[1] == L'\\' )
                {
                    WCHAR * pwcsSlash = wcschr( xawcPath.GetPointer() + 2, L'\\' );

                    // Assuming the machinename portion can be no longer than MAX_PATH

                    if ( 0 != pwcsSlash && *(pwcsSlash+1) != L'\0' &&
                         (pwcsSlash - xawcPath.GetPointer() - 2) <= MAX_PATH )
                    {
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), TRUE );
                        SetDlgItemText( hwndDlg, IDDI_USER_NAME, L"" );

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), TRUE );
                        SetDlgItemText( hwndDlg, IDDI_PASSWORD, L"" );

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), FALSE );
                        // username/pwd are not essential!
                        EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );
                    }
                    else
                    {
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDOK ), FALSE );
                    }
                }
                else
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), FALSE );
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), FALSE );
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), TRUE );
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), xawcPath.Count() > 0 );
                }
            }
            fRet = TRUE;
            break;
        }

        case IDDI_INCLUDE:
        case IDDI_EXCLUDE:
        {
            EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );
            break;
        }

        case IDDI_BROWSE:
        {
            // Disable the button so users can't launch multiple dialogs simultaneously
            EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), FALSE);

            if ( BN_CLICKED == HIWORD( wParam ) )
            {
                XArray<WCHAR> xawcPath;

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) )
                {
                    if ( xawcPath.IsNull() )
                    {
                        xawcPath.Init( 2 );
                        xawcPath[0] = L'\\';
                        xawcPath[1] = 0;
                    }

                    WCHAR awc[MAX_PATH];

                    if ( BrowseForDirectory( GetParent(hwndDlg),      // Parent
                                             xawcPath.GetPointer(),   // Current path
                                             awc,                     // New path goes here...
                                             MAX_PATH,
                                             0,                       // Title
                                             TRUE ) )                 // Remove trailing slash
                    {
                        SetWindowText( GetDlgItem( hwndDlg, IDDI_DIRPATH ), awc );
                    }

                    EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), TRUE);
                    // Set focus on dialog so user can continue working...
                    SetFocus(hwndDlg);
                }
            }

            fRet = TRUE;
            break;
        }

        case IDOK:
        {
            XArray<WCHAR> xawcPath;
            XArray<WCHAR> xawcAlias;
            XArray<WCHAR> xawcLogon;
            XArray<WCHAR> xawcPassword;

            //
            // Consider adding code to validate path. Warn user if path is invalid.
            // We don't really want to do this as it's a common admin scenario to
            // add paths that don't exist.
            //

            if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) )
            {
                //
                // Local or remote?
                //

                if ( IsWindowEnabled( GetDlgItem( hwndDlg, IDDI_ALIAS ) ) )
                {
                    GetDlgItemXArrayText( hwndDlg, IDDI_ALIAS, xawcAlias );
                }
                else
                {
                    GetDlgItemXArrayText( hwndDlg, IDDI_USER_NAME, xawcLogon );
                    GetDlgItemXArrayText( hwndDlg, IDDI_PASSWORD, xawcPassword );
                }

                BOOL fInclude = ( BST_CHECKED == IsDlgButtonChecked( hwndDlg, IDDI_INCLUDE ) );
                Win4Assert( fInclude == ( BST_UNCHECKED == IsDlgButtonChecked( hwndDlg, IDDI_EXCLUDE ) ));

                CCatalog * pCat= (CCatalog *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                SCODE sc = pCat->AddScope(  xawcPath.GetPointer(),
                                            xawcAlias.GetPointer(),
                                            !fInclude,
                                            xawcLogon.GetPointer(),
                                            xawcPassword.GetPointer() ? xawcPassword.GetPointer() : L"" );

                if ( !xawcPassword.IsNull() )
                {
                    SecureZeroMemory( xawcPassword.GetPointer(),
                                      xawcPassword.SizeOf() );
                }

                if ( SUCCEEDED(sc) )
                    EndDialog( hwndDlg, TRUE );
                else
                {
                    WCHAR * pBuf = 0;

                    //
                    // Convert Win32 errors back from HRESULT
                    //

                    if ( (sc & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
                        sc &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );

                    ULONG cchAvailMessage = 1024;

                    if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"query.dll"),
                                         sc,
                                         0,
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 ) &&
                         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"kernel32.dll"),
                                         sc,
                                         0,
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 )
                        )
                    {
                        MessageBox(hwndDlg, STRINGRESOURCE( srCMUnexpectedError ),
                                   STRINGRESOURCE( srCMInvalidScope ), MB_ICONHAND);
                    }
                    else
                    {
                        MessageBox(hwndDlg, pBuf,
                                   STRINGRESOURCE( srCMInvalidScope ), MB_ICONHAND);

                        LocalFree( pBuf );
                    }
                }
            }

            fRet = TRUE;
            break;
        }

        case IDCANCEL:
            ciaDebugOut(( DEB_ITRACE, "AddScope (WM_COMMAND, IDCANCEL) - 0x%x\n",
                          GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
            EndDialog( hwndDlg, FALSE );
        }
    }

    return fRet;
}

// Modify the directory settings

INT_PTR APIENTRY ModifyScopeDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    BOOL fRet = FALSE;

    switch ( message )
    {
    case WM_HELP:
    {
        HELPINFO *phi = (HELPINFO *) lParam;

        ciaDebugOut(( DEB_ITRACE, "ModifyScopeDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                      phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                      phi->iCtrlId, phi->dwContextId ));

        if ( HELPINFO_WINDOW == phi->iContextType )
        {
            switch ( phi->iCtrlId )
            {
                case IDDI_STATIC:
                    break;

                default :
                    DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                    break;
            }
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
        break;
    }

    case WM_INITDIALOG:
    {
        CScope *pScope = (CScope *)lParam;

        SetWindowLongPtr( hwndDlg, DWLP_USER, lParam );

        SendDlgItemMessage( hwndDlg, IDDI_INCLUDE, BM_SETCHECK, BST_CHECKED, 0 );

        SendDlgItemMessage( hwndDlg, IDDI_INCLUDE, BM_SETCHECK,
                            pScope->IsIncluded() ? BST_CHECKED : BST_UNCHECKED, 0);
        SendDlgItemMessage( hwndDlg, IDDI_EXCLUDE, BM_SETCHECK,
                            pScope->IsIncluded() ? BST_UNCHECKED : BST_CHECKED, 0);
        SetDlgItemText( hwndDlg, IDDI_DIRPATH, pScope->GetPath() );

        if (0 != pScope->GetAlias())
            SetDlgItemText( hwndDlg, IDDI_ALIAS, pScope->GetAlias() );

        WCHAR szBuffer[UNLEN + 1];

        Win4Assert(UNLEN >= PWLEN);

        szBuffer[0] = 0;
        pScope->GetUsername(szBuffer);
        SetDlgItemText( hwndDlg, IDDI_USER_NAME, szBuffer );
        szBuffer[0] = 0;
        pScope->GetPassword(szBuffer);
        SetDlgItemText( hwndDlg, IDDI_PASSWORD, szBuffer );

        ciaDebugOut(( DEB_ITRACE, "ModifyScope (WM_INITDIALOG) - 0x%x\n", lParam ));

        fRet = TRUE;
        break;
    }

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {

        case IDDI_USER_NAME:
        case IDDI_PASSWORD:
        {
            if ( EN_CHANGE == HIWORD(wParam) )
            {
                XArray<WCHAR> xawcTemp;

                //
                // Only user name needs to be filled. Password can be empty.
                //

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_USER_NAME, xawcTemp ) )
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), xawcTemp.Count() > 0 );
            }

            break;
        }

        // make sure to enable OK button on modify when this is touched
        // irrespective of the change.
        case IDDI_ALIAS:
            if ( EN_CHANGE == HIWORD(wParam) )
                EnableWindow( GetDlgItem(hwndDlg, IDOK), TRUE );
            break;

        case IDDI_DIRPATH:
        {
            if ( EN_CHANGE == HIWORD(wParam) )
            {
                XArray<WCHAR> xawcPath;

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) &&
                     xawcPath.Count() >= 2 &&
                     xawcPath[0] == L'\\' && xawcPath[1] == L'\\' )
                {
                    WCHAR * pwcsSlash = wcschr( xawcPath.GetPointer() + 2, L'\\' );

                    // Assuming the machinename portion can be no longer than MAX_PATH

                    if ( 0 != pwcsSlash && *(pwcsSlash+1) != L'\0' &&
                         (pwcsSlash - xawcPath.GetPointer() - 2) <= MAX_PATH )
                    {
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), TRUE );
                        SetDlgItemText( hwndDlg, IDDI_USER_NAME, L"" );

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), TRUE );
                        SetDlgItemText( hwndDlg, IDDI_PASSWORD, L"" );

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), FALSE );
                        // username/pwd are not essential!
                        EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );
                    }
                    else
                    {
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDOK ), FALSE );
                    }
                }
                else
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), FALSE );
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), FALSE );
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), TRUE );
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), xawcPath.Count() > 0 );
                }
            }
            fRet = TRUE;
            break;
        }

        case IDDI_INCLUDE:
        case IDDI_EXCLUDE:
        {
            EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );
            break;
        }

        case IDDI_BROWSE:
        {
            // Disable the button so users can't launch multiple dialogs simultaneously
            EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), FALSE);

            if ( BN_CLICKED == HIWORD( wParam ) )
            {
                XArray<WCHAR> xawcPath;

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) )
                {
                    if ( xawcPath.IsNull() )
                    {
                        xawcPath.Init( 2 );
                        xawcPath[0] = L'\\';
                        xawcPath[1] = 0;
                    }

                    WCHAR awc[MAX_PATH];

                    if ( BrowseForDirectory( GetParent(hwndDlg),      // Parent
                                             xawcPath.GetPointer(),   // Current path
                                             awc,                     // New path goes here...
                                             MAX_PATH,
                                             0,                       // Title
                                             TRUE ) )                 // Remove trailing slash
                    {
                        SetWindowText( GetDlgItem( hwndDlg, IDDI_DIRPATH ), awc );
                    }

                    EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), TRUE);
                    // Set focus on dialog so user can continue working...
                    SetFocus(hwndDlg);
                }
            }

            fRet = TRUE;
            break;
        }

        case IDOK:
        {
            XArray<WCHAR> xawcPath;
            XArray<WCHAR> xawcAlias;
            XArray<WCHAR> xawcLogon;
            XArray<WCHAR> xawcPassword;

            //
            // Consider adding code to validate path. Warn user if path is invalid.
            // We don't really want to do this as it's a common admin scenario to
            // add paths that don't exist.
            //

            if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) )
            {
                //
                // Local or remote?
                //

                if ( IsWindowEnabled( GetDlgItem( hwndDlg, IDDI_ALIAS ) ) )
                {
                    GetDlgItemXArrayText( hwndDlg, IDDI_ALIAS, xawcAlias );
                }
                else
                {
                    GetDlgItemXArrayText( hwndDlg, IDDI_USER_NAME, xawcLogon );
                    GetDlgItemXArrayText( hwndDlg, IDDI_PASSWORD, xawcPassword );
                }

                BOOL fInclude = ( BST_CHECKED == IsDlgButtonChecked( hwndDlg, IDDI_INCLUDE ) );
                Win4Assert( fInclude == ( BST_UNCHECKED == IsDlgButtonChecked( hwndDlg, IDDI_EXCLUDE ) ));

                CScope * pScope= (CScope *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                SCODE sc = pScope->GetCatalog().ModifyScope(  *pScope,
                                                              xawcPath.GetPointer(),
                                                              xawcAlias.GetPointer(),
                                                              !fInclude,
                                                              xawcLogon.GetPointer(),
                                                              xawcPassword.GetPointer() ? xawcPassword.GetPointer() : L"" );

                if ( !xawcPassword.IsNull() )
                {
                    SecureZeroMemory( xawcPassword.GetPointer(),
                                      xawcPassword.SizeOf() );
                }

                if ( SUCCEEDED(sc) )
                    EndDialog( hwndDlg, TRUE );
                else
                {
                    WCHAR * pBuf = 0;

                    //
                    // Convert Win32 errors back from HRESULT
                    //

                    if ( (sc & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
                        sc &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );

                    ULONG cchAvailMessage = 1024;

                    if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"query.dll"),
                                         sc,
                                         0,
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 ) &&
                         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"kernel32.dll"),
                                         sc,
                                         0,
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 )
                        )
                    {
                        MessageBox(hwndDlg, STRINGRESOURCE( srCMUnexpectedError ),
                                   STRINGRESOURCE( srCMInvalidScope ), MB_ICONHAND);
                    }
                    else
                    {
                        MessageBox(hwndDlg, pBuf,
                                   STRINGRESOURCE( srCMInvalidScope ), MB_ICONHAND);

                        LocalFree( pBuf );
                    }
                }
            }

            fRet = TRUE;
            break;
        }

        case IDCANCEL:
            ciaDebugOut(( DEB_ITRACE, "ModifyScope (WM_COMMAND, IDCANCEL) - 0x%x\n",
                          GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
            EndDialog( hwndDlg, FALSE );
        }
    }

    return fRet;
}

INT_PTR APIENTRY WksTunePerfDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
   BOOL fRet = FALSE;
   static DWORD dwUsage, dwIndexPos, dwQueryPos;

   switch (message)
   {
      case WM_HELP:
      {
          HELPINFO *phi = (HELPINFO *) lParam;

          ciaDebugOut(( DEB_ITRACE, "WksTunePerfDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                        phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                        phi->iCtrlId, phi->dwContextId ));

          if ( HELPINFO_WINDOW == phi->iContextType )
          {
              switch ( phi->iCtrlId )
              {
                  case IDDI_STATIC:
                      break;

                  default :
                      DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                      break;
              }
          }
          break;
      }


      case WM_CONTEXTMENU:
      {
          DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
          break;
      }

      case WM_INITDIALOG:
      {
         ciaDebugOut(( DEB_ITRACE, "WksTunePerfDlg (WM_INITDIALOG) - 0x%x\n", lParam ));

         SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)lParam );

         // Initialize the dialog.
         CCatalogs *pCats = (CCatalogs *)lParam;
         pCats->GetSavedServiceUsage(dwUsage, dwIndexPos, dwQueryPos);

         switch (dwUsage)
         {
            case wUsedOften:
               SendDlgItemMessage( hwndDlg, IDDI_USEDOFTEN, BM_SETCHECK, BST_CHECKED, 0 );
               pCats->SaveServicePerformanceSettings(wHighPos, wMidPos);
               break;

            case wUsedOccasionally:
               SendDlgItemMessage( hwndDlg, IDDI_USEDOCCASIONALLY, BM_SETCHECK, BST_CHECKED, 0 );
               pCats->SaveServicePerformanceSettings(wLowPos, wLowPos);
               break;

            case wNeverUsed:
               SendDlgItemMessage( hwndDlg, IDDI_NEVERUSED, BM_SETCHECK, BST_CHECKED, 0 );
               break;

            case wCustom:
               SendDlgItemMessage( hwndDlg, IDDI_CUSTOMIZE, BM_SETCHECK, BST_CHECKED, 0 );
               pCats->SaveServicePerformanceSettings((WORD)dwIndexPos, (WORD)dwQueryPos);
               break;

            case wDedicatedServer:
            default:
               Win4Assert(!"How did we get here?");
               break;
         }

         EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), dwUsage == wCustom);

         fRet = TRUE;
      }
      break;


   case WM_COMMAND:
   {
       CCatalogs *pCats = (CCatalogs *)GetWindowLongPtr(hwndDlg, DWLP_USER);

       switch ( LOWORD( wParam ) )
       {
          case IDDI_USEDOFTEN:
             if (BN_CLICKED == HIWORD(wParam))
             {
                 EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                 pCats->SaveServicePerformanceSettings(wHighPos, wMidPos);
                 dwUsage = wUsedOften;
             }
             break;

          case IDDI_USEDOCCASIONALLY:
             if (BN_CLICKED == HIWORD(wParam))
             {
                 EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                 pCats->SaveServicePerformanceSettings(wMidPos, wLowPos);
                 dwUsage = wUsedOccasionally;
             }
             break;

          case IDDI_NEVERUSED:
             if (BN_CLICKED == HIWORD(wParam))
             {
                 EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                 dwUsage = wNeverUsed;
             }
             break;

          case IDDI_CUSTOMIZE:
             if (BN_CLICKED == HIWORD(wParam))
             {
                 EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), TRUE);
                 dwUsage = wCustom;
                 pCats->SaveServicePerformanceSettings((WORD)dwIndexPos, (WORD)dwQueryPos);
             }
             break;

          case IDDI_ADVANCED:
          {
             pCats->SetServiceUsage(dwUsage);
             DialogBoxParam( ghInstance,                         // Application instance
                             MAKEINTRESOURCE( IDD_ADVANCED_INFO ), // Dialog box
                             hwndDlg,                      // main frame window
                             AdvPerfTuneDlg,                      // Dialog box function
                             (LPARAM)pCats );   // User parameter
             break;
          }

          case IDOK:
          {
              fRet = TRUE;

              if (wNeverUsed == dwUsage)
              {
                 int iResult;

                 iResult = MessageBox( GetFocus(), STRINGRESOURCE( srCMShutdownService ),
                                  STRINGRESOURCE( srCMShutdownServiceTitle ),
                                  MB_YESNO | /* MB_HELP | */
                                  MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );

                  switch ( iResult )
                  {
                  case IDYES:
                  {
                      SCODE sc = pCats->DisableService();
                      if (FAILED(sc))
                      {
                          MessageBox( GetFocus(), STRINGRESOURCE( srCMCantShutdownService ),
                                      STRINGRESOURCE( srCMShutdownServiceTitle ),
                                      MB_OK | /* MB_HELP | */
                                      MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );
                      }
                      // Fall through and close the dialog.
                  }
                  case IDNO:
                  default:
                      // Do nothing. Just close the dialog

                      EndDialog( hwndDlg, TRUE );
                      break;
                 }
                 break;
              }

              SCODE sc = pCats->TuneServicePerformance();

              if (FAILED(sc))
              {
                 // Inform user that performance tuning didn't go through.
                 // The only reason this happens is if the registry params couldn't be set, which
                 // should be a rare occurrence.
                 MessageBox( GetFocus(), STRINGRESOURCE( srCMCantSaveSettings ),
                             STRINGRESOURCE( srCMTunePerformance ),
                             MB_OK | /* MB_HELP | */
                             MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );

                 // About the only reason I can think of that could cause registry
                 // save to fail is if the registry was messed up. In that case, does it
                 // matter if we only saved part of what we wanted to save? Or should we be
                 // careful enough to remember the old settings and restore the registry to
                 // previous state in case we get here?
                 // No real reason to roll back.  There is no actually data loss or confusion.
              }

              if ( wNeverUsed != dwUsage )
              {
                  pCats->EnableService();
              }

              // The Advanced dialog takes care of setting custom settings
              // We don't want to set them here because dwIndexPos and dwQueryPos
              // have not been refreshed from registry since Adv dlg wrote them.

              if ( dwUsage != wCustom)
              {
                  sc = pCats->SaveServiceUsage(dwUsage, dwIndexPos, dwQueryPos);
              }

              // Not much to do if SaveServiceUsage fails. Just move on.

              EndDialog( hwndDlg, TRUE );
              break;
          }

          case IDCANCEL:
              ciaDebugOut(( DEB_TRACE, "WksTunePerfDlg (WM_COMMAND, IDCANCEL) - 0x%x\n",
                            GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
              EndDialog( hwndDlg, FALSE );
       }
   }  // wm_command
   }  // message

   return fRet;
}


INT_PTR APIENTRY SrvTunePerfDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    BOOL fRet = FALSE;
    static DWORD dwUsage, dwOldUsage, dwIndexPos, dwQueryPos;

    switch (message)
    {
       case WM_HELP:
       {
           HELPINFO *phi = (HELPINFO *) lParam;

           ciaDebugOut(( DEB_ITRACE, "SrvTunePerfDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                         phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                         phi->iCtrlId, phi->dwContextId ));

           if ( HELPINFO_WINDOW == phi->iContextType )
           {
               switch ( phi->iCtrlId )
               {
                   case IDDI_STATIC:
                       break;

                   default :
                       DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                       break;
               }

           }
           break;
       }

       case WM_CONTEXTMENU:
       {
          DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
          break;
       }

       case WM_INITDIALOG:
       {
          ciaDebugOut(( DEB_ITRACE, "SrvTunePerfDlg (WM_INITDIALOG) - 0x%x\n", lParam ));

          SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)lParam );

          // Initialize the dialog.
          CCatalogs *pCats = (CCatalogs *)lParam;
          pCats->GetSavedServiceUsage(dwUsage, dwIndexPos, dwQueryPos);
          dwOldUsage = dwUsage;
          switch (dwUsage)
          {
             case wDedicatedServer:
                SendDlgItemMessage( hwndDlg, IDDI_DEDICATED, BM_SETCHECK, BST_CHECKED, 0 );
                pCats->SaveServicePerformanceSettings(wHighPos, wHighPos);
                break;

             case wUsedOften:
                SendDlgItemMessage( hwndDlg, IDDI_USEDOFTEN, BM_SETCHECK, BST_CHECKED, 0 );
                pCats->SaveServicePerformanceSettings(wHighPos, wMidPos);
                break;

             case wUsedOccasionally:
                SendDlgItemMessage( hwndDlg, IDDI_USEDOCCASIONALLY, BM_SETCHECK, BST_CHECKED, 0 );
                pCats->SaveServicePerformanceSettings(wMidPos, wLowPos);
                break;

             case wCustom:
                SendDlgItemMessage( hwndDlg, IDDI_CUSTOMIZE, BM_SETCHECK, BST_CHECKED, 0 );
                pCats->SaveServicePerformanceSettings((WORD)dwIndexPos, (WORD)dwQueryPos);
                break;

             case wNeverUsed:
                SendDlgItemMessage( hwndDlg, IDDI_NEVERUSED, BM_SETCHECK, BST_CHECKED, 0 );
                break;

             default:
                Win4Assert(!"How did we get here?");
                break;
          }

          EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), dwUsage == wCustom);

          fRet = TRUE;
       }
       break;


    case WM_COMMAND:
    {
        CCatalogs *pCats = (CCatalogs *)GetWindowLongPtr(hwndDlg, DWLP_USER);

        switch ( LOWORD( wParam ) )
        {
           case IDDI_DEDICATED:
              if (BN_CLICKED == HIWORD(wParam))
              {
                  EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                  pCats->SaveServicePerformanceSettings(wHighPos, wHighPos);
                  dwUsage = wDedicatedServer;
              }
              break;

           case IDDI_USEDOFTEN:
              if (BN_CLICKED == HIWORD(wParam))
              {
                  EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                  pCats->SaveServicePerformanceSettings(wHighPos, wMidPos);
                  dwUsage = wUsedOften;
              }
              break;

           case IDDI_USEDOCCASIONALLY:
              if (BN_CLICKED == HIWORD(wParam))
              {
                  EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                  pCats->SaveServicePerformanceSettings(wMidPos, wLowPos);
                  dwUsage = wUsedOccasionally;
              }
              break;

           case IDDI_NEVERUSED:
              if (BN_CLICKED == HIWORD(wParam))
              {
                  EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                  dwUsage = wNeverUsed;
              }
              break;

           case IDDI_CUSTOMIZE:
              if (BN_CLICKED == HIWORD(wParam))
              {
                  EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), TRUE);
                  pCats->SaveServicePerformanceSettings((WORD)dwIndexPos, (WORD)dwQueryPos);
                  dwUsage = wCustom;
              }
              break;

           case IDDI_ADVANCED:
           {
              pCats->SetServiceUsage(dwUsage);
              DialogBoxParam( ghInstance,                         // Application instance
                              MAKEINTRESOURCE( IDD_ADVANCED_INFO ), // Dialog box
                              hwndDlg,                      // main frame window
                              AdvPerfTuneDlg,                      // Dialog box function
                              (LPARAM)pCats );   // User parameter
              break;
           }

           case IDOK:
           {
               fRet = TRUE;

               // only pop up the messagebox if old dwUsage != wNeverUsed
               if (wNeverUsed == dwUsage)
               {
                   if ( wNeverUsed != dwOldUsage )
                   {
                       
                       int iResult;

                       iResult = MessageBox( GetFocus(), STRINGRESOURCE( srCMShutdownService ),
                                             STRINGRESOURCE( srCMShutdownServiceTitle ),
                                             MB_YESNO | /* MB_HELP | */
                                             MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );

                       switch ( iResult )
                       {
                           case IDYES:
                           {
                               SCODE sc = pCats->DisableService();
                               if (FAILED(sc))
                               {
                                   MessageBox( GetFocus(), STRINGRESOURCE( srCMCantShutdownService ),
                                               STRINGRESOURCE( srCMShutdownServiceTitle ),
                                               MB_OK | /* MB_HELP | */
                                               MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );
                               }
                               else
                               {
                                   pCats->SaveServiceUsage(dwUsage, dwIndexPos, dwQueryPos);
                               }
                               // Fall through and close the dialog.
                           }
                           case IDNO:
                           default:
                           // Do nothing. Just close the dialog

                           EndDialog( hwndDlg, TRUE );
                           break;
                       }
                       break;
                   }
                   else
                   {
                       EndDialog( hwndDlg, FALSE );
                       break;
                   }
               }

               SCODE sc = pCats->TuneServicePerformance();

               if (FAILED(sc))
               {
                  // Inform user that performance tuning didn't go through.
                  // The only reason this happens is if the registry params couldn't be set, which
                  // should be a rare occurrence.
                  MessageBox( GetFocus(), STRINGRESOURCE( srCMCantSaveSettings ),
                              STRINGRESOURCE( srCMTunePerformance ),
                              MB_OK | /* MB_HELP | */
                              MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );

                  // About the only reason I can think of that could cause registry
                  // save to fail is if the registry was messed up. In that case, does it
                  // matter if we only saved part of what we wanted to save? Or should we be
                  // careful enough to remember the old settings and restore the registry to
                  // previous state in case we get here?
                  // No real reason to roll back.  There is no actually data loss or confusion.
                  //
               }

               if ( wNeverUsed != dwUsage )
               {
                   pCats->EnableService();
               }

               // The Advanced dialog takes care of setting custom settings
               // We don't want to set them here because dwIndexPos and dwQueryPos
               // have not been refreshed from registry since Adv dlg wrote them.

               if ( dwUsage != wCustom)
               {
                   sc = pCats->SaveServiceUsage(dwUsage, dwIndexPos, dwQueryPos);
               }

               // Not much to do if SaveServiceUsage fails. Just move on.

               EndDialog( hwndDlg, TRUE );
               break;
           }

           case IDCANCEL:
               ciaDebugOut(( DEB_TRACE, "SrvTunePerfDlg (WM_COMMAND, IDCANCEL) - 0x%x\n",
                             GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
               EndDialog( hwndDlg, FALSE );
        }
    } // wm_command
    } // message

    return fRet;
}

INT_PTR APIENTRY AdvPerfTuneDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
   BOOL fRet = FALSE;
   switch (message)
   {
       case WM_HELP:
       {
           HELPINFO *phi = (HELPINFO *) lParam;

           ciaDebugOut(( DEB_ITRACE, "AdvPerfTuneDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                         phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                         phi->iCtrlId, phi->dwContextId ));

           if ( HELPINFO_WINDOW == phi->iContextType )
           {
               switch ( phi->iCtrlId )
               {
                   case IDDI_STATIC:
                   case IDDI_LOWLOAD:
                   case IDDI_HIGHLOAD:
                   case IDDI_LAZY:
                   case IDDI_INSTANT:
                       break;

                   default :
                       DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                       break;
               }

           }
           break;
       }

      case WM_CONTEXTMENU:
      {
          DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
          break;
      }

      case WM_INITDIALOG:
      {
         // Prepare the controls
         SendDlgItemMessage(hwndDlg, IDDI_SLIDER_INDEXING, TBM_SETRANGE, TRUE, MAKELONG(wLowPos, wHighPos));
         SendDlgItemMessage(hwndDlg, IDDI_SLIDER_QUERYING, TBM_SETRANGE, TRUE, MAKELONG(wLowPos, wHighPos));

         // Set the dialog based on lParam
         DWORD dwUsage, dwIndexingPos, dwQueryingPos;
         CCatalogs *pCats = (CCatalogs *)lParam;
         pCats->GetSavedServiceUsage(dwUsage, dwIndexingPos, dwQueryingPos);
         SetSliderPositions(hwndDlg, (WORD)dwIndexingPos, (WORD)dwQueryingPos);
         SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)lParam );

         fRet = TRUE;
      }
      break;

      case WM_COMMAND:
         switch (LOWORD(wParam))
         {
            case IDOK:
            {
               fRet = TRUE;

               WORD wIdxPos = (WORD)SendDlgItemMessage(hwndDlg, IDDI_SLIDER_INDEXING, TBM_GETPOS, 0, 0);
               WORD wQryPos = (WORD)SendDlgItemMessage(hwndDlg, IDDI_SLIDER_QUERYING, TBM_GETPOS, 0, 0);

               CCatalogs *pCats = (CCatalogs *)GetWindowLongPtr(hwndDlg, DWLP_USER);
               pCats->SaveServicePerformanceSettings(wIdxPos, wQryPos);
               pCats->SaveServiceUsage(wCustom, wIdxPos, wQryPos);

               EndDialog( hwndDlg, TRUE );
               break;
            }

            case IDCANCEL:
               ciaDebugOut(( DEB_TRACE, "AdvPerfTuneDlg (WM_COMMAND, IDCANCEL) - 0x%x\n",
                             GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
               EndDialog( hwndDlg, FALSE );
         }
   }

   return fRet;
}

void SetSliderPositions(HWND hwndDlg, WORD wIndexingPos, WORD wQueryingPos)
{
   SendDlgItemMessage(hwndDlg, IDDI_SLIDER_INDEXING, TBM_SETPOS, TRUE, (LONG)wIndexingPos);
   SendDlgItemMessage(hwndDlg, IDDI_SLIDER_QUERYING, TBM_SETPOS, TRUE, (LONG)wQueryingPos);
}

INT_PTR APIENTRY AddCatalogDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    BOOL fRet = FALSE;

    switch ( message )
    {
    case WM_HELP:
    {
        HELPINFO *phi = (HELPINFO *) lParam;

        ciaDebugOut(( DEB_ITRACE, "AddCatalogDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                      phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                      phi->iCtrlId, phi->dwContextId ));

        if ( HELPINFO_WINDOW == phi->iContextType )
        {
            switch ( phi->iCtrlId )
            {
                case IDDI_STATIC:
                    break;

                default :
                    DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                    break;
            }

        }
        break;
    }


    case WM_CONTEXTMENU:
    {
        DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
        break;
    }

    case WM_INITDIALOG:

        ciaDebugOut(( DEB_ITRACE, "AddCatalogDlg (WM_INITDIALOG) - 0x%x\n", lParam ));

        SetWindowLongPtr( hwndDlg, DWLP_USER, lParam );

        fRet = TRUE;
        break;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDDI_CATNAME2:
        case IDDI_CATPATH:
            if ( EN_CHANGE == HIWORD(wParam) )
            {
                //
                // If both fields have data, then enable OK button.
                //

                WCHAR wcsTest[10];

                if ( 0 == GetDlgItemText( hwndDlg, IDDI_CATNAME2, wcsTest, sizeof(wcsTest) / sizeof(WCHAR) ) ||
                     0 == GetDlgItemText( hwndDlg, IDDI_CATPATH, wcsTest, sizeof(wcsTest) / sizeof(WCHAR) ) )
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), FALSE );
                }
                else
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );
                }
            }
            fRet = TRUE;
            break;

        case IDDI_BROWSE:
        {
            if ( BN_CLICKED == HIWORD( wParam ) )
            {
                // Disable the button so users can't launch multiple dialogs simultaneously
                EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), FALSE);

                XArray<WCHAR> xawcPath;

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_CATPATH, xawcPath ) )
                {
                    if ( xawcPath.IsNull() )
                    {
                        xawcPath.Init( 2 );
                        xawcPath[0] = L'\\';
                        xawcPath[1] = 0;
                    }

                    WCHAR awc[MAX_PATH];

                    if ( BrowseForDirectory( GetParent(hwndDlg),      // Parent
                                             xawcPath.GetPointer(),   // Current path
                                             awc,                     // New path goes here...
                                             MAX_PATH,
                                             0,                       // Title
                                             TRUE ) )                 // Remove trailing slash
                    {
                        SetWindowText( GetDlgItem( hwndDlg, IDDI_CATPATH ), awc );
                    }

                    // Re-enable the button
                    EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), TRUE);
                    // Set focus on dialog so user can continue working...
                    SetFocus(hwndDlg);
                }
            }

            fRet = TRUE;
            break;
        }

        case IDOK:
        {
            XArray<WCHAR> xawcCatName;
            XArray<WCHAR> xawcPath;

            if ( GetDlgItemXArrayText( hwndDlg, IDDI_CATNAME2, xawcCatName ) &&
                 GetDlgItemXArrayText( hwndDlg, IDDI_CATPATH, xawcPath ) )
            {
                CCatalogs * pCats= (CCatalogs *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                TRY
                {
                    SCODE sc = pCats->AddCatalog( xawcCatName.GetPointer(),
                                                  xawcPath.GetPointer() );

                    if (FAILED(sc))
                    {
                        MessageBox(hwndDlg,
                                   STRINGRESOURCE( srNCError ),
                                   STRINGRESOURCE( srNCErrorT ),
                                   MB_ICONHAND);
                    }
                    else
                    {
                        MessageBox( hwndDlg,
                                    STRINGRESOURCE( srNC ),
                                    STRINGRESOURCE( srNCT ),
                                    MB_OK | MB_ICONWARNING );

                        EndDialog( hwndDlg, TRUE );
                    }
                }
                CATCH( CException, e )
                {
                    WCHAR * pBuf = 0;

                    SCODE sc = GetOleError(e);

                    //
                    // Convert Win32 errors back from HRESULT
                    //

                    if ( (sc & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
                        sc &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );

                    if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"query.dll"),
                                         sc,
                                         GetSystemDefaultLCID(),
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 ) &&
                         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"kernel32.dll"),
                                         sc,
                                         GetSystemDefaultLCID(),
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 ) )
                    {
                        StringResource srGenericError = { MSG_GENERIC_ERROR };
                        srGenericError.Init( ghInstance );

                        unsigned cc = wcslen( STRINGRESOURCE(srGenericError) ) +
                                      11; // 0xnnnnnnnn + null

                        XArray<WCHAR> xawcText( cc );

                        wsprintf( xawcText.Get(),
                                  STRINGRESOURCE(srGenericError),
                                  GetOleError( e ) );

                        MessageBox( hwndDlg,
                                    xawcText.Get(),
                                    STRINGRESOURCE( srIndexServerCmpManage ),
                                    MB_OK | MB_ICONERROR );
                    }
                    else
                    {
                        MessageBox( hwndDlg,
                                    pBuf,
                                    STRINGRESOURCE( srIndexServerCmpManage ),
                                    MB_OK | MB_ICONERROR );

                        LocalFree( pBuf );
                    }

                }
                END_CATCH
            }

            fRet = TRUE;
            break;
        }

        case IDCANCEL:
            ciaDebugOut(( DEB_TRACE, "AddCatalogDlg (WM_COMMAND, IDCANCEL) - 0x%x\n",
                          GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
            EndDialog( hwndDlg, FALSE );
        }
    }

    return fRet;
}

BOOL GetDlgItemXArrayText( HWND hwndDlg, USHORT idCtrl, XArray<WCHAR> & xawcText )
{
    Win4Assert( 0 == xawcText.Count() );

    xawcText.Init( 5 );  // Start with some default size.

    while ( TRUE )
    {
        unsigned cc = GetDlgItemText( hwndDlg, idCtrl, xawcText.GetPointer(), xawcText.Count() );

        if ( 0 == cc )
        {
            xawcText.Free();
            break;
        }

        if ( cc != (xawcText.Count() - 1) )
            break;

        cc = xawcText.Count() * 2;

        xawcText.Free();
        xawcText.Init( cc );
    }

    if ( !xawcText.IsNull() && 0 == xawcText[0] )
        xawcText.Free();

    return TRUE;
}

// Used to initialize the browse directory dialog with the start root

int InitStartDir( HWND hwnd,
                  UINT uMsg,
                  LPARAM lParam,
                  LPARAM lpData)
{
    // we just capture Init Message
    if (BFFM_INITIALIZED == uMsg)
    {
        // we expect lpData to be our start path
        SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM)TRUE, lpData);
    }

    return 0;
}

//----------------------------------------------------------------------------
// Procedure    BrowseForDirectory
//
// Purpose      Displays a dialog that lets the user choose a directory
//              name, either local or UNC.
//
// Parameters   hwndParent              Parent window for the dialog
//              pszInitialDir           Directory to use as the default
//              pszBuf                  Where to store the answer
//              chBuf                   Number of characters in this buffer
//              szDialogTitle           Title for the dialog
//
// Returns      nonzero if successful, zero if not.  If successful, pszBuf
//              will be filled with the full pathname of the chosen directory.
//
// History              10/06/95        KenSh           Created
//                      10/09/95        KenSh           Use lCustData member instead of global
//                      10/28/98        KrishnaN        Using Shell's folder browser
//
//----------------------------------------------------------------------------

BOOL BrowseForDirectory(
                HWND hwndParent,
                LPCTSTR pszInitialDir,
                LPTSTR pszBuf,
                int cchBuf,
                LPCTSTR pszDialogTitle,
                BOOL bRemoveTrailingBackslash )
{
    // Get the necessary interfaces at the beginning. If we fail, we can return
    // immediately.

    // Caller is responsible for cleaning up the pidl returned by the shell
    // NOTE: Docs don't explicitly mention if SHGetMalloc refcounts it. It is
    // COMmon sense that it does, and NT sources supports it. So Release it after use.
    XInterface<IMalloc> xMalloc;

    SCODE sc = SHGetMalloc(xMalloc.GetPPointer());
    if (FAILED(sc))
    {
        // We need to cleaup pidl, but can't get a ptr to the shell task
        // allocator. What else can we do besides displaying an error?

        MessageBox(hwndParent, STRINGRESOURCE( srCMUnexpectedError ),
                   STRINGRESOURCE( srIndexServerCmpManage ), MB_ICONHAND);

        return FALSE;
    }

    BROWSEINFO bi;

    RtlZeroMemory(&bi, sizeof BROWSEINFO);

    bi.ulFlags = BIF_EDITBOX | BIF_RETURNONLYFSDIRS;
    TCHAR szInitialDir[MAX_PATH];
    pszBuf[0] = L'\0';

    // Prepare the initial directory... add a backslash if it's
    // a 2-character path
    wcsncpy( szInitialDir, pszInitialDir, sizeof szInitialDir / sizeof TCHAR );
    szInitialDir[ (sizeof szInitialDir / sizeof TCHAR) - 1 ] = 0;
    if( !szInitialDir[2] )
    {
        szInitialDir[2] = L'\\';
        szInitialDir[3] = L'\0';
    }

    WCHAR awcTitle[200];
    if( pszDialogTitle )
        bi.lpszTitle = pszDialogTitle;
    else
    {
        LoadString( ghInstance,
                    MSG_DIRECTORY_TITLE,
                    awcTitle,
                    sizeof awcTitle / sizeof WCHAR );
        bi.lpszTitle = awcTitle;
    }

    bi.hwndOwner = hwndParent;
    Win4Assert(cchBuf >= MAX_PATH);
    bi.pszDisplayName = pszBuf;

    if (pszInitialDir)
    {
       // engage these params only if we have an initial directory
       bi.lpfn = InitStartDir;
       bi.lParam = (LPARAM)szInitialDir;
    }

    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    BOOL fOk = (BOOL)(0 != pidl);

    fOk = fOk && SHGetPathFromIDList(pidl, pszBuf);

    xMalloc->Free((void *)pidl);

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\classfac.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1998
//
//  File:       ClassFac.cxx
//
//  Contents:   Class factory for admin COM object
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <classid.hxx>
#include <classfac.hxx>
#include <snapin.hxx>

//
// Global variables
//

long gulcInstances = 0;

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::CCIAdminCF
//
//  Synopsis:   CI MMC snap-in class factory constructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCIAdminCF::CCIAdminCF()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::~CCIAdminCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    26-Nov-1996     KyleP   Created
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CCIAdminCF::~CCIAdminCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminCF::QueryInterface( REFIID riid,
                                                    void  ** ppvObject )
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCIAdminCF::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCIAdminCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}


//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::CreateInstance
//
//  Synopsis:   Creates new snapin data object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    IUnknown * pIUnk = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        pIUnk = (IUnknown *)(IComponent *)new CCISnapinData();
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        if( SUCCEEDED(sc) )
            pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pIUnk );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;

        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    UNTRANSLATE_EXCEPTIONS;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    23-Feb-1994     KyleP   Created
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Text filter class factory
//
//  History:    23-Feb-1994     KyleP   Created
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject( REFCLSID   cid,
                                                      REFIID     iid,
                                                      void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        if ( guidCISnapin == cid )
            pResult = (IUnknown *)new CCIAdminCF;
        else
            sc = E_NOINTERFACE;

        if( pResult )
        {
            sc = pResult->QueryInterface( iid, ppvObj );
            pResult->Release(); // Release extra refcount from QueryInterface
        }
    }
    CATCH(CException, e)
    {
        if ( pResult )
            pResult->Release();

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    23-Feb-1994     KyleP   Created
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( 0 == gulcInstances )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\ciares.h ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997 - 2000.
//
// File:        CiaRes.h
//
// Contents:    Constants used in CiAdmin.rc
//
// History:     15-Jun-1998     KyleP   Added header
//              20-Jan-1999     SLarimor Modified rescan interface to include 
//                                      Full and Incremental options separatly
//
//----------------------------------------------------------------------------

#if !defined( __CIARES_H__ )
#define __CIARES_H__

//
// Image strips
//

#define BMP_SMALL_ICONS         400
#define BMP_LARGE_ICONS         401
#define BMP_TOOLBAR_SMALL       402
#define ICON_ABOUT              403
#define BMP_SMALL_OPEN_FOLDER   404
#define BMP_LARGE_CLOSED_FOLDER 405
#define BMP_SMALL_CLOSED_FOLDER 406

//
// These are the virtual offsets into the image strip
//

#define ICON_FOLDER              0
#define ICON_VIRTUAL_FOLDER      1
#define ICON_CATALOG             2
#define ICON_PROPERTY            3
#define ICON_MODIFIED_PROPERTY   4
#define ICON_SHADOW_ALIAS_FOLDER 5
#define ICON_URL                 6
#define ICON_APP                 7

//
// Strings
//

#define MSG_REMOVE_SCOPE_TITLE          501
#define MSG_REMOVE_SCOPE                502
// Gap can be filled with new ids

#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
#define MSG_SNAPIN_NAME_STRING_INDIRECT 504
#endif

#define MSG_DIRECTORY_TITLE             505
#define MSG_RESCAN_FULL_SCOPE           506
#define MSG_MERGE_CATALOG               507
#define MSG_NEW_CATALOG                 508
#define MSG_NEW_CATALOG_TITLE           509

#define MSG_CM_ADD_SCOPE                510
#define MSG_CM_ADD_SCOPE_HELP           511
#define MSG_CM_DEL_SCOPE                512
#define MSG_CM_DEL_SCOPE_HELP           513
#define MSG_CM_ADD_CATALOG              514
#define MSG_CM_ADD_CATALOG_HELP         515
#define MSG_CM_DEL_CATALOG              516
#define MSG_CM_DEL_CATALOG_HELP         517
#define MSG_CM_COMMIT_PROP              518
#define MSG_CM_COMMIT_PROP_HELP         519
#define MSG_CM_SCAN_FULL_SCOPE          520
#define MSG_CM_SCAN_FULL_SCOPE_HELP     521
#define MSG_CM_MERGE                    522
#define MSG_CM_MERGE_HELP               523
#define MSG_CM_START_CI                 524
#define MSG_CM_START_CI_HELP            525
#define MSG_CM_STOP_CI                  526
#define MSG_CM_STOP_CI_HELP             527
#define MSG_CM_INVALID_SCOPE            528
#define MSG_CM_UNEXPECTED_ERROR         529
#define MSG_CM_PAUSE_CI                 530
#define MSG_CM_PAUSE_CI_HELP            531
#define MSG_CM_EMPTY_CATALOG            532
#define MSG_CM_EMPTY_CATALOG_HELP       533
#define MSG_CM_SHUTDOWN_SERVICE         534
#define MSG_CM_SHUTDOWN_SERVICE_TITLE   535
#define MSG_CM_TUNE_PERFORMANCE         536
#define MSG_CM_TUNE_PERFORMANCE_HELP    537
#define MSG_CM_CANT_SHUTDOWN_SERVICE    538
#define MSG_CM_CANT_SAVE_SETTINGS       539

#define MSG_ERROR_TITLE                 540
#define MSG_GENERIC_ERROR               541
#define MSG_PENDING_PROP_CHANGE_TITLE   542
#define MSG_PENDING_PROP_CHANGE         543
#define MSG_YES                         544
#define MSG_NO                          545
#define MSG_INDEX_SERVER                546
#define MSG_LOCAL_MACHINE               547
#define MSG_CANT_DELETE_CATALOG         548
#define MSG_DELETE_CATALOG              549

#define MSG_NODE_DIRECTORIES            550
#define MSG_NODE_PROPERTIES             551
#define MSG_CM_PROPERTIES_REFRESH       552
#define MSG_CM_PROPERTIES_REFRESH_HELP  553
#define MSG_ENABLE_CI                   554
#define MSG_ENABLE_CI_TITLE             555
#define MSG_NODE_UNFILTERED             556

#define MSG_INDEX_SERVER_CMPMANAGE      557

#define MSG_STATE_SHADOW_MERGE          560
#define MSG_STATE_MASTER_MERGE          561
#define MSG_STATE_CONTENT_SCAN_REQUIRED 562
#define MSG_STATE_ANNEALING_MERGE       563
#define MSG_STATE_SCANNING              564
#define MSG_STATE_RECOVERING            565
#define MSG_STATE_HIGH_IO               566
#define MSG_STATE_LOW_MEMORY            567
#define MSG_STATE_MASTER_MERGE_PAUSED   568
#define MSG_STATE_READ_ONLY             569
#define MSG_STATE_BATTERY_POWER         570
#define MSG_STATE_USER_ACTIVE           571
#define MSG_STATE_STARTING              572
#define MSG_STATE_READING_USNS          573
#define MSG_STATE_STARTED               574
#define MSG_STATE_STOPPED               575

#define MSG_COL_CATNAME                 600
#define MSG_COL_DRIVE                   601
#define MSG_COL_SIZE                    602
#define MSG_COL_DOCTOTAL                603
#define MSG_COL_DOCFILTER               604
#define MSG_COL_WORDLISTS               605
#define MSG_COL_PERSINDEX               606
#define MSG_COL_STATUS                  607
#define MSG_COL_ROOT                    608
#define MSG_COL_ALIAS                   609
#define MSG_COL_EXCLUDE                 610
#define MSG_COL_PROPSET                 611
#define MSG_COL_PROPERTY                612
#define MSG_COL_DATATYPE                613
#define MSG_COL_DATASIZE                614
#define MSG_COL_FNAME                   615
#define MSG_COL_STORELEVEL              616

#define MSG_STORELEVEL_PRIMARY          625
#define MSG_STORELEVEL_SECONDARY        626

#define MSG_CANT_ADD_CATALOG            630
#define MSG_CANT_ADD_CATALOG_TITLE      631
#define MSG_DELETE_CATALOG_TITLE        632
#define MSG_ERROR_PROP_COMMIT           633

#define MSG_PRODUCT_DESCRIPTION         701
#define MSG_NONE_SELECTED               702
#define MSG_VENDOR_COPYRIGHT            703
#define MSG_VENDOR_NAME                 704
#define MSG_PROVIDER_NAME               705

#define MSG_COL_SECQDOCUMENTS           715
#define MSG_CATALOG_PARTIAL_DELETION    716
#define MSG_DELETE_CATALOG_ASK          717
#define MSG_INVALID_COMPUTER_NAME       718
#define MSG_EMPTY_CATALOG_TITLE         719
#define MSG_EMPTY_CATALOG_PROMPT        720
#define MSG_RESCAN_FULL_SCOPE_EXPLAIN   721
#define MSG_TYPE                        722
#define MSG_RESCAN_INCREMENTAL_SCOPE_EXPLAIN 723
#define MSG_RESCAN_INCREMENTAL_SCOPE    724
#define MSG_CM_SCAN_INCREMENTAL_SCOPE   725
#define MSG_CM_SCAN_INCREMENTAL_SCOPE_HELP 726 

//
// Property sheets
//

#define IDP_CATALOG_PAGE1               100
#define IDP_CATALOG_PAGE1_TITLE         101
#define IDP_CATALOG_PAGE2               102
#define IDP_CATALOG_PAGE2_TITLE         103
#define IDP_CATALOG_PAGE3               104
#define IDP_CATALOG_PAGE3_TITLE         105

#define IDP_PROPERTY_PAGE1              106
#define IDP_PROPERTY_PAGE1_TITLE        107

#define IDP_IS_PAGE0                    108
#define IDP_IS_PAGE0_TITLE              109
#define IDP_IS_PAGE1                    110
#define IDP_IS_PAGE1_TITLE              111

//
// Dialog constants
//

#define IDD_ADD_SCOPE                   301
#define IDD_BROWSEDIRECTORY             302
#define IDD_ADD_CATALOG                 303
#define IDD_USAGE_ON_SERVER             304
#define IDD_USAGE_ON_WORKSTATION        305
#define IDD_ADVANCED_INFO               306

#define IDDI_PATH                        1000
#define IDDI_BROWSE                      1001
#define IDDI_ALIAS                       1002
#define IDDI_USER_NAME                   1003
#define IDDI_PASSWORD                    1004
#define IDDI_SELECT_PATH                 1008
#define IDDI_SELECT_ALIAS                1009
#define IDDI_SELECT_USER_NAME            1010
#define IDDI_SELECT_PASSWORD             1011
#define IDDI_INCLUDE                     1012
#define IDDI_EXCLUDE                     1013
#define IDDI_CATNAME                     1014
#define IDDI_SIZE                        1015
#define IDDI_PROPSET                     1016
#define IDDI_PROPERTY                    1017
#define IDDI_CACHED                      1018
#define IDDI_DATATYPE                    1019
#define IDDI_VIRTUAL_SERVER              1020
#define IDDI_NNTP_SERVER                 1021
#define IDDI_FILTER_UNKNOWN              1022
#define IDDI_CHARACTERIZATION            1023
#define IDDI_CHARACTERIZATION_SIZE       1024
#define IDDI_SPIN_CHARACTERIZATION       1025
#define IDDI_COMPNAME                    1026
#define IDDI_LOCAL_COMPUTER              1027
#define IDDI_REMOTE_COMPUTER             1028
#define IDDI_SPIN_CACHEDSIZE             1029
#define IDDI_STORAGELEVEL                1030
#define IDDI_CACHEDSIZE                  1031
#define IDDI_DIRPATH                     1032
#define IDDI_CATPATH                     1033
#define IDDI_VSERVER_STATIC              1034
#define IDDI_NNTP_STATIC                 1035
#define IDDI_AUTO_ALIAS                  1036
#define IDDI_PROPCACHE_SIZE              1037
#define IDDI_DEDICATED                   1038
#define IDDI_USEDOFTEN                   1039
#define IDDI_USEDOCCASIONALLY            1040
#define IDDI_NEVERUSED                   1041
#define IDDI_ADVANCED                    1042
#define IDDI_SLIDER_MEMORY               1043
#define IDDI_SLIDER_CPU                  1044
#define IDDI_SLIDER_INDEXING             1045
#define IDDI_SLIDER_QUERYING             1046
#define IDDI_CUSTOMIZE                   1047
#define IDDI_INHERIT1                    1048
#define IDDI_INHERIT2                    1049
#define IDDI_ACCOUNT_INFORMATION         1050
#define IDDI_INCLUSION                   1051
#define IDDI_SELECT_PATH2                1052
#define IDDI_SELECT_PROPCACHE_SIZE       1053
#define IDDI_SELECT_SIZE                 1054
#define IDDI_SELECT_CATNAME              1055
#define IDDI_SELECT_CATPATH              1056
#define IDDI_SELECT_PROPSET              1057
#define IDDI_SELECT_PROPERTY             1058
#define IDDI_SELECT_DATATYPE             1059
#define IDDI_SELECT_CACHEDSIZE           1060
#define IDDI_SELECT_STORAGELEVEL         1061
#define IDDI_GROUP_INHERIT               1062
#define IDDI_CHARSIZE_STATIC             1063
#define IDDI_SELECT_INDEXING             1064
#define IDDI_SELECT_QUERYING             1065
#define IDDI_LAZY                        1066
#define IDDI_INSTANT                     1067
#define IDDI_LOWLOAD                     1068
#define IDDI_HIGHLOAD                    1069
#define IDDI_CATNAME2                    1070
#define IDDI_SELECT_CATNAME2             1071


#define IDDI_STATIC2                     50000
#define IDDI_STATIC                      -1

#endif // __CIARES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\header.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000
//
//  File:       Header.cxx
//
//  Contents:   Used to maintain / display listview header
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <header.hxx>

CHeaderItem::CHeaderItem( unsigned id,
                          WCHAR const * pwcsName,
                          int Format,
                          int Width,
                          BOOL fInUse )
        : _id( id ),
          _Format( Format ),
          _Width( Width ),
          _fInUse( fInUse )
{
    Win4Assert( wcslen(pwcsName) < ccMaxName );

    wcscpy( _wcsName, pwcsName );
}

CListViewHeader::CListViewHeader()
{
}

void CListViewHeader::Add( unsigned id,
                           WCHAR const * pwcsName,
                           int Format,
                           int Width )
{
    CHeaderItem * pItem = new CHeaderItem( id, pwcsName, Format, Width );

    _aColumn.Add( pItem, _aColumn.Count() );
}

void CListViewHeader::Display( IHeaderCtrl * pHeader )
{
    for ( unsigned i = 0; i < _aColumn.Count(); i++ )
    {
        CHeaderItem * pItem = _aColumn.Get( i );

        if ( pItem->IsInUse() )
            pHeader->InsertColumn( i, pItem->Name(), pItem->Format(), pItem->Width() );
    }
}

void CListViewHeader::Update( IHeaderCtrl * pHeader )
{
    for ( unsigned i = 0; i < _aColumn.Count(); i++ )
    {
        CHeaderItem * pItem = _aColumn.Get( i );

        if ( pItem->IsInUse() )
        {
            int Width;

            SCODE sc = pHeader->GetColumnWidth( i, &Width );

            if ( SUCCEEDED( sc ) )
                pItem->SetWidth( Width );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\dataobj.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1998
//
//  File:       DataObj.cxx
//
//  Contents:   Data object
//
//  History:    26-Nov-1996     KyleP    Created
//               7/1/98         mohamedn extend comp. mgmt
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <classid.hxx>
#include <dataobj.hxx>

#include <catalog.hxx>
#include <prop.hxx>

//
// Global variables
//

extern long gulcInstances;

//
// Static member initialization
//

unsigned int CCIAdminDO::_cfNodeType =       RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CCIAdminDO::_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CCIAdminDO::_cfDisplayName =    RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CCIAdminDO::_cfClassId =        RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CCIAdminDO::_cfInternal =       RegisterClipboardFormat(L"IS_SNAPIN_INTERNAL");
unsigned int CCIAdminDO::_cfMachineName =    RegisterClipboardFormat(MMC_MACHINE_NAME_CF);

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminDO::QueryInterface( REFIID riid,
                                                    void  ** ppvObject )
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    if ( IID_IDataObject == riid )
        *ppvObject = (IUnknown *)(IDataObject *) this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *) this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCIAdminDO::AddRef()
{
    //ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::AddRef\n" ));

    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCIAdminDO::Release()
{
    //ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::Release\n" ));

    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::Create
//
//  Synopsis:   CDataObject creation
//
//  Arguments:  [pBuffer]   -- buffer
//              [len]       -- buffer length
//              [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{

    //ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::Create\n" ));

    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            // store in smart pointer to release when we're out of scope

            XInterface<IStream>  xStream(lpStream);

            // Write to the stream the number of bytes

            unsigned long written;
            hr = lpStream->Write(pBuffer, len, &written);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CreateNodeTypeData
//
//  Synopsis:   NodeType creation
//
//  Arguments:  [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::CreateNodeTypeData\n" ));

    return Create(&guidCIRootNode, sizeof(GUID), lpMedium);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CreateNodeTypeStringData
//
//  Synopsis:   NodeType creation
//
//  Arguments:  [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::CreateNodeTypeStringData\n" ));

    return Create(wszCIRootNode, (wcslen(wszCIRootNode)+1) * sizeof (WCHAR) , lpMedium);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CreateDisplayName
//
//  Synopsis:   CreateDisplayName
//
//  Arguments:  [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    unsigned cc;
    XGrowable<WCHAR> xwcsTitle;

    if ( 0 == _pwcsMachine )
    {
        cc = wcslen( STRINGRESOURCE(srIndexServerCmpManage) ) + 1;
        xwcsTitle.SetSize(cc);
        wcscpy( xwcsTitle.Get(), STRINGRESOURCE(srIndexServerCmpManage) );
    }
    else
    {
        cc = wcslen( STRINGRESOURCE(srIndexServer) ) + 1;

        xwcsTitle.SetSize(cc);

        wcscpy( xwcsTitle.Get(), STRINGRESOURCE(srIndexServer) );

        if ( _pwcsMachine[0] == L'.' )
        {
            cc += wcslen( STRINGRESOURCE(srLM) );

            xwcsTitle.SetSize( cc );

            wcscat( xwcsTitle.Get(), STRINGRESOURCE(srLM) );
        }
        else
        {
            cc += wcslen( _pwcsMachine );
            cc += 2;  // the UNC slashes

            xwcsTitle.SetSize( cc );

            wcscat( xwcsTitle.Get(), L"\\\\" );
            wcscat( xwcsTitle.Get(), _pwcsMachine );
        }
    }

    return Create( xwcsTitle.Get(), cc * sizeof(WCHAR), lpMedium);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CreateCoClassID
//
//  Synopsis:   CreateCoClassID
//
//  Arguments:  [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::CreateCoClassID\n" ));

    const CLSID & clsid = guidCISnapin;

    return Create(&clsid, sizeof(CLSID), lpMedium);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CreateInternal
//
//  Synopsis:   CreateInternal
//
//  Arguments:  [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::CreateInternal(LPSTGMEDIUM lpMedium)
{

    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::CreateInternal\n" ));

    void * pThis = this;

    return Create(&pThis, sizeof (DWORD), lpMedium );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::GetData
//
//  Synopsis:   Retrieves requested data type
//
//  Arguments:  [lpFormatetcIn] -- Requested data format
//              [lpMedium]      -- Describes storage format
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminDO::GetData( FORMATETC * lpFormatetcIn,
                                             STGMEDIUM * lpMedium )
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::GetData\n" ));

    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::GetDataHere
//
//  Synopsis:   Retrieves requested data type.  Caller allocated storage.
//
//  Arguments:  [lpFormatetcIn] -- Requested data format
//              [lpMedium]      -- Describes storage format
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CCIAdminDO::GetDataHere( FORMATETC * lpFormatetc,
                                      STGMEDIUM * lpMedium )
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::GetDataHere\n" ));

    //
    // Simple parameter checking.
    //

    if ( 0 == lpFormatetc || 0 == lpMedium )
        return E_POINTER;

    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == _cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if (cf == _cfClassId)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == _cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == _cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == _cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::EnumFormatEtc
//
//  Synopsis:   Enumerate available format types
//
//  Arguments:  [dwDirection]     -- Get vs. Set formats
//              [ppEnumFormatEtc] -- Format(s) returned here
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminDO::EnumFormatEtc( DWORD dwDirection,
                                                   IEnumFORMATETC ** ppEnumFormatEtc )
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::EnumFormatEtc\n" ));

    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CCIAdminDO
//
//  Synopsis:   Constructor
//
//  Arguments:  [cookie]      -- Cookie (assigned by MMC)
//              [type]        -- Where data object is used (scope, result, ...)
//              [pwcsMachine] -- Name of computer
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCIAdminDO::CCIAdminDO( MMC_COOKIE cookie, DATA_OBJECT_TYPES type, WCHAR const * pwcsMachine )
        : _cookie( cookie ),
          _type( type ),
          _pwcsMachine( pwcsMachine ),
          _uRefs( 1 )
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::CCIAdminDO, New data object: cookie = 0x%x, type = 0x%x\n",
    //               _cookie, _type ));

    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::~CCIAdminDO
//
//  Synopsis:   Destructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCIAdminDO::~CCIAdminDO()
{
    // ciaDebugOut(( DEB_ITRACE, "Delete data object: cookie = 0x%x, type = 0x%x\n",
    //               _cookie, _type ));

    InterlockedDecrement( &gulcInstances );
}


CCatalog * CCIAdminDO::GetCatalog()
{
    if ( IsACatalog() )
        return (CCatalog *)_cookie;
    else if ( IsADirectoryIntermediate() || IsAPropertyIntermediate() )
        return &((CIntermediate *)_cookie)->GetCatalog();
    else if ( IsAProperty() )
        return &((CCachedProperty *)_cookie)->GetCatalog();
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\ixhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       CIAdmin.hm
//
//  Contents:   Help map for MMC snapin for CI.
//
//  History:    10-Sep-1997     KyleP   Created
//
//--------------------------------------------------------------------------

#pragma once

// Property pages
#define HIDP_GENERATION_FILTER_UNKNOWN             0x18000
#define HIDP_GENERATION_GENERATE_CHARACTERIZATION  0x18001
#define HIDP_GENERATION_MAXIMUM_SIZE               0x18002

#define HIDP_LOCATION_NAME                         0x18003
#define HIDP_LOCATION_LOCATION                     0x18004
#define HIDP_LOCATION_SIZE                         0x18005
#define HIDP_PROPCACHE_SIZE                        0x18006

#define HIDP_WEB_VSERVER                           0x18007
#define HIDP_WEB_NNTPSERVER                        0x18009

#define HIDP_PROPERTY_SET                          0x1800A
#define HIDP_PROPERTY_PROPERTY                     0x1800B
#define HIDP_PROPERTY_CACHED                       0x1800C
#define HIDP_PROPERTY_DATATYPE                     0x1800D
#define HIDP_PROPERTY_SIZE                         0x1800E

#define HIDP_SCOPE_PATH                            0x1800F
#define HIDP_SCOPE_BROWSE                          0x18010
#define HIDP_SCOPE_ALIAS                           0x18011
#define HIDP_SCOPE_USER_NAME                       0x18012
#define HIDP_SCOPE_PASSWORD                        0x18013
#define HIDP_SCOPE_INCLUDE                         0x18014
#define HIDP_SCOPE_EXCLUDE                         0x18015

#define HIDP_CONNECT_LOCAL                         0x18016
#define HIDP_CONNECT_ANOTHER                       0x18017

#define HIDP_PROPERTY_STORAGELEVEL                 0x18018

#define HIDP_LOCATION_BROWSE                       0x18019

#define HIDP_OK                                    0x18020
#define HIDP_CANCEL                                0x18021
#define HIDP_APPLY                                 0x18022

#define HIDP_CATALOG_LOCATION                      0x18023

// Indexing Service usage dialog
#define HIDP_DEDICATED                             0x18024
#define HIDP_USEDOFTEN                             0x18025
#define HIDP_USEDOCCASIONALLY                      0x18026
#define HIDP_NEVERUSED                             0x18027
#define HIDP_ADVANCED_CONFIG                       0x18028
#define HIDP_CUSTOMIZE                             0x18029

// Advanced Indexing Service performance tuning
#define HIDP_INDEXING_PERFORMANCE                  0x18030
#define HIDP_QUERY_PERFORMANCE                     0x18031

// Inheritable settings in property pages
#define HIDP_SETTINGS_INHERIT1                     0x18032
#define HIDP_SETTINGS_INHERIT2                     0x18033

// New additions
#define HIDP_ALIAS_NETWORK_SHARES                  0x18034
#define HIDP_ACCOUNT_INFORMATION                   0x18035
#define HIDP_INCLUSION                             0x18036
#define HIDP_INHERIT                               0x18037
#define HIDP_CATALOG_NAME                          0x18038

BOOL DisplayHelp( HWND hwnd, DWORD dwID );
BOOL DisplayPopupHelp( HWND hwnd, DWORD dwHelpType );
BOOL DisplayHelp( HWND hwnd, DWORD dwID, UINT uCommand );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\isreg.cxx: ..\query\isreg.cxx
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\prop.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       Catalog.cxx
//
//  Contents:   Used to manage catalog(s) state
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <catalog.hxx>
#include <catadmin.hxx>

#include <fsciexps.hxx>

//
// Local prototypes
//

WCHAR * ConvertToString ( GUID & Uuid, WCHAR * String );
WCHAR * ULongToHexString ( WCHAR * String, unsigned long Number );

//
// Global data
//

SPropertyColumn coldefProps[] = { { CCachedProperty::GetPropSet,    MSG_COL_PROPSET,    LVCFMT_LEFT },
                                  { CCachedProperty::GetProperty,   MSG_COL_PROPERTY,   LVCFMT_LEFT },
                                  { CCachedProperty::GetFName,      MSG_COL_FNAME,      LVCFMT_LEFT },
                                  { CCachedProperty::GetDatatype,   MSG_COL_DATATYPE,   LVCFMT_LEFT },
                                  { CCachedProperty::GetAllocation, MSG_COL_DATASIZE,   LVCFMT_LEFT },
                                  { CCachedProperty::GetStoreLevel, MSG_COL_STORELEVEL, LVCFMT_LEFT }
                                };

const unsigned cColDefProps = sizeof coldefProps / sizeof coldefProps[0];

BOOL CCachedProperty::_fFirstTime = TRUE;

WCHAR * awcsType[] = { L"VT_EMPTY",    // 0
                       L"VT_NULL",     // 1
                       L"VT_I2",       // 2
                       L"VT_I4",       // 3
                       L"VT_R4",       // 4
                       L"VT_R8",       // 5
                       L"VT_CY",       // 6
                       L"VT_DATE",     // 7
                       L"VT_BSTR",     // 8
                       0,              // 9
                       L"VT_ERROR",    // 10
                       L"VT_BOOL",     // 11
                       L"VT_VARIANT",  // 12
                       0,              // 13
                       L"VT_DECIMAL",  // 14
                       0,              // 15
                       L"VT_I1",       // 16
                       L"VT_UI1",      // 17
                       L"VT_UI2",      // 18
                       L"VT_UI4",      // 19
                       L"VT_I8",       // 20
                       L"VT_UI8",      // 21
                       L"VT_INT",      // 22
                       L"VT_UINT",     // 23
                       0,              // 24
                       0,              // 25
                       0,              // 26
                       0,              // 27
                       0,              // 28
                       0,              // 29
                       L"VT_LPSTR",    // 30
                       L"VT_LPWSTR",   // 31
                       0,              // 32
                       0,              // 33
                       0,              // 34
                       0,              // 35
                       0,              // 36
                       0,              // 37
                       0,              // 38
                       0,              // 39
                       0,              // 40
                       0,              // 41
                       0,              // 42
                       0,              // 43
                       0,              // 44
                       0,              // 45
                       0,              // 46
                       0,              // 47
                       0,              // 48
                       0,              // 49
                       0,              // 50
                       0,              // 51
                       0,              // 52
                       0,              // 53
                       0,              // 54
                       0,              // 55
                       0,              // 56
                       0,              // 57
                       0,              // 58
                       0,              // 59
                       0,              // 60
                       0,              // 61
                       0,              // 62
                       0,              // 63
                       L"VT_FILETIME", // 64
                       L"VT_BLOB",     // 65
                       0,              // 66
                       0,              // 67
                       0,              // 68
                       0,              // 69
                       0,              // 70
                       L"VT_CF",       // 71
                       L"VT_CLSID" };  // 72

//
// Index of string in packed list box.
//

ULONG aulTypeIndex[] = { 0,  // VT_EMPTY
                         1,  // VT_NULL
                         2,  // VT_I2
                         3,  // VT_I4
                         4,  // VT_R4
                         5,  // VT_R8
                         6,  // VT_CY
                         7,  // VT_DATE
                         8,  // VT_BSTR
                         0,  // 9
                         9,  // VT_ERROR
                         10, // VT_BOOL
                         11, // VT_VARIANT
                         0,  // 13
                         12,  // 14
                         0,  // 15
                         13, // VT_I1
                         14, // VT_UI1
                         15, // VT_UI2
                         16, // VT_UI4
                         17, // VT_I8
                         18, // VT_UI8
                         19, // VT_INT
                         20, // VT_UINT
                         0,  // 24
                         0,  // 25
                         0,  // 26
                         0,  // 27
                         0,  // 28
                         0,  // 29
                         21, // VT_LPSTR
                         22, // VT_LPWSTR
                         0,  // 32
                         0,  // 33
                         0,  // 34
                         0,  // 35
                         0,  // 36
                         0,  // 37
                         0,  // 38
                         0,  // 39
                         0,  // 40
                         0,  // 41
                         0,  // 42
                         0,  // 43
                         0,  // 44
                         0,  // 45
                         0,  // 46
                         0,  // 47
                         0,  // 48
                         0,  // 49
                         0,  // 50
                         0,  // 51
                         0,  // 52
                         0,  // 53
                         0,  // 54
                         0,  // 55
                         0,  // 56
                         0,  // 57
                         0,  // 58
                         0,  // 59
                         0,  // 60
                         0,  // 61
                         0,  // 62
                         0,  // 63
                         23, // VT_FILETIME
                         24, // VT_BLOB
                         0,  // 66
                         0,  // 67
                         0,  // 68
                         0,  // 69
                         0,  // 70
                         25, // VT_CF
                         26 }; // VT_CLSID

CCachedProperty::CCachedProperty( CCatalog & cat,
                                  GUID & guidPropSet,
                                  PROPSPEC & psProperty,
                                  ULONG vt,
                                  ULONGLONG cbAllocation,
                                  DWORD dwStoreLevel,
                                  VARIANT_BOOL  fModifiable,
                                  BOOL fNew )
        : _vt( vt ),
          _cb( (ULONG)cbAllocation ),
          _fZombie( FALSE ),
          _fNew( fNew ),
          _fFixed( FALSE ),
          _fUnapplied( FALSE ),
          _cat( cat ),
          _dwStoreLevel( dwStoreLevel ),
          _fModifiable( fModifiable )
{
    WCHAR wcsFileName[MAX_PATH];

    Win4Assert( (_dwStoreLevel != INVALID_STORE_LEVEL) ||
                (_dwStoreLevel == INVALID_STORE_LEVEL && 0 == cbAllocation) );

    _regEntry.GetDefaultColumnFile( wcsFileName, MAX_PATH );

    //
    // Get the file name from the registry and create a list that
    // will not be refreshed even if the underlying file changes.
    //

    _xPropList.Set(new CLocalGlobalPropertyList(GetGlobalStaticPropertyList(),
                                                FALSE,
                                                wcsFileName));

    if (_fFirstTime)
    {
        for ( unsigned i = 0; i < cColDefProps; i++ )
            coldefProps[i].srTitle.Init( ghInstance );

        _fFirstTime = FALSE;
    }

    CDbColId dbcol;
    dbcol.SetPropSet( guidPropSet );

    _fps.guidPropSet = guidPropSet;
    _fps.psProperty  = psProperty;

    //
    // String-ize GUID
    //

    ConvertToString( guidPropSet, _wcsPropSet );

    //
    // String-ize property
    //

    if ( PRSPEC_LPWSTR == psProperty.ulKind )
    {
        unsigned cc = wcslen( psProperty.lpwstr ) + 1;
        _xwcsProperty.SetSize( cc );
        RtlCopyMemory( _xwcsProperty.Get(), psProperty.lpwstr, cc * sizeof( WCHAR ) );

        _fps.psProperty.lpwstr = _xwcsProperty.Get();

        dbcol.SetProperty( psProperty.lpwstr );
    }
    else
    {
        wcscpy( _xwcsProperty.Get(), L"0x" );

        _ultow( psProperty.propid, _xwcsProperty.Get() + 2, 16 );

        dbcol.SetProperty( psProperty.propid );
    }

    if ( vt == VT_EMPTY && 0 == cbAllocation )
    {
        _wcsDatatype[0] = 0;
        _wcsAllocation[0] = 0;

        Win4Assert(VT_EMPTY == DBTYPE_EMPTY);

        _dbtDefaultType = VT_EMPTY;
        _uiDefaultSize = 0;
    }
    else
        SetVT( vt );

    //
    // Look for friendly name and other details.
    //

    CPropEntry const * pProp = _xPropList->Find( dbcol );

    if ( 0 == pProp )
        _xwcsFName[0] = 0;
    else
    {
        unsigned cc = wcslen( pProp->GetDisplayName() ) + 1;
        _xwcsFName.SetSize( cc );
        RtlCopyMemory( _xwcsFName.Get(), pProp->GetDisplayName(), cc * sizeof(WCHAR) );

        _dbtDefaultType = pProp->GetPropType();
        _uiDefaultSize = pProp->GetWidth();

        ciaDebugOut((DEB_ITRACE, "%ws has type %d (0x%x) and size %d\n", 
                     pProp->GetDisplayName(), _dbtDefaultType, _dbtDefaultType, _uiDefaultSize));
    }

    // If it is not cached, it can be modified!
    if (!IsCached())
        _fModifiable = VARIANT_TRUE;

    END_CONSTRUCTION( CCachedProperty );
}

CCachedProperty::CCachedProperty( CCachedProperty const & prop )
        : _cat( prop._cat ),
          _xwcsProperty( prop._xwcsProperty )
{
    *this = prop;

    END_CONSTRUCTION( CCachedProperty );
}

CCachedProperty & CCachedProperty::operator =( CCachedProperty const & prop )
{
    _vt =      prop._vt;
    _cb =      prop._cb;
    _fZombie = prop._fZombie;
    _fNew =    prop._fNew;
    _fFixed =  prop._fFixed;
    _fUnapplied = prop._fUnapplied;
    _fps =     prop._fps;
    _dwStoreLevel = prop._dwStoreLevel;
    _fModifiable = prop._fModifiable;

    _dbtDefaultType = prop._dbtDefaultType;
    _uiDefaultSize = prop._uiDefaultSize;

    RtlCopyMemory( _wcsPropSet, prop._wcsPropSet, sizeof( _wcsPropSet ) );
    RtlCopyMemory( _wcsDatatype, prop._wcsDatatype, sizeof( _wcsDatatype ) );
    RtlCopyMemory( _wcsAllocation, prop._wcsAllocation, sizeof( _wcsAllocation ) );
    _xwcsProperty = prop._xwcsProperty;

    if ( PRSPEC_LPWSTR == _fps.psProperty.ulKind )
        _fps.psProperty.lpwstr = _xwcsProperty.Get();

    return *this;
}

CCachedProperty::~CCachedProperty()
{
}

void CCachedProperty::SetVT( ULONG vt )
{
    ciaDebugOut(( DEB_ITRACE, "SetVT: _cb is %d before\n", _cb ));
    _vt = vt;

    //
    // Adjust size for fixed types.
    //

    switch ( _vt )
    {
    case VT_I1:
    case VT_UI1:
        _cb = 1;
        _fFixed = TRUE;
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        _cb = 2;
        _fFixed = TRUE;
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        _cb = 4;
        _fFixed = TRUE;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        _cb = 8;
        _fFixed = TRUE;
        break;

    case VT_CLSID:
        _cb = sizeof(GUID);
        _fFixed = TRUE;
        break;

    default:
        _fFixed = FALSE;
    }

    // If storage level is INVALID_STORE_LEVEL, the property is not cached
    // so its allocation size should be set to 0.
    if (_dwStoreLevel == INVALID_STORE_LEVEL)
        _cb = 0;

    //
    // String-ize datatype
    //

    if ( vt & VT_VECTOR )
    {
        wcscpy( _wcsDatatype, L"VT_VECTOR | " );
        vt &= ~VT_VECTOR;
    }
    else
        _wcsDatatype[0] = 0;

    if ( ( vt >= sizeof(awcsType)/sizeof(awcsType[0]) ) ||
         ( 0 == awcsType[vt] ) )
    {
        wcscpy( _wcsDatatype, L"---" );
    }
    else
        wcscat( _wcsDatatype, awcsType[vt] );

    //
    // String-ize allocation.  Assume < 4 Gb!
    //

    ciaDebugOut(( DEB_ITRACE, "SetVT: _wcsProperty is %ws and pointer is %d before\n", _xwcsProperty.Get(), _xwcsProperty.Get() ));

    ciaDebugOut(( DEB_ITRACE, "SetVT: _wcsAllocation is %ws before\n", _wcsAllocation ));
    
    // Max is 60K to fit a record into one page
    if ( _cb < 61440 )
        _ultow( _cb, _wcsAllocation, 10 );
    else
    {
        _cb = 61440;
        _ultow( 61440, _wcsAllocation, 10 );
    }

    ciaDebugOut(( DEB_ITRACE, "SetVT: _cb is %d after\n", _cb ));  
    ciaDebugOut(( DEB_ITRACE, "SetVT: _wcsProperty: pointer is %d\n", _xwcsProperty.Get() ));
    ciaDebugOut(( DEB_ITRACE, "SetVT: _wcsAllocation is %ws after\n", _wcsAllocation ));
    ciaDebugOut(( DEB_ITRACE, "SetVT: _wcsProperty is %ws\n", _xwcsProperty.Get() ));
}

void CCachedProperty::InitHeader( CListViewHeader & Header )
{
    if (_fFirstTime)
    {
        for ( unsigned i = 0; i < cColDefProps; i++ )
            coldefProps[i].srTitle.Init( ghInstance );

        _fFirstTime = FALSE;
    }

    //
    // Initialize header
    //

    for ( unsigned i = 0; i < cColDefProps; i++ )
    {
        Header.Add( i, STRINGRESOURCE(coldefProps[i].srTitle), coldefProps[i].justify, MMCLV_AUTO );
    }
}

void CCachedProperty::GetDisplayInfo( RESULTDATAITEM * item )
{
    //
    // This can happen if you right-click on properties and select refresh
    // while the current selection is something other than properties.
    // Looks like an MMC bug.
    //

    if ( item->nCol >= cColDefProps )
    {
        item->str = L"";
        return;
    }

    item->str = (WCHAR *)(this->*coldefProps[item->nCol].pfGet)();

    if ( 0 == item->nCol && IsUnappliedChange() )
    {
        item->nImage = ICON_MODIFIED_PROPERTY;
        item->mask |= RDI_IMAGE;
    }
    else
        item->nImage = ICON_PROPERTY;
} //GetDisplayInfo


static WCHAR HexDigits[] = L"0123456789abcdef";

static WCHAR * ULongToHexString ( WCHAR * String, unsigned long Number )
{
    *String++ = HexDigits[(Number >> 28) & 0x0F];
    *String++ = HexDigits[(Number >> 24) & 0x0F];
    *String++ = HexDigits[(Number >> 20) & 0x0F];
    *String++ = HexDigits[(Number >> 16) & 0x0F];
    *String++ = HexDigits[(Number >> 12) & 0x0F];
    *String++ = HexDigits[(Number >> 8) & 0x0F];
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];

    return(String);
}

static WCHAR * UShortToHexString ( WCHAR * String, unsigned short Number )
{
    *String++ = HexDigits[(Number >> 12) & 0x0F];
    *String++ = HexDigits[(Number >> 8) & 0x0F];
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];

    return(String);
}


static WCHAR * UCharToHexString ( WCHAR * String, WCHAR Number )
{
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];
    return(String);
}

WCHAR * ConvertToString ( UUID & Uuid, WCHAR * String )
{
    String = ULongToHexString(String, Uuid.Data1);
    *String++ = L'-';
    String = UShortToHexString(String, Uuid.Data2);
    *String++ = L'-';
    String = UShortToHexString(String, Uuid.Data3);
    *String++ = L'-';
    String = UCharToHexString(String, Uuid.Data4[0]);
    String = UCharToHexString(String, Uuid.Data4[1]);
    *String++ = L'-';
    String = UCharToHexString(String, Uuid.Data4[2]);
    String = UCharToHexString(String, Uuid.Data4[3]);
    String = UCharToHexString(String, Uuid.Data4[4]);
    String = UCharToHexString(String, Uuid.Data4[5]);
    String = UCharToHexString(String, Uuid.Data4[6]);
    String = UCharToHexString(String, Uuid.Data4[7]);
    *String++ = 0;

    return(String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#include <ctype.h>
#include <process.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>

#include <windows.h>
#include <commctrl.h>

//#define OLEDBVER 0x0250 // enable ICommandTree interface

#include <oledb.h>
#include <oledberr.h>
//#include <cmdtree.h>
#include <filter.h>     // FULLPROPSPEC
#include <query.h>
#include <mmc.h>

#define ciDebugOut ciaDebugOut
#define vqDebugOut ciaDebugOut

#include <cidebnot.h>
#include <ciexcpt.hxx>
#include <cisem.hxx>

#include <ciadebug.hxx>

#include <tgrow.hxx>
#include <smart.hxx>
#include <tsmem.hxx>
#include <dynstack.hxx>
#include <dynarray.hxx>
#include <strres.hxx>

#include <strings.hxx>

#include "ixhelp.h"

extern HINSTANCE ghInstance;

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\propsht.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       Propsht.cxx
//
//  Contents:   Property sheets for for CI snapin.
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cimbmgr.hxx>
#include <strres.hxx>

#include <ciares.h>
#include <propsht.hxx>

#include <catalog.hxx>
#include <prop.hxx>
#include <strings.hxx>

//
// Local prototypes
//

void InitVTList( HWND hwndCombo );
void InitVSList( HWND hwndComboVS, HWND hwndComboNNTP, CCatalog const & cat,
                 ULONG & cVServers, ULONG & cNNTPServers );
void InitStorageLevelList( HWND hwndCombo );
void DisplayError( HWND hwnd, CException & e );
BOOL GetDlgItemXArrayText( HWND hwndDlg, USHORT idCtrl, XArray<WCHAR> & xawcText );
DWORD VSToIndex( HWND hwndDlg, DWORD dwItem, ULONG ulVS, BOOL fTrack );
UINT DBTypeToVT(UINT uidbt);

CIndexSrvPropertySheet0::CIndexSrvPropertySheet0( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCatalogs * pCats )
        : _pCats( pCats ),
          _fFirstActive( TRUE ),
          _hMmcNotify( hMmcNotify )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_IS_PAGE0);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_IS_PAGE0_TITLE);
    _PropSheet.pfnDlgProc  = CIndexSrvPropertySheet0::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CIndexSrvPropertySheet0::~CIndexSrvPropertySheet0()
{
}

INT_PTR APIENTRY CIndexSrvPropertySheet0::DlgProc( HWND hwndDlg,
                                                   UINT message,
                                                   WPARAM wParam,
                                                   LPARAM lParam )
{
    BOOL fRet = FALSE;

    TRY
    {
        switch ( message )
        {
        case WM_INITDIALOG:
        {
            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet0::DlgProc -- WM_INITDIALOG\n" ));

            LONG_PTR lthis = ((CIndexSrvPropertySheet0 *)lParam)->_PropSheet.lParam;
            CIndexSrvPropertySheet0 * pthis = (CIndexSrvPropertySheet0 *)lthis;

            SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

            //
            // Default to local machine.
            //

            CheckRadioButton( hwndDlg,
                              IDDI_LOCAL_COMPUTER,
                              IDDI_REMOTE_COMPUTER,
                              IDDI_LOCAL_COMPUTER );

            EnableWindow( GetDlgItem( hwndDlg, IDDI_COMPNAME ), FALSE );

            fRet = TRUE;
            break;
        }

        case WM_COMMAND:
        {
            switch ( LOWORD( wParam ) )
            {
            case IDDI_LOCAL_COMPUTER:
            {
                if ( BN_CLICKED == HIWORD(wParam) )
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_COMPNAME ), FALSE );
                    PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_FINISH );
                    fRet = TRUE;
                }
                break;
            }

            case IDDI_REMOTE_COMPUTER:
            {
                if ( BN_CLICKED == HIWORD(wParam) )
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_COMPNAME ), TRUE );

                    //
                    // If we have a string, then enable finish button.
                    //

                    XArray<WCHAR> xawcTemp;

                    if ( GetDlgItemXArrayText( hwndDlg, IDDI_COMPNAME, xawcTemp ) &&
                         xawcTemp.Count() > 0 )
                    {
                        PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_FINISH );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_DISABLEDFINISH );
                    }

                    fRet = TRUE;
                }
                break;
            }

            case IDDI_COMPNAME:
            {
                if ( EN_CHANGE == HIWORD(wParam) )
                {
                    //
                    // If we have a string, then enable finish button.
                    //

                    XArray<WCHAR> xawcTemp;

                    if ( GetDlgItemXArrayText( hwndDlg, IDDI_COMPNAME, xawcTemp ) &&
                         xawcTemp.Count() > 0 )
                    {
                        PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_FINISH );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_DISABLEDFINISH );
                    }

                    fRet = TRUE;
                }
                break;
            }

            /* Help is not being used...
            case IDHELP:
            {
                DisplayHelp( hwndDlg, HIDD_CONNECT_TO_COMPUTER );
                break;
            }
            */

            } // switch
            break;
        }

        case WM_HELP:
        {
            HELPINFO *phi = (HELPINFO *) lParam;

            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet0 WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                          phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                          phi->iCtrlId, phi->dwContextId ));

            if ( HELPINFO_WINDOW == phi->iContextType )
            {
                switch ( phi->iCtrlId )
                {
                    case IDDI_STATIC:
                        break;

                    default :
                        DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                        break;
                }

            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
            break;
        }

        case WM_NOTIFY:
        {
            CIndexSrvPropertySheet0 * pthis = (CIndexSrvPropertySheet0 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            switch ( ((LPNMHDR) lParam)->code )
            {
            case PSN_KILLACTIVE:
            {
                // Allow loss of activation
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, FALSE );

                fRet = TRUE;
                break;
            }

            case PSN_SETACTIVE:
            {
                if ( pthis->_fFirstActive )
                {
                    PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_FINISH );

                    pthis->_fFirstActive = FALSE;
                }
                else
                {
                    // Go to next page
                    SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, -1 );
                }

                fRet = TRUE;
                break;
            }

            case PSN_WIZBACK:
            {
                // Allow previous page
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, PSNRET_NOERROR );

                fRet = TRUE;
                break;
            }

            case PSN_WIZNEXT:
            {
                // Allow next page
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, PSNRET_NOERROR );

                fRet = TRUE;
                break;
            }

            case PSN_WIZFINISH:
            {
                TRY
                {
                    XArray<WCHAR> xawcCompName;

                    if ( IsDlgButtonChecked( hwndDlg, IDDI_LOCAL_COMPUTER ) )
                        pthis->_pCats->SetMachine( L"." );
                    else
                    {
                        if ( GetDlgItemXArrayText( hwndDlg, IDDI_COMPNAME, xawcCompName ) )
                        {
                            pthis->_pCats->SetMachine( xawcCompName.GetPointer() );
                        }
                    }

                    MMCPropertyChangeNotify( pthis->_hMmcNotify, 0 );

                    fRet = TRUE;
                }
                CATCH( CException, e )
                {
                    // The only error caught here is a result of an invalid
                    // machine name.

                    Win4Assert(e.GetErrorCode() == E_INVALIDARG);

                    MessageBox( hwndDlg,
                                STRINGRESOURCE( srInvalidComputerName ),
                                STRINGRESOURCE( srIndexServerCmpManage ),
                                MB_OK | MB_ICONINFORMATION );
                }
                END_CATCH

                break;
            }

            } // switch

            break;
        }

        case WM_DESTROY:
        {
            CIndexSrvPropertySheet0 * pthis = (CIndexSrvPropertySheet0 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            MMCFreeNotifyHandle( pthis->_hMmcNotify );

            delete pthis;

            fRet = TRUE;
            break;
        }
        } // switch
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CIndexSrvPropertySheet0: Caught 0x%x\n", e.GetErrorCode() ));
        fRet = FALSE;
    }
    END_CATCH

    return fRet;
}

CIndexSrvPropertySheet1::CIndexSrvPropertySheet1( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCatalog * pCat )
        : _pCat( pCat ),
          _pCats( 0 ),
          _hMmcNotify( hMmcNotify )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_IS_PAGE1);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_IS_PAGE1_TITLE);
    _PropSheet.pfnDlgProc  = CIndexSrvPropertySheet1::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CIndexSrvPropertySheet1::CIndexSrvPropertySheet1( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCatalogs * pCats )
        : _pCat( 0 ),
          _pCats( pCats ),
          _hMmcNotify( hMmcNotify )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_IS_PAGE1);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_IS_PAGE1_TITLE);
    _PropSheet.pfnDlgProc  = CIndexSrvPropertySheet1::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CIndexSrvPropertySheet1::~CIndexSrvPropertySheet1()
{
}

INT_PTR APIENTRY CIndexSrvPropertySheet1::DlgProc( HWND hwndDlg,
                                                   UINT message,
                                                   WPARAM wParam,
                                                   LPARAM lParam )
{
    BOOL fRet = FALSE;

    TRY
    {
        switch ( message )
        {
        case WM_HELP:
        {
            HELPINFO *phi = (HELPINFO *) lParam;

            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet1 WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                          phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                          phi->iCtrlId, phi->dwContextId ));

            if ( HELPINFO_WINDOW == phi->iContextType )
            {
                switch ( phi->iCtrlId )
                {
                    case IDDI_STATIC:
                        break;

                    default :
                        DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                        break;
                }

            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
            break;
        }

        case WM_INITDIALOG:
        {
            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet1::DlgProc -- WM_INITDIALOG\n" ));

            LONG_PTR lthis = ((CIndexSrvPropertySheet1 *)lParam)->_PropSheet.lParam;
            CIndexSrvPropertySheet1 * pthis = (CIndexSrvPropertySheet1 *)lthis;

            SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

            BOOL  fUnknown;
            BOOL  fGenerateCharacterization;
            ULONG ccCharacterization;

            if ( pthis->IsTrackingCatalog() )
            {
                pthis->_pCat->GetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );

                // Look in the registry for Group1 params. If at least one of them is listed
                // we should uncheck the "Inherit" checkbox. Otherwise
                // (if none of them is listed), we should check the box.

                SendDlgItemMessage( hwndDlg, 
                                    IDDI_INHERIT1,
                                    BM_SETCHECK,
                                    pthis->_pCat->DoGroup1SettingsExist() ? BST_UNCHECKED : BST_CHECKED,
                                    0 );

                // If at least one setting exists, add the others in the group.
                // We don't want to have an incomplete set.
                if (pthis->_pCat->DoGroup1SettingsExist())
                   pthis->_pCat->FillGroup1Settings();
            }
            else
            {
                // Hide the "Inherit" checkbox because it is not applicable here
                ShowWindow(GetDlgItem(hwndDlg, IDDI_INHERIT1), SW_HIDE);

                pthis->_pCats->GetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );
            }

            SendDlgItemMessage( hwndDlg,
                                IDDI_FILTER_UNKNOWN,
                                BM_SETCHECK,
                                fUnknown ? BST_CHECKED : BST_UNCHECKED,
                                0 );

            SendDlgItemMessage( hwndDlg,
                                IDDI_CHARACTERIZATION,
                                BM_SETCHECK,
                                fGenerateCharacterization ? BST_CHECKED : BST_UNCHECKED,
                                0 );

            WCHAR wcsSize[120];

            _ultow( ccCharacterization, wcsSize, 10 );
            SetDlgItemText( hwndDlg, IDDI_CHARACTERIZATION_SIZE, wcsSize );

            SendDlgItemMessage( hwndDlg,
                                IDDI_SPIN_CHARACTERIZATION,
                                UDM_SETRANGE,
                                0,
                                (LPARAM) MAKELONG( 10000, 10) );

            // If the generate characterization checkbox is unchecked, we should disable the
            // characterization size controls
            if (!fGenerateCharacterization)
            {
                EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), FALSE);
            }

            // If we are inheriting, we should disable the local setting.
            if ( pthis->IsTrackingCatalog() && !pthis->_pCat->DoGroup1SettingsExist())
            {
                EnableWindow(GetDlgItem(hwndDlg, IDDI_FILTER_UNKNOWN), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), FALSE);
            }

            fRet = TRUE;
            break;
        }

        case WM_COMMAND:
        {
            BOOL fChanged = FALSE;
            BOOL fCorrected = TRUE;

            switch ( LOWORD( wParam ) )
            {

               case IDDI_CHARACTERIZATION:
                  if (BN_CLICKED == HIWORD(wParam))
                  {
                      BOOL fGenChar = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, 
                                                                           IDDI_CHARACTERIZATION, 
                                                                           BM_GETCHECK, 0, 0 ) );
                      EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), fGenChar);
                      EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), fGenChar);
                      EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), fGenChar);

                      if( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER ) )
                       {
                           fChanged = TRUE;
                           fRet = TRUE;
                       }
                  }
                  break;

               case IDDI_FILTER_UNKNOWN:
               {
                   if ( BN_CLICKED == HIWORD(wParam) )
                       fChanged = TRUE;

                   // Fall through
               }
               case IDDI_CHARACTERIZATION_SIZE:
               {
                   if ( EN_KILLFOCUS == HIWORD(wParam) && LOWORD( wParam ) == IDDI_CHARACTERIZATION_SIZE )
                   {
                       fRet = TRUE;
                       ULONG ulVal = 10;
   
                       // Validate the number
                       XArray<WCHAR> xawcTemp;
   
                       if ( (LOWORD(wParam) == IDDI_CHARACTERIZATION_SIZE) &&
                             GetDlgItemXArrayText( hwndDlg, IDDI_CHARACTERIZATION_SIZE, xawcTemp ) &&
                             xawcTemp.Count() > 0 )
                       {
                           // verify that all characters are digits
                           ULONG ulLen = wcslen(xawcTemp.GetPointer());
                           // When correcting, let's do our best
                           ulVal = _wtoi(xawcTemp.GetPointer());
                           for (ULONG i = 0; i < ulLen; i++)
                           {
                               if (!iswdigit(xawcTemp[i]))
                                   break;
                           }
                           if (i == ulLen)
                           {
                               // verify that the number is within range
                               ulVal = _wtoi(xawcTemp.GetPointer());
                               if (ulVal <= 10000 && ulVal >= 10)
                               {
                                   fCorrected = FALSE;
                               }
                               else
                                   ulVal = (ulVal < 10) ? 10 : 10000;
                           }
                       }
   
                       if (fCorrected)
                       {
                           WCHAR wszBuff[20];   // use this instead of a potentially empty xawcTemp

                           ciaDebugOut((DEB_ITRACE, "%ws is NOT a valid number\n", xawcTemp.GetPointer()));
                           MessageBeep(MB_ICONHAND);
                           SetWindowText((HWND)lParam, _itow(ulVal, wszBuff, 10));
                           SendMessage((HWND)lParam, EM_SETSEL, 0, -1);
                       }
                   }
                   else if ( EN_CHANGE == HIWORD(wParam) && ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER )) )
                   {
                       fChanged = TRUE;
                       fRet = TRUE;
                   }
   
                   break;
               }

               case IDDI_INHERIT1:
               {
                   if ( EN_CHANGE == HIWORD(wParam) || BN_CLICKED == HIWORD(wParam) )
                   {
                      if ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER ) )
                      {
                          fChanged = TRUE;
                          fRet = TRUE;

                          // If the Inherit Settings button is checked, we should remove the registry entries from the catalog's
                          // settings so the values will be inherited from the service.
                             
                          BOOL fInherit = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_INHERIT1, BM_GETCHECK, 0, 0 ) );
                          BOOL fUnknown = FALSE, fGenerateCharacterization = FALSE;
                          DWORD ccCharacterization = 0;
       
                          CIndexSrvPropertySheet1 * pthis = (CIndexSrvPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );
                          
                          if ( !pthis->IsTrackingCatalog() )
                              break;

                          if (fInherit)
                          {
                             Win4Assert(pthis->IsTrackingCatalog());

                             pthis->_pCat->GetParent().GetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );
                          }
                          else
                          {
                              pthis->_pCat->GetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );

                              // Enable so we can set controls
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_FILTER_UNKNOWN), TRUE);
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION), TRUE);
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), TRUE);
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), TRUE);
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), TRUE);
                          }
       
                          SendDlgItemMessage( hwndDlg,
                                              IDDI_FILTER_UNKNOWN,
                                              BM_SETCHECK,
                                              fUnknown ? BST_CHECKED : BST_UNCHECKED,
                                              0 );
                          SendDlgItemMessage( hwndDlg,
                                              IDDI_CHARACTERIZATION,
                                              BM_SETCHECK,
                                              fGenerateCharacterization ? BST_CHECKED : BST_UNCHECKED,
                                              0 );

                          WCHAR wcsSize[12];
                          _ultow( ccCharacterization, wcsSize, 10 );
                          SetDlgItemText( hwndDlg, IDDI_CHARACTERIZATION_SIZE, wcsSize );


                          // Enable/Disable controls if we need to
                           EnableWindow(GetDlgItem(hwndDlg, IDDI_FILTER_UNKNOWN), !fInherit);
                           EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION), !fInherit);
                           EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), !fInherit);
                           EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), !fInherit);
                           EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), !fInherit);
                      }
                   }
               }
            } // switch

            if ( fChanged )
                PropSheet_Changed( GetParent(hwndDlg), hwndDlg );

            break;
        } // case

        case WM_NOTIFY:
        {
            switch ( ((LPNMHDR) lParam)->code )
            {
            case PSN_APPLY:
            {
                TRY
                {
                    CIndexSrvPropertySheet1 * pthis = (CIndexSrvPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    BOOL  fUnknown = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_FILTER_UNKNOWN, BM_GETSTATE, 0, 0 ) );
                    BOOL  fGenerateCharacterization = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_CHARACTERIZATION, BM_GETSTATE, 0, 0 ) );

                    WCHAR wcsSize[12];
                    GetDlgItemText( hwndDlg, IDDI_CHARACTERIZATION_SIZE, wcsSize, sizeof(wcsSize)/sizeof(WCHAR) );
                    ULONG ccCharacterization = wcstoul( wcsSize, 0, 10 );

                    if ( pthis->IsTrackingCatalog() )
                    {

                        // If the Inherit Settings button is checked, we should remove the registry entries from the catalog's
                        // settings so the values will be inherited from the service.
                        BOOL fInherit = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_INHERIT1, BM_GETSTATE, 0, 0 ) );
                        if (fInherit)
                            pthis->_pCat->DeleteGroup1Settings();
                        else
                            pthis->_pCat->SetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );

                        // Set the values and enable or disable the local controls as appropriate
                        pthis->_pCat->GetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );

                        SendDlgItemMessage( hwndDlg,
                                            IDDI_FILTER_UNKNOWN,
                                            BM_SETCHECK,
                                            fUnknown ? BST_CHECKED : BST_UNCHECKED,
                                            0 );
                        SendDlgItemMessage( hwndDlg,
                                            IDDI_CHARACTERIZATION,
                                            BM_SETCHECK,
                                            fGenerateCharacterization ? BST_CHECKED : BST_UNCHECKED,
                                            0 );

                        WCHAR wcsSize[12];
                        _ultow( ccCharacterization, wcsSize, 10 );
                        SetDlgItemText( hwndDlg, IDDI_CHARACTERIZATION_SIZE, wcsSize);

                        EnableWindow(GetDlgItem(hwndDlg, IDDI_FILTER_UNKNOWN), !fInherit);
                        EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION), !fInherit);
                        EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), !fInherit);
                        EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), !fInherit);
                        EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), !fInherit);
                    }
                    else
                        pthis->_pCats->SetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );

                    MMCPropertyChangeNotify( pthis->_hMmcNotify, 0 );

                    fRet = TRUE;
                }
                CATCH( CException, e )
                {
                    DisplayError( hwndDlg, e );
                }
                END_CATCH

                break;
            }

            } // switch

            break;
        }

        case WM_DESTROY:
        {
            CIndexSrvPropertySheet1 * pthis = (CIndexSrvPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            //
            // Only gets called on *one* property page!
            //

            // MMCFreeNotifyHandle( pthis->_hMmcNotify );

            delete pthis;

            fRet = TRUE;
            break;
        }
        } // switch
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CIndexSrvPropertySheet1: Caught 0x%x\n", e.GetErrorCode() ));
        fRet = FALSE;
    }
    END_CATCH

    return fRet;
}

CCatalogBasicPropertySheet::CCatalogBasicPropertySheet( HINSTANCE hInstance,
                                                        LONG_PTR hMmcNotify,
                                                        CCatalog const * pCat )
        : _pCat( pCat ),
          _hMmcNotify( hMmcNotify )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_CATALOG_PAGE1);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_CATALOG_PAGE1_TITLE);
    _PropSheet.pfnDlgProc  = CCatalogBasicPropertySheet::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CCatalogBasicPropertySheet::~CCatalogBasicPropertySheet()
{
}

INT_PTR APIENTRY CCatalogBasicPropertySheet::DlgProc( HWND hwndDlg,
                                                      UINT message,
                                                      WPARAM wParam,
                                                      LPARAM lParam )
{
    BOOL fRet = FALSE;

    TRY
    {
        switch ( message )
        {
        case WM_HELP:
        {
            HELPINFO *phi = (HELPINFO *) lParam;

            ciaDebugOut(( DEB_ITRACE,
                          "CCatalogBasicPropertySheet::DlgProc -- WM_HELP: wp 0x%x, lp 0x%x\n",
                          wParam, lParam ));

            if ( HELPINFO_WINDOW == phi->iContextType )
            {
                switch ( phi->iCtrlId )
                {
                    case IDDI_STATIC:
                        break;

                    default :
                        DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                        break;
                }

            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
            break;
        }

        case WM_INITDIALOG:
        {
            ciaDebugOut(( DEB_ITRACE, "CCatalogBasicPropertySheet::DlgProc -- WM_INITDIALOG\n" ));

            LONG_PTR lthis = ((CCatalogBasicPropertySheet *)lParam)->_PropSheet.lParam;

            SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

            CCatalog const * pCat = ((CCatalogBasicPropertySheet *)lParam)->_pCat;

            SetDlgItemText( hwndDlg, IDDI_CATNAME, pCat->GetCat( TRUE ) );
            SetDlgItemText( hwndDlg, IDDI_SIZE, pCat->GetSize( TRUE ) );
            SetDlgItemText( hwndDlg, IDDI_PATH, pCat->GetDrive( TRUE ) );
            SetDlgItemText( hwndDlg, IDDI_PROPCACHE_SIZE, pCat->GetPropCacheSize( TRUE ) );

            fRet = TRUE;
            break;
        }

        case WM_DESTROY:
        {
            CCatalogBasicPropertySheet * pthis = (CCatalogBasicPropertySheet *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            //
            // Only gets called on *one* property page!
            //

            // MMCFreeNotifyHandle( pthis->_hMmcNotify );

            delete pthis;

            fRet = TRUE;
            break;
        }
        } // switch
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CCatalogBasicPropertySheet: Caught 0x%x\n", e.GetErrorCode() ));
        fRet = FALSE;
    }
    END_CATCH

    return fRet;
}

CIndexSrvPropertySheet2::CIndexSrvPropertySheet2( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCatalog * pCat )
        : _pCat( pCat ),
          _pCats( 0 ),
          _hMmcNotify( hMmcNotify ),
          _fNNTPServer( FALSE ),
          _fWebServer( FALSE )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_CATALOG_PAGE2);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_CATALOG_PAGE2_TITLE);
    _PropSheet.pfnDlgProc  = CIndexSrvPropertySheet2::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CIndexSrvPropertySheet2::CIndexSrvPropertySheet2( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCatalogs * pCats )
        : _pCat( 0 ),
          _pCats( pCats ),
          _hMmcNotify( hMmcNotify )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_CATALOG_PAGE2);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_CATALOG_PAGE2_TITLE);
    _PropSheet.pfnDlgProc  = CIndexSrvPropertySheet2::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CIndexSrvPropertySheet2::~CIndexSrvPropertySheet2()
{
}

INT_PTR APIENTRY CIndexSrvPropertySheet2::DlgProc( HWND hwndDlg,
                                                   UINT message,
                                                   WPARAM wParam,
                                                   LPARAM lParam )
{
    BOOL fRet = FALSE;

    TRY
    {
        switch ( message )
        {
        case WM_HELP:
        {
            HELPINFO *phi = (HELPINFO *) lParam;

            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet2 WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                          phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                          phi->iCtrlId, phi->dwContextId ));

            if ( HELPINFO_WINDOW == phi->iContextType )
            {
                switch ( phi->iCtrlId )
                {
                    case IDDI_STATIC:
                        break;

                    default :
                        DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                        break;
                }

            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
            break;
        }

        case WM_INITDIALOG:
        {
            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet2::DlgProc -- WM_INITDIALOG\n" ));

            LONG_PTR lthis = ((CIndexSrvPropertySheet2 *)lParam)->_PropSheet.lParam;
            CIndexSrvPropertySheet2 * pthis = (CIndexSrvPropertySheet2 *)lthis;

            SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

            BOOL  fAutoAlias;
            BOOL  fVirtualRoots;
            BOOL  fNNTPRoots;
            ULONG iVirtualServer;
            ULONG iNNTPServer;


            // It is important to initialize the counters here to guarantee that
            // they will remain 0 if we don't get to invoke the enumerators that
            // count the number of servers.
            ULONG cVServers = 0, cNNTPServers = 0;

            ShowWindow(GetDlgItem(hwndDlg, IDDI_VIRTUAL_SERVER), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDDI_NNTP_SERVER), FALSE);

            ShowWindow(GetDlgItem(hwndDlg, IDDI_VSERVER_STATIC), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDDI_NNTP_STATIC), FALSE);

            if ( 0 != pthis->_pCat )
            {
                if ( AreServersAvailable( *(pthis->_pCat) ) )
                {
                    pthis->_pCat->GetWeb( fVirtualRoots,
                                          fNNTPRoots,
                                          iVirtualServer,
                                          iNNTPServer );

                    InitVSList( GetDlgItem(hwndDlg, IDDI_VIRTUAL_SERVER),
                                GetDlgItem(hwndDlg, IDDI_NNTP_SERVER),
                                *(pthis->_pCat),
                                cVServers,
                                cNNTPServers );
                }

                pthis->_pCat->GetTracking( fAutoAlias );

                // Look in the registry for Group2 params. If at least one of them is listed
                // we should uncheck the "Inherit" checkbox. Otherwise
                // (if none of them is listed), we should check the box.
                SendDlgItemMessage( hwndDlg, 
                                    IDDI_INHERIT2,
                                    BM_SETCHECK,
                                    pthis->_pCat->DoGroup2SettingsExist() ? BST_UNCHECKED : BST_CHECKED,
                                    0 );

                // If all the settings don't exist, then delete the others in the group.
                // We don't want to have part of the group inherited and part local.
                if (pthis->_pCat->DoGroup2SettingsExist())
                    pthis->_pCat->FillGroup2Settings();
            }
            else
            {
                // Hide the "Inherit" checkbox because it is not applicable here
                ShowWindow(GetDlgItem(hwndDlg, IDDI_INHERIT2), SW_HIDE);

                pthis->_pCats->GetTracking( fAutoAlias );
            }

            if (cVServers)
            {
                ShowWindow(GetDlgItem(hwndDlg, IDDI_VIRTUAL_SERVER), TRUE);
                ShowWindow(GetDlgItem(hwndDlg, IDDI_VSERVER_STATIC), TRUE);
                pthis->_fWebServer = TRUE;
                SendDlgItemMessage( hwndDlg,
                                    IDDI_VIRTUAL_SERVER,
                                    CB_SETCURSEL,
                                    VSToIndex( hwndDlg, IDDI_VIRTUAL_SERVER,
                                               iVirtualServer, fVirtualRoots ), 0 );
            }

            if (cNNTPServers)
            {
                ShowWindow(GetDlgItem(hwndDlg, IDDI_NNTP_SERVER), TRUE);
                ShowWindow(GetDlgItem(hwndDlg, IDDI_NNTP_STATIC), TRUE);
                pthis->_fNNTPServer = TRUE;
                SendDlgItemMessage( hwndDlg,
                                    IDDI_NNTP_SERVER,
                                    CB_SETCURSEL,
                                    VSToIndex( hwndDlg, IDDI_NNTP_SERVER,
                                               iNNTPServer, fNNTPRoots ), 0 );
            }

            SendDlgItemMessage( hwndDlg,
                                IDDI_AUTO_ALIAS,
                                BM_SETCHECK,
                                fAutoAlias ? BST_CHECKED : BST_UNCHECKED,
                                0 );

            // If we are inheriting, we should disable the local setting.
            if ( 0 != pthis->_pCat && !pthis->_pCat->DoGroup2SettingsExist())
                EnableWindow(GetDlgItem(hwndDlg, IDDI_AUTO_ALIAS), FALSE);

            fRet = TRUE;

            break;
        }

        case WM_COMMAND:
        {
            BOOL fChanged = FALSE;

            switch ( LOWORD( wParam ) )
            {
               case IDDI_VIRTUAL_SERVER:
               case IDDI_NNTP_SERVER:
               {
                   if ( CBN_SELCHANGE == HIWORD(wParam) )
                   {
                       if ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER ) )
                       {
                           fChanged = TRUE;
                           fRet = TRUE;
                       }
                   }
   
                   break;
               }
   
               case IDDI_AUTO_ALIAS:
               {
                   if ( EN_CHANGE == HIWORD(wParam) || BN_CLICKED == HIWORD(wParam) )
                   {
                       if ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER ) )
                       {
                           fChanged = TRUE;
                           fRet = TRUE;
                       }
                   }
   
                   break;
               }

               case IDDI_INHERIT2:
               {
                   if ( EN_CHANGE == HIWORD(wParam) || BN_CLICKED == HIWORD(wParam) )
                   {
                      if ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER ) )
                      {
                          fChanged = TRUE;
                          fRet = TRUE;

                          BOOL fInherit = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_INHERIT2, BM_GETCHECK, 0, 0 ) );
                          BOOL fAutoAlias = FALSE;

                          CIndexSrvPropertySheet2 * pthis = (CIndexSrvPropertySheet2 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                          if (fInherit)
                          {
                              Win4Assert(pthis->IsTrackingCatalog());
                              pthis->_pCat->GetParent().GetTracking(fAutoAlias);
                          }
                          else
                          {
                              pthis->_pCat->GetTracking(fAutoAlias);

                              // Enable so we can set controls
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_AUTO_ALIAS), TRUE);
                          }

                          SendDlgItemMessage( hwndDlg,
                                              IDDI_AUTO_ALIAS,
                                              BM_SETCHECK,
                                              fAutoAlias ? BST_CHECKED : BST_UNCHECKED,
                                              0 );

                          // Disable controls if we need to
                          if (fInherit)
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_AUTO_ALIAS), FALSE);
                      }
                   }
               }

            } // switch

            if ( fChanged )
                PropSheet_Changed( GetParent(hwndDlg), hwndDlg );

            break;
        }

        case WM_NOTIFY:
        {
            switch ( ((LPNMHDR) lParam)->code )
            {
            case PSN_APPLY:
            {
                TRY
                {
                    CIndexSrvPropertySheet2 * pthis = (CIndexSrvPropertySheet2 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    BOOL  fAutoAlias = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_AUTO_ALIAS, BM_GETSTATE, 0, 0 ) );

                    if ( 0 != pthis->_pCat )
                    {
                        BOOL fVirtualRoots = FALSE;
                        ULONG iVirtualServer = 0;

                        if ( pthis->_fWebServer )
                        {
                            iVirtualServer = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_VIRTUAL_SERVER, CB_GETCURSEL, 0, 0 );
                            fVirtualRoots = ( 0 != iVirtualServer );
                            iVirtualServer = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_VIRTUAL_SERVER, CB_GETITEMDATA, iVirtualServer, 0 );
                        }

                        BOOL fNNTPRoots = FALSE;
                        ULONG iNNTPServer = 0;

                        if ( pthis->_fNNTPServer )
                        {
                            iNNTPServer = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_NNTP_SERVER, CB_GETCURSEL, 0, 0 );
                            fNNTPRoots = ( 0 != iNNTPServer );
                            iNNTPServer = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_NNTP_SERVER, CB_GETITEMDATA, iNNTPServer, 0 );
                        }

                        pthis->_pCat->SetWeb( fVirtualRoots, fNNTPRoots, iVirtualServer, iNNTPServer );

                        // If the Inherit Settings button is checked, we should remove the registry entries from the catalog's
                        // settings so the values will be inherited from the service.
                        BOOL fInherit = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_INHERIT2, BM_GETSTATE, 0, 0 ) );
                        if (fInherit)
                            pthis->_pCat->DeleteGroup2Settings();
                        else
                            pthis->_pCat->SetTracking( fAutoAlias );

                        // Set the current values and set state of the local controls
                        BOOL fAutoAlias;

                        pthis->_pCat->GetTracking( fAutoAlias );
                        SendDlgItemMessage( hwndDlg,
                                            IDDI_AUTO_ALIAS,
                                            BM_SETCHECK,
                                            fAutoAlias ? BST_CHECKED : BST_UNCHECKED,
                                            0 );
                        EnableWindow(GetDlgItem(hwndDlg, IDDI_AUTO_ALIAS), !fInherit);
                    }
                    else
                        pthis->_pCats->SetTracking( fAutoAlias );

                    MMCPropertyChangeNotify( pthis->_hMmcNotify, 0 );

                    fRet = TRUE;
                }
                CATCH( CException, e )
                {
                    DisplayError( hwndDlg, e );
                }
                END_CATCH

                break;
            }

            } // switch

            break;
        }

        case WM_DESTROY:
        {
            CIndexSrvPropertySheet2 * pthis = (CIndexSrvPropertySheet2 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            //
            // Only gets called on *one* property page!
            //

            // MMCFreeNotifyHandle( pthis->_hMmcNotify );

            delete pthis;

            fRet = TRUE;
            break;
        }
        } // switch
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CIndexSrvPropertySheet2: Caught 0x%x\n", e.GetErrorCode() ));
        fRet = FALSE;
    }
    END_CATCH

    return fRet;
}

CPropertyPropertySheet1::CPropertyPropertySheet1( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCachedProperty * pProperty,
                                                  CCatalog * pCat )
        : _pProperty( pProperty ),
          _propNew( *pProperty ),
          _hMmcNotify( hMmcNotify ),
          _pCat( pCat )
{
    _PropSheet.dwSize    = sizeof( _PropSheet ) + sizeof( this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_PROPERTY_PAGE1);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_PROPERTY_PAGE1_TITLE);
    _PropSheet.pfnDlgProc  = CPropertyPropertySheet1::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CPropertyPropertySheet1::~CPropertyPropertySheet1()
{
}

INT_PTR APIENTRY CPropertyPropertySheet1::DlgProc( HWND hwndDlg,
                                                   UINT message,
                                                   WPARAM wParam,
                                                   LPARAM lParam )
{
    BOOL fRet = FALSE;

    TRY
    {
        switch ( message )
        {
        case WM_HELP:
        {
            HELPINFO *phi = (HELPINFO *) lParam;

            ciaDebugOut(( DEB_ITRACE,
                          "CPropertyPropertySheet1 WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                          phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                          phi->iCtrlId, phi->dwContextId ));

            if ( HELPINFO_WINDOW == phi->iContextType )
            {
                switch ( phi->iCtrlId )
                {
                    case IDDI_STATIC:
                        break;

                    default :
                        DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                        break;
                }
            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
            break;
        }

        case WM_INITDIALOG:
        {
            ciaDebugOut(( DEB_ITRACE, "CPropertyPropertySheet1::DlgProc -- WM_INITDIALOG\n" ));

            LONG_PTR lthis = ((CPropertyPropertySheet1 *)lParam)->_PropSheet.lParam;

            SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

            CCachedProperty const & prop = ((CPropertyPropertySheet1 *)lthis)->_propNew;

            SetDlgItemText( hwndDlg, IDDI_PROPSET, prop.GetPropSet() );
            SetDlgItemText( hwndDlg, IDDI_PROPERTY, prop.GetProperty() );

            SendDlgItemMessage( hwndDlg,
                                IDDI_SPIN_CACHEDSIZE,
                                UDM_SETRANGE,
                                0,
                                (LPARAM) MAKELONG( 500, 4) );


            InitVTList( GetDlgItem(hwndDlg, IDDI_DATATYPE) );
            InitStorageLevelList( GetDlgItem(hwndDlg, IDDI_STORAGELEVEL) );

            if ( prop.IsCached() )
            {
                SendDlgItemMessage( hwndDlg, IDDI_CACHED, BM_SETCHECK, BST_CHECKED, 0 );
                SendDlgItemMessage( hwndDlg, IDDI_DATATYPE, CB_SETCURSEL, aulTypeIndex[ prop.GetVT() & ~VT_VECTOR ], 0 );
                // StoreLevel() is 0 for primary, 1 for secondary, which is the sequence in which we added them.
                // So using StoreLevel() as in index will work fine!
                SendDlgItemMessage( hwndDlg, IDDI_STORAGELEVEL, CB_SETCURSEL, prop.StoreLevel(), 0 );
                SetDlgItemText( hwndDlg, IDDI_CACHEDSIZE, prop.GetAllocation() );

                // Currently we do not allow the storage level to be changed after initial setting
                EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), FALSE );
            }
            else
            {
                SendDlgItemMessage( hwndDlg, IDDI_CACHED, BM_SETCHECK, BST_UNCHECKED, 0 );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_DATATYPE ), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), FALSE );
                EnableWindow( GetDlgItem( GetParent(hwndDlg), IDOK), FALSE );
            }

            // If properties cannot be modified, disable all controls
            // Only cached properties can be resitant to modifications!
            if (!prop.IsModifiable() && prop.IsCached())
            {
                EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHED), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_DATATYPE ), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), FALSE );
                EnableWindow( GetDlgItem( GetParent(hwndDlg), IDOK), FALSE );
            }

            fRet = TRUE;
            break;
        }

        case WM_COMMAND:
        {
            BOOL fChanged = FALSE;
            BOOL fCorrected = TRUE;

            switch ( LOWORD( wParam ) )
            {
            case IDDI_DATATYPE:
            {
                if ( CBN_CLOSEUP == HIWORD(wParam) )
                {
                    CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    fChanged = pthis->Refresh( hwndDlg, TRUE );

                    if ( pthis->_propNew.IsFixed() )
                    {
                        SetDlgItemText( hwndDlg, IDDI_CACHEDSIZE, pthis->_propNew.GetAllocation() );
                        // Disable the size control
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), FALSE );
                    }
                    else
                    {
                        SetDlgItemText( hwndDlg, IDDI_CACHEDSIZE, L"4" );
                        // Enable the size control. Variable props can be resized.
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), TRUE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), TRUE );
                    }

                    fRet = TRUE;
                }

                break;
            }


            case IDDI_STORAGELEVEL:
            {
                CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                if ( CBN_CLOSEUP == HIWORD(wParam) )
                {
                    fChanged = pthis->Refresh( hwndDlg, TRUE );
                    fRet = TRUE;
                }

                break;
            }

            case IDDI_CACHEDSIZE:
            {
               if ( EN_KILLFOCUS == HIWORD(wParam) )
               {
                   fRet = TRUE;
                   ULONG ulVal = 4;

                   // Validate the number
                   XArray<WCHAR> xawcTemp;

                   if ( GetDlgItemXArrayText( hwndDlg, IDDI_CACHEDSIZE, xawcTemp ) &&
                            xawcTemp.Count() > 0 )
                   {
                       // verify that all characters are digits
                       ULONG ulLen = wcslen(xawcTemp.GetPointer());
                       // When correcting, let's do our best.
                       ulVal = _wtoi(xawcTemp.GetPointer());
                       for (ULONG i = 0; i < ulLen; i++)
                       {
                           if (!iswdigit(xawcTemp[i]))
                               break;
                       }
                       if (i == ulLen)
                       {
                           // verify that the number is within range
                           ulVal = _wtoi(xawcTemp.GetPointer());

                           ciaDebugOut((DEB_ERROR, "number is %d, string is %ws\n", 
                                        ulVal, xawcTemp.GetPointer()));

                           if (ulVal <= 500)
                               fCorrected = FALSE;
                           else if (ulVal > 500)
                               ulVal = 500;
                       }
                   }

                   // if we are dealing with a vble property, we should ensure that the
                   // size is at least 4 bytes
                   
                   if (ulVal < 4)
                   {
                      CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );
  
                      if ( 0 != pthis )
                      {
                          if (pthis->_propNew.IsCached() && !pthis->_propNew.IsFixed())
                          {
                              ulVal = 4;
                              fCorrected = TRUE;
                          }
                      }
                   }

                   if (fCorrected)
                   {
                       MessageBeep(MB_ICONHAND);
                       // xawcTemp may not have a buffer, so don't use it for _itow. Use a temp vble
                       WCHAR wszBuff[20]; 
                       SetWindowText((HWND)lParam, _itow(ulVal, wszBuff, 10));
                       SendMessage((HWND)lParam, EM_SETSEL, 0, -1);
                   }
               }
               else if ( EN_CHANGE == HIWORD(wParam) && ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER )) )
               {
                    CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    if ( 0 != pthis )
                    {
                        fChanged = pthis->Refresh( hwndDlg, FALSE );
                        fRet = TRUE;
                    }
               }

               break;
            }

            case IDDI_CACHED:
            {
                if ( BN_CLICKED == HIWORD(wParam) )
                {
                    CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    ULONG fChecked = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_CACHED, BM_GETSTATE, 0, 0 );

                    if ( fChecked & BST_CHECKED )
                    {
                        pthis->Refresh( hwndDlg, FALSE );

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_DATATYPE ), TRUE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), TRUE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), TRUE );

                        // If this property is currently being cached in the property store (as indicated
                        // by CCachedProperty), we do not let it's store level be changed. This ensures
                        // that a user cannot change a property between store levels.

                        if (pthis->_propNew.IsCached() && INVALID_STORE_LEVEL != pthis->_propNew.StoreLevel())
                        {
                            SendDlgItemMessage( hwndDlg, IDDI_STORAGELEVEL, CB_SETCURSEL,
                                                pthis->_propNew.StoreLevel(), 0 );
                            EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), FALSE );
                        }
                        else
                        {
                            // enable and display the storage level. Default to secondary,
                            // if none is available

                            if (PRIMARY_STORE != pthis->_propNew.StoreLevel())
                                pthis->_propNew.SetStoreLevel(SECONDARY_STORE);

                            SendDlgItemMessage( hwndDlg, IDDI_STORAGELEVEL, CB_SETCURSEL,
                                                pthis->_propNew.StoreLevel(), 0 );
                            EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), TRUE );
                        }

                        // if no item is currently selected, set lpwstr by default
                        if (VT_EMPTY == pthis->_propNew.GetVT() || 0 == pthis->_propNew.Allocation())
                        {
                            UINT uiType = DBTypeToVT(pthis->_propNew.GetDefaultType());
                            if (uiType != VT_EMPTY)
                            {
                                ciaDebugOut((DEB_ITRACE, "DIALOG: %ws has type %d (==> %d)\n", 
                                             pthis->_propNew.GetFName(), pthis->_propNew.GetDefaultType(), 
                                             DBTypeToVT(pthis->_propNew.GetDefaultType())));
                                pthis->_propNew.SetVT( uiType );
                                pthis->_propNew.SetAllocation( pthis->_propNew.GetDefaultSize() );
                            }
                            else
                            {
                                // default datatype should be LPWSTR
                                pthis->_propNew.SetVT( VT_LPWSTR );
                                pthis->_propNew.SetAllocation( 4 );
                            }
                        }

                        // Assert that the property is now marked cached
                        Win4Assert( pthis->_propNew.IsCached() );

                        // now display it
                        SendDlgItemMessage( hwndDlg, IDDI_DATATYPE, CB_SETCURSEL,
                                            aulTypeIndex[ pthis->_propNew.GetVT() & ~VT_VECTOR ], 0 );
                        SetDlgItemText( hwndDlg, IDDI_CACHEDSIZE, pthis->_propNew.GetAllocation() );


                        // in case OK was disabled, enable it
                        EnableWindow( GetDlgItem( GetParent(hwndDlg), IDOK), TRUE );
                    }
                    else
                    {
                        pthis->_propNew.SetVT( VT_EMPTY );
                        pthis->_propNew.SetAllocation( 0 );
                        // IMPORTANT: Don't set storage level to invalid. We need to
                        //            know where to delete this from!
                        //pthis->_propNew.SetStoreLevel(INVALID_STORE_LEVEL);

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_DATATYPE ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), FALSE );
                    }

                    fChanged = TRUE;
                    fRet = TRUE;
                }
                break;
            }

            } // switch

            if ( fChanged )
            {
                CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                PropSheet_Changed( GetParent(hwndDlg), hwndDlg );
            }

            break;
        }

        case WM_NOTIFY:
        {
            switch ( ((LPNMHDR) lParam)->code )
            {
            case PSN_APPLY:
            {
                TRY
                {
                    CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    *pthis->_pProperty = pthis->_propNew;
                    pthis->_pProperty->MakeUnappliedChange();
                    pthis->_pCat->UpdateCachedProperty(pthis->_pProperty);

                    MMCPropertyChangeNotify( pthis->_hMmcNotify, (LONG_PTR)pthis->_pProperty );

                    MessageBox( hwndDlg,
                                STRINGRESOURCE( srPendingProps ),
                                STRINGRESOURCE( srPendingPropsTitle ),
                                MB_OK | MB_ICONINFORMATION );

                    fRet = TRUE;

                    ciaDebugOut((DEB_ITRACE, "VarType is %d, Allocation size is %d, Store level is %d\n",
                                 pthis->_pProperty->GetVT(), pthis->_pProperty->Allocation(), 
                                 pthis->_pProperty->StoreLevel() ));
                }
                CATCH( CException, e )
                {
                    DisplayError( hwndDlg, e );
                }
                END_CATCH

                break;
            }

            } // switch

            break;
        }

        case WM_DESTROY:
        {
            CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            // Freeing this will cause a double-delete since it's shared across instances of this page

#if 0
    DbgPrint( "WM_DESTROY CPropertyPropertySheet1 this %#x, _hMmcNotify: %#x\n", pthis, pthis->_hMmcNotify );
            MMCFreeNotifyHandle( pthis->_hMmcNotify );

    pthis->_hMmcNotify = 0;
#endif

            delete pthis;

            fRet = TRUE;
            break;
        }

        default:
            fRet = FALSE;
            break;
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CPropertyPropertySheet1: Caught 0x%x\n", e.GetErrorCode() ));
        fRet = FALSE;
    }
    END_CATCH

    return fRet;
}

BOOL CPropertyPropertySheet1::Refresh( HWND hwndDlg, BOOL fVTOnly )
{
    BOOL fChanged = FALSE;

    DWORD dwIndex = (DWORD)SendDlgItemMessage( hwndDlg, IDDI_DATATYPE, CB_GETCURSEL, 0, 0 );
    ULONG vt = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_DATATYPE, CB_GETITEMDATA, dwIndex, 0 );

    if ( vt != _propNew.GetVT() )
        fChanged = TRUE;

    _propNew.SetVT( vt );

    dwIndex = (DWORD)SendDlgItemMessage( hwndDlg, IDDI_STORAGELEVEL, CB_GETCURSEL, 0, 0 );
    DWORD dwStoreLevel = (DWORD)SendDlgItemMessage( hwndDlg, IDDI_STORAGELEVEL, CB_GETITEMDATA, dwIndex, 0 );

    if ( dwStoreLevel != _propNew.StoreLevel() )
        fChanged = TRUE;

    _propNew.SetStoreLevel( dwStoreLevel );

    if ( !fVTOnly )
    {
        XArray<WCHAR> xawcSize;

        if ( GetDlgItemXArrayText( hwndDlg, IDDI_CACHEDSIZE, xawcSize ) && xawcSize.Count() > 0)
        {
            ULONG cb = wcstoul( xawcSize.Get(), 0, 10 );

            if ( cb != _propNew.Allocation() )
                fChanged = TRUE;

            _propNew.SetAllocation( cb );
        }
    }

    return fChanged;
}

void InitVTList( HWND hwndCombo )
{
    DWORD dwIndex;

    //
    // Add an item for each type group.
    //

    int j = 0;

    for ( int i = 0; i < cType; i++ )
    {
        if ( 0 != awcsType[i] )
        {
            dwIndex = (DWORD)SendMessage( hwndCombo, CB_ADDSTRING, 0, (LPARAM)awcsType[i] );
            SendMessage(hwndCombo, CB_SETITEMDATA, dwIndex, i );
            j++;
        }
    }

    //
    // NOTE: After the first property box, this just sets identical values.
    //

    for ( j--; j >= 0; j-- )
    {
        dwIndex = (DWORD)SendMessage( hwndCombo, CB_GETITEMDATA, j, 0 );
        aulTypeIndex[dwIndex] = j;
    }
}

void InitStorageLevelList( HWND hwndCombo )
{
    DWORD dwIndex;

    //
    // Add an item for each of the two levels.
    //

    dwIndex = (DWORD)SendMessage( hwndCombo, CB_ADDSTRING, 0, (LPARAM)STRINGRESOURCE(srPrimaryStore) );
    SendMessage(hwndCombo, CB_SETITEMDATA, dwIndex, PRIMARY_STORE );

    dwIndex = (DWORD)SendMessage( hwndCombo, CB_ADDSTRING, 0, (LPARAM)STRINGRESOURCE(srSecondaryStore) );
    SendMessage(hwndCombo, CB_SETITEMDATA, dwIndex, SECONDARY_STORE );
}

//
// Helper class for virtual server callback.
//

//+---------------------------------------------------------------------------
//
//  Class:      CMetaDataVirtualServerCallBack
//
//  Purpose:    Pure virtual for vroot enumeration
//
//  History:    07-Feb-1997   dlee    Created
//
//----------------------------------------------------------------------------

class CVSComboBox : public CMetaDataVirtualServerCallBack
{
public:

    CVSComboBox( HWND hwndCombo ) :
        _hwndCombo( hwndCombo ),
        cEntries( 0 )
    {
    }

    virtual SCODE CallBack( DWORD iInstance, WCHAR const * pwcInstance );

    virtual ~CVSComboBox() {}

    ULONG EntryCount() { return cEntries; }

private:

    HWND _hwndCombo;
    ULONG cEntries;
};

SCODE CVSComboBox::CallBack( DWORD iInstance, WCHAR const * pwcInstance )
{
    // We pass NULL for _hwndCombo when we only need a count of entries.

    if (NULL != _hwndCombo)
    {
        DWORD dwIndex = (DWORD)SendMessage( _hwndCombo, CB_ADDSTRING, 0, (LPARAM)pwcInstance );
        SendMessage( _hwndCombo, CB_SETITEMDATA, dwIndex, (LPARAM)iInstance );
    }

    cEntries++;

    return S_OK;
}

BOOL AreServersAvailable( CCatalog const & cat )
{
    BOOL fEntriesInList = FALSE;

    //
    // Virtual Server(s)
    //

    TRY
    {
        //
        // Add an item for each type group.
        //

        CMetaDataMgr mgr( TRUE, W3VRoot, 0xffffffff, cat.GetMachine() );

        CVSComboBox  vsc( NULL );

        mgr.EnumVServers( vsc );

        fEntriesInList = (0 == vsc.EntryCount()) ? FALSE : TRUE;
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Couldn't enumerate virtual servers.\n" ));
    }
    END_CATCH

    //
    // Virtual NNTP Server(s)
    //

    TRY
    {
        //
        // Add an item for each type group.
        //

        CMetaDataMgr mgr( TRUE, NNTPVRoot, 0xffffffff, cat.GetMachine() );

        CVSComboBox  vsc( NULL );

        mgr.EnumVServers( vsc );

        fEntriesInList = fEntriesInList || ( (0 == vsc.EntryCount()) ? FALSE : TRUE );
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Couldn't enumerate virtual servers.\n" ));
    }
    END_CATCH

    return fEntriesInList;
}

void InitVSList( HWND hwndComboVS, HWND hwndComboNNTP, CCatalog const & cat,
                 ULONG & cVServers, ULONG & cNNTPServers )
{
    //
    // Virtual Server(s)
    //

    TRY
    {
        SendMessage( hwndComboVS, CB_ADDSTRING, 0,
                     (LPARAM) STRINGRESOURCE( srNoneSelected.wsz ) );

        //
        // Add an item for each type group.
        //

        CMetaDataMgr mgr( TRUE, W3VRoot, 0xffffffff, cat.GetMachine() );

        CVSComboBox  vsc( hwndComboVS );

        Win4Assert(0 == vsc.EntryCount());

        mgr.EnumVServers( vsc );

        cVServers = vsc.EntryCount();
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Couldn't enumerate virtual servers.\n" ));
    }
    END_CATCH

    //
    // Virtual NNTP Server(s)
    //

    TRY
    {
        SendMessage( hwndComboNNTP, CB_ADDSTRING, 0,
                     (LPARAM) STRINGRESOURCE( srNoneSelected.wsz ) );
        //
        // Add an item for each type group.
        //

        CMetaDataMgr mgr( TRUE, NNTPVRoot, 0xffffffff, cat.GetMachine() );

        CVSComboBox  vsc( hwndComboNNTP );

        Win4Assert(0 == vsc.EntryCount());

        mgr.EnumVServers( vsc );

        cNNTPServers = vsc.EntryCount();
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Couldn't enumerate virtual servers.\n" ));
    }
    END_CATCH

#if 0
    //
    // Virtual IMAP Server(s)
    //

    TRY
    {
        //
        // Add an item for each type group.
        //


        CMetaDataMgr mgr( TRUE, IMAPVRoot, 0xffffffff, cat.GetMachine() );

        DWORD dwIndex = SendMessage( hwndComboIMAP, CB_ADDSTRING, 0,
                                     (LPARAM) STRINGRESOURCE( srNoneSelected.wsz ) );

        CVSComboBox  vsc( hwndComboIMAP );

        mgr.EnumVServers( vsc );
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Couldn't enumerate virtual servers.\n" ));
    }
    END_CATCH
#endif
}

void DisplayError( HWND hwnd, CException & e )
{
    WCHAR wcsError[MAX_PATH];

    if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                         GetModuleHandle(L"query.dll"),
                         GetOleError( e ),
                         GetSystemDefaultLCID(),
                         wcsError,
                         sizeof(wcsError) / sizeof(WCHAR),
                         0 ) )
    {
        wsprintf( wcsError,
                  STRINGRESOURCE(srGenericError),
                  GetOleError( e ) );
    }

    MessageBox( hwnd,
                wcsError,
                STRINGRESOURCE( srIndexServerCmpManage ),
                MB_OK | MB_ICONERROR );
}

DWORD VSToIndex( HWND hwndDlg, DWORD dwItem, ULONG ulVS, BOOL fTrack )
{
    if ( !fTrack )
        return 0;

    unsigned cItem = (unsigned)SendDlgItemMessage( hwndDlg,
                                                   dwItem,
                                                   CB_GETCOUNT, 0, 0 );

    for ( unsigned i = 1; i < cItem; i++ )
    {
        ULONG ulItem = (ULONG)SendDlgItemMessage( hwndDlg,
                                                  dwItem,
                                                  CB_GETITEMDATA, i, 0 );

        if ( ulVS == ulItem )
            break;
    }

    return i;
} //VSToIndex


// Return of VT_EMPTY could imply an unknown conversion.
UINT DBTypeToVT(UINT uidbt)
{
    if (uidbt <= DBTYPE_GUID)
        return uidbt;
    
    // Some conversions

    DBTYPE dbtSimpler = uidbt &~ DBTYPE_VECTOR &~ DBTYPE_ARRAY &~ DBTYPE_BYREF;
    
    switch (dbtSimpler)
    {
        case DBTYPE_WSTR:
            return VT_LPWSTR;

        case DBTYPE_STR:
            return VT_LPSTR;

        case DBTYPE_FILETIME:
            return VT_FILETIME;

        default:
           return VT_EMPTY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\rootnode.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       rootnode.cxx
//
//  Contents:   snapin extension root node.
//
//  History:    6-16-98 mohamedn   created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rootnode.hxx>


//+---------------------------------------------------------------------------
//
//  Member:     CRootNode::Display, public
//
//  Synopsis:   Inserts the root node item in the scope pane.
//
//  Arguments:  [hScopeItem] -- handle to parent scope item
//
//  Returns:    none.
//
//  History:    01-Jul-1998  mohamedn    created
//
//----------------------------------------------------------------------------

void CRootNode::Display( HSCOPEITEM hScopeItem )
{
    SCOPEDATAITEM item;

    RtlZeroMemory( &item, sizeof(item) );

    item.mask |= SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
    item.nImage = item.nOpenImage = ICON_APP;
    item.displayname = MMC_CALLBACK;

    item.mask |= SDI_PARAM;
    item.lParam = (LPARAM)this;

    item.relativeID = hScopeItem;

    HRESULT hr = _pScopePane->InsertItem( &item );
    if ( FAILED(hr) )
    {
        ciaDebugOut(( DEB_ERROR, "_pScopePane->InsertItem() Failed, hr: %x\n", hr ));
        THROW( CException(hr) );
    }

    _idScope = item.ID;
    _idParent = hScopeItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootNode::Delete, public
//
//  Synopsis:   Deletes root node from scope pane.
//
//  History:    27-Jul-1998    KyleP   Created
//
//  Notes:      Called when MMCN_REMOVE_CHILDREN sent to snap-in.
//
//----------------------------------------------------------------------------

SCODE CRootNode::Delete()
{
    SCODE sc = S_OK;

    if ( -1 != _idScope )
    {
        sc = _pScopePane->DeleteItem( _idScope, TRUE );
        _idScope = -1;
        _idParent = -1;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\strings.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       Strings.cxx
//
//  Contents:   Localizable string resources.
//
//  History:    26-Jan-1998     KyleP   Added header
//              20-Jan-1999     SLarimor Modified rescan interface to include 
//                                      Full and Incremental options separatly
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciares.h>
#include "ntverp.h"

//-----------------------------------------------------------------------------

StringResource srAnnealing        = { MSG_STATE_ANNEALING_MERGE };
StringResource srBattery          = { MSG_STATE_BATTERY_POWER };
StringResource srCMAddCatalog     = { MSG_CM_ADD_CATALOG };
StringResource srCMAddCatalogHelp = { MSG_CM_ADD_CATALOG_HELP };
StringResource srCMDelCatalog     = { MSG_CM_DEL_CATALOG };
StringResource srCMDelCatalogHelp = { MSG_CM_DEL_CATALOG_HELP };
StringResource srCMDelScope       = { MSG_CM_DEL_SCOPE };
StringResource srCMDelScopeHelp   = { MSG_CM_DEL_SCOPE_HELP };
StringResource srCMMerge          = { MSG_CM_MERGE };
StringResource srCMMergeHelp      = { MSG_CM_MERGE_HELP };
StringResource srCMPauseCI        = { MSG_CM_PAUSE_CI };
StringResource srCMPauseCIHelp    = { MSG_CM_PAUSE_CI_HELP };
StringResource srCMRescanFull     = { MSG_CM_SCAN_FULL_SCOPE };
StringResource srCMRescanFullHelp = { MSG_CM_SCAN_FULL_SCOPE_HELP };
StringResource srCMRescanIncremental = { MSG_CM_SCAN_INCREMENTAL_SCOPE };
StringResource srCMRescanIncrementalHelp = { MSG_CM_SCAN_INCREMENTAL_SCOPE_HELP };
StringResource srCMScope          = { MSG_CM_ADD_SCOPE };
StringResource srCMScopeHelp      = { MSG_CM_ADD_SCOPE_HELP };
StringResource srCMStartCI        = { MSG_CM_START_CI };
StringResource srCMStartCIHelp    = { MSG_CM_START_CI_HELP };
StringResource srCMStopCI         = { MSG_CM_STOP_CI };
StringResource srCMStopCIHelp     = { MSG_CM_STOP_CI_HELP };
StringResource srCMEmptyCatalog   = { MSG_CM_EMPTY_CATALOG };
StringResource srCMEmptyCatalogHelp = { MSG_CM_EMPTY_CATALOG_HELP };
StringResource srCMInvalidScope     = { MSG_CM_INVALID_SCOPE };
StringResource srCMUnexpectedError  = { MSG_CM_UNEXPECTED_ERROR };
StringResource srCMShutdownService  = { MSG_CM_SHUTDOWN_SERVICE };
StringResource srCMShutdownServiceTitle   = { MSG_CM_SHUTDOWN_SERVICE_TITLE };
StringResource srCMCantShutdownService    = { MSG_CM_CANT_SHUTDOWN_SERVICE };
StringResource srCMCantSaveSettings       = { MSG_CM_CANT_SAVE_SETTINGS };

StringResource srGenericError     = { MSG_GENERIC_ERROR };
StringResource srGenericErrorTitle= { MSG_ERROR_TITLE };
StringResource srInvalidComputerName = { MSG_INVALID_COMPUTER_NAME };
StringResource srHighIo           = { MSG_STATE_HIGH_IO };
StringResource srIndexServer      = { MSG_INDEX_SERVER };
StringResource srIndexServerCmpManage = { MSG_INDEX_SERVER_CMPMANAGE };
StringResource srLM               = { MSG_LOCAL_MACHINE };
StringResource srLowMemory        = { MSG_STATE_LOW_MEMORY };
StringResource srMaster           = { MSG_STATE_MASTER_MERGE };
StringResource srMMPaused         = { MSG_STATE_MASTER_MERGE_PAUSED };
StringResource srMsgCantDeleteCatalog = { MSG_CANT_DELETE_CATALOG };
StringResource srMsgDeleteCatalog = { MSG_DELETE_CATALOG };
StringResource srMsgDeleteCatalogAsk = { MSG_DELETE_CATALOG_ASK };
StringResource srMsgCatalogPartialDeletion = { MSG_CATALOG_PARTIAL_DELETION };
StringResource srMsgDeleteCatalogTitle = { MSG_DELETE_CATALOG_TITLE };
StringResource srMsgEnableCI      = { MSG_ENABLE_CI };
StringResource srMsgEnableCITitle = { MSG_ENABLE_CI_TITLE };
StringResource srMsgMerge         = { MSG_MERGE_CATALOG };
StringResource srMsgRescanFull    = { MSG_RESCAN_FULL_SCOPE };
StringResource srMsgRescanIncremental = { MSG_RESCAN_INCREMENTAL_SCOPE };
StringResource srMsgRescanFullExplain = { MSG_RESCAN_FULL_SCOPE_EXPLAIN };
StringResource srMsgRescanIncrementalExplain = { MSG_RESCAN_INCREMENTAL_SCOPE_EXPLAIN };
StringResource srNC               = { MSG_NEW_CATALOG };
StringResource srNCError          = { MSG_CANT_ADD_CATALOG };
StringResource srNCT              = { MSG_NEW_CATALOG_TITLE };
StringResource srNCErrorT         = { MSG_CANT_ADD_CATALOG_TITLE };
StringResource srNo               = { MSG_NO };
StringResource srNodeDirectories  = { MSG_NODE_DIRECTORIES };
StringResource srNodeProperties   = { MSG_NODE_PROPERTIES };
StringResource srNodeUnfiltered   = { MSG_NODE_UNFILTERED };
StringResource srPendingProps     = { MSG_PENDING_PROP_CHANGE };
StringResource srPendingPropsTitle= { MSG_PENDING_PROP_CHANGE_TITLE };
StringResource srRecovering       = { MSG_STATE_RECOVERING };
StringResource srScanReq          = { MSG_STATE_CONTENT_SCAN_REQUIRED };
StringResource srScanning         = { MSG_STATE_SCANNING };
StringResource srShadow           = { MSG_STATE_SHADOW_MERGE };
StringResource srStarting         = { MSG_STATE_STARTING };
StringResource srReadingUsns      = { MSG_STATE_READING_USNS };
StringResource srUserActive       = { MSG_STATE_USER_ACTIVE };
StringResource srStarted          = { MSG_STATE_STARTED };
StringResource srStopped          = { MSG_STATE_STOPPED };
StringResource srYes              = { MSG_YES };
StringResource srPrimaryStore     = { MSG_STORELEVEL_PRIMARY };
StringResource srSecondaryStore   = { MSG_STORELEVEL_SECONDARY };
StringResource srPropCommitErrorT = { MSG_ERROR_PROP_COMMIT};
StringResource srProductDescription = { MSG_PRODUCT_DESCRIPTION };
StringResource srVendorCopyright    = { MSG_VENDOR_COPYRIGHT };
StringResource srVendorName         = { MSG_VENDOR_NAME };
StringResource srProviderName       = { MSG_PROVIDER_NAME };
StringResource srRefreshProperties  = { MSG_CM_PROPERTIES_REFRESH };
StringResource srRefreshPropertiesHelp = { MSG_CM_PROPERTIES_REFRESH_HELP };
StringResource srNoneSelected          = { MSG_NONE_SELECTED };
StringResource srReadOnly              = { MSG_STATE_READ_ONLY };
StringResource srMsgEmptyCatalogAsk    = { MSG_EMPTY_CATALOG_TITLE };
StringResource srMsgEmptyCatalogPrompt = { MSG_EMPTY_CATALOG_PROMPT };
StringResource srType                  = { MSG_TYPE };
StringResource srCMTunePerformance     = { MSG_CM_TUNE_PERFORMANCE };
StringResource srCMTunePerformanceHelp = { MSG_CM_TUNE_PERFORMANCE_HELP };
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
StringResource srSnapinNameStringIndirect = { MSG_SNAPIN_NAME_STRING_INDIRECT };
#endif

void InitStrings( HINSTANCE hInstance )
{
    srAnnealing.Init( hInstance );
    srBattery.Init( hInstance );
    srCMAddCatalog.Init( hInstance );
    srCMAddCatalogHelp.Init( hInstance );
    srCMDelCatalog.Init( hInstance );
    srCMDelCatalogHelp.Init( hInstance );
    srCMDelScope.Init( hInstance );
    srCMDelScopeHelp.Init( hInstance );
    srCMMerge.Init( hInstance );
    srCMMergeHelp.Init( hInstance );
    srCMPauseCI.Init( hInstance );
    srCMPauseCIHelp.Init( hInstance );
    srCMRescanFull.Init( hInstance );
    srCMRescanFullHelp.Init( hInstance );
    srCMRescanIncremental.Init( hInstance );
    srCMRescanIncrementalHelp.Init( hInstance );
    srCMScope.Init( hInstance );
    srCMScopeHelp.Init( hInstance );
    srCMStartCI.Init( hInstance );
    srCMStartCIHelp.Init( hInstance );
    srCMStopCI.Init( hInstance );
    srCMStopCIHelp.Init( hInstance );
    srCMEmptyCatalog.Init( hInstance );
    srCMEmptyCatalogHelp.Init( hInstance );
    srCMInvalidScope.Init( hInstance );
    srCMUnexpectedError.Init( hInstance );
    srGenericError.Init( hInstance );
    srGenericErrorTitle.Init( hInstance );
    srInvalidComputerName.Init( hInstance );
    srHighIo.Init( hInstance );
    srIndexServer.Init( hInstance );
    srIndexServerCmpManage.Init( hInstance );
    srLM.Init( hInstance );
    srLowMemory.Init( hInstance );
    srMaster.Init( hInstance );
    srMMPaused.Init( hInstance );
    srMsgCantDeleteCatalog.Init( hInstance );
    srMsgDeleteCatalog.Init( hInstance );
    srMsgCatalogPartialDeletion.Init( hInstance );
    srMsgDeleteCatalogAsk.Init( hInstance );
    srMsgDeleteCatalogTitle.Init( hInstance );
    srMsgEnableCI.Init( hInstance );
    srMsgEnableCITitle.Init( hInstance );
    srMsgMerge.Init( hInstance );
    srMsgRescanFull.Init( hInstance );
    srMsgRescanIncremental.Init( hInstance );
    srMsgRescanFullExplain.Init( hInstance );
    srMsgRescanIncrementalExplain.Init( hInstance );
    srNC.Init( hInstance );
    srNCError.Init( hInstance );
    srNCT.Init( hInstance );
    srNCErrorT.Init( hInstance );
    srNo.Init( hInstance );
    srNodeDirectories.Init( hInstance );
    srNodeProperties.Init( hInstance );
    srNodeUnfiltered.Init( hInstance );
    srPendingProps.Init( hInstance );
    srPendingPropsTitle.Init( hInstance );
    srRecovering.Init( hInstance );
    srScanReq.Init( hInstance );
    srScanning.Init( hInstance );
    srUserActive.Init( hInstance );
    srShadow.Init( hInstance );
    srStarting.Init( hInstance );
    srReadingUsns.Init( hInstance );
    srStarted.Init( hInstance );
    srStopped.Init( hInstance );
    srYes.Init( hInstance );
    srPrimaryStore.Init( hInstance );
    srSecondaryStore.Init( hInstance );
    srPropCommitErrorT.Init( hInstance );
    srProductDescription.Init( hInstance );
    srVendorName.Init( hInstance );
    srProviderName.Init( hInstance );
    srVendorCopyright.Init( hInstance );
    srRefreshProperties.Init( hInstance );
    srRefreshPropertiesHelp.Init( hInstance );
    srNoneSelected.Init( hInstance );
    srReadOnly.Init( hInstance );
    srMsgEmptyCatalogAsk.Init( hInstance );
    srMsgEmptyCatalogPrompt.Init( hInstance );
    srType.Init( hInstance );
    srCMTunePerformance.Init( hInstance );
    srCMTunePerformanceHelp.Init( hInstance );
    srCMShutdownService.Init( hInstance );
    srCMShutdownServiceTitle.Init( hInstance );
    srCMCantSaveSettings.Init( hInstance );
    srCMCantShutdownService.Init( hInstance );
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
    srSnapinNameStringIndirect.Init( hInstance );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ci\ci.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation, 1997 - 2001.  All Rights Reserved.
//
// PROGRAM:  ci.cxx
//
// PURPOSE:  Illustrates a minimal query using Indexing Service.
//           Uses CIMakeICommand and CITextToFullTree helper functions.
//
// PLATFORM: Windows 2000
//
//--------------------------------------------------------------------------

#define UNICODE
#define DBINITCONSTANTS

#include <stdio.h>
#include <wchar.h>
#include <windows.h>
#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>
#include <ntquery.h>
#include <mlang.h>
#include <ciodm.h>

#include "ci.hxx"

// This is found in disptree.cxx

extern void DisplayCommandTree( DBCOMMANDTREE * pNode, ULONG iLevel = 0 );

// These are found in isrch.cxx

extern HRESULT DoISearch( WCHAR const * pwcRestriction,
                          WCHAR const * pwcFilename,
                          BOOL          fPrintFile,
                          BOOL          fDefineCPP,
                          LCID          lcid,
                          ULONG         ulDialect );
extern HINSTANCE PrepareForISearch();
extern void DoneWithISearch( HINSTANCE h );

const ULONG MAX_CATALOGS = 8;

//
// These properties (func and class) are emitted by the C++ filter (cxxflt.dll)
//

CIPROPERTYDEF aCPPProperties[] =
{
    {
        L"FUNC",
        DBTYPE_WSTR | DBTYPE_BYREF,
        {
            { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
            DBKIND_GUID_NAME,
            L"func"
        }
    },
    {
        L"CLASS",
        DBTYPE_WSTR | DBTYPE_BYREF,
        {
            { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
            DBKIND_GUID_NAME,
            L"class"
        }
    }
};

unsigned cCPPProperties = sizeof aCPPProperties /
                          sizeof aCPPProperties[0];

//+---------------------------------------------------------------------------
//
//  Class:      XBStr
//
//  Purpose:    Smart BSTR class
//
//----------------------------------------------------------------------------

class XBStr
{
public:
    XBStr(BSTR p = 0) : _p( p ) {}
    XBStr ( XBStr & x ): _p( x.Acquire() ) {}
    ~XBStr() { SysFreeString( _p ); }
    BOOL IsNull() const { return ( 0 == _p ); }
    void Set ( BSTR pOleStr ) { _p = pOleStr; }
    BSTR Acquire()
    {
        BSTR pTemp = _p;
        _p = 0;
        return pTemp;
    }
    BSTR GetPointer() const { return _p; }
    void Free() { SysFreeString( Acquire() ); }
private:
    BSTR _p;
};

//+-------------------------------------------------------------------------
//
//  Template:   XInterface
//
//  Synopsis:   Template for managing ownership of interfaces
//
//--------------------------------------------------------------------------

template<class T> class XInterface
{
public:
    XInterface( T * p = 0 ) : _p( p ) {}
    ~XInterface() { if ( 0 != _p ) _p->Release(); }
    T * operator->() { return _p; }
    T * GetPointer() const { return _p; }
    IUnknown ** GetIUPointer() { return (IUnknown **) &_p; }
    T ** GetPPointer() { return &_p; }
    void ** GetQIPointer() { return (void **) &_p; }
    T * Acquire() { T * p = _p; _p = 0; return p; }
    BOOL IsNull() { return ( 0 == _p ); }

private:
    T * _p;
};

//+-------------------------------------------------------------------------
//
//  Template:   XPtr
//
//  Synopsis:   Template for managing ownership of memory
//
//--------------------------------------------------------------------------

template<class T> class XPtr
{
public:
    XPtr( unsigned c ) : _p(0) { if ( 0 != c ) _p = new T [ c ]; }
    ~XPtr() { Free(); }
    void SetSize( unsigned c ) { Free(); _p = new T [ c ]; }
    void Set ( T * p ) { _p = p; }
    T * Get() const { return _p ; }
    void Free() { delete [] Acquire(); }
    T & operator[]( unsigned i ) { return _p[i]; }
    T const & operator[]( unsigned i ) const { return _p[i]; }
    T * Acquire() { T * p = _p; _p = 0; return p; }
    BOOL IsNull() const { return ( 0 == _p ); }

private:
    T * _p;
};

//+-------------------------------------------------------------------------
//
//  Template:   CResString
//
//  Synopsis:   Class for loading string resources
//
//--------------------------------------------------------------------------

class CResString
{
public:
    CResString() { _awc[ 0 ] = 0; }
    CResString( UINT strIDS ) { Load( strIDS ); }
    WCHAR const * Get() const { return _awc; }

    BOOL Load( UINT strIDS )
    {
        _awc[ 0 ] = 0;
        LoadString( 0, strIDS, _awc, sizeof _awc / sizeof WCHAR );
        return ( 0 != _awc[ 0 ] );
    }

private:
    WCHAR _awc[ 200 ];
};

//+-------------------------------------------------------------------------
//
//  Function:   FormatError
//
//  Synopsis:   Formats an error code into a string
//
//  Arguments:  [sc]   - An Indexing Service or Win32 HRESULT
//              [pwc]  - Where to write the error string
//              [cwc]  - Count of characters in pwc
//              [lcid] - Locale for the error string
//
//--------------------------------------------------------------------------

void FormatError(
    SCODE   sc,
    WCHAR * pwc,
    ULONG   cwc,
    LCID    lcid )
{
    // FormatMessage works best when based on thread locale.

    LCID SaveLCID = GetThreadLocale();
    BOOL fLocaleSet = SetThreadLocale( lcid );

    // Is this an Indexing Service error?  These errors are in query.dll.

    if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                          GetModuleHandle( L"query.dll" ),
                          sc,
                          0,
                          pwc,
                          cwc,
                          0 ) )
    {
        // Is this a Win32 error?  These are in kernel32.dll

        const ULONG facWin32 = ( FACILITY_WIN32 << 16 );
        ULONG Win32Error = sc;

        if ( (Win32Error & facWin32) == facWin32 )
            Win32Error &= ~( 0x80000000 | facWin32 );

        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                              GetModuleHandle( L"kernel32.dll" ),
                              Win32Error,
                              0,
                              pwc,
                              cwc,
                              0 ) )
        {
            // It's not from Indexing Service or Win32; display a default error

            CResString str( IDS_UNKNOWNERROR );
            wcscpy( pwc, str.Get() );
        }
    }

    // Restore the original thread locale

    if ( fLocaleSet )
        SetThreadLocale( SaveLCID );
} //FormatError

//+-------------------------------------------------------------------------
//
//  Function:   DisplayError
//
//  Synopsis:   Prints an error message from a string resource
//
//  Arguments:  [uiError]     - The error message resource id
//              [pwcArgument] - A string argument for the error message
//              [hr]          - The error code
//              [lcid]        - Locale for the error string
//
//--------------------------------------------------------------------------

HRESULT DisplayError(
    UINT          uiError,
    WCHAR const * pwcArgument,
    HRESULT       hr,
    LCID          lcid )
{
    WCHAR awcError[ 200 ];
    FormatError( hr, awcError, sizeof awcError / sizeof WCHAR, lcid );

    CResString str( uiError );
    wprintf( str.Get(), pwcArgument, hr, awcError );

    return hr;
} //DisplayError

//+-------------------------------------------------------------------------
//
//  Function:   DisplayWin32Error
//
//  Synopsis:   Prints an error message taken from GetLastError()
//
//  Arguments:  [uiError]     - The string resource to use for the error
//              [pwcArgument] - A string argument for the error message
//              [lcid]        - Locale for the error string
//
//--------------------------------------------------------------------------

HRESULT DisplayWin32Error(
    UINT          uiError,
    WCHAR const * pwcArgument,
    LCID          lcid )
{
    HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
    DisplayError( uiError, pwcArgument, hr, lcid );
    return hr;
} //DisplayWin32Error

void DisplayStat( DWORD dw, UINT uiMsg )
{
    CResString str( uiMsg );
    wprintf( L"%8d %ws\n", dw, str.Get() );
} //DisplayStat

void DisplayStat( WCHAR const *pwcMsg, UINT uiMsg )
{
    CResString str( uiMsg );
    wprintf( L"%ws: %ws\n", str.Get(), pwcMsg );
} //DisplayStat

void DisplayStat( UINT uiMsg )
{
    CResString str( uiMsg );
    wprintf( L"%ws\n", str.Get() );
} //DisplayStat

//+-------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays information about how to use the app and exits
//
//--------------------------------------------------------------------------

void Usage()
{
    HRSRC hrc = FindResource( 0, (LPCWSTR) IDR_USAGE, RT_RCDATA );

    if ( 0 != hrc )
    {
        HGLOBAL hg = LoadResource( 0, hrc );

        if ( 0 != hg )
        {
            void * pv = LockResource( hg );

            if ( 0 != pv )
                wprintf( L"%ws\n", pv );
        }
    }

    exit( -1 );
} //Usage

//+-------------------------------------------------------------------------
//
//  Function:   LocaleToCodepage
//
//  Synopsis:   Finds the best matching codepage given a locale id.
//
//  Arguments:  [lcid]  - Locale to check
//
//  Returns:    The best matching codepage.
//
//--------------------------------------------------------------------------

ULONG LocaleToCodepage( LCID lcid )
{
    ULONG codepage;

    int cwc = GetLocaleInfo( lcid,
                             LOCALE_RETURN_NUMBER |
                                 LOCALE_IDEFAULTANSICODEPAGE,
                             (WCHAR *) &codepage,
                             sizeof ULONG / sizeof WCHAR );

    // If an error occurred, return the Ansi code page

    if ( 0 == cwc )
         return CP_ACP;

    return codepage;
} //LocaleToCodepage

//+-------------------------------------------------------------------------
//
//  Function:   GetLocaleString
//
//  Synopsis:   Looks up a locale string given an LCID
//
//  Arguments:  [lcid] - The lcid to look up
//
//  Returns:    The matching string (in a static buffer, caller beware).
//
//--------------------------------------------------------------------------

WCHAR const * GetLocaleString( LCID lcid )
{
    static WCHAR awcLocale[ 100 ];
    wcscpy( awcLocale, L"Neutral" );

    XInterface<IMultiLanguage> xMultiLang;

    HRESULT hr = CoCreateInstance( CLSID_CMultiLanguage,
                                   0,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IMultiLanguage,
                                   xMultiLang.GetQIPointer() );

    if ( SUCCEEDED( hr ) )
    {
        BSTR bstrLocale;

        hr = xMultiLang->GetRfc1766FromLcid( lcid, &bstrLocale );
        if ( SUCCEEDED( hr ) )
        {
            wcscpy( awcLocale, bstrLocale );
            SysFreeString( bstrLocale );
        }
    }

    return awcLocale;
} //GetLocaleString

//+-------------------------------------------------------------------------
//
//  Function:   LcidFromHttpAcceptLanguage
//
//  Synopsis:   Looks up an LCID given an HTTP Accept Language string
//
//  Arguments:  [pwc] - The string to look up
//
//  Returns:    The matching LCID.
//
//--------------------------------------------------------------------------

LCID LcidFromHttpAcceptLanguage( WCHAR const * pwc )
{
    // Default to the system locale

    LCID lcid = GetSystemDefaultLCID();

    if ( 0 != pwc )
    {
        // Check for an integer constant in hex or decimal, then try as a
        // string.

        if ( ( L'0' == pwc[0]  ) &&
             ( L'X' == towupper( pwc[1] ) ) )
        {
            int x = wcslen( pwc );
            WCHAR *pwcEnd;
            return wcstoul( pwc, &pwcEnd, 16 );
        }
        else
        {
            BOOL fInteger = TRUE;

            for ( WCHAR const * p = pwc; ( 0 != *p ); p++ )
            {
                if ( !iswdigit( *p ) )
                {
                    fInteger = FALSE;
                    break;
                }
            }

            if ( fInteger )
                return _wtol( pwc );
        }
    
        XInterface<IMultiLanguage> xMultiLang;

        HRESULT hr = CoCreateInstance( CLSID_CMultiLanguage,
                                       0,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IMultiLanguage,
                                       xMultiLang.GetQIPointer() );

        if ( SUCCEEDED( hr ) )
        {
            BSTR bstr = SysAllocString( pwc );

            if ( 0 != bstr )
            {
                hr = xMultiLang->GetLcidFromRfc1766( &lcid, bstr );

                SysFreeString( bstr );

                if ( S_FALSE == hr ||
                     E_FAIL == hr )
                {
                    if ( !_wcsicmp( pwc, L"neutral" ) ||
                         !_wcsicmp( pwc, L"neutr" ) )
                        lcid = 0;
                    else
                        Usage();
                }
                else if ( FAILED( hr ) )
                {
                    Usage();
                }
            }
        }
    }

    return lcid;
} //LcidFromHttpAcceptLanguage

//+-------------------------------------------------------------------------
//
//  Function:   SetCommandProperties
//
//  Synopsis:   Sets the DBPROP_USEEXTENDEDDBTYPES property to TRUE, so
//              data is returned in PROPVARIANTs, as opposed to the
//              default, which is OLE automation VARIANTs.  PROPVARIANTS
//              allow a superset of VARIANT data types.  Use of these
//              types avoids costly coercions.
//
//              Also sets the DBPROP_USECONTENTINDEX property to TRUE, so
//              the index will always be used to resolve the query (as
//              opposed to enumerating all the files on the disk), even
//              if the index is out of date.  This is set optionally.
//
//              Both of these properties are unique to Indexing Service's
//              OLE DB implementation.
//
//  Arguments:  [pICommand] - The ICommand used to set the property
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//              [lcid] - The locale of the query
//              [cMaxHits] - The maximum number of rows to return, 0 for all.
//              [fFirstHits] - TRUE for first N hits, FALSE for best N hits.
//
//  Returns:    HRESULT result of setting the properties
//
//--------------------------------------------------------------------------

HRESULT SetCommandProperties(
    ICommand * pICommand,
    BOOL       fForceUseContentIndex,
    LCID       lcid,
    ULONG      cMaxHits,
    BOOL       fFirstHits )
{
    static const DBID dbcolNull = { { 0,0,0, { 0,0,0,0,0,0,0,0 } },
                                    DBKIND_GUID_PROPID, 0 };
    static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

    DBPROP aProp[2];

    // Use extened types in accessor bindings -- it's faster and more accurate

    aProp[0].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
    aProp[0].dwOptions = DBPROPOPTIONS_OPTIONAL;
    aProp[0].dwStatus = 0;
    aProp[0].colid = dbcolNull;
    aProp[0].vValue.vt = VT_BOOL;
    aProp[0].vValue.boolVal = VARIANT_TRUE;

    // Should we force use of the index?  Otherwise, enumeration will be slow.

    aProp[1] = aProp[0];
    aProp[1].dwPropertyID = DBPROP_USECONTENTINDEX;
    aProp[1].vValue.boolVal = fForceUseContentIndex ? VARIANT_TRUE : VARIANT_FALSE;

    DBPROPSET aPropSet[3];

    aPropSet[0].rgProperties = &aProp[0];
    aPropSet[0].cProperties = 2;
    aPropSet[0].guidPropertySet = guidQueryExt;

    const GUID guidMSIDXS_ROWSETEXT = DBPROPSET_MSIDXS_ROWSETEXT;

    DBPROP aRowsetExtProp[1];

    aPropSet[1].rgProperties = &aRowsetExtProp[0];
    aPropSet[1].cProperties = 1;
    aPropSet[1].guidPropertySet = guidMSIDXS_ROWSETEXT;

    // Set the default locale of the query

    aRowsetExtProp[0] = aProp[0];
    aRowsetExtProp[0].dwPropertyID = MSIDXSPROP_COMMAND_LOCALE_STRING;
    aRowsetExtProp[0].vValue.vt = VT_BSTR;
    aRowsetExtProp[0].vValue.bstrVal = SysAllocString( GetLocaleString( lcid ) );
    if ( 0 == aRowsetExtProp[0].vValue.bstrVal )
        return E_OUTOFMEMORY;

    DBPROP aRowsetProp[1];
    aPropSet[2].rgProperties = &aRowsetProp[0];
    aPropSet[2].cProperties = 1;
    aPropSet[2].guidPropertySet = DBPROPSET_ROWSET;

    // Set the first or best maximum number of result rows

    aRowsetProp[0] = aProp[0];
    aRowsetProp[0].dwPropertyID = fFirstHits ? DBPROP_FIRSTROWS : DBPROP_MAXROWS;
    aRowsetProp[0].vValue.vt = VT_I4;
    aRowsetProp[0].vValue.lVal = (LONG) cMaxHits;

    XInterface<ICommandProperties> xICommandProperties;
    HRESULT hr = pICommand->QueryInterface( IID_ICommandProperties,
                                            xICommandProperties.GetQIPointer() );
    if ( SUCCEEDED( hr ) )
    {
        hr = xICommandProperties->SetProperties( 3,
                                                 aPropSet ); // the properties
    }

    // Free the locale string

    HRESULT hr2 = VariantClear( &aRowsetExtProp[0].vValue );

    if ( SUCCEEDED( hr ) && FAILED( hr2 ) )
        hr = hr2;

    return hr;
} //SetCommandProperties

//+-------------------------------------------------------------------------
//
//  Function:   Render
//
//  Synopsis:   Prints an item in a safearray
//
//  Arguments:  [vt]  - type of the element
//              [pa]  - pointer to the item
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa );

void Render( VARTYPE vt, void * pv )
{
    if ( VT_ARRAY & vt )
    {
        PrintSafeArray( vt - VT_ARRAY, *(SAFEARRAY **) pv );
        return;
    }

    switch ( vt )
    {
        case VT_UI1: wprintf( L"%u", (unsigned) *(BYTE *)pv ); break;
        case VT_I1: wprintf( L"%d", (int) *(CHAR *)pv ); break;
        case VT_UI2: wprintf( L"%u", (unsigned) *(USHORT *)pv ); break;
        case VT_I2: wprintf( L"%d", (int) *(SHORT *)pv ); break;
        case VT_UI4:
        case VT_UINT: wprintf( L"%u", (unsigned) *(ULONG *)pv ); break;
        case VT_I4:
        case VT_ERROR:
        case VT_INT: wprintf( L"%d", *(LONG *)pv ); break;
        case VT_UI8: wprintf( L"%I64u", *(unsigned __int64 *)pv ); break;
        case VT_I8: wprintf( L"%I64d", *(__int64 *)pv ); break;
        case VT_R4: wprintf( L"%f", *(float *)pv ); break;
        case VT_R8: wprintf( L"%lf", *(double *)pv ); break;
        case VT_DECIMAL:
        {
            double dbl;
            HRESULT hr = VarR8FromDec( (DECIMAL *) pv, &dbl );
            if ( SUCCEEDED( hr ) )
                wprintf( L"%lf", dbl );
            break;
        }
        case VT_CY:
        {
            double dbl;
            HRESULT hr = VarR8FromCy( * (CY *) pv, &dbl );
            if ( SUCCEEDED( hr ) )
                wprintf( L"%lf", dbl );
            break;
        }
        case VT_BOOL: wprintf( *(VARIANT_BOOL *)pv ? L"TRUE" : L"FALSE" ); break;
        case VT_BSTR: wprintf( L"%ws", *(BSTR *) pv ); break;
        case VT_VARIANT:
        {
            PROPVARIANT * pVar = (PROPVARIANT *) pv;
            Render( pVar->vt, & pVar->lVal );
            break;
        }
        case VT_DATE:
        {
            SYSTEMTIME st;
            BOOL fOK = VariantTimeToSystemTime( *(DATE *)pv, &st );

            if ( !fOK )
                break;

            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            wprintf( L"%2d-%02d-%04d %2d:%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_EMPTY:
        case VT_NULL:
            break;
        default :
        {
            wprintf( L"(vt 0x%x)", (int) vt );
            break;
        }
    }
} //Render

//+-------------------------------------------------------------------------
//
//  Function:   PrintSafeArray
//
//  Synopsis:   Prints items in a safearray
//
//  Arguments:  [vt]  - type of elements in the safearray
//              [pa]  - pointer to the safearray
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa )
{
    // Get the dimensions of the array

    UINT cDim = SafeArrayGetDim( pa );
    if ( 0 == cDim )
        return;

    XPtr<LONG> xDim( cDim );
    XPtr<LONG> xLo( cDim );
    XPtr<LONG> xUp( cDim );

    for ( UINT iDim = 0; iDim < cDim; iDim++ )
    {
        HRESULT hr = SafeArrayGetLBound( pa, iDim + 1, &xLo[iDim] );
        if ( FAILED( hr ) )
            return;

        xDim[ iDim ] = xLo[ iDim ];

        hr = SafeArrayGetUBound( pa, iDim + 1, &xUp[iDim] );
        if ( FAILED( hr ) )
            return;

        wprintf( L"{" );
    }

    // slog through the array

    UINT iLastDim = cDim - 1;
    BOOL fDone = FALSE;

    while ( !fDone )
    {
        // inter-element formatting

        if ( xDim[ iLastDim ] != xLo[ iLastDim ] )
            wprintf( L"," );

        // Get the element and render it

        void *pv;
        HRESULT hr = SafeArrayPtrOfIndex( pa, xDim.Get(), &pv );
        if ( FAILED( hr ) )
            return;

        Render( vt, pv );

        // Move to the next element and carry if necessary

        ULONG cOpen = 0;

        for ( LONG iDim = iLastDim; iDim >= 0; iDim-- )
        {
            if ( xDim[ iDim ] < xUp[ iDim ] )
            {
                xDim[ iDim ] = 1 + xDim[ iDim ];
                break;
            }

            wprintf( L"}" );

            if ( 0 == iDim )
                fDone = TRUE;
            else
            {
                cOpen++;
                xDim[ iDim ] = xLo[ iDim ];
            }
        }

        for ( ULONG i = 0; !fDone && i < cOpen; i++ )
            wprintf( L"{" );
    }
} //PrintSafeArray

//+-------------------------------------------------------------------------
//
//  Function:   PrintVectorItems
//
//  Synopsis:   Prints items in a PROPVARIANT vector
//
//  Arguments:  [pVal]  - The array of values
//              [cVals] - The count of values
//              [pcFmt] - The format string
//
//--------------------------------------------------------------------------

template<class T> void PrintVectorItems(
    T *     pVal,
    ULONG   cVals,
    char *  pcFmt )
{
    printf( "{ " );

    for( ULONG iVal = 0; iVal < cVals; iVal++ )
    {
        if ( 0 != iVal )
            printf( "," );
        printf( pcFmt, *pVal++ );
    }

    printf( " }" );
} //PrintVectorItems

//+-------------------------------------------------------------------------
//
//  Function:   DisplayValue
//
//  Synopsis:   Displays a PROPVARIANT value.  Limited formatting is done.
//
//  Arguments:  [pVar] - The value to display
//
//--------------------------------------------------------------------------

void DisplayValue( PROPVARIANT const * pVar )
{
    if ( 0 == pVar )
    {
        wprintf( L"NULL" );
        return;
    }

    // Display the most typical variant types

    PROPVARIANT const & v = *pVar;

    switch ( v.vt )
    {
        case VT_EMPTY : break;
        case VT_NULL : break;
        case VT_I4 : wprintf( L"%10d", v.lVal ); break;
        case VT_UI1 : wprintf( L"%10d", v.bVal ); break;
        case VT_I2 : wprintf( L"%10d", v.iVal ); break;
        case VT_R4 : wprintf( L"%10f", v.fltVal ); break;
        case VT_R8 : wprintf( L"%10lf", v.dblVal ); break;
        case VT_BOOL : wprintf( v.boolVal ? L"TRUE" : L"FALSE" ); break;
        case VT_I1 : wprintf( L"%10d", v.cVal ); break;
        case VT_UI2 : wprintf( L"%10u", v.uiVal ); break;
        case VT_UI4 : wprintf( L"%10u", v.ulVal ); break;
        case VT_INT : wprintf( L"%10d", v.lVal ); break;
        case VT_UINT : wprintf( L"%10u", v.ulVal ); break;
        case VT_I8 : wprintf( L"%20I64d", v.hVal ); break;
        case VT_UI8 : wprintf( L"%20I64u", v.hVal ); break;
        case VT_ERROR : wprintf( L"%#x", v.scode ); break;
        case VT_LPSTR : wprintf( L"%S", v.pszVal ); break;
        case VT_LPWSTR : wprintf( L"%ws", v.pwszVal ); break;
        case VT_BSTR : wprintf( L"%ws", v.bstrVal ); break;
        case VT_CY:
        {
            double dbl;
            HRESULT hr = VarR8FromCy( v.cyVal, &dbl );
            if ( SUCCEEDED( hr ) )
                wprintf( L"%lf", dbl );
            break;
        }
        case VT_DECIMAL :
        {
            double dbl;
            HRESULT hr = VarR8FromDec( (DECIMAL *) &v.decVal, &dbl );
            if ( SUCCEEDED( hr ) )
                wprintf( L"%lf", dbl );
            break;
        }
        case VT_FILETIME :
        case VT_DATE :
        {
            SYSTEMTIME st;

            if ( VT_DATE == v.vt )
            {
                BOOL fOK = VariantTimeToSystemTime( v.date, &st );

                if ( !fOK )
                    break;
            }
            else
            {
                FILETIME ft;
                BOOL fOK = FileTimeToLocalFileTime( &v.filetime, &ft );

                if ( fOK )
                    fOK = FileTimeToSystemTime( &ft, &st );

                if ( !fOK )
                    break;
            }

            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            wprintf( L"%2d-%02d-%04d %2d:%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_VECTOR | VT_I1:
            PrintVectorItems( v.cac.pElems, v.cac.cElems, "%d" ); break;
        case VT_VECTOR | VT_I2:
            PrintVectorItems( v.cai.pElems, v.cai.cElems, "%d" ); break;
        case VT_VECTOR | VT_I4:
            PrintVectorItems( v.cal.pElems, v.cal.cElems, "%d" ); break;
        case VT_VECTOR | VT_I8:
            PrintVectorItems( v.cah.pElems, v.cah.cElems, "%I64d" ); break;
        case VT_VECTOR | VT_UI1:
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%u" ); break;
        case VT_VECTOR | VT_UI2:
            PrintVectorItems( v.caui.pElems, v.caui.cElems, "%u" ); break;
        case VT_VECTOR | VT_UI4:
            PrintVectorItems( v.caul.pElems, v.caul.cElems, "%u" ); break;
        case VT_VECTOR | VT_ERROR:
            PrintVectorItems( v.cascode.pElems, v.cascode.cElems, "%#x" ); break;
        case VT_VECTOR | VT_UI8:
            PrintVectorItems( v.cauh.pElems, v.cauh.cElems, "%I64u" ); break;
        case VT_VECTOR | VT_BSTR:
            PrintVectorItems( v.cabstr.pElems, v.cabstr.cElems, "%ws" ); break;
        case VT_VECTOR | VT_LPSTR:
            PrintVectorItems( v.calpstr.pElems, v.calpstr.cElems, "%S" ); break;
        case VT_VECTOR | VT_LPWSTR:
            PrintVectorItems( v.calpwstr.pElems, v.calpwstr.cElems, "%ws" ); break;
        case VT_VECTOR | VT_R4:
            PrintVectorItems( v.caflt.pElems, v.caflt.cElems, "%f" ); break;
        case VT_VECTOR | VT_R8:
            PrintVectorItems( v.cadbl.pElems, v.cadbl.cElems, "%lf" ); break;
        default : 
        {
            if ( VT_ARRAY & v.vt )
                PrintSafeArray( v.vt - VT_ARRAY, v.parray );
            else
                wprintf( L"vt 0x%05x", v.vt );
            break;
        }
    }
} //DisplayValue

//-----------------------------------------------------------------------------
//
//  Function:   GetOleDBErrorInfo
//
//  Synopsis:   Retrieves the secondary error from the OLE DB error object.
//
//  Arguments:  [pErrSrc]      - Pointer to object that posted the error.
//              [riid]         - Interface that posted the error.
//              [lcid]         - Locale in which the text is desired.
//              [pErrorInfo]   - Pointer to memory where ERRORINFO should be.
//              [ppIErrorInfo] - Holds the returning IErrorInfo. Caller
//                               should release this.
//
//  Returns:    HRESULT for whether the error info was retrieved
//
//-----------------------------------------------------------------------------

HRESULT GetOleDBErrorInfo(
    IUnknown *    pErrSrc,
    REFIID        riid,
    LCID          lcid,
    ERRORINFO *   pErrorInfo,
    IErrorInfo ** ppIErrorInfo )
{
    *ppIErrorInfo = 0;

    // See if an error is available that is of interest to us.

    XInterface<ISupportErrorInfo> xSupportErrorInfo;
    HRESULT hr = pErrSrc->QueryInterface( IID_ISupportErrorInfo,
                                          xSupportErrorInfo.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    hr = xSupportErrorInfo->InterfaceSupportsErrorInfo( riid );
    if ( FAILED( hr ) )
        return hr;

    // Get the current error object. Return if none exists.

    XInterface<IErrorInfo> xErrorInfo;
    hr = GetErrorInfo( 0, xErrorInfo.GetPPointer() );
    if ( xErrorInfo.IsNull() )
        return hr;

    // Get the IErrorRecord interface and get the count of errors.

    XInterface<IErrorRecords> xErrorRecords;
    hr = xErrorInfo->QueryInterface( IID_IErrorRecords,
                                     xErrorRecords.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    ULONG cErrRecords;
    hr = xErrorRecords->GetRecordCount( &cErrRecords );
    if ( 0 == cErrRecords )
        return hr;

#if 1 // A good way to get the complete error message...

    XInterface<IErrorInfo> xErrorInfoRec;
    ERRORINFO ErrorInfo;
    for ( unsigned i=0; i<cErrRecords; i++ )
    {
        // Get basic error information.

        xErrorRecords->GetBasicErrorInfo( i, &ErrorInfo );

        // Get error description and source through the IErrorInfo interface
        // pointer on a particular record.

        xErrorRecords->GetErrorInfo( i, lcid, xErrorInfoRec.GetPPointer() );

        XBStr bstrDescriptionOfError;
        XBStr bstrSourceOfError;

        BSTR bstrDesc = bstrDescriptionOfError.GetPointer();
        BSTR bstrSrc = bstrSourceOfError.GetPointer();

        xErrorInfoRec->GetDescription( &bstrDesc ); 
        xErrorInfoRec->GetSource( &bstrSrc );

        // At this point, you could call GetCustomErrorObject and query for
        // additional interfaces to determine what else happened.

        wprintf( L"%s (%#x)\n%s\n", bstrDesc, ErrorInfo.hrError, bstrSrc );    
    }
#endif

    // Get basic error information for the most recent error

    ULONG iRecord = cErrRecords - 1;
    hr = xErrorRecords->GetBasicErrorInfo( iRecord, pErrorInfo );
    if ( FAILED( hr ) )
        return hr;

    return xErrorRecords->GetErrorInfo( iRecord, lcid, ppIErrorInfo );
} //GetOleDBErrorInfo

//-----------------------------------------------------------------------------
//
//  Function:   DisplayRowsetStatus
//
//  Synopsis:   Retrieves status information about the rowset and catalog.
//
//  Arguments:  [xIRowset] - Rowset about which information is retrieved.
//
//  Returns:    HRESULT result of retrieving the status
//
//-----------------------------------------------------------------------------

HRESULT DisplayRowsetStatus( XInterface<IRowset> & xIRowset )
{
    XInterface<IRowsetInfo> xIRowsetInfo;
    HRESULT hr = xIRowset->QueryInterface( IID_IRowsetInfo,
                                           xIRowsetInfo.GetQIPointer() );

    if ( SUCCEEDED( hr ) )
    {
        // This rowset property is Indexing-Service specific

        DBPROPID propId = MSIDXSPROP_ROWSETQUERYSTATUS;
        DBPROPIDSET propSet;
        propSet.rgPropertyIDs = &propId;
        propSet.cPropertyIDs = 1;
        const GUID guidRowsetExt = DBPROPSET_MSIDXS_ROWSETEXT;
        propSet.guidPropertySet = guidRowsetExt;
    
        ULONG cPropertySets = 0;
        DBPROPSET * pPropertySets;
    
        hr = xIRowsetInfo->GetProperties( 1,
                                          &propSet,
                                          &cPropertySets,
                                          &pPropertySets );

        if ( SUCCEEDED( hr ) )
        {
            DWORD dwStatus = pPropertySets->rgProperties->vValue.ulVal;

            CoTaskMemFree( pPropertySets->rgProperties );
            CoTaskMemFree( pPropertySets );

            DWORD dwFill = QUERY_FILL_STATUS( dwStatus );

            if ( STAT_ERROR == dwFill )
                DisplayStat( IDS_ROWSET_STAT_ERROR );

            DWORD dwReliability = QUERY_RELIABILITY_STATUS( dwStatus );

            if ( 0 != ( STAT_PARTIAL_SCOPE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_PARTIAL_SCOPE );
            if ( 0 != ( STAT_NOISE_WORDS & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_NOISE_WORDS );
            if ( 0 != ( STAT_CONTENT_OUT_OF_DATE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_CONTENT_OUT_OF_DATE );
            if ( 0 != ( STAT_REFRESH_INCOMPLETE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_REFRESH_INCOMPLETE );
            if ( 0 != ( STAT_CONTENT_QUERY_INCOMPLETE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_CONTENT_QUERY_INCOMPLETE );
            if ( 0 != ( STAT_TIME_LIMIT_EXCEEDED & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_TIME_LIMIT_EXCEEDED );
            if ( 0 != ( STAT_SHARING_VIOLATION & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_SHARING_VIOLATION );
        }
    }

    return hr;
} //DisplayRowsetStatus

ULONG CountEntries( WCHAR const * pwc, WCHAR wc )
{
    WCHAR const * p = wcschr( pwc, wc );
    ULONG c = 1;

    while ( 0 != p )
    {
        c++;
        p++;
        p = wcschr( p, wc );
    }

    return c;
} //CountEntries

//+-------------------------------------------------------------------------
//
//  Function:   IssueQuery
//
//  Synopsis:   Creates and executes a query, then displays the results.
//
//  Arguments:  [pwcQueryCatalog]       - Catalog name over which query is run
//              [pwcQueryMachine]       - Machine name on which query is run
//              [pwcQueryScope]         - Scope of the query
//              [dwScopeFlags]          - Scope flags
//              [pwcQueryRestrition]    - The actual query string
//              [pwcColumns]            - Output column names
//              [pwcSort]               - Sort order names, may be 0
//              [fDisplayTree]          - TRUE to display the command tree
//              [fQuiet]                - if TRUE, don't display hitcount
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//              [fNoQuery]              - if TRUE, just parse and display query
//              [fSearchHit]            - if TRUE invoke hit-hilighting
//              [ulDialect]             - Query dialect (1 or 2)
//              [cMaxHits]              - Maximum # of hits, or 0 for no limit
//              [fFirstHits]            - TRUE for first N or FALSE for best N
//              [lcid]                  - Locale for the query
//              [fDefineCPP]            - TRUE to define func and class props
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT IssueQuery(
    WCHAR const * pwcQueryCatalog,
    WCHAR const * pwcQueryMachine,
    WCHAR const * pwcQueryScope,
    DWORD         dwScopeFlags,
    WCHAR const * pwcQueryRestriction,
    WCHAR const * pwcColumns,
    WCHAR const * pwcSort,
    BOOL          fDisplayTree,
    BOOL          fQuiet,
    BOOL          fForceUseContentIndex,
    BOOL          fNoQuery,
    BOOL          fSearchHit,
    ULONG         ulDialect,
    ULONG         cMaxHits,
    BOOL          fFirstHits,
    LCID          lcid,
    BOOL          fDefineCPP )
{
    // Create an ICommand object.  CIMakeICommand is a shortcut for making an
    // ICommand.  The ADVQUERY sample shows the OLE DB equivalent.

    XInterface<ICommand> xICommand;
    HRESULT hr;

    // Handle distributed and single catalog queries

    if ( ( 0 != wcschr( pwcQueryCatalog, L',' ) ) ||
         ( 0 != wcschr( pwcQueryMachine, L',' ) ) )
    {
        ULONG cCat = CountEntries( pwcQueryCatalog, L',' );
        ULONG cMac = CountEntries( pwcQueryMachine, L',' );

        if ( ( ( cCat != cMac ) && ( 1 != cCat ) && ( 1 != cMac ) ) ||
             ( cCat > MAX_CATALOGS || cMac > MAX_CATALOGS ) )
            Usage();

        WCHAR awcCat[ MAX_PATH ];
        wcscpy( awcCat, pwcQueryCatalog );

        WCHAR awcMac[ MAX_PATH ];
        wcscpy( awcMac, pwcQueryMachine );

        WCHAR * aCat[ MAX_CATALOGS ];
        WCHAR * aMac[ MAX_CATALOGS ];
        WCHAR const * aSco[ MAX_CATALOGS ];
        DWORD aFla[ MAX_CATALOGS ];

        WCHAR * pwcCat = awcCat;
        WCHAR * pwcMac = awcMac;

        for ( ULONG i = 0; i < __max( cCat, cMac ); i++ )
        {
            aFla[i] = dwScopeFlags;
            aSco[i] = pwcQueryScope;

            aMac[i] = pwcMac;

            if ( 1 != cMac )
            {
                pwcMac = wcschr( pwcMac, L',' );
                if ( 0 != pwcMac )
                    *pwcMac++ = 0;
            }

            aCat[i] = pwcCat;

            if ( 1 != cCat )
            {
                pwcCat = wcschr( pwcCat, L',' );
                if ( 0 != pwcCat )
                    *pwcCat++ = 0;
            }
        }

        hr = CIMakeICommand( xICommand.GetPPointer(),
                             cCat,
                             aFla,
                             aSco,
                             aCat,
                             aMac );
    }
    else
    {
        hr = CIMakeICommand( xICommand.GetPPointer(),  // result
                             1,                        // 1 scope
                             &dwScopeFlags,            // scope flags
                             &pwcQueryScope,           // scope path
                             &pwcQueryCatalog,         // catalog
                             &pwcQueryMachine );       // machine
    }

    if ( FAILED( hr ) )
        return hr;

    // Set required properties on the ICommand

    hr = SetCommandProperties( xICommand.GetPointer(),
                               fForceUseContentIndex,
                               lcid,
                               cMaxHits,
                               fFirstHits );
    if ( FAILED( hr ) )
        return hr;

    // Get a command tree object

    XInterface<ICommandTree> xICommandTree;
    hr = xICommand->QueryInterface( IID_ICommandTree,
                                    xICommandTree.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    if ( ulDialect < 3 )
    {
        // Create an OLE DB query tree based on query parameters.
    
        DBCOMMANDTREE * pTree;
        ULONG cDefinedProperties = fDefineCPP ? cCPPProperties : 0;
        hr = CITextToFullTreeEx( pwcQueryRestriction, // the query itself
                                 ulDialect,           // query dialect
                                 pwcColumns,          // columns to return
                                 pwcSort,             // sort order, may be 0
                                 0,                   // reserved
                                 &pTree,              // resulting tree
                                 cDefinedProperties,  // C++ properties
                                 aCPPProperties,      // C++ properties
                                 lcid );              // default locale
        if ( FAILED( hr ) )
            return hr;
    
        // If directed, display the command tree.
    
        if ( fDisplayTree )
        {
            wprintf( L"%ws\n", pwcQueryRestriction );
            DisplayCommandTree( pTree );
        }
    
        // If directed, don't issue the query.  Parsing it was sufficient.
    
        if ( fNoQuery )
        {
            xICommandTree->FreeCommandTree( &pTree );
            return S_OK;
        }
    
        // Set the tree in the ICommandTree.  Ownership of the tree is transferred.
    
        hr = xICommandTree->SetCommandTree( &pTree,
                                            DBCOMMANDREUSE_NONE,
                                            FALSE );
        if ( FAILED( hr ) )
        {
            xICommandTree->FreeCommandTree( &pTree );
            return hr;
        }
    }
    else
    {
        // Get a command text object

        XInterface<ICommandText> xICommandText;
        hr = xICommand->QueryInterface( IID_ICommandText,
                                        xICommandText.GetQIPointer() );
        if ( FAILED( hr ) )
            return hr;

        hr = xICommandText->SetCommandText( DBGUID_SQL, pwcQueryRestriction );
        if ( FAILED( hr ) )
            return hr;

        // If directed, display the command tree.

        if ( fDisplayTree )
        {
            DBCOMMANDTREE * pTree = 0;
            hr = xICommandTree->GetCommandTree( &pTree );
            if ( FAILED( hr ) )
                return hr;

            wprintf( L"%ws\n", pwcQueryRestriction );
            DisplayCommandTree( pTree );
        }

        // If directed, don't issue the query.  Parsing it was sufficient.

        if ( fNoQuery )
            return S_OK;
    }
    
    // Execute the query.  The query is complete when Execute() returns.

    XInterface<IRowset> xIRowset;
    hr = xICommand->Execute( 0,            // no aggregating IUnknown
                             IID_IRowset,  // IID for interface to return
                             0,            // no DBPARAMs
                             0,            // no rows affected
                             xIRowset.GetIUPointer() ); // result
    if ( FAILED( hr ) )
    {
        // Get the real error; OLE DB permits few Execute() return codes

        ERRORINFO ErrorInfo;
        XInterface<IErrorInfo> xErrorInfo;
        HRESULT hr2 = GetOleDBErrorInfo( xICommand.GetPointer(),
                                         IID_ICommand,
                                         lcid,
                                         &ErrorInfo,
                                         xErrorInfo.GetPPointer() );

        // Post IErrorInfo only if we have a valid pointer to it.

        if ( SUCCEEDED( hr2 ) && !xErrorInfo.IsNull() )
            hr = ErrorInfo.hrError;

        return hr;
    }

    // Get the count of columns

    XInterface<IColumnsInfo> xColumnsInfo;
    hr = xIRowset->QueryInterface( IID_IColumnsInfo, xColumnsInfo.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    DBCOLUMNINFO *pColumnInfo = 0;
    WCHAR *pColumnNames = 0;
    DBORDINAL cColumns = 0;

    hr = xColumnsInfo->GetColumnInfo( &cColumns,
                                      &pColumnInfo,
                                      &pColumnNames );
    if ( FAILED( hr ) )
        return hr;

    // If bookmark was added as column 0, ignore it

    if ( 0 != ( pColumnInfo[0].dwFlags & DBCOLUMNFLAGS_ISBOOKMARK ) )
        cColumns--;

    CoTaskMemFree( pColumnInfo );
    CoTaskMemFree( pColumnNames );

    // Create an accessor, so data can be retrieved from the rowset.

    XInterface<IAccessor> xIAccessor;
    hr = xIRowset->QueryInterface( IID_IAccessor,
                                   xIAccessor.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Column iOrdinals are parallel with those passed to CiTextToFullTree,
    // so MapColumnIDs isn't necessary.  These binding values for dwPart,
    // dwMemOwner, and wType are the most optimal bindings for Indexing
    // Service.

    XPtr<DBBINDING> xBindings( (ULONG) cColumns );
    if ( xBindings.IsNull() )
        return E_OUTOFMEMORY;

    memset( xBindings.Get(), 0, sizeof DBBINDING * cColumns );

    for ( ULONG i = 0; i < cColumns; i++ )
    {
        xBindings[i].iOrdinal   = 1 + i; // 1-based column number
        xBindings[i].obValue    = i * sizeof( PROPVARIANT * ); // offset
        xBindings[i].dwPart     = DBPART_VALUE; // retrieve value, not status
        xBindings[i].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // provider owned
        xBindings[i].wType      = DBTYPE_VARIANT | DBTYPE_BYREF; // VARIANT *
    }

    HACCESSOR hAccessor;
    hr = xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA, // rowdata accessor
                                     cColumns,           // # of columns
                                     xBindings.Get(),    // columns
                                     0,                  // ignored
                                     &hAccessor,         // result
                                     0 );                // no status
    if ( FAILED( hr ) )
        return hr;

    DBORDINAL iPathColumn = ~0;

    if ( fSearchHit )
    {
        const DBID dbcolPath =  { PSGUID_STORAGE,
                                  DBKIND_GUID_PROPID,
                                  (LPWSTR) (ULONG_PTR) PID_STG_PATH };

        hr = xColumnsInfo->MapColumnIDs( 1,
                                         & dbcolPath,
                                         & iPathColumn );

        if ( FAILED( hr ) )
            return hr;

        // Change from 1-based to 0-based.

        iPathColumn--;
    }

    // Display the results of the query.

    XPtr<PROPVARIANT *> xData( (ULONG) cColumns );
    if ( xData.IsNull() )
        hr = E_OUTOFMEMORY;
    else
    {
        DBCOUNTITEM cRowsSoFar = 0;

        do
        {
            DBCOUNTITEM cRowsReturned = 0;
            const ULONG cRowsAtATime = 20;
            HROW aHRow[cRowsAtATime];
            HROW * pgrHRows = aHRow;
            hr = xIRowset->GetNextRows( 0,              // no chapter
                                        0,              // no rows to skip
                                        cRowsAtATime,   // # rows to get
                                        &cRowsReturned, // # rows returned
                                        &pgrHRows);     // resulting hrows
            if ( FAILED( hr ) )
                break;

            for ( DBCOUNTITEM iRow = 0; iRow < cRowsReturned; iRow++ )
            {
                HRESULT hr2 = xIRowset->GetData( aHRow[iRow],   // hrow being accessed
                                                 hAccessor,     // accessor to use
                                                 xData.Get() ); // resulting data
                if ( FAILED( hr2 ) )
                {
                    hr = hr2;
                    break;
                }

                if ( ( 1 != cColumns ) || !fSearchHit )
                {
                    for ( ULONG iCol = 0; iCol < cColumns; iCol++ )
                    {
                        if ( 0 != iCol )
                            wprintf( L"  " );
                        DisplayValue( xData[ iCol ] );
                    }

                    wprintf( L"\n" );
                }


                if ( fSearchHit )
                {
                    PROPVARIANT * pPropVar = xData[ (unsigned int)iPathColumn ];
                    if ( ( VT_LPWSTR == pPropVar->vt ) &&
                         ( 0 != pPropVar->pwszVal ) )
                    {
                        DoISearch( pwcQueryRestriction,
                                   pPropVar->pwszVal,
                                   ( 1 == cColumns ),
                                   fDefineCPP,
                                   lcid,
                                   ulDialect );
                    }
                }
            }

            // Release the HROWs retrived in GetNextRows

            if ( 0 != cRowsReturned )
            {
                cRowsSoFar += cRowsReturned;
                xIRowset->ReleaseRows( cRowsReturned, // # of rows to release
                                       aHRow,         // rows to release
                                       0,             // no options
                                       0,             // no refcounts
                                       0 );           // no status
            }

            // Check if all rows are now retrieved.

            if ( DB_S_ENDOFROWSET == hr || DB_S_ROWLIMITEXCEEDED == hr )
            {
                hr = S_OK; // succeeded, return S_OK from DoQuery
                break;
            }

            // Check if the query aborted because it was too costly.

            if ( DB_S_STOPLIMITREACHED == hr )
            {
                CResString str( IDS_QUERYTIMEDOUT );
                wprintf( L"%ws\n", str.Get() );
                hr = S_OK;
                break;
            }

            if ( FAILED( hr ) )
                break;
        } while ( TRUE );

        if ( !fQuiet )
        {
            CResString str( IDS_QUERYDONE );
            wprintf( str.Get(), cRowsSoFar, pwcQueryRestriction );
        }
    }

    xIAccessor->ReleaseAccessor( hAccessor, 0 );

    // Get query status information

    if ( SUCCEEDED( hr ) && !fQuiet )
        hr = DisplayRowsetStatus( xIRowset );

    return hr;
} //IssueQuery

//+-------------------------------------------------------------------------
//
//  Function:   DoQuery
//
//  Synopsis:   Issues a query and displays an error message on failure
//
//  Arguments:  [pwcQueryCatalog]       - Catalog name over which query is run
//              [pwcQueryMachine]       - Machine name on which query is run
//              [pwcQueryScope]         - Scope of the query
//              [dwScopeFlags]          - Scope flags
//              [pwcQueryRestrition]    - The actual query string
//              [pwcColumns]            - Output column names
//              [pwcSort]               - Sort order names, may be 0
//              [fDisplayTree]          - TRUE to display the command tree
//              [fQuiet]                - if TRUE, don't display hitcount
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//              [fNoQuery]              - if TRUE, just parse and display query
//              [fSearchHit]            - if TRUE invoke isrchdmp.exe
//              [ulDialect]             - Query dialect (1 or 2)
//              [cMaxHits]              - Maximum # of hits, or 0 for no limit
//              [fFirstHits]            - TRUE for first N or FALSE for best N
//              [lcid]                  - Locale for the query
//              [fDefineCPP]            - TRUE to define func and class props
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoQuery(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine,
    WCHAR const * pwcScope,
    DWORD         dwScopeFlags,
    WCHAR const * pwcRestriction,
    WCHAR const * pwcColumns,
    WCHAR const * pwcSort,
    BOOL          fDisplayTree,
    BOOL          fQuiet,
    BOOL          fForceUseContentIndex,
    BOOL          fNoQuery,
    BOOL          fSearchHit,
    ULONG         ulDialect,
    ULONG         cMaxHits,
    BOOL          fFirstHits,
    LCID          lcid,
    BOOL          fDefineCPP )
{
    HRESULT hr = IssueQuery( pwcCatalog,
                             pwcMachine,
                             pwcScope,
                             dwScopeFlags,
                             pwcRestriction,
                             pwcColumns,
                             pwcSort,
                             fDisplayTree,
                             fQuiet,
                             fForceUseContentIndex,
                             fNoQuery,
                             fSearchHit,
                             ulDialect,
                             cMaxHits,
                             fFirstHits,
                             lcid,
                             fDefineCPP );

    if ( FAILED( hr ) )
        DisplayError( IDS_QUERYFAILED, pwcRestriction, hr, lcid );

    return hr;
} //DoQuery

//+-------------------------------------------------------------------------
//
//  Function:   DoQueryFile
//
//  Synopsis:   Issues each query in the specified query file.  A query file
//              is just a text file where each line contains a query.
//
//  Arguments:  [pwcQueryCatalog]       - Catalog name over which query is run
//              [pwcQueryMachine]       - Machine name on which query is run
//              [pwcQueryScope]         - Scope of the query
//              [dwScopeFlags]          - Scope flags
//              [pwcColumns]            - Output column names
//              [pwcSort]               - Sort order names, may be 0
//              [fDisplayTree]          - TRUE to display the command tree
//              [fQuiet]                - if TRUE, don't display hitcount
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//              [fNoQuery]              - if TRUE, just parse and display query
//              [fSearchHit]            - if TRUE invoke isrchdmp.exe
//              [ulDialect]             - Query dialect (1 or 2)
//              [cMaxHits]              - Maximum # of hits, or 0 for no limit
//              [fFirstHits]            - TRUE for first N or FALSE for best N
//              [lcid]                  - Locale for the query
//              [pwcQueryFile]          - File containing queries, 1 per line
//              [fDefineCPP]            - TRUE to define func and class props
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoQueryFile(
    WCHAR const * pwcQueryCatalog,
    WCHAR const * pwcQueryMachine,
    WCHAR const * pwcQueryScope,
    DWORD         dwScopeFlags,
    WCHAR const * pwcColumns,
    WCHAR const * pwcSort,
    BOOL          fDisplayTree,
    BOOL          fQuiet,
    BOOL          fForceUseContentIndex,
    BOOL          fNoQuery,
    BOOL          fSearchHit,
    ULONG         ulDialect,
    ULONG         cMaxHits,
    BOOL          fFirstHits,
    LCID          lcid,
    WCHAR const * pwcQueryFile,
    BOOL          fDefineCPP )
{
    // Open and read the query file

    HANDLE hFile = CreateFile( pwcQueryFile,
                               FILE_GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_DELETE,
                               0,
                               OPEN_EXISTING,
                               0,
                               0 );

    if ( 0 == hFile || INVALID_HANDLE_VALUE == hFile )
        return DisplayWin32Error( IDS_CANTOPENFILE,
                                  pwcQueryFile,
                                  lcid );

    DWORD cbFile = GetFileSize( hFile, 0 );

    if ( 0xffffffff == cbFile )
    {
        CloseHandle( hFile );
        return DisplayWin32Error( IDS_CANTGETFILESIZE,
                                  pwcQueryFile,
                                  lcid );
    }

    // Allocate a buffer for the file

    XPtr<BYTE> xQueries( cbFile + sizeof WCHAR );
    if ( xQueries.IsNull() )
    {
        CloseHandle( hFile );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return DisplayWin32Error( IDS_CANTGETMEMORY,
                                  pwcQueryFile,
                                  lcid );
    }

    // Read the file into the buffer

    DWORD cbRead;
    BOOL fRead = ReadFile( hFile, xQueries.Get(), cbFile, &cbRead, 0 );

    CloseHandle( hFile );

    if ( ! fRead )
        return DisplayWin32Error( IDS_CANTREADFROMFILE,
                                  pwcQueryFile,
                                  lcid );

    if ( cbRead != cbFile )
    {
        SetLastError( ERROR_INVALID_DATA );
        return DisplayWin32Error( IDS_CANTREADFROMFILE,
                                  pwcQueryFile,
                                  lcid );
    }

    // Check if the file is Unicode already

    BOOL fUnicode = FALSE;

    if ( cbRead >= 2 )
        fUnicode = ( 0xfeff == ( * (WCHAR *) xQueries.Get() ) );

    WCHAR * pwcIn = 0;
    DWORD cwcIn = 0;

    if ( fUnicode )
    {
        pwcIn = (WCHAR *) xQueries.Get();

        // skip past the Unicode marker

        pwcIn++;
        cwcIn = ( cbFile / sizeof WCHAR ) - 1;
    }
    else
    {
        // Convert to Unicode.  Leave a little room for slack.

        DWORD cbTmp = cbFile * sizeof WCHAR + cbFile / 8;
        XPtr<BYTE> xTmp( cbTmp + sizeof WCHAR );
        if ( xTmp.IsNull() )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return DisplayWin32Error( IDS_CANTGETMEMORY,
                                      pwcQueryFile,
                                      lcid );
        }

        cwcIn = MultiByteToWideChar( LocaleToCodepage( lcid ),
                                     0,
                                     (const char *) xQueries.Get(),
                                     cbFile,
                                     (WCHAR *) xTmp.Get(),
                                     cbTmp );
        if ( 0 == cwcIn )
            return DisplayWin32Error( IDS_CANTCONVERTTOUNICODE,
                                      pwcQueryFile,
                                      lcid );

        pwcIn = (WCHAR *) xTmp.Get();
        xQueries.Free();
        xQueries.Set( xTmp.Acquire() );
    }

    // Read each line in the file and issue the query

    pwcIn[ cwcIn ] = 0;
    WCHAR * pwc = pwcIn;

    do
    {
        while ( 0     != *pwcIn &&
                L'\r' != *pwcIn &&
                L'\n' != *pwcIn )
            pwcIn++;

        BOOL fEOF = ( 0 == *pwcIn );

        *pwcIn = 0;

        if ( pwc != pwcIn )
        {
            DoQuery( pwcQueryCatalog,
                     pwcQueryMachine,
                     pwcQueryScope,
                     dwScopeFlags,
                     pwc,
                     pwcColumns,
                     pwcSort,
                     fDisplayTree,
                     fQuiet,
                     fForceUseContentIndex,
                     fNoQuery,
                     fSearchHit,
                     ulDialect,
                     cMaxHits,
                     fFirstHits,
                     lcid,
                     fDefineCPP );
            wprintf( L"\n\n" );
        }

        if ( fEOF )
            break;

        pwcIn++;
        while ( '\r' == *pwcIn || '\n' == *pwcIn )
            pwcIn++;
        pwc = pwcIn;
    } while ( TRUE );

    return S_OK;
} //DoQueryFile

//+-------------------------------------------------------------------------
//
//  Function:   LookupCatalog
//
//  Synopsis:   Looks for a catalog and machine matching the scope
//
//  Arguments:  [pwcScope]   - The scope used to find the catalog
//              [pwcMachine] - Returns the machine name
//              [cwcMachine] - In/Out: Count of characters in pwcMachine
//              [pwcCatalog] - Returns the catalog name
//              [cwcCatalog] - In/Out: Count of characters in pwcCatalog
//              [lcid]       - Locale to use for errors
//
//--------------------------------------------------------------------------

HRESULT LookupCatalog(
    WCHAR const * pwcScope,
    WCHAR *       pwcMachine,
    ULONG &       cwcMachine,
    WCHAR *       pwcCatalog,
    ULONG &       cwcCatalog,
    LCID          lcid )
{
    HRESULT hr = LocateCatalogs( pwcScope,       // scope to lookup
                                 0,              // go with the first match
                                 pwcMachine,     // returns the machine
                                 &cwcMachine,    // buffer size in/out
                                 pwcCatalog,     // returns the catalog
                                 &cwcCatalog );  // buffer size in/out

    if ( FAILED( hr ) || ( S_FALSE == hr ) )
    {
        DisplayError( IDS_CANTFINDCATALOG, pwcScope, hr, lcid );
        hr = E_FAIL;
    }

    return hr;
} //LookupCatalog

//+-------------------------------------------------------------------------
//
//  Function:   NormalizeScope
//
//  Synopsis:   Normalizes a scope and sets scope flags.
//
//  Arguments:  [pwcIn]        - The scope for the query
//              [pwcOut]       - Returns the scope for the query
//              [dwScopeFlags] - Returns the scope flags for the query
//
//--------------------------------------------------------------------------

HRESULT NormalizeScope(
    WCHAR const * pwcIn,
    WCHAR *       pwcOut,
    BOOL          fShallow,
    DWORD &       dwScopeFlags )
{
    if ( wcslen( pwcIn ) >= MAX_PATH )
        return E_INVALIDARG;

    if ( fShallow )
        dwScopeFlags = QUERY_SHALLOW;
    else
        dwScopeFlags = QUERY_DEEP;

    wcscpy( pwcOut, pwcIn );

    // Check if the scope is an IIS virtual scope.

    WCHAR wc = pwcIn[0];

    if ( L'/' == wc )
    {
        // Set the virtual scope flag and flip the slashes.

        dwScopeFlags |= QUERY_VIRTUAL_PATH;
        for ( WCHAR * pwc = pwcOut; *pwc; pwc++ )
            if ( '/' == *pwc )
                *pwc = '\\';
    }
    else if ( ( !( L'\\' == wc && L'\\' == pwcIn[1] ) ) &&
              ( !( L'\\' == wc && 0 == pwcIn[1] ) ) &&
              L':' != pwcIn[1] &&
              0 != wc )
    {
        // Turn the relative path into a full path based on the current dir.

        _wfullpath( pwcOut, pwcIn, MAX_PATH );
    }

    return S_OK;
} //NormalizeScope

//+-------------------------------------------------------------------------
//
//  Function:   DisplayStatus
//
//  Synopsis:   Displays status information about a catalog
//
//  Arguments:  [pwcCatalog] - Catalog name
//              [pwcMachine] - Machine on which catalog resides
//              [lcid]       - Locale to use
//
//--------------------------------------------------------------------------

HRESULT DisplayStatus(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine,
    LCID          lcid )
{
    CI_STATE state;
    state.cbStruct = sizeof state;

    DisplayStat( pwcMachine, IDS_STAT_MACHINE );
    DisplayStat( pwcCatalog, IDS_STAT_CATALOG );

    HRESULT hr = CIState( pwcCatalog, pwcMachine, &state );

    if ( SUCCEEDED( hr ) )
    {
        DisplayStat( state.cTotalDocuments, IDS_STAT_TOTALDOCUMENTS );
        DisplayStat( state.cFreshTest, IDS_STAT_FRESHTEST );
        DisplayStat( state.cFilteredDocuments, IDS_STAT_FILTEREDDOCUMENTS );
        DisplayStat( state.cDocuments, IDS_STAT_DOCUMENTS );
        DisplayStat( state.cSecQDocuments, IDS_STAT_SECQDOCUMENTS );
        DisplayStat( state.cUniqueKeys, IDS_STAT_UNIQUEKEYS );
        DisplayStat( state.cWordList, IDS_STAT_WORDLIST );
        DisplayStat( state.cPersistentIndex, IDS_STAT_PERSISTENTINDEX );
        DisplayStat( state.cQueries, IDS_STAT_QUERIES );
        DisplayStat( state.dwIndexSize, IDS_STAT_INDEXSIZE );
        DisplayStat( state.dwPropCacheSize / 1024, IDS_STAT_PROPCACHESIZE );

        DisplayStat( ( state.eState & CI_STATE_SCANNING ) ?
                     state.cPendingScans : 0,
                     IDS_STAT_SCANS );

        const DWORD ALL_CI_MERGE = ( CI_STATE_SHADOW_MERGE |
                                     CI_STATE_ANNEALING_MERGE |
                                     CI_STATE_INDEX_MIGRATION_MERGE |
                                     CI_STATE_MASTER_MERGE |
                                     CI_STATE_MASTER_MERGE_PAUSED );

        if ( 0 != ( ALL_CI_MERGE & state.eState ) )
        {
            UINT idStr;
            if ( state.eState & CI_STATE_SHADOW_MERGE )
                idStr = IDS_STAT_MERGE_SHADOW;
            else if ( state.eState & CI_STATE_ANNEALING_MERGE )
                idStr = IDS_STAT_MERGE_ANNEALING;
            else if ( state.eState & CI_STATE_INDEX_MIGRATION_MERGE )
                idStr = IDS_STAT_MERGE_INDEX_MIGRATION;
            else if ( state.eState & CI_STATE_MASTER_MERGE )
                idStr = IDS_STAT_MERGE_MASTER;
            else
                idStr = IDS_STAT_MERGE_MASTER_PAUSED;

            DisplayStat( state.dwMergeProgress, idStr );
        }

        if ( CI_STATE_READ_ONLY & state.eState )
            DisplayStat( IDS_STAT_READ_ONLY );
        if ( CI_STATE_RECOVERING & state.eState )
            DisplayStat( IDS_STAT_RECOVERING );
        if ( CI_STATE_LOW_MEMORY & state.eState )
            DisplayStat( IDS_STAT_LOW_MEMORY );
        if ( CI_STATE_HIGH_IO & state.eState )
            DisplayStat( IDS_STAT_HIGH_IO );
        if ( CI_STATE_BATTERY_POWER & state.eState )
            DisplayStat( IDS_STAT_BATTERY_POWER );
        if ( CI_STATE_USER_ACTIVE & state.eState )
            DisplayStat( IDS_STAT_USER_ACTIVE );
        if ( CI_STATE_STARTING & state.eState )
            DisplayStat( IDS_STAT_STARTING );
        if ( CI_STATE_READING_USNS & state.eState )
            DisplayStat( IDS_STAT_READING_USNS );
    }
    else
    {
        DisplayError( IDS_CANTDISPLAYSTATUS, pwcCatalog, hr, lcid );
    }

    return hr;
} //DisplayStatus

//+-------------------------------------------------------------------------
//
//  Function:   ForceMerge
//
//  Synopsis:   Forces a master merge on the catalog
//
//  Arguments:  [pwcCatalog] - Catalog name
//              [pwcMachine] - Machine on which catalog resides
//              [lcid]       - Locale to use
//
//--------------------------------------------------------------------------

HRESULT ForceMerge(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine,
    LCID          lcid )
{
    // Create the main Indexing Service administration object.

    CLSID clsid;
    HRESULT hr = CLSIDFromProgID( L"Microsoft.ISAdm", &clsid );
    if ( FAILED( hr ) )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             hr,
                             lcid );

    XInterface<IAdminIndexServer> xAdmin;
    hr = CoCreateInstance( clsid,
                           0,
                           CLSCTX_INPROC_SERVER,
                           __uuidof(IAdminIndexServer),
                           xAdmin.GetQIPointer() );
    if ( FAILED( hr ) )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             hr,
                             lcid );

    // Set the machine name.

    BSTR bstrMachine = SysAllocString( pwcMachine );
    if ( 0 == bstrMachine )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             E_OUTOFMEMORY,
                             lcid );

    XBStr xbstr( bstrMachine );
    hr = xAdmin->put_MachineName( bstrMachine );
    if ( FAILED( hr ) )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             hr,
                             lcid );

    // Get a catalog administration object.

    BSTR bstrCatalog = SysAllocString( pwcCatalog );
    if ( 0 == bstrCatalog )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             E_OUTOFMEMORY,
                             lcid );

    xbstr.Free();
    xbstr.Set( bstrCatalog );
    XInterface<ICatAdm> xCatAdmin;
    hr = xAdmin->GetCatalogByName( bstrCatalog,
                                   (IDispatch **) xCatAdmin.GetQIPointer() );
    if ( FAILED( hr ) )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             hr,
                             lcid );

    // Force the merge.

    hr = xCatAdmin->ForceMasterMerge();
    if ( FAILED( hr ) )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             hr,
                             lcid );

    return hr;
} //ForceMerge

//+-------------------------------------------------------------------------
//
//  Function:   DisplayUpToDate
//
//  Synopsis:   Checks if the index is up to date.
//
//  Arguments:  [pwcCatalog] - Catalog name
//              [pwcMachine] - Machine on which catalog resides
//              [lcid]       - Locale to use
//
//--------------------------------------------------------------------------

HRESULT DisplayUpToDate(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine,
    LCID          lcid )
{
    CI_STATE state;
    state.cbStruct = sizeof state;

    HRESULT hr = CIState( pwcCatalog, pwcMachine, &state );

    if ( SUCCEEDED( hr ) )
    {
        // It's up to date if there are no documents to filter, no scans or
        // usn activity, and the index isn't starting or recovering.

        BOOL fUpToDate = ( ( 0 == state.cDocuments ) &&
                           ( 0 == ( state.eState & CI_STATE_SCANNING ) ) &&
                           ( 0 == ( state.eState & CI_STATE_READING_USNS ) ) &&
                           ( 0 == ( state.eState & CI_STATE_STARTING ) ) &&
                           ( 0 == ( state.eState & CI_STATE_RECOVERING ) ) );

        DisplayStat( fUpToDate ? IDS_STAT_UP_TO_DATE :
                                 IDS_STAT_NOT_UP_TO_DATE );
    }
    else
    {
        DisplayError( IDS_CANTDISPLAYSTATUS, pwcCatalog, hr, lcid );
    }

    return hr;
} //DisplayUpToDate

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.  Parses command line arguments and
//              issues a query.
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const * pwcCatalog     = 0;        // default: lookup catalog
    WCHAR const * pwcMachine     = L".";     // default: local machine
    WCHAR const * pwcScope       = L"\\";    // default: entire catalog
    WCHAR const * pwcRestriction = 0;        // no default restriction
    WCHAR const * pwcColumns     = L"path";  // default output column(s)
    WCHAR const * pwcSort        = 0;        // no sort is the default
    WCHAR const * pwcQueryFile   = 0;        // no query file specified
    WCHAR const * pwcLocale      = 0;        // default: system locale
    BOOL fDisplayTree            = FALSE;    // don't display the tree
    BOOL fForceUseContentIndex   = TRUE;     // always use the index
    ULONG ulDialect              = 1;        // original query language dialect
    BOOL fQuiet                  = FALSE;    // show the hitcount
    ULONG cMaxHits               = 0;        // default: retrieve all hits
    BOOL fFirstHits              = FALSE;    // First vs Best N hits
    BOOL fDisplayStatus          = FALSE;    // default: don't show status
    BOOL fDisplayUpToDate        = FALSE;    // default: don't show up to date
    ULONG cRepetitions           = 1;        // # of times to repeat command
    BOOL fShallow                = FALSE;    // default: all subdirectories
    BOOL fNoQuery                = FALSE;    // default: execute query
    BOOL fSearchHit              = FALSE;    // default: don't isrchdmp.exe
    BOOL fDefineCPP              = FALSE;    // default: don't define props
    BOOL fForceMerge             = FALSE;    // default: don't force a MM
    BOOL fSmart                  = FALSE;    // default: use all the options provided

    // Parse command line parameters

    for ( int i = 1; i < argc; i++ )
    {
        if ( L'-' == argv[i][0] || L'/' == argv[i][0] )
        {
            WCHAR wc = (WCHAR) toupper( (char) argv[i][1] );

            if ( ':' != argv[i][2] &&
                 'D' != wc &&
                 'G' != wc &&
                 'H' != wc &&
                 'J' != wc &&
                 'N' != wc &&
                 'Q' != wc &&
                 'U' != wc &&
                 'S' != wc &&
                 'T' != wc &&
                 'Z' != wc )
                Usage();

            if ( 'C' == wc )
            {
                pwcCatalog = argv[i] + 3;

                if ( wcslen( pwcCatalog ) >= MAX_PATH )
                    Usage();
            }
            else if ( 'M' == wc )
            {
                pwcMachine = argv[i] + 3;

                if ( wcslen( pwcMachine ) >= MAX_PATH )
                    Usage();
            }
            else if ( 'P' == wc )
                pwcScope = argv[i] + 3;
            else if ( 'O' == wc )
                pwcColumns = argv[i] + 3;
            else if ( 'S' == wc )
            {
                if ( _wcsicmp (argv[i]+1, L"smart") == 0 )
                {
                    fSmart = TRUE;
                }
                else
                {
                    if (argv[i][2] != L':')
                        Usage();
                    pwcSort = argv[i] + 3;
                }
            }
            else if ( 'X' == wc )
                cMaxHits = _wtoi( argv[i] + 3 );
            else if ( 'Y' == wc )
            {
                cMaxHits = _wtoi( argv[i] + 3 );
                fFirstHits = TRUE;
            }
            else if ( 'I' == wc )
            {
                if ( 0 != pwcRestriction )
                    Usage();
                pwcQueryFile = argv[i] + 3;
            }
            else if ( 'R' == wc)
            {
                // get the next arg as a number
                cRepetitions = _wtol(argv[i]+3);
            }
            else if ( 'D' == wc )
                fDisplayTree = TRUE;
            else if ( 'G' == wc )
                fForceMerge = TRUE;
            else if ( 'H' == wc )
                fSearchHit = TRUE;
            else if ( 'J' == wc )
                fShallow = TRUE;
            else if ( 'N' == wc )
                fNoQuery = TRUE;
            else if ( 'Q' == wc )
                fQuiet = TRUE;
            else if ( 'T' == wc )
                fDisplayStatus = TRUE;
            else if ( 'U' == wc )
                fDisplayUpToDate = TRUE;
            else if ( 'E' == wc )
                pwcLocale = argv[i] + 3;
            else if ( 'L' == wc )
            {
                if ( '1' == argv[i][3] )
                    ulDialect = 1;
                else if ( '2' == argv[i][3] )
                    ulDialect = 2;
                else if ( '3' == argv[i][3] )
                    ulDialect = 3;
                else
                    Usage();
            }
            else if ( 'F' == wc )
            {
                if ( '+' == argv[i][3] )
                    fForceUseContentIndex = TRUE;
                else if ( '-' == argv[i][3] )
                    fForceUseContentIndex = FALSE;
                else
                    Usage();
            }
            else if ( 'Z' == wc )
                fDefineCPP = TRUE;
            else
                Usage();
        }
        else if ( 0 != pwcRestriction || 0 != pwcQueryFile )
            Usage();
        else
            pwcRestriction = argv[i];
    }

    // A query restriction, query file, or status request is necessary.

    if ( 0 == pwcRestriction && 0 == pwcQueryFile &&
         !fDisplayStatus && !fDisplayUpToDate && !fForceMerge )
        Usage();

    if ( fSmart )
    {
        // If we're in smart mode, don't let people specify machine, path, or catalog

        if ( ( pwcCatalog != 0 ) ||
             ( _wcsicmp( pwcMachine, L"." ) != 0 ) ||
             ( _wcsicmp( pwcScope, L"\\" ) != 0 ) )
        {
            Usage();
        }

        // Fix the scope, to figure out the catalog, but we'll reset it later.
        // We set it to the current directory now, which will be expanded to the
        // full path we're sitting in, so that we'll find the right catalog.

        pwcScope = L".";
    }

    // Normalize relative and virtual scopes

    WCHAR awcScope[ MAX_PATH ];
    DWORD dwScopeFlags;
    HRESULT hr = NormalizeScope( pwcScope, awcScope, fShallow, dwScopeFlags );

    // Initialize OLE

    BOOL fCoInit = FALSE;

    if ( SUCCEEDED( hr ) )
    {
        hr = CoInitialize( 0 );
        if ( SUCCEEDED( hr ) )
            fCoInit = TRUE;
    }

    if ( FAILED( hr ) )
        return -1;

    // Get the locale identifier to use for the query

    LCID lcid = LcidFromHttpAcceptLanguage( pwcLocale );

    HINSTANCE hISearch = 0;

    if ( fSearchHit )
    {
        hISearch = PrepareForISearch();

        if ( 0 == hISearch )
            Usage();
    }

    // If no catalog was specified, infer one based on the scope

    WCHAR awcMachine[ MAX_PATH ], awcCatalog[ MAX_PATH ];

    if ( SUCCEEDED( hr ) && ( 0 == pwcCatalog ) && !fNoQuery )
    {
        ULONG cwcMachine = sizeof awcMachine / sizeof WCHAR;
        ULONG cwcCatalog = sizeof awcCatalog / sizeof WCHAR;
        hr = LookupCatalog( awcScope,
                            awcMachine,
                            cwcMachine,
                            awcCatalog,
                            cwcCatalog,
                            lcid );
        pwcMachine = awcMachine;
        pwcCatalog = awcCatalog;

        // Turn scopes like \\machine into \ now that the lookup is done
        // and we've found a catalog and machine name.

        if ( SUCCEEDED( hr ) &&
             L'\\' == awcScope[0] && L'\\' == awcScope[1] &&
             0 == wcschr( awcScope + 2, L'\\' ) )
            awcScope[1] = 0;
    }

    if ( fSmart )
    {
        // Now that we've got the catalog, if we're in smart mode, put
        // the scope back to what it was.

        awcScope[0] = L'\\';
        awcScope[1] = L'\0';
    }

    if ( SUCCEEDED( hr ) )
    {
        for (ULONG j = 0; j < cRepetitions; j++)
        {
            if ( 0 != pwcQueryFile )
                hr = DoQueryFile( fNoQuery ? L"::_noquery" : pwcCatalog,
                                  pwcMachine,
                                  awcScope,
                                  dwScopeFlags,
                                  pwcColumns,
                                  pwcSort,
                                  fDisplayTree,
                                  fQuiet,
                                  fForceUseContentIndex,
                                  fNoQuery,
                                  fSearchHit,
                                  ulDialect,
                                  cMaxHits,
                                  fFirstHits,
                                  lcid,
                                  pwcQueryFile,
                                  fDefineCPP );
            else if ( 0 != pwcRestriction )
                hr = DoQuery( fNoQuery ? L"::_noquery" : pwcCatalog,
                              pwcMachine,
                              awcScope,
                              dwScopeFlags,
                              pwcRestriction,
                              pwcColumns,
                              pwcSort,
                              fDisplayTree,
                              fQuiet,
                              fForceUseContentIndex,
                              fNoQuery,
                              fSearchHit,
                              ulDialect,
                              cMaxHits,
                              fFirstHits,
                              lcid,
                              fDefineCPP );

            if ( SUCCEEDED( hr ) && fForceMerge )
                hr = ForceMerge( pwcCatalog, pwcMachine, lcid );

            if ( SUCCEEDED( hr ) && fDisplayStatus )
                hr = DisplayStatus( pwcCatalog, pwcMachine, lcid );

            if ( SUCCEEDED( hr ) && fDisplayUpToDate )
                hr = DisplayUpToDate( pwcCatalog, pwcMachine, lcid );
        }
    }

    if ( fCoInit )
        CoUninitialize();

    if ( 0 != hISearch )
        DoneWithISearch( hISearch );

    if ( FAILED( hr ) )
        return -1;

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\scope.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       Catalog.cxx
//
//  Contents:   Used to manage catalog(s) state
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <catalog.hxx>
#include <catadmin.hxx>

extern "C"
{
    #include <lmcons.h>
}
#include <cisecret.hxx>

//
// Global data
//

SScopeColumn coldefScope[] = { { CScope::GetPath,       MSG_COL_ROOT },
                               { CScope::GetAlias,      MSG_COL_ALIAS },
                               { CScope::GetInclude,    MSG_COL_EXCLUDE }
                             };

BOOL CScope::_fFirstTime = TRUE;

CScope::CScope( CCatalog & cat,
                WCHAR const * pwcsPath,
                WCHAR const * pwcsAlias,
                BOOL fExclude,
                BOOL fVirtual,
                BOOL fShadowAlias )
        : _pwcsPath( 0 ),
          _pwcsAlias( 0 ),
          _fExclude( fExclude ),
          _fVirtual( fVirtual ),
          _fShadowAlias( fShadowAlias ),
          _fZombie( FALSE ),
          _cat( cat )
{
    TRY
    {
        Set( pwcsPath, _pwcsPath );
        Set( pwcsAlias, _pwcsAlias );
    }
    CATCH( CException, e )
    {
        delete [] _pwcsPath;
        delete [] _pwcsAlias;

        RETHROW();
    }
    END_CATCH
}

CScope::~CScope()
{
    delete [] _pwcsPath;
    delete [] _pwcsAlias;
}

void CScope::Modify(WCHAR const * pwcsPath,
                    WCHAR const * pwcsAlias,
                    BOOL fExclude)
{
    Win4Assert( !IsZombie() );

    Reset( pwcsPath, _pwcsPath );
    Reset( pwcsAlias, _pwcsAlias );

    _fExclude = fExclude;
}

void CScope::InitHeader( CListViewHeader & Header )
{
    //
    // Initialize header
    //

    for ( unsigned i = 0; i < sizeof(coldefScope)/sizeof(coldefScope[0]); i++ )
    {
        if ( _fFirstTime )
            coldefScope[i].srTitle.Init( ghInstance );

        Header.Add( i, STRINGRESOURCE(coldefScope[i].srTitle), LVCFMT_LEFT, MMCLV_AUTO );
    }

    _fFirstTime = FALSE;
}

void CScope::Set( WCHAR const * pwcsSrc, WCHAR * & pwcsDst )
{
    if ( 0 == pwcsSrc )
    {
        pwcsDst = new WCHAR[1];
        RtlCopyMemory( pwcsDst, L"", sizeof(WCHAR) );
    }
    else
    {
        unsigned cc = wcslen( pwcsSrc ) + 1;

        pwcsDst = new WCHAR [cc];

        RtlCopyMemory( pwcsDst, pwcsSrc, cc * sizeof(WCHAR) );
    }
}

void CScope::Reset( WCHAR const * pwcsSrc, WCHAR * & pwcsDst )
{
    delete pwcsDst;

    Set(pwcsSrc, pwcsDst);
}

void CScope::Rescan( BOOL fFull )
{
    _cat.RescanScope( _pwcsPath, fFull );
}

// The username and password are not stored locally. They will
// be retrieved on demand from the catadmin object.

SCODE CScope::GetUsername(WCHAR *pwszLogon)
{
    SCODE sc = S_OK;

    TRY
    {
        //
        // First, remove from CI.
        //

        CMachineAdmin MachineAdmin( _cat.GetMachine() );
        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _cat.GetCat(TRUE) ) );

        XPtr<CScopeAdmin> xScopeAdmin( xCatalogAdmin->QueryScopeAdmin(_pwcsPath) );

        if ( !xScopeAdmin.IsNull() )
            wcscpy(pwszLogon, xScopeAdmin->GetLogon());
    }
    CATCH (CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

SCODE CScope::GetPassword(WCHAR *pwszPassword)
{
    WCHAR szLogon[UNLEN + 1];
    szLogon[0] = 0;
    GetUsername(szLogon);
    *pwszPassword = 0;
    BOOL fOK = TRUE;
    
    // don't attempt to get pwd of a NULL logon name!
    if (0 != szLogon[0])
        CiGetPassword(_cat.GetCat(TRUE), szLogon, pwszPassword);

    return fOK ? S_OK:S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\register.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1996 - 2000.
//
// File:        Register.cxx
//
// Contents:    Self-registration for CI MMC control.
//
// Functions:   DllRegisterServer, DllUnregisterServer
//
// History:     21-Nov-96       KyleP       Created
//                                          and CQueryBase to CQueryExecute
//              7/1/98          mohamedn    comp. mgmt extension
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <classid.hxx>
#include <isreg.hxx>

#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
#include <ciares.h>
#endif


//
// global functions
//
HRESULT BasicComRegistration(void);
HRESULT RegisterSnapinAsStandAloneAndExtension(void);

HRESULT RegisterSnapin(const GUID  * pSnapinCLSID,
                       const GUID  * pStaticNodeGUID,
                       const GUID  * pAboutGUID,
                       WCHAR const * pwszNameString,
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
                       WCHAR const * pwszNameStringIndirect,
#endif
                       WCHAR const * pwszVersion,
                       WCHAR const * pwszProvider,
                       _NODE_TYPE_INFO_ENTRY * pNodeTypeInfoEntryArray);

HRESULT RegisterNodeType(const GUID* pGuid, WCHAR const * pwszNodeDescription);

HRESULT RegisterNodeExtension(const GUID  * pNodeGuid,
                              WCHAR const * pwszExtensionType,
                              const GUID  * pExtensionSnapinCLSID,
                              WCHAR const * pwszDescription,
                              BOOL          bDynamic);

HRESULT RegisterServerApplicationExtension( const GUID  * pExtensionSnapinCLSID,
                                            WCHAR const * pwszDescription );

//
// registry constant
//
const WCHAR g_wszNODE_TYPES_KEY[] = L"Software\\Microsoft\\MMC\\NodeTypes";
const WCHAR g_wszSNAPINS_KEY[] = L"Software\\Microsoft\\MMC\\SnapIns";
const WCHAR g_wszNodeType[] = L"NodeType";
const WCHAR g_wszNameString[] = L"NameString";
const WCHAR g_wszStandaloneSnap[] = L"Standalone";
const WCHAR g_wszExtensionSnap[] = L"Extension";
const WCHAR g_wszNodeTypes[] = L"NodeTypes";
const WCHAR g_wszExtensions[] = L"Extensions";
const WCHAR g_wszDynamicExtensions[] = L"Dynamic Extensions";
const WCHAR g_wszVersion[] = L"Version";
const WCHAR g_wszProvider[] = L"Provider";
const WCHAR g_wszAbout[] = L"About";

const WCHAR g_wszISDescription[] = L"Indexing Service Snapin";
const WCHAR g_wszISVersion[] = L"1.0";

#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
const WCHAR g_wszNameStringIndirect[] = L"NameStringIndirect";
#endif

//
// Dynamic extension specific reg values
//
const WCHAR CONTROL_KEY[] = L"System\\CurrentControlSet\\Control\\";
const WCHAR g_wszServerApplications[] = L"Server Applications";

//
// Registry constants
//

WCHAR const wszSnapinPath[]  = L"Software\\Microsoft\\MMC\\SnapIns\\";
WCHAR const wszClsidPath[]   = L"CLSID";

WCHAR const * aClassKeyValue[] = { wszCISnapin,       0, L"Indexing Service Snapin",
                                   L"InprocServer32", 0, L"CIAdmin.dll",
                                   0, L"ThreadingModel", L"Both" };
//
// NodeType registration info
//
static _NODE_TYPE_INFO_ENTRY _NodeTypeInfoEntryArray[] =
{
    { &guidCIRootNode, wszCIRootNode, L"Indexing Service Root Subtree" },
    { NULL, NULL }
};

//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Self-registration
//
//  History:    22-Nov-96   KyleP       Created
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Self-registration
//
//  History:    22-Nov-96   KyleP       Created
//              7/1/98      mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

const HKEY HKeyInvalid = 0;

STDAPI DllRegisterServer()
{

    HRESULT hr = 0;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        hr = BasicComRegistration();

        if ( SUCCEEDED(hr) )
        {
            hr = RegisterSnapinAsStandAloneAndExtension();
        }
    }
    CATCH( CException, e )
    {
        hr = e.GetErrorCode();

        ciaDebugOut(( DEB_ERROR, "Exception 0x%x caught in DllRegisterServer\n", hr ));
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   BasicComRegistration
//
//  Synopsis:   Self-registration
//
//  History:    22-Nov-96   KyleP       Created
//              7/1/98      mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

HRESULT BasicComRegistration()
{
    //
    // Create key in snapin section
    //

    WCHAR wcTemp[MAX_PATH+1];
    wcscpy( wcTemp, wszSnapinPath );
    wcscat( wcTemp, wszCISnapin );

    long sc;
    HKEY hKey = HKeyInvalid;
    //
    // Then create class entry
    //

    wcscpy( wcTemp, wszClsidPath );

    for ( unsigned i = 0; i < sizeof(aClassKeyValue)/sizeof(aClassKeyValue[0]); i += 3 )
    {
        // Append only if keyname is non-null
        if ( 0 != aClassKeyValue[i] )
        {
            wcscat( wcTemp, L"\\" );
            wcscat( wcTemp, aClassKeyValue[i] );
        }

        DWORD  dwDisposition;

        sc = RegCreateKeyEx( HKEY_CLASSES_ROOT,    // Root
                             wcTemp,               // Sub key
                             0,                    // Reserved
                             0,                    // Class
                             0,                    // Flags
                             KEY_ALL_ACCESS,       // Access
                             0,                    // Security
                             &hKey,                // Handle
                             &dwDisposition );     // Disposition

        if ( ERROR_SUCCESS != sc )
        {
            sc = HRESULT_FROM_WIN32( sc );
            break;
        }

        sc = RegSetValueEx( hKey,                      // Key
                            aClassKeyValue[i+1],       // Name
                            0,                         // Reserved
                            REG_SZ,                    // Type
                            (BYTE *)aClassKeyValue[i+2], // Value
                            (1 + wcslen(aClassKeyValue[i+2])) *
                                sizeof(WCHAR) );       // Size

        if ( ERROR_SUCCESS != sc )
        {
            sc = HRESULT_FROM_WIN32( sc );
            break;
        }

        if ( HKeyInvalid != hKey )
        {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
        }
    }

    if ( HKeyInvalid != hKey )
        RegCloseKey( hKey );

    return sc;

}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterSnapinAsStandAloneAndExtension
//
//  Synopsis:   StandAlone & extension registration
//
//  History:    7/1/98      mohamedn   created
//
//----------------------------------------------------------------------------

HRESULT RegisterSnapinAsStandAloneAndExtension()
{
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
    WCHAR wszNameStringIndirect[MAX_PATH];
    WCHAR wszModule[MAX_PATH];
    if ( 0 != ::GetModuleFileName( ghInstance, wszModule, MAX_PATH) )
        wsprintf ( wszNameStringIndirect, L"@%s,-%d", wszModule, MSG_SNAPIN_NAME_STRING_INDIRECT );
    else
        wszNameStringIndirect[0] = L'\0';
#endif
  
    HRESULT hr = 0;
    
    // register the standalone ISSnapin into the console snapin list
    // ISnapinAbout is implemented by the same object implementing the snapin
    hr = RegisterSnapin( &guidCISnapin,
                         &guidCIRootNode,
                         &guidCISnapin,
                         STRINGRESOURCE( srIndexServerCmpManage ),
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
                         wszNameStringIndirect,
#endif
                         g_wszISVersion,
                         STRINGRESOURCE( srProviderName ),
                         _NodeTypeInfoEntryArray );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // register node types.
    //
    for ( _NODE_TYPE_INFO_ENTRY* pCurrEntry = _NodeTypeInfoEntryArray;
          pCurrEntry->_pNodeGUID != NULL; pCurrEntry++ )
    {
        hr = RegisterNodeType( pCurrEntry->_pNodeGUID, pCurrEntry->_pwszNodeDescription );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // register IS snapin as a namespace extension for the server apps node.
    //
    hr = RegisterNodeExtension( &CLSID_NodeTypeServerApps,
                                L"NameSpace",
                                &guidCISnapin,
                                g_wszISDescription,
                                TRUE /* dynamic */ );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // regiser under the server apps & services, we're installed on this machine.
    //
    hr = RegisterServerApplicationExtension( &guidCISnapin, STRINGRESOURCE( srIndexServerCmpManage ) );

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterSnapin
//
//  Synopsis:   snapin registration
//
//  History:    7/1/98  mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

HRESULT RegisterSnapin( GUID const * pSnapinCLSID,
                        GUID const * pStaticNodeGUID,
                        GUID const * pAboutGUID,
                        WCHAR const * pwszNameString,
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
                        WCHAR const * pwszNameStringIndirect,
#endif
                        WCHAR const * pwszVersion,
                        WCHAR const * pwszProvider,
                        _NODE_TYPE_INFO_ENTRY * pNodeTypeInfoEntryArray )
{

    WCHAR wszSnapinClassID[128], wszStaticNodeGUID[128];

    ::StringFromGUID2(*pSnapinCLSID, wszSnapinClassID, 128);
    ::StringFromGUID2(*pStaticNodeGUID, wszStaticNodeGUID, 128);
    ::StringFromGUID2(*pAboutGUID, wszSnapinClassID, 128);

    {
        CWin32RegAccess     reg( HKEY_LOCAL_MACHINE, g_wszSNAPINS_KEY );
        BOOL                fExists;

        if ( !reg.Ok() || !reg.CreateKey( wszSnapinClassID, fExists ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    {
        if ( wcslen(g_wszSNAPINS_KEY) + wcslen(wszSnapinClassID) + 2 > MAX_PATH )
        {
            return E_FAIL;  // insufficient buffer size
        }

        unsigned cc = wcslen(g_wszSNAPINS_KEY) + 2 /* L"\\" */ + wcslen(wszSnapinClassID) + 1;

        XGrowable<WCHAR> xwszSnapinClassIDKey(cc);

        wcscpy( xwszSnapinClassIDKey.Get(), g_wszSNAPINS_KEY );
        wcscat( xwszSnapinClassIDKey.Get(), L"\\" );
        wcscat( xwszSnapinClassIDKey.Get(), wszSnapinClassID );

        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, xwszSnapinClassIDKey.Get() );

        if ( !reg.Ok() )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }

        if ( !reg.Set( g_wszNameString, pwszNameString ) ||
             !reg.Set( g_wszAbout, wszCISnapin ) ||   // ISnapinAbout is implemented by the main dll
             !reg.Set( g_wszNodeType, wszStaticNodeGUID ) ||
             !reg.Set( g_wszProvider, pwszProvider ) ||
             !reg.Set( g_wszVersion, pwszVersion ) ) 
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
            || !reg.Set( g_wszNameStringIndirect, pwszNameStringIndirect ) )
#endif
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }

        //
        // create keys for both standalone and extension
        //

        BOOL fExists;

        if ( !reg.CreateKey( g_wszExtensionSnap, fExists ) ||
             !reg.CreateKey( g_wszStandaloneSnap, fExists ) ||
             !reg.CreateKey( g_wszNodeTypes, fExists ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    {
        unsigned cc = wcslen(g_wszSNAPINS_KEY) + 2 + wcslen(wszSnapinClassID) + 2 + wcslen(g_wszNodeTypes) + 1;

        XGrowable<WCHAR>   xwszSnapinNodeTypeKey(cc);

        wcscpy( xwszSnapinNodeTypeKey.Get(), g_wszSNAPINS_KEY );
        wcscat( xwszSnapinNodeTypeKey.Get(), L"\\" );
        wcscat( xwszSnapinNodeTypeKey.Get(), wszSnapinClassID );
        wcscat( xwszSnapinNodeTypeKey.Get(), L"\\" );
        wcscat( xwszSnapinNodeTypeKey.Get(), g_wszNodeTypes );

        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, xwszSnapinNodeTypeKey.Get() );

        if ( !reg.Ok() )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }

        for ( _NODE_TYPE_INFO_ENTRY * pCurrEntry = pNodeTypeInfoEntryArray;
                                      pCurrEntry->_pNodeGUID != NULL;
                                      pCurrEntry++ )
        {
            BOOL fExists;

            if ( !reg.CreateKey( pCurrEntry->_pwszNodeGUID, fExists ) )
            {
                return HRESULT_FROM_WIN32( reg.GetLastError() );
            }
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterNodeType
//
//  Synopsis:   NodeType registration
//
//  History:    7/1/98  mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

HRESULT RegisterNodeType( GUID const * pGuid, WCHAR const * pwszNodeDescription )
{
    BOOL    fExists;
    WCHAR   wszNodeGUID[128];

    ::StringFromGUID2( *pGuid, wszNodeGUID, 128 );

    {
        CWin32RegAccess reg ( HKEY_LOCAL_MACHINE, g_wszNODE_TYPES_KEY );

        if ( !reg.Ok() || !reg.CreateKey(wszNodeGUID, fExists) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    unsigned cc = wcslen(g_wszNODE_TYPES_KEY) + 2 + wcslen(wszNodeGUID) + 1;

    XGrowable<WCHAR>   xwszThisNodeType(cc);

    wcscpy( xwszThisNodeType.Get(), g_wszNODE_TYPES_KEY );
    wcscat( xwszThisNodeType.Get(), L"\\" );
    wcscat( xwszThisNodeType.Get(), wszNodeGUID );

    CWin32RegAccess reg ( HKEY_LOCAL_MACHINE, xwszThisNodeType.Get() );

    if ( !reg.Ok() || !reg.Set( NULL, pwszNodeDescription ) )
    {
        return HRESULT_FROM_WIN32( reg.GetLastError() );
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegisterNodeExtension
//
//  Synopsis:   NodeExtension registration
//
//  History:    7/1/98  mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

HRESULT RegisterNodeExtension( GUID const *  pNodeGuid,
                               WCHAR const * pwszExtensionType,
                               GUID const *  pExtensionSnapinCLSID,
                               WCHAR const * pwszDescription,
                               BOOL          fDynamic )
{
    BOOL  fExists;
    WCHAR wszNodeGUID[128], wszExtensionCLSID[128];

    ::StringFromGUID2(*pNodeGuid, wszNodeGUID, 128 );
    ::StringFromGUID2(*pExtensionSnapinCLSID, wszExtensionCLSID, 128);

    CWin32RegAccess     srvAppsNode( HKEY_LOCAL_MACHINE, g_wszNODE_TYPES_KEY );

    if ( !srvAppsNode.Ok() || !srvAppsNode.CreateKey( wszNodeGUID, fExists ) )
    {
        return HRESULT_FROM_WIN32( srvAppsNode.GetLastError() );
    }

    unsigned cc1 = wcslen( g_wszNODE_TYPES_KEY ) + 2 + wcslen( wszNodeGUID ) + 1;

    XGrowable<WCHAR>  xwszThisNodeType(cc1);

    wcscpy( xwszThisNodeType.Get(), g_wszNODE_TYPES_KEY );
    wcscat( xwszThisNodeType.Get(), L"\\" );
    wcscat( xwszThisNodeType.Get(), wszNodeGUID );

    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, xwszThisNodeType.Get() );

    if ( !reg.Ok() )
    {
        return HRESULT_FROM_WIN32( reg.GetLastError() );
    }

    if ( !reg.CreateKey( g_wszExtensions, fExists ) )
    {
        return HRESULT_FROM_WIN32( reg.GetLastError() );
    }

    unsigned cc2 = wcslen( xwszThisNodeType.Get() ) + 2 + wcslen( g_wszExtensions ) + 1;

    XGrowable<WCHAR> xwszExtensionPath(cc2);

    wcscpy( xwszExtensionPath.Get(), xwszThisNodeType.Get() );
    wcscat( xwszExtensionPath.Get(), L"\\" );
    wcscat( xwszExtensionPath.Get(), g_wszExtensions );

    //
    // create the extension key if it doesn't exist
    //
    {
        CWin32RegAccess regExtensions( HKEY_LOCAL_MACHINE, xwszExtensionPath.Get() );

        if ( !regExtensions.CreateKey( pwszExtensionType, fExists ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    //
    // add our snapin clsid to the extension key
    //
    {
        cc2 += 2 + wcslen( pwszExtensionType );

        xwszExtensionPath.SetSize(cc2);

        wcscat ( xwszExtensionPath.Get(), L"\\" );
        wcscat ( xwszExtensionPath.Get(), pwszExtensionType );

        CWin32RegAccess regExt( HKEY_LOCAL_MACHINE, xwszExtensionPath.Get() );

        if ( !reg.Ok() || !regExt.Set( wszExtensionCLSID, pwszDescription ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    //
    // add our snapin clsid to the dynamic extension key.
    //
    if ( fDynamic )
    {
        //
        // create the Dynamic Extensions key if it doesn't exist.
        //
        if ( !reg.CreateKey( g_wszDynamicExtensions, fExists ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }

        //
        // Add our snapin clsid to the dynamic key
        //

        unsigned cc = wcslen( xwszThisNodeType.Get() ) + 2 + wcslen(g_wszDynamicExtensions);

        XGrowable<WCHAR> xwszDynamicPath(cc);

        wcscpy( xwszDynamicPath.Get(), xwszThisNodeType.Get() );
        wcscat( xwszDynamicPath.Get(), L"\\" );
        wcscat( xwszDynamicPath.Get(), g_wszDynamicExtensions );

        CWin32RegAccess regDynamicExtensions(HKEY_LOCAL_MACHINE, xwszDynamicPath.Get() );

        if ( !regDynamicExtensions.Ok() ||
             !regDynamicExtensions.Set( wszExtensionCLSID, pwszDescription ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterServerApplicationExtension
//
//  Synopsis:   server application registration
//
//  History:    7/1/98  mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

HRESULT RegisterServerApplicationExtension( const GUID  * pExtensionSnapinCLSID,
                                            WCHAR const * pwszDescription )
{
    WCHAR wszExtensionGUID[128];

    ::StringFromGUID2( *pExtensionSnapinCLSID, wszExtensionGUID, 128 );

    //
    // create Server Applications key if it doesn't exist.
    //
    {
        BOOL            fExists;
        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, CONTROL_KEY );

        if ( !reg.Ok() || !reg.CreateKey( g_wszServerApplications, fExists ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    unsigned cc = wcslen(CONTROL_KEY) + 2 + wcslen(g_wszServerApplications) + 1;

    XGrowable<WCHAR>  xwszServerApplicationsPath(cc);

    wcscpy( xwszServerApplicationsPath.Get(), CONTROL_KEY );
    wcscat( xwszServerApplicationsPath.Get(), g_wszServerApplications );

    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, xwszServerApplicationsPath.Get() );

    if ( !reg.Ok() || !reg.Set( wszExtensionGUID, pwszDescription ) )
    {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\chgstate\chgstate.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:  ChgState.cxx
//
// PURPOSE:  To change the state of a catalog (on local machine) 
//
// PLATFORM: Windows NT
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.  
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>

#include <ntquery.h>

//+-------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays information about how to use the app and exits
//
//--------------------------------------------------------------------------

void Usage()
{
    printf( "Usage: ChgState /a:<RO|RW|Stop|GetState> /c:<Catalog Name>\n" ); 
    printf( "    /m:<Machine Name>\n\n" );
    printf( "    ChgState            Change the state of a catalog\n" );
    printf( "    /a:<Action>         the action to be taken, default is RO\n" );
    printf( "    The three actions are states RO (ReadOnly), RW (Read\\Write)\n" );
    printf( "    and Stop (Stopped)\n" );
    printf( "    You can also specify GetState to check the state of a catalog\n" ); 
    printf( "    /c:<Catalog Name>   name of the catalog, default is SYSTEM\n" );
    printf( "    /m:<Machine Name>   name of the machine, default is local machine\n" );
    exit( -1 );
} //Usage

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const * pwcsCatalog     = L"system"; // default: system
    WCHAR const * pwcsMachine     = L".";      // default: local machine
    WCHAR const * pwcsAction      = L"RO";     // default: ReadOnly
    DWORD dwNewState              = CICAT_READONLY;
    DWORD dwOldState;

    SCODE sc = S_OK;

    // Parse the command for arguments
    if ( argc > 1 )
    {
        for ( int i = 1; i < argc; i++ )
        {
            if ( L'/' == argv[i][0] )
            {
                WCHAR wc = (WCHAR) toupper( argv[i][1] );

                if ( ':' != argv[i][2] )
                    Usage();

                if ( 'A' == wc )  
                    pwcsAction = argv[i] + 3;
                else if ( 'C' == wc )
                    pwcsCatalog = argv[i] + 3;
                else if ( 'M' == wc )
                    pwcsMachine = argv[i] + 3;
                else
                    Usage();
            }
            else 
                Usage();
        }
    }
    else
    {
        Usage();
    }

    if ( !wcscmp( pwcsAction, L"RO" ) )          // ReadOnly
        dwNewState = CICAT_READONLY;
    else if ( !wcscmp( pwcsAction, L"RW" ) )     // ReadWrite
        dwNewState = CICAT_WRITABLE;   
    else if ( !wcscmp( pwcsAction, L"Stop" ) )   // Stop
        dwNewState = CICAT_STOPPED;
    else if ( !wcscmp( pwcsAction, L"GetState" ) ) // Get the current state 
        dwNewState = CICAT_GET_STATE;
    else
    {
        fprintf( stderr, "Action undefined!\n" );
        exit(-1);
    }

    // call the API
    sc = SetCatalogState ( pwcsCatalog,
                           pwcsMachine,  
                           dwNewState,
                           &dwOldState );   

    if ( FAILED( sc ) )
    {
        printf( "ChangeState for catalog %ws failed with error %#x\n", pwcsCatalog ,sc );
        return -1;
    }

    printf(" Old State is " );
    if ( CICAT_STOPPED == dwOldState ) 
        printf( "CICAT_STOPPED.\n" );
    else
    {
        if ( CICAT_WRITABLE & dwOldState ) 
            printf( "CICAT_WRITABLE.\n" );
        else if ( CICAT_READONLY & dwOldState )
            printf( "CICAT_READONLY.\n" );
        else printf( "Error obtaining oldState. The return value is %d\n", dwOldState );
    }

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\admin\snapin.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001.
//
//  File:       Snapin.cxx
//
//  Contents:   MMC snapin for CI.
//
//  History:    26-Nov-1996     KyleP   Created
//              20-Jan-1999     SLarimor Modified rescan interface to include 
//                                      Full and Incremental options separatly
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ISReg.hxx>
#include <CIARes.h>
#include <snapin.hxx>
#include <dataobj.hxx>
#include <propsht.hxx>
#include <callback.hxx>
#include <cmddlg.hxx>
#include <classid.hxx>
#include <catadmin.hxx>
#include <catalog.hxx>
#include <ntverp.h>

//
// Global data
//


//
// NOTE: Any new menus added to this array must be at the same location as
//       the value of "lCommandID", which is the third member of the
//       struct CONTEXTMENUITEM  ie. comidAddScope = 0 below.
//       Additionally, you should add another Win4Assert in the
//       "CCISnapinData::Initialize" method below.
CONTEXTMENUITEM aContextMenus[] = {
    // Add scope
    { STRINGRESOURCE( srCMScope ),
      STRINGRESOURCE( srCMScopeHelp ),
      comidAddScope,
      CCM_INSERTIONPOINTID_PRIMARY_NEW,
      MF_ENABLED,
      0 },

    // Add catalog
    { STRINGRESOURCE( srCMAddCatalog ),
      STRINGRESOURCE( srCMAddCatalogHelp ),
      comidAddCatalog,
      CCM_INSERTIONPOINTID_PRIMARY_NEW,
      MF_ENABLED,
      0 },

    // Rescan Full scope
    { STRINGRESOURCE( srCMRescanFull ),
      STRINGRESOURCE( srCMRescanFullHelp ),
      comidRescanFullScope,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Force merge
    { STRINGRESOURCE( srCMMerge ),
      STRINGRESOURCE( srCMMergeHelp ),
      comidMergeCatalog,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Start CI
    { STRINGRESOURCE( srCMStartCI ),
      STRINGRESOURCE( srCMStartCIHelp ),
      comidStartCI,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Stop CI
    { STRINGRESOURCE( srCMStopCI ),
      STRINGRESOURCE( srCMStopCIHelp ),
      comidStopCI,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Pause CI
    { STRINGRESOURCE( srCMPauseCI ),
      STRINGRESOURCE( srCMPauseCIHelp ),
      comidPauseCI,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Refresh properties list
    { STRINGRESOURCE( srRefreshProperties ),
      STRINGRESOURCE( srRefreshPropertiesHelp ),
      comidRefreshProperties,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Empty catalog
    { STRINGRESOURCE( srCMEmptyCatalog ),
      STRINGRESOURCE( srCMEmptyCatalogHelp ),
      comidEmptyCatalog,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Tune performance
    { STRINGRESOURCE( srCMTunePerformance ),
      STRINGRESOURCE( srCMTunePerformanceHelp ),
      comidTunePerfCITop,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Duplication of the commonly used menus
    // at the top of the menu.

    // Start CI
    { STRINGRESOURCE( srCMStartCI ),
      STRINGRESOURCE( srCMStartCIHelp ),
      comidStartCITop,
      CCM_INSERTIONPOINTID_PRIMARY_TOP,
      MF_ENABLED,
      0 },

    // Stop CI
    { STRINGRESOURCE( srCMStopCI ),
      STRINGRESOURCE( srCMStopCIHelp ),
      comidStopCITop,
      CCM_INSERTIONPOINTID_PRIMARY_TOP,
      MF_ENABLED,
      0 },

    // Pause CI
    { STRINGRESOURCE( srCMPauseCI ),
      STRINGRESOURCE( srCMPauseCIHelp ),
      comidPauseCITop,
      CCM_INSERTIONPOINTID_PRIMARY_TOP,
      MF_ENABLED,
      0 },

    // Rescan Incremental scope
    { STRINGRESOURCE( srCMRescanIncremental ),
      STRINGRESOURCE( srCMRescanIncrementalHelp ),
      comidRescanIncrementalScope,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },
};

static DWORD aIds[] =
    {
        IDOK,                       HIDP_OK,
        IDCANCEL,                   HIDP_CANCEL,

        // Catalog properties
        IDDI_FILTER_UNKNOWN,        HIDP_GENERATION_FILTER_UNKNOWN,
        IDDI_CHARACTERIZATION,      HIDP_GENERATION_GENERATE_CHARACTERIZATION,
        IDDI_CHARSIZE_STATIC,       HIDP_GENERATION_MAXIMUM_SIZE,
        IDDI_CHARACTERIZATION_SIZE, HIDP_GENERATION_MAXIMUM_SIZE,
        IDDI_SPIN_CHARACTERIZATION, HIDP_GENERATION_MAXIMUM_SIZE,
        IDDI_SELECT_SIZE,           HIDP_LOCATION_SIZE,
        IDDI_SIZE,                  HIDP_LOCATION_SIZE,
        IDDI_SELECT_PATH2,          HIDP_CATALOG_LOCATION,
        IDDI_PATH,                  HIDP_CATALOG_LOCATION,
        IDDI_SELECT_PROPCACHE_SIZE, HIDP_PROPCACHE_SIZE,
        IDDI_PROPCACHE_SIZE,        HIDP_PROPCACHE_SIZE,
        IDDI_VSERVER_STATIC,        HIDP_WEB_VSERVER,
        IDDI_VIRTUAL_SERVER,        HIDP_WEB_VSERVER,
        IDDI_NNTP_STATIC,           HIDP_WEB_NNTPSERVER,
        IDDI_NNTP_SERVER,           HIDP_WEB_NNTPSERVER,
        IDDI_AUTO_ALIAS,            HIDP_ALIAS_NETWORK_SHARES,
        IDDI_INHERIT1,              HIDP_SETTINGS_INHERIT1,
        IDDI_INHERIT2,              HIDP_SETTINGS_INHERIT2,
        IDDI_GROUP_INHERIT,         HIDP_INHERIT,
        IDDI_SELECT_CATNAME,        HIDP_CATALOG_NAME,
        IDDI_CATNAME,               HIDP_CATALOG_NAME,
        
        // New catalog
        IDDI_SELECT_CATPATH,        HIDP_LOCATION_LOCATION,
        IDDI_CATPATH,               HIDP_LOCATION_LOCATION,
        IDDI_SELECT_CATNAME2,       HIDP_LOCATION_NAME,
        IDDI_CATNAME2,              HIDP_LOCATION_NAME,
        IDDI_BROWSE,                HIDP_LOCATION_BROWSE,

        // Property dialog box
        IDDI_SELECT_PROPSET,        HIDP_PROPERTY_SET,
        IDDI_PROPSET,               HIDP_PROPERTY_SET,
        IDDI_SELECT_PROPERTY,       HIDP_PROPERTY_PROPERTY,
        IDDI_PROPERTY,              HIDP_PROPERTY_PROPERTY,
        IDDI_CACHED,                HIDP_PROPERTY_CACHED,
        IDDI_SELECT_DATATYPE,       HIDP_PROPERTY_DATATYPE,
        IDDI_DATATYPE,              HIDP_PROPERTY_DATATYPE,
        IDDI_SELECT_CACHEDSIZE,     HIDP_PROPERTY_SIZE,
        IDDI_CACHEDSIZE,            HIDP_PROPERTY_SIZE,
        IDDI_SPIN_CACHEDSIZE,       HIDP_PROPERTY_SIZE,
        IDDI_SELECT_STORAGELEVEL,   HIDP_PROPERTY_STORAGELEVEL,
        IDDI_STORAGELEVEL,          HIDP_PROPERTY_STORAGELEVEL,

        //IDDI_COMPNAME,              ,
        IDDI_LOCAL_COMPUTER,        HIDP_CONNECT_LOCAL,
        IDDI_REMOTE_COMPUTER,       HIDP_CONNECT_ANOTHER,
        IDDI_COMPNAME,              HIDP_CONNECT_ANOTHER,

        // New directory
        IDDI_SELECT_PATH,           HIDP_SCOPE_PATH,
        IDDI_DIRPATH,               HIDP_SCOPE_PATH,
        IDDI_BROWSE,                HIDP_SCOPE_BROWSE,
        IDDI_SELECT_ALIAS,          HIDP_SCOPE_ALIAS,
        IDDI_ALIAS,                 HIDP_SCOPE_ALIAS,
        IDDI_SELECT_USER_NAME,      HIDP_SCOPE_USER_NAME,
        IDDI_USER_NAME,             HIDP_SCOPE_USER_NAME,
        IDDI_SELECT_PASSWORD,       HIDP_SCOPE_PASSWORD,
        IDDI_PASSWORD,              HIDP_SCOPE_PASSWORD,
        IDDI_INCLUDE,               HIDP_SCOPE_INCLUDE,
        IDDI_EXCLUDE,               HIDP_SCOPE_EXCLUDE,
        IDDI_ACCOUNT_INFORMATION,   HIDP_ACCOUNT_INFORMATION,
        IDDI_INCLUSION,             HIDP_INCLUSION,

        // Performance Tuning
        IDDI_DEDICATED,             HIDP_DEDICATED,
        IDDI_USEDOFTEN,             HIDP_USEDOFTEN,
        IDDI_USEDOCCASIONALLY,      HIDP_USEDOCCASIONALLY,
        IDDI_NEVERUSED,             HIDP_NEVERUSED,
        IDDI_CUSTOMIZE,             HIDP_CUSTOMIZE,
        IDDI_ADVANCED,              HIDP_ADVANCED_CONFIG,
        IDDI_SELECT_INDEXING,       HIDP_INDEXING_PERFORMANCE,
        IDDI_SLIDER_INDEXING,       HIDP_INDEXING_PERFORMANCE,
        IDDI_SELECT_QUERYING,       HIDP_QUERY_PERFORMANCE,
        IDDI_SLIDER_QUERYING,       HIDP_QUERY_PERFORMANCE,

        0, 0 };


MMCBUTTON aContextButtons[] =
{
    // Start CI
    { comidStartCIButton, // 0
      comidStartCITop,
      TBSTATE_ENABLED,
      TBSTYLE_BUTTON,
      STRINGRESOURCE( srCMStartCI ),
      STRINGRESOURCE( srCMStartCIHelp )
    },

    // Stop CI
    { comidStopCIButton,  // 1
      comidStopCITop,
      TBSTATE_ENABLED,
      TBSTYLE_BUTTON,
      STRINGRESOURCE( srCMStopCI ),
      STRINGRESOURCE( srCMStopCIHelp )
    },

    // Pause CI
    { comidPauseCIButton,  // 1
      comidPauseCITop,
      TBSTATE_ENABLED,
      TBSTYLE_BUTTON,
      STRINGRESOURCE( srCMPauseCI ),
      STRINGRESOURCE( srCMPauseCIHelp )
    }
};

//
// Registry constants
//

WCHAR const wszSnapinPath[]  = L"Software\\Microsoft\\MMC\\SnapIns\\";
WCHAR const wszTriedEnable[] = L"TriedEnable";

//
// Global variables
//

extern long gulcInstances;
extern CStaticMutexSem gmtxTimer;
HINSTANCE ghInstance;

DECLARE_INFOLEVEL(cia)

//
// Function prototypes
//

SCODE StartMenu( IContextMenuCallback * piCallback, BOOL fTop = TRUE );
SCODE StopMenu( IContextMenuCallback * piCallback, BOOL fTop = TRUE );
SCODE PauseMenu( IContextMenuCallback * piCallback, BOOL fTop = TRUE );
SCODE DisabledMenu( IContextMenuCallback * piCallback, BOOL fTop = TRUE );
SCODE SetStartStopMenu( IContextMenuCallback * piCallback, BOOL fTop = TRUE );


BOOL WINAPI DllMain( HANDLE hInstance, DWORD dwReason, LPVOID dwReserved )
{
    BOOL fRetval = TRUE;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        if ( dwReason == DLL_PROCESS_ATTACH )
        {
            ghInstance = (HINSTANCE)hInstance;
            gmtxTimer.Init();
            InitStrings( ghInstance );
        }

    }
    CATCH( CException, e )
    {
        // About the only thing this could be is STATUS_NO_MEMORY which
        // can be thrown by InitializeCriticalSection.

        ciaDebugOut(( DEB_ERROR,
                      "CIADMIN: Exception %#x in DllMain\n",
                      e.GetErrorCode()));

#if CIDBG == 1  // for debugging NTRAID 340297
        if (e.GetErrorCode() == STATUS_NO_MEMORY)
            DbgPrint( "CIADMIN: STATUS_NO_MEMORY exception in DllMain\n");
        else
            DbgPrint( "CIADMIN: ??? Exception in DllMain\n");
#endif // CIDBG == 1

        fRetval = FALSE;
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return fRetval;
}

// Detect if we are running on a server or a workstation
BOOL IsNTServer()
{
    BOOL fServer = FALSE;

    CRegAccess reg( RTL_REGISTRY_CONTROL,
                    L"ProductOptions" );

    WCHAR awcProductType[ MAX_PATH ];
    reg.Get( L"ProductType",
                  awcProductType,
                  sizeof awcProductType / sizeof WCHAR );

     // winnt, pdc/bdc, server.
     // note: 4.0 bdcs are LanmanNt, 5.0+ are spec'ed to be LansecNt

     if ( !_wcsicmp( awcProductType, L"WinNt" ) )
         fServer = FALSE;
     else if ( ( !_wcsicmp( awcProductType, L"LanmanNt" ) ) ||
               ( !_wcsicmp( awcProductType, L"LansecNt" ) ) ||
               ( !_wcsicmp( awcProductType, L"ServerNt" ) ) )
         fServer = TRUE;

    return fServer;
} //IsNTServer

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::QueryInterface
//
//  Synopsis:   Switch from one interface to another
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::QueryInterface( REFIID riid,
                                                       void ** ppvObject )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::QueryInterface " ));

    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    if ( IID_IComponentData == riid )
        *ppvObject = (IUnknown *)(IComponentData *)this;
    else if ( IID_IExtendPropertySheet == riid )
        *ppvObject = (IUnknown *)(IExtendPropertySheet *)this;
    else if ( IID_IExtendContextMenu == riid )
        *ppvObject = (IUnknown *)(IExtendContextMenu *)this;
    else if ( IID_IPersistStream == riid )
        *ppvObject = (IUnknown *)(IPersistStream *)this;
    else if ( IID_ISnapinAbout == riid )
        *ppvObject = (IUnknown *)(ISnapinAbout *)this;
    else if ( IID_ISnapinHelp == riid )
        *ppvObject = (IUnknown *)(ISnapinHelp *)this;
    else if ( IID_IExtendControlbar == riid )
        *ppvObject = (IUnknown *)(IExtendControlbar *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IComponentData *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::AddRef
//
//  Synopsis:   Increment ref count
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCISnapinData::AddRef()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::AddRef\n" ));
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::Release
//
//  Synopsis:   Deccrement ref count
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCISnapinData::Release()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::Release\n" ));
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


SCODE STDMETHODCALLTYPE CCISnapinData::Initialize( IUnknown * pUnk )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::Initialize\n" ));

    //
    // Parameter checking.
    //

    if ( 0 == pUnk )
        return E_INVALIDARG;

    // Ensure that contex menus are in correct location in menu array. 
    Win4Assert( comidAddScope == aContextMenus[comidAddScope].lCommandID );
    Win4Assert( comidAddCatalog == aContextMenus[comidAddCatalog].lCommandID );
    Win4Assert( comidRescanFullScope == aContextMenus[comidRescanFullScope].lCommandID );
    Win4Assert( comidMergeCatalog == aContextMenus[comidMergeCatalog].lCommandID );
    Win4Assert( comidStartCI == aContextMenus[comidStartCI].lCommandID );
    Win4Assert( comidStopCI == aContextMenus[comidStopCI].lCommandID );
    Win4Assert( comidPauseCI == aContextMenus[comidPauseCI].lCommandID );
    Win4Assert( comidRefreshProperties == aContextMenus[comidRefreshProperties].lCommandID );
    Win4Assert( comidEmptyCatalog == aContextMenus[comidEmptyCatalog].lCommandID );
    Win4Assert( comidTunePerfCITop == aContextMenus[comidTunePerfCITop].lCommandID );
    Win4Assert( comidStartCITop == aContextMenus[comidStartCITop].lCommandID );
    Win4Assert( comidStopCITop == aContextMenus[comidStopCITop].lCommandID );
    Win4Assert( comidPauseCITop == aContextMenus[comidPauseCITop].lCommandID );
    Win4Assert( comidRescanIncrementalScope == aContextMenus[comidRescanIncrementalScope].lCommandID );

    TRANSLATE_EXCEPTIONS;

    SCODE sc;

    TRY
    {
        do
        {
            //
            // Collect interfaces
            //

            sc = pUnk->QueryInterface( IID_IConsole, (void **)&_pFrame );

            if ( FAILED(sc) )
                break;
            
            sc = _pFrame->GetMainWindow(&_hFrameWindow);

            if ( FAILED(sc) )
                break;

            //sc = _pFrame->QueryInterface( IID_IHeaderCtrl, (void **)&_pHeader );
            //
            //if ( FAILED(sc) )
            //    break;

            sc = _pFrame->QueryInterface(IID_IConsoleNameSpace, (void **)&_pScopePane );

            if ( FAILED(sc) )
                break;
            
            _rootNode.Init( _pScopePane );
            _Catalogs.Init( _pScopePane );

            //
            // Initialize resources
            //

            IImageList * pImageList;

            sc = _pFrame->QueryScopeImageList( &pImageList );

            if ( FAILED(sc) )
                break;

            sc = InitImageResources( pImageList );

            pImageList->Release();

            if ( FAILED(sc) )
                break;
        }
        while ( FALSE );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciaDebugOut(( DEB_ERROR, "Exception 0x%x caught in CCISnapinData::Initialize\n", sc ));
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    //
    // Damage control
    //

    if ( FAILED(sc) )
    {
        if ( 0 != _pScopePane )
        {
            _pScopePane->Release();
            _pScopePane = 0;
        }

        if ( 0 != _pFrame )
        {
            _pFrame->Release();
            _pFrame = 0;
        }
    }

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::CreateComponent( IComponent * * ppComponent )
{
    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        CCISnapin * p = new CCISnapin( *this, _pChild );

        *ppComponent = p;
        _pChild = p;

    }
    CATCH( CException, e )
    {
        sc = E_FAIL;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}


SCODE STDMETHODCALLTYPE CCISnapinData::Notify( IDataObject * pDO,
                                               MMC_NOTIFY_TYPE event,
                                               LPARAM arg,
                                               LPARAM param )
{
    ciaDebugOut(( DEB_ITRACE,
                  "CCISnapinData::Notify (pDO = 0x%x, event = 0x%x)\n",
                  pDO, event ));

    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        switch ( event )
        {
        case MMCN_EXPAND:
            ShowFolder( (CCIAdminDO *)pDO,   // Cookie
                        (BOOL)arg,           // TRUE --> Expand, FALSE --> Contract
                        (HSCOPEITEM)param ); // Scope item selected
            break;

        case MMCN_DELETE:
            RemoveCatalog( (CCIAdminDO *)pDO );
            break;

        case MMCN_REMOVE_CHILDREN:
            if ( _rootNode.IsParent( (HSCOPEITEM)arg ) )
            {
                Win4Assert( _fIsExtension );
                sc = _Catalogs.ReInit();

                if ( SUCCEEDED(sc) )
                    sc = _rootNode.Delete();

                _fIsInitialized = FALSE;
            }
            break;

        default:
            ciaDebugOut(( DEB_WARN, "unhandled notify 0x%x\n", event ));
            break;
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Exception 0x%x in CCISnapinData::Notify\n", e.GetErrorCode() ));
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::Destroy()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::Destroy\n" ));

    if ( 0 != _pFrame )
    {
        _pFrame->Release();
        _pFrame = 0;

        _pScopePane->Release();
        _pScopePane = 0;

        for ( CCISnapin * pCurrent = _pChild;
              0 != pCurrent;
              pCurrent = pCurrent->Next() )
        {
            pCurrent->ClearSnapinData();
        }

        // It's MMC's responsibility to destroy IConsole pointer we give them
        // I checked with Gautam in mmc team and confirmed this.
        _pChild = 0;
    }

    return S_OK;
}

SCODE STDMETHODCALLTYPE CCISnapinData::QueryDataObject( MMC_COOKIE cookie,
                                                        DATA_OBJECT_TYPES type,
                                                        IDataObject * * ppDataObject )
{
    //ciaDebugOut(( DEB_ITRACE,
    //              "CCISnapinData::QueryDataObject (cookie = 0x%x, type = 0x%x)\n",
    //              cookie, type ));

    //
    // Minimal parameter validation
    //

    if ( 0 == ppDataObject )
        return E_INVALIDARG;

    //
    // Create a data object
    //

    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        *ppDataObject = new CCIAdminDO( cookie, type, _fIsExtension ? 0 : _Catalogs.GetMachine() );
    }
    CATCH( CException, e )
    {
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::GetDisplayInfo( SCOPEDATAITEM * pScopeDataItem )
{
    //ciaDebugOut(( DEB_ITRACE, "CCISnapinData::GetDisplayInfo( 0x%x )\n", pScopeDataItem ));
    if (pScopeDataItem == NULL)
        return E_POINTER;

    TRANSLATE_EXCEPTIONS;

    SCODE sc = E_UNEXPECTED;

    TRY
    {
        PCIObjectType * pType = (PCIObjectType *)pScopeDataItem->lParam;

        if ( 0 == pType )
            return sc;

        switch ( pType->Type() )
        {
        case PCIObjectType::RootNode:
        {
            if ( pScopeDataItem->mask == SDI_STR )
            {
                pScopeDataItem->displayname = (WCHAR *)GetRootDisplay();

                sc = S_OK;
            }
            break;
        }

        case PCIObjectType::Catalog:
        {
            CCatalog * pCat = (CCatalog *)pScopeDataItem->lParam;

            if ( pScopeDataItem->mask == SDI_STR )
            {
                pScopeDataItem->displayname = (WCHAR *)pCat->GetCat( TRUE );
                sc = S_OK;
            }
            break;
        }

        case PCIObjectType::Intermediate_Scope:
        {
            if ( pScopeDataItem->mask == SDI_STR )
            {
                pScopeDataItem->displayname = STRINGRESOURCE( srNodeDirectories );
                sc = S_OK;
            }
            break;
        }

        case PCIObjectType::Intermediate_Properties:
        {
            if ( pScopeDataItem->mask == SDI_STR )
            {
                pScopeDataItem->displayname = STRINGRESOURCE( srNodeProperties );
                sc = S_OK;
            }
            break;
        }

        case PCIObjectType::Intermediate_UnfilteredURL:
        {
            if ( pScopeDataItem->mask == SDI_STR )
            {
                pScopeDataItem->displayname = STRINGRESOURCE( srNodeUnfiltered );
                sc = S_OK;
            }
            break;
        }

        case PCIObjectType::Property:
        case PCIObjectType::Directory:
        default:
            Win4Assert( !"Oops!" );
            break;
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Exception 0x%x in CCISnapinData::GetDisplayInfo\n", e.GetErrorCode() ));
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::CompareObjects( IDataObject * lpDataObjectA,
                                                       IDataObject * lpDataObjectB )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::CompareObjects( 0x%x, 0x%x )\n", lpDataObjectA, lpDataObjectB ));

    if ( *((CCIAdminDO *)lpDataObjectA) == *((CCIAdminDO *)lpDataObjectB) )
        return S_OK;
    else
        return S_FALSE;
}

SCODE STDMETHODCALLTYPE CCISnapinData::AddMenuItems( IDataObject * piDataObject,
                                                     IContextMenuCallback * piCallback,
                                                     long * pInsertionAllowed )
{
    if ( 0 == piDataObject )
        return E_UNEXPECTED;

    if ( 0 == (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP ) )
    {
        ciaDebugOut(( DEB_WARN, "Menu Insertion not allowed.\n" ));
        return S_OK;
    }

    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        CCIAdminDO * pDO = (CCIAdminDO *)piDataObject;

        ciaDebugOut(( DEB_ITRACE, "CCISnapinData::AddMenuItems (cookie = 0x%x, type = 0x%x)\n",
                      pDO->Cookie(), pDO->Type() ));

        if ( pDO->Type() == CCT_RESULT )

        {
            if ( SUCCEEDED(sc) && pDO->IsACatalog() )
            {
                sc = piCallback->AddItem( &aContextMenus[comidMergeCatalog] );
            }
            else if ( SUCCEEDED(sc) && pDO->IsADirectory() )
            {

                CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );
                if (MachineAdmin.IsCIStarted()) 
                {
                    // Add both Full and Incremental rescan options to menu.
                    sc = piCallback->AddItem( &aContextMenus[comidRescanFullScope] );
                    if ( SUCCEEDED(sc) )
                        sc = piCallback->AddItem( &aContextMenus[comidRescanIncrementalScope] );
                }

            }
            else
                ciaDebugOut(( DEB_WARN, "No menu items for (cookie = 0x%x, type = 0x%x)\n",
                              pDO->Cookie(), pDO->Type() ));
        }
        else if ( SUCCEEDED(sc) && pDO->Type() == CCT_SCOPE )
        {
            if ( (pDO->IsRoot() || pDO->IsStandAloneRoot()) )
            {
                if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK )
                {
                    //
                    // Adjust state accordingly.
                    //
                    CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

                    if ( MachineAdmin.IsCIStarted() )
                    {
                        sc = StartMenu( piCallback );

                        if (SUCCEEDED(sc))
                        {
                            aContextMenus[comidTunePerfCITop].fFlags = MF_ENABLED;
                            sc = piCallback->AddItem( &aContextMenus[comidTunePerfCITop] );
                        }
                    }
                    else if ( MachineAdmin.IsCIPaused() )
                    {
                        sc = PauseMenu( piCallback );

                        if (SUCCEEDED(sc))
                        {
                            aContextMenus[comidTunePerfCITop].fFlags = MF_ENABLED;
                            sc = piCallback->AddItem( &aContextMenus[comidTunePerfCITop] );
                        }
                    }
                    else
                    {
                        Win4Assert( MachineAdmin.IsCIStopped() );
                        sc = StopMenu( piCallback );

                        if (SUCCEEDED(sc))
                        {
                            aContextMenus[comidTunePerfCITop].fFlags = MF_ENABLED;
                            sc = piCallback->AddItem( &aContextMenus[comidTunePerfCITop] );
                        }
                    }
                }

                if (SUCCEEDED(sc) && (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW ) )
                {
                    sc = piCallback->AddItem( &aContextMenus[comidAddCatalog] );
                }
            }
            else if ( pDO->IsACatalog() )
            {
                if (SUCCEEDED(sc) && (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW ) )
                {
                    sc = piCallback->AddItem( &aContextMenus[comidAddScope] );
                }

                if (SUCCEEDED(sc) && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK ) )
                {
                    CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

                    //
                    // Only append individual catalog control if service is running.
                    //

                    if ( MachineAdmin.IsCIStarted() || MachineAdmin.IsCIPaused() )
                    {

                        // Menu item to trigger clean up of the catalog

                        aContextMenus[comidEmptyCatalog].fFlags = MF_GRAYED;
                        piCallback->AddItem( &aContextMenus[comidEmptyCatalog] );

                        aContextMenus[comidMergeCatalog].fFlags = MF_ENABLED;

                        XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                        if ( xCat->IsStarted() )
                        {
                            aContextMenus[comidMergeCatalog].fFlags = MF_ENABLED;
                            sc = StartMenu( piCallback, FALSE );
                        }
                        else if ( xCat->IsPaused() )
                        {
                            aContextMenus[comidMergeCatalog].fFlags = MF_GRAYED;
                            sc = PauseMenu( piCallback, FALSE );
                        }
                        else
                        {
                            Win4Assert( xCat->IsStopped() );
                            aContextMenus[comidMergeCatalog].fFlags = MF_GRAYED;
                            sc = StopMenu( piCallback, FALSE );
                        }
                    }
                    else
                    {
                        // Menu item to trigger clean up of the catalog

                        aContextMenus[comidEmptyCatalog].fFlags = MF_ENABLED;
                        piCallback->AddItem( &aContextMenus[comidEmptyCatalog] );

                        aContextMenus[comidMergeCatalog].fFlags = MF_GRAYED;
                        sc = DisabledMenu( piCallback, FALSE );
                    }

                    if (SUCCEEDED(sc)) 
                    {
                        sc = piCallback->AddItem( &aContextMenus[comidMergeCatalog] );
                    }
                }
            }
            else if ( pDO->IsADirectoryIntermediate() && (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW ) )
            {
                if (SUCCEEDED(sc))
                {
                    sc = piCallback->AddItem( &aContextMenus[comidAddScope] );
                }
            }
            else if ( pDO->IsAPropertyIntermediate() && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK ) )
            {
                if (SUCCEEDED(sc))
                {
                    sc = piCallback->AddItem( &aContextMenus[comidRefreshProperties] );
                }
            }
            else
            {
                ciaDebugOut(( DEB_WARN, "No menu items for (cookie = 0x%x, type = 0x%x)\n",
                              pDO->Cookie(), pDO->Type() ));
            }
        }
        else
        {
            ciaDebugOut(( DEB_WARN, "No menu items for (cookie = 0x%x, type = 0x%x)\n",
                          pDO->Cookie(), pDO->Type() ));
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Exception 0x%x in CCISnapinData::AddMenuItems\n", e.GetErrorCode() ));
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::Command( long lCommandID,
                                                IDataObject * piDataObject )
{
    if ( 0 == piDataObject )
        return E_POINTER;

    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        CCIAdminDO * pDO = (CCIAdminDO *)piDataObject;

        switch ( lCommandID )
        {
        case comidRescanFullScope:
        {
            CScope * pScope = pDO->GetScope();

            Win4Assert( 0 != pScope );

            //
            // Make sure the user wants to do a full rescan.
            //

            WCHAR awcMsg[MAX_PATH];
            WCHAR awcTemp[2 * MAX_PATH];

            LoadString( ghInstance, MSG_RESCAN_FULL_SCOPE_EXPLAIN, awcMsg, sizeof(awcMsg) / sizeof(WCHAR) );
            wsprintf( awcTemp, awcMsg, pScope->GetPath() );

            int iResult;

            // Pop up YES/NO box
            sc = _pFrame->MessageBox( awcTemp,
                                    STRINGRESOURCE( srMsgRescanFull ),
                                    MB_YESNO | /* MB_HELP | */
                                    MB_ICONWARNING | MB_DEFBUTTON2 |
                                    MB_APPLMODAL,
                                    &iResult );

            if ( SUCCEEDED(sc) )
            {
                switch ( iResult )
                {
                // Rescan( TRUE ) means "Full scan"
                case IDYES:
                {
                    pScope->Rescan( TRUE );
                    break;
                }
                case IDNO:
                {
                    // Do nothing.
                    break;
                }

                /* Help is not being used...
                case IDHELP:
                {
                    DisplayHelp( _hFrameWindow, HIDD_RESCAN );
                    break;
                }
                */

                default:
                    break;
                }
            }
            break;
        }
        case comidRescanIncrementalScope:
        {
            CScope * pScope = pDO->GetScope();

            Win4Assert( 0 != pScope );

            //
            // Make sure the user wants to do an incremental rescan.
            //

            WCHAR awcMsg[MAX_PATH];
            WCHAR awcTemp[2 * MAX_PATH];

            LoadString( ghInstance, MSG_RESCAN_INCREMENTAL_SCOPE_EXPLAIN, awcMsg, sizeof(awcMsg) / sizeof(WCHAR) );
            wsprintf( awcTemp, awcMsg, pScope->GetPath() );

            int iResult;

            // Pop up YES/NO box
            sc = _pFrame->MessageBox( awcTemp,
                                    STRINGRESOURCE( srMsgRescanIncremental ),
                                    MB_YESNO | /* MB_HELP | */
                                    MB_ICONWARNING | MB_DEFBUTTON2 |
                                    MB_APPLMODAL,
                                    &iResult );

            if ( SUCCEEDED(sc) )
            {
                switch ( iResult )
                {
                // Rescan( FALSE ) means "Incremental scan"
                case IDYES:
                {
                    pScope->Rescan( FALSE );
                    break;
                }
                case IDNO:
                {
                    // Do nothing.
                    break;
                }

                /* Help is not being used...
                case IDHELP:
                {
                    DisplayHelp( _hFrameWindow, HIDD_RESCAN );
                    break;
                }
                */

                default:
                    break;
                }
            }
            break;
        }

        case comidRefreshProperties:
        {
            // The user has explicitly requested a refresh of the list.
            // Delete the old list and recreate it.

            CCatalog * pcat = pDO->GetCatalog();
            
            BOOL fClearedYet = FALSE;

            for ( CCISnapin * pCurrent = _pChild;
                  0 != pCurrent;
                  pCurrent = pCurrent->Next() )
            {
                if ( CCISnapin::Properties == pCurrent->GetCurrentView() &&
                     pCurrent->GetCurrentCatalog() == pcat )
                {
                    if ( !fClearedYet )
                    {
                        pcat->ClearProperties( pCurrent->ResultPane() );
                        fClearedYet = TRUE;
                    }

                    pCurrent->ResultPane()->DeleteAllRsltItems();
                    pcat->DisplayProperties( TRUE, pCurrent->ResultPane() );
                }
            }

            break;
        }

        case comidEmptyCatalog:
        {
           // NOTE: The service must be stopped before we can do this. Deleting
           //       files under an active catalog leads to unpredictable results.

           int iResult;

           sc = _pFrame->MessageBox( STRINGRESOURCE( srMsgEmptyCatalogPrompt ),
                                     STRINGRESOURCE( srMsgEmptyCatalogAsk ),
                                     MB_YESNO | /* MB_HELP | */
                                       MB_ICONWARNING | MB_DEFBUTTON2 |
                                       MB_APPLMODAL,
                                     &iResult );

           if ( SUCCEEDED(sc) )
           {
               switch ( iResult )
               {
               case IDYES:
               {

                   CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );
                   XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                   //xCat->EmptyThisCatalog();

                   MachineAdmin.RemoveCatalogFiles(pDO->GetCatalog()->GetCat(TRUE));
                   break;
               }

               case IDNO:

                   // Do nothing.
                   break;

               default:
                   break;
               }
           }
           break;
        }

        case comidAddScope:
        {
            CCatalog * pCat = pDO->GetCatalog();

            Win4Assert( 0 != pCat );

            INT_PTR err = DialogBoxParam( ghInstance,                        // Application instance
                            MAKEINTRESOURCE( IDD_ADD_SCOPE ),  // Dialog box
                            _hFrameWindow,                     // main window
                            AddScopeDlg,                       // Dialog box function
                            (LPARAM)pCat );                    // User parameter

            if ( -1 == err )
                THROW( CException() );

            Refresh();  // Update all result pane(s)

            break;
        }

        case comidMergeCatalog:
        {
            CCatalog * pCat = pDO->GetCatalog();

            Win4Assert( 0 != pCat );

            //
            // Make sure the user wants to remove scope.
            //

            int iResult;

            sc = _pFrame->MessageBox( STRINGRESOURCE( srMsgMerge ),
                                      STRINGRESOURCE( srMsgMerge ),
                                        MB_YESNO | /* MB_HELP | */
                                        MB_ICONWARNING | MB_DEFBUTTON2 |
                                        MB_APPLMODAL,
                                      &iResult );

            if ( SUCCEEDED(sc) )
            {
                switch ( iResult )
                {
                case IDYES:
                {
                    pCat->Merge();
                    break;
                }
                case IDNO:
                case IDCANCEL:
                    // Do nothing.
                    break;

                /* Help is not being used...
                case IDHELP:
                {
                    DisplayHelp( _hFrameWindow, HIDD_MERGE_CATALOG );
                    break;
                }
                */

                default:
                    break;
                }
            }
            break;
        }

        case comidAddCatalog:
        {
            Win4Assert( pDO->IsRoot() || pDO->IsStandAloneRoot() );

            INT_PTR err = DialogBoxParam( ghInstance,                         // Application instance
                            MAKEINTRESOURCE( IDD_ADD_CATALOG ), // Dialog box
                            _hFrameWindow,                      // main frame window
                            AddCatalogDlg,                      // Dialog box function
                            (LPARAM)&_Catalogs );               // User parameter


            if ( -1 == err )
                THROW( CException() );

            // Ensure that only and all active catalogs are listed.
            _Catalogs.UpdateActiveState();

            Refresh();  // Update all result pane(s)

            break;
        }


        case comidStartCI:
        case comidStartCITop:
        {
            CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

            if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
            {
                MaybeEnableCI( MachineAdmin );

                MachineAdmin.StartCI();

                // Ensure that only and all active catalogs are listed.
                _Catalogs.UpdateActiveState();

                _Catalogs.SetSnapinData( this );
            }
            else
            {
                Win4Assert( pDO->IsACatalog() );

                XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                xCat->Start();

                // We are using the top-level buttons to control individual catalogs. Accordingly, they
                // should be updated to reflect the selected catalog's state.
                // The toolbar may not be created yet, so check if it is non-zero

                if ( xCat->IsStarted() && _pChild->_xToolbar.GetPointer() )
                {
                    // This is more efficient than calling CCISnapinData::SetButtonState

                    for ( CCISnapin * pCurrent = _pChild;
                         0 != pCurrent;
                         pCurrent = pCurrent->Next() )
                    {
                        pCurrent->_xToolbar->SetButtonState(comidStartCITop, ENABLED, FALSE);
                        pCurrent->_xToolbar->SetButtonState(comidStopCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidPauseCITop, ENABLED, TRUE);
                    }
                }
            }

            break;
        }

        case comidStopCI:
        case comidStopCITop:
        {
            CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

            if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
            {
                MachineAdmin.StopCI();

                // The toolbar may not be created yet, so check if it is non-zero
                if ( MachineAdmin.IsCIStopped() && _pChild->_xToolbar.GetPointer() )
                {
                    for ( CCISnapin * pCurrent = _pChild;
                          0 != pCurrent;
                          pCurrent = pCurrent->Next() )
                    {
                        pCurrent->_xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidStopCITop, ENABLED, FALSE);
                        pCurrent->_xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
                    }
                }

                // Ensure that only and all active catalogs are listed.
                _Catalogs.UpdateActiveState();
            }
            else
            {
                Win4Assert( pDO->IsACatalog() );

                XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                xCat->Stop();

                // The toolbar may not be created yet, so check if it is non-zero
                if ( xCat->IsStopped()  && _pChild->_xToolbar.GetPointer() )
                {
                    for ( CCISnapin * pCurrent = _pChild;
                          0 != pCurrent;
                          pCurrent = pCurrent->Next() )
                    {
                        pCurrent->_xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidStopCITop, ENABLED, FALSE);
                        pCurrent->_xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
                    }
                }
            }
            break;
        }

        case comidPauseCI:
        case comidPauseCITop:
        {
            CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

            if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
            {
                MachineAdmin.PauseCI();

                // The toolbar may not be created yet, so check if it is non-zero

                if ( MachineAdmin.IsCIPaused()  && _pChild->_xToolbar.GetPointer() )
                {
                    for ( CCISnapin * pCurrent = _pChild;
                          0 != pCurrent;
                          pCurrent = pCurrent->Next() )
                    {
                        pCurrent->_xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidStopCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
                    }
                }

                // Ensure that only and all active catalogs are listed.
                _Catalogs.UpdateActiveState();
            }
            else
            {
                Win4Assert( pDO->IsACatalog() );

                XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                xCat->Pause();

                // The toolbar may bot be created yet, so check if it is non-zero
                if ( xCat->IsPaused() && _pChild->_xToolbar.GetPointer() )
                {
                    for ( CCISnapin * pCurrent = _pChild;
                          0 != pCurrent;
                          pCurrent = pCurrent->Next() )
                    {
                        pCurrent->_xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidStopCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
                    }
                }
            }
            break;
        }

        case comidTunePerfCITop:
        {
           Win4Assert( pDO->IsRoot() || pDO->IsStandAloneRoot() );

           if ( IsNTServer() )
           {
              DialogBoxParam( ghInstance,                         // Application instance
                              MAKEINTRESOURCE( IDD_USAGE_ON_SERVER ), // Dialog box
                              _hFrameWindow,                      // main frame window
                              SrvTunePerfDlg,                      // Dialog box function
                              (LPARAM)&_Catalogs );               // User parameter
           }
           else
           {
              DialogBoxParam( ghInstance,                         // Application instance
                              MAKEINTRESOURCE( IDD_USAGE_ON_WORKSTATION ), // Dialog box
                              _hFrameWindow,                      // main frame window
                              WksTunePerfDlg,                      // Dialog box function
                              (LPARAM)&_Catalogs );               // User parameter
           }


           // Ensure that only and all active catalogs are listed.
           _Catalogs.UpdateActiveState();

           Refresh();  // Update all result pane(s)

           break;
        }

        default:
            sc = E_UNEXPECTED;
            break;
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Exception 0x%x in CCISnapinData::Command\n", e.GetErrorCode() ));
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCISnapinData::GetClassID, public
//
//  Synopsis:   Identifies class of storage
//
//  Arguments:  [pClassID] -- Class written here.
//
//  Returns:    S_OK
//
//  History:    14-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CCISnapinData::GetClassID( CLSID * pClassID )
{
    *pClassID = guidCISnapin;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCISnapinData::IsDirty, public
//
//  Returns:    TRUE if snapin data has not been saved.
//
//  History:    14-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CCISnapinData::IsDirty()
{
    return (_fDirty) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCISnapinData::Load, public
//
//  Synopsis:   Load persistent state
//
//  Arguments:  [pStm] -- State stored in stream.
//
//  Returns:    S_OK on successful load
//
//  History:    14-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CCISnapinData::Load( IStream * pStm )
{
    //
    // Read in machine name.
    //

    ULONG cbRead = 0;
    ULONG cc = 0;

    SCODE sc = pStm->Read( &cc, sizeof(cc), &cbRead );

    if ( S_OK != sc || cbRead != sizeof(cc) )
    {
        ciaDebugOut(( DEB_ERROR, "Could not load catalog name: 0x%x\n", sc ));
        return E_FAIL;
    }

    XGrowable<WCHAR> xwcsMachine( cc );

    sc = pStm->Read( xwcsMachine.Get(), cc * sizeof(WCHAR), &cbRead );

    if ( S_OK != sc || cbRead != cc * sizeof(WCHAR) )
    {
        ciaDebugOut(( DEB_ERROR, "Could not load catalog name: 0x%x\n", sc ));
        return E_FAIL;
    }

    _Catalogs.SetMachine( xwcsMachine.Get() );

    _fDirty = FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCISnapinData::Save, public
//
//  Synopsis:   Save persistent state
//
//  Arguments:  [pStm]        -- Stream into which state can be stored.
//              [fClearDirty] -- TRUE if dirty bit should be cleared
//
//  Returns:    S_OK if save succeeded.
//
//  History:    14-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CCISnapinData::Save( IStream * pStm, BOOL fClearDirty )
{
    ULONG cbWritten;
    ULONG cc = wcslen( _Catalogs.GetMachine() ) + 1;

    SCODE sc = pStm->Write( &cc, sizeof(cc), &cbWritten );

    if ( S_OK != sc || cbWritten != sizeof(cc) )
    {
        ciaDebugOut(( DEB_ERROR, "Could not save catalog name: 0x%x\n", sc ));
        return E_FAIL;
    }

    sc = pStm->Write( _Catalogs.GetMachine(), cc * sizeof(WCHAR), &cbWritten );

    if ( S_OK != sc || cbWritten != cc * sizeof(WCHAR) )
    {
        ciaDebugOut(( DEB_ERROR, "Could not save catalog name: 0x%x\n", sc ));
        return E_FAIL;
    }

    if ( fClearDirty )
        _fDirty = FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCISnapinData::GetSizeMax, public
//
//  Synopsis:   Computes size of persistent state
//
//  Arguments:  [pcbSize] -- Size returned here.
//
//  Returns:    S_OK
//
//  History:    14-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CCISnapinData::GetSizeMax( ULARGE_INTEGER * pcbSize )
{
    pcbSize->HighPart = 0;
    pcbSize->LowPart =  sizeof(ULONG) +
                        sizeof(WCHAR) * (wcslen(_Catalogs.GetMachine()) + 1);

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::CCISnapinData
//
//  Synopsis:   Constructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCISnapinData::CCISnapinData( )
        : _pFrame( 0 ),
          _pScopePane( 0 ),
          _pChild( 0 ),
          _uRefs( 1 ),
          _fDirty( TRUE ),
          _fIsInitialized( FALSE ),
          _fIsExtension( FALSE ),
          _fTriedEnable( FALSE ),
          _notifHandle( 0 ),
          _fURLDeselected( FALSE )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::~CCISnapinData
//
//  Synopsis:   Destructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCISnapinData::~CCISnapinData()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::~CCISnapinData\n" ));

    Win4Assert( 0 == _pFrame );
    Win4Assert( 0 == _pScopePane );

    // Tell catalogs that snapindata is no longer valid!
    _Catalogs.SetSnapinData(0);

    for ( CCISnapin * pCurrent = _pChild;
          0 != pCurrent;
          pCurrent = pCurrent->Next() )
    {
        pCurrent->ClearSnapinData();
    }

    InterlockedDecrement( &gulcInstances );
}

void CCISnapinData::Refresh()
{
    _Catalogs.DisplayScope( 0xFFFFFFFF );

    for ( CCISnapin * pCurrent = _pChild;
          0 != pCurrent;
          pCurrent = pCurrent->Next() )
    {
        pCurrent->Refresh();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::QueryInterface
//
//  Synopsis:   Switch from one interface to another
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapin::QueryInterface( REFIID riid,
                                                   void ** ppvObject )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::QueryInterface\n" ));

    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    if ( IID_IComponent == riid )
        *ppvObject = (IUnknown *)(IComponent *)this;
    else if ( IID_IExtendPropertySheet == riid )
        *ppvObject = (IUnknown *)(IExtendPropertySheet *)this;
    else if ( IID_IExtendContextMenu == riid )
        *ppvObject = (IUnknown *)(IExtendContextMenu *)this;
    else if ( IID_IExtendControlbar == riid )
        *ppvObject = (IUnknown *)(IExtendControlbar *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IComponent *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::AddRef
//
//  Synopsis:   Increment ref count
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCISnapin::AddRef()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::AddRef\n" ));
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::Release
//
//  Synopsis:   Deccrement ref count
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCISnapin::Release()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::Release\n" ));
    unsigned long uTmp = InterlockedDecrement( &_uRefs );
    
    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


SCODE STDMETHODCALLTYPE CCISnapin::Initialize( IConsole * lpFrame )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::Initialize\n" ));

    //
    // Parameter checking.
    //

    if ( 0 == lpFrame )
        return E_INVALIDARG;

    _pFrame = lpFrame;
    _pFrame->AddRef();

    SCODE sc;

    do
    {
        //
        // Collect interfaces
        //

        sc = _pFrame->QueryInterface( IID_IHeaderCtrl, (void **)&_pHeader );

        if ( FAILED(sc) )
            break;

        sc = _pFrame->QueryInterface( IID_IResultData, (void **)&_pResultPane );

        if ( FAILED(sc) )
            break;

        sc = _pFrame->QueryConsoleVerb( &_pConsoleVerb );

        if ( FAILED(sc) )
            break;

        sc = _pFrame->QueryInterface( IID_IDisplayHelp, (void **)&_pDisplayHelp );

        if ( FAILED(sc) )
            break;

        //
        // Initialize resources
        //

        sc = _pFrame->QueryResultImageList( &_pImageList );

        if ( FAILED(sc) )
            break;

        sc = _pFrame->GetMainWindow(&_hFrameWindow);

        if ( FAILED(sc) )
            break;

        //
        // Initialize catalogs
        //

        // _SnapinData.GetCatalogs().InitHeader( _pHeader );

    }
    while ( FALSE );



    //
    // Damage control
    //

    if ( FAILED(sc) )
    {
        if ( 0 != _pImageList )
        {
            _pImageList->Release();
            _pImageList = 0;
        }

        if ( 0 != _pResultPane )
        {
            _pResultPane->Release();
            _pResultPane = 0;
        }

        if ( 0 != _pConsoleVerb )
        {
            _pConsoleVerb->Release();
            _pConsoleVerb = 0;
        }

        if ( 0 != _pHeader )
        {
            _pHeader->Release();
            _pHeader = 0;
        }

        if ( 0 != _pFrame )
        {
            _pFrame->Release();
            _pFrame = 0;
        }
    }

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapin::Notify( IDataObject * pDataObject,
                                           MMC_NOTIFY_TYPE event,
                                           LPARAM arg,
                                           LPARAM param )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::Notify (pDO = 0x%x, event = 0x%x)\n",
                  pDataObject, event ));

    CCIAdminDO * pDO = (CCIAdminDO *)pDataObject;

    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        switch ( event )
        {
        case MMCN_SHOW:
            ShowItem( pDO,                 // Cookie
                      (BOOL)arg,           // TRUE --> Select, FALSE --> Deselect
                      (HSCOPEITEM)param ); // Scope item selected
            break;

        case MMCN_SELECT:
            if ( (CCIAdminDO *) -2 != pDO )
                EnableStandardVerbs( pDO );
            break;

/*
        case MMCN_COLUMN_CLICK:
            // No need to sort on these columns in this view
            sc = _pResultPane->Sort(arg, RSI_DESCENDING, 0);
            break;
*/

        case MMCN_DBLCLICK:

            if (pDO->Type() == CCT_SCOPE)
            {
                // This is an undocumented feature. Return S_FALSE and that will
                // cause the appropriate node in the scope pane to automagically expand
                // and select the right node. Figured this out after spending a couple of
                // hours trying to find a documented way of doing this...
                // Other components use this undocumented feature.

                sc = S_FALSE;
            }
            else if (pDO->IsADirectory())
            {
                CScope * pScope = pDO->GetScope();
    
                Win4Assert( 0 != pScope );
    
                DialogBoxParam( ghInstance,                        // Application instance
                                MAKEINTRESOURCE( IDD_ADD_SCOPE ),  // Dialog box
                                _hFrameWindow,                     // main window
                                ModifyScopeDlg,                    // Dialog box function
                                (LPARAM)pScope );                  // User parameter
    
                Refresh();  // Update all result pane(s)
            }
            else if (pDO->IsAProperty())
            {
                XPtr<CPropertyPropertySheet1> xPropSheet( 
                          new CPropertyPropertySheet1( ghInstance, 
                                                       _pSnapinData->NotifyHandle(),
                                                       pDO->GetProperty(),
                                                       pDO->GetCatalog() 
                                                      ));
                LPCPROPSHEETPAGE psp = xPropSheet->GetPropSheet();

                PROPSHEETHEADER psh;

                psh.dwSize = sizeof (PROPSHEETHEADER);
                psh.dwFlags = PSH_PROPSHEETPAGE;
                psh.hwndParent = _hFrameWindow;
                psh.hInstance = ghInstance;
                psh.pszIcon = NULL;
                psh.pszCaption = pDO->GetProperty()->GetPropSet();
                psh.nPages = 1;
                psh.ppsp = psp;
                
                PropertySheet(&psh);
                xPropSheet.Acquire();
            }
            break;

        case MMCN_PROPERTY_CHANGE:
        {
            PCIObjectType * pType = (PCIObjectType *)param;
            if ( pType->Type() == PCIObjectType::Property )
            {
                ciaDebugOut(( DEB_ITRACE, "PROPERTY CHANGE\n" ));

                HRESULTITEM hItem;

                sc = _pResultPane->FindItemByLParam( param, &hItem );

                if ( SUCCEEDED(sc) )
                {
                    RESULTDATAITEM rdi;
                    ZeroMemory(&rdi, sizeof(rdi));

                    rdi.mask   = RDI_IMAGE;
                    rdi.itemID = hItem;
                    rdi.nImage = ICON_MODIFIED_PROPERTY;

                    sc = _pResultPane->SetItem( &rdi );
                }
            }
            break;
        } // case

        case MMCN_DELETE:
            if ( pDO->IsACatalog() )
                _pSnapinData->RemoveCatalog( pDO );
            else
            {
                Win4Assert( pDO->IsADirectory() );
                RemoveScope( pDO );
            }
            break;

        case MMCN_HELP:
        {
            LPOLESTR lpHelpFile;

            if ( S_OK == _pSnapinData->GetHelpTopic2(&lpHelpFile) )
               _pDisplayHelp->ShowTopic(lpHelpFile);
        }
        break;


        case MMCN_CONTEXTHELP:
        {
            LPOLESTR lpHelpFile;
   
            if ( S_OK == _pSnapinData->GetHelpTopic2(&lpHelpFile) )
                _pDisplayHelp->ShowTopic(lpHelpFile);
        }
        break;

        case MMCN_SNAPINHELP:
        {
            LPOLESTR lpHelpFile;

            if ( S_OK == _pSnapinData->GetHelpTopic2(&lpHelpFile) )
               _pDisplayHelp->ShowTopic(lpHelpFile);
        }
        break;


        } // switch
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Exception 0x%x in CCISnapin::Notify\n", e.GetErrorCode() ));
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapin::Destroy( MMC_COOKIE cookie )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::Destroy\n" ));

    if ( 0 != _pFrame )
    {
        _pFrame->Release();
        _pFrame = 0;

        _pHeader->Release();
        _pHeader = 0;

        _pResultPane->Release();
        _pResultPane = 0;

        _pImageList->Release();
        _pImageList = 0;

        _pConsoleVerb->Release();
        _pConsoleVerb = 0;

        _pDisplayHelp->Release();
        _pDisplayHelp = 0;
    }

    return S_OK;
}

SCODE STDMETHODCALLTYPE CCISnapin::QueryDataObject( MMC_COOKIE cookie,
                                                    DATA_OBJECT_TYPES type,
                                                    IDataObject * * ppDataObject )
{
    return _pSnapinData->QueryDataObject( cookie, type, ppDataObject );
}

SCODE STDMETHODCALLTYPE CCISnapin::GetResultViewType( MMC_COOKIE cookie,
                                                      BSTR * ppViewType,
                                                      long * pViewOptions )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::GetResultViewType (cookie = 0x%x)\n", cookie ));


    CIntermediate *pIntermediate = (CIntermediate *) cookie;
    if ( 0 != pIntermediate &&
         PCIObjectType::Intermediate_UnfilteredURL == pIntermediate->Type() )
    {
        Win4Assert(pIntermediate);
        // To display a URL
        WCHAR wszSysPath[MAX_PATH + 1];
        WCHAR wszPath[MAX_PATH + 1];

        GetSystemWindowsDirectory(wszSysPath, MAX_PATH);
        wcscpy(wszPath, L"file://");
        wcscat(wszPath, wszSysPath);

        wcscat(wszPath, L"\\Help\\ciadmin.htm#machine=");
        wcscat(wszPath, _pSnapinData->GetCatalogs().GetMachine());
        wcscat(wszPath, L",catalog=");
        wcscat(wszPath, pIntermediate->GetCatalog().GetCat(TRUE));

        MakeOLESTR(ppViewType, wszPath);
        *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS ;
        return S_OK;
    }
    else
    {
        //
        // S_FALSE --> Use listview
        //

        return S_FALSE;
    }
}

SCODE STDMETHODCALLTYPE CCISnapin::GetDisplayInfo( RESULTDATAITEM * pResult )
{
    //ciaDebugOut(( DEB_ITRACE, "CCISnapin::GetDisplayInfo (itemID = 0x%x, bScopeItem = %s, lParam = 0x%x)\n",
    //              pResult->itemID, pResult->bScopeItem ? "TRUE" : "FALSE", pResult->lParam ));
    
    if ( 0 == pResult )
        return E_POINTER;

    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        if ( pResult->mask & RDI_STR )
        {
            PCIObjectType * pType = (PCIObjectType *)pResult->lParam;
    
            switch ( pType->Type() )
            {
            case PCIObjectType::RootNode:
            {
                switch ( pResult->nCol )
                {
                   case 0:
                      pResult->str = (WCHAR *)_pSnapinData->GetRootDisplay();
                      break;
                   case 1:
                      pResult->str = (WCHAR *)_pSnapinData->GetType();
                      break;
                   case 2:
                      pResult->str = (WCHAR *)_pSnapinData->GetDescription();
                      break;
                   default:
                      Win4Assert(!"How did we get here?");
                      pResult->str = L"";
                      break;
                }
    
                if ( pResult->mask & RDI_IMAGE && 0 == pResult->nCol )
                    pResult->nImage = ICON_APP;
    
                break;
            }
    
            case PCIObjectType::Catalog:
            {
                CCatalog * pCat = (CCatalog *)pResult->lParam;
                pCat->GetDisplayInfo( pResult );
                break;
            }
    
            case PCIObjectType::Directory:
            {
                CScope * pScope = (CScope *)pResult->lParam;
                pScope->GetDisplayInfo( pResult );
                break;
            }
    
            case PCIObjectType::Property:
            {
                CCachedProperty * pProperty = (CCachedProperty *)pResult->lParam;
                pProperty->GetDisplayInfo( pResult );
                break;
            }
    
            case PCIObjectType::Intermediate_Scope:
            {
                if ( 0 == pResult->nCol )
                    pResult->str = STRINGRESOURCE( srNodeDirectories );
                else
                    pResult->str = L"";
    
                if ( pResult->mask & RDI_IMAGE && 0 == pResult->nCol )
                    pResult->nImage = ICON_FOLDER;
    
                break;
            }
    
            case PCIObjectType::Intermediate_Properties:
            {
                if ( 0 == pResult->nCol )
                    pResult->str = STRINGRESOURCE( srNodeProperties );
                else
                    pResult->str = L"";
    
                if ( pResult->mask & RDI_IMAGE && 0 == pResult->nCol )
                    pResult->nImage = ICON_FOLDER;
    
                break;
            }
    
            case PCIObjectType::Intermediate_UnfilteredURL:
            {
                if ( 0 == pResult->nCol )
                    pResult->str = STRINGRESOURCE( srNodeUnfiltered );
                else
                    pResult->str = L"";
    
                if ( pResult->mask & RDI_IMAGE && 0 == pResult->nCol )
                    pResult->nImage = ICON_URL;
    
                break;
            }
            }
        }
        else
            sc = E_UNEXPECTED;
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Exception 0x%x in CCISnapinData::GetDisplayInfo\n", e.GetErrorCode() ));
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapin::CompareObjects( IDataObject * lpDataObjectA,
                                                   IDataObject * lpDataObjectB )
{
    return _pSnapinData->CompareObjects( lpDataObjectA, lpDataObjectB );
}

SCODE STDMETHODCALLTYPE CCISnapin::CreatePropertyPages( IPropertySheetCallback * lpProvider,
                                                        LONG_PTR handle,
                                                        IDataObject * lpIDataObject )
{
    return _pSnapinData->CreatePropertyPages( lpProvider, handle, lpIDataObject );
}

SCODE STDMETHODCALLTYPE CCISnapinData::CreatePropertyPages( IPropertySheetCallback * lpProvider,
                                                            LONG_PTR handle,
                                                            IDataObject * lpIDataObject )
{
    SCODE sc = S_OK;
    _notifHandle = handle;

    TRY
    {
        CCIAdminDO * pDO = (CCIAdminDO *)lpIDataObject;

        CCatalog * pCat = pDO->GetCatalog();
        CScope * pScope = pDO->GetScope();
        CCachedProperty * pProperty = pDO->GetProperty();

        if ( pDO->Type() == CCT_SNAPIN_MANAGER )
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages (object is Catalogs)\n" ));

            XPtr<CIndexSrvPropertySheet0> xFoo( new CIndexSrvPropertySheet0( ghInstance, handle, &_Catalogs ));

            if (S_OK == lpProvider->AddPage( xFoo->GetHandle()) )
                xFoo.Acquire();
        }
        else if ( 0 != pProperty )
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages (object is property %ws)\n",
                          pProperty->GetProperty() ));

            XPtr<CPropertyPropertySheet1> xFoo( new CPropertyPropertySheet1( ghInstance, handle, pProperty, pCat ));

            if ( S_OK == lpProvider->AddPage( xFoo->GetHandle()) )
                xFoo.Acquire();
        }
        else if ( 0 != pScope )
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages (object is scope %ws)\n",
                          pScope->GetPath() ));
        }
        //
        // NOTE: The following has to be last, because you can derive a pCat from the
        //       preceding choices.
        //

        else if ( 0 != pCat )
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages (object is catalog %ws)\n",
                          pCat->GetCat( TRUE ) ));

            XPtr<CCatalogBasicPropertySheet> xCat1( new CCatalogBasicPropertySheet( ghInstance, handle, pCat ));

            if (S_OK == lpProvider->AddPage( xCat1->GetHandle()) )
                xCat1.Acquire();

            XPtr<CIndexSrvPropertySheet2> xCP2( new CIndexSrvPropertySheet2( ghInstance, handle, pCat ));

            if ( S_OK == lpProvider->AddPage( xCP2->GetHandle()) )
                 xCP2.Acquire();

            XPtr<CIndexSrvPropertySheet1> xIS1( new CIndexSrvPropertySheet1( ghInstance, handle, pCat ));

            if (S_OK == lpProvider->AddPage( xIS1->GetHandle()) )
                xIS1.Acquire();

        }
        else if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages (object is root)\n" ));

            XPtr<CIndexSrvPropertySheet1> xIS1( new CIndexSrvPropertySheet1( ghInstance, handle, &_Catalogs) );

            if (S_OK == lpProvider->AddPage( xIS1->GetHandle()) )
                xIS1.Acquire();

            XPtr<CIndexSrvPropertySheet2> xIS2( new CIndexSrvPropertySheet2( ghInstance, handle, &_Catalogs) );

            if (S_OK == lpProvider->AddPage( xIS2->GetHandle()) )
                xIS2.Acquire();
        }
        else
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages.  Invalid call. (cookie = 0x%x, type = 0x%x)\n",
                          ((CCIAdminDO *)lpIDataObject)->Cookie(),
                          ((CCIAdminDO *)lpIDataObject)->Type() ));
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CCISnapin::CreatePropertyPages: Caught error 0x%x\n", e.GetErrorCode() ));

        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapin::QueryPagesFor( IDataObject * lpDataObject )
{
    return _pSnapinData->QueryPagesFor( lpDataObject );
}


SCODE STDMETHODCALLTYPE CCISnapin::SetControlbar( LPCONTROLBAR pControlbar)
{
    // Notes: This implementation is based on the MMC
    // sample Step4.

    if (0 == pControlbar)
    {
        _xControlbar.Free();
        return S_OK;
    }

    SCODE sc = S_OK;

    // cache the incoming pointer and AddRef it
    _xControlbar.Set(pControlbar);
    _xControlbar->AddRef();


    // If we haven't yet created a toolbar, create now
    if (0 == _xToolbar.GetPointer())
    {
        Win4Assert(0 == _xBmpToolbar.Get());

        sc  = pControlbar->Create(TOOLBAR, this, _xToolbar.GetIUPointer());

        if (SUCCEEDED(sc))
        {
            _xBmpToolbar.Set(LoadBitmap(ghInstance, MAKEINTRESOURCE(BMP_TOOLBAR_SMALL)));
            sc = (_xBmpToolbar.Get() ? S_OK : E_FAIL);
        }

        if (SUCCEEDED(sc))
            sc = _xToolbar->AddBitmap(sizeof aContextButtons / sizeof aContextButtons[0],
                                      _xBmpToolbar.Get(), 16, 16, RGB(255, 0, 255));

        if (SUCCEEDED(sc))
            sc = _xToolbar->AddButtons(sizeof aContextButtons / sizeof aContextButtons[0],
                                   aContextButtons);
    }
    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapin::ControlbarNotify( MMC_NOTIFY_TYPE event,
                                                     LPARAM arg,
                                                     LPARAM param)
{
    Win4Assert(_xControlbar.GetPointer() &&
               _xToolbar.GetPointer() &&
               _xBmpToolbar.Get());

    if (MMCN_SELECT == event && !((BOOL)LOWORD(arg)) && _pSnapinData->IsURLDeselected() )
        return E_POINTER;

    SCODE sc = S_OK;

    BOOL fPaused = FALSE;
    BOOL fStopped = FALSE;
    BOOL fStarted = FALSE;

    TRY
    {
        if (MMCN_SELECT == event)
        {
            LPDATAOBJECT pDataObject = (LPDATAOBJECT) param;
            if( NULL == pDataObject )
              return S_FALSE;

            // Completely random MMC behavior (apparently).

            if ( -2 == param )
                return S_FALSE;

            CCIAdminDO * pDO = (CCIAdminDO *)pDataObject;

            BOOL bScope = (BOOL) LOWORD(arg);
            BOOL bSelect = (BOOL) HIWORD(arg);

            ciaDebugOut((DEB_ITRACE, 
                         "select event: scope: %d, selection %d, lparam: 0x%x\n", 
                         bScope, bSelect, param));

            CMachineAdmin   MachineAdmin( _pSnapinData->GetCatalogs().IsLocalMachine() ? 
                                          0 : _pSnapinData->GetCatalogs().GetMachine() );

            if (bScope) // scope item selected
            {
                if (pDO->IsRoot() || pDO->IsStandAloneRoot() )
                {
                    sc = _xControlbar->Attach(TOOLBAR, _xToolbar.GetPointer());

                    if ( SUCCEEDED(sc) )
                    {
                        if ( MachineAdmin.IsCIStarted() )
                            fStarted = TRUE;
                        else if ( MachineAdmin.IsCIPaused() )
                            fPaused = TRUE;
                        else
                        {
                            Win4Assert( MachineAdmin.IsCIStopped() );
                            fStopped = TRUE;
                        }
                    }
                }
                else
                {
                    sc = _xControlbar->Detach(_xToolbar.GetPointer());

                    // If the URL on scope pane is deselected, remember that
                    _pSnapinData->SetURLDeselected( pDO->IsURLIntermediate() && bSelect == FALSE );
                }
            }
            // result list item selected
            else
            {
                if ( pDO->IsACatalog() )
                {
                    XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                    if ( xCat->IsStarted() )
                        fStarted = TRUE;
                    else if ( xCat->IsPaused() )
                        fPaused = TRUE;
                    else
                    {
                        Win4Assert( xCat->IsStopped() );
                        fStopped = TRUE;
                    }
                 }
                 else if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
                 {
                     sc = _xControlbar->Attach(TOOLBAR, _xToolbar.GetPointer());

                     if ( SUCCEEDED(sc) )
                     {
                         if ( MachineAdmin.IsCIStarted() )
                             fStarted = TRUE;
                         else if ( MachineAdmin.IsCIPaused() )
                             fPaused = TRUE;
                         else
                         {
                             Win4Assert( MachineAdmin.IsCIStopped() );
                             fStopped = TRUE;
                         }
                     }
                 }
            }

            Win4Assert( _xToolbar.GetPointer() );
            if (fStarted)
            {
                _xToolbar->SetButtonState(comidStartCITop, ENABLED, FALSE);
                _xToolbar->SetButtonState(comidStopCITop, ENABLED, TRUE);
                _xToolbar->SetButtonState(comidPauseCITop, ENABLED, TRUE);
            }
            else if (fStopped)
            {
                _xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                _xToolbar->SetButtonState(comidStopCITop, ENABLED, FALSE);
                _xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
            }
            else if (fPaused)
            {
                _xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                _xToolbar->SetButtonState(comidStopCITop, ENABLED, TRUE);
                _xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
            }
        }
        else if (MMCN_BTN_CLICK == event)
        {
            Win4Assert( comidStartCITop == param ||
                        comidStopCITop  == param ||
                        comidPauseCITop == param );

            LPDATAOBJECT pDataObject = (LPDATAOBJECT) arg;

            CCIAdminDO TempDO( 0, CCT_SCOPE, 0 );

            if( NULL == pDataObject )
                pDataObject = (LPDATAOBJECT)&TempDO;

            return Command( (long)param, pDataObject );
        }
    }
    CATCH( CException, e )
    {
        sc = E_FAIL;
    }
    END_CATCH

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::QueryPagesFor( IDataObject * lpDataObject )
{
    if ( 0 == lpDataObject || _fURLDeselected )
        return E_POINTER;

    SCODE sc = S_OK;

    TRY
    {
        
       // NOTE: Attempt to open the service and if that fails, we'll be unable to 
       // add property pages. That's expected behavior
       XPtr<CMachineAdmin> xMachineAdmin(new CMachineAdmin( _Catalogs.GetMachine() ));
    
       CCIAdminDO * pDO = (CCIAdminDO *)lpDataObject;
   
       ciaDebugOut(( DEB_ITRACE, "CCISnapin::QueryPagesFor (cookie = 0x%x, type = 0x%x)\n",
                     pDO->Cookie(), pDO->Type() ));
   
       if ( pDO->Type() == CCT_SNAPIN_MANAGER )
           sc = S_OK;
   
       if ( pDO->IsRoot() || pDO->IsStandAloneRoot() || pDO->IsACatalog() || pDO->IsAProperty())
       {
           sc = S_OK;
       }
       else
       {
           ciaDebugOut(( DEB_WARN, "No property pages for (cookie = 0x%x, type = 0x%x)\n",
                         pDO->Cookie(), pDO->Type() ));
           sc = S_FALSE;
       }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CCISnapin::QueryPagesFor: Caught error 0x%x\n", e.GetErrorCode() ));

        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapin::AddMenuItems( IDataObject * piDataObject,
                                                 IContextMenuCallback * piCallback,
                                                 long * pInsertionAllowed )
{

    EnableStandardVerbs( piDataObject );
    return _pSnapinData->AddMenuItems( piDataObject, piCallback, pInsertionAllowed );
}

SCODE STDMETHODCALLTYPE CCISnapin::Command( long lCommandID,
                                            IDataObject * piDataObject )
{
    return _pSnapinData->Command( lCommandID, piDataObject );
}

//
// ISnapinAbout methods
//


//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::GetSnapinDescription
//
//  Synopsis:   Get description about indexing service.
//
//  History:    02-Feb-1998     KrishanN   Added Header
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::GetSnapinDescription(LPOLESTR *lpDescription)
{
    WCHAR szStr[1024];

    wsprintf(szStr, L"%s\r\n%s", STRINGRESOURCE( srProductDescription ),
                                 STRINGRESOURCE( srVendorCopyright ));

    return MakeOLESTR(lpDescription, szStr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::GetProvider
//
//  Synopsis:   Get provider of index server.
//
//  History:    02-Feb-1998     KrishanN   Added Header
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::GetProvider(LPOLESTR *lpName)
{
    WCHAR szStr[1024];

    wsprintf(szStr, L"%S, %s", VER_COMPANYNAME_STR, STRINGRESOURCE( srVendorName ));
    return MakeOLESTR(lpName, szStr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::GetSnapinVersion
//
//  Synopsis:   Get version of index server.
//
//  History:    02-Feb-1998     KrishanN   Added Header
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::GetSnapinVersion(LPOLESTR *lpVersion)
{
    WCHAR szStr[1024];
    wsprintf(szStr, L"%S", VER_PRODUCTVERSION_STR);
    return MakeOLESTR(lpVersion, szStr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::GetSnapinImage
//
//  Synopsis:   Get image of index server.
//
//  History:    02-Feb-1998     KrishanN   Added Header
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::GetSnapinImage(HICON *phAppIcon)
{
    *phAppIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(ICON_ABOUT));
    return (NULL == *phAppIcon) ? E_FAIL : S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::GetStaticFolderImage
//
//  Synopsis:   Get static folder images for use with Index Server.
//
//  History:    02-Feb-1998     KrishanN   Added Header
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::GetStaticFolderImage(
                                             HBITMAP  *hSmallImage,
                                             HBITMAP  *hSmallImageOpen,
                                             HBITMAP  *hLargeImage,
                                             COLORREF *cMask)
{
    *hSmallImage = *hSmallImageOpen = *hLargeImage = NULL;

    *hSmallImage = LoadBitmap(ghInstance, MAKEINTRESOURCE(BMP_SMALL_CLOSED_FOLDER));
    *hSmallImageOpen = LoadBitmap(ghInstance, MAKEINTRESOURCE(BMP_SMALL_OPEN_FOLDER));
    *hLargeImage = LoadBitmap(ghInstance, MAKEINTRESOURCE(BMP_LARGE_CLOSED_FOLDER));
    *cMask = RGB(255, 0, 255);

    if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
    {
        if (*hSmallImage)
            DeleteObject(*hSmallImage);
        if (*hSmallImageOpen)
            DeleteObject(*hSmallImageOpen);
        if (*hLargeImage)
            DeleteObject(*hLargeImage);

        return E_FAIL;
    }
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::CCISnapin
//
//  Synopsis:   Constructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCISnapin::CCISnapin( CCISnapinData & SnapinData, CCISnapin * pNext )
        : _pFrame( 0 ),
          _pHeader( 0 ),
          _pResultPane( 0 ),
          _pImageList( 0 ),
          _pConsoleVerb( 0 ),
          _pDisplayHelp( 0 ),
          _CurrentView( CCISnapin::Nothing ),
          _pSnapinData( & SnapinData ),
          _pNext( pNext ),
          _uRefs( 1 )
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::~CCISnapin
//
//  Synopsis:   Destructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCISnapin::~CCISnapin()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::~CCISnapin\n" ));

    if ( 0 != _pSnapinData )
    {
        if ( _pSnapinData->_pChild == this )
        {
            _pSnapinData->_pChild = _pNext;
        }
        else
        {
            for ( CCISnapin * pCurrent = _pSnapinData->_pChild;
                  0 != pCurrent && 0 != pCurrent->Next();
                  pCurrent = pCurrent->Next() )
            {
                if ( pCurrent->Next() == this )
                {
                    pCurrent->Link( pCurrent->Next()->Next() );
                    break;
                }
            }
        }
    }

    Win4Assert( 0 == _pFrame );
    Win4Assert( 0 == _pHeader );
    Win4Assert( 0 == _pResultPane );
    Win4Assert( 0 == _pImageList );
    Win4Assert( 0 == _pConsoleVerb );
}

//+-------------------------------------------------------------------------
//
//  Function:   GetMachineName
//
//  Synopsis:   gets machine name to administer.
//
//  Arguments:  [pDO]             -- dataobject pointer
//              [pwszMachineName] -- out buffer
//              [ cc ]            -- buffer size in wchars
//
//  Returns:    none. throws upon fatal errors (out of memory).
//
//  History:    01-Jul-1998   mohamedn    created
//              31-Aug-1998   KyleP       Support DNS names
//
//--------------------------------------------------------------------------

void GetMachineName(LPDATAOBJECT pDO, XGrowable<WCHAR,MAX_COMPUTERNAME_LENGTH> & xwszMachineName)
{
    Win4Assert( pDO );

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)CCIAdminDO::GetMachineNameCF(), NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream

    //
    // What if the computer name is > 512 bytes long?
    //

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, 512);

    XGlobalAllocMem   xhGlobal(stgmedium.hGlobal);

    WCHAR * pwszTmpBuf = NULL;
    // Attempt to get data from the object
    do
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(pDO->GetDataHere(&formatetc, &stgmedium)))
            break;

        pwszTmpBuf = (WCHAR *)stgmedium.hGlobal;

        if ( pwszTmpBuf == NULL || *pwszTmpBuf == L'' )
        {
            xwszMachineName[0] = L'.';
            xwszMachineName[1] = 0;
        }
        else
        {
            unsigned cc = wcslen(pwszTmpBuf) + 1;

            xwszMachineName.SetSize( cc );

            RtlCopyMemory( xwszMachineName.Get(), pwszTmpBuf, cc * sizeof(WCHAR) );
        }
    } while (FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::ShowFolder, private
//
//  Synopsis:   Called when folder is selected.  Displays result in
//              scope pane.
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

void CCISnapinData::ShowFolder( CCIAdminDO * pDO, BOOL fExpanded, HSCOPEITEM hScopeItem )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::ShowFolder (fExpanded = %d, hScopeItem = 0x%x)\n",
                  fExpanded, hScopeItem ));

    Win4Assert( pDO );

    //
    // Only do something on expansion
    //
    if ( fExpanded )
    {
        if ( !_fIsInitialized && pDO->IsStandAloneRoot() )
        {
            _fIsExtension = FALSE;
        }
        else if ( !_fIsInitialized )
        {
            _fIsExtension = TRUE;
        }

        //
        // we're stand alone.
        //
        if ( !_fIsExtension )
        {
            _fIsInitialized = TRUE;

            if ( pDO->IsStandAloneRoot() )
            {
                _Catalogs.DisplayScope( hScopeItem );
            }
            else if ( pDO->IsACatalog() )
            {
                pDO->GetCatalog()->DisplayIntermediate( _pScopePane );
            }
        }
        else if ( _fIsExtension && !_fIsInitialized )
        {
            //
            // we're an extension
            //

            XGrowable<WCHAR,MAX_COMPUTERNAME_LENGTH> xwcsMachine;

            GetMachineName( pDO, xwcsMachine );

            _Catalogs.SetMachine( xwcsMachine.Get() );

            SetRootDisplay();

            _rootNode.Display(hScopeItem);

            _fIsInitialized = TRUE;
        }
        else if ( _fIsExtension && pDO->IsRoot() )
        {
            Win4Assert( _fIsInitialized );

            _Catalogs.DisplayScope( _rootNode.GethScopeItem() );
        }
        else if ( _fIsExtension && pDO->IsACatalog() )
        {
            Win4Assert( _fIsInitialized );

            pDO->GetCatalog()->DisplayIntermediate( _pScopePane );
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::SetRootDisplay
//
//  Synopsis:   sets display name string, type string, and description string
//              for static root node
//
//  History:    7/1/98  mohamedn    created
//              9/29/98 KrishnaN    Added type and description.
//
//--------------------------------------------------------------------------

void CCISnapinData::SetRootDisplay()
{
    if ( _fIsExtension )
    {
        unsigned cc = wcslen( STRINGRESOURCE(srIndexServerCmpManage) + 1 );
        _xwcsTitle.SetSize(cc);
        wcscpy( _xwcsTitle.Get(), STRINGRESOURCE(srIndexServerCmpManage) );

        cc = wcslen( STRINGRESOURCE(srType) + 1);
        _xwcsType.SetSize(cc);
        wcscpy( _xwcsType.Get(), STRINGRESOURCE(srType) );

        cc = wcslen( STRINGRESOURCE(srProductDescription) + 1);
        _xwcsDescription.SetSize(cc);
        wcscpy( _xwcsDescription.Get(), STRINGRESOURCE(srProductDescription) );

    }
    else
    {
        unsigned cc = wcslen( STRINGRESOURCE(srIndexServer) ) + 1;

        _xwcsTitle.SetSize(cc);

        wcscpy( _xwcsTitle.Get(), STRINGRESOURCE(srIndexServer) );

        if ( _Catalogs.IsLocalMachine() )
        {
            cc += wcslen( STRINGRESOURCE(srLM) );

            _xwcsTitle.SetSize( cc );

            wcscat( _xwcsTitle.Get(), STRINGRESOURCE(srLM) );
        }
        else
        {
            cc += wcslen( _Catalogs.GetMachine() );
            cc += 2;  // the UNC slashes

            _xwcsTitle.SetSize( cc );

            wcscat( _xwcsTitle.Get(), L"\\\\" );
            wcscat( _xwcsTitle.Get(), _Catalogs.GetMachine() );
        }

        _xwcsType.Free();
        _xwcsDescription.Free();
    }
}

void CCISnapin::EnableStandardVerbs( IDataObject * piDataObject )
{
    SCODE sc = QueryPagesFor( piDataObject );

    if ( S_OK == sc )
    {
        _pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
    }
    else
        _pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);


    if (!_pSnapinData->IsURLDeselected() )
    {
       CCIAdminDO * pDO = (CCIAdminDO *)piDataObject;
   
       if ( ( pDO->IsADirectory() && !pDO->GetScope()->IsVirtual() && !pDO->GetScope()->IsShadowAlias() ) ||
            pDO->IsACatalog() )
       {
           _pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
       }
       else
       {
           _pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
       }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::ShowItem, private
//
//  Synopsis:   Called when folder is selected.  Displays result in
//              result pane.
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

void CCISnapin::ShowItem( CCIAdminDO * pDO, BOOL fExpanded, HSCOPEITEM hScopeItem )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::ShowItem (fExpanded = %d, hScopeItem = 0x%x)\n",
                  fExpanded, hScopeItem ));

    if ( fExpanded )
    {
        SCODE sc = InitImageResources( _pImageList );

        if ( FAILED(sc) )
        {
            ciaDebugOut(( DEB_ERROR, "InitImageResources returned 0x%x\n", sc ));
            THROW( CException( sc ) );
        }

        if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
        {
            if ( !_CatalogsHeader.IsInitialized() )
            {
                _pSnapinData->GetCatalogs().InitHeader( _CatalogsHeader );

                //
                // Start background polling.
                //

                _pSnapinData->GetCatalogs().Display( TRUE );
            }

            _CatalogsHeader.Display( _pHeader );

            _CurrentView = CCISnapin::Catalogs;
        }
        else if ( pDO->IsADirectoryIntermediate() )
        {
            CCatalog * pCat = pDO->GetCatalog();

            if ( !_CatalogScopeHeader.IsInitialized() )
                pCat->InitScopeHeader( _CatalogScopeHeader );

            _CatalogScopeHeader.Display( _pHeader );

            pCat->DisplayScopes( TRUE, _pResultPane );

            _CurrentView = CCISnapin::Scopes;
            _CurrentCatalog = pCat;
        }
        else if ( pDO->IsAPropertyIntermediate() )
        {
            CCatalog * pCat = pDO->GetCatalog();

            if ( !_CatalogPropertyHeader.IsInitialized() )
                pCat->InitPropertyHeader( _CatalogPropertyHeader );

            _CatalogPropertyHeader.Display( _pHeader );

            pCat->DisplayProperties( TRUE, _pResultPane );

            _CurrentView = CCISnapin::Properties;
            _CurrentCatalog = pCat;
        }
        else
            _CurrentView = CCISnapin::Nothing;
    }
    else
    {
        switch ( _CurrentView )
        {
        case CCISnapin::Catalogs:
            Win4Assert( pDO->IsRoot() || pDO->IsStandAloneRoot() );
            _CatalogsHeader.Update( _pHeader );
            break;

        case CCISnapin::Scopes:
            Win4Assert( pDO->IsADirectoryIntermediate() );
            _CatalogScopeHeader.Update( _pHeader );
            break;

        case CCISnapin::Properties:
            Win4Assert( pDO->IsAPropertyIntermediate() );
            _CatalogPropertyHeader.Update( _pHeader );
            break;
        }

        _CurrentView = CCISnapin::Nothing;
    }
}

void CCISnapin::Refresh()
{
    switch ( _CurrentView )
    {
    case CCISnapin::Scopes:
        _CurrentCatalog->DisplayScopes( FALSE, _pResultPane );
        break;

    case CCISnapin::Properties:
        _CurrentCatalog->DisplayProperties( FALSE, _pResultPane );
        break;

    case CCISnapin::Catalogs:
    case CCISnapin::Nothing:
    default:
        break;
    }
}

void CCISnapin::RemoveScope( CCIAdminDO * pDO )
{
    Win4Assert( pDO->IsADirectory() && !pDO->GetScope()->IsVirtual() );

    CScope * pScope = pDO->GetScope();

    Win4Assert( 0 != pScope );

    //
    // Make sure the user wants to remove scope.
    //

    WCHAR awcMsg[MAX_PATH];
    WCHAR awcTemp[2 * MAX_PATH];

    LoadString( ghInstance, MSG_REMOVE_SCOPE, awcMsg, sizeof(awcMsg) / sizeof(WCHAR) );
    wsprintf( awcTemp, awcMsg, pScope->GetPath() );
    LoadString( ghInstance, MSG_REMOVE_SCOPE_TITLE, awcMsg, sizeof(awcMsg) / sizeof(WCHAR) );

    int iResult;

    SCODE sc = _pFrame->MessageBox( awcTemp,
                                    awcMsg,
                                    MB_YESNO | /* MB_HELP | */
                                      MB_ICONWARNING | MB_DEFBUTTON2 |
                                      MB_APPLMODAL,
                                    &iResult );

    if ( SUCCEEDED(sc) )
    {
        switch ( iResult )
        {
        case IDYES:
        {
            CCatalog & cat = pScope->GetCatalog();
            cat.RemoveScope( pScope );
            Refresh();                          // Update all result pane(s)
            break;
        }
        case IDNO:
            // Do nothing.
            break;

        /* Help is not being used...
        case IDHELP:
        {
           // NTRAID#DB-NTBUG9-83341-2000/07/31-dlee Need online help for several Indexing Service admin dialogs
            DisplayHelp( _hFrameWindow, HIDD_REMOVE_SCOPE );
            break;
        }
        */
        default:
            break;
        }
    }
}

void CCISnapinData::RemoveCatalog( CCIAdminDO * pDO )
{
    CCatalog * pCat = pDO->GetCatalog();

    Win4Assert( 0 != pCat );

    //
    // Make sure we can perform the operation right now.
    //

    CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

    if ( MachineAdmin.IsCIStarted() )
    {
        int iResult;

        SCODE sc = _pFrame->MessageBox( STRINGRESOURCE( srMsgCantDeleteCatalog ),
                                        STRINGRESOURCE( srMsgDeleteCatalogTitle ),
                                        MB_OK | /* MB_HELP | */
                                          MB_ICONWARNING | MB_APPLMODAL,
                                        &iResult );

        if ( SUCCEEDED(sc) )
        {
            switch ( iResult )
            {
            case IDOK:
            case IDCANCEL:
                // Do nothing.
                break;
            /* Help is not being used
            case IDHELP:
            {
                DisplayHelp( _hFrameWindow, HIDD_REMOVE_CATALOG );
                break;
            }
            */
            default:
                break;
            }
        }
    }
    else
    {
        int iResult;

        SCODE sc = _pFrame->MessageBox( STRINGRESOURCE( srMsgDeleteCatalog ),
                                        STRINGRESOURCE( srMsgDeleteCatalogAsk ),
                                        MB_YESNO | /* MB_HELP | */
                                          MB_ICONWARNING | MB_DEFBUTTON2 |
                                          MB_APPLMODAL,
                                        &iResult );

        if ( SUCCEEDED(sc) )
        {
            switch ( iResult )
            {
            case IDYES:
            {
                if ( FAILED(_Catalogs.RemoveCatalog( pCat )) )
                    _pFrame->MessageBox( STRINGRESOURCE( srMsgCatalogPartialDeletion ),
                                         STRINGRESOURCE( srMsgDeleteCatalogTitle ),
                                         MB_OK | /* MB_HELP | */
                                         MB_ICONWARNING | MB_APPLMODAL,
                                         &iResult);

                Refresh();  // Update all result pane(s)
                break;
            }
            case IDNO:
            case IDCANCEL:
                // Do nothing.
                break;

            /* Help is not being used...
            case IDHELP:
            {
                DisplayHelp( _hFrameWindow, HIDD_REMOVE_CATALOG );
                break;
            }
            */

            default:
                break;
            }
        }
    }
}

SCODE STDMETHODCALLTYPE CCISnapinData::GetHelpTopic( LPOLESTR *lpCompiledHelpFile)
{
    if (0 == lpCompiledHelpFile)
        return E_POINTER;

    WCHAR awc[ MAX_PATH + 1];
    const UINT cwcMax = sizeof awc / sizeof WCHAR;

    UINT cwc = GetSystemWindowsDirectory( awc, cwcMax );

    if ( 0 == cwc || cwc > cwcMax )
        return E_UNEXPECTED;

    if ( L'\\' != awc[ cwc-1] )
        wcscat( awc, L"\\" );

    // ixhelp.hlp is placed in %windir%\help
    wcscat( awc, L"help\\\\is.chm" );
    return MakeOLESTR(lpCompiledHelpFile, awc);
}

SCODE STDMETHODCALLTYPE CCISnapinData::GetLinkedTopics( LPOLESTR *lpCompiledHelpFiles)
{
    if (0 == lpCompiledHelpFiles)
        return E_POINTER;
    
    WCHAR awc[ MAX_PATH + 1];
    const UINT cwcMax = sizeof awc / sizeof WCHAR;

    UINT cwc = GetSystemWindowsDirectory( awc, cwcMax );

    if ( 0 == cwc || cwc > cwcMax )
        return E_UNEXPECTED;

    if ( L'\\' != awc[ cwc-1] )
        wcscat( awc, L"\\" );

    wcscat( awc, L"help\\\\isconcepts.chm" );
    return MakeOLESTR(lpCompiledHelpFiles, awc);
}


SCODE STDMETHODCALLTYPE CCISnapinData::GetHelpTopic2( LPOLESTR *lpCompiledHelpFile)
{
    if (0 == lpCompiledHelpFile)
        return E_POINTER;
    
    WCHAR awc[ MAX_PATH + 1];
    const UINT cwcMax = sizeof awc / sizeof WCHAR;

    UINT cwc = GetSystemWindowsDirectory( awc, cwcMax );

    if ( 0 == cwc || cwc > cwcMax )
        return E_UNEXPECTED;

    if ( L'\\' != awc[ cwc-1] )
        wcscat( awc, L"\\" );

    wcscat( awc, L"help\\\\isconcepts.chm::/sag_INDEXtopnode.htm" );
    return MakeOLESTR(lpCompiledHelpFile, awc);
}

SCODE InitImageResources( IImageList * pImageList )
{
    HBITMAP hbmpSmall = LoadBitmap( ghInstance, MAKEINTRESOURCE( BMP_SMALL_ICONS ) );

    if ( 0 == hbmpSmall )
        return E_FAIL;

    HBITMAP hbmpLarge = LoadBitmap( ghInstance, MAKEINTRESOURCE( BMP_LARGE_ICONS ) );

    if ( 0 == hbmpLarge )
    {
        DeleteObject( hbmpSmall );
        return E_FAIL;
    }

    SCODE sc = pImageList->ImageListSetStrip( (LONG_PTR *)hbmpSmall,
                                              (LONG_PTR *)hbmpLarge,
                                              0,
                                              RGB( 255, 0, 255 ) );

    DeleteObject( hbmpSmall );
    DeleteObject( hbmpLarge );

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Function:   DisplayHelp
//
//  Synopsis:   Displays context sensitive help
//
//  Arguments:  [hwnd]   -- The parent window handle
//              [dwID]   -- The help context identifier
//
//  Returns:    TRUE if successful
//
//  History:    20-Sep-1997     dlee        Created
//              14-Sep-1998     KrishnaN    Handle only context sensitive help.
//                                          Regular help is handled by MMC help.
//                                          This fixes 214619.
//
//--------------------------------------------------------------------------

BOOL DisplayHelp( HWND hwnd, DWORD dwID )
{
    if (0 != dwID)  // Display context-sensitive help
        return DisplayHelp( hwnd, dwID, HELP_CONTEXT );
    else
        return TRUE;    // Don't display regular help
} //DisplayHelp

//+-------------------------------------------------------------------------
//
//  Function:   DisplayHelp
//
//  Synopsis:   Displays context sensitive help
//
//  Arguments:  [hwnd]   -- The parent window handle
//              [dwID]   -- The help context identifier
//
//  Returns:    TRUE if successful
//
//  History:    20-Sep-1997     dlee   Created
//
//--------------------------------------------------------------------------

BOOL DisplayHelp( HWND hwnd, DWORD dwID, UINT uCommand )
{
    WCHAR awc[ MAX_PATH ];
    const UINT cwcMax = sizeof awc / sizeof WCHAR;

    UINT cwc = GetSystemWindowsDirectory( awc, cwcMax );

    if ( 0 == cwc || cwc > cwcMax )
        return FALSE;

    if ( L'\\' != awc[ cwc-1] )
        wcscat( awc, L"\\" );

    // ixhelp.hlp is placed in %windir%\help
    wcscat( awc, L"help\\\\ixhelp.hlp" );

    return WinHelp( hwnd, awc, uCommand, dwID );
} //DisplayHelp


//+-------------------------------------------------------------------------
//
//  Function:   DisplayPopupHelp
//
//  Synopsis:   Displays context sensitive help as a popup
//
//  Arguments:  [hwnd]   -- The parent window handle
//              [dwID]   -- The help context identifier
//
//  Returns:    TRUE if successful
//
//  History:    11-May-1998     KrishnaN   Created
//
//--------------------------------------------------------------------------

BOOL DisplayPopupHelp( HWND hwnd, DWORD dwHelpType )
{
    return DisplayHelp( hwnd, (DWORD) (DWORD_PTR) aIds, dwHelpType);
} //DisplayPopupHelp


SCODE MakeOLESTR(LPOLESTR *lpBuffer, WCHAR const * pwszText)
{
    if (0 == lpBuffer)
        return E_INVALIDARG;

    ULONG uLen = wcslen(pwszText);
    uLen++;  // string terminator
    uLen = sizeof(WCHAR) * uLen;

    *lpBuffer = (LPOLESTR)CoTaskMemAlloc(uLen);

    if (*lpBuffer)
    {
        RtlCopyMemory(*lpBuffer, pwszText, uLen);
        return S_OK;
    }
    else
        return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::MaybeEnableCI, private
//
//  Synopsis:   Prompt user to set service to automatic start
//
//  Arguments:  [MachineAdmin] -- Machine administration object
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

void CCISnapinData::MaybeEnableCI( CMachineAdmin & MachineAdmin )
{
    if ( _Catalogs.IsLocalMachine() && !_fTriedEnable )
    {
        //
        // Have we tried before?
        //

        if ( MachineAdmin.IsCIEnabled() )
        {
            _fTriedEnable = TRUE;
        }
        else
        {
            WCHAR wcTemp[ (sizeof(wszSnapinPath) + sizeof(wszCISnapin)) / sizeof(WCHAR) + 1];
            wcscpy( wcTemp, wszSnapinPath );
            wcscat( wcTemp, wszCISnapin );

            CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcTemp );
            BOOL fTry = FALSE;

            if ( reg.Ok() )
            {
                DWORD dwVal;
                BOOL fOk = reg.Get( wszTriedEnable, dwVal );

                if ( fOk )
                {
                    fTry = (0 == dwVal);
                }
                else
                {
                    if ( reg.GetLastError() == ERROR_FILE_NOT_FOUND )
                        fTry = TRUE;
                }
            }

            if ( fTry )
            {
                int iResult;

                SCODE sc = _pFrame->MessageBox( STRINGRESOURCE( srMsgEnableCI ),
                                                STRINGRESOURCE( srMsgEnableCITitle ),
                                                MB_YESNO | /* MB_HELP | */
                                                  MB_ICONQUESTION | MB_DEFBUTTON1 |
                                                  MB_APPLMODAL,
                                                &iResult );

                if ( SUCCEEDED(sc) )
                {
                    switch ( iResult )
                    {
                    case IDYES:
                        MachineAdmin.EnableCI();
                        break;

                    default:
                        break;
                    }

                    Win4Assert( reg.Ok() );
                    reg.Set( wszTriedEnable, 1 );
                    _fTriedEnable = TRUE;
                }
            }
            else
                _fTriedEnable = TRUE;
        }
    }
}

void CCISnapinData::SetButtonState( int idCommand, MMC_BUTTON_STATE nState, BOOL bState )
{
    for ( CCISnapin * pCurrent = _pChild;
          0 != pCurrent;
          pCurrent = pCurrent->Next() )
    {
        if ( !pCurrent->_xToolbar.IsNull() )
            pCurrent->_xToolbar->SetButtonState( idCommand, nState, bState );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   StartMenu
//
//  Synopsis:   Sets context menu for service started state.
//
//  Arguments:  [piCallback] -- Context menu callback routine
//              [fTop]       -- TRUE if menu items should be on top of list
//                              in addition to under Task section.
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE StartMenu( IContextMenuCallback * piCallback, BOOL fTop )
{
    aContextMenus[comidStartCI].fFlags =
    aContextMenus[comidStartCITop].fFlags = MF_GRAYED;
    aContextMenus[comidStopCI].fFlags  =
    aContextMenus[comidStopCITop].fFlags = MF_ENABLED;
    aContextMenus[comidPauseCI].fFlags  =
    aContextMenus[comidPauseCITop].fFlags = MF_ENABLED;

    return SetStartStopMenu( piCallback, fTop );
}

//+-------------------------------------------------------------------------
//
//  Function:   StopMenu
//
//  Synopsis:   Sets context menu for service stopped state.
//
//  Arguments:  [piCallback] -- Context menu callback routine
//              [fTop]       -- TRUE if menu items should be on top of list
//                              in addition to under Task section.
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE StopMenu( IContextMenuCallback * piCallback, BOOL fTop )
{
    aContextMenus[comidStartCI].fFlags    =
    aContextMenus[comidStartCITop].fFlags = MF_ENABLED;
    aContextMenus[comidStopCI].fFlags    =
    aContextMenus[comidStopCITop].fFlags = MF_GRAYED;
    aContextMenus[comidPauseCI].fFlags  =
    aContextMenus[comidPauseCITop].fFlags = MF_GRAYED;

    return SetStartStopMenu( piCallback, fTop );
}

//+-------------------------------------------------------------------------
//
//  Function:   PauseMenu
//
//  Synopsis:   Sets context menu for service paused state.
//
//  Arguments:  [piCallback] -- Context menu callback routine
//              [fTop]       -- TRUE if menu items should be on top of list
//                              in addition to under Task section.
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE PauseMenu( IContextMenuCallback * piCallback, BOOL fTop )
{
    aContextMenus[comidStartCI].fFlags =
    aContextMenus[comidStartCITop].fFlags = MF_ENABLED;
    aContextMenus[comidStopCI].fFlags  =
    aContextMenus[comidStopCITop].fFlags = MF_ENABLED;
    aContextMenus[comidPauseCI].fFlags  =
    aContextMenus[comidPauseCITop].fFlags = MF_GRAYED;

    return SetStartStopMenu( piCallback, fTop );
}

//+-------------------------------------------------------------------------
//
//  Function:   DisabledMenu
//
//  Synopsis:   Disables start/stop/pause menu items
//
//  Arguments:  [piCallback] -- Context menu callback routine
//              [fTop]       -- TRUE if menu items should be on top of list
//                              in addition to under Task section.
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE DisabledMenu( IContextMenuCallback * piCallback, BOOL fTop )
{
    aContextMenus[comidStartCI].fFlags =
    aContextMenus[comidStartCITop].fFlags = MF_GRAYED;
    aContextMenus[comidStopCI].fFlags  =
    aContextMenus[comidStopCITop].fFlags = MF_GRAYED;
    aContextMenus[comidPauseCI].fFlags  =
    aContextMenus[comidPauseCITop].fFlags = MF_GRAYED;

    return SetStartStopMenu( piCallback, fTop );
}

//+-------------------------------------------------------------------------
//
//  Function:   SetStartStopMenu, private
//
//  Synopsis:   Worker routine to call menu callback and set menu items.
//
//  Arguments:  [piCallback] -- Context menu callback routine
//              [fTop]       -- TRUE if menu items should be on top of list
//                              in addition to under Task section.
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE SetStartStopMenu( IContextMenuCallback * piCallback, BOOL fTop )
{
    SCODE sc = S_OK;

    if (SUCCEEDED(sc) && fTop)
        piCallback->AddItem( &aContextMenus[comidStartCITop] );

    if (SUCCEEDED(sc) && fTop)
        sc = piCallback->AddItem( &aContextMenus[comidStopCITop] );

    if (SUCCEEDED(sc) && fTop)
        sc = piCallback->AddItem( &aContextMenus[comidPauseCITop] );

    if (SUCCEEDED(sc))
        sc = piCallback->AddItem( &aContextMenus[comidStartCI] );

    if (SUCCEEDED(sc))
        sc = piCallback->AddItem( &aContextMenus[comidStopCI] );

    if (SUCCEEDED(sc))
        sc = piCallback->AddItem( &aContextMenus[comidPauseCI] );

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\cipt\cipt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       cipt.cxx
//
//  Contents:   Pipe tracing
//
//  History:    21 Nov 1997     DLee    Created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>

STDAPI Before(
    HANDLE  hPipe,
    ULONG   cbWrite,
    void *  pvWrite,
    ULONG & rcbWritten,
    void *& rpvWritten )
{
    rcbWritten = cbWrite;
    rpvWritten = pvWrite;

    printf( "before\n" );

    return S_OK;
} //Before

STDAPI After(
    HANDLE hPipe,
    ULONG  cbWrite,
    void * pvWrite,
    ULONG  cbWritten,
    void * pvWritten,
    ULONG  cbRead,
    void * pvRead )
{
    printf( "after\n" );

    return S_OK;
} //After

STDAPI ServerBefore(
    HANDLE  hPipe,
    ULONG   cbWrite,
    void *  pvWrite,
    ULONG & rcbWritten,
    void *& rpvWritten )
{
    rcbWritten = cbWrite;
    rpvWritten = pvWrite;

    printf( "server before\n" );

    return S_OK;
} //ServerBefore

STDAPI ServerAfter(
    HANDLE hPipe,
    ULONG  cbWrite,
    void * pvWrite,
    ULONG  cbWritten,
    void * pvWritten )
{
    printf( "server after\n" );

    return S_OK;
} //ServerAfter

STDAPI ServerRead(
    HANDLE hPipe,
    ULONG  cbRead,
    void * pvRead )
{
    printf( "server read\n" );

    return S_OK;
} //ServerRead

extern "C"
{
BOOL APIENTRY DllInit(HANDLE hInst, DWORD fdwReason, LPVOID lpReserved)
{
    return TRUE;
} //DllInit
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\cxxflt\cxx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       CXX.CXX
//
//  Contents:   C and C++ Filter
//
//  Classes:    CxxFilter
//
//  History:    26-Jun-92   BartoszM    Created
//              17-Oct-94   BartoszM    Rewrote
//
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::CxxScanner, public
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

CxxScanner::CxxScanner ()
        : _pStream(0),
          _fIgnorePreamble(FALSE),
          _fScanningPrepro(FALSE),
          _fIdFound(FALSE),
          _cLines( 0 )
{
    _buf[0] = L'\0';
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::Init, public
//
//  Arguments:  [pStream] -- stream for text
//
//  History:    24-Nov-93  AmyA            Created
//
//----------------------------------------------------------------------------

void CxxScanner::Init ( CFilterTextStream * pStream )
{
    _pStream = pStream;
    // Position scanner on a token
    Accept();
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::NextToken, public
//
//  Arguments:  [c] -- lookahead character
//
//  Returns:    Recognized token
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

CToken CxxScanner::NextToken( int c )
{
    BOOL fFirstTime = TRUE;

    // Loop until a token is recognized
    for(;;)
    {
        switch (c)
        {
        case -1:  // UNICODE EOF
            _token = tEnd;
            return _token;

        case L'\n':
            _cLines++;
            _fScanningPrepro = FALSE;
            c = _pStream->GetChar();
            break;

        case L'{':
            _token = tLBrace;
            return _token;

        case L'}':
            _token = tRBrace;
            return _token;

        case L';':
            _token = tSemi;
            return _token;

        case L',':
            if ( _fIgnorePreamble )
            {
                // skip comma in the preamble
                c = _pStream->GetChar();
                break;
            }
            _token = tComma;
            return _token;

        case L'*':
            if ( _fIgnorePreamble )
            {
                // skip star in the preamble
                c = _pStream->GetChar();
                break;
            }
            _token = tStar;
            return _token;

        case L'#':  // not a token!
            // consume preprocessor command
            _fScanningPrepro = TRUE;
            c = _pStream->GetChar();
            break;

        case L'(':
            if ( _fIgnorePreamble )
            {
                // skip parentheses in the preamble
                c = _pStream->GetChar();
                break;
            }
            _token = tLParen;
            return _token;

        case L')':
            if ( _fIgnorePreamble )
            {
                // skip parentheses in the preamble
                c = _pStream->GetChar();
                break;
            }
            _token = tRParen;
            return _token;

        case L':':
            c = _pStream->GetChar();
            // ignore colons in the preamble
            if ( !_fIgnorePreamble && c == L':')
            {
               _token = tDoubleColon;
               return _token;
            }
            break;

        case L'/':  // not a token!
            // consume comment
            c = EatComment();
            break;

        case L'"':  // not a token!
            // consume string literal
            c = EatString();
            break;

        case L'\'':  // not a token!
            // consume character literal
            c = EatCharLiteral();
            break;

        default:

            // We don't really care about indentifiers.
            // We store them in the buffer so that when
            // we recognize a real token like :: or (
            // we can retrieve them.
            // Look out for 'class' 'struct' and 'union' though.

            if ( iswalpha((wint_t)c) || (c == L'_') || (c == L'~') )
            {
                _fIdFound = TRUE;
                
                // in preamble skip names except for the first
                // one, which is the name of the procedure

                if ( _fIgnorePreamble && !fFirstTime )
                {
                    c = SkipName(c);
                    continue;
                }
                else
                {
                    c = LoadName (c);
                    fFirstTime = FALSE;
                }

                if (!_fIgnorePreamble)
                {
                    // look for class/struct/union keywords

                    if ( wcscmp(_buf, L"class" ) == 0 )
                    {
                        _token = tClass;
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"struct") == 0 )
                    {
                        _token = tStruct;
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"union" ) == 0 )
                    {
                        _token = tUnion;
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"interface" ) == 0 )
                    {
                        _token = tInterface;
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"typedef" ) == 0 )
                    {
                        _token = tTypedef;
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"enum" ) == 0 )
                    {
                        _token = tEnum;
                        return _token;
                    }
                }

                if ( _fScanningPrepro )
                {
                    if ( wcscmp(_buf, L"define" ) == 0 )
                    {
                        _token = tDefine;
                        c = LoadName(c);
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"include" ) == 0 )
                    {
                        _token = tInclude;
                        c = LoadIncludeFileName(c);
                        return _token;
                    }
                    else
                    {
                        c = EatPrepro();
                        _fScanningPrepro = FALSE;
                    }
                }
            }
            else // not recognized, continue scanning
            {
                c = _pStream->GetChar();
            }
            break;
        }   // end of switch
    }   // end of infinite loop

    return _token;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::SkipName, public
//
//  Returns:    Next character after identifier
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::SkipName(int c)
{
   int i = 0;

   do
   {
      c = _pStream->GetChar();
      i++;
   }
   while ( (iswalnum((wint_t)c) || (c == L'_')) && (i < MAXIDENTIFIER) );

   return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::LoadName, public
//
//  Synopsis:   Scans and copies identifier into scanner's buffer
//
//  Arguments:  [c] -- GetChar character
//
//  Returns:    Next character after identifier
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::LoadName(int c)
{
   WCHAR * pCur = _buf;
   _pStream->GetRegion ( _region, -1, 0 );
   int i = 0;
   do
   {
      _buf[i++] = (WCHAR)c;
      c = _pStream->GetChar();
   }
   while ( (iswalnum((wint_t)c) || (c == L'_')) && (i < MAXIDENTIFIER));

   _region.cwcExtent = i;
   // c is not a symbol character

   _buf[i] = L'\0';

   //DbgPrint("LoadName: =================>  %ws\n", _buf);
   
   return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::LoadIncludeFileName, public
//
//  Synopsis:   Scans and copies a file name following a
//              #include statement to internal buffer
//              If a path exists, it is ignored.
//              A '.' is converted to '_' because searching an id
//              with a '.' does not seem to work with ci.
//              For example, 
//              #include <\foo\bar\fname.h>  --> fname_h
//
//  Arguments:  [c] -- GetChar character
//
//  Returns:    Next character after the #include stmt
//
//  History:    10-June-2000 kumarp        Created
//
//----------------------------------------------------------------------------

int CxxScanner::LoadIncludeFileName(int c)
{
   WCHAR * pCur = _buf;
   int i = 0;

   // skip chars preceeding the file name
   do
   {
      c = _pStream->GetChar();       
   }
   while ((c == L'\t') || (c == L' ') || (c == L'"') || (c == L'<'));
       
   _pStream->GetRegion ( _region, -1, 0 );

   do
   {
      _buf[i++] = (WCHAR)c;
      if ((c == L'\\') || (c == L'/'))
      {
          // ignore path
          i = 0;
          _pStream->GetRegion ( _region, 0, 0 );
      }

      c = _pStream->GetChar();
//       if (c == L'.')
//       {
//           c = L'_';
//       }
   }
   while ((iswalnum((wint_t)c) || ( c == L'.' ) ||
           (c == L'_') || (c == L'\\') || (c == L'/')) &&
          (i < MAXIDENTIFIER));
   
   _region.cwcExtent = i;
   _buf[i] = L'\0';

   c = EatPrepro();

   return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::EatComment, public
//
//  Synopsis:   Eats comments
//
//  Returns:    First non-comment character
//
//  Requires:   Leading '/' found and scanned
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::EatComment()
{
   int c = _pStream->GetChar();

    if ( c == L'*')
    {
        // C style comment
        while ((c = _pStream->GetChar()) != EOF )
        {
            while ( c == L'*' )
            {
                c = _pStream->GetChar();

                if ( c == EOF )
                   return EOF;

                if ( c == L'/' )
                   return _pStream->GetChar();

            }
        }
    }
    else if ( c == L'/' )
    {
        // C++ style comment
        while ((c = _pStream->GetChar()) != EOF )
        {
            if ( c == L'\n' )
                break;
        }
    }

    return c;
}
//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::EatString, public
//
//  Synopsis:   Eats string literal
//
//  Returns:    First non-string character
//
//  Requires:   Leading '"' found and scanned
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::EatString()
{
   int c;

   while ((c = _pStream->GetChar()) != EOF )
   {
      if ( c == L'"' )
      {
         c = _pStream->GetChar();
         break;
      }

      // eat backslashes
      // skip escaped quotes

      if ( c == L'\\' )
      {
         c = _pStream->GetChar();
         if ( c == EOF )
            return EOF;
      }
   }
   return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::EatCharLiteral, public
//
//  Synopsis:   Eats character literal
//
//  Returns:    First non-char-literal character
//
//  Requires:   Leading apostrophe ' found and scanned
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::EatCharLiteral()
{
    int c;

    while ((c = _pStream->GetChar()) != EOF )
    {
        if ( c == L'\'' )
        {
            c = _pStream->GetChar();
            break;
        }

        // eat backslashes
        // skip escaped quotes

        if ( c == L'\\' )
        {
            c = _pStream->GetChar();
            if ( c == EOF )
                return EOF;
        }
    }
    return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::EatPrepro, public
//
//  Synopsis:   Eats preprocessor commands. Possibly multi-line.
//
//  Returns:    First non-preprocessor character
//
//  Requires:   Leading # found and scanned
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::EatPrepro()
{
    int c;

    _fScanningPrepro = FALSE;

    while ((c = _pStream->GetChar()) != EOF && (c != L'\n'))
    {
        if ( c == L'\\' ) // skip whatever follows backslash
        {
            c = _pStream->GetChar();
            if (c == L'\r')
                c = _pStream->GetChar();
            if ( c == EOF )
                return EOF;
        }
    }
    return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxParser::CxxParser, public
//
//  Synopsis:   Initialize parser
//
//  Arguments:  [pStm] -- stream
//              [drep] -- data repository
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

CxxParser::CxxParser ()
        : _scope(0),
          _inClass(0),
          _fParsingTypedef(FALSE),
          _fParsingFnPtrTypedef(FALSE),
          _iVal(0)
{
    _strClass[0] = L'\0';
    _strName[0]  = L'\0';
    _attribute.ulKind = PRSPEC_LPWSTR;
    _attribute.lpwstr = PROP_CLASS;

    _psVal[Function].ulKind = PRSPEC_LPWSTR;
    _psVal[Function].lpwstr = PROP_FUNC;

    _psVal[Class].ulKind = PRSPEC_LPWSTR;
    _psVal[Class].lpwstr = PROP_CLASS;

    _psVal[Lines].ulKind = PRSPEC_LPWSTR;
    _psVal[Lines].lpwstr = PROP_LINES;

    _aVal[Function] = 0;
    _aVal[Class]    = 0;
    _aVal[Lines]    = 0;
}

CxxParser::~CxxParser()
{
    delete _aVal[Function];
    delete _aVal[Class];
    delete _aVal[Lines];
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxParser::Init, public
//
//  Synopsis:   Initialize parser
//
//  Arguments:  [pStream] -- stream
//
//  History:    24-Nov-93  AmyA            Created
//
//----------------------------------------------------------------------------

void CxxParser::Init ( CFilterTextStream * pStream )
{
    _scan.Init(pStream);
    _token = _scan.Token();
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxParser::Parse, public
//
//  Synopsis:   Parse the file
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

BOOL CxxParser::Parse()
{
    _cwcCopiedClass = 0;
    _cwcCopiedName = 0;

    while ( _token != tEnd)
    {
        switch ( _token )
        {
        case tTypedef:
            if ( !_fParsingTypedef )
            {
                _fParsingTypedef = TRUE;
                _typedefScope = _scope;
            }
            _token = _scan.Accept();
            break;

        case tSemi:
            if ( _fParsingTypedef && ( _scope == _typedefScope ))
            {
                ASSERT(_fParsingFnPtrTypedef == FALSE);
                SetName();
                //DbgPrint("tSemi: name: %ws, scope: %d\n", _strName, _scope);
                PutFunction();
                _fParsingTypedef = FALSE;
                _token = _scan.Accept();
                return TRUE;
            }
            _token = _scan.Accept();
            break;

        case tComma:
            if ( _fParsingTypedef && ( _scope == _typedefScope ))
            {
                ASSERT(_fParsingFnPtrTypedef == FALSE);
                SetName();
                //DbgPrint("tComma: name: %ws, scope: %d\n", _strName, _scope);
                PutFunction();
                _token = _scan.Accept();
                return TRUE;
            }
            _token = _scan.Accept();
            break;

        case tEnum:
            //DbgPrint("tEnum\n");
            //_scan.IgnorePreamble(TRUE);
            _token = _scan.Accept();
            //_scan.IgnorePreamble(FALSE);

            if ( _token == tLBrace )
            {
                // Good, we're inside a enum definition

                _scope++;
                SetName();
                //DbgPrint("tEnum: %ws\n", _strName);
                PutFunction();
                _token = _scan.Accept();
                return TRUE;
            }
            // otherwise it was a false alarm
            break;
            
        case tClass:
        case tStruct:
        case tUnion:
        case tInterface:

            // We have to recognize stuff like this:
            // class FOO : public bar:a, private b {
            // -----                               --
            // text between 'class' and left brace is
            // a preamble that the scanner will skip
            // If it's only a forward declaration, we
            // will stop at a semicolon and ignore the
            // whole business.

#if CIDBG == 1
            _classToken = _token;
#endif // CIDBG == 1

            // scan through stuff like
            // : public foo, private bar

            _scan.IgnorePreamble(TRUE);
            _token = _scan.Accept();
            _scan.IgnorePreamble(FALSE);

            // Ignore embedded classes
            if ( _inClass == 0 )
               SetClass();     // record class name for later

            if ( _token == tLBrace )
            {
                // Good, we're inside a class definition

                _inClass++;
                _scope++;
                PutClass ();
                _token = _scan.Accept();
                return TRUE;
            }
            // otherwise it was a false alarm

            break;

        case tDoubleColon:

            // Here we deal with constructs like
            // FOO::FOO ( int x ) : bar(state::ok), (true) {
            //    --    -                                  --
            // Text between left paren and left brace is preamble
            // and the scanner skips it. If we hit a semicolon
            // rather than left brace, we ignore the whole
            // construct (it was an invocation or something)

            SetClass();     // record class name just in case
            _token = _scan.Accept();
            if ( _token == tLParen )
            {
                SetName();  // record method name just in case

                _scan.IgnorePreamble(TRUE);
                _token = _scan.Accept();
                _scan.IgnorePreamble(FALSE);

                if ( _token == tLBrace )
                {
                    // Yes, we have method definition
                    _scope++;
                    _token = _scan.Accept();
                    PutMethod();
                    return TRUE;
                }
                // otherwise it was a false alarm
            }
            break;

        case tLParen:
            if ( _fParsingTypedef && ( _scope == _typedefScope ))
            {
                //
                // at present we only support fn-ptr typedefs
                // of the following type:
                // 
                // typedef void (*FnPtr1) ( int i, float f );
                // 

                //SetName();
                //DbgPrint("tLParen: name: %ws, scope: %d\n", _strName, _scope);
                _scan.SetIdFound(FALSE);
                _token = _scan.Accept();
                if ( ( _token == tStar ) && !_scan.IdFound() )
                {
                    _fParsingFnPtrTypedef = TRUE;
                }
                else
                {
                    //PutFunction();
                    _fParsingTypedef      = FALSE;
                    _fParsingFnPtrTypedef = FALSE;
                }
                
                _token = _scan.Accept();
            }
            else
            {
                SetName(); // record procedure name just in case

                // It may be an inline constructor
                // skip argument list and constructor stuff like
                // : Parent(blah), member(blah)

                _scan.IgnorePreamble(TRUE);
                _token = _scan.Accept();
                _scan.IgnorePreamble(FALSE);

                if ( _token == tLBrace )
                {
                    // Yes, it's a definition

                    if ( _inClass )
                    {
                        // inline method definition inside class definition
                        _scope++;
                        _token = _scan.Accept();
                        PutInlineMethod();
                        return TRUE;
                    }
                    else if ( _scope == 0 )
                    {
                        // function definitions
                        // in outer scope

                        _scope++;
                        PutFunction();
                        _token = _scan.Accept();
                        return TRUE;
                    }
                    // else continue--false alarm
                }
            }
            break;

        case tRParen:
            if ( _fParsingFnPtrTypedef && ( _scope == _typedefScope ))
            {
                SetName();
                //DbgPrint("tRParen: name: %ws, scope: %d\n", _strName, _scope);
                PutFunction();
                _fParsingTypedef      = FALSE;
                _fParsingFnPtrTypedef = FALSE;
                _token = _scan.Accept();
                return TRUE;
            }
            _token = _scan.Accept();
            break;
                
        case tEnd:
            return FALSE;

        case tLBrace:
            // keep track of scope
            _scope++;
            _token = _scan.Accept();
            break;

        case tRBrace:
            // keep track of scope and (nested) class scope
            _scope--;
            if ( _inClass > _scope )
            {
               _inClass--;
            }
            _token = _scan.Accept();
            break;

        case tDefine:
            SetName();
            _regionName.cwcStart++;
            _regionName.cwcExtent--;
            PutFunction();
            _scan.EatPrepro();
            _token = _scan.Accept();
            return TRUE;

        case tInclude:
            SetName();
            PutFunction();
            _token = _scan.Accept();
            return TRUE;
                
        default:
            _token = _scan.Accept();
        }
    }

    if ( _aVal[Lines] == 0 )
    {
        _aVal[Lines] = new CPropVar;
        if ( 0 == _aVal[Lines] )
            THROW( CException( E_OUTOFMEMORY ) );
    }
    
    _aVal[Lines]->SetUI4( _scan.Lines() );

    return FALSE;   // we only end up here if _token == tEnd
}

void CxxParser::PutClass ()
{
    _tokenType = ttClass;
    _attribute.lpwstr = PROP_CLASS;
    _strName[0] = L'\0';

#if 0

    if ( _aVal[Class] == 0 )
    {
        _aVal[Class] = new CPropVar;
        if ( 0 == _aVal[Class] )
            THROW( CException( E_OUTOFMEMORY ) );
    }

    _aVal[Class]->SetLPWSTR( _strClass, _aVal[Class]->Count() );

#endif

    // PROP_CLASS, _strClass

    //DbgPrint("PutClass: class: %ws\n", _strClass);

#if CIDBG == 1
    if ( _classToken == tClass )
    {

        cxxDebugOut((DEB_ITRACE,"class %ws\n", _strClass ));
    }
    else if ( _classToken == tStruct )
    {

        cxxDebugOut((DEB_ITRACE, "struct %ws\n", _strClass ));
    }
    else if ( _classToken == tUnion )
    {

        cxxDebugOut((DEB_ITRACE, "union %ws\n", _strClass ));
    }
    else if ( _classToken == tInterface )
    {

        cxxDebugOut((DEB_ITRACE, "interface %ws\n", _strClass ));
    }
#endif // CIDBG == 1
}

void CxxParser::PutMethod ()
{
    _tokenType = ttMethod;
    _attribute.lpwstr = PROP_FUNC;

#if 0

    if ( _aVal[Function] == 0 )
    {
        _aVal[Function] = new CPropVar;
        if ( 0 == _aVal[Function] )
            THROW( CException( E_OUTOFMEMORY ) );
    }

    _aVal[Function]->SetLPWSTR( _strName, _aVal[Function]->Count() );

#endif

    cxxDebugOut((DEB_ITRACE, "%ws::%ws\n", _strClass, _strName ));
}

void CxxParser::PutInlineMethod ()
{
    _tokenType = ttInlineMethod;
    _attribute.lpwstr = PROP_FUNC;

#if 0

    if ( _aVal[Function] == 0 )
    {
        _aVal[Function] = new CPropVar;
        if ( 0 == _aVal[Function] )
            THROW( CException( E_OUTOFMEMORY ) );
    }

    _aVal[Function]->SetLPWSTR( _strName, _aVal[Function]->Count() );

#endif

    cxxDebugOut((DEB_ITRACE, "%ws::%ws\n", _strClass, _strName ));
}

void CxxParser::PutFunction ()
{
    _tokenType = ttFunction;
    _attribute.lpwstr = PROP_FUNC;
    _strClass[0] = L'\0';

#if 0
    if ( _aVal[Function] == 0 )
    {
        _aVal[Function] = new CPropVar;
        if ( 0 == _aVal[Function] )
            THROW( CException( E_OUTOFMEMORY ) );
    }

    _aVal[Function]->SetLPWSTR( _strName, _aVal[Function]->Count() );
#endif

    //DbgPrint("PutFunction: func: %ws\n", _strName);
    cxxDebugOut((DEB_ITRACE, "function %ws\n", _strName ));
}

void CxxParser::GetRegion ( FILTERREGION& region )
{
    switch (_tokenType)
    {
    case ttClass:
        region = _regionClass;
        break;
    case ttFunction:
    case ttInlineMethod:
    case ttMethod:
        region = _regionName;
        break;
    }
}

BOOL CxxParser::GetTokens ( ULONG * pcwcBuffer, WCHAR * awcBuffer )
{
    ULONG cwc = *pcwcBuffer;
    *pcwcBuffer = 0;

    if (_strClass[0] != L'\0')
    {
        // We have a class name

        WCHAR * strClass = _strClass + _cwcCopiedClass;

        ULONG cwcClass = wcslen( strClass );
        if ( cwcClass > cwc )
        {
            wcsncpy( awcBuffer, strClass, cwc );
            _cwcCopiedClass += cwc;
            return FALSE;
        }
        wcscpy( awcBuffer, strClass );
        *pcwcBuffer = cwcClass;
        _cwcCopiedClass += cwcClass;
        awcBuffer[(*pcwcBuffer)++] = L' ';
    }

    if (_strName[0] == L'\0')
    {
        // it was only a class name
        awcBuffer[*pcwcBuffer] = L'\0';
        return TRUE;
    }

    cwc -= *pcwcBuffer;
    WCHAR * awc = awcBuffer + *pcwcBuffer;
    WCHAR * strName = _strName + _cwcCopiedName;
    ULONG cwcName = wcslen( strName );

    if ( cwcName > cwc )
    {
        wcsncpy( awc, strName, cwc );
        _cwcCopiedName += cwc;
        return FALSE;
    }
    wcscpy( awc, strName );
    *pcwcBuffer += cwcName;
    _cwcCopiedName += cwcName;
    return TRUE;
}

BOOL CxxParser::GetValueAttribute( PROPSPEC & ps )
{
    for ( ; _iVal <= Lines && 0 == _aVal[_iVal];  _iVal++ )
        continue;

    if ( _iVal > Lines )
        return FALSE;
    else
    {
        ps = _psVal[_iVal];

        return TRUE;
    }
}

PROPVARIANT * CxxParser::GetValue()
{
    if ( _iVal > Lines )
        return 0;

    CPropVar * pTemp = _aVal[_iVal];
    _aVal[_iVal] = 0;
    _iVal++;

    return (PROPVARIANT *)(void *)pTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ci\isearch.h ===
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __isearch_h__
#define __isearch_h__

#ifndef __ISearchQueryHits_FWD_DEFINED__
#define __ISearchQueryHits_FWD_DEFINED__
typedef interface ISearchQueryHits ISearchQueryHits;
#endif  /* __ISearchQueryHits_FWD_DEFINED__ */

#ifndef __ISearchQueryHits_INTERFACE_DEFINED__
#define __ISearchQueryHits_INTERFACE_DEFINED__

/* interface ISearchQueryHits */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISearchQueryHits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ed8ce7e0-106c-11ce-84e2-00aa004b9986")
    ISearchQueryHits : public IUnknown
    {
    public:
        virtual SCODE STDMETHODCALLTYPE Init( 
            /* [in] */ IFilter __RPC_FAR *pflt,
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitMoniker( 
            /* [out][in] */ ULONG __RPC_FAR *pcMnk,
            /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitOffset( 
            /* [out][in] */ ULONG __RPC_FAR *pcRegion,
            /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ISearchQueryHitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchQueryHits __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchQueryHits __RPC_FAR * This);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [in] */ IFilter __RPC_FAR *pflt,
            /* [in] */ ULONG ulFlags);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *NextHitMoniker )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pcMnk,
            /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *NextHitOffset )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pcRegion,
            /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion);
        
        END_INTERFACE
    } ISearchQueryHitsVtbl;

    interface ISearchQueryHits
    {
        CONST_VTBL struct ISearchQueryHitsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchQueryHits_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchQueryHits_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ISearchQueryHits_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ISearchQueryHits_Init(This,pflt,ulFlags)        \
    (This)->lpVtbl -> Init(This,pflt,ulFlags)

#define ISearchQueryHits_NextHitMoniker(This,pcMnk,papMnk)      \
    (This)->lpVtbl -> NextHitMoniker(This,pcMnk,papMnk)

#define ISearchQueryHits_NextHitOffset(This,pcRegion,paRegion)  \
    (This)->lpVtbl -> NextHitOffset(This,pcRegion,paRegion)

#endif /* COBJMACROS */


#endif  /* C style interface */



SCODE STDMETHODCALLTYPE ISearchQueryHits_Init_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [in] */ IFilter __RPC_FAR *pflt,
    /* [in] */ ULONG ulFlags);


void __RPC_STUB ISearchQueryHits_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE ISearchQueryHits_NextHitMoniker_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pcMnk,
    /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk);


void __RPC_STUB ISearchQueryHits_NextHitMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE ISearchQueryHits_NextHitOffset_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pcRegion,
    /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion);


void __RPC_STUB ISearchQueryHits_NextHitOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISearchQueryHits_INTERFACE_DEFINED__ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\cxxflt\cxxflt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       CXXFLT.CXX
//
//  Contents:   C and Cxx Filter
//
//  History:    07-Oct-93   AmyA        Created
//
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop

extern "C" GUID CLSID_CxxIFilter;

GUID guidCPlusPlus = { 0x8DEE0300, \
                       0x16C2, 0x101B, \
                       0xB1, 0x21, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9 };

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::CxxIFilter, public
//
//  Synopsis:   Constructor
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

CxxIFilter::CxxIFilter()
        : _state(FilterDone),
          _ulLastTextChunkID(0),
          _ulChunkID(0),
          _pTextFilt(0),
          _pPersFile(0),
          _pPersStream(0),
          _cAttrib(0),
          _pAttrib(0),
          _pTextStream(0),
          _locale(0)         // the default locale
{
}

const FULLPROPSPEC fpsContents = { PSGUID_STORAGE, PRSPEC_PROPID, PID_STG_CONTENTS };

BOOL IsContents( FULLPROPSPEC const & fps )
{
   return ( !memcmp( &fps, &fpsContents, sizeof fpsContents ) );
} //IsContents

BOOL FPSMatch( FULLPROPSPEC const & fpsA, FULLPROPSPEC const & fpsB )
{
    if ( fpsA.guidPropSet != fpsB.guidPropSet )
        return FALSE;

    if ( fpsA.psProperty.ulKind != fpsB.psProperty.ulKind )
        return FALSE;

    if ( PRSPEC_PROPID == fpsA.psProperty.ulKind )
        return ( fpsA.psProperty.propid == fpsB.psProperty.propid );

    if ( PRSPEC_LPWSTR != fpsA.psProperty.ulKind )
        return FALSE;

    return ( !wcscmp( fpsA.psProperty.lpwstr,
                      fpsB.psProperty.lpwstr ) );
} //FPSMatch

void FPSCopy( FULLPROPSPEC & fpsTo, FULLPROPSPEC const & fpsFrom )
{
    fpsTo.guidPropSet = fpsFrom.guidPropSet;
    fpsTo.psProperty.ulKind = fpsFrom.psProperty.ulKind;

    if ( PRSPEC_PROPID == fpsFrom.psProperty.ulKind )
    {
        fpsTo.psProperty.propid = fpsFrom.psProperty.propid;
        return;
    }

    if ( PRSPEC_LPWSTR == fpsFrom.psProperty.ulKind )
    {
        unsigned cwc = 1 + wcslen( fpsFrom.psProperty.lpwstr );
        fpsTo.psProperty.lpwstr = (LPWSTR) CoTaskMemAlloc( cwc );
        wcscpy( fpsTo.psProperty.lpwstr, fpsFrom.psProperty.lpwstr );
    }
} //FPSCopy

void FPSFree( FULLPROPSPEC &fps )
{
    if ( ( PRSPEC_LPWSTR == fps.psProperty.ulKind ) &&
         ( 0 != fps.psProperty.lpwstr ) )
    {
        CoTaskMemFree( fps.psProperty.lpwstr );
        fps.psProperty.lpwstr = 0;
    }
} //FPSFree

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::~CxxIFilter, public
//
//  Synopsis:   Destructor
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

CxxIFilter::~CxxIFilter()
{
    delete [] _pAttrib;

    if ( _pTextFilt )
        _pTextFilt->Release();

    if ( _pPersFile )
        _pPersFile->Release();

    if ( _pPersStream )
        _pPersStream->Release();

    delete _pTextStream;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::Init, public
//
//  Synopsis:   Initializes instance of text filter
//
//  Arguments:  [grfFlags] -- flags for filter behavior
//              [cAttributes] -- number of attributes in array aAttributes
//              [aAttributes] -- array of attributes
//              [pfBulkyObject] -- indicates whether this object is a
//                                 bulky object
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::Init( ULONG grfFlags,
                                          ULONG cAttributes,
                                          FULLPROPSPEC const * aAttributes,
                                          ULONG * pFlags )
{
    CTranslateSystemExceptions translate;

    SCODE sc = S_OK;

    TRY
    {
        _ulLastTextChunkID = 0;
        _ulChunkID = 0;

        if( cAttributes > 0 )
        {
            if ( 0 == aAttributes )
                return E_INVALIDARG;

            _state = FilterProp;

            _cAttrib = cAttributes;
            if ( 0 != _pAttrib )
            {
                delete [] _pAttrib;
                _pAttrib = 0;
            }

            _pAttrib = new CFps [_cAttrib];

            for ( ULONG i = 0; i < cAttributes; i++ )
            {
                if ( _state != FilterContents && IsContents( aAttributes[i] ) )
                    _state = FilterContents;

                _pAttrib[i].Copy( aAttributes[i] );
            }
        }
        else if ( 0 == grfFlags || (grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES) )
        {
            _state = FilterContents;
        }
        else
        {
            _state = FilterDone;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    if ( FAILED( sc ) )
        return sc;

    return _pTextFilt->Init( 0,
                             1,
                             &fpsContents,
                             pFlags );
} //Init

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::GetChunk, public
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- for chunk information
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::GetChunk( STAT_CHUNK * pStat )
{
    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        if (_state == FilterNextProp)
        {
            _state = FilterProp;
        }
        //
        // All chunks of plain text come first.
        //

        if ( _state == FilterContents )
        {
            sc = _pTextFilt->GetChunk( pStat );

            if ( SUCCEEDED(sc) )
            {
                pStat->locale = 0;  // use the default word breaker
                _locale = 0;
                _ulLastTextChunkID = pStat->idChunk;
            }
            else if ( sc == FILTER_E_END_OF_CHUNKS )
            {
                _ulChunkID = _ulLastTextChunkID;

                ULONG Flags;

                sc = _pTextFilt->Init( 0,
                                       1,
                                       &fpsContents,
                                       &Flags );

                if ( SUCCEEDED(sc) )
                {
                    delete _pTextStream;
                    _pTextStream = new CFilterTextStream (_pTextFilt);
                    if (SUCCEEDED (_pTextStream->GetStatus()))
                    {
                        _cxxParse.Init( _pTextStream );
                        _state = FilterProp;
                    }
                    else
                        _state = FilterDone;
                }
                else
                    _state = FilterDone;
            }
        }

        if ( _state == FilterProp && SUCCEEDED(sc) )
        {
            while ( TRUE )
            {
                if (_cxxParse.Parse())
                {
                    pStat->attribute.guidPropSet = guidCPlusPlus;
                    pStat->attribute.psProperty = _cxxParse.GetAttribute();

                    for ( unsigned i = 0; i < _cAttrib; i++ )
                        if ( _pAttrib[i].IsMatch( pStat->attribute ) )
                            break;

                    if ( _cAttrib == 0 || i < _cAttrib )     // Property should be returned
                    {
                        pStat->idChunk = ++_ulChunkID;
                        pStat->breakType = CHUNK_EOS;
                        pStat->flags = CHUNK_TEXT;
                        pStat->locale = _locale;

                        FILTERREGION regionSource;
                        // what's the source of this derived property?
                        _cxxParse.GetRegion ( regionSource );
                        pStat->idChunkSource = regionSource.idChunk;
                        pStat->cwcStartSource = regionSource.cwcStart;
                        pStat->cwcLenSource = regionSource.cwcExtent;

                        sc = S_OK;
                        break;
                    }
                }
                else
                {
                    _state = FilterValue;
                    break;
                }
            }
        }

        if ( _state == FilterNextValue )
        {
            _cxxParse.SkipValue();
            _state = FilterValue;
        }

        if ( _state == FilterValue )
        {
            while ( TRUE )
            {
                if ( _cxxParse.GetValueAttribute( pStat->attribute.psProperty ) )
                {
                    pStat->attribute.guidPropSet = guidCPlusPlus;

                    for ( unsigned i = 0; i < _cAttrib; i++ )
                        if ( _pAttrib[i].IsMatch( pStat->attribute ) )
                            break;

                    if ( _cAttrib == 0 || i < _cAttrib )     // Property should be returned
                    {
                        pStat->flags = CHUNK_VALUE;
                        pStat->locale = _locale;

                        _state = FilterNextValue;
                        sc = S_OK;
                        break;
                    }
                    else
                        _cxxParse.SkipValue();
                }
                else
                {
                    _state = FilterDone;
                    break;
                }
            }
        }

        if (_state == FilterDone || !SUCCEEDED(sc))
        {
            sc = FILTER_E_END_OF_CHUNKS;
            _state = FilterDone;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::GetText, public
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcBuffer] -- count of characters in buffer
//              [awcBuffer] -- buffer for text
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::GetText( ULONG * pcwcBuffer,
                                             WCHAR * awcBuffer )
{
    if ( _state == FilterValue || _state == FilterNextValue )
        return FILTER_E_NO_TEXT;

    if ( _state == FilterContents )
    {
        return _pTextFilt->GetText( pcwcBuffer, awcBuffer );
    }
    else if ( _state == FilterProp )
    {

        if ( _cxxParse.GetTokens( pcwcBuffer, awcBuffer ))
        {
            _state = FilterNextProp;
            return FILTER_S_LAST_TEXT;
        }
        else
            return S_OK;
    }
    else if ( _state == FilterNextProp )
    {
        return FILTER_E_NO_MORE_TEXT;
    }
    else
    {
        Win4Assert ( _state == FilterDone );
        return FILTER_E_NO_MORE_TEXT;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::GetValue, public
//
//  Synopsis:   Not implemented for the text filter
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::GetValue( PROPVARIANT ** ppPropValue )
{
    if ( _state == FilterContents )
        return _pTextFilt->GetValue( ppPropValue );

    if ( _state == FilterDone )
        return FILTER_E_NO_MORE_VALUES;

    if ( _state != FilterNextValue )
        return FILTER_E_NO_VALUES;

    *ppPropValue = _cxxParse.GetValue();
    _state = FilterValue;

    if ( 0 == *ppPropValue )
        return FILTER_E_NO_MORE_VALUES;
    else
        return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::BindRegion, public
//
//  Synopsis:   Creates moniker or other interface for text indicated
//
//  Arguments:  [origPos] -- location of text
//              [riid]    -- Interface Id
//              [ppunk]   -- returned interface
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::BindRegion( FILTERREGION origPos,
                                                REFIID riid,
                                                void ** ppunk )
{
    return _pTextFilt->BindRegion( origPos, riid, ppunk );
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::GetClassID( CLSID * pClassID )
{
    *pClassID = CLSID_CxxIFilter;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since this class is read-only.
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::IsDirty()
{
    return S_FALSE; // Since the filter is read-only, there will never be
                    // changes to the file.
}

typedef HRESULT (__stdcall * PFnLoadTextFilter)( WCHAR const * pwcPath,
                                                 IFilter ** ppIFilter );

PFnLoadTextFilter g_pLoadTextFilter = 0;

SCODE MyLoadTextFilter( WCHAR const *pwc, IFilter **ppFilter )
{
    if ( 0 == g_pLoadTextFilter )
    {
        // Dummy call to CIState to force query.dll to be always loaded

        CIState( 0, 0, 0 );

        g_pLoadTextFilter = (PFnLoadTextFilter) GetProcAddress( GetModuleHandle( L"query.dll" ), "LoadTextFilter" );

        if ( 0 == g_pLoadTextFilter )
            return HRESULT_FROM_WIN32( GetLastError() );
    }

    return g_pLoadTextFilter( pwc, ppFilter );
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::Load, public
//
//  Synopsis:   Loads the indicated file
//
//  Arguments:  [pszFileName] -- the file name
//              [dwMode]      -- the mode to load the file in
//
//  History:    07-Oct-93   AmyA           Created.
//
//  Notes:      dwMode must be either 0 or STGM_READ.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::Load(LPCWSTR pszFileName, DWORD dwMode)
{
    if ( 0 != _pTextFilt )
    {
        _pTextFilt->Release();
        _pTextFilt = 0;
    }

    if ( 0 != _pPersFile )
    {
        _pPersFile->Release();
        _pPersFile = 0;
    }

    if ( 0 != _pPersStream )
    {
        _pPersStream->Release();
        _pPersStream = 0;
    }

    SCODE sc = MyLoadTextFilter( pszFileName, &_pTextFilt );

    if ( SUCCEEDED(sc) )
    {
        // Load file

        sc = _pTextFilt->QueryInterface( IID_IPersistFile, (void **) &_pPersFile );

        if ( SUCCEEDED(sc) )
        {
            sc = _pPersFile->Load( pszFileName, dwMode );
        }
        else
        {
            _pTextFilt->Release();
            _pTextFilt = 0;
        }
    }

    return sc;
} //Load

SCODE STDMETHODCALLTYPE CxxIFilter::Load( IStream * pStm )
{
    SCODE sc = MyLoadTextFilter( 0, &_pTextFilt );

    if ( SUCCEEDED(sc) )
    {
        // Load file

        sc = _pTextFilt->QueryInterface( IID_IPersistStream, (void **) &_pPersStream );

        if ( SUCCEEDED(sc) )
        {
            sc = _pPersStream->Load( pStm );
        }
        else
        {
            _pTextFilt->Release();
            _pTextFilt = 0;
        }
    }

    return sc;
} //Load

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::Save(LPCWSTR pszFileName, BOOL fRemember)
{
    return E_FAIL;  // cannot be saved since it is read-only
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::SaveCompleted, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::SaveCompleted(LPCWSTR pszFileName)
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::GetCurFile, public
//
//  Synopsis:   Returns a copy of the current file name
//
//  Arguments:  [ppszFileName] -- where the copied string is returned.
//
//  History:    09-Aug-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::GetCurFile(LPWSTR * ppszFileName)
{
    return _pPersFile->GetCurFile( ppszFileName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ci\disptree.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.  All Rights Reserved.
//
// FILE:     disptree.cxx
//
// PURPOSE:  Displays a command tree, for debugging.
//
// PLATFORM: Windows 2000
//
//--------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <windows.h>

#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>

//+-------------------------------------------------------------------------
//
//  Function:   PrintVectorItems
//
//  Synopsis:   Prints items in a PROPVARIANT vector
//
//  Arguments:  [pVal]  - The array of values
//              [cVals] - The count of values
//              [pcFmt] - The format string
//
//--------------------------------------------------------------------------

template<class T> void PrintVectorItems(
    T *     pVal,
    ULONG   cVals,
    char *  pcFmt )
{
    printf( "{ " );

    for( ULONG iVal = 0; iVal < cVals; iVal++ )
    {
        if ( 0 != iVal )
            printf( "," );
        printf( pcFmt, *pVal++ );
    }

    printf( " }" );
} //PrintVectorItems

//+-------------------------------------------------------------------------
//
//  Function:   DisplayVariant
//
//  Synopsis:   Displays a PROPVARIANT.  This is not a complete
//              implementation; many VT_ types are not complete.
//
//  Arguments:  [pNode]  - The command tree node
//              [iLevel] - The 0-based level in the tree
//
//--------------------------------------------------------------------------

void DisplayVariant( PROPVARIANT * pVar )
{
    if ( 0 == pVar )
    {
        printf( "NULL" );
        return;
    }

    PROPVARIANT & v = *pVar;

    switch ( v.vt )
    {
        case VT_I4 : printf( "VT_I4 %d", v.lVal ); break;
        case VT_UI1 : printf( "VT_UI1 %d", v.bVal ); break;
        case VT_I2 : printf( "VT_I2 %d", v.iVal ); break;
        case VT_R4 : printf( "VT_R4 %f", v.fltVal ); break;
        case VT_R8 : printf( "VT_R8 %lf", v.dblVal ); break;
        case VT_BOOL : printf( "VT_BOOL %d", v.boolVal ); break;
        case VT_ERROR : printf( "VT_ERROR %#x", v.scode ); break;
        case VT_CY :
        {
            double dbl;
            VarR8FromCy( pVar->cyVal, &dbl );

            printf( "VT_CY %lf", dbl );
            break;
        }
        case VT_DATE : printf( "VT_DATE " ); break;
        case VT_FILETIME : printf( "VT_FILETIME %#I64x ", v.filetime ); break;
        case VT_BSTR : printf( "VT_BSTR '%ws'", v.bstrVal ); break;
        case VT_UNKNOWN : printf( "VT_UNKNOWN " ); break;
        case VT_DISPATCH : printf( "VT_DISPATCH " ); break;
        case VT_BYREF|VT_UI1 : printf( "VT_BYREF|VT_UI1 " ); break;
        case VT_BYREF|VT_I2 : printf( "VT_BYREF|VT_I2 " ); break;
        case VT_BYREF|VT_I4 : printf( "VT_BYREF|VT_I4 " ); break;
        case VT_BYREF|VT_R4 : printf( "VT_BYREF|VT_R4 " ); break;
        case VT_BYREF|VT_R8 : printf( "VT_BYREF|VT_R8 " ); break;
        case VT_BYREF|VT_BOOL : printf( "VT_BYREF|VT_BOOL " ); break;
        case VT_BYREF|VT_ERROR : printf( "VT_BYREF|VT_ERROR " ); break;
        case VT_BYREF|VT_CY : printf( "VT_BYREF|VT_CY " ); break;
        case VT_BYREF|VT_DATE : printf( "VT_BYREF|VT_DATE " ); break;
        case VT_BYREF|VT_BSTR : printf( "VT_BYREF|VT_BSTR " ); break;
        case VT_BYREF|VT_UNKNOWN : printf( "VT_BYREF|VT_UNKNOWN " ); break;
        case VT_BYREF|VT_DISPATCH : printf( "VT_BYREF|VT_DISPATCH " ); break;
        case VT_BYREF|VT_ARRAY : printf( "VT_BYREF|VT_ARRAY " ); break;
        case VT_BYREF|VT_VARIANT : printf( "VT_BYREF|VT_VARIANT " ); break;
        case VT_I1 : printf( "VT_I1 %d", v.bVal ); break;
        case VT_UI2 : printf( "VT_UI2 %u", v.uiVal ); break;
        case VT_UI4 : printf( "VT_UI4 %u", v.ulVal ); break;
        case VT_INT : printf( "VT_INT %d", v.lVal ); break;
        case VT_UINT : printf( "VT_UINT %u", v.ulVal ); break;
        case VT_BYREF|VT_DECIMAL : printf( "VT_BYREF|VT_DECIMAL " ); break;
        case VT_BYREF|VT_I1 : printf( "VT_BYREF|VT_I1 " ); break;
        case VT_BYREF|VT_UI2 : printf( "VT_BYREF|VT_UI2 " ); break;
        case VT_BYREF|VT_UI4 : printf( "VT_BYREF|VT_UI4 " ); break;
        case VT_BYREF|VT_INT : printf( "VT_BYREF|VT_INT " ); break;
        case VT_BYREF|VT_UINT : printf( "VT_BYREF|VT_UINT " ); break;
        case VT_LPSTR : printf( "VT_LPSTR '%s'", v.pszVal ); break;
        case VT_LPWSTR : printf( "VT_LPWSTR '%ws'", v.pwszVal ); break;
        case VT_I8 : printf( "VT_I8 %I64d", v.hVal ); break;
        case VT_UI8 : printf( "VT_I8 %I64u", v.hVal ); break;
        case VT_VECTOR | VT_I1:
            printf( "VT_VECTOR | VT_I1 " );
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I2:
            printf( "VT_VECTOR | VT_I2 " );
            PrintVectorItems( v.cai.pElems, v.cai.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I4:
            printf( "VT_VECTOR | VT_I4 " );
            PrintVectorItems( v.cal.pElems, v.cal.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I8:
            printf( "VT_VECTOR | VT_I8 " );
            PrintVectorItems( v.cah.pElems, v.cah.cElems, "%I64d" );
            break;
        case VT_VECTOR | VT_UI1:
            printf( "VT_VECTOR | VT_UI1 " );
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI2:
            printf( "VT_VECTOR | VT_UI2 " );
            PrintVectorItems( v.caui.pElems, v.caui.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI4:
            printf( "VT_VECTOR | VT_UI4 " );
            PrintVectorItems( v.caul.pElems, v.caul.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI8:
            printf( "VT_VECTOR | VT_UI8 " );
            PrintVectorItems( v.cauh.pElems, v.cauh.cElems, "%I64u" );
            break;
        case VT_VECTOR | VT_BSTR:
            printf( "VT_VECTOR | VT_BSTR " );
            PrintVectorItems( v.cabstr.pElems, v.cabstr.cElems, "%ws" );
            break;
        case VT_VECTOR | VT_LPSTR:
            printf( "VT_VECTOR | VT_LPSTR " );
            PrintVectorItems( v.calpstr.pElems, v.calpstr.cElems, "%s" );
            break;
        case VT_VECTOR | VT_LPWSTR:
            printf( "VT_VECTOR | VT_LPWSTR " );
            PrintVectorItems( v.calpwstr.pElems, v.calpwstr.cElems, "%ws" );
            break;
        case VT_VECTOR | VT_R4:
            printf( "VT_VECTOR | VT_R4 " );
            PrintVectorItems( v.caflt.pElems, v.caflt.cElems, "%f" );
            break;
        case VT_VECTOR | VT_R8:
            printf( "VT_VECTOR | VT_R8 " );
            PrintVectorItems( v.cadbl.pElems, v.cadbl.cElems, "%lf" );
            break;
        default : printf( "unknown vt %#x", v.vt );
    }
} //DisplayVariant

//+-------------------------------------------------------------------------
//
//  Function:   PrintSpace
//
//  Synopsis:   Prints white space.
//
//  Arguments:  [cPlaces] - Number of levels to print
//
//--------------------------------------------------------------------------

void PrintSpace( ULONG cPlaces )
{
    for( ULONG iPlace = 0; iPlace < cPlaces; iPlace++ )
        printf( "  " );
} //PrintSpace

//+-------------------------------------------------------------------------
//
//  Function:   DisplayCommandTree
//
//  Synopsis:   Displays the command tree, useful for debugging.  This is
//              not a complete implementation; many DBVALUEKINDs are not
//              complete.
//
//  Arguments:  [pNode]  - The command tree node
//              [iLevel] - The 0-based level in the tree
//
//--------------------------------------------------------------------------

void DisplayCommandTree(
    DBCOMMANDTREE * pNode,
    ULONG           iLevel )
{
    PrintSpace( iLevel );
    printf( "op: (%d) ", pNode->op );
    switch ( pNode->op )
    {
        case DBOP_scalar_constant : printf( "DBOP_scalar_constant" ); break;
        case DBOP_DEFAULT : printf( "DBOP_DEFAULT" ); break;
        case DBOP_NULL : printf( "DBOP_NULL" ); break;
        case DBOP_bookmark_name : printf( "DBOP_bookmark_name" ); break;
        case DBOP_catalog_name : printf( "DBOP_catalog_name" ); break;
        case DBOP_column_name : printf( "DBOP_column_name" ); break;
        case DBOP_schema_name : printf( "DBOP_schema_name" ); break;
        case DBOP_outall_name : printf( "DBOP_outall_name" ); break;
        case DBOP_qualifier_name : printf( "DBOP_qualifier_name" ); break;
        case DBOP_qualified_column_name : printf( "DBOP_qualified_column_name" ); break;
        case DBOP_table_name : printf( "DBOP_table_name" ); break;
        case DBOP_nested_table_name : printf( "DBOP_nested_table_name" ); break;
        case DBOP_nested_column_name : printf( "DBOP_nested_column_name" ); break;
        case DBOP_row : printf( "DBOP_row" ); break;
        case DBOP_table : printf( "DBOP_table" ); break;
        case DBOP_sort : printf( "DBOP_sort" ); break;
        case DBOP_distinct : printf( "DBOP_distinct" ); break;
        case DBOP_distinct_order_preserving : printf( "DBOP_distinct_order_preserving" ); break;
        case DBOP_alias : printf( "DBOP_alias" ); break;
        case DBOP_cross_join : printf( "DBOP_cross_join" ); break;
        case DBOP_union_join : printf( "DBOP_union_join" ); break;
        case DBOP_inner_join : printf( "DBOP_inner_join" ); break;
        case DBOP_left_semi_join : printf( "DBOP_left_semi_join" ); break;
        case DBOP_right_semi_join : printf( "DBOP_right_semi_join" ); break;
        case DBOP_left_anti_semi_join : printf( "DBOP_left_anti_semi_join" ); break;
        case DBOP_right_anti_semi_join : printf( "DBOP_right_anti_semi_join" ); break;
        case DBOP_left_outer_join : printf( "DBOP_left_outer_join" ); break;
        case DBOP_right_outer_join : printf( "DBOP_right_outer_join" ); break;
        case DBOP_full_outer_join : printf( "DBOP_full_outer_join" ); break;
        case DBOP_natural_join : printf( "DBOP_natural_join" ); break;
        case DBOP_natural_left_outer_join : printf( "DBOP_natural_left_outer_join" ); break;
        case DBOP_natural_right_outer_join : printf( "DBOP_natural_right_outer_join" ); break;
        case DBOP_natural_full_outer_join : printf( "DBOP_natural_full_outer_join" ); break;
        case DBOP_set_intersection : printf( "DBOP_set_intersection" ); break;
        case DBOP_set_union : printf( "DBOP_set_union" ); break;
        case DBOP_set_left_difference : printf( "DBOP_set_left_difference" ); break;
        case DBOP_set_right_difference : printf( "DBOP_set_right_difference" ); break;
        case DBOP_set_anti_difference : printf( "DBOP_set_anti_difference" ); break;
        case DBOP_bag_intersection : printf( "DBOP_bag_intersection" ); break;
        case DBOP_bag_union : printf( "DBOP_bag_union" ); break;
        case DBOP_bag_left_difference : printf( "DBOP_bag_left_difference" ); break;
        case DBOP_bag_right_difference : printf( "DBOP_bag_right_difference" ); break;
        case DBOP_bag_anti_difference : printf( "DBOP_bag_anti_difference" ); break;
        case DBOP_division : printf( "DBOP_division" ); break;
        case DBOP_relative_sampling : printf( "DBOP_relative_sampling" ); break;
        case DBOP_absolute_sampling : printf( "DBOP_absolute_sampling" ); break;
        case DBOP_transitive_closure : printf( "DBOP_transitive_closure" ); break;
        case DBOP_recursive_union : printf( "DBOP_recursive_union" ); break;
        case DBOP_aggregate : printf( "DBOP_aggregate" ); break;
        case DBOP_remote_table : printf( "DBOP_remote_table" ); break;
        case DBOP_select : printf( "DBOP_select" ); break;
        case DBOP_order_preserving_select : printf( "DBOP_order_preserving_select" ); break;
        case DBOP_project : printf( "DBOP_project" ); break;
        case DBOP_project_order_preserving : printf( "DBOP_project_order_preserving" ); break;
        case DBOP_top : printf( "DBOP_top" ); break;
        case DBOP_top_percent : printf( "DBOP_top_percent" ); break;
        case DBOP_top_plus_ties : printf( "DBOP_top_plus_ties" ); break;
        case DBOP_top_percent_plus_ties : printf( "DBOP_top_percent_plus_ties" ); break;
        case DBOP_rank : printf( "DBOP_rank" ); break;
        case DBOP_rank_ties_equally : printf( "DBOP_rank_ties_equally" ); break;
        case DBOP_rank_ties_equally_and_skip : printf( "DBOP_rank_ties_equally_and_skip" ); break;
        case DBOP_navigate : printf( "DBOP_navigate" ); break;
        case DBOP_nesting : printf( "DBOP_nesting" ); break;
        case DBOP_unnesting : printf( "DBOP_unnesting" ); break;
        case DBOP_nested_apply : printf( "DBOP_nested_apply" ); break;
        case DBOP_cross_tab : printf( "DBOP_cross_tab" ); break;
        case DBOP_is_NULL : printf( "DBOP_is_NULL" ); break;
        case DBOP_is_NOT_NULL : printf( "DBOP_is_NOT_NULL" ); break;
        case DBOP_equal : printf( "DBOP_equal" ); break;
        case DBOP_not_equal : printf( "DBOP_not_equal" ); break;
        case DBOP_less : printf( "DBOP_less" ); break;
        case DBOP_less_equal : printf( "DBOP_less_equal" ); break;
        case DBOP_greater : printf( "DBOP_greater" ); break;
        case DBOP_greater_equal : printf( "DBOP_greater_equal" ); break;
        case DBOP_equal_all : printf( "DBOP_equal_all" ); break;
        case DBOP_not_equal_all : printf( "DBOP_not_equal_all" ); break;
        case DBOP_less_all : printf( "DBOP_less_all" ); break;
        case DBOP_less_equal_all : printf( "DBOP_less_equal_all" ); break;
        case DBOP_greater_all : printf( "DBOP_greater_all" ); break;
        case DBOP_greater_equal_all : printf( "DBOP_greater_equal_all" ); break;
        case DBOP_equal_any : printf( "DBOP_equal_any" ); break;
        case DBOP_not_equal_any : printf( "DBOP_not_equal_any" ); break;
        case DBOP_less_any : printf( "DBOP_less_any" ); break;
        case DBOP_less_equal_any : printf( "DBOP_less_equal_any" ); break;
        case DBOP_greater_any : printf( "DBOP_greater_any" ); break;
        case DBOP_greater_equal_any : printf( "DBOP_greater_equal_any" ); break;
        case DBOP_anybits : printf( "DBOP_anybits" ); break;
        case DBOP_allbits : printf( "DBOP_allbits" ); break;
        case DBOP_anybits_any : printf( "DBOP_anybits_any" ); break;
        case DBOP_allbits_any : printf( "DBOP_allbits_any" ); break;
        case DBOP_anybits_all : printf( "DBOP_anybits_all" ); break;
        case DBOP_allbits_all : printf( "DBOP_allbits_all" ); break;
        case DBOP_between : printf( "DBOP_between" ); break;
        case DBOP_between_unordered : printf( "DBOP_between_unordered" ); break;
        case DBOP_match : printf( "DBOP_match" ); break;
        case DBOP_match_unique : printf( "DBOP_match_unique" ); break;
        case DBOP_match_partial : printf( "DBOP_match_partial" ); break;
        case DBOP_match_partial_unique : printf( "DBOP_match_partial_unique" ); break;
        case DBOP_match_full : printf( "DBOP_match_full" ); break;
        case DBOP_match_full_unique : printf( "DBOP_match_full_unique" ); break;
        case DBOP_scalar_parameter : printf( "DBOP_scalar_parameter" ); break;
        case DBOP_scalar_function : printf( "DBOP_scalar_function" ); break;
        case DBOP_plus : printf( "DBOP_plus" ); break;
        case DBOP_minus : printf( "DBOP_minus" ); break;
        case DBOP_times : printf( "DBOP_times" ); break;
        case DBOP_over : printf( "DBOP_over" ); break;
        case DBOP_div : printf( "DBOP_div" ); break;
        case DBOP_modulo : printf( "DBOP_modulo" ); break;
        case DBOP_power : printf( "DBOP_power" ); break;
        case DBOP_like : printf( "DBOP_like" ); break;
        case DBOP_sounds_like : printf( "DBOP_sounds_like" ); break;
        case DBOP_like_any : printf( "DBOP_like_any" ); break;
        case DBOP_like_all : printf( "DBOP_like_all" ); break;
        case DBOP_is_INVALID : printf( "DBOP_is_INVALID" ); break;
        case DBOP_is_TRUE : printf( "DBOP_is_TRUE" ); break;
        case DBOP_is_FALSE : printf( "DBOP_is_FALSE" ); break;
        case DBOP_and : printf( "DBOP_and" ); break;
        case DBOP_or : printf( "DBOP_or" ); break;
        case DBOP_xor : printf( "DBOP_xor" ); break;
        case DBOP_equivalent : printf( "DBOP_equivalent" ); break;
        case DBOP_not : printf( "DBOP_not" ); break;
        case DBOP_implies : printf( "DBOP_implies" ); break;
        case DBOP_overlaps : printf( "DBOP_overlaps" ); break;
        case DBOP_case_condition : printf( "DBOP_case_condition" ); break;
        case DBOP_case_value : printf( "DBOP_case_value" ); break;
        case DBOP_nullif : printf( "DBOP_nullif" ); break;
        case DBOP_cast : printf( "DBOP_cast" ); break;
        case DBOP_coalesce : printf( "DBOP_coalesce" ); break;
        case DBOP_position : printf( "DBOP_position" ); break;
        case DBOP_extract : printf( "DBOP_extract" ); break;
        case DBOP_char_length : printf( "DBOP_char_length" ); break;
        case DBOP_octet_length : printf( "DBOP_octet_length" ); break;
        case DBOP_bit_length : printf( "DBOP_bit_length" ); break;
        case DBOP_substring : printf( "DBOP_substring" ); break;
        case DBOP_upper : printf( "DBOP_upper" ); break;
        case DBOP_lower : printf( "DBOP_lower" ); break;
        case DBOP_trim : printf( "DBOP_trim" ); break;
        case DBOP_translate : printf( "DBOP_translate" ); break;
        case DBOP_convert : printf( "DBOP_convert" ); break;
        case DBOP_string_concat : printf( "DBOP_string_concat" ); break;
        case DBOP_current_date : printf( "DBOP_current_date" ); break;
        case DBOP_current_time : printf( "DBOP_current_time" ); break;
        case DBOP_current_timestamp : printf( "DBOP_current_timestamp" ); break;
        case DBOP_content_select : printf( "DBOP_content_select" ); break;
        case DBOP_content : printf( "DBOP_content" ); break;
        case DBOP_content_freetext : printf( "DBOP_content_freetext" ); break;
        case DBOP_content_proximity : printf( "DBOP_content_proximity" ); break;
        case DBOP_content_vector_or : printf( "DBOP_content_vector_or" ); break;
        case DBOP_delete : printf( "DBOP_delete" ); break;
        case DBOP_update : printf( "DBOP_update" ); break;
        case DBOP_insert : printf( "DBOP_insert" ); break;
        case DBOP_min : printf( "DBOP_min" ); break;
        case DBOP_max : printf( "DBOP_max" ); break;
        case DBOP_count : printf( "DBOP_count" ); break;
        case DBOP_sum : printf( "DBOP_sum" ); break;
        case DBOP_avg : printf( "DBOP_avg" ); break;
        case DBOP_any_sample : printf( "DBOP_any_sample" ); break;
        case DBOP_stddev : printf( "DBOP_stddev" ); break;
        case DBOP_stddev_pop : printf( "DBOP_stddev_pop" ); break;
        case DBOP_var : printf( "DBOP_var" ); break;
        case DBOP_var_pop : printf( "DBOP_var_pop" ); break;
        case DBOP_first : printf( "DBOP_first" ); break;
        case DBOP_last : printf( "DBOP_last" ); break;
        case DBOP_in : printf( "DBOP_in" ); break;
        case DBOP_exists : printf( "DBOP_exists" ); break;
        case DBOP_unique : printf( "DBOP_unique" ); break;
        case DBOP_subset : printf( "DBOP_subset" ); break;
        case DBOP_proper_subset : printf( "DBOP_proper_subset" ); break;
        case DBOP_superset : printf( "DBOP_superset" ); break;
        case DBOP_proper_superset : printf( "DBOP_proper_superset" ); break;
        case DBOP_disjoint : printf( "DBOP_disjoint" ); break;
        case DBOP_pass_through : printf( "DBOP_pass_through" ); break;
        case DBOP_defined_by_GUID : printf( "DBOP_defined_by_GUID" ); break;
        case DBOP_text_command : printf( "DBOP_text_command" ); break;
        case DBOP_SQL_select : printf( "DBOP_SQL_select" ); break;
        case DBOP_prior_command_tree : printf( "DBOP_prior_command_tree" ); break;
        case DBOP_add_columns : printf( "DBOP_add_columns" ); break;
        case DBOP_column_list_anchor : printf( "DBOP_column_list_anchor" ); break;
        case DBOP_column_list_element : printf( "DBOP_column_list_element" ); break;
        case DBOP_command_list_anchor : printf( "DBOP_command_list_anchor" ); break;
        case DBOP_command_list_element : printf( "DBOP_command_list_element" ); break;
        case DBOP_from_list_anchor : printf( "DBOP_from_list_anchor" ); break;
        case DBOP_from_list_element : printf( "DBOP_from_list_element" ); break;
        case DBOP_project_list_anchor : printf( "DBOP_project_list_anchor" ); break;
        case DBOP_project_list_element : printf( "DBOP_project_list_element" ); break;
        case DBOP_row_list_anchor : printf( "DBOP_row_list_anchor" ); break;
        case DBOP_row_list_element : printf( "DBOP_row_list_element" ); break;
        case DBOP_scalar_list_anchor : printf( "DBOP_scalar_list_anchor" ); break;
        case DBOP_scalar_list_element : printf( "DBOP_scalar_list_element" ); break;
        case DBOP_set_list_anchor : printf( "DBOP_set_list_anchor" ); break;
        case DBOP_set_list_element : printf( "DBOP_set_list_element" ); break;
        case DBOP_sort_list_anchor : printf( "DBOP_sort_list_anchor" ); break;
        case DBOP_sort_list_element : printf( "DBOP_sort_list_element" ); break;
        case DBOP_alter_character_set : printf( "DBOP_alter_character_set" ); break;
        case DBOP_alter_collation : printf( "DBOP_alter_collation" ); break;
        case DBOP_alter_domain : printf( "DBOP_alter_domain" ); break;
        case DBOP_alter_index : printf( "DBOP_alter_index" ); break;
        case DBOP_alter_procedure : printf( "DBOP_alter_procedure" ); break;
        case DBOP_alter_schema : printf( "DBOP_alter_schema" ); break;
        case DBOP_alter_table : printf( "DBOP_alter_table" ); break;
        case DBOP_alter_trigger : printf( "DBOP_alter_trigger" ); break;
        case DBOP_alter_view : printf( "DBOP_alter_view" ); break;
        case DBOP_coldef_list_anchor : printf( "DBOP_coldef_list_anchor" ); break;
        case DBOP_coldef_list_element : printf( "DBOP_coldef_list_element" ); break;
        case DBOP_create_assertion : printf( "DBOP_create_assertion" ); break;
        case DBOP_create_character_set : printf( "DBOP_create_character_set" ); break;
        case DBOP_create_collation : printf( "DBOP_create_collation" ); break;
        case DBOP_create_domain : printf( "DBOP_create_domain" ); break;
        case DBOP_create_index : printf( "DBOP_create_index" ); break;
        case DBOP_create_procedure : printf( "DBOP_create_procedure" ); break;
        case DBOP_create_schema : printf( "DBOP_create_schema" ); break;
        case DBOP_create_synonym : printf( "DBOP_create_synonym" ); break;
        case DBOP_create_table : printf( "DBOP_create_table" ); break;
        case DBOP_create_temporary_table : printf( "DBOP_create_temporary_table" ); break;
        case DBOP_create_translation : printf( "DBOP_create_translation" ); break;
        case DBOP_create_trigger : printf( "DBOP_create_trigger" ); break;
        case DBOP_create_view : printf( "DBOP_create_view" ); break;
        case DBOP_drop_assertion : printf( "DBOP_drop_assertion" ); break;
        case DBOP_drop_character_set : printf( "DBOP_drop_character_set" ); break;
        case DBOP_drop_collation : printf( "DBOP_drop_collation" ); break;
        case DBOP_drop_domain : printf( "DBOP_drop_domain" ); break;
        case DBOP_drop_index : printf( "DBOP_drop_index" ); break;
        case DBOP_drop_procedure : printf( "DBOP_drop_procedure" ); break;
        case DBOP_drop_schema : printf( "DBOP_drop_schema" ); break;
        case DBOP_drop_synonym : printf( "DBOP_drop_synonym" ); break;
        case DBOP_drop_table : printf( "DBOP_drop_table" ); break;
        case DBOP_drop_translation : printf( "DBOP_drop_translation" ); break;
        case DBOP_drop_trigger : printf( "DBOP_drop_trigger" ); break;
        case DBOP_drop_view : printf( "DBOP_drop_view" ); break;
        case DBOP_foreign_key : printf( "DBOP_foreign_key" ); break;
        case DBOP_grant_privileges : printf( "DBOP_grant_privileges" ); break;
        case DBOP_index_list_anchor : printf( "DBOP_index_list_anchor" ); break;
        case DBOP_index_list_element : printf( "DBOP_index_list_element" ); break;
        case DBOP_primary_key : printf( "DBOP_primary_key" ); break;
        case DBOP_property_list_anchor : printf( "DBOP_property_list_anchor" ); break;
        case DBOP_property_list_element : printf( "DBOP_property_list_element" ); break;
        case DBOP_referenced_table : printf( "DBOP_referenced_table" ); break;
        case DBOP_rename_object : printf( "DBOP_rename_object" ); break;
        case DBOP_revoke_privileges : printf( "DBOP_revoke_privileges" ); break;
        case DBOP_schema_authorization : printf( "DBOP_schema_authorization" ); break;
        case DBOP_unique_key : printf( "DBOP_unique_key" ); break;
        case DBOP_scope_list_anchor : printf( "DBOP_scope_list_anchor" ); break;
        case DBOP_scope_list_element : printf( "DBOP_scope_list_element" ); break;
        case DBOP_content_table : printf( "DBOP_content_table" ); break;

        default : printf( "unknown DBOP" ); break;
    }

    printf( "\n" );

    PrintSpace( iLevel );
    printf( "wKind: (%d) ", pNode->wKind );
    switch( pNode->wKind )
    {
        case DBVALUEKIND_BYGUID :
        {
            printf( "DBVALUEKIND_BYGUID " );
            break;
        }
        case DBVALUEKIND_COLDESC :
        {
            printf( "DBVALUEKIND_COLDESC " );
            break;
        }
        case DBVALUEKIND_ID :
        {
            printf( "DBVALUEKIND_ID: " );
            if ( 0 == pNode->value.pdbidValue )
                printf( "NULL" );
            else
            {
                DBKIND kind = pNode->value.pdbidValue->eKind;

                if ( DBKIND_GUID        == kind ||
                     DBKIND_GUID_NAME   == kind ||
                     DBKIND_GUID_PROPID == kind )
                {
                    GUID &g = pNode->value.pdbidValue->uGuid.guid;
                    printf( "%8.8x-%4.4x-%4.4x-%2.2x%2.2x-"
                            "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
                            g.Data1,g.Data2,g.Data3,g.Data4[0],
                            g.Data4[1],g.Data4[2],g.Data4[3],g.Data4[4],
                            g.Data4[5],g.Data4[6],g.Data4[7] );
                }
                if ( DBKIND_GUID_PROPID == kind ||
                     DBKIND_PROPID      == kind )
                    printf( " %d", pNode->value.pdbidValue->uName.ulPropid );
                if ( DBKIND_GUID_NAME == kind ||
                     DBKIND_NAME      == kind )
                    printf( " '%ws'", pNode->value.pdbidValue->uName.pwszName );
            }
            break;
        }
        case DBVALUEKIND_CONTENT :
        {
            printf( "DBVALUEKIND_CONTENT: " );
            if ( 0 == pNode->value.pdbcntntValue )
                printf( "NULL" );
            else
                printf( "'%ws', method %d, weight %d, lcid %#x",
                        pNode->value.pdbcntntValue->pwszPhrase,
                        pNode->value.pdbcntntValue->dwGenerateMethod,
                        pNode->value.pdbcntntValue->lWeight,
                        pNode->value.pdbcntntValue->lcid );
            break;
        }
        case DBVALUEKIND_CONTENTVECTOR :
        {
            printf( "DBVALUEKIND_CONTENTVECTOR: " );
            DBCONTENTVECTOR *p = pNode->value.pdbcntntvcValue;
            if ( 0 == p )
                printf( "NULL" );
            else
            {
                printf( "method %d, weight %d ",
                         p->dwRankingMethod,
                         p->lWeight );
            }
            break;
        }
        case DBVALUEKIND_GROUPINFO :
        {
            printf( "DBVALUEKIND_GROUPINFO " );
            break;
        }
        case DBVALUEKIND_PARAMETER :
        {
            printf( "DBVALUEKIND_PARAMETER " );
            break;
        }
        case DBVALUEKIND_PROPERTY :
        {
            printf( "DBVALUEKIND_PROPERTY " );
            break;
        }
        case DBVALUEKIND_SETFUNC :
        {
            printf( "DBVALUEKIND_SETFUNC " );
            break;
        }
        case DBVALUEKIND_SORTINFO :
        {
            printf( "DBVALUEKIND_SORTINFO: " );
            if ( 0 == pNode->value.pdbsrtinfValue )
                printf( "NULL" );
            else
                printf( "fDesc %d, lcid %#x",
                        pNode->value.pdbsrtinfValue->fDesc,
                        pNode->value.pdbsrtinfValue->lcid );
            break;
        }
        case DBVALUEKIND_TEXT :
        {
            printf( "DBVALUEKIND_TEXT " );
            break;
        }
        case DBVALUEKIND_COMMAND :
        {
            printf( "DBVALUEKIND_COMMAND " );
            break;
        }
        case DBVALUEKIND_MONIKER :
        {
            printf( "DBVALUEKIND_MONIKER " );
            break;
        }
        case DBVALUEKIND_ROWSET :
        {
            printf( "DBVALUEKIND_ROWSET " );
            break;
        }
        case DBVALUEKIND_LIKE :
        {
            printf( "DBVALUEKIND_LIKE " );
            break;
        }
        case DBVALUEKIND_CONTENTPROXIMITY :
        {
            printf( "DBVALUEKIND_CONTENTPROXIMITY " );
            break;
        }
        case DBVALUEKIND_CONTENTSCOPE :
        {
            printf( "DBVALUEKIND_CONTENTSCOPE " );
            if ( 0 == pNode->value.pdbcntntscpValue )
                printf( "NULL" );
            else
                printf( "dwFlags %#x, pwszElementValue %ws",
                        pNode->value.pdbcntntscpValue->dwFlags,
                        pNode->value.pdbcntntscpValue->pwszElementValue );
            break;
        }
        case DBVALUEKIND_CONTENTTABLE :
        {
            printf( "DBVALUEKIND_CONTENTTABLE " );
            if ( 0 == pNode->value.pdbcntnttblValue )
                printf( "NULL" );
            else
                printf( "machine %ws, catalog %ws",
                        pNode->value.pdbcntnttblValue->pwszMachine,
                        pNode->value.pdbcntnttblValue->pwszCatalog );
            break;
        }
        case DBVALUEKIND_IDISPATCH :
        {
            printf( "DBVALUEKIND_IDISPATCH " );
            break;
        }
        case DBVALUEKIND_IUNKNOWN :
        {
            printf( "DBVALUEKIND_IUNKNOWN " );
            break;
        }
        case DBVALUEKIND_EMPTY :
        {
            printf( "DBVALUEKIND_EMPTY " );
            break;
        }
        case DBVALUEKIND_NULL :
        {
            printf( "DBVALUEKIND_NULL " );
            break;
        }
        case DBVALUEKIND_I2 :
        {
            printf( "DBVALUEKIND_I2: %d", pNode->value.sValue );
            break;
        }
        case DBVALUEKIND_I4 :
        {
            printf( "DBVALUEKIND_I4: %d", pNode->value.lValue );
            break;
        }
        case DBVALUEKIND_R4 :
        {
            printf( "DBVALUEKIND_R4: %f", pNode->value.flValue );
            break;
        }
        case DBVALUEKIND_R8 :
        {
            printf( "DBVALUEKIND_R8: %lf", pNode->value.dblValue );
            break;
        }
        case DBVALUEKIND_CY :
        {
            printf( "DBVALUEKIND_CY " );
            break;
        }
        case DBVALUEKIND_DATE :
        {
            printf( "DBVALUEKIND_DATE " );
            break;
        }
        case DBVALUEKIND_BSTR :
        {
            printf( "DBVALUEKIND_BSTR: '%ws'", pNode->value.pbstrValue );
            break;
        }
        case DBVALUEKIND_ERROR :
        {
            printf( "DBVALUEKIND_ERROR: %d", pNode->value.scodeValue );
            break;
        }
        case DBVALUEKIND_BOOL :
        {
            printf( "DBVALUEKIND_BOOL: %d", pNode->value.fValue );
            break;
        }
        case DBVALUEKIND_VARIANT :
        {
            printf( "DBVALUEKIND_VARIANT " );

            // Indexing Service uses PROPVARIANTs (extended VARIANTs)

            DisplayVariant( (PROPVARIANT *) pNode->value.pvarValue );
            break;
        }
        case DBVALUEKIND_I1 :
        {
            printf( "DBVALUEKIND_I1: %d", pNode->value.schValue );
            break;
        }
        case DBVALUEKIND_UI1 :
        {
            printf( "DBVALUEKIND_UI1: %u", pNode->value.uchValue );
            break;
        }
        case DBVALUEKIND_UI2 :
        {
            printf( "DBVALUEKIND_UI2: %u", pNode->value.usValue );
            break;
        }
        case DBVALUEKIND_UI4 :
        {
            printf( "DBVALUEKIND_UI4: %u", pNode->value.ulValue );
            break;
        }
        case DBVALUEKIND_I8 :
        {
            printf( "DBVALUEKIND_I8: %I64d", pNode->value.llValue );
            break;
        }
        case DBVALUEKIND_UI8 :
        {
            printf( "DBVALUEKIND_UI8: %I64u", pNode->value.llValue );
            break;
        }
        case DBVALUEKIND_GUID :
        {
            printf( "DBVALUEKIND_GUID " );
            break;
        }
        case DBVALUEKIND_BYTES :
        {
            printf( "DBVALUEKIND_BYTES " );
            break;
        }
        case DBVALUEKIND_STR :
        {
            printf( "DBVALUEKIND_STR: '%s'", pNode->value.pzValue );
            break;
        }
        case DBVALUEKIND_WSTR :
        {
            printf( "DBVALUEKIND_WSTR: '%ws'", pNode->value.pwszValue );
            break;
        }
        case DBVALUEKIND_NUMERIC :
        {
            printf( "DBVALUEKIND_NUMERIC " );
            break;
        }
        case DBVALUEKIND_DBDATE :
        {
            printf( "DBVALUEKIND_DBDATE " );
            break;
        }
        case DBVALUEKIND_DBTIME :
        {
            printf( "DBVALUEKIND_DBTIME " );
            break;
        }
        case DBVALUEKIND_DBTIMESTAMP :
        {
            printf( "DBVALUEKIND_DBTIMESTAMP " );
            break;
        }
        default :
        {
            printf( "unknown DBVALUEKIND " );
            break;
        }
    }

    printf( "\n" );

    if ( pNode->pctFirstChild )
    {
        PrintSpace( iLevel );
        printf( "first child:\n" );
        DisplayCommandTree( pNode->pctFirstChild, iLevel + 1 );
    }

    if ( pNode->pctNextSibling )
    {
        PrintSpace( iLevel );
        printf( "next sibling:\n" );
        DisplayCommandTree( pNode->pctNextSibling, iLevel + 1 );
    }

    if ( 0 == iLevel )
        printf( "\n" );
} //DisplayCommandTree
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ci\isrch.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:  isrchdmp.cx
//
// PURPOSE:  Illustrates a minimal query using Indexing Service.
//
// PLATFORM: Windows 2000
//
//--------------------------------------------------------------------------

#ifndef UNICODE
#define UNICODE
#endif

#include <stdio.h>
#include <windows.h>

#define DBINITCONSTANTS

#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>

#include <ntquery.h>
#include <filter.h>
#include <filterr.h>

#include "isearch.h"
#include "array.hxx"

extern CIPROPERTYDEF aCPPProperties[];

extern unsigned cCPPProperties;

//+-------------------------------------------------------------------------
//
//  Template:   XInterface
//
//  Synopsis:   Template for managing ownership of interfaces
//
//--------------------------------------------------------------------------

template<class T> class XInterface
{
public:
    XInterface( T * p = 0 ) : _p( p ) {}
    ~XInterface() { if ( 0 != _p ) _p->Release(); }
    T * operator->() { return _p; }
    T * GetPointer() const { return _p; }
    IUnknown ** GetIUPointer() { return (IUnknown **) &_p; }
    T ** GetPPointer() { return &_p; }
    void ** GetQIPointer() { return (void **) &_p; }
    T * Acquire() { T * p = _p; _p = 0; return p; }

private:
    T * _p;
};

const GUID guidStorage = PSGUID_STORAGE;

typedef void (__stdcall * PFnCIShutdown)(void);
typedef HRESULT (__stdcall * PFnMakeISearch)( ISearchQueryHits ** ppSearch,
                                              DBCOMMANDTREE * pRst,
                                              WCHAR const * pwcPath );
typedef HRESULT (__stdcall * PFnLoadTextFilter)( WCHAR const * pwcPath,
                                                 IFilter ** ppIFilter );

PFnCIShutdown g_pCIShutdown = 0;
PFnMakeISearch g_pMakeISearch = 0;
PFnLoadTextFilter g_pLoadTextFilter = 0;

#define UNICODE_PARAGRAPH_SEPARATOR 0x2029

ULONG CountCR( WCHAR * pCur, ULONG cwc, WCHAR * &pwcPrev )
{
    pwcPrev = pCur;
    WCHAR * pEnd = pCur + cwc;
    ULONG cCR = 0;

    while ( pCur < pEnd )
    {
        WCHAR c = *pCur;

        if ( L'\r' == c ||
             L'\n' == c ||
             UNICODE_PARAGRAPH_SEPARATOR == c )
        {
            cCR++;

            if ( ( L'\r' == c ) &&
                 ( (pCur+1) < pEnd ) &&
                 ( L'\n' == *(pCur+1) ) )
                pCur++;

            pwcPrev = pCur + 1;
        }

        pCur++;
    }

    return cCR;
} //CountCR

HRESULT WalkFile(
    TArray<FILTERREGION> & aHits,
    XInterface<IFilter> &  xIFilter,
    WCHAR const *          pwcFile,
    BOOL                   fPrintFile )
{
    ULONG ulFlags;

    HRESULT hr = xIFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                                 IFILTER_INIT_CANON_HYPHENS |
                                 IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                                 0,
                                 0,
                                 &ulFlags );
    if ( FAILED( hr ) )
        return hr;

    ULONG lenSoFar = 0;
    int cChunk = 0;
    BOOL fSeenProp = FALSE;
    ULONG iHit = 0;
    ULONG cLines = 1;

    const ULONG cwcBufSize = 65536;
    WCHAR *pwc = new WCHAR[cwcBufSize + 1];

    if ( 0 == pwc )
        return E_OUTOFMEMORY;

    STAT_CHUNK statChunk;
    hr = xIFilter->GetChunk( &statChunk );

    while( SUCCEEDED( hr ) ||
           ( FILTER_E_LINK_UNAVAILABLE == hr ) ||
           ( FILTER_E_EMBEDDING_UNAVAILABLE == hr ) )
    {
        if ( SUCCEEDED( hr ) && (statChunk.flags & CHUNK_TEXT) )
        {
            // read the contents only

            if ( ( guidStorage == statChunk.attribute.guidPropSet ) &&
                 ( PRSPEC_PROPID == statChunk.attribute.psProperty.ulKind ) &&
                 ( PID_STG_CONTENTS == statChunk.attribute.psProperty.propid ) )
            {
                if ( CHUNK_NO_BREAK != statChunk.breakType )
                {
                    switch( statChunk.breakType )
                    {
                        case CHUNK_EOW:
                        case CHUNK_EOS:
                            break;
                        case CHUNK_EOP:
                        case CHUNK_EOC:
                            cLines++;
                            break;
                    }
                }

                ULONG iIntoChunk = 0;
                ULONG cwcRetrieved;
                ULONG iPrevLine = ~0;

                do
                {
                    cwcRetrieved = cwcBufSize;
                    hr = xIFilter->GetText( &cwcRetrieved, pwc );

                    pwc[cwcRetrieved] = 0;

                    // The buffer may be filled with zeroes.  Nice filter.
    
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( 0 != cwcRetrieved )
                            cwcRetrieved = __min( cwcRetrieved,
                                                  wcslen( pwc ) );

                        while ( ( iHit < aHits.Count() ) &&
                                ( aHits[iHit].idChunk == statChunk.idChunk ) &&
                                ( aHits[iHit].cwcStart >= iIntoChunk ) &&
                                ( aHits[iHit].cwcStart < ( iIntoChunk + cwcRetrieved ) ) )
                        {
                            WCHAR *pwcStart;

                            ULONG iLine = cLines +
                                          CountCR( pwc,
                                                   aHits[iHit].cwcStart - iIntoChunk,
                                                   pwcStart );

                            WCHAR *pwcEnd = wcschr( pwcStart, L'\r' );

                            if ( 0 == pwcEnd )
                                pwcEnd = wcschr( pwcStart, L'\n' );

                            if ( 0 != pwcEnd )
                                *pwcEnd = 0;

                            if ( iLine != iPrevLine )
                            {
                                if ( fPrintFile )
                                    wprintf( L"%ws", pwcFile );

                                wprintf( L"(%u): %ws\n", iLine, pwcStart );
                                iPrevLine = iLine;
                            }

                            if ( 0 != pwcEnd )
                                *pwcEnd = '\r';

                            iHit++;
                        }

                        WCHAR * pwcDummy;
                        cLines += CountCR( pwc, cwcRetrieved, pwcDummy );

                        iIntoChunk += cwcRetrieved;
                    }
                } while( SUCCEEDED( hr ) );
            }
        }

        hr = xIFilter->GetChunk ( &statChunk );
    }

    delete [] pwc;

    if ( FILTER_E_END_OF_CHUNKS == hr )
        hr = S_OK;

    return hr;
} //WalkFile

//+-------------------------------------------------------------------------
//
//  Function:   DoISearchQuery
//
//  Synopsis:   Creates and executes a query, then displays the results.
//
//  Arguments:  [pwcFilename]        - Name of the file
//              [pwcQueryRestrition] - The actual query string
//              [fPrintFile]         - whether to print the filename
//              [lcid]               - Locale of the query
//              [ulDialect]          - Dialect of tripolish, 1 or 2.
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoISearchQuery(
    WCHAR const * pwcFilename,
    WCHAR const * pwcQueryRestriction,
    BOOL          fPrintFile,
    BOOL          fDefineCPP,
    LCID          lcid,
    ULONG         ulDialect )
{
    // Create an OLE DB query tree from a text restriction

    DBCOMMANDTREE * pTree;
    ULONG cDefinedProperties = fDefineCPP ? cCPPProperties : 0;
    HRESULT hr = CITextToSelectTreeEx( pwcQueryRestriction,  // the query itself
                                       ulDialect,            // dialect to use
                                       &pTree,               // resulting tree
                                       cDefinedProperties,   // C++ properties
                                       aCPPProperties,       // C++ properties
                                       lcid );               // the locale
    if ( FAILED( hr ) )
        return hr;

    // Make the ISearchQueryHits object

    XInterface<ISearchQueryHits> xISearch;
    hr = g_pMakeISearch( xISearch.GetPPointer(),
                         pTree,
                         0 );
    if ( FAILED( hr ) )
        return hr;

    XInterface<IFilter> xIFilter;

#if 1

    hr = LoadIFilter( pwcFilename, 0, xIFilter.GetQIPointer() );
    if ( FAILED( hr ) )
    {
        // Fall back on the plain text filter

        hr = g_pLoadTextFilter( pwcFilename, xIFilter.GetPPointer() );
        if ( FAILED( hr ) )
            return hr;
    }

#else

   // LIFF_LOAD_DEFINED_FILTER: Load the filter found for the file
   // LIFF_IMPLEMENT_TEXT_FILTER_FALLBACK_POLICY: Use the registry key to check to fallback
   // LIFF_FORCE_TEXT_FILTER_FALLBACK: Always fall back to the text filter if no other is available

    hr = LoadIFilterEx( pwcFilename,
                        LIFF_IMPLEMENT_TEXT_FILTER_FALLBACK_POLICY,
                        IID_IFilter,
                        xIFilter.GetQIPointer() );

    if ( FAILED( hr ) )
    {
        printf( "can't load filter: %#x\n", hr );
        return hr;
    }

#endif

    ULONG ulFlags;
    hr = xIFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                         IFILTER_INIT_CANON_HYPHENS |
                         IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                         0,
                         0,
                         &ulFlags );
    if ( FAILED( hr ) )
        return hr;

    hr = xISearch->Init( xIFilter.GetPointer(), ulFlags );
    if ( FAILED( hr ) )
        return hr;

    //
    // Retrieve all the hit info.  the info is wrt output from the IFilter.
    // a separate pass over a different IFilter is needed to match up
    // text to the hit info.
    //

    TArray<FILTERREGION> aHits;

    ULONG cRegions;
    FILTERREGION* aRegion;
    hr = xISearch->NextHitOffset( &cRegions, &aRegion );
    
    while ( S_OK == hr )
    {
        for ( ULONG i = 0; i < cRegions; i++ )
            aHits.Append( aRegion[i] );

        CoTaskMemFree( aRegion );
        hr = xISearch->NextHitOffset( &cRegions, &aRegion );
    }

#if 0
    for ( ULONG i = 0; i < aHits.Count(); i++ )
        printf( "hit %d, chunk %d start %d extent %d\n",
                i, aHits[i].idChunk, aHits[i].cwcStart, aHits[i].cwcExtent );
#endif

    return WalkFile( aHits, xIFilter, pwcFilename, fPrintFile );
} //DoISearchQuery

//+-------------------------------------------------------------------------
//
//  Function:   GetQueryFunctions
//
//  Synopsis:   Loads needed undocumented functions from query.dll.
//
//  Returns:    The module handle or 0 on failure.
//
//--------------------------------------------------------------------------

HINSTANCE GetQueryFunctions()
{
    HINSTANCE h = LoadLibrary( L"query.dll" );

    if ( 0 != h )
    {
        #ifdef _WIN64
            char const * pcCIShutdown = "?CIShutdown@@YAXXZ";
            char const * pcMakeISearch = "?MakeISearch@@YAJPEAPEAUISearchQueryHits@@PEAVCDbRestriction@@PEBG@Z";
        #else
            char const * pcCIShutdown = "?CIShutdown@@YGXXZ";
            char const * pcMakeISearch = "?MakeISearch@@YGJPAPAUISearchQueryHits@@PAVCDbRestriction@@PBG@Z";
        #endif

        g_pCIShutdown = (PFnCIShutdown) GetProcAddress( h, pcCIShutdown );

        if ( 0 == g_pCIShutdown )
        {
            FreeLibrary( h );
            return 0;
        }

        g_pMakeISearch = (PFnMakeISearch) GetProcAddress( h, pcMakeISearch );

        if ( 0 == g_pMakeISearch )
        {
            FreeLibrary( h );
            return 0;
        }

        g_pLoadTextFilter = (PFnLoadTextFilter) GetProcAddress( h, "LoadTextFilter" );

        if ( 0 == g_pLoadTextFilter )
        {
            FreeLibrary( h );
            return 0;
        }
    }

    return h;
} //GetQueryFunctions

HINSTANCE PrepareForISearch()
{
    return GetQueryFunctions();
} //DoneWithISearch

void DoneWithISearch( HINSTANCE h )
{
    g_pCIShutdown();
    FreeLibrary( h );
} //DoneWithISearch

//+-------------------------------------------------------------------------
//
//  Function:   DoISearch
//
//  Synopsis:   Invoke ISearch on the file
//
//  Arguments:  [pwcRestriction] -- the query
//              [pwcFilename]    -- the file
//              [fPrintFile]     -- whether to print the filename
//              [fDefineCPP]     -- TRUE to define the C++ properties func and class
//              [lcid]           -- locale of the query
//              [ulDialect]      -- the dialect of the query language
//
//--------------------------------------------------------------------------

HRESULT DoISearch(
    WCHAR const * pwcRestriction,
    WCHAR const * pwcFilename,
    BOOL          fPrintFile,
    BOOL          fDefineCPP,
    LCID          lcid,
    ULONG         ulDialect )
{
    // Run the query

    return DoISearchQuery( pwcFilename, pwcRestriction, fPrintFile, fDefineCPP, lcid, ulDialect );
} //DoISearch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\cidump\cidump.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1997-1998
//
//  File:       cidump.cxx
//
//  Contents:   CI catalog dump utility
//
//  History:    09-Apr-97       SitaramR          Created
//
//----------------------------------------------------------------------------

#define _OLE32_
#define __QUERY__

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <malloc.h>
#include <math.h>
#include <memory.h>
#include <stddef.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>
#include <imagehlp.h>
#include <lmcons.h>

#define _DCOM_
#define _CAIROSTG_

#include <cidebnot.h>
#include <cierror.h>

#define OLEDBVER 0x0250 // enable ICommandTree interface

#include <oleext.h>
#include <oledberr.h>
#include <oledb.h>
#include <query.h>
#include <stgprop.h>
#include <filter.h>
#include <filterr.h>
#include <vquery.hxx>
#include <restrict.hxx>

//
// Base services
//

#include <ciexcpt.hxx>
#include <smart.hxx>
#include <tsmem.hxx>
#include <xolemem.hxx>
#include <dynarray.hxx>
#include <dynstack.hxx>
#include <dblink.hxx>
#include <cisem.hxx>
#include <thrd32.hxx>
#include <readwrit.hxx>
#include <ci.h>

//
// Debug files from
//

#include <cidebug.hxx>
#include <vqdebug.hxx>

//
// CI-specific
//

#include <align.hxx>
#include <memser.hxx>
#include <memdeser.hxx>

#include <tgrow.hxx>
#include <funypath.hxx>
#include <params.hxx>
#include <key.hxx>
#include <keyarray.hxx>
#include <irest.hxx>
#include <cursor.hxx>
#include <idxids.hxx>
#include <dberror.hxx>

// property-related macros and includes

#include <propapi.h>
#include <propstm.hxx>
extern UNICODECALLOUTS UnicodeCallouts;
#define DebugTrace( x, y, z )
#ifdef PROPASSERTMSG
#undef PROPASSERTMSG
#endif
#define PROPASSERTMSG( x, y )

#include <rcstrmhd.hxx>
#include <xact.hxx>
#include <pidxtbl.hxx>

#include "cistore.hxx"
#include "physidx.hxx"

#include "pcomp.hxx"
#include "cidir.hxx"

DECLARE_INFOLEVEL(ci)
//DECLARE_INFOLEVEL(vq)


//extern BOOL ExceptDllMain( HANDLE hDll, DWORD dwReason, LPVOID lpReserved );

unsigned fVerbose = 0;        // Verbose mode dumps all keys, wids and occurrences
unsigned fStats = 0;          // Just dump wid/occ counts.
unsigned fFullStats = 0;          // Just dump wid/occ counts.
unsigned fKeys = 0;           // Key info
unsigned fDistribution = 0;           // Key distribution info
unsigned fOccurrences = 0;           // Occurrence distribution info

extern "C" GUID CLSID_CTextIFilter = CLSID_TextIFilter;

DWORD Bytes( BitOffset & boff )
{
    return ( boff.Page() * CI_PAGE_SIZE ) + ( ( boff.Offset() + 7 ) / 8 );
}

ULONGLONG BitDistance( BitOffset & b1, BitOffset & b2 )
{
    ULONGLONG bA = ((ULONGLONG) b1.Page() * (ULONGLONG) ( CI_PAGE_SIZE * 8) ) + b1.Offset();
    ULONGLONG bB = ((ULONGLONG) b2.Page() * (ULONGLONG) ( CI_PAGE_SIZE * 8) ) + b2.Offset();

    return ( bB - bA );
}

//+---------------------------------------------------------------------------
//
//  Function:   LocaleToCodepage
//
//  Purpose:    Returns a codepage from a locale
//
//  Arguments:  [lcid]  --  Locale
//
//  History:    09-Apr-97   SitaramR    Created
//
//----------------------------------------------------------------------------

ULONG LocaleToCodepage( LCID lcid )
{
    const BUFFER_LENGTH = 10;
    WCHAR wcsCodePage[BUFFER_LENGTH];

    int cwc = GetLocaleInfoW( lcid, LOCALE_IDEFAULTANSICODEPAGE, wcsCodePage, BUFFER_LENGTH );

    //
    // If error, return Ansi code page
    //
    if ( cwc == 0 )
    {
         ciDebugOut(( DEB_ERROR, "GetLocaleInfoW for lcid %d returned %d\n", lcid, GetLastError() ));

         return CP_ACP;
    }

    return wcstoul( wcsCodePage, 0 , 10 );
}

void Usage()
{
    printf( "Usage: cidump <catalog path> [-e indexid] [-d] [-s] [-f] [-v] [-w workid]\n"
            "       -d : Distribution of keys in documents (key, wid, occ)\n"
            "       -e : Exclude this index\n"
            "       -k : Print keys with #files, #occ, pid, size\n"
            "       -s : Stats only\n"
            "       -f : Full Stats only (for all keys)\n"
            "       -v : Verbose (full occurrence information)\n"
            "       -w : Data for this workid only\n\n"
            "Example: cidump e:\\testdump\\catalog.wci\n" );
}

void DumpDirectoryKey( unsigned i, CDirectoryKey & Key )
{
    BitOffset bo;
    Key.Offset( bo );
    printf( "  key %d  cb 0x%x, PropId 0x%x, opage 0x%x, obits 0x%x\n",
            i,
            Key.Count(),
            Key.PropId(),
            bo.Page(),
            bo.Offset() );
} //DumpDirectoryKey

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Purpose:    Main dump routine
//
//  History:    09-Apr-97   SitaramR    Created
//              02-Nov-98   KLam        Passed disk space to leave to CiStorage
//
//----------------------------------------------------------------------------

int __cdecl main( int argc, char * argv[] )
{
    char * pszCatDir = argv[1];
    WORKID widTarget = 0xFFFFFFFF;

    INDEXID  aExclude[100];
    unsigned cExclude = 0;

    if ( argc < 2 )
    {
        Usage();
        return 0;
    }

    for ( int i = 1; i < argc; i++ )
    {
        if ( argv[i][0] == '-' )
        {
            switch ( argv[i][1] )
            {
            case 'e':
            case 'E':
                i++;
                aExclude[cExclude] = strtoul( argv[i], 0, 16 );
                cExclude++;
                break;

            case 's':
            case 'S':
                fStats = 1;
                break;

            case 'd':
            case 'D':
                fDistribution = 1;
                break;

            case 'f':
            case 'F':
                fFullStats = 1;
                break;

            case 'k':
            case 'K':
                fKeys = 1;
                break;

            case 'o':
            case 'O':
                fOccurrences = 1;
                break;

            case 'v':
            case 'V':
                fVerbose = 1;
                break;

            case 'w':
            case 'W':
                i++;
                widTarget = strtoul( argv[i], 0, 10 );
                break;

            default:
                Usage();
                return 0;
            }
        }
        else
            pszCatDir = argv[i];
    }

    if ( fKeys )
    {
        fFullStats = 0;
        fStats = 0;
        fVerbose = 0;
    }

    if ( fDistribution )
    {
        fFullStats = 0;
        fStats = 0;
        fVerbose = 0;
        fKeys = 0;
        fOccurrences = 0;
    }

    if ( fOccurrences )
    {
        fFullStats = 0;
        fStats = 0;
        fVerbose = 0;
        fKeys = 0;
        fDistribution = 0;
    }

    if ( (pszCatDir[0] != '\\' || pszCatDir[1] != '\\') &&
         (pszCatDir[0] == '\0' || pszCatDir[1] != ':' || pszCatDir[2] != '\\') )
    {
        printf("Use full path name for catalog path!\n\n");
        Usage();
        return 1;
    }

    WCHAR wszCatDir[MAX_PATH];

    LocaleToCodepage( GetSystemDefaultLCID() );

    ULONG cwcActual = MultiByteToWideChar( LocaleToCodepage( GetSystemDefaultLCID() ),
                                           0,
                                           pszCatDir,
                                           strlen( pszCatDir ) + 1,
                                           wszCatDir,
                                           MAX_PATH );

    if ( 0 == cwcActual )
    {
        Usage();
        return 1;
    }

    //
    // Keep stats on where we are when we die...
    //

    CIndexRecord recCrash;
    CKeyBuf      keyCrash;
    BitOffset    boffCrash;

    ULONG maxOccCounts = 1024;

    TRY
    {
        ULONGLONG * aOccCounts = new ULONGLONG[ maxOccCounts ];
        ULONGLONG * acbOccCounts = new ULONGLONG[ maxOccCounts ];

        CTransaction xact;
        XPtr<CiStorage> xStorage( new CiStorage( wszCatDir,
                                                 *((ICiCAdviseStatus *)0),
                                                 CI_MIN_DISK_SPACE_TO_LEAVE_DEFAULT ) );

        XPtr<PIndexTable> xIndexTable( xStorage->QueryIndexTable( xact ) );

        SIndexTabIter xIndexIter( xIndexTable->QueryIterator() );

        if ( xIndexIter->Begin() )
        {
            CIndexRecord record;

            while ( xIndexIter->NextRecord( record ) )
            {
                if ( record.Type() == itMaster || record.Type() == itShadow )
                {
                    //
                    // Do we want to skip this one?
                    //

                    for ( unsigned i = 0; i < cExclude; i++ )
                    {
                        if ( aExclude[i] == record.Iid() )
                            break;
                    }

                    if ( i < cExclude )
                        continue;

                    recCrash = record;
                    boffCrash.Init( 0, 0 );

                    if ( !fKeys && !fDistribution && !fOccurrences )
                    {
                        if ( record.Type() == itMaster )
                            printf( "Index master: " );
                        else
                            printf( "Index shadow: " );

                        printf( "Object id = 0x%x, Index id = 0x%x, MaxWorkid = 0x%x\n",
                                record.ObjectId(),
                                record.Iid(),
                                record.MaxWorkId() );
                    }

                    ULONG maxWid = record.MaxWorkId();

                    SStorageObject xStorageObj( xStorage->QueryObject( record.ObjectId() ) );

                    PMmStream * pStream = xStorage->QueryExistingIndexStream( xStorageObj.GetObj(),
                                                                          PStorage::eOpenForRead  );
                    XPtr<PMmStream> xStream( pStream );
                    CPhysIndex *pPhysIndex = new CPhysIndex ( *xStorage.GetPointer(),
                                                              xStorageObj.GetObj(),
                                                              record.ObjectId(),
                                                              PStorage::eOpenForRead,
                                                              xStream );
                    Win4Assert( 0 == xStream.GetPointer() );

                    XPtr<CPhysIndex> xPhysIndex( pPhysIndex );

                    CiDirectory *pDir = (CiDirectory *) xStorage->QueryExistingDirectory( xStorageObj.GetObj(),
                                                                                      PStorage::eOpenForRead );
                    XPtr<CiDirectory> xDir( pDir);

                    unsigned cLevel1 = xDir->Level1Count();
                    unsigned cLevel2 = xDir->Level2Count();

                    if ( !fKeys && !fDistribution && !fOccurrences )
                    {
                        printf( "directory has %d level 1 and %d level 2 keys\n",
                                cLevel1, cLevel2 );

                        if ( fVerbose )
                        {
                            for ( unsigned i = 0; i < cLevel1; i++ )
                                DumpDirectoryKey( i, xDir->GetLevel1Key( i ) );

                            for ( i = 0; i < cLevel2; i++ )
                                DumpDirectoryKey( i, xDir->GetLevel2Key( i ) );
                        }
                    }

                    ULONGLONG cOccInIndex = 0;
                    ULONGLONG cWidsWithOneOcc = 0;
                    ULONGLONG cWidsWith5OrLessOcc = 0;
                    ULONGLONG cWidsWithOcc = 0;
                    ULONG cKeysWithOneWid = 0;
                    ULONG cKeysInIndex = 0;
                    ULONG cbMinimumKey = 100000;
                    ULONG cbMaximumKey = 0;
                    ULONGLONG cBitsForOcc = 0;
                    ULONGLONG cBitsForWid = 0;
                    ULONGLONG cBitsForKey = 0;
                    ULONG cKeysInMoreThanHalfWids = 0;
                    ULONG cOccMinOverall = 0xffffffff;
                    ULONG cOccMaxOverall = 0;

                    ZeroMemory( aOccCounts, sizeof( ULONGLONG ) * maxOccCounts );
                    ZeroMemory( acbOccCounts, sizeof( ULONGLONG ) * maxOccCounts );

                    CPersDeComp *pDecomp = new CPersDeComp( *xDir.GetPointer(),
                                                            record.Iid(),
                                                            *xPhysIndex.GetPointer(),
                                                            record.MaxWorkId(),
                                                            TRUE,
                                                            TRUE );
                    XPtr<CPersDeComp> xDecomp( pDecomp );

                    const CKeyBuf *pKey;
                    BitOffset off;
                    xDecomp->GetOffset( off );

                    BitOffset boffBefore;
                    boffBefore.Init( 0, 0 );

                    for ( pKey = xDecomp->GetKey();
                          pKey != NULL;
                          pKey = xDecomp->GetNextKey() )
                    {
                        BitOffset boAfterKey;
                        xDecomp->GetOffset( boAfterKey );
                        cBitsForKey += BitDistance( boffBefore, boAfterKey );

                        cKeysInIndex++;

                        keyCrash = *pKey;
                        xDecomp->GetOffset( boffCrash );
                        BOOL fFirst = TRUE;

                        unsigned cWid = 0;
                        unsigned cOccTotal = 0;
                        unsigned cOccMin = 0xFFFFFFFF;
                        unsigned cOccMax = 0;

                        BitOffset boBeforeWid;
                        xDecomp->GetOffset( boBeforeWid );

                        if ( fDistribution )
                            printf( "%ws", pKey->GetStr() );

                        for ( WORKID wid = xDecomp->WorkId();
                              wid != widInvalid;
                              wid = xDecomp->NextWorkId() )
                        {
                            BitOffset boAfterWid;
                            xDecomp->GetOffset( boAfterWid );
                            cBitsForWid += BitDistance( boBeforeWid, boAfterWid );

                            cWidsWithOcc++;

                            xDecomp->GetOffset( boffCrash );
                            cWid++;
                            if ( fFirst )
                            {
                                if ( fVerbose || fFullStats || wid == widTarget )
                                {
                                    printf( "     Key size = 0x%x, pid = 0x%x, buffer = %ws, "
                                            "near page %u (0x%x), bit offset %u (0x%x) --> File offset 0x%x\n",
                                            pKey->Count(),
                                            pKey->Pid(),
                                            pKey->GetStr(),
                                            boffCrash.Page(), boffCrash.Page(),
                                            boffCrash.Offset(), boffCrash.Offset(),
                                            boffCrash.Page() * CI_PAGE_SIZE + (boffCrash.Offset() + 7)/8 );

                                    if ( !fKeys )
                                        fFirst = FALSE;
                                }
                            }

                            if ( (fVerbose && 0 == widTarget) ||
                                 wid == widTarget )
                                printf( "\t  wid = 0x%x, MaxOcc = 0x%x, OccCount = 0x%x, "
                                        "near page %u (0x%x), bit offset %u (0x%x) --> File offset 0x%x, "
                                        "\n\t  Occurrences = ",
                                        wid,
                                        xDecomp->MaxOccurrence(),
                                        xDecomp->OccurrenceCount(),
                                        boffCrash.Page(), boffCrash.Page(),
                                        boffCrash.Offset(), boffCrash.Offset(),
                                        boffCrash.Page() * CI_PAGE_SIZE + (boffCrash.Offset() + 7)/8 );

                            unsigned cOcc = 0;

                            BitOffset bo1;
                            xDecomp->GetOffset( bo1 );

                            for ( OCCURRENCE occ = xDecomp->Occurrence();
                                  occ != OCC_INVALID;
                                  occ = xDecomp->NextOccurrence() )
                            {
                                xDecomp->GetOffset( boffCrash );
                                cOcc++;

                                if ( (fVerbose && 0 == widTarget) ||
                                     wid == widTarget )
                                    printf( "0x%x ", occ );
                            }

                            if ( cOcc >= maxOccCounts )
                            {
                                ULONG newMax = cOcc * 2;

                                ULONGLONG *a1 = new ULONGLONG[ newMax ];
                                ULONGLONG *a2 = new ULONGLONG[ newMax ];

                                ZeroMemory( a1, sizeof( ULONGLONG ) * newMax );
                                ZeroMemory( a2, sizeof( ULONGLONG ) * newMax );

                                RtlCopyMemory( a1, aOccCounts, sizeof( ULONGLONG ) * maxOccCounts );
                                RtlCopyMemory( a2, acbOccCounts, sizeof( ULONGLONG ) * maxOccCounts );

                                delete [] aOccCounts;
                                delete [] acbOccCounts;
                                aOccCounts = a1;
                                acbOccCounts = a2;

                                maxOccCounts = newMax;
                            }

#if 0
                            if ( cOcc >= 500 )
                            {
                                printf( "cocc %d in wid %d, pid %#x, len %d, %ws\n",
                                        cOcc, wid, pKey->Pid(),
                                        pKey->StrLen(),
                                        pKey->GetStr() );

                                printf( "  cb %d: ", pKey->Count() );
                                BYTE const * pb = pKey->GetBuf();
                                for ( ULONG i = 0; i < pKey->Count(); i++ )
                                    printf( "  %#x", pb[i] );
                                printf( "\n" );
                            }
#endif

                            BitOffset bo2;
                            xDecomp->GetOffset( bo2 );
                            ULONG cDelta = (ULONG) BitDistance( bo1, bo2 );
                            cBitsForOcc += cDelta;

                            aOccCounts[ cOcc ]++;
                            acbOccCounts[ cOcc ] += cDelta;

//                            if ( fOccurrences )
//                                printf( "%d, %d\n", cOcc, cDelta );

                            cOccInIndex += cOcc;

                            if ( 1 == cOcc )
                                cWidsWithOneOcc++;

                            if ( cOcc <= 5 )
                                cWidsWith5OrLessOcc++;

                            if ( (fVerbose && 0 == widTarget) ||
                                 wid == widTarget )
                                printf( "\n" );

                            cOccTotal += cOcc;

                            if ( cOcc > cOccMax )
                                cOccMax = cOcc;

                            if ( cOcc < cOccMin )
                                cOccMin = cOcc;

                            xDecomp->GetOffset( boBeforeWid );
                        }

                        if ( 1 == cWid )
                            cKeysWithOneWid++;

                        if ( cWid >= ( maxWid/2 ) )
                        {
                            printf( "key with >= half wids (%u):\n", cWid );

                            printf( "  pid %#x, len %d, %ws\n",
                                    pKey->Pid(),
                                    pKey->StrLen(),
                                    pKey->GetStr() );

                            printf( "  cb %d: ", pKey->Count() );
                            BYTE const * pb = pKey->GetBuf();
                            for ( ULONG i = 0; i < pKey->Count(); i++ )
                                printf( "  %#x", pb[i] );
                            printf( "\n" );

                            cKeysInMoreThanHalfWids++;
                        }

                        BitOffset boffAfter;
                        xDecomp->GetOffset( boffAfter );

                        DWORD b = Bytes( boffAfter ) - Bytes( boffBefore );

                        if ( b < cbMinimumKey )
                            cbMinimumKey = b;

                        if ( b > cbMaximumKey )
                            cbMaximumKey = b;

                        // Print this data:
                        //   # of files with the key
                        //   # of occurrences of key in all files
                        //   property id
                        //   # of bytes taken by this key in the index
                        //   string form of the key
                        //

                        if ( fKeys )
                            printf( "%7u %10u %4u %7u %ws\n",
                                    cWid,
                                    cOccTotal,
                                    pKey->Pid(),
                                    b,
                                    pKey->GetStr() );

                        boffBefore = boffAfter;

                        if ( cOccMin < cOccMinOverall )
                            cOccMinOverall = cOccMin;

                        if ( cOccMax > cOccMaxOverall )
                            cOccMaxOverall = cOccMax;

                        if ( fFullStats )
                            printf( "%u Workid(s), Total Occ = %u, Min Occ = %u, Max Occ = %u\n",
                                    cWid, cOccTotal, cOccMin, cOccMax );

                        if ( fDistribution )
                            printf( "! %d! %d\n", cWid, cOccTotal );
                    }

                    BitOffset boEnd;
                    xDecomp->GetOffset( boEnd );
                    BitOffset boStart;

                    if ( fOccurrences )
                        for ( ULONG i = 0; i <= cOccMaxOverall; i++ )
                        {
                            printf( "%I64u, ", aOccCounts[ i ] );
                            printf( "%I64u\n", acbOccCounts[ i ] / 8 );
                        }

                    if ( !fDistribution && !fKeys )
                    {
                        printf( "cWidsWithOcc %I64u\n", cWidsWithOcc );
                        printf( "bytes in index: %I64u\n", BitDistance( boStart, boEnd ) / 8 );

                        printf( "max workid %d\n", maxWid );
                        printf( "cKeysInIndex: %d\n", cKeysInIndex );
                        printf( "cOccInIndex %I64u\n", cOccInIndex );
                        printf( "cWidsWithOneOcc %I64u\n", cWidsWithOneOcc );
                        printf( "cWidsWith5OrLessOcc %I64u\n", cWidsWith5OrLessOcc );
                        printf( "cKeysWithOneWid %d\n", cKeysWithOneWid );
                        printf( "cKeysInMoreThanHalfWids %d\n", cKeysInMoreThanHalfWids );

                        printf( "cOccMaxOverall %d\n", cOccMaxOverall );
                        printf( "cOccMinOverall %d\n", cOccMinOverall );

                        printf( "maximum key bytes %d\n", cbMaximumKey );
                        printf( "minimum key bytes %d\n", cbMinimumKey );
                        printf( "bytes for occ data: %I64u\n", ( cBitsForOcc / 8 ) );
                        printf( "bytes for key data: %I64u\n", ( cBitsForKey / 8 ) );
                        printf( "bytes for wid data: %I64u\n", ( cBitsForWid / 8 ) );

                        printf( "total for o+k+w data: %I64u\n", ( cBitsForOcc/8 + cBitsForKey/8 + cBitsForWid/8 ) );
                    }
                }
                else if ( !fKeys && !fDistribution && !fOccurrences )
                {
                    switch ( record.Type() )
                    {
                    case itZombie:
                        printf( "Zombie:       " );
                        break;

                    case itDeleted:
                        printf( "Deleted:      " );
                        break;

                    case itPartition:
                         printf( "Partition:    " );
                         break;

                    case itChangeLog:
                        printf( "ChangeLog:    " );
                        break;

                    case itFreshLog:
                        printf( "FreshLog:     " );
                        break;

                    case itPhraseLat:
                        printf( "Phrase Lat:   " );
                        break;

                    case itKeyList:
                        printf( "Key List:     " );
                        break;

                    case itMMLog:
                        printf( "MM Log:       " );
                        break;

                    case itNewMaster:
                        printf( "New Master:   " );
                        break;

                    case itMMKeyList:
                        printf( "MM Key List:  " );
                        break;
                    } // switch

                    printf( "Object id = 0x%x, Index id = 0x%x, MaxWorkid = 0x%x\n",
                            record.ObjectId(),
                            record.Iid(),
                            record.MaxWorkId() );
                }  // if
            } // while
        } // if
        else
            printf( "0 records found in index table\n" );

        delete [] aOccCounts;
        delete [] acbOccCounts;
    }
    CATCH( CException, e )
    {
        if ( HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) == e.GetErrorCode() )
        {
            printf("Sharing violation -- Is cisvc running?\n");
        }
        else
        {
            printf( "Caught exception 0x%x in %s 0x%x\n",
                    e.GetErrorCode(),
                    ( recCrash.Type() == itMaster ) ? "master index" : "shadow index",
                    recCrash.Iid() );

            printf( "\tProcessing key: %ws (pid = 0x%x)\n", keyCrash.GetStr(), keyCrash.Pid() );

            printf( "\tNear page %u (0x%x), bit offset %u (0x%x) --> File offset 0x%x\n",
                    boffCrash.Page(), boffCrash.Page(),
                    boffCrash.Offset(), boffCrash.Offset(),
                    boffCrash.Page() * CI_PAGE_SIZE + (boffCrash.Offset() + 7)/8 );
        }
    }
    END_CATCH

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\cxxflt\cxxifilt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       cxxifilt.cxx
//
//  Contents:   C++ filter 'class factory'.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <filtreg.hxx>

long gulcInstances = 0;

extern "C" CLSID TYPID_CxxIFilter = {
    0x96fe75e0,
    0xa581,
    0x101a,
    { 0xb5, 0x53, 0x08, 0x00, 0x2b, 0x33, 0xb0, 0xe6 }
};

extern "C" CLSID CLSID_CxxIFilter = {
    0xC1BCD320,
    0xBF96,
    0x11CD,
    { 0xB5, 0x79, 0x08, 0x00, 0x2B, 0x30, 0xBF, 0xEB }
};

extern "C" CLSID CLSID_CxxClass = {
    0x96fe75e1,
    0xa581,
    0x101a,
    { 0xb5, 0x53, 0x08, 0x00, 0x2b, 0x33, 0xb0, 0xe6 }
};

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterBase::CxxIFilterBase
//
//  Synopsis:   Base constructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CxxIFilterBase::CxxIFilterBase()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterBase::~CxxIFilterBase
//
//  Synopsis:   Base destructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CxxIFilterBase::~CxxIFilterBase()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterBase::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilterBase::QueryInterface( REFIID riid,
                                                        void  ** ppvObject)
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IFilter == riid )
        *ppvObject = (IUnknown *)(IFilter *)this;
    else if ( IID_IPersist == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else if ( IID_IPersistFile == riid )
        *ppvObject = (IUnknown *)(IPersistFile *)this;
    else if ( IID_IPersistStream == riid )
        *ppvObject = (IUnknown *)(IPersistStream *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterBase::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CxxIFilterBase::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterBase::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CxxIFilterBase::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::CxxIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CxxIFilterCF::CxxIFilterCF()
{
    _uRefs = 1;
    long c = InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::~CxxIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CxxIFilterCF::~CxxIFilterCF()
{
    long c = InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilterCF::QueryInterface( REFIID riid,
                                                      void  ** ppvObject )
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_ITypeLib == riid )
        sc = E_NOTIMPL;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CxxIFilterCF::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CxxIFilterCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::CreateInstance
//
//  Synopsis:   Creates new TextIFilter object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilterCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    CxxIFilter *  pIUnk = 0;
    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        pIUnk = new CxxIFilter();
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        if( SUCCEEDED(sc) )
            pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pIUnk );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilterCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Text filter class factory
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject( REFCLSID   cid,
                                                      REFIID     iid,
                                                      void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        if ( memcmp( &cid, &CLSID_CxxIFilter, sizeof(cid) ) == 0
          || memcmp( &cid, &CLSID_CxxClass, sizeof(cid) ) == 0 )
            pResult = (IUnknown *) new CxxIFilterCF;
        else
            sc = E_NOINTERFACE;

        if( pResult )
        {
            sc = pResult->QueryInterface( iid, ppvObj );
            pResult->Release(); // Release extra refcount from QueryInterface
        }
    }
    CATCH(CException, e)
    {
        if ( pResult )
            pResult->Release();

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( 0 == gulcInstances )
        return( S_OK );
    else
        return( S_FALSE );
}

SClassEntry const aCxxClasses[] =
{
    { L".cpp", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".hpp", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".cxx", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".hxx", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".c",   L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".h",   L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".w",   L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".acf", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".idl", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".inl", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".odl", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
};

SHandlerEntry const CxxHandler =
{
    L"{5f2cb400-bf96-11cd-b579-08002b30bfeb}",
    L"C++ persistent handler",
    L"{c1bcd320-bf96-11cd-b579-08002b30bfeb}",
};

SFilterEntry const CxxFilter =
{
    L"{c1bcd320-bf96-11cd-b579-08002b30bfeb}",
    L"C++ IFilter",
    L"cxxflt.dll",
    L"Both"
};

DEFINE_DLLREGISTERFILTER( CxxHandler, CxxFilter, aCxxClasses )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\cxxflt\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    10-Aug-93       AmyA            Created
//
//--------------------------------------------------------------------------

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <limits.h>
    #include <string.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <ctype.h>
}

#include <windows.h>

#include <oleext.h>
#include <ntquery.h>
#include <olectl.h>

#include <eh.h>

#include "minici.hxx"
#include "oledberr.h"
#include "filterr.h"
#include "cierror.h"
#include "query.h"
#include "tsource.hxx"
#include "mapper.hxx"
#include "pfilter.hxx"

#include "propwrap.hxx"
#include "cxxifilt.hxx"
#include "tmpprop.hxx"
#include "fstrm.hxx"
#include "cxx.hxx"
#include "cxxflt.hxx"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\cxxflt\tsource.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1994.
//
//  File:       TSource.cxx
//
//  Contents:   TEXT_SOURCE implementation
//
//  Classes:    CTextSource
//
//  History:    14-Apr-94   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::CTextSource, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pFilter] -- IFilter (source of data)
//              [Stat]    -- Chunk statistics
//
//  History:    01-Aug-93 AmyA      Created
//              14-Apr-94 KyleP     Sync with wordbreaker spec
//
//--------------------------------------------------------------------------

CTextSource::CTextSource( IFilter * pFilter, STAT_CHUNK & Stat, CSourceMapper* pMapper )
        : _pMapper (pMapper),
          _pFilter(pFilter),
          _Stat( Stat ),
          _sc( S_OK )
{
    iEnd = 0;
    iCur = 0;
    awcBuffer = _awcFilterBuffer;
    pfnFillTextBuffer = CTextSource::FillBuf;

    if (_pMapper)
    {
        if (_Stat.idChunk == _Stat.idChunkSource)
        {
            _pMapper->NewChunk ( _Stat.idChunk, 0 );
        }
        else
        {
            _pMapper->NewDerivedChunk (
                _Stat.idChunkSource,
                _Stat.cwcStartSource,
                _Stat.cwcLenSource);
        }
    }

    FillBuf( this );
}



//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::FillBuf, public
//
//  Synopsis:   Fills buffer with IFilter::GetText and IFilter::GetChunk
//
//  History:    01-Aug-93 AmyA      Created
//              20-Apr-94 KyleP     Sync with spec
//
//  Notes:      NOTE! In several places, this function casts const away
//              from awcBuffer.  This is an acceptable cast from const to
//              non-const. The buffer is const to the client but non-const
//              to the server.
//
//--------------------------------------------------------------------------

SCODE CTextSource::FillBuf( TEXT_SOURCE * pTextSource )
{
    CTextSource * pthis = (CTextSource *)pTextSource;

    //
    // Never continue past an error condition other than FILTER_E_NO_MORE_TEXT
    //

    if ( FAILED( pthis->_sc ) && pthis->_sc != FILTER_E_NO_MORE_TEXT )
        return( pthis->_sc );

    //
    // Move any existing text to beginning of buffer.
    //

    Win4Assert ( pthis->iEnd >= pthis->iCur );

    ULONG ccLeftOver = pthis->iEnd - pthis->iCur;

    if ( ccLeftOver > 0 )
    {
        RtlMoveMemory( (WCHAR *)pthis->awcBuffer,
                       &pthis->awcBuffer[pthis->iCur],
                       ccLeftOver * sizeof (WCHAR) );
    }

    if (pthis->_pMapper)
    {
        // this much has been processed from the current chunk
        pthis->_pMapper->Advance ( pthis->iCur );
    }

    pthis->iCur = 0;
    pthis->iEnd = ccLeftOver;
    ULONG ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
    const BUFFER_SLOP = 10;  // Buffer is attempted to be filled until BUFFER_SLOP remains

    //
    // Get some more text.  If *previous* call to GetText returned
    // FILTER_S_LAST_TEXT, or FILTER_E_NO_MORE_TEXT then don't even
    // bother trying.
    //

    if ( pthis->_sc == FILTER_S_LAST_TEXT || pthis->_sc == FILTER_E_NO_MORE_TEXT )
        pthis->_sc = FILTER_E_NO_MORE_TEXT;
    else
    {
        pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                               (WCHAR *) &pthis->awcBuffer[ccLeftOver] );

        if ( SUCCEEDED( pthis->_sc ) )
        {
            pthis->iEnd += ccRead;
            ccLeftOver += ccRead;
            ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;

            while ( pthis->_sc == S_OK && ccRead > BUFFER_SLOP )
            {
               //
               // Attempt to fill in as much of buffer as possible before returning
               //
               pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                                     (WCHAR *) &pthis->awcBuffer[ccLeftOver] );
               if ( SUCCEEDED( pthis->_sc ) )
               {
                  pthis->iEnd += ccRead;
                  ccLeftOver += ccRead;
                  ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
               }
            }

#if 0
            DebugPrintBuffer( pthis );
#endif
            //
            // Either return FILTER_S_LAST_TEXT or return S_OK because we have succeeded in
            // adding text to the buffer
            //
            if ( pthis->_sc == FILTER_S_LAST_TEXT )
                 return FILTER_S_LAST_TEXT;
            else
                 return S_OK;
        }

        if ( pthis->_sc != FILTER_E_NO_MORE_TEXT )
        {
            //
            // Weird failure, hence return, else goto next chunk
            //
            return pthis->_sc;
        }
    }

    //
    // Go to next chunk, if necessary.
    //

    while ( pthis->_sc == FILTER_E_NO_MORE_TEXT )
    {
        pthis->_sc = pthis->_pFilter->GetChunk( &pthis->_Stat );

        if ( pthis->_sc == FILTER_E_END_OF_CHUNKS )
            return WBREAK_E_END_OF_TEXT;

        if ( FAILED( pthis->_sc ) )
            return( pthis->_sc );

        if ( pthis->_Stat.flags & CHUNK_VALUE )
        {
            pthis->_sc = FILTER_E_NO_TEXT;
            return WBREAK_E_END_OF_TEXT;
        }

        if ( pthis->_Stat.breakType != CHUNK_NO_BREAK )
        {
            pthis->_sc = WBREAK_E_END_OF_TEXT;
            return WBREAK_E_END_OF_TEXT;
        }

#if 0
        ciDebugOut(( DEB_WORDS, "TEXT SOURCE: NoBreak chunk\n" ));
#endif

        if (pthis->_pMapper)
        {
            ULONG idChunk = pthis->_Stat.idChunk;
            if (idChunk == pthis->_Stat.idChunkSource)
            {
                pthis->_pMapper->NewChunk ( idChunk, ccLeftOver );
            }
            else
            {
                pthis->_sc = WBREAK_E_END_OF_TEXT;
                return WBREAK_E_END_OF_TEXT;
            }
        }

        ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
        pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                               (WCHAR *) &pthis->awcBuffer[ccLeftOver] );

        if ( SUCCEEDED( pthis->_sc ) )
        {
            pthis->iEnd += ccRead;
            ccLeftOver += ccRead;
            ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;

            while ( pthis->_sc == S_OK && ccRead > BUFFER_SLOP )
            {
               //
               // Attempt to fill in as much of buffer as possible before returning
               //
               pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                                     (WCHAR *) &pthis->awcBuffer[ccLeftOver] );
               if ( SUCCEEDED( pthis->_sc ) )
               {
                  pthis->iEnd += ccRead;
                  ccLeftOver += ccRead;
                  ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
               }
            }

#if 0
            DebugPrintBuffer( pthis );
#endif
            //
            // Either return FILTER_S_LAST_TEXT or return S_OK because we have succeeded in
            // adding text to the buffer
            //
            if ( pthis->_sc == FILTER_S_LAST_TEXT )
                 return FILTER_S_LAST_TEXT;
            else
                 return S_OK;
        }
    }

    if ( FAILED( pthis->_sc ) )
        return( pthis->_sc );

    if ( ccRead == 0 )
        return WBREAK_E_END_OF_TEXT;

    Win4Assert( pthis->iCur == 0 );
    Win4Assert( pthis->iEnd == ccLeftOver );

#if 0
    ciDebugOut(( DEB_WORDS, "TEXT SOURCE: Fill buffer with %d characters. %d left over\n",
                 pthis->iEnd, ccLeftOver ));
#endif

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::DebugPrintBuffer
//
//  Synopsis:   Debug print the text buffer
//
//  Arguments:  [pThis] -- Pointer to text source
//
//  History:    08-Apr-97   SitaramR      Created
//
//--------------------------------------------------------------------------

void CTextSource::DebugPrintBuffer( CTextSource *pthis )
{
#if 0
   if ( ciInfoLevel & DEB_WORDS )
      {
          ciDebugOut(( DEB_WORDS, "CTextSource::FillBuf -- iCur = %u, iEnd = %u\n",
                       pthis->iCur, pthis->iEnd ));

          BOOL fOk = TRUE;
          for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
          {
              if ( pthis->awcBuffer[i] > 0xFF )
              {
                  fOk = FALSE;
                  break;
              }
          }

          if ( fOk )
          {
              unsigned j = 0;
              WCHAR awcTemp[71];

              for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
              {
                  awcTemp[j] = pthis->awcBuffer[i];
                  j++;

                  if ( j == sizeof(awcTemp)/sizeof(awcTemp[0]) - 1 )
                  {
                      awcTemp[j] = 0;
                      ciDebugOut(( DEB_WORDS, "%ws\n", awcTemp ));
                      j = 0;
                  }
              }

              awcTemp[j] = 0;
              ciDebugOut(( DEB_WORDS, "%ws\n", awcTemp ));
          }
          else
          {
              unsigned j = 0;

              for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
              {
                  if ( 0 == j )
                      ciDebugOut(( DEB_WORDS, "%04X", pthis->awcBuffer[i] ));
                  else if ( 14 == j )
                  {
                      ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, " %04X\n", pthis->awcBuffer[i] ));
                  }
                  else
                      ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, " %04X", pthis->awcBuffer[i] ));

                  j++;

                  if ( j > 14 )
                      j = 0;
              }

              ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, "\n" ));
          }

      }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\enumprop\enumprop.cxx ===
#define UNICODE
#define _OLE32_

#include <windows.h>
#include <shlobj.h>
#include <shlguid.h>

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <eh.h>

#include <oleext.h>
#include <oledberr.h>
#include <filterr.h>
#include <cierror.h>
#include <oledb.h>
#include <ciodm.h>
#include <oledbdep.h>
#include <cmdtree.h>
#include <indexsrv.h>

// local headers

#include "minici.hxx"
#include "propinfo.hxx"

typedef HRESULT (STDAPICALLTYPE * LPStgOpenStorageEx) (
    const WCHAR* pwcsName,
    DWORD grfMode,
    DWORD stgfmt,              // enum
    DWORD grfAttrs,            // reserved
    STGOPTIONS * pStgOptions,
    void * reserved,
    REFIID riid,
    void ** ppObjectOpen );

typedef HRESULT (STDAPICALLTYPE * PSHGetDesktopFolder) (
    IShellFolder ** ppshf );

typedef HRESULT (STDAPICALLTYPE * PSHBindToParent) (
    LPCITEMIDLIST pidl,
    REFIID riid,
    void **ppv,
    LPCITEMIDLIST *ppidlLast);

PSHGetDesktopFolder pShGetDesktopFolder = 0;
PSHBindToParent pShBindToParent = 0;

struct SProperty
{
    PROPID        pid;
    WCHAR const * pwcName;
};

struct SPropertySet
{
    GUID          guid;
    WCHAR const * pwcName;
    SProperty *   pProperties;
    ULONG         cProperties;
};

const SProperty aImageSummaryProps[] =
{
    { PIDISI_FILETYPE, L"file type" },       
    { PIDISI_CX, L"cx" },             
    { PIDISI_CY, L"cy" },             
    { PIDISI_RESOLUTIONX, L"resolution x" },    
    { PIDISI_RESOLUTIONY, L"resolution y" },    
    { PIDISI_BITDEPTH, L"bit depth" },       
    { PIDISI_COLORSPACE, L"color space" },     
    { PIDISI_COMPRESSION, L"compression" },    
    { PIDISI_TRANSPARENCY, L"transparency" },   
    { PIDISI_GAMMAVALUE, L"gamma value" },     
    { PIDISI_FRAMECOUNT, L"frame count" },     
    { PIDISI_DIMENSIONS, L"dimensions" },     
};

const SProperty aSummaryProps[] =
{
    { PIDSI_TITLE, L"title" },
    { PIDSI_SUBJECT, L"subject" },
    { PIDSI_AUTHOR, L"author" },
    { PIDSI_KEYWORDS, L"keywords" },
    { PIDSI_COMMENTS, L"comments" },
    { PIDSI_TEMPLATE, L"template" },
    { PIDSI_LASTAUTHOR, L"last author" },
    { PIDSI_REVNUMBER, L"revision number" },
    { PIDSI_EDITTIME, L"edit time" },
    { PIDSI_LASTPRINTED, L"last printed" },
    { PIDSI_CREATE_DTM, L"create date" },
    { PIDSI_LASTSAVE_DTM, L"last save date" },
    { PIDSI_PAGECOUNT, L"page count" },
    { PIDSI_WORDCOUNT, L"word count" },
    { PIDSI_CHARCOUNT, L"character count" },
    { PIDSI_THUMBNAIL, L"thumbnail" },
    { PIDSI_APPNAME, L"application name" },
    { PIDSI_DOC_SECURITY, L"document security" },
};

const SProperty aDocSummaryProps[] =
{
    { PIDDSI_CATEGORY, L"category" },
    { PIDDSI_PRESFORMAT, L"presentation format" },
    { PIDDSI_BYTECOUNT, L"byte count" },
    { PIDDSI_LINECOUNT, L"line count" },
    { PIDDSI_PARCOUNT, L"paragraph count" },
    { PIDDSI_SLIDECOUNT, L"slide count" },
    { PIDDSI_NOTECOUNT, L"note count" },
    { PIDDSI_HIDDENCOUNT, L"hidden count" },
    { PIDDSI_MMCLIPCOUNT, L"mm clip count" },
    { PIDDSI_SCALE, L"scale" },
    { PIDDSI_HEADINGPAIR, L"heading pair" },
    { PIDDSI_DOCPARTS, L"document parts" },
    { PIDDSI_MANAGER, L"manager" },
    { PIDDSI_COMPANY, L"company" },
    { PIDDSI_LINKSDIRTY, L"links dirty" },
};

const SProperty aImageProps[] =
{
    { PropertyTagNewSubfileType, L"NewSubfileType" },
    { PropertyTagSubfileType, L"SubfileType" },
    { PropertyTagImageWidth, L"ImageWidth" },
    { PropertyTagImageHeight, L"ImageHeight" },
    { PropertyTagBitsPerSample, L"BitsPerSample" },
    { PropertyTagCompression, L"Compression" },
    { PropertyTagPhotometricInterp, L"PhotometricInterp" },
    { PropertyTagThreshHolding, L"ThreshHolding" },
    { PropertyTagCellWidth, L"CellWidth" },
    { PropertyTagCellHeight, L"CellHeight" },
    { PropertyTagFillOrder, L"FillOrder" },
    { PropertyTagDocumentName, L"DocumentName" },
    { PropertyTagImageDescription, L"ImageDescription" },
    { PropertyTagEquipMake, L"EquipMake" },
    { PropertyTagEquipModel, L"EquipModel" },
    { PropertyTagStripOffsets, L"StripOffsets" },
    { PropertyTagOrientation, L"Orientation" },
    { PropertyTagSamplesPerPixel, L"SamplesPerPixel" },
    { PropertyTagRowsPerStrip, L"RowsPerStrip" },
    { PropertyTagStripBytesCount, L"StripBytesCount" },
    { PropertyTagMinSampleValue, L"MinSampleValue" },
    { PropertyTagMaxSampleValue, L"MaxSampleValue" },
    { PropertyTagXResolution, L"XResolution" },
    { PropertyTagYResolution, L"YResolution" },
    { PropertyTagPlanarConfig, L"PlanarConfig" },
    { PropertyTagPageName, L"PageName" },
    { PropertyTagXPosition, L"XPosition" },
    { PropertyTagYPosition, L"YPosition" },
    { PropertyTagFreeOffset, L"FreeOffset" },
    { PropertyTagFreeByteCounts, L"FreeByteCounts" },
    { PropertyTagGrayResponseUnit, L"GrayResponseUnit" },
    { PropertyTagGrayResponseCurve, L"GrayResponseCurve" },
    { PropertyTagT4Option, L"T4Option" },
    { PropertyTagT6Option, L"T6Option" },
    { PropertyTagResolutionUnit, L"ResolutionUnit" },
    { PropertyTagPageNumber, L"PageNumber" },
    { PropertyTagTransferFuncition, L"TransferFuncition" },
    { PropertyTagSoftwareUsed, L"SoftwareUsed" },
    { PropertyTagDateTime, L"DateTime" },
    { PropertyTagArtist, L"Artist" },
    { PropertyTagHostComputer, L"HostComputer" },
    { PropertyTagPredictor, L"Predictor" },
    { PropertyTagWhitePoint, L"WhitePoint" },
    { PropertyTagPrimaryChromaticities, L"PrimaryChromaticities" },
    { PropertyTagColorMap, L"ColorMap" },
    { PropertyTagHalftoneHints, L"HalftoneHints" },
    { PropertyTagTileWidth, L"TileWidth" },
    { PropertyTagTileLength, L"TileLength" },
    { PropertyTagTileOffset, L"TileOffset" },
    { PropertyTagTileByteCounts, L"TileByteCounts" },
    { PropertyTagInkSet, L"InkSet" },
    { PropertyTagInkNames, L"InkNames" },
    { PropertyTagNumberOfInks, L"NumberOfInks" },
    { PropertyTagDotRange, L"DotRange" },
    { PropertyTagTargetPrinter, L"TargetPrinter" },
    { PropertyTagExtraSamples, L"ExtraSamples" },
    { PropertyTagSampleFormat, L"SampleFormat" },
    { PropertyTagSMinSampleValue, L"SMinSampleValue" },
    { PropertyTagSMaxSampleValue, L"SMaxSampleValue" },
    { PropertyTagTransferRange, L"TransferRange" },
    { PropertyTagJPEGProc, L"JPEGProc" },
    { PropertyTagJPEGInterFormat, L"JPEGInterFormat" },
    { PropertyTagJPEGInterLength, L"JPEGInterLength" },
    { PropertyTagJPEGRestartInterval, L"JPEGRestartInterval" },
    { PropertyTagJPEGLosslessPredictors, L"JPEGLosslessPredictors" },
    { PropertyTagJPEGPointTransforms, L"JPEGPointTransforms" },
    { PropertyTagJPEGQTables, L"JPEGQTables" },
    { PropertyTagJPEGDCTables, L"JPEGDCTables" },
    { PropertyTagJPEGACTables, L"JPEGACTables" },
    { PropertyTagYCbCrCoefficients, L"YCbCrCoefficients" },
    { PropertyTagYCbCrSubsampling, L"YCbCrSubsampling" },
    { PropertyTagYCbCrPositioning, L"YCbCrPositioning" },
    { PropertyTagREFBlackWhite, L"REFBlackWhite" },
    { PropertyTagICCProfile, L"ICCProfile" },
    { PropertyTagGamma, L"Gamma" },
    { PropertyTagICCProfileDescriptor, L"ICCProfileDescriptor" },
    { PropertyTagSRGBRenderingIntent, L"SRGBRenderingIntent" },
    { PropertyTagImageTitle, L"ImageTitle" },
    { PropertyTagCopyright, L"Copyright" },
    { PropertyTagResolutionXUnit, L"ResXUnit" },
    { PropertyTagResolutionYUnit, L"ResYUnit" },
    { PropertyTagResolutionXLengthUnit, L"ResXLengthUnit" },
    { PropertyTagResolutionYLengthUnit, L"ResYLengthUnit" },
    { PropertyTagPrintFlags, L"PrintFlags" },
    { PropertyTagPrintFlagsVersion, L"PrintFlagsVersion" },
    { PropertyTagPrintFlagsCrop, L"PrintFlagsCrop" },
    { PropertyTagPrintFlagsBleedWidth, L"PrintFlagsBleedWidth" },
    { PropertyTagPrintFlagsBleedWidthScale, L"PrintFlagsBleedWidthScale" },
    { PropertyTagHalftoneLPI, L"HalftoneLPI" },
    { PropertyTagHalftoneLPIUnit, L"HalftoneLPIUnit" },
    { PropertyTagHalftoneDegree, L"HalftoneDegree" },
    { PropertyTagHalftoneShape, L"HalftoneShape" },
    { PropertyTagHalftoneMisc, L"HalftoneMisc" },
    { PropertyTagHalftoneScreen, L"HalftoneScreen" },
    { PropertyTagJPEGQuality, L"JPEGQuality" },
    { PropertyTagGridSize, L"GridSize" },
    { PropertyTagThumbnailFormat, L"ThumbFormat" },
    { PropertyTagThumbnailWidth, L"ThumbWidth" },
    { PropertyTagThumbnailHeight, L"ThumbHeight" },
    { PropertyTagThumbnailColorDepth, L"ThumbColorDepth" },
    { PropertyTagThumbnailPlanes, L"ThumbPlanes" },
    { PropertyTagThumbnailRawBytes, L"ThumbRawBytes" },
    { PropertyTagThumbnailSize, L"ThumbSize" },
    { PropertyTagThumbnailCompressedSize, L"ThumbCompressedSize" },
    { PropertyTagColorTransferFunction, L"ColorTransferFunction" },
    { PropertyTagThumbnailData, L"ThumbData" },
    { PropertyTagThumbnailImageWidth, L"ThumbImageWidth" },
    { PropertyTagThumbnailImageHeight, L"ThumbImageHeight" },
    { PropertyTagThumbnailBitsPerSample, L"ThumbBitsPerSample" },
    { PropertyTagThumbnailCompression, L"ThumbCompression" },
    { PropertyTagThumbnailPhotometricInterp, L"ThumbPhotometricInterp" },
    { PropertyTagThumbnailImageDescription, L"ThumbImageDescription" },
    { PropertyTagThumbnailEquipMake, L"ThumbEquipMake" },
    { PropertyTagThumbnailEquipModel, L"ThumbEquipModel" },
    { PropertyTagThumbnailStripOffsets, L"ThumbStripOffsets" },
    { PropertyTagThumbnailOrientation, L"ThumbOrientation" },
    { PropertyTagThumbnailSamplesPerPixel, L"ThumbSamplesPerPixel" },
    { PropertyTagThumbnailRowsPerStrip, L"ThumbRowsPerStrip" },
    { PropertyTagThumbnailStripBytesCount, L"ThumbStripBytesCount" },
    { PropertyTagThumbnailResolutionX, L"ThumbResolutionX" },
    { PropertyTagThumbnailResolutionY, L"ThumbResolutionY" },
    { PropertyTagThumbnailPlanarConfig, L"ThumbPlanarConfig" },
    { PropertyTagThumbnailResolutionUnit, L"ThumbResolutionUnit" },
    { PropertyTagThumbnailTransferFunction, L"ThumbTransferFunction" },
    { PropertyTagThumbnailSoftwareUsed, L"ThumbSoftwareUsed" },
    { PropertyTagThumbnailDateTime, L"ThumbDateTime" },
    { PropertyTagThumbnailArtist, L"ThumbArtist" },
    { PropertyTagThumbnailWhitePoint, L"ThumbWhitePoint" },
    { PropertyTagThumbnailPrimaryChromaticities, L"ThumbPrimaryChromaticities" },
    { PropertyTagThumbnailYCbCrCoefficients, L"ThumbYCbCrCoefficients" },
    { PropertyTagThumbnailYCbCrSubsampling, L"ThumbYCbCrSubsampling" },
    { PropertyTagThumbnailYCbCrPositioning, L"ThumbYCbCrPositioning" },
    { PropertyTagThumbnailRefBlackWhite, L"ThumbRefBlackWhite" },
    { PropertyTagThumbnailCopyRight, L"ThumbCopyRight" },
    { PropertyTagLuminanceTable, L"LuminanceTable" },
    { PropertyTagChrominanceTable, L"ChrominanceTable" },
    { PropertyTagFrameDelay, L"FrameDelay" },
    { PropertyTagLoopCount, L"LoopCount" },
    { PropertyTagPixelUnit, L"PixelUnit" },
    { PropertyTagPixelPerUnitX, L"PixelPerUnitX" },
    { PropertyTagPixelPerUnitY, L"PixelPerUnitY" },
    { PropertyTagPaletteHistogram, L"PaletteHistogram" },
    { PropertyTagExifExposureTime, L"ExifExposureTime" },
    { PropertyTagExifFNumber, L"ExifFNumber" },
    { PropertyTagExifExposureProg, L"ExifExposureProg" },
    { PropertyTagExifSpectralSense, L"ExifSpectralSense" },
    { PropertyTagExifISOSpeed, L"ExifISOSpeed" },
    { PropertyTagExifOECF, L"ExifOECF" },
    { PropertyTagExifVer, L"ExifVer" },
    { PropertyTagExifDTOrig, L"ExifDTOrig" },
    { PropertyTagExifDTDigitized, L"ExifDTDigitized" },
    { PropertyTagExifCompConfig, L"ExifCompConfig" },
    { PropertyTagExifCompBPP, L"ExifCompBPP" },
    { PropertyTagExifShutterSpeed, L"ExifShutterSpeed" },
    { PropertyTagExifAperture, L"ExifAperture" },
    { PropertyTagExifBrightness, L"ExifBrightness" },
    { PropertyTagExifExposureBias, L"ExifExposureBias" },
    { PropertyTagExifMaxAperture, L"ExifMaxAperture" },
    { PropertyTagExifSubjectDist, L"ExifSubjectDist" },
    { PropertyTagExifMeteringMode, L"ExifMeteringMode" },
    { PropertyTagExifLightSource, L"ExifLightSource" },
    { PropertyTagExifFlash, L"ExifFlash" },
    { PropertyTagExifFocalLength, L"ExifFocalLength" },
    { PropertyTagExifMakerNote, L"ExifMakerNote" },
    { PropertyTagExifUserComment, L"ExifUserComment" },
    { PropertyTagExifDTSubsec, L"ExifDTSubsec" },
    { PropertyTagExifDTOrigSS, L"ExifDTOrigSS" },
    { PropertyTagExifDTDigSS, L"ExifDTDigSS" },
    { PropertyTagExifFPXVer, L"ExifFPXVer" },
    { PropertyTagExifColorSpace, L"ExifColorSpace" },
    { PropertyTagExifPixXDim, L"ExifPixXDim" },
    { PropertyTagExifPixYDim, L"ExifPixYDim" },
    { PropertyTagExifRelatedWav, L"ExifRelatedWav" },
    { PropertyTagExifInterop, L"ExifInterop" },
    { PropertyTagExifFlashEnergy, L"ExifFlashEnergy" },
    { PropertyTagExifSpatialFR, L"ExifSpatialFR" },
    { PropertyTagExifFocalXRes, L"ExifFocalXRes" },
    { PropertyTagExifFocalYRes, L"ExifFocalYRes" },
    { PropertyTagExifFocalResUnit, L"ExifFocalResUnit" },
    { PropertyTagExifSubjectLoc, L"ExifSubjectLoc" },
    { PropertyTagExifExposureIndex, L"ExifExposureIndex" },
    { PropertyTagExifSensingMethod, L"ExifSensingMethod" },
    { PropertyTagExifFileSource, L"ExifFileSource" },
    { PropertyTagExifSceneType, L"ExifSceneType" },
    { PropertyTagExifCfaPattern, L"ExifCfaPattern" },
    { PropertyTagGpsVer, L"GpsVer" },
    { PropertyTagGpsLatitudeRef, L"GpsLatitudeRef" },
    { PropertyTagGpsLatitude, L"GpsLatitude" },
    { PropertyTagGpsLongitudeRef, L"GpsLongitudeRef" },
    { PropertyTagGpsLongitude, L"GpsLongitude" },
    { PropertyTagGpsAltitudeRef, L"GpsAltitudeRef" },
    { PropertyTagGpsAltitude, L"GpsAltitude" },
    { PropertyTagGpsGpsTime, L"GpsGpsTime" },
    { PropertyTagGpsGpsSatellites, L"GpsGpsSatellites" },
    { PropertyTagGpsGpsStatus, L"GpsGpsStatus" },
    { PropertyTagGpsGpsMeasureMode, L"GpsGpsMeasureMode" },
    { PropertyTagGpsGpsDop, L"GpsGpsDop" },
    { PropertyTagGpsSpeedRef, L"GpsSpeedRef" },
    { PropertyTagGpsSpeed, L"GpsSpeed" },
    { PropertyTagGpsTrackRef, L"GpsTrackRef" },
    { PropertyTagGpsTrack, L"GpsTrack" },
    { PropertyTagGpsImgDirRef, L"GpsImgDirRef" },
    { PropertyTagGpsImgDir, L"GpsImgDir" },
    { PropertyTagGpsMapDatum, L"GpsMapDatum" },
    { PropertyTagGpsDestLatRef, L"GpsDestLatRef" },
    { PropertyTagGpsDestLat, L"GpsDestLat" },
    { PropertyTagGpsDestLongRef, L"GpsDestLongRef" },
    { PropertyTagGpsDestLong, L"GpsDestLong" },
    { PropertyTagGpsDestBearRef, L"GpsDestBearRef" },
    { PropertyTagGpsDestBear, L"GpsDestBear" },
    { PropertyTagGpsDestDistRef, L"GpsDestDistRef" },
    { PropertyTagGpsDestDist, L"GpsDestDist" },
};

const SProperty aMusicProps[] =
{
    { PIDSI_ARTIST, L"artist" },   
    { PIDSI_SONGTITLE, L"song title" },  
    { PIDSI_ALBUM, L"album" },    
    { PIDSI_YEAR, L"year" },     
    { PIDSI_COMMENT, L"comment" },  
    { PIDSI_TRACK, L"track" },    
    { PIDSI_GENRE, L"genre" },    
    { PIDSI_LYRICS, L"lyrics" },   
};

const SProperty aAudioProps[] =
{
    { PIDASI_FORMAT, L"format" },         
    { PIDASI_TIMELENGTH, L"time length" },     
    { PIDASI_AVG_DATA_RATE, L"average data rate" },  
    { PIDASI_SAMPLE_RATE, L"sample rate" },    
    { PIDASI_SAMPLE_SIZE, L"sample size" },    
    { PIDASI_CHANNEL_COUNT, L"channel count" },  
    { PIDASI_STREAM_NUMBER, L"stream number" },  
    { PIDASI_STREAM_NAME, L"stream name" },    
    { PIDASI_COMPRESSION, L"compression" },    
};

const SProperty aDRMProps[] =
{
    { PIDDRSI_PROTECTED, L"protected" },    
    { PIDDRSI_DESCRIPTION, L"description" },  
    { PIDDRSI_PLAYCOUNT, L"play count" },    
    { PIDDRSI_PLAYSTARTS, L"play starts" },   
    { PIDDRSI_PLAYEXPIRES, L"play expires" },  
};

const SProperty aVideoProps[] =
{
    { PIDVSI_STREAM_NAME, L"stream name" },
    { PIDVSI_FRAME_WIDTH, L"width" },
    { PIDVSI_FRAME_HEIGHT, L"height" },
    { PIDVSI_TIMELENGTH, L"time length" },
    { PIDVSI_FRAME_COUNT, L"frame count" },
    { PIDVSI_FRAME_RATE, L"frame rate" },
    { PIDVSI_DATA_RATE, L"data rate" },
    { PIDVSI_SAMPLE_SIZE, L"sample size" },
    { PIDVSI_COMPRESSION, L"compression" },
    { PIDVSI_STREAM_NUMBER, L"stream number" },
};

#define ArrayCount( x ) (SProperty *) x, sizeof x / sizeof x[0]

const SPropertySet g_aPropSets[] =
{
    { PSGUID_IMAGESUMMARYINFORMATION, L"Image Summary Information", ArrayCount( aImageSummaryProps ) },
    { PSGUID_SUMMARYINFORMATION, L"Summary Information", ArrayCount( aSummaryProps ) },
    { PSGUID_DOCUMENTSUMMARYINFORMATION, L"Document Summary Information", ArrayCount( aDocSummaryProps ) },
    { PSGUID_IMAGEPROPERTIES, L"Image Properties", ArrayCount( aImageProps ) },
    { PSGUID_MUSIC, L"Music", ArrayCount( aMusicProps ) },
    { PSGUID_AUDIO, L"Audio", ArrayCount( aAudioProps ) },
    { PSGUID_DRM, L"Digital Rights Management", ArrayCount( aDRMProps ) },
    { PSGUID_VIDEO, L"Video", ArrayCount( aVideoProps ) },
};

const ULONG g_cPropSets = sizeof g_aPropSets / sizeof g_aPropSets[0];

const WCHAR * aVariantType[] =
{
    /* 0  0  */ { L"vt_empty" },
    /* 1  1  */ { L"vt_null" },
    /* 2  2  */ { L"vt_i2" },
    /* 3  3  */ { L"vt_i4" },
    /* 4  4  */ { L"vt_r4" },
    /* 5  5  */ { L"vt_r8" },
    /* 6  6  */ { L"vt_cy" },
    /* 7  7  */ { L"vt_date" },
    /* 8  8  */ { L"vt_bstr" },
    /* 9  9  */ { L"vt_dispatch*/" },
    /* a  10 */ { L"vt_error" },
    /* b  11 */ { L"vt_bool" },
    /* c  12 */ { L"vt_variant" },
    /* d  13 */ { L"vt_unknown" },
    /* e  14 */ { L"vt_decimal" },
    /* f  15 */ { 0 },
    /* 10 16 */ { L"vt_i1" },
    /* 11 17 */ { L"vt_ui1" },
    /* 12 18 */ { L"vt_ui2" },
    /* 13 19 */ { L"vt_ui4" },
    /* 14 20 */ { L"vt_i8" },
    /* 15 21 */ { L"vt_ui8" },
    /* 16 22 */ { L"vt_int" },
    /* 17 23 */ { L"vt_uint" },
    /* 18 24 */ { L"vt_void" },
    /* 19 25 */ { L"vt_hresult" },
    /* 1a 26 */ { L"vt_ptr" },
    /* 1b 27 */ { L"vt_safearray" },
    /* 1c 28 */ { L"vt_carray" },
    /* 1d 29 */ { L"vt_userdefined" },
    /* 1e 30 */ { L"vt_lpstr" },
    /* 1f 31 */ { L"vt_lpwstr" },
    /* 20 32 */ { 0 },
    /* 21 33 */ { 0 },
    /* 22 34 */ { 0 },
    /* 23 35 */ { 0 },
    /* 24 36 */ { L"vt_record" },
    /* 25 37 */ { L"vt_int_ptr" },
    /* 26 38 */ { L"vt_uint_ptr" },
    {0},                           //     39 unused
    {0}, {0}, {0}, {0}, {0},       //     40-44, unused
    {0}, {0}, {0}, {0}, {0},       //     45-49, unused
    {0}, {0}, {0}, {0}, {0},       //     50-54, unused
    {0}, {0}, {0}, {0}, {0},       //     55-59, unused
    /* 3c 60 */ { 0 },
    /* 3d 61 */ { 0 },
    /* 3e 62 */ { 0 },
    /* 3f 63 */ { 0 },
    /* 40 64 */ { L"vt_filetime" },
    /* 41 65 */ { L"vt_blob" },
    /* 42 66 */ { L"vt_stream" },
    /* 43 67 */ { L"vt_storage" },
    /* 44 68 */ { L"vt_streamed_object" },
    /* 45 69 */ { L"vt_stored_object" },
    /* 46 70 */ { L"vt_blob_object" },
    /* 47 71 */ { L"vt_cf" },
    /* 48 72 */ { L"vt_clsid" },
    /* 49 73 */ { L"vt_versioned_stream" },
};

const ULONG cVariantType = sizeof aVariantType / sizeof aVariantType[0];

void Usage()
{
    printf( "usage: enumprop [-s] filename\n" );
    printf( "       -s   -- use the shell's property code instead of OLE\n" );
    exit( 1 );
} //Usage

void PrintVariantType( VARTYPE vt )
{
    printf( "%#-6x ", vt );

    VARTYPE vtBase = vt & VT_TYPEMASK;

    if ( ( vtBase < cVariantType ) &&
         ( 0 != aVariantType[vtBase] ) )
         printf( "%-11ws ", aVariantType[vtBase] );
    else
         printf( "?           " );

    if ( VT_VECTOR & vt )
        printf( "|vt_vector" );

    if ( VT_ARRAY & vt )
        printf( "|vt_array" );

    if ( VT_BYREF & vt )
        printf( "|vt_byref" );
} //PrintVariantType

//+-------------------------------------------------------------------------
//
//  Function:   Render
//
//  Synopsis:   Prints an item in a safearray
//
//  Arguments:  [vt]  - type of the element
//              [pa]  - pointer to the item
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa );

void Render( VARTYPE vt, void * pv )
{
    if ( VT_ARRAY & vt )
    {
        PrintSafeArray( vt - VT_ARRAY, *(SAFEARRAY **) pv );
        return;
    }

    switch ( vt )
    {
        case VT_UI1: wprintf( L"%u", (unsigned) *(BYTE *)pv ); break;
        case VT_I1: wprintf( L"%d", (int) *(CHAR *)pv ); break;
        case VT_UI2: wprintf( L"%u", (unsigned) *(USHORT *)pv ); break;
        case VT_I2: wprintf( L"%d", (int) *(SHORT *)pv ); break;
        case VT_UI4:
        case VT_UINT: wprintf( L"%u", (unsigned) *(ULONG *)pv ); break;
        case VT_I4:
        case VT_ERROR:
        case VT_INT: wprintf( L"%d", *(LONG *)pv ); break;
        case VT_UI8: wprintf( L"%I64u", *(unsigned __int64 *)pv ); break;
        case VT_I8: wprintf( L"%I64d", *(__int64 *)pv ); break;
        case VT_R4: wprintf( L"%f", *(float *)pv ); break;
        case VT_R8: wprintf( L"%lf", *(double *)pv ); break;
        case VT_DECIMAL:
        {
            double dbl;
            HRESULT hr = VarR8FromDec( (DECIMAL *) pv, &dbl );
            if ( SUCCEEDED( hr ) )
                wprintf( L"%lf", dbl );
            break;
        }
        case VT_CY:
        {
            double dbl;
            HRESULT hr = VarR8FromCy( * (CY *) pv, &dbl );
            if ( SUCCEEDED( hr ) )
                wprintf( L"%lf", dbl );
            break;
        }
        case VT_BOOL: wprintf( *(VARIANT_BOOL *)pv ? L"TRUE" : L"FALSE" ); break;
        case VT_BSTR: wprintf( L"%ws", *(BSTR *) pv ); break;
        case VT_VARIANT:
        {
            PROPVARIANT * pVar = (PROPVARIANT *) pv;
            Render( pVar->vt, & pVar->lVal );
            break;
        }
        case VT_DATE:
        {
            SYSTEMTIME st;
            BOOL fOK = VariantTimeToSystemTime( *(DATE *)pv, &st );

            if ( !fOK )
                break;

            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            wprintf( L"%2d-%02d-%04d %2d:%02d%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    (DWORD) st.wSecond,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_EMPTY:
        case VT_NULL:
            break;
        default :
        {
            wprintf( L"(vt 0x%x)", (int) vt );
            break;
        }
    }
} //Render

//+-------------------------------------------------------------------------
//
//  Function:   PrintSafeArray
//
//  Synopsis:   Prints items in a safearray
//
//  Arguments:  [vt]  - type of elements in the safearray
//              [pa]  - pointer to the safearray
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa )
{
    // Get the dimensions of the array

    UINT cDim = SafeArrayGetDim( pa );
    if ( 0 == cDim )
        return;

    XPtr<LONG> xDim( cDim );
    XPtr<LONG> xLo( cDim );
    XPtr<LONG> xUp( cDim );

    for ( UINT iDim = 0; iDim < cDim; iDim++ )
    {
        HRESULT hr = SafeArrayGetLBound( pa, iDim + 1, &xLo[iDim] );
        if ( FAILED( hr ) )
            return;

        xDim[ iDim ] = xLo[ iDim ];

        hr = SafeArrayGetUBound( pa, iDim + 1, &xUp[iDim] );
        if ( FAILED( hr ) )
            return;

        wprintf( L"{" );
    }

    // slog through the array

    UINT iLastDim = cDim - 1;
    BOOL fDone = FALSE;

    while ( !fDone )
    {
        // inter-element formatting

        if ( xDim[ iLastDim ] != xLo[ iLastDim ] )
            wprintf( L"," );

        // Get the element and render it

        void *pv;
        HRESULT hr = SafeArrayPtrOfIndex( pa, xDim.Get(), &pv );
        if ( FAILED( hr ) )
            return;

        Render( vt, pv );

        // Move to the next element and carry if necessary

        ULONG cOpen = 0;

        for ( LONG iDim = iLastDim; iDim >= 0; iDim-- )
        {
            if ( xDim[ iDim ] < xUp[ iDim ] )
            {
                xDim[ iDim ] = 1 + xDim[ iDim ];
                break;
            }

            wprintf( L"}" );

            if ( 0 == iDim )
                fDone = TRUE;
            else
            {
                cOpen++;
                xDim[ iDim ] = xLo[ iDim ];
            }
        }

        for ( ULONG i = 0; !fDone && i < cOpen; i++ )
            wprintf( L"{" );
    }
} //PrintSafeArray

//+-------------------------------------------------------------------------
//
//  Function:   PrintVectorItems
//
//  Synopsis:   Prints items in a PROPVARIANT vector
//
//  Arguments:  [pVal]  - The array of values
//              [cVals] - The count of values
//              [pcFmt] - The format string
//
//--------------------------------------------------------------------------

template<class T> void PrintVectorItems(
    T *     pVal,
    ULONG   cVals,
    char *  pcFmt )
{
    printf( "{ " );

    for( ULONG iVal = 0; iVal < cVals; iVal++ )
    {
        if ( 0 != iVal )
            printf( "," );
        printf( pcFmt, *pVal++ );
    }

    printf( " }" );
} //PrintVectorItems

//+-------------------------------------------------------------------------
//
//  Function:   DisplayValue
//
//  Synopsis:   Displays a PROPVARIANT value.  Limited formatting is done.
//
//  Arguments:  [pVar] - The value to display
//
//--------------------------------------------------------------------------

void DisplayValue( PROPVARIANT const * pVar )
{
    if ( 0 == pVar )
    {
        wprintf( L"NULL" );
        return;
    }

    // Display the most typical variant types

    PROPVARIANT const & v = *pVar;

    switch ( v.vt )
    {
        case VT_EMPTY : wprintf( L"vt_empty" ); break;
        case VT_NULL : wprintf( L"vt_null" ); break;
        case VT_I4 : wprintf( L"%d", v.lVal ); break;
        case VT_UI1 : wprintf( L"%d", v.bVal ); break;
        case VT_I2 : wprintf( L"%d", v.iVal ); break;
        case VT_R4 : wprintf( L"%f", v.fltVal ); break;
        case VT_R8 : wprintf( L"%lf", v.dblVal ); break;
        case VT_BOOL : wprintf( v.boolVal ? L"TRUE" : L"FALSE" ); break;
        case VT_I1 : wprintf( L"%d", v.cVal ); break;
        case VT_UI2 : wprintf( L"%u", v.uiVal ); break;
        case VT_UI4 : wprintf( L"%u", v.ulVal ); break;
        case VT_INT : wprintf( L"%d", v.lVal ); break;
        case VT_UINT : wprintf( L"%u", v.ulVal ); break;
        case VT_I8 : wprintf( L"%I64d", v.hVal ); break;
        case VT_UI8 : wprintf( L"%I64u", v.hVal ); break;
        case VT_ERROR : wprintf( L"%#x", v.scode ); break;
        case VT_LPSTR : wprintf( L"%S", v.pszVal ); break;
        case VT_LPWSTR : wprintf( L"%ws", v.pwszVal ); break;
        case VT_BSTR : wprintf( L"%ws", v.bstrVal ); break;
        case VT_CY:
        {
            double dbl;
            HRESULT hr = VarR8FromCy( v.cyVal, &dbl );
            if ( SUCCEEDED( hr ) )
                wprintf( L"%lf", dbl );
            break;
        }
        case VT_DECIMAL :
        {
            double dbl;
            HRESULT hr = VarR8FromDec( (DECIMAL *) &v.decVal, &dbl );
            if ( SUCCEEDED( hr ) )
                wprintf( L"%lf", dbl );
            break;
        }
        case VT_FILETIME :
        case VT_DATE :
        {
            SYSTEMTIME st;

            if ( VT_DATE == v.vt )
            {
                BOOL fOK = VariantTimeToSystemTime( v.date, &st );

                if ( !fOK )
                    break;
            }
            else
            {
#if 0
                FILETIME ft;
                BOOL fOK = FileTimeToLocalFileTime( &v.filetime, &ft );

                if ( fOK )
                    fOK = FileTimeToSystemTime( &ft, &st );

                if ( !fOK )
                    break;
#else
                BOOL fOK = FileTimeToSystemTime( &v.filetime, &st );
                if ( !fOK )
                    break;
#endif
            }

            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            wprintf( L"%2d-%02d-%04d %2d:%02d:%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    (DWORD) st.wSecond,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_VECTOR | VT_I1:
            PrintVectorItems( v.cac.pElems, v.cac.cElems, "%d" ); break;
        case VT_VECTOR | VT_I2:
            PrintVectorItems( v.cai.pElems, v.cai.cElems, "%d" ); break;
        case VT_VECTOR | VT_I4:
            PrintVectorItems( v.cal.pElems, v.cal.cElems, "%d" ); break;
        case VT_VECTOR | VT_I8:
            PrintVectorItems( v.cah.pElems, v.cah.cElems, "%I64d" ); break;
        case VT_VECTOR | VT_UI1:
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%u" ); break;
        case VT_VECTOR | VT_UI2:
            PrintVectorItems( v.caui.pElems, v.caui.cElems, "%u" ); break;
        case VT_VECTOR | VT_UI4:
            PrintVectorItems( v.caul.pElems, v.caul.cElems, "%u" ); break;
        case VT_VECTOR | VT_ERROR:
            PrintVectorItems( v.cascode.pElems, v.cascode.cElems, "%#x" ); break;
        case VT_VECTOR | VT_UI8:
            PrintVectorItems( v.cauh.pElems, v.cauh.cElems, "%I64u" ); break;
        case VT_VECTOR | VT_BSTR:
            PrintVectorItems( v.cabstr.pElems, v.cabstr.cElems, "%ws" ); break;
        case VT_VECTOR | VT_LPSTR:
            PrintVectorItems( v.calpstr.pElems, v.calpstr.cElems, "%S" ); break;
        case VT_VECTOR | VT_LPWSTR:
            PrintVectorItems( v.calpwstr.pElems, v.calpwstr.cElems, "%ws" ); break;
        case VT_VECTOR | VT_R4:
            PrintVectorItems( v.caflt.pElems, v.caflt.cElems, "%f" ); break;
        case VT_VECTOR | VT_R8:
            PrintVectorItems( v.cadbl.pElems, v.cadbl.cElems, "%lf" ); break;
        default : 
        {
            if ( VT_ARRAY & v.vt )
                PrintSafeArray( v.vt - VT_ARRAY, v.parray );
            else
                wprintf( L"vt 0x%05x", v.vt );
            break;
        }
    }
} //DisplayValue

void DumpProps(
    XInterface<IPropertySetStorage> & xPropSetStorage,
    XInterface<IColumnMapper> &       xColumnMapper )
{
    // Get enumerator for property set

    XInterface<IEnumSTATPROPSETSTG> xPropSetEnum;

    HRESULT hr = xPropSetStorage->Enum( xPropSetEnum.GetPPointer() );
    if ( FAILED( hr ) )
    {
        printf( "IPropertySetStorage::Enum failed: %#x\n", hr );
        exit( 1 );
    }

    STATPROPSETSTG propset;
    BOOL fTriedUserDefinedPropsYet = FALSE;
    
    while( ( (hr = xPropSetEnum->Next(1, &propset, NULL)) == S_OK ) ||
           !fTriedUserDefinedPropsYet)
    {
        GUID FormatID;
        if ( S_OK == hr )
        {
            FormatID = propset.fmtid;
        }
        else
        {
            FormatID = FMTID_UserDefinedProperties;
            fTriedUserDefinedPropsYet = TRUE;
        }
        
        XInterface<IPropertyStorage> xPropStorage;

        hr = xPropSetStorage->Open( FormatID,
                                    STGM_READ | STGM_SHARE_EXCLUSIVE,
                                    xPropStorage.GetPPointer() );

        if ( ( ( E_FAIL == hr ) || ( STG_E_FILENOTFOUND == hr ) ) &&
             ( FMTID_UserDefinedProperties == FormatID ) )
        {
            //printf( "IPropertySetStorage::Open failed with %#x\n", hr );
            hr = S_OK;
            continue;
        }
        else if ( FAILED( hr ) )
        {
            printf( "IPropertySetStorage::Open failed badly with %#x\n", hr );
            exit( 1 );
        }

        BOOL fFirstOfSet = TRUE;

        XInterface<IEnumSTATPROPSTG> xEnumStatPropStg;
        
        // Get enumerator for property

        hr = xPropStorage->Enum( xEnumStatPropStg.GetPPointer() );

        if ( FAILED( hr ) )
        {
            printf( "IPropertyStorage::Enum failed %#x\n", hr );
            continue;
        }
        
        PROPVARIANT prop;
        PropVariantInit( &prop );
        
        // Get the locale for properties

        PROPSPEC ps;
        ps.ulKind = PRSPEC_PROPID;
        ps.propid = PID_LOCALE;

        hr = xPropStorage->ReadMultiple( 1, 
                                         &ps,
                                         &prop );

        LCID lcid = GetSystemDefaultLCID();
        BOOL fSystemLcid = TRUE;

        if ( SUCCEEDED( hr ) )
        {
            if ( VT_EMPTY != prop.vt )
            {
                lcid = prop.ulVal;
                PropVariantClear(&prop);
                fSystemLcid = FALSE;
            }
        }
        else
        {
            printf( " can't read the locale: %#x\n", hr );
        }
        
        // Get the code page for properties

        PROPSPEC psCodePage = { PRSPEC_PROPID, PID_CODEPAGE };
        
        hr = xPropStorage->ReadMultiple(1, &psCodePage, &prop);
        UINT uiCodepage = 0;
        
        if ( SUCCEEDED( hr ) )
        {
            if (VT_I2 == prop.vt)
                uiCodepage = prop.uiVal;
            else
                printf( " vt of codepage: %d (%#x)\n", prop.vt, prop.vt );

            PropVariantClear( &prop );
        }
        else
        {
            printf( "  no codepage, assume ansi\n" );
        }
        
        // Enumerate all properties in the property set

        STATPROPSTG statPS;
        ULONG ul;
        hr = S_OK;
        ULONG iPropSet = 0;

        while ( ( S_OK == xEnumStatPropStg->Next( 1, &statPS, &ul ) ) &&
                ( 1 == ul ) &&
                ( SUCCEEDED( hr ) ) )
        {
            if ( fFirstOfSet )
            {
                printf( "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                        FormatID.Data1,
                        FormatID.Data2,
                        FormatID.Data3,
                        FormatID.Data4[0], FormatID.Data4[1],
                        FormatID.Data4[2], FormatID.Data4[3],
                        FormatID.Data4[4], FormatID.Data4[5],
                        FormatID.Data4[6], FormatID.Data4[7] );
        
                for ( iPropSet = 0; iPropSet < g_cPropSets; iPropSet++ )
                {
                    if ( g_aPropSets[iPropSet].guid == FormatID )
                    {
                        printf( " %ws", g_aPropSets[iPropSet].pwcName );
                        break;
                    }
                }
        
                printf( "\n" );

                printf( " locale: %d (%#x) %ws\n", lcid, lcid,
                        fSystemLcid ? L"not specified; using system default" : L"" );

                printf( " codepage: %d (%#x)\n", uiCodepage, uiCodepage );

                printf( " property                     IS name           type                value\n" );
                printf( " --------                     -------           ----                -----\n" );

                fFirstOfSet = FALSE;
            }

            if ( 0 != statPS.lpwstrName )
            {
                printf( " '%10ws' ", statPS.lpwstrName );

                ps.ulKind = PRSPEC_LPWSTR;
                ps.lpwstr = statPS.lpwstrName;
            }
            else
            {
                printf( " %#8x ", statPS.propid );

                ps.ulKind = PRSPEC_PROPID;
                ps.propid = statPS.propid;
            }

            // Display well-known property names if available

            BOOL fFound = FALSE;
            if ( ( iPropSet < g_cPropSets ) &&
                 ( PRSPEC_PROPID == ps.ulKind ) )
            {
                const SPropertySet & set = g_aPropSets[ iPropSet ];

                for ( ULONG i = 0; i < set.cProperties; i++ )
                {
                    if ( set.pProperties[i].pid == ps.propid )
                    {
                        printf( "%-19ws ", set.pProperties[i].pwcName );
                        fFound = TRUE;
                        break;
                    }
                }
            }

            if ( !fFound )
                printf( "                    " );

            // If there is a column mapper, look up the IS friendly name.

            fFound = FALSE;
            if ( !xColumnMapper.IsNull() )
            {
                DBID dbid;
                dbid.uGuid.guid = FormatID;
                dbid.eKind = ps.ulKind;
                dbid.uName.pwszName = ps.lpwstr;

                WCHAR *pwcName;
                UINT uiWidth;
                DBTYPE dbType;

                HRESULT hrName = xColumnMapper->GetPropInfoFromId( &dbid,
                                                                   &pwcName,
                                                                   &dbType,
                                                                   &uiWidth );
                if ( SUCCEEDED( hrName ) )
                {
                    printf( "%-17ws ", pwcName );
                    fFound = TRUE;
                }
            }

            if ( !fFound )
                printf( "                  " );

            hr = xPropStorage->ReadMultiple( 1, 
                                             &ps,
                                             &prop );

            if ( SUCCEEDED( hr ) )
            {
                if ( S_FALSE == hr )
                    printf( "readmultiple returned S_FALSE!\n" );

                PrintVariantType( prop.vt );
                printf( " " );

                DisplayValue( &prop );
                printf( "\n" );

                PropVariantClear( &prop );
            }
            else
            {
                printf( "  IPropertyStorage::ReadMultiple failed: %#x\n", hr );
                hr = S_OK;
            }
        }

        printf( "\n" );
    }
} //DumpProps

HRESULT BindToItemByName(
    WCHAR const * pszFile,
    REFIID        riid,
    void **       ppv )
{
    XInterface<IShellFolder> xDesktop;
    HRESULT hr = pShGetDesktopFolder( xDesktop.GetPPointer() );

    if ( SUCCEEDED( hr ) )
    {
        XInterface<IBindCtx> xBindCtx;

        hr = CreateBindCtx( 0, xBindCtx.GetPPointer() );
        if ( FAILED( hr ) )
            return hr;

        BIND_OPTS bo = {sizeof(bo), 0};
        bo.grfFlags = BIND_JUSTTESTEXISTENCE;   // skip all junctions

        hr = xBindCtx->SetBindOptions( &bo );
        if ( FAILED( hr ) )
            return hr;

        LPITEMIDLIST pidl;

        // cast needed for bad interface def
    
        hr = xDesktop->ParseDisplayName( 0,
                                         xBindCtx.GetPointer(),
                                         (LPWSTR) pszFile,
                                         0,
                                         &pidl,
                                         0 );
        if ( SUCCEEDED( hr ) )
        {
            XInterface<IShellFolder> xSF;
            LPCITEMIDLIST pidlChild;
    
            hr = pShBindToParent( pidl,
                                  IID_IShellFolder,
                                  xSF.GetQIPointer(),
                                  &pidlChild );
            if (SUCCEEDED(hr))
                hr = xSF->BindToObject( pidlChild, 0, riid, ppv );
            else
                printf( "SHBindToParent failed: %#x\n", hr );
    
            CoTaskMemFree( pidl );
        }
        else
        {
            printf( "IShellFolder::ParseDisplayNamed failed %#x\n", hr );
        }
    }
    else
    {
        printf( "SHGetDesktopFolder failed: %#x\n", hr );
    }

    return hr;
} //BindToItemByName

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    if ( 2 != argc && 3 != argc )
        Usage();

    BOOL fUseOLE = TRUE;

    if ( 3 == argc )
    {
        if ( !_wcsicmp( L"-s", argv[1] ) )
            fUseOLE = FALSE;
        else
            Usage();
    }

    WCHAR awcPath[MAX_PATH];

    WCHAR * pwcResult = _wfullpath( awcPath, argv[ (2 == argc) ? 1 : 2 ], MAX_PATH );

    if ( 0 == pwcResult )
        Usage();

    CTranslateSystemExceptions xlate;

    TRY
    {
        XCom initCom;
    
        //
        // Attempt to get a column mapper so Indexing Service friendly names can
        // be displayed.  If we can't get it, just don't use it.
        //
    
        XInterface<IColumnMapper> xColumnMapper;
    
        {
            CLSID clsidCISimpleCommandCreator = CLSID_CISimpleCommandCreator;
            XInterface<ISimpleCommandCreator> xCmdCreator;
        
            HRESULT hr = CoCreateInstance( clsidCISimpleCommandCreator,
                                           0,
                                           CLSCTX_INPROC_SERVER,
                                           IID_ISimpleCommandCreator,
                                           xCmdCreator.GetQIPointer() );
            if ( SUCCEEDED( hr ) )
            {
                XInterface<IColumnMapperCreator> xMapCreator;
        
                hr = xCmdCreator->QueryInterface( IID_IColumnMapperCreator, xMapCreator.GetQIPointer() );
                if ( SUCCEEDED( hr ) )
                    hr = xMapCreator->GetColumnMapper( L".", L"SYSTEM", xColumnMapper.GetPPointer() );
            }
        }
    
        if ( fUseOLE )
        {
            BOOL fWindows2000Plus = FALSE;
    
            OSVERSIONINFOA ovi;
            ovi.dwOSVersionInfoSize = sizeof ovi;
            GetVersionExA( &ovi );
    
            if ( ( VER_PLATFORM_WIN32_NT == ovi.dwPlatformId ) &&
                 ( ovi.dwMajorVersion >= 5 ) )
                fWindows2000Plus = TRUE;
    
            HINSTANCE h = LoadLibraryA( "ole32.dll" );
            if ( 0 == h )
            {
                printf( "can't load ole32.dll\n" );
                exit( 1 );
            }
    
            LPStgOpenStorageEx pOpen = (LPStgOpenStorageEx) GetProcAddress( h, "StgOpenStorageEx" );
    
            // Note: on some platforms closing the IStorage before finishing with
            // the IPropertySetStorage will result in the object going away.  It's a bug
            // in OLE.
        
            XInterface<IStorage> xStorage;
            XInterface<IPropertySetStorage> xPropSetStorage;
        
            if ( fWindows2000Plus && 0 != pOpen )
            {
                HRESULT hr = pOpen( awcPath,
                                    STGM_DIRECT |
                                        STGM_READ |
                                        STGM_SHARE_DENY_WRITE,
                                    STGFMT_ANY,
                                    0,
                                    0,
                                    0,
                                    IID_IPropertySetStorage,      
                                    xPropSetStorage.GetQIPointer() );
                if ( FAILED( hr ) )
                {
                    printf( "failed to openEx the file: %#x\n", hr );
                    exit( 1 );
                }
            }
            else
            {
                HRESULT hr = StgOpenStorage( awcPath,
                                             0,
                                             STGM_READ | STGM_SHARE_DENY_WRITE,
                                             0,
                                             0, 
                                             xStorage.GetPPointer() );
                if ( FAILED( hr ) )
                {
                    printf( "StgOpenStorage failed to open the file: %#x\n", hr );
                    exit( 1 );
                }
    
                // Rely on iprop.dll on Win9x, since OLE32 doesn't have the code
            
                hr = StgCreatePropSetStg( xStorage.GetPointer(),
                                          0,
                                          xPropSetStorage.GetPPointer() );
                if ( FAILED( hr ) )
                {
                    printf( "StgCreatePropSetStg failed: %#x\n", hr );
                    exit( 1 );
                }
            }
        
            DumpProps( xPropSetStorage, xColumnMapper );
    
            FreeLibrary( h );
        }
        else
        {
            // This will only work on Windows XP and later...
    
            HINSTANCE h = LoadLibrary( L"shell32.dll" );
            if ( 0 == h )
            {
                printf( "can't load shell32.dll\n" );
                exit( 1 );
            }
    
            pShGetDesktopFolder = (PSHGetDesktopFolder) GetProcAddress( h, "SHGetDesktopFolder" );
            if ( 0 == pShGetDesktopFolder )
            {
                printf( "can't find SHGetDesktopFolder in shell32.dll\n" );
                exit( 1 );
            }
    
            pShBindToParent = (PSHBindToParent) GetProcAddress( h, "SHBindToParent" );
            if ( 0 == pShBindToParent )
            {
                printf( "can't find SHBindToParent in shell32.dll\n" );
                exit( 1 );
            }
    
            XInterface<IPropertySetStorage> xPropSetStorage;
            CLSID clsidPSS = IID_IPropertySetStorage;
    
            HRESULT hr = BindToItemByName( awcPath,
                                           clsidPSS,
                                           xPropSetStorage.GetQIPointer() );
            if ( FAILED( hr ) )
                printf( "couldn't bind to item %ws by name: %#x\n", awcPath, hr );
            else
                DumpProps( xPropSetStorage, xColumnMapper );
    
            FreeLibrary( h );
        }
    }
    CATCH( CException, e )
    {
        printf( "caught exception %#x\n", e.GetErrorCode() );
    }

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\dumpsec\main.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       Main.cxx
//
//  Contents:   Main file for CI security dump utility
//
//  History:    29-Jul-1998   KyleP    Created
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <aclapi.h>

typedef ULONG SDID;

//
// Copied from SecCache.hxx (NtCiUtil directory)
//

const USHORT SECSTORE_REC_SIZE = 64;
const ULONG SECSTORE_HASH_SIZE = 199;

struct SSdHeaderRecord
{
    ULONG       cbSD;           // size in bytes of the security descriptor
    ULONG       ulHash;         // the hash of the security descriptor
    SDID        iHashChain;     // index to previous entry for hash bucket
};

//
// Used for mapping bitmasks to text.
//

struct SPermDisplay
{
    DWORD  Perm;
    char * Display;
};

//
// Local constants and function prototypes
//

unsigned const SixtyFourK = 1024 * 64;

void DisplayTrustee( TRUSTEE const & Trustee );
void DisplayACE( char const * pszPreface, unsigned cACE, EXPLICIT_ACCESS * pACE );
void DisplayMode( DWORD mode );
void DisplayInheritance( DWORD Inherit );
void DisplayPerms( DWORD grfAccess );
void Display( DWORD grfAccess, SPermDisplay aPerm[], unsigned cPerm, unsigned cDisplay = 0 );
void Usage();

//+---------------------------------------------------------------------------
//
//  Function:   wmain, public
//
//  Synopsis:   Program entry point.  Iterates and displays SDID mapping.
//
//  Arguments:  [argc] -- Argument count
//              [argv] -- Program arguments
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    if ( argc != 2 )
    {
        Usage();
        return 1;
    }

    //
    // Open handle
    //

    if ( wcslen( argv[1] ) > ( MAX_PATH - 20 ) )
    {
        Usage();
        return 1;
    }

    WCHAR wszSecFile[MAX_PATH];
    wcscpy( wszSecFile, argv[1] );
    wcscat( wszSecFile, L"\\CiST0000.001" );

    HANDLE h = CreateFile( wszSecFile,
                           GENERIC_READ,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           0,
                           OPEN_EXISTING,
                           0,
                           0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %ws. Error %u\n", wszSecFile, GetLastError() );
        return GetLastError();
    }

    //
    // Read until done.
    //

    BYTE abTemp[SixtyFourK];
    DWORD cbRead;
    int i = 0;

    SSdHeaderRecord Header;

    while ( ReadFile( h,
                      &Header,
                      sizeof(Header),
                      &cbRead,
                      0 ) )
    {
        if ( 0 == Header.cbSD )
            break;

        i++;
        printf( "SDID %u / 0x%x (cbSD = %u bytes)\n", i, i, Header.cbSD );

        //
        // Read rest of first record.
        //

        if ( !ReadFile( h,
                        abTemp,
                        SECSTORE_REC_SIZE - sizeof(Header) + 4,
                        &cbRead,
                        0 ) )
        {
            printf( "Error %u reading file\n", GetLastError() );
            return 1;
        }

        //
        // Read additional records, which together create one security descriptor
        //

        if ( Header.cbSD > (SECSTORE_REC_SIZE - sizeof(Header)) )
        {
            unsigned iCurrent = SECSTORE_REC_SIZE - sizeof(Header);

            for ( unsigned cLeft = (Header.cbSD - SECSTORE_REC_SIZE + sizeof(Header) - 1) / SECSTORE_REC_SIZE + 1;
                  cLeft > 0;
                  cLeft-- )
            {
                if ( !ReadFile( h,
                                abTemp + iCurrent,
                                SECSTORE_REC_SIZE + 4,
                                &cbRead,
                                0 ) )
                {
                    printf( "Error %u reading file\n", GetLastError() );
                    return 1;
                }

                i++;
                iCurrent += SECSTORE_REC_SIZE;
            }
        }

        SECURITY_DESCRIPTOR * pSD = (SECURITY_DESCRIPTOR *)abTemp;

        //
        // Create a human-readable descriptor
        //

        TRUSTEE * pOwner = 0;
        TRUSTEE * pGroup = 0;
        DWORD cACE;
        EXPLICIT_ACCESS * pACE;
        DWORD cAudit = 0;
        EXPLICIT_ACCESS * pAudit = 0;

        DWORD dwError = LookupSecurityDescriptorParts( &pOwner,
                                                       &pGroup,
                                                       &cACE,
                                                       &pACE,
                                                       &cAudit,
                                                       &pAudit,
                                                       pSD );

        //
        // And display it.
        //

        if ( ERROR_SUCCESS == dwError )
        {
            if ( 0 != pOwner )
            {
                printf( "Owner: " );
                DisplayTrustee( *pOwner );
                printf( "\n" );
                LocalFree( pOwner );
            }

            if ( 0 != pGroup )
            {
                printf( "Group: " );
                DisplayTrustee( *pGroup );
                printf( "\n" );
                LocalFree( pGroup );
            }

            if ( cACE > 0 )
            {
                printf( "Access: " );
                DisplayACE( "        ", cACE, pACE );
                printf( "\n" );
                LocalFree( pACE );
            }

#if 0 // comes out the same as the access 

            if ( cAudit > 0 )
            {
                printf( "Audit: " );
                DisplayACE( "        ", cAudit, pAudit );
                printf( "\n" );
                LocalFree( pAudit );
            }

#endif

        }
        else
            printf( "LookupSecurityDescriptorParts returned %u\n", dwError );

        printf( "\n\n" );
    }

    CloseHandle( h );

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   DisplayTrustee
//
//  Synopsis:   Prints out trustee (user, group, etc.)
//
//  Arguments:  [Trustee] -- Trustee description
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

char * aszTrusteeType[] = { "Unknown",   // TRUSTEE_IS_UNKNOWN
                            "User",      // TRUSTEE_IS_USER,
                            "Group",     // TRUSTEE_IS_GROUP,
                            "Domain",    // TRUSTEE_IS_DOMAIN,
                            "Alias",     // TRUSTEE_IS_ALIAS,
                            "Group",     // TRUSTEE_IS_WELL_KNOWN_GROUP,
                            "Deleted",   // TRUSTEE_IS_DELETED,
                            "Invalid",   // TRUSTEE_IS_INVALID
                            "Unknown",
                            "Computer" };

void DisplayTrustee( TRUSTEE const & Trustee )
{
    if ( TRUSTEE_IS_NAME == Trustee.TrusteeForm )
    {
        printf( "%ws (%s)", Trustee.ptstrName, aszTrusteeType[Trustee.TrusteeType] );
    }
    else if ( TRUSTEE_IS_SID == Trustee.TrusteeForm )
    {
        WCHAR wszName[100];
        DWORD ccName = sizeof(wszName)/sizeof(wszName[0]);

        WCHAR wszDomain[100];
        DWORD ccDomain = sizeof(wszDomain)/sizeof(wszDomain[0]);

        SID_NAME_USE snu;

        BOOL fOk = LookupAccountSid( 0,                       // local system
                                     (PSID)Trustee.ptstrName, // address of security identifier
                                     wszName,                 // address of string for account name
                                     &ccName,                 // address of size account string
                                     wszDomain,               // address of string for referenced domain
                                     &ccDomain,               // address of size domain string
                                     &snu );                  // address of structure for SID type

        if ( fOk )
        {
            if ( 0 == wszDomain[0] )
                printf( "%ws (%s)", wszName, aszTrusteeType[snu] );
            else
                printf( "%ws\\%ws (%s)", wszDomain, wszName, aszTrusteeType[snu] );
        }
        else
            printf( "<SID>" );
    }
    else
        printf( "Invalid Trustee form: %d\n", Trustee.TrusteeForm );
}

//+---------------------------------------------------------------------------
//
//  Function:   DisplayACE
//
//  Synopsis:   Prints out Access Control Entry(ies)
//
//  Arguments:  [pszPreface] -- String to append at beginning of each line.
//              [cACE]       -- Count of entries
//              [pACE]       -- Array of entries
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

void DisplayACE( char const * pszPreface, unsigned cACE, EXPLICIT_ACCESS * pACE )
{
    for ( unsigned i = 0; i < cACE; i++ )
    {
        if ( 0 != i )
            printf( "%s", pszPreface );

        DisplayTrustee( pACE[i].Trustee );

        printf( " : " );

        DisplayMode( pACE[i].grfAccessMode );

        printf( " /" );

        DisplayInheritance( pACE[i].grfInheritance );

        printf( " /" );

        DisplayPerms( pACE[i].grfAccessPermissions );

        printf( "\n" );
    }
    //ACCESS_MODE  grfAccessMode;    DWORD        grfInheritance;
}

//+---------------------------------------------------------------------------
//
//  Function:   DisplayMode, private
//
//  Synopsis:   Prints out access mode (Set or Deny access)
//
//  Arguments:  [mode] -- Access mode
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

char * aszAccessDisplay[] = { "NOT_USED",
                              "GRANT_ACCESS",
                              "SET_ACCESS",
                              "DENY_ACCESS",
                              "REVOKE_ACCESS",
                              "SET_AUDIT_SUCCESS",
                              "SET_AUDIT_FAILURE" };

void DisplayMode( DWORD mode )
{
    printf( "%s", aszAccessDisplay[mode] );
}

//+---------------------------------------------------------------------------
//
//  Function:   DisplayInheritance, private
//
//  Synopsis:   Prints out inheritance, both up (to parent) and down (to children)
//
//  Arguments:  [Inherit] -- Inheritance bitmask
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

SPermDisplay aInheritDisplay[] = {
  //{ INHERITED_ACCESS_ENTRY,             "(inherited)" },
  { INHERITED_PARENT,                   "(inherited from parent)" },
  { INHERITED_GRANDPARENT,              "(inherited from grandparent)" },
  { SUB_OBJECTS_ONLY_INHERIT,           "SUB_OBJECTS_ONLY" },
  { SUB_CONTAINERS_ONLY_INHERIT,        "SUB_CONTAINERS_ONLY" },
  { SUB_CONTAINERS_AND_OBJECTS_INHERIT, "SUB_CONTAINERS_AND_OBJECTS" },
  { INHERIT_NO_PROPAGATE,               "INHERIT_NO_PROPAGATE" },
  { INHERIT_ONLY,                       "INHERIT_ONLY" } };

void DisplayInheritance( DWORD Inherit )
{
    if ( NO_INHERITANCE == Inherit )
        printf( "\n\t\t(not inherited)" );
    else
        Display( Inherit, aInheritDisplay, sizeof(aInheritDisplay)/sizeof(aInheritDisplay[0]) );
}

//+---------------------------------------------------------------------------
//
//  Function:   DisplayPerms
//
//  Synopsis:   Displays file permissions
//
//  Arguments:  [grfAccess] -- Access permission bitmask
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

SPermDisplay aPermDisplay[] = {
  { FILE_READ_DATA,        "READ_DATA" },
  { FILE_WRITE_DATA,       "WRITE_DATA" },
  { FILE_ADD_FILE,         "ADD_FILE" },
  { FILE_APPEND_DATA,      "APPEND_DATA" },
  { FILE_ADD_SUBDIRECTORY, "ADD_SUBDIRECTORY" },
  { FILE_CREATE_PIPE_INSTANCE, "CREATE_PIPE_INSTANCE" },
  { FILE_READ_EA,              "READ_EA" },
  { FILE_WRITE_EA,             "WRITE_EA" },
  { FILE_EXECUTE,              "EXECUTE" },
  { FILE_TRAVERSE,             "TRAVERSE" },
  { FILE_DELETE_CHILD,         "DELETE_CHILD" },
  { FILE_READ_ATTRIBUTES,      "READ_ATTRIBUTES" },
  { FILE_WRITE_ATTRIBUTES,     "WRITE_ATTRIBUTES" },
  { DELETE,                    "DELETE" },
  { READ_CONTROL,              "READ_CONTROL" },
  { WRITE_DAC,                 "WRITE_DAC" },
  { WRITE_OWNER,               "WRITE_OWNER" },
  { SYNCHRONIZE,               "SYNCHRONIZE" },
  { GENERIC_READ,              "GENERIC_READ" },
  { GENERIC_WRITE,             "GENERIC_WRITE" },
  { GENERIC_EXECUTE,           "GENERIC_EXECUTE" } };


void DisplayPerms( DWORD grfAccess )
{
    BOOL  cDisplay = 0;
    DWORD grfRemove = 0;

    printf( "\n\t\t" );

    //
    // First, get rid of the basics...
    //

    if ( (grfAccess & FILE_GENERIC_READ) == FILE_GENERIC_READ )
    {
        printf( "GENERIC_READ" );
        grfRemove = FILE_GENERIC_READ;
        cDisplay++;
    }

    if ( (grfAccess & FILE_GENERIC_WRITE) == FILE_GENERIC_WRITE )
    {
        if ( 0 != cDisplay )
            printf( " | " );

        printf( "GENERIC_WRITE" );
        grfRemove = grfRemove | FILE_GENERIC_WRITE;
        cDisplay++;
    }

    if ( (grfAccess & FILE_GENERIC_EXECUTE) == FILE_GENERIC_EXECUTE )
    {
        if ( 0 != cDisplay )
            printf( " | " );

        if ( 0 == (cDisplay % 2) )
            printf( " \n\t\t" );

        printf( "GENERIC_EXECUTE" );
        grfRemove = grfRemove | FILE_GENERIC_EXECUTE;
        cDisplay++;
    }

    //
    // Now, individual permissions.
    //

    DWORD grfRemainder = grfAccess & ~grfRemove;

    Display( grfRemainder, aPermDisplay, sizeof(aPermDisplay)/sizeof(aPermDisplay[0]), cDisplay );

    printf( " (0x%x)", grfAccess );
}

//+---------------------------------------------------------------------------
//
//  Function:   Display, private
//
//  Synopsis:   Print bit masks
//
//  Arguments:  [grfAccess] -- Bit mask
//              [aPerm]     -- Description of bits
//              [cPerm]     -- Count of entries in [aPerm]
//              [cDisplay]  -- Number of entries already displayed on
//                             current line by caller.
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

void Display( DWORD grfAccess, SPermDisplay aPerm[], unsigned cPerm, unsigned cDisplay )
{
    for ( unsigned i = 0; i < cPerm ; i++ )
    {
        if ( grfAccess & aPerm[i].Perm )
        {
            if ( 0 != cDisplay )
                printf( " | " );

            if ( 0 == (cDisplay % 2) )
                printf( " \n\t\t" );

            printf( "%s", aPerm[i].Display );

            cDisplay++;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays program usage
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

void Usage()
{
    printf( "Usage: DumpSec <Path to catalog>\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\cxxflt\fstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992 - 1994, Microsoft Corporation.
//
//  File:       fstrm.cxx
//
//  Contents:   Stream for transporting text from IFilter to cxx parser.
//
//  Classes:    CFilterTextStream
//
//  History:    01-Aug-93       AmyA        Created
//              17-Oct-94       BartoszM    Rewrote
//
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Member:     CFilterTextStream::CFilterTextStream, public
//
//  Synopsis:   Constructor
//
//  History:    01-Aug-93       AmyA        Created
//              17-Oct-94       BartoszM    Rewrote
//
//--------------------------------------------------------------------------

CFilterTextStream::CFilterTextStream(IFilter* pIFilter)
: CTextSource(_statChunk)
{
    iEnd = 0;
    iCur = 0;
    Win4Assert (pIFilter != 0);
    awcBuffer = _awcFilterBuffer;
    _sc = pIFilter->GetChunk( &_statChunk );
    if (SUCCEEDED(_sc))
    {
        _pFilter = pIFilter;
        pfnFillTextBuffer = CTextSource::FillBuf;
        _mapper.NewChunk ( _statChunk.idChunk, 0 );
        _pMapper = &_mapper;
        _sc = CTextSource::FillBuf( this );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterTextStream::GetMore, public
//
//  Synopsis:   Try to replenish the buffer
//
//  History:    16-Nov-94  BartoszM         Created
//
//----------------------------------------------------------------------------

int CFilterTextStream::GetMore()
{
    if (iCur == iEnd - 1)
    {
        _sc = FillBuf( this );
        // if there was no more data
        // the last lookahead was moved
        // to the beginning and
        // iCur == iEnd - 1
        // next time around it will be
        // iCur == iEnd
    }
    else
    {
        Win4Assert(iCur == iEnd);
        return -1;  // EOF
    }
    return awcBuffer[iCur++];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\cxxflt\mapper.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   MAPPER.CXX
//
//  Contents:   Search Key Repository
//
//  Classes:    CSourceMapper
//
//  History:    23-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CSourceMapper::Advance
//
//  Synopsis:   Advance the mapper after processing ccDelta characters
//
//  History:    30-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

void CSourceMapper::Advance ( ULONG ccProcessed )
{
    _offInChunk += ccProcessed;
    if (_offSplit != 0)
    {
        // split buffer situation (two current chunks)
        if (ccProcessed >= _offSplit)
        {
            // got rid of leftover chunk
            _offInChunk = ccProcessed - _offSplit;
            _offSplit = 0;
            _idChunk = _idNewChunk;
        }
        else
            _offSplit -= ccProcessed;
    }
}

void CSourceMapper::NewChunk ( ULONG idChunk, ULONG ccBegin )
{
    if (ccBegin != 0)
    {
        _offSplit = ccBegin;
        _idNewChunk = idChunk;
    }
    else
    {
        _offSplit = 0;
        _idChunk = idChunk;
        _offInChunk = 0;
    }
    _ccLen = 0;
}

void CSourceMapper::NewDerivedChunk ( ULONG idChunkSource, ULONG ccBeginSource, ULONG ccLen )
{
    _idChunk = idChunkSource;
    _offInChunk = ccBeginSource;
    _offSplit = 0;
    _ccLen = ccLen;
}
//+---------------------------------------------------------------------------
//
//  Member:     CSourceMapper::GetSrcRegion
//
//  Synopsis:   Returns source filter region for current position
//
//  History:    23-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

void CSourceMapper::GetSrcRegion ( FILTERREGION& region, ULONG len, ULONG ccOffsetInBuf )
{
    if (_offSplit == 0 || ccOffsetInBuf < _offSplit)
    {
        region.idChunk = _idChunk;
        if (_ccLen == 0)  // direct mapping
        {
            region.cwcStart = _offInChunk + ccOffsetInBuf;
            region.cwcExtent = len;
        }
        else  // map to whole region
        {
            region.cwcStart = _offInChunk;
            region.cwcExtent = _ccLen;
        }
    }
    else
    {
        region.idChunk = _idNewChunk;
        region.cwcStart = ccOffsetInBuf - _offSplit;
        region.cwcExtent = len;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\filtdump\filtdump.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       filtdump.cxx
//
//  Contents:   IFilter dump utility
//
//  History:    30-Dec-97 KyleP     Added header
//
//--------------------------------------------------------------------------

#include <stdio.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <filterr.h>
#include <filter.h>
#include <ntquery.h>
#include <vquery.hxx>

BOOL fContentOnly = FALSE;
BOOL fOutputFile = FALSE;

void * pProtectedStart;
WCHAR * pwszProtectedBuf;
unsigned ccProtectedBuf = 100;

void Usage();

int _cdecl main( int argc, char * argv[] )
{
    if ( argc < 2 )
    {
        Usage();
        exit( 0 );
    }

    WCHAR wszBuffer[4096];
    WCHAR wszBuffer2[4096];
    char  szBuffer[4096];
    char  szOutputFile[MAX_PATH];
    ULONG cbWritten;
    char szDefault[] = "?";

    HRESULT hr = CoInitializeEx( 0, COINIT_MULTITHREADED );

    if ( FAILED( hr ) )
        return 1;

    HANDLE hFile = GetStdHandle( STD_OUTPUT_HANDLE );

    int iFile = 1;

    for ( int i = 1; i < argc; i++ )
    {
        if ( argv[i][0] == '-' )
        {
            switch ( argv[i][1] )
            {
            case 'b':
            case 'B':
                iFile = i+1;
                fContentOnly = 1;
                break;

            case 'o':
            case 'O':
                fOutputFile = 1;
                if ( strlen( argv[i+1] ) >= sizeof szOutputFile ) 
                {
                    Usage();
                    return 1;
                }
                strcpy(szOutputFile, argv[i+1]);
                iFile = i+2;
                break;

            case 's':
            case 'S':
                iFile = i+2;
                i++;
                ccProtectedBuf = atoi( argv[i] );
                break;

            default:
                Usage();
                return 0;
            }
        }
    }

    if ( fOutputFile )
    {
        hFile = CreateFileA( szOutputFile,         // pointer to name of the file
                             GENERIC_WRITE,        // access (read-write) mode
                             FILE_SHARE_READ,      // share mode
                             0,                    // pointer to security attributes
                             CREATE_ALWAYS,        // how to create
                             0,                    // file attributes
                             0 );                  // template

        if ( INVALID_HANDLE_VALUE == hFile )
        {
            sprintf( szBuffer, "Error %d opening %s\n", GetLastError(), argv[iFile] );
            WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, strlen(szBuffer), &cbWritten, 0 );

            exit( 1 );
        }

        wszBuffer[0] = 0xFEFF;
        if (!fContentOnly)
            WriteFile( hFile, wszBuffer, sizeof(WCHAR), &cbWritten, 0 );
    }

    //
    // Allocate protected buffer
    //

    int cbProtectedBuf = ccProtectedBuf * sizeof(WCHAR);
    pProtectedStart = VirtualAlloc( 0, cbProtectedBuf + 4096 + 1, MEM_RESERVE, PAGE_READWRITE );
    VirtualAlloc( pProtectedStart, ((cbProtectedBuf + 4095) / 4096) * 4096, MEM_COMMIT, PAGE_READWRITE );
    pwszProtectedBuf = (WCHAR *) ((BYTE *)pProtectedStart + ((cbProtectedBuf + 4095) / 4096) * 4096 - cbProtectedBuf);


    for ( ; iFile < argc; iFile++ )
    {
        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
        {
            sprintf( szBuffer, "FILE: %s\n", argv[iFile] );

            if (!fContentOnly)
                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
        }
        else
        {
            mbstowcs( wszBuffer2, argv[iFile], sizeof(wszBuffer2)/sizeof(WCHAR) );
            swprintf( wszBuffer, L"FILE: %s\r\n", wszBuffer2 );

            if (!fContentOnly)
                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
        }

        WCHAR wcsPath[MAX_PATH];
        mbstowcs( wcsPath, argv[iFile], sizeof(wcsPath)/sizeof(WCHAR) );
        IFilter * pFilt = 0;

        SCODE sc = LoadIFilter( wcsPath, 0, (void **)&pFilt );

        if ( FAILED(sc) )
        {
            if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
            {
                sprintf( szBuffer, "Error 0x%x loading IFilter\n", sc );

                if (!fContentOnly)
                    WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
            }
            else
            {
                swprintf( wszBuffer, L"Error 0x%x loading IFilter\r\n", sc );

                if (!fContentOnly)
                    WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
            }

            CIShutdown();

            exit( 1 );
        }

        //
        // Initialize filter.
        //

        ULONG Flags = 0;

        sc = pFilt->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                          IFILTER_INIT_HARD_LINE_BREAKS |
                          IFILTER_INIT_CANON_HYPHENS |
                          IFILTER_INIT_CANON_SPACES |
                          IFILTER_INIT_INDEXING_ONLY |
                          IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                          0,
                          NULL,
                          &Flags );


        if( FAILED(sc) )
        {
            if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
            {
                sprintf( szBuffer, "Error 0x%x from IFilter::Init.\n", sc );

                if (!fContentOnly)
                    WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
            }
            else
            {
                swprintf( wszBuffer, L"Error 0x%x from IFilter::Init.\r\n", sc );

                if (!fContentOnly)
                    WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
            }

            pFilt->Release();
            CIShutdown();
            exit( 1 );
        }

        if ( !fContentOnly && (Flags & IFILTER_FLAGS_OLE_PROPERTIES) )
        {
            if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
            {
                sprintf( szBuffer, "**Additional Properties available via IPropertyStorage.\n\n", sc );
                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
            }
            else
            {
                swprintf( wszBuffer, L"**Additional Properties available via IPropertyStorage.\r\n\r\n", sc );
                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
            }
        }

        //
        // Loop through the chunks.
        //

        BOOL fText;
        STAT_CHUNK StatChunk;
        StatChunk.attribute.psProperty.ulKind = PRSPEC_PROPID;

        while (1)
        {
            WCHAR wcsBuffer[2048];

            sc = pFilt->GetChunk( &StatChunk );

            if ( FILTER_E_EMBEDDING_UNAVAILABLE == sc || FILTER_E_LINK_UNAVAILABLE == sc )
            {
                if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                {
                    sprintf( szBuffer, "Encountered an embed/link for which filter is not available.\n" );

                    if (!fContentOnly)
                        WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                }
                else
                {
                    swprintf( wszBuffer, L"Encountered an embed/link for which filter is not available.\r\n" );

                    if (!fContentOnly)
                        WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                }

                continue; //continue with other chunks.
            }

            if ( FAILED(sc) && sc != FILTER_E_END_OF_CHUNKS )
            {
                if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                {
                    sprintf( szBuffer, "IFilter::GetChunk returned 0x%x\n", sc );

                    if (!fContentOnly)
                        WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                }
                else
                {
                    swprintf( wszBuffer, L"IFilter::GetChunk returned 0x%x\r\n", sc );

                    if (!fContentOnly)
                        WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                }

                break;
            }

            if ( sc == FILTER_E_END_OF_CHUNKS )
                break;

            if ( CHUNK_TEXT == StatChunk.flags )
                fText = TRUE;
            if ( CHUNK_VALUE == StatChunk.flags )
                fText = FALSE;

            //
            // Put in the struct of chunk into the file if requested
            //

            int cc = 0;

            cc += swprintf( wszBuffer + cc, L"\r\n----------------------------------------------------------------------\r\n" );

            cc += swprintf( wszBuffer + cc, L"\t\tAttribute = %08lX-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X\\",
                         StatChunk.attribute.guidPropSet.Data1,
                         StatChunk.attribute.guidPropSet.Data2,
                         StatChunk.attribute.guidPropSet.Data3,
                         StatChunk.attribute.guidPropSet.Data4[0], StatChunk.attribute.guidPropSet.Data4[1],
                         StatChunk.attribute.guidPropSet.Data4[2], StatChunk.attribute.guidPropSet.Data4[3],
                         StatChunk.attribute.guidPropSet.Data4[4], StatChunk.attribute.guidPropSet.Data4[5],
                         StatChunk.attribute.guidPropSet.Data4[6], StatChunk.attribute.guidPropSet.Data4[7] );

            if ( StatChunk.attribute.psProperty.ulKind == PRSPEC_PROPID )
                cc += swprintf( wszBuffer + cc, L"%d\r\n", StatChunk.attribute.psProperty.propid );
            else
                cc += swprintf( wszBuffer + cc, L"%ws\r\n", StatChunk.attribute.psProperty.lpwstr );

            cc += swprintf( wszBuffer + cc, L"\t\tidChunk = %d\r\n", StatChunk.idChunk );
            cc += swprintf( wszBuffer + cc, L"\t\tBreakType = %d", StatChunk.breakType );

            switch ( StatChunk.breakType )
            {
            case CHUNK_NO_BREAK:
                cc += swprintf( wszBuffer + cc, L" (No Break)\r\n" );
                break;

            case CHUNK_EOW:
                cc += swprintf( wszBuffer + cc, L" (Word)\r\n" );
                break;

            case CHUNK_EOS:
                cc += swprintf( wszBuffer + cc, L" (Sentence)\r\n" );
                break;

            case CHUNK_EOP:
                cc += swprintf( wszBuffer + cc, L" (Paragraph)\r\n" );
                break;

            case CHUNK_EOC:
                cc += swprintf( wszBuffer + cc, L" (Chapter)\r\n" );
                break;
            }

            cc += swprintf( wszBuffer + cc, L"\t\tFlags(chunkstate) = 0x%x", StatChunk.flags );

            if ( CHUNK_TEXT & StatChunk.flags )
                cc += swprintf( wszBuffer + cc, L" (Text) " );

            if ( CHUNK_VALUE & StatChunk.flags )
                cc += swprintf( wszBuffer + cc, L" (Value) " );

            cc += swprintf( wszBuffer + cc, L"\r\n" );
            cc += swprintf( wszBuffer + cc, L"\t\tLocale = %d (0x%x)\r\n", StatChunk.locale, StatChunk.locale );
            cc += swprintf( wszBuffer + cc, L"\t\tIdChunkSource = %d\r\n", StatChunk.idChunkSource );
            cc += swprintf( wszBuffer + cc, L"\t\tcwcStartSource = %d\r\n", StatChunk.cwcStartSource );
            cc += swprintf( wszBuffer + cc, L"\t\tcwcLenSource = %d\r\n", StatChunk.cwcLenSource );

            cc += swprintf( wszBuffer + cc, L"----------------------------------------------------------------------\r\n" );

            if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
            {
                int cc2 = WideCharToMultiByte( CP_ACP,
                                               WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                                               wszBuffer,
                                               cc,
                                               szBuffer,
                                               sizeof(szBuffer),
                                               szDefault,
                                               0 );

                if (!fContentOnly)
                    WriteFile( hFile, szBuffer, cc2, &cbWritten, 0 );
            }
            else
            {
                if (!fContentOnly)
                    WriteFile( hFile, wszBuffer, cc*sizeof(WCHAR), &cbWritten, 0 );
            }

            PROPVARIANT * pPropValue;

            while ( TRUE )
            {
                if( fText )
                {
                    ULONG ccBuffer = ccProtectedBuf;
                    sc = pFilt->GetText( &ccBuffer, pwszProtectedBuf );

//printf ("sc: %#x, ccBuffer: %d, buffer %#x\n", sc, ccBuffer, pwszProtectedBuf );
//DebugBreak();

                    if ( FAILED(sc) && (sc != FILTER_E_NO_MORE_TEXT) )
                    {
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            sprintf( szBuffer, "Error 0x%x from IFilter::GetText.\n", sc );

                            if (!fContentOnly)
                                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                        }
                        else
                        {
                            swprintf( wszBuffer, L"Error 0x%x from IFilter::GetText.\r\n", sc );

                            if (!fContentOnly)
                                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                        }

                        break;
                    }

                    if ( sc == FILTER_E_NO_MORE_TEXT )
                        break; //go, fetch another chunk

                    //
                    // write the buffer to file
                    //

#if 0

                    if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                    {
                        sprintf( szBuffer, "\n------\nGetText returned %d characters\n------\n", ccBuffer );

                        if (!fContentOnly)
                            WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                    }
                    else
                    {
                        swprintf( wszBuffer, L"\n------\nGetText returned %d characters\n------\n", ccBuffer );

                        if (!fContentOnly)
                            WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                    }
#endif

                    if ( 0 == ccBuffer )
                    {
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            sprintf( szBuffer, "<empty ::GetText>\r\n", ccBuffer );

                            if (!fContentOnly)
                                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                        }
                        else
                        {
                            swprintf( wszBuffer, L"<empty ::GetText>\r\n", ccBuffer );

                            if (!fContentOnly)
                                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                        }
                    }

                    wcsBuffer[ccBuffer] = 0;

                    //
                    // Convert to MBCS
                    //

                    if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                    {
//printf( "copy to %#x, from %#x, cc %d\n", wcsBuffer, pwszProtectedBuf, ccBuffer );
//DebugBreak();
                        for ( unsigned i = 0; i < ccBuffer; i++ )
                        {
                            if ( 0xd == pwszProtectedBuf[i] ||
                                 0xb == pwszProtectedBuf[i] )
                                WriteFile( hFile, "\r\n", 2, &cbWritten, 0 );
                            else
                                WriteFile( hFile, &pwszProtectedBuf[i], sizeof BYTE, &cbWritten, 0 );
                        }
//                        RtlCopyMemory( wcsBuffer, pwszProtectedBuf, ccBuffer * sizeof WCHAR );
//                        printf( "%ws", wcsBuffer );
                    }
                    else
                    {
                        WriteFile( hFile, pwszProtectedBuf, ccBuffer * sizeof(WCHAR), &cbWritten, 0 );
                    }
                }

                if( !fText )
                {
                    sc = pFilt->GetValue( &pPropValue );

                    if ( FAILED(sc) && (sc != FILTER_E_NO_MORE_VALUES) )
                    {
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            sprintf( szBuffer, "IFilter::GetValue returned 0x%x\n", sc );

                            if (!fContentOnly)
                                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                        }
                        else
                        {
                            swprintf( wszBuffer, L"IFilter::GetValue returned 0x%x\r\n", sc );

                            if (!fContentOnly)
                                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                        }
                        break;
                    }

                    if ( sc == FILTER_E_NO_MORE_VALUES )
                        break; //go, fetch another chunk

                    if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                    {
                        sprintf( szBuffer, "Type = %d (0x%x): ", pPropValue->vt, pPropValue->vt );

                        if (!fContentOnly)
                            WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                    }
                    else
                    {
                        swprintf( wszBuffer, L"Type = %d (0x%x): ", pPropValue->vt, pPropValue->vt );

                        if (!fContentOnly)
                            WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                    }

                    switch( pPropValue->vt )
                    {
                    case VT_LPWSTR:
                    case VT_BSTR:
                    {
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            int cc = WideCharToMultiByte( CP_ACP,
                                                          WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                                                          pPropValue->pwszVal,
                                                          wcslen( pPropValue->pwszVal ),
                                                          szBuffer,
                                                          sizeof(szBuffer),
                                                          szDefault,
                                                          0 );

                            WriteFile( hFile, szBuffer, cc, &cbWritten, 0 );
                        }
                        else
                        {
                            WriteFile( hFile, pPropValue->pwszVal, wcslen(pPropValue->pwszVal) * sizeof(WCHAR), &cbWritten, 0 );
                        }
                        break;
                    }

                    case VT_LPSTR:
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            WriteFile( hFile, pPropValue->pszVal, strlen(pPropValue->pszVal), &cbWritten, 0 );
                        }
                        else
                        {
                            wszBuffer[0] = 0;

                            MultiByteToWideChar( CP_ACP,
                                                 0,
                                                 pPropValue->pszVal,
                                                 -1,
                                                 wszBuffer,
                                                 sizeof wszBuffer / sizeof wszBuffer[0] );

                            WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                        }
                        break;

                    default:
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            sprintf( szBuffer, "Unprintable type" );

                            if (!fContentOnly)
                                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                        }
                        else
                        {
                            swprintf( wszBuffer, L"Unprintable type" );

                            if (!fContentOnly)
                                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                        }

                        break;
                    }

                    if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                    {
                        sprintf( szBuffer, "\n" );
                        WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                    }
                    else
                    {
                        swprintf( wszBuffer, L"\r\n" );
                        WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                    }

                    if( pPropValue )
                    {
                        PropVariantClear( pPropValue );

                        CoTaskMemFree( pPropValue );

                        pPropValue = 0;
                    }
                }
            }//while
        }//while

        pFilt->Release();


        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
        {
            sprintf( szBuffer, "\n\n" );
            WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
        }
        else
        {
            swprintf( wszBuffer, L"\r\n\r\n" );
            WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
        }
    }

    CIShutdown();

    CoUninitialize();

    if ( hFile != GetStdHandle( STD_OUTPUT_HANDLE ) )
    {
        CloseHandle( hFile );
    }

    return 0;
}

void Usage()
{
    printf( "Usage: FiltDump [-b] [-o Unicode output file] [-s buffer size] <file> <file> <file> ...\n" );
    printf( "Use -b to print only the contents of the file without additional commentary.\n");
    printf( "Use -s to control text buffer size (guard page at end)\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\mapper.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   MAPPER.CXX
//
//  Contents:   Search Key Repository
//
//  Classes:    CSourceMapper
//
//  History:    23-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CSourceMapper::Advance
//
//  Synopsis:   Advance the mapper after processing ccDelta characters
//
//  History:    30-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

void CSourceMapper::Advance ( ULONG ccProcessed )
{
    _offInChunk += ccProcessed;
    if (_offSplit != 0)
    {
        // split buffer situation (two current chunks)
        if (ccProcessed >= _offSplit)
        {
            // got rid of leftover chunk
            _offInChunk = ccProcessed - _offSplit;
            _offSplit = 0;
            _idChunk = _idNewChunk;
        }
        else
            _offSplit -= ccProcessed;
    }
}

void CSourceMapper::NewChunk ( ULONG idChunk, ULONG ccBegin )
{
    if (ccBegin != 0)
    {
        _offSplit = ccBegin;
        _idNewChunk = idChunk;
    }
    else
    {
        _offSplit = 0;
        _idChunk = idChunk;
        _offInChunk = 0;
    }
    _ccLen = 0;
}

void CSourceMapper::NewDerivedChunk ( ULONG idChunkSource, ULONG ccBeginSource, ULONG ccLen )
{
    _idChunk = idChunkSource;
    _offInChunk = ccBeginSource;
    _offSplit = 0;
    _ccLen = ccLen;
}
//+---------------------------------------------------------------------------
//
//  Member:     CSourceMapper::GetSrcRegion
//
//  Synopsis:   Returns source filter region for current position
//
//  History:    23-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

void CSourceMapper::GetSrcRegion ( FILTERREGION& region, ULONG len, ULONG ccOffsetInBuf )
{
    if (_offSplit == 0 || ccOffsetInBuf < _offSplit)
    {
        region.idChunk = _idChunk;
        if (_ccLen == 0)  // direct mapping
        {
            region.cwcStart = _offInChunk + ccOffsetInBuf;
            region.cwcExtent = len;
        }
        else  // map to whole region
        {
            region.cwcStart = _offInChunk;
            region.cwcExtent = _ccLen;
        }
    }
    else
    {
        region.idChunk = _idNewChunk;
        region.cwcStart = ccOffsetInBuf - _offSplit;
        region.cwcExtent = len;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\filtreg\filtreg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       filtreg.cxx
//
//  Contents:   Filter registration utility
//
//  History:    02 Dec 1997     KyleP   Created
//
//--------------------------------------------------------------------------

#include <stdio.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

//
// From smart.hxx
//

class SRegKey
{
public:
    SRegKey( HKEY key ) : _key( key ) {}
    SRegKey() : _key( 0 ) {}
    ~SRegKey() { Free(); }
    void Set( HKEY key ) { _key = key; }
    HKEY Acquire() { HKEY tmp = _key; _key = 0; return tmp; }
    void Free() { if ( 0 != _key ) { RegCloseKey( _key ); _key = 0; } }

private:
    HKEY _key;
};

void Usage();
void PrintExtensions( HKEY hkeyCLSID, WCHAR const * wcsTargetCLSID );
void LocateByExtension( HKEY hkeyCLSID );
void LocateByCLSID( HKEY hkeyCLSID );
BOOL LocateFilter( HKEY hkeyBase,
                   HKEY hkeyCLSID,
                   WCHAR const * wcsClassOrExt,
                   WCHAR * wcsFilterName,
                   WCHAR * wcsFilterDll );
LONG Replicate( WCHAR const * wszDstExt, WCHAR const * wszSrcExt );

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    if ( argc > 1 )
    {
        if ( argc != 3 )
            Usage();
        else
            Replicate( argv[1], argv[2] );
    }
    else
    {
        //
        // Enumerate, looking for extensions and classes with a persistent handler.
        //

        HKEY hkeyCLSID;

        LONG dwError = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                                     L"CLSID",
                                     0,
                                     KEY_READ | KEY_ENUMERATE_SUB_KEYS,
                                     &hkeyCLSID );

        if ( ERROR_SUCCESS != dwError )
        {
            printf( "RegOpenKey( \"CLSID\" ) returned %d\n", dwError );
        }
        else
        {
            SRegKey xkeyCLSID( hkeyCLSID );

            printf( "Filters loaded by extension:\n" );
            LocateByExtension( hkeyCLSID );

            printf( "\n\nFilters loaded by class:\n" );
            LocateByCLSID( hkeyCLSID );
        }
    }

    return 0;
}

void Usage()
{
    printf( "Usage: filtreg [dstExt] [srcExt]\n"
            "  Displays IFilter registrations.  If [dstExt] and [srcExt]\n"
            "  are specified then [dstExt] is registered to act like [srcExt].\n" );
}

void LocateByExtension( HKEY hkeyCLSID )
{
    DWORD dwExtIndex;

    DWORD dwError = RegQueryInfoKey (  HKEY_CLASSES_ROOT,
                                       0,
                                       0,
                                       0,
                                       &dwExtIndex,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0 );

    if ( ERROR_SUCCESS != dwError )
    {
        printf( "RegQueryInfoKey( HKCR ) returned %d\n", dwError );
    }
    else
    {
        for ( DWORD dwIndex = 0; dwIndex < dwExtIndex; dwIndex++ )
        {
            WCHAR wcsExt[100];
            DWORD ccExt = sizeof(wcsExt)/sizeof(WCHAR);

            dwError = RegEnumKeyEx( HKEY_CLASSES_ROOT,
                                    dwIndex,
                                    wcsExt,
                                    &ccExt,
                                    0,
                                    0,
                                    0,
                                    0 );

            //
            // All the extensions come first.
            //

            if ( ERROR_SUCCESS != dwError || ( wcsExt[0] != L'.' && wcsExt[0] != L'*' ) )
                break;

            WCHAR wcsFilterName[MAX_PATH];
            WCHAR wcsFilterDll[MAX_PATH]; 

            if ( LocateFilter( HKEY_CLASSES_ROOT,
                               hkeyCLSID,
                               wcsExt,
                               wcsFilterName,
                               wcsFilterDll ) )
            {
                printf( "%ws --> %ws (%ws)\n", wcsExt, wcsFilterName, wcsFilterDll );
            }
        }
    }
}

void LocateByCLSID( HKEY hkeyCLSID )
{
    DWORD dwClsidIndex;

    DWORD dwError = RegQueryInfoKey (  hkeyCLSID,
                                       0,
                                       0,
                                       0,
                                       &dwClsidIndex,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0 );

    if ( ERROR_SUCCESS != dwError )
    {
        printf( "RegQueryInfoKey( \"CLSID\" ) returned %d\n", dwError );
    }
    else
    {
        for ( DWORD dwIndex = dwClsidIndex - 2; dwIndex != 0xFFFFFFFF; dwIndex-- )
        {
            WCHAR wcsCLSID[100];
            DWORD ccCLSID = sizeof(wcsCLSID)/sizeof(WCHAR);

            dwError = RegEnumKeyEx( hkeyCLSID,
                                    dwIndex,
                                    wcsCLSID,
                                    &ccCLSID,
                                    0,
                                    0,
                                    0,
                                    0 );

            if ( ERROR_SUCCESS == dwError )
            {
                //
                // Look for a filter.
                //

                WCHAR wcsFilterName[MAX_PATH]; 
                WCHAR wcsFilterDll[MAX_PATH];  

                if ( LocateFilter( hkeyCLSID,
                                   hkeyCLSID,
                                   wcsCLSID,
                                   wcsFilterName,
                                   wcsFilterDll ) )
                {
                    //
                    // Find a decent name for the class.
                    //

                    HKEY hkeyClass;

                    RegOpenKeyEx( hkeyCLSID,
                                  wcsCLSID,
                                  0,
                                  KEY_READ,
                                  &hkeyClass );

                    SRegKey xkeyClass( hkeyClass );

                    WCHAR wcsClassName[500];
                    DWORD dwType;
                    DWORD cbClassName = sizeof(wcsClassName);

                    dwError = RegQueryValueEx( hkeyClass,
                                               0,
                                               0,
                                               &dwType,
                                               (BYTE *)wcsClassName,
                                               &cbClassName );

                    if ( ERROR_SUCCESS != dwError || dwType != REG_SZ || wcsClassName[0] == 0)
                    {
                        wcscpy( wcsClassName, wcsCLSID );
                    }

                    printf( "%ws\n\tFilter: %ws (%ws)\n", wcsClassName, wcsFilterName, wcsFilterDll );

                    PrintExtensions( hkeyCLSID, wcsCLSID );
                    printf( "\n\n" );
                }
            }
        }
    }
}

BOOL LocateFilter( HKEY hkeyBase,
                   HKEY hkeyCLSID,
                   WCHAR const * wcsClassOrExt,
                   WCHAR * wcsFilterName,
                   WCHAR * wcsFilterDll )
{
    BOOL fOk = FALSE;

    do
    {
        //
        // Look for a persistent handler
        //

        unsigned cwc = wcslen( wcsClassOrExt ) + wcslen( L"\\PersistentHandler" );

        if ( cwc >= MAX_PATH )
            return FALSE;

        HKEY hkeyPH;
        WCHAR wcsTemp[MAX_PATH];

        wcscpy( wcsTemp, wcsClassOrExt );
        wcscat( wcsTemp, L"\\PersistentHandler" );

        DWORD dwError = RegOpenKeyEx( hkeyBase,
                                      wcsTemp,
                                      0,
                                      KEY_READ | KEY_ENUMERATE_SUB_KEYS,
                                      &hkeyPH );

        if ( ERROR_SUCCESS != dwError )
            break;

        SRegKey xkeyPH( hkeyPH );

        //
        // Find the name of the persistent handler
        //

        wcscat( wcsFilterName, L"Unknown" );
        wcscat( wcsFilterDll, L"Unknown" );

        WCHAR wcsPHClass[1000];
        DWORD cbPHClass = sizeof(wcsPHClass);
        DWORD dwType;

        dwError = RegQueryValueEx( hkeyPH,
                                   0,
                                   0,
                                   &dwType,
                                   (BYTE *)wcsPHClass,
                                   &cbPHClass );

        if ( ERROR_SUCCESS != dwError )
            break;

        HKEY hkeyPHClass;

        wcscat( wcsPHClass, L"\\PersistentAddinsRegistered\\{89BCB740-6119-101A-BCB7-00DD010655AF}" );

        RegOpenKeyEx( hkeyCLSID,
                      wcsPHClass,
                      0,
                      KEY_READ,
                      &hkeyPHClass );

        SRegKey xkeyPHClass( hkeyPHClass );

        //
        // Now open the filter class and look for a name.
        //

        if ( ERROR_SUCCESS != dwError )
            break;

        WCHAR wcsFilterClass[1000];
        DWORD cbFilterClass = sizeof(wcsFilterClass);

        dwError = RegQueryValueEx( hkeyPHClass,
                                   0,
                                   0,
                                   &dwType,
                                   (BYTE *)wcsFilterClass,
                                   &cbFilterClass );

        if ( ERROR_SUCCESS != dwError || dwType != REG_SZ )
            break;

        HKEY hkeyFilterClass;

        dwError = RegOpenKeyEx( hkeyCLSID,
                                wcsFilterClass,
                                0,
                                KEY_READ,
                                &hkeyFilterClass );

        if ( ERROR_SUCCESS != dwError )
            break;

        SRegKey xkeyFilterClass( hkeyFilterClass );

        DWORD cbFilterName = MAX_PATH;

        dwError = RegQueryValueEx( hkeyFilterClass,
                                   0,
                                   0,
                                   &dwType,
                                   (BYTE *)wcsFilterName,
                                   &cbFilterName );

        //
        // Don't check for error, because "Unknown was already in wcsFiltername
        //

        HKEY hkeyFilterIPS;

        dwError = RegOpenKeyEx( hkeyFilterClass,
                                L"InprocServer32",
                                0,
                                KEY_READ,
                                &hkeyFilterIPS );

        if ( ERROR_SUCCESS != dwError )
            break;

        DWORD cbFilterDll = MAX_PATH;

        dwError = RegQueryValueEx( hkeyFilterIPS,
                                   0,
                                   0,
                                   &dwType,
                                   (BYTE *)wcsFilterDll,
                                   &cbFilterDll );

        //
        // Don't check for error, because "Unknown was already in wcsFiltername
        //

        fOk = TRUE;

    } while( FALSE );

    return fOk;
}


void PrintExtensions( HKEY hkeyCLSID, WCHAR const * wcsTargetCLSID )
{
    unsigned cExt = 0;

    //
    // Re-used vars
    //

    DWORD ccTemp;  // Size for RegQueryValueEx
    DWORD dwType;  // Type for RegQueryValueEx

    DWORD dwClassIndex;

    DWORD dwError = RegQueryInfoKey (  HKEY_CLASSES_ROOT,
                                       0,
                                       0,
                                       0,
                                       &dwClassIndex,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0 );

    if ( ERROR_SUCCESS != dwError )
    {
        printf( "RegQueryInfoKey( \"CLSID\" ) returned %d\n", dwError );
    }
    else
    {
        //
        // Outer loop looks for items registered with this class id
        //

        WCHAR wcsShortName[100];
        WCHAR wcsShortName2[sizeof(wcsShortName)/sizeof(WCHAR)];
        wcsShortName2[0] = 0;

        for ( DWORD dwIndex = dwClassIndex - 2; dwIndex != 0xFFFFFFFF; dwIndex-- )
        {
            ccTemp = sizeof(wcsShortName)/sizeof(WCHAR);


            dwError = RegEnumKeyEx( HKEY_CLASSES_ROOT,
                                    dwIndex,
                                    wcsShortName,
                                    &ccTemp,
                                    0,
                                    0,
                                    0,
                                    0 );

            if ( ERROR_SUCCESS != dwError )
                continue;

            HKEY hkeyClsid;
            WCHAR wcsTemp[sizeof(wcsShortName)/sizeof(WCHAR) + 50];

            unsigned cwc = wcslen( wcsShortName ) + wcslen( L"\\CLSID" );

            if ( cwc >= ( sizeof wcsTemp / sizeof WCHAR ) )
                return;

            wcscpy( wcsTemp, wcsShortName );
            wcscat( wcsTemp, L"\\CLSID" );

            dwError = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                                    wcsTemp,
                                    0,
                                    KEY_READ | KEY_ENUMERATE_SUB_KEYS,
                                    &hkeyClsid );

            if ( ERROR_SUCCESS != dwError )
                continue;

            //
            // This is a short name. Now get the Class Id and see if
            // it matches.
            //

            SRegKey xkeyClsid( hkeyClsid );

            WCHAR wcsClsid[100];
            DWORD cbTemp = sizeof(wcsClsid);

            dwError = RegQueryValueEx( hkeyClsid,
                                       0,
                                       0,
                                       &dwType,
                                       (BYTE *)wcsClsid,
                                       &cbTemp );

            if ( ERROR_SUCCESS != dwError ||
                 0 != _wcsicmp( wcsClsid, wcsTargetCLSID ) )
            {
                continue;
            }

            //
            // This is a matching short name.  Now, go back and look for
            // extensions.
            //

            for ( DWORD dwIndex2 = 0; dwIndex2 < dwClassIndex; dwIndex2++ )
            {
                WCHAR wcsExtension[100];
                DWORD ccExtension = sizeof(wcsExtension)/sizeof(WCHAR);

                dwError = RegEnumKeyEx( HKEY_CLASSES_ROOT,
                                        dwIndex2,
                                        wcsExtension,
                                        &ccExtension,
                                        0,
                                        0,
                                        0,
                                        0 );

                //
                // All the extensions come first.
                //

                if ( ERROR_SUCCESS != dwError || (wcsExtension[0] != L'.' && wcsExtension[0] != L'*') )
                    break;

                //
                // Potential extension...
                //

                HKEY hkeyExtension;

                dwError = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                                        wcsExtension,
                                        0,
                                        KEY_READ | KEY_ENUMERATE_SUB_KEYS,
                                        &hkeyExtension );

                if ( ERROR_SUCCESS != dwError )
                    continue;

                SRegKey xkeyExtension( hkeyExtension );
                WCHAR wcsShortName3[sizeof(wcsShortName)/sizeof(WCHAR)];
                cbTemp = sizeof(wcsShortName3);

                dwError = RegQueryValueEx( hkeyExtension,
                                           0,
                                           0,
                                           &dwType,
                                           (BYTE *)wcsShortName3,
                                           &cbTemp );

                if ( ERROR_SUCCESS == dwError && 0 == _wcsicmp( wcsShortName, wcsShortName3 ) )
                {
                    //
                    // Work around wierd anomalies in registry enumeration.
                    //

                    #if 0
                    if ( 0 == _wcsicmp( wcsShortName2, wcsShortName3 ) )
                        continue;
                    else
                        wcscpy( wcsShortName2, wcsShortName3 );
                    #endif

                    //
                    // Is this extension covered by an override?
                    //

                    WCHAR wcsFilterName[MAX_PATH]; 
                    WCHAR wcsFilterDll[MAX_PATH];  

                    if ( !LocateFilter( HKEY_CLASSES_ROOT,
                                        hkeyCLSID,
                                        wcsExtension,
                                        wcsFilterName,
                                        wcsFilterDll ) )
                    {
                        if ( cExt % 2 == 0 )
                        {
                            if ( 0 != cExt )
                                printf( "\n" );

                            printf( "\tExtensions: %ws (%ws) ", wcsExtension, wcsShortName );
                        }
                        else
                            printf( "%ws (%ws) ", wcsExtension, wcsShortName );

                        cExt++;
                    }
                }
            }
        }
    }
}

LONG Replicate( WCHAR const * wszDstExt, WCHAR const * wszSrcExt )
{
    DWORD dwError;

    do
    {
        //
        // First, look up the old one...
        //

        unsigned cwc = wcslen( wszSrcExt ) + wcslen( L"\\PersistentHandler" );

        if ( cwc >= MAX_PATH )
            return ERROR_INVALID_PARAMETER;

        HKEY hkeyPH;
        WCHAR wcsTemp[MAX_PATH];

        wcscpy( wcsTemp, wszSrcExt );
        wcscat( wcsTemp, L"\\PersistentHandler" );

        dwError = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                                wcsTemp,
                                0,
                                KEY_READ | KEY_ENUMERATE_SUB_KEYS,
                                &hkeyPH );

        if ( ERROR_SUCCESS != dwError )
        {
            printf( "Error %u opening HKCR\\%ws\n", dwError, wcsTemp );
            break;
        }

        SRegKey xkeyPH( hkeyPH );

        DWORD dwType;
        WCHAR wcsPH[100];
        DWORD cbTemp = sizeof(wcsPH);

        dwError = RegQueryValueEx( hkeyPH,
                                   0,
                                   0,
                                   &dwType,
                                   (BYTE *)wcsPH,
                                   &cbTemp );

        if ( ERROR_SUCCESS != dwError )
        {
            printf( "Error %u reading persistent handler class.\n", dwError );
            break;
        }

        //
        // Now append to new extension.
        //

        HKEY  hkeyDstPH;
        DWORD dwDisposition;

        cwc = wcslen( wszDstExt ) + wcslen( L"\\PersistentHandler" );

        if ( cwc >= MAX_PATH )
            return ERROR_INVALID_PARAMETER;

        wcscpy( wcsTemp, wszDstExt );
        wcscat( wcsTemp, L"\\PersistentHandler" );

        dwError = RegCreateKeyExW( HKEY_CLASSES_ROOT,    // Root
                                   wcsTemp,              // Sub key
                                   0,                    // Reserved
                                   0,                    // Class
                                   0,                    // Flags
                                   KEY_ALL_ACCESS,       // Access
                                   0,                    // Security
                                   &hkeyDstPH,           // Handle
                                   &dwDisposition );     // Disposition

        if ( ERROR_SUCCESS != dwError )
        {
            printf( "Error %u creating persistent handler key HKCR\\%ws\n", dwError, wcsTemp );
            break;
        }

        SRegKey xkeyDstPH( hkeyDstPH );

        dwError = RegSetValueExW( hkeyDstPH,                // Key
                                  0,                        // Name
                                  0,                        // Reserved
                                  REG_SZ,                   // Type
                                  (BYTE *)wcsPH,            // Value
                                  (1 + wcslen(wcsPH)) * sizeof(WCHAR) );

        if ( ERROR_SUCCESS != dwError )
        {
            printf( "Error %u creating persistent handler key HKCR\\%ws\n", dwError, wcsTemp );
            break;
        }

    } while( FALSE );

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    10-Aug-93       AmyA            Created
//
//--------------------------------------------------------------------------


extern "C"
{
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
}

#undef _CTYPE_DISABLE_MACROS
#include <crt/ctype.h>
 
#define USE_DAYTONA_OLE

#if defined(USE_DAYTONA_OLE)
# include <oleext.h>
# include <query.h>
# include <olectl.h>
# if defined(__varnt_h__)
#  error "VARIANT incompatible with PROPVARIANT"
# else
#  define VARIANT PROPVARIANT
#  define VT_UUID VT_CLSID
#  define VT_FUNCPTR 0x12345678
#  define __varnt_h__
# endif
#else
# include <varnt.h>
#endif

#include <eh.h>

#include <minici.hxx>
#include <oledberr.h>
#include <filterr.h>
#include <cierror.h>
#include <stgprop.h>
#include <restrict.hxx>
#include <stgvar.hxx>
#include <tsource.hxx>
#include <mapper.hxx>
#include <propspec.hxx>
#include <pfilter.hxx>

#include "tmpprop.hxx"
#include "fstrm.hxx"
//  #include "gen.hxx"
//  #include "genifilt.hxx"
//  #include "genflt.hxx"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\genifilt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       genifilt.cxx
//
//  Contents:   C++ filter 'class factory'.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <filtreg.hxx>
#include "gen.hxx"
#include "genifilt.hxx"
#include "genflt.hxx"

long gulcInstances = 0;

extern "C" CLSID TYPID_GenIFilter = { /* c4aac357-d152-493b-8c39-d08f575be46e */
    0xc4aac357,
    0xd152,
    0x493b,
    {0x8c, 0x39, 0xd0, 0x8f, 0x57, 0x5b, 0xe4, 0x6e}
  };

extern "C" CLSID CLSID_GenIFilter = { /* d0c093a9-8f6d-4816-aaad-df054aad0cbc */
    0xd0c093a9,
    0x8f6d,
    0x4816,
    {0xaa, 0xad, 0xdf, 0x05, 0x4a, 0xad, 0x0c, 0xbc}
  };

extern "C" CLSID CLSID_GenClass = { /* 7322e01d-d56f-494b-a8df-4685cc402f59 */
    0x7322e01d,
    0xd56f,
    0x494b,
    {0xa8, 0xdf, 0x46, 0x85, 0xcc, 0x40, 0x2f, 0x59}
  };

//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterBase::GenIFilterBase
//
//  Synopsis:   Base constructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

GenIFilterBase::GenIFilterBase()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterBase::~GenIFilterBase
//
//  Synopsis:   Base destructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

GenIFilterBase::~GenIFilterBase()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterBase::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilterBase::QueryInterface( REFIID riid,
                                                        void  ** ppvObject)
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IFilter == riid )
        *ppvObject = (IUnknown *)(IFilter *)this;
    else if ( IID_IPersist == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else if ( IID_IPersistFile == riid )
        *ppvObject = (IUnknown *)(IPersistFile *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterBase::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE GenIFilterBase::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterBase::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE GenIFilterBase::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterCF::GenIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

GenIFilterCF::GenIFilterCF()
{
    _uRefs = 1;
    long c = InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterCF::~GenIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

GenIFilterCF::~GenIFilterCF()
{
    long c = InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilterCF::QueryInterface( REFIID riid,
                                                      void  ** ppvObject )
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_ITypeLib == riid )
        sc = E_NOTIMPL;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE GenIFilterCF::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE GenIFilterCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterCF::CreateInstance
//
//  Synopsis:   Creates new TextIFilter object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilterCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    GenIFilter *  pIUnk = 0;
    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        pIUnk = new GenIFilter();
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        if( SUCCEEDED(sc) )
            pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pIUnk );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     GenIFilterCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilterCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Text filter class factory
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject( REFCLSID   cid,
                                                      REFIID     iid,
                                                      void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        if ( memcmp( &cid, &CLSID_GenIFilter, sizeof(cid) ) == 0
          || memcmp( &cid, &CLSID_GenClass, sizeof(cid) ) == 0 )
            pResult = (IUnknown *) new GenIFilterCF;
        else
            sc = E_NOINTERFACE;

        if( pResult )
        {
            sc = pResult->QueryInterface( iid, ppvObj );
            pResult->Release(); // Release extra refcount from QueryInterface
        }
    }
    CATCH(CException, e)
    {
        if ( pResult )
            pResult->Release();

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( 0 == gulcInstances )
        return( S_OK );
    else
        return( S_FALSE );
}

SClassEntry const aGenClasses[] =
{
    { L".el", L"GenFile", L"Class for generic files", L"{7322e01d-d56f-494b-a8df-4685cc402f59}", L"Class for generic files" },
//      { L".pl", L"GenFile", L"Class for generic files", L"{7322e01d-d56f-494b-a8df-4685cc402f59}", L"Class for generic files" },
//      { L".pm", L"GenFile", L"Class for generic files", L"{7322e01d-d56f-494b-a8df-4685cc402f59}", L"Class for generic files" },
};

SHandlerEntry const GenHandler =
{
    L"{f7a89b42-365d-4f41-b480-f210a449410e}",
    L"Generic persistent handler",
    L"{d0c093a9-8f6d-4816-aaad-df054aad0cbc}",
};

SFilterEntry const GenFilter =
{
    L"{d0c093a9-8f6d-4816-aaad-df054aad0cbc}",
    L"Generic IFilter",
    L"genflt.dll",
    L"Both"
};

DEFINE_DLLREGISTERFILTER( GenHandler, GenFilter, aGenClasses )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\fstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992 - 1994, Microsoft Corporation.
//
//  File:       fstrm.cxx
//
//  Contents:   Stream for transporting text from IFilter to cxx parser.
//
//  Classes:    CFilterTextStream
//
//  History:    01-Aug-93       AmyA        Created
//              17-Oct-94       BartoszM    Rewrote
//
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Member:     CFilterTextStream::CFilterTextStream, public
//
//  Synopsis:   Constructor
//
//  History:    01-Aug-93       AmyA        Created
//              17-Oct-94       BartoszM    Rewrote
//
//--------------------------------------------------------------------------

CFilterTextStream::CFilterTextStream(IFilter* pIFilter)
: CTextSource(_statChunk)
{
    iEnd = 0;
    iCur = 0;
    Win4Assert (pIFilter != 0);
    awcBuffer = _awcFilterBuffer;
    _sc = pIFilter->GetChunk( &_statChunk );
    if (SUCCEEDED(_sc))
    {
        _pFilter = pIFilter;
        pfnFillTextBuffer = CTextSource::FillBuf;
        _mapper.NewChunk ( _statChunk.idChunk, 0 );
        _pMapper = &_mapper;
        _sc = CTextSource::FillBuf( this );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterTextStream::GetMore, public
//
//  Synopsis:   Try to replenish the buffer
//
//  History:    16-Nov-94  BartoszM         Created
//
//----------------------------------------------------------------------------

int CFilterTextStream::GetMore()
{
    if (iCur == iEnd - 1)
    {
        _sc = FillBuf( this );
        // if there was no more data
        // the last lookahead was moved
        // to the beginning and
        // iCur == iEnd - 1
        // next time around it will be
        // iCur == iEnd
    }
    else
    {
        Win4Assert(iCur == iEnd);
        return -1;  // EOF
    }
    return awcBuffer[iCur++];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\filtstat\filtstat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       TxtSinkDump.cxx
//
//  Contents:   Contains an implementation of ICiCTextSink interface.
//
//  History:    Jan-13-97   KLam   Created
//
//----------------------------------------------------------------------------

#define WIN32_LEAN_AND_MEAN

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <cierror.h>
#include <query.h>

#include <cidebnot.h>
#include <ciexcpt.hxx>
#include <tgrow.hxx>
#include <regacc.hxx>
#include <ciregkey.hxx>
#include <filtreg.hxx>      // registration functions
#include "FiltStat.hxx"

static long glcInstances = 0;
static WCHAR gwszModule[MAX_PATH];
static WCHAR gwszFilterStatusDumpCLSID[] = L"{3ce7c910-8d72-11d1-8f76-00a0c91917f5}";
static GUID CLSID_CFilterStatusDump = { 0x3ce7c910, 0x8d72, 0x11d1,
                                        { 0x8f, 0x76, 0x00, 0xa0, 0xc9, 0x19, 0x17, 0xf5 } };
static const WCHAR gwszDescription [] = L"Filtering Status Dumper";

//
// CFilterStatusDump Methods
//

CFilterStatusDump::CFilterStatusDump ()
        : _pfOutput(0),
          _fSuccessReport( FALSE ),
          _cRefs ( 1 )
{
    InterlockedIncrement ( &glcInstances );
}

CFilterStatusDump::~CFilterStatusDump ()
{
    if ( 0 != _pfOutput )
        fclose( _pfOutput );

    InterlockedDecrement( &glcInstances );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusDump::QueryInterface
//
//  Synopsis:   Returns interfaces to IID_IUknown, IID_ICiCTextSink
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CFilterStatusDump::QueryInterface ( REFIID riid,
                                             void ** ppvObject )
{
    //Win4Assert ( 0 != ppvObject );

    if ( IID_IUnknown == riid )
    {
        AddRef ();
        *ppvObject = (void *)(IUnknown *) this;
        return S_OK;
    }
    else if ( IID_IFilterStatus == riid )
    {
        AddRef ();
        *ppvObject = (void *)(IFilterStatus *) this;
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusDump::AddRef
//
//  Synopsis:   Increments the reference count on the object
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CFilterStatusDump::AddRef ()
{
    return InterlockedIncrement ( (long *)&_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusDump::Release
//
//  Synopsis:   Decrements the reference count on the object.
//              If the reference count reaches 0, the object is deleted.
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CFilterStatusDump::Release ()
{
    ULONG cTemp = InterlockedDecrement ( (long *)&_cRefs );

    if ( 0 == cTemp )
        delete this;

    return cTemp;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusDump::Initialize
//
//  Synopsis:   Creates or opens the text sink dump file.  If the file already
//              exists, it sets the file pointer to the end of the file.
//
//  Arguments:  [pwszSessionId]     --  String identifying current session
//              [pwszSessionPath]   --  Path containing current session catalog
//              [pIndexClientInfo]  --  Pointer to Client Info context
//              [fQuery]            --  Boolean indicating whether the incoming
//                                      text is a query
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CFilterStatusDump::Initialize ( WCHAR const * pwszCatalog,
                                             WCHAR const * pwszCatalogPath )
{
    CLock lock( _mutex );

    SCODE sc = E_FAIL;

    //
    // Clean up from previous state, if any.
    //

    if ( 0 != _pfOutput )
    {
        fclose( _pfOutput );
        _pfOutput = 0;
    }

    CTranslateSystemExceptions translate;
    TRY
    {
        //
        // Locate path of dump file in registry.
        //

        unsigned ccCat = wcslen( pwszCatalog );
        unsigned const ccBase = sizeof(wcsRegJustCatalogsSubKey)/sizeof(WCHAR) - 1;

        XGrowable<WCHAR> xTemp;

        xTemp.SetSize( ccBase + ccCat + 2 );

        RtlCopyMemory( xTemp.Get(), wcsRegJustCatalogsSubKey, ccBase * sizeof(WCHAR) );
        xTemp[ccBase] = L'\\';
        RtlCopyMemory( xTemp.Get() + ccBase + 1, pwszCatalog, (ccCat + 1) * sizeof(WCHAR) );  // 1 for null

        CRegAccess reg( RTL_REGISTRY_CONTROL, xTemp.Get() );

        XGrowable<WCHAR> xFile;
        reg.Get( L"FilterStatusLog", xFile.Get(), xFile.Count() );

        _fSuccessReport = (reg.Read( L"FilterStatusReportSuccess", 0, 0, 1 ) != 0);

        //
        // Open file
        //

        _pfOutput = _wfopen( xFile.Get(), L"a+" );

        if ( 0 == _pfOutput )
        {
            THROW( CException( ERROR_FILE_NOT_FOUND ) );
        }

        sc = S_OK;
    }
    CATCH( CException, e )
    {
        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
}

STDMETHODIMP CFilterStatusDump::PreFilter( WCHAR const * pwszPath )
{
    return S_OK;
}

STDMETHODIMP CFilterStatusDump::FilterLoad( WCHAR const * pwszPath, SCODE scFilterStatus )
{
    if ( FAILED(scFilterStatus) && 0 != _pfOutput )
    {
        //
        // Convert to narrow string.
        //

        XGrowable<char, MAX_PATH*2> xTemp;

        DWORD cbConvert = WideCharToMultiByte( CP_ACP,
                                               WC_COMPOSITECHECK,
                                               pwszPath,
                                               wcslen( pwszPath ) + 1,
                                               xTemp.Get(),
                                               xTemp.Count(),
                                               0,
                                               0 );

        CLock lock( _mutex );

        if ( 0 == cbConvert )
        {
            xTemp[cbConvert] = 0;
            fprintf( _pfOutput, "Error %#x loading filter for \"%ws\"\n", scFilterStatus, pwszPath );
        }
        else
        {
            xTemp[cbConvert] = 0;
            fprintf( _pfOutput, "Error %#x loading filter for \"%s\"\n", scFilterStatus, xTemp.Get() );
        }

        fflush( _pfOutput );
    }

    return S_OK;
}

STDMETHODIMP CFilterStatusDump::PostFilter( WCHAR const * pwszPath, SCODE scFilterStatus )
{
    if ( (_fSuccessReport || FAILED(scFilterStatus)) && 0 != _pfOutput )
    {
        //
        // Convert to narrow string.
        //

        XGrowable<char, MAX_PATH*2> xTemp;

        DWORD cbConvert = WideCharToMultiByte( CP_ACP,
                                               WC_COMPOSITECHECK,
                                               pwszPath,
                                               wcslen( pwszPath ) + 1,
                                               xTemp.Get(),
                                               xTemp.Count(),
                                               0,
                                               0 );

        CLock lock( _mutex );

        if ( 0 == cbConvert )
        {
            xTemp[cbConvert] = 0;

            if ( SUCCEEDED(scFilterStatus) )
                fprintf( _pfOutput, "ok: \"%ws\"\n", pwszPath );
            else
                fprintf( _pfOutput, "Error %#x indexing \"%ws\"\n", scFilterStatus, pwszPath );
        }
        else
        {
            xTemp[cbConvert] = 0;

            if ( SUCCEEDED(scFilterStatus) )
                fprintf( _pfOutput, "ok \"%s\"\n", xTemp.Get() );
            else
                fprintf( _pfOutput, "Error %#x indexing \"%s\"\n", scFilterStatus, xTemp.Get() );
        }

        fflush( _pfOutput );
    }

    return S_OK;
}

//
// CFilterStatusCF Methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusCF::CFilterStatusCF
//
//  Synopsis:   Constructor
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

CFilterStatusCF::CFilterStatusCF () : _cRefs (1)
{
    InterlockedIncrement ( &glcInstances );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusCF::~CFilterStatusCF
//
//  Synopsis:   Destructor
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

CFilterStatusCF::~CFilterStatusCF ()
{
    //Win4Assert( _cRefs == 0);
    //Win4Assert( glcInstances != 0 );

    InterlockedDecrement( &glcInstances );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CFilterStatusCF::QueryInterface ( REFIID riid,
                                               void ** ppvObject )
{
    //Win4Assert ( NULL != ppvObject );

    if ( IID_IUnknown == riid )
    {
        AddRef ();
        *ppvObject = (void *) ((IUnknown *) this);
        return S_OK;
    }
    else if ( IID_IClassFactory == riid )
    {
        AddRef ();
        *ppvObject = (void *) ((IClassFactory *) this);
        return S_OK;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusCF::AddRef
//
//  Synopsis:   Increments the reference count on the object
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CFilterStatusCF::AddRef ()
{
    return InterlockedIncrement ( (long *)&_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusCF::Release
//
//  Synopsis:   Decrements the reference count on the object.
//              If the reference count reaches 0, the object is deleted.
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CFilterStatusCF::Release ()
{
    //Win4Assert ( 0 < _cRefs );
    unsigned long cTemp = InterlockedDecrement ( (long *)&_cRefs );

    if ( 0 == cTemp )
        delete this;

    return cTemp;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFilterStatusCF::CreateInstance
//
//  Synopsis:   Create new CFilterStatus instance
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown; IGNORED
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    Jan-13-1998  KLam   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CFilterStatusCF::CreateInstance ( IUnknown * pUnkOuter,
                                               REFIID riid,
                                               void ** ppvObject )
{
    if ( 0 != pUnkOuter )
        return ResultFromScode ( CLASS_E_NOAGGREGATION );

    CFilterStatusDump *pSink = NULL;
    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        // Create a new CFilterStatus
        pSink = new CFilterStatusDump;

        // Query the object to see if it supports the desired interface
        sc = pSink->QueryInterface ( riid, ppvObject );

        // Release the class factory's instance of the object
        pSink->Release ();
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pSink );

        sc = GetOleError( e );
    }
    END_CATCH;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFilterStatusCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE to lock ther server. FALSE to unlock the server
//
//  History:    Jan-13-1998  KLam   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CFilterStatusCF::LockServer ( BOOL fLock )
{
    if ( fLock )
        InterlockedIncrement ( &glcInstances );
    else
        InterlockedDecrement ( &glcInstances );

    return S_OK;
}

//
// Exported Routines
//

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]       -- Class to load
//              [iid]       -- Interface to bind to on class object
//              [ppvObject] -- Interface pointer returned here
//
//  Returns:    Text sink dump object
//
//  History:    13-Jan-1998     KLam    Created
//
//--------------------------------------------------------------------------

STDAPI DllGetClassObject( REFCLSID cid,
                          REFIID iid,
                          void ** ppvObject )
{
    CFilterStatusCF * pFactory = NULL;
    SCODE sResult = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        if ( CLSID_CFilterStatusDump == cid )
        {
            pFactory = new CFilterStatusCF;
            if ( NULL != pFactory )
            {
                sResult = pFactory->QueryInterface( iid, ppvObject );
                pFactory->Release ( );
            }
            else
                sResult = E_OUTOFMEMORY;
        }
        else
            sResult = E_NOINTERFACE;
    }
    CATCH(CException, e)
    {
        sResult = GetOleError(e);
    }
    END_CATCH;

    return sResult;
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Queries DLL to see if it can be unloaded
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    13-Jan-1998     KLam    Created
//
//--------------------------------------------------------------------------

STDAPI DllCanUnloadNow ( )
{
    return ( glcInstances <= 0 ) ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     DllRegisterServer
//
//  Synopsis:   Registers this server with the registry
//
//  Returns:    S_OK if registration succeeded, otherwise SELFREG_E_CLASS
//
//  History:    13-Jan-1998     KLam    Created
//
//--------------------------------------------------------------------------

STDAPI DllRegisterServer ()
{
    WCHAR const * aKeyValues[4] = { gwszFilterStatusDumpCLSID,
                                    gwszDescription,
                                    L"InprocServer32",
                                    gwszModule };

    long retVal = BuildKeyValues( aKeyValues, sizeof(aKeyValues)/sizeof(aKeyValues[0]) );

    if ( ERROR_SUCCESS == retVal )
        retVal = AddThreadingModel( L"{3ce7c910-8d72-11d1-8f76-00a0c91917f5}",
                                    L"Both" );

    if ( ERROR_SUCCESS == retVal )
        return S_OK;
    else
        return SELFREG_E_CLASS;
}

//+-------------------------------------------------------------------------
//
//  Method:     DllUnregisterServer
//
//  Synopsis:   Unregisters this server
//
//  Returns:    S_OK if unregistration succeeded, otherwise SELFREG_E_CLASS
//
//  History:    13-Jan-1998     KLam    Created
//
//--------------------------------------------------------------------------

STDAPI DllUnregisterServer ()
{
    WCHAR const * aKeyValues[4] = { gwszFilterStatusDumpCLSID,
                                    gwszDescription,
                                    L"InprocServer32",
                                    gwszModule };

    long retval = DestroyKeyValues( aKeyValues,
                                    sizeof(aKeyValues)/sizeof(aKeyValues[0]) );

    if ( ERROR_SUCCESS == retval )
        return S_OK;
    else
        return SELFREG_E_CLASS;
}

//+-------------------------------------------------------------------------
//
//  Method:     DllMain
//
//  Synopsis:   Main routine for DLL.  Saves the module name for this dll.
//
//  Returns:    TRUE
//
//  History:    13-Jan-1998     KLam    Created
//
//--------------------------------------------------------------------------

BOOL APIENTRY DllMain ( HANDLE hModule,
                        DWORD dwReason,
                        void * pReserved )
{
    if ( DLL_PROCESS_ATTACH == dwReason )
    {
        DisableThreadLibraryCalls( (HINSTANCE)hModule );

        //
        // Get the name of the module
        //
        DWORD dwResult = GetModuleFileName ( (HMODULE)hModule,
                                             gwszModule,
                                             sizeof(gwszModule)/sizeof(WCHAR) );
        //Win4Assert( 0 != dwResult );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\genflt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       GENFLT.CXX
//
//  Contents:   C and Cxx Filter
//
//  History:    07-Oct-93   AmyA        Created
//
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop

#include <queryexp.hxx>
#include "gen.hxx"
#include "genifilt.hxx"
#include "genflt.hxx"

extern "C" GUID CLSID_GenIFilter;

GUID guidCPlusPlus = { 0x8DEE0300, \
                       0x16C2, 0x101B, \
                       0xB1, 0x21, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9 };

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::GenIFilter, public
//
//  Synopsis:   Constructor
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

GenIFilter::GenIFilter()
        : _state(FilterDone),
          _ulLastTextChunkID(0),
          _ulChunkID(0),
          _pTextFilt(0),
          _pPersFile(0),
          _cAttrib(0),
          _pAttrib(0),
          _pTextStream(0),
          _locale(0)         // the default locale
{
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::~GenIFilter, public
//
//  Synopsis:   Destructor
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

GenIFilter::~GenIFilter()
{
    delete [] _pAttrib;

    if ( _pTextFilt )
        _pTextFilt->Release();

    if ( _pPersFile )
        _pPersFile->Release();

    delete _pTextStream;
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::Init, public
//
//  Synopsis:   Initializes instance of text filter
//
//  Arguments:  [grfFlags] -- flags for filter behavior
//              [cAttributes] -- number of attributes in array aAttributes
//              [aAttributes] -- array of attributes
//              [pfBulkyObject] -- indicates whether this object is a
//                                 bulky object
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilter::Init( ULONG grfFlags,
                                          ULONG cAttributes,
                                          FULLPROPSPEC const * aAttributes,
                                          ULONG * pFlags )
{
    CTranslateSystemExceptions translate;

    SCODE sc = S_OK;

    TRY
    {
        _ulLastTextChunkID = 0;
        _ulChunkID = 0;

        if( cAttributes > 0 )
        {
            _state = FilterProp;

            _cAttrib = cAttributes;
            _pAttrib = new CFullPropSpec [_cAttrib];

            //
            // Known, safe cast
            //

            CCiPropSpec const * pAttrib = (CCiPropSpec const *)aAttributes;


            for ( ULONG i = 0; i < cAttributes; i++ )
            {
                if ( _state != FilterContents && pAttrib[i].IsContents() )
                    _state = FilterContents;

                _pAttrib[i] = pAttrib[i];
            }
        }
        else if ( 0 == grfFlags || (grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES) )
        {
            _state = FilterContents;
        }
        else
        {
            _state = FilterDone;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    if ( FAILED( sc ) )
        return sc;

    CFullPropSpec ps( guidStorage, PID_STG_CONTENTS );
    return _pTextFilt->Init( 0,
                             1,
                             (FULLPROPSPEC const *)&ps,
                             pFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::GetChunk, public
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- for chunk information
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilter::GetChunk( STAT_CHUNK * pStat )
{
    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        if (_state == FilterNextProp)
        {
            _state = FilterProp;
        }
        //
        // All chunks of plain text come first.
        //

        if ( _state == FilterContents )
        {
            sc = _pTextFilt->GetChunk( pStat );

            if ( SUCCEEDED(sc) )
            {
                pStat->locale = 0;  // use the default word breaker
                _locale = 0;
                _ulLastTextChunkID = pStat->idChunk;
            }
            else if ( sc == FILTER_E_END_OF_CHUNKS )
            {
                _ulChunkID = _ulLastTextChunkID;

                ULONG Flags;
                CFullPropSpec ps( guidStorage, PID_STG_CONTENTS );

                sc = _pTextFilt->Init( 0,
                                       1,
                                       (FULLPROPSPEC const *)&ps,
                                       &Flags );

                if ( SUCCEEDED(sc) )
                {
                    delete _pTextStream;
                    _pTextStream = new CFilterTextStream (_pTextFilt);
                    if (SUCCEEDED (_pTextStream->GetStatus()))
                    {
                        _genParse.Init( _pTextStream );
                        _state = FilterProp;
                    }
                    else
                        _state = FilterDone;
                }
                else
                    _state = FilterDone;
            }
        }

        if ( _state == FilterProp && SUCCEEDED(sc) )
        {
            while ( TRUE )
            {
                if (_genParse.Parse())
                {
                    pStat->attribute.guidPropSet = guidCPlusPlus;
                    pStat->attribute.psProperty = _genParse.GetAttribute();

                    for ( unsigned i = 0; i < _cAttrib; i++ )
                        if ( *(CFullPropSpec *)(&pStat->attribute) == _pAttrib[i] )
                            break;

                    if ( _cAttrib == 0 || i < _cAttrib )     // Property should be returned
                    {
                        pStat->idChunk = ++_ulChunkID;
                        pStat->breakType = CHUNK_EOS;
                        pStat->flags = CHUNK_TEXT;
                        pStat->locale = _locale;

                        FILTERREGION regionSource;
                        // what's the source of this derived property?
                        _genParse.GetRegion ( regionSource );
                        pStat->idChunkSource = regionSource.idChunk;
                        pStat->cwcStartSource = regionSource.cwcStart;
                        pStat->cwcLenSource = regionSource.cwcExtent;

                        sc = S_OK;
                        break;
                    }
                }
                else
                {
                    _state = FilterValue;
                    break;
                }
            }
        }

        if ( _state == FilterNextValue )
        {
            _genParse.SkipValue();
            _state = FilterValue;
        }

        if ( _state == FilterValue )
        {
            while ( TRUE )
            {
                if ( _genParse.GetValueAttribute( pStat->attribute.psProperty ) )
                {
                    pStat->attribute.guidPropSet = guidCPlusPlus;

                    for ( unsigned i = 0; i < _cAttrib; i++ )
                        if ( *(CFullPropSpec *)(&pStat->attribute) == _pAttrib[i] )
                            break;

                    if ( _cAttrib == 0 || i < _cAttrib )     // Property should be returned
                    {
                        pStat->flags = CHUNK_VALUE;
                        pStat->locale = _locale;

                        _state = FilterNextValue;
                        sc = S_OK;
                        break;
                    }
                    else
                        _genParse.SkipValue();
                }
                else
                {
                    _state = FilterDone;
                    break;
                }
            }
        }

        if (_state == FilterDone || !SUCCEEDED(sc))
        {
            sc = FILTER_E_END_OF_CHUNKS;
            _state = FilterDone;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::GetText, public
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcBuffer] -- count of characters in buffer
//              [awcBuffer] -- buffer for text
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilter::GetText( ULONG * pcwcBuffer,
                                             WCHAR * awcBuffer )
{
    if ( _state == FilterValue || _state == FilterNextValue )
        return FILTER_E_NO_TEXT;

    if ( _state == FilterContents )
    {
        return _pTextFilt->GetText( pcwcBuffer, awcBuffer );
    }
    else if ( _state == FilterProp )
    {

        if ( _genParse.GetTokens( pcwcBuffer, awcBuffer ))
        {
            _state = FilterNextProp;
            return FILTER_S_LAST_TEXT;
        }
        else
            return S_OK;
    }
    else if ( _state == FilterNextProp )
    {
        return FILTER_E_NO_MORE_TEXT;
    }
    else
    {
        Win4Assert ( _state == FilterDone );
        return FILTER_E_NO_MORE_TEXT;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::GetValue, public
//
//  Synopsis:   Not implemented for the text filter
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilter::GetValue( VARIANT ** ppPropValue )
{
    if ( _state == FilterContents )
        return _pTextFilt->GetValue( ppPropValue );

    if ( _state == FilterDone )
        return FILTER_E_NO_MORE_VALUES;

    if ( _state != FilterNextValue )
        return FILTER_E_NO_VALUES;

    *ppPropValue = _genParse.GetValue();
    _state = FilterValue;

    if ( 0 == *ppPropValue )
        return FILTER_E_NO_MORE_VALUES;
    else
        return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::BindRegion, public
//
//  Synopsis:   Creates moniker or other interface for text indicated
//
//  Arguments:  [origPos] -- location of text
//              [riid]    -- Interface Id
//              [ppunk]   -- returned interface
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilter::BindRegion( FILTERREGION origPos,
                                                REFIID riid,
                                                void ** ppunk )
{
    return _pTextFilt->BindRegion( origPos, riid, ppunk );
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilter::GetClassID( CLSID * pClassID )
{
    *pClassID = CLSID_GenIFilter;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since this class is read-only.
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilter::IsDirty()
{
    return S_FALSE; // Since the filter is read-only, there will never be
                    // changes to the file.
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::Load, public
//
//  Synopsis:   Loads the indicated file
//
//  Arguments:  [pszFileName] -- the file name
//              [dwMode]      -- the mode to load the file in
//
//  History:    07-Oct-93   AmyA           Created.
//
//  Notes:      dwMode must be either 0 or STGM_READ.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilter::Load(LPCWSTR pszFileName, DWORD dwMode)
{
    SCODE sc = LoadTextFilter( pszFileName, &_pTextFilt );

    if ( SUCCEEDED(sc) )
    {
        //
        // Load file
        //

        sc = _pTextFilt->QueryInterface( IID_IPersistFile, (void **) &_pPersFile );

        if ( SUCCEEDED(sc) )
        {
            sc = _pPersFile->Load( pszFileName, dwMode );
        }
        else
        {
            _pTextFilt->Release();
            _pTextFilt = 0;
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilter::Save(LPCWSTR pszFileName, BOOL fRemember)
{
    return E_FAIL;  // cannot be saved since it is read-only
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::SaveCompleted, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilter::SaveCompleted(LPCWSTR pszFileName)
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     GenIFilter::GetCurFile, public
//
//  Synopsis:   Returns a copy of the current file name
//
//  Arguments:  [ppszFileName] -- where the copied string is returned.
//
//  History:    09-Aug-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE GenIFilter::GetCurFile(LPWSTR * ppszFileName)
{
    return _pPersFile->GetCurFile( ppszFileName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\gen.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       gen.cxx
//
//  Contents:   Generic filter code
//
//  History:    1-May-2001   kumarp  created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "gen.hxx"
#include "genifilt.hxx"
#include "genflt.hxx"
#include "rxutil.h"

GenScanner::GenScanner ()
        : _pStream(0),
          _cLines( 0 )
{
}

void GenScanner::Init ( CFilterTextStream * pStream )
{
    _pStream = pStream;
    _cLines = 0;
}

int GenScanner::GetLine( PWSTR pszBuf, UINT BufSize, FILTERREGION* pRegion )
{
    int c, i=0;

   _pStream->GetRegion ( *pRegion, -1, 0 );

    while (((c = _pStream->GetChar()) != -1) &&
           ( c != L'\n' ) &&
           ( i < (int) BufSize ))
    {
        pszBuf[i++] = (WCHAR) c;
    }

    pszBuf[i] = 0;

    if ( c == -1 )
    {
        return 0;
    }
    else if ( ( c == L'\n' ) || ( i > 0 ) )
    {
        _cLines++;
    }
    
    return 1;
}


GenParser::GenParser ()
    : _iVal(0)
{
    _strName[0]  = L'\0';

    _attribute.ulKind = PRSPEC_LPWSTR;
    _attribute.lpwstr = PROP_FUNC; 

    _psVal[Function].ulKind = PRSPEC_LPWSTR;
    _psVal[Function].lpwstr = PROP_FUNC;

    _psVal[Lines].ulKind = PRSPEC_LPWSTR;
    _psVal[Lines].lpwstr = PROP_LINES;

    _aVal[Function] = 0;
    _aVal[Lines]    = 0;
}

GenParser::~GenParser()
{
    delete _aVal[Function];
    delete _aVal[Lines];
}

void GenParser::Init ( CFilterTextStream * pStream )
{
    DWORD dwError = NO_ERROR;

    _scanner.Init(pStream);

    dwError = RxInit();

    if ( dwError != NO_ERROR )
    {
        DbgPrint( "RxInit failed: %x\n", dwError );
        THROW( CException( dwError ) );
    }
}

void ConvertSpecialCharsToUnderscore( IN PWSTR pszName )
{
    WCHAR ch;
    static PCWSTR c_szSpecialChars = L"-+*/:,<>|";
    
    while ( ch = *pszName )
    {
        if ( wcschr( c_szSpecialChars, ch ) )
        {
            *pszName = L'_';
        }
        pszName++;
    }
}

BOOL GenParser::Parse()
{
    _cwcCopiedName = 0;
    WCHAR idbuf[MAX_LINE_SIZE];
    UINT MatchStart, MatchLength;

#if DBG
    //    DbgPrint("GenParser::Parse\n");
#endif
    
    while ( _scanner.GetLine( _buf, MAX_LINE_SIZE, &_regionName ) > 0 )
    {
        if ( ParseLine( _buf, &MatchStart, &MatchLength ))
        {
            ASSERT( MatchLength < MAXIDENTIFIER );
            wcsncpy ( _strName, _buf + MatchStart, MatchLength );
            _strName[MatchLength] = 0;
            _regionName.cwcStart  += MatchStart + 1;
            _regionName.cwcExtent  = MatchLength;
            ConvertSpecialCharsToUnderscore( _strName );
#if DBG
            DbgPrint("GenParser::Parse: tag: %ws @ %d, [%d,%d,%d]\n", _strName, _scanner.Lines(), _regionName.idChunk, _regionName.cwcStart, _regionName.cwcExtent );
#endif

            DefineTag();
            
            return TRUE;
        }
    }

    if ( _aVal[Lines] == 0 )
    {
        _aVal[Lines] = new CStorageVariant;
        if ( 0 == _aVal[Lines] )
            THROW( CException( E_OUTOFMEMORY ) );
    }
    
    _aVal[Lines]->SetUI4( _scanner.Lines() );

    return FALSE;   // we only end up here on EOF
}


void GenParser::DefineTag()
{
    _tokenType = ttFunction;
    _attribute.lpwstr = PROP_FUNC;

    if ( _aVal[Function] == 0 )
    {
        _aVal[Function] = new CStorageVariant;
        if ( 0 == _aVal[Function] )
            THROW( CException( E_OUTOFMEMORY ) );
    }

    _aVal[Function]->SetLPWSTR( _strName, _aVal[Function]->Count() );

#if DBG
    //    DbgPrint("DefineTag: %ws @ %d\n", _strName, _scanner.Lines());
#endif
}

void GenParser::GetRegion ( FILTERREGION& region )
{
    switch (_tokenType)
    {
    case ttFunction:
        region = _regionName;
        break;
    }
}

BOOL GenParser::GetTokens ( ULONG * pcwcBuffer, WCHAR * awcBuffer )
{
    ULONG cwc = *pcwcBuffer;
    *pcwcBuffer = 0;

    if (_strName[0] == L'\0')
    {
        awcBuffer[*pcwcBuffer] = L'\0';
        return TRUE;
    }

    cwc -= *pcwcBuffer;
    WCHAR * awc = awcBuffer + *pcwcBuffer;
    WCHAR * strName = _strName + _cwcCopiedName;
    ULONG cwcName = wcslen( strName );

    if ( cwcName > cwc )
    {
        wcsncpy( awc, strName, cwc );
        _cwcCopiedName += cwc;
        return FALSE;
    }
    wcscpy( awc, strName );
    *pcwcBuffer += cwcName;
    _cwcCopiedName += cwcName;
    return TRUE;
}

BOOL GenParser::GetValueAttribute( PROPSPEC & ps )
{
    for ( ; _iVal <= Lines && 0 == _aVal[_iVal];  _iVal++ )
        continue;

    if ( _iVal > Lines )
        return FALSE;
    else
    {
        ps = _psVal[_iVal];

        return TRUE;
    }
}

PROPVARIANT * GenParser::GetValue()
{
    if ( _iVal > Lines )
        return 0;

    CStorageVariant * pTemp = _aVal[_iVal];
    _aVal[_iVal] = 0;
    _iVal++;

    return (PROPVARIANT *)(void *)pTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\regexpr.h ===
//+---------------------------------------------------------------------------
//
//  File:       basic_regexpr.hxx
//
//  Contents:   classes for regular expression pattern matching a-la perl
//
//  Classes:    basic_rpattern, basic_regexpr
//
//  Functions:  basic_regexpr::match
//              basic_regexpr::substitute
//              basic_regexpr::cbackrefs
//              basic_regexpr::backref
//              basic_regexpr::all_backrefs
//              basic_regexpr::backref_str
//
//  Coupling:   
//
//  History:    12-11-1998   ericne   Created
//              01-05-2001   ericne   Removed dependency on VC's choice
//                                    of STL iterator types.
//
//----------------------------------------------------------------------------

#pragma once
// warning C4290: C++ Exception Specification ignored
// warning C4786: identifier was truncated to '255' characters in the debug information
#pragma warning( disable : 4290 4786 )
#pragma warning( push )
// warning C4511: copy constructor could not be generated
// warning C4512: assignment operator could not be generated
#pragma warning( disable : 4511 4512 )

#ifdef _MT
#include <windows.h> // for CRITICAL_SECTION
#endif

#include <string>
#include <stdexcept>
#include <vector>
#include <list>
#include <map>
#include <iosfwd>
#include <tchar.h>
#include <new.h> // for _set_new_handler
#include <crtdbg.h>
#include "syntax.h"

namespace regex
{

// Called when an allocation fails
inline int __cdecl my_new_handler( size_t )
{
    throw std::bad_alloc();
}

// For pushing and popping the new handler
class push_new_handler
{
   _PNH m_pnh;
public:
   push_new_handler( _PNH pnh )
   {
      m_pnh = _set_new_handler( pnh );
   }
   ~push_new_handler()
   {
      (void)_set_new_handler( m_pnh );
   }
};

class bad_regexpr : public std::runtime_error
{
public:
    explicit bad_regexpr(const std::string& _S)
        : std::runtime_error(_S) {}
    virtual ~bad_regexpr() {}
};

//
// Flags to control how matching occurs
//
enum REGEX_FLAGS
{      
    NOCASE        = 0x0001, // ignore case
    GLOBAL        = 0x0002, // match everywhere in the string
    MULTILINE     = 0x0004, // ^ and $ can match internal line breaks
    SINGLELINE    = 0x0008, // . can match newline character
    RIGHTMOST     = 0x0010, // start matching at the right of the string
    NOBACKREFS    = 0x0020, // only meaningful when used with GLOBAL and substitute
    FIRSTBACKREFS = 0x0040, // only meaningful when used with GLOBAL
    ALLBACKREFS   = 0x0080, // only meaningful when used with GLOBAL
    CSTRINGS      = 0x0100, // optimize pattern for use with null-terminated strings
    NORMALIZE     = 0x0200  // Preprocess patterns: "\\n" => "\n", etc.
};

// Forward declarations
template< typename CI > struct match_param;
template< typename CI > class  match_group;
template< typename CI > class  match_wrapper;
template< typename CI > class  match_charset;
template< typename CI > class  basic_rpattern_base;

// --------------------------------------------------------------------------
// 
// Class:       width_type
// 
// Description: represents the width of a sub-expression
// 
// Methods:     width_add  - add two widths
//              width_mult - multiply two widths
//              width_type - ctor
//              width_type - ctor
//              operator=  - assign a width
//              operator== - are widths equal
//              operator!= - are widths now equal
//              operator+  - add two widths
//              operator*  - multiply two widths
// 
// Members:     m_min      - smallest number of characters a sub-expr can span
//              m_max      - largest number of characters a sub-expr can span
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
struct width_type
{
    size_t m_min;
    size_t m_max;

    static size_t width_add( size_t a, size_t b )
    {
        return ( size_t(-1) == a || size_t(-1) == b ? size_t(-1) : a + b );
    }

    static size_t width_mult( size_t a, size_t b )
    {
        return ( size_t(-1) == a || size_t(-1) == b ? size_t(-1) : a * b );
    }

    width_type( size_t _min = 0, size_t _max = size_t(-1) ) 
        : m_min(_min), m_max(_max) 
    {
    }
    
    width_type( const width_type & that ) 
        : m_min(that.m_min), m_max(that.m_max) 
    {
    }
    
    width_type & operator=( const width_type & that )
    {
        m_min = that.m_min;
        m_max = that.m_max;
        return *this;
    }

    bool operator==( const width_type & that ) const
    {
        return ( m_min == that.m_min && m_max == that.m_max );
    }

    bool operator!=( const width_type & that ) const
    {
        return ( m_min != that.m_min || m_max != that.m_max );
    }

    width_type operator+( const width_type & that ) const
    {
        return width_type( width_add( m_min, that.m_min ), width_add( m_max, that.m_max ) );
    }

    width_type operator*( const width_type & that ) const
    {
        return width_type( width_mult( m_min, that.m_min ), width_mult( m_max, that.m_max ) );
    }
};

const width_type worst_width(0,size_t(-1));
const width_type uninit_width(size_t(-1),size_t(-1));

// --------------------------------------------------------------------------
// 
// Class:       sub_expr
// 
// Description: patterns are "compiled" into a directed graph of sub_expr
//              structs.  Matching is accomplished by traversing this graph.
// 
// Methods:     sub_expr     - construct a sub_expr
//              _match_this  - does this sub_expr match at the given location
//              _width_this  - what is the width of this sub_expr
//              ~sub_expr    - virt dtor so cleanup happens correctly
//              _delete      - delete this node in the graph and all nodes linked
//              next         - pointer to the next node in the graph
//              next         - pointer to the next node in the graph
//              match_next   - match the rest of the graph
//              domatch      - match_this and match_next
//              is_assertion - true if this sub_expr is a zero-width assertion
//              get_width    - find the width of the graph at this sub_expr
// 
// Members:     m_pnext      - pointer to the next node in the graph
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI > 
class sub_expr
{
    sub_expr * m_pnext;

protected:
    
    // Only derived classes and basic_rpattern can instantiate sub_expr's
    sub_expr( ) 
        : m_pnext(NULL) 
    {
    }
    
    // match this object only
    virtual bool _match_this( match_param<CI> &, CI & ) const throw()
    { 
        return true; 
    }

    virtual width_type _width_this() throw() = 0;

public:

    typedef typename std::iterator_traits<CI>::value_type char_type;

    friend class match_wrapper<CI>;  // wrappers can access _match_this method

    virtual ~sub_expr() {}
    
    virtual void _delete() 
    { 
        if( m_pnext )
            m_pnext->_delete();
        delete this;
    }

    inline const sub_expr *const   next() const { return m_pnext; }
    inline       sub_expr *      & next()       { return m_pnext; }

    // Match all subsequent objects
    inline bool match_next( match_param<CI> & param, CI icur ) const throw()
    {
        return NULL == m_pnext || m_pnext->domatch( param, icur );
    }

    // Match this object and all subsequent objects
    // If domatch returns false, it must not change any internal state
    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        return ( _match_this(param,icur) && match_next(param,icur) );
    }

    virtual bool is_assertion() const throw() 
    { 
        return false; 
    }

    width_type get_width() throw()
    {
        width_type this_width = _width_this();
        
        if( NULL == m_pnext )
            return this_width;
        
        width_type that_width = m_pnext->get_width();

        return ( this_width + that_width );
    }
};

template< typename CI >
void delete_sub_expr( sub_expr<CI> * psub )
{
    if( psub )
        psub->_delete();
}

template< typename CI, typename SY = perl_syntax<std::iterator_traits<CI>::value_type> >
class create_charset_helper
{
public:
    typedef std::iterator_traits<CI>::value_type char_type;

    static sub_expr<CI> * create_charset_aux(
        std::basic_string<char_type> & str,
        std::basic_string<char_type>::iterator & icur,
        unsigned flags );
};


// --------------------------------------------------------------------------
// 
// Class:       auto_sub_ptr
// 
// Description: Class for automatically cleaning up the structure associated
//              with a parsed pattern
// 
// Methods:     auto_sub_ptr  - private copy ctor - not used
//              operator=     - private assign operator - not used
//              operator T*   - private implicit cast operator - not used
//              auto_sub_ptr  - ctor
//              ~auto_sub_ptr - dtor, frees ptr
//              free_ptr      - explicitly free pointer
//              release       - relinquish ownership of ptr
//              operator=     - take ownership of ptr
//              get           - return ptr
//              get           - return ptr
//              operator->    - method call through ptr
//              operator->    - method call through ptr
// 
// Members:     m_psub        - sub_expr pointer
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename T >
class auto_sub_ptr
{
    T * m_psub;

    // hide these methods
    auto_sub_ptr( const auto_sub_ptr<T> & ) {}
    auto_sub_ptr & operator=( const auto_sub_ptr<T> & ) { return *this; }
    operator T*() const { return m_psub; }

public:
    auto_sub_ptr( T * psub = NULL ) : m_psub( psub ) {}
    
    ~auto_sub_ptr() 
    { 
        free_ptr();
    }

    void free_ptr() // deallocate
    {
        delete_sub_expr( m_psub );
        m_psub = NULL;
    }

    T * release() // relinquish ownership, but don't deallocate
    { 
        T * psub = m_psub; 
        m_psub = NULL; 
        return psub; 
    }

    auto_sub_ptr<T> & operator=( T * psub ) 
    { 
        delete_sub_expr( m_psub );
        m_psub = psub;
        return *this;
    }

    inline const T*const   get()        const { return m_psub; }
    inline       T*      & get()              { return m_psub; }
    inline const T*const   operator->() const { return m_psub; }
    inline       T*        operator->()       { return m_psub; }
};

template< typename CI >
struct backref_tag : public std::pair<CI,CI>
{
    backref_tag( CI i1 = CI(0), CI i2 = CI(0) )
        : std::pair<CI,CI>(i1,i2), reserved(0) {}
    operator bool() const throw() { return first != CI(0) && second != CI(0); }
    bool operator!() const throw() { return ! operator bool(); }
    size_t reserved; // used for internal book-keeping
};

template< typename CH >
backref_tag< const CH * > _static_match_helper(
    const CH * szstr,
    const basic_rpattern_base< const CH * > & pat,
    std::vector< backref_tag< const CH * > > * prgbackrefs ) throw();

template< typename CH >
size_t _static_count_helper( 
    const CH * szstr,
    const basic_rpattern_base< const CH * > & pat ) throw();

// --------------------------------------------------------------------------
// 
// Class:       basic_regexpr
// 
// Description: string class that allows regular expression pattern matching
// 
// Methods:     basic_regexpr  - ctor
//              match          - static method for matching C-style strings
//              match          - non-static method for matching C++-style strings
//              count          - static method for couting matches in C-style strings
//              count          - non-static method for counting matches in C++-style strin
//              substitute     - perform substitutions in C++-style strings
//              cbackrefs      - return the count of internally stored back-references
//              rstart         - offset to start of n-th backref
//              rlength        - lenght of n-th backref
//              backref        - return the n-th backref
//              all_backrefs   - return a vector of all saved backrefs
//              backref_str    - return the string to which the backreferences refer
// 
// Members:     m_rgbackrefs   - vector of backrefs
//              m_backref_str  - temp string buffer
//              m_pbackref_str - pointer to the string containing the string to which
//                               the backreferences refer (either *this or m_backref_str)
// 
// Typedefs:    backref_type   - 
//              backref_vector - 
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CH, typename TR = std::char_traits<CH>, typename AL = std::allocator<CH> >
class basic_regexpr : public std::basic_string<CH,TR,AL>
{
public:

    basic_regexpr( const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const CH * p,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( p, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const CH * p, size_type n,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( p, n, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const std::basic_string<CH,TR,AL> & s, size_type pos = 0, size_type n = npos,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( s, pos, n, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( size_type n, CH ch,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( n, ch, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const_iterator begin, const_iterator end,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( begin, end, a ), m_pbackref_str( & m_backref_str ) {}

    // actually stores iterators into *m_pbackref_str:
    typedef backref_tag<const_iterator> backref_type;
    typedef std::vector< backref_type > backref_vector;

    // stores pointers into the null-terminated C-stype string
    typedef backref_tag< const CH * >     backref_type_c;
    typedef std::vector< backref_type_c > backref_vector_c;

    // returns $0, the first backref
    static backref_type_c match( const CH * szstr,
                                 const basic_rpattern_base< const CH * > & pat,
                                 backref_vector_c * prgbackrefs = NULL ) throw()
    {
        return _static_match_helper<CH>( szstr, pat, prgbackrefs );
    }

    // returns $0, the first backref
    backref_type match( const basic_rpattern_base< const_iterator > & pat,
                        size_type pos = 0,
                        size_type len = npos ) const throw();

    static size_t count( const CH * szstr,
                         const basic_rpattern_base< const CH * > & pat ) throw()
    {
        return _static_count_helper<CH>( szstr, pat );
    }

    size_t count( const basic_rpattern_base< const_iterator > & pat,
                  size_type pos = 0,
                  size_type len = npos ) const throw();

    size_t substitute( const basic_rpattern_base< const_iterator > & pat,
                       size_type pos = 0,
                       size_type len = npos ) throw(std::bad_alloc);

    size_t cbackrefs() const throw()
    { 
        return m_rgbackrefs.size(); 
    }

    size_type rstart( size_t cbackref = 0 ) const throw(std::out_of_range)
    {
        return std::distance( m_pbackref_str->begin(), m_rgbackrefs.at( cbackref ).first );
    }

    size_type rlength( size_t cbackref = 0 ) const throw(std::out_of_range)
    {
        return std::distance( m_rgbackrefs.at( cbackref ).first, m_rgbackrefs.at( cbackref ).second );
    }

    backref_type backref( size_t cbackref ) const throw(std::out_of_range)
    {
        return m_rgbackrefs.at( cbackref );
    }

    const backref_vector & all_backrefs() const throw()
    {
        return m_rgbackrefs;
    }

    const std::basic_string<CH,TR,AL> & backref_str() const throw()
    {
        return *m_pbackref_str;
    }

protected:

    // save information about the backrefs
    // mutable because these can change in the "const" match() method.
    mutable backref_vector m_rgbackrefs;
    mutable std::basic_string<CH,TR,AL> m_backref_str;
    mutable const std::basic_string<CH,TR,AL> * m_pbackref_str;
};

// --------------------------------------------------------------------------
// 
// Class:       match_param
// 
// Description: Struct that contains the state of the matching operation.
//              Passed by reference to all domatch and _match_this routines.
// 
// Methods:     match_param - ctor
//              match_param - ctor
// 
// Members:     ibegin      - start of the string
//              istart      - start of this iteration
//              istop       - end of the string
//              prgbackrefs - pointer to backref array0
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI >
struct match_param
{
    CI ibegin;
    CI istart;
    CI istop;
    std::vector< backref_tag< CI > > * prgbackrefs;

    match_param( CI _istart,
                 CI _istop,
                 std::vector< backref_tag< CI > > * _prgbackrefs )
    : ibegin(_istart),
      istart(_istart),
      istop(_istop),
      prgbackrefs(_prgbackrefs)
    {
    }
    match_param( CI _ibegin,
                 CI _istart,
                 CI _istop,
                 std::vector< backref_tag< CI > > * _prgbackrefs )
    : ibegin(_ibegin),
      istart(_istart),
      istop(_istop),
      prgbackrefs(_prgbackrefs)
    {
    }
};

// --------------------------------------------------------------------------
// 
// Class:       subst_node
// 
// Description: Substitution strings are parsed into an array of these
//              structures in order to speed up subst operations.
// 
// Members:     stype         - type of this struct
//              subst_string  - do a string substitution
//              subst_backref - do a bacref substitution
//              op            - execute an operation
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
struct subst_node
{
    enum subst_type { SUBST_STRING, SUBST_BACKREF, SUBST_OP };
    enum         { PREMATCH = -1, POSTMATCH = -2 };
    enum op_type { UPPER_ON   = SUBST_UPPER_ON,
                   UPPER_NEXT = SUBST_UPPER_NEXT, 
                   LOWER_ON   = SUBST_LOWER_ON, 
                   LOWER_NEXT = SUBST_LOWER_NEXT, 
                   ALL_OFF    = SUBST_ALL_OFF };
    subst_type stype;
    union
    {
        struct
        {
            size_t rstart;
            size_t rlength;
        } subst_string;
        size_t  subst_backref;
        op_type op;
    };
};

// --------------------------------------------------------------------------
// 
// Class:       basic_rpattern_base
// 
// Description: 
// 
// Methods:     basic_rpattern_base     - ctor
//              flags                   - get the state of the flags
//              uses_backrefs           - true if the backrefs are referenced
//              get_first_subexpression - return ptr to first sub_expr struct
//              get_width               - get min/max nbr chars this pattern can match
//              loops                   - if false, we only need to try to match at 1st position
//              cgroups                 - number of visible groups
//              _cgroups_total          - total number of groups, including hidden (?:) groups
//              get_pat                 - get string representing the pattern
//              get_subst               - get string representing the substitution string
//              get_subst_list          - get the list of subst nodes
//              _normalize_string       - perform character escaping
//              _reset                  - reinitialize the pattern
// 
// Members:     m_fuses_backrefs        - 
//              m_floop                 - 
//              m_cgroups               - 
//              m_cgroups_visible       - 
//              m_flags                 - 
//              m_nwidth                - 
//              m_pat                   - 
//              m_subst                 - 
//              m_subst_list            - 
//              m_pfirst                - 
// 
// Typedefs:    char_type               - 
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI >
class basic_rpattern_base
{
public:
    typedef std::iterator_traits<CI>::value_type char_type;

    basic_rpattern_base( unsigned flags = 0, 
                         const std::basic_string<char_type> & pat   = std::basic_string<char_type>(),
                         const std::basic_string<char_type> & subst = std::basic_string<char_type>() ) throw()
        : m_fuses_backrefs( false ),
          m_floop( true ),
          m_cgroups( 0 ),
          m_cgroups_visible( 0 ),
          m_flags( flags ),
          m_nwidth( uninit_width ),
          m_pat( pat ),
          m_subst( subst ),
          m_pfirst( NULL )
    {
    }

    unsigned flags() const throw() 
    { 
        return m_flags; 
    }

    bool uses_backrefs() const throw()
    {
        return m_fuses_backrefs;
    }

    const sub_expr<CI> * get_first_subexpression() const throw()
    {
        return m_pfirst.get();
    }

    width_type get_width() const throw()
    {
        return m_nwidth;
    }

    bool loops() const throw()
    {
        return m_floop;
    }

    size_t cgroups() const throw() 
    { 
        return m_cgroups_visible; 
    }
    
    size_t _cgroups_total() const throw() 
    { 
        return m_cgroups; 
    }

    const std::basic_string<char_type> & get_pat() const throw()
    {
        return m_pat;
    }

    const std::basic_string<char_type> & get_subst() const throw()
    {
        return m_subst;
    }

    const std::list<subst_node> & get_subst_list() const throw()
    {
        return m_subst_list;
    }

protected:
    
    void     _normalize_string( std::basic_string<char_type> & str );

    void     _reset() throw()
    {
        m_fuses_backrefs = false;
        m_flags          = 0;
    }

    bool        m_fuses_backrefs;  // true if the substitution uses backrefs
    bool        m_floop;           // false if m_pfirst->domatch only needs to be called once
    size_t      m_cgroups;         // number of groups (always at least one)
    size_t      m_cgroups_visible; // number of visible groups
    unsigned    m_flags;           // flags used to customize search/replace
    width_type  m_nwidth;          // width of the pattern

    std::basic_string<char_type>  m_pat;   // contains the unparsed pattern
    std::basic_string<char_type>  m_subst; // contains the unparsed substitution

    std::list<subst_node>         m_subst_list; // used to speed up substitution
    auto_sub_ptr<sub_expr<CI> >   m_pfirst;     // first subexpression in pattern
};

// --------------------------------------------------------------------------
// 
// Class:       basic_rpattern
// 
// Description: 
// 
// Methods:     basic_rpattern             - ctor
//              basic_rpattern             - 
//              basic_rpattern             - 
//              init                       - for (re)initializing a pattern
//              init                       - 
//              set_substitution           - set the substitution string
//              set_flags                  - set the flags
//              register_intrinsic_charset - bind an escape sequence to a user-def'd charset
//              purge_intrinsic_charsets   - delete all user-def'd charsets
//              _get_next_group_nbr        - return a monotomically increasing id
//              _find_next_group           - parse the next group of the pattern
//              _find_next                 - parse the next sub_expr of the pattern
//              _find_atom                 - parse the next atom of the pattern
//              _quantify                  - quantify the sub_expr
//              _common_init               - perform some common initialization tasks
//              _parse_subst               - parse the substitution string
//              _add_subst_backref         - add a backref node to the subst list
//              _reset                     - reinitialize the pattern
// 
// Members:     s_charset_map              - for maintaining user-defined charsets
//              m_invisible_groups         - list of hidden groups to be numbered last
// 
// Typedefs:    syntax_type                - 
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI, typename SY = perl_syntax<std::iterator_traits<CI>::value_type> >
class basic_rpattern : public basic_rpattern_base<CI>
{
public:

    friend class match_charset<CI>;

    typedef SY syntax_type;

    basic_rpattern() throw();

    basic_rpattern( const std::basic_string<char_type> & pat, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);
    
    basic_rpattern( const std::basic_string<char_type> & pat, const std::basic_string<char_type> & subst, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);

    void init( const std::basic_string<char_type> & pat, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);

    void init( const std::basic_string<char_type> & pat, const std::basic_string<char_type> & subst, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);

    void set_substitution( const std::basic_string<char_type> & subst ) throw(bad_regexpr,std::bad_alloc);
    
    void set_flags( unsigned flags ) throw(bad_regexpr,std::bad_alloc);
    
    class charset_map
    {
        struct charsets
        {
            sub_expr<CI>                 * rgpcharsets[2];
            std::basic_string<char_type>   str_charset;

            charsets() throw()
            {
                memset( rgpcharsets, 0, sizeof( rgpcharsets ) ); 
            }
            ~charsets() throw()
            {
                clean();
            }
            void clean() throw()
            {
                for( int i=0; i < (sizeof(rgpcharsets)/sizeof(*rgpcharsets)); ++i )
                {
                    delete_sub_expr( rgpcharsets[i] );
                    rgpcharsets[i] = NULL;
                }
            }
            match_charset<CI> * get_charset( unsigned flags ) throw(bad_regexpr,std::bad_alloc)
            {
                push_new_handler pnh( &my_new_handler );
                // Since these charsets are only used while creating other charsets,
                // all flags besides NOCASE can safely be ignored here.
                bool index = ( NOCASE == ( NOCASE & flags ) );
                if( NULL == rgpcharsets[ index ] )
                {
                    std::basic_string<char_type>::iterator istart = str_charset.begin();
                    rgpcharsets[ index ] = create_charset_helper<CI,SY>::create_charset_aux( str_charset, ++istart, flags );
                }
                return (match_charset<CI>*) rgpcharsets[ index ];
            }
        };

        typedef std::map<char_type,charsets> map_type;
        std::auto_ptr<map_type> m_pmap;

    public:

        void put( char_type ch, const std::basic_string<char_type> & str ) throw(bad_regexpr,std::bad_alloc)
        {
            // These characters cannot be bound to a user-defined intrinsic character set
            static const char_type rgIllegal[] = 
            {
                '0','1','2','3','4','5','6','7','8','9','A','Z','z','Q',
                'b','B','d','D','f','n','r','s','S','t','v','w','W','E'
            };

            // So operator new throws bad_alloc on failure.
            push_new_handler pnh( &my_new_handler );

            if( std::char_traits<char_type>::find( rgIllegal, ARRAYSIZE( rgIllegal ), ch ) )
                throw bad_regexpr( "illegal character specified for intrinsic character set." );

            if( NULL == m_pmap.get() )
                m_pmap = std::auto_ptr<map_type>( new map_type );

            // creates an empty entry if one does not already exist
            charsets & chrsts = (*m_pmap)[ch];
            chrsts.clean();
            chrsts.str_charset = str;

            // Try compiling the character set once to make sure it is properly formed:
            (void) chrsts.get_charset( 0 );
        }

        match_charset<CI> * get( char_type ch, unsigned flags ) throw()
        {
            match_charset<CI> * pRet = NULL;
            if( NULL != m_pmap.get() )
            {
                try
                {
                    push_new_handler pnh( &my_new_handler );
                    map_type::iterator iter = m_pmap->find( ch );
                    if( iter != m_pmap->end() )
                        pRet = iter->second.get_charset( flags );
                }
                catch(...) {}
            }

            return pRet;
        }

        void purge() throw()
        {
            if( NULL != m_pmap.get() )
                delete m_pmap.release();
        }
    };

    static void register_intrinsic_charset( 
        char_type ch, const std::basic_string<char_type> & str ) throw(bad_regexpr,std::bad_alloc)
    {
        s_charset_map.put( ch, str );
    }

    static void purge_intrinsic_charsets() throw()
    {
        s_charset_map.purge();
    }

protected:
    
    static charset_map s_charset_map;

    size_t _get_next_group_nbr() 
    { 
        return m_cgroups++; 
    }

    match_group<CI> * _find_next_group( std::basic_string<char_type>::iterator & ipat, 
                                        unsigned & flags,
                                        std::vector<match_group<CI>*> & rggroups );
    
    bool _find_next( std::basic_string<char_type>::iterator & ipat,
                     match_group<CI> * pgroup, unsigned & flags,
                     std::vector<match_group<CI>*> & rggroups );
    
    void _find_atom( std::basic_string<char_type>::iterator & ipat,
                     match_group<CI> * pgroup, unsigned flags );
    
    void _quantify( auto_sub_ptr<sub_expr<CI> > & pnew,
                    match_group<CI> * pnew_group,
                    std::basic_string<char_type>::iterator & ipat );

    void _common_init( unsigned flags );
    
    void _parse_subst();
    
    void _add_subst_backref( subst_node & snode, size_t nbackref, size_t rstart );

    void _reset() throw();

    std::list<match_group<CI>*>   m_invisible_groups; // groups w/o backrefs

};

template< typename CH, typename TR, typename AL >
void process_escapes( std::basic_string<CH,TR,AL> & str )
{
    size_t i = 0;

    while( basic_string<CH,TR,AL>::npos != ( i = str.find( CH('\\'), i ) ) )
    {
        if( str.size() - 1 == i )
            return;

        switch( str[i+1] )
        {
        case CH('f'):
            str.replace( i, 2, 1, CH('\f') );
            break;
        case CH('n'):
            str.replace( i, 2, 1, CH('\n') );
            break;
        case CH('r'):
            str.replace( i, 2, 1, CH('\r') );
            break;
        case CH('t'):
            str.replace( i, 2, 1, CH('\t') );
            break;
        case CH('v'):
            str.replace( i, 2, 1, CH('\v') );
            break;
        case CH('\\'):
            str.replace( i, 2, 1, CH('\\') );
            break;
        default:
            ++i;
            break;
        }
        ++i;
        if( str.size() <= i )
            return;
    }
}

inline std::ostream & operator<<( std::ostream & sout, 
                                  const basic_regexpr<char>::backref_type & br )
{
    for( std::string::const_iterator ithis = br.first; ithis != br.second; ++ithis )
        sout.put( *ithis );
    return sout;
}

inline std::wostream & operator<<( std::wostream & sout, 
                                   const basic_regexpr<wchar_t>::backref_type & br )
{
    for( std::wstring::const_iterator ithis = br.first; ithis != br.second; ++ithis )
        sout.put( *ithis > UCHAR_MAX ? L'?' : *ithis );
    return sout;
}

typedef basic_regexpr<TCHAR>     regexpr;
typedef std::basic_string<TCHAR> tstring;

typedef basic_rpattern<const TCHAR *,perl_syntax<TCHAR> >  perl_rpattern_c;
typedef basic_rpattern<const TCHAR *,posix_syntax<TCHAR> > posix_rpattern_c;
typedef basic_rpattern<tstring::const_iterator,perl_syntax<TCHAR> >  perl_rpattern;
typedef basic_rpattern<tstring::const_iterator,posix_syntax<TCHAR> > posix_rpattern;

typedef perl_rpattern            rpattern;   // matches against std::string
typedef perl_rpattern_c          rpattern_c; // matches against null-terminated, c-style strings

#ifdef _MT

//
// Define some classes and macros for creating function-local 
// static const rpatterns in a thread-safe way
//

template< typename PAT >
class rpattern_destroyer
{
    const bool & m_fConstructed;
    const PAT  & m_refPat;
public:
    rpattern_destroyer( const bool & fConstructed, const PAT & refPat )
        : m_fConstructed( fConstructed ), m_refPat( refPat )
    {
    }
    ~rpattern_destroyer()
    {
        if( m_fConstructed )
            _Destroy( & m_refPat );
    }
};

class CRegExCritSect : private CRITICAL_SECTION
{
public:
    CRegExCritSect()  { InitializeCriticalSection(this); }
    ~CRegExCritSect() { DeleteCriticalSection(this); }
    void Enter()      { EnterCriticalSection(this); }
    void Leave()      { LeaveCriticalSection(this); }
};

extern CRegExCritSect g_objRegExCritSect;

class CRegExLock
{
public:
    CRegExLock()  { g_objRegExCritSect.Enter(); }
    ~CRegExLock() { g_objRegExCritSect.Leave(); }
};

#define STATIC_RPATTERN_EX( type, var, params ) \
    static unsigned char s_rgb_##var[ sizeof type ]; \
    static bool s_f_##var = false; \
    static const type & var = *reinterpret_cast<type*>( s_rgb_##var ); \
    static const regex::rpattern_destroyer<type> s_des_##var( s_f_##var, var ); \
    if( ! s_f_##var ) \
    { \
        regex::CRegExLock objLock; \
        if( ! s_f_##var ) \
        { \
            new( s_rgb_##var ) type params; \
            s_f_##var = true; \
        } \
    }

#else

#define STATIC_RPATTERN_EX( type, var, params ) \
    static const type var params;

#endif

#define STATIC_RPATTERN( var, params ) \
    STATIC_RPATTERN_EX( regex::rpattern, var, params )

} // namespace regex

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\regexpr.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       basic_regexpr.cxx
//
//  Contents:   
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    1-11-1999   ericne   Created
//
//----------------------------------------------------------------------------

// unlimited inline expansion (compile with /Ob1 or /Ob2)
#pragma inline_depth(255)

// warning C4355: 'this' : used in base member initializer list
// warning C4511: copy constructor could not be generated
// warning C4512: assignment operator could not be generated
// warning C4660: template-class specialization 'foo<bar>' is already instantiated
// warning C4706: assignment within conditional expression
// warning C4786: identifier was truncated to '255' characters in the debug information
// warning C4800: 'int' : forcing value to bool 'true' or 'false' (performance warning)
#pragma warning( disable : 4355 4511 4512 4660 4706 4786 4800 )

#include <assert.h>
#include <malloc.h> // for _alloca	
#include <algorithm>
#include <minmax.h>
#include "regexpr.h"

using namespace std;

namespace regex 
{

#ifdef _MT
// Global critical section used to synchronize the creation of static const patterns
CRegExCritSect g_objRegExCritSect;
#endif

// For use while doing uppercase/lowercase conversions:
// For use while doing uppercase/lowercase conversions:
inline  char   to_upper(  char   ch ) { return ( char  )toupper(ch); }
inline  char   to_lower(  char   ch ) { return ( char  )tolower(ch); }
inline wchar_t to_upper( wchar_t ch ) { return (wchar_t)towupper(ch); }
inline wchar_t to_lower( wchar_t ch ) { return (wchar_t)towlower(ch); }
template< typename II, typename CI > 
void to_upper( II ibegin, CI iend )
{
    for( ; (CI)ibegin != iend; ++ibegin )
        *ibegin = to_upper( *ibegin );
}
template< typename II, typename CI > 
void to_lower( II ibegin, CI iend )
{
    for( ; (CI)ibegin != iend; ++ibegin )
        *ibegin = to_lower( *ibegin );
}

template< typename II, typename CI >
unsigned parse_int( II & istr, CI iend, const unsigned m_max = unsigned(-1) )
{
    unsigned retval = 0;
    while( (CI)istr != iend && '0' <= *istr && '9' >= *istr && m_max > retval )
    {
        retval = retval * 10 + ( (unsigned)*istr++ - (unsigned)'0' );
    }
    if( m_max < retval )
    {
        retval /= 10;
        --istr;
    }
    return retval;
}

// This class is used to speed up character set matching by providing
// a bitset that spans the ASCII range. std::bitset is not used because
// the range-checking slows it down.
// Note: The division and modulus operations are optimized by the compiler
// into bit-shift operations.
class ascii_bitvector
{
    typedef unsigned int elem_type;

    enum { CBELEM = 8 * sizeof elem_type,     // count of bytes per element
           CELEMS = (UCHAR_MAX+1) / CBELEM }; // number of element in array
    elem_type m_rg[ CELEMS ];

    // Used to inline operations like: bv1 |= ~bv2; without creating temp bit vectors.
    struct not_ascii_bitvector
    {
        const ascii_bitvector & m_ref;
        not_ascii_bitvector( const ascii_bitvector & ref ) throw()
            : m_ref(ref) {}
    };
public:
    ascii_bitvector() throw()
        { memset( m_rg, 0, CELEMS * sizeof elem_type ); }
    
    inline void set( unsigned char ch ) throw()
        { m_rg[ ( ch / CBELEM ) ] |= ( (elem_type)1U << ( ch % CBELEM ) ); }
    
    inline bool operator[]( unsigned char ch ) const throw()
        { return 0 != ( m_rg[ ( ch / CBELEM ) ] & ( (elem_type)1U << ( ch % CBELEM ) ) ); }
    
    inline not_ascii_bitvector operator~() const throw()
        { return not_ascii_bitvector(*this); }
    
    inline ascii_bitvector & operator|=( const ascii_bitvector & that ) throw()
        { for( int i=0; i<CELEMS; ++i )
              m_rg[i] |= that.m_rg[i];
          return *this; }
    
    inline ascii_bitvector & operator|=( const not_ascii_bitvector & that ) throw()
        { for( int i=0; i<CELEMS; ++i )
              m_rg[i] |= ~that.m_ref.m_rg[i];
          return *this; }
};

const ascii_bitvector & get_digit_vector(void)
{
    // 0-9
    class digit_vector : public ascii_bitvector
    {
    public:
        digit_vector()
        {
            unsigned char ich;
            for( ich ='0'; ich <= '9'; ++ich )
                set(ich);
        }
    };

    static const digit_vector s_digit_vector;
    return s_digit_vector;
}

const ascii_bitvector & get_word_vector(void)
{
    // a-zA-Z_0-9
    class word_vector : public ascii_bitvector
    {
    public:
        word_vector()
        {
            unsigned char ich;
            for( ich = 'a'; ich <= 'z'; ++ich )
                set(ich);
            for( ich = 'A'; ich <= 'Z'; ++ich )
                set(ich);
            for( ich = '0'; ich <= '9'; ++ich )
                set(ich);
            set('_');
        }
    };

    static const word_vector s_word_vector;
    return s_word_vector;
}

const ascii_bitvector & get_space_vector(void)
{
    // " \t\r\n\f"
    class space_vector : public ascii_bitvector
    {
    public:
        space_vector()
        {
            set(' ');
            set('\t');
            set('\r');
            set('\n');
            set('\f');
        }
    };

    static const space_vector s_space_vector;
    return s_space_vector;
}

//
// Operator implementations
//

// Base type used so that all derived operators share typedefs.
template< typename CI >
struct op_t : public binary_function<match_param<CI>,CI,bool>
{
    typedef CI const_iterator;
    typedef typename iterator_traits<CI>::value_type char_type;
};

// Evaluates the beginning-of-string condition
template< typename CI >
struct bos_t : public op_t<CI>
{
    inline bool operator()( const match_param<CI> & param, CI iter ) const
    {
        return param.ibegin == iter;
    }
};

// Find the beginning of a line, either beginning of a string, or the character
// immediately following a newline
template< typename CI >
struct bol_t : public bos_t<CI>
{
    inline bool operator()( const match_param<CI> & param, CI iter ) const
    {
        return bos_t<CI>::operator()(param,iter) || char_type('\n') == *--iter;
    }
};

// Evaluates end-of-string condition for string's
template< typename CI >
struct eos_t : public op_t<CI>
{
    inline bool operator()( const match_param<CI> & param, CI iter ) const
    {
        return param.istop == iter;
    }
};

// Evaluates end-of-string condidition for C-style string's when the length is unknown by
// looking for the null-terminator.
template< typename CI >
struct eocs_t : public op_t<CI>
{
    inline bool operator()( const match_param<CI> &, CI iter ) const
    {
        return char_type('\0') == *iter;
    }
};

// Evaluates end-of-line conditions, either the end of the string, or a
// return or newline character.
template< typename EOS >
struct eol_t_t : public EOS
{
    typedef typename EOS::const_iterator CI;
    typedef typename EOS::char_type char_type;
    inline bool operator()( const match_param<CI> & param, CI iter ) const
    {
        return EOS::operator()(param,iter) || char_type('\n') == *iter || char_type('\r') == *iter;
    }
};

template< typename CI > struct eol_t  : public eol_t_t<eos_t<CI> >  {};
template< typename CI > struct eocl_t : public eol_t_t<eocs_t<CI> > {};

// Evaluates perl's end-of-string conditions, either the end of the string, or a
// newline character followed by end of string. (Only used by $ and /Z assertions)
template< typename EOS >
struct peos_t_t : public EOS
{
    typedef typename EOS::const_iterator CI;
    typedef typename EOS::char_type char_type;
    inline bool operator()( const match_param<CI> & param, CI iter ) const
    {
        return EOS::operator()(param,iter) || ( ( char_type('\n') == *iter ) && EOS::operator()(param,++iter) );
    }
};

template< typename CI > struct peos_t  : public peos_t_t<eos_t<CI> >  {};
template< typename CI > struct peocs_t : public peos_t_t<eocs_t<CI> > {};

// compare two characters, case-sensitive
template< typename CH >
struct ch_neq_t : public binary_function<CH, CH, bool>
{
    typedef CH char_type;
    inline bool operator()( register CH ch1, register CH ch2 ) const
    {
        return ch1 != ch2;
    }
};

// Compare two characters, disregarding case
template< typename CH >
struct ch_neq_nocase_t : public binary_function<CH, CH, bool>
{
    typedef CH char_type;
    inline bool operator()( register CH ch1, register CH ch2 ) const
    {
        return to_upper(ch1) != to_upper(ch2);
    }
};

//
// Helper functions for match and substitute
//

template< typename CI >
size_t string_length( CI iter )
{
    size_t n = 0;
    while( 0 != *iter++ )
        ++n;
    return n;
}

template< typename CI >
backref_tag<CI> _do_match( const basic_rpattern_base<CI> & pat, match_param<CI> & param ) throw()
{
    typedef typename iterator_traits<CI>::value_type char_type;
    
    bool       floop  = pat.loops();
    unsigned   flags  = pat.flags();
    width_type nwidth = pat.get_width();

    const sub_expr<CI> * pfirst = pat.get_first_subexpression();

    try
    {
        vector<backref_tag<CI> > rgbackrefs; // dummy backref vector

        if( NULL == param.prgbackrefs )
            param.prgbackrefs = & rgbackrefs;

        param.prgbackrefs->resize( pat._cgroups_total() ); 
        fill( param.prgbackrefs->begin(), param.prgbackrefs->end(), backref_tag<CI>() );

        // If a pattern is optimized for CSTRINGS, it can save a call
        // to calculate the length of the string.
        if( CI(0) == param.istop && ( ( RIGHTMOST & flags ) || ( 0 == ( CSTRINGS & flags ) ) ) )
            param.istop = param.istart + string_length( param.istart );

        if( CI(0) != param.istop )
        {
            // If the minimum width of the pattern exceeds the width of the
            // string, a succesful match is impossible
            if( nwidth.m_min <= (size_t)distance( param.istart, param.istop ) )
            {
                CI local_istop = param.istop;
                advance( local_istop, -int( nwidth.m_min ) );

                if( RIGHTMOST & flags )
                {
                    // begin trying to match after the last character.
                    // Continue to the beginning
                    for( CI icur = local_istop; icur >= param.istart; --icur )
                        if( pfirst->domatch( param, icur ) ) 
                            break; // m_floop not used for rightmost matches
                }
                else
                {
                    // begin trying to match before the first character.
                    // Continue to the end
                    for( CI icur = param.istart; icur <= local_istop; ++icur )
                        if( pfirst->domatch( param, icur ) || ! floop )
                            break;
                }
            }
        }
        else
        {
            // begin trying to match before the first character.
            // Continue to the end
            for( CI icur = param.istart; ; ++icur )
            {
                if( pfirst->domatch( param, icur ) || ! floop )
                    break;
                if( char_type('\0') == *icur )
                    break;
            }
        }
    }
    catch(...) // bad alloc, stack overflow?
    {
        fill( param.prgbackrefs->begin(), param.prgbackrefs->end(), backref_tag<CI>() );
    }

    // Shrink the backref vector to chop off information about the "invisible" groups
    param.prgbackrefs->resize( pat.cgroups() );

    return (*param.prgbackrefs)[0];
}

template< typename CI, typename CH, typename TR, typename AL >
size_t _do_subst( basic_regexpr<CH,TR,AL> & str, const basic_rpattern_base<CI> & pat, size_t strpos, size_t strlen ) throw(bad_alloc)
{
    typedef iterator_traits<CI>::value_type char_type;
    typedef list<subst_node>::const_iterator LCI;
    enum { UPPER = -1, NIL, LOWER } next = NIL, rest = NIL;
    bool first = true;
    size_t old_strpos = strpos;
    const list<subst_node> & subst_list = pat.get_subst_list();
    basic_string<CH,TR,AL>::iterator itstrlen = str.begin();
    advance( itstrlen, strpos + strlen );
    const basic_string<char_type> & subst = pat.get_subst();
    push_new_handler pnh( &my_new_handler );
    
    for( LCI isubst = subst_list.begin(); isubst != subst_list.end(); ++isubst )
    {
        size_t sublen;
        basic_string<CH,TR,AL>::const_iterator  itsubpos1; // iter into str
        basic_string<CH,TR,AL>::const_iterator  itsublen1;
        basic_string<char_type>::const_iterator itsubpos2; // iter into subst string
        basic_string<char_type>::const_iterator itsublen2;
        basic_string<CH,TR,AL>::iterator itstrpos = str.begin();
        advance( itstrpos, strpos );

        switch( isubst->stype )
        {
            case subst_node::SUBST_STRING:
                itsubpos2 = subst.begin();
                advance( itsubpos2, isubst->subst_string.rstart );
                itsublen2 = itsubpos2;
                advance( itsublen2, isubst->subst_string.rlength );

                first ? str.replace( itstrpos, itstrlen, itsubpos2, itsublen2 ) : 
                        str.insert( itstrpos, itsubpos2, itsublen2 );
                sublen = distance( itsubpos2, itsublen2 );
                break;

            case subst_node::SUBST_BACKREF:
                switch( isubst->subst_backref )
                {
                case subst_node::PREMATCH:
                    itsubpos1 = str.backref_str().begin();
                    itsublen1 = itsubpos1;
                    advance( itsublen1, sublen = str.rstart() );
                    break;
                case subst_node::POSTMATCH:
                    itsubpos1 = str.backref_str().begin();
                    advance( itsubpos1, str.rstart() + str.rlength() );
                    itsublen1 = str.backref_str().end();
                    break;
                default:
                    itsubpos1 = str.backref_str().begin();
                    advance( itsubpos1, str.rstart( isubst->subst_backref ) );
                    itsublen1 = itsubpos1;
                    advance( itsublen1, str.rlength( isubst->subst_backref ) );
                    break;
                }

                first ? str.replace( itstrpos, itstrlen, itsubpos1, itsublen1 ) : 
                        str.insert( itstrpos, itsubpos1, itsublen1 );
                sublen = distance( itsubpos1, itsublen1 );
                break;

            case subst_node::SUBST_OP:
                switch( isubst->op )
                {
                case subst_node::UPPER_ON:
                    rest = UPPER;
                    break;
                case subst_node::UPPER_NEXT:
                    next = UPPER;
                    break;
                case subst_node::LOWER_ON:
                    rest = LOWER;
                    break;
                case subst_node::LOWER_NEXT:
                    next = LOWER;
                    break;
                case subst_node::ALL_OFF:
                    rest = NIL;
                    break;
                default:
                    __assume(0);
                }
                continue; // jump to the next item in the list

            default:
                __assume(0);
        }

        first = false;

        // Are we upper- or lower-casing this string?
        if( rest )
        {
            basic_string<CH,TR,AL>::iterator istart = str.begin();
            advance( istart, strpos );
            basic_string<CH,TR,AL>::const_iterator istop = istart;
            advance( istop, sublen );
            switch( rest )
            {
            case UPPER:
                to_upper( istart, istop );
                break;
            case LOWER:
                to_lower( istart, istop );
                break;
            default:
                __assume(0);
            }
        }

        // Are we upper- or lower-casing the next character?
        if( next )
        {
            switch( next )
            {
            case UPPER:
                str[strpos] = to_upper(str[strpos]);
                break;
            case LOWER:
                str[strpos] = to_lower(str[strpos]);
                break;
            default:
                __assume(0);
            }
            next = NIL;
        }

        strpos += sublen;
    }

    // If *first* is still true, then we never called str.replace, and the substitution
    // string is empty. Erase the part of the string that the pattern matched.
    if( first )
        str.erase( strpos, strlen );

    // return length of the substitution
    return strpos - old_strpos;
}

//
// Implementation of basic_regexpr
//

template< typename CH, typename TR, typename AL >
size_t basic_regexpr<CH,TR,AL>::substitute( 
    const basic_rpattern_base<basic_regexpr<CH,TR,AL>::const_iterator> & pat, 
    size_type pos, 
    size_type len ) throw(bad_alloc)
{
    if( pat.flags() & CSTRINGS )
    {
        assert( ! "You can't use a pattern optimized for CSTRINGS with regexpr::substitute" );
        return 0;
    }

    backref_vector rgbackrefs; // dummy backref vector
    backref_vector * prgbackrefs = & rgbackrefs;
    const bool fsave_backrefs = ( pat.uses_backrefs() || !( pat.flags() & NOBACKREFS ) );

    if( fsave_backrefs )
    {
        prgbackrefs = & m_rgbackrefs;
        m_pbackref_str = & ( m_backref_str = *this );
    }
    else
    {
        m_backref_str.erase();
        m_pbackref_str = this;
        m_rgbackrefs.resize( 0 );
    }

    backref_type br;
    size_t csubst = 0;
    long stop_offset = ( len == npos ? 
                         m_pbackref_str->size() : 
                         min( pos + len, m_pbackref_str->size() ) );

    match_param<const_iterator> param( m_pbackref_str->begin(),
                                       m_pbackref_str->begin(),
                                       prgbackrefs );
    advance( param.istart, pos );
    advance( param.istop, stop_offset );
    param.ibegin = param.istart;

    if( GLOBAL & pat.flags() )
    {
        const bool fAll   = ( ALLBACKREFS   == ( ALLBACKREFS   & pat.flags() ) );
        const bool fFirst = ( FIRSTBACKREFS == ( FIRSTBACKREFS & pat.flags() ) );
        backref_vector rgtempbackrefs; // temporary vector used if fsave_backrefs

        long pos_offset = 0; // keep track of how much the backref_str and
                             // the current string are out of sync

        while( br = _do_match( pat, param ) )
        {
            ++csubst;
            size_type match_length = distance( br.first, br.second );
            pos = distance( m_pbackref_str->begin(), br.first );
            size_type subst_length = _do_subst( *this, pat, pos + pos_offset, match_length );

            if( fsave_backrefs )
            {
                pos += match_length;
                pos_offset += ( subst_length - match_length );

                // Handle specially the backref flags
                if( fFirst )
                    rgtempbackrefs.push_back( br );
                else if( fAll )
                    rgtempbackrefs.insert( rgtempbackrefs.end(),
                                           param.prgbackrefs->begin(), 
                                           param.prgbackrefs->end() );
                else
                    rgtempbackrefs.swap( *param.prgbackrefs );
            }
            else
            {
                pos += subst_length;
                stop_offset += ( subst_length - match_length );

                // we're not saving backref information, so we don't
                // need to do any special backref maintenance here
            }
            
            // prevent a pattern that matches 0 characters from matching
            // again at the same point in the string
            if( 0 == match_length )
            {
                if( br.first == param.istop ) // We're at the end, so we're done
                    break;
                ++pos;
            }

            param.istart = m_pbackref_str->begin();
            advance( param.istart, pos ); // ineffecient for bidirectional iterators.

            param.istop = m_pbackref_str->begin();
            advance( param.istop, stop_offset ); // ineffecient for bidirectional iterators.
        }

        // If we did special backref handling, swap the backref vectors
        if( fsave_backrefs && ( !br || fFirst || fAll ) )
            param.prgbackrefs->swap( rgtempbackrefs );
        else if( ! (*param.prgbackrefs)[0] )
            param.prgbackrefs->clear();
    }
    else if( br = _do_match( pat, param ) )
    {
        ++csubst;
        _do_subst( *this, pat,
                   distance( m_pbackref_str->begin(), br.first ),
                   distance( br.first, br.second ) );
    }

    if( NOBACKREFS == ( pat.flags() & NOBACKREFS ) )
        param.prgbackrefs->clear();

    return csubst;
}

//
// Helper functions called from both basic_regexpr matc